{
    "EliSnow": "Other references:\nhttp://mathiasbynens.be/notes/javascript-properties\nhttp://mothereff.in/js-properties (linked from above article)\n. It would make sense to me that json5 sticks with ecmascript 5 grammar. What would be awesome is to see a json6 spec with ecmascript 6 grammar which would include support for multi-line string templates.\n. Other references:\nhttp://mathiasbynens.be/notes/javascript-properties\nhttp://mothereff.in/js-properties (linked from above article)\n. It would make sense to me that json5 sticks with ecmascript 5 grammar. What would be awesome is to see a json6 spec with ecmascript 6 grammar which would include support for multi-line string templates.\n. ",
    "jordanbtucker": "Are there any ideas on how to support Unicode and their escape sequences in identifiers? What are the options, and what are the pros and cons of those options?\nIt seems the biggest hurdle is that there is no standard way to determine what Unicode category a code point belongs to. For example, an identifier can start with $, _, or any character in the five Letter categories or in the Number, Letter category. That's 17196 different characters, all spread across the Unicode code point list.\nHere are some ideas on perhaps how to solve this:\n- Require a dependency that provides support for testing Unicode categories.\n- Bake in support for it yourself. I've already done some prototyping and benchmarking.\n- Consume Unicode escape sequences and forego testing them against appropriate Unicode classes, willfully violating the ES5 spec.\n- Something very obvious I haven't thought of yet.\nI think it's worth discussing the costs and benefits of implementing this support. What do you think?\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.. I move to close this as a won't fix. This is outside the scope of JSON5. Use the reviver argument of JSON5.parse if you want to restore types other than primitives, objects and arrays.\n. mofo syn posted on the JSON5 Google Group:\n\nI wonder if anyone thought about custom data types e.g. ISO8601\njson\n{\"data\": !ISO8601 \"2013-10-07T18:06:03.048Z\"}`\nAbove is how yaml would approach this. Obviously not JSON compatible.\nBelow is how MongelDB approches it:\njson\n{\"data\":{\"$date\":\"2013-10-07T18:06:03.048Z\"}}`\n\nWould be interesting to see if there is a way to define custom datatypes in a way that is consistent with javascript V5.\n\nI think @shish summed it up nicely:\n\nstoring as strings and then attempting to turn all strings into dates would have false positives; storing as non-strings breaks the purity of the format\n\nAlso, YAML's method would violate one of the core values:\n\nJSON5 remains a strict subset of JavaScript.\n\nProbably the best solution would be to allow new Date() or Date.parse() as values. When JSON5 is serialized as JSON, it would output the date string, but when serialized as JSON5, it would output new Date() or Date.parse().\nBTW, new Date() and Date.parse() are equivalent, so it comes down to which one feels better. I think my vote is for new Date() since it's two characters less.\n. Correction, new Date() and Date.parse() are not equivalent, since new Date() returns a Date object and Date.parse() returns a Number. \nnew Date() may cause some confusion as to what type of parameter is accepted since it has four overloads:\njavascript\nnew Date()\nnew Date(value)\nnew Date(dateString)\nnew Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]])\nI think JSON5 should only accept strings as parameters (for readability) so new Date(dateString) would be the only acceptable overload. But we're still left with ambiguity about what date formats are acceptable. I think ISO8601 should be allowed exclusively.\njavascript\nnew Date('2015-10-08T10:29:00.000Z') // acceptable\nnew Date('October 8, 2015 10:29 AM') // unacceptable\nNote that stringify will output all ISO8601 fields, but all fields do not need to be specified when parsing:\njavascript\n// all acceptable\nnew Date('2015')\nnew Date('2015-10')\nnew Date('2015-10-08')\nnew Date('2015-10-08T10:29')\nnew Date('2015-10-08T10:29Z')\nnew Date('2015-10-08T10:29-08:00')\nnew Date('2015-10-08T10:29:30')\nnew Date('2015-10-08T10:29:30Z')\nnew Date('2015-10-08T10:29:30-08:00')\nnew Date('2015-10-08T10:29:30.123')\nnew Date('2015-10-08T10:29:30.123Z')\nnew Date('2015-10-08T10:29:30.123-08:00')\nnew Date('2015-10-08T10:29:30.123456789')       // these last three are acceptable,\nnew Date('2015-10-08T10:29:30.123456789Z')      // but lose resolution in some environments\nnew Date('2015-10-08T10:29:30.123456789-08:00') // like Node.js and browsers\nAny values without a time zone designation would be treated as UTC.\n. I'm in the process of finalizing v1.0.0, so I've taken another look at Date support. I've been testing out an option for parse that will automatically find strings that look like dates and parse them as Date objects. Here's what the API looks like.\njs\nconst result = JSON5.parse(\"{dateTime: '2017-09-23T23:53:40.303Z'}\", {dates: true})\n// `result` is equivalent to { dateTime: new Date('2017-09-23T23:53:40.303Z') }\n\nThe date string must be in ISO format with all fields present and in the UTC time zone. In other words, it must be in the format YYYY-MM-DDTHH:mm:ss.sssZ. This is the same format returned by Date.prototype.toJSON().\nThe second argument of parse can be a reviver function or a new options object. The options object can have a reviver property and a dates property. If dates is truthy, then each string will be tested to see if it conforms to the format described earlier, and if so, converted to a Date object.\nIf a reviver function is also defined, then it will be called after all date strings have been converted to Date objects.\n\nIt has not yet been decided whether this feature will make it into v1.0.0. Please let me know what you think.\nThis is not an extension to the JSON5 document specification. It is only an extension to the API of this library. JSON5 implementations are not required to implement this API.\nYou can try this out by using npm install json5@dates.. See my reply at https://github.com/json5/json5/issues/91#issuecomment-333287297.. \n\nHere's a polyfill\n\n```js\nfunction json5DatesPolyfill() {\n    const JSON5 = require('json5')\nconst origParse = JSON5.parse\n\nJSON5.parse = function parse(text, reviver) {\n    let root = origParse(text)\n\n    if (reviver != null && typeof reviver === 'object') {\n        const dates = reviver.dates\n        reviver = reviver.reviver\n\n        if (dates) {\n            root = internalize({ '': root }, '', dateReviver)\n        }\n    }\n\n    if (typeof reviver === 'function') {\n        return internalize({ '': root }, '', reviver)\n    }\n\n    return root\n}\n\nfunction dateReviver(name, value) {\n    if (\n        typeof value === 'string' &&\n        /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\dZ$/.test(value)\n    ) {\n        return new Date(value)\n    }\n\n    return value\n}\n\nfunction internalize(holder, name, reviver) {\n    const value = holder[name]\n    if (value != null && typeof value === 'object') {\n        for (const key in value) {\n            const replacement = internalize(value, key, reviver)\n            if (replacement === undefined) {\n                delete value[key]\n            } else {\n                value[key] = replacement\n            }\n        }\n    }\n\n    return reviver.call(holder, name, value)\n}\n\n}\n```\n. Closing as JSON5 will not support numeric literals as property names until there is enough demand for it. #55 is now the official issue regarding this.\n. I move to continue disallowing leading commas and empty values. And I apologize for the following novel. There's a TL;DR at the bottom. :)\nOne of the headaches of JSON is that it doesn't allow trailing commas. For instance, you start to write a JSON file, and like any normal JavaScript developer, you add a comma after each value because it makes it easier to copy and paste and move values around.\njson\n{\n  \"end_of_line\": \"lf\",\n  \"indent_style\": \"space\",\n  \"indent_size\": 4,\n}\nOf course, JSON throws SyntaxError: Unexpected token } because of the trailing comma. This has led to hacks like adding commas to the beginning of each value except the first.\njson\n{\n  \"end_of_line\": \"lf\"\n  ,\"indent_style\": \"space\"\n  ,\"indent_size\": 4\n}\nIt gets the job done, but it's ugly IMO, and it creates another problem. If you remove the first value and forget to remove the proceeding comma, you get SyntaxError: Unexpected token ,.\nFast forward to today. You start using JSON5 because trailing commas are awesome and should have been allowed by JSON in the first place. Even better, you don't have to change your current JSON files because JSON5 is completely backward compatible. And that's great because you have a lot of JSON files using the hacky leading comma syntax.\nYou edit one of your old JSON files, removing the first value, and you forget to also remove the proceeding comma because you're involved in several projects, overworked, and having trouble paying attention to detail.\nBut that's okay because JSON5 throws SyntaxError: Unexpected token , when you try to parse it. Because you've seen it so many times with JSON files, you immediately know the issue.\nActually, JSON5 throws SyntaxError: Bad identifier. Remind me to fix that. :)\nTL;DR\nIf JSON5 allowed leading commas and empty values, old JSON files that used to throw would no longer do so, which could introduce silent and/or hard to find bugs.\nAlso, undefined is its own data type, and, repeating for emphasis, JSON5 introduces no new data types over JSON.\nThoughts?\n. I wanted to open this back up for discussion, clarify some things, and see if we want to change this behavior.\nTL;DR\nThis issue was originally a bug because of a change in V8. Instead of fixing the bug, the feature was removed even though the feature didn't really have anything to do with the V8 bug. It was the implementation of the feature that needed a fix.\nSigned numbers vs numeric literals\nSigned numbers, whether decimal or hexadecimal, are not treated as literals when parsed by ES5. They are parsed as two separate tokens: a Punctuator (+ or - in this case) and a NumericLiteral (an unsigned decimal or hexadecimal number).\nThat sequence produces a UnaryExpression using the + or - operators. In either case, the text of the NumericLiteral is converted to a number using ES5's ToNumber operation, and in the case of the - operator, the mathematical value is negated.\nThe discrepancy between signed decimals and signed hexadecimals occurs within the ToNumber(String) operation. It allows signed decimal numbers but prohibits signed hexadecimal numbers, returning NaN instead. Compare the following. (The global Number function uses the ToNumber operation):\n``` js\n\n[  eval('1'),   eval('0x1'),   eval('-1'),   eval('-0x1')]\n[ 1, 1, -1, -1 ]\n[Number('1'), Number('0x1'), Number('-1'), Number('-0x1')]\n[ 1, 1, -1, NaN ]\n```\n\nThe V8 bug\nThe + unary operator with a String argument (i.e. +'1.234') also applies the ToNumber operation, which is what the V8 bug was about. Expressions like +'-0xF' and Number('-0xF') were resulting in -15 instead of NaN as called for in the spec. Note that this is separate from the actual unary expression -0xF; this is the string '-0xF' being converted to a number.\nConclusion\nSigned hexadecimals aren't evil, nor are they disallowed in ES5. They just can't be converted from strings for whatever reason the ES5 authors had. This really has nothing to do with JSON5.\nJSON5 has freed us from the restrictions of JSON so that we can have a lightweight data-interchange format that is even easier for humans to read and write. Why disallow signed hexadecimals just because ES5 doesn't convert them from strings?\n. I'm going to move to close this issue as won't fix. It could be a goal for JSON6 (working title). ;)\n. @sykano I mentioned this in the PR, but I'll say it again here. Thanks for the diagrams. I don't think the code repository is the best place for them though. If you'd like to update the Wiki, that would be great. Thanks.\n. From the json.org website (emphasis mine).\n\nJSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.\n\nSo you see, the purpose of JSON is not just that it is language agnostic and fast to parse, but that it is also easily readable and writable for humans. JSON5 is a bit of a trade-off\u2014far easier for humans to manipulate, only marginally more complex for computers to manipulate. I think the benefits outweigh the cost.\nI think its best feature is how well if follows the Principle of Least Astonishment. Things you can do in JavaScript tend to just work in JSON5.\n. I couldn't find any rationale in ES5 as to why this is allowed. I think it's more of a convenience thing. I can see where it could make your code cleaner, especially if you want to store a hash table using hexadecimal numbers as keys.\njs\n// ELF header\n// Source: http://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_layout\n// { offset : fieldName }\n{ 0x00 : 'EI_MAG0',\n  0x04 : 'EI_CLASS',\n  0x05 : 'EI_DATA',\n  0x06 : 'EI_VERSION',\n  0x07 : 'EI_OSABI',\n  0x08 : 'EI_ABIVERSION',\n  ... }\nBut this brings with it at least two issues that come to mind:\n1. The user must be aware that the keys 1, 1., 1.0, 1.00, 1e0, 1e-0, 1e+0, 1.e0, 1.0e0, 0x1, 0x01, ad infinitum all get stored as '1' in the object, and as such will overwrite each other.\n2. JSON5.stringify must either:\n   - parse keys to detect whether they are identifiers, numbers, or strings and output them appropriately, or\n   - output numeric keys as strings.\n     - In either case, the original representation of the key will be lost unless it conformed to the output of the ToString method as indicated at the bottom of ES5 \u00a711.1.5\n. I'm thinking we should leave this alone unless there happens to be a demand for it. To be honest, the only reason I brought it up is because it's allowed in ES5.\n. I just realized that #10 sort of referenced this issue.\n. I wrote the code for this in the numeric-keys branch of my fork. It wasn't a difficult change.\nI'm not advocating that we implement this, I just wanted to see how much work it would be. Now the code is already written if we want to.. Moved to #1. Thanks.\n. @amb26 I'm in agreement with you that having duplicate keys in a JSON document is bad form. However, the major ECMAScript implementations\u2014V8, SpiderMonkey, and Chakra\u2014all allow duplicate keys. And they should, because according to the official spec, once the parser validates that a JSON document conforms to the JSON syntax, it parses the document as ES5 (almost). Note that RFC 7159 only describes the structure of JSON documents but not the API and implementation requirements.\nAll this considered, one of the core values of JSON5 is being backward compatible with JSON\u2014in document structure, API, and implementation.\nI do see some value in logging a warning when duplicate keys are encountered, especially since JSON5 is meant for handwritten data documents where duplicate keys are more likely to occur.\nI appreciate your opinion and research on this matter and welcome any further comments. And don't be too quick to think that these issues won't be revisited. Just look at some of the earliest issues for this repository and note how many times the community went back and forth on some pretty important features :)\n. The multi-string test cases were failing on Windows due to CRLF line endings.\n. The reason I'm handling \\r as a special case is due to the differences in how operating systems represent new lines.\n- \\n is used by Unix, Linux, and OS X and later.\n- \\r is used by OS 9 and earlier.\n- \\r\\n is used by Windows (note that it is a \\r followed by \\n).\nTherefore, any of the following combinations constitute an escaped new line:\n- \\ followed by \\n\n- \\ followed by \\r not followed by \\n\n- \\ followed by \\r\\n\nThis conforms to the LineContinuation production, which uses the LineTerminatorSequence production.\nThere's no need to add \\r to escapee since it's always handled as a special case.\n. I'm thinking I should create test cases for these before merging. Working on that now.\n. I don't think that will work. Supposed we added \\r to escapee and removed its special case. Then we parse a string like this:\n'line1 \\\\\\r\\n line 2'\nWhen the parser hits the \\ character, it will check for a following u, which won't be there. So it moves on to check for one of the escapees, finding \\r. It appends an empty string to string, and moves on to the next iteration.\nNow ch contains \\n, but it doesn't know that there was a \\ before the \\r that was before this character. so it will hit the check for \\n returning a Bad string error.\nI ran some tests to confirm this too.\n. I think the problem is with the develop branch. .travis.yml lists a Node version of 0.9, but the travis CI VM doesn't have 0.9 installed.\n. Looks like you can trigger a re-run of a Travis CI build if you're logged in.\n. Thanks for the rebase tip.\n. You know, I was thinking the same thing about ES5 whitespace. I was going back and forth between JSON and ES5 whitespace. I don't remember why I chose JSON. Let me do some research and get back to you.\n. Oh, now I remember. It was because ES5 supports whitespace from certain Unicode categories that we can't support yet. So I just went with JSON.\nI'm going to fix this to support as much ES5 whitespace as possible without venturing into Unicode territory.\n. I decided to put my prototype on the Wiki. If you have any issues with that, please let me know. Thanks.\n. I think that might be a good idea, especially since I don't see a way to lock down Wiki pages. I'd like to expand the \"spec\" into a full document at some point.\n. @rlidwka Nice document. Almost the same as the one on the wiki, as far as I can see, with a few differences: line terminators (#70), signed hexadecimals (#36), numeric literals as property names (#55), Unicode escapes in property names (#1), and it's one grammar instead of a lexical and a syntactical.\n. Funny, that's the same thing I did when I started writing a JSON5 parser for another language. I used the ES5 grammar. That's when I started finding a lot of missing features. :)\n. C# / .NET. It's a WIP at this point. I stopped to focus on JSON5 itself before continuing with other implementations.\nThere's a page on the Wiki called In The Wild. I think that's a good starting point to keep that list.\n. We now have an official spec in draft status. The PDF version can be found on the releases page.\nIdeally, discussions regarding the future of JSON5 will be discussed in the json5-spec repo, while discussions regarding the JavaScript reference implementation will still be discussed in this repo.\nI'd like to separate the goal of JSON5 from the different implementations.\nLet me know what you think.\n. @aseemk That sounds good. I've got a partial C# implementation and another one for Go, but I haven't uploaded them yet.\n. I'm thinking json5 for now.\n. @aseemk Awesome. Thanks.\nBTW, did you see this controversial issue about removing support for Infinity and NaN on the json5-spec repo?\n. Added another housekeeping item. Single line comments should break on \\r or \\n.\n. Maybe I don't have this rebase thing down yet. These commits from other branches keep showing up in my current branch.\n. Thanks @aeisenberg. I think I've been doing that, minus the cherry picking. What happens in the case where I want to include new commits from develop after I've already created my branch? For exmaple:\ngit checkout -b cool-feature develop\nDuring testing I realize there's bug that should really be its own branch.\n```\ngit checkout -b bug-fix develop\nwrite code to patch bug\ngit commit -m \"bug squashed\"\ngit push origin bug-fix\ncreate PR and merge into develop\n```\ncool-feature depends on that bug being fixed, so I want to pull the new changes from upstream/develop into my remote.\ngit checkout develop\ngit pull upstream develop\ngit checkout cool-feature\ngit rebase develop\nIs that wrong? When do I cherry pick? Should you just tell me to RTFM so I actually know what I'm doing? :)\n. Thank. I'll try that the next time I create a branch.\nAnyway. What do you think about this merge?\n. I was finally able to fix the PR issues with these commands:\n```\n\ngit reset --hard \ngit rebase -i upstream/\ngit push -f origin \n``\n. Sorry. Still battling it out with Git. Please ignore.\n. I also just noticed that JSON5 is outputtingInfinityasnull`.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. @rlidwka You are correct, and thanks for clarifying. I only included them because they are possible values, not because I expected them to output the sign too.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. @rlidwka You make a good point. It seems that JSON5 cannot be a strict subset of JavaScript and work with all existing JSON content at the same time.\n\nGranted, those Unicode whitespace characters probably aren't common, but it might be a rude awakening for someone who has been using those characters in JSON and then switched to JSON5.\nIn the end, is it more important for JSON5 to be a script subset of JavaScript or to work with all existing JSON5 content?\n. @aseemk I'm not so sure that ES5 should win over JSON in this instance.\nThe JSONP issue can be fixed by JSONP implementations, and since JSON is an official standard and JSONP is not, the onus is on JSONP implementations to escape \\u2028 and \\u2029 in strings.\nIt may be true that not many people would be using those characters in hand-written JSON5, but what about the cases where existing JSON files are parsed as JSON5? They'll fail if they contain those characters.\nI think it's more important for JSON5 to be backward compatible with JSON in this case. In other words, it's more important that JSON5 can parse JSON than that ES5 can parse JSON5. eval is strongly discouranged, so the only other time JSON5 would be parsed as ES5 is in JSON5P (working title) implementations and when the user copies and pastes JSON5 directly into their JavaScript.\nThis only applies to parsing strings, however. Whether we allow those characters in comments is up for discussion. I'm leaning toward keeping the ES5 standard and rejecting them.\n. What if we parse \\u2028 and \\u2029 (perhaps with a warning) but never output those characters unescaped?\nI had that idea last time I posted, but I discarded it because I didn't like having a parser that doesn't match the spec. But after your comments, I started thinking about the difference between HTML and XML parsers. Does JSON5 need to have draconian error handling like XML, or can we take a page from HTML's tag soup handling book?\nIn this case:\n- \\u2028 and \\u2029 are technically valid in strings in JSON5.\n- JSON5 will parse \\u2028 and \\u2029, and optionally give a warning.\n- JSON5 will escape those characters when stringified.\nIf you have a JSON5 file with those characters, and the contents of that file are in a variable named file, you can call JSON5.stringify(JSON5.parse(file)) and you'll get back valid ES5 that you can inject into scripts.\nAnd you can do the same thing if file is regular JSON, too.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. +1 for @rlidwka's config object approach. The second argument in JSON.stringify can be a function or array. JSON5 could extend this to also be a config object.\n. Fixed in a88fbd2be4bc16c8eee02968a5abe94c4041ddff.. Partially fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58\nStill needs tests.. Fixed in 51d03206a69b8fab3ac2a7a0658f8442bef4133f.. @rlidwka Good catch. This is also the proper way according to Travis CI.\n. And if merged, I'll need to update the grammar again.\n. Good catches, @rlidwka. I forgot that JSON5 did not yet support \\x escapes, and \\0 and \\v were oversights on my part. I've fixed those locally, and I'll write tests and push the changes later.\n\\1 - \\7 are octal escapes, so they're only supported in non-strict modes, but Node, Chrome, and Firefox allow \\8 and \\9, even in strict mode.\nWhat baffles me is that the ES5 spec doesn't appear to address \\8 or \\9. At least, I can't find where it does.\n. And apparently I'm not the only one.\n. Well apparently Node v0.6 doesn't throw on \\x and \\u, which is causing tests to fail. JSON5 (including this patch) works in v0.6, it's just the tests that are failing.\n. My two cents: JSON5 is JSON with some ES5 features. A strict subset of JavaScript doesn't mean a strict subset of strict ES5.* So I don't have a problem with ES5 octal literals. However, I'm not sure about ES6 octals yet. The README is pretty heavy on ES5 as the target.\nI'm also not a fan of the potentially ambiguous 0O000 sytax, but that's just a personal gripe.\n* #59 breaks this anyway. It is a SyntaxError if strict mode code contains an ObjectLiteral with more than one definition of any data property (11.1.5).\n. This is already a supported feature.\n. Ah. No problem. I see you submitted a bug with them too. Thanks.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. Fixed by #101\n. @jasonswearingen, yes. Please join in on the discussion in #113. I'll see about bumping the number ASAP. Thanks.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.. I tried to incorporate some of your commits into #94 and #96, but my implementation was a little too different for it to make sense.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. There's discussion of this in #70\n. I've thought about this, but it isn't really a feature that anyone has been asking for or that seems to be lacking. Without that demand, this probably won't get implemented.\n(Also, who would want to write a parser for a regex expression?)\n. Here's a few examples that would fail if we treated everything between two / as a RegExp:\njs\n/\\/\n/(/\n/)/\n/[/\n/*/\n/+/\n/?/\nWe would also need to parse trailing flags (g, i, m).\nWe could try to eval anything between two / and see if a RegExp comes out, but that would be a blatant security risk.\nAlso, ECMAScript doesn't support full PCRE. Specifically, it doesn't support recursion, look-behind, directives, conditionals, atomic groups, named capture, comments, or embedded code. So, JSON5 cannot represent PCRE without breaking ES5 compatibility. Ultimately, this means that platforms that support PCRE wouldn't be able to serialize PCRE as JSON5.\nThe best way to serialize regular expressions is to convert them to strings.\n. It still seems that there is some desire to implement regular expressions as first class values in JSON5. So, I'm going to elaborate on why I think it's a bad idea.\nParsing\nI've already established that if you just treat everything between two / characters as a regular expression you'd have to use the native platform's regular expression parser to ensure it's valid. Bet let me entertain that idea and see how easy it would be to implement it.\nFirst, you'd need to make sure that at least one character exists between the two /s because // is a comment in JSON5.\njs\n//  <- comment\n/a/ <- RegExp\nNow, what happens if you want to match a / in your regular expression? You need to escape it with a \\ character.\njs\n/a\\/b/    // matches 'a/b'\nOkay, so any occurrences of \\/ should not terminate a regular expression. But what about this regular expression:\njs\n/a\\\\/    // matches 'a\\\\'\nIt has an occurrence of \\/ but the \\ is escaped as \\\\. So we need to check for occurrences of \\\\ and \\/.\nOkay, we're done, right? Well, what about this regular expression?\njs\n/a[b/c]d/    // matches 'abd', 'a/d' and 'acd'\nIt's a valid regular expression with an unescaped / because it's inside an alternation group [\u2026]. So now we need to track when an alternation group begins and ends. Not so difficult, right?\njs\n/a\\[bc]d/    // matches 'a[bc]d'\n/a[b[c]d/    // matches 'abd', 'a[d' and 'acd'\n/a[bc\\]d/    // error: alternation group is never closed\nOkay, so in the first example the [ is escaped, but the ] isn't because it only has special meaning in an alternation group. In the second example, the second [ is not escaped but doesn't start new alternation group. The third example is self-explanatory. So, we need to check for [, ], \\[, and \\], and treat [ and ] differently depending on whether or not we're in a alternation group.\nDoes that cover our bases? I don't know, but for the sake of argument, let's just say it does.\nLet's simplify this into a list of steps:\n1. When parsing a JSON5 value, if the first non-whitespace character is /:\n2. Peek the next character, and if it is /, parse a comment, and do not perform subsequent steps. (Otherwise, assume it's a regular expression.)\n3. Let p = \"\". p will store the regular expression pattern.\n4. Let f = \"\". f will store the regular expression flags.\n5. Let a = false. a will indicate whether we are in an alternation group.\n6. Let c = the next character read from the stream of characters.\n7. If c is / and a is false, skip to step 14.\n8. If c is / and a is true, concatenate c onto p, and return to step 6.\n9. If c is [, set a to true, concatenate c onto p, and return to step 6.\n10. If c is ], set a to false, concatenate c onto p, and return to step 6.\n11. If c is \\, concatenate c and the next character in the stream onto p, and return to step 6.\n12. If the end of the stream has been reached, throw a parsing error.\n13. Concatenate c onto p, and return to step 6.\n14. Let c = the next character read from the stream.\n15. If c matches the IdentifierPart production, concatenate c onto f, and return to step 14.\n16. Try to instantiate a RegExp object with the arguments p and f.\nStep 16 parses the flags according to the ES5 spec. This would allow implementation specific flags to be used (e.g. ES5 doesn't support the s flag, but does support the non-standard y flag).\nBesides the fact that this extremely minimal regular expression parser is still relatively complex, it doesn't actually parse the regular expression. There's no way to validate the regular expression in an implementation agnostic way without writing way more code.\nWe would also need to define what happens if a platform doesn't support regular expressions or can't parse the regular expression given. It wouldn't know until it tried to parse it.\nSo, all JSON5 documents that include regular expressions would have to be late-validated, and there would be no true JSON5 validator.\nImplementation Agnostic vs Implementation Specific\nLet's say we did implement a full regular expression parser according to the ES5 spec. It would no longer be implementation agnostic, and we would expect all implementations of JSON5 to parse JSON5 regular expressions into an ES5 compatible format on its native platform.\nFurther, by creating an implementation restricted parser you're castrating the more powerful regular expression engines supported by other platforms. No more named captures, no more comments, no more look-behind, no more recursion, no more s flag (dot matches new line).\nSolution\nJSON.stringify serializes a RegExp instance as en empty object ({}). You can modify that behavior by executing the following line of code:\njs\nRegExp.prototype.toJSON = function() { return this.toString() }\nThat's all you need to do to write code like:\njs\nvar emailRegex = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/\nconsole.log(JSON.stringify(emailRegex))\n// output: \"/^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$/\"\nAs an added bonus, that same line of code also applies to JSON5.stringify because JSON5 also checks for toJSON().\n. I've re-opened this issue to discuss whether JSON5 should serialize RegExp objects to strings and how it would be implemented.\nI'm not suggesting that we treat RegExps as first class JSON5 values, nor would JSON5 automatically parse a RegExp out of a string. It would work similarly to how Dates work in JSON, where they are serialized into ISO 8601 format but date strings are not automatically parsed as Date objects.\n. I'm in the process of finalizing v1.0.0, so I've taken another look at RegExp support. I've been testing out an option for parse that will automatically find strings that look like regular expressions and parse them as RegExp objects and an option for stringify that will convert RegExp objects to strings.\nHere's what the parse API looks like.\njs\nconst result = JSON5.parse(\"{regex: '/a[b/c]d/i'}\", {regExps: true})\n// `result` is equivalent to { regex: /a[b/c]d/i } and { regex: new RegExp('a[b/c]d', 'i') }\n\nThe regex string must start with a slash and end with a slash, which is optionally followed by regular expression flags.\nThe second argument of parse can be a reviver function or a new options object. The options object can have a reviver property and a regExps property. If regExps is truthy, then each string will be tested to see if it conforms to the format described earlier, and if so, attempted to be converted to a RegExp object. If it cannot be converted, then the string will be returned.\nIf a reviver function is also defined, then it will be called after all regex strings have been converted to RegExp objects.\n\nHere's what the stringify API looks like.\njs\nconst result = JSON5.stringify({regex: /a[b/c]d/i}, {regExps: true})\n// result === \"{regex:'/a[b\\/c]d/i'}\"\n\nThe second argument of stringify can be a replacer function, an array of white listed property names, or a new options object. The options object can have a replacer property, a space property, and a regExps property. If regExps is truthy, then each RegExp object will be converted to a string, otherwise it will converted to an empty object.\nIf a replacer option is defined, then it will be called before all RegExp objects have been converted to strings.\nIf the second argument of stringify is an options object, then all subsequent arguments will be ignored. In other words, space must be specified in the options argument rather than as the third argument of stringify if the second argument is an object.\n\nIt has not yet been decided whether this feature will make it into v1.0.0. Please let me know what you think.\nThis is not an extension to the JSON5 document specification. It is only an extension to the API of this library. JSON5 implementations are not required to implement this API.\nYou can try this out by using npm install json5@regexps.. @aseemk Valid point about having differing implementations, especially since this is the reference implementation. This feature may be better left to another implementation.\nI'm still hesitant about allowing regex literals as I stated in my earlier rant under the heading Implementation Agnostic vs Implementation Specific.\n\nSide Note: Although Date('\u2026') is valid ES5, it returns a string instead of a Date, and Date.parse returns a number, so it would have to be new Date('\u2026') if we wanted to match the ES5 behavior. (i.e. Placing a JSON5 document into an ES5 script should Just Work\u2122.). Funny thing about that rant. I actually used that algorithm to implement this experimental feature.. I think the original wording is just as clear, if not, more so.\nStrings can be split across multiple lines; just prefix each newline with a backslash.\n\nI do think it would be good to replace 'newline' with 'newline character' however.\n. @abhisekp I'm not sure what you mean by \"the word 'prefix' is not correctly written.\"\n. I think most will understand that you prefix the newline character not the beginning of the next line. I'll let someone else weigh in on this before any movement.\n. This is some good work!\nI do see one issue just from looking at the code. It only treats \\n as a new line. In the vast majority of cases, this will suffice, but in the rare case where only \\r is used for new lines, your code will always report errors as appearing on line 1.\nPlease see the ES5 spec on Line Terminators and the JSON5 code that handles new lines in strings.\nAs for cosmetics, can you please convert the prefixed increment operators ++ to postfix and remove the space between them and their variables, e.g. lineNumber++ instead of ++ lineNumber. Thanks.\n. I've thought about this for a while today, and I came to the conclusion that determining what constitutes a new line is not the job of ES5, JSON, or JSON5, but it is a job for Unicode.\nRegardless of what whitespace and new lines are allowed in JSON5, errors should report line numbers based on what the JSON5 document (valid or not) would look like in a text editor.\nWe should use Unicode's Newline Guidelines (Section 5.8) for determining what characters (or sequence of characters) are new lines. Namely \\r\\n, \\r, \\n, \\x85, \\v, \\f, \\u2028, and \\u2029.\nAll that said, I think we should remove the changes to whitespace from this PR and keep that as a separate issue. I've got more to say on that matter anyway.\n. I think I prefer solution ii. We could write a thousand test cases that are invalid JSON5. I think we should focus on passing test cases for features and failing test cases for specific error messages.\n. Fixed by #103\n. :+1: \n. I'm not sure this is the right place to keep this diagram code. Perhaps you can post this on the Wiki?\n. Partially fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.\nCoveralls should be easy to implement since istanbul is already in use.. 51d03206a69b8fab3ac2a7a0658f8442bef4133f has 100% code coverage, but I'm going to skip coveralls for now.. At first I was opposed to this, but I've written plenty of code like 24*60*60*1000 for the number of milliseconds in a day.\nWhat's better?\njs\n{\n  ms: 86400000, // one day\n}\nor\njs\n{\n  ms: 24*60*60*1000, // one day\n}\nThe first example appears like it doesn't require the parser to do any math, but the parser already has to math to parse the number as base 10. The second example is easier to modify if you want to change it to e.g. 12 hours or 3 days.\n. I think @amulware, correct me if I'm wrong, was just using variables to represent numeric literals. For example, you could have:\njs\n{ offset: (10 + 3) * 2 }\nbut not the literal string:\njs\n{ offset: (base + increment) * stride }\nBut it is an interesting concept to declare variables in a JSON5 file. Maybe we should start a new discussion on that.\nAlso, see #91 for a discussion on why regular expressions have not been included in JSON5.\n. I'm glad we're getting some great discussions around this. That's what I was hoping for :smile: \n@aseemk\n\nI'd be okay with adding basic math operators. I would discourage adding **, etc., as those aren't standard ES5 either. (But I do appreciate them in CoffeeScript.)\n\nI totally agree here. Let's keep things ES5 compliant.\n@aseemk\n\nEven with these basic operators, though, it does e.g. make supporting JSON5 in other languages harder. E.g. what is 5 / 0? If we're to be consistent with ES5, it's Infinity. But in most languages, that'd be a runtime error. Or possibly an undefined-ish value.\n\nI'd alter that statement by saying that 5 / 0 is an error in most languages if they're treated as integers. ES5 doesn't have integers (all numbers are IEEE 754 floating point values) so this returns Infinity. If the numbers are treated as floating points, then most languages would return some form of IEEE 754 Infinity. (Python and Go are exceptions, however. Python always throws a ZeroDivisionError. The Go spec says it's implementation specific, but the official Playground throws a division by zero error. There are likely other exceptions, too).\n@piranna\n\nI consider RegExp data, too... ;-) They are the same as function declarations as far as they are not executed, but function declaration would be beyond the line too not only because they are language specific but also could be dangerous if executed (RegExp are not dangerous in that way).\n\nOh no. Now the RegExp discussion is bleeding into this one. :wink: I do see the parallels, though.\n@piranna\n\nInfinity is a valid float value in all languajes, including C/C++\n\nMost languages have a way to check for Infinity, but not all languages have a way of actually representing that value (e.g. a constant that represents Infinity or a function that returns Infinity). PHP 4.0 is an example of this.\n. @piranna \n\nThis operations will not be executed on runtime but when parsed, so there's no problem the implementation wrap the operations on a try-catch block to capture these exceptions and set the value to infinite \"by hand\". Python support both Infinite and NaN, so...\n\nNo one was saying that it can't be done in those languages. @aseemk's point was that more work would need to be done in those languages to support JSON5 with math features. In Python, you can't just parse a / and perform division on the operands. Like you said, you have to check whether the divisor is a zero and return float(\"inf\").\nThe more complex you make a specification, the more work that needs to be done to implement it, and the less it actually gets implemented.\n\nPHP sucks, but not so much... ;-)\n\nI know PHP supports NaN and Infinity at this point in time. I was referring specifically to PHP 4.0. And regardless of whether PHP sucks, it's still an extremely popular platform for web applications.\n. @piranna \n\nLol :-P Yes, there are parallels because it depends on the concepts of \"what is data\" and \"what is executable code\". After parsing we would get respectively a number or a RegExp object that both are not executables by themselves (a RegExp is a description that can be used to find some data, the same way a number can be used as an index on an array), so I would accept both. I would not accept functions because if they get parsed they are executables \"as is\", and there's almost no way to sanitize them and know they are secure (a RegExp could be bad written, but it's not a security thread or could erase data by itself...).\n\nSupporting functions is not just about security. You would have to expect the JSON5 parser be able to parse functions and implementations to be able to represent those functions on their native platforms. If someone wants to implement functions in JSON or JSON5, they might as well write a transpiler for ES5 into every other programming language.\nRegarding regular expressions, I wrote a little more about the subject. \n. @piranna \n\nYour last solution (map RegExp.toJson() to RegExp.toString()) so they got embebed inside strings is just what I'm doing in another project processing them with another data types and it works like a charm... :-D Maybe we could add and process the RegExp in the same way, storing them as strings :-)\n\nI'm open for discussions on serializing RegExps as strings. In fact, I've renamed and re-opened the issue. Let's keep further discussions there. Thanks.\n. I'm all for adding this functionality, and the code looks good at a glance. I'll look over it more closely later, but for now I'd just like to point out that this would set a precedent for adding NPM dependencies.\nHistorically, we've avoided those to make it easier for web developers to use JSON5. Granted, this PR only changes the CLI and not the core, so we could merge this now, but we should probably implement Browserify before we start adding more dependencies. I took a crack at it but ultimately had to revert it. If someone would like to pick up where I left off, that would be awesome.\n. We don't need to wait on Browserify for this PR. I would like to see some tests written for this though.\n. Partially fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.\nIt currently does not stream JSON5 input, but consumes it all at once, however the parser is capable of parsing streaming input with some API changes. It still uses JSON.stringify, so output is not streamed.. :+1: \n. This look great at a glance. I don't have time to vet this in depth right now, but I'll definitely take a look later. For now, I'll just leave a few comments in the code. Thanks for the great work!\n. I'd like to see some test cases using other number literals like NaN and Infinity and for cases like dividing by zero (1 / 0) and overflowing the operation with large numbers.\n. Thanks for this write-up. I agree with everything you've said. Here's what I'd like to see in this discussion:\n- Use cases (why we would implement this)\n- JSON5 document examples (how this would look in a file)\n- API (how we generate a document with constants)\nI can see how this might be useful in configuration files (similar to how LESS and SASS use them) but I'm struggling to see a data serialization use case.\nMy first thoughts on how this would look in a document is this:\njs\nvar e = 2.72;\nvar pi = 355/113; // using the new operator syntax in #111\nvar contact = 'Obi-Wan Kenobi <obiwan@jedicouncil.gov>';\n{\n  e: e,\n  pi: pi,\n  authors: [\n    contact,\n  ],\n}\nFor the API, I have some questions. The API wouldn't be able to generate a document that uses variables. It could declare them, but not use them without some special function.\nMaybe it would work something like this. Add another argument to stringify (or modify an existing one to use some kind of config format) and pass it an object of name/value pairs. The names must be valid identifiers or it will throw. Add a special JSON5 function (e.g. JSON5.useConstant()) that lets you use a constant name in your generated document.\n``` js\nvar options = {\n  quote_keys: false, // don't put quotes around keys unless required\n  quote: \"'\", // use single quotes\n  constants: {\n    e: 2.72,\n    pi: 355/113, // using the new operator syntax in #111\n    contact: 'Obi-Wan Kenobi obiwan@jedicouncil.gov',\n  },\n};\nvar doc = {\n  e: JSON5.useConstant('e'),\n  pi: JSON5.useConstant('pi'),\n  authors: [\n    contact: JSON5.useConstant('contact'),\n  ],\n};\nvar json5 = JSON5.stringify(doc, options);\n```\nFor the parse API, does it parse the constants into values before it gives it to the revivier, or does it notify the reviver that a constant was used?\n. The reason I didn't use the word const is because it's not part of the ES5 spec, so using it would break compatibility with ES5. It is part of the ES2015 spec though.\nAlso, JSON5.stringify doesn't produce valid JSON documents, it produces valid JSON5 documents.\nI'm still on the fence about whether the API should allow generating documents with constants, but we could certainly implement constants without it until there is demand.\n. > Wasn't it the intention that stringify produce valid JSON documents at\n\nleast originally, and JSON5 only offered more flexibility? At least I\nremember so...\n\nYes, but that changed with #32.\n. TBH, I didn't expect this to get implemented, but I thought it would be good to have a conversation about it. I'm in full agreement with @aseemk on this.\n. I think I might make this v0.5.0. I'd like to get the following PRs merged before v1.0.0:\n- [ ] #89: Browserify support\n  - [ ] #1: Unicode support\n  - [ ] #94: helpers.js file and fix for isWord leaking into public API\n- [ ] #84: --validate CLI option\n- [ ] #87: slim down npm payload\n- [ ] #105: CI improvements including coveralls\n- [ ] #108: streaming command line and yargs runtime dependency\nOnce we implement Browserify, we should be able to add in Unicode support.\n. @aseemk\nv0.5.0 is released, but I don't have permission to publish to npm. Thanks.\n. According to RFC 7159:\n\nAn object whose names are all unique is interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings. When the names within an object are not unique, the behavior of software that receives such an object is unpredictable. Many implementations report the last name/value pair only. Other implementations report an error or fail to parse the object, and some implementations report all of the name/value pairs, including duplicates.\n\nI don't think JSON5 should always output \"unpredictable\" JSON. However, if you would like to add that to your JSON5 files manually, you could do something like this:\njs\n{\n  note: 'THIS FILE WAS GENERATED BY A http://json5.org TOOL,\\\nEDIT THE .json5 SOURCE FILE INSTEAD OF THIS .json FILE',\n  anykeywhatsoever: 5,\n}\nThe JSON consumer would need to ignore the \"note\" property in this case.\n. This makes me wonder if JSON5 should preserve duplicate keys when compiling to JSON.\n. I'm still hesitant about this. Although JSON5 supports duplicate keys, keeping only the last one, outputting duplicate keys feels like promoting them, which is opposite to the stance that RFC 7159 takes.\nI'd like to see more discussion from others on this topic.\n. I'm not sure I follow. If your JSON5 file is invalid, then you'll get errors when you try to compile it to JSON. A JSON file generated from a JSON5 source file would not have any errors.\nIf you're talking about application errors not related to JSON syntax (e.g. the JSON consuming application expected a number instead of a string) can you provide an example where replacing comments with a space instead of stripping them would match up more closely with the source file?\n. Okay, it makes more sense after reading the README for strip-json-comments.\nComments are replaced with whitespace, meaning spaces and new lines where appropriate, to keep the lines and columns matching. Here's some examples:\n``` js\n{\n  // happy\n  \"earth\": \"day\"\n}\n{\n\"earth\": \"day\"\n}\n```\n``` js\n{\n  \"earth-day-2016\": / 4/22/2016 in ms / 1461308400000\n}\n{\n  \"earth-day-2016\":                       1461308400000\n}\n```\n``` js\n{\n  \"first-earth-day\":\n  / Earth Day was founded by\n     Senator Gaylord Nelson on\n     April 22, 1970 /\n  \"1970-04-22T00:00:00.000Z\"\n}\n{\n  \"first-earth-day\":\n\"1970-04-22T00:00:00.000Z\"\n}\n``\n. I don't think this makes sense for this project since JSON5 to JSON is not a one-to-one compilation even without comments. JSON5 documents are normalized to JSON as if you used theJSON.stringify` function.\nImplementing sourcemaps might be a better general option.\n. Thanks for the suggestion, but this breaks JSON5's compatibility with ES5.. LGTM. Thanks for the input. #108 needs tests before merging. If you would like to write the tests, it would be greatly appreciated.\nI'm going to close this issue since it's in essence a duplicate of #108. Thanks.\n. A similar solution has already been discussed in #52. The reason we haven't implemented this feature is because it would make JSON5 no longer compatible with ES5.\n. See #129\n. Closes #128\n. This sounds good to me. Thanks for putting in the work. Please see #131 for continued work and discussion.\n. I think you're the first person to ask for support for functions. What is your use case for this?\nAlso, the result of the string you trying to parse is not a valid JSON value. Just run the following code:\njs\nJSON.stringify({\n  local: { active: true },\n  effects: {\n    toggle: function (data, state, send, done)   {\n      this.local = !this.local\n    }\n  }\n}, null, '  ')\nAnd you'll get:\njson\n{\n  \"local\": {\n    \"active\": true\n  },\n  \"effects\": {}\n}\nNote that the function is missing from the JSON result.\n. If you're looking to parse JavaScript, you should look into Esprima, Acorn, and UglifyJS.\nParsing functions is out of the scope of JSON5. Thanks.\n. If you're parsing the JSON5, you can use the reviver argument in JSON5.parse. It works the same as JSON.parse.\njs\nJSON5.parse(text, function(key, value) {\n  if(value['address']) {\n    delete value['address'];\n    return value;\n  }\n});\nIf you're stringifying to JSON5, you can use the replacer argument in JSON5.stringify. It works the same as JSON.stringify.\nThere are two ways to use replacer, as an array containing the keys you want to stringify,\njs\nJSON5.stringify(data, ['name', 'age']);\nOr as a function that works just like reviver.\njs\nJSON5.stringify(data, function(key, value) {\n  if(value['address']) {\n    delete value['address'];\n    return value;\n  }\n});\nNotice you can use the same function for reviver and replacer to get the same results.\n``` js\nfunction addressFilter(key, value) {\n  if(value['address']) {\n    delete value['address'];\n    return value;\n  }\n}\nJSON5.parse(text, addressFilter);\nJSON5.stringify(data, addressFilter);\n```\n. Thanks for the bug report! I just published the fix, so try it out at let us know if you still have any issues.. Please see the v1.0.0 TODO list. If you are able to contribute to the spec, please do so on the beta branch.\nBeside completing the spec, I'm going to do a rewrite of the codebase because the current codebase is based on Crockford's implementation whereas the new codebase will be based on the ES5 implementation.. Please see the v1.0.0 Milestone. Many of the issues/PRs will be fixed with the codebase rewrite, and I'll close those once I've merged that in, however, the CLI enhancements still need to be written along with their tests.. v1.0.0-beta is live. Read the CHANGELOG to see the new features and fixes.\nUse it in your projects with:\nbash\nnpm install --save json5@beta\nUse it in your terminal with:\nbash\nnpm install -g json5@beta\nUse it in your browser with:\nhtml\n<script src=\"https://unpkg.com/json5@beta/dist/index.js\"></script>. @seagreen Thanks for the commendation. Here's the relevant section from the WIP spec regarding line and paragraph separators.\n\nParagraph and Line Separators\nLike JSON, JSON5 allows the Unicode code points U+2028 and U+2029 to appear unescaped in strings. Since ECMAScript 5.1 does not allow these code points in strings, JSON5 authors should avoid including them in JSON5 documents. JSON5 parsers should produce a warning when they are found unescaped in strings. JSON5 generators should escape these code points in strings.\n\nSo officially, JSON5 is a strict superset of JSON and a loose subset of ES5 (but only loose regarding line and paragraph separators). I updated that comment to reflect this now.\nI haven't reviewed the ABNF with the new changes in mind, so I've added that to the TODO list.. I'm also curious to know what everyone thinks about the Date and RegExp support I've added in experimental branches.. I forgot to document a new feature in the CHANGELOG.\n\nNew: stringify checks for a toJSON5 method on objects and, if it exists, stringifies its return value instead of the object. toJSON5 overrides toJSON if they both exist.\n\nThis is mainly useful in two cases:\n- When you want to convert an object to Infinity or NaN before stringifying.\n- When you want JSON5 output to differ from JSON output because reasons.. The latest draft of the spec is up at https://json5.github.io/json5-spec/. Make sure you refresh the page to get the latest version. The date should be September 28, 2017.\nI consider this the final version unless anyone finds anything wrong with it. Once finalized, it will say Standard instead of Draft, and the note about it being a draft will be removed.\nI appreciate any feedback.. @aseemk Good catch. I fixed that, added a JSON5Punctuator production that I missed, made it mobile friendly, and added a server script for development.. I've made several changes to the spec. Many of the changes are only formatting or rewording, but there are a few important changes.\n\nReworded the introduction to state that JSON5 is a superset of JSON and removed the part about it being a subset of ES5 (https://github.com/json5/json5-spec/commit/3b5c1f1417b70f9c157cc1341a25b99114f6008d)\nRelated to that, JSON5 doesn't add new data types to ES5, but it does add new data types to JSON, namely Infinity and NaN, so I removed that part too.\nFixed an error regarding what characters must be escaped in strings (https://github.com/json5/json5-spec/commit/932a7d4a1e9cddda39e7215d1e8fdae9fec64d03)\nReworded the parts about Infinity and NaN and added an example (https://github.com/json5/json5-spec/commit/9a6aa9cdf706fe8f4738220824f5e9285c84dba3)\nRefactored some grammar productions (https://github.com/json5/json5-spec/commit/f034fc028ff0cbcee444e915d497b798eab54275)\nThe diff is a little confusing, but essentially I added a JSON5Identifier, JSON5Null, and JSON5Boolean production to the lexical grammar and ensured that the syntactic grammar only references the JSON5 lexical grammar and not the ES5 lexical grammar.\nAddressed octal escapes in strings (https://github.com/json5/json5-spec/commit/33aee9941e56ed7a215cbc5c67498e54e6583aed)\n\nThat last change also required a bug fix committed in c952a0d6e0f6fc285461c52cdd2d0f4952f6249c and 78b403a9ef60602741065907b032040dd9b780a5, which is live on npm at json5@beta.. A while ago, I ran the beta against the v0.5.1 test cases to make sure there were no regressions and fixed the bugs I found. Now, I've run v0.5.1 against the beta test cases to see if there were any changes I forgot to document. I found a few and updated the CHANGELOG. Here's a summary. (Subpoints are additional information not included in the CHANGELOG.)\n\nNew: Unicode property names and Unicode escapes in property names are supported. (#1)\nExample: { \\u0061: true } and { a: true } are equivalent.\nCharacter and escapes can be mixed, so { abc\\u0064\\u0065\\u0066: true } and { abcdef: true } are equivalent.\nThe code points represented by the escaped character must still conform to IdentifierName, so the following will fail: { \\u0000: true }\nNew: In addition to the white space characters space \\t, \\v, \\f, \\n, \\r, and \\xA0, the additional white space characters \\u2028, \\u2029, and all other characters in the Space Separator Unicode category are allowed.\nNew: In addition to the character escapes \\', \\\", \\\\, \\b, \\f, \\n, \\r, and \\t, the additional character escapes \\v and \\0, hexadecimal escapes like \\x0F, and unnecessary escapes like \\a are allowed in string values and string property names.\nNew: When a character is not allowed in a string, stringify outputs a character escape like \\t when available, a hexadecimal escape like \\x0F when the Unicode code point is less than 256, or a Unicode character escape like \\u01FF, in that order.\nExample: '\\u0061\\u0009\\u000F\\u01FF' becomes 'a\\t\\x0F\\u01FF'\nFix: stringify properly handles the key argument of toJSON(key) methods. toJSON5(key) follows this pattern.\nRaise your hand if you didn't know this was a thing. :hand:\nFix: stringify accepts Number and String objects as its space argument.\nRelated but different: #154\nFix: In addition to a function, stringify also accepts an array of keys to include in the output as its replacer argument. Numbers, Number objects, and String objects will be converted to a string if they are given as array values.\nRaise your other hand if you didn't know this was a thing either. :hand:. Good question. The use of the word \"should\" has the same meaning as in RFC 2119.\n\n\nSHOULD   This word, or the adjective \"RECOMMENDED\", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.\n\nSo, no you should not rely on this behavior, especially since the JSON spec does not recommend that generators escape those characters and JSON5 parsers must be backward compatible with JSON.\nThe old Bikeshed version of the spec referenced this RFC, but the Ecmarkup version doesn't. I'll be sure to add that reference back in.. I just updated the spec with a clause about the keywords and a few other fixes and clarifications.. Apologies for the lack of updates lately. I've been busy with work and personal things. The reason I haven't released v1.0 yet is because I discovered a bug in the reference implementation, and I think it's important to release a working reference implementation along with the spec.\nI've already fixed the bug, so v1.0 of the spec and reference implementation should be ready to be released after the READMEs, and CHANGELOGs are updated.\nAfter v1.0 is released, I will continue work on refactoring parse to use Parser and Lexer classes, which will facilitate the development of modules that must inspect JSON5 code, e.g. an ESLint plugin.. @MartinMuzatko At this point in time, there is no intention to make JSON5 a W3C or TC39 spec, and there isn't really a need to. The Source Maps spec is just a Google Doc, but it's in use by almost every modern transpilation software today, and I plan to implement it into JSON5 at some point too.\nAs long as everyone agrees with the official JSON5 spec, it will be a standard regardless of whether it's endorsed by W3C or TC39.. https://github.com/json5/json5-spec. It's not really a formal language, but it's the same convention used in the ES5 spec.. The problem with formal grammars is that, while they're often meant for machine processing, the grammars don't always support the nuances of the languages they parse.\nFor example, ECMAScript allows Unicode escape sequences in identifiers as long as the unescaped value can also be parsed as a valid identifier. In other words:\njs\nvar a;      // valid identifier\nvar 0;      // invalid identifier (cannot start with a number)\nvar \\u0061; // valid identifier (\\u0061 = 'a')\nvar \\u0030; // invalid identifier (\\u0030 = '0')\nThis is not something a lot of, if any, language grammars natively support. Take for example this ECMAScript parser written with ANTLR. Its IdentifierStart production will parse any Unicode escape sequence regardless of whether or not it's a letter, $, or _.\nI proved this by forking it and adding a test case that should fail and then building it on Travis CI. All tests passed.\nTalking specifically about JSON5, its grammar references some ECMAScript 5.1 grammar productions, which would have to be translated to a formal grammar language as well.\nYou're welcome to make a first go at writing an ABNF for JSON5.. @dreftymac This is all interesting information, but what does this have to do with JSON5?. @dreftymac BTW, I answered that StackOverflow question because the other answerers don't seem to understand the YAML spec.\nhttp://stackoverflow.com/a/42194903/164430. I'm on full agreement on this. :100:. I can do the command line merge, just let me know if you see anything I missed.. Clever :wink:. These are the only items included in the json5 package.\n\nCHANGELOG.md\nlib/\nLICENSE.md\npackage.json\nREADME.md\n\nThis is accomplished by the files: [ \"lib/\" ] entry in package.json.\nThe rest of the files are always included regardless of .npmignore.\nThe test directory does not appear in my node_modules/json5 directory. How is it that it appears in yours? Are you using a version < v0.5.0?. It would be great if you could clarify a few points on the web-page which are not obvious.\n\nCan multi-line comments be nested? (I assume they may not be nested)\nNo.\nIt says numbers may be prefixed by +. Does this also apply to NaN and Infinity? (I assume yes, +NaN and +Infinity are valid)\nYes.\nNumbers may have leading or trailing decimal separator. Is it allowed to have both leading and trailing decimal separator? Meaning: Is . a valid number? (I assume it is not)\nNo.\nStrings can now be single-quoted. What escaped characters are allowed in single-quoted strings? \\'? Is \\\" allowed in a single-quoted string? And is \\' now allowed in a double-quoted string? Any other extensions? EDIT: JSON allows an escape slash: \\/, does ECMAScript? What about \\v (not in JSON, but in ECMAScript).\nIn strings, the following characters have special meaning when preceded by \\: b, f, n, r, t, u, \\n (U+00A0, line feed), \\r (U+00D0, carriage return). When the following characters are preceded by \\, they are treated as if they weren't: ', \", \\, /. (Meaning \"\\'\" is the same as \"'\".) This applies to both single and double quoted strings.\nObject keys are, in JSON, strings. Can a multi-line string be used as a key in JSON5?\nYes.\nUnquoted object keys - is there any chance you can limit this to an explicitly specified character set without relying on some unicode support? Our library (https://github.com/taocpp/json) tries to be dependency-free and having to deal with unicode character properties seems to go against the simplicity of JSON (and hopefully JSON5). In fact, I'd consider alnums + _ + $ (without a leading cipher) to be good enough, if you want throw in more characters explicitly like -, ., ... but Unicode is way too much IMHO.\nCurrently JSON5 only supports unquoted property names that follow the regex pattern /[$_A-Za-z][$_A-Za-z0-9]*/. To better align with ECMAScript 5, support for certain alphanumeric Unicode characters has been proposed. (- and . would not be included.) For an example of this implementation, see jsonext, which aligns with ECMAScript 6. Its build.js file generates regular expressions that match the Unicode characters allowed in property names.. Short answer: No.\n\nLong answer:\nIn ECMAScript 5, a leading zero indicates an octal number if it is immediately followed by one or more numeric digits. In the literal 00, the first 0 is treated as an indicator that the number is octal (base 8) and the second 0 is treated as the actual octal number, which results in 0.\nIf you try this in ECMAScript 5 in strict mode, you'll get a syntax error indicating that octal literals are not allowed. And regardless of whether you're in strict mode, you'll get a syntax error if you try things like 00.0 or 00e0.\nLike strict ES5, neither JSON nor JSON5 allow octal literals, so 00 is an invalid token. Interestingly in ES5, 08 should be a syntax error (even when not in strict mode) however many parsers just interpret it as the number 8, willfully ignoring the ES5 spec.. Here's another discrepancy between JSON5 and ES5 you may not be aware of. There is no such thing as a negative numeric literal in ES5 like there is in JSON and JSON5.\nIn ES5 -1 is treated as the two tokens - and 1 with the first being a unary negation operator and the second being a numeric literal. This means that - 1 is also a valid expression (note the space between - and 1). This also means that - - - 1 is a valid expression the same as -(-(-(1))). (Note that ---1 is not valid because -- is a different operator that cannot be applied to literals.)\nIn JSON and JSON5, there are no unary operators, so - 1 would throw a syntax error. The - must immediately precede the 1 with no characters in between. The same goes for + 1 in JSON5.. Okay, so I've gotten myself in a tough spot now. A draft of the JSON5 spec exists at https://github.com/json5/json5-spec, but the information I've been giving you is based on the reference implentation of JSON5, which doesn't completely follow the spec.\nIt is a goal of mine to align the reference implementation to the spec, but I haven't found the time. I think effort would be better used by aligning the reference implementation to the spec rather than writing a new spec based on the implementation. When complete, this would be JSON5 version 1.0 and the spec and reference implementation would likely be frozen at that point (with occasional bug fixes).\nHere is the only discrepancy I can think of between the reference implementation and the spec, but there may be others. According to the spec, strings allow any character to be escaped unless it has a special meaning. The characters that have special meaning are: b, f, n, r, t, v, x, u, 0, 1 through 9 (which are errors), \\r (carriage return), and \\n (line feed). Any other character is treated as the character itself without the preceding \\. (For example, '\\a' is the same as 'a' just like \"\\'\" is the same as \"'\".) Taking after JSON, the JSON5 reference implementation only allows a subset of escapes and v and x aren't even included among them.\nThere is also some work to be done on the spec as listed at https://github.com/json5/json5-spec/issues/1. Here's another discrepancy. The whitespace allowed in the spec does not match the whitespace allowed in the reference implementation. Namely \\u2028 and \\u2029 are valid whitespace characters in the spec, but they are not in the reference implementation.\nIf you take the implementation of jsonext and comment out all of the features added in ES6, you get a JSON5 implementation that follows the official JSON5 spec (with Unicode support). Those ES6 features are binary and octal literals (0o777 and 0b1010), template strings (`abc`), and Unicode code point escapes ('\\u{20BB7}').. That ABNF looks like a good starting point. NBSP is valid whitespace in JSON5. Section 7.1 explains why the BOM is allowed after the start of the document. 1-9 are not valid escape characters but 0 is.\nHere are the character escapes in strings and how they should be handled. Each \"sequence\" refers to the character(s) immediately following the \\ (U+005C) character.\nSequence        | Result | Notes\n----------------|--------|----------\nb (U+0062)    | U+0008 | Backspace\nt (U+0074)    | U+0009 | Horizontal tab\nn (U+006E)    | U+00A0 | Line feed\nv (U+0076)    | U+000B | Vertical tab\nf (U+0066)    | U+000C | Form feed\nr (U+0072)    | U+000D | Carriage return\n0 (U+0030)    | U+0000 | Nul character\n1 through 9 (U+0031 through U+0039) | Error  | Octal escapes are not supported\nx (U+0078) followed by two hex digits | The character with the code point of the hex number | For example \\x61 becomes a. It is a syntax error if the x is not followed by two hex digits.\nu (U+0075) followed by four hex digits | The character with the code point of the hex number | For example \\u0061 becomes a. It is a syntax error if the u is not followed by four hex digits.\nU+00A0          | Nothing | Escaped line feed results in an empty string\nU+00D0 U+00A0   | Nothing | Escaped carriage return followed by a line feed results in an empty string\nU+00D0          | Nothing | Escaped carriage return not followed by a line feed results in an empty string\nU+2028         | Nothing | Escaped line separator results in an empty string\nU+2029         | Nothing | Escaped paragraph separator results in an empty string\nAny other character | The character itself | For example \\a becomes a, \\\\ becomes \\, and \\\" becomes \"\n*Whether escaped line and paragraph separators should be allowed as line continuations is still up for discussion. See #70, which discusses these characters but does not touch on whether they should be treated as line continuations when escaped in strings.. * Disallows trailing commas on empty arrays/objects. OK? ([,], {,})\n\n\nThis is correct. A comma can only appear after an object member or array element.\n\n\nAdding \\0 and \\xXX as escape-sequences makes sense thinking about bytes, but JSON strings are required to be valid unicode strings - and those may not contain embedded nul-bytes IIUC. What is the intended semantics of those? Or does JSON5 allow \"binary\" strings, meaning any byte-combination is allowed? And if that is the case, what is the semantics of escaped surrogate pairs?\n\n\nThe only Unicode code points that are invalid are values U+D800 through U+DFFF and values larger than U+10FFFF. This means that \"\\0\", \"\\x00\", \"\\u0000\", \"\\xFF\", and \"\\u00FF\" are all valid Unicode strings in ES5 and JSON5 (and the \\u versions are valid in JSON). So it's technically possible to store binary data in a string this way.\nAlthough it's possible to store binary data as a string of character escapes, it's recommended to encode the data as Base64 and store the result as a string.\nThe string '\\uD800' doesn't represent a valid Unicode string because it's only half of a surrogate pair. JSON5 doesn't define how to handle this situation. I would encourage implementations to either throw an error or replace the character with U+FFFD.\nHistorically, strings and byte arrays were equivalent. The string 'abc' was stored in memory and on disk as the byte array 61 62 63. Likewise, '\\x81\\x82\\x83' was stored as 81 82 83. So it made sense to represent byte arrays as strings. However, once Unicode became popular, strings started being stored in memory as UTF-16, so 'abc' became 00 61 00 62 00 63 and when stored on disk or sent over the network, they were usually represented as UTF-8, so '\\x81\\x82\\x83' became C2 81 C2 82 C2 83.\n\n\nShould the grammar be committed somewhere?\n\n\nYes, please submit a PR to https://github.com/json5/json5-spec. Thanks.. * The grammar doesn't allow it (yet), but I guess a single-line comment is allowed to be at the end of the input without an explicit eol? (complete input exampe: \"foo\" // a string - no newline anywhere)\n\nYes.\nAre negative (or explicitly positive) hexadecimal values allowed? -0x1234 or +0x1234 instead of just plain 0x1234?\nYes, and it's a bit of a funny story: #36. I recommend running your library against the JSON5 test suite at https://github.com/json5/json5-tests.. This conflicts with our goal of having JSON5 be a strict subset of ES5 that adds no new data types.. Thanks for the suggestions, but this goes against JSON5 being valid ES5.. I saw this proposal too. I think it would be a nice addition to JSONext, a spiritual successor to JSON5, if it lands in a version of ES.. JSON5 is able to stringify objects, arrays, strings, numbers, Booleans, and nulls. Anything else, including functions and symbols, should return undefined. It should only throw when you have a circular reference or when the replacer argument is truthy but neither function nor array.\n\nWhat are you passing into stringify that is causing it to throw, and what is the error message?. I see where the error is now. Thanks.\nI might patch this soon if it's an easy fix, but in the meantime, you could use JSONext. It supports JSON5 syntax but also supports Unicode keys and includes some ES6 features. It doesn't suffer from this bug as you can see in this updated example: https://jsfiddle.net/j1156ewj/2/. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.. I just released v1.0.0-beta which has a --validate CLI option.\n```bash\nnpm install -g json5@beta\njson5 --validate my-file.json5\n```\nIt will output an error if the file is invalid or nothing if it is valid. See json5 --help for more information.\nTo validate with the API, you can just use JSON5.parse and see if it throws.\n\nThere is no CLI feature for formatting JSON5, but you can use the API to do it:\njs\nconst json5 = fs.readFileSync('my-file.json5')\nconst value = JSON5.parse(json5)\nconst formattedJSON5 = JSON5.stringify(value, null, 2)\n\nI'm also considering writing an ESLint plugin for JSON5, and maybe a \"Try JSON5 Online\" page.. Easy fix in the grammar too:\n```\nJSON5Punctuator :: one of\n    ( ) { } [ ] : ,\nJSON5Text :\n    ( JSON5Value )\n    JSON5Value. Fixed in 687582810ec353c2333b02bd1036a0e4398d73ca.. This is possible in the beta.\nbash\nnpm install -g json5@beta. Thanks for the suggestion. This has been discussed in #55. Please continue this discussion there.. Thanks for the suggestion. This has been discussed in #52. Please continue this discussion there.. Are there any ideas on how to support Unicode and their escape sequences in identifiers? What are the options, and what are the pros and cons of those options?\nIt seems the biggest hurdle is that there is no standard way to determine what Unicode category a code point belongs to. For example, an identifier can start with $, _, or any character in the five Letter categories or in the Number, Letter category. That's 17196 different characters, all spread across the Unicode code point list.\nHere are some ideas on perhaps how to solve this:\n- Require a dependency that provides support for testing Unicode categories.\n- Bake in support for it yourself. I've already done some prototyping and benchmarking.\n- Consume Unicode escape sequences and forego testing them against appropriate Unicode classes, willfully violating the ES5 spec.\n- Something very obvious I haven't thought of yet.\nI think it's worth discussing the costs and benefits of implementing this support. What do you think?\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.. I move to close this as a won't fix. This is outside the scope of JSON5. Use the reviver argument of JSON5.parse if you want to restore types other than primitives, objects and arrays.\n. mofo syn posted on the JSON5 Google Group:\n\nI wonder if anyone thought about custom data types e.g. ISO8601\njson\n{\"data\": !ISO8601 \"2013-10-07T18:06:03.048Z\"}`\nAbove is how yaml would approach this. Obviously not JSON compatible.\nBelow is how MongelDB approches it:\njson\n{\"data\":{\"$date\":\"2013-10-07T18:06:03.048Z\"}}`\n\nWould be interesting to see if there is a way to define custom datatypes in a way that is consistent with javascript V5.\n\nI think @shish summed it up nicely:\n\nstoring as strings and then attempting to turn all strings into dates would have false positives; storing as non-strings breaks the purity of the format\n\nAlso, YAML's method would violate one of the core values:\n\nJSON5 remains a strict subset of JavaScript.\n\nProbably the best solution would be to allow new Date() or Date.parse() as values. When JSON5 is serialized as JSON, it would output the date string, but when serialized as JSON5, it would output new Date() or Date.parse().\nBTW, new Date() and Date.parse() are equivalent, so it comes down to which one feels better. I think my vote is for new Date() since it's two characters less.\n. Correction, new Date() and Date.parse() are not equivalent, since new Date() returns a Date object and Date.parse() returns a Number. \nnew Date() may cause some confusion as to what type of parameter is accepted since it has four overloads:\njavascript\nnew Date()\nnew Date(value)\nnew Date(dateString)\nnew Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]])\nI think JSON5 should only accept strings as parameters (for readability) so new Date(dateString) would be the only acceptable overload. But we're still left with ambiguity about what date formats are acceptable. I think ISO8601 should be allowed exclusively.\njavascript\nnew Date('2015-10-08T10:29:00.000Z') // acceptable\nnew Date('October 8, 2015 10:29 AM') // unacceptable\nNote that stringify will output all ISO8601 fields, but all fields do not need to be specified when parsing:\njavascript\n// all acceptable\nnew Date('2015')\nnew Date('2015-10')\nnew Date('2015-10-08')\nnew Date('2015-10-08T10:29')\nnew Date('2015-10-08T10:29Z')\nnew Date('2015-10-08T10:29-08:00')\nnew Date('2015-10-08T10:29:30')\nnew Date('2015-10-08T10:29:30Z')\nnew Date('2015-10-08T10:29:30-08:00')\nnew Date('2015-10-08T10:29:30.123')\nnew Date('2015-10-08T10:29:30.123Z')\nnew Date('2015-10-08T10:29:30.123-08:00')\nnew Date('2015-10-08T10:29:30.123456789')       // these last three are acceptable,\nnew Date('2015-10-08T10:29:30.123456789Z')      // but lose resolution in some environments\nnew Date('2015-10-08T10:29:30.123456789-08:00') // like Node.js and browsers\nAny values without a time zone designation would be treated as UTC.\n. I'm in the process of finalizing v1.0.0, so I've taken another look at Date support. I've been testing out an option for parse that will automatically find strings that look like dates and parse them as Date objects. Here's what the API looks like.\njs\nconst result = JSON5.parse(\"{dateTime: '2017-09-23T23:53:40.303Z'}\", {dates: true})\n// `result` is equivalent to { dateTime: new Date('2017-09-23T23:53:40.303Z') }\n\nThe date string must be in ISO format with all fields present and in the UTC time zone. In other words, it must be in the format YYYY-MM-DDTHH:mm:ss.sssZ. This is the same format returned by Date.prototype.toJSON().\nThe second argument of parse can be a reviver function or a new options object. The options object can have a reviver property and a dates property. If dates is truthy, then each string will be tested to see if it conforms to the format described earlier, and if so, converted to a Date object.\nIf a reviver function is also defined, then it will be called after all date strings have been converted to Date objects.\n\nIt has not yet been decided whether this feature will make it into v1.0.0. Please let me know what you think.\nThis is not an extension to the JSON5 document specification. It is only an extension to the API of this library. JSON5 implementations are not required to implement this API.\nYou can try this out by using npm install json5@dates.. See my reply at https://github.com/json5/json5/issues/91#issuecomment-333287297.. \n\nHere's a polyfill\n\n```js\nfunction json5DatesPolyfill() {\n    const JSON5 = require('json5')\nconst origParse = JSON5.parse\n\nJSON5.parse = function parse(text, reviver) {\n    let root = origParse(text)\n\n    if (reviver != null && typeof reviver === 'object') {\n        const dates = reviver.dates\n        reviver = reviver.reviver\n\n        if (dates) {\n            root = internalize({ '': root }, '', dateReviver)\n        }\n    }\n\n    if (typeof reviver === 'function') {\n        return internalize({ '': root }, '', reviver)\n    }\n\n    return root\n}\n\nfunction dateReviver(name, value) {\n    if (\n        typeof value === 'string' &&\n        /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\dZ$/.test(value)\n    ) {\n        return new Date(value)\n    }\n\n    return value\n}\n\nfunction internalize(holder, name, reviver) {\n    const value = holder[name]\n    if (value != null && typeof value === 'object') {\n        for (const key in value) {\n            const replacement = internalize(value, key, reviver)\n            if (replacement === undefined) {\n                delete value[key]\n            } else {\n                value[key] = replacement\n            }\n        }\n    }\n\n    return reviver.call(holder, name, value)\n}\n\n}\n```\n. Closing as JSON5 will not support numeric literals as property names until there is enough demand for it. #55 is now the official issue regarding this.\n. I move to continue disallowing leading commas and empty values. And I apologize for the following novel. There's a TL;DR at the bottom. :)\nOne of the headaches of JSON is that it doesn't allow trailing commas. For instance, you start to write a JSON file, and like any normal JavaScript developer, you add a comma after each value because it makes it easier to copy and paste and move values around.\njson\n{\n  \"end_of_line\": \"lf\",\n  \"indent_style\": \"space\",\n  \"indent_size\": 4,\n}\nOf course, JSON throws SyntaxError: Unexpected token } because of the trailing comma. This has led to hacks like adding commas to the beginning of each value except the first.\njson\n{\n  \"end_of_line\": \"lf\"\n  ,\"indent_style\": \"space\"\n  ,\"indent_size\": 4\n}\nIt gets the job done, but it's ugly IMO, and it creates another problem. If you remove the first value and forget to remove the proceeding comma, you get SyntaxError: Unexpected token ,.\nFast forward to today. You start using JSON5 because trailing commas are awesome and should have been allowed by JSON in the first place. Even better, you don't have to change your current JSON files because JSON5 is completely backward compatible. And that's great because you have a lot of JSON files using the hacky leading comma syntax.\nYou edit one of your old JSON files, removing the first value, and you forget to also remove the proceeding comma because you're involved in several projects, overworked, and having trouble paying attention to detail.\nBut that's okay because JSON5 throws SyntaxError: Unexpected token , when you try to parse it. Because you've seen it so many times with JSON files, you immediately know the issue.\nActually, JSON5 throws SyntaxError: Bad identifier. Remind me to fix that. :)\nTL;DR\nIf JSON5 allowed leading commas and empty values, old JSON files that used to throw would no longer do so, which could introduce silent and/or hard to find bugs.\nAlso, undefined is its own data type, and, repeating for emphasis, JSON5 introduces no new data types over JSON.\nThoughts?\n. I wanted to open this back up for discussion, clarify some things, and see if we want to change this behavior.\nTL;DR\nThis issue was originally a bug because of a change in V8. Instead of fixing the bug, the feature was removed even though the feature didn't really have anything to do with the V8 bug. It was the implementation of the feature that needed a fix.\nSigned numbers vs numeric literals\nSigned numbers, whether decimal or hexadecimal, are not treated as literals when parsed by ES5. They are parsed as two separate tokens: a Punctuator (+ or - in this case) and a NumericLiteral (an unsigned decimal or hexadecimal number).\nThat sequence produces a UnaryExpression using the + or - operators. In either case, the text of the NumericLiteral is converted to a number using ES5's ToNumber operation, and in the case of the - operator, the mathematical value is negated.\nThe discrepancy between signed decimals and signed hexadecimals occurs within the ToNumber(String) operation. It allows signed decimal numbers but prohibits signed hexadecimal numbers, returning NaN instead. Compare the following. (The global Number function uses the ToNumber operation):\n``` js\n\n[  eval('1'),   eval('0x1'),   eval('-1'),   eval('-0x1')]\n[ 1, 1, -1, -1 ]\n[Number('1'), Number('0x1'), Number('-1'), Number('-0x1')]\n[ 1, 1, -1, NaN ]\n```\n\nThe V8 bug\nThe + unary operator with a String argument (i.e. +'1.234') also applies the ToNumber operation, which is what the V8 bug was about. Expressions like +'-0xF' and Number('-0xF') were resulting in -15 instead of NaN as called for in the spec. Note that this is separate from the actual unary expression -0xF; this is the string '-0xF' being converted to a number.\nConclusion\nSigned hexadecimals aren't evil, nor are they disallowed in ES5. They just can't be converted from strings for whatever reason the ES5 authors had. This really has nothing to do with JSON5.\nJSON5 has freed us from the restrictions of JSON so that we can have a lightweight data-interchange format that is even easier for humans to read and write. Why disallow signed hexadecimals just because ES5 doesn't convert them from strings?\n. I'm going to move to close this issue as won't fix. It could be a goal for JSON6 (working title). ;)\n. @sykano I mentioned this in the PR, but I'll say it again here. Thanks for the diagrams. I don't think the code repository is the best place for them though. If you'd like to update the Wiki, that would be great. Thanks.\n. From the json.org website (emphasis mine).\n\nJSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.\n\nSo you see, the purpose of JSON is not just that it is language agnostic and fast to parse, but that it is also easily readable and writable for humans. JSON5 is a bit of a trade-off\u2014far easier for humans to manipulate, only marginally more complex for computers to manipulate. I think the benefits outweigh the cost.\nI think its best feature is how well if follows the Principle of Least Astonishment. Things you can do in JavaScript tend to just work in JSON5.\n. I couldn't find any rationale in ES5 as to why this is allowed. I think it's more of a convenience thing. I can see where it could make your code cleaner, especially if you want to store a hash table using hexadecimal numbers as keys.\njs\n// ELF header\n// Source: http://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_layout\n// { offset : fieldName }\n{ 0x00 : 'EI_MAG0',\n  0x04 : 'EI_CLASS',\n  0x05 : 'EI_DATA',\n  0x06 : 'EI_VERSION',\n  0x07 : 'EI_OSABI',\n  0x08 : 'EI_ABIVERSION',\n  ... }\nBut this brings with it at least two issues that come to mind:\n1. The user must be aware that the keys 1, 1., 1.0, 1.00, 1e0, 1e-0, 1e+0, 1.e0, 1.0e0, 0x1, 0x01, ad infinitum all get stored as '1' in the object, and as such will overwrite each other.\n2. JSON5.stringify must either:\n   - parse keys to detect whether they are identifiers, numbers, or strings and output them appropriately, or\n   - output numeric keys as strings.\n     - In either case, the original representation of the key will be lost unless it conformed to the output of the ToString method as indicated at the bottom of ES5 \u00a711.1.5\n. I'm thinking we should leave this alone unless there happens to be a demand for it. To be honest, the only reason I brought it up is because it's allowed in ES5.\n. I just realized that #10 sort of referenced this issue.\n. I wrote the code for this in the numeric-keys branch of my fork. It wasn't a difficult change.\nI'm not advocating that we implement this, I just wanted to see how much work it would be. Now the code is already written if we want to.. Moved to #1. Thanks.\n. @amb26 I'm in agreement with you that having duplicate keys in a JSON document is bad form. However, the major ECMAScript implementations\u2014V8, SpiderMonkey, and Chakra\u2014all allow duplicate keys. And they should, because according to the official spec, once the parser validates that a JSON document conforms to the JSON syntax, it parses the document as ES5 (almost). Note that RFC 7159 only describes the structure of JSON documents but not the API and implementation requirements.\nAll this considered, one of the core values of JSON5 is being backward compatible with JSON\u2014in document structure, API, and implementation.\nI do see some value in logging a warning when duplicate keys are encountered, especially since JSON5 is meant for handwritten data documents where duplicate keys are more likely to occur.\nI appreciate your opinion and research on this matter and welcome any further comments. And don't be too quick to think that these issues won't be revisited. Just look at some of the earliest issues for this repository and note how many times the community went back and forth on some pretty important features :)\n. The multi-string test cases were failing on Windows due to CRLF line endings.\n. The reason I'm handling \\r as a special case is due to the differences in how operating systems represent new lines.\n- \\n is used by Unix, Linux, and OS X and later.\n- \\r is used by OS 9 and earlier.\n- \\r\\n is used by Windows (note that it is a \\r followed by \\n).\nTherefore, any of the following combinations constitute an escaped new line:\n- \\ followed by \\n\n- \\ followed by \\r not followed by \\n\n- \\ followed by \\r\\n\nThis conforms to the LineContinuation production, which uses the LineTerminatorSequence production.\nThere's no need to add \\r to escapee since it's always handled as a special case.\n. I'm thinking I should create test cases for these before merging. Working on that now.\n. I don't think that will work. Supposed we added \\r to escapee and removed its special case. Then we parse a string like this:\n'line1 \\\\\\r\\n line 2'\nWhen the parser hits the \\ character, it will check for a following u, which won't be there. So it moves on to check for one of the escapees, finding \\r. It appends an empty string to string, and moves on to the next iteration.\nNow ch contains \\n, but it doesn't know that there was a \\ before the \\r that was before this character. so it will hit the check for \\n returning a Bad string error.\nI ran some tests to confirm this too.\n. I think the problem is with the develop branch. .travis.yml lists a Node version of 0.9, but the travis CI VM doesn't have 0.9 installed.\n. Looks like you can trigger a re-run of a Travis CI build if you're logged in.\n. Thanks for the rebase tip.\n. You know, I was thinking the same thing about ES5 whitespace. I was going back and forth between JSON and ES5 whitespace. I don't remember why I chose JSON. Let me do some research and get back to you.\n. Oh, now I remember. It was because ES5 supports whitespace from certain Unicode categories that we can't support yet. So I just went with JSON.\nI'm going to fix this to support as much ES5 whitespace as possible without venturing into Unicode territory.\n. I decided to put my prototype on the Wiki. If you have any issues with that, please let me know. Thanks.\n. I think that might be a good idea, especially since I don't see a way to lock down Wiki pages. I'd like to expand the \"spec\" into a full document at some point.\n. @rlidwka Nice document. Almost the same as the one on the wiki, as far as I can see, with a few differences: line terminators (#70), signed hexadecimals (#36), numeric literals as property names (#55), Unicode escapes in property names (#1), and it's one grammar instead of a lexical and a syntactical.\n. Funny, that's the same thing I did when I started writing a JSON5 parser for another language. I used the ES5 grammar. That's when I started finding a lot of missing features. :)\n. C# / .NET. It's a WIP at this point. I stopped to focus on JSON5 itself before continuing with other implementations.\nThere's a page on the Wiki called In The Wild. I think that's a good starting point to keep that list.\n. We now have an official spec in draft status. The PDF version can be found on the releases page.\nIdeally, discussions regarding the future of JSON5 will be discussed in the json5-spec repo, while discussions regarding the JavaScript reference implementation will still be discussed in this repo.\nI'd like to separate the goal of JSON5 from the different implementations.\nLet me know what you think.\n. @aseemk That sounds good. I've got a partial C# implementation and another one for Go, but I haven't uploaded them yet.\n. I'm thinking json5 for now.\n. @aseemk Awesome. Thanks.\nBTW, did you see this controversial issue about removing support for Infinity and NaN on the json5-spec repo?\n. Added another housekeeping item. Single line comments should break on \\r or \\n.\n. Maybe I don't have this rebase thing down yet. These commits from other branches keep showing up in my current branch.\n. Thanks @aeisenberg. I think I've been doing that, minus the cherry picking. What happens in the case where I want to include new commits from develop after I've already created my branch? For exmaple:\ngit checkout -b cool-feature develop\nDuring testing I realize there's bug that should really be its own branch.\n```\ngit checkout -b bug-fix develop\nwrite code to patch bug\ngit commit -m \"bug squashed\"\ngit push origin bug-fix\ncreate PR and merge into develop\n```\ncool-feature depends on that bug being fixed, so I want to pull the new changes from upstream/develop into my remote.\ngit checkout develop\ngit pull upstream develop\ngit checkout cool-feature\ngit rebase develop\nIs that wrong? When do I cherry pick? Should you just tell me to RTFM so I actually know what I'm doing? :)\n. Thank. I'll try that the next time I create a branch.\nAnyway. What do you think about this merge?\n. I was finally able to fix the PR issues with these commands:\n```\n\ngit reset --hard \ngit rebase -i upstream/\ngit push -f origin \n``\n. Sorry. Still battling it out with Git. Please ignore.\n. I also just noticed that JSON5 is outputtingInfinityasnull`.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. @rlidwka You are correct, and thanks for clarifying. I only included them because they are possible values, not because I expected them to output the sign too.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. @rlidwka You make a good point. It seems that JSON5 cannot be a strict subset of JavaScript and work with all existing JSON content at the same time.\n\nGranted, those Unicode whitespace characters probably aren't common, but it might be a rude awakening for someone who has been using those characters in JSON and then switched to JSON5.\nIn the end, is it more important for JSON5 to be a script subset of JavaScript or to work with all existing JSON5 content?\n. @aseemk I'm not so sure that ES5 should win over JSON in this instance.\nThe JSONP issue can be fixed by JSONP implementations, and since JSON is an official standard and JSONP is not, the onus is on JSONP implementations to escape \\u2028 and \\u2029 in strings.\nIt may be true that not many people would be using those characters in hand-written JSON5, but what about the cases where existing JSON files are parsed as JSON5? They'll fail if they contain those characters.\nI think it's more important for JSON5 to be backward compatible with JSON in this case. In other words, it's more important that JSON5 can parse JSON than that ES5 can parse JSON5. eval is strongly discouranged, so the only other time JSON5 would be parsed as ES5 is in JSON5P (working title) implementations and when the user copies and pastes JSON5 directly into their JavaScript.\nThis only applies to parsing strings, however. Whether we allow those characters in comments is up for discussion. I'm leaning toward keeping the ES5 standard and rejecting them.\n. What if we parse \\u2028 and \\u2029 (perhaps with a warning) but never output those characters unescaped?\nI had that idea last time I posted, but I discarded it because I didn't like having a parser that doesn't match the spec. But after your comments, I started thinking about the difference between HTML and XML parsers. Does JSON5 need to have draconian error handling like XML, or can we take a page from HTML's tag soup handling book?\nIn this case:\n- \\u2028 and \\u2029 are technically valid in strings in JSON5.\n- JSON5 will parse \\u2028 and \\u2029, and optionally give a warning.\n- JSON5 will escape those characters when stringified.\nIf you have a JSON5 file with those characters, and the contents of that file are in a variable named file, you can call JSON5.stringify(JSON5.parse(file)) and you'll get back valid ES5 that you can inject into scripts.\nAnd you can do the same thing if file is regular JSON, too.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. +1 for @rlidwka's config object approach. The second argument in JSON.stringify can be a function or array. JSON5 could extend this to also be a config object.\n. Fixed in a88fbd2be4bc16c8eee02968a5abe94c4041ddff.. Partially fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58\nStill needs tests.. Fixed in 51d03206a69b8fab3ac2a7a0658f8442bef4133f.. @rlidwka Good catch. This is also the proper way according to Travis CI.\n. And if merged, I'll need to update the grammar again.\n. Good catches, @rlidwka. I forgot that JSON5 did not yet support \\x escapes, and \\0 and \\v were oversights on my part. I've fixed those locally, and I'll write tests and push the changes later.\n\\1 - \\7 are octal escapes, so they're only supported in non-strict modes, but Node, Chrome, and Firefox allow \\8 and \\9, even in strict mode.\nWhat baffles me is that the ES5 spec doesn't appear to address \\8 or \\9. At least, I can't find where it does.\n. And apparently I'm not the only one.\n. Well apparently Node v0.6 doesn't throw on \\x and \\u, which is causing tests to fail. JSON5 (including this patch) works in v0.6, it's just the tests that are failing.\n. My two cents: JSON5 is JSON with some ES5 features. A strict subset of JavaScript doesn't mean a strict subset of strict ES5.* So I don't have a problem with ES5 octal literals. However, I'm not sure about ES6 octals yet. The README is pretty heavy on ES5 as the target.\nI'm also not a fan of the potentially ambiguous 0O000 sytax, but that's just a personal gripe.\n* #59 breaks this anyway. It is a SyntaxError if strict mode code contains an ObjectLiteral with more than one definition of any data property (11.1.5).\n. This is already a supported feature.\n. Ah. No problem. I see you submitted a bug with them too. Thanks.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. Fixed by #101\n. @jasonswearingen, yes. Please join in on the discussion in #113. I'll see about bumping the number ASAP. Thanks.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.. I tried to incorporate some of your commits into #94 and #96, but my implementation was a little too different for it to make sense.\n. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58. There's discussion of this in #70\n. I've thought about this, but it isn't really a feature that anyone has been asking for or that seems to be lacking. Without that demand, this probably won't get implemented.\n(Also, who would want to write a parser for a regex expression?)\n. Here's a few examples that would fail if we treated everything between two / as a RegExp:\njs\n/\\/\n/(/\n/)/\n/[/\n/*/\n/+/\n/?/\nWe would also need to parse trailing flags (g, i, m).\nWe could try to eval anything between two / and see if a RegExp comes out, but that would be a blatant security risk.\nAlso, ECMAScript doesn't support full PCRE. Specifically, it doesn't support recursion, look-behind, directives, conditionals, atomic groups, named capture, comments, or embedded code. So, JSON5 cannot represent PCRE without breaking ES5 compatibility. Ultimately, this means that platforms that support PCRE wouldn't be able to serialize PCRE as JSON5.\nThe best way to serialize regular expressions is to convert them to strings.\n. It still seems that there is some desire to implement regular expressions as first class values in JSON5. So, I'm going to elaborate on why I think it's a bad idea.\nParsing\nI've already established that if you just treat everything between two / characters as a regular expression you'd have to use the native platform's regular expression parser to ensure it's valid. Bet let me entertain that idea and see how easy it would be to implement it.\nFirst, you'd need to make sure that at least one character exists between the two /s because // is a comment in JSON5.\njs\n//  <- comment\n/a/ <- RegExp\nNow, what happens if you want to match a / in your regular expression? You need to escape it with a \\ character.\njs\n/a\\/b/    // matches 'a/b'\nOkay, so any occurrences of \\/ should not terminate a regular expression. But what about this regular expression:\njs\n/a\\\\/    // matches 'a\\\\'\nIt has an occurrence of \\/ but the \\ is escaped as \\\\. So we need to check for occurrences of \\\\ and \\/.\nOkay, we're done, right? Well, what about this regular expression?\njs\n/a[b/c]d/    // matches 'abd', 'a/d' and 'acd'\nIt's a valid regular expression with an unescaped / because it's inside an alternation group [\u2026]. So now we need to track when an alternation group begins and ends. Not so difficult, right?\njs\n/a\\[bc]d/    // matches 'a[bc]d'\n/a[b[c]d/    // matches 'abd', 'a[d' and 'acd'\n/a[bc\\]d/    // error: alternation group is never closed\nOkay, so in the first example the [ is escaped, but the ] isn't because it only has special meaning in an alternation group. In the second example, the second [ is not escaped but doesn't start new alternation group. The third example is self-explanatory. So, we need to check for [, ], \\[, and \\], and treat [ and ] differently depending on whether or not we're in a alternation group.\nDoes that cover our bases? I don't know, but for the sake of argument, let's just say it does.\nLet's simplify this into a list of steps:\n1. When parsing a JSON5 value, if the first non-whitespace character is /:\n2. Peek the next character, and if it is /, parse a comment, and do not perform subsequent steps. (Otherwise, assume it's a regular expression.)\n3. Let p = \"\". p will store the regular expression pattern.\n4. Let f = \"\". f will store the regular expression flags.\n5. Let a = false. a will indicate whether we are in an alternation group.\n6. Let c = the next character read from the stream of characters.\n7. If c is / and a is false, skip to step 14.\n8. If c is / and a is true, concatenate c onto p, and return to step 6.\n9. If c is [, set a to true, concatenate c onto p, and return to step 6.\n10. If c is ], set a to false, concatenate c onto p, and return to step 6.\n11. If c is \\, concatenate c and the next character in the stream onto p, and return to step 6.\n12. If the end of the stream has been reached, throw a parsing error.\n13. Concatenate c onto p, and return to step 6.\n14. Let c = the next character read from the stream.\n15. If c matches the IdentifierPart production, concatenate c onto f, and return to step 14.\n16. Try to instantiate a RegExp object with the arguments p and f.\nStep 16 parses the flags according to the ES5 spec. This would allow implementation specific flags to be used (e.g. ES5 doesn't support the s flag, but does support the non-standard y flag).\nBesides the fact that this extremely minimal regular expression parser is still relatively complex, it doesn't actually parse the regular expression. There's no way to validate the regular expression in an implementation agnostic way without writing way more code.\nWe would also need to define what happens if a platform doesn't support regular expressions or can't parse the regular expression given. It wouldn't know until it tried to parse it.\nSo, all JSON5 documents that include regular expressions would have to be late-validated, and there would be no true JSON5 validator.\nImplementation Agnostic vs Implementation Specific\nLet's say we did implement a full regular expression parser according to the ES5 spec. It would no longer be implementation agnostic, and we would expect all implementations of JSON5 to parse JSON5 regular expressions into an ES5 compatible format on its native platform.\nFurther, by creating an implementation restricted parser you're castrating the more powerful regular expression engines supported by other platforms. No more named captures, no more comments, no more look-behind, no more recursion, no more s flag (dot matches new line).\nSolution\nJSON.stringify serializes a RegExp instance as en empty object ({}). You can modify that behavior by executing the following line of code:\njs\nRegExp.prototype.toJSON = function() { return this.toString() }\nThat's all you need to do to write code like:\njs\nvar emailRegex = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/\nconsole.log(JSON.stringify(emailRegex))\n// output: \"/^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$/\"\nAs an added bonus, that same line of code also applies to JSON5.stringify because JSON5 also checks for toJSON().\n. I've re-opened this issue to discuss whether JSON5 should serialize RegExp objects to strings and how it would be implemented.\nI'm not suggesting that we treat RegExps as first class JSON5 values, nor would JSON5 automatically parse a RegExp out of a string. It would work similarly to how Dates work in JSON, where they are serialized into ISO 8601 format but date strings are not automatically parsed as Date objects.\n. I'm in the process of finalizing v1.0.0, so I've taken another look at RegExp support. I've been testing out an option for parse that will automatically find strings that look like regular expressions and parse them as RegExp objects and an option for stringify that will convert RegExp objects to strings.\nHere's what the parse API looks like.\njs\nconst result = JSON5.parse(\"{regex: '/a[b/c]d/i'}\", {regExps: true})\n// `result` is equivalent to { regex: /a[b/c]d/i } and { regex: new RegExp('a[b/c]d', 'i') }\n\nThe regex string must start with a slash and end with a slash, which is optionally followed by regular expression flags.\nThe second argument of parse can be a reviver function or a new options object. The options object can have a reviver property and a regExps property. If regExps is truthy, then each string will be tested to see if it conforms to the format described earlier, and if so, attempted to be converted to a RegExp object. If it cannot be converted, then the string will be returned.\nIf a reviver function is also defined, then it will be called after all regex strings have been converted to RegExp objects.\n\nHere's what the stringify API looks like.\njs\nconst result = JSON5.stringify({regex: /a[b/c]d/i}, {regExps: true})\n// result === \"{regex:'/a[b\\/c]d/i'}\"\n\nThe second argument of stringify can be a replacer function, an array of white listed property names, or a new options object. The options object can have a replacer property, a space property, and a regExps property. If regExps is truthy, then each RegExp object will be converted to a string, otherwise it will converted to an empty object.\nIf a replacer option is defined, then it will be called before all RegExp objects have been converted to strings.\nIf the second argument of stringify is an options object, then all subsequent arguments will be ignored. In other words, space must be specified in the options argument rather than as the third argument of stringify if the second argument is an object.\n\nIt has not yet been decided whether this feature will make it into v1.0.0. Please let me know what you think.\nThis is not an extension to the JSON5 document specification. It is only an extension to the API of this library. JSON5 implementations are not required to implement this API.\nYou can try this out by using npm install json5@regexps.. @aseemk Valid point about having differing implementations, especially since this is the reference implementation. This feature may be better left to another implementation.\nI'm still hesitant about allowing regex literals as I stated in my earlier rant under the heading Implementation Agnostic vs Implementation Specific.\n\nSide Note: Although Date('\u2026') is valid ES5, it returns a string instead of a Date, and Date.parse returns a number, so it would have to be new Date('\u2026') if we wanted to match the ES5 behavior. (i.e. Placing a JSON5 document into an ES5 script should Just Work\u2122.). Funny thing about that rant. I actually used that algorithm to implement this experimental feature.. I think the original wording is just as clear, if not, more so.\nStrings can be split across multiple lines; just prefix each newline with a backslash.\n\nI do think it would be good to replace 'newline' with 'newline character' however.\n. @abhisekp I'm not sure what you mean by \"the word 'prefix' is not correctly written.\"\n. I think most will understand that you prefix the newline character not the beginning of the next line. I'll let someone else weigh in on this before any movement.\n. This is some good work!\nI do see one issue just from looking at the code. It only treats \\n as a new line. In the vast majority of cases, this will suffice, but in the rare case where only \\r is used for new lines, your code will always report errors as appearing on line 1.\nPlease see the ES5 spec on Line Terminators and the JSON5 code that handles new lines in strings.\nAs for cosmetics, can you please convert the prefixed increment operators ++ to postfix and remove the space between them and their variables, e.g. lineNumber++ instead of ++ lineNumber. Thanks.\n. I've thought about this for a while today, and I came to the conclusion that determining what constitutes a new line is not the job of ES5, JSON, or JSON5, but it is a job for Unicode.\nRegardless of what whitespace and new lines are allowed in JSON5, errors should report line numbers based on what the JSON5 document (valid or not) would look like in a text editor.\nWe should use Unicode's Newline Guidelines (Section 5.8) for determining what characters (or sequence of characters) are new lines. Namely \\r\\n, \\r, \\n, \\x85, \\v, \\f, \\u2028, and \\u2029.\nAll that said, I think we should remove the changes to whitespace from this PR and keep that as a separate issue. I've got more to say on that matter anyway.\n. I think I prefer solution ii. We could write a thousand test cases that are invalid JSON5. I think we should focus on passing test cases for features and failing test cases for specific error messages.\n. Fixed by #103\n. :+1: \n. I'm not sure this is the right place to keep this diagram code. Perhaps you can post this on the Wiki?\n. Partially fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.\nCoveralls should be easy to implement since istanbul is already in use.. 51d03206a69b8fab3ac2a7a0658f8442bef4133f has 100% code coverage, but I'm going to skip coveralls for now.. At first I was opposed to this, but I've written plenty of code like 24*60*60*1000 for the number of milliseconds in a day.\nWhat's better?\njs\n{\n  ms: 86400000, // one day\n}\nor\njs\n{\n  ms: 24*60*60*1000, // one day\n}\nThe first example appears like it doesn't require the parser to do any math, but the parser already has to math to parse the number as base 10. The second example is easier to modify if you want to change it to e.g. 12 hours or 3 days.\n. I think @amulware, correct me if I'm wrong, was just using variables to represent numeric literals. For example, you could have:\njs\n{ offset: (10 + 3) * 2 }\nbut not the literal string:\njs\n{ offset: (base + increment) * stride }\nBut it is an interesting concept to declare variables in a JSON5 file. Maybe we should start a new discussion on that.\nAlso, see #91 for a discussion on why regular expressions have not been included in JSON5.\n. I'm glad we're getting some great discussions around this. That's what I was hoping for :smile: \n@aseemk\n\nI'd be okay with adding basic math operators. I would discourage adding **, etc., as those aren't standard ES5 either. (But I do appreciate them in CoffeeScript.)\n\nI totally agree here. Let's keep things ES5 compliant.\n@aseemk\n\nEven with these basic operators, though, it does e.g. make supporting JSON5 in other languages harder. E.g. what is 5 / 0? If we're to be consistent with ES5, it's Infinity. But in most languages, that'd be a runtime error. Or possibly an undefined-ish value.\n\nI'd alter that statement by saying that 5 / 0 is an error in most languages if they're treated as integers. ES5 doesn't have integers (all numbers are IEEE 754 floating point values) so this returns Infinity. If the numbers are treated as floating points, then most languages would return some form of IEEE 754 Infinity. (Python and Go are exceptions, however. Python always throws a ZeroDivisionError. The Go spec says it's implementation specific, but the official Playground throws a division by zero error. There are likely other exceptions, too).\n@piranna\n\nI consider RegExp data, too... ;-) They are the same as function declarations as far as they are not executed, but function declaration would be beyond the line too not only because they are language specific but also could be dangerous if executed (RegExp are not dangerous in that way).\n\nOh no. Now the RegExp discussion is bleeding into this one. :wink: I do see the parallels, though.\n@piranna\n\nInfinity is a valid float value in all languajes, including C/C++\n\nMost languages have a way to check for Infinity, but not all languages have a way of actually representing that value (e.g. a constant that represents Infinity or a function that returns Infinity). PHP 4.0 is an example of this.\n. @piranna \n\nThis operations will not be executed on runtime but when parsed, so there's no problem the implementation wrap the operations on a try-catch block to capture these exceptions and set the value to infinite \"by hand\". Python support both Infinite and NaN, so...\n\nNo one was saying that it can't be done in those languages. @aseemk's point was that more work would need to be done in those languages to support JSON5 with math features. In Python, you can't just parse a / and perform division on the operands. Like you said, you have to check whether the divisor is a zero and return float(\"inf\").\nThe more complex you make a specification, the more work that needs to be done to implement it, and the less it actually gets implemented.\n\nPHP sucks, but not so much... ;-)\n\nI know PHP supports NaN and Infinity at this point in time. I was referring specifically to PHP 4.0. And regardless of whether PHP sucks, it's still an extremely popular platform for web applications.\n. @piranna \n\nLol :-P Yes, there are parallels because it depends on the concepts of \"what is data\" and \"what is executable code\". After parsing we would get respectively a number or a RegExp object that both are not executables by themselves (a RegExp is a description that can be used to find some data, the same way a number can be used as an index on an array), so I would accept both. I would not accept functions because if they get parsed they are executables \"as is\", and there's almost no way to sanitize them and know they are secure (a RegExp could be bad written, but it's not a security thread or could erase data by itself...).\n\nSupporting functions is not just about security. You would have to expect the JSON5 parser be able to parse functions and implementations to be able to represent those functions on their native platforms. If someone wants to implement functions in JSON or JSON5, they might as well write a transpiler for ES5 into every other programming language.\nRegarding regular expressions, I wrote a little more about the subject. \n. @piranna \n\nYour last solution (map RegExp.toJson() to RegExp.toString()) so they got embebed inside strings is just what I'm doing in another project processing them with another data types and it works like a charm... :-D Maybe we could add and process the RegExp in the same way, storing them as strings :-)\n\nI'm open for discussions on serializing RegExps as strings. In fact, I've renamed and re-opened the issue. Let's keep further discussions there. Thanks.\n. I'm all for adding this functionality, and the code looks good at a glance. I'll look over it more closely later, but for now I'd just like to point out that this would set a precedent for adding NPM dependencies.\nHistorically, we've avoided those to make it easier for web developers to use JSON5. Granted, this PR only changes the CLI and not the core, so we could merge this now, but we should probably implement Browserify before we start adding more dependencies. I took a crack at it but ultimately had to revert it. If someone would like to pick up where I left off, that would be awesome.\n. We don't need to wait on Browserify for this PR. I would like to see some tests written for this though.\n. Partially fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.\nIt currently does not stream JSON5 input, but consumes it all at once, however the parser is capable of parsing streaming input with some API changes. It still uses JSON.stringify, so output is not streamed.. :+1: \n. This look great at a glance. I don't have time to vet this in depth right now, but I'll definitely take a look later. For now, I'll just leave a few comments in the code. Thanks for the great work!\n. I'd like to see some test cases using other number literals like NaN and Infinity and for cases like dividing by zero (1 / 0) and overflowing the operation with large numbers.\n. Thanks for this write-up. I agree with everything you've said. Here's what I'd like to see in this discussion:\n- Use cases (why we would implement this)\n- JSON5 document examples (how this would look in a file)\n- API (how we generate a document with constants)\nI can see how this might be useful in configuration files (similar to how LESS and SASS use them) but I'm struggling to see a data serialization use case.\nMy first thoughts on how this would look in a document is this:\njs\nvar e = 2.72;\nvar pi = 355/113; // using the new operator syntax in #111\nvar contact = 'Obi-Wan Kenobi <obiwan@jedicouncil.gov>';\n{\n  e: e,\n  pi: pi,\n  authors: [\n    contact,\n  ],\n}\nFor the API, I have some questions. The API wouldn't be able to generate a document that uses variables. It could declare them, but not use them without some special function.\nMaybe it would work something like this. Add another argument to stringify (or modify an existing one to use some kind of config format) and pass it an object of name/value pairs. The names must be valid identifiers or it will throw. Add a special JSON5 function (e.g. JSON5.useConstant()) that lets you use a constant name in your generated document.\n``` js\nvar options = {\n  quote_keys: false, // don't put quotes around keys unless required\n  quote: \"'\", // use single quotes\n  constants: {\n    e: 2.72,\n    pi: 355/113, // using the new operator syntax in #111\n    contact: 'Obi-Wan Kenobi obiwan@jedicouncil.gov',\n  },\n};\nvar doc = {\n  e: JSON5.useConstant('e'),\n  pi: JSON5.useConstant('pi'),\n  authors: [\n    contact: JSON5.useConstant('contact'),\n  ],\n};\nvar json5 = JSON5.stringify(doc, options);\n```\nFor the parse API, does it parse the constants into values before it gives it to the revivier, or does it notify the reviver that a constant was used?\n. The reason I didn't use the word const is because it's not part of the ES5 spec, so using it would break compatibility with ES5. It is part of the ES2015 spec though.\nAlso, JSON5.stringify doesn't produce valid JSON documents, it produces valid JSON5 documents.\nI'm still on the fence about whether the API should allow generating documents with constants, but we could certainly implement constants without it until there is demand.\n. > Wasn't it the intention that stringify produce valid JSON documents at\n\nleast originally, and JSON5 only offered more flexibility? At least I\nremember so...\n\nYes, but that changed with #32.\n. TBH, I didn't expect this to get implemented, but I thought it would be good to have a conversation about it. I'm in full agreement with @aseemk on this.\n. I think I might make this v0.5.0. I'd like to get the following PRs merged before v1.0.0:\n- [ ] #89: Browserify support\n  - [ ] #1: Unicode support\n  - [ ] #94: helpers.js file and fix for isWord leaking into public API\n- [ ] #84: --validate CLI option\n- [ ] #87: slim down npm payload\n- [ ] #105: CI improvements including coveralls\n- [ ] #108: streaming command line and yargs runtime dependency\nOnce we implement Browserify, we should be able to add in Unicode support.\n. @aseemk\nv0.5.0 is released, but I don't have permission to publish to npm. Thanks.\n. According to RFC 7159:\n\nAn object whose names are all unique is interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings. When the names within an object are not unique, the behavior of software that receives such an object is unpredictable. Many implementations report the last name/value pair only. Other implementations report an error or fail to parse the object, and some implementations report all of the name/value pairs, including duplicates.\n\nI don't think JSON5 should always output \"unpredictable\" JSON. However, if you would like to add that to your JSON5 files manually, you could do something like this:\njs\n{\n  note: 'THIS FILE WAS GENERATED BY A http://json5.org TOOL,\\\nEDIT THE .json5 SOURCE FILE INSTEAD OF THIS .json FILE',\n  anykeywhatsoever: 5,\n}\nThe JSON consumer would need to ignore the \"note\" property in this case.\n. This makes me wonder if JSON5 should preserve duplicate keys when compiling to JSON.\n. I'm still hesitant about this. Although JSON5 supports duplicate keys, keeping only the last one, outputting duplicate keys feels like promoting them, which is opposite to the stance that RFC 7159 takes.\nI'd like to see more discussion from others on this topic.\n. I'm not sure I follow. If your JSON5 file is invalid, then you'll get errors when you try to compile it to JSON. A JSON file generated from a JSON5 source file would not have any errors.\nIf you're talking about application errors not related to JSON syntax (e.g. the JSON consuming application expected a number instead of a string) can you provide an example where replacing comments with a space instead of stripping them would match up more closely with the source file?\n. Okay, it makes more sense after reading the README for strip-json-comments.\nComments are replaced with whitespace, meaning spaces and new lines where appropriate, to keep the lines and columns matching. Here's some examples:\n``` js\n{\n  // happy\n  \"earth\": \"day\"\n}\n{\n\"earth\": \"day\"\n}\n```\n``` js\n{\n  \"earth-day-2016\": / 4/22/2016 in ms / 1461308400000\n}\n{\n  \"earth-day-2016\":                       1461308400000\n}\n```\n``` js\n{\n  \"first-earth-day\":\n  / Earth Day was founded by\n     Senator Gaylord Nelson on\n     April 22, 1970 /\n  \"1970-04-22T00:00:00.000Z\"\n}\n{\n  \"first-earth-day\":\n\"1970-04-22T00:00:00.000Z\"\n}\n``\n. I don't think this makes sense for this project since JSON5 to JSON is not a one-to-one compilation even without comments. JSON5 documents are normalized to JSON as if you used theJSON.stringify` function.\nImplementing sourcemaps might be a better general option.\n. Thanks for the suggestion, but this breaks JSON5's compatibility with ES5.. LGTM. Thanks for the input. #108 needs tests before merging. If you would like to write the tests, it would be greatly appreciated.\nI'm going to close this issue since it's in essence a duplicate of #108. Thanks.\n. A similar solution has already been discussed in #52. The reason we haven't implemented this feature is because it would make JSON5 no longer compatible with ES5.\n. See #129\n. Closes #128\n. This sounds good to me. Thanks for putting in the work. Please see #131 for continued work and discussion.\n. I think you're the first person to ask for support for functions. What is your use case for this?\nAlso, the result of the string you trying to parse is not a valid JSON value. Just run the following code:\njs\nJSON.stringify({\n  local: { active: true },\n  effects: {\n    toggle: function (data, state, send, done)   {\n      this.local = !this.local\n    }\n  }\n}, null, '  ')\nAnd you'll get:\njson\n{\n  \"local\": {\n    \"active\": true\n  },\n  \"effects\": {}\n}\nNote that the function is missing from the JSON result.\n. If you're looking to parse JavaScript, you should look into Esprima, Acorn, and UglifyJS.\nParsing functions is out of the scope of JSON5. Thanks.\n. If you're parsing the JSON5, you can use the reviver argument in JSON5.parse. It works the same as JSON.parse.\njs\nJSON5.parse(text, function(key, value) {\n  if(value['address']) {\n    delete value['address'];\n    return value;\n  }\n});\nIf you're stringifying to JSON5, you can use the replacer argument in JSON5.stringify. It works the same as JSON.stringify.\nThere are two ways to use replacer, as an array containing the keys you want to stringify,\njs\nJSON5.stringify(data, ['name', 'age']);\nOr as a function that works just like reviver.\njs\nJSON5.stringify(data, function(key, value) {\n  if(value['address']) {\n    delete value['address'];\n    return value;\n  }\n});\nNotice you can use the same function for reviver and replacer to get the same results.\n``` js\nfunction addressFilter(key, value) {\n  if(value['address']) {\n    delete value['address'];\n    return value;\n  }\n}\nJSON5.parse(text, addressFilter);\nJSON5.stringify(data, addressFilter);\n```\n. Thanks for the bug report! I just published the fix, so try it out at let us know if you still have any issues.. Please see the v1.0.0 TODO list. If you are able to contribute to the spec, please do so on the beta branch.\nBeside completing the spec, I'm going to do a rewrite of the codebase because the current codebase is based on Crockford's implementation whereas the new codebase will be based on the ES5 implementation.. Please see the v1.0.0 Milestone. Many of the issues/PRs will be fixed with the codebase rewrite, and I'll close those once I've merged that in, however, the CLI enhancements still need to be written along with their tests.. v1.0.0-beta is live. Read the CHANGELOG to see the new features and fixes.\nUse it in your projects with:\nbash\nnpm install --save json5@beta\nUse it in your terminal with:\nbash\nnpm install -g json5@beta\nUse it in your browser with:\nhtml\n<script src=\"https://unpkg.com/json5@beta/dist/index.js\"></script>. @seagreen Thanks for the commendation. Here's the relevant section from the WIP spec regarding line and paragraph separators.\n\nParagraph and Line Separators\nLike JSON, JSON5 allows the Unicode code points U+2028 and U+2029 to appear unescaped in strings. Since ECMAScript 5.1 does not allow these code points in strings, JSON5 authors should avoid including them in JSON5 documents. JSON5 parsers should produce a warning when they are found unescaped in strings. JSON5 generators should escape these code points in strings.\n\nSo officially, JSON5 is a strict superset of JSON and a loose subset of ES5 (but only loose regarding line and paragraph separators). I updated that comment to reflect this now.\nI haven't reviewed the ABNF with the new changes in mind, so I've added that to the TODO list.. I'm also curious to know what everyone thinks about the Date and RegExp support I've added in experimental branches.. I forgot to document a new feature in the CHANGELOG.\n\nNew: stringify checks for a toJSON5 method on objects and, if it exists, stringifies its return value instead of the object. toJSON5 overrides toJSON if they both exist.\n\nThis is mainly useful in two cases:\n- When you want to convert an object to Infinity or NaN before stringifying.\n- When you want JSON5 output to differ from JSON output because reasons.. The latest draft of the spec is up at https://json5.github.io/json5-spec/. Make sure you refresh the page to get the latest version. The date should be September 28, 2017.\nI consider this the final version unless anyone finds anything wrong with it. Once finalized, it will say Standard instead of Draft, and the note about it being a draft will be removed.\nI appreciate any feedback.. @aseemk Good catch. I fixed that, added a JSON5Punctuator production that I missed, made it mobile friendly, and added a server script for development.. I've made several changes to the spec. Many of the changes are only formatting or rewording, but there are a few important changes.\n\nReworded the introduction to state that JSON5 is a superset of JSON and removed the part about it being a subset of ES5 (https://github.com/json5/json5-spec/commit/3b5c1f1417b70f9c157cc1341a25b99114f6008d)\nRelated to that, JSON5 doesn't add new data types to ES5, but it does add new data types to JSON, namely Infinity and NaN, so I removed that part too.\nFixed an error regarding what characters must be escaped in strings (https://github.com/json5/json5-spec/commit/932a7d4a1e9cddda39e7215d1e8fdae9fec64d03)\nReworded the parts about Infinity and NaN and added an example (https://github.com/json5/json5-spec/commit/9a6aa9cdf706fe8f4738220824f5e9285c84dba3)\nRefactored some grammar productions (https://github.com/json5/json5-spec/commit/f034fc028ff0cbcee444e915d497b798eab54275)\nThe diff is a little confusing, but essentially I added a JSON5Identifier, JSON5Null, and JSON5Boolean production to the lexical grammar and ensured that the syntactic grammar only references the JSON5 lexical grammar and not the ES5 lexical grammar.\nAddressed octal escapes in strings (https://github.com/json5/json5-spec/commit/33aee9941e56ed7a215cbc5c67498e54e6583aed)\n\nThat last change also required a bug fix committed in c952a0d6e0f6fc285461c52cdd2d0f4952f6249c and 78b403a9ef60602741065907b032040dd9b780a5, which is live on npm at json5@beta.. A while ago, I ran the beta against the v0.5.1 test cases to make sure there were no regressions and fixed the bugs I found. Now, I've run v0.5.1 against the beta test cases to see if there were any changes I forgot to document. I found a few and updated the CHANGELOG. Here's a summary. (Subpoints are additional information not included in the CHANGELOG.)\n\nNew: Unicode property names and Unicode escapes in property names are supported. (#1)\nExample: { \\u0061: true } and { a: true } are equivalent.\nCharacter and escapes can be mixed, so { abc\\u0064\\u0065\\u0066: true } and { abcdef: true } are equivalent.\nThe code points represented by the escaped character must still conform to IdentifierName, so the following will fail: { \\u0000: true }\nNew: In addition to the white space characters space \\t, \\v, \\f, \\n, \\r, and \\xA0, the additional white space characters \\u2028, \\u2029, and all other characters in the Space Separator Unicode category are allowed.\nNew: In addition to the character escapes \\', \\\", \\\\, \\b, \\f, \\n, \\r, and \\t, the additional character escapes \\v and \\0, hexadecimal escapes like \\x0F, and unnecessary escapes like \\a are allowed in string values and string property names.\nNew: When a character is not allowed in a string, stringify outputs a character escape like \\t when available, a hexadecimal escape like \\x0F when the Unicode code point is less than 256, or a Unicode character escape like \\u01FF, in that order.\nExample: '\\u0061\\u0009\\u000F\\u01FF' becomes 'a\\t\\x0F\\u01FF'\nFix: stringify properly handles the key argument of toJSON(key) methods. toJSON5(key) follows this pattern.\nRaise your hand if you didn't know this was a thing. :hand:\nFix: stringify accepts Number and String objects as its space argument.\nRelated but different: #154\nFix: In addition to a function, stringify also accepts an array of keys to include in the output as its replacer argument. Numbers, Number objects, and String objects will be converted to a string if they are given as array values.\nRaise your other hand if you didn't know this was a thing either. :hand:. Good question. The use of the word \"should\" has the same meaning as in RFC 2119.\n\n\nSHOULD   This word, or the adjective \"RECOMMENDED\", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.\n\nSo, no you should not rely on this behavior, especially since the JSON spec does not recommend that generators escape those characters and JSON5 parsers must be backward compatible with JSON.\nThe old Bikeshed version of the spec referenced this RFC, but the Ecmarkup version doesn't. I'll be sure to add that reference back in.. I just updated the spec with a clause about the keywords and a few other fixes and clarifications.. Apologies for the lack of updates lately. I've been busy with work and personal things. The reason I haven't released v1.0 yet is because I discovered a bug in the reference implementation, and I think it's important to release a working reference implementation along with the spec.\nI've already fixed the bug, so v1.0 of the spec and reference implementation should be ready to be released after the READMEs, and CHANGELOGs are updated.\nAfter v1.0 is released, I will continue work on refactoring parse to use Parser and Lexer classes, which will facilitate the development of modules that must inspect JSON5 code, e.g. an ESLint plugin.. @MartinMuzatko At this point in time, there is no intention to make JSON5 a W3C or TC39 spec, and there isn't really a need to. The Source Maps spec is just a Google Doc, but it's in use by almost every modern transpilation software today, and I plan to implement it into JSON5 at some point too.\nAs long as everyone agrees with the official JSON5 spec, it will be a standard regardless of whether it's endorsed by W3C or TC39.. https://github.com/json5/json5-spec. It's not really a formal language, but it's the same convention used in the ES5 spec.. The problem with formal grammars is that, while they're often meant for machine processing, the grammars don't always support the nuances of the languages they parse.\nFor example, ECMAScript allows Unicode escape sequences in identifiers as long as the unescaped value can also be parsed as a valid identifier. In other words:\njs\nvar a;      // valid identifier\nvar 0;      // invalid identifier (cannot start with a number)\nvar \\u0061; // valid identifier (\\u0061 = 'a')\nvar \\u0030; // invalid identifier (\\u0030 = '0')\nThis is not something a lot of, if any, language grammars natively support. Take for example this ECMAScript parser written with ANTLR. Its IdentifierStart production will parse any Unicode escape sequence regardless of whether or not it's a letter, $, or _.\nI proved this by forking it and adding a test case that should fail and then building it on Travis CI. All tests passed.\nTalking specifically about JSON5, its grammar references some ECMAScript 5.1 grammar productions, which would have to be translated to a formal grammar language as well.\nYou're welcome to make a first go at writing an ABNF for JSON5.. @dreftymac This is all interesting information, but what does this have to do with JSON5?. @dreftymac BTW, I answered that StackOverflow question because the other answerers don't seem to understand the YAML spec.\nhttp://stackoverflow.com/a/42194903/164430. I'm on full agreement on this. :100:. I can do the command line merge, just let me know if you see anything I missed.. Clever :wink:. These are the only items included in the json5 package.\n\nCHANGELOG.md\nlib/\nLICENSE.md\npackage.json\nREADME.md\n\nThis is accomplished by the files: [ \"lib/\" ] entry in package.json.\nThe rest of the files are always included regardless of .npmignore.\nThe test directory does not appear in my node_modules/json5 directory. How is it that it appears in yours? Are you using a version < v0.5.0?. It would be great if you could clarify a few points on the web-page which are not obvious.\n\nCan multi-line comments be nested? (I assume they may not be nested)\nNo.\nIt says numbers may be prefixed by +. Does this also apply to NaN and Infinity? (I assume yes, +NaN and +Infinity are valid)\nYes.\nNumbers may have leading or trailing decimal separator. Is it allowed to have both leading and trailing decimal separator? Meaning: Is . a valid number? (I assume it is not)\nNo.\nStrings can now be single-quoted. What escaped characters are allowed in single-quoted strings? \\'? Is \\\" allowed in a single-quoted string? And is \\' now allowed in a double-quoted string? Any other extensions? EDIT: JSON allows an escape slash: \\/, does ECMAScript? What about \\v (not in JSON, but in ECMAScript).\nIn strings, the following characters have special meaning when preceded by \\: b, f, n, r, t, u, \\n (U+00A0, line feed), \\r (U+00D0, carriage return). When the following characters are preceded by \\, they are treated as if they weren't: ', \", \\, /. (Meaning \"\\'\" is the same as \"'\".) This applies to both single and double quoted strings.\nObject keys are, in JSON, strings. Can a multi-line string be used as a key in JSON5?\nYes.\nUnquoted object keys - is there any chance you can limit this to an explicitly specified character set without relying on some unicode support? Our library (https://github.com/taocpp/json) tries to be dependency-free and having to deal with unicode character properties seems to go against the simplicity of JSON (and hopefully JSON5). In fact, I'd consider alnums + _ + $ (without a leading cipher) to be good enough, if you want throw in more characters explicitly like -, ., ... but Unicode is way too much IMHO.\nCurrently JSON5 only supports unquoted property names that follow the regex pattern /[$_A-Za-z][$_A-Za-z0-9]*/. To better align with ECMAScript 5, support for certain alphanumeric Unicode characters has been proposed. (- and . would not be included.) For an example of this implementation, see jsonext, which aligns with ECMAScript 6. Its build.js file generates regular expressions that match the Unicode characters allowed in property names.. Short answer: No.\n\nLong answer:\nIn ECMAScript 5, a leading zero indicates an octal number if it is immediately followed by one or more numeric digits. In the literal 00, the first 0 is treated as an indicator that the number is octal (base 8) and the second 0 is treated as the actual octal number, which results in 0.\nIf you try this in ECMAScript 5 in strict mode, you'll get a syntax error indicating that octal literals are not allowed. And regardless of whether you're in strict mode, you'll get a syntax error if you try things like 00.0 or 00e0.\nLike strict ES5, neither JSON nor JSON5 allow octal literals, so 00 is an invalid token. Interestingly in ES5, 08 should be a syntax error (even when not in strict mode) however many parsers just interpret it as the number 8, willfully ignoring the ES5 spec.. Here's another discrepancy between JSON5 and ES5 you may not be aware of. There is no such thing as a negative numeric literal in ES5 like there is in JSON and JSON5.\nIn ES5 -1 is treated as the two tokens - and 1 with the first being a unary negation operator and the second being a numeric literal. This means that - 1 is also a valid expression (note the space between - and 1). This also means that - - - 1 is a valid expression the same as -(-(-(1))). (Note that ---1 is not valid because -- is a different operator that cannot be applied to literals.)\nIn JSON and JSON5, there are no unary operators, so - 1 would throw a syntax error. The - must immediately precede the 1 with no characters in between. The same goes for + 1 in JSON5.. Okay, so I've gotten myself in a tough spot now. A draft of the JSON5 spec exists at https://github.com/json5/json5-spec, but the information I've been giving you is based on the reference implentation of JSON5, which doesn't completely follow the spec.\nIt is a goal of mine to align the reference implementation to the spec, but I haven't found the time. I think effort would be better used by aligning the reference implementation to the spec rather than writing a new spec based on the implementation. When complete, this would be JSON5 version 1.0 and the spec and reference implementation would likely be frozen at that point (with occasional bug fixes).\nHere is the only discrepancy I can think of between the reference implementation and the spec, but there may be others. According to the spec, strings allow any character to be escaped unless it has a special meaning. The characters that have special meaning are: b, f, n, r, t, v, x, u, 0, 1 through 9 (which are errors), \\r (carriage return), and \\n (line feed). Any other character is treated as the character itself without the preceding \\. (For example, '\\a' is the same as 'a' just like \"\\'\" is the same as \"'\".) Taking after JSON, the JSON5 reference implementation only allows a subset of escapes and v and x aren't even included among them.\nThere is also some work to be done on the spec as listed at https://github.com/json5/json5-spec/issues/1. Here's another discrepancy. The whitespace allowed in the spec does not match the whitespace allowed in the reference implementation. Namely \\u2028 and \\u2029 are valid whitespace characters in the spec, but they are not in the reference implementation.\nIf you take the implementation of jsonext and comment out all of the features added in ES6, you get a JSON5 implementation that follows the official JSON5 spec (with Unicode support). Those ES6 features are binary and octal literals (0o777 and 0b1010), template strings (`abc`), and Unicode code point escapes ('\\u{20BB7}').. That ABNF looks like a good starting point. NBSP is valid whitespace in JSON5. Section 7.1 explains why the BOM is allowed after the start of the document. 1-9 are not valid escape characters but 0 is.\nHere are the character escapes in strings and how they should be handled. Each \"sequence\" refers to the character(s) immediately following the \\ (U+005C) character.\nSequence        | Result | Notes\n----------------|--------|----------\nb (U+0062)    | U+0008 | Backspace\nt (U+0074)    | U+0009 | Horizontal tab\nn (U+006E)    | U+00A0 | Line feed\nv (U+0076)    | U+000B | Vertical tab\nf (U+0066)    | U+000C | Form feed\nr (U+0072)    | U+000D | Carriage return\n0 (U+0030)    | U+0000 | Nul character\n1 through 9 (U+0031 through U+0039) | Error  | Octal escapes are not supported\nx (U+0078) followed by two hex digits | The character with the code point of the hex number | For example \\x61 becomes a. It is a syntax error if the x is not followed by two hex digits.\nu (U+0075) followed by four hex digits | The character with the code point of the hex number | For example \\u0061 becomes a. It is a syntax error if the u is not followed by four hex digits.\nU+00A0          | Nothing | Escaped line feed results in an empty string\nU+00D0 U+00A0   | Nothing | Escaped carriage return followed by a line feed results in an empty string\nU+00D0          | Nothing | Escaped carriage return not followed by a line feed results in an empty string\nU+2028         | Nothing | Escaped line separator results in an empty string\nU+2029         | Nothing | Escaped paragraph separator results in an empty string\nAny other character | The character itself | For example \\a becomes a, \\\\ becomes \\, and \\\" becomes \"\n*Whether escaped line and paragraph separators should be allowed as line continuations is still up for discussion. See #70, which discusses these characters but does not touch on whether they should be treated as line continuations when escaped in strings.. * Disallows trailing commas on empty arrays/objects. OK? ([,], {,})\n\n\nThis is correct. A comma can only appear after an object member or array element.\n\n\nAdding \\0 and \\xXX as escape-sequences makes sense thinking about bytes, but JSON strings are required to be valid unicode strings - and those may not contain embedded nul-bytes IIUC. What is the intended semantics of those? Or does JSON5 allow \"binary\" strings, meaning any byte-combination is allowed? And if that is the case, what is the semantics of escaped surrogate pairs?\n\n\nThe only Unicode code points that are invalid are values U+D800 through U+DFFF and values larger than U+10FFFF. This means that \"\\0\", \"\\x00\", \"\\u0000\", \"\\xFF\", and \"\\u00FF\" are all valid Unicode strings in ES5 and JSON5 (and the \\u versions are valid in JSON). So it's technically possible to store binary data in a string this way.\nAlthough it's possible to store binary data as a string of character escapes, it's recommended to encode the data as Base64 and store the result as a string.\nThe string '\\uD800' doesn't represent a valid Unicode string because it's only half of a surrogate pair. JSON5 doesn't define how to handle this situation. I would encourage implementations to either throw an error or replace the character with U+FFFD.\nHistorically, strings and byte arrays were equivalent. The string 'abc' was stored in memory and on disk as the byte array 61 62 63. Likewise, '\\x81\\x82\\x83' was stored as 81 82 83. So it made sense to represent byte arrays as strings. However, once Unicode became popular, strings started being stored in memory as UTF-16, so 'abc' became 00 61 00 62 00 63 and when stored on disk or sent over the network, they were usually represented as UTF-8, so '\\x81\\x82\\x83' became C2 81 C2 82 C2 83.\n\n\nShould the grammar be committed somewhere?\n\n\nYes, please submit a PR to https://github.com/json5/json5-spec. Thanks.. * The grammar doesn't allow it (yet), but I guess a single-line comment is allowed to be at the end of the input without an explicit eol? (complete input exampe: \"foo\" // a string - no newline anywhere)\n\nYes.\nAre negative (or explicitly positive) hexadecimal values allowed? -0x1234 or +0x1234 instead of just plain 0x1234?\nYes, and it's a bit of a funny story: #36. I recommend running your library against the JSON5 test suite at https://github.com/json5/json5-tests.. This conflicts with our goal of having JSON5 be a strict subset of ES5 that adds no new data types.. Thanks for the suggestions, but this goes against JSON5 being valid ES5.. I saw this proposal too. I think it would be a nice addition to JSONext, a spiritual successor to JSON5, if it lands in a version of ES.. JSON5 is able to stringify objects, arrays, strings, numbers, Booleans, and nulls. Anything else, including functions and symbols, should return undefined. It should only throw when you have a circular reference or when the replacer argument is truthy but neither function nor array.\n\nWhat are you passing into stringify that is causing it to throw, and what is the error message?. I see where the error is now. Thanks.\nI might patch this soon if it's an easy fix, but in the meantime, you could use JSONext. It supports JSON5 syntax but also supports Unicode keys and includes some ES6 features. It doesn't suffer from this bug as you can see in this updated example: https://jsfiddle.net/j1156ewj/2/. Fixed in 35269daf8c8dd257796c1f1dc768bd25175f2c58.. I just released v1.0.0-beta which has a --validate CLI option.\n```bash\nnpm install -g json5@beta\njson5 --validate my-file.json5\n```\nIt will output an error if the file is invalid or nothing if it is valid. See json5 --help for more information.\nTo validate with the API, you can just use JSON5.parse and see if it throws.\n\nThere is no CLI feature for formatting JSON5, but you can use the API to do it:\njs\nconst json5 = fs.readFileSync('my-file.json5')\nconst value = JSON5.parse(json5)\nconst formattedJSON5 = JSON5.stringify(value, null, 2)\n\nI'm also considering writing an ESLint plugin for JSON5, and maybe a \"Try JSON5 Online\" page.. Easy fix in the grammar too:\n```\nJSON5Punctuator :: one of\n    ( ) { } [ ] : ,\nJSON5Text :\n    ( JSON5Value )\n    JSON5Value. Fixed in 687582810ec353c2333b02bd1036a0e4398d73ca.. This is possible in the beta.\nbash\nnpm install -g json5@beta. Thanks for the suggestion. This has been discussed in #55. Please continue this discussion there.. Thanks for the suggestion. This has been discussed in #52. Please continue this discussion there.. ",
    "aseemk": "Great work investigating this!\nIf you've already prototyped and profiled implementing this directly, I'd say that's a very appealing option. No dependency means this continues to be easily portable (e.g. in the browser).\n:thumbsup:\n. Nice @rlidwka, thanks!\nI agree re: browserify (we use and love it at FiftyThree), but I think there's still something to be said for having a simple drop-in file for developers who aren't knowledgeable about these tools. Maybe it's not worth worrying about that audience in this case though. We could also always provide a browserify-built distribution, either in the repo or via GitHub releases/downloads.\n. Great point! Thanks.\n. Great point!\nLooking at your hexadecimal patch, this should be straightforward to do, too, yeah? When we start with a 0, if the next character is a digit, throw an error. WDYT?\nIt might be nice to look into exactly what the other implementations do, to see if there are edge cases we need to account for.\nSorry, I'm completely busy in my day job right now, but I hope to take a look into this and other issues soon. Thanks for all the help!\n. Great catch! I agree with you \u2014 let's disallow leading 0's to avoid confusion.\n. I'll update our eval tests to use strict mode (issue #14), and then I'll pull in your commit eab3058cd8. =)\n. Pulled. Thanks again Max!\n. Great point.\nSomeone pointed me to JSON3, which is still a regular JSON implementation, but which serializes Date objects to ISO 8601 date-time strings.\nInterestingly, it seems it doesn't do anything special to parse the generated strings back to Date objects. But maybe it's fine for that to be application-level logic, not sure.\nI thought maybe serializing to Date(...) could be an idea, but it turns out that in ES5 (see link above), calling Date(...) without new is actually supposed to ignore the parameters and always return the current date-time.\nThat leads to the thought of serializing to new Date(...), but that strikes me as a bad idea, putting object construction in a data format.\nSo maybe the best thing to do is to follow JSON3 in at least serializing dates to a standard format. What do you think?\n. It also seems that V8 (in Node and Chrome) does this natively too:\n```\n\nJSON.stringify(new Date())\n\"2012-05-29T04:21:20.031Z\"\n```\n\nSo this is probably the right thing for this JSON5 parser to do too?\n. I think it's for convenience, when Date instances are nested within objects or arrays.\n. Indeed -- but that's not always convenient to do when the Date is nested. =)\n. Actually, I just realized that we've been talking about serialization, and this JSON5 implementation defers to the regular JSON.stringify() for serialization, so it'll already do this in V8.\nNeed to investigate whether there are still issues there that could be improved, but in general, I'd love to output regular JSON if possible. JSON5's purpose is really to make JSON more write-/maintain-friendly.\n. Someone on the Node.js thread pointed out this great gist:\nhttps://gist.github.com/2504336\nSince JSON5's parse() is built off of Douglas Crockford's own parser, it too supports a reviver argument, so that helper code will work with JSON5 too. =)\nLet's keep in mind though that the goal of JSON5 is to make writing JSON easier. I'm not sure that ISO 8601 strings are the most human-friendly way to write dates, but I'm not sure that introducing new types is a good idea, either.\n. Yes, that's a fair point, thanks. I'm hesitant to introduce syntax that's no longer \"just JS\" though.\nThe reviver example linked above though gives me another idea \u2014 we could have an option to e.g. auto-parse Dates, and the reviver could simply try calling Date.parse(str) on every string value. So you could write dates in any human-readable format that Date.parse() recognizes, like \"May 29, 2012\" or \"6:08 PM\".\n. Definitely, thanks Marco!\n. @shish, thanks for the comment. You're right that JSON5 probably shouldn't specify arbitrary or open-ended date string formats.\nI don't think using advanced types like that is a good either, though. The purpose of JSON5 is to be human-friendly when writing, and having to specify such things to help the machine parse your data defeats that purpose. =) It also greatly muddies the spec if we start reserving keys.\nLet's keep things simple here and stick to the \"no new data types\" philosophy, and for developer convenience, this JS implementation will add an option to auto-try-parse all strings into JS Date objects, via @polotek's reviver.\n. Folks, just a heads-up that I started a JSON5 google group:\nhttps://groups.google.com/group/json5\nIf you're interested in news and updates to JSON5, it'd be great to have you join. Cheers.\n. Very interesting, @rlidwka! That's good to know, but in this case, the native Date#toJSON() already outputs an ISO 8601 string (and not an {type: \"Date\", data: \"ISO 8601\"} object), so we probably can't expect that to change.\n. I'm not sure personally. I agree that fortunately, there is a simple workaround (reviver as mentioned), but I think lots of good arguments have been made in this thread that adding some type of support aligns with the goals of JSON5: to help people write dates by hand. Tough call!\nLet's keep this issue open. I think I'm still open to pull requests that give some implementation a stab and can demonstrate the value.\n. I have the same opinion here as https://github.com/json5/json5/issues/91#issuecomment-332359187.. Thanks guys for raising this issue.\nI wasn't aware that npm link doesn't work on Windows; I'll update the documentation. (npm install is actually all that's needed, but npm link does that plus symlink it globally if you want to use it elsewhere. Not a requirement.)\n@ajlopez, it's good to know that node test\\via-eval runs without a hitch, but that doesn't actually run the tests \u2014 it just defines them. It seems the problem is running Mocha.\nCould you try running Mocha directly? Install it globally first via npm install -g mocha, then run mocha --ui exports --reporter list?\n. Great! But that made me realize what may be up -- Mocha was never installed locally, I'm guessing. If you run npm ls in the project directory, does it show anything?\nIf not, just run npm install (I updated the documentation to list this instead of npm link), then npm should be able to find the local mocha binary just fine. You can choose to npm uninstall -g mocha if you like then.\n. Interesting. Npm is indeed supposed to include local binaries in the PATH when running scripts like npm test.\nCould you echo %PATH% and see what it says? Could you also print the contents of node_modules\\.bin?\n. Ah, that's awesome! Great to hear.\n. Awesome stuff \u2014 thanks! I'll try to take a look at this later tonight. \nQuick request: would you mind adding a few non-hex regression test cases, like decimals and negatives and exponents?\n. Merged! (GitHub doesn't detect it since I rebased.)\n. Very interesting. The native JSON.parse() doesn't like:\n```\n\nJSON.parse('.5')\nSyntaxError: Unexpected token .\n```\n\nI think this is another good human-friendly feature to have, but I'd love to learn why regular JSON doesn't allow it, whether there's any good reason for it or it's just yet-another strictness/simplification decision.\nThanks for the patch though! If there's no good reason against it, I'm definitely down to merge. =)\n. Cool, merged for now, and we can always revert if there's a good reason against this. Thanks again!\n. Thanks!\n. Great catch. =)\n. Oooh, very interesting! I was going to say, \"are we sure we want trailing decimal point support?\" But a quick test reveals that it's already implemented before your leading decimal point patch (where I had assumed it came from).\nShould this be considered a bug rather than a feature then? Is there ever good reason to use it, and is it ever used in practice (given that e.g. JS only has doubles, not ints)?\n. Btw, thanks for bringing this discrepancy to light, and great catch!\nI'm on the fence about this, because it is valid ES5. Super interesting that the native, standardized JSON.parse() rejects trailing decimal points \u2014 at least in V8 \u2014 while Douglas Crockford's json_parse.js doesn't. Wonder if either was by design or if they're unspecified implementation differences.\n. No prob. =) Thanks for pointing out that JSON by design doesn't allow trailing decimals. I'm inclined to not allow them either, since there doesn't appear to be any good reason to \u2014 what do you think?\n. My thinking was that it might be wise to \"pick our battles\" \u2014\u00a0every deviation from the original JSON spec means a higher barrier/friction for adoption.\nChanges that add significant convenience or usability (like trailing commas and comments) are worth adding. I'm not sure that trailing decimals add any value along either of those lines.\nYou are right that ES5 allows them, but JSON5 just needs to be a subset of ES5; it doesn't need to allow everything that ES5 does.\nIt's a close call either way, and that's why I'm leaning towards disallowing them simply to err on the side of keeping the changes purposeful and meaningful.\n. Cool. I'll add support for \"negative\" ES5 test cases (issue #15) and then I'll pull in these test cases to ensure that we revoke them.\n. Yep \u2014 this in invalid JS too:\n```\n\n{1:true}\nSyntaxError: Unexpected token :\n```\n\nUnquoted keys have the same rules as variables (\"identifiers\"). Here's a reference:\nhttps://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\nI'll update the readme to be clearer about this.\n. No worries. =)\n. Yes, you're right @rlidwka:\n```\n\n{1:true}\nSyntaxError: Unexpected token :\n({1:true})\nObject {1: true}\n```\n\n(Interestingly, the first case gives that syntax error in Chrome, but not Node.)\nThat we reject this is currently expected, because I was under the impression that ES5's spec on object keys applies the same rules for unquoted keys as it does to variable names (hence the link I shared above).\nIf it's valid ES5 though, perhaps we should allow this... It'd be nice to confirm that this is allowed per ES5 though, not just an \"it-so-happens\" behavior of existing implementations.\n. Yep, I'm aware of the ambiguity, I was just surprised that two different instances of the same JS implementation treat the ambiguity differently.\n. Done:\nhttps://github.com/aseemk/json5/compare/ce264b5%5E...ce264b5\n. Cool, @MaxNanasy has already done this: MaxNanasy/json5@38414028; pulling in.\n. @Midar, did you check out the discussion on pull request #9?\nhttps://github.com/aseemk/json5/pull/9\nJSON doesn't differentiate between ints and floats \u2014 it only defines a single \"Number\" type, and indeed, same with JavaScript \u2014 but is it the case that JSON implementations in other languages return specific types?\n. Good to know. I think you've made a reasonable case for allowing it. =)\n. Happy to help! ;)\n. Thanks for the nudge! Sorry there's been no progress on this; I've been quite busy. I can try to get to this over the holidays, but if you'd like to send a pull request, feel free! Even if it just updates the readme (but in that case, it'd nice to call out a TODO for this implementation to support it).\n. Released in 0.2.0 FYI!\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\n. Uh oh, we've duplicated some work \u2014 I just implemented this as well! =P\nHope you don't mind if I don't take yours \u2014 I've implemented it slightly differently. Significant experience with CoffeeScript's (and Streamline's until recently) require() hooks have taught me that modules shouldn't auto-register require() hooks, as this can lead to local dependencies overwriting global state, and potential version conflicts in the future. So I've implemented it as a separate file, thus requiring a separate require.\nI appreciate your support nonetheless!\n. Great catch, thanks!\n. @williamwicks: Are you saying you specifically want the array to contain undefined elements? The undefined type itself is not part of JSON. You can return null elements though even in regular JSON:\n``` js\nJSON.stringify([,,,])\n\"[null,null,null]\"\n```\nDoes that work fine for you?\n. That's a good point about the representation changing, but ultimately I think what this boils down to is adding the notion of undefined to JSON5. That's probably unlikely to happen, unfortunately, since most languages don't have a concept for it vs. null.\n(This also fits the \"adds no new data types\" part of the mission statement.)\nAnd without undefined, supporting sparse arrays using null doesn't seem like a good idea, either, since that'd differ from the semantics of JS.\nSo ultimately it seems like your best bet is to explicitly include null elements in your array. WDYT?\n. Lemme re-open this case for consideration.\n. Very interesting point @jordanbtucker! But I'm not sure I totally buy this argument:\n\nIf JSON5 allowed leading commas and empty values, old JSON files that used to throw would no longer do so, which could introduce silent and/or hard to find bugs.\n\nBecause there are plenty of examples where invalid JSON (that would throw) is valid JSON5 \u2014\u00a0e.g. unquoted keys, comments, even trailing commas as you mention. =)\n\u2014\nI do agree that this still feels like it'd implicitly be adding a new data type. Your suggestion of leaving the element types unspecified/\"empty\" is an interesting one though, @williamwicks.\nOn the notion of round-tripping, @jasons-novaleaf, I'm still a bit unconvinced, because both native JSON and JSON3 fail the round-trip test here too. So this isn't new to JSON5.\nAt this point, I'm in agreement with @jordanbtucker that I don't think we should add this.\n. Wow, looks like the CNAME file used to register custom domain names was deleted by GitHub when I went to edit the page using GitHub's automatic page generator.\nI've manually re-added the file [1], though the DNS change doesn't seem to have been picked up or propagated yet on GitHub's side. Hopefully it does soon.\nI've also emailed support letting them know of this unexpected issue. Thanks for the catch, Max \u2014\u00a0much appreciated.\n[1] https://github.com/aseemk/json5/blob/gh-pages/CNAME\n. Yep, it's back up now. It was indeed down earlier since the CNAME file had been deleted. Thanks guys.\n. Hey @Midar, apologies if I'm misunderstanding, but let me answer your question at the bottom first: the behavior for single quotes in the ES5 spec, as far as I know, is identical to double quotes. This is not like PHP or similar where escaping rules are different for single- vs. double-quoted strings.\nMaybe the confusion stems from the fact that Node is outputting the raw string value, when maybe you mean to be outputting the string that the user sees. Try using console.log() for that instead. Here's an example:\n```\n\nconsole.log('\\foo')\n\noo\n\nconsole.log('\\e')\ne\nconsole.log('\\e')\n\\e\nconsole.log(\"\\foo\")\n\noo\n\nconsole.log(\"\\e\")\ne\nconsole.log(\"\\e\")\n\\e\n```\n\nSeems to be working the same on my end and as expected. What do you think?\n. No problem \u2014 glad we were able to resolve this. =)\nYou ask a good question. The grammar on json.org doesn't seem to support a backslash followed by anything other than the whitelisted characters (of which 'e' is not one), but V8's implementation and Douglas Crockford's json_parse.js implementation (from which this JSON5 implementation is built) both seem to allow such characters:\n```\n\n\"\\e\"\n'e'\nJSON.parse('\"\\e\"')\n'e'\nJSON5.parse('\"\\e\"')\n'e'\n```\n\nI'll look into what Firefox does, but later when I get some time, I'll also look into whether the actual JSON and ES5 specs are more precise in the expected behavior either.\nInformally, I think either behavior you choose is okay \u2014 \\e is not a recognized escape sequence, and the correct way to input backslash-e is \\\\e.\n. Ah, true \u2014 the grammar on json.org doesn't support \\e, so that implies it should be rejected.\nYou're right, so unless the ES5 spec states differently, JSON5 should be the same in this regard. I think I'll leave this JS implementation the way it is in order to be bug-for-bug compatible with JS JSON implementations today, but rejecting is totally reasonable too.\nThanks for bringing this to light!\n. > Does that mean an identifier is allowed to start with a Unicode letter?\nYes, it does.\nThis is the one part of the spec I haven't totally understood and digested, but there seems to be different \"categories\" of Unicode characters, and Unicode \"letters\" are allowed as the first character just like regular letters. Unicode \"digits\" can be used after the first character.\n\nAre the following valid identifiers?\n\nYep. Node confirms this too:\n```\n\n{\u00e4bc: \"a\"}\n{ '\u00e4bc': 'a' }\n{\\u00E4: \"a\"}\n{ '\u00e4': 'a' }\n```\n\nHope this helps!\n. Very interesting! Thanks for that catch.\nAnother way to compare this then is as regular variable names \u2014 unquoted object keys are (supposed to be) bound to the same restrictions as variable names, with the one loosening up that reserved keywords are allowed.\n```\n\nvar \u00e4 = false;\n\u00e4\nfalse\nvar \\u00E4 = true;\n\\u00E4\ntrue\nvar 1 = false;\n[SyntaxError]\nvar \\u0030 = false;\n[SyntaxError]\n```\n\nAnd indeed as per the spec, Unicode digits (incl. escape sequences) are not valid as the first character.\n. Both are great ideas.\nThis module already has a bunch of test cases, FWIW: https://github.com/aseemk/json5/tree/develop/test Let me know if you find those useful.\nFor the list of parsers, maybe the wiki is a good place to start \u2014\u00a0I'll do that right now. =)\n. How's this? https://github.com/aseemk/json5/wiki/In-The-Wild\n. You know, you're technically right, and I used to go by that too, e.g. when designing REST API responses, but every major JSON parser I've come across supports any top-level value, not just object or array \u2014 including JavaScript's native JSON.parse() and Douglas Crockford's json_parse.js. So I've kept that compatibility with this JSON5 implementation.\nIf you'd like to follow the formal definition, one thing you could do is just wrap each test case in [], and make sure that every successfully parsed array has length exactly 1.\n. Makes sense. =)\n. Sorry, I meant your rationale for only allowing objects or arrays makes sense \u2014 given the context you describe.\nI have indeed seen e.g. APIs that return primitive values, calling it JSON, so developer expectations could swing the other way too, though. Maybe make it an option? (Though adding options is never a great first resort.)\nIf I had to choose one or the other, I would allow it given that developers probably know what data type to expect if they're parsing JSON. E.g. an API response, a config file, test case data, etc.\n. Awesome! You're definitely welcome to add it to the wiki \u2014 and feel free to reword it if you think it makes sense.\nNot a bad idea to explicitly specify that any value can be the top-level value. I'd like to keep the readme overview minimal, but I've been thinking this deserves a more thorough spec and/or FAQ at some point, so I'll add it there. Thanks for the suggestion!\n. Wiki looks great, thanks! Mind if I tweet it out? =)\nA formal spec w/ EBNF syntax is definitely worth doing at some point. I don't know EBNF, so I'd probably need some help on it. =)\nRe: newline behavior \u2014 very interesting! Indeed that's what Node/V8 seems to do, which I wouldn't have expected. The spec seems to suggest that only the newline should be stripped, which is indeed what I've done in this implementation. Let me see what other JS engines do.\n. I actually agree w/ you in terms of what would be more helpful/common, but that prevents you from being able to add any whitespace to a string after the newline.\nI also ran into this same issue with CoffeeScript, FWIW, which I believe was meant to mimic the JS spec: https://github.com/jashkenas/coffee-script/issues/610#issuecomment-2053479\n. Got it. That's what I expected from the spec. Btw, tested in Chrome and it behaves the same as Node, which I would expect \u2014 they use the same JS engine (V8).\nV8 also has deviates from ES5 in at least one other way (\"noctal\" numbers are allowed in strict mode). I'm inclined to adhere to the ES5 spec here, even though I realize it could be friendlier...\n. I think filing a bug report with V8 is a totally reasonable thing to do. Want to lead that charge? =)\nYou're right \u2014\u00a0that's another bug. Thanks.\n. I think there's value in being able to break a string up across multiple lines, even despite those points, but let me chew on it.\n. The + operator starts getting away from data-only; I'd like to avoid that. (Edit: sorry, should clarify. E.g. it starts to suggest that \"foo\" + 5 is valid, or \"foo\" + [...], etc.)\n. @Midar: @MaxNanasy acutely pointed out that we were both testing this wrong \u2014\u00a0unrecognized escapes like \\e are correctly rejected by JSON5. The backslash needed to be properly escaped when we were testing it.\n(It's just regular V8 that accepts arbitrary backslash escapes.)\n```\n\n'\\e'\n'e'\n'\"\\e\"'\n'\"e\"'\n'\"\\e\"'\n'\"\\e\"'\nconsole.log('\"\\e\"')\n\"\\e\"\nJSON.parse('\"\\e\"')\nSyntaxError: Unexpected token e\nJSON5.parse('\"\\e\"')\nSyntaxError: Bad string\n```\n. Good question and thanks for the nudge!\n\nI haven't taken any action yet, but instead of dropping newline support altogether (I think there's value in keeping it, e.g. for a build tool where inconsistency between browsers isn't an issue), how about I just update the documentation to explicitly call out this behavior for now?\nIn particular, is it good enough if the documentation encourages only using newline support like this?\njs\n{\n    this: \"is a newline \\\nstring where each newline backslash \\\nis preceded by a space, and \\\neach newline explicitly begins \\\nwith *no* spaces.\"\n}\nUsing newlines like this appears to work consistently across all browsers, and still adheres to the ES5 spec. Would that work for you?\nOptionally or additionally, perhaps the compiler could warn or throw an error if it encounters newline usage not like this. But that might be unnecessary.\n. Hey @Midar, sorry for the delay! But good news: this was fixed in V8 (to match other browsers and the ES5 spec) last year, and even Node actually seems to behave correctly when running in a file (rather than the REPL).\nhttp://code.google.com/p/v8/issues/detail?id=2165\nAnd indeed, the current multi-line string test case tests this behavior and passes in both Node and Chrome as well as Firefox. So I'm thinking the current behavior of this JSON5 implementation is just fine. Sound reasonable to you?\n. Released in 0.2.0 FYI:\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\nEdit: oops, what I meant was that I updated the readme example, at least, to put the whitespace before the newline rather than after. At least that will always work. But I'm pretty happy and confident now that the multi-line spec and implementation are both correct and consistent with every implementation out there now.\n. Working on this. Confirmed that this is indeed a bug in Douglas Crockford's original json_parse.js, as it doesn't check for newlines at all. My newline implementation also only added newlines as a valid post-backslash value:\nhttps://github.com/aseemk/json5/commit/0fe0d239ced3362f0700ad8c792e58e016511206\n. Released in 0.2.0 FYI!\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\n. Yep, that's true to some degree. I personally feel there's value in and space for having a markup language that's still a subset of JS. We had a good discussion about this on the Node mailing list, FWIW:\nhttp://groups.google.com/group/nodejs/browse_thread/thread/1a2a5503f5874816\n=)\n. No problem! Thoughts and feedback are always welcome.\n. I hear you, but I don't think breaking compatibility with JS is something I'm ready to accept just yet. I really do want to keep it \"JavaScript Object Notation\".\n. I'm not sure, but it doesn't seem so:\nhttp://en.wikipedia.org/wiki/JavaScript_syntax#Number\n. Very interesting. That's actually invalid JSON (grammar) \u2014\u00a0a dot isn't a valid character after a backslash. Some console output in V8 (Chrome and Node):\n```\n\nJSON.parse(\".svn$\")\nSyntaxError: Unexpected token .\n```\n\nHow is Sencha parsing that JSON? Should that backslash perhaps be escaped, e.g. \"\\\\.svn$\"?\n. Sorry, I made a mistake. V8 does parse that as JSON:\n```\n\nJSON.parse('\".svn$\"')\n\".svn$\"\n```\n\nIt seems it either allows a dot to be (unnecessarily) escaped, or it strips backslashes which don't have a valid escape character after them. I'll investigate.\nInteresting nonetheless that this is still invalid JSON technically. Lemme investigate how other JS engines handle it. (And if you have IE8+, would you mind testing?)\n. No worries, me too. =)\n. Tested in both Safari (Nitro) and Firefox (SpiderMonkey), and both also exhibit this same behavior \u2014\u00a0for arbitrary characters after the slash.\nOkay, this should get fixed. =) Thanks for reporting!\n. Great catch! Can't believe I made that silly mistake \u2014 twice! =P\nI'm a bit busy at the moment, but I'll go through and update both these issues soon. Thanks for the catch!\n. Thanks again @MaxNanasy, you're totally right.\n```\n\n\".svn$\"\n'.svn$'\n'\".svn$\"'\n'\".svn$\"'\n'\"\\.svn$\"'\n'\"\\.svn$\"'\nconsole.log('\"\\.svn$\"')\n\".svn$\"\nJSON.parse('\"\\.svn$\"')\nSyntaxError: Unexpected token .\nJSON5.parse('\"\\.svn$\"')\nSyntaxError: Bad string\n```\n\nHey @donaldpipowitch, as you can see, \\. is indeed an invalid escape sequence in JSON strings. Is that indeed what Sencha Touch auto-generates?\nOne thing you could do to confirm is plug the generated JSON into e.g. http://jsonlint.com/ or http://jslint.com/ \u2014\u00a0does it indeed show up as invalid?\nIf so, maybe we should be reaching out to Sencha Touch instead to let them know they're generating invalid JSON...\n. It'd also be interesting to find out what JSON parser gets used to parse that app.json file...\n. Let's use #29 for this. Thanks Max.\n. Cool Max, thanks! I wonder if this should be a standalone jQuery plugin, or if utilities like this should be part of this project/repo. Let me think about it.\n. I'm about to remove this repo's develop branch, in favor of just master. Doing so will close this PR, and GitHub doesn't support changing the merge target of a PR, so this'll have to be re-opened as a new PR. Sorry about that!\nI'm not sure where we landed with this though. I'd like to keep the Node require support in this main repo for convenience, e.g. like CoffeeScript. If this jQuery adapter is truly useful in practice, should we just add it to the bottom of the main json5.js file? (Because it also wouldn't be good practice to make a whole separate request for just five lines of code.)\n. I'm sorry that this has been open and unmerged for over two years now though, @MaxNanasy!!\n. Good point and reasonable request! I'm not sure about NaN since null is allowed, but Infinity and -Infinity both seem perfectly reasonable. =)\n. Released in 0.2.0 FYI!\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\n. Interesting, I didn't know that NaN was part of a common standard @rlidwka, thanks.\nI'm just curious though, do you have a real-world need for specifying NaN values? Or is this just a theoretical issue? Nothing wrong with the latter, just want to understand.\n. Thanks very much for the explanation, @rlidwka! You've enlightened me. So we should add NaN; got it.\n. Hey @trans, sorry for the delay in responding.\nI appreciate your concern, but unfortunately it seems like JSON5 has to choose between being a proper subset of either JavaScript or YAML. As with JSON, I think it's higher priority to be a proper subset of JavaScript.\nThus, for the time being, I think it makes sense for JSON5 to keep its current syntax for comments and its current behavior of escaping newlines in single-quoted strings too.\nThanks again for the note!\n. Hey @aeisenberg, thanks for the suggestion. The current behavior of outputting regular/strict JSON with stringify() was actually a purposeful design decision: the output is then readable by existing JSON parsers.\nAnd indeed, much of the feedback after release was around the importance of maintaining interoperability to help adoption. We're breaking it with parse(), so it'll help to preserve it with stringify().\nIt also gels with JSON5's purpose: to help humans write JSON (by hand) more easily. If you're outputting JSON programmatically, it's probably worth adding a bit of verbosity in order to maintain interoperability.\nThat said, it might be nice to implement what you suggest as an extra, to help with things like conversion tools. I probably won't be able to get to this anytime soon, so if you want to take a stab, a pull request would be welcome!\n. Okay guys, I'm convinced -- supporting stringifying to \"clean\" JSON5 sounds reasonable. The only question is, should that be the default behavior of JSON5.stringify()? Or should it be an option?\n(Maybe overload the space option -- if any given, pretty-print, but if not, use the default JSON stringify?)\nI can be convinced to make stringifying to JSON5 the default, since you can always use the regular/native JSON.stringify() if you want regular JSON.\nI'm busy at the moment, so if anyone wants to take a stab, pull requests welcome!\n. Sounds reasonable!\n. Sorry Andrew, I've been at home for a family emergency and haven't had any\ntime or energy to look through your pull req yet, but I appreciate it and\nhope to get to it in the new year. Hope you're having a great holiday, and\nhappy new year. =)\n. Hey folks! I've granted @aeisenberg contributor rights to merge his pull request whenever it's deemed ready, so please help both of us out by taking a look at it and giving us your feedback!\nhttps://github.com/aseemk/json5/pull/35\nAnd while I have your guys' attention, consider joining our new JSON5 google group to stay up-to-date on new releases, announcements, and have a place to discuss new ideas.\nhttps://groups.google.com/group/json5\nExciting times. =)\n. Great idea, thanks! Might this be better as a wiki page here instead of as a standalone gist?\n. Thanks @dpashkevich!\n. Oops, didn't realize I had an issue open for this. This is done!\nhttps://github.com/aseemk/json5/compare/de6f784...16c840c\nRemoved the Makefile dependency later:\nhttps://github.com/aseemk/json5/commit/34d79dd657f40fdb9c10d65d8bd0ba9d6b367ad1\n. Hey @aeisenberg, sorry for the delay, but I'm finally getting to the backlog of JSON5 issues. I'll look at this really soon now, promise. =) Thanks again for submitting.\n. Oh man, I'm sorry @aeisenberg.\nI'm clearly not able to be an effective maintainer right now, so I'd like to try something that I read about (but can't find the source for at the moment edit: link; article by @felixge, shown to me by @gasi; thanks guys!): I'd like to give you and other folks who've submitted meaningful pull requests contributor rights to JSON5, so you won't be hindered by me anymore.\n(cc @MaxNanasy)\nI'd love for JSON5 to remain a cohesive project, which often means minimal and simple, so I do ask that you please still leave \"editorial oversight\" to me, e.g. let's discuss new features before you implement them. =)\nIn this particular case, if you want to introduce this, there's a few more things that should happen here:\n- [ ] We should update the readme.\n- [ ] We should update the changelog.\n- [ ] If you want to release an update with this, we should bump the version number also, to 0.3.0.\n- [ ] And don't forget to list yourself as a contributor in the package.json5. =)\nWhat do you think?\n. Forgot to mention: nice work on implementing this, and thanks for adding all the tests!\n. Also, to finally address your original comments:\n\nBasic work is complete and tested.\n\nNo problem. I think it's fine to have an incomplete implementation, as long as it's clearly documented. (E.g. this JSON5 implementation itself doesn't support Unicode characters in key names yet.)\nSo let's keep that in mind and document both the readme and changelog appropriately.\n\nThe replacer argument (2nd) is not implemented. I don't plan to implement this one since it seems a bit esoteric to me.\n\nIt has some utility, and I've seen it used in a few places. E.g. https://gist.github.com/mikeal/2504336\nLike the above, that doesn't have to be implemented today, but we should still plan on it I think. The good news is it shouldn't be too hard to (eventually) implement: it's ultimately just calling a function on every key-value pair. =)\n\nBut, feedback is welcome up until this point.\n\nThe community would be the best source of feedback. Unfortunately at the moment we don't have a channel to easily reach the community. I had started a Google Group way back when, but never shared the link:\nhttps://groups.google.com/group/json5\nFor now, I'll at least add a comment to the issue requesting this feature, where several people +1'ed, but let's look to make the Google Group a thing going forward. I'll add it to the readme!\nNice work again. =)\n. Sorry for the multiple-comment spam; another thing:\nI haven't looked deeply at your implementation, and it looks simple/elegant enough to me, but FYI it might help to look at Douglas Crockford's original implementation as well (if you haven't already) for a reference check:\nhttps://github.com/douglascrockford/JSON-js/blob/master/json2.js#L228\n(Not that Doug's original implementation is the best model implementation =D, but JSON5's parse implementation is based directly on his, FWIW. Though there's been talk of changing that\u2026)\n. As commit 9cf34ad's message shows, I was able to test this easily since ES5 doesn't throw an error on negative hexadecimal literals -- it just evaluates them to NaN. Fixed.\n. Released in 0.2.0 FYI!\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\n. Great argument @jordanbtucker, and fantastically thorough explanation! Thanks.\nI'm convinced: let's re-add support for negative hexadecimals. Updated the issue title.\nNow we just have to figure out how, right? =)\n. Fixed by @jordanbtucker in pull #74.\n. Oops, I'd forgotten to close this.\n. What do you expect it to produce? Object as you're using it refers to the native Object function, and functions aren't valid data types in JSON or JSON5.\n. That's an interesting use case. I can see why you're asking, but I'm not sure what a good solution would be. I'm also not sure if JSON5 should solve this since it strays quite a bit from the purpose of being a data format that's easy to write by hand. Let's chew on this, and feedback from others welcome.\n. If it's okay, I'm going to close this since the workaround is straightforward enough, and I'm not sure that it'd be right for JSON parsers to accept and parse [Object] as [] or {}. Thanks for raising, though!\n. Yep, I'd say either is fine. Thanks guys!\n. Looks good to me \u2014 :thumbsup:! \u2014\u00a0but @aeisenberg please sign off too. =) Thanks @kasperp!\n. Awesome, @rowanhill, thank you! (And thanks 24 Pull Requests!)\n@aeisenberg is the right person to look at this in detail, but I'll try to give it a look-through soon.\nCheers, and thanks again!\nP.S. Branching off develop is perfect.\n. Thanks very much for your work, folks!\n. Awesome work again @rowanhill! =)\n. Thanks again for your work, folks! So awesome to have helpful contributors.\n@rowanhill: I'd be happy to grant you contributor privileges like @aeisenberg, so that any future work you'd like to do you can do directly in this repo. (It'd still be nice to do it in a separate branch and submit a pull request, so that we can all code review and track changes more easily.) Interested?\n. Spaces is my preference; thanks for checking. But more importantly, thanks for doing this in general! Much appreciated, @rowanhill. :thumbsup:\n. Even better that you'll rebase your other PRs and take care of the conflicts; that was my first thought when I read the title. =) Thanks!\n. I'm sorry guys, I didn't realize this was the case. I will be sure to push out an update later today or tomorrow! (I don't have access to my development machine at the moment.)\n. Sorry again for the delay here! I slipped on this, and then the weekend JSON5 randomly re-appears on Hacker News, I'm on a company retreat in the mountains. =)\n@aeisenberg also just merged some great work from @rowanhill, so I'll try to cut a new release this week. I'll also simplify the git branches here to just master rather than master and develop.\n. Sooooo sorry again, haha. Release finally cut!\nhttps://github.com/aseemk/json5/blob/master/CHANGELOG.md#v040-code-diff\n. Very cool to see that your npm fork handles package.json5! Thanks for the heads-up. =)\nUnfortunately, regular npm still only supports package.json. So if we didn't have a package.json checked in, anyone who did a git clone wouldn't b able to automatically run any scripts \u2014 including the build script to compile package.json5 to package.json. =)\n(We could use a Makefile \u2014\u00a0that's in fact what the original implementation did \u2014 but that isn't cross-platform.)\nAgreed that this is less than ideal. I think it needs to stay though for now... Thanks for the idea though!\n. Good post @mathiasbynens \u2014 I like it. Good catch also to reword \"Unicode\" to \"non-ASCII\".\nI agree with @aeisenberg that we should continue pointing to a more \"official\" reference like MDN, but lemme see if I can add a secondary link to your post.\nThese changes should also be made on the readme rather than the gh-pages branch directly, which is generated from the readme. I'll do that.\nRe-opening this PR to help me remember/track, but I'll bring over your link manually.\n. Sorry for the massive delay, but finally added to the readme: https://github.com/aseemk/json5/commit/c2e5f65b8a6bd74a149cf1858ce86f2a2044e0f0\nThanks again @mathiasbynens!\n. The gh-pages branch is auto-generated by GitHub from a GitHub Pages template. No harm that this got merged, but it'll get lost on the next (manual) re-generation. Good news, though \u2014\u00a0I just checked, and the template source has added monospace as well:\nhttps://github.com/orderedlist/minimal/blob/master/stylesheets/styles.css#L69\n=)\n. Yes, this is a duplicate of #19. The current behavior is by design because undefined is not a data type in JSON, and JSON5 adds no new data types. Thanks folks.\n. I agree, ultimately I think JSON5 needs to remain a subset of ES5, so I don't think we can do this under the JSON5 umbrella. I like the idea of a JSON6! ;)\n. Going to close this, but added a \"JSON6\" label to track these kinds of requests.\n. Agreed, thanks for the response guys. =)\n@mcharytoniuk: to add on, I wouldn't say the things you mention are \"ambiguities\" in the literal sense. The grammar (thanks @jordanbtucker!) is still concretely well-defined, and JSON5 is still ultimately a language-agnostic data format. (It just happens to be inspired by and a subset of JS in the same way that JSON originally was.)\nI can't speak to performance, because that's comparing apples to oranges right now. The implementation in this repo is an example one based on Douglas Crockford's original JSON implementation, but browsers and other platforms have native JSON parsers these days. One day I hope/expect we'll see a prototype of a native JSON5 parser; then we can compare performance. =)\n. Very interesting! I didn't know that was possible in ES5.\nI don't personally see these as super compelling, and it's not a goal of JSON5 to support every feature of ES5 (there's still something to be said for keeping the additions lean and simple), but WDYT?\nFeedback from others welcome too.\n. I agree with you, let's not worry about this for now.\nTo keep issue noise down, let's go ahead close this as WONTFIX for now, but we can always re-open if enough other people want this.\n. @kylpo: Thanks for your feedback! Can you share your use case a bit?. These are great thoughts. Issue #1 already exists for the same thing you're talking about, I think. Want to move your comment there and close this one as a dupe?\n. Agreed, thanks!\nIf JSON5 is not backwards compatible with JSON anywhere, that's definitely worth an issue/bug (like this) instead of the wiki I think.\n. @jordanbtucker: you are totally awesome! Thanks for so many great suggestions and pull requests. I'm glad @aeisenberg stepped in for one, but he's on vacation, and I'm super busy with work right now.\nGiven your awesome contributions so far, I'm going to make you a collaborator and give you push rights to this repo. Please do keep on opening pull requests and giving others a chance to review your changes, but you can now make the call to merge yourself. (E.g. for minor changes, or if no one has reviewed your code after some time.)\nWelcome to the team! =)\n. I didn't mean why \\r in general \u2014 yep, I'm aware of different line endings =D \u2014\u00a0I meant why are you peeking ahead in the \\r case to look for an \\n? Why not just ignore \\r and \\n each independently? It'll then work when they're back-to-back as well. And to ignore \\r independent of \\n, you would just add an entry for \\r into escapees just like \\n.\n. Oh, got it! Duh, sorry about that. Thanks for explaining. =)\n. Great test cases! :ship:\n. Thanks for fixing the build issue! @jordanbtucker, do you know how to git rebase? If you rebase this branch to the latest master now, the CI should pass again.\nWe should add a CONTRIBUTING.md, but as a matter of habit, it's always nice to rebase branches/pull requests before merging them, to ensure clean merges (not just logistically but logically too).\n. Thanks @jordanbtucker! Just out of curiosity, what's your reasoning for this? Any harm in accepting more whitespace than JSON? (As long as it's not more than ES5.)\n. LGTM if you think this is worth merging! Feel free to then. =)\n. This is great @jordanbtucker, thank you!\nNo issues at all with it in the wiki. I do wonder if it could go in the repo itself though, since part of the purpose of this repo is to be the \"spec\". I don't feel strongly either way. WDYT?\n. Just want to say that you guys are awesome. Thanks for all the great work!\n. Nice @jordanbtucker.\nQuestion: should we (finally) just create a json5 organization and move these repos there?\n. Thanks @jordanbtucker on creating the org! Happy to move this repo there. Should we keep the name simply json5, or change to json5-js?\n. Woohoo! Done. =)\nhttps://github.com/json5/json5\n. :thumbsup:!\n. WDYT of adding tests for these things?\n. @jordanbtucker: your rebase at the end looks perfectly right.\nOne thing I often do is add --interactive (or -i for short) after rebase. That lets you confirm it's doing what you think it's doing. Specifically, only the commits for your cool-feature branch should be kept (picked) for the rebase. That should do it then!\n. The change LGTM to me. :ship:!\nYou do have an unrelated commit in this PR though, so try a rebase on this PR to remove it. If you encounter any issues, you can always git rebase --abort and maybe it'd be fine to merge as is then.\n. Glad you figured it out! =)\n. :thumbsup: to the idea from me. =)\n. Agreed!\n. Good points guys. I wasn't aware of that issue, thanks!\nIs that the only case where JSON itself isn't a strict subset of ES5? Or are there others?\nIf that's the only one, I agree with @rlidwka here: let's go on the side of being a subset of ES5 in this case. I don't think we should expect people to be using those characters in their hand-written JSON.\n. Great points, @jordanbtucker.\nFunny enough, the two unsafe chars just hit us at @FiftyThree: we just had site-wide downtime this morning from user input that had them.\nhttps://medium.com/joys-of-javascript/json-js-42a28471221d\nOur context was that we take server-side JSON data and render it to client-side JS (to bootstrap client-side functionality). Bug filed with our rendering lib:\nhttps://github.com/malgorithms/toffee/issues/34\nTo be clear, this was programmatic JSON, not handwritten JSON5. The characters came from user input, probably copy-pasted somehow (as it didn't look malicious).\nI guess this issue boils down to these questions for me:\n- How often does (legitimate) JSON have these two characters?\n- How often are people parsing JSON5 as JS? (Whether through JSONP, eval, or rendering.)\n- ==> How often are people parsing JSON with these legitimate characters, with JSON5, as JS?\n. Agreed!\n. Nice idea. =)\n. Nice work! LGTM.\n. I just removed this repo's develop branch, in favor of just master. Doing so closed this PR, and GitHub doesn't support changing the merge target of a PR, so this'll have to be re-opened as a new PR, splitting the discussion up. Sorry about that! Thanks for the great discussion though. =)\n. Indeed as @rlidwka said. =)\nAt some point, I'd like to improve the documentation to be explicit and clear between \"for users\" vs. \"for implementors\". Right now, this project is combo spec + ready-to-use implementation.\n. I'm not sure how much performance overhead these features really add. My guess is that using JS at all for parsing \u2014 as opposed to using the native JSON.parse \u2014\u00a0is the significant bit here.\nIOW, if you don't need JSON5's features, you'd be better off using the native JSON.parse if you want performance.\n. I'm going to go ahead close this, but if anybody comes up with benchmark data/numbers that disproves my assumption above, please feel free to re-open!\n. I don't feel strongly, but agreed:\nhttps://www.npmjs.org/doc/files/package.json.html#license\n. We can take a look after publishing on the new https://preview.npmjs.com/, and if it's still not showing up there, we can file an issue on https://github.com/npm/npm-www. Thanks @michaelsanford!\n. Nope, no need. Thanks again!\n. Sorry about that, @d10! I missed this over the holidays. Thanks for the ping. =)\n@gasi would love you for the change in quotes. =D\nI will review and would be happy to merge after any changes. Thank you for the PR!\n. LGTM otherwise, thank you @d10!\n. Whoops, I totally missed this PR, sorry about that! Taking a quick look now.\n. Nice work otherwise @AVGP. Thank you for the pull request! =)\n. Good point @ravi. So this won't fix that. Please feel free to open a new issue to add line and column number to syntax error messages. Hopefully it won't be too hard for someone to take a stab at.\n. Fascinating! Thank you.\nDoes anyone else have any thoughts on this? Should we simply do this on all objects we return? Or if, say, the input string was over a certain size?\nOr perhaps we can do this as part of the parse process inline. E.g. on every close quote.\n. Good bug, @sandermarechal. Maybe file this issue with the YUI Compressor first? They'll be able to debug, and tell us if it's something wrong with JSON5's code or a bug in YUI Compressor.\nhttps://github.com/yui/yuicompressor\n. I like the intent, but I'm hesitant at the idea of different implementations supporting different opt-in features. If regexes and dates are in demand, maybe we should just ~support~ edit: formalize syntax like foo: /.../i and bar: Date('...') directly. Still a subset of JS/ES5 and standard, not one-off.\nEither way, I don't personally feel like this should be part of 1.0. IMHO, 1.0's primary goal should be to finalize & formalize what's already been there and what people have already been using. The rough edges you've been smoothing have been awesome! This feels like just a bit beyond the line from polish to new feature to me.\nAll that said \u2014\u00a0don't consider my opinion a show-stopper at this point! You've been doing amazing work @jordanbtucker and I appreciate your leadership and ownership. Even if you move ahead with it, I'll take a page from Jeff Bezos's book and say \"disagree but commit\". =)\nThank you again for your contributions!. I totally forgot about that rant. It's a good one!\nThen I guess I end up back with a conservative stance of \"let's not take this on right now\". =). Also great point about Date. Yuck.. I too have been pretty hesitant about this feature request, because it's hard to know if it's gone just a bit too far beyond the line of \"minimal but useful\"... but I also agree with @jordanbtucker that I too have written 60 * 24 * ... multiple times for (non-JSON) config-ish constant values.\nI'd be okay with adding basic math operators. I would discourage adding **, etc., as those aren't standard ES5 either. (But I do appreciate them in CoffeeScript.)\n. @piranna: I totally agree that functions are beyond the line. A core tenet of JSON(5) is \"it's just data\", not executable code.\n@XGHeaven: agreed, thank you.\nEven with these basic operators, though, it does e.g. make supporting JSON5 in other languages harder. E.g. what is 5 / 0? If we're to be consistent with ES5, it's Infinity. But in most languages, that'd be a runtime error. Or possibly an undefined-ish value.\n. Great discussion indeed! Very good food for thought. =)\nI'll keep chewing on it...\n. Thanks for the idea!\nI'm reluctant with this feature, because {checked} is not the same as {checked: \"checked\"}.\nA core principle of JSON5 is that it's a strict subset of (ES5) JavaScript. Even if we expanded that to ES6, this feature wouldn't pass that test: you couldn't e.g. paste that JSON5 snippet into an ES6 file without changing its meaning.\n. Nice! Thanks for the great contribution.\nI'll try to review this when I get some time, but hopefully one of the other maintainers will beat me.\n. Big +1 to an npm dependency being okay here.\nI also agree some tests would be nice, so no one has to manually test whenever making changes to the CLI code, but they can be basic tests for the logic rather than e.g. the command-line argument parsing (since you're using a dependency for that).\nThanks again!\n. I have to admit I'm pretty hesitant about this feature.\n- JSON(5) is already a format for describing values.\n- There's something elegant about an entire JSON(5) document being a single expression.\n- Do people really need this? Are we really solving a common problem people have? Or are we just considering adding this feature because we can?\n. Whoops, submitted too early.\nAs always, I did want to add: I appreciate the thoughtful discussion, however. And suggestions for improvement are always welcome. =)\nI just feel part of my (limited) role is to be a steward for keeping this project tightly scoped. It's already an uphill battle in many places to use JSON5 at all \u2014 even though all it adds (so far) is mainly just comments, unquoted keys, and trailing commas. Crossing the always ambiguous \"too much\" line will start moving it towards YAML, and JSON5 has always had a selling point that it's simpler.\n. Re: JSON5.stringify specifically: I might be forgetting some earlier discussions, but I still often wonder: what really is JSON5.stringify's purpose \u2014 and what should it be?\n- The problem JSON5 set out to solve was \"make it easier and more human-friendly to write JSON out by hand\", with common use cases like config files and declarative data. \"Write\" == parse.\n- Tooling is a legitimate and great need: it's really helpful if tools can parse human input, amend it in some way, and output it back again. E.g. IDE auto-formatting, npm install --save, etc. But we'll never have this ability as long as comments are stripped, which JSON5.parse does. So if we really want \"parse the JSON5 document in its full original syntax\", JSON5.parse is not it \u2014\u00a0so JSON5.stringify shouldn't be considered the counterpart to it. (Another angle: as long as JSON5.stringify takes data, e.g. a JS object, and not a syntax tree, it doesn't serve this purpose.)\n- Similar to my point about variables, what problem is JSON5.stringify really trying to solve?\nThanks for the discussion again! Looking forward to responses.\n. I'd be okay with just considering the current spec/code 1.0. The main missing feature from the implementation is proper Unicode support, but that's a code issue, and the spec probably matters more than the code (since the code is just a reference implementation).\n:+1: to semver in general.\n. @jordanbtucker: Your suggestion SGTM. I'll also give you npm publish access! Thanks again for all your great work \u2014 it's really helpful to have your hands here.\n. Looks like I need to know your npm username?\n. Ah, jordanbtucker naturally. =) Added!\n. Thanks for the feedback! You're totally right. This is just one of the built-in GitHub Pages themes.\nIt looks like the theme has been improved to have better contrast. What do you think of this?\nhttp://orderedlist.com/minimal/\nTo pick up the changes, I wonder if we just need to re-generate the website.\n. Nice investigation, @AlexDaniel, thanks. I've +1'ed your PR.\nI'm happy to either re-generate the website, or if you want to experiment with the stylesheet on the gh-pages branch of this repo directly, happy to take a PR!\n. Nice! Rebuilt the site, and indeed, contrast looks improved:\nhttp://json5.org/\nThanks again for the feedback!\n. Thank you!\n. Good question. There aren't specifically for JSON5, but since JSON5 is a subset of ES5, you should be able to prettify your JSON5 using any standard JavaScript prettifier.\nLet us know (and feel free to re-open) if you run into any issues!\n. Thanks @jordanbtucker! I was out getting married. =) Cheers.\n. I think this is a great idea too! Thanks guys. =)\n. Great question! cc @jordanbtucker to chime in too.\nI think that's a reasonable goal. The reality is that we haven't shaken the boat with things like dates in all these years, so it's probably unlikely that we will at this point either.\nSo there could be some value in officially and formally \"freezing\" the spec... but I think there's also something to be said for learning from people's experiences and adapting to an ever-changing world.\nHow do others feel?. @seagreen: That sounds like a good perspective to me. Thanks! \ud83d\udc4d . Amazing work @jordanbtucker!! :). @jordanbtucker: This is excellent work!! Thank you as always. =)\nMinor bug: \"A JSON5 parser transforms a JSON text into another representation\" should be \"JSON5 text\", right?. Nice work! I raise both of my hands \ud83d\ude4c \u2014 this is purposely a double-entendre. =). Good suggestion! I like \"JSON for humans\", inspired by Kenneth Reitz's work (e.g. Requests, HTTPie). How do others feel about that?\n(Alternately, the GitHub repo description already also says, \"JSON for the ES5 era\".). Thank you @jordanbtucker! We should re-generate the website too. Do you have the ability to do that? (Under the repo settings.). It's looking great! Thank you @jordanbtucker.\nOne thing I noticed: the license link is broken. I guess GH Pages doesn't automatically translate relative file links in this case, so you may need to explicitly point to github.../blob/master/LICENSE.md.\nSelfishly, I also realize now that my name is not explicitly listed anywhere! (Only the package.json example.) This isn't you; this is the case in the README directly too.\nI'm curious for your opinion: which of the below do you think is better?\n\nTweak the license line to say \"MIT \u00a9 Aseem Kishore and others\", like our actual license file.\n  -or-\nAdd my name to the \"Credits\" section? E.g. \"Aseem Kishore created this project and authored the first version.\" (And maybe link to the Hacker News reaction for fun\u2026 :trollface:)\n\nFeel free to make either change (both in your PR and on the master README), but I'm happy to do either also if that'd help.\nThanks again for the great work!. Sorry @jordanbtucker, I forgot about this PR and just updated the website myself:\nhttp://json5.org/\nEverything LGTY?. You can simply use JSON.stringify (instead of JSON5.stringify) which is built into all JavaScript engines these days.\nHope that helps! Feel free to re-open if not.. Ah, that's surprising and too bad.\nJSON.stringify is part of the official ES5 standard, which is pretty pervasive these days, so I'm not sure it'd be worth the API surface area for JSON5.stringify to re-implement that. We also probably wouldn't do it as robustly or as fast as other libraries, e.g. https://github.com/bestiejs/json3.\nGood luck!. Not a bad idea! Unobtrusive, and a quick and easy way for people to use existing JS tooling on their JSON5 data.. Thanks for your first-time contribution, @lifuzu!\nI'm personally pretty wary of supporting functions in JSON5, as they pretty firmly move us away from being a data format to now supporting arbitrary behaviors.\nI know there are use cases, but I'd say for anything non-trivial, if you need functions, you might be better off just using JS directly rather than JSON5.\nThe other major problem with them is that they'll only work on JS runtimes. These days there are JSON5 parsers for other platforms too.\nSo I don't think we'll be able to merge this, but your thoughts/questions/etc. welcome!. Great work investigating this!\nIf you've already prototyped and profiled implementing this directly, I'd say that's a very appealing option. No dependency means this continues to be easily portable (e.g. in the browser).\n:thumbsup:\n. Nice @rlidwka, thanks!\nI agree re: browserify (we use and love it at FiftyThree), but I think there's still something to be said for having a simple drop-in file for developers who aren't knowledgeable about these tools. Maybe it's not worth worrying about that audience in this case though. We could also always provide a browserify-built distribution, either in the repo or via GitHub releases/downloads.\n. Great point! Thanks.\n. Great point!\nLooking at your hexadecimal patch, this should be straightforward to do, too, yeah? When we start with a 0, if the next character is a digit, throw an error. WDYT?\nIt might be nice to look into exactly what the other implementations do, to see if there are edge cases we need to account for.\nSorry, I'm completely busy in my day job right now, but I hope to take a look into this and other issues soon. Thanks for all the help!\n. Great catch! I agree with you \u2014 let's disallow leading 0's to avoid confusion.\n. I'll update our eval tests to use strict mode (issue #14), and then I'll pull in your commit eab3058cd8. =)\n. Pulled. Thanks again Max!\n. Great point.\nSomeone pointed me to JSON3, which is still a regular JSON implementation, but which serializes Date objects to ISO 8601 date-time strings.\nInterestingly, it seems it doesn't do anything special to parse the generated strings back to Date objects. But maybe it's fine for that to be application-level logic, not sure.\nI thought maybe serializing to Date(...) could be an idea, but it turns out that in ES5 (see link above), calling Date(...) without new is actually supposed to ignore the parameters and always return the current date-time.\nThat leads to the thought of serializing to new Date(...), but that strikes me as a bad idea, putting object construction in a data format.\nSo maybe the best thing to do is to follow JSON3 in at least serializing dates to a standard format. What do you think?\n. It also seems that V8 (in Node and Chrome) does this natively too:\n```\n\nJSON.stringify(new Date())\n\"2012-05-29T04:21:20.031Z\"\n```\n\nSo this is probably the right thing for this JSON5 parser to do too?\n. I think it's for convenience, when Date instances are nested within objects or arrays.\n. Indeed -- but that's not always convenient to do when the Date is nested. =)\n. Actually, I just realized that we've been talking about serialization, and this JSON5 implementation defers to the regular JSON.stringify() for serialization, so it'll already do this in V8.\nNeed to investigate whether there are still issues there that could be improved, but in general, I'd love to output regular JSON if possible. JSON5's purpose is really to make JSON more write-/maintain-friendly.\n. Someone on the Node.js thread pointed out this great gist:\nhttps://gist.github.com/2504336\nSince JSON5's parse() is built off of Douglas Crockford's own parser, it too supports a reviver argument, so that helper code will work with JSON5 too. =)\nLet's keep in mind though that the goal of JSON5 is to make writing JSON easier. I'm not sure that ISO 8601 strings are the most human-friendly way to write dates, but I'm not sure that introducing new types is a good idea, either.\n. Yes, that's a fair point, thanks. I'm hesitant to introduce syntax that's no longer \"just JS\" though.\nThe reviver example linked above though gives me another idea \u2014 we could have an option to e.g. auto-parse Dates, and the reviver could simply try calling Date.parse(str) on every string value. So you could write dates in any human-readable format that Date.parse() recognizes, like \"May 29, 2012\" or \"6:08 PM\".\n. Definitely, thanks Marco!\n. @shish, thanks for the comment. You're right that JSON5 probably shouldn't specify arbitrary or open-ended date string formats.\nI don't think using advanced types like that is a good either, though. The purpose of JSON5 is to be human-friendly when writing, and having to specify such things to help the machine parse your data defeats that purpose. =) It also greatly muddies the spec if we start reserving keys.\nLet's keep things simple here and stick to the \"no new data types\" philosophy, and for developer convenience, this JS implementation will add an option to auto-try-parse all strings into JS Date objects, via @polotek's reviver.\n. Folks, just a heads-up that I started a JSON5 google group:\nhttps://groups.google.com/group/json5\nIf you're interested in news and updates to JSON5, it'd be great to have you join. Cheers.\n. Very interesting, @rlidwka! That's good to know, but in this case, the native Date#toJSON() already outputs an ISO 8601 string (and not an {type: \"Date\", data: \"ISO 8601\"} object), so we probably can't expect that to change.\n. I'm not sure personally. I agree that fortunately, there is a simple workaround (reviver as mentioned), but I think lots of good arguments have been made in this thread that adding some type of support aligns with the goals of JSON5: to help people write dates by hand. Tough call!\nLet's keep this issue open. I think I'm still open to pull requests that give some implementation a stab and can demonstrate the value.\n. I have the same opinion here as https://github.com/json5/json5/issues/91#issuecomment-332359187.. Thanks guys for raising this issue.\nI wasn't aware that npm link doesn't work on Windows; I'll update the documentation. (npm install is actually all that's needed, but npm link does that plus symlink it globally if you want to use it elsewhere. Not a requirement.)\n@ajlopez, it's good to know that node test\\via-eval runs without a hitch, but that doesn't actually run the tests \u2014 it just defines them. It seems the problem is running Mocha.\nCould you try running Mocha directly? Install it globally first via npm install -g mocha, then run mocha --ui exports --reporter list?\n. Great! But that made me realize what may be up -- Mocha was never installed locally, I'm guessing. If you run npm ls in the project directory, does it show anything?\nIf not, just run npm install (I updated the documentation to list this instead of npm link), then npm should be able to find the local mocha binary just fine. You can choose to npm uninstall -g mocha if you like then.\n. Interesting. Npm is indeed supposed to include local binaries in the PATH when running scripts like npm test.\nCould you echo %PATH% and see what it says? Could you also print the contents of node_modules\\.bin?\n. Ah, that's awesome! Great to hear.\n. Awesome stuff \u2014 thanks! I'll try to take a look at this later tonight. \nQuick request: would you mind adding a few non-hex regression test cases, like decimals and negatives and exponents?\n. Merged! (GitHub doesn't detect it since I rebased.)\n. Very interesting. The native JSON.parse() doesn't like:\n```\n\nJSON.parse('.5')\nSyntaxError: Unexpected token .\n```\n\nI think this is another good human-friendly feature to have, but I'd love to learn why regular JSON doesn't allow it, whether there's any good reason for it or it's just yet-another strictness/simplification decision.\nThanks for the patch though! If there's no good reason against it, I'm definitely down to merge. =)\n. Cool, merged for now, and we can always revert if there's a good reason against this. Thanks again!\n. Thanks!\n. Great catch. =)\n. Oooh, very interesting! I was going to say, \"are we sure we want trailing decimal point support?\" But a quick test reveals that it's already implemented before your leading decimal point patch (where I had assumed it came from).\nShould this be considered a bug rather than a feature then? Is there ever good reason to use it, and is it ever used in practice (given that e.g. JS only has doubles, not ints)?\n. Btw, thanks for bringing this discrepancy to light, and great catch!\nI'm on the fence about this, because it is valid ES5. Super interesting that the native, standardized JSON.parse() rejects trailing decimal points \u2014 at least in V8 \u2014 while Douglas Crockford's json_parse.js doesn't. Wonder if either was by design or if they're unspecified implementation differences.\n. No prob. =) Thanks for pointing out that JSON by design doesn't allow trailing decimals. I'm inclined to not allow them either, since there doesn't appear to be any good reason to \u2014 what do you think?\n. My thinking was that it might be wise to \"pick our battles\" \u2014\u00a0every deviation from the original JSON spec means a higher barrier/friction for adoption.\nChanges that add significant convenience or usability (like trailing commas and comments) are worth adding. I'm not sure that trailing decimals add any value along either of those lines.\nYou are right that ES5 allows them, but JSON5 just needs to be a subset of ES5; it doesn't need to allow everything that ES5 does.\nIt's a close call either way, and that's why I'm leaning towards disallowing them simply to err on the side of keeping the changes purposeful and meaningful.\n. Cool. I'll add support for \"negative\" ES5 test cases (issue #15) and then I'll pull in these test cases to ensure that we revoke them.\n. Yep \u2014 this in invalid JS too:\n```\n\n{1:true}\nSyntaxError: Unexpected token :\n```\n\nUnquoted keys have the same rules as variables (\"identifiers\"). Here's a reference:\nhttps://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\nI'll update the readme to be clearer about this.\n. No worries. =)\n. Yes, you're right @rlidwka:\n```\n\n{1:true}\nSyntaxError: Unexpected token :\n({1:true})\nObject {1: true}\n```\n\n(Interestingly, the first case gives that syntax error in Chrome, but not Node.)\nThat we reject this is currently expected, because I was under the impression that ES5's spec on object keys applies the same rules for unquoted keys as it does to variable names (hence the link I shared above).\nIf it's valid ES5 though, perhaps we should allow this... It'd be nice to confirm that this is allowed per ES5 though, not just an \"it-so-happens\" behavior of existing implementations.\n. Yep, I'm aware of the ambiguity, I was just surprised that two different instances of the same JS implementation treat the ambiguity differently.\n. Done:\nhttps://github.com/aseemk/json5/compare/ce264b5%5E...ce264b5\n. Cool, @MaxNanasy has already done this: MaxNanasy/json5@38414028; pulling in.\n. @Midar, did you check out the discussion on pull request #9?\nhttps://github.com/aseemk/json5/pull/9\nJSON doesn't differentiate between ints and floats \u2014 it only defines a single \"Number\" type, and indeed, same with JavaScript \u2014 but is it the case that JSON implementations in other languages return specific types?\n. Good to know. I think you've made a reasonable case for allowing it. =)\n. Happy to help! ;)\n. Thanks for the nudge! Sorry there's been no progress on this; I've been quite busy. I can try to get to this over the holidays, but if you'd like to send a pull request, feel free! Even if it just updates the readme (but in that case, it'd nice to call out a TODO for this implementation to support it).\n. Released in 0.2.0 FYI!\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\n. Uh oh, we've duplicated some work \u2014 I just implemented this as well! =P\nHope you don't mind if I don't take yours \u2014 I've implemented it slightly differently. Significant experience with CoffeeScript's (and Streamline's until recently) require() hooks have taught me that modules shouldn't auto-register require() hooks, as this can lead to local dependencies overwriting global state, and potential version conflicts in the future. So I've implemented it as a separate file, thus requiring a separate require.\nI appreciate your support nonetheless!\n. Great catch, thanks!\n. @williamwicks: Are you saying you specifically want the array to contain undefined elements? The undefined type itself is not part of JSON. You can return null elements though even in regular JSON:\n``` js\nJSON.stringify([,,,])\n\"[null,null,null]\"\n```\nDoes that work fine for you?\n. That's a good point about the representation changing, but ultimately I think what this boils down to is adding the notion of undefined to JSON5. That's probably unlikely to happen, unfortunately, since most languages don't have a concept for it vs. null.\n(This also fits the \"adds no new data types\" part of the mission statement.)\nAnd without undefined, supporting sparse arrays using null doesn't seem like a good idea, either, since that'd differ from the semantics of JS.\nSo ultimately it seems like your best bet is to explicitly include null elements in your array. WDYT?\n. Lemme re-open this case for consideration.\n. Very interesting point @jordanbtucker! But I'm not sure I totally buy this argument:\n\nIf JSON5 allowed leading commas and empty values, old JSON files that used to throw would no longer do so, which could introduce silent and/or hard to find bugs.\n\nBecause there are plenty of examples where invalid JSON (that would throw) is valid JSON5 \u2014\u00a0e.g. unquoted keys, comments, even trailing commas as you mention. =)\n\u2014\nI do agree that this still feels like it'd implicitly be adding a new data type. Your suggestion of leaving the element types unspecified/\"empty\" is an interesting one though, @williamwicks.\nOn the notion of round-tripping, @jasons-novaleaf, I'm still a bit unconvinced, because both native JSON and JSON3 fail the round-trip test here too. So this isn't new to JSON5.\nAt this point, I'm in agreement with @jordanbtucker that I don't think we should add this.\n. Wow, looks like the CNAME file used to register custom domain names was deleted by GitHub when I went to edit the page using GitHub's automatic page generator.\nI've manually re-added the file [1], though the DNS change doesn't seem to have been picked up or propagated yet on GitHub's side. Hopefully it does soon.\nI've also emailed support letting them know of this unexpected issue. Thanks for the catch, Max \u2014\u00a0much appreciated.\n[1] https://github.com/aseemk/json5/blob/gh-pages/CNAME\n. Yep, it's back up now. It was indeed down earlier since the CNAME file had been deleted. Thanks guys.\n. Hey @Midar, apologies if I'm misunderstanding, but let me answer your question at the bottom first: the behavior for single quotes in the ES5 spec, as far as I know, is identical to double quotes. This is not like PHP or similar where escaping rules are different for single- vs. double-quoted strings.\nMaybe the confusion stems from the fact that Node is outputting the raw string value, when maybe you mean to be outputting the string that the user sees. Try using console.log() for that instead. Here's an example:\n```\n\nconsole.log('\\foo')\n\noo\n\nconsole.log('\\e')\ne\nconsole.log('\\e')\n\\e\nconsole.log(\"\\foo\")\n\noo\n\nconsole.log(\"\\e\")\ne\nconsole.log(\"\\e\")\n\\e\n```\n\nSeems to be working the same on my end and as expected. What do you think?\n. No problem \u2014 glad we were able to resolve this. =)\nYou ask a good question. The grammar on json.org doesn't seem to support a backslash followed by anything other than the whitelisted characters (of which 'e' is not one), but V8's implementation and Douglas Crockford's json_parse.js implementation (from which this JSON5 implementation is built) both seem to allow such characters:\n```\n\n\"\\e\"\n'e'\nJSON.parse('\"\\e\"')\n'e'\nJSON5.parse('\"\\e\"')\n'e'\n```\n\nI'll look into what Firefox does, but later when I get some time, I'll also look into whether the actual JSON and ES5 specs are more precise in the expected behavior either.\nInformally, I think either behavior you choose is okay \u2014 \\e is not a recognized escape sequence, and the correct way to input backslash-e is \\\\e.\n. Ah, true \u2014 the grammar on json.org doesn't support \\e, so that implies it should be rejected.\nYou're right, so unless the ES5 spec states differently, JSON5 should be the same in this regard. I think I'll leave this JS implementation the way it is in order to be bug-for-bug compatible with JS JSON implementations today, but rejecting is totally reasonable too.\nThanks for bringing this to light!\n. > Does that mean an identifier is allowed to start with a Unicode letter?\nYes, it does.\nThis is the one part of the spec I haven't totally understood and digested, but there seems to be different \"categories\" of Unicode characters, and Unicode \"letters\" are allowed as the first character just like regular letters. Unicode \"digits\" can be used after the first character.\n\nAre the following valid identifiers?\n\nYep. Node confirms this too:\n```\n\n{\u00e4bc: \"a\"}\n{ '\u00e4bc': 'a' }\n{\\u00E4: \"a\"}\n{ '\u00e4': 'a' }\n```\n\nHope this helps!\n. Very interesting! Thanks for that catch.\nAnother way to compare this then is as regular variable names \u2014 unquoted object keys are (supposed to be) bound to the same restrictions as variable names, with the one loosening up that reserved keywords are allowed.\n```\n\nvar \u00e4 = false;\n\u00e4\nfalse\nvar \\u00E4 = true;\n\\u00E4\ntrue\nvar 1 = false;\n[SyntaxError]\nvar \\u0030 = false;\n[SyntaxError]\n```\n\nAnd indeed as per the spec, Unicode digits (incl. escape sequences) are not valid as the first character.\n. Both are great ideas.\nThis module already has a bunch of test cases, FWIW: https://github.com/aseemk/json5/tree/develop/test Let me know if you find those useful.\nFor the list of parsers, maybe the wiki is a good place to start \u2014\u00a0I'll do that right now. =)\n. How's this? https://github.com/aseemk/json5/wiki/In-The-Wild\n. You know, you're technically right, and I used to go by that too, e.g. when designing REST API responses, but every major JSON parser I've come across supports any top-level value, not just object or array \u2014 including JavaScript's native JSON.parse() and Douglas Crockford's json_parse.js. So I've kept that compatibility with this JSON5 implementation.\nIf you'd like to follow the formal definition, one thing you could do is just wrap each test case in [], and make sure that every successfully parsed array has length exactly 1.\n. Makes sense. =)\n. Sorry, I meant your rationale for only allowing objects or arrays makes sense \u2014 given the context you describe.\nI have indeed seen e.g. APIs that return primitive values, calling it JSON, so developer expectations could swing the other way too, though. Maybe make it an option? (Though adding options is never a great first resort.)\nIf I had to choose one or the other, I would allow it given that developers probably know what data type to expect if they're parsing JSON. E.g. an API response, a config file, test case data, etc.\n. Awesome! You're definitely welcome to add it to the wiki \u2014 and feel free to reword it if you think it makes sense.\nNot a bad idea to explicitly specify that any value can be the top-level value. I'd like to keep the readme overview minimal, but I've been thinking this deserves a more thorough spec and/or FAQ at some point, so I'll add it there. Thanks for the suggestion!\n. Wiki looks great, thanks! Mind if I tweet it out? =)\nA formal spec w/ EBNF syntax is definitely worth doing at some point. I don't know EBNF, so I'd probably need some help on it. =)\nRe: newline behavior \u2014 very interesting! Indeed that's what Node/V8 seems to do, which I wouldn't have expected. The spec seems to suggest that only the newline should be stripped, which is indeed what I've done in this implementation. Let me see what other JS engines do.\n. I actually agree w/ you in terms of what would be more helpful/common, but that prevents you from being able to add any whitespace to a string after the newline.\nI also ran into this same issue with CoffeeScript, FWIW, which I believe was meant to mimic the JS spec: https://github.com/jashkenas/coffee-script/issues/610#issuecomment-2053479\n. Got it. That's what I expected from the spec. Btw, tested in Chrome and it behaves the same as Node, which I would expect \u2014 they use the same JS engine (V8).\nV8 also has deviates from ES5 in at least one other way (\"noctal\" numbers are allowed in strict mode). I'm inclined to adhere to the ES5 spec here, even though I realize it could be friendlier...\n. I think filing a bug report with V8 is a totally reasonable thing to do. Want to lead that charge? =)\nYou're right \u2014\u00a0that's another bug. Thanks.\n. I think there's value in being able to break a string up across multiple lines, even despite those points, but let me chew on it.\n. The + operator starts getting away from data-only; I'd like to avoid that. (Edit: sorry, should clarify. E.g. it starts to suggest that \"foo\" + 5 is valid, or \"foo\" + [...], etc.)\n. @Midar: @MaxNanasy acutely pointed out that we were both testing this wrong \u2014\u00a0unrecognized escapes like \\e are correctly rejected by JSON5. The backslash needed to be properly escaped when we were testing it.\n(It's just regular V8 that accepts arbitrary backslash escapes.)\n```\n\n'\\e'\n'e'\n'\"\\e\"'\n'\"e\"'\n'\"\\e\"'\n'\"\\e\"'\nconsole.log('\"\\e\"')\n\"\\e\"\nJSON.parse('\"\\e\"')\nSyntaxError: Unexpected token e\nJSON5.parse('\"\\e\"')\nSyntaxError: Bad string\n```\n. Good question and thanks for the nudge!\n\nI haven't taken any action yet, but instead of dropping newline support altogether (I think there's value in keeping it, e.g. for a build tool where inconsistency between browsers isn't an issue), how about I just update the documentation to explicitly call out this behavior for now?\nIn particular, is it good enough if the documentation encourages only using newline support like this?\njs\n{\n    this: \"is a newline \\\nstring where each newline backslash \\\nis preceded by a space, and \\\neach newline explicitly begins \\\nwith *no* spaces.\"\n}\nUsing newlines like this appears to work consistently across all browsers, and still adheres to the ES5 spec. Would that work for you?\nOptionally or additionally, perhaps the compiler could warn or throw an error if it encounters newline usage not like this. But that might be unnecessary.\n. Hey @Midar, sorry for the delay! But good news: this was fixed in V8 (to match other browsers and the ES5 spec) last year, and even Node actually seems to behave correctly when running in a file (rather than the REPL).\nhttp://code.google.com/p/v8/issues/detail?id=2165\nAnd indeed, the current multi-line string test case tests this behavior and passes in both Node and Chrome as well as Firefox. So I'm thinking the current behavior of this JSON5 implementation is just fine. Sound reasonable to you?\n. Released in 0.2.0 FYI:\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\nEdit: oops, what I meant was that I updated the readme example, at least, to put the whitespace before the newline rather than after. At least that will always work. But I'm pretty happy and confident now that the multi-line spec and implementation are both correct and consistent with every implementation out there now.\n. Working on this. Confirmed that this is indeed a bug in Douglas Crockford's original json_parse.js, as it doesn't check for newlines at all. My newline implementation also only added newlines as a valid post-backslash value:\nhttps://github.com/aseemk/json5/commit/0fe0d239ced3362f0700ad8c792e58e016511206\n. Released in 0.2.0 FYI!\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\n. Yep, that's true to some degree. I personally feel there's value in and space for having a markup language that's still a subset of JS. We had a good discussion about this on the Node mailing list, FWIW:\nhttp://groups.google.com/group/nodejs/browse_thread/thread/1a2a5503f5874816\n=)\n. No problem! Thoughts and feedback are always welcome.\n. I hear you, but I don't think breaking compatibility with JS is something I'm ready to accept just yet. I really do want to keep it \"JavaScript Object Notation\".\n. I'm not sure, but it doesn't seem so:\nhttp://en.wikipedia.org/wiki/JavaScript_syntax#Number\n. Very interesting. That's actually invalid JSON (grammar) \u2014\u00a0a dot isn't a valid character after a backslash. Some console output in V8 (Chrome and Node):\n```\n\nJSON.parse(\".svn$\")\nSyntaxError: Unexpected token .\n```\n\nHow is Sencha parsing that JSON? Should that backslash perhaps be escaped, e.g. \"\\\\.svn$\"?\n. Sorry, I made a mistake. V8 does parse that as JSON:\n```\n\nJSON.parse('\".svn$\"')\n\".svn$\"\n```\n\nIt seems it either allows a dot to be (unnecessarily) escaped, or it strips backslashes which don't have a valid escape character after them. I'll investigate.\nInteresting nonetheless that this is still invalid JSON technically. Lemme investigate how other JS engines handle it. (And if you have IE8+, would you mind testing?)\n. No worries, me too. =)\n. Tested in both Safari (Nitro) and Firefox (SpiderMonkey), and both also exhibit this same behavior \u2014\u00a0for arbitrary characters after the slash.\nOkay, this should get fixed. =) Thanks for reporting!\n. Great catch! Can't believe I made that silly mistake \u2014 twice! =P\nI'm a bit busy at the moment, but I'll go through and update both these issues soon. Thanks for the catch!\n. Thanks again @MaxNanasy, you're totally right.\n```\n\n\".svn$\"\n'.svn$'\n'\".svn$\"'\n'\".svn$\"'\n'\"\\.svn$\"'\n'\"\\.svn$\"'\nconsole.log('\"\\.svn$\"')\n\".svn$\"\nJSON.parse('\"\\.svn$\"')\nSyntaxError: Unexpected token .\nJSON5.parse('\"\\.svn$\"')\nSyntaxError: Bad string\n```\n\nHey @donaldpipowitch, as you can see, \\. is indeed an invalid escape sequence in JSON strings. Is that indeed what Sencha Touch auto-generates?\nOne thing you could do to confirm is plug the generated JSON into e.g. http://jsonlint.com/ or http://jslint.com/ \u2014\u00a0does it indeed show up as invalid?\nIf so, maybe we should be reaching out to Sencha Touch instead to let them know they're generating invalid JSON...\n. It'd also be interesting to find out what JSON parser gets used to parse that app.json file...\n. Let's use #29 for this. Thanks Max.\n. Cool Max, thanks! I wonder if this should be a standalone jQuery plugin, or if utilities like this should be part of this project/repo. Let me think about it.\n. I'm about to remove this repo's develop branch, in favor of just master. Doing so will close this PR, and GitHub doesn't support changing the merge target of a PR, so this'll have to be re-opened as a new PR. Sorry about that!\nI'm not sure where we landed with this though. I'd like to keep the Node require support in this main repo for convenience, e.g. like CoffeeScript. If this jQuery adapter is truly useful in practice, should we just add it to the bottom of the main json5.js file? (Because it also wouldn't be good practice to make a whole separate request for just five lines of code.)\n. I'm sorry that this has been open and unmerged for over two years now though, @MaxNanasy!!\n. Good point and reasonable request! I'm not sure about NaN since null is allowed, but Infinity and -Infinity both seem perfectly reasonable. =)\n. Released in 0.2.0 FYI!\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\n. Interesting, I didn't know that NaN was part of a common standard @rlidwka, thanks.\nI'm just curious though, do you have a real-world need for specifying NaN values? Or is this just a theoretical issue? Nothing wrong with the latter, just want to understand.\n. Thanks very much for the explanation, @rlidwka! You've enlightened me. So we should add NaN; got it.\n. Hey @trans, sorry for the delay in responding.\nI appreciate your concern, but unfortunately it seems like JSON5 has to choose between being a proper subset of either JavaScript or YAML. As with JSON, I think it's higher priority to be a proper subset of JavaScript.\nThus, for the time being, I think it makes sense for JSON5 to keep its current syntax for comments and its current behavior of escaping newlines in single-quoted strings too.\nThanks again for the note!\n. Hey @aeisenberg, thanks for the suggestion. The current behavior of outputting regular/strict JSON with stringify() was actually a purposeful design decision: the output is then readable by existing JSON parsers.\nAnd indeed, much of the feedback after release was around the importance of maintaining interoperability to help adoption. We're breaking it with parse(), so it'll help to preserve it with stringify().\nIt also gels with JSON5's purpose: to help humans write JSON (by hand) more easily. If you're outputting JSON programmatically, it's probably worth adding a bit of verbosity in order to maintain interoperability.\nThat said, it might be nice to implement what you suggest as an extra, to help with things like conversion tools. I probably won't be able to get to this anytime soon, so if you want to take a stab, a pull request would be welcome!\n. Okay guys, I'm convinced -- supporting stringifying to \"clean\" JSON5 sounds reasonable. The only question is, should that be the default behavior of JSON5.stringify()? Or should it be an option?\n(Maybe overload the space option -- if any given, pretty-print, but if not, use the default JSON stringify?)\nI can be convinced to make stringifying to JSON5 the default, since you can always use the regular/native JSON.stringify() if you want regular JSON.\nI'm busy at the moment, so if anyone wants to take a stab, pull requests welcome!\n. Sounds reasonable!\n. Sorry Andrew, I've been at home for a family emergency and haven't had any\ntime or energy to look through your pull req yet, but I appreciate it and\nhope to get to it in the new year. Hope you're having a great holiday, and\nhappy new year. =)\n. Hey folks! I've granted @aeisenberg contributor rights to merge his pull request whenever it's deemed ready, so please help both of us out by taking a look at it and giving us your feedback!\nhttps://github.com/aseemk/json5/pull/35\nAnd while I have your guys' attention, consider joining our new JSON5 google group to stay up-to-date on new releases, announcements, and have a place to discuss new ideas.\nhttps://groups.google.com/group/json5\nExciting times. =)\n. Great idea, thanks! Might this be better as a wiki page here instead of as a standalone gist?\n. Thanks @dpashkevich!\n. Oops, didn't realize I had an issue open for this. This is done!\nhttps://github.com/aseemk/json5/compare/de6f784...16c840c\nRemoved the Makefile dependency later:\nhttps://github.com/aseemk/json5/commit/34d79dd657f40fdb9c10d65d8bd0ba9d6b367ad1\n. Hey @aeisenberg, sorry for the delay, but I'm finally getting to the backlog of JSON5 issues. I'll look at this really soon now, promise. =) Thanks again for submitting.\n. Oh man, I'm sorry @aeisenberg.\nI'm clearly not able to be an effective maintainer right now, so I'd like to try something that I read about (but can't find the source for at the moment edit: link; article by @felixge, shown to me by @gasi; thanks guys!): I'd like to give you and other folks who've submitted meaningful pull requests contributor rights to JSON5, so you won't be hindered by me anymore.\n(cc @MaxNanasy)\nI'd love for JSON5 to remain a cohesive project, which often means minimal and simple, so I do ask that you please still leave \"editorial oversight\" to me, e.g. let's discuss new features before you implement them. =)\nIn this particular case, if you want to introduce this, there's a few more things that should happen here:\n- [ ] We should update the readme.\n- [ ] We should update the changelog.\n- [ ] If you want to release an update with this, we should bump the version number also, to 0.3.0.\n- [ ] And don't forget to list yourself as a contributor in the package.json5. =)\nWhat do you think?\n. Forgot to mention: nice work on implementing this, and thanks for adding all the tests!\n. Also, to finally address your original comments:\n\nBasic work is complete and tested.\n\nNo problem. I think it's fine to have an incomplete implementation, as long as it's clearly documented. (E.g. this JSON5 implementation itself doesn't support Unicode characters in key names yet.)\nSo let's keep that in mind and document both the readme and changelog appropriately.\n\nThe replacer argument (2nd) is not implemented. I don't plan to implement this one since it seems a bit esoteric to me.\n\nIt has some utility, and I've seen it used in a few places. E.g. https://gist.github.com/mikeal/2504336\nLike the above, that doesn't have to be implemented today, but we should still plan on it I think. The good news is it shouldn't be too hard to (eventually) implement: it's ultimately just calling a function on every key-value pair. =)\n\nBut, feedback is welcome up until this point.\n\nThe community would be the best source of feedback. Unfortunately at the moment we don't have a channel to easily reach the community. I had started a Google Group way back when, but never shared the link:\nhttps://groups.google.com/group/json5\nFor now, I'll at least add a comment to the issue requesting this feature, where several people +1'ed, but let's look to make the Google Group a thing going forward. I'll add it to the readme!\nNice work again. =)\n. Sorry for the multiple-comment spam; another thing:\nI haven't looked deeply at your implementation, and it looks simple/elegant enough to me, but FYI it might help to look at Douglas Crockford's original implementation as well (if you haven't already) for a reference check:\nhttps://github.com/douglascrockford/JSON-js/blob/master/json2.js#L228\n(Not that Doug's original implementation is the best model implementation =D, but JSON5's parse implementation is based directly on his, FWIW. Though there's been talk of changing that\u2026)\n. As commit 9cf34ad's message shows, I was able to test this easily since ES5 doesn't throw an error on negative hexadecimal literals -- it just evaluates them to NaN. Fixed.\n. Released in 0.2.0 FYI!\nhttps://github.com/aseemk/json5/blob/develop/CHANGELOG.md#v020-code-diff\n. Great argument @jordanbtucker, and fantastically thorough explanation! Thanks.\nI'm convinced: let's re-add support for negative hexadecimals. Updated the issue title.\nNow we just have to figure out how, right? =)\n. Fixed by @jordanbtucker in pull #74.\n. Oops, I'd forgotten to close this.\n. What do you expect it to produce? Object as you're using it refers to the native Object function, and functions aren't valid data types in JSON or JSON5.\n. That's an interesting use case. I can see why you're asking, but I'm not sure what a good solution would be. I'm also not sure if JSON5 should solve this since it strays quite a bit from the purpose of being a data format that's easy to write by hand. Let's chew on this, and feedback from others welcome.\n. If it's okay, I'm going to close this since the workaround is straightforward enough, and I'm not sure that it'd be right for JSON parsers to accept and parse [Object] as [] or {}. Thanks for raising, though!\n. Yep, I'd say either is fine. Thanks guys!\n. Looks good to me \u2014 :thumbsup:! \u2014\u00a0but @aeisenberg please sign off too. =) Thanks @kasperp!\n. Awesome, @rowanhill, thank you! (And thanks 24 Pull Requests!)\n@aeisenberg is the right person to look at this in detail, but I'll try to give it a look-through soon.\nCheers, and thanks again!\nP.S. Branching off develop is perfect.\n. Thanks very much for your work, folks!\n. Awesome work again @rowanhill! =)\n. Thanks again for your work, folks! So awesome to have helpful contributors.\n@rowanhill: I'd be happy to grant you contributor privileges like @aeisenberg, so that any future work you'd like to do you can do directly in this repo. (It'd still be nice to do it in a separate branch and submit a pull request, so that we can all code review and track changes more easily.) Interested?\n. Spaces is my preference; thanks for checking. But more importantly, thanks for doing this in general! Much appreciated, @rowanhill. :thumbsup:\n. Even better that you'll rebase your other PRs and take care of the conflicts; that was my first thought when I read the title. =) Thanks!\n. I'm sorry guys, I didn't realize this was the case. I will be sure to push out an update later today or tomorrow! (I don't have access to my development machine at the moment.)\n. Sorry again for the delay here! I slipped on this, and then the weekend JSON5 randomly re-appears on Hacker News, I'm on a company retreat in the mountains. =)\n@aeisenberg also just merged some great work from @rowanhill, so I'll try to cut a new release this week. I'll also simplify the git branches here to just master rather than master and develop.\n. Sooooo sorry again, haha. Release finally cut!\nhttps://github.com/aseemk/json5/blob/master/CHANGELOG.md#v040-code-diff\n. Very cool to see that your npm fork handles package.json5! Thanks for the heads-up. =)\nUnfortunately, regular npm still only supports package.json. So if we didn't have a package.json checked in, anyone who did a git clone wouldn't b able to automatically run any scripts \u2014 including the build script to compile package.json5 to package.json. =)\n(We could use a Makefile \u2014\u00a0that's in fact what the original implementation did \u2014 but that isn't cross-platform.)\nAgreed that this is less than ideal. I think it needs to stay though for now... Thanks for the idea though!\n. Good post @mathiasbynens \u2014 I like it. Good catch also to reword \"Unicode\" to \"non-ASCII\".\nI agree with @aeisenberg that we should continue pointing to a more \"official\" reference like MDN, but lemme see if I can add a secondary link to your post.\nThese changes should also be made on the readme rather than the gh-pages branch directly, which is generated from the readme. I'll do that.\nRe-opening this PR to help me remember/track, but I'll bring over your link manually.\n. Sorry for the massive delay, but finally added to the readme: https://github.com/aseemk/json5/commit/c2e5f65b8a6bd74a149cf1858ce86f2a2044e0f0\nThanks again @mathiasbynens!\n. The gh-pages branch is auto-generated by GitHub from a GitHub Pages template. No harm that this got merged, but it'll get lost on the next (manual) re-generation. Good news, though \u2014\u00a0I just checked, and the template source has added monospace as well:\nhttps://github.com/orderedlist/minimal/blob/master/stylesheets/styles.css#L69\n=)\n. Yes, this is a duplicate of #19. The current behavior is by design because undefined is not a data type in JSON, and JSON5 adds no new data types. Thanks folks.\n. I agree, ultimately I think JSON5 needs to remain a subset of ES5, so I don't think we can do this under the JSON5 umbrella. I like the idea of a JSON6! ;)\n. Going to close this, but added a \"JSON6\" label to track these kinds of requests.\n. Agreed, thanks for the response guys. =)\n@mcharytoniuk: to add on, I wouldn't say the things you mention are \"ambiguities\" in the literal sense. The grammar (thanks @jordanbtucker!) is still concretely well-defined, and JSON5 is still ultimately a language-agnostic data format. (It just happens to be inspired by and a subset of JS in the same way that JSON originally was.)\nI can't speak to performance, because that's comparing apples to oranges right now. The implementation in this repo is an example one based on Douglas Crockford's original JSON implementation, but browsers and other platforms have native JSON parsers these days. One day I hope/expect we'll see a prototype of a native JSON5 parser; then we can compare performance. =)\n. Very interesting! I didn't know that was possible in ES5.\nI don't personally see these as super compelling, and it's not a goal of JSON5 to support every feature of ES5 (there's still something to be said for keeping the additions lean and simple), but WDYT?\nFeedback from others welcome too.\n. I agree with you, let's not worry about this for now.\nTo keep issue noise down, let's go ahead close this as WONTFIX for now, but we can always re-open if enough other people want this.\n. @kylpo: Thanks for your feedback! Can you share your use case a bit?. These are great thoughts. Issue #1 already exists for the same thing you're talking about, I think. Want to move your comment there and close this one as a dupe?\n. Agreed, thanks!\nIf JSON5 is not backwards compatible with JSON anywhere, that's definitely worth an issue/bug (like this) instead of the wiki I think.\n. @jordanbtucker: you are totally awesome! Thanks for so many great suggestions and pull requests. I'm glad @aeisenberg stepped in for one, but he's on vacation, and I'm super busy with work right now.\nGiven your awesome contributions so far, I'm going to make you a collaborator and give you push rights to this repo. Please do keep on opening pull requests and giving others a chance to review your changes, but you can now make the call to merge yourself. (E.g. for minor changes, or if no one has reviewed your code after some time.)\nWelcome to the team! =)\n. I didn't mean why \\r in general \u2014 yep, I'm aware of different line endings =D \u2014\u00a0I meant why are you peeking ahead in the \\r case to look for an \\n? Why not just ignore \\r and \\n each independently? It'll then work when they're back-to-back as well. And to ignore \\r independent of \\n, you would just add an entry for \\r into escapees just like \\n.\n. Oh, got it! Duh, sorry about that. Thanks for explaining. =)\n. Great test cases! :ship:\n. Thanks for fixing the build issue! @jordanbtucker, do you know how to git rebase? If you rebase this branch to the latest master now, the CI should pass again.\nWe should add a CONTRIBUTING.md, but as a matter of habit, it's always nice to rebase branches/pull requests before merging them, to ensure clean merges (not just logistically but logically too).\n. Thanks @jordanbtucker! Just out of curiosity, what's your reasoning for this? Any harm in accepting more whitespace than JSON? (As long as it's not more than ES5.)\n. LGTM if you think this is worth merging! Feel free to then. =)\n. This is great @jordanbtucker, thank you!\nNo issues at all with it in the wiki. I do wonder if it could go in the repo itself though, since part of the purpose of this repo is to be the \"spec\". I don't feel strongly either way. WDYT?\n. Just want to say that you guys are awesome. Thanks for all the great work!\n. Nice @jordanbtucker.\nQuestion: should we (finally) just create a json5 organization and move these repos there?\n. Thanks @jordanbtucker on creating the org! Happy to move this repo there. Should we keep the name simply json5, or change to json5-js?\n. Woohoo! Done. =)\nhttps://github.com/json5/json5\n. :thumbsup:!\n. WDYT of adding tests for these things?\n. @jordanbtucker: your rebase at the end looks perfectly right.\nOne thing I often do is add --interactive (or -i for short) after rebase. That lets you confirm it's doing what you think it's doing. Specifically, only the commits for your cool-feature branch should be kept (picked) for the rebase. That should do it then!\n. The change LGTM to me. :ship:!\nYou do have an unrelated commit in this PR though, so try a rebase on this PR to remove it. If you encounter any issues, you can always git rebase --abort and maybe it'd be fine to merge as is then.\n. Glad you figured it out! =)\n. :thumbsup: to the idea from me. =)\n. Agreed!\n. Good points guys. I wasn't aware of that issue, thanks!\nIs that the only case where JSON itself isn't a strict subset of ES5? Or are there others?\nIf that's the only one, I agree with @rlidwka here: let's go on the side of being a subset of ES5 in this case. I don't think we should expect people to be using those characters in their hand-written JSON.\n. Great points, @jordanbtucker.\nFunny enough, the two unsafe chars just hit us at @FiftyThree: we just had site-wide downtime this morning from user input that had them.\nhttps://medium.com/joys-of-javascript/json-js-42a28471221d\nOur context was that we take server-side JSON data and render it to client-side JS (to bootstrap client-side functionality). Bug filed with our rendering lib:\nhttps://github.com/malgorithms/toffee/issues/34\nTo be clear, this was programmatic JSON, not handwritten JSON5. The characters came from user input, probably copy-pasted somehow (as it didn't look malicious).\nI guess this issue boils down to these questions for me:\n- How often does (legitimate) JSON have these two characters?\n- How often are people parsing JSON5 as JS? (Whether through JSONP, eval, or rendering.)\n- ==> How often are people parsing JSON with these legitimate characters, with JSON5, as JS?\n. Agreed!\n. Nice idea. =)\n. Nice work! LGTM.\n. I just removed this repo's develop branch, in favor of just master. Doing so closed this PR, and GitHub doesn't support changing the merge target of a PR, so this'll have to be re-opened as a new PR, splitting the discussion up. Sorry about that! Thanks for the great discussion though. =)\n. Indeed as @rlidwka said. =)\nAt some point, I'd like to improve the documentation to be explicit and clear between \"for users\" vs. \"for implementors\". Right now, this project is combo spec + ready-to-use implementation.\n. I'm not sure how much performance overhead these features really add. My guess is that using JS at all for parsing \u2014 as opposed to using the native JSON.parse \u2014\u00a0is the significant bit here.\nIOW, if you don't need JSON5's features, you'd be better off using the native JSON.parse if you want performance.\n. I'm going to go ahead close this, but if anybody comes up with benchmark data/numbers that disproves my assumption above, please feel free to re-open!\n. I don't feel strongly, but agreed:\nhttps://www.npmjs.org/doc/files/package.json.html#license\n. We can take a look after publishing on the new https://preview.npmjs.com/, and if it's still not showing up there, we can file an issue on https://github.com/npm/npm-www. Thanks @michaelsanford!\n. Nope, no need. Thanks again!\n. Sorry about that, @d10! I missed this over the holidays. Thanks for the ping. =)\n@gasi would love you for the change in quotes. =D\nI will review and would be happy to merge after any changes. Thank you for the PR!\n. LGTM otherwise, thank you @d10!\n. Whoops, I totally missed this PR, sorry about that! Taking a quick look now.\n. Nice work otherwise @AVGP. Thank you for the pull request! =)\n. Good point @ravi. So this won't fix that. Please feel free to open a new issue to add line and column number to syntax error messages. Hopefully it won't be too hard for someone to take a stab at.\n. Fascinating! Thank you.\nDoes anyone else have any thoughts on this? Should we simply do this on all objects we return? Or if, say, the input string was over a certain size?\nOr perhaps we can do this as part of the parse process inline. E.g. on every close quote.\n. Good bug, @sandermarechal. Maybe file this issue with the YUI Compressor first? They'll be able to debug, and tell us if it's something wrong with JSON5's code or a bug in YUI Compressor.\nhttps://github.com/yui/yuicompressor\n. I like the intent, but I'm hesitant at the idea of different implementations supporting different opt-in features. If regexes and dates are in demand, maybe we should just ~support~ edit: formalize syntax like foo: /.../i and bar: Date('...') directly. Still a subset of JS/ES5 and standard, not one-off.\nEither way, I don't personally feel like this should be part of 1.0. IMHO, 1.0's primary goal should be to finalize & formalize what's already been there and what people have already been using. The rough edges you've been smoothing have been awesome! This feels like just a bit beyond the line from polish to new feature to me.\nAll that said \u2014\u00a0don't consider my opinion a show-stopper at this point! You've been doing amazing work @jordanbtucker and I appreciate your leadership and ownership. Even if you move ahead with it, I'll take a page from Jeff Bezos's book and say \"disagree but commit\". =)\nThank you again for your contributions!. I totally forgot about that rant. It's a good one!\nThen I guess I end up back with a conservative stance of \"let's not take this on right now\". =). Also great point about Date. Yuck.. I too have been pretty hesitant about this feature request, because it's hard to know if it's gone just a bit too far beyond the line of \"minimal but useful\"... but I also agree with @jordanbtucker that I too have written 60 * 24 * ... multiple times for (non-JSON) config-ish constant values.\nI'd be okay with adding basic math operators. I would discourage adding **, etc., as those aren't standard ES5 either. (But I do appreciate them in CoffeeScript.)\n. @piranna: I totally agree that functions are beyond the line. A core tenet of JSON(5) is \"it's just data\", not executable code.\n@XGHeaven: agreed, thank you.\nEven with these basic operators, though, it does e.g. make supporting JSON5 in other languages harder. E.g. what is 5 / 0? If we're to be consistent with ES5, it's Infinity. But in most languages, that'd be a runtime error. Or possibly an undefined-ish value.\n. Great discussion indeed! Very good food for thought. =)\nI'll keep chewing on it...\n. Thanks for the idea!\nI'm reluctant with this feature, because {checked} is not the same as {checked: \"checked\"}.\nA core principle of JSON5 is that it's a strict subset of (ES5) JavaScript. Even if we expanded that to ES6, this feature wouldn't pass that test: you couldn't e.g. paste that JSON5 snippet into an ES6 file without changing its meaning.\n. Nice! Thanks for the great contribution.\nI'll try to review this when I get some time, but hopefully one of the other maintainers will beat me.\n. Big +1 to an npm dependency being okay here.\nI also agree some tests would be nice, so no one has to manually test whenever making changes to the CLI code, but they can be basic tests for the logic rather than e.g. the command-line argument parsing (since you're using a dependency for that).\nThanks again!\n. I have to admit I'm pretty hesitant about this feature.\n- JSON(5) is already a format for describing values.\n- There's something elegant about an entire JSON(5) document being a single expression.\n- Do people really need this? Are we really solving a common problem people have? Or are we just considering adding this feature because we can?\n. Whoops, submitted too early.\nAs always, I did want to add: I appreciate the thoughtful discussion, however. And suggestions for improvement are always welcome. =)\nI just feel part of my (limited) role is to be a steward for keeping this project tightly scoped. It's already an uphill battle in many places to use JSON5 at all \u2014 even though all it adds (so far) is mainly just comments, unquoted keys, and trailing commas. Crossing the always ambiguous \"too much\" line will start moving it towards YAML, and JSON5 has always had a selling point that it's simpler.\n. Re: JSON5.stringify specifically: I might be forgetting some earlier discussions, but I still often wonder: what really is JSON5.stringify's purpose \u2014 and what should it be?\n- The problem JSON5 set out to solve was \"make it easier and more human-friendly to write JSON out by hand\", with common use cases like config files and declarative data. \"Write\" == parse.\n- Tooling is a legitimate and great need: it's really helpful if tools can parse human input, amend it in some way, and output it back again. E.g. IDE auto-formatting, npm install --save, etc. But we'll never have this ability as long as comments are stripped, which JSON5.parse does. So if we really want \"parse the JSON5 document in its full original syntax\", JSON5.parse is not it \u2014\u00a0so JSON5.stringify shouldn't be considered the counterpart to it. (Another angle: as long as JSON5.stringify takes data, e.g. a JS object, and not a syntax tree, it doesn't serve this purpose.)\n- Similar to my point about variables, what problem is JSON5.stringify really trying to solve?\nThanks for the discussion again! Looking forward to responses.\n. I'd be okay with just considering the current spec/code 1.0. The main missing feature from the implementation is proper Unicode support, but that's a code issue, and the spec probably matters more than the code (since the code is just a reference implementation).\n:+1: to semver in general.\n. @jordanbtucker: Your suggestion SGTM. I'll also give you npm publish access! Thanks again for all your great work \u2014 it's really helpful to have your hands here.\n. Looks like I need to know your npm username?\n. Ah, jordanbtucker naturally. =) Added!\n. Thanks for the feedback! You're totally right. This is just one of the built-in GitHub Pages themes.\nIt looks like the theme has been improved to have better contrast. What do you think of this?\nhttp://orderedlist.com/minimal/\nTo pick up the changes, I wonder if we just need to re-generate the website.\n. Nice investigation, @AlexDaniel, thanks. I've +1'ed your PR.\nI'm happy to either re-generate the website, or if you want to experiment with the stylesheet on the gh-pages branch of this repo directly, happy to take a PR!\n. Nice! Rebuilt the site, and indeed, contrast looks improved:\nhttp://json5.org/\nThanks again for the feedback!\n. Thank you!\n. Good question. There aren't specifically for JSON5, but since JSON5 is a subset of ES5, you should be able to prettify your JSON5 using any standard JavaScript prettifier.\nLet us know (and feel free to re-open) if you run into any issues!\n. Thanks @jordanbtucker! I was out getting married. =) Cheers.\n. I think this is a great idea too! Thanks guys. =)\n. Great question! cc @jordanbtucker to chime in too.\nI think that's a reasonable goal. The reality is that we haven't shaken the boat with things like dates in all these years, so it's probably unlikely that we will at this point either.\nSo there could be some value in officially and formally \"freezing\" the spec... but I think there's also something to be said for learning from people's experiences and adapting to an ever-changing world.\nHow do others feel?. @seagreen: That sounds like a good perspective to me. Thanks! \ud83d\udc4d . Amazing work @jordanbtucker!! :). @jordanbtucker: This is excellent work!! Thank you as always. =)\nMinor bug: \"A JSON5 parser transforms a JSON text into another representation\" should be \"JSON5 text\", right?. Nice work! I raise both of my hands \ud83d\ude4c \u2014 this is purposely a double-entendre. =). Good suggestion! I like \"JSON for humans\", inspired by Kenneth Reitz's work (e.g. Requests, HTTPie). How do others feel about that?\n(Alternately, the GitHub repo description already also says, \"JSON for the ES5 era\".). Thank you @jordanbtucker! We should re-generate the website too. Do you have the ability to do that? (Under the repo settings.). It's looking great! Thank you @jordanbtucker.\nOne thing I noticed: the license link is broken. I guess GH Pages doesn't automatically translate relative file links in this case, so you may need to explicitly point to github.../blob/master/LICENSE.md.\nSelfishly, I also realize now that my name is not explicitly listed anywhere! (Only the package.json example.) This isn't you; this is the case in the README directly too.\nI'm curious for your opinion: which of the below do you think is better?\n\nTweak the license line to say \"MIT \u00a9 Aseem Kishore and others\", like our actual license file.\n  -or-\nAdd my name to the \"Credits\" section? E.g. \"Aseem Kishore created this project and authored the first version.\" (And maybe link to the Hacker News reaction for fun\u2026 :trollface:)\n\nFeel free to make either change (both in your PR and on the master README), but I'm happy to do either also if that'd help.\nThanks again for the great work!. Sorry @jordanbtucker, I forgot about this PR and just updated the website myself:\nhttp://json5.org/\nEverything LGTY?. You can simply use JSON.stringify (instead of JSON5.stringify) which is built into all JavaScript engines these days.\nHope that helps! Feel free to re-open if not.. Ah, that's surprising and too bad.\nJSON.stringify is part of the official ES5 standard, which is pretty pervasive these days, so I'm not sure it'd be worth the API surface area for JSON5.stringify to re-implement that. We also probably wouldn't do it as robustly or as fast as other libraries, e.g. https://github.com/bestiejs/json3.\nGood luck!. Not a bad idea! Unobtrusive, and a quick and easy way for people to use existing JS tooling on their JSON5 data.. Thanks for your first-time contribution, @lifuzu!\nI'm personally pretty wary of supporting functions in JSON5, as they pretty firmly move us away from being a data format to now supporting arbitrary behaviors.\nI know there are use cases, but I'd say for anything non-trivial, if you need functions, you might be better off just using JS directly rather than JSON5.\nThe other major problem with them is that they'll only work on JS runtimes. These days there are JSON5 parsers for other platforms too.\nSo I don't think we'll be able to merge this, but your thoughts/questions/etc. welcome!. ",
    "rlidwka": "Full unicode testing could take as much space as the rest of the library. :)\nBut I think it's worth it. You could generate this using esprima tools and just hardcode it into the library, since it's unlikely to be changed, or just take this one.\nPS: dependencies aren't an issue, because you can always use browserify. \n. You can do this:\njavascript\n{\"type\":\"Date\",\"data\":\"2013-10-07T18:06:03.048Z\"}\nNote that starting with node 0.11.x (https://github.com/joyent/node/commit/840a29fc0fd256a63b3f2f5e7528de5107a608a3) Buffer type is going to be serialized this way:\njavascript\n{\"type\":\"Buffer\",\"data\":[116,101,115,116]}\nSo it has a chance of becoming \"kinda standard\", translating {type:XXX,data:YYY} to new XXX(YYY). Same could be done for regexps and any user-defined type somebody would want.\n. > but in this case, the native Date#toJSON() already outputs an ISO 8601 string\nThe key issue here is that when you're doing Date.toJSON(), type information is lost. In other words, you can't possibly make so both these assertions are true while preserving current Date.toJSON() serialization:\njavascript\nvar x = new Date();\nvar y = String(x);\nassert.deepEqual(x, JSON.parse(JSON.stringify(x)));\nassert.deepEqual(y, JSON.parse(JSON.stringify(y)));\nJSON fails first one, reviver suggestion fails second one.\nIs that important so you convert a date to JSON5 and back, and get the same date object again? I guess that's the answer we have to answer here. \n. {1:true} is a valid JS object.\nAn example of this notation can be found on the link you posted in the \"String literals\" chapter:\nhttps://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Object_literals\n. require('./json5').parse('{1:true}') doesn't work. I don't know whether it counts as unexpected or not.\n. > (Interestingly, the first case gives that syntax error in Chrome, but not Node.)\nIt can happen because first \"{\" is treated as a beginning of a block (as in {var x=0;}), not as an object.\nIf you want to test such kind of things reliably, add parentheses around the statement. This: ({1:true}) should work everywhere.\n. So what about NaN? It's the same kind of IEEE 754 floating point numbers, and as far as I know, all languages that support Infinities support NaN as well.\nnull is not applicable here because null is not technically a number, but NaN is.\n. No, and I don't have any need for specifying Infinities either. I don't really remember when I needed to represent any numbers.\nIt is a theoretical issue, number theory.\nIf you restrict representation to any real number, you have a field, which means for every number a and b you can always represent a+b and a-b. But you can't really represent a*b and a/b.\nThat's where Infinities come in. If you restrict representation to any real number, Infinities and NaN, it should be a ring, which means you can represent all operations (a+b, a-b, a*b and a/b).\nBut if you add Infinities without a NaN, you'll have neither. you can't represent a result of Infinity-Infinity, and you can't represent a result of Infinity/Infinity. So when somebody writes \"a-b\", he can't be sure if he will get a number.\nThat's why from mathematical point of view current situation really makes no sense. And the same reason is why all programming languages having Infinity also have NaN.\nPS: null is not a replacement for it:\n1. typeof(NaN) === 'number', typeof(null) !== 'number'\n2. null + 1 === 1, NaN + 1 !== 1\n. I don't entirely understand why signed hexadecimals are not valid.\nThis seem to work just fine for me:\n``` javascript\n\neval('(function(){\"use strict\";return -0xC8})()')\n-200\n``\n. @tarlepp , I think it might be worth it to ask core team to change[ [Object] ]to[ /Object/ ]`. This way json5 parser will parse it correctly.\n. > Yes, they already did that ( thanks to sails.js team ).\n\nWe're talking about util.inspect() function in node.js core, right? It still produces [Object] in those cases.\nDid sails.js return raw inspect output instead of javascript?\n. > My understanding is that until there is an RFC for this, there should be a vnd prefix to the sub-type, so this would be preferred: \n\"vnd.\" prefix should be registered to use. Unregistered prefix is \"x-\", but it has been deprecated, although still widely used, i.e. YAML uses text/x-yaml currently. I think \"vnd.\" prefix is more suited for private formats that will never be standardized.\n. Mixing tabs and spaces is definitely a no-go, but if you're forced to choose, tabs are better for quite a few reasons. So I'd say \"-1\" to that.\n. > And how about support for 'undefined' values and sparsed arrays in JSON5?\n1. what is the practical difference between undefined and null?\n2. what is the practical difference between [,,] and [null,null]?\nwhen I was working on my own implementation, I was thinking about that as well, but didn't find any good reasons to implement those\nalso, see #19 for discussion about sparsed arrays\n. > [0:0,10000:10000,non_numeric_property:\"zzz\"/why not?/]\nnot valid javascript\n. #19\n. When I was implementing tests for my json5 parser, I took this approach:\n1. got existing json5 tests and tweaked them a bit\n2. got existing v8 json tests and tweaked them a bit\n3. threw a bunch of random data and made sure that JSON5.parse(JSON5.stringify(x)) == x\n4. threw a bunch of random strings and made sure that for each of my tests results are equal to at least one of these functions:\n   - JSON.parse(something)\n   - eval('(function(){return ('+String(something)+'\\n)\\n})()')\nYou can do the same thing, just compare your output with the existing json5 parsers.\nPS: is there a portable test data set for a classic JSON?\n. > Is there a portable test data set?\nI just created one here: https://github.com/rlidwka/jju/blob/master/test/portable-json5-tests.yaml\nAbout a hundred tests, should cover pretty much anything about literals notation in ES5 spec.\n. > 1. Lines 95 and 100: I think you have object and array mixed up\noops... you're right :)\n\n\nJSON will stringify NaN and Infinity to null.\n\n\nYeah, initially I wanted to write \"this is json5, this is corresponding json\", but I got this exact issue. Then I thought \"hey, I'm using yaml anyway, so why do I need json at all\"?\nSo tests are written using YAML. It supports infinity using +.inf syntax, so if target platform supports yaml, you can just compare output with the result of JSON5.parse(input), and it should work.\nIf someone converts it all to json, NaN's would be lost of course, so it would be a special case. Maybe do a JSON.stringify(JSON5.parse(input)) == JSON.stringify(output) check or something.\n. > What would be awesome is to see a json6 spec with ecmascript 6 grammar which would include support for multi-line string templates.\nAgreed. But ES6 templates aren't just multi-line strings, they're more powerful than that, so it'd need some discussion.\n. use BSON then, it's language-agnostic and fast to parse\n. Already done 7 months ago. :)\nhttps://github.com/rlidwka/jju/blob/master/docs/Grammar.md\n. Yeah, you see two different approaches here. This repository (and its grammar in wiki) is based on JSON parser. But in my implementation I actually got ES5 grammar and worked down from there, reducing features.\nSo all the differences you see are probably differences between JSON and JavaScript that haven't been resolved yet. And a potential source of the confusion for users trying to use JS grammar with JSON5.\n. Offtopic: which language? Can we make a list of existing parsers somewhere? Do all tests pass?\n. I'll just note that +NaN and -NaN is the same value:\n``` javascript\n\nObject.is(+NaN, -NaN)\ntrue\n```\n\nSo it should be stringified as NaN.\n. > But maybe it would be better to move these functions like isWord into their own \"helper\" module to avoid leaking.\nYes, it would be.\n. -1\nJSON5 is defined as JavaScript subset, not as JSON superset, so it makes sense to use it as such.\nThe fact that JSON is not a proper subset is creating issues (see JSONP for example - https://github.com/strongloop/express/issues/1132). It would be nice if JSON5 would fix those.\n. > Is that the only case where JSON itself isn't a strict subset of ES5? Or are there others?\nThose two characters are the only case.\n. You're welcome to clone my implementation here, I went for the config object.\nUsers might want to configure trailing comma and other stuff, so it seems most appropriate here.\n. It's not that simple. :)\n``` js\n\nrequire('jju').parse('\"\\0\"')\n'\\u0000'\nrequire('json5').parse('\"\\0\"')\n'0'\n```\n\n``` js\n\nrequire('jju').parse('\"\\1\"')\n'\\u0001'\nrequire('json5').parse('\"\\1\"')\n'1'\n```\n\n``` js\n\nrequire('jju').parse('\"\\8\"')\nSyntaxError: Unexpected token '\"' at 1:4\n\"\\8\"\n   ^\nrequire('json5').parse('\"\\8\"')\n'8'\n```\n\n``` js\n\nrequire('jju').parse('\"\\v\"')\n'\\u000b'\nrequire('json5').parse('\"\\v\"')\n'v'\n```\n\n``` js\n\nrequire('jju').parse('\"\\x\"')\nSyntaxError: Bad escape sequence at 1:4\n\"\\x\"\n   ^\nrequire('json5').parse('\"\\x\"')\n'x'\n``\n. PS:\\1and\\8stuff is controversial, but\\x` pretty surely should be an error...\n. > Good catches, @rlidwka.\n\nOh well... I'm afraid I have about 30 good catches in this module. :(   I wonder if it even makes sense to list every one.\n\n\\1 - \\7 are octal escapes, so they're only supported in non-strict modes, but Node, Chrome, and Firefox allow \\8 and \\9, even in strict mode.\n\nYeah, octals is a whole other question that need to be discussed elsewhere. I think I'll create an issue about that.\n. > I think I'll create an issue about that.\nhttps://github.com/aseemk/json5/issues/76\n. > I'm also not a fan of the potentially ambiguous 0O000 sytax\nThere was a talk about forbidding uppercase \"O\" while allowing lowercase one, I don't remember what they ended up with.\n. As far as I understand it, they are optional for people who use JSON5 documents. Meaning you can write JSON and be able to parse it with JSON5 parser.\nThings like single quotes/comments/etc. are certainly required for all implementations.\n. If you're looking to improve parsing speed, it's better to optimize the code, not turn off features.\n. it should be just license: 'MIT' imho\n. https://github.com/aseemk/json5/issues/40\n. yes\n. duplicate of https://github.com/aseemk/json5/issues/52\n. Thoughts are pretty skeptic, and the published workaround isn't a very good one.\nHowever, char-by-char concatenation in general isn't efficient. Maybe instead of var str = ''; str += 'x'; return str we could do var arr = []; arr.push('x'); return arr.join('') or something.\nAlso, any benchmarks?\n. what exception does it throw?\n. Full unicode testing could take as much space as the rest of the library. :)\nBut I think it's worth it. You could generate this using esprima tools and just hardcode it into the library, since it's unlikely to be changed, or just take this one.\nPS: dependencies aren't an issue, because you can always use browserify. \n. You can do this:\njavascript\n{\"type\":\"Date\",\"data\":\"2013-10-07T18:06:03.048Z\"}\nNote that starting with node 0.11.x (https://github.com/joyent/node/commit/840a29fc0fd256a63b3f2f5e7528de5107a608a3) Buffer type is going to be serialized this way:\njavascript\n{\"type\":\"Buffer\",\"data\":[116,101,115,116]}\nSo it has a chance of becoming \"kinda standard\", translating {type:XXX,data:YYY} to new XXX(YYY). Same could be done for regexps and any user-defined type somebody would want.\n. > but in this case, the native Date#toJSON() already outputs an ISO 8601 string\nThe key issue here is that when you're doing Date.toJSON(), type information is lost. In other words, you can't possibly make so both these assertions are true while preserving current Date.toJSON() serialization:\njavascript\nvar x = new Date();\nvar y = String(x);\nassert.deepEqual(x, JSON.parse(JSON.stringify(x)));\nassert.deepEqual(y, JSON.parse(JSON.stringify(y)));\nJSON fails first one, reviver suggestion fails second one.\nIs that important so you convert a date to JSON5 and back, and get the same date object again? I guess that's the answer we have to answer here. \n. {1:true} is a valid JS object.\nAn example of this notation can be found on the link you posted in the \"String literals\" chapter:\nhttps://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Object_literals\n. require('./json5').parse('{1:true}') doesn't work. I don't know whether it counts as unexpected or not.\n. > (Interestingly, the first case gives that syntax error in Chrome, but not Node.)\nIt can happen because first \"{\" is treated as a beginning of a block (as in {var x=0;}), not as an object.\nIf you want to test such kind of things reliably, add parentheses around the statement. This: ({1:true}) should work everywhere.\n. So what about NaN? It's the same kind of IEEE 754 floating point numbers, and as far as I know, all languages that support Infinities support NaN as well.\nnull is not applicable here because null is not technically a number, but NaN is.\n. No, and I don't have any need for specifying Infinities either. I don't really remember when I needed to represent any numbers.\nIt is a theoretical issue, number theory.\nIf you restrict representation to any real number, you have a field, which means for every number a and b you can always represent a+b and a-b. But you can't really represent a*b and a/b.\nThat's where Infinities come in. If you restrict representation to any real number, Infinities and NaN, it should be a ring, which means you can represent all operations (a+b, a-b, a*b and a/b).\nBut if you add Infinities without a NaN, you'll have neither. you can't represent a result of Infinity-Infinity, and you can't represent a result of Infinity/Infinity. So when somebody writes \"a-b\", he can't be sure if he will get a number.\nThat's why from mathematical point of view current situation really makes no sense. And the same reason is why all programming languages having Infinity also have NaN.\nPS: null is not a replacement for it:\n1. typeof(NaN) === 'number', typeof(null) !== 'number'\n2. null + 1 === 1, NaN + 1 !== 1\n. I don't entirely understand why signed hexadecimals are not valid.\nThis seem to work just fine for me:\n``` javascript\n\neval('(function(){\"use strict\";return -0xC8})()')\n-200\n``\n. @tarlepp , I think it might be worth it to ask core team to change[ [Object] ]to[ /Object/ ]`. This way json5 parser will parse it correctly.\n. > Yes, they already did that ( thanks to sails.js team ).\n\nWe're talking about util.inspect() function in node.js core, right? It still produces [Object] in those cases.\nDid sails.js return raw inspect output instead of javascript?\n. > My understanding is that until there is an RFC for this, there should be a vnd prefix to the sub-type, so this would be preferred: \n\"vnd.\" prefix should be registered to use. Unregistered prefix is \"x-\", but it has been deprecated, although still widely used, i.e. YAML uses text/x-yaml currently. I think \"vnd.\" prefix is more suited for private formats that will never be standardized.\n. Mixing tabs and spaces is definitely a no-go, but if you're forced to choose, tabs are better for quite a few reasons. So I'd say \"-1\" to that.\n. > And how about support for 'undefined' values and sparsed arrays in JSON5?\n1. what is the practical difference between undefined and null?\n2. what is the practical difference between [,,] and [null,null]?\nwhen I was working on my own implementation, I was thinking about that as well, but didn't find any good reasons to implement those\nalso, see #19 for discussion about sparsed arrays\n. > [0:0,10000:10000,non_numeric_property:\"zzz\"/why not?/]\nnot valid javascript\n. #19\n. When I was implementing tests for my json5 parser, I took this approach:\n1. got existing json5 tests and tweaked them a bit\n2. got existing v8 json tests and tweaked them a bit\n3. threw a bunch of random data and made sure that JSON5.parse(JSON5.stringify(x)) == x\n4. threw a bunch of random strings and made sure that for each of my tests results are equal to at least one of these functions:\n   - JSON.parse(something)\n   - eval('(function(){return ('+String(something)+'\\n)\\n})()')\nYou can do the same thing, just compare your output with the existing json5 parsers.\nPS: is there a portable test data set for a classic JSON?\n. > Is there a portable test data set?\nI just created one here: https://github.com/rlidwka/jju/blob/master/test/portable-json5-tests.yaml\nAbout a hundred tests, should cover pretty much anything about literals notation in ES5 spec.\n. > 1. Lines 95 and 100: I think you have object and array mixed up\noops... you're right :)\n\n\nJSON will stringify NaN and Infinity to null.\n\n\nYeah, initially I wanted to write \"this is json5, this is corresponding json\", but I got this exact issue. Then I thought \"hey, I'm using yaml anyway, so why do I need json at all\"?\nSo tests are written using YAML. It supports infinity using +.inf syntax, so if target platform supports yaml, you can just compare output with the result of JSON5.parse(input), and it should work.\nIf someone converts it all to json, NaN's would be lost of course, so it would be a special case. Maybe do a JSON.stringify(JSON5.parse(input)) == JSON.stringify(output) check or something.\n. > What would be awesome is to see a json6 spec with ecmascript 6 grammar which would include support for multi-line string templates.\nAgreed. But ES6 templates aren't just multi-line strings, they're more powerful than that, so it'd need some discussion.\n. use BSON then, it's language-agnostic and fast to parse\n. Already done 7 months ago. :)\nhttps://github.com/rlidwka/jju/blob/master/docs/Grammar.md\n. Yeah, you see two different approaches here. This repository (and its grammar in wiki) is based on JSON parser. But in my implementation I actually got ES5 grammar and worked down from there, reducing features.\nSo all the differences you see are probably differences between JSON and JavaScript that haven't been resolved yet. And a potential source of the confusion for users trying to use JS grammar with JSON5.\n. Offtopic: which language? Can we make a list of existing parsers somewhere? Do all tests pass?\n. I'll just note that +NaN and -NaN is the same value:\n``` javascript\n\nObject.is(+NaN, -NaN)\ntrue\n```\n\nSo it should be stringified as NaN.\n. > But maybe it would be better to move these functions like isWord into their own \"helper\" module to avoid leaking.\nYes, it would be.\n. -1\nJSON5 is defined as JavaScript subset, not as JSON superset, so it makes sense to use it as such.\nThe fact that JSON is not a proper subset is creating issues (see JSONP for example - https://github.com/strongloop/express/issues/1132). It would be nice if JSON5 would fix those.\n. > Is that the only case where JSON itself isn't a strict subset of ES5? Or are there others?\nThose two characters are the only case.\n. You're welcome to clone my implementation here, I went for the config object.\nUsers might want to configure trailing comma and other stuff, so it seems most appropriate here.\n. It's not that simple. :)\n``` js\n\nrequire('jju').parse('\"\\0\"')\n'\\u0000'\nrequire('json5').parse('\"\\0\"')\n'0'\n```\n\n``` js\n\nrequire('jju').parse('\"\\1\"')\n'\\u0001'\nrequire('json5').parse('\"\\1\"')\n'1'\n```\n\n``` js\n\nrequire('jju').parse('\"\\8\"')\nSyntaxError: Unexpected token '\"' at 1:4\n\"\\8\"\n   ^\nrequire('json5').parse('\"\\8\"')\n'8'\n```\n\n``` js\n\nrequire('jju').parse('\"\\v\"')\n'\\u000b'\nrequire('json5').parse('\"\\v\"')\n'v'\n```\n\n``` js\n\nrequire('jju').parse('\"\\x\"')\nSyntaxError: Bad escape sequence at 1:4\n\"\\x\"\n   ^\nrequire('json5').parse('\"\\x\"')\n'x'\n``\n. PS:\\1and\\8stuff is controversial, but\\x` pretty surely should be an error...\n. > Good catches, @rlidwka.\n\nOh well... I'm afraid I have about 30 good catches in this module. :(   I wonder if it even makes sense to list every one.\n\n\\1 - \\7 are octal escapes, so they're only supported in non-strict modes, but Node, Chrome, and Firefox allow \\8 and \\9, even in strict mode.\n\nYeah, octals is a whole other question that need to be discussed elsewhere. I think I'll create an issue about that.\n. > I think I'll create an issue about that.\nhttps://github.com/aseemk/json5/issues/76\n. > I'm also not a fan of the potentially ambiguous 0O000 sytax\nThere was a talk about forbidding uppercase \"O\" while allowing lowercase one, I don't remember what they ended up with.\n. As far as I understand it, they are optional for people who use JSON5 documents. Meaning you can write JSON and be able to parse it with JSON5 parser.\nThings like single quotes/comments/etc. are certainly required for all implementations.\n. If you're looking to improve parsing speed, it's better to optimize the code, not turn off features.\n. it should be just license: 'MIT' imho\n. https://github.com/aseemk/json5/issues/40\n. yes\n. duplicate of https://github.com/aseemk/json5/issues/52\n. Thoughts are pretty skeptic, and the published workaround isn't a very good one.\nHowever, char-by-char concatenation in general isn't efficient. Maybe instead of var str = ''; str += 'x'; return str we could do var arr = []; arr.push('x'); return arr.join('') or something.\nAlso, any benchmarks?\n. what exception does it throw?\n. ",
    "1354092549": "\nConsume Unicode escape sequences and forego testing them against appropriate Unicode classes, willfully violating the ES5 spec.\n\nMaybe this is enough.. > Consume Unicode escape sequences and forego testing them against appropriate Unicode classes, willfully violating the ES5 spec.\nMaybe this is enough.. ",
    "MaxNanasy": "I think disallowing octal literals would be justified, since ES5 disallows octal literals in strict mode (see http://es5.github.com/#B.1).\n. Some data (using V8):\n\n\nExpression/SourceResult\n\n\nJSON5.parse('010')10\nJSON.parse('010')<Syntax error>\n0108\n(function () { \"use strict\"; return 010; })()<Syntax error>\n([http://json.org]).parse('010')<Syntax error>\n\n\nI feel like JSON5.parse('010') should throw a syntax error.\nAlso see https://mail.mozilla.org/pipermail/es-discuss/2009-June/009428.html, which discusses whether or not to validate octalish literals when parsing JSON and seems to reach the same consensus.\n. In strict mode, the ES5 spec, SpiderMonkey, and V8 disallow octal literals such as 07.  However, in strict mode, the ES5 spec and SpiderMonkey disallow, but V8 allows, noctal literals (so-called because they have a leading 0 but non-octal digits) such as 08 or 078, which it interprets as decimal.  Do you think that JSON5 should support noctal literals?  I do not.\n. npm test worked for me on Windows 7 using commit b511ff40589b7434779c57f65ca5f3047b246e08 in branch develop.  I had to run npm install first.\nnpm link was also not supported for me in Windows.\n. The JSON grammar at http://json.org does not allow it.\n. The only other deviation from the JSON grammar I've noticed in json_parse.js is that it allows a leading '0' in decimal literals (they are still interpreted as decimal, not octal).\n. FYI: The closing of this pull request was accidental :P.\n. I'm inclined to allow them, because ES5 allows them, and I don't see any downsides to allowing them.\n. I didn't really have a strong opinion either way as to whether this should be in the language, but I see what you mean by not changing for the sake of change, so I'm closing the pull request.\n. NP\n. @aseemk RE: JSON.parse('\"\\.svn\"'): I think you meant JSON.parse('\"\\\\.svn\"'), which also results in SyntaxError: Unexpected token ..\n. @aseemk The above also applies to this comment on Issue #21.\n. @aseemk \n\nI wonder if this should be a standalone jQuery plugin, or if utilities like this should be part of this project/repo. Let me think about it.\n\nI view it as analogous to #11 (Node require() support): it's five lines of trivial code for a popular library.  However, I think that it should probably be in its own project (mostly for idealistic reasons), which leads me to believe that maybe Node require() support should also be in a separate project.\n. I think disallowing octal literals would be justified, since ES5 disallows octal literals in strict mode (see http://es5.github.com/#B.1).\n. Some data (using V8):\n\n\nExpression/SourceResult\n\n\nJSON5.parse('010')10\nJSON.parse('010')<Syntax error>\n0108\n(function () { \"use strict\"; return 010; })()<Syntax error>\n([http://json.org]).parse('010')<Syntax error>\n\n\nI feel like JSON5.parse('010') should throw a syntax error.\nAlso see https://mail.mozilla.org/pipermail/es-discuss/2009-June/009428.html, which discusses whether or not to validate octalish literals when parsing JSON and seems to reach the same consensus.\n. In strict mode, the ES5 spec, SpiderMonkey, and V8 disallow octal literals such as 07.  However, in strict mode, the ES5 spec and SpiderMonkey disallow, but V8 allows, noctal literals (so-called because they have a leading 0 but non-octal digits) such as 08 or 078, which it interprets as decimal.  Do you think that JSON5 should support noctal literals?  I do not.\n. npm test worked for me on Windows 7 using commit b511ff40589b7434779c57f65ca5f3047b246e08 in branch develop.  I had to run npm install first.\nnpm link was also not supported for me in Windows.\n. The JSON grammar at http://json.org does not allow it.\n. The only other deviation from the JSON grammar I've noticed in json_parse.js is that it allows a leading '0' in decimal literals (they are still interpreted as decimal, not octal).\n. FYI: The closing of this pull request was accidental :P.\n. I'm inclined to allow them, because ES5 allows them, and I don't see any downsides to allowing them.\n. I didn't really have a strong opinion either way as to whether this should be in the language, but I see what you mean by not changing for the sake of change, so I'm closing the pull request.\n. NP\n. @aseemk RE: JSON.parse('\"\\.svn\"'): I think you meant JSON.parse('\"\\\\.svn\"'), which also results in SyntaxError: Unexpected token ..\n. @aseemk The above also applies to this comment on Issue #21.\n. @aseemk \n\nI wonder if this should be a standalone jQuery plugin, or if utilities like this should be part of this project/repo. Let me think about it.\n\nI view it as analogous to #11 (Node require() support): it's five lines of trivial code for a popular library.  However, I think that it should probably be in its own project (mostly for idealistic reasons), which leads me to believe that maybe Node require() support should also be in a separate project.\n. ",
    "arunoda": "Why we need Date serialization since we have data.getTime() ?\n. Why we need Date serialization since we have data.getTime() ?\n. ",
    "chilts": "Of course, instead of\nJSON.stringify(new Date())\nyou can always\n(new Date()).toISOString();\nI kinda like the latter better. :)\n. Of course, instead of\nJSON.stringify(new Date())\nyou can always\n(new Date()).toISOString();\nI kinda like the latter better. :)\n. ",
    "ForbesLindesay": "This input JSON.stringify(new Date());\nGives this output \"2012-05-29T13:00:29.886Z\" (at least it does in Chrome)\nSo I think all we need to do is parse that and turn it into a date?  It would mean that a string in exactly that format would also be parsed as a date, which isn't ideal.  But I think it's fair to say that if you get something in that format it will be a date.\n. Hmm, I take your point about not necessarily being easier to write, but long term it might be nice to view this as a potential replacement for traditional JSON even when the JSON is generated, in which case date representation would be high on people's priorities.  We could consider supporting dates of the form\njavascript\n{myDateField:16/06/1981, myTimeField:16:08}\nThe only problem then is you make a lot of decisions (english vs. american, 24hr vs.12hr).  ISO saves us from those judgements.\n. I like that idea\n. This input JSON.stringify(new Date());\nGives this output \"2012-05-29T13:00:29.886Z\" (at least it does in Chrome)\nSo I think all we need to do is parse that and turn it into a date?  It would mean that a string in exactly that format would also be parsed as a date, which isn't ideal.  But I think it's fair to say that if you get something in that format it will be a date.\n. Hmm, I take your point about not necessarily being easier to write, but long term it might be nice to view this as a potential replacement for traditional JSON even when the JSON is generated, in which case date representation would be high on people's priorities.  We could consider supporting dates of the form\njavascript\n{myDateField:16/06/1981, myTimeField:16:08}\nThe only problem then is you make a lot of decisions (english vs. american, 24hr vs.12hr).  ISO saves us from those judgements.\n. I like that idea\n. ",
    "polotek": "In v8 (not sure about other engines), the Date prototype has a toJSON method which the spec for JSON.stringify respects. The toJSON method seems to just return the ISO 8601 string. So in v8 you're already set up to stringify dates properly. You just need to parse them back out. I left this on the node list, but I'll leave it here too.\nhttps://gist.github.com/2504336#gistcomment-281565\nNote that this uses try/catch which has perf implications. But I've heard that JSON.parse is already pretty slow anyway :)\n. In v8 (not sure about other engines), the Date prototype has a toJSON method which the spec for JSON.stringify respects. The toJSON method seems to just return the ISO 8601 string. So in v8 you're already set up to stringify dates properly. You just need to parse them back out. I left this on the node list, but I'll leave it here too.\nhttps://gist.github.com/2504336#gistcomment-281565\nNote that this uses try/catch which has perf implications. But I've heard that JSON.parse is already pretty slow anyway :)\n. ",
    "shish": "When representing dates as strings, anything other than ISO 8601 is a world of pain, as you get into special cases, custom parsers, and guesswork that differs between implementations...\nI'm pretty sure a perfect implementation would be impossible - storing as strings and then attempting to turn all strings into dates would have false positives; storing as non-strings breaks the purity of the format :S\nA possibility:\n{\n    mydate: {\n        advanced_type: \"date\",\n        advanced_data: \"2012-05-02T12:03\"\n    }\n}\n? That would also allow for other advanced data types, though I can't think of any other practical ones. At a stretch, {advanced_type: \"image\", advanced_data: \"base64 encoded pixels go here\"}.\nThat is should be fairly unambiguous and easy to process, I imagine; it is quite a lot more typing than a single string though v.v\n. When representing dates as strings, anything other than ISO 8601 is a world of pain, as you get into special cases, custom parsers, and guesswork that differs between implementations...\nI'm pretty sure a perfect implementation would be impossible - storing as strings and then attempting to turn all strings into dates would have false positives; storing as non-strings breaks the purity of the format :S\nA possibility:\n{\n    mydate: {\n        advanced_type: \"date\",\n        advanced_data: \"2012-05-02T12:03\"\n    }\n}\n? That would also allow for other advanced data types, though I can't think of any other practical ones. At a stretch, {advanced_type: \"image\", advanced_data: \"base64 encoded pixels go here\"}.\nThat is should be fairly unambiguous and easy to process, I imagine; it is quite a lot more typing than a single string though v.v\n. ",
    "emirotin": "Microsoft (sorry for that :)) has it solved like that \n1. http://stackoverflow.com/questions/726334/asp-net-mvc-jsonresult-date-format\n2. http://msdn.microsoft.com/en-us/library/bb299886.aspx\n. Microsoft (sorry for that :)) has it solved like that \n1. http://stackoverflow.com/questions/726334/asp-net-mvc-jsonresult-date-format\n2. http://msdn.microsoft.com/en-us/library/bb299886.aspx\n. ",
    "ashmind": "I have thought on this for a while.\nI see two main user groups:\n1. Services generating/consuming JSON that want to pass dates around (especially without defining field schema in advance)\n2. People writing JSON by hand (configuration, complex command-line args, etc)\nMain problem with strings is that you have to define common schema between sender and receiver. Since only dates need that, it is a really weird limitation. Another problem is that in JavaScript, your JSON object would not represent the same JS object, so either you have to do postprocessing, or include schema support in JSON lib, or do some random hacks based on string format (similar to what MS does).\nHere are the options I see for non-string solutions:\n1. Push for ISO-8601 date literals in JS vNext (e.g. ES7). This works well for both groups, but obviously hard to do and with unknown timelines.\n2. Parse new Date(\"ISO8601String\"). Literally hardcode this on the parser level, so new with  anything else or non ISO8601 string parameters are a syntax error. This is valid JS, and works well for web services, but kind of annoying to write manually.\nI would much prefer option 1, but if it not realistic, I think that option 2 is a good substitute that solves problems with string approaches.\n. I have thought on this for a while.\nI see two main user groups:\n1. Services generating/consuming JSON that want to pass dates around (especially without defining field schema in advance)\n2. People writing JSON by hand (configuration, complex command-line args, etc)\nMain problem with strings is that you have to define common schema between sender and receiver. Since only dates need that, it is a really weird limitation. Another problem is that in JavaScript, your JSON object would not represent the same JS object, so either you have to do postprocessing, or include schema support in JSON lib, or do some random hacks based on string format (similar to what MS does).\nHere are the options I see for non-string solutions:\n1. Push for ISO-8601 date literals in JS vNext (e.g. ES7). This works well for both groups, but obviously hard to do and with unknown timelines.\n2. Parse new Date(\"ISO8601String\"). Literally hardcode this on the parser level, so new with  anything else or non ISO8601 string parameters are a syntax error. This is valid JS, and works well for web services, but kind of annoying to write manually.\nI would much prefer option 1, but if it not realistic, I think that option 2 is a good substitute that solves problems with string approaches.\n. ",
    "tracker1": "An iso format date, with at least yyyy-mm-dd should be parsed and turned into a Date object, it's easy enough to detect.. yes, a hydration script could be used, but at this point the ISO serialization has been standard in ES for over half a decade, so deserializing makes sense, the trouble is the offset, though it's probably best to just use new Date(Date.parse(str)) and leave it at that for detection.\nThe following regex should match the above serializations.\n```\nvar reSerializedDate = /^\\d{4}-\\d\\d-\\d\\d([T ]\\d\\d(\\:\\d\\d(\\:\\d\\d(.\\d{3,9)?)?)?(Z|[+-]\\d\\d\\:?\\d\\d)?)?$/;\nif (typeof str === 'string' && str.length > 9 && str.length < 36 && reSerializedDate.test(str) {\n  return new Date(Date.parse(str));\n}\n```\nThe reason to use Date.parse over just new Date(str) is because Date.parse is more likely to be polyfilled than the Date itself... (I wrote one of the first polyfills for new Date, and it was rather evil).  There are better fills for Date.parse out there, and in wider usage.\n. An iso format date, with at least yyyy-mm-dd should be parsed and turned into a Date object, it's easy enough to detect.. yes, a hydration script could be used, but at this point the ISO serialization has been standard in ES for over half a decade, so deserializing makes sense, the trouble is the offset, though it's probably best to just use new Date(Date.parse(str)) and leave it at that for detection.\nThe following regex should match the above serializations.\n```\nvar reSerializedDate = /^\\d{4}-\\d\\d-\\d\\d([T ]\\d\\d(\\:\\d\\d(\\:\\d\\d(.\\d{3,9)?)?)?(Z|[+-]\\d\\d\\:?\\d\\d)?)?$/;\nif (typeof str === 'string' && str.length > 9 && str.length < 36 && reSerializedDate.test(str) {\n  return new Date(Date.parse(str));\n}\n```\nThe reason to use Date.parse over just new Date(str) is because Date.parse is more likely to be polyfilled than the Date itself... (I wrote one of the first polyfills for new Date, and it was rather evil).  There are better fills for Date.parse out there, and in wider usage.\n. ",
    "icefoxen": "Parsing \"any string that looks like a Foo\" is almost never what you actually want in the end; it sounds like a glorious way to get some very annoying and subtle edge cases.\nYes you would hope that an ISO date string is specific enough to not be a problem but that's still an assumption.  Assumptions in specifications is why we need JSON5 over normal JSON in the first place.. Or you could use type constructors as have been used by languages based off of formal type systems for the past 45 years:\n{\n  date: Date(\"05 October 2011 14:48 UTC\"),\n  map: Map({2:\"two\"}),\n  object: Object({two, 2}),\n  array: [1, 2, 'foo', 'foo'],\n  float32array: F32([21, 31]),\n  float64array: F64([21, 31]),\n  set: Set([1, 2,'foo']),\n  regex: Regex(\"/match/i\"),\n  function: Function(arg1, arg2, null)\n}\nIs it pretty?  Eh, not really.  Is it simple, unambiguous, extensible, easy to read, easy to parse, and used widely in other languages, including Elm, Rust, and type constructors for just about everything else?  Yes.  How difficult does one really need to make things?\nThat said, it's probably not valid JS, so.. Parsing \"any string that looks like a Foo\" is almost never what you actually want in the end; it sounds like a glorious way to get some very annoying and subtle edge cases.\nYes you would hope that an ISO date string is specific enough to not be a problem but that's still an assumption.  Assumptions in specifications is why we need JSON5 over normal JSON in the first place.. Or you could use type constructors as have been used by languages based off of formal type systems for the past 45 years:\n{\n  date: Date(\"05 October 2011 14:48 UTC\"),\n  map: Map({2:\"two\"}),\n  object: Object({two, 2}),\n  array: [1, 2, 'foo', 'foo'],\n  float32array: F32([21, 31]),\n  float64array: F64([21, 31]),\n  set: Set([1, 2,'foo']),\n  regex: Regex(\"/match/i\"),\n  function: Function(arg1, arg2, null)\n}\nIs it pretty?  Eh, not really.  Is it simple, unambiguous, extensible, easy to read, easy to parse, and used widely in other languages, including Elm, Rust, and type constructors for just about everything else?  Yes.  How difficult does one really need to make things?\nThat said, it's probably not valid JS, so.. ",
    "davidwkeith": "A few thoughts:\n\nDates are great, but we now have Maps, Sets, URLs, and more.\nHex literals start with 0x, so there is precedence for 'special strings' defining types in ECMAScript.\nECMAScript should have other literal formats, it would be nice to have a standard form to define literals.\n\nI agree with the desire to make JSON5 valid ECMAScript, but that doesn't mean we can't advance EMCAScript to meet JSON5's needs. Ultimately we should move both forward in tandem using something like the following syntax:\njavascript\n{\n  date: @d 05 October 2011 14:48 UTC, // quotes optional\n  map: @m {2:\"two\"}, // or nested array notation\n  object: @o {two, 2}, // or nested array notation\n  array: @a [1, 2, 'foo', 'foo'], // brackets optional\n  float32array: @f32a [21, 31],  // brackets optional\n  float64array: @f64a [21, 31],  // brackets optional\n  set: @s [1, 2,'foo'],  // brackets optional\n  regex: @r /match/i, // or string, but without flags\n  function: @f \"(arg1, arg2) {alert('hi'); //Kidding, don't do this.}\"\n}\nUltimately I am proposing the following:\n* @<hint-string> could be an optional way to disambiguate any literal past what the parser would consider the default for a given notation.\n* #91 might work better with a hint (see above).\n* The hint could be both a short code (@f32a) and long (@float32array) for clarity.\n* Parse errors for anything that does not match the <hint-string> object type.\nI chose @ as it matches the Obj-C literal identifier, there may be better choices given the additional information we would want to convey. I can't think of other language conventions at this time.. A few thoughts:\n\nDates are great, but we now have Maps, Sets, URLs, and more.\nHex literals start with 0x, so there is precedence for 'special strings' defining types in ECMAScript.\nECMAScript should have other literal formats, it would be nice to have a standard form to define literals.\n\nI agree with the desire to make JSON5 valid ECMAScript, but that doesn't mean we can't advance EMCAScript to meet JSON5's needs. Ultimately we should move both forward in tandem using something like the following syntax:\njavascript\n{\n  date: @d 05 October 2011 14:48 UTC, // quotes optional\n  map: @m {2:\"two\"}, // or nested array notation\n  object: @o {two, 2}, // or nested array notation\n  array: @a [1, 2, 'foo', 'foo'], // brackets optional\n  float32array: @f32a [21, 31],  // brackets optional\n  float64array: @f64a [21, 31],  // brackets optional\n  set: @s [1, 2,'foo'],  // brackets optional\n  regex: @r /match/i, // or string, but without flags\n  function: @f \"(arg1, arg2) {alert('hi'); //Kidding, don't do this.}\"\n}\nUltimately I am proposing the following:\n* @<hint-string> could be an optional way to disambiguate any literal past what the parser would consider the default for a given notation.\n* #91 might work better with a hint (see above).\n* The hint could be both a short code (@f32a) and long (@float32array) for clarity.\n* Parse errors for anything that does not match the <hint-string> object type.\nI chose @ as it matches the Obj-C literal identifier, there may be better choices given the additional information we would want to convey. I can't think of other language conventions at this time.. ",
    "ajlopez": "I tried again, in another machine, now with Windows 7. Same issue (I ran npm install, to get mocha, in my first attempt, too). I got the last develop commit (the one mentioned by Max, now)\nApparently, it not recognize \"mocha ... \" as an executable.\nI could run the test manually with\nnode test\\via-eval.js\nwithout glitches.\nThis is the npm log after npm test, if helps:\ninfo it worked if it ends with ok\nverbose cli [ 'C:\\Program Files (x86)\\nodejs\\node.exe',\nverbose cli   'C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',\nverbose cli   'test' ]\ninfo using npm@1.1.0-beta-4\ninfo using node@v0.6.6\nverbose config file C:\\Users\\angel.npmrc\nverbose config file C:\\Program Files (x86)\\nodejs\\etc\\npmrc\nverbose config file C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\npmrc\nverbose caching D:\\Git\\json5\\package.json\nverbose loadDefaults json5@0.0.1\nverbose run-script [ 'pretest', 'test', 'posttest' ]\ninfo pretest json5@0.0.1\ninfo test json5@0.0.1\nverbose unsafe-perm in lifecycle true\nsilly exec cmd \"/c\" \"mocha --ui exports --reporter list\"\nsilly spawning [ 'cmd',\nsilly spawning   [ '/c', 'mocha --ui exports --reporter list' ],\nsilly spawning   'D:\\Git\\json5' ]\ninfo json5@0.0.1 Failed to exec test script\nERR! json5@0.0.1 test: mocha --ui exports --reporter list\nERR! cmd \"/c\" \"mocha --ui exports --reporter list\" failed with 1\nERR! \nERR! Failed at the json5@0.0.1 test script.\nERR! This is most likely a problem with the json5 package,\nERR! not with npm itself.\nERR! Tell the author that this fails on your system:\nERR!     mocha --ui exports --reporter list\nERR! You can get their info via:\nERR!     npm owner ls json5\nERR! There is likely additional logging output above.\nERR! \nERR! System Windows_NT 6.1.7600\nERR! command \"C:\\Program Files (x86)\\nodejs\\node.exe\" \"C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\bin\\npm-cli.js\" \"test\"\nERR! cwd D:\\Git\\json5\nERR! node -v v0.6.6\nERR! npm -v 1.1.0-beta-4\nERR! code ELIFECYCLE\nERR! message json5@0.0.1 test: mocha --ui exports --reporter list\nERR! message cmd \"/c\" \"mocha --ui exports --reporter list\" failed with 1\nverbose exit [ 1, true ]\n. Great!\nnpm install -g mocha\ndid the trick in my Windows 7 box!\nI don't need npm link, yet. But I could emulate it (in other projects, to reference my local json5 project) using mklink Windows command (I guess)\n. Mocha was installed locally, since my first attempt. But I don't know why it doesn't run from npm test.\nI just run npm ls, and mocha is there.\nI checked local node_modules, too.\nAll mocha is there.\nJust to be sure, now I did:\nnpm uninstall -g mocha\nnpm test\nand the issue was back: error, \"mocha .... \" was not recognized as executable.\nA bit of research:\nIn windows, npm -g install the program at\n\\AppData\\Roaming\\npm\nMocha put mocha.cmd at that folder\nThe machine PATH has an item pointing to that folder (I guess it was put there by node installer for windows).\nSo, mocha is recognized as command from any folder.\nBut with local install of mocha, that mocha.cmd is at local node_modules.bin\nI don't know if npm includes that local folder in a temporary PATH when it launches test scripts.\nBut apparently, it doesn't work in my machines.\nWhen I run from local project folder:\nnode_modules.bin\\mocha --ui exports --reporter list\nit works (wo/global mocha install)\n. Well, I put\n\"test\": \"echo %PATH%\"\nand run\nnpm test\nbut the path is just the original one. No node_modules.bin added\nI'm using npm 1.1.0-beta-4\npacked into node for windows 0.6.6\nin this machine.\nOk, I just upgrade to the latest windows stable version\nnode v0.6.18\nnpm 1.1.21\nand voila!\nthe echo %PATH% shows the local node_modules .bin added to PATH!!!\nThanks for your help. I used the old version node/npm for month, wo/major glitches. But with the new version, it's all ok!\n(In Windows .msi (installation file), node AND npm are installed, together)\n. I tried again, in another machine, now with Windows 7. Same issue (I ran npm install, to get mocha, in my first attempt, too). I got the last develop commit (the one mentioned by Max, now)\nApparently, it not recognize \"mocha ... \" as an executable.\nI could run the test manually with\nnode test\\via-eval.js\nwithout glitches.\nThis is the npm log after npm test, if helps:\ninfo it worked if it ends with ok\nverbose cli [ 'C:\\Program Files (x86)\\nodejs\\node.exe',\nverbose cli   'C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',\nverbose cli   'test' ]\ninfo using npm@1.1.0-beta-4\ninfo using node@v0.6.6\nverbose config file C:\\Users\\angel.npmrc\nverbose config file C:\\Program Files (x86)\\nodejs\\etc\\npmrc\nverbose config file C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\npmrc\nverbose caching D:\\Git\\json5\\package.json\nverbose loadDefaults json5@0.0.1\nverbose run-script [ 'pretest', 'test', 'posttest' ]\ninfo pretest json5@0.0.1\ninfo test json5@0.0.1\nverbose unsafe-perm in lifecycle true\nsilly exec cmd \"/c\" \"mocha --ui exports --reporter list\"\nsilly spawning [ 'cmd',\nsilly spawning   [ '/c', 'mocha --ui exports --reporter list' ],\nsilly spawning   'D:\\Git\\json5' ]\ninfo json5@0.0.1 Failed to exec test script\nERR! json5@0.0.1 test: mocha --ui exports --reporter list\nERR! cmd \"/c\" \"mocha --ui exports --reporter list\" failed with 1\nERR! \nERR! Failed at the json5@0.0.1 test script.\nERR! This is most likely a problem with the json5 package,\nERR! not with npm itself.\nERR! Tell the author that this fails on your system:\nERR!     mocha --ui exports --reporter list\nERR! You can get their info via:\nERR!     npm owner ls json5\nERR! There is likely additional logging output above.\nERR! \nERR! System Windows_NT 6.1.7600\nERR! command \"C:\\Program Files (x86)\\nodejs\\node.exe\" \"C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\bin\\npm-cli.js\" \"test\"\nERR! cwd D:\\Git\\json5\nERR! node -v v0.6.6\nERR! npm -v 1.1.0-beta-4\nERR! code ELIFECYCLE\nERR! message json5@0.0.1 test: mocha --ui exports --reporter list\nERR! message cmd \"/c\" \"mocha --ui exports --reporter list\" failed with 1\nverbose exit [ 1, true ]\n. Great!\nnpm install -g mocha\ndid the trick in my Windows 7 box!\nI don't need npm link, yet. But I could emulate it (in other projects, to reference my local json5 project) using mklink Windows command (I guess)\n. Mocha was installed locally, since my first attempt. But I don't know why it doesn't run from npm test.\nI just run npm ls, and mocha is there.\nI checked local node_modules, too.\nAll mocha is there.\nJust to be sure, now I did:\nnpm uninstall -g mocha\nnpm test\nand the issue was back: error, \"mocha .... \" was not recognized as executable.\nA bit of research:\nIn windows, npm -g install the program at\n\\AppData\\Roaming\\npm\nMocha put mocha.cmd at that folder\nThe machine PATH has an item pointing to that folder (I guess it was put there by node installer for windows).\nSo, mocha is recognized as command from any folder.\nBut with local install of mocha, that mocha.cmd is at local node_modules.bin\nI don't know if npm includes that local folder in a temporary PATH when it launches test scripts.\nBut apparently, it doesn't work in my machines.\nWhen I run from local project folder:\nnode_modules.bin\\mocha --ui exports --reporter list\nit works (wo/global mocha install)\n. Well, I put\n\"test\": \"echo %PATH%\"\nand run\nnpm test\nbut the path is just the original one. No node_modules.bin added\nI'm using npm 1.1.0-beta-4\npacked into node for windows 0.6.6\nin this machine.\nOk, I just upgrade to the latest windows stable version\nnode v0.6.18\nnpm 1.1.21\nand voila!\nthe echo %PATH% shows the local node_modules .bin added to PATH!!!\nThanks for your help. I used the old version node/npm for month, wo/major glitches. But with the new version, it's all ok!\n(In Windows .msi (installation file), node AND npm are installed, together)\n. ",
    "mohsen1": "Oh! Sorry\n. Oh! Sorry\n. ",
    "aeisenberg": "This is currently working for me. From the node prompt:\n```\n\nrequire('./json5').parse(require('./json5').stringify({1:true}))\n{ '1': true }\n```\n\nIf there's something unexpected, then please raise a new issue.\nps- you are correct that {1:true} is valid JS.\n. I'll see what I can do.\n. I've had Issue #35 open for a while with a pull request, but I haven't had any feedback on it.\n. No problem.  Hope things work out for you.  Happy holidays as well!\nOn Fri, Dec 28, 2012 at 12:00 PM, Aseem Kishore notifications@github.comwrote:\n\nSorry Andrew, I've been at home for a family emergency and haven't had any\ntime or energy to look through your pull req yet, but I appreciate it and\nhope to get to it in the new year. Hope you're having a great holiday, and\nhappy new year. =)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/32#issuecomment-11740186.\n. Well, this is now available in the 0.3.0 release.\n. Thanks.  Let me know if there's anything you need.\n. Hi, wondering if you can get a chance to look at this PR.  I'm using json5 in another project now and it would be nice to use a released version. Thanks.\n. Thanks for the commit rights. As you mention, there's still some work to do here.  I think the guthub hack might actually work in this case. :)  I'll address the documentation and other issues over the next few days.\n. As far as I know there hasn't been any movement towards standardizing the\nmime type.  My understanding is that until there is an RFC for this, there\nshould be a vnd prefix to the sub-type, so this would be preferred:\n\napplication/vnd.json5\nBut if we ever get around to standardizing, I would want to see:\napplication/json5\nOn Sat, Nov 16, 2013 at 2:23 AM, Alex Kocharin notifications@github.comwrote:\n\nI'm slowly pushing json5 to production systems in a backward compatible\nmanner (which means strict json on the output, expecting json5 on the\ninput).\nSince we do expect json5 on the input, we should recognize its mime type\nas well. Sadly, there is none.\nSo the question is: what mime type are you planning to register/use in the\nfuture?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/40\n.\n. Thanks for the pull request!  I'll take a look at this in the next day or so.\n. Looks fine. \n\nIf I was being anal, I would ask for resubmitting, but without the whitespace changes. But since the changes only remove whitespace from the end of line, it's not too big of a deal. In the future, please do not include whitespace changes in pull requests (or create a separate one for them).\nThanks for your contribution.\n. Thanks for the pull request! I'm on vacation right now, so I may not be\nable to get to it for a few days. @aseemk, if you want to have a look,\nalso, feel free to.\nOn Sun, Dec 8, 2013 at 10:03 AM, Aseem Kishore notifications@github.comwrote:\n\nAwesome, @rowanhill https://github.com/rowanhill, thank you! (And\nthanks 24 Pull Requests!)\n@aeisenberg https://github.com/aeisenberg is the right person to look\nat this in detail, but I'll try to give it a look-through soon.\nCheers, and thanks again!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/pull/42#issuecomment-30087030\n.\n. Sorry for taking so many months to get back to you on this.  The replacer parameter is extremely complex. That is why I originally did not implement it.  I have some questions about your implementation. It does not seem to follow the spec in places. The spec can be found here:\nhttp://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3\n\nMy original implementation doesn't follow the spec in some places either. I hope to get some time to work on this soon.\n. Done.\nOn Sun, Mar 2, 2014 at 11:16 AM, Rowan Hill notifications@github.comwrote:\n\nHi - thanks for getting back to this. I've replied to your comments and\nadded a small fix to invoke the replacer function on the holder object, and\nadded tests for that.\nI'm not sure I understood all your comments, so please can you go into a\nbit more detail in those places?\n\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/pull/42#issuecomment-36463175\n.\n. This looks good now. Merged!\n\nThere may be some other corner cases that are not being handed correctly, but we can fix this if it ever comes up.  Thanks for your work.\n. This looks right to me! Thanks for the PR.\n. I'm not sure where that extra commit went. I don't see it in the original PR.  All tests are passing and this looks good to merge. I don't think it needs another PR.\n. Committed.\n. Thanks for submitting a pull request.\nI would prefer keeping the link pointing to a more official site like MDN, rather than your blog post even though your blog post goes into more detail than the existing link.  I would be fine with a link pointing to the ES5 specs. So, if you wanted to use that link instead, I could merge it.\n. Thanks!\n. Single trailing commas are handled as expected:\n```\n$ node -i\n\nvar JSON5 = require('./json5')\nundefined\nJSON5.parse('[1,]')\n[ 1 ]\n```\n\nBut, it looks like there's something funny going on with multiple trailing commas:\n```\n\nJSON5.parse('[1,,]')\n... \n```\n\nI would expect this:\n```\n\nJSON5.parse('[1,,]')\n[1,undefined]\n```\n\nI'm not sure what is going on. I'll try to get a chance and look.\n. There is none.  But my recommendation would be to take a look at the\nexisting test cases and adapt them to the new implementation. I've thought\nabout creating a proper spec and TCK, but that's not something I've had\ntime to do.\nWhat language are you looking at and do you have any implementation yet?\nOn Tue, Mar 4, 2014 at 9:48 PM, Tokuhiro Matsuno\nnotifications@github.comwrote:\n\nI want to port JSON5 to another programming language.\nIs there a portable test data set?\n\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/51\n.\n. This looks like a good approach.\n\nOn Wed, Mar 5, 2014 at 7:55 AM, Alex Kocharin notifications@github.comwrote:\n\nWhen I was implementing tests for my json5 parserhttps://github.com/rlidwka/jju,\nI took this approach:\n1. got existing json5 tests and tweaked them a bit\n2. got existing v8 json tests and tweaked them a bit, since\n3. threw a bunch of random data and made sure that JSON5.parse(JSON5.stringify(x))\n   == x\n4. threw a bunch of random strings and made sure that for each of my\n   tests results are equal to at least one of these functions:\n   - JSON.parse(something)\n   - eval('(function(){return ('+String(something)+'\\n)\\n})()')\n\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/51#issuecomment-36756901\n.\n. Nice. I had a brief look and found a couple of inconsistencies:\n1. Lines 95 and 100: I think you have object and array mixed up\n2. JSON will stringify NaN and Infinity to null. Eg-\nJSON.stringify(NaN)\n   'null'\n   Your tests show something different. Perhaps I'm not understanding how\n   these tests are supposed to run.\n\nOn Thu, Mar 27, 2014 at 3:03 PM, Alex Kocharin notifications@github.comwrote:\n\nIs there a portable test data set?\nI just created one here:\nhttps://github.com/rlidwka/jju/blob/master/test/portable-json5-tests.yaml\nAbout a hundred tests, should cover pretty much anything about literals\nnotation in ES5 spec.\n\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/51#issuecomment-38866573\n.\n. Thanks for the pull request!  The travis CI build has failed, but it doesn't look like it's anything related to your PR.  The commits look good and I would like to merge, but I don't want to until we have a clean build. Would you mind pushing again and seeing if this is a transient problem?\n. Looks like that's right.  But, this build was working in the past. Perhaps this particular build node is not the same as the others and doesn't have 0.9 installed (while the others do).\n. This is great.  Thanks. I'm actually on vacation right now or else I'd look into doing this myself.\n. So, for submitting pull requests, the best way to do it is to start with the master branch (or in this case, the develop branch), create a new branch off of that, and only add the commits relevant for the PR you are working on.  In this particular case, you can do something like this:\n\ngit checkout -b line_endings develop # creates new branch 'line_endings' based on 'develop'\ngit cherry-pick  ca1ec3  68f2e1c # grab the two relevant commits\ngit push origin line_endings # push the new branch to your remote\nNow, create the PR based on the new branch you just pushed.\nIn general, you should follow this practice before submitting a new PR: make sure you are on a clean branch based off of master that only contains the commits you want included.\n. There are several possibilities.  The stringify function takes 3 arguments. The most straightforward way would be to introduce a fourth argument called options.  This argument would take a bunch of name-value pairs.  One of them could be quoteChar, which defines the character to use for quoting.\nHappy to discuss other options.\n. +1 for @rlidwka implementation as well.  In my opinion, most important thing is backwards compatibility with JSON.stringify.  The config object can be used as the recommended syntax, with a fallback of standard JSON's syntax.\n. json5 has a stringify method. That sounds like what you'd want to use.\n. As far as I know, formatting is not preserved. json5.stringify accepts the same arguments as JSON.stringify. So, it would reformat the text.\n. This is currently working for me. From the node prompt:\n```\n\nrequire('./json5').parse(require('./json5').stringify({1:true}))\n{ '1': true }\n```\n\nIf there's something unexpected, then please raise a new issue.\nps- you are correct that {1:true} is valid JS.\n. I'll see what I can do.\n. I've had Issue #35 open for a while with a pull request, but I haven't had any feedback on it.\n. No problem.  Hope things work out for you.  Happy holidays as well!\nOn Fri, Dec 28, 2012 at 12:00 PM, Aseem Kishore notifications@github.comwrote:\n\nSorry Andrew, I've been at home for a family emergency and haven't had any\ntime or energy to look through your pull req yet, but I appreciate it and\nhope to get to it in the new year. Hope you're having a great holiday, and\nhappy new year. =)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/32#issuecomment-11740186.\n. Well, this is now available in the 0.3.0 release.\n. Thanks.  Let me know if there's anything you need.\n. Hi, wondering if you can get a chance to look at this PR.  I'm using json5 in another project now and it would be nice to use a released version. Thanks.\n. Thanks for the commit rights. As you mention, there's still some work to do here.  I think the guthub hack might actually work in this case. :)  I'll address the documentation and other issues over the next few days.\n. As far as I know there hasn't been any movement towards standardizing the\nmime type.  My understanding is that until there is an RFC for this, there\nshould be a vnd prefix to the sub-type, so this would be preferred:\n\napplication/vnd.json5\nBut if we ever get around to standardizing, I would want to see:\napplication/json5\nOn Sat, Nov 16, 2013 at 2:23 AM, Alex Kocharin notifications@github.comwrote:\n\nI'm slowly pushing json5 to production systems in a backward compatible\nmanner (which means strict json on the output, expecting json5 on the\ninput).\nSince we do expect json5 on the input, we should recognize its mime type\nas well. Sadly, there is none.\nSo the question is: what mime type are you planning to register/use in the\nfuture?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/40\n.\n. Thanks for the pull request!  I'll take a look at this in the next day or so.\n. Looks fine. \n\nIf I was being anal, I would ask for resubmitting, but without the whitespace changes. But since the changes only remove whitespace from the end of line, it's not too big of a deal. In the future, please do not include whitespace changes in pull requests (or create a separate one for them).\nThanks for your contribution.\n. Thanks for the pull request! I'm on vacation right now, so I may not be\nable to get to it for a few days. @aseemk, if you want to have a look,\nalso, feel free to.\nOn Sun, Dec 8, 2013 at 10:03 AM, Aseem Kishore notifications@github.comwrote:\n\nAwesome, @rowanhill https://github.com/rowanhill, thank you! (And\nthanks 24 Pull Requests!)\n@aeisenberg https://github.com/aeisenberg is the right person to look\nat this in detail, but I'll try to give it a look-through soon.\nCheers, and thanks again!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/pull/42#issuecomment-30087030\n.\n. Sorry for taking so many months to get back to you on this.  The replacer parameter is extremely complex. That is why I originally did not implement it.  I have some questions about your implementation. It does not seem to follow the spec in places. The spec can be found here:\nhttp://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3\n\nMy original implementation doesn't follow the spec in some places either. I hope to get some time to work on this soon.\n. Done.\nOn Sun, Mar 2, 2014 at 11:16 AM, Rowan Hill notifications@github.comwrote:\n\nHi - thanks for getting back to this. I've replied to your comments and\nadded a small fix to invoke the replacer function on the holder object, and\nadded tests for that.\nI'm not sure I understood all your comments, so please can you go into a\nbit more detail in those places?\n\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/pull/42#issuecomment-36463175\n.\n. This looks good now. Merged!\n\nThere may be some other corner cases that are not being handed correctly, but we can fix this if it ever comes up.  Thanks for your work.\n. This looks right to me! Thanks for the PR.\n. I'm not sure where that extra commit went. I don't see it in the original PR.  All tests are passing and this looks good to merge. I don't think it needs another PR.\n. Committed.\n. Thanks for submitting a pull request.\nI would prefer keeping the link pointing to a more official site like MDN, rather than your blog post even though your blog post goes into more detail than the existing link.  I would be fine with a link pointing to the ES5 specs. So, if you wanted to use that link instead, I could merge it.\n. Thanks!\n. Single trailing commas are handled as expected:\n```\n$ node -i\n\nvar JSON5 = require('./json5')\nundefined\nJSON5.parse('[1,]')\n[ 1 ]\n```\n\nBut, it looks like there's something funny going on with multiple trailing commas:\n```\n\nJSON5.parse('[1,,]')\n... \n```\n\nI would expect this:\n```\n\nJSON5.parse('[1,,]')\n[1,undefined]\n```\n\nI'm not sure what is going on. I'll try to get a chance and look.\n. There is none.  But my recommendation would be to take a look at the\nexisting test cases and adapt them to the new implementation. I've thought\nabout creating a proper spec and TCK, but that's not something I've had\ntime to do.\nWhat language are you looking at and do you have any implementation yet?\nOn Tue, Mar 4, 2014 at 9:48 PM, Tokuhiro Matsuno\nnotifications@github.comwrote:\n\nI want to port JSON5 to another programming language.\nIs there a portable test data set?\n\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/51\n.\n. This looks like a good approach.\n\nOn Wed, Mar 5, 2014 at 7:55 AM, Alex Kocharin notifications@github.comwrote:\n\nWhen I was implementing tests for my json5 parserhttps://github.com/rlidwka/jju,\nI took this approach:\n1. got existing json5 tests and tweaked them a bit\n2. got existing v8 json tests and tweaked them a bit, since\n3. threw a bunch of random data and made sure that JSON5.parse(JSON5.stringify(x))\n   == x\n4. threw a bunch of random strings and made sure that for each of my\n   tests results are equal to at least one of these functions:\n   - JSON.parse(something)\n   - eval('(function(){return ('+String(something)+'\\n)\\n})()')\n\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/51#issuecomment-36756901\n.\n. Nice. I had a brief look and found a couple of inconsistencies:\n1. Lines 95 and 100: I think you have object and array mixed up\n2. JSON will stringify NaN and Infinity to null. Eg-\nJSON.stringify(NaN)\n   'null'\n   Your tests show something different. Perhaps I'm not understanding how\n   these tests are supposed to run.\n\nOn Thu, Mar 27, 2014 at 3:03 PM, Alex Kocharin notifications@github.comwrote:\n\nIs there a portable test data set?\nI just created one here:\nhttps://github.com/rlidwka/jju/blob/master/test/portable-json5-tests.yaml\nAbout a hundred tests, should cover pretty much anything about literals\nnotation in ES5 spec.\n\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/51#issuecomment-38866573\n.\n. Thanks for the pull request!  The travis CI build has failed, but it doesn't look like it's anything related to your PR.  The commits look good and I would like to merge, but I don't want to until we have a clean build. Would you mind pushing again and seeing if this is a transient problem?\n. Looks like that's right.  But, this build was working in the past. Perhaps this particular build node is not the same as the others and doesn't have 0.9 installed (while the others do).\n. This is great.  Thanks. I'm actually on vacation right now or else I'd look into doing this myself.\n. So, for submitting pull requests, the best way to do it is to start with the master branch (or in this case, the develop branch), create a new branch off of that, and only add the commits relevant for the PR you are working on.  In this particular case, you can do something like this:\n\ngit checkout -b line_endings develop # creates new branch 'line_endings' based on 'develop'\ngit cherry-pick  ca1ec3  68f2e1c # grab the two relevant commits\ngit push origin line_endings # push the new branch to your remote\nNow, create the PR based on the new branch you just pushed.\nIn general, you should follow this practice before submitting a new PR: make sure you are on a clean branch based off of master that only contains the commits you want included.\n. There are several possibilities.  The stringify function takes 3 arguments. The most straightforward way would be to introduce a fourth argument called options.  This argument would take a bunch of name-value pairs.  One of them could be quoteChar, which defines the character to use for quoting.\nHappy to discuss other options.\n. +1 for @rlidwka implementation as well.  In my opinion, most important thing is backwards compatibility with JSON.stringify.  The config object can be used as the recommended syntax, with a fallback of standard JSON's syntax.\n. json5 has a stringify method. That sounds like what you'd want to use.\n. As far as I know, formatting is not preserved. json5.stringify accepts the same arguments as JSON.stringify. So, it would reformat the text.\n. ",
    "Midar": "Uhm, why exactly are they disallowed? I think it makes sense to support them to denote that it's a floating number. node also seems to support them.\n. Yes, other languages differentiate. In ObjFW, it's an OFNumber, but an OFNumber can contains a float, a double, an int, a size_t, etc. What it currently does is use an intmax_t for integers and a double for floating types.\nCurrently, it interprets 5.0 as a double and 5 as an integer. 5. would be a double then, while 5 would be an integer. It would actually make a difference if you go on and calculate something with it.\nYou can, of course, always convert it manually. The OFNumber class even has abstraction for that. For example, you call call [someNumber intMaxValue] and get an intmax_t - no matter whether it actually was an intmax_t or a double, it will just be converted if necessary.\nHowever, these types have different limits, so it might actually make a difference.\nWhat I also don't get about this is the inconsistency: Why would one allow .5, but not 5.?\n. And here is another example:\n@implementation Test\n- (void)applicationDidFinishLaunching\n{\n        [of_stdout writeFormat: @\"%@\\n%@\\n\",\n            [[@\"[5.]\" JSONValue] JSONRepresentation],\n            [[@\"[5]\" JSONValue] JSONRepresentation]];\n}\n@end\nOutput:\n[5.0]\n[5]\nI have to admit though that this is only since my last commit ;). OFNumber's description method was using the printf format specifier %f for floating points which would kill the decimal point if unnecessary. But since I fixed that bug in the description of an OFNumber, it behaves like pasted here. So I actually found and fixed a non-JSON5-related bug thanks to this discussion :).\n. Any progress on this? Can at least the spec be updated?\n. Nice! Thanks!\n. Indeed, you seem to be right. I have to admit that I just installed node to try this out and just wrote the strings I pasted above.\nOne remaining question, though: Is it just node behaviour that for example '\\e' gets 'e' or is handling it that way actually a requirement for JSON5? Should I also implement it this way? Currently I reject '\\e' as invalid JSON.\n. Ok, thanks, so I will keep it an error for now until you decided on how to handle it in JSON5 :). I think making it an error is better, there is no real reason to write \\e instead of e.\nActually, I implemented it the way described on json.org :).\n. One more question. The ES5 spec you linked for identifiers says:\n\nA JavaScript identifier must start with a letter, underscore (_), or dollar sign ($); subsequent characters can also be digits (0-9). Because JavaScript is case sensitive, letters include the characters \"A\" through \"Z\" (uppercase) and the characters \"a\" through \"z\" (lowercase).\nStarting with JavaScript 1.5, you can use ISO 8859-1 or Unicode letters such as \u00e5 and \u00fc in identifiers. You can also use the \\uXXXX Unicode escape sequences as characters in identifiers.\n\nI'm unsure about this here:\nThe first part says it can start with a letter. The second part says that since JavaScript 1.5, Unicode letters are allowed and even \\uXXXX escape sequences. Now I'm wondering: Does that mean an identifier is also allowed to start with a Unicode letter? It first defines letter as a-z and A-Z and then redefines it to include Unicode, so I'm confused. Are the following valid identifiers?\n{\u00e4bc: \"a\"}\n{\\u00E4: \"a\"}\n. Yeah, but node OTOH node even accepts numbers as first character:\n```\n\n{1: 'a'}\n{ '1': 'a' }\n```\n\nAnd what happens if you encode a number using \\u? like {\\u0030: 'foo'}? Is that still valid?\n. How do you think about creating a set of test .json5 files, invalid ones and valid ones, to test parsers?\nAnd how about creating a list of JSON5 parsers?\n. The problem with these tests is that none of them is valid JSON: JSON requires that you either start with an object or an array. None of them does that. Is that intentional?\n. I did it like that before as well, but I just changed it for the simple reason that this might be dangerous: As JSON only allows [] and {}, a user of the library might assume that the result is either of type object or array and unexpected stuff might happen if it is suddenly a string or a number. For example, in my implementation arrays map to OFArray and objects to OFDictionary - both conform to the protocol OFCollection. So you can safely assume you got a collection - which a string is not.\nEdit: Maybe I should change it back though for compatibility - has it happened in the wild that a JSON file just contained a string or a number?\n. The part before the edit or the edit part?\nIf this is actually done in the wild, I'd rather allow it.\nIf it is not and programmers assume they get an object or array, I'd rather disallow it.\n. Ok, I will allow it but I added a warning in the documentation (https://github.com/Midar/objfw/commit/6e6217865e1418c392c2296cc3f619e567a74063). Thanks.\nMaybe you could explicitly allow it in JSON5?\n. I have complete JSON5 support now, including Unicode characters and escape sequences in identifiers which is currently missing in your implementation. Should I add it to the Wiki? It's not a JSON(5) library, but a general purpose framework which happens to have JSON support included.\n. Added it. Is it fine this way?\nMaybe you could create a spec in EBNF syntax at some point? That'd help a lot in writing a parser in the future :).\n. One more thing I noticed:\n\"foo\\\n            bar\"\nCreates \"foobar\", thus removing all the spaces - this was not clear from what I read on the homepage. It should mention that all leading whitespaces on the next line should be stripped. Then the next problem: What are whitespaces in this context? Because the following generates an error:\n```\n\"foo\\\nbar\"\n```\n. Sure, go ahead and tweet it :).\nWell, EBNF is not hard - basically reading the Wikipedia article on it should be enough to be able to write and understand it.\nWell I had the same behaviour that you have, but I changed it to node's behaviour now for the simple reason that\n{\n  foo: \"This is a very long\\                                                    \n        string that takes\\                                                      \n        a few lines\"                                                            \n}\nis much more likely what you want than the ugly\n{\n  foo: \"This is a very long\\                                                    \nstring that takes\\                                                      \na few lines\"                                                            \n}\nthat would be required otherwise.\n. I created a simple HTML, only containing\n<script language='javascript'>\nalert(\"Hello\\\n  World\");\n</script>\nOpening it in Firefox 12 and Safari 5.1 includes all spaces.\nSo, either it's a bug in node or a bug in everything else.\nEdit: I have not tested in Chrome. Would be interesting, I guess.\n. Great, so if one eval()s JSON5 in Node, it's different from what you get when using the lib. Or, if we use the node way, the same applies for every other browser. So either way sucks.\nMaybe we should create a bug report at Chrome?\nEdit: I just noticed that the node behaviour actually makes a lot of sense. Multilines are otherwise pretty useless, as there's not much of a difference to your editor doing the linebreak.\n. Also note that\n\"foo\nbar\"\nis invalid and should be rejected.\n. Might I suggest that you maybe remove multiline strings from JSON5?\nRationale:\n- Currently multiline strings are not portable between JS engines\n- JSON5 tries to improve readability for humans - however, multiline strings without indentation are not really more readable than long strings wrapped by the editor\n- It can be added later again without breaking anything once JS engines reached consensus\n. I really don't see much value in it unless you can do indentation. I think that maybe allowing multiline strings with the + operator is a better way to go.\n{\n  foo: \"foo\" +\n       \"bar\"\n}\n. Well I thought about only allow \"foo\" + \"bar\" :). It seems the most natural way to do it in JS. I wouldn't allow it as an operator, but as part of the data format. Actually executing the + operator seems dangerous.\n. Any news? It kinda sucks to get a different result depending on whether you use a JSON lib or eval(). I still suggest dropping newline support until this is fixed in ECMAScript.\n. I don't see any problem anymore now that node seems to be compatible to the rest, so yes, this can stay closed :).\n. Is there any way in JS to represent a floating point number without loss of precision?\n. Well, writing hexadecimal floats like in C99 is what I was thinking about when I created the issue. It's even already implemented in my JSON5 parser, because it just uses strtod() for doubles.\nWhat do you mean by \"bitwise operators being 32bit, and numbers being 64bit\"?\n. Well, what I basically meant was: Is JavaScript even able to serialize and deserialize a floating point value without loss of precision?\n. Have you found out anything? It would be nice to be able to store floating point numbers without loss of precision :).\n. @darcyparker Yes, that seems to work at least for 32 bit floats. But what about 64 bit doubles?\n. Uhm, why exactly are they disallowed? I think it makes sense to support them to denote that it's a floating number. node also seems to support them.\n. Yes, other languages differentiate. In ObjFW, it's an OFNumber, but an OFNumber can contains a float, a double, an int, a size_t, etc. What it currently does is use an intmax_t for integers and a double for floating types.\nCurrently, it interprets 5.0 as a double and 5 as an integer. 5. would be a double then, while 5 would be an integer. It would actually make a difference if you go on and calculate something with it.\nYou can, of course, always convert it manually. The OFNumber class even has abstraction for that. For example, you call call [someNumber intMaxValue] and get an intmax_t - no matter whether it actually was an intmax_t or a double, it will just be converted if necessary.\nHowever, these types have different limits, so it might actually make a difference.\nWhat I also don't get about this is the inconsistency: Why would one allow .5, but not 5.?\n. And here is another example:\n@implementation Test\n- (void)applicationDidFinishLaunching\n{\n        [of_stdout writeFormat: @\"%@\\n%@\\n\",\n            [[@\"[5.]\" JSONValue] JSONRepresentation],\n            [[@\"[5]\" JSONValue] JSONRepresentation]];\n}\n@end\nOutput:\n[5.0]\n[5]\nI have to admit though that this is only since my last commit ;). OFNumber's description method was using the printf format specifier %f for floating points which would kill the decimal point if unnecessary. But since I fixed that bug in the description of an OFNumber, it behaves like pasted here. So I actually found and fixed a non-JSON5-related bug thanks to this discussion :).\n. Any progress on this? Can at least the spec be updated?\n. Nice! Thanks!\n. Indeed, you seem to be right. I have to admit that I just installed node to try this out and just wrote the strings I pasted above.\nOne remaining question, though: Is it just node behaviour that for example '\\e' gets 'e' or is handling it that way actually a requirement for JSON5? Should I also implement it this way? Currently I reject '\\e' as invalid JSON.\n. Ok, thanks, so I will keep it an error for now until you decided on how to handle it in JSON5 :). I think making it an error is better, there is no real reason to write \\e instead of e.\nActually, I implemented it the way described on json.org :).\n. One more question. The ES5 spec you linked for identifiers says:\n\nA JavaScript identifier must start with a letter, underscore (_), or dollar sign ($); subsequent characters can also be digits (0-9). Because JavaScript is case sensitive, letters include the characters \"A\" through \"Z\" (uppercase) and the characters \"a\" through \"z\" (lowercase).\nStarting with JavaScript 1.5, you can use ISO 8859-1 or Unicode letters such as \u00e5 and \u00fc in identifiers. You can also use the \\uXXXX Unicode escape sequences as characters in identifiers.\n\nI'm unsure about this here:\nThe first part says it can start with a letter. The second part says that since JavaScript 1.5, Unicode letters are allowed and even \\uXXXX escape sequences. Now I'm wondering: Does that mean an identifier is also allowed to start with a Unicode letter? It first defines letter as a-z and A-Z and then redefines it to include Unicode, so I'm confused. Are the following valid identifiers?\n{\u00e4bc: \"a\"}\n{\\u00E4: \"a\"}\n. Yeah, but node OTOH node even accepts numbers as first character:\n```\n\n{1: 'a'}\n{ '1': 'a' }\n```\n\nAnd what happens if you encode a number using \\u? like {\\u0030: 'foo'}? Is that still valid?\n. How do you think about creating a set of test .json5 files, invalid ones and valid ones, to test parsers?\nAnd how about creating a list of JSON5 parsers?\n. The problem with these tests is that none of them is valid JSON: JSON requires that you either start with an object or an array. None of them does that. Is that intentional?\n. I did it like that before as well, but I just changed it for the simple reason that this might be dangerous: As JSON only allows [] and {}, a user of the library might assume that the result is either of type object or array and unexpected stuff might happen if it is suddenly a string or a number. For example, in my implementation arrays map to OFArray and objects to OFDictionary - both conform to the protocol OFCollection. So you can safely assume you got a collection - which a string is not.\nEdit: Maybe I should change it back though for compatibility - has it happened in the wild that a JSON file just contained a string or a number?\n. The part before the edit or the edit part?\nIf this is actually done in the wild, I'd rather allow it.\nIf it is not and programmers assume they get an object or array, I'd rather disallow it.\n. Ok, I will allow it but I added a warning in the documentation (https://github.com/Midar/objfw/commit/6e6217865e1418c392c2296cc3f619e567a74063). Thanks.\nMaybe you could explicitly allow it in JSON5?\n. I have complete JSON5 support now, including Unicode characters and escape sequences in identifiers which is currently missing in your implementation. Should I add it to the Wiki? It's not a JSON(5) library, but a general purpose framework which happens to have JSON support included.\n. Added it. Is it fine this way?\nMaybe you could create a spec in EBNF syntax at some point? That'd help a lot in writing a parser in the future :).\n. One more thing I noticed:\n\"foo\\\n            bar\"\nCreates \"foobar\", thus removing all the spaces - this was not clear from what I read on the homepage. It should mention that all leading whitespaces on the next line should be stripped. Then the next problem: What are whitespaces in this context? Because the following generates an error:\n```\n\"foo\\\nbar\"\n```\n. Sure, go ahead and tweet it :).\nWell, EBNF is not hard - basically reading the Wikipedia article on it should be enough to be able to write and understand it.\nWell I had the same behaviour that you have, but I changed it to node's behaviour now for the simple reason that\n{\n  foo: \"This is a very long\\                                                    \n        string that takes\\                                                      \n        a few lines\"                                                            \n}\nis much more likely what you want than the ugly\n{\n  foo: \"This is a very long\\                                                    \nstring that takes\\                                                      \na few lines\"                                                            \n}\nthat would be required otherwise.\n. I created a simple HTML, only containing\n<script language='javascript'>\nalert(\"Hello\\\n  World\");\n</script>\nOpening it in Firefox 12 and Safari 5.1 includes all spaces.\nSo, either it's a bug in node or a bug in everything else.\nEdit: I have not tested in Chrome. Would be interesting, I guess.\n. Great, so if one eval()s JSON5 in Node, it's different from what you get when using the lib. Or, if we use the node way, the same applies for every other browser. So either way sucks.\nMaybe we should create a bug report at Chrome?\nEdit: I just noticed that the node behaviour actually makes a lot of sense. Multilines are otherwise pretty useless, as there's not much of a difference to your editor doing the linebreak.\n. Also note that\n\"foo\nbar\"\nis invalid and should be rejected.\n. Might I suggest that you maybe remove multiline strings from JSON5?\nRationale:\n- Currently multiline strings are not portable between JS engines\n- JSON5 tries to improve readability for humans - however, multiline strings without indentation are not really more readable than long strings wrapped by the editor\n- It can be added later again without breaking anything once JS engines reached consensus\n. I really don't see much value in it unless you can do indentation. I think that maybe allowing multiline strings with the + operator is a better way to go.\n{\n  foo: \"foo\" +\n       \"bar\"\n}\n. Well I thought about only allow \"foo\" + \"bar\" :). It seems the most natural way to do it in JS. I wouldn't allow it as an operator, but as part of the data format. Actually executing the + operator seems dangerous.\n. Any news? It kinda sucks to get a different result depending on whether you use a JSON lib or eval(). I still suggest dropping newline support until this is fixed in ECMAScript.\n. I don't see any problem anymore now that node seems to be compatible to the rest, so yes, this can stay closed :).\n. Is there any way in JS to represent a floating point number without loss of precision?\n. Well, writing hexadecimal floats like in C99 is what I was thinking about when I created the issue. It's even already implemented in my JSON5 parser, because it just uses strtod() for doubles.\nWhat do you mean by \"bitwise operators being 32bit, and numbers being 64bit\"?\n. Well, what I basically meant was: Is JavaScript even able to serialize and deserialize a floating point value without loss of precision?\n. Have you found out anything? It would be nice to be able to store floating point numbers without loss of precision :).\n. @darcyparker Yes, that seems to work at least for 32 bit floats. But what about 64 bit doubles?\n. ",
    "williamkapke": "I'm in favor of allowing this. Reason being is that there is no other way to describe \"nth item of Array\" except for having null (or empty) spots.\nFor instance; Say I am doing some validation on an array that I want to only have numbers in:\njs\n[\n  45,\n  18,\n  \"eleventeen\",\n  65535,\n  \"the end\"\n]\nI'd like to respond with something like:\njs\n[\n  ,\n  ,\n  \"Numbers only please\",\n  ,\n  \"Numbers only please\"\n]\nI asked Crockford why he didn't allow this (it has been allowed in JS for a VERY long time) and he said it was because not all languages handle sparse arrays.\nBecause javascript doesn't allocate based on the length of an array- it is easy to have a seemingly huge array:\njs\nvar x = [];\nx.length = 4294967295; //Chrome's limit\nIndeed, it could be trouble for a parser/stringifier to do a lot of work in other languages to handle this. However- it seems like a lame argument to me since it would sill have the problem if all the values were NOT null.\n. > Are you saying you specifically want the array to contain undefined elements?\nYes. It seems wrong for serialization to change the representation of the object. For example:\n``` javascript\nvar original = [,,,];\nvar stringified = JSON.stringify(original); // \"[null,null,null]\"\nvar parsed = JSON.parse(stringified);\nassert.strictEqual(parsed[1], original[1])\n// AssertionError: null === \"undefined\"\n```\nUsing null place holders is an improvement, but I'd rather see it just be empty. I went back to your README which seems to be a sort of \"mission statement\" for this project. It says:\n\nIt remains a strict subset of JavaScript, adds no new data types, and is a strict superset of existing JSON\n\nThat being the case, it seems this should be acceptable.\nIt is the only representation that allows it to be stringify'ed & parsed back while maintaining the original representation.\nOne other thing to point out to anyone that comes along and reads this: To hold true to how Javascript handles[,,,] means that the parser needs to count the last one as a \"trailing comma\" and not increment the length.\njavascript\n[,,,].length; // 3\n[1,2,3,].length; // 3\n[1,2,,4].length; // 4\nThanks for considering it!\n. [,,,] is just a syntax (I call them \"empties\"). How that syntax is handled can be left up to the language specific implementations. It does not require JSON5 to add an undefined type. JSON5 could just say that it is \"empty\"- ignore it if you want.\nBut I suspect it would most likely end up like this...\nLanguages without undefined:\n- Will treat \"empties\" it as nulls.\n- Consumers of the array will see no difference.\n- Implementations may use \"empties\" as a compact form of [null,null,null].\nLanguages that do have undefined\n- Will treat \"empties\" as undefineds and nulls as nulls.\n- Consumers of the array will understand that null and undefined are not guaranteed across implementations.\n- Implementations will use \"empties\" only for undefined values when serializing.\nYes- explicitly injecting nulls does the trick for retaining item indexes. I've been doing it that way for years. If we're going to improve JSON- this is my feature request. Will it break anything or limit usage?\n. I'm in favor of allowing this. Reason being is that there is no other way to describe \"nth item of Array\" except for having null (or empty) spots.\nFor instance; Say I am doing some validation on an array that I want to only have numbers in:\njs\n[\n  45,\n  18,\n  \"eleventeen\",\n  65535,\n  \"the end\"\n]\nI'd like to respond with something like:\njs\n[\n  ,\n  ,\n  \"Numbers only please\",\n  ,\n  \"Numbers only please\"\n]\nI asked Crockford why he didn't allow this (it has been allowed in JS for a VERY long time) and he said it was because not all languages handle sparse arrays.\nBecause javascript doesn't allocate based on the length of an array- it is easy to have a seemingly huge array:\njs\nvar x = [];\nx.length = 4294967295; //Chrome's limit\nIndeed, it could be trouble for a parser/stringifier to do a lot of work in other languages to handle this. However- it seems like a lame argument to me since it would sill have the problem if all the values were NOT null.\n. > Are you saying you specifically want the array to contain undefined elements?\nYes. It seems wrong for serialization to change the representation of the object. For example:\n``` javascript\nvar original = [,,,];\nvar stringified = JSON.stringify(original); // \"[null,null,null]\"\nvar parsed = JSON.parse(stringified);\nassert.strictEqual(parsed[1], original[1])\n// AssertionError: null === \"undefined\"\n```\nUsing null place holders is an improvement, but I'd rather see it just be empty. I went back to your README which seems to be a sort of \"mission statement\" for this project. It says:\n\nIt remains a strict subset of JavaScript, adds no new data types, and is a strict superset of existing JSON\n\nThat being the case, it seems this should be acceptable.\nIt is the only representation that allows it to be stringify'ed & parsed back while maintaining the original representation.\nOne other thing to point out to anyone that comes along and reads this: To hold true to how Javascript handles[,,,] means that the parser needs to count the last one as a \"trailing comma\" and not increment the length.\njavascript\n[,,,].length; // 3\n[1,2,3,].length; // 3\n[1,2,,4].length; // 4\nThanks for considering it!\n. [,,,] is just a syntax (I call them \"empties\"). How that syntax is handled can be left up to the language specific implementations. It does not require JSON5 to add an undefined type. JSON5 could just say that it is \"empty\"- ignore it if you want.\nBut I suspect it would most likely end up like this...\nLanguages without undefined:\n- Will treat \"empties\" it as nulls.\n- Consumers of the array will see no difference.\n- Implementations may use \"empties\" as a compact form of [null,null,null].\nLanguages that do have undefined\n- Will treat \"empties\" as undefineds and nulls as nulls.\n- Consumers of the array will understand that null and undefined are not guaranteed across implementations.\n- Implementations will use \"empties\" only for undefined values when serializing.\nYes- explicitly injecting nulls does the trick for retaining item indexes. I've been doing it that way for years. If we're going to improve JSON- this is my feature request. Will it break anything or limit usage?\n. ",
    "jasonswearingen": "as @William mentions, i think care has to be taken for breaking\ndata-round-trip with JSON.     JSON5-->obj-->JSON3-->obj.    both \"obj\"\ndata structures should be identical.   if any changes to JSON5 should\nensure that the round-trip is still valid.\n- Jason\n\nJason Swearingen  Technical Director: Novaleaf Softwarehttp://www.Novaleaf.com\nJasonS@Novaleaf.com  Cell: +66-089-775-0111\nOffice: +66-02-234-3031  Fax: +66-02-234-3032\nOn Mon, Jul 29, 2013 at 3:20 AM, William Wicks notifications@github.comwrote:\n\n[,,,] is just a syntax (I call them \"empties\"). How that syntax is\nhandled can be left up to the language specific implementations. It does\nnot require JSON5 to add an undefined type. JSON5 could just say that it\nis \"empty\"- ignore it if you want.\nBut I suspect it would most likely end up like this...\nLanguages without undefined:\n- Will treat \"empties\" it as nulls.\n- Consumers of the array will see no difference.\n- Implementations may use \"empties\" as a compact form of\n  [null,null,null].\nLanguages that do have undefined\n- Will treat \"empties\" as undefineds and nulls as nulls.\n- Consumers of the array will understand that null and undefined are\n  not guaranteed across implementations.\n- Implementations will use \"empties\" only for undefined values when\n  serializing.\nYes- explicitly injecting nulls does the trick for retaining item\nindexes. I've been doing it that way for years. If we're going to improve\nJSON- this is my feature request. Will it break anything or limit usage?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/19#issuecomment-21690210\n.\n. could you also please update the npm version to include this?\n. it would be very nice if we got this merged in.  non-useful error messages are a very big pain point.\n. as @William mentions, i think care has to be taken for breaking\ndata-round-trip with JSON.     JSON5-->obj-->JSON3-->obj.    both \"obj\"\ndata structures should be identical.   if any changes to JSON5 should\nensure that the round-trip is still valid.\n- Jason\n\n\nJason Swearingen  Technical Director: Novaleaf Softwarehttp://www.Novaleaf.com\nJasonS@Novaleaf.com  Cell: +66-089-775-0111\nOffice: +66-02-234-3031  Fax: +66-02-234-3032\nOn Mon, Jul 29, 2013 at 3:20 AM, William Wicks notifications@github.comwrote:\n\n[,,,] is just a syntax (I call them \"empties\"). How that syntax is\nhandled can be left up to the language specific implementations. It does\nnot require JSON5 to add an undefined type. JSON5 could just say that it\nis \"empty\"- ignore it if you want.\nBut I suspect it would most likely end up like this...\nLanguages without undefined:\n- Will treat \"empties\" it as nulls.\n- Consumers of the array will see no difference.\n- Implementations may use \"empties\" as a compact form of\n  [null,null,null].\nLanguages that do have undefined\n- Will treat \"empties\" as undefineds and nulls as nulls.\n- Consumers of the array will understand that null and undefined are\n  not guaranteed across implementations.\n- Implementations will use \"empties\" only for undefined values when\n  serializing.\nYes- explicitly injecting nulls does the trick for retaining item\nindexes. I've been doing it that way for years. If we're going to improve\nJSON- this is my feature request. Will it break anything or limit usage?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/19#issuecomment-21690210\n.\n. could you also please update the npm version to include this?\n. it would be very nice if we got this merged in.  non-useful error messages are a very big pain point.\n. \n",
    "grahamc": "Works from here. Y'all are probably experiencing DNS caching on your own side.\n. Works from here. Y'all are probably experiencing DNS caching on your own side.\n. ",
    "trans": "Btw, thanks for the link, it was interesting reading.\n. Btw, thanks for the link, it was interesting reading.\n. ",
    "darcyparker": "I know this is closed. But have you looked at C99 Hexadecimal floats?  Example\nThe challenge is writing a javascript parseHexFloat(string) in the same spirit as parseFloat(string), but where the string for parseHexFloat() is formatted like the C99 standard.  And similarly toHexFloatString() in the same spirit as Number.toString().\nWith bitwise operators being 32bit, and numbers being 64bit I am not sure how to begin... but maybe others have had ideas? \n. That's cool that there is a JSON5 parser that can read a string of a hexadecimal float.  When I quickly scanned the tests in this repo, (json5/test/parse-cases/numbers), I didn't see a test for a hexadecimal float (just hex integers), so I assumed no one was doing it yet.\nSorry, my comment about 32bit bitwise operators was a bit confusing. I was thinking that the parseHexFloat() and toHexFloatString() functions would be written in pure javascript for portability. In which case I would expect the only reliable way to access the internal 64 bit representation of a number such as Math.tan(1), would be to use bitwise operations... but given that the bitwise operations are only 32bit in javascript, I am not sure it can be done. Maybe dividing by Math.pow(2,n) could be used to do shifts...? But I have doubts.\nEdit: In other words, how would you write the value of Math.tan(1) to a hexadecimal float string?  And how would you parse a string with a hexadecimal float into a Number using a typical browser's implementation of javascript?\n. @aseemk : I think @midar's enhancement is a good one and could maybe researched a little more?  I don't have a solution/response that would work generically in any browser. But I am interested in looking into it. I can respond back here with findings if I have success if you are interested.\nAlso: The question \"Is there any way in JS to represent a floating point number without loss of precision?\" may have been better asked this way: \n\"Is there any way in JS to represent a floating point number as a string without loss of precision during the conversion?\" And the same question could be asked about going from a string of a hex float back to a javascript Number without loss of precision.  (I am not sure if you understood @midar correctly? ... but that's how I read it.  Maybe @midar can confirm?)\n. @midar - yes I think that's a better way to say it.  - thanks.  \nI know you can round trip a number to a decimal string and back to a number again (serialize and deserialize it) and still pass the javascript === test between the before and after number.  But === is not a sufficient test because it really just testing within the number's tolerance. It's still possible to loose information by serializing and deserializing using just javascript's Number.toString and parseFloat().\nI think it may be possible to avoid loss in precision... but it won't be trivial via pure javascript.\n. @Midar - sorry, I haven't yet.  It fell off my radar for awhile.  I do intend to look at this more sometime, but not sure when I will get to it.\n. @Midar - as an FYI. I recently saw this implementation that is close: https://github.com/mikolalysenko/float-bits  (it simple but uses typed arrays) It seems to be the simplest way to extract a floating point's number without loss of accuracy.\n. @Midar - in a similar spirit, Mikola says he is working on a double-bits implementation.  He is doing interesting work.\n. I know this is closed. But have you looked at C99 Hexadecimal floats?  Example\nThe challenge is writing a javascript parseHexFloat(string) in the same spirit as parseFloat(string), but where the string for parseHexFloat() is formatted like the C99 standard.  And similarly toHexFloatString() in the same spirit as Number.toString().\nWith bitwise operators being 32bit, and numbers being 64bit I am not sure how to begin... but maybe others have had ideas? \n. That's cool that there is a JSON5 parser that can read a string of a hexadecimal float.  When I quickly scanned the tests in this repo, (json5/test/parse-cases/numbers), I didn't see a test for a hexadecimal float (just hex integers), so I assumed no one was doing it yet.\nSorry, my comment about 32bit bitwise operators was a bit confusing. I was thinking that the parseHexFloat() and toHexFloatString() functions would be written in pure javascript for portability. In which case I would expect the only reliable way to access the internal 64 bit representation of a number such as Math.tan(1), would be to use bitwise operations... but given that the bitwise operations are only 32bit in javascript, I am not sure it can be done. Maybe dividing by Math.pow(2,n) could be used to do shifts...? But I have doubts.\nEdit: In other words, how would you write the value of Math.tan(1) to a hexadecimal float string?  And how would you parse a string with a hexadecimal float into a Number using a typical browser's implementation of javascript?\n. @aseemk : I think @midar's enhancement is a good one and could maybe researched a little more?  I don't have a solution/response that would work generically in any browser. But I am interested in looking into it. I can respond back here with findings if I have success if you are interested.\nAlso: The question \"Is there any way in JS to represent a floating point number without loss of precision?\" may have been better asked this way: \n\"Is there any way in JS to represent a floating point number as a string without loss of precision during the conversion?\" And the same question could be asked about going from a string of a hex float back to a javascript Number without loss of precision.  (I am not sure if you understood @midar correctly? ... but that's how I read it.  Maybe @midar can confirm?)\n. @midar - yes I think that's a better way to say it.  - thanks.  \nI know you can round trip a number to a decimal string and back to a number again (serialize and deserialize it) and still pass the javascript === test between the before and after number.  But === is not a sufficient test because it really just testing within the number's tolerance. It's still possible to loose information by serializing and deserializing using just javascript's Number.toString and parseFloat().\nI think it may be possible to avoid loss in precision... but it won't be trivial via pure javascript.\n. @Midar - sorry, I haven't yet.  It fell off my radar for awhile.  I do intend to look at this more sometime, but not sure when I will get to it.\n. @Midar - as an FYI. I recently saw this implementation that is close: https://github.com/mikolalysenko/float-bits  (it simple but uses typed arrays) It seems to be the simplest way to extract a floating point's number without loss of accuracy.\n. @Midar - in a similar spirit, Mikola says he is working on a double-bits implementation.  He is doing interesting work.\n. ",
    "donaldpipowitch": "Sorry, I'm on a Mac. No IE8+ :(\n. I have to thank you :)\n. Sorry, I'm on a Mac. No IE8+ :(\n. I have to thank you :)\n. ",
    "rentalhost": "Just make different files, as you pull request. /lib/json5.jquery.js, /lib/json5.node.js, ...\n. Just make different files, as you pull request. /lib/json5.jquery.js, /lib/json5.node.js, ...\n. ",
    "sindresorhus": "I was hit by this too. I just assumed it supported outputting the same format that it reads...\nMy use-case is having user editable config files which can also be modified programatically. Which means I would need to be able both read/write JSON5. Going with YAML instead.\n. ^ +1\n. I was hit by this too. I just assumed it supported outputting the same format that it reads...\nMy use-case is having user editable config files which can also be modified programatically. Which means I would need to be able both read/write JSON5. Going with YAML instead.\n. ^ +1\n. ",
    "dpashkevich": "+1 on this, there should be an option to programmatically output human-friendly JSON5\n. I think the sentence JSON5.stringify() should pretty much do what it\nsays: that is stringify JSON5. So I vote for human-friendly output by\ndefault, that's what JSON5 is about anyway.\nDmitry Pashkevich\nOn Dec 11, 2012 10:37 PM, \"Aseem Kishore\" notifications@github.com wrote:\n\nOkay guys, I'm convinced -- supporting stringifying to \"clean\" JSON5\nsounds reasonable. The only question is, should that be the default\nbehavior of JSON5.stringify()? Or should it be an option?\n(Maybe overload the space option -- if any given, pretty-print, but if\nnot, use the default JSON stringify?)\nI can be convinced to make stringifying to JSON5 the default, since you\ncan always use the regular/native JSON.stringify() if you want regular\nJSON.\nI'm busy at the moment, so if anyone wants to take a stab, pull requests\nwelcome!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/32#issuecomment-11256181.\n. Agreed! Besides wiki has better editing interface.\nHere's the page: https://github.com/aseemk/json5/wiki/Where-JSON5-could-be-useful\nI'm not sure if it's a good title, you're welcome to change it to something better!\n. +1 on this, there should be an option to programmatically output human-friendly JSON5\n. I think the sentence JSON5.stringify() should pretty much do what it\nsays: that is stringify JSON5. So I vote for human-friendly output by\ndefault, that's what JSON5 is about anyway.\n\nDmitry Pashkevich\nOn Dec 11, 2012 10:37 PM, \"Aseem Kishore\" notifications@github.com wrote:\n\nOkay guys, I'm convinced -- supporting stringifying to \"clean\" JSON5\nsounds reasonable. The only question is, should that be the default\nbehavior of JSON5.stringify()? Or should it be an option?\n(Maybe overload the space option -- if any given, pretty-print, but if\nnot, use the default JSON stringify?)\nI can be convinced to make stringifying to JSON5 the default, since you\ncan always use the regular/native JSON.stringify() if you want regular\nJSON.\nI'm busy at the moment, so if anyone wants to take a stab, pull requests\nwelcome!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/aseemk/json5/issues/32#issuecomment-11256181.\n. Agreed! Besides wiki has better editing interface.\nHere's the page: https://github.com/aseemk/json5/wiki/Where-JSON5-could-be-useful\nI'm not sure if it's a good title, you're welcome to change it to something better!\n. \n",
    "tarlepp": "Actual the I'm trying to parse following message.\njavascript\n{\n  \"status\": 500,\n  \"errors\": [\n    {\n      \"message\": \"{ ValidationError: { title: [ [Object] ] } }\",\n      \"stack\": \"Error: { ValidationError: { title: [ [Object] ] } }\\n    at Object.serverErrorOccurred [as handle] (/home/wunder/projects/Taskboard/config/500.js:27:34)\\n    at next (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/node_modules/connect/lib/proto.js:185:17)\\n    at next (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/node_modules/connect/lib/proto.js:187:11)\\n    at next (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/node_modules/connect/lib/proto.js:187:11)\\n    at next (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/node_modules/connect/lib/proto.js:187:11)\\n    at pass (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/lib/router/index.js:107:24)\\n    at nextRoute (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/lib/router/index.js:100:7)\\n    at callbacks (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/lib/router/index.js:164:11)\\n    at /home/wunder/projects/Taskboard/node_modules/sails/lib/hooks/controllers/controller.create.js:31:20\\n    at /home/wunder/projects/Taskboard/node_modules/sails/node_modules/waterline/lib/waterline/query/dql.js:120:22\"\n    }\n  ]\n}\nAnd as you can see the problematic case is an string which i'm trying to parse. Basically this is a sails.js validation problem, but it would be nice if JSON5 handle this kind of cases. Maybe there should be optional method to make loose parse which handles cases like this.\nMy simple solution for this was var object = JSON5.parse(errorObject.message.replace(\"[ [Object] ]\", \"[]\"));\n. Yes, they already did that ( thanks to sails.js team ). Note that my proposal solutions was enough for me for that time the real solution was not available. Thanks anyway.\n. there was a bug in sails.js core and in those cases returned value were converted to string.\n. Actual the I'm trying to parse following message.\njavascript\n{\n  \"status\": 500,\n  \"errors\": [\n    {\n      \"message\": \"{ ValidationError: { title: [ [Object] ] } }\",\n      \"stack\": \"Error: { ValidationError: { title: [ [Object] ] } }\\n    at Object.serverErrorOccurred [as handle] (/home/wunder/projects/Taskboard/config/500.js:27:34)\\n    at next (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/node_modules/connect/lib/proto.js:185:17)\\n    at next (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/node_modules/connect/lib/proto.js:187:11)\\n    at next (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/node_modules/connect/lib/proto.js:187:11)\\n    at next (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/node_modules/connect/lib/proto.js:187:11)\\n    at pass (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/lib/router/index.js:107:24)\\n    at nextRoute (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/lib/router/index.js:100:7)\\n    at callbacks (/home/wunder/projects/Taskboard/node_modules/sails/node_modules/express/lib/router/index.js:164:11)\\n    at /home/wunder/projects/Taskboard/node_modules/sails/lib/hooks/controllers/controller.create.js:31:20\\n    at /home/wunder/projects/Taskboard/node_modules/sails/node_modules/waterline/lib/waterline/query/dql.js:120:22\"\n    }\n  ]\n}\nAnd as you can see the problematic case is an string which i'm trying to parse. Basically this is a sails.js validation problem, but it would be nice if JSON5 handle this kind of cases. Maybe there should be optional method to make loose parse which handles cases like this.\nMy simple solution for this was var object = JSON5.parse(errorObject.message.replace(\"[ [Object] ]\", \"[]\"));\n. Yes, they already did that ( thanks to sails.js team ). Note that my proposal solutions was enough for me for that time the real solution was not available. Thanks anyway.\n. there was a bug in sails.js core and in those cases returned value were converted to string.\n. ",
    "kasperp": "\nIf I was being anal, I would ask for resubmitting, but without the whitespace changes.\n\nSorry about that, I did notice in the diff (my editor did that for me) and briefly considered not committing them but decided to leave them cause who likes trailing whitespace :smiley_cat:. \nI'll leave them out next time.\n. > If I was being anal, I would ask for resubmitting, but without the whitespace changes.\nSorry about that, I did notice in the diff (my editor did that for me) and briefly considered not committing them but decided to leave them cause who likes trailing whitespace :smiley_cat:. \nI'll leave them out next time.\n. ",
    "rowanhill": "(Rebased after whitespace changes)\n. Hi - thanks for getting back to this. I've replied to your comments and added a small fix to invoke the replacer function on the holder object, and added tests for that.\nI'm not sure I understood all your comments, so please can you go into a bit more detail in those places?\n. (Rebased after whitespace changes)\n. @aseemk Sure! I don't know how much time I'll have to spend on this in the future, but I might find some.\n. Guys, I'm slightly confused by the state of this: GitHub claims it's been merged into develop, but I can't see this commit anywhere. Am I missing something?\n. I've cherry-picked this commit on top of the current develop branch here - let me know if you'd like this as a PR.\n. Yeah, I'm not sure what's going on there. Oh well, looks like all the code's committed now. Thanks!\n. Heh, I did wonder if this would be a bit controversial! I'm not too bothered either way - I'll let @aseemk decide which he prefers, since it's his repository.\n. Great stuff, thanks @aseemk! I've rebased my other PRs now that this has been merged.\n. (Rebased after whitespace changes)\n. Hi - thanks for getting back to this. I've replied to your comments and added a small fix to invoke the replacer function on the holder object, and added tests for that.\nI'm not sure I understood all your comments, so please can you go into a bit more detail in those places?\n. (Rebased after whitespace changes)\n. @aseemk Sure! I don't know how much time I'll have to spend on this in the future, but I might find some.\n. Guys, I'm slightly confused by the state of this: GitHub claims it's been merged into develop, but I can't see this commit anywhere. Am I missing something?\n. I've cherry-picked this commit on top of the current develop branch here - let me know if you'd like this as a PR.\n. Yeah, I'm not sure what's going on there. Oh well, looks like all the code's committed now. Thanks!\n. Heh, I did wonder if this would be a bit controversial! I'm not too bothered either way - I'll let @aseemk decide which he prefers, since it's his repository.\n. Great stuff, thanks @aseemk! I've rebased my other PRs now that this has been merged.\n. ",
    "litmit": "I'm agree with @williamwicks.\nAnd I think you will easy see practical difference with JSON and JSON_with_sparsed_arrays:\njs\nvar a = [];\na[0]=0;\na[10000]=10000;\na.non_numeric_property=\"zzz\";\nvar j = JSON.stringify(a);\nAlso I think that support for sparse arrays assume next syntax (not only [,,,,5,,,2]:\n[0:0,10000:10000,non_numeric_property:\"zzz\"/*why not?*/]\n. I'm agree with @williamwicks.\nAnd I think you will easy see practical difference with JSON and JSON_with_sparsed_arrays:\njs\nvar a = [];\na[0]=0;\na[10000]=10000;\na.non_numeric_property=\"zzz\";\nvar j = JSON.stringify(a);\nAlso I think that support for sparse arrays assume next syntax (not only [,,,,5,,,2]:\n[0:0,10000:10000,non_numeric_property:\"zzz\"/*why not?*/]\n. ",
    "mathiasbynens": "The MDN link doesn\u2019t really go into any detail at all. Oh well.\n. :+1: \n. The MDN link doesn\u2019t really go into any detail at all. Oh well.\n. :+1: \n. ",
    "briandeheus": "Why not update MDN with more information?\n. Why not update MDN with more information?\n. ",
    "ravi": "+1\nMultiline strings in which second and later lines have to start at column 0 improve readability only marginally.\n. This is pretty critical, since, if there are errors during conversion the message provides no clue on the location of the error. (unless I am missing something :-))\n. Can we have this? (please!)\n. @AVGP Unfortunately I might have misunderstood your commit... I had hoped for more context for the error message, but it seems to me your change does not provide that.\n. For my ~ 600 line JSON5 config file, the below is mostly useless as an error report, I am afraid:\n/tmp/node_modules/json5/lib/json5.js:54\n            throw error;\n                  ^\nSyntaxError: Expected ']' instead of '{'\n. Created #86 . Thanks.\n. +1\nMultiline strings in which second and later lines have to start at column 0 improve readability only marginally.\n. This is pretty critical, since, if there are errors during conversion the message provides no clue on the location of the error. (unless I am missing something :-))\n. Can we have this? (please!)\n. @AVGP Unfortunately I might have misunderstood your commit... I had hoped for more context for the error message, but it seems to me your change does not provide that.\n. For my ~ 600 line JSON5 config file, the below is mostly useless as an error report, I am afraid:\n/tmp/node_modules/json5/lib/json5.js:54\n            throw error;\n                  ^\nSyntaxError: Expected ']' instead of '{'\n. Created #86 . Thanks.\n. ",
    "tomByrer": "Yes, great idea!\nhttp://www.xanthir.com/etc/railroad-diagrams/generator.html\n. Cool @sykano \nI forgot about this suggestion.  Ironically, I found just a few days ago https://github.com/tabatkins/railroad-diagrams\n. Yes, great idea!\nhttp://www.xanthir.com/etc/railroad-diagrams/generator.html\n. Cool @sykano \nI forgot about this suggestion.  Ironically, I found just a few days ago https://github.com/tabatkins/railroad-diagrams\n. ",
    "sykano": "I took the liberty of coding the diagrams for the mentioned diagram generator (by extending the diagrams from json.org with the extensions specified in the JSON5 readme).\nSomebody should review them for correctness. I'm not quite sure about the string specification (e.g. Do one have to escape ' in a double-quoted string and vice versa?) and about the number specification (e.g. Is .0 legal?).\nsee pull request #104\n. I took the liberty of coding the diagrams for the mentioned diagram generator (by extending the diagrams from json.org with the extensions specified in the JSON5 readme).\nSomebody should review them for correctness. I'm not quite sure about the string specification (e.g. Do one have to escape ' in a double-quoted string and vice versa?) and about the number specification (e.g. Is .0 legal?).\nsee pull request #104\n. ",
    "kylpo": "Hey, just wanted to add that I would definitely appreciate numeric literals as property names. e.g. JSON5.parse(\"{0.5:true}\") parsing without error. For now, I'm just regex to replace my strings before sending it to json5, but I'd love to take out that step!\nThanks for your work on json5!. Absolutely! My use case is very specific: I am building an animation component that accepts a keyframes object or string. For my convenience and skim-ability, I often prefer to use a string, like:\n``jsx\n<Animate\n  animation={{\n    0: {\n      opacity: 0.5,\n    },\n    0.5: {\n      opacity: 0,\n    },\n    1: {\n      opacity: 1,\n    }\n  }`}\n  duration={500}\n\n```\n\nAnimate takes this string and converts it to an object using json5. For number-type consistency within this animation string, I do not want to force devs to add quotes around the keys, it \"feels\" more jarring:\n``jsx\n<Animate\n  animation={{\n    '0': {\n      opacity: 0.5,\n    },\n    '0.5': {\n      opacity: 0,\n    },\n    '1': {\n      opacity: 1,\n    }\n  }`}\n  duration={500}\n\n```\n\nThanks for your quick response!. Hey, just wanted to add that I would definitely appreciate numeric literals as property names. e.g. JSON5.parse(\"{0.5:true}\") parsing without error. For now, I'm just regex to replace my strings before sending it to json5, but I'd love to take out that step!\nThanks for your work on json5!. Absolutely! My use case is very specific: I am building an animation component that accepts a keyframes object or string. For my convenience and skim-ability, I often prefer to use a string, like:\n``jsx\n<Animate\n  animation={{\n    0: {\n      opacity: 0.5,\n    },\n    0.5: {\n      opacity: 0,\n    },\n    1: {\n      opacity: 1,\n    }\n  }`}\n  duration={500}\n\n```\n\nAnimate takes this string and converts it to an object using json5. For number-type consistency within this animation string, I do not want to force devs to add quotes around the keys, it \"feels\" more jarring:\n``jsx\n<Animate\n  animation={{\n    '0': {\n      opacity: 0.5,\n    },\n    '0.5': {\n      opacity: 0,\n    },\n    '1': {\n      opacity: 1,\n    }\n  }`}\n  duration={500}\n\n```\n\nThanks for your quick response!. ",
    "amb26": "I know that this issue has been long-closed, but I did want to express my preference for the other decision - repeating a key in a structure, as far as I can see, always represents an error or oversight of some kind, and it's a mistake I've made several times myself! I think it would be great if we returned to the original behaviour. This thread contains some interesting discussion: http://stackoverflow.com/questions/21832701/does-json-syntax-allow-duplicate-keys-in-an-object\nan interesting point being that whilst ECMA-404 doesn't say anything about duplicate keys, RFC 7159 says that they \"should\" not occur. It would be possible in time, I guess, to have a JSON5 standard that adopted one or other of these choices without saying that we had \"deviated\" from the JSON behaviour which seems to mostly result from accidents in parser implementation.\nI know this decision is unlikely ever to be revisited but I thought I'd put my opinion on record :)\n. Hi - thanks for the speedy and helpful review! I've added support for all the line terminators in the ES5 spec - I didn't update the code for handling newlines in strings to match since this looked like a potentially breaking strategy change that presumably we should discuss separately. Addressed cosmetics also - ready for another round of feedback, cheers!\nPS - I thought it a bit less fussy to test with internal strings for these cases rather than lug around a set of very hard-to-edit files containing nonstandard line terminators, see what you think\n. I see indeed that the \"nonstandard line terminators within strings\" issue is being tracked separately at https://github.com/aseemk/json5/issues/70 so just as well I left it alone :)\n. OK - looks like I have indeed violated the published grammar in a minor way, in that U+2028 and U+2029 are now at least recognised as whitespace even though they are not recognised as line terminators (for the purpose of continuation). This seemed better than the current behaviour of throwing a syntax error when encountering these characters. I guess if this PR is accepted, this would require us to update the JSON5Whitespace production in our grammar.\n. Thanks for the feedback, @jordanbtucker  - I've reverted the changes to the whitespace rules as you suggested - this involved axing our two testcases for the PS and LS line terminators since these now represent syntax errors. I think your plan for universally moving to support for Unicode line terminators both within and outside strings is a reasonable one. Ready for another round - cheers.\n. I know that this issue has been long-closed, but I did want to express my preference for the other decision - repeating a key in a structure, as far as I can see, always represents an error or oversight of some kind, and it's a mistake I've made several times myself! I think it would be great if we returned to the original behaviour. This thread contains some interesting discussion: http://stackoverflow.com/questions/21832701/does-json-syntax-allow-duplicate-keys-in-an-object\nan interesting point being that whilst ECMA-404 doesn't say anything about duplicate keys, RFC 7159 says that they \"should\" not occur. It would be possible in time, I guess, to have a JSON5 standard that adopted one or other of these choices without saying that we had \"deviated\" from the JSON behaviour which seems to mostly result from accidents in parser implementation.\nI know this decision is unlikely ever to be revisited but I thought I'd put my opinion on record :)\n. Hi - thanks for the speedy and helpful review! I've added support for all the line terminators in the ES5 spec - I didn't update the code for handling newlines in strings to match since this looked like a potentially breaking strategy change that presumably we should discuss separately. Addressed cosmetics also - ready for another round of feedback, cheers!\nPS - I thought it a bit less fussy to test with internal strings for these cases rather than lug around a set of very hard-to-edit files containing nonstandard line terminators, see what you think\n. I see indeed that the \"nonstandard line terminators within strings\" issue is being tracked separately at https://github.com/aseemk/json5/issues/70 so just as well I left it alone :)\n. OK - looks like I have indeed violated the published grammar in a minor way, in that U+2028 and U+2029 are now at least recognised as whitespace even though they are not recognised as line terminators (for the purpose of continuation). This seemed better than the current behaviour of throwing a syntax error when encountering these characters. I guess if this PR is accepted, this would require us to update the JSON5Whitespace production in our grammar.\n. Thanks for the feedback, @jordanbtucker  - I've reverted the changes to the whitespace rules as you suggested - this involved axing our two testcases for the PS and LS line terminators since these now represent syntax errors. I think your plan for universally moving to support for Unicode line terminators both within and outside strings is a reasonable one. Ready for another round - cheers.\n. ",
    "mlegenhausen": "If that gets in stringify how would I give this options in the function?\n. That was my first idea too. As addition there could be a config object as second parameter:\njs\nJSON.stringify({ ... }, {\n  replacer: ['first'],\n  space: '  ',\n  quoteChar: '\\''\n});\nWhich looks more like a modern API of course with a fallback to the old style.\nSome drawbacks of a fourth parameter can be if you use the stringify method inline. Which could lead to some side effects.\nThen I could also think about a global configuration object like:\njs\nJSON5.defaults = {\n  replacer: ['first']\n  space: '  ',\n  quoteChar: '\\''\n};\nAnother question for me what would be the allowed quote chars?\n. Thanks for the link I will take a look. That looks exactly for what I was looking for.\n. If that gets in stringify how would I give this options in the function?\n. That was my first idea too. As addition there could be a config object as second parameter:\njs\nJSON.stringify({ ... }, {\n  replacer: ['first'],\n  space: '  ',\n  quoteChar: '\\''\n});\nWhich looks more like a modern API of course with a fallback to the old style.\nSome drawbacks of a fourth parameter can be if you use the stringify method inline. Which could lead to some side effects.\nThen I could also think about a global configuration object like:\njs\nJSON5.defaults = {\n  replacer: ['first']\n  space: '  ',\n  quoteChar: '\\''\n};\nAnother question for me what would be the allowed quote chars?\n. Thanks for the link I will take a look. That looks exactly for what I was looking for.\n. ",
    "michaelsanford": "I've noticed that npmjs.org doesn't always pick up on that format, for whatever reason, but I will happily update my pull request.\n. Would you like it squashed, @aseemk ?\n. I've noticed that npmjs.org doesn't always pick up on that format, for whatever reason, but I will happily update my pull request.\n. Would you like it squashed, @aseemk ?\n. ",
    "howardroark": "Thanks! So I guess application/json5 is the way to go then?\nSeems like the vnd and x prefixes just muddy things up.\n. Thanks! So I guess application/json5 is the way to go then?\nSeems like the vnd and x prefixes just muddy things up.\n. ",
    "kokizzu": "ah I see, I guess this library https://github.com/yosuke-furukawa/json5\nthat has incomplete feature\n. ah I see, I guess this library https://github.com/yosuke-furukawa/json5\nthat has incomplete feature\n. ",
    "bnjmnt4n": "Ping? ;)\n. Array#join is faster in IE6/7, but is slower for modern browsers. Using += causes modern browsers to store references to the strings being concatenated, but the whole string is joined only when actually being used, unlike Array#join, which joins strings immediately. That said, char-by-char concatenation is extremely slow. There should be a better way to do that.\n. Ping? ;)\n. Array#join is faster in IE6/7, but is slower for modern browsers. Using += causes modern browsers to store references to the strings being concatenated, but the whole string is joined only when actually being used, unlike Array#join, which joins strings immediately. That said, char-by-char concatenation is extremely slow. There should be a better way to do that.\n. ",
    "gasi": ":+1: \n. :+1: \n. ",
    "AVGP": "@ravi You can use my branch (referenced in this pull request) to try it :) I'm waiting for feedback or a merge on this, too\n. @ravi You can use my branch (referenced in this pull request) to try it :) I'm waiting for feedback or a merge on this, too\n. ",
    "sandermarechal": "It's a Java exception. I'm not sure what the problem is. The same command works fine on every other javascript file I've thrown at it.\n```\n$ yui-compressor --type=js lib/json5.js --verbose\n[INFO] Using charset UTF-8\nException in thread \"main\" java.lang.reflect.InvocationTargetException\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at com.yahoo.platform.yui.compressor.Bootstrap.main(Bootstrap.java:21)\nCaused by: java.util.MissingResourceException: Can't find bundle for base name org.mozilla.javascript.resources.Messages, locale en_US\n    at java.util.ResourceBundle.throwMissingResourceException(ResourceBundle.java:1499)\n    at java.util.ResourceBundle.getBundleImpl(ResourceBundle.java:1322)\n    at java.util.ResourceBundle.getBundle(ResourceBundle.java:795)\n    at org.mozilla.javascript.ScriptRuntime$DefaultMessageProvider.getMessage(ScriptRuntime.java:3608)\n    at org.mozilla.javascript.ScriptRuntime.getMessage(ScriptRuntime.java:3592)\n    at org.mozilla.javascript.ScriptRuntime.getMessage0(ScriptRuntime.java:3540)\n    at org.mozilla.javascript.Parser.addError(Parser.java:145)\n    at org.mozilla.javascript.Parser.reportError(Parser.java:160)\n    at org.mozilla.javascript.Parser.mustMatchToken(Parser.java:265)\n    at org.mozilla.javascript.Parser.function(Parser.java:598)\n    at org.mozilla.javascript.Parser.parseFunctionBody(Parser.java:479)\n    at org.mozilla.javascript.Parser.function(Parser.java:611)\n    at org.mozilla.javascript.Parser.primaryExpr(Parser.java:2255)\n    at org.mozilla.javascript.Parser.memberExpr(Parser.java:1974)\n    at org.mozilla.javascript.Parser.unaryExpr(Parser.java:1832)\n    at org.mozilla.javascript.Parser.mulExpr(Parser.java:1761)\n    at org.mozilla.javascript.Parser.addExpr(Parser.java:1742)\n    at org.mozilla.javascript.Parser.shiftExpr(Parser.java:1722)\n    at org.mozilla.javascript.Parser.relExpr(Parser.java:1696)\n    at org.mozilla.javascript.Parser.eqExpr(Parser.java:1652)\n    at org.mozilla.javascript.Parser.bitAndExpr(Parser.java:1641)\n    at org.mozilla.javascript.Parser.bitXorExpr(Parser.java:1630)\n    at org.mozilla.javascript.Parser.bitOrExpr(Parser.java:1619)\n    at org.mozilla.javascript.Parser.andExpr(Parser.java:1607)\n    at org.mozilla.javascript.Parser.orExpr(Parser.java:1595)\n    at org.mozilla.javascript.Parser.condExpr(Parser.java:1578)\n    at org.mozilla.javascript.Parser.assignExpr(Parser.java:1563)\n    at org.mozilla.javascript.Parser.assignExpr(Parser.java:1569)\n    at org.mozilla.javascript.Parser.expr(Parser.java:1542)\n    at org.mozilla.javascript.Parser.statementHelper(Parser.java:1221)\n    at org.mozilla.javascript.Parser.statement(Parser.java:726)\n    at org.mozilla.javascript.Parser.parse(Parser.java:420)\n    at org.mozilla.javascript.Parser.parse(Parser.java:378)\n    at com.yahoo.platform.yui.compressor.JavaScriptCompressor.parse(JavaScriptCompressor.java:312)\n    at com.yahoo.platform.yui.compressor.JavaScriptCompressor.(JavaScriptCompressor.java:533)\n    at com.yahoo.platform.yui.compressor.YUICompressor.main(YUICompressor.java:131)\n    ... 5 more\n```\n. It's a Java exception. I'm not sure what the problem is. The same command works fine on every other javascript file I've thrown at it.\n```\n$ yui-compressor --type=js lib/json5.js --verbose\n[INFO] Using charset UTF-8\nException in thread \"main\" java.lang.reflect.InvocationTargetException\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at com.yahoo.platform.yui.compressor.Bootstrap.main(Bootstrap.java:21)\nCaused by: java.util.MissingResourceException: Can't find bundle for base name org.mozilla.javascript.resources.Messages, locale en_US\n    at java.util.ResourceBundle.throwMissingResourceException(ResourceBundle.java:1499)\n    at java.util.ResourceBundle.getBundleImpl(ResourceBundle.java:1322)\n    at java.util.ResourceBundle.getBundle(ResourceBundle.java:795)\n    at org.mozilla.javascript.ScriptRuntime$DefaultMessageProvider.getMessage(ScriptRuntime.java:3608)\n    at org.mozilla.javascript.ScriptRuntime.getMessage(ScriptRuntime.java:3592)\n    at org.mozilla.javascript.ScriptRuntime.getMessage0(ScriptRuntime.java:3540)\n    at org.mozilla.javascript.Parser.addError(Parser.java:145)\n    at org.mozilla.javascript.Parser.reportError(Parser.java:160)\n    at org.mozilla.javascript.Parser.mustMatchToken(Parser.java:265)\n    at org.mozilla.javascript.Parser.function(Parser.java:598)\n    at org.mozilla.javascript.Parser.parseFunctionBody(Parser.java:479)\n    at org.mozilla.javascript.Parser.function(Parser.java:611)\n    at org.mozilla.javascript.Parser.primaryExpr(Parser.java:2255)\n    at org.mozilla.javascript.Parser.memberExpr(Parser.java:1974)\n    at org.mozilla.javascript.Parser.unaryExpr(Parser.java:1832)\n    at org.mozilla.javascript.Parser.mulExpr(Parser.java:1761)\n    at org.mozilla.javascript.Parser.addExpr(Parser.java:1742)\n    at org.mozilla.javascript.Parser.shiftExpr(Parser.java:1722)\n    at org.mozilla.javascript.Parser.relExpr(Parser.java:1696)\n    at org.mozilla.javascript.Parser.eqExpr(Parser.java:1652)\n    at org.mozilla.javascript.Parser.bitAndExpr(Parser.java:1641)\n    at org.mozilla.javascript.Parser.bitXorExpr(Parser.java:1630)\n    at org.mozilla.javascript.Parser.bitOrExpr(Parser.java:1619)\n    at org.mozilla.javascript.Parser.andExpr(Parser.java:1607)\n    at org.mozilla.javascript.Parser.orExpr(Parser.java:1595)\n    at org.mozilla.javascript.Parser.condExpr(Parser.java:1578)\n    at org.mozilla.javascript.Parser.assignExpr(Parser.java:1563)\n    at org.mozilla.javascript.Parser.assignExpr(Parser.java:1569)\n    at org.mozilla.javascript.Parser.expr(Parser.java:1542)\n    at org.mozilla.javascript.Parser.statementHelper(Parser.java:1221)\n    at org.mozilla.javascript.Parser.statement(Parser.java:726)\n    at org.mozilla.javascript.Parser.parse(Parser.java:420)\n    at org.mozilla.javascript.Parser.parse(Parser.java:378)\n    at com.yahoo.platform.yui.compressor.JavaScriptCompressor.parse(JavaScriptCompressor.java:312)\n    at com.yahoo.platform.yui.compressor.JavaScriptCompressor.(JavaScriptCompressor.java:533)\n    at com.yahoo.platform.yui.compressor.YUICompressor.main(YUICompressor.java:131)\n    ... 5 more\n```\n. ",
    "alexpusch": "Came here to suggest the same thing. Something like\njavascript\n{\n   pattern: /.*_tests\\.js/\n}\nI think it would be enough to try to convert anything between two / into a RegExp, why would you need to parse the actual expression?\n. Came here to suggest the same thing. Something like\njavascript\n{\n   pattern: /.*_tests\\.js/\n}\nI think it would be enough to try to convert anything between two / into a RegExp, why would you need to parse the actual expression?\n. ",
    "XGHeaven": "I think no...\nIn README.md\n\nThe JSON5 aims to make it easier for humans to write and maintain by hand. It does this by adding some minimal syntax features directly from ECMAScript 5.\n\nIf implement RegExp or Date, the JSON5 can't convert to JSON.\nI can't hope this.\nI have a other suggestion, create a package call json5-regexp or json5-date. And expose a use method in JSON5 to use json5-regexp middleware.\n. @amulware you meaning is like\njavascript\n{ offset: (base + increment) * stride }\nnot\njavascript\n{ offset: (10 + 3) * 2 }\n. @aseemk Yes, I agree with minimal but useful. So I only add + - * / feather in my PR. It's enough.\n. You said \"It's just data\". So I believe 5 / 0, no one could write it... :smile: useless data...\n. @jordanbtucker I change some code.\n. If add variables support, I pretty to write js instead of json5.\nI don't like to add this support.\n. I think no...\nIn README.md\n\nThe JSON5 aims to make it easier for humans to write and maintain by hand. It does this by adding some minimal syntax features directly from ECMAScript 5.\n\nIf implement RegExp or Date, the JSON5 can't convert to JSON.\nI can't hope this.\nI have a other suggestion, create a package call json5-regexp or json5-date. And expose a use method in JSON5 to use json5-regexp middleware.\n. @amulware you meaning is like\njavascript\n{ offset: (base + increment) * stride }\nnot\njavascript\n{ offset: (10 + 3) * 2 }\n. @aseemk Yes, I agree with minimal but useful. So I only add + - * / feather in my PR. It's enough.\n. You said \"It's just data\". So I believe 5 / 0, no one could write it... :smile: useless data...\n. @jordanbtucker I change some code.\n. If add variables support, I pretty to write js instead of json5.\nI don't like to add this support.\n. ",
    "piranna": "\nIf implement RegExp or Date, the JSON5 can't convert to JSON.\n\nIf we embed RegExp or Date inside string, they are plain strings accepted by JSON, so no problem here. In fact, this \"trick\" is currently used on JSON sucessfully. The only thing is that JSON needs a special reviver function to interpret the strings that have embeded a RegExp or Date object, like https://github.com/piranna/ContextBroker/blob/master/lib/reviver.js\n\nI have a other suggestion, create a package call json5-regexp or json5-date. And expose a use method in JSON5 to use json5-regexp middleware.\n\nNot a bad idea, but this would mostly host reviver functions if we want to still being compatible with JSON or with JSON5 implementations without support for this extensions. Also, if we use embeded strings this revivers could be used with plain JSON too...\n. > Please let me know what you think.\nI like it :-) Being opt-in extensions would allow other implementations to not support it but just instead threat them as plain strings, that's a nice default :-). > I could imagine someone wanting to encode some sort of offset like (base+increment)*stride for example. (And I am sure there are more good use cases.)\nThis would need (or lead) to have support for constants or at least get that variables from the context... This will break compatibility with json, but would be a nice feature too. Maybe in a new spec with regex too?\n. I've open an issue for discussion about the variables at #112.\n. I think the limit will be when people want to use functions or Math.sqrt() or import modules ;-)\n. > @piranna: I totally agree that functions are beyond the line. A core tenet of JSON(5) is \"it's just data\", not executable code.\nI consider RegExp data, too... ;-) They are the same as function declarations as far as they are not executed, but function declaration would be beyond the line too not only because they are language specific but also could be dangerous if executed (RegExp are not dangerous in that way).\n\nEven with these basic operators, though, it does e.g. make supporting JSON5 in other languages harder. E.g. what is 5 / 0? If we're to be consistent with ES5, it's Infinity. But in most languages, that'd be a runtime error. Or possibly an undefined-ish value.\n\nInfinity is a valid float value in all languajes, including C/C++...\n. > Even with these basic operators, though, it does e.g. make supporting JSON5 in other languages harder. E.g. what is 5 / 0? If we're to be consistent with ES5, it's Infinity. But in most languages, that'd be a runtime error. Or possibly an undefined-ish value.\n\nI'd alter that statement by saying that 5 / 0 is an error in most languages if they're treated as integers. ES5 doesn't have integers (all numbers are IEEE 754 floating point values) so this returns Infinity. If the numbers are treated as floating points, then most languages would return some form of IEEE 754 Infinity. (Python and Go are exceptions, however. Python always throws a ZeroDivisionError. The Go spec says it's implementation specific, but the official Playground throws a division by zero error. There are likely other exceptions, too).\n\nThis operations will not be executed on runtime but when parsed, so there's no problem the implementation wrap the operations on a try-catch block to capture these exceptions and set the value to infinite \"by hand\". Python support both Infinite and NaN, so...\n\nOh no. Now the RegExp discussion is bleeding into this one.  I do see the parallels, though.\n\nLol :-P Yes, there are parallels because it depends on the concepts of \"what is data\" and \"what is executable code\". After parsing we would get respectively a number or a RegExp object that both are not executables by themselves (a RegExp is a description that can be used to find some data, the same way a number can be used as an index on an array), so I would accept both. I would not accept functions because if they get parsed they are executables \"as is\", and there's almost no way to sanitize them and know they are secure (a RegExp could be bad written, but it's not a security thread or could erase data by itself...).\n\n@piranna\nInfinity is a valid float value in all languajes, including C/C++\nMost languages have a way to check for Infinity, but not all languages have a way of actually representing that value (e.g. a constant that represents Infinity or a function that returns Infinity). PHP 4.0 is an example of this.\n\nPHP sucks, but not so much... ;-)\n. > Supporting functions is not just about security. You would have to expect the JSON5 parser be able to parse functions and implementations to be able to represent those functions on their native platforms. If someone wants to implement functions in JSON or JSON5, they might as well write a transpiler for ES5 into every other programming language.\nAnd also, adding functions support would deviates from being a data format to became a programming languaje...\n\nRegarding regular expressions, I wrote a little more about the subject.\n\nYour last solution (map RegExp.toJson() to RegExp.toString()) so they got embebed inside strings is just what I'm doing in another project processing them with another data types and it works like a charm... :-D Maybe we could add and process the RegExp in the same way, storing them as strings :-)\n. > I'm open for discussions on serializing RegExps as strings. In fact, I've renamed and re-opened the issue. Let's keep further discussions there. Thanks.\n:+1: let's keep the issues focused :-)\n. Besides the fact I would use const instead of var because this last one has the implicit concept that they could be change later (and I think it's something we don't want to allow), I had in mind everything exactly as how you've put it here, +1000 for me :-)\n\nFor the parse API, does it parse the constants into values before it gives it to the revivier, or does it notify the reviver that a constant was used?\n\nI would transparently parse the constants. I think constants is more oriented towards make it easier to hand-written JSON5 files instead of generate them programatically, since the stringify will be generate valid JSON files, so constants are mostly an implementation detail...\n. > The reason I didn't use the word const is because it's not part of the\n\nES5 spec, so using it would break compatibility with ES5. It is part of the\nES2015 spec though.\n\nGood point, ok then.\n\nAlso, JSON5.stringify doesn't produce valid JSON documents, it produces\nvalid JSON5 documents.\n\nWasn't it the intention that stringify produce valid JSON documents at\nleast originally, and JSON5 only offered more flexibility? At least I\nremember so...\n\nI'm still on the fence about whether the API should allow generating\ndocuments with constants, but we could certainly implement constants\nwithout it until there is demand.\n\nOk, I agree with that.\n. > The problem JSON5 set out to solve was \"make it easier and more human-friendly to write JSON out by hand\", with common use cases like config files and declarative data. \"Write\" == parse.\nTotally agree.\n\nBut we'll never have this ability as long as comments are stripped, which JSON5.parse does.\n\nIf that's the case, then comments should be preserved. Don't know about whitespaces, but probably they should be preserved too, but this will make the parser too much more difficult...\n\nIf add variables support, I pretty to write js instead of json5.\n\nThat would make sense if we export the content instead of left it as a statement... besides that, I don't think it's too much of a problem to have constants (not variables) in json5.\n. > If implement RegExp or Date, the JSON5 can't convert to JSON.\nIf we embed RegExp or Date inside string, they are plain strings accepted by JSON, so no problem here. In fact, this \"trick\" is currently used on JSON sucessfully. The only thing is that JSON needs a special reviver function to interpret the strings that have embeded a RegExp or Date object, like https://github.com/piranna/ContextBroker/blob/master/lib/reviver.js\n\nI have a other suggestion, create a package call json5-regexp or json5-date. And expose a use method in JSON5 to use json5-regexp middleware.\n\nNot a bad idea, but this would mostly host reviver functions if we want to still being compatible with JSON or with JSON5 implementations without support for this extensions. Also, if we use embeded strings this revivers could be used with plain JSON too...\n. > Please let me know what you think.\nI like it :-) Being opt-in extensions would allow other implementations to not support it but just instead threat them as plain strings, that's a nice default :-). > I could imagine someone wanting to encode some sort of offset like (base+increment)*stride for example. (And I am sure there are more good use cases.)\nThis would need (or lead) to have support for constants or at least get that variables from the context... This will break compatibility with json, but would be a nice feature too. Maybe in a new spec with regex too?\n. I've open an issue for discussion about the variables at #112.\n. I think the limit will be when people want to use functions or Math.sqrt() or import modules ;-)\n. > @piranna: I totally agree that functions are beyond the line. A core tenet of JSON(5) is \"it's just data\", not executable code.\nI consider RegExp data, too... ;-) They are the same as function declarations as far as they are not executed, but function declaration would be beyond the line too not only because they are language specific but also could be dangerous if executed (RegExp are not dangerous in that way).\n\nEven with these basic operators, though, it does e.g. make supporting JSON5 in other languages harder. E.g. what is 5 / 0? If we're to be consistent with ES5, it's Infinity. But in most languages, that'd be a runtime error. Or possibly an undefined-ish value.\n\nInfinity is a valid float value in all languajes, including C/C++...\n. > Even with these basic operators, though, it does e.g. make supporting JSON5 in other languages harder. E.g. what is 5 / 0? If we're to be consistent with ES5, it's Infinity. But in most languages, that'd be a runtime error. Or possibly an undefined-ish value.\n\nI'd alter that statement by saying that 5 / 0 is an error in most languages if they're treated as integers. ES5 doesn't have integers (all numbers are IEEE 754 floating point values) so this returns Infinity. If the numbers are treated as floating points, then most languages would return some form of IEEE 754 Infinity. (Python and Go are exceptions, however. Python always throws a ZeroDivisionError. The Go spec says it's implementation specific, but the official Playground throws a division by zero error. There are likely other exceptions, too).\n\nThis operations will not be executed on runtime but when parsed, so there's no problem the implementation wrap the operations on a try-catch block to capture these exceptions and set the value to infinite \"by hand\". Python support both Infinite and NaN, so...\n\nOh no. Now the RegExp discussion is bleeding into this one.  I do see the parallels, though.\n\nLol :-P Yes, there are parallels because it depends on the concepts of \"what is data\" and \"what is executable code\". After parsing we would get respectively a number or a RegExp object that both are not executables by themselves (a RegExp is a description that can be used to find some data, the same way a number can be used as an index on an array), so I would accept both. I would not accept functions because if they get parsed they are executables \"as is\", and there's almost no way to sanitize them and know they are secure (a RegExp could be bad written, but it's not a security thread or could erase data by itself...).\n\n@piranna\nInfinity is a valid float value in all languajes, including C/C++\nMost languages have a way to check for Infinity, but not all languages have a way of actually representing that value (e.g. a constant that represents Infinity or a function that returns Infinity). PHP 4.0 is an example of this.\n\nPHP sucks, but not so much... ;-)\n. > Supporting functions is not just about security. You would have to expect the JSON5 parser be able to parse functions and implementations to be able to represent those functions on their native platforms. If someone wants to implement functions in JSON or JSON5, they might as well write a transpiler for ES5 into every other programming language.\nAnd also, adding functions support would deviates from being a data format to became a programming languaje...\n\nRegarding regular expressions, I wrote a little more about the subject.\n\nYour last solution (map RegExp.toJson() to RegExp.toString()) so they got embebed inside strings is just what I'm doing in another project processing them with another data types and it works like a charm... :-D Maybe we could add and process the RegExp in the same way, storing them as strings :-)\n. > I'm open for discussions on serializing RegExps as strings. In fact, I've renamed and re-opened the issue. Let's keep further discussions there. Thanks.\n:+1: let's keep the issues focused :-)\n. Besides the fact I would use const instead of var because this last one has the implicit concept that they could be change later (and I think it's something we don't want to allow), I had in mind everything exactly as how you've put it here, +1000 for me :-)\n\nFor the parse API, does it parse the constants into values before it gives it to the revivier, or does it notify the reviver that a constant was used?\n\nI would transparently parse the constants. I think constants is more oriented towards make it easier to hand-written JSON5 files instead of generate them programatically, since the stringify will be generate valid JSON files, so constants are mostly an implementation detail...\n. > The reason I didn't use the word const is because it's not part of the\n\nES5 spec, so using it would break compatibility with ES5. It is part of the\nES2015 spec though.\n\nGood point, ok then.\n\nAlso, JSON5.stringify doesn't produce valid JSON documents, it produces\nvalid JSON5 documents.\n\nWasn't it the intention that stringify produce valid JSON documents at\nleast originally, and JSON5 only offered more flexibility? At least I\nremember so...\n\nI'm still on the fence about whether the API should allow generating\ndocuments with constants, but we could certainly implement constants\nwithout it until there is demand.\n\nOk, I agree with that.\n. > The problem JSON5 set out to solve was \"make it easier and more human-friendly to write JSON out by hand\", with common use cases like config files and declarative data. \"Write\" == parse.\nTotally agree.\n\nBut we'll never have this ability as long as comments are stripped, which JSON5.parse does.\n\nIf that's the case, then comments should be preserved. Don't know about whitespaces, but probably they should be preserved too, but this will make the parser too much more difficult...\n\nIf add variables support, I pretty to write js instead of json5.\n\nThat would make sense if we export the content instead of left it as a statement... besides that, I don't think it's too much of a problem to have constants (not variables) in json5.\n. ",
    "abhisekp": "@jordanbtucker the word \"prefix\" is not correctly written. Yes it should be \"prefix newline character\". But no one can see that unless they've visibility set in their editor. :stuck_out_tongue_winking_eye: \n. @jordanbtucker i meant \"prefix each newline with a backslash\" is not correct. That's confusing.\nShould I write like this?\ntext\n{\n    \"new_string\": \"This is a multiline string and \n\\the backslash must be appended at the end\n\\before this line.\"\n}\nAs you said, it should be \"prefix newline character\"\n. @jordanbtucker the word \"prefix\" is not correctly written. Yes it should be \"prefix newline character\". But no one can see that unless they've visibility set in their editor. :stuck_out_tongue_winking_eye: \n. @jordanbtucker i meant \"prefix each newline with a backslash\" is not correct. That's confusing.\nShould I write like this?\ntext\n{\n    \"new_string\": \"This is a multiline string and \n\\the backslash must be appended at the end\n\\before this line.\"\n}\nAs you said, it should be \"prefix newline character\"\n. ",
    "amulware": "If this was done (and I feel divided about it too.. yet it would be really cool to have), should it also support parenthesis?\nI could imagine someone wanting to encode some sort of offset like (base+increment)*stride for example. (And I am sure there are more good use cases.)\n. Yes, I indeed only meant using literals, like @jordanbtucker says.\nUsing variables like that would make things a lot more complicated and would have to be discussed in a lot of detail I imagine.\n. You confuse me. :D\nI was only asking about adding parenthesis to the list of supported operators, so I only care about:\n{ offset: (10 + 3) * 2 }\nThe other things is a much bigger feature that needs to be designed very carefully, if it is a good idea at all.\n. If this was done (and I feel divided about it too.. yet it would be really cool to have), should it also support parenthesis?\nI could imagine someone wanting to encode some sort of offset like (base+increment)*stride for example. (And I am sure there are more good use cases.)\n. Yes, I indeed only meant using literals, like @jordanbtucker says.\nUsing variables like that would make things a lot more complicated and would have to be discussed in a lot of detail I imagine.\n. You confuse me. :D\nI was only asking about adding parenthesis to the list of supported operators, so I only care about:\n{ offset: (10 + 3) * 2 }\nThe other things is a much bigger feature that needs to be designed very carefully, if it is a good idea at all.\n. ",
    "justjake": "I don't think adding an NPM dependency to the command-line tool significantly changes the requirements to use the tool. This won't break anyone's scripts\na) the command-line tool already uses require() to load the JSON5 module as a dependency, so it's fine to introduce an additional use of require().\nb) you already recommend installing the tool as an NPM package, so adding an NPM dependency doesn't significantly change the interface; node comes with npm on all platforms but FreeBSD.\nI can understand not wanting to move forward with additional dependencies without Browserify -- future contributors might want to use NPM deps in JSON5.js itself, and then where would we be? If that's the case, would I be better off publishing my own json5-tool package or something?\n. I don't think adding an NPM dependency to the command-line tool significantly changes the requirements to use the tool. This won't break anyone's scripts\na) the command-line tool already uses require() to load the JSON5 module as a dependency, so it's fine to introduce an additional use of require().\nb) you already recommend installing the tool as an NPM package, so adding an NPM dependency doesn't significantly change the interface; node comes with npm on all platforms but FreeBSD.\nI can understand not wanting to move forward with additional dependencies without Browserify -- future contributors might want to use NPM deps in JSON5.js itself, and then where would we be? If that's the case, would I be better off publishing my own json5-tool package or something?\n. ",
    "AlexDaniel": "If we look at the source code we will see that this:\ncss\ncolor: #777;\nWas changed to this:\ncss\ncolor: #727272;\nWhich is not that much of an improvement\u2026 In fact, it is now lighter!!! What the\u2026\nHowever, they've also changed the font itself and current font is much bolder than the previous one. This makes it easier to read (and visually it is perceived as being darker), so that's good. Good but not enough.\nBy the way, I'm happy to find that I am not alone. See this: https://github.com/orderedlist/minimal/issues/1\nIn fact, it was fixed here: https://github.com/yegeniy/yegeniy.github.io/commit/79a69bac86fecc0ff89c9ea72124c0322af8f3ce (someone's page).\nBut there's also this pull request in upstream https://github.com/orderedlist/minimal/pull/2 which changed it to #666. However, it was then set back to #727272 in https://github.com/orderedlist/minimal/commit/3574fcf40f8f3149369ea3d243f23c16196c2b38.\nSo either fix it yourself or find a new stylesheet. This stylesheet is not that good in other aspects too, so you can safely drop it.\n. By the way, I've opened a pull request here: https://github.com/orderedlist/minimal/pull/25\nIf anybody feels with this hilariously light text as uncomfortable as I do, please express your opinion there.\n. It was merged!\n. Actually\u2026 this has to be reopened\u2026\nSee this comment: https://github.com/orderedlist/minimal/issues/1#issuecomment-255735813\n. If we look at the source code we will see that this:\ncss\ncolor: #777;\nWas changed to this:\ncss\ncolor: #727272;\nWhich is not that much of an improvement\u2026 In fact, it is now lighter!!! What the\u2026\nHowever, they've also changed the font itself and current font is much bolder than the previous one. This makes it easier to read (and visually it is perceived as being darker), so that's good. Good but not enough.\nBy the way, I'm happy to find that I am not alone. See this: https://github.com/orderedlist/minimal/issues/1\nIn fact, it was fixed here: https://github.com/yegeniy/yegeniy.github.io/commit/79a69bac86fecc0ff89c9ea72124c0322af8f3ce (someone's page).\nBut there's also this pull request in upstream https://github.com/orderedlist/minimal/pull/2 which changed it to #666. However, it was then set back to #727272 in https://github.com/orderedlist/minimal/commit/3574fcf40f8f3149369ea3d243f23c16196c2b38.\nSo either fix it yourself or find a new stylesheet. This stylesheet is not that good in other aspects too, so you can safely drop it.\n. By the way, I've opened a pull request here: https://github.com/orderedlist/minimal/pull/25\nIf anybody feels with this hilariously light text as uncomfortable as I do, please express your opinion there.\n. It was merged!\n. Actually\u2026 this has to be reopened\u2026\nSee this comment: https://github.com/orderedlist/minimal/issues/1#issuecomment-255735813\n. ",
    "bcowgill": "yes, the problem with the note is that some tools generate an error when it doesn't recognize a key.  I wasn't intending it to be a case of always generating the comment key, but perhaps as an option passed in to the json5 tool so users had the choice. It is unfortunate that the spec didn't have more to say on this to make it reliable.\n. I mean what you said in your second paragraph. I don't have a real world example yet, as far as JSON is concerned. As in, this is not stopping me. I have felt this pain before using other source code translators though. As you say, if a consuming app reported an error as line 5 column 32\nthen the removal of commented lines would throw the line number off and any inline comments\nwould throw the column count off.\nWhile looking for a commented JSON solution I saw this one: \nhttps://github.com/sindresorhus/strip-json-comments\nWhich mentions that feature as an option and thought I'd post it here as well.\nBTW json5 worked just perfectly for my project yesterday so thanks for that!\n. I realised it also wouldn't help in the case where you split lines using \\ as the following line numbers would also be out of alignment.\n. yes, the problem with the note is that some tools generate an error when it doesn't recognize a key.  I wasn't intending it to be a case of always generating the comment key, but perhaps as an option passed in to the json5 tool so users had the choice. It is unfortunate that the spec didn't have more to say on this to make it reliable.\n. I mean what you said in your second paragraph. I don't have a real world example yet, as far as JSON is concerned. As in, this is not stopping me. I have felt this pain before using other source code translators though. As you say, if a consuming app reported an error as line 5 column 32\nthen the removal of commented lines would throw the line number off and any inline comments\nwould throw the column count off.\nWhile looking for a commented JSON solution I saw this one: \nhttps://github.com/sindresorhus/strip-json-comments\nWhich mentions that feature as an option and thought I'd post it here as well.\nBTW json5 worked just perfectly for my project yesterday so thanks for that!\n. I realised it also wouldn't help in the case where you split lines using \\ as the following line numbers would also be out of alignment.\n. ",
    "DinisCruz": "but does it preserve the previous format?\ni'll give it a try and see what it produces\nthx\n. ok, so that that will not work for what I'm trying to do (json5 , It's a good project and for config it is a good idea)\nGoing to close the issue since it the question is answered\n. but does it preserve the previous format?\ni'll give it a try and see what it produces\nthx\n. ok, so that that will not work for what I'm trying to do (json5 , It's a good project and for config it is a good idea)\nGoing to close the issue since it the question is answered\n. ",
    "vdh": "I guess I'll just use any-json instead (which ironically, uses json5\u2026)\n. I guess I'll just use any-json instead (which ironically, uses json5\u2026)\n. ",
    "ianloic": "Thanks! The copyright in README.md lists (well links to) other people. How about making tham consistent, and linking to the LICENCE.md from the README.md?\n. Congratulations @aseemk!\n. Thanks! The copyright in README.md lists (well links to) other people. How about making tham consistent, and linking to the LICENCE.md from the README.md?\n. Congratulations @aseemk!\n. ",
    "YerkoPalma": "Mmm it seems that's not a valid json but it is a valid js object.\nI'm working in a browserify transform, so I have to parse some js code as a string. I don't know if your library is supposed to handle js objects or jsons, in fact I started using it because of native JSON.parse and JSON.stringify limitations. I guess I'll look for a regex for now.\nIf you think this use case is out of scope, just close this issue, if don't I'll wait for a solution.\nThanks for your time anyway :)\n. Mmm it seems that's not a valid json but it is a valid js object.\nI'm working in a browserify transform, so I have to parse some js code as a string. I don't know if your library is supposed to handle js objects or jsons, in fact I started using it because of native JSON.parse and JSON.stringify limitations. I guess I'll look for a regex for now.\nIf you think this use case is out of scope, just close this issue, if don't I'll wait for a solution.\nThanks for your time anyway :)\n. ",
    "dessalines": "JSON is a data format, when you build the data, just leave those out. \n. JSON is a data format, when you build the data, just leave those out. \n. ",
    "dgreensp": "Thanks for the ultrafast turn-around!\nOn Sun, Nov 27, 2016 at 2:09 PM Jordan Tucker notifications@github.com\nwrote:\n\nThanks for the bug report! I just published the fix, so try it out at let\nus know if you still have any issues.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/json5/json5/issues/134#issuecomment-263151357, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAJgpnzD-6GHQPR-C-nEZ-wvgTxjz6axks5rCf-rgaJpZM4K9Omx\n.\n. Thanks for the ultrafast turn-around!\n\nOn Sun, Nov 27, 2016 at 2:09 PM Jordan Tucker notifications@github.com\nwrote:\n\nThanks for the bug report! I just published the fix, so try it out at let\nus know if you still have any issues.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/json5/json5/issues/134#issuecomment-263151357, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAJgpnzD-6GHQPR-C-nEZ-wvgTxjz6axks5rCf-rgaJpZM4K9Omx\n.\n. \n",
    "seagreen": "Hey @aseemk, a few thoughts:\n(1) If you freeze JSON5 that doesn't mean in 5+ years from now the lessons from JSON5 can't be taken and developed into a new spec (JSON22?).\nJavaScript will continue to change slowly, and someday it might be good to have another spec for easy to write JSON to keep up with it. But I actually think that process will go better in some ways if the specs are separate! Otherwise you end up in a very awkward period where a program may accept .json5 documents, but you're not sure if you can use the new features or not.\nOf course, this will end your ability to make small changes, which I admit is a real downside.\n(2) If you think it's a good idea to move towards freezing JSON5 then it doesn't have to happen immediately. For instance, @jordanbtucker's issues are exactly the kind of thing that would be good to resolve first.\nWhat do you think?. @aseemk: It's been half a year since I opened this issue. Do you think it's time to move towards finishing this thing? If so we should start making a list of blockers.. Bump. YAML is terrible, the world needs JSON5, to get adoption from serious users it has to actually be finished.. @techtonik: Gotchya. I actually have no opinion on any of the specifics. I really like the general direction of JSON5, so I trust that whatever changes are made in the run up to finalization will be as classy as the rest of the spec.\nThe thing I do care about is that some kind of release does happen eventually. Even making a 1.x release and saying \"nothing will change from this point except touchups\" would go a long way, though of course I would prefer:\nBecause it is so simple, it is not expected that the JSON5 grammar will ever change.. @jordanbtucker: Awesome! That was blazingly fast. Thank you for all your work on it.\nMy only comment would be that I look forward to this TODO being filled out. I'm having trouble telling whether JSON5 is meant to be a superset of JSON or not. This comment makes me think not, but the ABNF makes me think it is.\nEDIT: I just want to say again how excited I am JSON5 is moving towards a 1.x release. This is seriously great.. @jordanbtucker: This is amazingly fast progress. Also, thanks for the clarification that JSON5 is definitely a superset of JSON!\nMy only concern is the clarity of this line:\n\nJSON5 generators should escape these code points in strings.\n\nIt depends a lot on the precise meaning of \"should\" here. If I write a program that consumes JSON5 created by a generator, can I rely on those code points being escaped (AKA that the JSON5 will not actually be a superset of JSON, but rather an overlapping set?) You may define how you're using \"should\" somewhere else in the spec, if so sorry I missed it!. @jordanbtucker: Excellent\ud83d\ude04 You've fully addressed all my concerns.. Also there are some tools to generate railroad diagrams from EBNF or such, so if a formal grammar has been written I'd be happy to take it and make railroad diagrams from it.. @jordanbtucker: Thanks! I am extremely new to formal grammars, is there a name for the language that's used to describe JSON5 at the end of that document?. Sorry to get back to this so late!\nI am not sure why the ECMAScript people would make up their own convention when formal grammars already exist. For one thing this puts us in a crappy place because we're stuck copying their made up language.\nIt still might be nice to have a description of JSON5 using an actual formal grammar. We would probably want to use Augmented Backus\u2013Naur because that's what's used in the JSON spec. There are tools to turn Extended Backus-Naur into railroad diagrams, like in this project of mine here: https://github.com/seagreen/Son, we could probably find such a tool for Augmented Backus-Naur as well.\nI guess the question is: if we had unlimited volunteer time and could write the spec in any language we wanted, would we go with the ES5 convention or ABNF? I can see advantages for both.. That's really helpful, thanks! I'll close this for now since ABNF won't be a clear win over the current situation. I still might get around to writing one eventually, if I start on it I'll make a new issue to discuss it.. > \"JSON for humans\"\nI love it.\n\n\"JSON for the ES5 era\"\n\nThis might be better for specific audiences like frontend devs. I do like that it explains the \"5\" in \"JSON5\". I think your previous idea is better for json5.org though because all kinds of people will be arriving there. Backend devs are unlikely to realize that \"JSON for the ES5 era\" will be relevant and helpful to them.. Hey @aseemk, a few thoughts:\n(1) If you freeze JSON5 that doesn't mean in 5+ years from now the lessons from JSON5 can't be taken and developed into a new spec (JSON22?).\nJavaScript will continue to change slowly, and someday it might be good to have another spec for easy to write JSON to keep up with it. But I actually think that process will go better in some ways if the specs are separate! Otherwise you end up in a very awkward period where a program may accept .json5 documents, but you're not sure if you can use the new features or not.\nOf course, this will end your ability to make small changes, which I admit is a real downside.\n(2) If you think it's a good idea to move towards freezing JSON5 then it doesn't have to happen immediately. For instance, @jordanbtucker's issues are exactly the kind of thing that would be good to resolve first.\nWhat do you think?. @aseemk: It's been half a year since I opened this issue. Do you think it's time to move towards finishing this thing? If so we should start making a list of blockers.. Bump. YAML is terrible, the world needs JSON5, to get adoption from serious users it has to actually be finished.. @techtonik: Gotchya. I actually have no opinion on any of the specifics. I really like the general direction of JSON5, so I trust that whatever changes are made in the run up to finalization will be as classy as the rest of the spec.\nThe thing I do care about is that some kind of release does happen eventually. Even making a 1.x release and saying \"nothing will change from this point except touchups\" would go a long way, though of course I would prefer:\nBecause it is so simple, it is not expected that the JSON5 grammar will ever change.. @jordanbtucker: Awesome! That was blazingly fast. Thank you for all your work on it.\nMy only comment would be that I look forward to this TODO being filled out. I'm having trouble telling whether JSON5 is meant to be a superset of JSON or not. This comment makes me think not, but the ABNF makes me think it is.\nEDIT: I just want to say again how excited I am JSON5 is moving towards a 1.x release. This is seriously great.. @jordanbtucker: This is amazingly fast progress. Also, thanks for the clarification that JSON5 is definitely a superset of JSON!\nMy only concern is the clarity of this line:\n\nJSON5 generators should escape these code points in strings.\n\nIt depends a lot on the precise meaning of \"should\" here. If I write a program that consumes JSON5 created by a generator, can I rely on those code points being escaped (AKA that the JSON5 will not actually be a superset of JSON, but rather an overlapping set?) You may define how you're using \"should\" somewhere else in the spec, if so sorry I missed it!. @jordanbtucker: Excellent\ud83d\ude04 You've fully addressed all my concerns.. Also there are some tools to generate railroad diagrams from EBNF or such, so if a formal grammar has been written I'd be happy to take it and make railroad diagrams from it.. @jordanbtucker: Thanks! I am extremely new to formal grammars, is there a name for the language that's used to describe JSON5 at the end of that document?. Sorry to get back to this so late!\nI am not sure why the ECMAScript people would make up their own convention when formal grammars already exist. For one thing this puts us in a crappy place because we're stuck copying their made up language.\nIt still might be nice to have a description of JSON5 using an actual formal grammar. We would probably want to use Augmented Backus\u2013Naur because that's what's used in the JSON spec. There are tools to turn Extended Backus-Naur into railroad diagrams, like in this project of mine here: https://github.com/seagreen/Son, we could probably find such a tool for Augmented Backus-Naur as well.\nI guess the question is: if we had unlimited volunteer time and could write the spec in any language we wanted, would we go with the ES5 convention or ABNF? I can see advantages for both.. That's really helpful, thanks! I'll close this for now since ABNF won't be a clear win over the current situation. I still might get around to writing one eventually, if I start on it I'll make a new issue to discuss it.. > \"JSON for humans\"\nI love it.\n\n\"JSON for the ES5 era\"\n\nThis might be better for specific audiences like frontend devs. I do like that it explains the \"5\" in \"JSON5\". I think your previous idea is better for json5.org though because all kinds of people will be arriving there. Backend devs are unlikely to realize that \"JSON for the ES5 era\" will be relevant and helpful to them.. ",
    "techtonik": "For me comments, trailing commas and non-quoted key names is a must. \nMultiline stings with quoted ends are not convenient for copy/paste - Python-like triple quoted strings are better, but they lack indentation for readability.\nEverything else potentially makes parsing slower.\nConsidering that JSON is cross-language, this - Infinity, -Infinity, NaN, and -NaN. - is not portable.. Comments alone are worthy of release - https://stackoverflow.com/questions/tagged/json?sort=votes. Okay. json5 wins with 5 votes.. For me comments, trailing commas and non-quoted key names is a must. \nMultiline stings with quoted ends are not convenient for copy/paste - Python-like triple quoted strings are better, but they lack indentation for readability.\nEverything else potentially makes parsing slower.\nConsidering that JSON is cross-language, this - Infinity, -Infinity, NaN, and -NaN. - is not portable.. Comments alone are worthy of release - https://stackoverflow.com/questions/tagged/json?sort=votes. Okay. json5 wins with 5 votes.. ",
    "MartinMuzatko": "Hello. Having no idea about the entire standardization process of the w3c and tc39 etc.. Is this issue the ticket for us, to make JSON5 an official supported standard?. Hello. Having no idea about the entire standardization process of the w3c and tc39 etc.. Is this issue the ticket for us, to make JSON5 an official supported standard?. ",
    "d-frey": "FWIW, I wrote an ABNF for JSON5, see json5.abnf.\nAs it is an ABNF, the grammar itself might not fully describe the language, additional rules apply (e.g. about valid surrogate pairs in strings, etc.). Or even just .j5?. Thanks, this seems quite reasonable and I think my implementation in our library is now complete.\nI can only hope that the allowed identifiers will stay as they are, I think it is quite sufficient and anything beyond /[$_A-Za-z][$_A-Za-z0-9]*/ can surely go into an ordinary string :)\n. One more question: I noticed that ECMAScript allows multiple zeroes (and JSON5's Grammar refers to it). Is this a JSON5 extension or not? Also, would you accept a closed grammar for JSON5 if I write one? (I basically have it already, I just need to convert it from PEGTL-format to an ABNF-like syntax) I think it would make sense to explicitly define the complete and unambiguous JSON5 grammar.. OK, thanks.\nWhat about the free-standing grammar for JSON5? I think JSON5 would be great if it would stand on its own, referring to ECMAScript (5) might seem natural to you (and others that work with it), but it is completely alien to me (and possibly others that also don't use it).\nMaking it independent (and only taking care of being a (sub-set) of ECMAScript in the background) will likely turn it into a more concise and accessible standard. One which I already like, and I can only repeat my offer to help it grow to its full potential :) But ultimately, it is your decision.. I still have a hard time to understand exactly what is now intended and what is not. For example: You refer to escape sequences from ES5, only the edit clarifies that v and x are excluded. What about 0-9?\nAnyways, I went ahead and wrote a first version of a ABNF for JSON5. Does this look reasonable to you? (It's actually based on and extends the JSON ABNF from RFC 7159.\n```abnf\n;--------------------------------------------------------\n; Proposed grammar for JSON5 (http://json5.org/)\n; Questions? mailto:d.frey@gmx.de\neol = %x0A / %x0A.0D / %x0D    ; Accept any line ending\n; TODO: These probably need to be more complex, not just up to %x10FFFF\np-char = %x20-10FFFF          ; Printable character\np-char-non-star = %x20-29 / %x2B-10FFFF\n                              ; Printable character except *\np-char-non-slash = %x20-2E / %x30-10FFFF\n                              ; Printable character except /\n; TODO: Allow sl-comment as the last line without eol?\nsl-comment = %x2F.2F *( %x09 / p-char ) eol\nml-comment = %x2F.2A *( p-char-non-star / ( %x2A p-char-non-slash ) / %x09 / eol ) %x2A.2F\ncomment = sl-comment / ml-comment\n; TODO: Add %xA0 (NBSP) and/or %xFEFF (BOM)?\n; TODO: Shouldn't a BOM only be allowed at the start of the input?\nws = *(\n          %x20 /              ; Space\n          %x09 /              ; Horizontal tab\n          eol /               ; Line ending\n      sl-comment /        ; Single-line comment\n      ml-comment          ; Multi-line comment\n      )\n;--------------------------------------------------------\nbegin-array     = ws %x5B ws  ; [ left square bracket\nbegin-object    = ws %x7B ws  ; { left curly bracket\nend-array       = ws %x5D ws  ; ] right square bracket\nend-object      = ws %x7D ws  ; } right curly bracket\nname-separator  = ws %x3A ws  ; : colon\nvalue-separator = ws %x2C ws  ; , comma\nvalue-sep-opt   = [ value-separator ]\n;--------------------------------------------------------\nnull  = %x6E.75.6C.6C         ; null\ntrue  = %x74.72.75.65         ; true\nfalse = %x66.61.6C.73.65      ; false\n;--------------------------------------------------------\nnumber = [ plus / minus ] ( nan / inf / hex / dec )\nnan = %x4E.61.4E              ; NaN\ninf = %x49.6E.66.69.6E.69.74.79\n                              ; Infinity\nhex = zero x 1*HEXDIG         ; 0xXXX...\ndec = ( int [ frac0 ] / frac1 ) [ exp ]\ndecimal-point = %x2E          ; .\ndigit1-9 = %x31-39            ; 1-9\ne = %x65 / %x45               ; e E\nx = %x78 / %x58               ; x X\nexp = e [ plus / minus ] 1*DIGIT\nfrac0 = decimal-point *DIGIT\nfrac1 = decimal-point 1*DIGIT\nint = zero / ( digit1-9 *DIGIT )\nplus = %x2B                   ; +\nminus = %x2D                  ; -\nzero = %x30                   ; 0\n;--------------------------------------------------------\nstring = s-string / d-string\nd-string = d-quotation-mark *( char / s-quotation-mark ) d-quotation-mark\ns-string = s-quotation-mark *( char / d-quotation-mark ) s-quotation-mark\nchar = unescaped /\n       escape (\n           eol /              ; escaped newline\n           %x62 /             ; b    backspace       U+0008\n           %x66 /             ; f    form feed       U+000C\n           %x6E /             ; n    line feed       U+000A\n           %x72 /             ; r    carriage return U+000D\n           %x74 /             ; t    tab             U+0009\n           %x76 /             ; v    vtab            U+000B\n           %x78 2HEXDIG /     ; xXX                  U+00XX\n           %x75 4HEXDIG /     ; uXXXX                U+XXXX\n           other-escape )     ; no special meaning\nescape = %x5C                 ; \\\nd-quotation-mark = %x22       ; \"\ns-quotation-mark = %x27       ; '\nunescaped = %x20-21 / %x23-26 / %x28-5B / %x5D-10FFFF\n; TODO: Exclude 0-9?\nother-escaped = %x20-61 / %x63-65 / %x67-6D / %x6F-71 / %x73 / %x77 / %x79-10FFFF\n;--------------------------------------------------------\n; TODO: Is [,] allowed? No.\narray = begin-array [ value *( value-separator value ) value-sep-opt ] end-array\n;--------------------------------------------------------\n; TODO: Is {,} allowed? No.\nobject = begin-object [ member *( value-separator member ) value-sep-opt ] end-object\nmember = key name-separator value\nkey = string / identifier\nbegin-identifier = ALPHA / %x5F / %x24\ncontinue-identifier = begin-identifier / DIGIT\nidentifier = begin-identifier *continue-identifier\n;--------------------------------------------------------\nvalue = null / true / false / number / string / array / object\nJSON5-text = ws value ws\n```\n. Updated:\n```abnf\n;--------------------------------------------------------\n; Proposed grammar for JSON5 (http://json5.org/)\n; Questions? mailto:d.frey@gmx.de\n;--------------------------------------------------------\neol = %x0A / %x0A.0D / %x0D   ; End-of-line\n;--------------------------------------------------------\np-char = %x20-10FFFF          ; Printable character\np-char-non-star = %x20-29 / %x2B-10FFFF\n                              ; Printable character except *\np-char-non-slash = %x20-2E / %x30-10FFFF\n                              ; Printable character except /\n; TODO: Allow sl-comment as the last line without eol?\nsl-comment = begin-sl-comment *( p-char / ows ) eol\nml-comment = begin-ml-comment *( p-char-non-star / ( %x2A p-char-non-slash ) / ows / eol ) end-ml-comment\ncomment = sl-comment / ml-comment\n;--------------------------------------------------------\nbegin-sl-comment = %x2F.2F    ; //\nbegin-ml-comment = %x2F.2A    ; /\nend-ml-comment   = %x2A.2F    ; /\n;--------------------------------------------------------\nws = *(\n          %x20 /              ; Space\n          ows /               ; Other space-like characters\n          eol /               ; Line ending\n      sl-comment /        ; Single-line comment\n      ml-comment          ; Multi-line comment\n      )\nows = %x09 /                  ; Horizontal tab\n      %xA0                    ; NBSP\n      %xFEFF                  ; BOM\n;--------------------------------------------------------\nbegin-array     = ws %x5B ws  ; [ left square bracket\nbegin-object    = ws %x7B ws  ; { left curly bracket\nend-array       = ws %x5D ws  ; ] right square bracket\nend-object      = ws %x7D ws  ; } right curly bracket\nname-separator  = ws %x3A ws  ; : colon\nvalue-separator = ws %x2C ws  ; , comma\nvalue-sep-opt   = [ value-separator ]\n;--------------------------------------------------------\nnull  = %x6E.75.6C.6C         ; null\ntrue  = %x74.72.75.65         ; true\nfalse = %x66.61.6C.73.65      ; false\n;--------------------------------------------------------\nnumber = [ plus / minus ] ( nan / inf / hex / dec )\nnan = %x4E.61.4E              ; NaN\ninf = %x49.6E.66.69.6E.69.74.79\n                              ; Infinity\nhex = zero x 1*HEXDIG         ; 0xXXX...\ndec = ( int [ frac0 ] / frac1 ) [ exp ]\ndecimal-point = %x2E          ; .\ndigit1-9 = %x31-39            ; 1-9\ne = %x65 / %x45               ; e E\nx = %x78 / %x58               ; x X\nexp = e [ plus / minus ] 1*DIGIT\nfrac0 = decimal-point *DIGIT\nfrac1 = decimal-point 1*DIGIT\nint = zero / ( digit1-9 *DIGIT )\nplus = %x2B                   ; +\nminus = %x2D                  ; -\nzero = %x30                   ; 0\n;--------------------------------------------------------\nstring = s-string / d-string\nd-string = d-quotation-mark *( char / s-quotation-mark ) d-quotation-mark\ns-string = s-quotation-mark *( char / d-quotation-mark ) s-quotation-mark\nchar = unescaped /\n       escape (\n           %x30 /             ; 0    nul             U+0000\n           %x62 /             ; b    backspace       U+0008\n           %x66 /             ; f    form feed       U+000C\n           %x6E /             ; n    line feed       U+000A\n           %x72 /             ; r    carriage return U+000D\n           %x74 /             ; t    tab             U+0009\n           %x76 /             ; v    vtab            U+000B\n           %x78 2HEXDIG /     ; xXX                  U+00XX\n           %x75 4HEXDIG /     ; uXXXX                U+XXXX\n       eol /              ; end-of-line -> empty string\n       %x2028 /           ; line separator -> empty string\n       %x2029 /           ; paragraph separator -> empty string\n                          ; TODO: Remove U+2028 and U+2029? See #70\n\n       other-escape )     ; the character itself\n\nescape = %x5C                 ; \\\nd-quotation-mark = %x22       ; \"\ns-quotation-mark = %x27       ; '\nunescaped = %x20-21 / %x23-26 / %x28-5B / %x5D-10FFFF\nother-escaped = %x20-2F / %x3A-61 / %x63-65 / %x67-6D / %x6F-71 / %x73 / %x77 / %x79-10FFFF\n;--------------------------------------------------------\narray = begin-array [ value *( value-separator value ) value-sep-opt ] end-array\n;--------------------------------------------------------\nobject = begin-object [ member *( value-separator member ) value-sep-opt ] end-object\nmember = key name-separator value\nkey = string / identifier\nbegin-identifier = ALPHA / %x5F / %x24\n                              ; ALPHA / \"_\" / \"$\"\ncontinue-identifier = begin-identifier / DIGIT\nidentifier = begin-identifier *continue-identifier\n;--------------------------------------------------------\nvalue = null / true / false / number / string / array / object\nJSON5-text = ws value ws\n```. Remarks about the grammar:\n\nAllows escaped U+2028 and U+2029 for now, they are easy to remove if they are not wanted.\nDisallows trailing commas on empty arrays/objects. OK? ([,], {,})\nRestricts identifiers to (ALPHA/\"_\"/\"$\") *(ALNUM/\"_\"/\"$\").\nAdding \\0 and \\xXX as escape-sequences makes sense thinking about bytes, but JSON strings are required to be valid unicode strings - and those may not contain embedded nul-bytes IIUC. What is the intended semantics of those? Or does JSON5 allow \"binary\" strings, meaning any byte-combination is allowed? And if that is the case, what is the semantics of escaped surrogate pairs?\nShould the grammar be committed somewhere?. OK, so I'll just add the raw bytes for \\0 and \\xXX - let's see how that will turn out :)\n\nNext remarks:\n\nThe grammar doesn't allow it (yet), but I guess a single-line comment is allowed to be at the end of the input without an explicit eol? (complete input exampe: \"foo\" // a string - no newline anywhere)\nAre negative (or explicitly positive) hexadecimal values allowed? -0x1234 or +0x1234 instead of just plain 0x1234?\n. I did some final changes and polishing and created a PR as requested. Now I'll have to do my homework and fix our library's JSON5 parser :). I think I now implemented everything in our library, see https://github.com/taocpp/json\n\nHave you found the time to review the changes? (grammar-wise wrt the JSON grammar from RFC 7159, not our library). Running the test-suite is not the same as reviewing a grammar as a human.\nAlso, that test suite does not contain JSON reference strings. Currently, you test suite only tests whether or not something parses, but not how. With a reference string, I could at least compare the result of parsing JSON5 to something from a well-known and working JSON parser. Example:\n\"hello,\\\n world\"\nshould be identical to this JSON:\n\"hello, world\"\nand not this:\n\"hello,\\n world\"\n. FWIW, I wrote an ABNF for JSON5, see json5.abnf.\nAs it is an ABNF, the grammar itself might not fully describe the language, additional rules apply (e.g. about valid surrogate pairs in strings, etc.). Or even just .j5?. Thanks, this seems quite reasonable and I think my implementation in our library is now complete.\nI can only hope that the allowed identifiers will stay as they are, I think it is quite sufficient and anything beyond /[$_A-Za-z][$_A-Za-z0-9]*/ can surely go into an ordinary string :)\n. One more question: I noticed that ECMAScript allows multiple zeroes (and JSON5's Grammar refers to it). Is this a JSON5 extension or not? Also, would you accept a closed grammar for JSON5 if I write one? (I basically have it already, I just need to convert it from PEGTL-format to an ABNF-like syntax) I think it would make sense to explicitly define the complete and unambiguous JSON5 grammar.. OK, thanks.\nWhat about the free-standing grammar for JSON5? I think JSON5 would be great if it would stand on its own, referring to ECMAScript (5) might seem natural to you (and others that work with it), but it is completely alien to me (and possibly others that also don't use it).\nMaking it independent (and only taking care of being a (sub-set) of ECMAScript in the background) will likely turn it into a more concise and accessible standard. One which I already like, and I can only repeat my offer to help it grow to its full potential :) But ultimately, it is your decision.. I still have a hard time to understand exactly what is now intended and what is not. For example: You refer to escape sequences from ES5, only the edit clarifies that v and x are excluded. What about 0-9?\nAnyways, I went ahead and wrote a first version of a ABNF for JSON5. Does this look reasonable to you? (It's actually based on and extends the JSON ABNF from RFC 7159.\n```abnf\n;--------------------------------------------------------\n; Proposed grammar for JSON5 (http://json5.org/)\n; Questions? mailto:d.frey@gmx.de\neol = %x0A / %x0A.0D / %x0D    ; Accept any line ending\n; TODO: These probably need to be more complex, not just up to %x10FFFF\np-char = %x20-10FFFF          ; Printable character\np-char-non-star = %x20-29 / %x2B-10FFFF\n                              ; Printable character except *\np-char-non-slash = %x20-2E / %x30-10FFFF\n                              ; Printable character except /\n; TODO: Allow sl-comment as the last line without eol?\nsl-comment = %x2F.2F *( %x09 / p-char ) eol\nml-comment = %x2F.2A *( p-char-non-star / ( %x2A p-char-non-slash ) / %x09 / eol ) %x2A.2F\ncomment = sl-comment / ml-comment\n; TODO: Add %xA0 (NBSP) and/or %xFEFF (BOM)?\n; TODO: Shouldn't a BOM only be allowed at the start of the input?\nws = *(\n          %x20 /              ; Space\n          %x09 /              ; Horizontal tab\n          eol /               ; Line ending\n      sl-comment /        ; Single-line comment\n      ml-comment          ; Multi-line comment\n      )\n;--------------------------------------------------------\nbegin-array     = ws %x5B ws  ; [ left square bracket\nbegin-object    = ws %x7B ws  ; { left curly bracket\nend-array       = ws %x5D ws  ; ] right square bracket\nend-object      = ws %x7D ws  ; } right curly bracket\nname-separator  = ws %x3A ws  ; : colon\nvalue-separator = ws %x2C ws  ; , comma\nvalue-sep-opt   = [ value-separator ]\n;--------------------------------------------------------\nnull  = %x6E.75.6C.6C         ; null\ntrue  = %x74.72.75.65         ; true\nfalse = %x66.61.6C.73.65      ; false\n;--------------------------------------------------------\nnumber = [ plus / minus ] ( nan / inf / hex / dec )\nnan = %x4E.61.4E              ; NaN\ninf = %x49.6E.66.69.6E.69.74.79\n                              ; Infinity\nhex = zero x 1*HEXDIG         ; 0xXXX...\ndec = ( int [ frac0 ] / frac1 ) [ exp ]\ndecimal-point = %x2E          ; .\ndigit1-9 = %x31-39            ; 1-9\ne = %x65 / %x45               ; e E\nx = %x78 / %x58               ; x X\nexp = e [ plus / minus ] 1*DIGIT\nfrac0 = decimal-point *DIGIT\nfrac1 = decimal-point 1*DIGIT\nint = zero / ( digit1-9 *DIGIT )\nplus = %x2B                   ; +\nminus = %x2D                  ; -\nzero = %x30                   ; 0\n;--------------------------------------------------------\nstring = s-string / d-string\nd-string = d-quotation-mark *( char / s-quotation-mark ) d-quotation-mark\ns-string = s-quotation-mark *( char / d-quotation-mark ) s-quotation-mark\nchar = unescaped /\n       escape (\n           eol /              ; escaped newline\n           %x62 /             ; b    backspace       U+0008\n           %x66 /             ; f    form feed       U+000C\n           %x6E /             ; n    line feed       U+000A\n           %x72 /             ; r    carriage return U+000D\n           %x74 /             ; t    tab             U+0009\n           %x76 /             ; v    vtab            U+000B\n           %x78 2HEXDIG /     ; xXX                  U+00XX\n           %x75 4HEXDIG /     ; uXXXX                U+XXXX\n           other-escape )     ; no special meaning\nescape = %x5C                 ; \\\nd-quotation-mark = %x22       ; \"\ns-quotation-mark = %x27       ; '\nunescaped = %x20-21 / %x23-26 / %x28-5B / %x5D-10FFFF\n; TODO: Exclude 0-9?\nother-escaped = %x20-61 / %x63-65 / %x67-6D / %x6F-71 / %x73 / %x77 / %x79-10FFFF\n;--------------------------------------------------------\n; TODO: Is [,] allowed? No.\narray = begin-array [ value *( value-separator value ) value-sep-opt ] end-array\n;--------------------------------------------------------\n; TODO: Is {,} allowed? No.\nobject = begin-object [ member *( value-separator member ) value-sep-opt ] end-object\nmember = key name-separator value\nkey = string / identifier\nbegin-identifier = ALPHA / %x5F / %x24\ncontinue-identifier = begin-identifier / DIGIT\nidentifier = begin-identifier *continue-identifier\n;--------------------------------------------------------\nvalue = null / true / false / number / string / array / object\nJSON5-text = ws value ws\n```\n. Updated:\n```abnf\n;--------------------------------------------------------\n; Proposed grammar for JSON5 (http://json5.org/)\n; Questions? mailto:d.frey@gmx.de\n;--------------------------------------------------------\neol = %x0A / %x0A.0D / %x0D   ; End-of-line\n;--------------------------------------------------------\np-char = %x20-10FFFF          ; Printable character\np-char-non-star = %x20-29 / %x2B-10FFFF\n                              ; Printable character except *\np-char-non-slash = %x20-2E / %x30-10FFFF\n                              ; Printable character except /\n; TODO: Allow sl-comment as the last line without eol?\nsl-comment = begin-sl-comment *( p-char / ows ) eol\nml-comment = begin-ml-comment *( p-char-non-star / ( %x2A p-char-non-slash ) / ows / eol ) end-ml-comment\ncomment = sl-comment / ml-comment\n;--------------------------------------------------------\nbegin-sl-comment = %x2F.2F    ; //\nbegin-ml-comment = %x2F.2A    ; /\nend-ml-comment   = %x2A.2F    ; /\n;--------------------------------------------------------\nws = *(\n          %x20 /              ; Space\n          ows /               ; Other space-like characters\n          eol /               ; Line ending\n      sl-comment /        ; Single-line comment\n      ml-comment          ; Multi-line comment\n      )\nows = %x09 /                  ; Horizontal tab\n      %xA0                    ; NBSP\n      %xFEFF                  ; BOM\n;--------------------------------------------------------\nbegin-array     = ws %x5B ws  ; [ left square bracket\nbegin-object    = ws %x7B ws  ; { left curly bracket\nend-array       = ws %x5D ws  ; ] right square bracket\nend-object      = ws %x7D ws  ; } right curly bracket\nname-separator  = ws %x3A ws  ; : colon\nvalue-separator = ws %x2C ws  ; , comma\nvalue-sep-opt   = [ value-separator ]\n;--------------------------------------------------------\nnull  = %x6E.75.6C.6C         ; null\ntrue  = %x74.72.75.65         ; true\nfalse = %x66.61.6C.73.65      ; false\n;--------------------------------------------------------\nnumber = [ plus / minus ] ( nan / inf / hex / dec )\nnan = %x4E.61.4E              ; NaN\ninf = %x49.6E.66.69.6E.69.74.79\n                              ; Infinity\nhex = zero x 1*HEXDIG         ; 0xXXX...\ndec = ( int [ frac0 ] / frac1 ) [ exp ]\ndecimal-point = %x2E          ; .\ndigit1-9 = %x31-39            ; 1-9\ne = %x65 / %x45               ; e E\nx = %x78 / %x58               ; x X\nexp = e [ plus / minus ] 1*DIGIT\nfrac0 = decimal-point *DIGIT\nfrac1 = decimal-point 1*DIGIT\nint = zero / ( digit1-9 *DIGIT )\nplus = %x2B                   ; +\nminus = %x2D                  ; -\nzero = %x30                   ; 0\n;--------------------------------------------------------\nstring = s-string / d-string\nd-string = d-quotation-mark *( char / s-quotation-mark ) d-quotation-mark\ns-string = s-quotation-mark *( char / d-quotation-mark ) s-quotation-mark\nchar = unescaped /\n       escape (\n           %x30 /             ; 0    nul             U+0000\n           %x62 /             ; b    backspace       U+0008\n           %x66 /             ; f    form feed       U+000C\n           %x6E /             ; n    line feed       U+000A\n           %x72 /             ; r    carriage return U+000D\n           %x74 /             ; t    tab             U+0009\n           %x76 /             ; v    vtab            U+000B\n           %x78 2HEXDIG /     ; xXX                  U+00XX\n           %x75 4HEXDIG /     ; uXXXX                U+XXXX\n       eol /              ; end-of-line -> empty string\n       %x2028 /           ; line separator -> empty string\n       %x2029 /           ; paragraph separator -> empty string\n                          ; TODO: Remove U+2028 and U+2029? See #70\n\n       other-escape )     ; the character itself\n\nescape = %x5C                 ; \\\nd-quotation-mark = %x22       ; \"\ns-quotation-mark = %x27       ; '\nunescaped = %x20-21 / %x23-26 / %x28-5B / %x5D-10FFFF\nother-escaped = %x20-2F / %x3A-61 / %x63-65 / %x67-6D / %x6F-71 / %x73 / %x77 / %x79-10FFFF\n;--------------------------------------------------------\narray = begin-array [ value *( value-separator value ) value-sep-opt ] end-array\n;--------------------------------------------------------\nobject = begin-object [ member *( value-separator member ) value-sep-opt ] end-object\nmember = key name-separator value\nkey = string / identifier\nbegin-identifier = ALPHA / %x5F / %x24\n                              ; ALPHA / \"_\" / \"$\"\ncontinue-identifier = begin-identifier / DIGIT\nidentifier = begin-identifier *continue-identifier\n;--------------------------------------------------------\nvalue = null / true / false / number / string / array / object\nJSON5-text = ws value ws\n```. Remarks about the grammar:\n\nAllows escaped U+2028 and U+2029 for now, they are easy to remove if they are not wanted.\nDisallows trailing commas on empty arrays/objects. OK? ([,], {,})\nRestricts identifiers to (ALPHA/\"_\"/\"$\") *(ALNUM/\"_\"/\"$\").\nAdding \\0 and \\xXX as escape-sequences makes sense thinking about bytes, but JSON strings are required to be valid unicode strings - and those may not contain embedded nul-bytes IIUC. What is the intended semantics of those? Or does JSON5 allow \"binary\" strings, meaning any byte-combination is allowed? And if that is the case, what is the semantics of escaped surrogate pairs?\nShould the grammar be committed somewhere?. OK, so I'll just add the raw bytes for \\0 and \\xXX - let's see how that will turn out :)\n\nNext remarks:\n\nThe grammar doesn't allow it (yet), but I guess a single-line comment is allowed to be at the end of the input without an explicit eol? (complete input exampe: \"foo\" // a string - no newline anywhere)\nAre negative (or explicitly positive) hexadecimal values allowed? -0x1234 or +0x1234 instead of just plain 0x1234?\n. I did some final changes and polishing and created a PR as requested. Now I'll have to do my homework and fix our library's JSON5 parser :). I think I now implemented everything in our library, see https://github.com/taocpp/json\n\nHave you found the time to review the changes? (grammar-wise wrt the JSON grammar from RFC 7159, not our library). Running the test-suite is not the same as reviewing a grammar as a human.\nAlso, that test suite does not contain JSON reference strings. Currently, you test suite only tests whether or not something parses, but not how. With a reference string, I could at least compare the result of parsing JSON5 to something from a well-known and working JSON parser. Example:\n\"hello,\\\n world\"\nshould be identical to this JSON:\n\"hello, world\"\nand not this:\n\"hello,\\n world\"\n. ",
    "zamicol": "I don't follow.  That thread states that YAML is not a json superset.  . I don't follow.  That thread states that YAML is not a json superset.  . ",
    "dreftymac": "\nI don't follow. That thread states that YAML is not a json superset.\n\n(TL:DR;) YAML parses JSON just fine, so long as one does not use TAB for indentation\n\nBoring details below.\n\nWTF: Is YAML a superset of JSON or not?\nYAML does not permit tabs for indentation, that is the single factor that precludes it as an unambiguous superset of JSON.\n\nIf a developer wishes to use tabs to indent JSON, then YAML is not a json superset holds.\nIf a developer avoids using tabs to indent JSON, then YAML is not a json superset still holds, but for all practical purposes, YAML and JSON are logically indistinguishable.\n\nSince \"tabs vs spaces\" is one of those aspects of engineering design that will never be a closed issue, it seems reasonable to leave it at that.\n\nhttps://www.youtube.com/watch?v=SsoOG6ZeyUI. There is a section already in the documentation and design philosophy which does address why JSON5 is not superfluous, given that YAML already exists.\n\nThis is an invitation to readers to further understand the nature of the differences between JSON and YAML; so that they can be well-informed in their choice of JSON5 as an alternative to both classic JSON and YAML.\nIf there is no need to augment the documentation and design philosophy notes on JSON5, then this issue can be considered complete AFAIC and left only as an historical note.. > I don't follow. That thread states that YAML is not a json superset.\n(TL:DR;) YAML parses JSON just fine, so long as one does not use TAB for indentation\n\nBoring details below.\n\nWTF: Is YAML a superset of JSON or not?\nYAML does not permit tabs for indentation, that is the single factor that precludes it as an unambiguous superset of JSON.\n\nIf a developer wishes to use tabs to indent JSON, then YAML is not a json superset holds.\nIf a developer avoids using tabs to indent JSON, then YAML is not a json superset still holds, but for all practical purposes, YAML and JSON are logically indistinguishable.\n\nSince \"tabs vs spaces\" is one of those aspects of engineering design that will never be a closed issue, it seems reasonable to leave it at that.\n\nhttps://www.youtube.com/watch?v=SsoOG6ZeyUI. There is a section already in the documentation and design philosophy which does address why JSON5 is not superfluous, given that YAML already exists.\n\nThis is an invitation to readers to further understand the nature of the differences between JSON and YAML; so that they can be well-informed in their choice of JSON5 as an alternative to both classic JSON and YAML.\nIf there is no need to augment the documentation and design philosophy notes on JSON5, then this issue can be considered complete AFAIC and left only as an historical note.. ",
    "aaronoah": "That's a brilliant idea! 5 could stands for S symbol partially in its shape as well as reserving the meaning of version number. That's a brilliant idea! 5 could stands for S symbol partially in its shape as well as reserving the meaning of version number. ",
    "louisbuchbinder": "What is wrong with .json5?. What is wrong with .json5?. ",
    "fracz": "Clever idea, but when it comes to pronunciation, the json5 is the best.. Clever idea, but when it comes to pronunciation, the json5 is the best.. ",
    "AleCaste": "Thanks for the quick response.\nUnfortunately the javascript engine I am forced to use does NOT have a JSON.stringify function built in. Along with the JSON5 lib, I could also make use of an additional lib just to generate the standard JSON output... but I feel it should not be necessary. There should be a mechanism in JSON5 customize the output a little bit.\nGoing through the JSON5 issues I learnt that JSON5.stringify used to generate standard JSON strings years ago. And I also came across another issue talking about the possibility of adding an \"options\" argument to the stringify function.. No worries. I totally understand your view. I'll simply add the json2 lib to stringify in standard JSON.\nIt's not that bad after all.\nThanks!. Thanks for the quick response.\nUnfortunately the javascript engine I am forced to use does NOT have a JSON.stringify function built in. Along with the JSON5 lib, I could also make use of an additional lib just to generate the standard JSON output... but I feel it should not be necessary. There should be a mechanism in JSON5 customize the output a little bit.\nGoing through the JSON5 issues I learnt that JSON5.stringify used to generate standard JSON strings years ago. And I also came across another issue talking about the possibility of adding an \"options\" argument to the stringify function.. No worries. I totally understand your view. I'll simply add the json2 lib to stringify in standard JSON.\nIt's not that bad after all.\nThanks!. ",
    "lyrachord": "May  consider space as well.\npi: 3.14 159 26\nmovreg: 0x1122 3344 5566 7788\nbinary: 0 1010 1111 1011 0001. May  consider space as well.\npi: 3.14 159 26\nmovreg: 0x1122 3344 5566 7788\nbinary: 0 1010 1111 1011 0001. ",
    "tobiasandersen": "Here's an example: https://jsfiddle.net/j1156ewj/1/. Thanks! I've worked around it already, just thought I'd let you know.. Here's an example: https://jsfiddle.net/j1156ewj/1/. Thanks! I've worked around it already, just thought I'd let you know.. ",
    "sachinlala": "Thanks @jordanbtucker for the prompt response.\nWill be best to have an ESLInk plugin also as you suggested.. Thanks @jordanbtucker for the prompt response.\nWill be best to have an ESLInk plugin also as you suggested.. ",
    "Peping": "Isn't JSON5 about enhancing JSON with EcmaScript5 features? This is not valid EcmaScript5.. Why don't you go with YAML instead? There's plenty of libraries already supporting it! The README.md in this repository is pretty explicit that JSON5 only intends to add features from EcmaScript5. . Isn't JSON5 about enhancing JSON with EcmaScript5 features? This is not valid EcmaScript5.. Why don't you go with YAML instead? There's plenty of libraries already supporting it! The README.md in this repository is pretty explicit that JSON5 only intends to add features from EcmaScript5. . ",
    "tidde": "Exactly, that's the question: Is it about enhancing with ES5 features, or is it about making a format for humans (manual editing, readability, and clean diffs)?\nFor me, the solution was to create a format I call Config Object Notation (with .con as filename extension).  The concrete syntax is even more light weight than the proposal above, while still being trivial to tokenize and parse.  In case someone ends up reading this in search for a format that is more about being for humans than enhancing JSON with ES5 features, these are some of the key features of the format:\n\nAbstract structure is based on JSON, but with some extensions.  Most notably, documentation comments are supported, see below.  Abstract structure is close enough to JSON to make one way conversion to JSON pretty straight-forward.\nNo separator is used between elements in arrays or between key/value pairs in objects.\nThe need to quote keys has been further reduced compared to JSON5, almost down to allowing any non-whitespace character in a non-quoted key.\nBy requiring the top value to be either an object or an array (which should be fine for any configuration file), the braces around a top level object may be omitted (the to level value must be an object unless the first token is an opening bracket).  Besides dropping the lines with the top level object delimiters, this makes it natural to start all top level key/value pairs in the first column.\nPython style raw strings reduces amount of escape sequences when writing regular expressions.  By being distinct from normal strings in the abstract structure, a tool reading CON and writing back to file will be able to preserve them as raw strings.\nSo-called single line comments may only be used to comment out an entire line, and are not part of the abstract structure (a tool reading CON and then writing back to file is not expected to preserve such comments).\nSo-called multi-line comments are intended for documentation, and while this is still under development, the idea is that these should only be allowed in certain places, but be part of the abstract structure.  For example, a documentation comment is allowed following (separated only by horizontal space) any non-top value, and is attached to this value in the abstract structure.  Similarly, a documentation comment for the top level value is allowed at the beginning of the file.  Inside arrays, documentation comments may appear among the elements of the array (without being attached to any of the elements) if it is only surrounded by whitespace on the lines it occupies.  Inside objects, documentation comments may appear among the key/value pairs in a similar way.\n\nExample:\n```\n/ Small example of a Config Object Notation file.\n * (Documentation belonging to to level obejct.)\n /\nname: 'CON'\n/ Author details (documentation between key/value pairs) /\nauthor-name: 'Henrik'\nauthor-email: 'henrik@service' / Not working, need to update. (Documentation belonging to value.) /\n/ Properties of the Config Object Notation format /\ntypes: [\n  / Plain JSON types /\n  { name: 'Boolean' }\n  { name: 'Integer' }\n  {\n    name: 'Float'\n    examples: [ 4.2e1 Infinity -Infinity NaN ]\n  }\n  {\n    name: 'String'\n    examples: [\n      'Hello,'\n      \"world!\"\n    ]\n  }\n  / Modified JSON types /\n  { name: 'Array' } / May contain documentation comments among elements. /\n  { name: 'Object' } / May contain documentation comments among elements. /\n  / Extensions /\n  {\n    name: 'RawString'\n    examples: [ r'.*.con' ]\n  }\n]\n``. YAML seems nice in many ways, but I see a few reasons why it would solve my needs:\n- Lack of stable implementation in OCaml (which is what I have to use at work), and too complicated to start yet another attempt at implementing it.\n- Handling of comments; I really care about the comments, and want to be able to write comment-preserving programs that operate on the \"representation graph\".\n- Presence of aliases also makes transforms more difficult to express; when a line is added to thebill-toaddress, what happens to theship-to` address?\nI guess one reason there seems to be no mature YAML implementation in OCaml is the complexity of the specification.  JSON is the opposite, and it simplicity really makes it a very useful format.  There are many inspiring ideas in YAML, but if I end up pursuing the CON format, I'll have to strike the right balance so that the burden of implementing the specification becomes more on par with JSON than YAML.. Exactly, that's the question: Is it about enhancing with ES5 features, or is it about making a format for humans (manual editing, readability, and clean diffs)?\nFor me, the solution was to create a format I call Config Object Notation (with .con as filename extension).  The concrete syntax is even more light weight than the proposal above, while still being trivial to tokenize and parse.  In case someone ends up reading this in search for a format that is more about being for humans than enhancing JSON with ES5 features, these are some of the key features of the format:\n\nAbstract structure is based on JSON, but with some extensions.  Most notably, documentation comments are supported, see below.  Abstract structure is close enough to JSON to make one way conversion to JSON pretty straight-forward.\nNo separator is used between elements in arrays or between key/value pairs in objects.\nThe need to quote keys has been further reduced compared to JSON5, almost down to allowing any non-whitespace character in a non-quoted key.\nBy requiring the top value to be either an object or an array (which should be fine for any configuration file), the braces around a top level object may be omitted (the to level value must be an object unless the first token is an opening bracket).  Besides dropping the lines with the top level object delimiters, this makes it natural to start all top level key/value pairs in the first column.\nPython style raw strings reduces amount of escape sequences when writing regular expressions.  By being distinct from normal strings in the abstract structure, a tool reading CON and writing back to file will be able to preserve them as raw strings.\nSo-called single line comments may only be used to comment out an entire line, and are not part of the abstract structure (a tool reading CON and then writing back to file is not expected to preserve such comments).\nSo-called multi-line comments are intended for documentation, and while this is still under development, the idea is that these should only be allowed in certain places, but be part of the abstract structure.  For example, a documentation comment is allowed following (separated only by horizontal space) any non-top value, and is attached to this value in the abstract structure.  Similarly, a documentation comment for the top level value is allowed at the beginning of the file.  Inside arrays, documentation comments may appear among the elements of the array (without being attached to any of the elements) if it is only surrounded by whitespace on the lines it occupies.  Inside objects, documentation comments may appear among the key/value pairs in a similar way.\n\nExample:\n```\n/ Small example of a Config Object Notation file.\n * (Documentation belonging to to level obejct.)\n /\nname: 'CON'\n/ Author details (documentation between key/value pairs) /\nauthor-name: 'Henrik'\nauthor-email: 'henrik@service' / Not working, need to update. (Documentation belonging to value.) /\n/ Properties of the Config Object Notation format /\ntypes: [\n  / Plain JSON types /\n  { name: 'Boolean' }\n  { name: 'Integer' }\n  {\n    name: 'Float'\n    examples: [ 4.2e1 Infinity -Infinity NaN ]\n  }\n  {\n    name: 'String'\n    examples: [\n      'Hello,'\n      \"world!\"\n    ]\n  }\n  / Modified JSON types /\n  { name: 'Array' } / May contain documentation comments among elements. /\n  { name: 'Object' } / May contain documentation comments among elements. /\n  / Extensions /\n  {\n    name: 'RawString'\n    examples: [ r'.*.con' ]\n  }\n]\n``. YAML seems nice in many ways, but I see a few reasons why it would solve my needs:\n- Lack of stable implementation in OCaml (which is what I have to use at work), and too complicated to start yet another attempt at implementing it.\n- Handling of comments; I really care about the comments, and want to be able to write comment-preserving programs that operate on the \"representation graph\".\n- Presence of aliases also makes transforms more difficult to express; when a line is added to thebill-toaddress, what happens to theship-to` address?\nI guess one reason there seems to be no mature YAML implementation in OCaml is the complexity of the specification.  JSON is the opposite, and it simplicity really makes it a very useful format.  There are many inspiring ideas in YAML, but if I end up pursuing the CON format, I'll have to strike the right balance so that the burden of implementing the specification becomes more on par with JSON than YAML.. ",
    "lifuzu": "@aseemk Thanks for the quick feedback. I totally understand what you are wary of.\nActually, the reason why I put function as a value into JSON is not to execute the code (yes, I will have another engine to take care of that part), just extract the code as a string. With this way we exactly use JSON as a data exchange carrier. In fact, without function we could use string to pass the function, but not human friendly.\nFor JS runtime problem, I think JS (function as the first class citizen, ref: http://ryanchristiani.com/functions-as-first-class-citizens-in-javascript/) is a great language for learning and using for all kinds of work. Some platforms have their JS interpreter (https://github.com/robertkrimen/otto, for go language). Besides, since function is not a mandatory, any other platforms could ignore if they don't want to have.\nI am trying to combine the feature together with the best flavor of JSON I think so far. If it is not really fit for the initial design principle, I will have another repo to maintain the feature. And again I will continue to contribute something here once I have. :-). @aseemk Thanks for the quick feedback. I totally understand what you are wary of.\nActually, the reason why I put function as a value into JSON is not to execute the code (yes, I will have another engine to take care of that part), just extract the code as a string. With this way we exactly use JSON as a data exchange carrier. In fact, without function we could use string to pass the function, but not human friendly.\nFor JS runtime problem, I think JS (function as the first class citizen, ref: http://ryanchristiani.com/functions-as-first-class-citizens-in-javascript/) is a great language for learning and using for all kinds of work. Some platforms have their JS interpreter (https://github.com/robertkrimen/otto, for go language). Besides, since function is not a mandatory, any other platforms could ignore if they don't want to have.\nI am trying to combine the feature together with the best flavor of JSON I think so far. If it is not really fit for the initial design principle, I will have another repo to maintain the feature. And again I will continue to contribute something here once I have. :-). ",
    "d3x0r": "Yes, I'm pretty sure that's where the improvement was.  The initial port of C code was string comparisons and it was about half the speed it is now.. Yes, I'm pretty sure that's where the improvement was.  The initial port of C code was string comparisons and it was about half the speed it is now.. "
}