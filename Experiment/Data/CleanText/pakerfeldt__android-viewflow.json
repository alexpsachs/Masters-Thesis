{
    "pakerfeldt": "Thanks for the report. I know that orientation messes things up. Will have a look at it, or if somebody else have a fix, feel free to send me a pull request.\n. Alright, so there is something odd with the main.xml layout in the example. The buttons are only for convenience though and shouldn't effect the actual library. \nWhat if you flip orientation? \n. Yes, thanks for the report. I will try to have this fixed in the future.\nThe crash experience is interesting as well. If you ever manage to reproduce the FC, please report it. I'm very keen on making the library stable.\n. Closing this since I've just merged the pull request from Eric that introduces a new kind of nice flow indicator. \n. Thanks for the contribution, it looks really nice. The issue with the LinearLayout was probably due to the temporary method logBuffer I've been using.\nWhy don't you think an adapter is suitable? It's capable of just that, returning different views for different items in the adapter. That's how ListView does it.\nI will have a look at the \"sideBuffer\" issue with your new widget and see if I can get it to work. Then I'll pull your request into the master.\n. This ViewFlow was actually written for just that purpose; to show result from a backend dynamically. But I can see your use case as well which we should support easily.\n. Cool. I will have a look at it this weekend.\n. Looks awsome! I did some minor changes, like resizing the images. Anywho, it's merged in. Nice work!\n. First of all, I do appreciate every contribution I receive, so kudos for that.\nBut I don't quite get what problem you solve with this patch? I tried it out but I can't see any difference at all. Could you please elaborate on the problem you are trying to solve.\n. Oh I see now. But I guess Layout Gravity should be used instead of defining a new attribute for that style. Although I'm not sure how to read the layout gravity attribute parameter. Do you?\n. Just caring about horizontal is fine for now. But I believe we should stick to the gravity attribute. I'll try to see if I can get the gravity attribute programmatically some how.\n. This is done just as we would do with other views like TextView. That is, setting the width to wrap_content on the CircleFlowIndicator, and gravity to center_horizontal on the encapsulating layout.\n. I suppose you are talking about attributes like our sidebuffer and the need of defining the namespace like xmlns:app=\"http://schemas.android.com/apk/res/your.application.package.here\" in your layout XML. AFAIK, this is the standard (and only) way of consuming custom XML attributes in Android. Please comment this issue if you believe it could be done elsewise and I'll have it re-opened.\n. I actually don't think that the xmlns:app thingy is all that bad. And after all, we could add the feature of setting the sidebuffer programmatically as well, just to give an alternative way of defining a side buffer. Would that be satisfying you think?\n. You could very well publish a re-usable code snippet by simply leave out the sidebuffer attribute, thus getting rid of the app specific namespace. It would get a default sidebuffer value assigned to it though, but still, it would be perfectly re-usable without any change needed.\n. The @Override issue suggests that you are running an old version of the Java compiler. Make sure you use Java 1.6 by going into project settings and look for Java Compiler. That will probably resolve your second issue as well.\n. Are you using the latest version? I'm pretty sure I solved this precise\nissue in the latest commit.\nOn Jun 24, 2011 4:51 PM, \"jspeth\" \nreply@reply.github.com\nwrote:\n\nIf you call setSelection() with something other than 0 before the first\nmeasure pass has been performed, the ViewFlow will display the wrong view.\nFor instance, we call setSelection in our activities onCreate to take you\nto one of the middle items.  The displayed view will be sidebuffer views to\nthe left of the one you expect, for whatever value you have for sidebuffer.\nI've been able to get it to work correctly by changing line 165 from:\n   scrollTo(mCurrentScreen * width, 0);\nto:\n   mScroller.startScroll(0, 0, mCurrentScreen * width, 0, 0);\nBut I'm not sure exactly why that works, or why the scrollTo isn't working\nin the first place.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/9\n. Okay, Ill look into it. Unfortunately not until sunday. Thanks for the\nreport.\nOn Jun 24, 2011 5:18 PM, \"jspeth\" \nreply@reply.github.com\nwrote:\nYes, it's the latest version. Try adding\nviewFlow.setSelection(3);\nright after setting the adapter in CircleViewFlowExample.java to see it.\nIt shows the first view, since sidebuffer is set to 3. If you change\nsidebuffer to 1 then it shows view 2.\nThanks, by the way. This view is really useful.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/9#issuecomment-1432991\n. Thanks!\n. You might want to run DDMS to check heap usage. \nIf you have a buffer of 1 then at most three views should be loaded at a time. So, what happens if you decrease the number of png's to 3 instead of 20. Still causing the OutOfMemoryError? If not, it seems like a bug in the viewflow library.\n. No worries!\n. Perhaps you might find this an interesting read: http://android-developers.blogspot.com/2010/06/making-sense-of-multitouch.html\nI don't believe that the viewflow library in any particular way, instead you should add a View to the viewflow which supports what you're asking for.\n. I'm afraid that's not planned. The right thing to do would be to implement this in the View itself I believe.\n. I'm guessing the difference between a list view and the scrollable view of yours is that the list view consumes the touch event when the user has scrolled enough on the Y-axis, but with your scrollable view that event is never consumed so the ViewFlow consumes it whenever you happen to pass the mTouchSlop value on the X-axis. \n\nCan you try implementing onTouchEvent and make sure the event is consumed as soon as you believe the user is scrolling vertically?\nI don't believe setting the mTouchSlop is the right way to go.\n. I would love a solution where the user of this library didn't have to think about anything when it comes to scrolling. I just don't know how that would be possible. But it might very well be, if so I need to be pointed in the right direction. Just changing mTouchSlop doesn't seem like a long-lasting solution. \nI'm not entirely sure what you mean by \"a motion controller\" but \"all you have to do\" is to implement the onTouchEvent in your ScrollView and make sure the event is consumed when the user scrolls vertically. I don't have time to test this myself at this very moment, but if you're unable to find a suitable solution for you I might try this out later. You could perhaps look at the source code for the ListView. Then again, if there is an ultimate solution for this problem on the viewflow end I would definitely implement it, I just need to know how.\n. I get what you're after. I wonder how the list view handles this issue. Can you have a horizontal scroll view inside a list view item? If you would like to write such utility I will pull it. Otherwise, I'll dig into this issue as soon as I get some time.\n. I'm not against the idea. But I was hoping for a solution where it wasn't needed at all. You can't change the sensitivity on a list view, right? But I guess it's best if we added such attribute to solve this issue.\n. I may very well add a jar file for people to download but I cannot guarantee that it's always up to date. Creating a new jar file for every commit adds quite some overhead. Would that be acceptable?\n. I didn't mean overhead as in space but as in time (exporting jar file from eclipse, uploading to github).\n. Try it out!\n. Thanks for pointing this out! The onConfigurationChanged method is needed for proper handling of orientation changes. As now mentioned in the README, you need to forward this call from your Activity yourself if you plan on supporting an API level < 8. Please see Caveats in README and CircleViewFlowExample for more detail.\n. Hmm, I don't quite get that error. Which file are you talking about, attrs.xml? Can't see any second comment opening.\n. Oh, my mistake. I hadn't commited everything. Pushing it to the repository as we speak.\n. Thank you!\n. That piece of code is a remnant from the RealViewSwitcher which viewflow is based on. Not sure whether it's required or not but I suppose it's not. From what I can see, it is not really recommended to extend AbsSpinner but we could very well re-write our onMeasure method with inspiration from the AbsSpinner.\n. Perfect. Would it be possible for you to just commit the TitleFlowIndicator.java and attrs.xml? I rather include an example of your padding in the already existing TitleFlowIndicatorExample (instead of creating a new activity).\n. I still depend on your first commit for changes made in TitleFlowIndicator.java, though. I'm no git pro so I don't know if it's possible to cherry pick certain files from a commit.\nI see two alternatives. \n1. I merge your changes manually (it's not that much) but that would erase commit history and put my name on your contribution, or \n2. You do a fresh new pull request with all changes necessary only to TitleFlowIndicator.java, attrs.xml (and possibly title_layout.xml in order to add the clipPadding attribute), and I pull in that one instead. That would keep your name in the commit history.\nWhat do you prefer?\n. Thank you!\n. The README fix was already made by myself but I missed to push the changes.\n. I'm not entirely sure what you're after. Do you want to be able scroll horizontally both in ViewFlow and in Gallery? That is not considered good practice and would probably confuse the user. \nOn a technical level, the ViewFlow will get the touch event before the gallery, and since ViewFlow supports horizontal scrolling it will consume the event.\n. I was actually wrong, the gallery view will get the touch event before the ViewFlow but for some reason it does not consume it. This indicates that ViewFlow identifies the horizontal action earlier than gallery. It could possibly be fixed by increasing the distance needed to travel on the screen before ViewFlow consumes the event. \nYou could try to increase the value of mTouchSlop in ViewFlow.java and see if that changes things. We currently get the distance needed to travel by reading from ViewConfiguration. I would guess the gallery widget would do the same but apparently ViewFlow consumes the event before.\nIssue #14 is quite similar.\n. Good point with dimension. I believe I have corrected that issue now. As for the other feature request, please file a new separate issue. I will close this one now.\n. Seems like you haven't told your circle flow indicator about your viewflow instance.\nMake sure you call setViewFlow(...) with your viewflowindic.\n. You should have a look at the Compatibility Library and more specifically ViewPager which is pretty much ViewFlow but with Fragments instead.\nhttp://developer.android.com/sdk/compatibility-library.html\n. I'm afraid that hasn't been tried. You could possibly copy the title flow indicator and adjust it to the ViewPager.\n. I have had very limited time to spend on ViewFlow lately (due to vacation) but I will look at your changes as soon as I can.\n. Sounds good. I've looked at your code but haven't tried it yet. In your gist you seem to be using an old version of the sources. Could you do a pull of the master repository and either send me another gist or even better, send me a pull request (if you are familiar with that, a gist is fine otherwise)?\n. Closing this issue since Jake already made the awesome indicator-only library (based on your work):\nhttps://github.com/JakeWharton/Android-ViewPagerIndicator\n. I tried the TitleFlowIndicator with a very long title and even though it doesn't really fit anymore it only seems to disappear when shown on the left side of the title view. Anyway, I don't believe that the TitleFlowIndicator should be responsible for deciding what to do with the text (which is apparently to long). Instead I believe you should implement that kind of logic in your TitleProvider. Preferably you could crop the text if it's to long in the getTitle method in your TitleProvider implementation.\n. I don't experience this at all (running HEAD version of the master repository). Can you please make sure you've pulled the latest changes and check if the issue persists?\n. I was thinking of something similar myself the other day. I'll look into it.\n. You could keep a reference to the view you are (synchronously) returning in getView(), do whatever lazy loading you need and then call invalidate() on that view when needed. This is actually how I personally do it in another project using ViewFlow where we load images asynchronously.\nDoes that make sense?\n. Absolutely. As long as the data loaded is somewhat persistent. I would prefer if you could load resources found in this project, like reading these URLs for instance:\nhttps://github.com/pakerfeldt/android-viewflow/raw/master/viewflow-example/res/drawable/cupcake.jpg\nhttps://github.com/pakerfeldt/android-viewflow/raw/master/viewflow-example/res/drawable/donut.jpg\nhttps://github.com/pakerfeldt/android-viewflow/raw/master/viewflow-example/res/drawable/eclair.png\nhttps://github.com/pakerfeldt/android-viewflow/raw/master/viewflow-example/res/drawable/froyo.png\nhttps://github.com/pakerfeldt/android-viewflow/raw/master/viewflow-example/res/drawable/gingerbread.png\nhttps://github.com/pakerfeldt/android-viewflow/raw/master/viewflow-example/res/drawable/honeycomb.png\nhttps://github.com/pakerfeldt/android-viewflow/raw/master/viewflow-example/res/drawable/icecream.png\n. I'm on the go right now. Can give more details later. But you mainly want to\nfork my repository first.  Pull down your fork. Do your changes, commit and\npush to your fork. Then issue a pull request on github.\nOn Aug 16, 2011 4:37 PM, \"Voldemar123\" \nreply@reply.github.com\nwrote:\n\nOk, I try to commit my changes\nit is my first github experience - could advise me how to start work with\nproject ?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/32#issuecomment-1816795\n. Here are some links. \nForking on Github: http://help.github.com/fork-a-repo/\nSending pull requests: http://help.github.com/send-pull-requests/\n. Perfect, thanks!\n. I did a little change. Instead of defaulting to a SELECTED_TEXT_SIZE, it now defaults to whatever textsize will resolve to.\n. I can't see what the issue is about? Tried with several different line heights but it doesn't look weird to me.\n. Ah, perfect! I'll make sure your fix will get commited asap.\n. And what does the stack trace look like?\n. There seems to be a NullPointerException somewhere in your code when ViewFlow calls getView (in your adapter) for the particular view to show. I suggest you check TaskView at line 53 to see why the null pointer occurs.\n. convertView does not have to be null. You might very well be given an old view that you're supposed to use instead of inflating a new one. For an example of getView() and how convertView is used, see: \nhttps://github.com/pakerfeldt/android-viewflow/blob/master/viewflow-example/src/org/taptwo/android/widget/viewflow/example/AndroidVersionAdapter.java\n. If someone would like to give it a go, please do. I, personally, won't be able to add this feature in the near future.\n. I was primarily talking about adding more titles to the indicator. Having them clickable is probably more straight forward and there's already a separate issue for that: #28\n. No problem! I'll try it out later this evening, thanks!\n. Thanks! I look closer into your code later, but it seems to run just fine.\n. It doesn't really work as I would expect a multi title indicator to function. First of all, I guess we have to agree on how it would  work. From your example, when I start scrolling to the right, A moves to the left as expected, but it continues to move all the way to the left. Then when I release to make it snap to B, A is instantly moved to its \"expected\" position (i.e. to the left of the centered B). And at the same time, when B is to be scrolled to the left, it first, instantly moves to the far end from where the animation starts and continues to the middle.\n\nThis is how I would expect it to work: When I scroll to the right, the A (in the indicator) would move to the left but halt when it hits its new position. Continuing scrolling to the right and B, C and D (in the indicator) would eventually move to the left and halt when each title hits its position. And at the same time, E would move in from the far right.\n. I think your first example here aligns best with how the title flow indicator works today (as well as how they work in other examples, like Googles own implementation of this \"workspaces\" pattern).\n. I'm gonna close this issue. Please feel free to post another pull request if you solve it.\n. This is actually the first time I see an app making use of ViewFlow, cool!\nSo, if I get it right. Your ListViewFlow would know that it contains a ListView and be able to synchronize the current vertical position to the other ListViews?\nSounds interesting but I'm thinking of a more general solution. I guess it would be possible to somehow add a custom \"synchronizer\" to the ViewFlow that would synchronize the views in any way the user want. \nFirst of all, am I understanding your \"problem\" correctly?\n. I don't really have a use case at all, other than the one you gave me. I just thinking that handling ListViews directly seems to be a bit to specialized. It should be possible to do a bit of abstraction to the problem to handle ListView as well as other types of use cases in the future. But then again, if we can't come up with another use case, maybe we're over-doing it. Let me think of this case a bit.\n. Awesome work! I just did this slight change in default colors where they are the same regardless of the type (in order to keep it bit more simple). Updated javadoc and README as well.\n. That might make sense. But consider this scenario.\nYou have 10 elements in the adapter and side buffer is set to 1 and you're currently focusing on element 5. Hence, ViewFlow has loaded view 4, 5, 6. Then, let's assume setSelection(1) is called. That would result in the currently loaded views: 0, 1, 2, hence, the previously shown View 5 is not loaded any more. \nQuestion: What would be passed as previousView in the new onSwitched method?\nI am very tempted to answer null on that since the ViewFlow has removed the view from the buffer and should hold no reference to it. Passing a view that is expected to be freed from memory doesn't sound too good.\n. I have the fix almost done but need to close down for the evening. Hopefully I will push it tomorrow.\n. First of all, a previous view will never be passed if it was just removed.\nBut we still might have the case that a view is removed later on, if the user is storing a reference to the view or doing some asynchronous task. But this issue is applicable for the current view as well. Separating the interface into two callbacks won't solve that problem I think. We need to remember that ViewFlow is re-using old Views as well when appropriate. Therefore, modifying a View from a ViewSwitchListener asynchronously might have strange effects if ViewFlow is trying to re-use the View before the asynchronous task is complete.\nIf you have control over both the ViewSwitchListener and the Adapter you can avoid these situations by checking which View is being re-used when the getView(...) method is called in the Adapter. Better yet, if you can modify the View synchronously, this will never occur.\nI should probably clarify things in the Javadoc for the ViewSwitchListener.\n. Implementing this in postViewSwitched (which is called when the user swipes) is very straight-forward. But I just figured out, doing this in setSelection requires bigger changes. In setSelection I'm taking a shortcut and remove all views from the buffer, and then request to get a new view from the adapter for each element. Of course re-using the actual view objects, but still, if I would simply save the previous view in the beginning of setSelection, that view would no longer correspond to the previous view as it has been re-used by another (arbitrary) element.\nI certainly need to re-do setSelection anyway because it is very sub-optimal. Especially if someone uses setSelection to just go back and forth one view at a time, as setSelection will ask the adapter for all views and not really make use of the buffer.\n. I did the merge directly on github.It was not my intention to remove anything.\n. Theoretically, I guess you could extend ScrollView and make sure vertical movements are consumed first when you hit a certain threshold value. It has been suggested that android-viewflow provides such wrapper class but unfortunately it doesn't yet.\n. Could you pull the intercepttouch branch and try it out? Not sure I did it right, but requestDisallowInterceptTouchEvent seems like a good solution.\nhttps://github.com/pakerfeldt/android-viewflow/tree/intercepttouch\n. Cool! Thanks for the contribution. Could you please try your code on the latest changes of ViewFlow? I have just merged some changes from chripo that might interfere with your work.\n. Hmm. So I have two options here. Revert to the old version and go with your patch or try to solve this issue myself. I want to at least have a look at it and see if I can fix it first. Because I really like the contribution chripo sent with better handling of recycled views. You are, of course, able to look into this yourself as well if you want to.\n. See recent post from svtdragon in this thread.\n. Okay, so here's a shot at supporting different view types. It's based on AbsListView and therefore very similar to @svtdragon 's approach. Much of the code in RecycleBin class is copy/paste from AbsListView.\nThis is the commit on the new recyclebin branch (not on master):\nhttps://github.com/pakerfeldt/android-viewflow/commit/3eaef478e898a712cc2edcd87786c17206107533\nI would be happy if you could review this. I have just run a very simple smoke test yet.\n. You have some sort of background service changing the layout of the list view? I'm trying to figure out how to re-produce this issue. Would it be possible for you to alter the \"Different views\" layout in viewflow-example and have it re-produce your problem?\n. Yes, that's a known issue that setSelection causes every view in the buffer to be re-fetched from the adapter. Still they are \"re-cycled\" in the sense that old views are passed to the getView method in your adapter (hence you don't need to inflate the view). But you still have to populate the view with data, yes.\n. So, is there still some kind of outstanding issue or did you resolve it in your adapter?\n. Cool!\n. setSelection should be optimized a bit. It re-creates all views in the buffer when called. Larger buffer, more views to populate for your adapter. Is the UI unaccessible during this time?\n. That's not the only use case. Consider a use case where you have an unknown number of elements in the adapter. A number that may grow over time as you flow through the view. Also, consider the use case where each view loads a resource over the internet. You typically don't want to load all those resources if not necessary.\n. If someone points me to a working solution I'll pull it off.\n. Not at the moment. Are you talking about custom fonts as in fonts you provide with your application or as those provided by the system?\n. Nevermind, I implemented both in https://github.com/pakerfeldt/android-viewflow/commit/6befb6b80447774ec8a9dcb90a2b38b02c4919c0\nEither use android:typeface (and optionally android:textStyle) or if you provide your own font use app:customTypeface. Set it to the path of your font relative assets, e.g. fonts/Antic.ttf. See viewflow-example.\n. Did you solve it in a similar fashion?\n. okay, cool.\n. Use setAdapter(myAdapter, 1); instead.\n. If by that you mean that each of the views in the viewflow contains a listview, yes that's possible.\n. Sorry, but I can't give you that kind of support. I simply don't have the time. You should look in the viewflow-examples folder for getting started help.\n. Just as you have an ArrayAdapter for your listview you need an Adapter for the viewflow. This adapter implements getView(...) and here you need to inflate your listview and populate it with another adapter (like the one you just wrote).\nIf you get a listview for the first view only, you need to have a look at the adapter implementation and the getView(...) method. For each position you need to return a valid view (a listview in your case).\n. What you ask for is simply elementary knowledge of the Android platform. This tutorial might help you: http://www.vogella.de/articles/AndroidListView/article.html\n. I'm sorry to hear that you get upset. But you have to accept the fact that I don't have time to give you the complete example you ask for. Especially when there's already a lot of very god tutorials which, together with the examples in android-viewflow should be enough to understand how to create a viewflow with multiple list views.\n. Can you set a breakpoint at TitleFlowIndicator.java:308 and check that title isn't null? \n. Thank you.\n. Thanks!\n. Have you looked at the examples? The circle flow example uses wrap_content and shows up as expected.\nMake sure there is nothing else in your layout that is causing this behaviour.\n. It has most likely nothing to do what's inside your viewflow but rather how the parent layout looks like. The layout that contains the indicator and the viewflow. In the example, they both live in a FrameLayout. Which might not really be the way you want. Try adding them to a vertical oriented LinearLayout instead. But it's hard to give any advice without having a look at the layout xml.\n. Are you using Eclipse? Try select the CircleFlowIndicator in the Layout Editor and show should see where it's located. If it has been pushed down, outside the screen by the ViewFlow. Try moving the indicator above the ViewFlow just to see what happens.\n. Just wanted to let you know that I appreciate the contributions. Haven't had the time to test them yet but I hopefully will soon.\n. Awesome! Thanks a lot!\n. You are right. That's just terrible. It will, of course, never work. \nTo answer your last question. Even though setSelection causes a complete redraw, that is more considered a bad side effect. I simply didn't have the time to write setSelection in a way that it does not cause a complete redraw. If possible, we shouldn't rely on that side effect since it might get \"fixed\" later on. But it might be the easy way out here.\nIn your fix, what happens if mAdapter does not have stable ids?\n. A ViewFlow is always backed up by an Adapter and what you want to do is to simply add/remove items to/from this Adapter.\n. Unfortunately I don't have the time to maintain this library any longer. Especially not since we have the ViewPager in the compatibility library which in most cases is a much better fit than android-viewflow.\n. Thanks for the improvements!\n. Thanks\n. ",
    "tilusnet": "Screenshot:\nhttp://tilusnet.com/tmp/gfx/viewflow-example-notallseen.png\n. True, it's not related to the library, I just thought I let you know. (although the app crashed the first time I flicked beyond number 9, but never since)\nIn landscape orientation there's enough space for all buttons.\n. ",
    "eric-taix": "Hi,\nYes the issue was with the logBuffer method.\nI know that adapter is capable of returning different views. But most of\ntime we use adapter to return different instance of the same view. If your\nadapter need to return different view type, you have to override\n\"getItemViewType\" and \"getViewTypeCount\" (it allows Android to give you the\ngood convertView instance)\nabstract intgetItemViewTypehttp://developer.android.com/reference/android/widget/Adapter.html#getItemViewType(int)(int\nposition)\nGet the type of View that will be created by getView(int, View,\nViewGroup)http://developer.android.com/reference/android/widget/Adapter.html#getView(int,\nandroid.view.View, android.view.ViewGroup) for the specified item.\nabstract Viewhttp://developer.android.com/reference/android/view/View.html\ngetViewhttp://developer.android.com/reference/android/widget/Adapter.html#getView(int,\nandroid.view.View, android.view.ViewGroup)(int position,\nViewhttp://developer.android.com/reference/android/view/View.html\n convertView, ViewGrouphttp://developer.android.com/reference/android/view/ViewGroup.html\n parent)\nGet a View that displays the data at the specified position in the data set.\nabstract intgetViewTypeCounthttp://developer.android.com/reference/android/widget/Adapter.html#getViewTypeCount()\n()\nReturns the number of types of Views that will be created by getView(int,\nView, ViewGroup)http://developer.android.com/reference/android/widget/Adapter.html#getView(int,\nandroid.view.View, android.view.ViewGroup).\nWell, it's not very difficult and your adapter is a very good solution\nespecially if the views number is dynamic (a backend result for example).\nBut if a user just want to add 3 static views inflated from XML files, I\nthink it's much easier to use something like that:\nmyViewFlow.addView(myFirstView);\nmyViewFlow.addView(mySecondView);\nmyViewFlow.addView(myThirdView);\nWhile I'm writing this email, I'm thinking that it could be a good idea to\nimplement a default adapter where we can add views. If I have time, I'll try\nsomething and I'll send you a pull request.\nEric\n. ",
    "BenoitDuffez": "That looks really bad. Since the code addition is very small, you'll be able to figure out what to add, if you want to keep my modifications.\nNext time I'll post something cleaner! Sorry.\n. You're welcome. I should be thanking you for the work you've done.\nIn fact I just :\n- added a boolean in the CircleFlowIndicator styleable called \"centered\"\n- I got the value of it in CircleFlowIndicator constructor: isCentered = a.getBoolean(R.styleable.CircleFlowIndicator_centered, false);\n- added this in the onDraw method :\nfloat offset;\n        if (isCentered) {\n            offset = getWidth() - 3*radius*count;\n            offset = Math.max(0, offset/2);\n        } else {\n            offset = getPaddingLeft();\n        }\nThis code is used in the canvas.drawCircle as the x coordinate as follows:\n```\n    // Draw stroked circles\n    for (int iLoop = 0; iLoop < count; iLoop++) {\n        canvas.drawCircle(offset + radius\n                + (iLoop * (2 * radius + radius)),\n                getPaddingTop() + radius, radius, mPaintStroke);\n    }\n    int cx = 0;\n    if (flowWidth != 0) {\n        // Draw the filled circle according to the current scroll\n        cx = (currentScroll * (2 * radius + radius)) / flowWidth;\n    }\n    // The flow width has been upadated yet. Draw the default position\n    canvas.drawCircle(offset + radius + cx,\n                getPaddingTop() + radius, radius, mPaintFill);\n\n```\nThe result is that if the boolean centered is set to true, the circles will be centered in the CircleFlowIndicator view. So if the layout_width of that view is fill_parent and fills the whole screen for example, the circles will be centered in the screen width. That provides a nicer display.\n. I don't know how to read it. I tried gravity, it doesn't work of course.\nI guess it would be something like: a.getInteger(android.R.styleable.gravity, 0) or something...\nAnd my code only handles the horizontal gravity, I guess it could be easy to tune it to manage vertical aswell, and a combination of the two in order to make all the gravities handled.\n. ",
    "jcogilvie": "I would like to be able to set the layout width to match_parent, because my adapter has a set of data whose size changes and I'd like to not have to re-layout (to add more width to the flow indicator) every time my adapter is updated.  \nI believe that the appropriate way to do this is to respect the android:gravity attribute, which declares how the contents within the view will be oriented with respect to the view.  You suggestion above to wrap_content and use layout_gravity is not exactly how these attributes were meant to be used.  (This shrinks the layout around the flow indicator and centers the indicator within the parent view, as opposed to centering the circles within the indicator.)\n. Another +1.\n. Fixed this, but using an HG repo on bitbucket, and not git.  \nTherefore, pasting my current version of the code.  Summary of changes below it.  \n``` /\n * Copyright (C) 2011 Patrik Akerfeldt\n * As adapted by Jonathan Ogilvie\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n \n *      http://www.apache.org/licenses/LICENSE-2.0\n \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n /\npackage org.taptwo.android.widget;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.eoti.fetlife.ui.WorkspaceView.SavedState;\nimport org.taptwo.android.widget.viewflow.R;\nimport android.content.Context;\nimport android.content.res.Configuration;\nimport android.content.res.TypedArray;\nimport android.database.DataSetObserver;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.VelocityTracker;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.View.BaseSavedState;\nimport android.view.ViewTreeObserver.OnGlobalLayoutListener;\nimport android.widget.AbsListView;\nimport android.widget.Adapter;\nimport android.widget.AdapterView;\nimport android.widget.Scroller;\n/*\n * A horizontally scrollable {@link ViewGroup} with items populated from an\n * {@link Adapter}. The ViewFlow uses a buffer to store loaded {@link View}s in.\n * The default size of the buffer is 3 elements on both sides of the currently\n * visible {@link View}, making up a total buffer size of 3 * 2 + 1 = 7. The\n * buffer size can be changed using the {@code sidebuffer} xml attribute.\n * \n /\npublic class ViewFlow extends AdapterView {\nprivate static final int SNAP_VELOCITY = 1000;\nprivate static final int INVALID_SCREEN = -1;\nprivate final static int TOUCH_STATE_REST = 0;\nprivate final static int TOUCH_STATE_SCROLLING = 1;\n\nprivate LinkedList<View> mLoadedViews;\nprivate int mCurrentBufferIndex;\nprivate int mCurrentAdapterIndex;\nprivate int mSideBuffer = 2;\nprivate Scroller mScroller;\nprivate VelocityTracker mVelocityTracker;\nprivate int mTouchState = TOUCH_STATE_REST;\nprivate float mLastMotionX;\nprivate int mTouchSlop;\nprivate int mMaximumVelocity;\nprivate int mCurrentScreen;\nprivate int mNextScreen = INVALID_SCREEN;\nprivate boolean mFirstLayout = true;\nprivate ViewSwitchListener mViewSwitchListener;\nprivate Adapter mAdapter;\nprivate int mLastScrollDirection;\nprivate AdapterDataSetObserver mDataSetObserver;\nprivate FlowIndicator mIndicator;\nprivate int mLastOrientation = -1;\nprivate int numVisibleViews = 1;\n\nprivate OnGlobalLayoutListener orientationChangeListener = new OnGlobalLayoutListener() {\n\n    @Override\n    public void onGlobalLayout() {\n        getViewTreeObserver().removeGlobalOnLayoutListener(\n                orientationChangeListener);\n        setSelection(mCurrentAdapterIndex);\n    }\n};\nprivate int mNumberOfViewTypes;\nprivate ArrayList<View>[] mRecycledViews;\n\n/**\n * Receives call backs when a new {@link View} has been scrolled to.\n */\npublic static interface ViewSwitchListener {\n\n    /**\n     * This method is called when a new View has been scrolled to.\n     * \n     * @param view\n     *            the {@link View} currently in focus.\n     * @param position\n     *            The position in the adapter of the {@link View} currently in focus.\n     * @param direction \n     */\n    void onSwitched(View view, int position, int direction);\n\n}\n\npublic ViewFlow(Context context) {\n    super(context);\n    mSideBuffer = 3;\n    init();\n}\n\npublic ViewFlow(Context context, int sideBuffer) {\n    super(context);\n    mSideBuffer = sideBuffer;\n    init();\n}\n\npublic ViewFlow(Context context, AttributeSet attrs) {\n    super(context, attrs);\n    TypedArray styledAttrs = context.obtainStyledAttributes(attrs,\n            R.styleable.ViewFlow);\n    mSideBuffer = styledAttrs.getInt(R.styleable.ViewFlow_sidebuffer, 3);\n    init();\n}\n\nprivate void init() {\n    mLoadedViews = new LinkedList<View>();\n    mScroller = new Scroller(getContext());\n    final ViewConfiguration configuration = ViewConfiguration\n            .get(getContext());\n    mTouchSlop = configuration.getScaledTouchSlop();\n    mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();\n}\n\npublic void onConfigurationChanged(Configuration newConfig) {\n    if (newConfig.orientation != mLastOrientation) {\n        mLastOrientation = newConfig.orientation;\n        getViewTreeObserver().addOnGlobalLayoutListener(orientationChangeListener);\n    }\n}\n\npublic int getViewsCount() {\n    if(mAdapter != null){\n        return mAdapter.getCount();\n    } else {\n        return 1;\n    }\n}\n\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n    final int width = MeasureSpec.getSize(widthMeasureSpec);\n    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n    if (widthMode != MeasureSpec.EXACTLY && !isInEditMode()) {\n        throw new IllegalStateException(\n                \"ViewFlow can only be used in EXACTLY mode.\");\n    }\n\n    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n    if (heightMode != MeasureSpec.EXACTLY && !isInEditMode()) {\n        throw new IllegalStateException(\n                \"ViewFlow can only be used in EXACTLY mode.\");\n    }\n\n    // The children are given the same width and height as the workspace\n    final int count = getChildCount();\n    for (int i = 0; i < count; i++) {\n        getChildAt(i).measure(widthMeasureSpec, heightMeasureSpec);\n    }\n\n    if (mFirstLayout) {\n        mScroller.startScroll(0, 0, mCurrentScreen * width, 0, 0);\n        mFirstLayout = false;\n    }\n}\n\n@Override\nprotected void onLayout(boolean changed, int l, int t, int r, int b) {\n    int childLeft = 0;\n\n    final int count = getChildCount();\n    for (int i = 0; i < count; i++) {\n        final View child = getChildAt(i);\n        if (child.getVisibility() != View.GONE) {\n            final int childWidth = child.getMeasuredWidth();\n            child.layout(childLeft, 0, childLeft + childWidth,\n                    child.getMeasuredHeight());\n            childLeft += childWidth;\n        }\n    }\n}\n\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\n    if (getChildCount() == 0)\n        return false;\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    final int action = ev.getAction();\n    final float x = ev.getX();\n\n    switch (action) {\n    case MotionEvent.ACTION_DOWN:\n        /*\n         * If being flinged and user touches, stop the fling. isFinished\n         * will be false if being flinged.\n         */\n        if (!mScroller.isFinished()) {\n            mScroller.abortAnimation();\n        }\n\n        // Remember where the motion event started\n        mLastMotionX = x;\n\n        mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST\n                : TOUCH_STATE_SCROLLING;\n\n        break;\n\n    case MotionEvent.ACTION_MOVE:\n        final int xDiff = (int) Math.abs(x - mLastMotionX);\n\n        boolean xMoved = xDiff > mTouchSlop;\n\n        if (xMoved) {\n            // Scroll if the user moved far enough along the X axis\n            mTouchState = TOUCH_STATE_SCROLLING;\n        }\n\n        if (mTouchState == TOUCH_STATE_SCROLLING) {\n            // Scroll to follow the motion event\n            final int deltaX = (int) (mLastMotionX - x);\n            mLastMotionX = x;\n\n            final int scrollX = getScrollX();\n            if (deltaX < 0) {\n                if (scrollX > 0) {\n                    scrollBy(Math.max(-scrollX, deltaX), 0);\n                }\n            } else if (deltaX > 0) {\n                final int availableToScroll = getChildAt(\n                        getChildCount() - 1).getRight()\n                        - scrollX - getWidth();\n                if (availableToScroll > 0) {\n                    scrollBy(Math.min(availableToScroll, deltaX), 0);\n                }\n            }\n            return true;\n        }\n        break;\n\n    case MotionEvent.ACTION_UP:\n        if (mTouchState == TOUCH_STATE_SCROLLING) {\n            final VelocityTracker velocityTracker = mVelocityTracker;\n            velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n            int velocityX = (int) velocityTracker.getXVelocity();\n\n            if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) {\n                // Fling hard enough to move left\n                snapToScreen(mCurrentScreen - 1);\n            } else if (velocityX < -SNAP_VELOCITY\n                    && mCurrentScreen < getChildCount() - 1) {\n                // Fling hard enough to move right\n                snapToScreen(mCurrentScreen + 1);\n            } else {\n                snapToDestination();\n            }\n\n            if (mVelocityTracker != null) {\n                mVelocityTracker.recycle();\n                mVelocityTracker = null;\n            }\n        }\n\n        mTouchState = TOUCH_STATE_REST;\n\n        break;\n    case MotionEvent.ACTION_CANCEL:\n        mTouchState = TOUCH_STATE_REST;\n    }\n    return false;\n}\n\n@Override\npublic boolean onTouchEvent(MotionEvent ev) {\n    if (getChildCount() == 0)\n        return false;\n\n    if (mVelocityTracker == null) {\n        mVelocityTracker = VelocityTracker.obtain();\n    }\n    mVelocityTracker.addMovement(ev);\n\n    final int action = ev.getAction();\n    final float x = ev.getX();\n\n    switch (action) {\n    case MotionEvent.ACTION_DOWN:\n        /*\n         * If being flinged and user touches, stop the fling. isFinished\n         * will be false if being flinged.\n         */\n        if (!mScroller.isFinished()) {\n            mScroller.abortAnimation();\n        }\n\n        // Remember where the motion event started\n        mLastMotionX = x;\n\n        mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST\n                : TOUCH_STATE_SCROLLING;\n\n        break;\n\n    case MotionEvent.ACTION_MOVE:\n        final int xDiff = (int) Math.abs(x - mLastMotionX);\n\n        boolean xMoved = xDiff > mTouchSlop;\n\n        if (xMoved) {\n            // Scroll if the user moved far enough along the X axis\n            mTouchState = TOUCH_STATE_SCROLLING;\n        }\n\n        if (mTouchState == TOUCH_STATE_SCROLLING) {\n            // Scroll to follow the motion event\n            final int deltaX = (int) (mLastMotionX - x);\n            mLastMotionX = x;\n\n            final int scrollX = getScrollX();\n            if (deltaX < 0) {\n                if (scrollX > 0) {\n                    scrollBy(Math.max(-scrollX, deltaX), 0);\n                }\n            } else if (deltaX > 0) {\n                final int availableToScroll = getChildAt(\n                        getChildCount() - 1).getRight()\n                        - scrollX - getWidth();\n                if (availableToScroll > 0) {\n                    scrollBy(Math.min(availableToScroll, deltaX), 0);\n                }\n            }\n            return true;\n        }\n        break;\n\n    case MotionEvent.ACTION_UP:\n        if (mTouchState == TOUCH_STATE_SCROLLING) {\n            final VelocityTracker velocityTracker = mVelocityTracker;\n            velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);\n            int velocityX = (int) velocityTracker.getXVelocity();\n\n            if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) {\n                // Fling hard enough to move left\n                snapToScreen(mCurrentScreen - 1);\n            } else if (velocityX < -SNAP_VELOCITY\n                    && mCurrentScreen < getChildCount() - 1) {\n                // Fling hard enough to move right\n                snapToScreen(mCurrentScreen + 1);\n            } else {\n                snapToDestination();\n            }\n\n            if (mVelocityTracker != null) {\n                mVelocityTracker.recycle();\n                mVelocityTracker = null;\n            }\n        }\n\n        mTouchState = TOUCH_STATE_REST;\n\n        break;\n    case MotionEvent.ACTION_CANCEL:\n        snapToDestination();\n        mTouchState = TOUCH_STATE_REST;\n    }\n    return true;\n}\n\n@Override\nprotected void onScrollChanged(int h, int v, int oldh, int oldv) {\n    super.onScrollChanged(h, v, oldh, oldv);\n    if (mIndicator != null) {\n        /*\n         * The actual horizontal scroll origin does typically not match the\n         * perceived one. Therefore, we need to calculate the perceived\n         * horizontal scroll origin here, since we use a view buffer.\n         */\n        int hPerceived = h + (mCurrentAdapterIndex - mCurrentBufferIndex)\n                * getWidth();\n        mIndicator.onScrolled(hPerceived, v, oldh, oldv);\n    }\n}\n\nprivate void snapToDestination() {\n    final int screenWidth = getWidth();\n    final int whichScreen = (getScrollX() + (screenWidth / 2))\n            / screenWidth;\n\n    snapToScreen(whichScreen);\n}\n\nprivate void snapToScreen(int whichScreen) {\n    mLastScrollDirection = whichScreen - mCurrentScreen;\n    if (!mScroller.isFinished())\n        return;\n\n    whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));\n\n    mNextScreen = whichScreen;\n\n    final int newX = whichScreen * getWidth();\n    final int delta = newX - getScrollX();\n    mScroller.startScroll(getScrollX(), 0, delta, 0, Math.abs(delta) * 2);\n    invalidate();\n}\n\n@Override\npublic void computeScroll() {\n    if (mScroller.computeScrollOffset()) {\n        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n        postInvalidate();\n    } else if (mNextScreen != INVALID_SCREEN) {\n        mCurrentScreen = Math.max(0,\n                Math.min(mNextScreen, getChildCount() - 1));\n        mNextScreen = INVALID_SCREEN;\n        postViewSwitched(mLastScrollDirection);\n    }\n}\n\n/**\n * Scroll to the {@link View} in the view buffer specified by the index.\n * \n * @param indexInBuffer\n *            Index of the view in the view buffer.\n */\nprivate void setVisibleView(int indexInBuffer, boolean uiThread) {\n    mCurrentScreen = Math.max(0,\n            Math.min(indexInBuffer, getChildCount() - 1));\n    int dx = (mCurrentScreen * getWidth()) - mScroller.getCurrX();\n    mScroller.startScroll(mScroller.getCurrX(), mScroller.getCurrY(), dx,\n            0, 0);\n    if(dx == 0)\n        onScrollChanged(mScroller.getCurrX() + dx, mScroller.getCurrY(), mScroller.getCurrX() + dx, mScroller.getCurrY());\n    if (uiThread)\n        invalidate();\n    else\n        postInvalidate();\n}\n\n/**\n * Set the listener that will receive notifications every time the {code\n * ViewFlow} scrolls.\n * \n * @param l\n *            the scroll listener\n */\npublic void setOnViewSwitchListener(ViewSwitchListener l) {\n    mViewSwitchListener = l;\n}\n\n@Override\npublic Adapter getAdapter() {\n    return mAdapter;\n}\n\n@Override\npublic void setAdapter(Adapter adapter) {\n    setAdapter(adapter, 0);\n}\n\n@SuppressWarnings(\"unchecked\")\npublic void setAdapter(Adapter adapter, int initialPosition) {\n    if (mAdapter != null) {\n        mAdapter.unregisterDataSetObserver(mDataSetObserver);\n\n        for(ArrayList<View> views : mRecycledViews){\n            for(View v : views){\n                removeDetachedView(v, false);\n            }\n        }           \n    }\n\n    mAdapter = adapter;\n\n    if (mAdapter != null) {\n        mDataSetObserver = new AdapterDataSetObserver();\n        mAdapter.registerDataSetObserver(mDataSetObserver);\n        mNumberOfViewTypes = mAdapter.getViewTypeCount();\n    }\n\n    mRecycledViews = new ArrayList[mNumberOfViewTypes];\n    for (int i = 0; i < mNumberOfViewTypes; i++) {\n        mRecycledViews[i] = new ArrayList<View>();\n    }\n\n    if (mAdapter == null || mAdapter.getCount() == 0)\n        return;\n\n    setSelection(initialPosition);      \n}\n\n@Override\npublic View getSelectedView() {\n    return (mCurrentBufferIndex < mLoadedViews.size() ? mLoadedViews\n            .get(mCurrentBufferIndex) : null);\n}\n\n@Override\npublic int getSelectedItemPosition() {\n    return mCurrentAdapterIndex;\n}\n\n/**\n * Set the FlowIndicator\n * \n * @param flowIndicator\n */\npublic void setFlowIndicator(FlowIndicator flowIndicator) {\n    mIndicator = flowIndicator;\n    mIndicator.setViewFlow(this);\n}\n\n@Override\npublic void setSelection(int position) {\n    mNextScreen = INVALID_SCREEN;\n    mScroller.forceFinished(true);\n    if (mAdapter == null)\n        return;\n\n    position = Math.max(position, 0);\n    position =  Math.min(position, mAdapter.getCount()-1);\n\n    ArrayList<View> recycleViews = new ArrayList<View>();\n    View recycleView;\n    while (!mLoadedViews.isEmpty()) {\n        recycleViews.add(recycleView = mLoadedViews.remove());\n        detachViewFromParent(recycleView);\n        mRecycledViews[((ViewFlow.LayoutParams)recycleView.getLayoutParams()).viewType].add(recycleView);\n    }\n\n    View currentView = makeAndAddView(position, true);//,\n\n//              (recycleViews.isEmpty() ? null : recycleViews.remove(0)));\n        mLoadedViews.addLast(currentView);\n    for(int offset = 1; mSideBuffer - offset >= 0; offset++) {\n        int leftIndex = position - offset;\n        int rightIndex = position + offset;\n        if(leftIndex >= 0)\n            mLoadedViews.addFirst(makeAndAddView(leftIndex, false));//,\n\n//                      (recycleViews.isEmpty() ? null : recycleViews.remove(0))));\n            if(rightIndex < mAdapter.getCount())\n                mLoadedViews.addLast(makeAndAddView(rightIndex, true));//,\n//                      (recycleViews.isEmpty() ? null : recycleViews.remove(0))));\n        }\n    mCurrentBufferIndex = mLoadedViews.indexOf(currentView);\n    mCurrentAdapterIndex = position;\n\n    // TODO make sure we don't keep too many recycled views.\n\n//      for (View view : recycleViews) {\n//          removeDetachedView(view, false);\n//      }\n        pruneRecycledViews();\n        requestLayout();\n        setVisibleView(mCurrentBufferIndex, false);\n        if (mIndicator != null) {\n            mIndicator.onSwitched(mLoadedViews.get(mCurrentBufferIndex),\n                    mCurrentAdapterIndex,0);\n        }\n        if (mViewSwitchListener != null) {\n            mViewSwitchListener\n                    .onSwitched(mLoadedViews.get(mCurrentBufferIndex),\n                            mCurrentAdapterIndex,0);\n        }\n    }\n// For a full-screen (one item at a time) ViewFlow, we really only need\n// one view of any given type in reserve... but looking forward to expandability,\n// we're going to use # view types + 1 \n// TODO we should adjust this based on number of visible views\nprivate void pruneRecycledViews() {\n    for(ArrayList<View> views : mRecycledViews){\n        int numViews = views.size();\n        if(numViews > numVisibleViews){\n            for(int i=numViews-1; i > numVisibleViews; i--){\n                removeDetachedView(views.get(i),false);\n                views.remove(0);\n            }\n        }\n    }\n}\n\nprivate void resetFocus() {\n    logBuffer();\n    mLoadedViews.clear();\n    if(mRecycledViews != null){\n        for(ArrayList<View> views : mRecycledViews){\n            for(View v : views){\n                removeDetachedView(v, false);\n            }\n        }\n    }\n\n    removeAllViewsInLayout();\n\n    for (int i = Math.max(0, mCurrentAdapterIndex - mSideBuffer); i < Math\n            .min(mAdapter.getCount(), mCurrentAdapterIndex + mSideBuffer\n                    + 1); i++) {\n        mLoadedViews.addLast(makeAndAddView(i, true));//, null));\n        if (i == mCurrentAdapterIndex)\n            mCurrentBufferIndex = mLoadedViews.size() - 1;\n    }\n\n    if(mIndicator != null){\n        // force an invalidate on the flow indicator when the data set changes\n        mIndicator.setViewFlow(this);\n    }\n    logBuffer();\n    requestLayout();\n}\n\nprivate void postViewSwitched(int direction) {\n    if (direction == 0)\n        return;\n\n    if (direction > 0) { // to the right\n        mCurrentAdapterIndex++;\n        mCurrentBufferIndex++;\n\n//          View recycleView = null;\n        // Remove view outside buffer range\n        if (mCurrentAdapterIndex > mSideBuffer) {\n            recycleView(mLoadedViews.removeFirst());\n            // removeView(recycleView);\n            mCurrentBufferIndex--;\n        }\n\n        // Add new view to buffer\n        int newBufferIndex = mCurrentAdapterIndex + mSideBuffer;\n        if (newBufferIndex < mAdapter.getCount())\n            mLoadedViews.addLast(makeAndAddView(newBufferIndex, true));//,\n\n//                      recycleView));\n    } else { // to the left\n        mCurrentAdapterIndex--;\n        mCurrentBufferIndex--;\n\n//          View recycleView = null;\n        // Remove view outside buffer range\n        if (mAdapter.getCount() - 1 - mCurrentAdapterIndex > mSideBuffer) {\n            recycleView(mLoadedViews.removeLast());\n        }\n\n        // Add new view to buffer\n        int newBufferIndex = mCurrentAdapterIndex - mSideBuffer;\n        if (newBufferIndex > -1) {\n            mLoadedViews.addFirst(makeAndAddView(newBufferIndex, false));//,\n\n//                      recycleView));\n                mCurrentBufferIndex++;\n            }\n    }\n\n    requestLayout();\n    setVisibleView(mCurrentBufferIndex, true);\n    if (mIndicator != null) {\n        mIndicator.onSwitched(mLoadedViews.get(mCurrentBufferIndex),\n                mCurrentAdapterIndex,direction);\n    }\n    if (mViewSwitchListener != null) {\n        mViewSwitchListener\n                .onSwitched(mLoadedViews.get(mCurrentBufferIndex),\n                        mCurrentAdapterIndex,direction);\n    }\n    logBuffer();\n}\n\nprivate void recycleView(View toRecycle) {\n    int viewType = ((ViewFlow.LayoutParams)toRecycle.getLayoutParams()).viewType;\n    detachViewFromParent(toRecycle);\n    List<View> viewsOfLikeType = mRecycledViews[viewType];\n    if(viewsOfLikeType.size() < numVisibleViews){\n        // TODO maybe store \"removed from index\"\n        mRecycledViews[viewType].add(toRecycle);\n    } else {\n        removeDetachedView(toRecycle,false);\n    }\n}\n\nprivate View setupChild(View child, boolean addToEnd, boolean recycle, int viewType) {\n    ViewGroup.LayoutParams p = (ViewGroup.LayoutParams) child\n            .getLayoutParams();\n    if (p == null) {\n        p = new ViewFlow.LayoutParams(\n                ViewFlow.LayoutParams.FILL_PARENT,\n                ViewFlow.LayoutParams.WRAP_CONTENT, viewType);\n    } else {\n        if(!(p instanceof ViewFlow.LayoutParams)){\n            p = new ViewFlow.LayoutParams(p,viewType);\n        }\n    }\n\n    if (recycle)\n        attachViewToParent(child, (addToEnd ? -1 : 0), p);\n    else\n        addViewInLayout(child, (addToEnd ? -1 : 0), p, true);\n    return child;\n}\n\nprivate View makeAndAddView(int position, boolean addToEnd) {\n\n    // pull a recycled view of like type, or null if none\n    View convertView = null;\n    ArrayList<View> viewsOfLikeType = mRecycledViews[mAdapter.getItemViewType(position)];\n\n    // TODO come up with a smarter way of retaining these views\n    // since there is a significant chance that it's identical\n    // to the one we are adding\n    if(viewsOfLikeType.size() > 0){\n        convertView = viewsOfLikeType.get(0);\n        viewsOfLikeType.remove(0);\n    }\n\n    // pass the recycled view\n    View view = mAdapter.getView(position, convertView, this);\n\n    return setupChild(view, addToEnd, convertView != null, mAdapter.getItemViewType(position));\n}\n\nclass AdapterDataSetObserver extends DataSetObserver {\n\n    @Override\n    public void onChanged() {\n        View v = getChildAt(mCurrentBufferIndex);\n        if (v != null) {\n            for (int index = 0; index < mAdapter.getCount(); index++) {\n                if (v.equals(mAdapter.getItem(index))) {\n                    mCurrentAdapterIndex = index;\n                    break;\n                }\n            }\n        }\n        resetFocus();\n    }\n\n    @Override\n    public void onInvalidated() {\n        // Not yet implemented!\n    }\n\n}\n\nprivate void logBuffer() {\n\n    Log.d(\"viewflow\", \"Size of mLoadedViews: \" + mLoadedViews.size() +\n            \"X: \" + mScroller.getCurrX() + \", Y: \" + mScroller.getCurrY());\n    Log.d(\"viewflow\", \"IndexInAdapter: \" + mCurrentAdapterIndex\n            + \", IndexInBuffer: \" + mCurrentBufferIndex);\n}\n\n/\n  * ViewFlow extends LayoutParams to provide a place to hold the view type.\n  */\n public static class LayoutParams extends ViewGroup.LayoutParams {\n     /\n      * View type for this view, as returned by\n      * {@link android.widget.Adapter#getItemViewType(int) }\n      */\n     int viewType;\n /**\n  * When an AbsListView is measured with an AT_MOST measure spec, it needs\n  * to obtain children views to measure itself. When doing so, the children\n  * are not attached to the window, but put in the recycler which assumes\n  * they've been attached before. Setting this flag will force the reused\n  * view to be attached to the window rather than just attached to the\n  * parent.\n  */\n boolean forceAdd;\n\n /**\n  * The position the view was removed from when pulled out of the\n  * scrap heap.\n  * @hide\n  */\n int scrappedFromPosition;\n\n public LayoutParams(Context c, AttributeSet attrs) {\n     super(c, attrs);\n }\n\n public LayoutParams(int w, int h) {\n     super(w, h);\n }\n\n public LayoutParams(int w, int h, int viewType) {\n     super(w, h);\n     this.viewType = viewType;\n }\n\n public LayoutParams(ViewGroup.LayoutParams source) {\n     super(source);\n }\n\n public LayoutParams(ViewGroup.LayoutParams source, int viewType) {\n     super(source);\n     this.viewType = viewType;\n }\n\n}\n}\n```\n1.  Added a recycle bin for views (by view type).  Since ViewFlow only has one view visible at any given time, the most views we need in the \"recycle bin\" (after we have loaded) for any given view type is 1, but instead of creating a hard limit I've based the number on the number of view types we have.  The idea here is ultimately to make it so that I can have ViewFlow display its current view, centered, and small fractions of adjacent views (or even whole views on Tablet-sized devices), perhaps blurred, so that users can easily tell there are more pages.\n2.  Added a call to FlowIndicator.setViewFlow to force a circle indicator to redraw upon modification of the underlying data (because there was no easy way to call flowIndicator.invalidate).  I've also added a \"direction\" integer to the FlowIndicator notify page change callback (I use this for lazy loading data into my adapter in the direction we're moving).\nI also re-added code for \"center\" attribute in the CircleFlowIndicator (not shown because somebody else already did it) because I couldn't figure out how to get at the android:gravity styleable attribute.  It's necessary because if the length of data in your adapter is changing it is necessary to make the indicator larger than circle size * number of circles, and without the ability to center the circle indicators within their own view this would force a re-layout.\nAnything else you see changed, let me know and I'll tell you why!\n. Looking at the merge history, the changes re: recycling are largely in conflict.  I performed much the same refactoring as you just merged in, but the touch points in the code are very different when you start caring about which kind of view you're recycling.\n. I definitely agree that refactoring the recycling makes sense; the major difference between my version and the latest ViewFlow is where my changes touch recycled views versus where chripo's changes touch them.  I've moved almost all of the recycle handling into makeAndAddView and setupChild.\nI have, like chripo, created a recycleView method to be called when removing a view from the buffer, but we must by the nature of my change do very different things with them now. :)\nIt's probably easier to merge his changes into mine than vice versa, since he refactored whereas I changed functionality.  The diff will look a lot cleaner if you remove the commented-out lines where you used to pass the View recycleView around.\n. Perhaps we should ask @chripo to see if he has any suggestions based on a quick look at my edits.\n. I'll do a diff with the pre-merge ViewFlow and post it when I get a chance.\n. The layout param hack is taken directly from AbsListView in the Google code\nbase. :)\nOn Apr 21, 2012 10:29 AM, \"Christoph Polcin\" \nreply@reply.github.com\nwrote:\n\nI feel somehow unsatisfied with @svtdragon LayoutParam hack.\nTherefore I tried an other approach, but got stuck by computing the\nadapter index when adding a view to the recycled list.\n3 lines of code need more work. I marked them with TODO.\nmaybe someone can use this as a starting point:\nchripo/android-viewflow@caa43888162fcd2ab5b843fc851c6c3854cc0dbd\ni will continue the work if some time is left.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/47#issuecomment-5260823\n. They store all kinds of info there, including the position that a given\nview was removed from; it seems to be a big part of their Recycler object.\n\nThe first thing I tried was to modify that and implement it in ViewFlow but\nit wasn't a neat fit.  My approach could be improved however by keeping\ntrack of that position-removed-from and fetching the same view out of the\nrecycle bin if it still exists.\nOn Sat, Apr 21, 2012 at 2:56 PM, Christoph Polcin <\nreply@reply.github.com\n\nwrote:\nmaybe that's the reason why it's feeling uncomfortable ;)\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/47#issuecomment-5262699\n. Well, as I indicated above, the above only halfway fixes the issue.  I currently have to call setSelection because setting the adapter index (followed by any number of different ways I tried to invalidate/cause the view at the adapter index to be redrawn) doesn't actually force an update in the next layout pass.  I would love a way to do that which didn't involve setSelection... any ideas?  If you can give me a direction to go in, I can try to follow up with it.\n\nI just left the code alone if the adapter doesn't have stable IDs.  There doesn't seem to be a good way to tell which view is currently active and should be made visible after the adapter has already been updated, unless maybe we put something into the LayoutParams and looped over our buffer...?  We could also maybe use tags on the views based on other info from the adapter, but that might interfere with the ViewHolder pattern that is the current best practice.  I know that AbsListView keeps track of the \"position removed from\" attribute of a view in its LayoutParams, so maybe there's a path forward there, and it should also help with efficiency (because we could pull an already-populated view out of the recycle bin if it hasn't been overwritten).\nThe root of my problem is this:  My app does lazy-loading of images in a gallery, for which I use ViewFlow.  When an image page is loaded, it has the URLs for the next and previous images from that image.  I queue up downloads of them and then prepend the previous and append the next image to the adapter.  The user swipes to the next or previous image, and the same thing happens on every view switch.\nPrepending the previous image is causing all kinds of issues because it shifts all the indices by 1.  Even with my fix, occasionally something doesn't work quite right while prepending and I end up with mis-ordered images (seems like some kind of race condition).\nOf course, I think I'm rather an amateur at custom Android UI components, so maybe you can think of a better way to handle this situation!\n. Have a look at all references (there are not many) to mNeedSync here.\nI think this is what we ultimately need to implement.  handleDataChanged() looks promising...\n. ",
    "xxv": "Yeah, that's what I was referring to.\nThe technique I was thinking of (attrs.getAttributeValue(NS, \"your_attr\")) does allow for custom namespaces, but seems to bypass the whole theming system (which is bad). I still think it's more complex than it should be for reusable widgets, but it also seems to be standard.\n. My main issue with the app-specific namespace is that that it adds a dependency on your app and makes the widget less reusable. Ideally, it should be as easy to use a custom widget as it is to use a MapView (hopefully without all the bugs or special activities). One should be able to put a bit of sample code out that you can copy into your activity without having to adjust a namespace string.\nI think this could be accomplished using an Android library for the widget, but I need to investigate further to really understand what's going on. The whole Android style/theming system is a bit of a kludge and it's hard to see how it's intended to be used properly when you aren't the main Android source. \n. ",
    "dfetter": "You are right. Changing the compiler to 1.6 fixed the @override problems. The onConfigurationChanged error was due to my target-sdk being 7 in my default.properties. I had to change it to android-8 because onConfigurationChanged wasn't added to View until then.\n. ",
    "jspeth": "Yes, it's the latest version.  Try adding\n    viewFlow.setSelection(3);\nright after setting the adapter in CircleViewFlowExample.java to see it.  It shows the first view, since sidebuffer is set to 3.  If you change sidebuffer to 1 then it shows view 2.\nThanks, by the way.  This view is really useful.\n. ",
    "delneet": "Thanks for your quick reply!\nI have a heap size of 2.7MB (with 3 pics)\nThis doesn't change when I increase the num of pics to lets say 10.\nWhen I decrease the card_count in my ImageAdapter from 20 to 3 (so that getCount() returns 3) everything is just fine.\nBut anything higher than 3 causes the error.\nAlso when I set it to 3 and then start another activity with an image, my app crashes with this error.\nIt seems like the resources are all loaded and stay in memory?\ndoes this help?\nhttp://www.helloandroid.com/tutorials/how-avoid-outofmemory-error-oom-ugly-truth-revealed\n. It seems the issue lies in the rest of the application consuming too much bitmap vm\ndecreasing other images (like background on ImageItemView) results in no more errors.\nSorry, seems to be false alarm\n. I know the article.\nWas just wondering if you were planning on implementing this.\nI will try and put it in my ImageView myself.\nThank you!\n. ",
    "franciscojunior": "Hmmmmm, I see. \nI thought I could get a simpler approach to that. I mean, I may be missing something here, but if I'm understanding it right, I would need to add a motion controller to my view just to intercept the motion when it is scrolling vertically. I mean, I loved the approach of just getting my views as they are in xml and just inflate them inside my Adapter getView(). I used the viewflow-example as a template, so I may be missing some other ways of using viewflow. As the Scrollable view defined in my xml already gives me the scroll, I didn't want to have to play with scrolling code. I'd like to have that abstracted away from my code. Or, maybe you could make the mTouchSlop property or something which gives control over it accessible to my code.\nI thought about the mTouchSlop because I noticed that the only problem is that when I'm scrolling vertically, viewflow sometimes thinks I'm scrolling horizontally and stops the vertical scroll. \nI think that if I wanted to make more complex gestures in my view, I really would need to override gesture consumption of viewflow, but I just wanted a simple vertical scroll and would like to use it with less code as possible. Sorry if I'm looking like a too lazy guy.\nThanks in advance\n. By motion controller I mean I will need another class to keep the state of the motion and consume the events. \nOk, I could make this class, but I think that the best way would be a \"helper class\" which could be used by many other layouts which had this \"problem\". I mean, it would be best if it could be used in any layout based on Scrollview xml layouts regardless of the place it is used. If this is the case, I think the best place for this helper class would be inside flowview itself. So, for example, if I need to add a layout with a scrollview inside it and I already know that scrollviews have this \"problem\", I could make something like:\nin my adapter:\npublic View getView(int position, View convertView, ViewGroup parent) {\n        switch (position) {\n        case 0:\n            if(convertView == null) {\n            convertView = mInflater.inflate(R.layout.cryptcarddetails, null);\n            convertView = ViewFlowHelpers.wrapScrollView(convertView); <===\n            }\n            break; \n        }\n        return convertView;\n    }\nOr something like that. My point is that the wrapScrollView method would take care of this \"problem\" with scrollviews. Either by setting up another touchevent handler or doing a special handling of this view which has a scrollview. I say specifically scrollviews because as I said before, with ListViews I didn't have this type of problem. I didn't test other views to see if they show the same problem too.\nI think this would be much easier for the library user.\nI hope it is more understandable now. If you have any other question, please, let me know.\n. I didn't test adding a horizontal scroll view in a list view item. I'll see if I can come up with something about that and I'll let you know. If you get something, please let me know so I can test it.\nAgain, thanks for such awesome library!\n. Yeah, thats what I'm using right now. But the viewpager doesn't have the title flow indicator, or at least I couldn't find it. My idea was to be able to use something like viewpager with your title flow indicator. \n. Ok, thanks! I'll have a look at viewflow code and see what I can get. I'll let you know if I have any progress...\n. Ok, I think I got some real progress here....\nI got the TitleFlowIndicator to work with the ViewPager, but there is only one detail giving me problem right now: When I scroll to a view in the right, the title scroll is done correctly but when the scroll finishes, the title scrolled doesn't stick. :( It is changed to the first title. As soon as I start to scroll back to the left, the title is changed and the title scrolling happens normally. \nSo, the only problem right now I couldn't figure out yet is why the tile is being stick to the first title.\nThe only change I had to make to the TitleFlowIndicator was to add:\na field: \nprivate PagerAdapter pagerAdapter\na method: \npublic void setPagerAdapter(PagerAdapter pager) {\n        pagerAdapter = pager;\n    }\nAnd I changed the 2 lines which read:\nint count = (viewFlow != null && viewFlow.getAdapter() != null) ? viewFlow.getAdapter().getCount() : 1;\nto\nint count = (pagerAdapter != null) ? pagerAdapter.getCount() : 1;\nWith those changes, you only have to add the TitleFlowIndicator together with your viewpager in your layout:\nxml version=\"1.0\" encoding=\"utf-8\"?\n\n```\n\n\n\n\n```\n\nThe trick comes in the form of this adapter class:\npublic static class TextIndicatorAdapter extends FragmentPagerAdapter implements ViewPager.OnPageChangeListener, TitleProvider {\n```\n    public TextIndicatorAdapter(FragmentActivity activity,\n            ViewPager pager, TitleFlowIndicator tfi) {\n        super(activity.getSupportFragmentManager());\n    mContext = activity;\n    mViewPager = pager;\n    mFlowIndicator = tfi;\n\n    mViewPager.setAdapter(this);\n    mViewPager.setOnPageChangeListener(this);\n\n\n    tfi.setTitleProvider(this);\n    tfi.setPagerAdapter(this);\n\n    // TODO Auto-generated constructor stub\n}\n\nprivate final Context mContext;\n\nprivate final ViewPager mViewPager;\n\nprivate final TitleFlowIndicator mFlowIndicator;\n\n\n@Override\npublic void onPageScrolled(int position, float positionOffset,\n        int positionOffsetPixels) {\n    // TODO Auto-generated method stub\n\n    mFlowIndicator.onScrolled(positionOffsetPixels, 0, 0, 0);\n\n}\n\n@Override\npublic void onPageSelected(int position) {\n    // TODO Auto-generated method stub\n\n    mFlowIndicator.onSwitched(null, position);\n    Log.d(\"viewpager\", String.valueOf(position));\n\n}\n\n@Override\npublic void onPageScrollStateChanged(int state) {\n    // TODO Auto-generated method stub\n\n}\n\n@Override\npublic Fragment getItem(int position) {\n    // TODO Auto-generated method stub\n    if (position == 0)\n        return Fragment.instantiate(mContext, Fragment1.class.getName(),\n                null); \n    else\n        return Fragment.instantiate(mContext, Fragment2.class.getName(),\n                null);\n}\n\n@Override\npublic int getCount() {\n    // TODO Auto-generated method stub\n    return 2;\n}\n\npublic void setCurrentView(int id) {\n\n    mViewPager.setCurrentItem(id);\n}\n\n@Override\npublic String getTitle(int position) {\n    // TODO Auto-generated method stub\n    if (position == 0)\n        return \"Title 1\"; \n    else\n        return \"Title 2\";\n}\n\n}\n```\nIt is hardcoded, sorry for that, because I just wanted to test it fast and see how it works.\nAfter that, you just need to glue the adapter with the viewpager in your onCreate or onCreateView method:\n```\nmViewPager = (ViewPager) v.findViewById(R.id.pager);\nTitleFlowIndicator tfi = (TitleFlowIndicator) v.findViewById(R.id.viewflowindic);\n\n\n\n\nTextIndicatorAdapter a = new TextIndicatorAdapter(getActivity(), mViewPager, tfi);\na.setCurrentView(0);\n\n```\nThat's it! \nPlease, if you could point me out what I have to do in order to get the correct title stick in the selected value after scroll it would be very much welcome!\nThanks in advance.\n. More info: I noticed that the titleindicator always stick to the left most title when the scroll is stopped. As soon as I start scrolling, the titles are drawn correctly. \nI may be missing something when the scroll stops in order to update the title indicator state.\n. Ok, now I got it. \nThe problem was on my onPageScrolled implementation. After checking ViewFlow implementation, I reached the following lines:\n/\n             * The actual horizontal scroll origin does typically not match the\n             * perceived one. Therefore, we need to calculate the perceived\n             * horizontal scroll origin here, since we use a view buffer.\n             /\n            int hPerceived = h + (mCurrentAdapterIndex - mCurrentBufferIndex)\n                    * getWidth();\nAnd obviously my initial implementation wasn't taking care of the offset correctly.\nI just had to change it to:\nint hPerceived = positionOffsetPixels + position\n                        * mViewPager.getWidth();\nmFlowIndicator.onScrolled(hPerceived, 0, 0, 0);\nAnd it worked like a charm!\nI hope it helps.\nPlease, let me know if you have any question about it.\n. Sure! I'm woking on it right now....\n. There is it: \nhttps://gist.github.com/1122947  \nI didn't know about gist. It is awesome!\nWhen using the code, note that you have to change the code of TitleFlowIndicator. I think this may, if accepted, of course, be refactored into 2 different classes or added support for both adapters, as I noticed that the viewflow adapter in only used to get the number of views.  Maybe the code could test the presence of both adapters and use which one is available.\nNote that I also added a simple onclick handler to the titleflowindicator to show that the click of the tabs would work as expected and it would be a nice addition to have the tabs recognize clicks and act accordingly. The click handler I added only changes the view from the position 1 to 2, but is works as a proof of concept.\nPlease, let me know what do you think.\n. pakerfeldt, what did you think about the changes?\n. Ok, no problem! \nI'm improving the code a little bit more. I also think I found an issue with TitleFlowIndicator when screen orientation changes: The indicator doesn't persist the previous position. I already got a fix for that and I'll open another issue talking about it and giving you my solution. I think that now we got a 100% working titleflowindicator working with fragments. :)\n. Sure! I'll get the latest code and send you another gist. \n. I'll make sure to use the latest code and return you back. \nThanks!\n. ",
    "yjukaku": "I think an XML attribute for sensitivity (which would take a multiplier to mTouchSlop) might not be too much to ask. Why are you against this idea?\n. Yeah, I agree with you that it would break from standard Android practice. I guess I was just being selfish because I didn't want to extend my scrollview :) \n. Did you accidentally remove the code that does the centering? Or did I just make a mistake while committing? Theres an if-block that actually calculates the centeringOffset that seems to be missing from the CircleFlowIndicator code\n. ",
    "Miserlou": "That's fine - but does git overhead really matter that much? It's not like GitHub has any space limits, and git checkout is pretty damn fast anyway. shrug Either way is fine though - I'd just commit the Jar though, because otherwise I'd end up having to keep the Jar on the download page up to date because I'm OCD like that.\n. Ah, I see. In that case just write the ant script and add instructions to 'ant jar' in the README, maybe?\n. Cool thanks!\n. ",
    "rp-": "Thank you for supporting API4.\nJust had a problem with your changes with your copyright comment, the XML resource parser had problems with the '--' token within the document. If you remove the second comment opening tag '<!--' it works\n. viewflow/res/values/attrs.xml\nline 3\n. you have to build it first with eclipse or the toolchain of your choice\n. ",
    "AfzalivE": "You're welcome! Thanks for guiding me.\n. Hmm, only the Catch Notes implementation seems to have the clickable titles. I'll try to see if I can help.\n. ",
    "nadam": "Ok, I'll give it a try and let you know the result.\n. I ran into problems with the horizontal scrolling, so I decided to use the standard Gallery widget instead and made some minor changes to CircleFlowIndicator to have it work together with Gallery.\n. ",
    "iboyko": "Last commit contains only files specified by you with comment on added methods and attribute.\n. Second pull request is created #22 that contains only TitleFlowIndicator.java,  attrs.xml and title_layout.xml \n. Thank you!\n. ",
    "tlegras": "Thanks for your quick reply, \nYes you're right but the gallery is one a small component at the bottom of the views, so I was thinking it would not be a problem for the users.\nOkay may be I have either to consider another solution for switching views or for the gallery. \nAnyway your implementation of viewflow with adapter pattern and also the title indicator is really brilliant. Thanks for sharing it.\nThierry\nLe 31 juil. 2011 \u00e0 12:40, pakerfeldtreply@reply.github.com a \u00e9crit :\n\nI'm not entirely sure what you're after. Do you want to be able scroll horizontally both in ViewFlow and in Gallery? That is not considered good practice and would probably confuse the user. \nOn a technical level, the ViewFlow will get the touch event before the gallery, and since ViewFlow supports horizontal scrolling it will consume the event.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/24#issuecomment-1694705\n. Year you must be right as in some cases the gallery seems to get the event.\nOn the other hand I think I you follow your first suggestion and remove the gallery. Indeed I use it as an extensible button bar and I am no consider replace it by a quick action pattern. \nSo for me the issue is closed :)\nThanks.\nThierry.\n. \n",
    "JakeWharton": "Please provide a gist of the final working example so we can see the code in one place.\n. ",
    "elnoxvie": "I second this but it seems that the only way to make the the title click-able is to check the bounds from onTouch. I will probably implement it that way and will update the codes here if i do it. \n. It's already implemented in JakeWharton's version for viewpager. \n. Hi, \nHere is the stack trace: \n08-15 15:16:58.810: ERROR/AndroidRuntime(4659): java.lang.NullPointerException\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at com.handyapps.GTasks.Task.TaskView.load(TaskView.java:53)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at com.handyapps.GTasks.Task.TaskView.(TaskView.java:40)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at com.handyapps.GTasks.Adapter.AndroidVersionAdapter.getView(AndroidVersionAdapter.java:97)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at org.taptwo.android.widget.ViewFlow.makeAndAddView(ViewFlow.java:647)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at org.taptwo.android.widget.ViewFlow.setSelection(ViewFlow.java:533)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at com.handyapps.GTasks.TaskList.TasklistView$3.onItemClick(TasklistView.java:145)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at android.widget.AdapterView.performItemClick(AdapterView.java:284)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at android.widget.ListView.performItemClick(ListView.java:3382)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at android.widget.AbsListView$PerformClick.run(AbsListView.java:1696)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at android.os.Handler.handleCallback(Handler.java:587)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at android.os.Handler.dispatchMessage(Handler.java:92)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at android.os.Looper.loop(Looper.java:123)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at android.app.ActivityThread.main(ActivityThread.java:4627)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at java.lang.reflect.Method.invokeNative(Native Method)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at java.lang.reflect.Method.invoke(Method.java:521)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:860)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:618)\n08-15 15:16:58.810: ERROR/AndroidRuntime(4659):     at dalvik.system.NativeStart.main(Native Method)\n. Thanks. It works now by commenting the following line but it seems much more sluggish now. \nif(convertView == null) {}\nFor some reason, it seems that if i do a set selection, the convertView doesn't get detected as null. \nAnyway, i will try to check again. \nThanks for the help. \n. I also noticed this on the latest update. I switched back to the old version for the time being. \n. Thanks. I like your implementation on buffer but nowadays, it seems that the device is powerful enough to handle at least 20 pages full of views.. why not just store them inside the memory instead. thus views doesn't need to be created and thus speed up the selection. ViewPager is actually has much faster implementation. I am not sure how its internal mechanism works but it's quite efficient. \n. I see. Thanks for the explanation. \n. ",
    "matt-oakes": "I'll likely impliment this at some point. Someone has requested this for a project I use viewflow on.\n. Perfect. No problem!\n. ",
    "krajzler": "Is anything new with this issue?\n. ",
    "b3nc3": "I'm going to fix this by using textviews on canvas. I'll let you know when I'm done.\n. ",
    "Voldemar123": "It's all right intended\nafter reading the documentation I did so\nI have a working example of asynchronous data loading into ViewFlow\nCan I add it ViewFlowExample and commit into this project?\nI think my experience will be useful to others\n. Ok, I try to commit my changes\nit is my first github experience - could advise me how to start work with project ?\n. ",
    "sergk79": "Yeah, it's hard to see it with transparent background. \nI found this issue when I added a background drawable for TitleFlowIndicator. Look at this screenshot:\nhttp://lh3.googleusercontent.com/-29H9sAjZj0k/TkoddUHR3xI/AAAAAAAAAVU/bFoOkqPq9ZQ/s779/TitleFlowIndicator_footerLine_issue.png\n. ",
    "nfrancois": "Oups, I failed my pull request. It's not link with this issue, it create the issue #41.\nBut I did this feature, I add the param \"sideTitle\" whitch default value is 1.\n. It's true my titles movement is weird\nIf I understand well your idea :\nThe begin state is :\n|............A...B...C...D|\nAnd the movement is :\n|...........A....B...C...D|\n|..........A.....B...C...D|\n|.........A......B...C...D|\n|........A.......B...C...D| <- A stop moving\n|........A......B...C...D.| \n|........A.....B...C...D..| \n|........A....B...C...D...| \n|.......A...B...C...D...E| <- Final position\nWhat do you think of this :\n|............A...B...C...D|\n|...........A...B...C...D.|\n|..........A...B...C...D..|\n|.........A...B...C...D...|\n|........A...B...C...D...E|\nand with more titles :\n|A...B...C...D...E...F...G|\n|A..B...C...D...E...F....G|\n|A.B...C...D...E...F.....G|\n|AB...C...D...E...F......G|\n|B...C...D...E...F...G...H|\nIt's close to 1 side titles case : full left and full right titles just move when another title hit them.\n. Not exactly, my problem was that I had to know  mLoadedViews to set position on them when a ListView is scrolling. So, I add a getLoadedViews() method in ViewFlow. I do not have this scenario, but when a new ListView is created by ViewFlow, it means it's position have also to be set.\nBut I think this solution is bad and can be improved.\nGood idea to generalize, I'll think about it.\nIn my case, I use OnScrollListener on all loadedView, and the position is set with 2 position indicator.\nHave you idea of another synchronisation use case ?\nI just thinking about tabs : all views in horizontally scroll have the same tab selected. \n. ",
    "tadfisher": "I agree with this, and passing null will also prevent memory leaks caused by references on the application side. Some might view null-valued parameters as poor API design, however. Google does it anyway, such as in adapter-view binding.\n. Thanks. I was just thinking that a second callback might be more appropriate, since taking these references might influence GC unnecessarily... for example, if you take a reference to the view prior to removing it from the buffer. But checking for this case would also prevent that.\n. ",
    "jleidgens": "I think extending ScrollView is not something I want to do. I don't need it to use a standard android gallery inside a scrollview. I had a look at the Gallery source code and I found the following in the onScroll method of the gallery widget: \n/*\n     * Now's a good time to tell our parent to stop intercepting our events!\n     * The user has moved more than the slop amount, since GestureDetector\n     * ensures this before calling this method. Also, if a parent is more\n     * interested in this touch's events than we are, it would have\n     * intercepted them by now (for example, we can assume when a Gallery is\n     * in the ListView, a vertical scroll would not end up in this method\n     * since a ListView would have intercepted it by now).\n     */\n    mParent.requestDisallowInterceptTouchEvent(true);\nI think this line prevents the scrollview from reacting on vertical touch events once the scroll has started. I looked through your code but I couldn't find a good spot to insert this line and test if it works. I would like to improve your gallery to incorporate this feature but I couldn't come up with a good way to retrieve the parent view and I didn't know when a scroll starts and when one scroll ends.\n. ",
    "cmoaciopm": "yes, I find the same problem. Expecting author to fix this issue.\n. ",
    "chripo": "sorry,  i took a few days off.\nis it possible to get a diff / patch that contains your changes?\nit would be much easyer to review and adapt changes.\n. just attach a diff from your last branching point.\nmyabe it's easyer to adapt your idea ontop of the head.\n. or post a link to your hg repo.\n. I feel somehow unsatisfied with @svtdragon LayoutParam hack.\nTherefore I tried an other approach, but got stuck by computing the adapter index when adding a view to the recycled list.\n3 lines of code need more work. I marked them with TODO.\nmaybe someone can use this as a starting point:\nchripo/android-viewflow@caa43888162fcd2ab5b843fc851c6c3854cc0dbd\ni will continue the work if some time is left.\n. maybe that's the reason why it's feeling uncomfortable ;)\n. ",
    "Cliffus": "thanks for the comment! what version are you using?\n. Hi!\nI just 'solved' the issue, there was a stupid bug in my adapter which caused views to not recycle anymore... deeply ashamed ;-)\nbut still, this might be a bug in the viewflow class, this is what happens:\nI initialize the adapter, set it on the viewflow class with selected index 0. On user interaction, I set the index to 1 (or something else), the views in the adapater are not recycled so they are recreated in the setSelected() method. On that moment, all views in the adapter are frozen.\nI hope this scenario can help you find the cause of this issue, but it's not a big one ;-)\n. that wasn't really the problem, the views inside the viewflow view seemed like some kind of 'screenshots' of the views. The UI thread wasn't looping inside them anymore.\nI could only reproduce the issue on Android 2.1+\n. for me, there is no issue anymore. there is only an issue when the developer decides to not use view recyling.\nI'll close this one ;-)\n. ",
    "euvid": "I have the same problem, in which my listview updates only after one or several touches, such as there is no getView called on listview adapter. Can you explain me how did you resolve the problem. I know it's recommended to use viewPager, but i have used this for a while and i addapted the viewFlow for my needs\n. ",
    "csgavino": "Any updates?\n. ",
    "meredrica": "The problem seems to be the A with the circle on top of your name in the copyright.\nit gave me a hell lot of trouble. I changed it to a normal A and everything works again\n. ",
    "orac": "There's currently no way for Android projects to include XML (or other) resources from JAR files. Either include ViewFlow as an \"Android library project\", or use the JAR and copy the resources into your project by hand.\n. In your XML layout, set the radius attribute, as described in the README. For example:\n<org.taptwo.android.widget.CircleFlowIndicator\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_height=\"wrap_content\" android:layout_width=\"wrap_content\"\n    app:radius=\"5dp\" />\nCurrently this is the only way to increase the radius: there's no mutator function for it in CircleFlowIndicator.\n. ",
    "SeanPONeil": "I was going to do a pull request tonight for this, but this is cool too! Thank you\n. I had only implemented the android:typeface feature, but it was nearly exactly what you had committed\n. ",
    "knitfaced": "Oh! i just found notifyDataSetChanged() on the adapter. This is a much nicer way of doing it, which already exists. Please ignore this pull request :)\n. ",
    "zhouYunan2010": "but I can't find the method? \nonly  public void setAdapter(Adapter adapter) {..}\n. pakerfeldt, thank you so much\nI download the newest version, and it works well.\n. ",
    "sundarsan": "yes absolutely\nI am very much new to android......Kindly give me some sample for have\nListviews in all the view of viewflow as you said.\n        Looking for ur reply as sooon as possible\n2012/1/5 Patrik kerfeldt <\nreply@reply.github.com\n\nIf by that you mean that each of the views in the viewflow contains a\nlistview, yes that's possible.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/54#issuecomment-3368274\n. I tried with ur sample ....\n   Let me tell you what i have done\n\n```\n I added a listview in diff_View2.xml\nand added this\n```\nListView listView = (ListView) findViewById(R.id.listView2);\nString[] Values = new String[] { \"Cupcake\", \"Donut\", \"Eclair\", \"Froyo\",\n\"Gingerbread\", \"Honeycomb\", \"IceCream Sandwich\"};\nlistView.setAdapter(new ArrayAdapter(this,\nandroid.R.layout.simple_list_item_1, Values));\nBt whatever i add i am getting listView only in the First View of the\nViewflow\nKindly suggest me where i am doing mistake\n2012/1/6 Patrik kerfeldt <\nreply@reply.github.com\n\nSorry, but I can't give you that kind of support. I simply don't have the\ntime. You should look in the viewflow-examples folder for getting started\nhelp.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/54#issuecomment-3381243\n. Hi,\n\nI have tried my level best with above code attached....Moreover i tried\ndebugging as well..\n     Bt cant able to find where i did mistake..Kindly help me in this issue\n2012/1/6 Patrik kerfeldt <\nreply@reply.github.com\n\nJust as you have an ArrayAdapter for your listview you need an Adapter for\nthe viewflow. This adapter implements getView(...) and here you need to\ninflate your listview and populate with another adapter (like the one you\njust wrote).\nIf you only get a listview for the first view only, you need to have a\nlook at the adapter implementation and the getView(...) method. For each\nposition you need to return a valid view (a listview in your case).\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/54#issuecomment-3381864\n. Looking forward to your help in this...I done all things which you said in\nthe previous reply but still didnt work..\n\n2012/1/9 sundar rajan sundarsym@gmail.com\n\nHi,\nI have tried my level best with above code attached....Moreover i tried\ndebugging as well..\n     Bt cant able to find where i did mistake..Kindly help me in this\nissue\n2012/1/6 Patrik kerfeldt <\nreply@reply.github.com\n\nJust as you have an ArrayAdapter for your listview you need an Adapter\nfor the viewflow. This adapter implements getView(...) and here you need to\ninflate your listview and populate with another adapter (like the one you\njust wrote).\nIf you only get a listview for the first view only, you need to have a\nlook at the adapter implementation and the getView(...) method. For each\nposition you need to return a valid view (a listview in your case).\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/54#issuecomment-3381864\n. Whenever u find time try to provide me some sample with the above req\n\n\n2012/1/10 sundar rajan sundarsym@gmail.com\n\nLooking forward to your help in this...I done all things which you said in\nthe previous reply but still didnt work..\n2012/1/9 sundar rajan sundarsym@gmail.com\n\nHi,\nI have tried my level best with above code attached....Moreover i\ntried debugging as well..\n     Bt cant able to find where i did mistake..Kindly help me in this\nissue\n2012/1/6 Patrik kerfeldt <\nreply@reply.github.com\n\nJust as you have an ArrayAdapter for your listview you need an Adapter\nfor the viewflow. This adapter implements getView(...) and here you need to\ninflate your listview and populate with another adapter (like the one you\njust wrote).\nIf you only get a listview for the first view only, you need to have a\nlook at the adapter implementation and the getView(...) method. For each\nposition you need to return a valid view (a listview in your case).\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/54#issuecomment-3381864\n. come on i knew this is elementary ...Just leave it ...Let me show with my\nknowledge\nwhat this elementary boy can do in future....\n\n\n\n2012/1/25 Patrik kerfeldt <\nreply@reply.github.com\n\nWhat you ask for is simply elementary knowledge of the Android platform.\nThis tutorial might help you:\nhttp://www.vogella.de/articles/AndroidListView/article.html\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/54#issuecomment-3649850\n. Its k dude....I will try to manage\n\n2012/1/26 Patrik kerfeldt <\nreply@reply.github.com\n\nI'm sorry to hear that you get upset. But you have to accept the fact that\nI don't have time to give you the complete example you ask for. Especially\nwhen there's already a lot of very god tutorials which, together with the\nexamples in android-viewflow should be enough to understand how to create a\nviewflow with multiple list views.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/54#issuecomment-3665175\n. \n",
    "gothion": "Hello , Patrik! \n      I am a beginner in learning  android . and I found one of your work viewflow, which I think very excellent, may contain some bug. According to the log ,I found that when Keep sliding the screen, strings  in the green block  (05-25 10:32:25.370: D/viewflow(2536): Size of mLoadedViews: 5, Size of mRecycledViews: 4, X: 640, Y: 0),   and (05-25 10:32:25.380: D/viewflow(2536): IndexInAdapter: 5, IndexInBuffer: 3  can be get. And then the index out of bounds will occur.which will cause the  appliacation of your example to crash.\nMay this string ,05-25 10:15:35.590: E/AndroidRuntime(1914):    at org.taptwo.android.widget.ViewFlow.postViewSwitched(ViewFlow.java:667),  be helpful in debugging.\n  it would be very helpful for you to fix this,and I will be very happy for your kindness responding\n best regards!\n. ",
    "sebastiancity": "sorry it was something else!\n. it was null...my bad. Thanks!\n. ",
    "neofloww": "I changed the code in TitleFlowIndicator to set the currentposition as follows\n    public void setTitleProvider(TitleProvider provider, int position) {\n        titleProvider = provider;\n        currentPosition = position;\n    }\nand it fixed this problem.\n. ",
    "fcavedon": "I have copied the layout exactly like the example. That's why I find it odd. \nThe only difference is that in your example, the view that is shown inside the viewFlow is a LinearLayout with a ScrollView, while mine is a LinearLayout with a bunch of TableLayouts; could this be the cause?\n. This is my parent layout. I tried switching it to a LinearLayout, but still no indicator is shown. With width=70dp the circles are shown, however, not centered with few elements.\n\n```\n\n\n```\n\n. Yes, I'm using Eclipse. I tried your suggestion, but still nothing. The\nindicator was inside the ViewFlow widget. I moved it down, and reduced the\nViewFlow's height, so the indicator could still be underneath it. Still no\nluck..\nWhat is bothering me is that your example works very well with\nwrap_contents. And also, the indicator appears if I use ADT's HierarchyView\nand load all views. This does not makes sense...\nThanks for your help!\n2012/1/27 Patrik kerfeldt <\nreply@reply.github.com\n\nAre you using Eclipse? Try select the CircleFlowIndicator in the Layout\nEditor and show should see where it's located. If it has been pushed down,\noutside the screen by the ViewFlow. Try moving the indicator above the\nViewFlow just to see what happens.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/pakerfeldt/android-viewflow/issues/60#issuecomment-3694021\n\n\nFrancisco A. Cavedon - SCJP\nfrancisco.cavedon@gmail.com\n. ",
    "julioz": "I noticed that when I removed the android:configChanges=\"...\" the viewflow worked as usual... why is that?\n. ",
    "Substitut": "I solve the problem ! The problem was that i call bindApplications in my onResume so when I return to this activity I stack again my ViewFlow and i got this error !\n. I didn't work with this library anymore, I found that you can easily do the same things with Fragment on Android. So I don't know. Good luck.\n. ",
    "appss": "Hello... I am facing same problem on some devices. I am calling notifyDataSetChanged() in onResume of class in which i am setting adapter for ViewFlow. I don't get any such exception if i don't call notifyDataSetChanges(). Moreover this exception is shown only in some devices. Is there any other solution to this problem? I need to get my grid views refreshed on pressing back and resuming this activity.\n. ",
    "gokselguren": "Hi, you can implement onClick action by adding your image_item.xml an onClick method.\n\n\nAnd at your Activity, which contains viewflow, define the myFancyMethod\npublic void myFancyMethod(View v) {\n       Toast.makeText(ctx, \"Deneme\", 0).show();\n    }\n. ",
    "13leaf": "Thank you,that is one way.\nBut implement onItemClick will make ViewFlow more like AdapterView.(which declare implement that)\nI really advise to do that.\n. ",
    "geckhan": "@13leaf  please show your code ,thanks. ",
    "shimiuh": "yes pleas post solution for on title click featuer\nthanks\n. what is\n1.getSelectedItemPosition()\n2.getViewTreeObserver()\n3.orientationChangeListener\n. ",
    "steam0r": "same here, i am using viewflow to scroll through webviews and sometimes it loads the old view, then the new view. this seems to be related to some kind of \"flashing\" that happens when loading bigger views (like webviews). viewflo seems to reload views on every scroll...and gets confused there sometimes.\n. ",
    "tomyZhou": "hello,I register the github.I\u2018m zhougang .\u54c8\u54c8\n. \u8fd9\u662fTomyZhou\uff0cI like this place\n. ",
    "robzon": "Having a similar issue with recycled views. Is there any workaround till this gets fixed?\n. I see, I'll look into ViewPager then. Thanks for the great work!\n. ",
    "Tooto": "i  need this thing too. is it possible?\n. ",
    "superlandero": "Hi, this can autoscroll modifying the PRIVATE method postViewSwitched(int direction) \n    [when direction > 0 is to the right, \n    direction < 0 is to the left \n    and direction = 0 just returns].\nCan change it to PUBLIC or use it on OTHER FUNCTION.\nYou may have to do some validations (i think), but this is working nice for me.\n. ",
    "configurer": "Can you give me code snippet for this? I found method \"postViewSwitched(int direction) \" but don't know how to add animations.\nThanks.\n. ",
    "Spxc": "I'm having the same problem, any solution ?\n. ",
    "adouggy": "Yes, thanks. it works for me. default version from master is android 2.2 which make compile failed with hint getMeasuredState. \n. same issue, after adding project from exists code, compile failed with this notice\n. see issue #95 \n. ",
    "guanguodong999": "Thanks , see this anwser .  issue is solved.\n. oh,sorry,just saw. In your project,\nbonne chance!\n\u00d4\u00da 2013-11-11 19:40:05\u00a3\u00acYolapop notifications@github.com \u00d0\u00b4\u00b5\u00c0\u00a3\u00ba\nExcuse me, what was the solution?\n\u00a1\u00aa\nReply to this email directly or view it on GitHub.\n. That is a image between \"in your project\" and \"bonne chance\".\nplease check the enclosure.\neclipse -> viewflow-> project.properties\ntarget = android-17\n\nplease check your project .perhaps your name of  project.properties file is  below API 11.\nIf you don't solve , you can email , and  attach the screenshot.\nemail : guanguodong999@163.com\n\u00d4\u00da 2013-11-15 07:31:40\u00a3\u00ac\"Charles Neveu\" notifications@github.com \u00d0\u00b4\u00b5\u00c0\u00a3\u00ba\nWhat was the solution? I don't see anything between \"in your project\" and \"bonne chance\".\n\u00a1\u00aa\nReply to this email directly or view it on GitHub.\n. ",
    "yolapop": "Excuse me, what was the solution?\n. ",
    "ghost": "What was the solution? I don't see anything between \"in your project\" and \"bonne chance\". \n. thanks a lot @PhilippEmmermacher that worked perfectly.\n. ",
    "Venni27": "Does it mean that the min sdk level is 11 now? \n. ",
    "siwangqishiq": "Does it mean that the min sdk level is 11 now?\n. ",
    "atest1": "branch:recyclebin is OK with API Level 8.\n. ",
    "PhilippEmmermacher": "in ViewFlow.java function onMeasure()\nreplace\nchildState = child.getMeasuredState();\nwith\nchildState = child.MEASURED_HEIGHT_STATE_SHIFT >> child.MEASURED_STATE_MASK;\n. @Gurvinder1406\nThe function getMeasuredState() was introduced in API 11.\nThis means it cannot be used in API's below Level 11.\nBut if you look at its documentation (http://developer.android.com/reference/android/view/View.html#getMeasuredState%28%29) you will easily notice what the function does:\n\"Return only the state bits of getMeasuredWidthAndState() and getMeasuredHeightAndState(), combined into one integer. The width component is in the regular bits MEASURED_STATE_MASK and the height component is at the shifted bits MEASURED_HEIGHT_STATE_SHIFT>>MEASURED_STATE_MASK. \"\n. ",
    "Gurvinder1406": "Thanks a ton @PhilippEmmermacher \nCan you please briefly explain what exactly was the issue ?\n. ",
    "obaniu2006": "maybe you need to set ViewFlow layout_width or minWidth values\u3002\n. ",
    "xmflsdede": "After I pass the ExpandableListView as variable into my own adapter and call smoothScrollBy everytime on onGroupCollapsed() and onGroupExpanded(), the problem will be solved. I figure it might be caused by viewflow refresh timing. Plz check it out.\n. ",
    "jingyichushi": "if (mIndicator != null) {\n//++start\n            if (mCurrentBufferIndex < 0)\n                mCurrentBufferIndex = 0;\n            if (mCurrentAdapterIndex < 0)\n                mCurrentAdapterIndex = 0;\n//++end\n            mIndicator.onSwitched(mLoadedViews.get(mCurrentBufferIndex),\n                    mCurrentAdapterIndex);\n        }\n        if (mViewSwitchListener != null) {\n            mViewSwitchListener\n                    .onSwitched(mLoadedViews.get(mCurrentBufferIndex),\n                            mCurrentAdapterIndex);\n        }\n        logBuffer();\n. ",
    "SlavaJan": "There's a hack for that in HTML. I hope it will help you in your case too.\nWhen you place images like that: <img src=\"bunny.jpg\"><img src=\"sheep.jpg\"> there is a space between them like you said about 10 pixels.\nTo avoid that you can place images like this:\n<img src=\"bunny.jpg\"><!----><img src=\"sheep.jpg\">\nor even like this:\n<img src=\"bunny.jpg\"><!-- killing the margin\n --><img src=\"sheep.jpg\">\nto keep code beautiful. Just remember to put any commentary between your pictures.\n. ",
    "gaoneng102": "@pakerfeldt I'm so sorry,it's not android-viewflow cause memory leak.My colleague put a handler for calculagraph in viewflow then the handler cause memory leak.sorry again!\n. "
}