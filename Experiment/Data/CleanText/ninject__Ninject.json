{
    "idavis": "Just tried it out and got this:\nUnhandled Exception: System.IO.FileLoadException: Could not load file or assembl\ny 'Ninject, Version=2.0.0.0, Culture=neutral, PublicKeyToken=c7192dc5380945e7' o\nr one of its dependencies. The located assembly's manifest definition does not m\natch the assembly reference. (Exception from HRESULT: 0x80131040)\n   at TestBed.Program.Main(String[] args)\n. I wonder if it is caused by the assembly signing.\n. What I mean is Our Apps->Ninject 2.0.1->Extension->Ninject 2.0.0 - I think the extensions are looking for the signed 2.0.0 release\n. That test is now fixed and this issue should be resolved. I am getting all of the builds ready right now.\n. Pushed, but not released.\n. I have tried a few things with this issue. I need to look at it a little more. The options I have come up with so far kill the deferred resolution by counting.\n. Resolved in branch. Waiting for feedback before merging into master.\n. does this work for you?  Kernel.Load(new []{@\"C:\\FirstPath\",@\"C:\\SecondPath\"});\n. sorry, missed the wildcard @\"C:\\FirstPath.dll\",@\"C:\\SecondPath.dll\"\n. Does this work for you? I have tested it and it seems to work for me. http://gist.github.com/395563\n. Pushed:  http://github.com/ninject/ninject/commit/1ac23d444c1d480034f236643dc83cc7b86bfdd9\n. This works fine if you remove the line:\nkernel.Bind().ToConstant(kernel);\nWhy are you binding the kernel?\n-Ian\n. Fixed and pushed.\n. You can sign it yourself using the snk in the repository.\n. If you are using VS to build it yourself, just click the sign checkbox.\n. Closing this unless I get more feedback\n. Enabled in the build now.\n. This is happening because components are delay loaded. They are only created when they are used for the first time. This code tries to access the same component simultaneously from multiple threads before it is created so there is a race to create and add it.\n. Fixed and pushed\n. The issue is that both bindings are completely satisfiable and both are default bindings. The following bindings will work as you expect:\n```\npublic class Module : NinjectModule\n{\n    public override void Load()\n    {\n        this.Bind>().To();\n    this.Bind(typeof(IInjectable<>)).To(typeof(Injectable<>));\n    this.Bind(typeof(IInjectable<>)).To(typeof(StringInjectable))\n        .When(request => request.Service == typeof(IInjectable<string>));\n}\n\n}\n```\nConditional bindings take priority over default/explicit bindings. So if a conditional binding is satisfiable, it will use the conditional binding. I will be doing a blog post about it soon.\nThanks!\nIan Davis\n. Are you referring to the latest builds of Ninject? Over the last week or so we have been upgrading the resolution intelligence.\n-Ian\n. Please post questions like this to the mailing list.\n. Hi Oren,\nThanks for the impressive pull request. This will need to be discussed with the other project maintainers when they are back from their vacations. I am not sure if this is a direction we want to go as the portable libraries are a very poor solution that can't be extended. I realize our setup is far from ideal as well; Microsoft has very poor vision in this area.\n. I have reviewed the pull request from Oren, but I am a little unsure as to what adding a portable libraries to Ninject offers us. Whether the portable libraries are used or not,  we always need main Ninject dll in order for the system to work. It seems like all that is being done is adding another dll which isn't needed in order to isolate code that is platform invariant into its own library. The pull request is also missing all of the NAnt scripts which would be needed in order to make it work as part of the build (not to mention there are now 20+ extension projects whose references/scripts/builds/specs that would need to be updated).\nNinject currently supports the following platforms on our build server:\nmono-2.0\nmono-3.5\nmono-4.0\nnet-3.5\nnet-3.5_medium_trust\nnet-4.0\nnet-4.0_medium_trust\nnetcf-3.5\nsilverlight-2.0\nsilverlight-3.0\nsilverlight-4.0\nsilverlight-5.0\nOur build is so complex that we use csc rather than msbuild/xbuild. NAnt was chosen long before the build DSLs came out and we have had to extend NAnt in order to support our build targets. On our client machines, we build for even more platforms:\nmono-2.0\nmono-3.5\nmono-4.0\nnet-3.5-client\nnet-4.0-client\nnet-4.5\nnet-3.5_medium_trust\nnet-4.0_medium_trust\nnetcf-3.5\nsilverlight-2.0\nsilverlight-3.0\nsilverlight-4.0\nsilverlight-5.0\nsilverlight-4.0-wp7\nsilverlight-4.0-wp71\nWindows phone required the installation of VS Express when it came out and CodeBetter refuses to install VS on any build server (which I am happy about). In addition, compiling as a portable library in no way guarantees that the DLL works on all portable library platforms. They link against the same DLLs but have different behaviors. Expression trees, LINQ, and reflection behaviors vary on all of the platforms despite being binary compatible. This list of implementation differences between Silverlight and Silverlight for Windows Phone is terrifying (more information is also available). It took me weeks to find and fix a few lines of code in order to get Ninject working for WP7 as there was no unit testing capability for WP7 and testing using StatLight will not do anything to find bugs. The functionality can only be tested if you are running the code inside of the phone or emulator.\nForgive me if I am coming across like I have you in the crosshairs for Microsoft's choices. I am just trying to explain the history of how the build and projects are set up.\n@remogloor Refers to bugs, some of which can be found in our extensions\nNuGet doesn't support portable libraries directly, instead you just put the DLL into all of the supported framework folders. But we still need to then add our additional platform specific DLL into that folder as well.\nTo me, what would be helpful in VS is being able to have a single project, with many build targets, each one supporting on from the list of build platforms we support. Then, having conditional references which would select the reference with the corresponding build target (This is supported in MSBuild IIRC, but you have do manually compose it and use various MSBuild variables to enable/disable references).\nIf we use portable libraries, we now have two different DLL structures, build setups that we have to maintain as portable libraries doesn't cover our needs.\n. I agree with @danielmarbach that we should drop support for the older platforms, but I think we need to hold off portable libraries and the dropping of old platforms for 4.0. I also think that we should not merge this pull as it is only partially complete (merging it completely breaks our master).\nI wish @onovotny would have emailed us prior to posting NuGet packages for the portable libraries as we have already been hamstrung by MS people and the MVC3 package; we had to support complaints from its users, it didn't match our naming conventions or versioning. We didn't have a tag or knowledge of which commit it came from to diagnose any issue. It added a dependency that we had no intention of adding at the time as well (introducing in WebActivator). On top of that, the prolific MS blogger (S. H.) blogged with that package forcing us to stay with the lackluster package that was created (The creation of the blog post and package we planned as far as I can tell with complete disregard to the project maintainers).\nI am not trying to say that the two portable packages are crap like the original MVC3, I just wish we had been consulted as we have to deal with the ramifications. If/When we do support portable libraries, we are now stuck with trying to take over the packages or replace them, and deal with people trying to figure out which release is official.\n\n@onovotny :\nI know that xUnit is going 4.5 for their 2.0 version.\n\nI truly hope that they leave a 4.0 version. Very few people need to test async methods.\n-Ian\n. Any chance you can give an integration test or code sample?\nThanks!\nIan\n. http://msdn.microsoft.com/en-us/library/ff426930(v=vs.95).aspx#Reflection\n. What are you seeing that is slow enough to impact your application? Do you\nsee timeouts? Do you have slow response times? Is the the IoC container? Is\nthe IoC container being used improperly? Have you profiled your app to\nisolate the cause?\nI have never seen a valid case where the container, any container, was the\nactual cause of performance issues. Almost every issue I ever see is people\nmisusing the container. If someone presents an actual case where Ninject\nhas a real-world performance issue, I'd be happy to look into it. Until\nthen, it's all FUD and microbenchmarks.\n-Ian\nOn Tue, May 7, 2013 at 8:50 AM, martinkoslof notifications@github.comwrote:\n\nHmmmm, this topic seems to be gaining more momentum and I'm curious what\nspecific areas or \"advanced\" features are the most costly regarding\nperformance. For example we use Ninject heavily within an MVC application\nand most objects are Request scoped. We have leveraged some additional add\nins, such as Ninject.Extensions.Conventions and I'm ok with extensions and\nadvanced assembly scanning being \"slower\". In those scenarios, yes you are\nchoosing flexibility over performance (within reason).\nAre there particular things we should \"avoid\" with Ninject to help boost\nour performance? I'd really like to see more time or conversations around\nthis topic. We have been doing some heavy performance tuning recently and\nwe've already done a massive amount of Entity Framework/LINQ optimizations\nand Razor view pre-compilation, CSS and JS optimizations and now\nNinject/IOC is going to need to be evaluated as well.\nThanks\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/84#issuecomment-17550947\n.\n. I was referring to the thread in general; it wasn't directed at you and I'm\nsorry that wasn't clear. People have been clamoring for a long time about\nhow slow Ninject is, without any substantial claim that there is actually a\nproblem. The team I work on now uses Castle, and I really don't care. Use\nthe tooling that solves your needs.\n\n-Ian\nOn Tue, May 7, 2013 at 11:23 AM, martinkoslof notifications@github.comwrote:\n\nI'm not sure if your comments are directed towards me, or someone else in\nthe comments thread, but I'm not sure what nomenclature in my last post\nlead you believe I am having \"timeouts\", or that I'm misusing the IOC\nContainer. I also didn't say Ninject was slow/unusable to the point where\nmy application was worse off. There have been several bench-marking\narticles written and other people I talk to also have commented that\nNinject is \"slower\" then other IOC containers.\nIf 10 solutions exists and yours is deemed the slowest it doesn't mean its\ntime to stop using it...it means it is the SLOWEST of those tested. Yes,\nthere are many advantages and extensions to Ninject which I find useful\n(also noted in my comments). \"Real world performance\" also comes down to\nyour expectations. If you are trying to get as optimized as possible, and\nanother IOC container is x times faster the question isn't \"what's wrong\"\nbut \"how can this be faster as well\".\nI also didn't say Ninject was too slow for my existing MVC application.\nALL aspects are beening performance tested and tweaked and our IOC\nimplementation is going to be tested next. If another IOC container is\nfaster and provides all the functionality we currently use, we might switch\nover. Overall I find nothing about this topic irrational or riddled in FUD.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/84#issuecomment-17560428\n.\n. If I recall correctly, if you inject an IList or an array this is taken\ncare of.\n\n-Ian\nOn Mon, Apr 14, 2014 at 6:18 AM, Bruno Juchli notifications@github.comwrote:\n\nCurrently the IEnumerable which is injected will be \"lazy\" materialized\nwhen someone accesses it. This can lead to erratic behavior / deadlocks etc.\nPlease change it so that IEnumerable is backed by a materialized\ncollection which is \"eager\" materialized before injection.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/128\n.\n. I am in agreement with @danielmarbach. The usage/point of IEnumerable is based on lazy evaluation. IReadonlyCollection<T> is one option, but an array works just as well and you can initialize your collection from the array.\n. The DNS just had to be updated. It is fixed now.\n. Can you write an integration test that show's this behavior? In the meantime, would it be easier to just have an interface as a provider rather than injecting a Func?\n\nI'm a bit rusty, but this may be a problem in the planning pipeline.\n. Hi Matt,\nCan you try this:\n``` cs\npublic class MyModule : NinjectModule\n{\n    public override void Load()\n    {\n        Kernel.Components.RemoveAll();\n        Kernel.Components.Add();\n    }\n}\npublic class MySelector : Selector\n{\n    public override IEnumerable SelectConstructorsForInjection(Type type)\n    {\n       if(type.IsGeneric && type.GetGenericTypeDefinition.Name.StartsWith(\"Func`\"))\n       {\n            return null;\n       }\n       return base.SelectConstructorsForInjection(type);\n    }\n}\n```\nLoad that module into your kernel during initialization and it should bypass the IL emitting.\nCan you give that a try and let me know. I can't run the code right now to test.\n. You are most likely correct. I just typed that module code from memory. You can replace virtually all components that Ninject uses internally in order to customize the behavior you want in the system.\nIf you are ever up for it, take a look at a few of the extensions and you'll see that they use these kind of extension points in order to add their functionality.\n. ",
    "chillitom": "Yeah that's what I was seeing.. sorry, I should have pasted an exception too.\n. I saw it with assemblies that I built myself.  Those would be unsigned right?\n. ",
    "ammachado": "The same problem is happening in my machine when I try to build Ninject locally.  A test fail (Ninject.Tests.Integration.ModuleLoadingTests.WhenLoadIsCalledWithAssemblies.ModulesContainedInAssembliesAreLoaded), because there is a strong reference to Ninject 2.0.0 assembly in Ninject.Tests.TestModule.dll (located in src/Ninject.Tests/TestModules).\n. Just forgot, ... the source code of Ninject.Tests.TestModule.dll is not in the trunk\n. ",
    "Talljoe": "With the above change HandleMissingBindings can cause problems by creating an unconditional binding.  See tests and proposed change at:\nhttp://github.com/Talljoe/ninject/commit/733558f624f027c209fdd94926f19fd0c9fc0731\nThis makes a pretty bold decision by stripping out implicit bindings if there are any explicit bindings.  This is probably the correct behavior (no tests break), but perhaps we only want to do it when \"request.IsUnique\" (or not all, in which case the CanResolve change can't be included).\nWhat started off as a simple code change is turning into a fork, so I'll investigate non-patchy options but I think this is the best route.\n. There's a problem with your test, shield2 is actually of type \"Shield\" not \"Shield2\":\n    var shield2 = kernel.Get();\nChanging that to \".Get<Shield2>\" causes the test to pass (Talljoe/ninject@a9e8ba533f0bb2df0dafa2a1529f41b09be22630). The resolution of the default value happens in .Create() of the provider grabbing it from the current request so it should all work properly. \nThat being said, I've never been happy with IMissingBindingResolvers adding their bindings to the final list of bindings because of the chance for conflicts.  I didn't make that change when I first added IMBRs because it was a pretty large change to the resolution (it would likely break backwards compatibility with anyone that derives from KernelBase) so I worked around it with implicit bindings.  I'm better prepared to make the change so I'm willing to do it (or at least give the IMBRs the choice) if we want to take that hit.\nAlso, I've been working on an alternate implementation of this that creates the concept of an ITargetResolutionStrategy. See Talljoe/ninject@b98d72c8605ac410497ed7d46b3c758a04897bf4 for how that might play out (untested work in progress).  I like this idea because it would also be a great place to park my configuration-based resolver.\n. Bah, clicked the wrong button.\n. It does seem that the behavior has changed. \nhttps://github.com/ninject/ninject/commit/453be1c1549bfd39bd77d5c6e41b809917012569#L2L65\nI think this was done so that classes with ambiguous constructors would still get created. It's probably incorrect with regards to the [Inject] attribute.  One solution is to do something like this:\nvar directiveList = directives.ToLookup(option => Selector.ConstructorScorer.Score(context, option))\n                                      .OrderByDescending(g => g.Key)\n                                      .First();\n        if (directiveList.Key == Int32.MaxValue && directiveList.Count() > 1)\n            throw new NotSupportedException(\"Too many constructors!\");\n        var directive = directiveList.First();\nBut it turns MaxValue into a magic number. To fix this proper would take some re-architecture. It may just be easiest to say that if there is more than one [Inject] attribute the behavior is undefined.\n. Ninject.Web and Ninject.MVC[1-3] will automatically dispose of the objects at the end of the request. To release a single object you can call kernel.Release(<object>) which will search all of the caches for that object.  It looks like there's no convenience method to release all objects in a context, so if you're not using Ninject.Web you can release those instances with:\nkernel.Components.Get<ICache>().Clear(HttpContext.Current);\n. I'm not entirely sure about 2.2.  The current trunk code will do it deterministically at the end of the request.\n. Always a great question. :) No ETA currently.\n. ",
    "keff85": "OK, so I made a fix in my fork: http://github.com/keff85/ninject/commit/4b3637dfefdcbeb4cde8651ceb9d940826f373cb\n\"NInject forgets that RelativeSearchPath can be compound path, this is a hack \nthat uses just BaseDirectory when a compound path is encountered.\nThis is a hack, Ninject should either offer no option to look for plugins in \nRelativeSearchPath, or accept that user can have several RelativeSearchPaths, \nand Ninject's one is just one of them.\"\n. Hi idavis, yes, it does, perfectly - thank you!\n(and I also appreciate the elegance of yields :))\n. Thanks, works perfectly, so I deleted my fork.\n. ",
    "hpebley3": "This is different from v1.5 where circular dependencies worked when Using<SingletonBehavior> was used. If this is a feature and not a bug, it should probably be included in the breaking behavior documentation.\n. ",
    "remogloor": "We must distinguish the possible circular references. \n- If they are on the constructor its technically not possible to resolve. Its not possible to create a Foo that requires a Bar in the constructor which itsself requires a Foo in the constructor.\n- If they are on properties Ninject can handle them.\n- The mixed case constructor and property is tricky. It the one with property is created first Ninject can handle. If the constructor injected object is created first Ninject can not. The second case is technically possible but would require a major change in the implementation (Activation after everything is created). \n. The stackoverflow is not caused by ninject, but by your implementation. The request has no circular dependency. Ninject can resolve the ITwoWayConstructor. Performing more getrequests in a constructor is a very bad thing. If an object requires more dependencies they should be added to the constructor parameters instead. \n. Also for Silverlight and Mono, \n. Integration tests for SL and WP7 have been added. But they can not be executed on TC because it requires the permission to open a port.\nOpen tasks:\n- Mono Integration and Unit tests\n- SL Unit-Tests\n- Tests running on TC\n. Added to 2.2\n. Done\n. Named only adds the name to the bindings metadata. The constraint is done when the binding is resolved. In this example no constraint is given and both bindings are valid. In such a scenario either add a name for all bindings or give a constraint such as specifying that you want the one with name == null.\n. Fixed in build 2.1.0.70\n. I was able to reproduce this issue. I'll fix it soon.\n. Fixed in 2.1.0.80\n. Implemented in 2.1.0.85\n. Hi\nWe analized the problem and found that the solution is much simpler. Check the latest build. It should fix the problem.\n. First of all thanks for your help and contribution. I defenately appriciate to add additional unittests around this topic. But, I do not like the tests as they are at the moment because they show a way how it should not be done. Just one example, many others have the same problem: MatchedConstructorInstanceIsReused\nIn this unittest the scope of the warrior is set to its weapon. But the warrior references the weapon. This means ninject will release the warrior as soon as no one references its weapon. But as the warrior himself references the weapon this will never happen. In other words this results in a memory leak.\n. It seems a bit more complicated. E.g immagine the case where IAmNothing is self bindable or an open generic in these case you want to have the constructor with parameter.\nIn other words this needs a bigger change so I'll postpone this to the next release as I do not want to add major changes anymore.\n. Thanks for your contribution. I'll check and pull it as soon as I have created the development branche for the next release.\n. Hi Joe\nI did a short review of your implementation. There is a problem it the implementation. It is a bad idea to use a missing binding resolver because this creates a new binding. See the attached unit test. It shows that a default value creates a new binding that is used for all resolves that are done later. This creates unexpected behaviors in some scenarios. In the example below I created two shield implementations using different default values. The first default parameter wins and is used for all other classes as default value. I think we need some change in KernelBase for this feature.\n```\n    [Fact]\n    public void DefaultValuesShouldNotInflunceInjectionsToOtherTypes()\n    {\n        using (IKernel kernel = new StandardKernel())\n        {\n            kernel.Bind().ToSelf();\n            kernel.Bind().ToSelf();\n        var shield1 = kernel.Get<Shield>();\n        var shield2 = kernel.Get<Shield>();\n\n        shield1.ShouldNotBeNull();\n        shield1.Color.ShouldBe(ShieldColor.Red);\n\n        shield2.ShouldNotBeNull();\n        shield2.Color.ShouldBe(ShieldColor.Orange); // This check fails because it is red\n    }\n}\n\npublic class Shield2\n{\n    public Shield2([DefaultParameterValue(ShieldColor.Orange)] ShieldColor color)\n    {\n        Color = color;\n    }\n\n    public ShieldColor Color { get; set; }\n}\n\n```\n. Sry my fault. I looks ok. I'll do some minor clean up (e.g. one I remember is that some comments do not match the method implementation) and push it to the ninject repo.\n. Thats already possible request.Service.Name\n. That's technically not possible. And I can't see any situation where you need to know that. I think you try to do something that should be done in another way.\n. Update NuGet to 1.1\n. That's exaxtly the expected behavior. The named constraint is used for the first level. For other levels you have to mark the constructor argument using the NamedAttribute or use one of the When overloads.\n. Regarding the first question: Ist simply not possible. Get with a name adds a the constraint \"give me an instance where the binding is named x\" to the request. But as you only hava an unnamed binding nothing will match and an exception is thrown. Furthermore as I already said there are better ways to control which instance is injected to the first level object.\nRegarding the second post: I don't understand what you want to do. But I think there is a design smell. Attached properties are not really intended to pass complicated objects. Furthermore business logic dosn't belong to this level so complicated object structures shouldn't be used at xaml level. And as you already said they are not created by Ninject so they are not under it's control and no mechanism can be used to inject something at all.\n. Fixed. Constructor must be uniquely defined now.\n. 1. It is technically not possible to get to implementation type because of several overloads e.g. ToMethod and ToProvider return some unknown type whose only requirement is that it implements the type of the binding. Furthermore, they can even return several types e.g. ToMethod(ctx => IsSunday ? new SundayImplementation() : new WeekdayImplementation()). So whats the implementation type in this scenario?\n2. I still do not see any scenario that requires to know the implementation type. Ninject is a big factory which is responsible to put classes together. The only time the implementation must be known is internally in Ninject at the time of resolve.\nUnless you can show any valid scenario that requires lookup of the implementation type no action will be taken.\n. No the situation is still the same. It's not possible to tell what's the implementation for several binding types e.g. ToMethod and ToProvider \n. Fixed in https://github.com/ninject/ninject/commit/2da3d01b4896d60c091958e0a6fe4e1db9d46d54\n. Ninject.Web and Ninject.Web.MVC[1-3] 2.2 already dispose all instances in request scope at the end of a request. ETA is hard to tell as it highly depends on how much time we can put into the project. But there is not a lot left until Beta/RC1.\n. SL is more restrictive than .Net. You have to expose your class as public.\n. This seems to be a reflection issue in mono. Without having the involved\nclasses and interfaces this can not be reproduced. Please add the involved\nclasses and interfaces (IConfig, ConfigProvider, object created by Config\nProvider)\n2011/10/10 Joo Silva \nreply@reply.github.com\n\nC#\nKernel.Bind<IConfig>().ToProvider<ConfigProvider>();\nCauses a NullReferenceException on Mono. On Windows works fine. I'm using\nNinject 2.2.1.0 for mono (2.2.1.4 from nuget throws same expcetion) and Mono\n2.10.5.\nIConfig, DynamicConfig and ConfigProvider are simple classes. I can post\nthem here if you want.\nstacktrace:\nUnhandled Exception: System.NullReferenceException: Object reference not\nset to an instance of an object\n at\nNinject.Infrastructure.Language.ExtensionsForMemberInfo.GetParentDefinition\n(System.Reflection.MethodInfo method, BindingFlags flags) [0x00000] in\n:0\n at\nNinject.Infrastructure.Language.ExtensionsForMemberInfo.GetParentDefinition\n(System.Reflection.PropertyInfo property) [0x00000] in :0\n at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.IsDefined\n(System.Reflection.PropertyInfo element, System.Type attributeType, Boolean\ninherit) [0x00000] in :0\n at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.HasAttribute\n(System.Reflection.MemberInfo member, System.Type type) [0x00000] in\n:0\n at Ninject.Selection.Heuristics.StandardInjectionHeuristic.ShouldInject\n(System.Reflection.MemberInfo member) [0x00000] in :0\n at\nNinject.Selection.Selector+c__AnonStorey29.<>m__4A\n(IInjectionHeuristic h) [0x00000] in :0\n at System.Linq.Enumerable.AnyIInjectionHeuristic [0x00000] in :0\n at Ninject.Selection.Selector.m__47\n(System.Reflection.PropertyInfo p) [0x00000] in :0\n at\nSystem.Linq.Enumerable+c__Iterator1D1[System.Reflection.PropertyInfo].MoveNext\n() [0x00000] in <filename unknown>:0\n at\nSystem.Collections.Generic.List1[System.Reflection.PropertyInfo].AddEnumerable\n(IEnumerable1 enumerable) [0x00000] in <filename unknown>:0\n at\nSystem.Collections.Generic.List1[System.Reflection.PropertyInfo].AddRange\n(IEnumerable1 collection) [0x00000] in <filename unknown>:0\n at Ninject.Selection.Selector.SelectPropertiesForInjection (System.Type\ntype) [0x00000] in <filename unknown>:0\n at Ninject.Planning.Strategies.PropertyReflectionStrategy.Execute (IPlan\nplan) [0x00000] in <filename unknown>:0\n at Ninject.Planning.Planner+<GetPlan>c__AnonStorey28.<>m__44\n(IPlanningStrategy s) [0x00000] in <filename unknown>:0\n at\nNinject.Infrastructure.Language.ExtensionsForIEnumerableOfT.Map[IPlanningStrategy]\n(IEnumerable1 series, System.Action1 action) [0x00000] in <filename\nunknown>:0\n at Ninject.Planning.Planner.GetPlan (System.Type type) [0x00000] in\n<filename unknown>:0\n at Ninject.Activation.Providers.StandardProvider.Create (IContext context)\n[0x00000] in <filename unknown>:0\n at Ninject.Activation.Context.Resolve () [0x00000] in <filename unknown>:0\n at Ninject.KernelBase.<Resolve>m__55 (IContext context) [0x00000] in\n<filename unknown>:0\n at\nSystem.Linq.Enumerable+<CreateSelectIterator>c__Iterator102[Ninject.Activation.IContext,System.Object].MoveNext\n() [0x00000] in :0\n at\nSystem.Linq.Enumerable+c__Iterator01[NInjectTest2.ConfigProvider].MoveNext\n() [0x00000] in <filename unknown>:0\n at System.Linq.Enumerable.Single[ConfigProvider] (IEnumerable1 source,\nSystem.Func2 predicate, Fallback fallback) [0x00000] in <filename\nunknown>:0\n at System.Linq.Enumerable.Single[ConfigProvider] (IEnumerable1 source)\n[0x00000] in :0\n at Ninject.ResolutionExtensions.GetConfigProvider [0x00000] in :0\n at\nNinject.Planning.Bindings.BindingBuilder1[NInjectTest2.IConfig].<ToProvider1>m__33ConfigProvider [0x00000] in :0\n at Ninject.Planning.Bindings.Binding.GetProvider (IContext context)\n[0x00000] in :0\n at Ninject.Activation.Context.GetProvider () [0x00000] in :0\n at Ninject.Activation.Context.Resolve () [0x00000] in :0\n at Ninject.KernelBase.m__55 (IContext context) [0x00000] in\n:0\n at\nSystem.Linq.Enumerable+c__Iterator102[Ninject.Activation.IContext,System.Object].MoveNext\n() [0x00000] in <filename unknown>:0\n at System.Linq.Enumerable.Single[Object] (IEnumerable1 source,\nSystem.Func2 predicate, Fallback fallback) [0x00000] in <filename\nunknown>:0\n at System.Linq.Enumerable.SingleOrDefault[Object] (IEnumerable1 source)\n[0x00000] in :0\n at\nNinject.Planning.Targets.Target1[System.Reflection.ParameterInfo].GetValue\n(System.Type service, IContext parent) [0x00000] in <filename unknown>:0\n at\nNinject.Planning.Targets.Target1[System.Reflection.ParameterInfo].ResolveWithin\n(IContext parent) [0x00000] in :0\n at Ninject.Activation.Providers.StandardProvider.GetValue (IContext\ncontext, ITarget target) [0x00000] in :0\n at\nNinject.Activation.Providers.StandardProvider+c__AnonStorey3.<>m__B\n(ITarget target) [0x00000] in :0\n at\nSystem.Linq.Enumerable+c__Iterator102[Ninject.Planning.Targets.ITarget,System.Object].MoveNext\n() [0x00000] in <filename unknown>:0\n at System.Collections.Generic.List1[System.Object].AddEnumerable\n(IEnumerable1 enumerable) [0x00000] in <filename unknown>:0\n at System.Collections.Generic.List1[System.Object]..ctor (IEnumerable1\ncollection) [0x00000] in <filename unknown>:0\n at System.Linq.Enumerable.ToArray[Object] (IEnumerable1 source) [0x00000]\nin :0\n at Ninject.Activation.Providers.StandardProvider.Create (IContext context)\n[0x00000] in :0\n at Ninject.Activation.Context.Resolve () [0x00000] in :0\n at Ninject.KernelBase.m__55 (IContext context) [0x00000] in\n:0\n at\nSystem.Linq.Enumerable+c__Iterator102[Ninject.Activation.IContext,System.Object].MoveNext\n() [0x00000] in <filename unknown>:0\n at\nSystem.Linq.Enumerable+<CreateCastIterator>c__Iterator01[NInjectTest2.Engine].MoveNext\n() [0x00000] in :0\n at System.Linq.Enumerable.SingleEngine [0x00000] in :0\n at System.Linq.Enumerable.SingleEngine [0x00000]\nin :0\n at Ninject.ResolutionExtensions.GetEngine [0x00000] in :0\n at NInjectTest2.Program.Main (System.String[] args) [0x00000] in :0\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ninject/ninject/issues/39\n. Fixed in 2.3.0.58\n. If the assembly is built correctly this exception is not possible because the Ninject.Infrastructure.Language.ExtensionsForMemberInfo.ParentDefinitionMethodInfo property is explicitly excluded by a compiler directive. \n\nThis leads to the question where exactly do you have the Ninject assembly from?\n. Fixed using ReaderWriterLock instead of permanent locking.\n. Sure. This is planned for the next major release (4.0).\n2011/12/19 shartte <\nreply@reply.github.com\n\nGood idea using a read write lock in this situation.\nAlthough I would plan to replace this with a ConcurrentDictionary when the\nminimum .NET version for Ninject is bumped to 4 (which may take a while ;-).\nWhen it is bumped to 3.5, I would use the included ReadWriteLockSlim\ninstead of the copied implementation.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ninject/ninject/pull/40#issuecomment-3209343\n. This code makes no sense. What it should do it throw some kind of exception\n\nYou have to bindi either an open generic interfac to an open generic implmentation or a cloased generic interface to a closed generic implementation.\nkernel.Bind<ISomething<string>>().To<StringThing>();\n. Please use the current master instead of the previous release. It is in release candidate state for 3.0. All Unit tests are running in Ninject 3.0 for all mono versions 2.0, 3.5 and 4.0. No bugfixes will be done anymore for 2.2\n. Hi Urs\nWhat happens if you Update Contextpreservation first? This should also update Ninject because it is a dependency. \nIt could also be a problem of NuGet itsself since a new installation seems not to cause any problems.\n. I don't want to do such changes anymore for the release. If there is no serious issue then rc3 is the final version for 3.0.0.\n. Without the stachtrace there is not much we can do. So please add the stacktrace of the exception that you get.\n. This is a limitation of the Silverlight framework. Unless Microsoft decides that invocation of private methods/properties using reflection is allowed there is nothing we can do.\n. Ninject has no support for field injection because this is considered as a bad practice. See https://github.com/ninject/ninject/wiki/Changes-in-Ninject-2 i suggest you use constructor injection instead.\nIf you want to do private field injection against all advices not to do so then you can add support the same way as the property injection is done.\n. Please use the mono build instead of the .net build\n. Thanks for submiting this pull request. I'll review and pull it. But\nit will take some time because I'm busy atm\nVon meinem iPhone gesendet\nAm 19.04.2012 um 16:33 schrieb Jason Walker\nreply@reply.github.com:\n\nThis code is very similar to how the Microsoft.CSharp.CSharpCodeGenerator formats types, but it strips namespaces and uses curly braces instead of angle braces to enclose generic arguments.\nI added some unit tests, though I'm not sure they are in the format that you guys want/use for the rest of the project.\nIt's a bit more complicated than I first expected, but it needs to be to handle the many nuances that exist.\nHope it helps,\n~jw\nYou can merge this Pull Request by running:\ngit pull https://github.com/ungood/ninject master\nOr you can view, comment on it, or merge it online at:\nhttps://github.com/ninject/ninject/pull/53\n-- Commit Summary --\n- Resolved issue #52\n- Allow Format(Type) to handle anonymous types\n-- File Changes --\nM src/Ninject.Test/Ninject.Tests.csproj (1)\nA src/Ninject.Test/Unit/FormatTests.cs (95)\nM src/Ninject/Infrastructure/Introspection/FormatExtensions.cs (121)\n-- Patch Links --\nhttps://github.com/ninject/ninject/pull/53.patch\n https://github.com/ninject/ninject/pull/53.diff\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ninject/ninject/pull/53\n. Which Ninject Version did you use.\n. Fixed in 3.0.1\n. Can you explain why you think mono requires the hashset?\n. You have  to use the medium trust build from google code instead of the nuget version or build Ninject with MEDIUM_TRUST.\n. You have  to use the medium trust build from google code instead of the nuget version or build Ninject with MEDIUM_TRUST.\n. This would require that a medium trust package is published for each extensions referencing this medium trust ninject core package. This is far more than I am willing to do. But if you want to do this then go on. Just make sure you keep it up do date when new packages are released.\n. Changed build scripts\n. You have to create a new instance of the module for each kernel.\n. I'll look into this implementation. The only concern I have about the portable class lib is how you work around the bugs of the various .NET frameworks. Each .NET version has its own problems. So I assume it is not possible to call the portable class lib function for some functionallities unless they have fixes inside the protable class lib. But I hardly believe that this is  the case.\n\n@davkean Can you elaborate on this? The worst bug I know of is getting the attributes of properties. Any framework is acting differently any none acts correctly so far. Is portable class lib helping in some way with such problems?\n. his issue still needs a demonstration sample.\n. I really don't know if I even want to fix such a bug in case it should still exists. \nNested classes are really not meant to be used outside of the parent class. And therefore I don't see any situation where I want to inject such a class into another. This just seems to be a very bad design imo. \nCan anyone give me a real example to convince me this has a good use?\n. Thanks for that bug report. The code of that special part is quite\ndifferent for the various .NET frameworks Can you please add exactly\nwhat version you are using? It would help enormously to find the\nproblem.\n. Fixed in https://github.com/ninject/ninject/commit/4a49c51e789e3be80413ecb26994eb1d1927750f\n. Thanks for reporting the bug. The implementation seems perfect. \nWould you mind changing the whitespaces in the code from tab to spaces so that I can pull it in github?\n. Will be changed on the next major release.\n. Added correctly spelled method and marked current as obsolete.\n. The hash code is used for better performance while storing/finding objects. Without hash code a full scan of all objects has to be done whenever an object is created or destroyed.\n. It would work, but RuntimeHelpers.GetHashCode will require a new instance of ReferenceEqualWeakReference whenever the cache is checked for the existence of the object (2-4 instances of ReferenceEqualWeakReference atm). This would have some impact to the performance because new objects are expensive.\nI have to think about if there is some other way to get the same result.\n. Fixed in ddbb323ec286f44665068f18bed203b044c6703f\n. What's the intension of this? Binding configurations are additive. All your declarations are added so the order should not matter.\n. closed because on reason was given why this should be useful\n. I still do not see why the order matters. When module A defines components that requires dependencies that are defined in a module B it does not matter if A is loaded before B or after B.\n. so you do kernel.Get() in a module?\n2013/1/7 lucajulian notifications@github.com\n\nOk this is true, but if module A need an istance of module B, module B\nmust be loaded before module A.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/71#issuecomment-11953880.\n. Unfortunatly the .NET Framework WP7.X itsself is very buggy when it comes\nto reflection of types with generic methods. If I remember correctly I'd\nexpect\n\ntypeof(Derivate).GetMethods()\nto throw. Seems like we have to find another workaround for the buggy WP\nreflection implementation.\n2012/12/12 zver notifications@github.com\n\nBug reproduction:\nClass hierarchy :\npublic interface IEntity\n{\nvoid DoWork();\n}\npublic interface IBase\n{\n    void Foo() where A : IEntity;\n}\npublic abstract class Base : IBase\n{\n    public abstract void Foo() where A : IEntity;\n}\npublic class Derivate : Base\n{\n    public override void Foo()\n    {\n    }\n}\nDependency registration:\nIKernel Kernel = new StandardKernel();\nKernel.Bind().To();\n// In next line an \"System.MethodAccessException\" exception is thrown\nvar instance = Kernel.Get();\nBug description:\nCode does not work ONLY on Windows Phone 7.5 platform, but works fine on\nWindows Phone 8. I didn't test it on other platforms.\nCode does not work ONLY when generic type \"A\" is interface.\nMy package version:\nThank you guys for this great framework!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/72.\n. No.\n\nBe aware that you can easily implement your own IConstructorArgument implementation that keeps a weak reference to the object instead of the object itsself.\n. Not a bug - Use mailing list for questions\n. If you just look at the performance of the IoC container then those performance tests are correct. What none of them does is to investigate what's the actual impact on a real application. \nE.g. If I add the MiniProfiler to an ASP.NET MVC application that doesn't even have and db access. I can see on my computer that the impact of the IoC container is far less than 10% rather around 1% or even less. This impact makes it not even worth thinking about what IoC container to use because if you get to the point where you have performance issues you will so with all other IoC containers as well.\nNinject has some unique features like conditional bindings and scoping to the lifetime of other objects that cost a lot of performance. Removing them would boost Ninject by magnitudes. But then we have just the features of any of the tiny DI frameworks. Without those features there would be no reason to continue the development of Ninject anymore. Because you can take many others. Therefore we prefer to keep those advanced features and take the disadvantage of beeing slower.\nWhat would be possible though is to do a complete rewrite of the resolving mechanism to do precalculated resolves for all those subtrees that do not use any conditional bindings. But that would be a huge work. Many other things have a higher priority.\nSure the current implementation has potential for improvment too but you will never get near the tiny DI frameworks.\nIn conclusion. You have to choose what matters more. Squeezing out the last 1% of additional performance or to pay a bit and get more advanced features.\n. Do you have many implementations of one or more interfaces and bind them with conditional bindings or are these all unique servie types?\n. Feel free to use this on your own risk if performance is highly important:\nhttps://github.com/ninject/ninject/tree/PerformanceTryouts\nhttps://teamcity.bbv.ch/viewType.html?buildTypeId=bt7&branch_Ninject=PerformanceTryouts&tab=buildTypeStatusDiv\n. 1. Happens when using Ninject 3.5 from 4.0+ => not an issue, use correct build\n2. Can't see and relation to Ninject\n3. Can't reproduce with the imformation given so far\n4. Was fixed, use latest version\n5. There is a special medium trust Ninject build\nExcept 3 these are all not valid issues. For 3 I haven't seen this happen so I can't do anything unless enough information is provided to reproduce this issue.\n. Fixed in https://github.com/ninject/ninject/commit/5e0d8730d8f2d3b66e12f2c18a29ce8aefadf48a\n. Implemented in https://github.com/ninject/Ninject.Web.Common/commit/55829c27699e434fcaa1168514b1cce0f8241f03\n. I think you missunderstood my comment.\nThe implementation works correctly for generic types. For normal classes it will fail. Adding the tests for generic types was good though, Those for normal classes are still missing.\n. We're close to release 3.0.2.\nCan you get this fixed so that we can add it to that release?\n. build is still failing:\n2013/8/3 Andr\u00e9 Matos notifications@github.com\n\nCan you please test and check if everything is ok now?\nCheers!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/pull/94#issuecomment-22058120\n.\n. https://teamcity.bbv.ch/viewLog.html?buildId=3055&tab=buildResultsDiv&buildTypeId=bt7\n\n2013/8/3 Remo Gloor remo.gloor@gmail.com\n\nbuild is still failing:\n2013/8/3 Andr\u00e9 Matos notifications@github.com\n\nCan you please test and check if everything is ok now?\nCheers!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/pull/94#issuecomment-22058120\n.\n. login as guest\n\n\n2013/8/3 Andr\u00e9 Matos notifications@github.com\n\nI've executed the unit tests locally and they passed... Can't see anything\non that url. Don't have username & password to access\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/pull/94#issuecomment-22058228\n.\n. Not a bug.\n\nYour heuristic selects properties with either no setter method or a none public setter with none public member injection disabled.\n. Better place this issue here:\nhttps://github.com/onovotny/ninject\nThis won't be adressed here until it WinRT is supported in this repository.\n. Try https://teamcity.bbv.ch/viewLog.html?buildId=3146&tab=artifacts&buildTypeId=bt7\nThis probably solves the problem. Be aware though that switching from locking the binding to locking the scope can have side effects I havn't thought of. But I'm quite positive that it should not have one. At least when not referencing shorter living scopes which is a problem in itsself. Test it well before going into production.\n. Not a bug. Implementation Type must be newable.\nUse Bind().To()\n. Replaced by https://github.com/ninject/ninject.web/issues/13\n. Won't fix\nThis is a limitation of the caching/scoping strategy. Implementations are not allowed to have a strong reference to the scope. You can fix this issue by weak referencing HttpContext in your wrapper.\n. Any solution I can think of is odd or has disadvantages:\n- We could restrict constructor arguments to transient objects. Because this is the only scope that makes sense with them. But I'm sure we get an issue from some ServiceLocator like user soon asking to remove that restriction.\n- We could return different instances when the argument does not match. But I'm sure we have the next issue soon telling that the scope is ignored when using constructor arguments.\n- We could throw an exception on the second resolve. But this will use a lot additional performance since Arguments can be inherited so that we will have to check the whole tree in this case.\nUnless someone has a good solution or very good arguments I do not see any reason to change this. It is up to the user to make sure he uses the only scope that makes sense with constructor arguments which is transient.\n. Not a bug.\nSeems like a security issue that your pulgin is not allowed to scan for assemblies. Most likely this is caused by the automatic extension loading. Thry to create Ninject with extension loading disabled.\nnew StandardKernel(new NinjectSettings() { LoadExtensions = false });\n. I strongly suggest not to use ActivationBlocks. This will be obsolete in future anyway since its concept is fundamentally broken. I won't invest the time anymore to fix this issue which is a natural result of this concept. If someone else thisnks this is important enough then go ahead.\nI don't know MassTransits Ninject implementation. But I think it should be changed to something similar like the NServiceBus implementation.\n. Not a bug\nThe test requests a\nICalculate<IValue>.\nNinject is configured to return \nMultiplyCaculate<IValue>.\nBut IValue does not fulfill the restriction of DoubleValue. You must get a \nICalculate<DoubleValue>\n. Can't reproduce.\n\u00a8\nSteps done:\n- New Console App\n- Install Ninject.Web.WebApi.SelfHost\n- Install Ninject.Extensions.Wcf.Selfhost\n=> No App_Start\nAll none IIS hosting Nuget packages can be installed iwthout an App_Start file\n. First, I don't see any problem in switching these lines.\nBut if you really have a circular reference in the cache then you most likely have a bigger problem than just that it throws during GC. You should think about your scopes again.\n. Attributes are created by the .NET Framework. There is no way to controll how many times they are created.\nAlso I do not even see a situation where you would want it to be created multiple times. What Ninject does is to scan  each type for constraint attributes once and it caches this information for future resolves. It then calls Matches foreach resolve.\nI don't consider this a bug but the intended behavior. If you have another use case then open a feature request that explains why you want a different behavior.\n. Have a look at Ninject.Extensions.WCF. What you are doing is implemented there already so that you do not have to do a hack.\nWhat you are asking for isn't possible due to .NET limitations, I can pass a System.Type to a constructor argument of the type ISomeInterface.\n. Merged and fixed implementation.\nPlease update release notes and the documentation in the wiki.\n. I'm mergin this without testing because its just a new solution and project that won't affect the other builds. But I won't make an official release before I have the time to test.\n. Won't implement\nUse either Named bindings or a generic IPresenter\n. I won't implement this feature because it is not implementatble for all\ncases properly: E.g. here are some of the cases that can become problematic\n    1. There are more bindings than just To<>. For other binding types the\nimplementation type is unknown until an instance is created e.g. ToMethod,\nToProvider,\n    2. The constructor value type is not known for lazy configured\nConstructorArguments. It could even change for different contexts e.g.\nreturning an int if the first constructor argument is an int or a string if\nthe first constructor argument is a string.\n    3. ConstructorArguments can be inherited to be applied deeper in the\nobject tree. Many of the classes in that tree won't even have an instance\nthat can take the ConstructorArgument leading to ActivationExceptions\nbecause none matching binding can be found.\n    4. Conficts with Conditional Bindings\nThis needs special knowledge about what you intend to do. And all that is\nrequired is already there so that it is quite simple in the configuration:\nkernel.Bind(x => x\n       .FromThisAssembly().SelectAllClasses().InheritedFrom()\n    .BindAllInterfaces()\n    .Configure((b, c) => b.Named(c.Name.Replace(\"Presenter\", \"View\")));\nkernel.Get(view.GetType().Name, new ConstructorArgument(\"view\",\nview));\nThe only thing that I would offer is to make the Type on\nTypeMatchingConstructorArgument available public so that you can do\nkernel.Bind(x => x\n       .FromThisAssembly().SelectAllClasses().InheritedFrom()\n    .BindAllInterfaces()\n    .Configure((b, c) => {\n       var constructorParameterType =\nc.GetConstructors().Single().GetParameters().Single().ParameterTypehttp://msdn.microsoft.com/de-de/library/system.reflection.parameterinfo.parametertype(v=vs.110).aspx\n;\n       b.When(ctx =>\nctx.Parameters.OfType().Any(p\n=> p.Type == constructorParameterType))\n    });\nkernel.Get(new TypeMatchingConstructorArgument(view));\n2014/1/24 Darren Horrocks notifications@github.com\n\nusing Named binding could be replicated with 2 small classes added to any\nproject, and is essentially coupling the classes through a string rather\nthan through C# code. Seems that ninject is missing what would be a vital\nfeature in true decoupling and proper DI.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/120#issuecomment-33222022\n.\n. Already fixed\n. Won't fix\n\nActivationBlock will be removed or at least marked obsolete with 4.0.\nThe desired behavior can be achieved with the named scope extension.\nhttps://github.com/ninject/ninject.extensions.namedscope/wiki/CreateNamedScope-and-GetScope\n. can't apply atm\nsilverlight does not compile anymore\n. Ninject 4.0 will drop support for .NET < 4.0 (and therefore Mono < 4.0)\nsupport so that we can use concurrent collections. For .NET 3.5 application\nwe will keep bugfixing Ninject 3.x but not add any new features.\n2014-05-06 10:35 GMT+02:00 Jesper Kamstrup Linnet notifications@github.com\n:\n\n@remogloor https://github.com/remogloor I can see from the 4.0.0 branch\nthat support for the older versions of Mono (< 4.0) has been removed.\nWhat is your attitude towards this pull request? If it is deemed feasible\nI will gladly redo the changes to target the 4.0.0 branch instead.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/pull/126#issuecomment-42278352\n.\n. I think this can only happen in two situations:\n1. You spawn another thread during resolve of an object e.g. with a Ninject provider or ToMethod binding that creates a new Thread and calls kernel Get in that thread.\n2. You do two resolves (A and B) and in each of them there are two scopes (X, Y) involved. Request A needs scope X first and B Y first. So they can lock each other.\n\nThe first cast is very special case which needs to handled differntly. E.g. inject a Lazy so that it is resolved at different times.\nThe second case is simple wrong usage of Ninject which will cause you other problems during runtime. The two scopes X an Y do not have the same lificycle. If an object in one scope lets say X requires an object in the other scope Y then this means the scope Y is longer living than X. And this means there can't be an object with scope Y that requires an object in scope X.\nOr in a more practical scenario. If you have an object in a request scope it can reference a singleton service. But a singleton service can never depend on a request scoped object.\nSo please check if either of these scenarios applies to your problem. Otherwise tell me what scenario I missed.\n. When do you use the factories? \nWhen they are called outside of the constructor then they do a independent resolve and should not cause any problem. When you call them in the constructor they belong to the same resolve. \nIf the second case applies I suggest not to switch threads during the resolve but instead resolve in the same thread and start a new thread in one of the classes.\nIf possible then add a sample that demonstrates your problem. It's hard to understand it without any code.\n. Do you still have this problem? If yes then please answer my previous question otherwise close the issue.\n. It would help a lot if you can provide a sample application that demonstrates the problem.\n. The only way I can think of this can happen is when the WebApiModule is not loaded for some reason. If that module is not loaded then there must something be wrong in your App_Start.\n. Do you still have this problem or can I close this issue?\n. Fixed in Ninject.Web.Common 3.2.2\n. Fixed in Ninject.Web.Common 3.2.2\n. Do you use \nNinject.Web.Common 3.2.2\n. An instance is just activated once on the first resolve. Which happens to be\nctx.Kernel.Get<FootSoldier>()\nAll further activations are prevented by the activation cache. I think the current behavior is the intended behavior since you don't know what the Get will return. E.g. It could be a singleton and I don't think that a singleton should change just because someone decides to get it through another bind to method.\nIn your case the binding does not exist explicitly. But it is still gererated automatically.\nI consider it the correct behavior atm and not a bug.\n. You can easily opt out of this behavior by removing the IActivationCacheStrategy btw.\n. Works as intended. You have a dependency cycle. Nothing we can to there without an extremely high effort to build a new .NET like GC I'm not willing to spend. \nB is kept in the cache until A is garbage collected. But A is used by B so it will not ba garbage collected as long as B does not release that reference or is garbage collected itself what will not happen because  it is referenced by the cache.\nYou seem to have a design problem. Try to break the dependency cycle and the problem will disappear. \n. @iappert \nI haven't verified but i think you will now ignore circular dependencies for generics completely. e.g.\nA -> Foo<int> -> A\nwill lead to a stack overflow instead of an activation exception.\n. This will get you a stackoverflow exception:\n```\n    [Fact]\n    public void DetectsCyclicDependenciesForGenericServiceRegisteredViaOpenGenericType2()\n    {\n        kernel.Bind(typeof(IGeneric<>)).To(typeof(GenericServiceWithGenericConstructor<>));\n    Action act = () => kernel.Get<IGeneric<int>>();\n\n    act.ShouldThrow<ActivationException>();\n}\n\npublic class GenericServiceWithGenericConstructor<T> : IGeneric<T>\n{\n    public GenericServiceWithGenericConstructor(IGeneric<T> arg)\n    {\n    }\n}\n\n```\n. There are special medium trust builds available from teamcity:\nhttps://teamcity.bbv.ch/viewLog.html?buildId=5525&buildTypeId=bt7&tab=artifacts\n. ",
    "danielmarbach": "Hy Ian,\nSorry for me that is really lame. Removing the key is considered a breaking change. Open source project which themselves are strong named and are referencing the strong named ninject need to custom build ninject for their purpose. You don't need to rebuild the extensions for every commit you are doing. Make feature releases and then release the new compiled versions of the extensions. With TeamCity this could even be automated.\nDaniel\n. Hy Ian,\nDon't get me wrong. I don't want to offend you. My comment was maybe a bit too harsh...\nDaniel\n. Investigating\n. Was not able to reproduce the bug. The following test passes with latest revision:\npublic class NinjectServiceLocatorTest\n{\n    [Fact]\n    public void ShouldResolveWithoutNameBeingGiven()\n    {\n        var kernel = new StandardKernel();\n        kernel.Bind<IWeapon>().To<Sword>();\n        var locator = new NinjectServiceLocator(kernel);\n        var weapon = locator.GetInstance<IWeapon>();\n        weapon.ShouldNotBeNull();\n        weapon.ShouldBeInstanceOf<Sword>();\n    }\n}\nThe following test passes as expected:\npublic class NinjectServiceLocatorTest\n{\n    [Fact]\n    public void ShouldNotResolveWithoutNameBeingGiven()\n    {\n        var kernel = new StandardKernel();\n        kernel.Bind<IWeapon>().To<Sword>();\n        kernel.Bind<IWeapon>().To<Shuriken>();\n        var locator = new NinjectServiceLocator(kernel);\n        Assert.Throws<ActivationException>(() => locator.GetInstance<IWeapon>());\n    }\n}\nThe following test passes as expected:\npublic class NinjectServiceLocatorTest\n{\n    [Fact]\n    public void ShouldResolveWithoutNameBeingGiven()\n    {\n        var kernel = new StandardKernel();\n        kernel.Bind<IWeapon>().To<Sword>();\n        kernel.Bind<IWeapon>().To<Shuriken>().Named(\"Shuriken\");\n        var locator = new NinjectServiceLocator(kernel);\n        var weapon = locator.GetInstance<IWeapon>();\n        weapon.ShouldNotBeNull();\n        weapon.ShouldBeInstanceOf<Sword>();\n    }\n}\nPlease recheck and reopen if necessary!\nDaniel\n. Yeah but this is the desired behavior. Look if you do\nvar kernel = new StandardKernel();\n        kernel.Bind<IWeapon>().To<Sword>().Named(\"sword\");\n        var w = kernel.Get<IWeapon>();\nthat throws an ActivationException by design. You named the binding so ninject does look for an unnamed binding in your test. And there is no unnamed binding which would fulfill the request and therefore an ActivationException is thrown.\n. Correct. Maybe that helps:\nhttp://groups.google.com/group/ninject/browse_thread/thread/3f26e37c160bf82e\n. Just to clarify things. You mean:\npublic class InjectMe\n{\n    [Inject]\n    public ISomeInterface PublicPrivateProperty\n    {\n        get;\n        private set;\n    }\n}\n?\n. Hello\nWas able to reproduce the issue. When you don't apply the inject attribute ninject behaves like expected. Here is a temporary fix:\nSet the InjectNonPublic property on the Settings to true. Then it works with your code above and the Inject attribute.\n. Pushed and fixed with latest commit c768c550fdd498f4f29e\n. Hello\nForget my last comment. This makes sense! For InjectMeChild the setter of PublicPrivateProperty of base can never be seen because it is private! Change it to protected and InjectMeChild will also get ISomeInterface injected. I will push a test which shows that behavior\n. Please see: http://github.com/ninject/ninject/commit/09d46ef6613503060f663795380399b5cad2c5bc\n. I see your point. I think this feature would rarely be ever used. From this point of view it makes no sense to integrate it. From your point of view I see that when Inherited is set to true on the InjectAttribute and InjectNonPublic is set to true you expect ninject to inject dependencies into base classes also. I think we need to discuss this... I'm split\n. Sorry for not having replied sooner. I understand what you mean. I just don't have the responsibility to take this decision. Ian Davis and Nate are the bright heads behind this project. We need to see what Ian's opinion is. But in the meantime just fork and apply your changes and use your fork if you desperately need it. Ian can then review your changes and incorporate it when necessary.\nDaniel\n. In the meantime you can apply the changes from Remo Gloor into your branch. He has done it already!\n. Looks good! Will discuss this with Remo and then apply hopefully next week.\n. Fixed implementation. Didn't compile!\n. If I understand correctly with the new API changes this should be possible. And also with the convention extension we have the ability to auto scan for consumers\n. Hy all,\nRegarding the build infrastructure. In my point of view it is time to drop some plattforms. As .NET 4.5 is now publically available I would start dropping older plattforms like:\nMono-2.0 \nmono-3.5\nnet-3.5\nnet-3.5_medium_trust\nsilverlight-2.0\nsilverlight-3.0\nand we can even think about dropping CF3.5 support. That doesn\u2019t solve the build complexity but gives as more speed to move forward.\nDaniel\nFrom: Ian Davis [mailto:notifications@github.com] \nSent: Freitag, 31. August 2012 02:58\nTo: ninject/ninject\nSubject: Re: [ninject] Portable Class Library support for Ninject (#65)\nI have reviewed the pull request from Oren, but I am a little unsure as to what adding a portable libraries to Ninject offers us. Whether the portable libraries are used or not, we always need main Ninject dll in order for the system to work. It seems like all that is being done is adding another dll which isn't needed in order to isolate code that is platform invariant into its own library. The pull request is also missing all of the NAnt scripts which would be needed in order to make it work as part of the build (not to mention there are now 20+ extension projects whose references/scripts/builds/specs that would need to be updated).\nNinject currently supports the following platforms on our build server:\nmono-2.0\nmono-3.5\nmono-4.0\nnet-3.5\nnet-3.5_medium_trust\nnet-4.0\nnet-4.0_medium_trust\nnetcf-3.5\nsilverlight-2.0\nsilverlight-3.0\nsilverlight-4.0\nsilverlight-5.0\nOur build is so complex that we use csc rather than msbuild/xbuild. NAnt was chosen long before the build DSLs came out and we have had to extend NAnt in order to support our build targets. On our client machines, we build for even more platforms:\nmono-2.0\nmono-3.5\nmono-4.0\nnet-3.5-client\nnet-4.0-client\nnet-4.5\nnet-3.5_medium_trust\nnet-4.0_medium_trust\nnetcf-3.5\nsilverlight-2.0\nsilverlight-3.0\nsilverlight-4.0\nsilverlight-5.0\nsilverlight-4.0-wp7\nsilverlight-4.0-wp71\nWindows phone required the installation of VS Express when it came out and CodeBetter refuses to install VS on any build server (which I am happy about). In addition, compiling as a portable library in no way guarantees that the DLL works on all portable library platforms. They link against the same DLLs but have different behaviors. Expression trees, LINQ, and reflection behaviors vary on all of the platforms despite being binary compatible. This list of implementation differences between Silverlight and Silverlight for Windows Phone http://msdn.microsoft.com/en-us/library/ff426930(v=vs.95).aspx  is terrifying (more information http://msdn.microsoft.com/en-us/library/gg597392.aspx  is also available). It took me weeks to find and fix a few lines of code in order to get Ninject working for WP7 as there was no unit testing capability for WP7 and testing using StatLight http://statlight.codeplex.com/  will not do anything to find bugs. The functionality can only be tested if you are running the code inside of the phone or emulator.\nForgive me if I am coming across like I have you in the crosshairs for Microsoft's choices. I am just trying to explain the history of how the build and projects are set up.\n@remogloor https://github.com/remogloor  Refers to bugs, some of which can be found in our extensions https://github.com/ninject/ninject/blob/master/src/Ninject/Infrastructure/Language/ExtensionsForMemberInfo.cs \nNuGet doesn't support portable libraries directly, instead you just put the DLL into all of the supported framework folders. But we still need to then add our additional platform specific DLL into that folder as well.\nTo me, what would be helpful in VS is being able to have a single project, with many build targets, each one supporting on from the list of build platforms we support. Then, having conditional references which would select the reference with the corresponding build target (This is supported in MSBuild IIRC, but you have do manually compose it and use various MSBuild variables to enable/disable references).\nIf we use portable libraries, we now have two different DLL structures, build setups that we have to maintain as portable libraries doesn't cover our needs.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/ninject/ninject/pull/65#issuecomment-8179690 . \nhttps://github.com/notifications/beacon/TUqL6p7Xz6SF-_dIEJ1YBI1s17woHAIDlWa6TxYBgrqgNkvnVfMxuJDKjddSK59k.gif \n. Fixe in 4d2e6218d5eec0440402bdef839aa9b5d44fe280\n. Provide an abstract example so that we can understand your use case\nAm 07.01.2013 um 17:13 schrieb lucajulian notifications@github.com:\n\nThe code is not exactly what you wrote but the final effect is the same. In my case I pass the kernel to a factory that instantiates objects (with custum logics) that need some binds that have already been registered.\n\u2014\nReply to this email directly or view it on GitHub.\n. @remogloor could you blog this planetgeek?\n\nAm 28.02.2013 um 23:10 schrieb Remo Gloor notifications@github.com:\n\nIf you just look at the performance of the IoC container then those performance tests are correct. What none of them does is to investigate what's the actual impact on a real application.\nE.g. If I add the MiniProfiler to an ASP.NET MVC application that doesn't even have and db access. I can see on my computer that the impact of the IoC container is far less than 10% rather around 1% or even less. This impact makes it not even worth thinking about what IoC container to use because if you get to the point where you have performance issues you will so with all other IoC containers as well.\nNinject has some unique features like conditional bindings and scoping to the lifetime of other objects that cost a lot of performance. Removing them would boost Ninject by magnitudes. But then we have just the features of any of the tiny DI frameworks. Without those features there would be no reason to continue the development of Ninject anymore. Because you can take many others. Therefore we prefer to keep those advanced features and take the disadvantage of beeing slower.\nWhat would be possible though is to do a complete rewrite of the resolving mechanism to do precalculated resolves for all those subtrees that do not use any conditional bindings. But that would be a huge work. Many other things have a higher priority.\nSure the current implementation has potential for improvment too but you will never get near the tiny DI frameworks.\nIn conclusion. You have to choose what matters more. Squeezing out the last 1% of additional performance or to pay a bit and get more advanced features.\n\u2014\nReply to this email directly or view it on GitHub.\n. By the way guys Remo Gloor is in Vacation for the next two weeks and will not be very responsive. Just that you know.\n\nFrom: Andrew Armstrong [mailto:notifications@github.com] \nSent: Montag, 19. August 2013 13:20\nTo: ninject/ninject\nCc: danielmarbach\nSubject: Re: [ninject] Fix resolution performance issues (#84)\n97 https://github.com/ninject/ninject/issues/97  is interesting, as part of my load testing - using a mix of transient and singleton scopes only - I sometimes seemed to get deadlocks (CPU was 0%, but IIS threads were all backed up).\n@ssakharov https://github.com/ssakharov  do you think #97 https://github.com/ninject/ninject/issues/97  would also affect non-request scopes?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/ninject/ninject/issues/84#issuecomment-22865183 .  https://github.com/notifications/beacon/TUqL6p7Xz6SF-_dIEJ1YBOhUabR9ydt1W40Pm-MlRvmKOwG8eLIeCTi_up2eIggv.gif \n. The major pain point we currently have is that ninject\u2019s architecture allows to add bindings during the runtime. That is why it requires locks. Of course there are rooms for improving this performance as you guys already spotted but if we could somehow change the kernel internally so that it builds up a \u201creadonly\u201d kernel we wouldn\u2019t require locks and this would dramatically improve the performance. We would like to build this without breaking the public API and behavior. So the current kernel would need to build up a readonly internal kernel and as soon as someone adds a binding after that build up it would throw away that one and rebuild the whole readonly kernel plus that new binding. \nFrom: Andrew Armstrong [mailto:notifications@github.com] \nSent: Montag, 19. August 2013 13:20\nTo: ninject/ninject\nCc: danielmarbach\nSubject: Re: [ninject] Fix resolution performance issues (#84)\n97 https://github.com/ninject/ninject/issues/97  is interesting, as part of my load testing - using a mix of transient and singleton scopes only - I sometimes seemed to get deadlocks (CPU was 0%, but IIS threads were all backed up).\n@ssakharov https://github.com/ssakharov  do you think #97 https://github.com/ninject/ninject/issues/97  would also affect non-request scopes?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/ninject/ninject/issues/84#issuecomment-22865183 .  https://github.com/notifications/beacon/TUqL6p7Xz6SF-_dIEJ1YBOhUabR9ydt1W40Pm-MlRvmKOwG8eLIeCTi_up2eIggv.gif \n. We thought about having a readonly kernel. Similar like you described it but determined by the kernel class you instantiate. That certainly improve perf. By the way there is a performance branch remo did. You can try out that. The largest issues are actually around conditional bindings. There is almost no way you can precompute and cache them. So not onky users would not be able to add bindings when the kernel has all bindings loaded and is armed but also no conditionals. Urs and I did a lot of evangelizing internally it and looks like we got budget to get more love into ninject. We'll keep you posted\n\nAm 16.01.2014 um 07:21 schrieb BrunoJuchli notifications@github.com:\nDuring boot-up phase we are frequently adding bindings. The boot-up phase can last several seconds. With our bootstrapping we do (or should) know when all bindings are completed but this is certainly after ninject has already handled quite a few requests.\nSo i would suggest that the kernel initially has a modifiable \"binding repository\" which is then converted to an unmodifiable \"binding repository\" on an external call .Snapshot(). Like .Compact() on a database ;-)\nAdvantages:\nfull backwards compatibility if one doesn't call Snapshot()\nninject does not need some elaborate code to find out at which time it makes sense to convert the \"binding repository\" to an unmodifiable one\nconverting from an unmodifiable to a modifiable repository might be costly?\nDrawbacks:\nuser cannot Snapshot then add bindings again. Or one adds support for that, but would make implementation more complex.\nOf course even this does not work without locking completely. But instead of locking read-access to the \"binding repository\" one can lock Snapshot() vs write-access to \"binding repository\" (i.E. creating a binding).\nFor most applications binding resolving is probably executed far more often then binding creation, the change should thus result in a performance improvement.\n\u2014\nReply to this email directly or view it on GitHub.\n. Forgot to mention:\n\nAnother approach would be to stripp out the binding builder from the kernel. The user uses the binding builder and passes the built bindings to the kernel. The kernel never modifies those.\n\nAm 16.01.2014 um 07:21 schrieb BrunoJuchli notifications@github.com:\nDuring boot-up phase we are frequently adding bindings. The boot-up phase can last several seconds. With our bootstrapping we do (or should) know when all bindings are completed but this is certainly after ninject has already handled quite a few requests.\nSo i would suggest that the kernel initially has a modifiable \"binding repository\" which is then converted to an unmodifiable \"binding repository\" on an external call .Snapshot(). Like .Compact() on a database ;-)\nAdvantages:\nfull backwards compatibility if one doesn't call Snapshot()\nninject does not need some elaborate code to find out at which time it makes sense to convert the \"binding repository\" to an unmodifiable one\nconverting from an unmodifiable to a modifiable repository might be costly?\nDrawbacks:\nuser cannot Snapshot then add bindings again. Or one adds support for that, but would make implementation more complex.\nOf course even this does not work without locking completely. But instead of locking read-access to the \"binding repository\" one can lock Snapshot() vs write-access to \"binding repository\" (i.E. creating a binding).\nFor most applications binding resolving is probably executed far more often then binding creation, the change should thus result in a performance improvement.\n\u2014\nReply to this email directly or view it on GitHub.\n. You guys know that there is a feature branch with perf improvements and we are working on more improvements\nAm 04.04.2014 um 23:18 schrieb Andrew Armstrong notifications@github.com:\nSimple injector, had near feature parity and was benchmarked as one of the fastest (google for IOC benchmarks .net) \nSent from my iPhone \n\nOn 5 Apr 2014, at 7:44 am, Michael Aird notifications@github.com wrote: \n@Plasma out of curiousity, what did you switch to? \n\u2014 \nReply to this email directly or view it on GitHub.\n\u2014\nReply to this email directly or view it on GitHub.\n. What about conditional bindings?\n\n\nFrom: Lukas Waslowski [mailto:notifications@github.com] \nSent: Freitag, 12. Juni 2015 23:12\nTo: ninject/Ninject\nCc: Daniel Marbach\nSubject: Re: [Ninject] Fix resolution performance issues (#84)\n@BrunoJuchli https://github.com/BrunoJuchli  @scott-xu https://github.com/scott-xu\nI'm very in favor of something like .Snapshot(), because that's what it is really wanted. Automatic change detection would be even better, e.g. using optimistic version numbers, see below.\nMost of the time in Resolve() is probably spent in searching for matching bindings to the constructor, and then searching for matching bindings for the parameters of those bindings, and so on.\nThe current process goes like this (I'm concentrating on constructor injection using StandardProvider for now):\n1.   https://github.com/cr7pt0gr4ph7/Ninject/blob/pull-request/old-kernel/src/Ninject/KernelBase.cs KernelBase.Resolve: \n-   Looks for a binding that matches in the current context\n-   Creates an instance of Ninject.Activation.Context and calls Context.Resolve() \n1.   https://github.com/cr7pt0gr4ph7/Ninject/blob/pull-request/old-kernel/src/Ninject/Activation/Context.cs Context.Resolve \n-   Determines the scope by looking at the request or, if the former has no associated scope, the matching binding (using IBinding.ScopeCallback, passing in the current context).\n-   Lock on the scope and call Context.ResolveInternal \n1.   https://github.com/cr7pt0gr4ph7/Ninject/blob/pull-request/old-kernel/src/Ninject/Activation/Context.cs Context.ResolveInternal (executed while a lock on the scope is held!): \n-   Queries Ninject.Activation.Caching.ICache to get the already activated instance for the current scope\n-   Gets the provider that matches the current context (using IBinding.ProviderCallback)\n-   Call IProvider.Create(IContext) \n1.   https://github.com/cr7pt0gr4ph7/Ninject/blob/pull-request/old-kernel/src/Ninject/Activation/Providers/StandardProvider.cs StandardProvider.Create: \n-   ...uses the ConstructorScorer to select an appropriate constructor, thus yielding an ConstructorInjectionDirective.\n-   ...get the injection targets (i.e. the constructor arguments) from the ConstructorInjectionDirective and call StandardProvider.GetValue to resolve them, which in turn: \n-   Looks if the context contains an IConstructorArgument,\n-   Or, if not, calls ITarget.ResolveWithin.\n1.   https://github.com/cr7pt0gr4ph7/Ninject/blob/pull-request/old-kernel/src/Ninject/Planning/Targets/Target.cs Target.ResolveWithin \n-   Calls IRequest.CreateChildRequest, and\n-   IKernel.Resolve(IRequest) to resolve the request.\nSo, to improve performance, many information from the steps above can be cached:\n1.  KernelBase.Resolve \n-   Look for an ICachedActivationPlan for the given type and context, which already contains: \n-   The binding to activate.\n-   The ICachedActivationPlan instances for the parameters required by the binding.\n1.  Context.Resolve \n-   (Use a special case for the transient scope that avoids a delegate call to ScopeCallback when the is always returning null anyway (e.g. via delegate == null)?).\n-   Do not take a coarse lock here; instead, take more granular locks in Context.ResolvIInternal.\n1.  Context.ResolveInternal \n-   For non-scoped singletons: \n-   Note that locks are taken on this instance of ICachedActivationPlan \n-   Note that the cached instance for a binding is stored in an instance field of ICachedActivationPlan, which is protected using the double-null-check idiom (see below):\n-   For transient bindings: \n-   No locking of the cachedInstance field needed.\n-   Bindings with custom scopes (e.g. HttpContext): \n-   These currently pose a problem.\n1.  StandardProvider.Create \n-   Determine the constructor to be used at the time when ICachedActivationPlan is created.\n-   For each constructor parameter, use the binding for that injection target that is already cached in the ICachedActivationPlan, and also represented as an ICachedActivationPlan.\nFor change detection, one could use an optimistic versioning approach, such that a counter is incremented whenever the kernel transitions from \"unmodified\" to \"dirty\". This way, binding caches (that contain instances of ICachedActivationPlan) can check \"their\" version number with the current one, and only update their data (on take a lock on the kernel's data structures) when really necessary.\nThe main point is to cache the activation plan for a binding, and let it contain pointers to other activation plans for other related binding, such that searches in the internal datastructures are avoided, as well as avoiding coarse locks over the whole kernel / the whole scope / a certain binding, even when viewed from different scopes.\n@BrunoJuchli https://github.com/BrunoJuchli \nI've got a version that contains the latest changes from #142 https://github.com/ninject/Ninject/pull/142 , but excludes the readonly kernel, over at [https://github.com/cr7pt0gr4ph7/Ninject/tree/pull-request/old-kernel], if you want to experiment with the design as it was before the introduction of IReadonlyKernel.\n\nDouble null check\nif (instance == null) {\n    lock (this) {\n        if (instance == null) {\n            instance = new ...();\n         }\n    }\n}\n\u2014\nReply to this email directly or view it on GitHub https://github.com/ninject/Ninject/issues/84#issuecomment-111620284 .  https://github.com/notifications/beacon/AAKossRA7SN0JvomQPdG15yWwoTGJMs9ks5oS0KPgaJpZM4Acfx5.gif \n. Interesting read http://ayende.com/blog/164739/immutable-collections-performance\nFrom: Lukas Waslowski [mailto:notifications@github.com] \nSent: Freitag, 12. Juni 2015 23:38\nTo: ninject/Ninject\nCc: Daniel Marbach\nSubject: Re: [Ninject] Fix resolution performance issues (#84)\nOne idea for realizing snapshots would be to use  https://www.nuget.org/packages/System.Collections.Immutable/ System.Collections.Immutable, smartly combining immutable collections and their builders, so that locks can be completely avoided in the fast path.\nThe idea would be that, at the start of the resolution operation, the current state of the kernel's data structures is stored in the IRequest (or IContext, maybe) and passed down to child resolution operations.\nModifcations of the kernel are done by swapping out the pointer to the data structure using an atomic operation (note that loading and setting variables that contain a pointer to a reference type is always done atomically according to the CLR specification http://www.ecma-international.org/publications/standards/Ecma-335.htm ./.object references are\nPossibly problematic is the scenario of concurrent modifications, but this could be avoided by taking a lock only for threads wishing to modify the IKernel. The other problematic area is the resolution cache, see my comment above for more information.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/ninject/Ninject/issues/84#issuecomment-111625581 .  https://github.com/notifications/beacon/AAKospzoeTvRQu62n2pFVrfP4sUDcomBks5oS0jCgaJpZM4Acfx5.gif \n. As far as I know there is a special medium trust build here:\nHttp://teamcity.bbv.ch\nLogin as guest and goto the project ninject2, pick the release build you want, click on artifacts -> there you go!\nDaniel\nAm 16.08.2013 um 18:21 schrieb inderids notifications@github.com:\n\nis switching to Unity for medium trust is the only solution ??? \nIs there anybody who can tell me how to use Ninject with medium Trust ???\n\u2014\nReply to this email directly or view it on GitHub.\n. Do you have:\n\n[assembly: AllowPartiallyTrustedCallers]\nIn the Global.asax :\nINinjectSettings settings = new NinjectSettings\n{\nUseReflectionBasedInjection = true, // disable code generation for partial trust\nInjectNonPublic = false, // disable private reflection for partial trust\nInjectParentPrivateProperties = false, // reduce magic\nLoadExtensions = false // reduce magic\n};\nIKernel kernel = new StandardKernel(settings);\n?\nAm 16.08.2013 um 18:21 schrieb inderids notifications@github.com:\n\nis switching to Unity for medium trust is the only solution ??? \nIs there anybody who can tell me how to use Ninject with medium Trust ???\n\u2014\nReply to this email directly or view it on GitHub.\n. This is expected. You are resolving twice on the main thread therefore subsequent calls return same object and ignore any ctor args on get request. When you resolve on another thread your test would work\nAm 04.10.2013 um 11:54 schrieb pajo notifications@github.com:\nI'm not really sure if this is issue or not, but it looks like it could be. I was doing some testing how instance are resolved in thread scope and I found something interesting. To keep it short here is test code\npublic class AppContext : IAppContext\n{\npublic AppContext(Guid id)\n{\nthis.Id = id;\n}\npublic Guid Id { get; private set; }\n}\npublic interface IAppContext\n{\nGuid Id { get; }\n}\n// Test\nKernel.Bind().To().InThreadScope();\nvar app1Id = Guid.NewGuid();\nvar app1 = Kernel.Get(new Ninject.Parameters.ConstructorArgument(\"id\", app1Id));\nvar app2Id = Guid.NewGuid();\nvar app2 = Kernel.Get(new Ninject.Parameters.ConstructorArgument(\"id\", app2Id));\napp1.Id.Should().Be(app1Id);\napp2.Id.Should().Be(app2Id);\nIt turns out second test fails, when IAppContext is resolved first time any subsequent call to resolve IAppContext will return first instance. Can someone shed a light if this is expected behavior and why it should be?\n\u2014\nReply to this email directly or view it on GitHub.\n. I question this so called unit test and therefore also the issue about opening access to the bindings. Imagine what happens go your test as soon as you introduce extensions such as conventions, factory etc. You fhen have a lot of automatic bindings and simply checking whether a binding is there provides almost now  value when you use complex scoping, conditional bindings or even ninject parameters.\n\nWrite a specification which builds up your whole system except boundaries (use rebind for that) and execute your major use cases on top of it. If your system is modularized correctly you can also think about only testing one module instead of the whole system\n\nAm 07.10.2013 um 03:55 schrieb James Rhodes notifications@github.com:\nWe currently have an extension method:\n/// <summary>\n    /// Get all of the types bound in the kernel.\n    /// </summary>\n    public static Type[] GetBindings(this IKernel kernel)\n    {\n        return ((Multimap<Type, IBinding>)typeof(KernelBase)\n            .GetField(\"bindings\", BindingFlags.NonPublic | BindingFlags.Instance)\n            .GetValue(kernel)).Select(x => x.Key).ToArray();\n    }\nWe use this in unit tests to verify that all bindings in a kernel are correctly resolved and that there are no missing dependencies. It would be great if this functionality was exposed on the standard kernel so we don't need to resort to reflection to access a private field (which is liable to break in future versions of Ninject).\n\u2014\nReply to this email directly or view it on GitHub.\n. Have you tried removing InTransientascope?\nAm 14.10.2013 um 22:14 schrieb aaronasmith notifications@github.com:\nI'm not sure if this is the intended behavior or not, but when a constant is bound into the kernel and then is injected into an object resolved from an activation block it will dispose of that constant and continue to inject it into further objects.\nA trivial example is included below. I would expect Foo to not be disposed on the second call to Get but it is.\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var kernel = new StandardKernel();\n        kernel.Bind().ToSelf();\n        var foo = new Foo();\n        kernel.Bind().ToConstant(foo).InTransientScope();\nusing (var activationBlock = kernel.BeginBlock())\n    {\n        var bar = activationBlock.Get<Bar>();\n    }\n    using (var activationBlock = kernel.BeginBlock())\n    {\n        var bar = activationBlock.Get<Bar>();\n        Console.WriteLine(bar.Foo.IsDisposed);\n    }            \n}\n}\nclass Bar : IDisposable\n{\n    public Foo Foo { get; set; }\n    public Bar(Foo foo)\n    {\n        Foo = foo;\n    }\n    public void Dispose()\n    {\n}\n}\nclass Foo : IDisposable\n{\n    public void Dispose()\n    {\n        IsDisposed = true;\n    }\npublic bool IsDisposed { get; set; }\n}\n\u2014\nReply to this email directly or view it on GitHub.\n. What is the reason you need blocks? Usually we tried to avoid them with proper scoping\nAm 15.10.2013 um 00:30 schrieb aaronasmith notifications@github.com:\nYes. I've also tried singleton and anything else I could think of. It seems to ignore these when using the activation block.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah but you really want to change that? It is a public metadata interface. This would be a massive breaking change. I see no value doing that for just an unsexy interface.\nMy 2 cents\nAm 26.11.2013 um 07:47 schrieb iappert notifications@github.com:\nThe interface IParameter defines to many members with respect to its usage. Member \"Name\" is unnecessary and can be moved to its decendedants. E.g. a constructor argument using type as matching criteria does not need a name.\n\u2014\nReply to this email directly or view it on GitHub.\n. Here a summary of what I discussed with Ivan:\n\nMy opinion is that it makes sense to have the name on the interface. BUT the name should only give information about the name of the parameter which can be pretty stable for certain parameters or a combination of the parameter name together with an internal information (i.ex. such as a typename used internally). The Name should not be used to reflect things as constructor argument names. Specific code which looks for ConstructorArgumentParameters should use the information directly available on that type such as a property ArgumentName.\nFrom: iappert [mailto:notifications@github.com] \nSent: Dienstag, 26. November 2013 08:27\nTo: ninject/ninject\nCc: danielmarbach\nSubject: Re: [ninject] Clean up interfaces IParameter and its decendants (#113)\nIt depends. I don't want to do it for release 3.x, but I think it feasible for a release 4.x.\nThe problem is that this interfaces forces/leads to NotSupportedException implementations resulting in code degradation. Cleaning up the interface in Ninject is done in no time. I am aware of a dependency in the NamedScope extension, but I'd need more time to do a thorough analysis.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/ninject/ninject/issues/113#issuecomment-29272169 .  https://github.com/notifications/beacon/TUqL6p7Xz6SF-_dIEJ1YBD9hedPkS9m03nnIn42ALO6K35je-WyxqaDL4Acf0Qmv.gif \n. Use Named Scope and you get that feature.\nFrom: Darren Horrocks [mailto:notifications@github.com] \nSent: Freitag, 24. Januar 2014 09:41\nTo: ninject/ninject\nSubject: Re: [ninject] Bind().To() based on constructor argument type (#120)\nSetting the constructor argument type does not work also.\nIKernel kernel = new StandardKernel();\nkernel.Bind().To().WithConstructorArgument(typeof(int));\nkernel.Bind().To().WithConstructorArgument(typeof(long));\nkernel.Bind().To().WithConstructorArgument(typeof(string));\nITest t = kernel.Get(new Parameter(\"i\", 1, true));\nStill returns all 3 concrete classes even though each one has a different constructor argument type. I think the feature i requested is sort of the entire point of dependency injection, removing the entire need to couple objects. naming objects and setting hard coded constructor types is just coupling the classes, just in a less obvious way.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/ninject/ninject/issues/120#issuecomment-33205796 .  https://github.com/notifications/beacon/174258__eyJzY29wZSI6Ik5ld3NpZXM6QmVhY29uIiwiZXhwaXJlcyI6MTcwNjA4NTY2OCwiZGF0YSI6eyJpZCI6MjQxMDczNzJ9fQ==--eb3455e4a08c9ad828dfdae29e01443178fd9dee.gif \n. I think we should obsolete it immidiately. I use obsolete fody to provide migration path between semvers in mspec\n\nAm 05.04.2014 um 08:53 schrieb Daniel Little notifications@github.com:\nAs Remo Gloor says:\nWithin an activation block each bindings is changed to have the activation block as scope. This means the scope specified on the binding will be ignored. Exactly one instance will be created for resolves on one activation block. The feature flawed by ignoring all kind of other scopes like InSingletonScope.\n\u2014\nReply to this email directly or view it on GitHub.\n. You can either use namedscope or callscope for that. Documentation is old but should be still valid. I've built pretty complex applications with mixed lifetime requirements over the last 4 years and have used all available scoped but never needed activationblock\nAm 06.04.2014 um 10:02 schrieb Daniel Little notifications@github.com:\nCreating binding that share an instance over the lifetime over a unit of work is a very useful thing to have (http://nblumhardt.com/2011/01/an-autofac-lifetime-primer/). I'm not sure what you recommend to do instead (possibly named scopes?) however the documentation all seems to be out of date in this area.\n\u2014\nReply to this email directly or view it on GitHub.\n. The problem is that way you are esentially redefining the semantics of IEnumerable! An IEnumerable is only evaluated when iterated. The currwnt behavior maked total sense from a usage perspectiv\nAm 14.04.2014 um 16:08 schrieb Bruno Juchli notifications@github.com:\nYes i would agree. Still this is a pitfall for bugs.\nAlso using collectionis as a workaround is a tiny bit smelly: i don't ever want to add or remove items to / from that collection.\n(we (Erowa AG / Marco Erni,...) have also already had a discussion about this with @remogloor).\nMaybe support for IReadOnlyCollection could also be added to ninject?\n\u2014\nReply to this email directly or view it on GitHub.\n. Or constrain the syntax...\nAm 22.07.2014 um 18:05 schrieb Bruno Juchli notifications@github.com:\nOk i think i got it now. Are you telling us, that the OnActivation part after a .ToMethod() is never ever executed?\nIf that's the case one could argue whether that is a plausible / desired behavior. But at least i would expect ninject to throw an exception @ OnActivation() in case it does not work (NotSupportedException \"for ToMethod..\", throw @ binding time, not at resolution time).\n\u2014\nReply to this email directly or view it on GitHub.\n. Could you guys align on line endings and spacing or seperate changes from code formatting? Kinda hard to follow what changed otherwise\nAm 04.09.2014 um 07:13 schrieb Ivan Appert notifications@github.com:\n@remogloor I implemented a fix for this issue. Could you review my changes? Link to commit: iappert@1d0121b\n\u2014\nReply to this email directly or view it on GitHub.\n. Just make your ctrl+e+f spree in seperate commit ;)\nAm 04.09.2014 um 08:07 schrieb Ivan Appert notifications@github.com:\nSorry for that. Habbits...\nI added the following test:\n```\n[Fact]\npublic void OpenGenericBindingsWithDifferentGenericParametersCanBeAggregated()\n{\n    kernel.Bind(typeof(IGeneric<>)).To(typeof(Bla<>));\n    kernel.Bind().To();\n    kernel.Bind().To();\nvar service = kernel.Get<IGeneric<IServiceA>>();\n\nservice.Should().NotBeNull();\n\n}\n```\n\u2014\nReply to this email directly or view it on GitHub.\n. You can replace the default module loader in the kernel component list with your own.\n\nOn 10 Aug 2014, at 20:46, faridprogrammer notifications@github.com wrote:\n\nHello. \nI have run a asp.net MVC 3 project with latest version of ninject.\nI get Security exception within this method\nprivate static AppDomain CreateTemporaryAppDomain()\n    {\n        return AppDomain.CreateDomain(\n            \"NinjectModuleLoader\",\n            AppDomain.CurrentDomain.Evidence,\n            AppDomain.CurrentDomain.SetupInformation);\n    }\ni use this config in my web.config\n<trust level=\"Medium\"/>\nIs there any solution for this problem?\nI have temporary removed whole temporaryAppDomain creation parts.\n\u2014\nReply to this email directly or view it on GitHub.\n. Correct. And then just copy paste the AssemblyCheckercode into yours and replace the component\nAm 10.08.2014 um 22:14 schrieb faridprogrammer notifications@github.com:\nI think i only need to change IAssemblyNameRetriever component? is that right?\n\u2014\nReply to this email directly or view it on GitHub.\n. Repo and cname entry is still correct. Could be an issue of github nameserver or domain registrar. I have no idea who owns the domain and has paid for it\nAm 10.01.2015 um 10:45 schrieb Scott Xu notifications@github.com:\n@remogloor @danielmarbach , any updates?\n\u2014\nReply to this email directly or view it on GitHub.\n. @BrunoJuchli I'm glad that my comments are plain wrong ;)\n\nLook at the links you provided. The sole purpose of IEnumerable is to expose a GetEnumerator method. Only when the enumerator is accessed by design the enumeration and thus first materialization should happen. Yes correct my argument is coming from LINQ and its design philosophies that's correct. But if you look at the larger .NET ecosystem and what the history and introduction of LINQ taught us is that enumerables cannot be assumed materialized thus it is a perfectly valid implemenation that ninject decided not to. \nBtw. I don't think I've claimed in the original issue that I'm against changing it. Since your arguments about the danger of it are perfectly valid and sound. My whole arguments were around the semantics of enumerable.\nThus if your intention of claiming that I'm wrong is to push forward why this should be changed I think you missed the point since like I said I was never against your arguments. When you look at an OSS framework like Ninject the larger context has to be taken account. When a library has a certain behavior people start building all sorts of assumptions around a certain behavior. If you suddenly redefine a previous behavior you'd better be sure you are not destroying someone else's assumptions. If I understood correctly these were the arguments of @idavis saying if you do not want lazy evaluation use the other support interfaces. . ",
    "ursenzler": "I strongly agree with Daniel.\nWe are using Ninject in multi strong named projects.\nPlease sign the official releases of Ninject.\n. Nuget updated all ninject packages, not only ninject (core) - this was\na nice surprise.\nI didn't find any hint why the update works in some projects and in\nothers it does not. The same extensions were referenced in both kind\nof projects.\nA workaround would be really easy if it wouldn't be a prerelease: just\nuninstall and reinstall. With a prerelease it took some manual\nmanipulation of the packages files. But I got it running anyway.\nSo for me it's okay :-)\nCheers\nUrs\n. ",
    "kae": "Thanks.\nInterestingly enough that behavior struck me on the project only after using last build from repository.\nNow I'll go and try to understand what is happening with my code!\n. I thought it was the issue, but than i tried binary releases of 2.0.1 and 2.0.0 with same result.\nIt was some strange mistery but now I clean up my code and trouble is gone.\n. ",
    "tlwalker": "I'm sorry I pasted the wrong test this is the correct test.\npublic class NinjectServiceLocatorTest\n{\n    [Fact]\n    public void ShouldResolveWithoutNameBeingGiven()\n    {\n        var kernel = new StandardKernel();\n        kernel.Bind<IWeapon>().To<Sword>().Named(\"sword\");\n        var locator = new NinjectServiceLocator(kernel);\n        var weapon = locator.GetInstance<IWeapon>();\n        weapon.ShouldNotBeNull();\n        weapon.ShouldBeInstanceOf<Sword>();\n    }\n}\n. If I stick the code that just posted into that test then it passes. So are you saying that the Get should not resolve if there is only a named binding in the container for T?\n. The group item was posted because the code in your earlier does indeed resolve. The Activation Exception that the OP get tells him that he has too many bindings. So Get() is NOT the same as Get((string)null). So is a unconstrained resolution the default or is it a resolution with the a constraint of metadata.Name == null?\n. ",
    "MrKWatkins": "Thanks!\n. It sort of makes sense... Yes InjectMeChild can never see the setter because it is private.\nBut then again Ninject can never see it in either case because it is private and Ninject is external. However Ninject can still inject InjectMe despite not being able to 'see' it's setter, so why can't it do the same for InjectMeChild?\nThe way I'm looking at it is I would expect Ninject to inject members for base class members the same way each time irrespective of whether I'm doing a Get for the base class or a sub class. As things currently stand I have to make the setter protected (not good - I don't want a subclass changing my properties) or pass things in via the constructor. (Could do but again don't want to for various reasons and it kind of makes InjectPrivate pointless in the first place if I have to inject everything via the constructor)\nAny chance of changing things so the injection mechanism searches through base classes as well? Or add an extra InjectNonPublicInBaseClasses property to settings to preserve backwards compatibility? Something like this would get the relevant setter:\n```\nprivate static MethodInfo GetSetter(PropertyInfo property, bool nonPublic, bool nonPublicBaseClasses)\n{\n    var setter = property.GetSetMethod(nonPublic);\nif ((setter == null) && \n    nonPublicBaseClasses && \n    (property.DeclaringType != property.ReflectedType))\n{\n    setter = property.DeclaringType.GetProperty(property.Name).GetSetMethod(true);\n}\n\nreturn setter;\n\n}\n```\nYou should be able to invoke setter on an instance of the base class or the sub class, i.e. if using the classes in my original example then \nsetter.Invoke(new InjectMe(), new [] { new SomeInterfaceImplementation() })\nand\nsetter.Invoke(new InjectMeChild(), new [] { new SomeInterfaceImplementation() })\nShould both work fine.\nHope that makes sense!\n. Well you know my views. 8o)\nBe happy to do the coding myself and send it to you for review if you want?\n. \"I think this feature would rarely be ever used.\" - not sure I agree. If people are using InjectNonPublic enough for it to be included then some of those are going to be using inheritance as well.\nAnother way of looking at it - if all the properties were public and the base class properties weren't being injected, would you consider that a bug?\nAnd another way - InjectNonPublic doesn't specify anything about where those non-public members live, therefore it should inject all non-public members anywhere in the hierarchy, or be more specific about what non-public members are being injected.\nThe best argument for me is that I have to change the behaviour of my base class if someone decides to extend it with a subclass, which is obviously a big no-no from general OO principles.\nAs I said I'd be happy to help out with the coding if your main reason for not including this is that you don't think enough people would use it to warrant the time coding it up.\n. Ah, OK, didn't realise! It's not a desparate problem for me; will fork and make the changes if I get the time.\n. Finally got around to looking at this!\nAfraid Remo's changes didn't work for me - they gave me exceptions when injecting classes with two or more indexers.\nI've created my own fork and written a fix based on Remo's that works with multiple indexers, find it at: http://github.com/MrKWatkins/ninject/commit/a2d16307607cc42a4e0407a23c29728723452892\n. ",
    "dabide": "Here's a unified diff (using the CodeSmith/PLINQO implementation):\n```\n--- Infrastructure/Multimap.cs  Mon Jan 19 23:26:36 1970\n+++ Infrastructure/Multimap.cs  Mon Jan 19 23:26:36 1970\n@@ -7,10 +7,12 @@\n // See the file LICENSE.txt for details.\n // \n #endregion\n-#region Using Directives\n-using System;\n-using System.Collections;\n-using System.Collections.Generic;\n+#region Using Directives\n+\n+using System.Collections;\n+using System.Collections.Generic;\n+using CodeSmith.Data.Collections;\n+\n #endregion\nnamespace Ninject.Infrastructure\n@@ -22,7 +24,7 @@\n     /// The type of value.\n     public class Multimap : IEnumerable>>\n     {\n-        private readonly Dictionary> _items = new Dictionary>();\n+        private readonly ConcurrentDictionary> _items = new ConcurrentDictionary>();\n     /// <summary>\n     /// Gets the collection of values stored under the specified key.\n\n@@ -34,10 +36,7 @@\n             {\n                 Ensure.ArgumentNotNull(key, \"key\");\n\nif (!_items.ContainsKey(key))\n\n_items[key] = new List();\n\nreturn _items[key];\nreturn _items.GetOrAdd(key, new List());\n             }\n         }\n\n@@ -95,7 +94,9 @@\n         public bool RemoveAll(K key)\n         {\n             Ensure.ArgumentNotNull(key, \"key\");\n-            return _items.Remove(key);\n+      \n+            ICollection removed;\n+            return _items.TryRemove(key, out removed);\n         }\n     /// <summary>\n\n--- Planning/Planner.cs Mon Jan 19 23:26:36 1970\n+++ Planning/Planner.cs Mon Jan 19 23:26:36 1970\n@@ -8,9 +8,10 @@\n // \n #endregion\n #region Using Directives\n-using System;\n+using System;\n using System.Collections.Generic;\n-using System.Linq;\n+using System.Linq;\n+using CodeSmith.Data.Collections;\n using Ninject.Components;\n using Ninject.Infrastructure;\n using Ninject.Infrastructure.Language;\n@@ -24,7 +25,7 @@\n     /// \n     public class Planner : NinjectComponent, IPlanner\n     {\n-        private readonly Dictionary _plans = new Dictionary();\n+        private readonly ConcurrentDictionary _plans = new ConcurrentDictionary();\n     /// <summary>\n     /// Gets the strategies that contribute to the planning process.\n\n@@ -50,15 +51,15 @@\n         {\n             Ensure.ArgumentNotNull(type, \"type\");\n\nif (_plans.ContainsKey(type))\nreturn _plans[type];\nreturn _plans.GetOrAdd(type, t =>\n{\n\nvar plan = CreateEmptyPlan(type);\n\n\nvar plan = CreateEmptyPlan(type);\n\n_plans.Add(type, plan);\n\nStrategies.Map(s => s.Execute(plan));\n\n\nStrategies.Map(s => s.Execute(plan));\n\nreturn plan;\n\n});\n\n\nreturn plan;\n         }\n /// <summary>\n\n```\n. I did it this way to emulate the way WebServiceBase works. AnotherService inherits from InjectedBase, which looks like this:\n\n\npublic class InjectedBase\n{\n    public InjectedBase()\n    {\n        Program.Kernel.Inject(this);\n    }\n}\nSo yes, I use the kernel. Otherwise, I wouldn't get concurrency issues in Ninject... :-)\n. ",
    "sekhat": "I fail to see in your test program where you using the kernel to get your service? or doing any injecting by using the kernel. I assume it's a mistake, see the added comment to the quoted block of code below, while I'm not any sort of maintainer here, I shall still implore you to fix your test program :)\nCheers\n\n\n    internal class Program\n    {\n        public static IKernel Kernel { get; private set; }\n\n        private static void Main(string[] args)\n        {\n            Kernel = new StandardKernel();\n            Kernel.Bind<ITestService>().To<TestService>();\n\n            for (int i = 0; i < 1000; i++)\n            {\n                Thread thread = new Thread(() =>\n                                               {\n// the service is created by new, so the kernel injects nothing\n// neither is kernel.Inject(service) called at all, so it can't inject anything there either\n// so  AnotherService.TestService will return null\n\n                                                   var service = new AnotherService();\n\n                                                   Guid guid = service.UseTheService();\n\n                                                   Console.WriteLine(guid);\n                                               });\n                thread.Start();\n\n                Thread.Sleep(30);\n            }\n\n            Console.WriteLine(\"Finished. Press any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n\n. Ah, so you do. My apologies, I'll read things more thoroughly in the future  :)\n. ",
    "wimh": "I improved my factory example to depend on an interface instead of the class itself. But I also just realized that I have modified my visual studio editor settings to insert a space before () because of another c# project. That make my files inconsistently formatted. \n. I fully agree not to add bad examples. In my original use case the scope was based on a string constructor parameter. But because there was no fake class example with a string as parameter, I chose to use warrior+weapon instead. I will create a better example, and do some additional testing to make sure I fully understand the problem.\n. ",
    "ryber": "Note: On Google Groups Ian Davis said he had a fix for this but was reviewing (in Nov '10) I just wanted to add a ticket to put it on peoples radar\nhttps://groups.google.com/group/ninject/browse_thread/thread/fb4ee5493d840230/101d3023ddc5eeb5\n. Oh, this is in 2.3.0.24\n. mistake. This is indeed fixed.\n. ",
    "bartelink": "I reckon a big FAQ that needs to be addressed somewhere near where people land is that one can get bins off TC.CB.com\nNot clear to me where it fits now...\n. Thanks Daniel. So now we just need the manual and automated testing to verify there are not other holes :P\n. @ssakharov \"much larger than 1%\". How much larger? % of what? Are you sure the request processing time is definitely not IO bound?\nI'd spend lots more time measuring (though really I'd invest the time in reading and re-reading http://blog.ploeh.dk/2011/03/04/Composeobjectgraphswithconfidence/ )\n. Dunno if you're aware of this post and/or whether it's relevant:\nhttp://www.planetgeek.ch/2012/04/23/future-of-activation-blocks/\n--R\nOn 14 October 2013 23:30, aaronasmith notifications@github.com wrote:\n\nYes. I've also tried singleton and anything else I could think of. It\nseems to ignore these when using the activation block.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/106#issuecomment-26294388\n.\n\n\n--Ruben\nRuben Bartelink / +353 86 885 2399\n. @aaronasmith If you read the post I cited, you'll see that Activation Blocks are a fundamentally broken concept in many ways. They are deprecated functionality.\nThere are now plenty mechanisms to do equivalents of what it sounds like Activation Blocks might do properly in Ninject(and SO posts/gists etc.). Unfortunately this wasnt the case say 2-3 years back. So yes, the likelihood is that integration with MassTransit is far more likely to be achievable cleanly if the implementation uses other Scoping mechanisms, i.e., https://github.com/ninject/ninject.extensions.namedscope/wiki\nBut if as you say you have the option to switch container easily (and the integration with that container is done correctly) then that's ideal for you.\n. Just to aid people assessing what you mean, I'll ask some followups:-\nAre you trying to define a Module?\nWhat package are you using ? Is that necessary to do what you're doing?\nWhat would you like to see it split into (which bits do you want to use and which bits do you view as obviously needing to live elsewhere) ?\n. ",
    "innovatian": "Done\n. ",
    "zealic": "request.Service is requested [System.Type]\nI need name parameter of IKernel.Get  (string name) \n. ",
    "alexbeletsky": "Solved)\n. ",
    "salfab": "Is there any reason not to support this scenario, or is it Just that so\nfar nobody needed This, therefore, it has never been implemented ?\n. After having read the documentation about NameAttribute and When clauses, I came to the conclusion that my unusual setup (I am using silverlight attached properties so there is no class instanciation,therefore, no way I can use NameAttributes for dependency injection and have to resort to use the get() method, even if i'd prefer not to, since it's an anti-pattern. And as far as the when clause are concerned, my conditionnal bindings, the context defining Which type binding to use is not based on the target member (always the same get) nor the target class for the same reason. The perfect fit is really specifying a string, because what will define which type binding to use is the type my attached property is attached to. And the call to get() is done in the attached property's callback !\nI hope this clarifies the need for my request, and that was not too cryptic.\nAs of now, what I am forced to do is to have my get() caller tightly bound to all the constructor cascade in order to only have first level resolutions, and I really don't like this approach.\n. The reason I am using attached properties is to leverage a pattern in xaml called \"attached behavior\" This allows adding logic to a Silverlight control, a page or a button for instance. Typically, this is used to circumvent the lack of Command mechanism on buttons in Silverlight up to 3.0 and Windows Phone 7. \nThat being said, you were right : In my case, there is no need for deeper levels : I've found how to solve my problem using a NamedAttribute, because one specific constructor always needs one specific name, and this can be defined at compile-time.\nThe only thing that might be a little bit annoying is the fact that this way of doing is a bit intrusive, since the IoC will make us change the code of our classes, but I can live with that. MEF does it as well anyway ;)\nall in all, thank you remo for your support and qour quick answers !\n. ",
    "drusellers": "The only scenario I have is for bringing Ninject and MassTransit integration tighter than it currently is. Thank you for taking the time to answer. :)\n. i would be interested to review this when the new version drops\n. ",
    "Haacked": "Thanks! When running on .NET4 does it hook the end request event to\ndispose request scoped objects de\nOn Saturday, May 21, 2011, Talljoe\nreply@reply.github.com\nwrote:\n\nNinject.Web and Ninject.MVC[1-3] will automatically dispose of the objects at the end of the request. To release a single object you can call kernel.Release(<object>) which will search all of the caches for that object. \u00a0It looks like there's no convenience method to release all objects in a context, so if you're not using Ninject.Web you can release those instances with:\nkernel.Components.Get().Clear(HttpContext.Current);\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ninject/ninject/issues/37#comment_1214616\n. Whoops. ...deterministically. I remember older versions of Ninject\nused a timer based approach, which is why I asked.\n\nOn Saturday, May 21, 2011, Phil Haack haacked@gmail.com wrote:\n\nThanks! When running on .NET4 does it hook the end request event to\ndispose request scoped objects de\nOn Saturday, May 21, 2011, Talljoe\nreply@reply.github.com\nwrote:\n\nNinject.Web and Ninject.MVC[1-3] will automatically dispose of the objects at the end of the request. To release a single object you can call kernel.Release(<object>) which will search all of the caches for that object. \u00a0It looks like there's no convenience method to release all objects in a context, so if you're not using Ninject.Web you can release those instances with:\nkernel.Components.Get().Clear(HttpContext.Current);\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ninject/ninject/issues/37#comment_1214616\n. Ok, thanks! Any ETA on the next version? :)\n\n\nOn Mon, May 23, 2011 at 7:13 AM, Talljoe \nreply@reply.github.comwrote:\n\nI'm not entirely sure about 2.2.  The current trunk code will do it\ndeterministically at the end of the request.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ninject/ninject/issues/37#comment_1221842\n. \n",
    "GSchroder": "This means that using a DI framework like Ninject is then not suitable for API libraries, as you are exposing your implementations!\n. ",
    "kabua": "I'm having the same problem with plain old .NET. We have a component where the internal (default) implementation needs access to the internal ctor of a class but derived components must use the more limited public ctor. We have marked the internal ctor with [inject] but Ninject is only resolving to the public ctor - which isn't what we explicitly told Ninject to do. Therefore, we feel this is still an open bug and should be fixed.\nThanks.. @szogun1987  are you suggesting (which I hope you are) that the order in which you create the IParameter array should dictate which constructor to match?\nI.e.\nIParameter[] params = new [] {\n  new ConstructorArgument(fooOne),\n  new ConstructorArgument(fooTwo)\n}\nWould then match MyCtor(IFoo one, IFoo two), and execute as MyCtor(fooOne, fooTwo)\nIf so, than I totally agree with you!\n. ",
    "joaomatossilva": "``` C#\n    public class ConfigProvider : IProvider {\n        public object Create(IContext context) {\n            return new DynamicConfigReader(\"test\");\n        }\n    public Type Type {\n        get { return typeof(DynamicConfigReader); }\n    }\n}\n\n```\nC#\n    public interface IConfig {\n        string Get();\n    }\n``` C#\n    public class DynamicConfigReader : IConfig {\n        private readonly string name;\n        public DynamicConfigReader(string name) {\n            this.name = name;\n        }\n    public string Get() {\n        return name;\n    }\n}\n\n```\n. ",
    "MicahWray": "Ninject exception calling Get(controllerType)\nreturn controllerType == null ? null : (IController)kernel.Get(controllerType);\nMONO Version information: Mono Runtime Version: 2.10.8 (tarball Mon Dec 19 17:43:18 EST 2011); \nASP.NET Version: 4.0.30319.1\nNINJECT Version Information: 3.0.0.8\nStack Trace:\nSystem.NullReferenceException: Object reference not set to an instance of an object\n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.get_ParentDefinitionMethodInfo () [0x00000] in :0 \n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.GetParentDefinition (System.Reflection.MethodInfo method, BindingFlags flags) [0x00000] in :0 \n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.GetParentDefinition (System.Reflection.PropertyInfo property) [0x00000] in :0 \n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.IsDefined (System.Reflection.PropertyInfo element, System.Type attributeType, Boolean inherit) [0x00000] in :0 \n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.HasAttribute (System.Reflection.MemberInfo member, System.Type type) [0x00000] in :0 \n  at Ninject.Selection.Heuristics.StandardInjectionHeuristic.ShouldInject (System.Reflection.MemberInfo member) [0x00000] in :0 \n  at Ninject.Selection.Selector+<>c__DisplayClass3.b__2 (IInjectionHeuristic h) [0x00000] in :0 \n  at System.Linq.Enumerable.AnyIInjectionHeuristic [0x00000] in :0 \n  at Ninject.Selection.Selector.b__1 (System.Reflection.PropertyInfo p) [0x00000] in :0 \n  at System.Linq.Enumerable+c__Iterator351[System.Reflection.PropertyInfo].MoveNext () [0x00000] in <filename unknown>:0 \n  at System.Collections.Generic.List1[System.Reflection.PropertyInfo].AddEnumerable (IEnumerable1 enumerable) [0x00000] in <filename unknown>:0 \n  at System.Collections.Generic.List1[System.Reflection.PropertyInfo].AddRange (IEnumerable1 collection) [0x00000] in <filename unknown>:0 \n  at Ninject.Selection.Selector.SelectPropertiesForInjection (System.Type type) [0x00000] in <filename unknown>:0 \n  at Ninject.Planning.Strategies.PropertyReflectionStrategy.Execute (IPlan plan) [0x00000] in <filename unknown>:0 \n  at Ninject.Planning.Planner+<>c__DisplayClass1.<CreateNewPlan>b__0 (IPlanningStrategy s) [0x00000] in <filename unknown>:0 \n  at Ninject.Infrastructure.Language.ExtensionsForIEnumerableOfT.Map[IPlanningStrategy] (IEnumerable1 series, System.Action1 action) [0x00000] in <filename unknown>:0 \n  at Ninject.Planning.Planner.CreateNewPlan (System.Type type) [0x00000] in <filename unknown>:0 \n  at Ninject.Planning.Planner.GetPlan (System.Type type) [0x00000] in <filename unknown>:0 \n  at Ninject.Activation.Providers.StandardProvider.Create (IContext context) [0x00000] in <filename unknown>:0 \n  at Ninject.Activation.Context.Resolve () [0x00000] in <filename unknown>:0 \n  at Ninject.KernelBase+<>c__DisplayClass10.<Resolve>b__c (IBinding binding) [0x00000] in <filename unknown>:0 \n  at System.Linq.Enumerable+<CreateSelectIterator>c__Iterator272[Ninject.Planning.Bindings.IBinding,System.Object].MoveNext () [0x00000] in :0 \n  at System.Linq.Enumerable.SingleObject [0x00000] in :0 \n  at System.Linq.Enumerable.SingleObject [0x00000] in :0 \n  at Ninject.ResolutionExtensions.Get (IResolutionRoot root, System.Type service, Ninject.Parameters.IParameter[] parameters) [0x00000] in :0 \nAny idea on how to resolve? Thanks in advance\n. Recompiling with MONO specified worked like a charm. Thanks for the quick follow up and excellent product!\n. ",
    "trampster": "Why on why do you use compile time variation points. This means you can't use the same assembly on mono and .net.\nThe nuget package can't support mono because of this. Want to use ninject with nuget cross platform on linux and windows? you can't because of this.\nYou should handle this with run time checks, method returned null? ok we might be on mono try doing it the mono way. Then you have only one assembly, you need only one nuget package.\nThe first rule of cross platform .net is stay the heck away from #if if at all possible.\n. Yeah sorry, it was born out of frustration, after losing a number of hours to this bug.\nI actually had already forked the repo on git hub with the intention of improving things before your reply. Hopefully I'll find some time to work on it. Having looked more at the code I think that the mono code would probably work on windows, simply switching to it might be the way forward, unless there are performance implications of doing so. \nThe other mono #if statements seem to be about hashsets and Remoting. Hashset is supported in mono so I'm guessing this code is just out of date. The Remoting thing seems to be trying to work around some issue with the is keyword which I don't understand. Do you guys have a development forum/mailing list where this can be discussed.\n. I have submitted a pull request here:\nhttps://github.com/ninject/Ninject/pull/170\nThis is sufficient to get the main ninject build working on mono/linux at least for our usage requirements. \n. ",
    "BrunoJuchli": "@trampster \ninstead of ranting you might consider providing a pull request...\n. I'm currently working on a Fody AddIn to compile-time weave proxies so that I can use the .ToFactory() functionality on mobile platforms which don't support dynamic code creation (iPhone + WinRT AFAIR, or was it Windows Phone 8.1,.. or both?). So I'm interested in the state of things.\n@remogloor \nare there any plans regarding PCL support or has this been dropped definitively?\nWhat would be required to get this going?\n@onovotny \nDo you know of any website listing the differences in behavior / reflection API for the relevant current plattforms?\nThank you for the PCL fork, by the way.\n. @onovotny\nThere is no ninject.platform.dll in the nuget package folder \"portable-net4+sl5+wp8+win8\". So there is no Kernel / Standardkernel one could instanciate. Is this by design or...? Also see http://stackoverflow.com/questions/24757186/how-come-theres-no-ikernel-implementation-in-ninject-portable?noredirect=1#comment38442728_24757186\n. During boot-up phase we are frequently adding bindings. The boot-up phase can last several seconds. With our bootstrapping we do (or should) know when all bindings are completed but this is certainly after ninject has already handled quite a few requests.\n@danielmarbach \nSo i would suggest that the kernel initially has a modifiable \"binding repository\" which is then converted to an unmodifiable \"binding repository\" on an external call .Snapshot(). Like .Compact() on a database ;-)\nOf course even this does not work without locking completely. But instead of locking read-access to the \"binding repository\" one can lock Snapshot() vs write-access to \"binding repository\" (i.E. creating a binding).\nAdvantages:\n- full backwards compatibility (if one doesn't call Snapshot() == same behavior as before).\n- ninject does not need some elaborate code to find out at which time it makes sense to convert the \"binding repository\" to an unmodifiable one\n- converting from an unmodifiable to a modifiable repository might be costly?\nDrawbacks:\n- user cannot Snapshot then add bindings again. Or one adds support for that, but would make implementation more complex.\n- For users which don't use Snapshot() performance will decrease since now there are locks on both binding creation and binding resolving.\nFor most applications binding resolving is probably executed far more often then binding creation, the change should thus result in a performance improvement.\n. @scott-xu \nregarding #176 and you saying that there would be room for joining work on this \"ReadOnlyKernel\" feature:\nWhat do you think regarding my earlier comments on read only kernel by doing something like .Snapshot() ? I think we could retain a lot of the performance improvements and still offer flexibility for all who don't want to use a readonly kernel.\nWould that be an option? If so i would try getting started with an implementation. Should i base this on master or another branch?\n. Sadly enough i wasn't able to spend as much time on this topic as I'd wished. The good side, however, is that it allowed me some more time to think things over.\nSo in the following section there'll be some more or less coherent ramblings about the stuff. Feel free to jump to the next section to read more on my (preliminary) conclusions!\nSo regarding requirements, I've come to the conclusion that an interface like\nIKernel newKernel = kernel.Compact();\nwould be very cumbersome to maintain because the application would need to update all references to the kernel. So i think the kernel should not change but rather the binding information it uses should be changed. An interface like\nkernel.Compact();\nwhich doesn't replace the kernel would still be an option. There'd be two options:\n- after a Compact() attempting to change / add bindings throws an InvalidOperationException (so user who want to continuously change the kernel during runtime can't make use of Compact(). Same goes for users who don't have a clear point-in-time where kernel buildup is complete).\n- Compact() is allowed to be called multiple times. Adding bindings after a Compact() basically \"uncompacts\" the kernel until the next Compact() is called.\n  - we could also potentially perform the Compact() call internally instead of leaving this responsiblity to the user. Issue: When? After each added binding? After each loaded module?\nin the end, i think this is a rather expensive solution to implement, because binding retrieval would need to support the \"uncompacted\" as well as the \"compacted\" state. Except of course if we create a fully transactional system where only the \"commited\" bindings can be used. This poses another issue with the current ninject interface: IKernel inherits IBindingRoot and IResolutionRoot. So the atomicity of a transaction would need to be one single binding - otherwise it's unclear what state you're retrieving a binding from (warning: such small an atomicity would be detrimental on application startup performance!). Imagine:\nclass MyModule : NinjectModule\n{\n    public void Load()\n    {\n        Bind<IFoo>().To<Foo>();\n        var fooInstance = Get<IFoo>();\n    }\n}\nthis can only work if the Bind is immediately commited. Here comes the next issue: is it even finished? :\npublic void Load()\n    {\n        var syntax = Bind<IFoo>().To<Foo>();\n        var fooInstance = Get<IFoo>();\n        syntax.WhenInjectedInto<SomeType>();\n    }\nThere's actually no clear definition when a binding is complete!\nConclusion\nSeparating \"kernel usage\" from \"kernel buildup\" phases would be beneficial because:\n- buildup: allows for more coarse transactions, which improves startup performance\n- buildup: transaction boundaries are clearly defined. It is well defined when a binding definition is complete. Once you the buildup ends, you can't change the binding any more.\n- usage: improves the \"default\" performance because there's no explicit calls like Compact() to be made to improve performance. Also you don't really have to think that much about this topic because it comes naturally.\nHow about something like:\n```\npublic interface IBIndingRoot\n{\n     Load() where TModule : NinjectModule;\n     / more overloads for loading modules /\nIBindingSyntax<T> Bind<T>();\n/* more overloads for creating bindings */\n\n}\npublic interface InitialKernelBuilder : IBindingRoot {\n    / creates the kernel with initial binding map /\n    IKernel Build(); \n}\npublic interface IKernelExpander : IBindingRoot \n{\n    / replaces the kernel's binding map with Interlocked.Exchange /\n    void Commit(); //alternative: inherit from IDisposable to enable usage of using\n}\npublic interface IKernel : IResolutionRoot\n{\n    IKernelExpander AddBindings();\n}\npublic class InitialKernelBuilder : IInitialKernelBuilder\n{\n    public InitialKernelBuilder(KernelConfiguration configuration)\n    {\n         // similar to new StandardKernel(config);\n    }\n}\n```\nusage:\n```\nvar kernelBuilder = new InitialKernelBuilder(new KernelConfig { LoadExtensions = true });\nkernelBuilder.Load();\nkernelBuilder.Load();\nkernelBuilder.Bind().To();\nvar kernel = kernelBuiler.Build();\nvar bar = kernel.Get();\nbar.DoSomeBarStuff();\nvar kernelExpander = kernel.AddBindings();\nkernelExpander.BInd().To();\nkernelExpander.Commit();\n// this should throw:\nkernelExpander.Bind().To();\n```\nI think this way we can keep on supporting the same scenarios the old kernel supported but introduce better performance without making the new implementation overly complex.\nWhat do you guys think?\n. @scott-xu \nI would agree that for now bugfix and platform update (i interpret: .net standard/.net core support) is much more important.\nRegarding performance optimization, I believe it's highly likely that an \"optimal\" solution will also require some interface changes - which means new major release. Question is whether the platform change would make sense to be 4.0.0 \"politically\". And then performance optimizations = 5.0.0.\nWith a .net standard 4.0.0 release one would show \"progress\". Given a new 3.3 release people might believe it's just a minor bugfix update - no major new things. And I believe .net standard support to be a major new thing.. I believe that there only should be information on the interface which is necessary for the operation of ninject.For example, IProvider<T> / IProvider has the Type property which i believe to be obsolete. At least it works if i don't implement it correctly, right? Anyway, what should it be for? I specify the type which the builder returns by the binding, what would i need a Type property for? \nHaving such properties on the interface makes it more complicated to understand how things work.\nFurthermore, removing such \"obsolete\" properties from interfaces should only lead to incompatibility in very few cases, don't you think? We for one have never used the Type property of the IProvider, ever.\nEDIT: i mistook IBindingBuilder for IProvider. Fatal mixup ;-)\n. Thank you Remo, I'll update the docs & release notes tomorrow during work hours ;-)\nThank you also for adding the ForceUnique parameter, perfect!\n. Also see https://github.com/ninject/ninject/wiki/Optional-Bindings-and-Null-Object-Pattern\n. Yes i would agree. Still this is a pitfall for bugs.\nAlso using collections as a workaround is a tiny bit smelly: i don't ever want to add or remove items to / from that collection.\n(we (Erowa AG / Marco Erni,...) have also already had a discussion about this with @remogloor).\nMaybe support for IReadOnlyCollection<T> could also be added to ninject?\n. @danielmarbach \nActually neither MSDN (http://msdn.microsoft.com/en-us/library/system.collections.ienumerable.aspx) nor Wikipedia (http://en.wikipedia.org/wiki/Iterator), nor often-read Stackoverflow entries (http://stackoverflow.com/questions/716238/distinction-between-iterator-and-enumerator) say anything about when the \"collection\" is built.\nYours is probably an assumption originating from broad use of LINQ.\nAlso i did not say that the IEnumerable should be evaluated before injection, i only stated that the backing collection (or elements, for that matter), should be instanciated beforehand.\nIn any case, one could still use Lazy<IEnumerable<T>> if one would want to have lazy creation of the objects.\nI still stress that the current implementation of IEnumerable<T> support is dangerous.\nWould you like to discuss / debate that?\nIn any case, i would agree that lots of people associate IEnumerable with late (lazy) creation (eventhough there is no guarantee made that it is actually done lazily).\nSince this may also lead to confusion, an acceptable solution may be to remove IEnumerable<T> support and introduce IReadOnlyCollection<T> and Lazy<IReadOnlyCollection<T>> support instead.\n@idavis \nI like your array suggestion. There's a (smallish) caveat: Array.Add(...) method renders an array mutable. Also array explicitly implement the IList<T>.Add(...) method.\n(I'll try to discuss it with the team in the few remaining days I'm spending with them ;-)).\nSummary\nIMO:\n- IEnumerable<T> does not make any statements about when the collection is materialized.\n- current IEnumerable<T> support is a pitfall, cause of bugs, presents another entry threshold for new users and programming beginners\n- it is highly doubtable that there is any (broad) use case for injecting modifiable collections. It contradicts general rules (..,ISP,..) and thus makes usage of ninject harder. And also is slightly smelly.\n- IReadonlyCollection<T> is only available from .net 4.5 on and thus a backwards-compatibility issue as long as .net < 4.5 is supported. (what is the outlook for ninject 4?)\n- Current IEnumerable<T> behavior could, if one would dare to wish for it, be offered by Lazy<IEnumerable<T>>, which does make an explicit statement about materialization (=> not instanciated before you are accessing Lazy.Value).\nAlso, there's the point of funding of development work required:\n- We already discussed this with Remo. EROWA is going to fund some of the change requests we've placed / are going to place. I'm currently in doubt whether this is one of them but i'll check.\nAddendum:\ni don't dispute that there may be (most likely are) significant issues with what i propose in regards of breaking the interface, backwards compatibility. I think we should discuss these, too.\n. Link to issue \"reports\":\nhttp://ninject.codeplex.com/workitem/2948\nhttps://groups.google.com/forum/#!topic/ninject/5WiOkJIImDE\nSomewhat related:\nhttps://groups.google.com/forum/#!topic/ninject/f2HgHwTRFwY\n. @danielmarbach \nIn reference to your answer on #252:\nSorry for being so confrontative. \nI concur you never disagreed with the reasoning that the current behavior of lazy-materialization is dangerous.\nI also concur that the original implementation does not violate the semantics of IEnumerable - no beef there.\nHowever, your answer insinuated that you were categorically against the proposed change. And the reasoning you provided, that's what I don't agree with and where I still believe that you're wrong.\nYesterday you wrote:\n\n(...) Only when the enumerator is accessed by design the enumeration and thus first materialization should happen. (...)\n(...)But if you look at the larger .NET ecosystem and what the history and introduction of LINQ taught us is that enumerables cannot be assumed materialized thus it is a perfectly valid implemenation that ninject decided not to.(...)\n\nI fully agree with the second part - enumerables cannot be assumed materialized. That is part of the semantics, yes. Might have been so before LINQ, even.\nHowever, I also postulate that the semantics here include the reversal of the sentence:\n\nEnumerables cannot be assumed unmaterialized\n\nSimply, the semantics probably don't include anything about materialization.\nNow, to support my arguments:\nFrom MSDN:\n\nNotice, IEnumerable exists since in .net 1.1, while LINQ was introduced in .NET 3.5.\n\nNotice, ICollection inherits IEnumerable.\nThis means, there's tons  of implementations and usages of materialized lists in the BCL where enumerables are indeed materialized, \nI think that's already more than enough proof for:\n\nEnumerables cannot be assumed unmaterialized\n\nand consequently that you statement:\n\n(...) you are esentially redefining the semantics of IEnumerable (...)\n\nis wrong.\nBreaking Change\nOf course, the change being a breaking change is a very important factor and what the discussion should be about, effectively.. regarding OR conditions: i've changed my mind. In case you have a more complicated binding like ToCtor, ToMethod, etc. it would be beneficial to be able to do OR constraints as well.\nAlso, one could leave the current interface as is but just make the actual \"condition computation\" available externally. For example for WhenInjectedInto<T> there's an internal / private method which represents the (open) predicate. If this predicate would be available outside, it would be very easy to create one's own combinations:\n.When(x => \n     ContextualBindingConditions.InjectedInto<T>(x)  ||   \n     ContextualBindingConditions.InjectedIntto<T>(x));\nOf course this is not as elegant as a nicely and fully featured fluent interface, however, it's more flexible, too. And also keeps the fluent interface more simple for the simpler use cases...\n. https://docs.nuget.org/create/deleting-packages\nshould be...\n. @iappert \nSure, you're right. I've been expressing myself poorly. Because that behavior is what i expected - the argument being on the context but not having any other effects. With WithConstructorArguments() i tell ninject to inject the value of a constructor parameter matching a name. But that is not happening.\nOf course, .WithConstructorArgument() method works the same for all bindings. However, the intended usage is not appliccable to .ToProvider() bindings - but how does the end user know? It requires \"expert\" insight into ninject.\nAs a ninject-newcomer one would not care how ninject is solving this internally - one only observes that it does not work as one would expect.\nDocumenting this \"special\" behavior is a start - not perfect - but i guess one always needs to compromise.\nWhat the ideal solution is, is depending on whether it is ever sensible to use .WithConstructorArguments(...) on a .ToProvider(...) binding. I suspect one should usually choose a different, clearer design. Like .Bind<IConfig>().ToConst(new Config { ... }); and then injecting IConfig, which works with basic ninject features and works as expected.\nTo sum it up, i would not clearly categorize this as a bug. The method implementation is working as intended. However the interface is missleading. It makes ninject a little bit less attractive and requires more know-how from it's users (of course, ninject is still very attractive compared to other tools ;-) ).\nEDIT: this is clearly not a strategically very important \"issue\" and fully expect the contributors to focus on the more important features for Ninject v4.0. However, this might be a candidate for a \"you take it\" kind of backlog entry.\n. Great, thanks! Let me know when there are issues / backlog items i can participate in.\n. Just for clarification, it does actually support (WPF, WinForms,..) Desktop Applications on Windows 8.1.\n.net 4.5.1, too, is fine.\nIt does however not support either WinRT (Windows Runtime, Windows Store Apps) nor Windows Phone applications. For those you would need to use the Portable.Ninject nuget package.\n@iappert: is that going to change for Ninject 4? Will it be PCL compatible? I would like that very much.\nAs it stands i can't use any of the extensions with the Portable.Ninject, right? (without compiling them myself, of course)\n. If that's the case you might want to ask @onovotny\n. Did you try http://www.nuget.org/packages/Portable.Ninject/ ?\n. I don't really get what you're trying to tell us. The 'OnActivation' method is binding specific, not specific to the type being resolved. And that's by design and not a bug.\nFor example you could do something like\nkernel.Bind<IService1>().To<Service1>().Named(\"foo\").OnActivation(x => x.Initialize(\"foo\"));\nkernel.Bind<IService2>().To<Service1>().Named(\"bar\").OnActivation(x => x.Initialize(\"bar\"));\nso depending on whether you do kernel.Get<IService1>(\"foo\") or kernel.Get<IService1>(\"bar\") the service will be instantiated differently.\nThus also follows that when you do kernel.Get<Service1>() no OnActivation will be executed, because there is none!\nIf you want the same activation on both resolutions you ought to do:\nkernel.Bind<IService1, Service1>().To<Service1>().OnActivation(x => x.Initialize());\nOnActivation is also only executed when the type is instantiated, not every time the type is resolved (it's not OnResolution after all).\n. Ok i think i got it now. Are you telling us, that the OnActivation part after a .ToMethod() is never ever executed?\nIf that's the case one could argue whether that is a plausible / desired behavior. But at least i would expect ninject to throw an exception @ OnActivation() in case it does not work (NotSupportedException \"for ToMethod..\", throw @ binding time, not at resolution time).\n. @danielmarbach\nthat would certainly be the best implementation, but would probably make the syntax interfaces & implementation quite complex, don't you think?\n(as long as pull requests go uncommented for months i don't expected the most expensive - though best solution - even to be considered, sadly. I love that you introduced \"you take it\" tagged issues @MSpec.)\n. So in case of\n```\nprivate static readonly FootSoldier OneAndOnlyGodSoldier = new FootSoldier();\nkernel.Bind().ToMethod(\n             ctx => OneAndOnlyGodSoldier).OnActivation(\n             instance =>\n             {\n                 instance.Weapon = new Shuriken();\n             });\n kernel.Get();\n```\nThe OnActivation may be executed multiple times per the one instance OneAndOnlyGoodSoldier.\nOf course i would agree that that's expected and would be perfectly fine, however being somewhat of a slight trap (well we often tend to expect it to work the way we want, not the way it does).\nFurthermore, with a .ToMethod binding one can easily replace the OnActivation implement in the .ToMethod part, so there's no actual need for 'OnActivation`.\nThis might tip the scale a bit towards the direction of \"not supporting OnActivation for ToMethod bindings\".\n. Please fix the code formatting. Each line of multine code is prefixed by 4 spaces.\nhave you tried adding INotifyWhenDisposed to the object defining the scope + explicitly releasing it?\nNinject itself is maintaining a weak-reference to the scope defining object. If the scope object is not implementing the INotifyWhenDisposed method, it will get disposed - but only after the periodically running clean-up task detects it as not being alive.\nIt may thus take a while until the scope is detected as \"not alive\" and scoped object to be released.\nIf a simple Thread.Sleep(60 seconds) before the wR.IsAlive check resolves the issue, then it works as intended...\n. Code Formatting\nAdd 4 spaces in front of each line of code.\nThat means, that indentation remains (no tabs, only spaces.\nInline comments are enclosed by two of these hyphens: `\nIsue\nOk well if the Thread.Sleep had worked, it would prove that everything is working correctly. However, it failing does not mean there's anything wrong.\nI don't know how often Ninject's \"Scope Garbage Collector\" is running.\nIt would be an interesting experiment to let the application run until WeakReference.IsAlive == false.\nhow about:\n```\nDateTime start = DateTime.Now;\nwhile(WeakReference.IsAlive)\n{\n      Thread.Sleep(TimeSpan.FromSeconds(1));\n}\nDateTime end = DateTime.Now;\nConsole.WriteLine(\"Collection of scope and subsequent garbage collection of now unreferenced objects took {0}\", (end-start));\n```\n\nThat said, if you need know/determine when the scoped objects actually get disposed, the scope will need to implement INotifyWhenDisposed, otherwise it's just at some \"random\" point (influenced by when the GC will collect the scope object and when the Ninject scope collector will dispose the scoped objects).\n. It would be really really great if this would make it into ninject. I'm offering my help.\n. @scott-xu \nit's great to see things moving again!\nIf there's something we can provide i'd like it if you'd add \"you-take-it\" labels (or the like) to the issues where you would accept PRs.\n. yeah you should provide a Minimal, Complete, and Verifiable example\n. @l0nley did you follow the steps outlined here?\nFrom which version did you migrate to 3.2.4?\n. If you're not running a web application / -service you neither want nor need Ninject.Web.\nSo having Ninject.Extensions.Wcf depend on Ninject.Web would be a bad idea.\nBut maybe something could be done on the documentation side?\n. EDIT: there's no new nuget package yet, so no you can't find it - yet.\nThe most up-to-date version is Ninject 3.2.3-unstable-012 which is from January 4th. \n~~Could it be that the pdb file is from same source revision but from a different build?\nAs far as i remember: If you do a rebuild the resulting pdb file does not match the dll file anymore - even if there were no source file changes at all.~~\n. Seems strange to me. It's something that really should not be on by default. There should only be a few conventions and those should be easy to remember and identify.\nI don't think this applies here.\nWhile it's clear that if you want to implement the singleton pattern in a classic way you'd have a private ctor, it's unclear why a private ctor necessarily leads to a singleton (there's other use cases for private ctors).\n. probably here: https://teamcity.bbv.ch/viewType.html?buildTypeId=bt7&tab=buildTypeHistoryList&branch_Ninject=%3Cdefault%3E\n(use guest login)\n. there's not that much development going on with Ninject.. so i believe that the current maintainers are unlikely to do so. However, if anyone else starts his/her own project to create an adapter, i think this should be fine.\n. @ah- i don't understand what that has got to do with this issue. Could you please explain?\n. Can't reproduce your issue. Why do you \"hope\" it does?\nYou should always provide a full exception including stack trace as well.\n. @WattsC-90\nYou should upgrade to (3.3.4) - 3.3.x supports .net standard 2.0. @WattsC-90 \nI was under the impression that current versions of Mono support using .net standard 2.0 packages.\nSupport was first introduced with Mono 5.2 but might require the installation of .net core 2.\nAlso see: https://stackoverflow.com/a/48061658/684096\nIt's been 9 months and 6 releases since 5.2 so things might have changed a bit.. There's no (limiting) scope. So each will get injected a transient instance. Which in turn will get injected a transient instance. Which in turn will get injected a transient instance...hence the StackoverflowException\nOne could improve that by detecting the error and throwing a specific exception (making debugging easier). However, there would still be an exception.\n. Ok. Yes i thought this might be your intention but you did not state it. Your repro code also gave another impression. After all, this part:\n```\n    var bar = kernel.Get();\nfoo.Bar.Should().BeSameAs(bar);\nbar.Foo.Should().BeSameAs(foo);\n\n```\nis not necessary to reproduce the issue. And it would never (ever) pass, anyway (given your scoping setup).\n. This is a thing solved quite easily with a contextual binding.\n. Sure i could. But could you take 5 minutes to read the article?\n. ok let me be a bit less mean :P\nBind<IContentService>().To<ContentService>()\n    .WithConstructorArgument(\"nameOfCtorArgument\", ProjectAppSettings.WebServiceAddress)\n    .When(ctx => ProjectAppSettings.IsApiService)\n(maybe WithConstructorArgument has to come after the When, i'm writing this from memory)\nand in the same manner for the else case.\nAs you can see, this results in two bindings. There's an alternative:\nBind<IContentService>().ToMethod(ctx =>\n    {\n        if (ProjectAppSettings.IsApiService)\n        {\n            return new ContentService(ProjectAppSettings.WebServiceAddress);\n        }\n        else\n        {\n            return new ContentRepository(new StoreContext(AppConstants.ConnectionStringName));\n        }\n     });\n. This is not a discussion forum! This is an issue tracker where you report bugs and post feature requests.\nPost Your questions somewhere else, for example a discussion board, mailing list or https://www.quora.com/\n. Have you had a look at https://github.com/ninject/Ninject/issues/177 ?\nI think that relates.\n. link: https://github.com/ninject/Ninject.Extensions.Wcf/issues/36\n. Can you provide an example (code...) of what's not working and how you expect it to work?\nCurrently, you can already easily nest named scopes. \n. Well an IEnumerable doesn't say wether it's going to lazy create objects or not and it's also not stating at what time the backing values are generated. So this is not per se wrong, however, also see #128 (i'd close this as a duplicate of #128)\n. Sorry, i spoke hastily before (didn't sleep a lot tonight). As far as i know Ninject does not take the When clauses into consideration when scoring for constructors (see StandardConstructorScorer).\nAs the exception message mentions you could make use of the ToConstructor binding to circumvent the issue, also see Remo Gloors post on this feature here:\nkernel.Bind<Item1>().ToConstructor(c => new Item1(c.Inject<IThing1>());\nOr, alternatively, place an [Inject] attribute on the ctor:\n[Inject]\npublic Item1(IThing1 thing1) { }\n. What's the performance impact? Why is this feature important? Why can't the code be changed - why is there an obsolete constructor at all? Is the benefit worth the performance impact?\n. It's the expected behavior - has been like this for years. I don't think it's ideal but then again when you have Parameters with ShouldInherit== true then there's not really a way around this behavior. . My argument is not related to class inheritance. See the IParameter interface. A constructor argument is just one of the IParameter implementations.. @StingyJack makes sense. However, as mentioned before with the current design there's no easy fix for this.\nHowever, there's something you as a user can do.\n\nslightest change, improvement is to use a TypeMatchingConstructorArgument instead of a name matching one. This is possible as long as you don't have multiple arguments with the same type. \nbigger change but full control is to use ToMethod binding to create the type\npossibly you could also use the ToConstructor binding.. With T[], List<T> and IEnumerable<T> multi injection takes precedence. If there is no Bindings for T (like Bind<T>()...) then ninject checks whether T is \"self-bindable\" (i.E. an instantiatable class), if so, it will create an instance of T.\n\nSo if T is an abstract class injecting an empty array is possible, too - because in that case T is not \"self-bindable\".\nShort of making T abstract (or maybe changing it's ctors visibility, if that's possible?) the only remedies i can think of is adapting the binding of X where T[] is injected, either using ToConstructor, ToMethod, ToProvider - or mabe with an argument/parameter. Maybe you could also roll your own IParameter which resolves all the Ts by IResolutionRoot.GetAll.. @omar side-question: what's your approximate timelime for a decision to stick with Ninject or move to another container? Or at which point would you need to have a working Ninject \"netstandard\" to stick with it?. @omar so you're current pain is more related to https://github.com/ninject/Ninject/issues/177 / https://github.com/ninject/Ninject/issues/201 than actual support for .NET Core?\n(I'm sorry, i'm not really up-to-date with asp.net core). There actually is. Kernel.Inject(...). Also see https://stackoverflow.com/questions/9982617/what-does-kernel-injectinstance-actually-do. So usually, basically, once the event is subscribed to, the reference is the other way round:\nnotifyScope has a reference to Cache because notifyScope needs to inform the Cache about the Disposed event.\nSo the event subscription will keep Cache from being collected, but it won't keep notifyScope from being collected. Sidenote: If there's no strong reference to either Cache or notifyScope, both would still be collected (eventually).\nThe best way to go about solving problems like this is to use a memory profiler.\nAlso, how do you know that there's actually a memory leak?. I'm not a maintainer but I currently plan to fork Ninject for a .net standard based release \"4.0\" with 90% feature and interface compatibility. I plan for some design changes, like the way bindings are created, i think I'll use a read-only collection and a \"unit of work\" kind of approach to make changes to these. This will reflect in the interface of ninject in some places. Loading of a module could be auto-encapsulated, other use cases not so much.\nIf everything goes according to plan I'd welcome some feedback regarding my interface changes, so to anyone willing to chime in: would be glad if you could state so here, then i'll send you a message when I've got something going on.... Due to some unforeseen circumstances and \"personal problems\" - just at the wrong time... I've not been able to dedicate a significant ammount of time into \"re factoring\" Ninject and making it ready for .net core.\nI really love the Ninject API and would hate to see it dying. However, to keep it alive, I believe there would need to be major effort to be put in performance-optimizing it. The \"website\" use case get's more and more important, and that's where Ninject performance is very bad.\nSo just making it .net standard by itself would not be enough, IMO.. In the meantime, you've edited the code:\nkernel.Bind<int>().ToConstant(1).WhenInjectedExactlyInto<TestClass1>();\nkernel.Bind<string>().ToConstant(\"2\").WhenInjectedExactlyInto<TestClass2>();\n\nBefore, both weere WhenInjectedExactlyInto<TestClass1>. Is the exception still happening on using Get<List<T>>()?\nWhat happens when removing the bindings for TestClass2 and doing Get<ITestClass>()?. Consider:\nMyCtor(IFoo one, IFoo two)\n\nAs both parameters have the same type, matching by name is necessary.\nOtherwise, personally, I prefer type matching as it's more refactor safe.. @szogun1987 That's certainly a viable alternative but it's just as brittle as using names, actually even more so.\nNamed: If you change names without adapting the binding, activation will fail with an exception.\nIndexed: Changing the parameter sequence - given multiple parameters of the same type - will introduce a bug silently.\nFor all cases where you have distinct parameter types you should use typed injection anyway.\nSo, personally, i don't think there's any significant benefit in adding the indexed constructor arguments. It also brings downsides with it:\n\ninitial effort for implementation\nadds code which needs to be maintained\nmore options - more things to figure out for the user\n\nSo I guess you have your argument to require argument names (whenever you don't have distinct argument types).\nOf course you are free to implement and use your own ConstructorArgument in your code. Have been there myself... (typed constructor argument before it was introduced in Ninject).\n@kabua. @StingyJack\nWhile corret, what will happen if you refactor your constructor and change the sequence of foo1 and foo2?\nMaybe the original implementation was Bar(IBankAccount seller, IBankAccount buyer) and you change it to Bar(IBankAccoutn buyer, IBankAccount seller). That could introduce a nasty issue.\nSo while technically possible to rely on the order, I'm not sure that's a wise thing to do. The order does not communicate intent. It's just circumstancial that it'll work.. I agree, however i'd vote to remove this feature from Ninject entirely (in a Ninject V4). Private-property injection is basically only limited to cases where bad code is written. I think in 99% of the cases there's a better ctor-injection, or entirely different, design possible.. @barbosatek\nI believe you are mistaken. It is supported by Ninject.\nI know I have used it plenty of times.\n@scott-xu or has it been removed?\nAlso see: #128 \nbtw.: I still don't agree with @idavis and especially not @danielmarbach comments (which I claim to be plain wrong). \nNonetheless:\n\nMaterializing IEnumerable<T> before injection prevents bugs.\nUsing Lazy<IEnumerable<T>>  for lazy-use cases is concise and works as expected.. @barbosatek  \n\nok so that's a specific ASP.net Core feature that might not work/no be implemented.\nseems like you're using 4.0.0-beta, right?\nIf that's the case, do you mind trying out 3.3.0? It's the latest stable release and it supports .net standard and it's newer than 4.0.0-beta.\nI don't know how ninjectServiceProvider.GetServices works internally, however, with ninject 3.x the following does work:\nBind<IFoo>().To<Foo1>();\nBind<IFoo>().To<Foo2>();\n\npublic class Bar\n{\n   public Bar(IEnumerable<IFoo> foos) {} // will inject 2 foos\n }\n\n\nIf it currently does not work for Asp.net core because of lacking infrastructure or because this is not implemented in 4.0, i suggest updating/editing your issue to explicitly specify this.\n. duplicate of #84 . Cross posted here: https://stackoverflow.com/questions/46843110/ninject-binding-a-generic-type-to-create-method. Could you provide the code for \"copy & paste\" so we can easily reproduce the issue?. To summarize the issue:\nWhen a Type (Samurai) is bound InSingletonScope() and uses property injection, and this property fails to inject, then a second call to Get<Samurai> will return a Samurai instance with uninitialized property.\nThe expected outcome would be to throw the same ActivationException (and, internally, not having cached the Samurai instance).. When cross posting please mention that you do so and link to cross posts.. Might this be related to https://github.com/ninject/Ninject/issues/128 ?\n(see https://groups.google.com/forum/#!topic/ninject/5WiOkJIImDE). @ternst \nThe problem occurring in AuthenticationService might be caused by another component concurrently enumerating an IEnumerable. I'd expect the path which AuthenticationService is taking to take the proper locks to safe-guard against concurrent access, but the IEnumerable access not to.. @ternst It's entirely possible that it's unrelated.\nI am, however, talking about a concurrency issue and therefore one should be open minded about the possibilty that there are two entirely different code paths leading to a concurrency issue on the dictionary.\nTo be a bit more precise: If you have ninject inject an IEnumerable<T> where the Ts are bound by ninject, enumerating the IEnumerable<T> will lead to unsynchronized access to Ninject internals - might well be the Dictionary the MultiMap contains.\nHence why I believe, with the info we currently have,  it is a plausible cause.. ",
    "foens": "I have just bumped into this problem, developing on Windows but want to run the code on Mono. Glad to see you provided a pull request, just hoping it will get looked at soon.\n. ",
    "scott-xu": "No more #if now\n. still thinking.... Hi folks, I'd propose to back out ReadOnlyKernel as it still has a long way to go.\nI'm thinking to draft a release called 3.3.0 which is mainly focused on bugfix and platform update.. @BrunoJuchli There's no breaking API change. According to Semantic Version, there's no need to bump major version.. Will merge to 4.0\n. A PR is welcome.\n. The plan is to add \"Verify()\" to the kernel.\n. Unfortunately, in this case, the ServiceChannelProxy has different reference than the TransparentProxy while they do have the same HC.\nhere's a test program:\n``` C#\nusing (var kernel = new StandardKernel())\n{\n    var channelFactory = new ChannelFactory(new BasicHttpBinding(), new EndpointAddress(\"http://localhost/IService\"));\nkernel.Bind<IService>().ToMethod(ctx => channelFactory.CreateChannel()).InThreadScope();\n\nfor (var i = 0; i < 1000; i++)\n{\n    new Thread(new ThreadStart(() => kernel.Get<IService>())).Start();\n}\n\nConsole.ReadKey();\n\n}\n```\nYou will see that 1000 instances didn't get disposed. (I don't know how to check instances inside Ninject cache. I just made a dump and checked the memory.)\nIf use HC compare, they disposed.\n. @iJoyCode implemented\n. Can you please provide a sample application?\n. This issue is very interesting, because when I call ctx.Kernel.Get<FootSoldier>(), the FootSoldier will be resolved without OnActivationActions since there's no binding to FootSoldier. After that when resolve IWarrior, it found that the target has already been activated so the OnActivationActions will be omitted.\nThis really raises a question here:\n``` C#\n// Given\nkernel.Bind().To().OnActivation(ctx=>Console.WriteLine(\"Activated by IService1\")).InSingletonScope();\nkernel.Bind().To().OnActivation(ctx=>Console.WriteLine(\"Activated by IService2\")).InSingletonScope();\n// When\nvar s1=kernel.Get();\nvar s2=kernel.Get();\n```\nWhat should the output be?\nCurrent logic is to write only one line \"Activated by IService1\". But does this make sense for real case?\n. Let me give you the comparison:\nC#\nkernel.Bind<IWarrior>().ToMethod(\n                 ctx => ctx.Kernel.Get<FootSoldier>()).OnActivation(\n                 instance =>\n                 {\n                     instance.Weapon = new Shuriken(); \n                 });\nkernel.Get<IWarrior>(); // The OnActivation delegation is NOT executed\nC#\nkernel.Bind<IWarrior>().ToMethod(\n                 ctx => new FootSoldier()).OnActivation(\n                 instance =>\n                 {\n                     instance.Weapon = new Shuriken(); // It will be called as expected\n                 });\nkernel.Get<IWarrior>(); // The OnActivation delegation is executed as expected\n. @BrunoJuchli  I tried your case and the OnActivation delegation only runs one time even if I resolved IWarrior multiple times\n. You are right, thanks @remogloor \n. Will merge to 4.0. Thanks for the hard work\n. Can you please merge to the latest master?\nI agree dropping pre .NET 4.5 platforms in v4\n. Here's my thoughts:\n1. dnx451\n2. dnxcore50\n3. MonoAndroid\n4. MonoTouch\n5. net45\n6. portable-net45+win+wpa81+wp80+MonoAndroid10+Xamarin.iOS10+MonoTouch10\n7. sl5\n8. win\n9. wp8\n10. wpa81\n11. Xamarin.iOS10\n. Ok, let's drop sl5 and win8.\nI'd also prefer leveraging some C#6 features.\n. Refreshed target frameworks:\n1. dnx451\n2. dnxcore50\n3. MonoAndroid\n4. MonoTouch\n5. net45\n6. netcore451\n7. portable-net45+netcore451+wpa81+MonoAndroid10+Xamarin.iOS10+MonoTouch10\n8. wpa81\n9. Xamarin.iOS10\n. @BrunoJuchli thanks for loving Ninject.\nIf you have time, could you please help take a look at the extensions to adopt the readonly kernel? That would be a heavy task for 4.0\n. Can't reproduce. You are not using the latest Ninject.Web.Common. Please upgrade from 3.2.0.0 to 3.2.2.0\nhttps://github.com/nicholashead/ninject-not-disposing-example/blob/master/MvcApplication3/packages.config#L27\n. The SharedAssembly.cs will be regenerated by the CI sever when build. You could change it manually when build locally.\n\u53d1\u81ea\u6211\u7684 iPhone\n\n\u5728 2014\u5e7410\u67081\u65e5\uff0c21:20\uff0c\"Jeremy Berven\" notifications@github.com \u5199\u9053\uff1a\nWhen I download the source listed in released as 3.2.2 of Ninject/Ninject, The SharedAssembly.cs in the Ninject project shows an AssemblyVersionAttribute of 3.0.0.0 and an AssemblyFileVersionAttribute of 3.0.2.65. However, when I download the package from Nuget the .dll version attribute is 3.2.2. How do I build so that I get the same .dll as the Nuget Package?\n\u2014\nReply to this email directly or view it on GitHub.\n. Can you please provide a demo application?\n. You could abstract the only necessary code, or create a new project which only contains this defect.\n\n\u53d1\u81ea\u6211\u7684 iPhone\n\n\u5728 2014\u5e7410\u670811\u65e5\uff0c22:27\uff0c\"VansFannel\" notifications@github.com \u5199\u9053\uff1a\nIt's a commercial product and I'm not sure if I can send you source code.\n\u2014\nReply to this email directly or view it on GitHub.\n. Could you please provide a demo project to reproduce this issue so that  we can verify?\n\n\u53d1\u81ea\u6211\u7684 iPhone\n\n\u5728 2014\u5e7410\u670816\u65e5\uff0c21:30\uff0c\"glooblooz\" notifications@github.com \u5199\u9053\uff1a\nI have a unit test project with several tests depending on NInject. Every single test runs fine. The Kernel is created and configured in TestInit and disposed in TestCleanup. When I run all tests in one test run, some tests fail with the following exception:\nTest method Com.Xavo.Xps.Development.Test.ExcelTests.VerifyRemoteImportExport threw exception: \nSystem.ServiceModel.FaultException`1[System.ServiceModel.ExceptionDetail]: Error loading Ninject component ICache\nNo such component has been registered in the kernel's component container.\nSuggestions:\n  1) If you have created a custom subclass for KernelBase, ensure that you have properly\n     implemented the AddComponents() method.\n  2) Ensure that you have not removed the component from the container via a call to RemoveAll().\n  3) Ensure you have not accidentally created more than one kernel.\nAs I am sure that 1) and 2) cannot be the problem in my case I suppose it is 3).\nSo my request is: it would be nice when IKernel.Dispose() would clean up everything so that creating another kernel would not lead to any problems.\n\u2014\nReply to this email directly or view it on GitHub.\n. I would suggest you trying Ninject.MockingKernel. By using the MockingKernel, you could call Reset to clear the cache while keep the bindings, rather than create/dispose kernel for every test.\nYou can find more details from its wiki https://github.com/ninject/ninject.mockingkernel/wiki\n. Please use this nuget package: Ninject.Extensions.Wcf.WebHost\n. You got it. It's already being pushed.\n. Please make sure your link is correct: http://srv.symbolsource.org/pdb/Public\n. @remogloor @danielmarbach , any updates?\n. InSingletonScope will lock the kernel when Resolve. In your sample, thread1 will lock kernel1 and then try to lock kernel2, thread2 will lock kernel2 and then try to lock kernel1. That's the reason of your dead lock.\n. I don't think it's a bug. It is not recommended that more than one kernel is introduced in one application. \n. Both platforms are not supported now. . Can you please send a sample to me?\n. @jowensboggs scott-xu at msn.com\n. @jowensboggs  It works in my case.\n. Please upgrade every Ninject packages to the latest stable version. Especially Ninject.Web.Common and Ninject.Web.WebApi\n\n\u53d1\u81ea\u6211\u7684 iPhone\n\n\u5728 2015\u5e742\u670826\u65e5\uff0c07:58\uff0cjnpwly notifications@github.com \u5199\u9053\uff1a\nAlso, somebody else came across the same problem, here: http://stackoverflow.com/questions/28570477/web-api-2-owin-3-ninject-web-webapi-owinhost-error-at-startup-only\n\u2014\nReply to this email directly or view it on GitHub.\n. ``` C#\nvoid AddBefore()\n            where TComponent : INinjectComponent\n            where TExistingImplementation: TComponent, INinjectComponent\n            where TImplementation : TComponent, INinjectComponent;\n\nvoid AddAfter()\n            where TComponent : INinjectComponent\n            where TExistingImplementation: TComponent, INinjectComponent\n            where TImplementation : TComponent, INinjectComponent;\n```\n. Fixed in the latest commits\n. Why your ClassA implement IInitializable?\n. Can you please send me a sample? scott-xu at msn.com\n. @mattwarren @idavis \nCould you please try https://github.com/ninject/Ninject/pull/179\n. I think it was not considered for this case\n. Please refer https://github.com/ninject/Ninject/issues/84\n. ReadOnlyKernel has been backed out.. Agree to merge if someone makes it support\n. I just ported version 3.2 to .net core: https://github.com/scott-xu/Ninject\n. Not yet\n\u53d1\u81ea\u6211\u7684 iPhone\n\n\u5728 2016\u5e747\u670826\u65e5\uff0c13:48\uff0cMichael Whelan notifications@github.com \u5199\u9053\uff1a\nHi @scott-xu. Is it available on NuGet, or what is the best way to get hold of it?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Pushed to Nuget\n. No need any more. Fixed https://github.com/ninject/Ninject/issues/187 and https://github.com/ninject/Ninject/issues/171\n. Also fixed https://github.com/ninject/Ninject/issues/143\n. Once we implement 'If Then Else', we need to implement 'Switch Case'. It should be language feature so I think the Bind<ILoginService>.ToMethod() is generic enough.\n. Please try request.Target.Member.ReflectedType\n. @onovotny any thoughts?\n. This PR is a fresh porting from last released 3.2.\nSince PCL is dead, we don't need any PCL specified csproj files nor PCL related conditional compilations.\nSome highlights:\n1. Omitted ReadOnlyKernel temporarily as its still at early stage.\n2. One xproj with one project.json is enough. We can improve if xproj is completely obsoleted. \n3. Regarding platform, netstandard 1.5 plus net 4.5 should be enough. Most of the platform specified conditional compilation has been removed. \n\n\u53d1\u81ea\u6211\u7684 iPhone\n\n\u5728 2016\u5e747\u670831\u65e5\uff0c05:00\uff0cOren Novotny notifications@github.com \u5199\u9053\uff1a\nOkay, here's what I think --\nThis PR has too many changed files... 545. That should not be required to add .NET Core support and makes this PR nearly impossible to review. The .NET Core bits should be split out from whatever else is in here (formatting, etc).\nAdding .NET Core support should be really easy here...so whatever was done seems like overkill. It looks like everything was moved to xproj but I can't really tell.\nThe approach I would recommend for adding .NET Core support is as follows:\nConvert the existing facade project to netstandard1.0. My blog post shows how to do that.\nAdd a new project, a csproj based PCL that targets netstandard1.3\nGiven the current directory structure, you'll need to ensure that the project.json file names include the project name -- so you'll have Ninject.project.json, Ninject.ios.project.json, etc... and you'll add a new csproj called Ninject.netstandard and with a Ninject.netstandard.project.json. (be sure to update the intermediate object directories to prevent directory conflicts similar to the rest of the projects there).\nBasically, I believe you can implement everything needed using a NETStandard 1.3 library and you'll simply \"add an output\" to the package.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I'll try set it up. \n\n\u53d1\u81ea\u6211\u7684 iPhone\n\n\u5728 2016\u5e747\u670831\u65e5\uff0c05:01\uff0cOren Novotny notifications@github.com \u5199\u9053\uff1a\nThe other issue is that we need access to the existing CI server so we can disconnect it and to the NuGet account so we can update the original packages. Otherwise the only packages I can update is Portable.Ninject as I don't have the account info for the others.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. What's your preference about csproj and xproj?\n. I'd prefer xproj before VS15 RTM, because it supports\n- Build packages directly from the project\n- Multi-targeting\n. Ok, let's move forward.\n. There are a few trick codes involved to support .netstandard 1.3. Considered about the uwp usage and to build a consolidated code base, I think .netstandard 1.5 is the way to go. I'll update the code.\n. Also, the upcoming tools can convert the xproj to the next version of csproj. So let's use xproj at this moment.\n. Can you please try Ninject.Extensions.Factory and Ninject.Extensions.ContextPreservation. Duplicate with https://github.com/ninject/Ninject/issues/237\nFixed in https://github.com/ninject/Ninject/commit/4f5a384d881151583e76863ad5eefe1a0265d0bd. A simple solution is to resolve it.. Fixed by https://github.com/ninject/Ninject/commit/8de2b0273df05fae25d49bccaaef4e7df7a3d34a. Fixed in https://github.com/ninject/Ninject/commit/969b20b15ebd44268986d4dad1f2189339233a7a. Fixed by https://github.com/ninject/Ninject/commit/bf47cc9e81b754209791858d637096adcaa2e13e. 3.3 is on progress. . Please let Ninject manage your DbContext. You were creating the DbContext yourself and as I can see there's only one instance and never gets disposed. . Bind DbContext in request scope. You didn't bind DbContext. Where?. var context=new DbContext(\"someparameter\",\"connectionStrin\");\nThe above context is not managed by Ninject. public class NinjectDependencyResolver()\n{\n  kernel.Bind().ToMethod(ctx=>new DbContext(\"someparameter\",\"connectionStrin\")).InRequestScope();\n  kernel.Bind().To();\n  kernel.Bind().To();\n}. It seems that your kernel is not from IoCKernel. Fixed . will do. 3.3 beta1 is released with netstandard2.0 and without ReadOnlyKernel. @davethieben if people are using 4.0 alpha/beta, they have to change ReadOnlyKernel and KernelConfiguration back to StandardKernel.\nI know it may not be the best decision to back out ReadOnlyKernel. However, to make a stable release targeting just bug fix and .net standard support is far more urgent than performance tuning. Ninject slept too long... If we continue 4.0 ReadOnlyKernel, to be honest, I don\u2019t have confidence to make a stable release in the near future.\nHope you understand. I just want to make it progressive.. PR is welcome. Should be only one. Fixed in https://github.com/ninject/Ninject/commit/8de2b0273df05fae25d49bccaaef4e7df7a3d34a. Thanks for the info. Does Ninject add non-serializable object in logical call context?. Can you please create dump files and see if there's any dead lock?. Did you register any event at DomainUnload?. Please try the latest build\n\n\u53d1\u81ea\u6211\u7684 iPad\n\u5728 2017\u5e749\u670821\u65e5\uff0c16:49\uff0cagostinocinelli notifications@github.com<mailto:notifications@github.com> \u5199\u9053\uff1a\nHello,\ni'm facing a problem with Bind ToConstant()\nWhen I inject service into ViewModel, it get the constant, but when i call Get() in ServiceLocator, it creates a new instance.\nI think is a problem of the v4 beta, can anyone confirm?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHubhttps://github.com/ninject/Ninject/issues/248, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AB0yoWpKdw9aV2ozS76VcIk_L359VnLZks5skiL-gaJpZM4Pe_rl.\n. Try this please: https://ci.appveyor.com/project/scott-xu/ninject/branch/master/artifacts\n\u53d1\u81ea\u6211\u7684 iPhone\n\u5728 2017\u5e749\u670821\u65e5\uff0c20:01\uff0cagostinocinelli notifications@github.com<mailto:notifications@github.com> \u5199\u9053\uff1a\nv 4.0.0-beta-0134 already installed.\nMaybe it's not relevant, but some of solution's projects target .Net Standard 1.4 and some target Full Framework\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHubhttps://github.com/ninject/Ninject/issues/248#issuecomment-331135682, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AB0yoV-cHbLh4bakhElj_ElBDgg4idXyks5sklAYgaJpZM4Pe_rl.\n. Please try https://www.nuget.org/packages/Ninject/3.3.0-beta1. Unfortunately, Pirates do not start with \"N\". So, Ninjas win!. - [x] Ninject.Extensions.ContextPreservation\n- [x] Ninject.Extensions.Conventions\n- [x] Ninject.Extensions.Factory\n- [x] Ninject.Extensions.Interception\n- [x] Ninject.Extensions.Logging\n- [x] Ninject.Extensions.NamedScope\n- [x] Ninject.Extensions.Wcf\n- [x] Ninject.Extensions.MockingKernel\n- [x] Ninject.Web.Common\n- [x] Ninject.Extensions.Xml\n- [x] Ninject.Web.Mvc\n- [x] Ninject.Web.WebApi. Most ticked extensions are in beta phase. Please try the 3.3.0 beta versions from nuget.. Ninject.Extensions.Conventions 3.3.0-beta1 released just now. Please note that all \"NonePublic\" has been renamed to \"NonPublic\". thanks\uff01. thanks. Released @michaelestermann . It has been migrated to appveyor. Would you please try the latest build? https://ci.appveyor.com/project/Ninject/ninject/build/artifacts. In most cases, you don\u2019t need to call kernel.Load function because by default  Ninject will load extensions automatically. . Please set ninjectSetting.LoadExtensions to false if you want to load all dlls. Otherwise ninject extentions (in this case Ninject.Extensions.Interception) will be loaded twice.. It doesn\u2019t matter. Give it a try pls.. Thanks for reporting this!. Can you please share the error details\uff1f. Try this please https://ci.appveyor.com/api/buildjobs/540od47pnnym3kd2/artifacts/src%2FNinject%2Fbin%2FRelease%2FNinject.4.0.0-alpha073.nupkg. @hesourman Try https://ci.appveyor.com/api/buildjobs/8m3chce94wk92mj8/artifacts/src%2FNinject%2Fbin%2FRelease%2FNinject.4.0.0-alpha078.nupkg please.\nI just replaced LCG with Expression build system which makes Ninject not depend on System.Reflection.Emit.ILGeneration and System.Reflection.Emit.Lightweight. Thanks for reporting. Fixed just now.. I have a problem here. If optimize set to false, GC related unit tests will fail; if optimize set to true, we loose the ability to debug from visual studio. It\u2019s not a issue about this PR. Just wondering if you have any idea about this scenario. . The reason why we use \u201cNO\u201d prefix in symbol name is that we hope newer framework has fewer symbol. \nWhen .NET Core comes, AppDomain is an exception, Remoting has no clear plan. For Array.Empty, I hope we don\u2019t carry to every new framework. So I suggest keep using NO prefix.. AssemblyScanning is a feature which depends on AppDomain Isolation, and may potentially depends on AssemblyLoadContext in the future. The feature can be turned on/off by NinjectSettings. So I\u2019d suggest keep this symbol at this time.  . Okay, I realized that alias Array hides the System.Array.\nMy original intention is to keep code as consistent as possible. With \u201cArray\u201d alias, the Empty<T> method has a consist way to consume. \nI\u2019m just a little worried about the Array_Empty symbol because it brings more variants. \nLet\u2019s move on for .NET Framework 4.6. \nStarting with Ninject 4.0, we only support .NET 4.6+ and .NET STANDARD 2.0+. Sorry I should discuss first. After some thinking, I agree that the build-in symbols are not self-explained.\nLet me rollback the change.. Just defer materialize. Assembly Scanning is to scan assemblies and load Ninject Modules automatically. It is typically used for auto load Ninject extensions.. Ok, I understand your question. Yes we need to \n- [x] use AssemblyLoadContext (Assembly.LoadFile) for .NET Standard to load assemblies in isolation\n- [x] remove NO_ASSEMBLY_SCANNING in ExceptionFormatter.. BTW, we can use <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies> in ninject extensions' unit test project to resolve issue about loading assemblies from nuget packages.. I'd prefer sunset InjectNonPublic. In my opinion, this behavior is not the best practice. Non public is designed to not be changed externally. Thoughts?. And private constructors, private methods.. Do we need to Define Constants explicitly?. Could you please try tick \"Suppress JIT optimization on module load (managed only)\" at Options->Debugging->General? If it works, we can \n\nmake all UT pass even using debug configuration\ndebug Ninject.Test (hit break point, inspect variables, etc.). It would be best if we can make the tests pass with optimization turned off. However, GC does not behave the same between optimization on/off when tests are running under .NET Core.. Just curious what\u2019s the difference between LINQ Any and handwritten for-condition-break?. Is it benefited from static method?. This looks interesting: https://nessos.github.io/LinqOptimizer/. Let\u2019s move it to Ninject.Components namespace. . It makes sense to me. You can update package with \"IgnoreDependencies\" switch. @drieseng Can you please help me understand why this change could improve the performance?. Thanks!. \n",
    "shartte": "Good idea using a read write lock in this situation. \nAlthough I would plan to replace this with a ConcurrentDictionary when the minimum .NET version for Ninject is bumped to 4 (which may take a while ;-).\nWhen it is bumped to 3.5, I would use the included ReadWriteLockSlim instead of the copied implementation.\n. ",
    "andhernand": "I did some research and found out that it is something to do with a Git feature I do not use. I apologize for taking up your time. I will close this issue.\n. ",
    "alecthomas": "The top of the trace is in GetParentDefinition (), ExtensionsForMemberInfo.cs:139 ...\n. ",
    "qdtitan": "Thank you for your quick reply.  I did notice that this is an error that I had in my code, not from you guys.  :)\nThe table name in SQL Server is Survey, and I don't know how and where this query is coming from that is looking for a table called Surveys.\nLooking through the code and trying to find it now....\n\n[System.Data.Entity.DbSet]    {SELECT \n[Extent1].[SurveyID] AS [SurveyID], \n[Extent1].[SurveyName] AS [SurveyName], \n[Extent1].[SurveyDescription] AS [SurveyDescription], \n[Extent1].[SurveyStartDate] AS [SurveyStartDate], \n[Extent1].[SurveyEndDate] AS [SurveyEndDate], \n[Extent1].[SurveyCode] AS [SurveyCode], \n[Extent1].[surveytypeid] AS [surveytypeid]\nFROM [dbo].[Surveys] AS [Extent1]}  System.Data.Entity.DbSet\n. ",
    "agatsenko": "Thank you for the explanation\u044e\n. ",
    "otakustay": "After a little deeper research, I found this is not a problem of the System.Net.WebProxy class, but a more generic one.\nThe fact is, whenever I have a class with a public property, the injection fails with a NullReferenceException, here is a really simple example:\n```\npublic class Test {\n    public int MyProperty { get; set; } // Can be any type\n}\nclass Program {\n    [STAThread]\n    static void Main(string[] args) {\n        IKernel kernel = new StandardKernel();\n        kernel.Bind().ToSelf();\n        Console.WriteLine(kernel.Get());\n    }\n}\n```\nThis program fails when running with mono, the stacktrace is:\nUnhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object\n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.get_ParentDefinitionMethodInfo () [0x00000] in <filename unknown>:0 \n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.GetParentDefinition (System.Reflection.MethodInfo method, BindingFlags flags) [0x00000] in <filename unknown>:0 \n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.GetParentDefinition (System.Reflection.PropertyInfo property) [0x00000] in <filename unknown>:0 \n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.IsDefined (System.Reflection.PropertyInfo element, System.Type attributeType, Boolean inherit) [0x00000] in <filename unknown>:0 \n  at Ninject.Infrastructure.Language.ExtensionsForMemberInfo.HasAttribute (System.Reflection.MemberInfo member, System.Type type) [0x00000] in <filename unknown>:0 \n  at Ninject.Selection.Heuristics.StandardInjectionHeuristic.ShouldInject (System.Reflection.MemberInfo member) [0x00000] in <filename unknown>:0 \n  at Ninject.Selection.Selector+<>c__DisplayClass3.<SelectPropertiesForInjection>b__2 (IInjectionHeuristic h) [0x00000] in <filename unknown>:0 \n  at System.Linq.Enumerable.Any[IInjectionHeuristic] (IEnumerable`1 source, System.Func`2 predicate) [0x00000] in <filename unknown>:0 \n  at Ninject.Selection.Selector.<SelectPropertiesForInjection>b__1 (System.Reflection.PropertyInfo p) [0x00000] in <filename unknown>:0 \n  at System.Linq.Enumerable+<CreateWhereIterator>c__Iterator35`1[System.Reflection.PropertyInfo].MoveNext () [0x00000] in <filename unknown>:0 \n  at System.Collections.Generic.List`1[System.Reflection.PropertyInfo].AddEnumerable (IEnumerable`1 enumerable) [0x00000] in <filename unknown>:0 \n  at System.Collections.Generic.List`1[System.Reflection.PropertyInfo].AddRange (IEnumerable`1 collection) [0x00000] in <filename unknown>:0 \n  at Ninject.Selection.Selector.SelectPropertiesForInjection (System.Type type) [0x00000] in <filename unknown>:0 \n  at Ninject.Planning.Strategies.PropertyReflectionStrategy.Execute (IPlan plan) [0x00000] in <filename unknown>:0 \n  at Ninject.Planning.Planner+<>c__DisplayClass1.<CreateNewPlan>b__0 (IPlanningStrategy s) [0x00000] in <filename unknown>:0 \n  at Ninject.Infrastructure.Language.ExtensionsForIEnumerableOfT.Map[IPlanningStrategy] (IEnumerable`1 series, System.Action`1 action) [0x00000] in <filename unknown>:0 \n  at Ninject.Planning.Planner.CreateNewPlan (System.Type type) [0x00000] in <filename unknown>:0 \n  at Ninject.Planning.Planner.GetPlan (System.Type type) [0x00000] in <filename unknown>:0 \n  at Ninject.Activation.Providers.StandardProvider.Create (IContext context) [0x00000] in <filename unknown>:0 \n  at Ninject.Activation.Context.Resolve () [0x00000] in <filename unknown>:0 \n  at Ninject.KernelBase+<>c__DisplayClass10.<Resolve>b__c (IBinding binding) [0x00000] in <filename unknown>:0 \n  at System.Linq.Enumerable+<CreateSelectIterator>c__Iterator27`2[Ninject.Planning.Bindings.IBinding,System.Object].MoveNext () [0x00000] in <filename unknown>:0 \n  at System.Linq.Enumerable+<CreateCastIterator>c__Iterator17`1[TestCmd.Test].MoveNext () [0x00000] in <filename unknown>:0 \n  at System.Linq.Enumerable.Single[Test] (IEnumerable`1 source, System.Func`2 predicate, Fallback fallback) [0x00000] in <filename unknown>:0 \n  at System.Linq.Enumerable.Single[Test] (IEnumerable`1 source) [0x00000] in <filename unknown>:0 \n  at Ninject.ResolutionExtensions.Get[Test] (IResolutionRoot root, Ninject.Parameters.IParameter[] parameters) [0x00000] in <filename unknown>:0 \n  at TestCmd.Program.Main (System.String[] args) [0x00000] in <filename unknown>:0\nSo I think this must be a big problem in NInject core, is there any temporary methods to get rid of it?\n. ",
    "ungood": "Thanks.  No hurry, it's a fairly obscure bug, I only ran into it by being too careless with the conventions extension.\n. Latest nuget releast 3.0.0.15\n. ",
    "jarrettmeyer": "@danielmarbach - I hope that helps. If there's some other condition that you wanted me to test, please let me know and I will try to add it. I've been using Ninject since pre-1.0, but never really needed to get into the guts of it before.\n. ",
    "IDisposable": "I was just mirroring the conditional used in ActivationCache.cs.  One or the other is right, sadly I don't have a Mono setup to validate against.\n. Doh, looks like a typo that the GitHub+me compiler didn't catch.\n. ",
    "Pathoschild": "Thanks! Could you publish a NuGet package for the medium trust build, or would you mind if I published one?\n. ",
    "andreswatson": "We have the same problem, we are trying to use Ninject in Rackspace CloudSites environment that is a \"modified\" MediumTrust level, we tried in several ways being sure that the assembly is set to AllowPartialCallers and we are getting the same security / permission error message:\n[SecurityException: Request for the permission of type 'System.Security.Permissions.SecurityPermission, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' failed.] System.AppDomain.get_Evidence() +24 Ninject.Modules.AssemblyNameRetriever.CreateTemporaryAppDomain() +19 Ninject.Modules.AssemblyNameRetriever.GetAssemblyNames(IEnumerable1 filenames, Predicate1 filter) +50 Ninject.Modules.CompiledModuleLoaderPlugin.LoadModules(IEnumerable1 filenames) +87 Ninject.Modules.ModuleLoader.LoadModules(IEnumerable1 patterns) +379 Ninject.KernelBase.Load(IEnumerable1 filePatterns) +40 Ninject.KernelBase..ctor(IComponentContainer components, INinjectSettings settings, INinjectModule[] modules) +359 Ninject.KernelBase..ctor(INinjectModule[] modules) +92 Ninject.StandardKernel..ctor(INinjectModule[] modules) +5 TPS.Framework.NInject.NinjectIocContainer..ctor(INinjectModule[] modules) in NinjectIocContainer.cs:22 WebServices.Global.CreateKernel() in Global.asax.cs:22 Ninject.Web.Common.Bootstrapper.Initialize(Func1 createKernelCallback) +16 Ninject.Web.Common.NinjectHttpApplication.Application_Start() +102\nAny idea or suggestion?\nThanks in advance, Andres Watson (aw@smedia.com)\n. ",
    "mc0re": "I'd very much like the PDB file for Ninject - where can I find it now, that it's not a part of NuGet??\n. I've read that pushing PDB file to symbolsource.org is also an option.\n. I can't see it there, nor can VS 2013!\n. But VS 2013 cannot see it, then...\nI set symbol server to http://symbolsource.org to no avail.\nDate: Thu, 8 Jan 2015 01:37:14 -0800\nFrom: notifications@github.com\nTo: Ninject@noreply.github.com\nCC: mnikitin@hotmail.com\nSubject: Re: [Ninject] Please add PDB file for Ninject (#160)\nYou got it. It's already being pushed.\n\u2014\nReply to this email directly or view it on GitHub.\n=\n. I do not build Ninject, I only use it - got via NuGet. So I cannot build PDB files.\nBy the way, you're right, PDB files can differ for the same source files, because recompilation can take a slightly different route.\nDate: Thu, 8 Jan 2015 07:49:18 -0800\nFrom: notifications@github.com\nTo: Ninject@noreply.github.com\nCC: mnikitin@hotmail.com\nSubject: Re: [Ninject] Please add PDB file for Ninject (#160)\nCould it be that the pdb file is from same source revision but from a different build?\nAs far as i remember: If you do a rebuild the resulting pdb file does not match the dll file anymore - even if there were no source file changes at all.\n\u2014\nReply to this email directly or view it on GitHub.\n=\n. ",
    "onovotny": "Hi Ian,\nI\u2019d be happy to discuss this further with the team and I know that David Kean and Daniel Plaisted from Microsoft would be interested too. David is the owner of the PCL\u2019s and wants to ensure they are successful. I\u2019m sure they\u2019d like to know about your concerns about PCL\u2019s.\nThe main idea here is that the main interfaces/base classes are exposed across the broadest possible platform set. Then, the entrypoint can have platform-specific implementations where necessary.\nI know that a lot of people want to use portable view models to share code amongst desktop, winrt and phone apps, and having a DI framework is critical to that.\nBtw, I have posted the portable version to NuGet under Portable.Ninject and Portable.Ninject.Common.\nRegards,\nOren\nFrom: Ian Davis [mailto:notifications@github.com]\nSent: Thursday, August 30, 2012 10:22 AM\nTo: ninject/ninject\nCc: Oren Novotny\nSubject: Re: [ninject] Portable Class Library support for Ninject (#65)\nHi Oren,\nThanks for the impressive pull request. This will need to be discussed with the other project maintainers when they are back from their vacations. I am not sure if this is a direction we want to go as the portable libraries are a very poor solution that can't be extended. I realize our setup is far from ideal as well; Microsoft has very poor vision in this area.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/pull/65#issuecomment-8160922.\n. We have a grand vision in this area that we\u2019ve not yet made clear to the public.  Feel free to rant/point out where you think we\u2019re going wrong, my team owns this, and we\u2019re all ears. \u263a\nFrom: Oren Novotny [mailto:oren@novotny.org]\nSent: Thursday, August 30, 2012 7:28 AM\nTo: ninject/ninject; ninject/ninject\nCc: David Kean; Daniel Plaisted\nSubject: RE: [ninject] Portable Class Library support for Ninject (#65)\nHi Ian,\nI\u2019d be happy to discuss this further with the team and I know that David Kean and Daniel Plaisted from Microsoft would be interested too. David is the owner of the PCL\u2019s and wants to ensure they are successful. I\u2019m sure they\u2019d like to know about your concerns about PCL\u2019s.\nThe main idea here is that the main interfaces/base classes are exposed across the broadest possible platform set. Then, the entrypoint can have platform-specific implementations where necessary.\nI know that a lot of people want to use portable view models to share code amongst desktop, winrt and phone apps, and having a DI framework is critical to that.\nBtw, I have posted the portable version to NuGet under Portable.Ninject and Portable.Ninject.Common.\nRegards,\nOren\nFrom: Ian Davis [mailto:notifications@github.com]mailto:[mailto:notifications@github.com]\nSent: Thursday, August 30, 2012 10:22 AM\nTo: ninject/ninject\nCc: Oren Novotny\nSubject: Re: [ninject] Portable Class Library support for Ninject (#65)\nHi Oren,\nThanks for the impressive pull request. This will need to be discussed with the other project maintainers when they are back from their vacations. I am not sure if this is a direction we want to go as the portable libraries are a very poor solution that can't be extended. I realize our setup is far from ideal as well; Microsoft has very poor vision in this area.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/pull/65#issuecomment-8160922.\n. Remo,\nIf you look at the split of the code, that's why only \"non functional\" base classes/interfaces and stuff around defining the modules, type associations, etc are in the portable library. The part that does the resolution/execution/checks attributes, is still in the platform-specific one that's used by the entrypoint, so you can still work-around those issues.\nAnother option is to use a \"feature detection\" like approach, where you can test for a behavior using some internal classes and then take the appropriate action. \n. I just wanted to add a few more points to the discussion:\n1) What's the usage of some of the older platforms? Is it worth still supporting them?\nSL3 and below must be nearly zero with even SL4 being very low at this point. As of several months ago, only Mango WP's could connect to the store, so there's no point in WP7; only 7.1. As far as .NET, at what point do you make the cut-off? I know that xUnit is going 4.5 for their 2.0 version. \nOne option could be to bring the portable changes in as Ninject 4.0. Leave the current bits \"as-is\" for existing users on down-level platforms with bugfixes brought in as appropriate. At some point, it's time to move forward.\nIf you can move forward, then the build system gets a lot easier. If you can support .NET 4, WP7.1, SL4 and WinRT, then you eliminate most of the build configurations. In fact, you'd have really only two build configurations: Microsoft (with MSBuild) and non-Microsoft (whatever mono version you want to support).\nThis would simplify the build and packaging significantly.\n2) Feature detection. You've already identified the areas where behavior is slightly different as you do have unit tests for them. Instead of just validating at test time, that same logic/check can be done once at runtime and be turned into an if statement.\nFor example, here's how I test for support of private reflection in MVVM Light:\nhttp://mvvmlight.codeplex.com/SourceControl/network/forks/onovotny/MvvmLightPortable/changeset/view/1f53e9699eb6#GalaSoft.MvvmLight%2fPortable%2fGalaSoft.MvvmLight%2fHelpers%2fFeatureDetection.cs\nIn the WeakAction* classes, there are if statements based on that, but it doesn't need to be an #ifdef.\nifdef's make it hard and fragile to refactor as a developer is more likely to miss something that's used in another build configuration.\n3) Platform-specific. Not everything can be done in a PCL. Some optimizations are platform specific, like the ILGenerator. That can be put into a single lib references the bulk of the shared code. Most code can be portable.\n4) Value. As others have said, the value is mostly for library developers, consumers of Ninject. I'd like to point out that I have no knowledge of any internal plans, so the following is 120% speculation. Going forward, there'll be more .net-based platforms. You'll have WP8 soon, but that's not going to be 100% compatible with desktop WinRT. You'll need a PCL if you want to have code run on that in addition to your desktop app. A little further out, let's think about \"next box\"/xbox 720/whatever. I'd be shocked if WinRT wasn't on it in some form given the desire to have code run everywhere and the living-room's prominence. That'll probably need a PCL too.\nThe point is, is that there's an upcoming explosion of platforms that are mostly similar. Library authors aren't going to want to have to recompile their library for each specific platform. Looking at it this way, portable libraries are a huge win. Write once, and have the same file work on all of the platforms.\nApplication developers benefit hugely as well -- the bulk of the code from the view model down can be portable. When a new platform comes along, all they need to do is write a new set of view's that fit the UI paradigm and attach the rest of their portable code. Much faster and easier than multiple libraries, etc.\n. Windows Universal apps, and Xamarin ones, are supported in my Ninject fork, Portable.Ninject: https://github.com/onovotny/ninject. The nuget package is Portable.Ninject\n. Ah, yes, sorry....I haven't yet updated Ninject to support Wpa81 yet; it only has wp8. This has been on my to-do list... \nI'm not sure if I'll have time to get to this in the next week or two, but I'd happily take a PR. It shouldn't really be that hard as the Wpa81 project/version should follow the same as Win8 -- use linked files, the same symbols, etc. That's the good news as Wpa81 is very close to WinRT. If there's a PR with this done, I can update the NuGet easily anytime.\nWhat I really wanted to do is follow the \"Bait and switch\" PCL pattern to eliminate the need for two dlls -- there doesn't need to be a \"platform\" assembly with the right #ifdefs/substitutions by NuGet. Just getting Wpa81 done though isn't hard.\n. Awesome news, great to hear!\nOne point for consideration for 4.0 should be the removal of pre .NET 4.5 platforms, including Silverlight. Doing so would remove many (most?) of the #ifdef's and make the code easier to maintain.\nFor users who still need Silverlight or .NET 4, they can continue to use the 3.x releases, those packages wouldn't disappear.\nThis will also help with the needed netcore50 support to enable ASPNet 5 Core with DNX (and better support for UWP projects in Win10).\nI'd be happy to start that process of removing those platforms in branch from my current bait-and-switch to speed that along if the team is interested.\n. Yes, I'll get it merged in properly. It's a big set of changes so it may take me a few days.\nI also noticed a bug in the xunit vs runner that I need to track down. I'd been using .99.5 with the beta-5 of xunit 2 just fine. After updating to 2.0 rtm, tests don't show in the test explorer window now.\n. As I'm going through the merge, I noticed that the build symbols for Silverlight are gone. Can I safely assume that SL support is gone and remove that from the PCL? Better question: what are the expected targets for 4.0?\n. So I would propose the following mostly due to PCL and VS issues\nDrop SL5 and Win8 (Win 8.1 is ok). Very likely drop wp8 as well (as it's Silverlight based).\nThat should allow all of the #ifdef's around the reflection to go away completely as Mono is 4.5 compatible.\nVS 2015 will not open a Win 8 project and SL5 brings back \"old\" reflection. \nFor Win8, I'd say that most people have updated to 8.1 and/or will go to 10 very soon. I can't see that many people sticking around Win8-only.\nFor SL5, those apps are mostly in maintenance now.... they can stay with Ninject 3 while they get rewritten :P\n. :+1:\nI'll get the merge done first as any bigger changes should be done once merged to the main repo to minimize conflicts. \n. Looks good! The only question is whether explicit dnx support is required or if they can use the net45 or netcore5. Dnx is core + dnx runtime env, and ask the needed types might not need dnx. That said, netcore5 isn't on Nuget yet and won't likely be ready until win 10 RTM.\nGuess it's TBD.\nOnce netcore5 is ready, that should simplify versions going forward too \n. Master branch is merged in and tests pass. I'm now removing SL5 and WP8 and changing the PCL/project targets to .net 4.5.1.\n. Okay @scott-xu, should be good to go \n. It's more than that presently. The PCL portion is really a fa\u00e7ade, a reference assembly. It still needs a compiled version; this should be do-able with a \"modern PCL\" that targets Win10, ASPNet5 and Net46 but it's a matter of time.\n. I've just setup a new CI build with a MyGet CI packages feed.\nhttps://www.myget.org/F/ninject/api/v2\nCan you give that a shot? It has a build fresh from the last hour or so.\n. @danielcweber I'm working on getting the main package updated. The bits in there will the same though as the portable code has merged into the main codebase. What's breaking with the portable package for you? The assembly names and identity (Strong name) are the same as the \"Regular\" package?\n. Gotcha, makes sense. I'm trying to get the main package updated but it might be a few days\n. Is there any chance you can update to the VS 2015 Community Edition? It has far more features than VS 2013 Express and is free.\nWhat you're seeing there is a PCL profile, 151, it's not a real 4.6 target but has to do with where the PCL libraries sit on disk.\n. Can you please add a unit test project for DNX as well? \n. Working on the build machine. AppVeyor is setup but the current build server is interfering\nhttps://ci.appveyor.com/project/onovotny/ninject\n. Okay, here's what I think -- \n1.  This PR has too many changed files... 545. That should not be required to add .NET Core support and makes this PR nearly impossible to review. The .NET Core bits should be split out from whatever else is in here (formatting, etc).\n2.  Adding .NET Core support should be really easy here...so whatever was done seems like overkill. It looks like everything was moved to xproj but I can't really tell.\nThe approach I would recommend for adding .NET Core support is as follows:\n1.  Convert the existing Ninject facade project to netstandard1.0. My blog post shows how to do that.\n2.  Add a new project, a csproj based PCL that targets netstandard1.3\nGiven the current directory structure, you'll need to ensure that the project.json file names include the project name -- so you'll have Ninject.project.json, Ninject.ios.project.json, etc... and you'll add a  new csproj called Ninject.netstandard and with a Ninject.netstandard.project.json. (be sure to update the intermediate object directories to prevent directory conflicts similar to the rest of the projects there).\nBasically, I believe you can implement everything needed using a NETStandard 1.3 library and you'll simply \"add an output\" to the package.\n. The other issue is that we need access to the existing CI server so we can disconnect it and to the NuGet account so we can update the original packages. Otherwise the only packages I can update is Portable.Ninject as I don't have the account info for the others.\n. PCL is not dead...it's just evolved to be netstandard. It's the same concept. You do need the conditional compilations or this will stop working for anything less than netstandard1.5. In that case, you're excluding UWP...netstandard 1.3 is where most of the functionality comes in.\nDoing what I suggest ensures that Ninject continues to work on all of the existing platforms. It's really easy to do. \nAll the ifdef's are still required, just that the netstandard1.3 version (one that works with net 4.6, uwp, and .net core) probably is closest to the desktop .net version.\nOne benefit is that Xamarin can support netstandard 1.6, so the Xamarin specific outputs can probably go away...but the win8/wp8 stuff can't unless those are dropped....which I'm actually fine with.\nSo in the end, I think that there can be a single netstandard1.3 output and the rest of the heads can go away. Support for older platforms can be dropped.\nAlso, csproj is the way to go as xproj is a dead-end. With a single netstandard1.3 output, this should be easy.\n. I'll create a branch that demonstrates...won't be fully complete\n. Take a look here: https://github.com/ninject/Ninject/tree/netstandard\nIt's compiling for net45 and netstandard1.3, so that should be all we need. It still needs some cleanup and ifdef removal, but I think it's a good starting point...\nThoughts?\n. I guess I don't see the point in moving everything to xproj when we'll be getting csproj back in a few months. Besides, the WinRT bits need hacks to compile with xproj. It's just easier to not bother for now.\nOnce the fall hits and csproj can multi-target, then there can be some big cleanup.\nThe NuGet package isn't a big deal, IMO, esp since the packages already exist. It's just one more build step to call nuget pack.\n. @scott-xu I really disagree here, we cannot drop UWP. My other branch has this all done and working with both netstandard 1.4 for UWP and 1.5.\n. I would recommend using NuSpec.ReferenceGenerator to add/update the dependencies as they can change over time and the tool will ensure they're up-to-date.\n. ",
    "davkean": "Sorry, that reply looked like it can from Oren, but actually came from me. I'll repeat it: \nWe have a grand vision in this area that we\u2019ve not yet made clear to the public.  Feel free to rant/point out where you think we\u2019re going wrong, my team owns this, and we\u2019re all ears. \u263a\nDave Kean\ndavkean AT Microsoft DOT com\n. ",
    "dsplaisted": "For Ninject, Portable Class Libraries probably won't do much to simplify your project structure and build system, because you target platforms which aren't supported by portable libraries and because there are pieces of Ninject that aren't portable.  The value would mostly be that people writing cross-platform apps using portable libraries would be able to use Ninject in their shared portable code.\nI've written a blog post on How to Make Portable Libraries Work for You which has a lot of information about how to take advantage of portable libraries, either as an app or a library author.  It also has links to sample apps and other code that demonstrate the patterns I talk about in the post.\nThe next version of NuGet will support portable libraries, so you will be able to have a folder in your package for something like lib/sl4+net40+wp7+winrt with portable DLLs that run on all those platforms.  Then NuGet will use those DLLs when you reference the package from a portable library with compatible targets, or from a platform specific library if you don't have a separate lib folder for that platform.\nAs far as bugs/implementation differences across the platforms go, the APIs that are usable from portable libraries should work the same way across platforms.  The big list of differences you linked mostly covers APIs that are not usable from portable libraries, or corner cases which are hopefully rarely hit and easily worked around.  The list of behavior differences for portable libraries is much shorter and the main issues have to do with reflection over generics on Windows Phone 7.\nIn any case, it looks like you've already identified the differences that affect you and handled them behind conditional compilation.  So the code that behaves differently can either go in the platform-specific Ninject library (as it looks like Oren has done), or in some cases you can do a runtime check in portable code to determine what code path to take.\nI took a look and it looks like a lot of the code which is platform specific in this pull request could be moved to the portable Ninject.Common project without much work.  For example a lot of the WINRT #ifdefs just deal with the reflection API changes, but from a portable library which targets older platforms you can still use the old APIs and run on WinRT/Windows Store/Metro [sic] style.\nDoes this help clarify things?\nDaniel Plaisted (MSFT)\n. ",
    "Soflar": "Hey,\nThe code is that crashes is this:\ncsharp\n            Bind<LinkedSetCache<long, Guid,\nNotificationCache.CachedNotification>.IRepository>().To<NotificationCache.Repository>().InRequestScope();\nIt crashes in the first part, even if the .To and .InRequestScope methods\nare removed.\nThe classes are nested like this:\n``` csharp\n    public class NotificationCache\n    {\n        public class Repository : LinkedSetCache.IRepository\n        {\n        }\n    }\npublic class LinkedSetCache<TSetIdentifier, TItemIdentifier, TItem> {\n\n    public interface IRepository\n    {\n    }\n}\n\n```\nAt Runtime, typeof(LinkedSetCache<long, Guid,CachedNotification>.IRepository).Name evaluates to \"IRepository\"\nThis is the exception detail:\n```\nSystem.ArgumentOutOfRangeException was unhandled by user code\nHResult=-2146233086\nMessage=Length cannot be less than zero.\nParameter name: length\nSource=mscorlib\nParamName=length\nStackTrace:\n   at System.String.InternalSubStringWithChecks(Int32 startIndex, Int32\n\nlength, Boolean fAlwaysCopy)\n   at System.String.Substring(Int32 startIndex, Int32 length)\n\n   at Ninject.Infrastructure.Introspection.FormatExtensions.Format(Type\n\ntype) in\nc:\\Projects\\Ninject\\ninject\\src\\Ninject\\Infrastructure\\Introspection\\FormatExtensions.cs:line\n162\n   at Ninject.Syntax.BindingRoot.Bind[T]() in\n\nc:\\Projects\\Ninject\\ninject\\src\\Ninject\\Syntax\\BindingRoot.cs:line 57\n   at\n\nBGD.Commons.Web.General.BGDWebsiteCommonModule.BindNotifications(DMSRepositorySettings\nrepositorySettings) in e:\\Backseat\nGames\\BackseatWeb\\code\\trunk\\BGD.Commons.Web\\General\\BGDWebCommonModule.cs:line\n68\n   at BackseatWeb.MvcApplication.BGDWebsiteModule.Load() in e:\\Backseat\n\nGames\\BackseatWeb\\code\\trunk\\BackseatWeb\\Global.asax.cs:line 103\n   at Ninject.Modules.NinjectModule.OnLoad(IKernel kernel) in\n\nc:\\Projects\\Ninject\\ninject\\src\\Ninject\\Modules\\NinjectModule.cs:line 85\n   at Ninject.KernelBase.Load(IEnumerable`1 m) in\n\nc:\\Projects\\Ninject\\ninject\\src\\Ninject\\KernelBase.cs:line 217\n   at Ninject.KernelBase..ctor(IComponentContainer components,\n\nINinjectSettings settings, INinjectModule[] modules) in\nc:\\Projects\\Ninject\\ninject\\src\\Ninject\\KernelBase.cs:line 100\n   at Ninject.KernelBase..ctor(INinjectModule[] modules) in\n\nc:\\Projects\\Ninject\\ninject\\src\\Ninject\\KernelBase.cs:line 57\n   at Ninject.StandardKernel..ctor(INinjectModule[] modules) in\n\nc:\\Projects\\Ninject\\ninject\\src\\Ninject\\StandardKernel.cs:line 46\n   at BackseatWeb.MvcApplication.CreateKernel() in e:\\Backseat\n\nGames\\BackseatWeb\\code\\trunk\\BackseatWeb\\Global.asax.cs:line 62\n   at Ninject.Web.Common.Bootstrapper.Initialize(Func`1\n\ncreateKernelCallback) in\nc:\\Projects\\Ninject\\Ninject.Web.Common\\src\\Ninject.Web.Common\\Bootstrapper.cs:line\n50\n   at Ninject.Web.Common.NinjectHttpApplication.Application_Start() in\n\nc:\\Projects\\Ninject\\Ninject.Web.Common\\src\\Ninject.Web.Common\\NinjectHttpApplication.cs:line\n80\nInnerException:\n```\nI hope this provides you with all the information you need.\nSam\nOn Thu, Aug 30, 2012 at 4:14 PM, Ian Davis notifications@github.com wrote:\n\nAny chance you can give an integration test or code sample?\nThanks!\nIan\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/66#issuecomment-8160694.\n. All code needed to reproduce this issue is included.\n\nTwo classes that can be defined:\npublic class NotificationCache\n{\n    public class Repository : LinkedSetCache<long, Guid,\nCachedNotification>.IRepository\n        {\n        }\n    }\n```\npublic class LinkedSetCache {\npublic interface IRepository\n{\n}\n\n}\n```\nThe setup in global.asax:\nBind<LinkedSetCache<long, Guid,\nNotificationCache.CachedNotification>.IRepository>().To().InRequestScope();\nThe bind statement itself will crash.\nWhat more of a demonstration sample do you require?\nOn Tue, Jan 8, 2013 at 7:22 PM, Remo Gloor notifications@github.com wrote:\n\nhis issue still needs a demonstration sample.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/66#issuecomment-12009859.\n. Where I use it, it's like this:\n\nabstract class Cache {\n    interface IRepository {\n    }\nCache(IRepository repository) { // constructor\n   }\n}\nI then changed it to this:\nabstract class Cache {\n   Cache(ICacheRepository repository) { // constructor\n   }\n}\ninterface ICacheRepository {\n}\nand then I have a\nclass ForumCache : Cache {\n   ForumCache(Cache.IRepository repository) : base(repository) { //\nconstructor\n   }\n}\nwhich didn't work so I changed it to:\nclass ForumCache : Cache {\n   ForumCache(ICacheRepository repository) : base(repository) { //\nconstructor\n   }\n}\nOf course a lot of code was left out here. In fact I'm reconstructing this\nfrom memory, I don't have the files right now where I'm writing from.\nSo basically I still have the same functionality with a tiny work-around\nthat changes nothing to the architecture overall, just to the way in which\nI declare the classes. I simply wanted to let you know there was a bug in\nyour code which made it not support this case. I did this because I thought\nyou would care, not because I am so bothered by it. From my point it is I\nwho is doing you a service by reporting, not you doing me a service by\nfixing this issue.\nIn conclusion, I feel I have spent enough time explaining this minor bug to\nyou as it has no dire implications for either you or me whether this gets\nfixed or not. I would rather not discuss this any further as I feel that\nI'm only troubling you with an issue you'd rather not know about. So feel\nfree to mark this as fixed and ignore it.\nThis may seem unfair of me to say. I really respect your framework and all\nthe time you must have put in. I'm just not a fan of the attitude I'm\ngetting when, in the end, all I'm trying to do is help you improve your\nproduct.\nOn Sat, Feb 9, 2013 at 2:03 AM, Remo Gloor notifications@github.com wrote:\n\nI really don't know if I even want to fix such a bug in case it should\nstill exists.\nNested classes are really not meant to be used outside of the parent\nclass. And therefore I don't see any situation where I want to inject such\na class into another. This just seems to be a very bad design imo.\nCan anyone give me a real example to convince me this has a good use?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/66#issuecomment-13323217..\n. \n",
    "georgboe": "This issue seems to be fixed in the current HEAD. The following example fails when using the dll available on NuGet.\n``` C#\nclass Program\n{\n    static void Main()\n    {\n        var kernel = new StandardKernel(new RuntimeModule());\n    }\n}\npublic class RuntimeModule : NinjectModule\n{\n    public override void Load()\n    {\n        Bind.ISomething>().ToSelf();\n    }\n}\npublic class SomeClass\n{\n    public interface ISomething\n    {\n    }\n}\n.\nCan anyone give me a real example to convince me this has a good use?\n```\nNo, I can not and I agree about it being bad design.\nYou requested a sample and I provided one based on Dodgedog's description. I also tested it on 5c82ddc0acdafa28c8db47b5164f472730ccca4f and it did not throw an exception. So I think this issue can be closed.\n. ",
    "JanWosnitza": "Hi remogloor, I found the bug with:\n- Unity 3.5.4f1: MonoDevelop 2.8.2 ninject.dll: Mono 2.0\nand reproduced it with (code from above):\n- VS-Project: .NET Framework 4.0 ninject.dll: .NET Framework 4.0\n- VS-Project: .NET Framework 4.0 ninject.dll Mono 2.0\n. ",
    "aaubry": "Sorry about that. I have replaced the tabs with spaces. I am new to github, do I need to do to anything to update the pull request?\n. ",
    "mjvh80": "Sure, I get that you want to cache using a hash code, however, I feel the current code is not right and one cannot rely on the object's GetHashCode for reasons mentioned above. How about my suggestion?\n. Have you had a chance to think some more about this? It would certainly seem better to me that the behaviour is correct, even at the cost of some performance. If there's anything more I could do to help let me know.\n. ",
    "ghost": "Sorry for the late response. This should be useful when you want to activate the modules which in turn need some binds are already set.\n. Ok this is true, but if module A need an istance of module B, module B must be loaded before module A.\n. The code is not exactly what you wrote but the final effect is the same. In my case I pass the kernel to a factory that instantiates objects (with custum logics) that need some binds that have already been registered. \n. i read somewhere that godady allows medium trust packages. Thats why i am getting this exception . So I should use Ninject with Medium Trust ... \nCan please somebody guide me where I can get Ninject medium trust for Asp.net framework 4.5 ?? I tried to look on Nuget on ASP .net But it only shows the Ninject the one I installed .. \nPlease help\n. is switching to Unity for medium trust is the only solution  ??? \nIs there anybody who can tell me how to use Ninject with medium Trust ???\n. Thanks for Replying Danielmarbach  !!!\nAnd thanks much for the url .. I am going to download special medium trust package .. and will come back .. \n. Here s What i did ... \nDownloaded Ninject with Medium Trust PAckage. Unzip it and Replaced the dll file with the old one. \nThen added code as you said ...\nINinjectSettings settings = new NinjectSettings\n            {\n                UseReflectionBasedInjection = true, // disable code generation for partial trust \n                InjectNonPublic = false, // disable private reflection for partial trust \n                InjectParentPrivateProperties = false, // reduce magic \n                LoadExtensions = false // reduce magic\n            };\nninject = new StandardKernel(settings);\n\nNow it is throwing following exception \n\nAttempt by security transparent method 'AnneAshley.WebUI.MvcApplication.Application_Start()' to access security critical method 'System.Web.Optimization.BundleTable.get_Bundles()' failed.\nAssembly 'AnneAshley.WebUI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null' is marked with the AllowPartiallyTrustedCallersAttribute, and uses the level 2 security transparency model.  Level 2 transparency causes all methods in AllowPartiallyTrustedCallers assemblies to become security transparent by default, which may be the cause of this exception.\nDescription: An unhandled exception occurred during the execution of the current web request. Please review the stack trace for more information about the error and where it originated in the code. \nException Details: System.MethodAccessException: Attempt by security transparent method 'AnneAshley.WebUI.MvcApplication.Application_Start()' to access security critical method 'System.Web.Optimization.BundleTable.get_Bundles()' failed.\nAssembly 'AnneAshley.WebUI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null' is marked with the AllowPartiallyTrustedCallersAttribute, and uses the level 2 security transparency model.  Level 2 transparency causes all methods in AllowPartiallyTrustedCallers assemblies to become security transparent by default, which may be the cause of this exception.\nSource Error: \nLine 25:             FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);\nLine 26:             RouteConfig.RegisterRoutes(RouteTable.Routes);\nLine 27:             BundleConfig.RegisterBundles(BundleTable.Bundles);\nLine 28: \nLine 29:             // Setting own Controller Builder.\nSource File: d:\\VisualStudio\\AnneAshley\\AnneAshley.WebUI\\Global.asax.cs    Line: 27\nAny Suggestions ???\n. I did not get the solution of this problem. Finally I switched to Unity. So far it is working good. \nThank you Daniel for your time and effort.\n. Hi Scott. I've tried to reproduce in a simple project but I can't. Everything seems to be fine when I Dispose a Kernel. In my project it seems to be more complex. Maybe one of the NInject extensions is causing this issue.\n. Thanks Scott. I'll give it a try next week. I think we can close this issue now.\n. ",
    "grajdeanserghei": "Thank you for quick reply. I expected something like this.\nI will change my architecture. Unfortunately this is not first time when I change my applications because of bugs in Windows :(\n. ",
    "dermeister0": "All classes must be public on Windows Phone 7.1 when using reflection to access their methods.\n. Looks like it's WP SDK bug.\n. ",
    "furier": "any updates on this?\n. ",
    "SharpNoiZy": "If it's not a bug (Then I expect you tested my scenario), can you give the answer to my question?\n. ",
    "Mystere": "While I appreciate your point, I think it is a bit short sighted.  Yes, Ninject may be only 1% of an application run on normal hardware, but many of us are running apps on very high end servers that need fast response times.  We tune the apps to remove all the normal bottlenecks, and what that does is raise the percentage of time spent resolving objects by significant amounts.  \nAdd in the fact that you may have rather complex call graphs, each with their own sets of objects that need to be resolved, and it can become quite extensive.  If Ninject is truly 10-100x slower than other common containers (and I'm not talking about the tiny ones, i'm referring to Unity, Windsor, etc..) the that becomes exponential as the number of objects you resolve grows.\nHell, i'd be happy if we could improve it by 50%.  Please, let's keep this open so that it can be something that eventually gets addressed.\n. ssakharov is definitely on to something here.  The locks seem to be a huge part of the problem.\nAs an unsafe test, I did nothing but remove the locks around the MultiMap objects and re-ran the Palmmedia benchmark test, and performance more than doubled across the board.  \nI think we need to look into the locking strategy in use here and figure out why it's blocking so much.\n. Would it maybe make more sense to do a re-write from scratch?. ",
    "jsmarsch": "For what it's worth, microbenchmark or not, performance differences like these are enough to scare me away.  I'm at the start of a large enterprise application.  We're not doing anything realtime, but I can't afford to have timeouts or a slow app.  I really like the ninject API.  Heck, I even like the name!  But we're talking orders of magnitude in performance difference, I'm just not willing to take the risk that it will only be a 1% hit.\n. I am getting this error as well (Using Ninject, and Ninject.Extensions.Factory).  The only way I could upgrade was to uninstall Ninject.Extensions.Factory and then upgrade ninject, and then reinstall ninject.extensions.factory.  . ",
    "martinkoslof": "Hmmmm, this topic seems to be gaining more momentum and I'm curious what specific areas or \"advanced\" features are the most costly regarding performance. For example we use Ninject heavily within an MVC application and most objects are Request scoped. We have leveraged some additional add ins, such as Ninject.Extensions.Conventions and I'm ok with extensions and advanced assembly scanning being \"slower\". In those scenarios, yes you are choosing flexibility over performance (within reason).\nAre there particular things we should \"avoid\" with Ninject to help boost our performance?  I'd really like to see more time or conversations around this topic. We have been doing some heavy performance tuning recently and we've already done a massive amount of Entity Framework/LINQ optimizations and Razor view pre-compilation, CSS and JS optimizations and now Ninject/IOC is going to need to be evaluated as well.\nThanks\n. I'm not sure if your comments are directed towards me, or someone else in the comments thread, but I'm not sure what nomenclature in my last post lead you believe I am having \"timeouts\", or that I'm misusing the IOC Container. I also didn't say Ninject was slow/unusable to the point where my application was worse off. There have been several bench-marking articles written and other people I talk to also have commented that Ninject is \"slower\" then other IOC containers.\nIf 10 solutions exists and yours is deemed the slowest it doesn't mean its time to stop using it...it means it is the SLOWEST of those tested.  Yes, there are many advantages and extensions to Ninject which I find useful (also noted in my comments). \"Real world performance\" also comes down to your expectations. If you are trying to get as optimized as possible, and another IOC container is x times faster the question isn't \"what's wrong\" but \"how can this be faster as well\".\nI also didn't say Ninject was too slow for my existing MVC application. ALL aspects are beening performance tested and tweaked and our IOC implementation is going to be tested next. If another IOC container is faster and provides all the functionality we currently use, we might switch over.  Overall I find nothing about this topic irrational or riddled in FUD.\n. I also started  using Simple Injector for my MVC web apps. I think it does a good job while remaining performant.\n. ",
    "ssakharov": "I think I have a real world example of when performance is important for IoC container.\nSome background:\nWhen I joined my current company and started working on the project it was a big and messy mix of all layers (originally it was designed as active-record but later it grew into something big with UI specific stuff leaking through business logic, data access straight into DB). On top of that system uses no-longer supported ORM (Gentle.NET) and not even latest version of it. One of the main reasons why it became like this is because the company grew too fast and project had to catch up with whatever human resources were available.\nBy the time I joined, company got bought by a bigger one and amount of change requests grew dramatically in their scope and complexity without allowing for a major rewrite of the system itself.\nAt that point decision was made that we should start extracting layers of the system without breaking it. The most obvious/easiest one was data access (which is the opposite to where you'd usually start introducing DI). That allowed us to decrease amount of mess and leave only service/domain and parts of presentation mixed up. Additionally we now had a chance to start transition to a different ORM.\nNOTE: all of those changes should be done to the live system without breaking it while it undergoes business-related transformation.\nTo cut out that part, decision was made to extract data access and inject it using service location backed by Ninject.\nFast forward to present: While the new projects are designed with DI in mind and do not need service location - core of the system is still using it very extensively. Meaning e.g. every http request from most of the websites will cause thousands of resolution calls. (sorry I do not have any numbers on my hands but I saw profiles at some point and they were much larger than 1% and comparable to some IO calls by total time per business transaction)\nI am not trying to pretend that this is a \"correct\" usage of the container whatever that word means. But it is real-world enough for me and was driven by imperfect real-world decisions.\n. Just did live profiling for 5 minutes. It showed that Ninject.Activation.Context.Resolve had 1.1m calls that took 51k seconds to complete which is really close to be 66% of CPU time.\nI haven't had a chance looking into the problem in more details yet. Regardless that does not seem like a normal performance to me anyway.\nNinject version: 3.0.1.10\n. So, after trying out perf. tryout branch following are the profile summaries for same set of load tests on the app that I ran on my dev machine. Branch indeed brings some improvements in performance but nowhere close enough to address the issue.\nAs far as I can tell problem here with lock contention since when profiling with \"Thread Cycle Time\" measurements, Context.Resolve times become negligible.\nTherefore, at the moment we have decided to follow 2 routes of how to try to fix our app performance:\n1. Change ninject's MultiMap implementation to use ConcurrentDictionary and remove corresponding locks\n2. Get rid of static scoped bindings in our web apps and have kernel per thread for service location\n\nUpdate:\nThis is how profile looks with proof-of-concept implementation of thread-static kernels:\n\n. Could you try https://github.com/ninject/ninject/issues/97 on your solutions? Seems pretty relevant to me and apparently it was not merged into perf tryouts branch when I tried it out. If I understand code correctly it should reduce locks a lot if you mostly using transient scope.\n. ",
    "Plasma": "Hi,\nI've recently benchmarked a few of our services and threw hundreds of requests against a server.\nUsing Ninject 3.0.10.1 Context.Resolve() takes up an abnormally large amount of time.\nI can't see from the profiling any of my own code being used (the page being loaded is supposed to be a simple blank page, but it has dependencies to be resolved).\nHigh level time taken:\n\nAnd when diving into Context.Resolve:\n\n@ssakharov does this look similar to yours / any thoughts?\nI also notice there's a large GC time, not sure if this is Ninject's fault.\n. #97 is interesting, as part of my load testing - using a mix of transient and singleton scopes only - I sometimes seemed to get deadlocks (CPU was 0%, but IIS threads were all backed up).\n@ssakharov do you think #97 would also affect non-request scopes?\n. I'm not sure how frequently at runtime other people are adding bindings, but I do it once-off during a static constructor and adds about 30 things at once and never again.\n. I have done some performance improvements using ConcurrentDictionary at https://github.com/ninject/ninject/pull/102 (all tests pass)\n. I switched to another dependency framework as my improvements still weren't enough to remove Ninject from showing up on dotTrace profiler, as the first or second longest running code point, when my ASP.NET app was under load.\nI just bit the bullet and spend a few hours moving everything across and have had no problems now, even under load I don't see the DI system appearing in any traces.\n. Also with regards to being \"slow\", I really mean it, its not 2ms slower, its 1000ms+ slower under load.\n. Simple injector, had near feature parity and was benchmarked as one of the fastest (google for IOC benchmarks .net)\nSent from my iPhone\n\nOn 5 Apr 2014, at 7:44 am, Michael Aird notifications@github.com wrote:\n@Plasma out of curiousity, what did you switch to?\n\u2014\nReply to this email directly or view it on GitHub.\n. Not to derail this project, but I ended up replacing Ninject with\nSimpleInjector and DI stopped showing up in profiling sessions, I\u2019d\nrecommend it.\n\nOn Sun, 22 Apr 2018 at 7:11 am, Quentin notifications@github.com wrote:\n\nHas anyone found a registration/dependency pattern with Ninject that's\nperformant for resolving conditional dependencies?\nWe have interfaces that have multiple implementations where the specific\nimplementation resolved depends on things like configuration values that\ncan change at any time or based on parameters in the web request. Most of\nthese are registered ToMethod which checks a condition and resolves a\nspecific class with IContext.Kernel.Get. Many of these are also registered\nInScope to the current thread or http context object.\nResolving these dependencies consumes a lot of time and literally costs us\nreal money in increased compute resource needs. Our main application serves\n20M-30M requests per day and over the years I've profiled multiple pieces\nof functionality in our app where Ninject resolution consumes up to 50% of\nCPU times.\nHere's an example of the types of registrations that resolve especially\nslowly.\nbuilder.Kernel.Bind().ToSelf().InRequestOrTransientScope();\nbuilder.Kernel.Bind().ToSelf().InSingletonScope();\nbuilder.Kernel.Bind>()\n        .ToMethod(c => {\n            var ctx = c;\n            return () => CacheDiagModeFromHttpContext()\n                            ? ctx.Kernel.Get()\n                            : (ICacheDiagnostics)ctx.Kernel.Get();\n        })\n        .InSingletonScope();\nbuilder.Kernel.Bind().ToMethod(ctx => {\n    switch (CacheTypeFromHttpContext()) {\n        case \"redis\": return ctx.Kernel.Get();\n        case \"memory\": return ctx.Kernel.Get();\n        default: return ctx.Kernel.Get();\n    }\n}).InRequestOrTransientScope();\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ninject/Ninject/issues/84#issuecomment-383331601, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAN_WW3piiubgEFWk5Yk93hMw32c2Nmuks5tq6CdgaJpZM4Acfx5\n.\n. \n",
    "chaim1221": "Any updates on this? I'm thinking about using the -pre and was wondering if the performance changes made it in.\n. Daniel--does -pre from Nuget include those improvements?\n. ",
    "Telavian": "I also am very curious if there has been any work on this. I used Ninject for a WPF project a while ago and never saw any issues, but have heard from other developers that they won't use Ninject because it is \"slow\".\n. I looked at autofac, is it similar?\nOn Apr 4, 2014 3:17 PM, \"martinkoslof\" notifications@github.com wrote:\n\nI also started using Simple Injector for my MVC web apps. I think it does\na good job while remaining performant.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/ninject/issues/84#issuecomment-39617117\n.\n. \n",
    "michaelaird": "@Plasma out of curiousity, what did you switch to?\n. ",
    "cr7pt0gr4ph7": "@BrunoJuchli @scott-xu \nI'm very in favor of something like .Snapshot(), because that's what it is really wanted. Automatic change detection would be even better, e.g. using optimistic version numbers, see below.\nMost of the time in Resolve() is probably spent in searching for matching bindings to the constructor, and then searching for matching bindings for the parameters of those bindings, and so on.\nThe current process goes like this (I'm concentrating on constructor injection using StandardProvider for now):\n1. KernelBase.Resolve:\n   - Looks for a binding that matches in the current context\n   - Creates an instance of Ninject.Activation.Context and calls Context.Resolve()\n2. Context.Resolve\n   - Determines the scope by looking at the request or, if the former has no associated scope, the matching binding (using IBinding.ScopeCallback, passing in the current context).\n   - Lock on the scope and call Context.ResolveInternal\n3. Context.ResolveInternal (executed while a lock on the scope is held!):\n   - Queries Ninject.Activation.Caching.ICache to get the already activated instance for the current scope\n   - Gets the provider that matches the current context (using IBinding.ProviderCallback)\n   - Call IProvider.Create(IContext)\n4. StandardProvider.Create:\n   - ...uses the ConstructorScorer to select an appropriate constructor, thus yielding an ConstructorInjectionDirective.\n   - ...get the injection targets (i.e. the constructor arguments) from the ConstructorInjectionDirective and call StandardProvider.GetValue to resolve them, which in turn:\n     - Looks if the context contains an IConstructorArgument,\n     - Or, if not, calls ITarget.ResolveWithin.\n5. Target.ResolveWithin\n   - Calls IRequest.CreateChildRequest, and\n   - IKernel.Resolve(IRequest) to resolve the request.\nSo, to improve performance, many information from the steps above can be cached:\n1. KernelBase.Resolve\n   - Look for an ICachedActivationPlan for the given type and context, which already contains:\n     - The binding to activate.\n     - The ICachedActivationPlan instances for the parameters required by the binding.\n2. Context.Resolve\n   - (Use a special case for the transient scope that avoids a delegate call to ScopeCallback when the is always returning null anyway (e.g. via delegate == null)?).\n   - Do not take a coarse lock here; instead, take more granular locks in Context.ResolvIInternal.\n3. Context.ResolveInternal\n   - For non-scoped singletons:\n     - Note that locks are taken on this instance of ICachedActivationPlan\n     - Note that the cached instance for a binding is stored in an instance field of ICachedActivationPlan, which is protected using the double-null-check idiom (see below):\n   - For transient bindings:\n     - No locking of the cachedInstance field needed.\n   - Bindings with custom scopes (e.g. HttpContext):\n     - These currently pose a problem.\n4. StandardProvider.Create\n   - Determine the constructor to be used at the time when ICachedActivationPlan is created.\n   - For each constructor parameter, use the binding for that injection target that is already cached in the ICachedActivationPlan, and also represented as an ICachedActivationPlan.\nFor change detection, one could use an optimistic versioning approach, such that a counter is incremented whenever the kernel transitions from \"unmodified\" to \"dirty\". This way, binding caches (that contain instances of ICachedActivationPlan) can check \"their\" version number with the current one, and only update their data (on take a lock on the kernel's data structures) when really necessary.\nThe main point is to cache the activation plan for a binding, and let it contain pointers to other activation plans for other related binding, such that searches in the internal datastructures are avoided, as well as avoiding coarse locks over the whole kernel / the whole scope / a certain binding, even when viewed from different scopes.\n@BrunoJuchli\nI've got a version that contains the latest changes from #142, but excludes the readonly kernel, over at [https://github.com/cr7pt0gr4ph7/Ninject/tree/pull-request/old-kernel], if you want to experiment with the design as it was before the introduction of IReadonlyKernel.\n\nDouble null check\ncsharp\nif (instance == null) {\n    lock (this) {\n        if (instance == null) {\n            instance = new ...();\n         }\n    }\n}\n. One idea for realizing snapshots would be to use System.Collections.Immutable, smartly combining immutable collections and their builders, so that locks can be completely avoided in the fast path.\nThe idea would be that, at the start of the resolution operation, the current state of the kernel's data structures is stored in the IRequest (or IContext, maybe) and passed down to child resolution operations.\nModifcations of the kernel are done by swapping out the pointer to the data structure using an atomic operation (note that loading and setting variables that contain a pointer to a reference type is always done atomically according to the CLR specification./.object references are\nPossibly problematic is the scenario of concurrent modifications, but this could be avoided by taking a lock only for threads wishing to modify the IKernel. The other problematic area is the resolution cache, see my comment above for more information.\n. The only additional functionality of IReadOnlyKernel that I can see is that it allows to clone a \"template\" kernel, so that it is based on the same configuration but does not share the activated instances etc. But I can't imagine a real use case for that; neither one, which could not be solved using an IKernel.Clone() method.\n. Thank you for the pointer to #84! That answers my question of the \"why\".\nI'm glad that using a readonly kernel is not set in stone, but instead only a mean to an end (that is, better activation performance), which could possibly be reached in another way. One way would be caching of the resolved bindings.\nI'll add further discussion to #84, but I'm leaving this issue open, because, as it stands, it is a problem.\n. ",
    "qstarin": "Has anyone found a registration/dependency pattern with Ninject that's performant for resolving conditional dependencies?\nWe have interfaces that have multiple implementations where the specific implementation resolved depends on things like configuration values that can change at any time or based on parameters in the web request. Most of these are registered ToMethod which checks a condition and resolves a specific class with IContext.Kernel.Get. Many of these are also registered InScope to the current thread or http context object.\nResolving these dependencies consumes a lot of time and literally costs us real money in increased compute resource needs. Our main application serves 20M-30M requests per day and over the years I've profiled multiple pieces of functionality in our app where Ninject resolution consumes up to 50% of CPU times.\nHere's an example of the types of registrations that resolve especially slowly.\n```\nbuilder.Kernel.Bind().ToSelf().InRequestOrTransientScope();\nbuilder.Kernel.Bind().ToSelf().InSingletonScope();\nbuilder.Kernel.Bind>()\n        .ToMethod(c => {\n            var ctx = c;\n            return () => CacheDiagModeFromHttpContext()\n                            ? ctx.Kernel.Get()\n                            : (ICacheDiagnostics)ctx.Kernel.Get();\n        })\n        .InSingletonScope();\nbuilder.Kernel.Bind().ToMethod(ctx => {\n    switch (CacheTypeFromHttpContext()) {\n        case \"redis\": return ctx.Kernel.Get();\n        case \"memory\": return ctx.Kernel.Get();\n        default: return ctx.Kernel.Get();\n    }\n}).InRequestOrTransientScope();\n```. ",
    "niwrA": "Same here ... . ",
    "jamesmanning": "My apologies for opening this issue - I didn't realize the pull request would create one as well, so I'll close this one since #90 has already been merged.\nThanks, Remo!!\n. ",
    "LorenDorez": "Hi I have been working with the creator of WebActivator closely for a new issue that arose with update to .net 4.5 using MVC. We have patched a work around in WebActivator 2.0.2, but ninject this requires 1.5.x\nCan you please update ninject to use the latest WebActivator\n. ",
    "apdmatos": "I've added some unit tests to generic types. Sorry for the mess here and for the anonymous commit\n. Hi,\nHave you already checked the unit tests that I've added?\nCheers!\n. Yes. I am sorry... I've been a little busy, but can I try to fix it till the next weekend?\n. Can you please test and check if everything is ok now? \nCheers!\n. I've executed the unit tests locally and they passed... Can't see anything on that url. Don't have username & password to access\n. i think that now it's done. It passes the build now.\n. ",
    "brucewilkins": "I dont have permission to add issues to that repo, if anyone there has could you do it for me please?\n. ",
    "stefanbynature": "Thanks Remo! Will look at getting this into testing as soon as possible.\n. Just posting to let you know that we've been running the build linked above in production for almost 2 months now. It has resolved the deadlocking and we haven't experienced any other issues. Thanks again for your help.\n. ",
    "jbdutton": "I have also noticed this issue, specifically with the Ninject.Web extension. I can successfully inject services into a Web Forms page but other, previously working and unchanged pages begin receiving null references from FindControl. Removing Ninject.Web fixes the problem.\n@bizzehdee I don't have a solution for you but if I come across one I'll share.\n. @bizzehdee, yours may turn out to be a different issue, but I've also opened a ticket with Ninject.Web:\nhttps://github.com/ninject/ninject.web/issues/12\n. ",
    "caledhwa": ":+1: I'd love to see some benchmarks on how this might improve the performance on .net 4+\n. ",
    "drieseng": "I'm currently working on improving throughput, and reducing memory pressure.\nThat said, replacing locks with ConcurrentDictionary\\ is not always feasible.\nIt should be reviewed on a case-by-case basis.\nFor example, your changes in Planner  would cause a regression because ConcurrentDictionary does not guarantee that valueFactory in ConcurrentDictionary<TKey, TValue>.GetOrAdd (TKey key, Func<TKey,TValue> valueFactory) is only executed once when a key does not exist.\nAlso, ConcurrentDictionary\\ uses about twice the memory.\n. I moved (recreated) this issue in the issue tracker for Ninject.Extensions.Wcf.\n. I'm working on this. See also #276.\nI've started submitting PRs, but it will take a while before all my local changes end up in master.. - [x] Remove double lookup in ComponentContainer.ResolveInstance(Type component, Type implementation) (#310).\n- [x] Remove double lookup in ComponentContainer.RemoveAll(Type component) (#310).\n- [x] Remove double lookup in ComponentContainer.Remove<T, TImplementation>() (#310).\n- [x] Eliminate Linq in ComponentContainer.CreateNewInstance(Type component, Type implementation) (#310).\n- [x] Remove double lookup in Multimap<TKey,TValue>.this[TKey key].\n- [x] Remove double lookup in Multimap<TKey,TValue>.Remove(TKey key, TValue value).\n- [x] Remove double lookup in Multimap<TKey,TValue>.ContainsValue(TKey key, TValue value).\n- [ ] Eliminate virtual method calls in Ninject.Planning.Plan.\n- [x] Remove double lookup in BindingMetadata.Get<T>(string key, T defaultValue) (#313).\n- [x] Remove duplicate null checks in BindingMetadata (#313).\n- [x] Eliminate delegate allocation in NinjectModule.OnUnload() (#312).\n- [x] Eliminate use of ExtensionsForIEnumerableOfT.Map(this IEnumerable<T> series, Action<T> action) in NinjectModule.OnUnload() (#312).\n- [x] Eliminate virtual method calls in NinjectModule (#312).\n- [x] Introduce backing field of type List for NinjectModule.Bindings, and update NinjectModule.OnUnload() to use List<T>.ForEach(Action<T> action) instead of ExtensionsForIEnumerableOfT.Map<T>(this IEnumerable<T> series, Action<T> action) (which is much slower) (#312).\n- [x] Refactor NinjectSettings to no longer use a Dictionary to store the individual setting (#293).\n- [x] Refactor Context.IsCyclical(IRequest request) to a static method (#309).. Here's where we are up to now:\n|                          |  Singleton  | Transient |  Combined |\n|--------------------------|:-----------:|:---------:|:---------:|\n| No                       |     84244     |     121228  |    178 294   |\n| Ninject 3.3.4            |     47208964   |   1247621469  |  3607955305   |\n| Ninject master           |     16003123   |   54317861   |  1549520580   | \n| SimpleInjector 4.4.0     |     121329    |   176338    |    242454   |. New results available in #344.. I'd like to get a least a new beta out as soon as possible. It's not just up to me though. I don't even have access to manage our nuget packages.. As of this PR it's set to true for release builds, and false for debug builds.\nSo why not just use the release build config for the tests?. Doesn't the fact that the unit tests all passed for this PR, means it's already OK?. @scott-xu Do you need anything changed before we can get this in?. Hey Scott, \nDo you think you'll have time soon to review the PRs I submitted? \nCan we come up with another solution that will not block any work I'm trying to do? \nRegards, \nGert \n. Important:\nCommit https://github.com/ninject/Ninject/commit/dd1f10b6dd652b779bfac47d54e56c911035835a contains a breaking change for implementing custom a IBindingResolver.\nThe return type of the Resolve(IDictionary<Type, ICollection<IBinding>> bindings, Type service) method has changed from IEnumerable\\ to ICollection\\.\nThis change enables optimizations as we now immediately have access to the number of items in the collection.\n@scott-xu Let's discuss this, if this is a problem for you.. @scott-xu Do you need anything changed before we can get this in?. @scott-xu I know, but we're still targeting .NET Framework 4.5 (and .NET Standard 2.0). We could work with FEATURE compile symbols to support \"older\" target frameworks, while still allowing us to consume new APIs.\nThis is what I did for SSH.NET. I (partially) documented our \"switches\" here.\nNote that we should keep these to a minimum. For this aspect, SSH.NET is not the best example :-)\n. @scott-xu Can we get this in?. I'll update this PR accordingly.. I changed my PR to use negative symbols again.\nCan we consider changing Ninject.Infrastructure.Array back to Ninject.Infrastructure.Arrays again. I really don't think it's a good idea to \"hide\" System.Array.. I understand, but I was more worried about consistent usage of symbols.\nIn case of Array.Empty() we could indeed apply a static using.\nBut I doubt we ever run into such a situation again, and as such I preferred to apply the same technique we use for other framework-specific code.\nI'm ok with moving to .NET Framework 4.6, and postponing this discussion until we need such a mechanism again.\nI'll update this PR - and other PRs where I introduce the Arrays class - later today.\nIs this the only thing blocking my other PRs?\nIf not, let me know what you want me to change.. @scott-xu Can we get this in?. @scott-xu Why not discuss this first? Do you really think it is a better approach to use built-in symbols? \nI have either applied this approach before (eg. in NAnt and log4net), and I can say for sure that using FEATURE symbols is a much better approach.\nDo you for example think that .NET Standard 2.1 will also set NETSTANDARD2_0, or not?. No problem. You surely don't always have to agree with me.. I know, but IEnumerable itself isn't cheap, and since you'll need to access Parameters anyway (and even multiple times) you'll just postpone it and make it slower when you actually use it.\nI'll run some benchmarks on this later (this week).. Revised in #334.. I don't get why - in PropertyInjectionStrategy - we only create PropertyInjectionDirective instances for those properties with InjectAttribute, and then in PropertyInjectionStrategy we inject the PropertyValue parameters in the corresponding property regardless whether it has an InjectAttribute.. What's the reason for the conditional code (!NO_ASSEMBLY_SCANNING) in ExceptionFormatter?\nEven when NO_ASSEMBLY_SCANNING is set, we still scan assemblies (but not in isolation).. I totally agree!. I've created issue #297  to remove private property injection.. @scott-xu Apparently, we do not need to explicitly specify the DEBUG or TRACE symbols. VS build settings is badly broken as it shows the \"Define DEBUG constant\" as unchecked for the Debug config, but still sets it.\nChanging the VS config indeed allows one to debug with optimizations turned on.\nAnother option is to make our tests pass with optimizations turned off.\nThat way, there's no need to update VS config.\nI'm ok with whatever you prefer.. No, because locals are - for example - not collected immediately.\nYou can work around this by moving them into a separate method.\nI'll have a look.. Fixed by #338.. I'll look into the regression later today.. @scott-xu This one's now ready to go :p . It's a combination of factors:\n Less argument checks\n Reduction in IL code size\n Elimination of captures\n Less virtual method invocations\nWe can reduce allocations (and perhaps improve performance) even more by eliminating more usage of Linq, but let's take it one step at a time.. \u2026 and static methods are indeed cheaper than instance methods.. @scott-xu Can we get this in?. Yeah, but personally I think you should be aware when to use or not use Linq.\nI don't like the fact that the actual code that is generated is not visible to you.\nI see the benefit in it when you have a code base that heavily bets on Linq, and which you gradually want to refactor for performance. In that case LinqOptimizer is a no-brainer first step.\nWe are not (and less and less) a heavy Linq consumer. In most cases where we still use Linq, it is effectively a good solution.\nAre the changes in this PR bothering you? Let me know, and I'll see how I can address your concerns.\n. I'll take of the conflicts later.. @scott-xu Are you ok with this? If so, I'll submit a PR.. Updated as part of #344.. @scott-xu Please review this one.. @scott-xu Ready for review.. @scott-xu Can you find a little time to review this one? Thanks!. @scott-xu Since this is a trivial change, I'll go ahead and merge it.. @scott-xu This is a new extension method which I plan to use in a subsequent PR. Is this ok to merge?. This can be easily fixed (for 4.x or 5.x), but I'll need to discuss this with @scott-xu.. @pcroc @JaronPiet This is now fixed in master. As an added bonus you'll get some serious performance gains.. This is related to the use of method group vs. delegate.\nA delegate is cached by the compiler, method group is not.\nI'll update this PR (for Array.Empty<T>()) and re-run the benchmarks again to make sure the results are \"stable\".. I verified that the (minor) performance improvement for the constructor is indeed from replacing a method group by a delegate.. ",
    "khorvat": "Ok, this is expected but isn't it a bit odd to write   ... and everything is working and not throwing exception because this line of code was hit after the one with constructor arguments ? If this line was hit first then runtime exception will be thrown, I don't know to me this is odd behavior, thoughts ?\n. ",
    "hach-que": "We have both the conventions and factory extensions, they don't impair the unit test at all.\nWe're not testing \"is there a binding for IBlah\", but \"can we fully resolve IBlah\".  With the list of bindings, we basically call kernel.Get(type) and verify that all of the dependencies are satisfied.  So we do something similar to:\nAssert.DoesNotThrow(() =>\n{\n    var bindings = kernel.GetBindings();\n    foreach (var t in bindings)\n    {\n      kernel.Get(t);\n    }\n});\nIt's a bit more complex than this because we also find all Web Forms and MVC controllers and validate that they can be fully dependency injected as well.\n. I don't think it's likely this feature will ever end up in Ninject based on what's been discussed above.  In the end I wrote my own dependency injection system which supports validation.. I have verified that this works on Android now.\n. ",
    "jupaol": "It would be even better if Ninject exposed a method to verify the configuration is valid, something like the AssertConfigurationIsValid method in StructureMap http://docs.structuremap.net/QuickStart.htm\n. Any update on this?\n. ",
    "Dashue": "Wow still no action on this? \nI cannot count the times this would've prevented issues in production.\nAny workarounds or plans to introduce this?\n. ",
    "pimterry": "Is there an issue to track that? I'd find a verify() method useful, and I'd potentially be interested in helping put it together.\n. ",
    "jamiebarrow": "I too would like to verify that registered bindings can result in all resolutions to be successful, without having to write full system tests - not always possible to do this on legacy systems. I second (or well, third) the vote to have an IKernel.Verify() method, that would attempt to verify that all registrations can be resolved without missing dependencies.. ",
    "aaronasmith": "Yes.  I've also tried singleton and anything else I could think of.  It seems to ignore these when using the activation block.\n. I was trying to use mass transit with ninject and their ninject factory uses blocks.  For now I've had to switch over to another container.  I may log an issue with mass transit instead, but this seemed like a bug with ninject.\n. ",
    "alexmbaker": "Should anyone reading this need a work around I did the following:\nAdded the code included below to my c# project then simply called\nIKernel kernel = new StandardKernel(....\n.....\nkernel.EnsureSpecialCacheUsed();\nThe code included below is based on the current trunk source \nhttps://github.com/ninject/ninject/blob/master/src/Ninject/Activation/Caching/Cache.cs\n```\npublic static class NinjectExtensions\n{\n    /// \n    /// removes the standard cache and uses our one that has the bugfix \n    /// included to prevent stack overflow exceptions.\n    /// \n    /// \n    public static void EnsureSpecialCacheUsed(this IKernel kernel)\n    {\n        if (!kernel.GetAll().Any(v => v is Cache))\n        {\n            kernel.Components.RemoveAll();\n            kernel.Components.Add();  \n        }\n    }\n}\n//This modified cache based on the Ninject one eliminates the stack overflow exceptions that \n//can be thrown when circular references are established within the Ninject pipeline (often through\n//its own system for tracking disposable objects - changes are marked\n/// \n///     Compares ReferenceEqualWeakReferences to objects\n/// \npublic class WeakReferenceEqualityComparer : IEqualityComparer\n{\n    /// \n    ///     Returns if the specifed objects are equal.\n    /// \n    /// The first object.\n    /// The second object.\n    /// True if the objects are equal; otherwise false\n    public new bool Equals(object x, object y)\n    {\n        return x.Equals(y);\n    }\n/// <summary>\n///     Returns the hash code of the specified object.\n/// </summary>\n/// <param name=\"obj\">The object for which the hash code is calculated.</param>\n/// <returns>The hash code of the specified object.</returns>\npublic int GetHashCode(object obj)\n{\n    var weakReference = obj as ReferenceEqualWeakReference;\n    return weakReference != null\n               ? weakReference.GetHashCode()\n               :\n\nif !NETCF\nRuntimeHelpers.GetHashCode(obj);\n\nelse\n        obj.GetHashCode();\n\nendif\n}\n\n}\n/// \n///     Tracks instances for re-use in certain scopes.\n/// \npublic class Cache : NinjectComponent, ICache\n{\n    /// \n    ///     Contains all cached instances.\n    ///     This is a dictionary of scopes to a multimap for bindings to cache entries.\n    /// \n    private readonly IDictionary> _entries =\n        new Dictionary>(new WeakReferenceEqualityComparer());\n/// <summary>\n///     Initializes a new instance of the <see cref=\"Cache\" /> class.\n/// </summary>\n/// <param name=\"pipeline\">The pipeline component.</param>\n/// <param name=\"cachePruner\">The cache pruner component.</param>\npublic Cache(IPipeline pipeline, ICachePruner cachePruner)\n{\n    //Ensure.ArgumentNotNull(pipeline, \"pipeline\");\n    //Ensure.ArgumentNotNull(cachePruner, \"cachePruner\");\n\n    Pipeline = pipeline;\n    cachePruner.Start(this);\n}\n\n/// <summary>\n///     Gets the pipeline component.\n/// </summary>\npublic IPipeline Pipeline { get; private set; }\n\n/// <summary>\n///     Gets the number of entries currently stored in the cache.\n/// </summary>\npublic int Count\n{\n    get { return GetAllCacheEntries().Count(); }\n}\n\n/// <summary>\n///     Stores the specified context in the cache.\n/// </summary>\n/// <param name=\"context\">The context to store.</param>\n/// <param name=\"reference\">The instance reference.</param>\npublic void Remember(IContext context, InstanceReference reference)\n{\n    //Ensure.ArgumentNotNull(context, \"context\");\n\n    var scope = context.GetScope();\n    var entry = new CacheEntry(context, reference);\n\n    lock (_entries)\n    {\n        var weakScopeReference = new ReferenceEqualWeakReference(scope);\n        if (!_entries.ContainsKey(weakScopeReference))\n        {\n            _entries[weakScopeReference] = new Multimap<IBindingConfiguration, CacheEntry>();\n            var notifyScope = scope as INotifyWhenDisposed;\n            if (notifyScope != null)\n            {\n                notifyScope.Disposed += (o, e) => Clear(weakScopeReference);\n            }\n        }\n\n        _entries[weakScopeReference].Add(context.Binding.BindingConfiguration, entry);\n    }\n}\n\n/// <summary>\n///     Tries to retrieve an instance to re-use in the specified context.\n/// </summary>\n/// <param name=\"context\">The context that is being activated.</param>\n/// <returns>\n///     The instance for re-use, or <see langword=\"null\" /> if none has been stored.\n/// </returns>\npublic object TryGet(IContext context)\n{\n    //Ensure.ArgumentNotNull(context, \"context\");\n    var scope = context.GetScope();\n    if (scope == null)\n    {\n        return null;\n    }\n\n    lock (_entries)\n    {\n        Multimap<IBindingConfiguration, CacheEntry> bindings;\n        if (!_entries.TryGetValue(scope, out bindings))\n        {\n            return null;\n        }\n\n        foreach (var entry in bindings[context.Binding.BindingConfiguration])\n        {\n            if (context.HasInferredGenericArguments)\n            {\n                var cachedArguments = entry.Context.GenericArguments;\n                var arguments = context.GenericArguments;\n\n                if (!cachedArguments.SequenceEqual(arguments))\n                {\n                    continue;\n                }\n            }\n\n            return entry.Reference.Instance;\n        }\n\n        return null;\n    }\n}\n\n/// <summary>\n///     Deactivates and releases the specified instance from the cache.\n/// </summary>\n/// <param name=\"instance\">The instance to release.</param>\n/// <returns>\n///     <see langword=\"True\" /> if the instance was found and released; otherwise <see langword=\"false\" />.\n/// </returns>\npublic bool Release(object instance)\n{\n    lock (_entries)\n    {\n        var instanceFound = false;\n        foreach (var bindingEntry in _entries.Values.SelectMany(bindingEntries => bindingEntries.Values).ToList()\n            )\n        {\n            var instanceEntries =\n                bindingEntry.Where(cacheEntry => ReferenceEquals(instance, cacheEntry.Reference.Instance))\n                            .ToList();\n            foreach (var cacheEntry in instanceEntries)\n            {\n                Forget(cacheEntry);\n                bindingEntry.Remove(cacheEntry);\n                instanceFound = true;\n            }\n        }\n\n        return instanceFound;\n    }\n}\n\n/// <summary>\n///     Removes instances from the cache which should no longer be re-used.\n/// </summary>\npublic void Prune()\n{\n    lock (_entries)\n    {\n        var disposedScopes =\n            _entries.Where(scope => !((ReferenceEqualWeakReference)scope.Key).IsAlive)\n                   .Select(scope => scope)\n                   .ToList();\n        foreach (var disposedScope in disposedScopes)\n        {\n            //PINPOINT MODIFIED - Reversed order of these 2 lines of code to avoid stack overflow exception\n            _entries.Remove(disposedScope.Key);\n            Forget(GetAllBindingEntries(disposedScope.Value));\n        }\n    }\n}\n\n/// <summary>\n///     Immediately deactivates and removes all instances in the cache that are owned by\n///     the specified scope.\n/// </summary>\n/// <param name=\"scope\">The scope whose instances should be deactivated.</param>\npublic void Clear(object scope)\n{\n    lock (_entries)\n    {\n        Multimap<IBindingConfiguration, CacheEntry> bindings;\n        if (_entries.TryGetValue(scope, out bindings))\n        {\n            //PINPOINT MODIFIED - Reversed order of these 2 lines of code to avoid stack overflow exception\n            _entries.Remove(scope);\n            Forget(GetAllBindingEntries(bindings));\n        }\n    }\n}\n\n/// <summary>\n///     Immediately deactivates and removes all instances in the cache, regardless of scope.\n/// </summary>\npublic void Clear()\n{\n    lock (_entries)\n    {\n        Forget(GetAllCacheEntries());\n        _entries.Clear();\n    }\n}\n\n/// <summary>\n///     Releases resources held by the object.\n/// </summary>\n/// <param name=\"disposing\"></param>\npublic override void Dispose(bool disposing)\n{\n    if (disposing && !IsDisposed)\n    {\n        Clear();\n    }\n\n    base.Dispose(disposing);\n}\n\n/// <summary>\n///     Gets all entries for a binding withing the selected scope.\n/// </summary>\n/// <param name=\"bindings\">The bindings.</param>\n/// <returns>All bindings of a binding.</returns>\nprivate static IEnumerable<CacheEntry> GetAllBindingEntries(\n    IEnumerable<KeyValuePair<IBindingConfiguration, ICollection<CacheEntry>>> bindings)\n{\n    return bindings.SelectMany(bindingEntries => bindingEntries.Value);\n}\n\n/// <summary>\n///     Gets all cache entries.\n/// </summary>\n/// <returns>Returns all cache entries.</returns>\nprivate IEnumerable<CacheEntry> GetAllCacheEntries()\n{\n    return _entries.SelectMany(scopeCache => GetAllBindingEntries(scopeCache.Value));\n}\n\n/// <summary>\n///     Forgets the specified cache entries.\n/// </summary>\n/// <param name=\"cacheEntries\">The cache entries.</param>\nprivate void Forget(IEnumerable<CacheEntry> cacheEntries)\n{\n    foreach (var entry in cacheEntries.ToList())\n    {\n        Forget(entry);\n    }\n}\n\n/// <summary>\n///     Forgets the specified entry.\n/// </summary>\n/// <param name=\"entry\">The entry.</param>\nprivate void Forget(CacheEntry entry)\n{\n    Clear(entry.Reference.Instance);\n    Pipeline.Deactivate(entry.Context, entry.Reference);\n}\n\n/// <summary>\n///     An entry in the cache.\n/// </summary>\nprivate class CacheEntry\n{\n    /// <summary>\n    ///     Initializes a new instance of the <see cref=\"CacheEntry\" /> class.\n    /// </summary>\n    /// <param name=\"context\">The context.</param>\n    /// <param name=\"reference\">The instance reference.</param>\n    public CacheEntry(IContext context, InstanceReference reference)\n    {\n        Context = context;\n        Reference = reference;\n    }\n\n    /// <summary>\n    ///     Gets the context of the instance.\n    /// </summary>\n    /// <value>The context.</value>\n    public IContext Context { get; private set; }\n\n    /// <summary>\n    ///     Gets the instance reference.\n    /// </summary>\n    /// <value>The instance reference.</value>\n    public InstanceReference Reference { get; private set; }\n}\n\n}\n```\n. ",
    "iappert": "It depends. I don't want to do it for release 3.x, but I think it feasible for a release 4.x.\nThe problem is that this interfaces forces/leads to NotSupportedException implementations resulting in code degradation. Cleaning up the interface in Ninject is done in no time. I am aware of a dependency in the NamedScope extension, but I'd need more time to do a thorough analysis.\n. Hi \nThe constructor argument has an effect. It is part of the context, check my answer on stack overflow. You can access the constructor argument using: \nstring t = (string)context.Parameters.Cast<IConstructorArgument>().First().GetValue(context, context.Request.Target);\nCheers\n. @BrunoJuchli Agreed, I wouldn't want to use it.\nFor the sake of documentation, I added the example with the context :-).\n. Hi\nNinject does not currently support windows 8.1 apps. You may use a portable version of ninject, see https://www.nuget.org/packages/Portable.Ninject/3.0.5\nThank you.\n. @remogloor I implemented a fix for this issue. Could you review my changes? Link to commit: https://github.com/iappert/ninject/commit/1d0121b6b60f8965197fd94c79d0952769635a5d\n. Sorry for that. Habbits...\nI added the following test:\n```\n    [Fact]\n    public void OpenGenericBindingsWithDifferentGenericParametersCanBeAggregated()\n    {\n        kernel.Bind(typeof(IGeneric<>)).To(typeof(Bla<>));\n        kernel.Bind().To();\n        kernel.Bind().To();\n    var service = kernel.Get<IGeneric<IServiceA>>();\n\n    service.Should().NotBeNull();\n}\n\n```\n. @remogloor\nIn my opinion, it still detects circular dependencies since\nA -> Foo<B> -> B -> A\nor\nFoo<A> -> A -> B -> Foo<A> ->\nresult in a circular dependency of  A.\nI added some additional tests for circular dependency detection, check out commit https://github.com/iappert/ninject/commit/2cce59449ae1b23e6949db27ac3c750ac4df104b\nWithout my change, the example of @halter73 leads to a circular dependency because of the open generic binding, i.e.\nIGeneric<IServiceA> -> ServiceA -> IGeneric<IServiceB> -> ServiceB\nResolving IGeneric<IServiceB> throws an activation exception because the binding IGeneric<> has already been used for resolving IGeneric<IServiceA>.\n. Agreed.\nI haven't thought about this case. I will try to find another solution:-). thanks for your help.\n. ",
    "cjablonski76": "From the little bit of digging I did in to this \"issue\", using ninject-3.0.2 source code this is what I found:\nThe Ninject.Planning.Targets.Target class has the property Func<IBindingMetadata, bool> Constraint, it also contains private readonly Future<Func<IBindingMetadata, bool>> _constraint. The Getter method for Target.Constraint reads get { return _constraint; } which calls an implicit operator in the Ninject.Infrastructure.Future class.\npublic static implicit operator T(Future<T> future)\n{\n    return future.Value;\n}\nwith the future.Value Getter\npublic T Value\n{\n    get\n    {\n        if (!_hasValue)\n        {\n            _value = Callback();\n            _hasValue = true;\n        }\n        return _value;\n    }\n}\nCallback is set to the Target.ReadConstraintFromTarget() function for constraints, which will go through and run the logic of getting the new CustomAttribute objects.\nSo the reason the CustomAttribute object constructors are only called once is because the Future.Value Getter sets the _hasValue = true after the first time of running the Callback logic, thus never calling the constructor the next time through.\nFrom what I am seeing, at a lower layer this causes the issue I am seeing, and commenting out the logic using _hasValue and simply always calling Callback() results in the behavior I am expecting. Of course I was just testing out my special case, without knowing the background and intention of the pieces at work I can not say whether changing this makes sense.\n. Thanks for taking a look! I will weigh my options and look into putting in a feature request.\n. ",
    "bizzehdee": "Wont for what reason? this would be a very useful feature for the project as a whole.\n. Setting the constructor argument type does not work also.\n```\nIKernel kernel = new StandardKernel();\nkernel.Bind().To().WithConstructorArgument(typeof(int));\nkernel.Bind().To().WithConstructorArgument(typeof(long));\nkernel.Bind().To().WithConstructorArgument(typeof(string));\nITest t = kernel.Get(new Parameter(\"i\", 1, true));\n```\nStill returns all 3 concrete classes even though each one has a different constructor argument type. I think the feature i requested is sort of the entire point of dependency injection, removing the entire need to couple objects. naming objects and setting hard coded constructor types is just coupling the classes, just in a less obvious way.\n. using Named binding could be replicated with 2 small classes added to any project, and is essentially coupling the classes through a string rather than through C# code. Seems that ninject is missing what would be a vital feature in true decoupling and proper DI.\n. ",
    "bnordli": "Any update on this? We have stumbled over the exact same problem:\nBasically, we have a PerRequest object to hold database sessions, and use the OnePerRequestHttpModule to commit transactions when the request has ended. We soon found out that in the Dispose method of this object, the thread holds the cache lock so we have to make sure not to call into Ninject again.\nA suggested fix would be for Forget to return a list of forgotten objects, for the callers to deactivate them outside of the lock.\n. ",
    "zapalap": "I actually have encountered a deadlock in production caused by this exact behavior. \nWe are using Ninject to provide per-request instances of System.Net.Mail.SmtpClient. Turns out, that when disposing, SmtpClient sends an SMTP QUIT message through a socket and awaits server response without any timeout. If that data never arrives, the lock on entries is never released and the application hangs. . ",
    "Lavinski": "I'm not sure what you mean by \"obsolete fody\", could you clarify?\n. Creating binding that share an instance over the lifetime over a unit of work is a very useful thing to have (http://nblumhardt.com/2011/01/an-autofac-lifetime-primer/). I'm not sure what you recommend to do instead (possibly named scopes?) however the documentation all seems to be out of date in this area.\n. ",
    "GeorgeHahn": "https://github.com/Fody/Obsolete\n. ",
    "linnet": "@remogloor I can see from the 4.0.0 branch that support for the older versions of Mono (< 4.0) has been removed.\nWhat is your attitude towards this pull request? If it is deemed feasible I will gladly redo the changes to target the 4.0.0 branch instead.\n. Ok. But will runtime detection of Mono (as implemented in this pull request) be interesting to you in order to avoid a separate Mono build? It would make a lot of sense for our project running under .NET on Windows and Mono on Linux.\n. ",
    "ygormutti": "I would like to see this pull request merged. I'm working on a project which developers use Linux and Windows and we use NuGet for every external dependency, except for Ninject, because of this issue.\nAs you can see, the Coinium project isn't using Ninject anymore. If the build for Mono doesn't work well on Windows I'll have to stop using Ninject too.\n. ",
    "cmenzi": "We spawn new threads, but we inject a factory (dynProxy) into the thread. The thread creates the dependency later when it's used.\nMaybe the problem is in the StandardInstanceProvider from the FactoryExtension or in the FuncModule which uses ToMethod() bindings.\n. Yes, we still have the problem. We currently stay on 3.0.1.10 as workaround, because this version can fulfill our requirements.\nThe factories are used outside the c'tor. But it's strange to reproduce it. It only occurs when a UI WPF Thread is involved. I could not get it in UnitTest.\nI've planned to invest time next sprint for this problem.\n. ",
    "marcoerni": "As discussed with @remogloor, lazy resolving of the enumerable can have bad side effects according to scopes and locking of them. In fact when you let inject an enumerable you always have to materialize the enumerable in the constructor using .ToList(), ToArray() or something similar. Materializing the enumerable during run-time can produce unexpected exceptions.\n. ",
    "brandondahler": "+1, my application requires me to resolve a db context factory based on the url that the site is accessed from (basic multi-tenant application with separate databases per site).\nWhen using async/await with this setup, the dependency resolution gets bumped to a ThreadPool thread and causes the factory to fail to be created.  Basic pseudocode of the issue:\n``` C#\n// DbContext\nclass DbContext\n{\n    ...\n}\ninterface IDbContextFactory\n{\n    DbContext Create();\n}\nclass DefaultDbContextFactory\n{\n    Func lazyFactory;\nDefaultDbContextFactory()\n{\n    lazyFactory =  SomethingThatUsesHttpContextToProduceLazyFactory()\n}\n\nDbContext Create()\n{\n    return lazyFactory();\n }\n\n}\n// Providers\ninterface IProvider\n{\n    Task ProduceSomethingAsync();\n}\nclass ProviderA\n{\n    public ProviderA(IDbContextFactory contextFactory)\n    {\n        ...\n     }\nTask<Something> ProduceSomethingAsync()\n{\n    ...\n }\n\n}\nclass ProviderB\n{\n    public ProviderB(IDbContextFactory contextFactory)\n    {\n        ...\n     }\nTask<Something> ProduceSomethingAsync()\n{\n    ...\n }\n\n}\n// Resolver\ninterface IResolver\n{\n    Task Resolve();\n}\nclass DefaultResolver\n{\n    IEnumerable _providers;\n    public DefaultResolver(IEnumerable providers)\n    {\n        _providers = providers;\n    }\npublic Task<Something> Resolve()\n{\n     // Resolves IDbContextFactory dependencies at each enumeration\n     // Would throw on second item due to HttpContext.Current == null\n     foreach (provdier in _providers)\n     {\n\n      }\n }\n\n}\n```\nObviously I'll fix this myself by changing the DefaultResolver constructor to: \nC#\n    public DefaultResolver(IEnumerable<IProvider> providers)\n    {\n        // Resolves all IDbContextFactory dependencies now\n        _providers = providers.ToArray();\n    }\n. ",
    "cidthecoatrack": "+1\n. ",
    "andersosthus": "Hi,\nWe've been running on 3.2.0 since then, so I haven't looked into it any more.\nSo for now, I'll just close it, and when we look into upgrading again I'll investigate and see if I can reproduce it.\n. ",
    "bajak": "Just reinstall it.\n. ",
    "ahqepha": "I think we encountred the same problem today.\nAs a workaround, we uninstalled all old versions of related nuget packages and the install the new ones...\nBut we have now some problems because we WebForms pages no longer compile... (namespace PageBase not found)\n. After desinstalling old nuget versions and installing the new ones, we had to resolve some problems due to the fact that nuget erased some of the customized code. \nMainly there were one caused by a duplicate class name called DependencyResolver wich is present in two different name spaces (System.Web.Mvc and System.Web.Http.Dependencies) and that were used by NinjectDependencyResolver. If you have such troubles, you can see possible work-arounds here: http://stackoverflow.com/questions/18486129/how-to-resolve-error-the-type-does-not-appear-to-implement-microsoft-practices/24687917#24687917\n. ",
    "noocyte": "We have this same problem still (I work with @andersosthus ), I can see that there is a mismatch in version:\n\"Ninject\" version=\"3.2.2.0\" \n\"Ninject.Web.Common\" version=\"3.2.2.0\" \n\"Ninject.Web.Common.WebHost\" version=\"3.2.2.0\"\n\"Ninject.Web.WebApi\" version=\"3.2.1.0\"\nLooks like .WebApi has not been updated in May, though the other packages were. Could this be the issue?\n. ",
    "VansFannel": "I'm having the same problem. I've asked this SO question: http://stackoverflow.com/questions/26312231/ninjectdependencyresolver-fails-binding-modelvalidatorprovider\n. Does ninject support Windows 8.1 store apps? Two weeks ago, I have tried with latest packages and I couldn't install them.\n. It's a commercial product and I'm not sure if I can send you source code.\n. I have found the problem (but I don't know how to solve it). There is a question with a lot of details here: http://stackoverflow.com/questions/26312231/ninjectdependencyresolver-fails-binding-modelvalidatorprovider\n. ",
    "arindamdat": "The cyclic dependency is between the classes \"NinjectDefaultModelValidatorProvider\" and \"DefaultModelValidatorProviders\".Simply add a binding for \"DefaultModelValidatorProviders\" on your startup like below:\n\n_kernel.Bind<DefaultModelValidatorProviders>().ToConstant(new DefaultModelValidatorProviders(config.Services.GetServices(typeof (ModelValidatorProvider)).Cast<ModelValidatorProvider>()));\n\n. ",
    "bananabags": "I had the same problem. When I added:\n_kernel.Bind<DefaultModelValidatorProviders>().ToConstant(new DefaultModelValidatorProviders(config.Services.GetServices(typeof (ModelValidatorProvider)).Cast<ModelValidatorProvider>())); \nI got the next problem with DefaultFilters provider, if you had the same problem, just add:\nkernel.Bind<DefaultFilterProviders>().ToConstant(new DefaultFilterProviders(new[] { new NinjectFilterProvider(kernel) }.AsEnumerable()));. I'm not sure that is the best solving but it works for me. Thanks. \n. ",
    "MisterGoodcat": "Duplicate of/also see: https://github.com/ninject/Ninject.Web.Common/issues/15\n. ",
    "nicholashead": "@remogloor this is still not working for me, with the latest stable packages on NuGet, for MVC5.\n. @remogloor I can upload a test case repo if needed.\n. Okay, fair enough. That fixed it in my example. But in my actual production app (which I can't share the source to), I cannot for the life of me get per-request disposing working, unless I implement the mistergoodcat.com hack, which is adding a module to the kernel that inherits GlobalKernelRegistrationModule<OnePerRequestHttpModule> -- that seems to do the trick for us. Still feels very hacky, and I wish I knew why it wasn't just working in Ninject out of the box. But I'm leaving this comment in case anyone else continues to have issues, >= 3.2.2.\n. ",
    "johnkors": "Upgrading from 3.2.0 -> 3.2.2 fixed this issue for us. Thanks. Is it possible to unlist that bad package in NuGet?\n. ",
    "edaloicaro18": "Upgrading all the Ninject packages to their latest versions fixed this issue for me as well\n. ",
    "Jonesie": "Looks like we reference 3.2.1\n. The connection error does seem random.  In 'my machine testing' OnDeactivate is getting called when it should.\n. We upgraded to 322 and 'fixed' our connection factory so that it disposes of connections properly and doesn't use the Request context items to store connections.  Now we can hammer the site with 10000 requests and it releases all but 9 connections (give or take a few).  Not sure why these ones stick around but it doesn't seem to grow.  We are still using OnDeactivate in the binding but this is probably redundant and harmless.\nAnd the site now seems a lot more responsive!\nCheers\n. ",
    "iJoyCode": "Any news?\n. ",
    "rubberduck203": "Has this been mainlined yet @scott-xu?\n. ",
    "dapage": "Thank you for the suggestion.  I tried to install the portable library with a Windows Phone 8.1 test project, but it also was unable to install.\nInstalling 'Portable.Ninject 3.2'.\nSuccessfully installed 'Portable.Ninject 3.2'.\nAdding 'Portable.Ninject 3.2' to App2.\nUninstalling 'Portable.Ninject 3.2'.\nSuccessfully uninstalled 'Portable.Ninject 3.2'.\nInstall failed. Rolling back...\nCould not install package 'Portable.Ninject 3.2'. You are trying to install this package into a project that targets 'WindowsPhoneApp,Version=v8.1', but the package does not contain any assembly references or content files that are compatible with that framework. For more information, contact the package author.\n. ",
    "eloitay": "Hi\nIt seems that implementing the INotifyWhenDisposed method does work but not the Thread.Sleep(60s) method. What is the code formatting do I need to do? Add 4 space for each line of code, correct indentation or it should be flat?\n. ",
    "yishaigalatzer": "Any update on the status for this?\n. We have made a fix where we don't register some of the services as open generics. The issue in ninject still exists and will break user code (or potentially other framework code)\n. ",
    "faridprogrammer": "@danielmarbach  I think i only need to change IAssemblyNameRetriever component? is that right?\n. ",
    "l0nley": "Still have it with ninject webapi 3.2.4 and selfhosted webapi. does it fixed?\n. _kernel.Bind().ToConstant(new DefaultModelValidatorProviders(config.Services.GetServices(typeof (ModelValidatorProvider)).Cast()));\nworks for me. But i totally dont understand why i should do so nasty things to get ninject up and running. I not migrated from any previous version- just installed the package and get this error, when replace default DR with NinjectDepedencyResolver. \n. ",
    "berv63": "Needed to remove the \"AllowPartiallyTrustedCallers\" attribute from the Ninject assemblyInfo.cs\n. ",
    "defrancea": "This is fixed in the current unstable version: https://www.nuget.org/packages/Ninject/3.2.3-unstable-012\nNot sure when exactly this has been fixed though\n. ",
    "robv8r": "I have fully annotated 3.2.2 in a fork of this project. I have included the annotations in the Community External Annotations project.\nIf you have R#9, you can get this extension through the official ReShaper Extension feed.\nI'm happy to continue annotating the Ninject API as new versions come out and include the annotations in the Community External Annotations package.  Over time, this will probably become cumbersome.  Instead, I'd like to fully annotate the current development branch so that the Annotations live with the official source code.\nBefore I do the work, I'd like to know if the owners of this project want the annotations in the official API.\nFeel free to review my work on the fork I mentioned above. \n. ",
    "lsoft": "Got it.  What's about a way to define a finite lock timeout? Is it helpful? If not, should I close this issue as \"not a bug\"?\n. Ok. Thanks for reply.\n. Incorrect proposal, it only work with fast deployment. Sorry.. ",
    "jowensboggs": "Looks like NinjectWcfHttpApplicationPlugin.GetRequestScope is returning null because OperationContext.Current has not been set on the active thread - though since the return is being awaited, we are still within the request.\n. Certainly,\nWhere should I put it?  I currently have it as a clone of the NInject + Common + WCF + Demo all in one solution from February, with an additional WCF project demo project. Zipped, It\u2019s about 44K?\nFrom: Scott Xu [mailto:notifications@github.com]\nSent: Friday, June 05, 2015 10:15 AM\nTo: ninject/Ninject\nCc: Owens-Boggs, Jeremy\nSubject: Re: [Ninject] InRequestScope is ignored for async WCF calls (#164)\nCan you please send a sample to me?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/Ninject/issues/164#issuecomment-109324415.\n\nCONFIDENTIALITY NOTICE: This message may contain information that is confidential and/or legally privileged. Any use, disclosure, distribution, or duplication by anyone other than an intended recipient is prohibited. If you received this message in error, please notify the sender and permanently delete the original message, any copies and attachments from your computer system. __________\n. Yes, when I tried to replicate before forwarding the sample code on, I could not\u2026 meant to dig in to see if I changed something, or to better get a handle on what I was doing originally, but \u2026 no luck\u2026\nGuess I can\u2019t replicate\u2026.\nFrom: Scott Xu [mailto:notifications@github.com]\nSent: Friday, June 12, 2015 9:39 AM\nTo: ninject/Ninject\nCc: Owens-Boggs, Jeremy\nSubject: Re: [Ninject] InRequestScope is ignored for async WCF calls (#164)\n@jowensboggshttps://github.com/jowensboggs It works in my case.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ninject/Ninject/issues/164#issuecomment-111514730.\n\nCONFIDENTIALITY NOTICE: This message may contain information that is confidential and/or legally privileged. Any use, disclosure, distribution, or duplication by anyone other than an intended recipient is prohibited. If you received this message in error, please notify the sender and permanently delete the original message, any copies and attachments from your computer system. __________\n. ",
    "jnpwly": "Note: I had been following the instructions laid out here: http://www.alexzaitzev.pro/2014/11/webapi2-owin-and-ninject.html\n. Also, somebody else came across the same problem, here: http://stackoverflow.com/questions/28570477/web-api-2-owin-3-ninject-web-webapi-owinhost-error-at-startup-only\n. Hi @scott-xu, thanks for your reply -- appreciated.\nWith the latest versions of the applicable Ninject packages, I can confirm that there appears to be no issue. \nIt is, however, slightly confusing that, when installing, say, \nPM> Install-Package Ninject.Web.WebApi.OwinHost\nthat this pulls in older versions of other Ninject packages, which do exhibit the I saw.\n. ",
    "crush83": "I thought I was getting this error after updating to the latest versions, then I realized that my debug /bin folder simply had the Ninject.Web.WebApi.WebHost.dll in it for some reason, despite me not having a NuGet Package referencing it or Reference to it. I had to manually delete everything out of the /bin folder. Clean and Rebuild didn't delete them.\n. ",
    "Niondir": "Actually putting this to my Kernel works. But the implementation of the IComponentContainer seems to saves the Strategies in some very generic Multimap that (from an interface point of view) does not guarantee the order of the elements.\nprotected override void AddComponents()\n    {\n        // Inject config values before all other ActivationStrategies\n        Components.Add<IActivationStrategy, ConfigPropertyInjectionStrategy>();\n        base.AddComponents();\n    }\n. ",
    "mtangoo": "Did I post in right place?\n. ",
    "JohanLarsson": "I agree it should not be the default. InjectNonPublic or a new flag ResolvePrivateConstructors could make sense.\nChanging ctor to private is very little code and closes the door for newing it up. Pit of success imo.\nWe have ~1000 lines of setup code and maintaining it is not much fun. Also I have spent many hours tracking down bugs caused by things that should have been singleton were not.\n. I hoped the code was enough for a repro, Wrote it in the browser. I will investigate this further and include stack trace.\n. ",
    "kfrajtak": "It does not, ClassA constructor is a location where Kernel.Get<ClassB>() is invoked (yes, I am accessing the Kernel directly).\n. ",
    "mattwarren": "Just to add, if you want to verify that the invalid IL throws an InvalidProgramException when executed, you can change the code here to\n``` csharp\ntry\n{\n    var ctorDelegate = (ConstructorInjector)dynamicMethod.CreateDelegate(\n                                typeof(ConstructorInjector));\nif (constructor.DeclaringType.Namespace == \"System\"\n    && constructor.DeclaringType.Name.StartsWith(\"Func`\"))\n{\n    MethodInfo testMethod = new methodof<Action>(Console.WriteLine);\n    ctorDelegate(null, testMethod.MethodHandle.GetFunctionPointer());\n}\n\nreturn ctorDelegate;\n\n}\ncatch (InvalidProgramException invalidProgramException)\n{\n    Console.WriteLine(invalidProgramException);\n}\n// Original code\n//return (ConstructorInjector) dynamicMethod.CreateDelegate(typeof(ConstructorInjector));\n```\nYou'll also need the methodof helper class, for that see this gist.\n. Would it help if I put together a pull-request to show a possible fix for this issue?\nIf so, could someone please clarify something for me?\n\nAm I right in thinking that when using a Binding like so Bind<Func<ILogging>>().ToMethod(ctx => () => new MockLogging());, the ConstructorInjector is never used? I.e. the IL emitted is never actually executed? \n\nFrom what I can tell from looking around the Ninject code, this is because CallbackProvider is used instead of a StandardProvider (which would've used the ConstructorInjector)\n. Thanks for replying\n\nCan you write an integration test that show's this behaviour?\n\nYeah no problem, I'll put something together.\n\nIn the meantime, would it be easier to just have an interface as a provider rather than injecting a Func?\n\nIf you have a binding like this:\ncsharp\nBind<ILogging>().To<MockLogging>();\nI can absolutely see the point of creating a ConstructorInjector in DynamicMethodInjectorFactory, because MockLogging might have a ctor that takes other dependancies, for instance if could be public MockLogging(IFileWriter fileWriter). So you'd want to be able to create a MockLogger (to satisfy the ILogging dependency) and at the same time pass in the IFileWriter dependency.\nBut when you have a binding like this:\ncsharp\nBind<Func<ILogging>>().ToMethod(ctx => () => new MockLogging());\nI'm a bit confused as to why Ninject tries to create a ConstructorInjector for the Func<ILogging> ctor (private void .ctor(System.Object, System.IntPtr)). In what scenario would Ninject need to create a Func<ILogging> object in that way? It's bound via ToMethod(), so the Func ctx => () => new MockLogging() is called to create the ILogging dependency. \nI can't think of a scenario where Ninject needs to create a Func<ILogging> object, but maybe I'm missing something?\n. @idavis I've added a code sample with a failing test to demonstrate the issue, see https://github.com/mattwarren/Ninject/commit/cc4537203e6a571a608dd13e4f95f8fb5dc6a70d\n. Thanks Ian, that's solved the problem.\nI didn't realise that Ninject was that flexible, so thanks for pointing out the mechanism of wiring up Modules/Selectors.\nBTW to get it to compile, I had to change MySelector to the following:\n``` csharp\npublic class MySelector : Selector\n{\n    public MySelector(IConstructorScorer constructorScorer, IEnumerable injectionHeuristics)\n        : base(constructorScorer, injectionHeuristics)\n    {\n    }\npublic override IEnumerable<ConstructorInfo> SelectConstructorsForInjection(Type type)\n{\n    if (type.IsGenericType && type.GetGenericTypeDefinition().Name.StartsWith(\"Func`\"))\n    {\n        return null;\n    }\n    return base.SelectConstructorsForInjection(type);\n}\n\n}\n```\nI had to add the 2 param constructor and and changed parts of the if (..) statement, I assume these are valid changes?\n. Ian,\nWould you be willing to release a new version of Ninject with this fix included by default? It's just that our customers are reluctant to make source code changes to fix this problem?\nThe main issue is that their application works without our monitoring Agent, but once it's attached it triggers this issue (InvalidProgramException) within Ninject. So they see that it's our Agent that breaks things and are therefore reluctant to change their code to fix it. If we could point them to a newer version of Ninject that would be preferable, is that possible?\n. @scott-xu thank's for that. I've tried it out in a few tests and it look good. I'll report back here if I find any problems.\n(I did always wonder why Ninject was creating a ConstructorInjector for a Func/delegate. From your fix it seems like it's not actually needed, which makes sense)\n. When will #179 be included in an official build, so that we can download a Release version of Ninject.dll with it included?\n. Sorry if this is a dumb question, but where can I get the pre-build binaries of #179, or do you not publish those?\nThe latest NuGet package I can see is from Sunday, January 04 2015\n. ",
    "psylenced": "Just seconding Matt's request for a new build with the fix implemented.\n. ",
    "siberianguy": "Any feedback on this would be highly appreciated. I'm now migrating my application to ASP.NET 5 and I'm confused whether I can use Ninject or not.\n. ",
    "dotnetjunkie": "You can -and should- continue to use Ninject. Whether an Ninject adapter for ASP.NET Core is created or not is irrelevant, because you should not use such adapter in your applications, as explained here.\n. Take a look at this discussion on the Simple Injector forum. It describes how to integrate Identity Framework with SI and you'll find most (if not all) of it to be applicable to Ninject as well.\n. Hi @hodzanassredin,\nSince you are using the Missing-Core-DI-Extensions, please consider sharing your experience with them on this thread. It's important for Microsoft to understand that the omission of these extensions is a problem for Ninject users as well and to know how well these integration points work.\n. ",
    "ciel": "I'm still super lost on how to use Ninject with ASP.NET 5, specifically the Identity stuff. \n. ",
    "AlexKeySmith": ":+1: \nI think an \"official\" response from the ninject core team would be very useful. It feels like autofac have made a statement with their choice of support. But I'm unsure if ninject's opinion, whether there currently isn't an adapter because it's the wrong thing to do (as SimpleInjector suggests) or whether it's something that's coming in the future. \nAs people begin to migrate their code to MVC 6 this question will come up a lot and it's an unknown at the moment probably making people consider autofac (rightly or wrongly) as there is an official response.\n. Thanks @BrunoJuchli for the input, I'm thinking the same thing. I wonder if the adapter is a good idea or not for ninject, there seems to be polarized view between the maintainers of Simple Injector and Autofac.\n. :+1: \n. Hi @philip-peterson good spot, it looks like the website is open source too :-) Perhaps pop a pull request on https://github.com/ninject/ninject.github.com\n(I am just guessing however, as I'm not a core contributor)\n. I think the documentation needs some TLC in general: https://github.com/ninject/Ninject/issues/202\n. ",
    "ah-": "Anyone interested in getting this working? https://github.com/ah-/Ninject/commit/b6820cb2f13f98fd9795a56b525a1a340d263652\n. What's the status of this? I think the new infrastructure has now sufficiently stabilized to start building netstandard compatible packages.\nA starting point might be https://github.com/ah-/Ninject/commit/b6820cb2f13f98fd9795a56b525a1a340d263652, would you accept an updated PR?\n. ",
    "hodzanassredin": "Created demo project ninject + asp.net core here. It uses Missing-Core-DI-Extensions\n. ",
    "davidfowl": "+1\n. ",
    "schambers": "I actually just came across this same problem but with OnePerHttpRequestModule \nSpecifically when in the anonymous method passed to MapKernels inside deactivation of the http request.\nThe only way I could reliably reproduce is purposefully throw exceptions in rapid succession amongst multiple threads until I could get a deadlock.\nIs anyone aware of this issue? It's quite deep\n. ",
    "jeremymeng": "@onovotny already added https://github.com/ninject/Ninject/blob/master/Portable.Ninject.nuspec. Maybe it is just as easy as adding the PCL output to the 'dotnet' folder, and adding its dependency group.  Or does it need to be an output from Profile 259 PCL project?\n. Let me give it a try.\n. @scott-xu Thanks for the work to support .NET Standard.  Do you know when the package will be out of Beta?. Thanks for asking to add the test project.  It revealed that I cannot just simply copy the PCL project.\n. Looks like the build machine doesn't support .Net 4.6.\n. @onovotny is there anything I can do to move this PR forward?\n. Closing as the master branch already has netstandard support.\n. I actually tried. But for some reason it didn't work. NuSpec.ReferenceGenerator wasn't getting added to the project.json.  I didn't have time to look into it yet.\n. I don't understand why adding a Modern PCL project creates so many configurations.\n. ",
    "mwhelan": "Just wondering how this is going? Is .Net Core support coming for Ninject?\n. Hi @scott-xu. Is it available on NuGet, or what is the best way to get hold of it?\n. ",
    "WattsC-90": "guess noone fixed/found an answer for this one? running into the same problem with 3.2.2 and would like to maintain a single nuget package to enable windows linux in a single build. OK so plan going forward is to no longer support mono and to solely support the .net standard/core?\nI just want to confirm as I will then investigate, everything I have done so far was for mono support. @BrunoJuchli you may be right.. im running some old versions it seems! \nThanks for your guidance and speedy responses!. ",
    "sglienke": "My point was that it should raise an ActivationException as is done when detecting a circular dependency by ctor injection.\n. Yes, I just copied an existing test where I had removed the InSingletonScope - but that did not make any sense because it would still fail. Sorry for that - I updated the issue.\n. ",
    "retailcoder": "IMO you're doing it wrong: \"I need to create a new DbContext for every repository\" sounds completely wrong, as does \"I am using EF 6 and Repository Pattern\" - EF is a unit-of-work / repository pattern, you're wrapping an abstraction with... an abstraction.\nRelevant:\n- Correct usage of EF's DBContext in ASP.NET MVC application with Castle Windsor\n- EF Generic Repository + Unit of Work pattern with support for Async\n. ",
    "eminyuce": "Let me tell you why I did it. I am using GenericRepository with EF6 to get data. Generic Repository manages query inside repository.. The project I used as generic repository.\nhttp://www.tugberkugurlu.com/archive/clean-better-and-sexier-generic-repository-implementation-for-entity-framework\nThe web application I worked is not using Repository directly to fetch data, it is using service interfaces. The service interfaces has two different impelementations, one is repositories and other is web json api implementation. It is working fine with web json api implementation which is just getting data from HTTP request. But then I realized my repository is not working because they have to have different DBContext to manage async methods\nhttp://stackoverflow.com/questions/29763732/entity-framework-async-issues-context-or-query#new-answer\n. To explain the issue further, I tried to create my services without ninject DI like the below code and it works because DbContext is created in every request.\n```\n        IProductService rep = new ProductRepository(new StoreContext(ConnectionString));\n        IContentService rep2 = new ContentRepository(new StoreContext(ConnectionString));\n        IPageDesignService rep3 = new PageDesignRepository(new StoreContext(ConnectionString));\n        IProductCategoryService rep4 = new ProductCategoryRepository(new StoreContext(ConnectionString));\n        ICategoryService rep5 = new CategoryRepository(new StoreContext(ConnectionString));\n        IFileManagerService rep6 = new FileManagerRepository(new StoreContext(ConnectionString));\n    var productsTask = rep.GetProductsByBrandAsync(StoreId, 5, 100, null);\n    var pageDesignTask = rep3.GetPageDesignByName(StoreId, \"HomePage\");\n    var blogsTask = rep2.GetMainPageContentsAsync(StoreId, categoryId, StoreConstants.BlogsType, 5);\n    var newsTask = rep2.GetMainPageContentsAsync(StoreId, categoryId, StoreConstants.NewsType, 5);\n    var productCategoriesTask = rep4.GetProductCategoriesByStoreIdAsync(StoreId, StoreConstants.ProductType, true);\n    var categoriesTask = rep5.GetCategoriesByStoreIdAsync(StoreId);\n    var sliderTask = rep6.GetStoreCarouselsAsync(StoreId, 58);\n\n```\n. I did it without ninject injection. I could not find a way with ninject.\n      public IContentService ContentService\n        {\n            get\n            {\n                if (ProjectAppSettings.IsApiService)\n                {\n                    return new ContentService(ProjectAppSettings.WebServiceAddress);\n                }\n                else\n                {\n                    return new ContentRepository(new StoreContext(AppConstants.ConnectionStringName));\n                }\n            }\n        }\n. Could you give a example code? \n. Thank you so much, I used your alternative solution, I am so newbie about Ninject and using it in my first time in my project right now. It is working fine.  I think alternative solution you proposed is much more readable so I used it.\n. ",
    "nkohari": "This behavior is currently as-designed, because of how StandardConstructorSelector works. When activating a class with multiple constructors, the StandardConstructorSelector will choose the constructor with the most \"bindable\" parameters. A bindable parameter satisfies one of the following conditions:\n1. An explicit binding has been registered for it using kernel.Bind(), etc.\n2. The type is self-bindable, meaning it is a non-abstract class that can be instantiated.\nSince Dependency and String are both self-bindable, Ninject will choose the second constructor. This problem can be avoided by annotating the constructor you want Ninject to use with the [Inject] attribute. If you give it this hint, it won't have to guess which constructor you want to use.\n. ",
    "hh19": "Actually it seems that Ninject considers String not self-bindable. That is why the activation fails. String cannot be instantiated. If it was self-bindable then surely Ninject would inject the constructor with default string.\nHere is the relevant part from the exception message:\n\nError activating string\nNo matching bindings are available, and the type is not self-bindable.\n\nIt's pretty clear there is a bug here where Ninject selects unresolvable constructor when there is a resolvable one available. The way it should work is either\n1. Select the constructor without string argument (consider string not self-bindable).\n2. Select the constructor with string argument and inject default string (consider string self-bindable).\nI would prefer the number one option because injecting empty strings seems like a bad default behavior.\n. ",
    "PehrGit": "Did you ever figure this out?\n. ",
    "brenovieira": "@PehrGit , no.\nI just changed my class BarProvider to use generics, something like BarProvider<TKey, TValue> which has a concurrentDictionary and Get and Create methods.\nand in NinjectConfig I'm using like this:\nvar provider = new BarProvider<MyKey, MyValue>();\nBind<IMyValue>().ToMethod(ctx => barProvider.Get(ctx));\nI would like to Ninject do this for me, but I noticed last release of Ninject was long time ago and I think the maintainers could take too much time to release another version.\nSo I did it myself and closed the issue.\n. ",
    "lukemcgregor": "This issue doesn't occur with the latest version of Ninject.Web.Common so the fix is probably to update the Ninject.Web package to refer/prefer the newer versions\n. ",
    "danielcweber": "Thanks. We used to use the Factory-extension, which will not work out-of-the-box with Portable.Ninject (probably with a few binding redirects and manual csproj-editing, but that's not the point of all this). Any chance the 'official' project (with the NuGet-Id \"Ninject\" instead of \"Portable.Ninject\") will have an alpha-release ?\n. Just the fact that we would have to uninstall Ninject manually (with Ninject.Factory still depending on it) made us consider this a hack. We had to ensure the quality of our software and did not go that way.\n. Alright. Thanks a lot.\n. ",
    "stefc": "See this Article for details \nand here is the related .net core repo\n. ",
    "ademsenel": "i solved this issue \nthank you \n. ",
    "AqlaSolutions": "Yep, I've already made named scopes work in my prototype. I thought they don't support nesting because not-named custom scopes don't. But everything works now.\n. ",
    "trevorash": "Sounds like the behavior is well understood and debated. Thanks for the back story. The solutions are simple enough, and 128 certainly captures my concerns.\n. ",
    "SonnevilleJ": "Instead of binding to a constant:\nCSharp\nvar instance = CreateInstance();\nBind<MyClass>().ToConstant(instance);\nBinding to a method which itself returns the constant works great:\nCSharp\nvar instance = CreateInstance();\nBind<MyClass>().ToMethod((context) => instance);\n. ",
    "BvdVen": "Not an error of Ninject...\n. ",
    "jjbott": "If there is one I haven't noticed it, and the performance tests pass (I realize there aren't any). Because using anything marked obsolete without explicitly requesting it (which can still be done by using [Inject]) is incorrect behavior in any context, especially from the perspective of an IoC container where it may not be obvious it is choosing the wrong thing. I can only give a specific answer from the perspective of my code, where legacy code that can not yet use Ninject has no choice but to instantiate objects the wrong way, but in general the obsolete attribute is used when deprecating functions that are still in use by legacy code. I haven't seen a performance impact (although I assume there is an imperceptible difference), so it comes down to whether choosing to use obsolete functions is considered correct.\n. ",
    "AngusMcIntyre": "This error is occurring because Assembly.Load cannot be called upon dynamic assemblies. You must filter out the dynamic assemblies before using them.\nkernel.Load(AppDomain.CurrentDomain.GetAssemblies().Where(p => !p.IsDynamic));. ",
    "slaneyrw": "thanks for the confirmation.  Not sure inheritance plays a part with constructor args though, you can't directly use the base class constructor.. Thanks, I'll look at the custom IParameter route. ",
    "StingyJack": "An explicit instruction was given to use a named ctor arg of a specific type. \nI think it would be expected that ninject would throw an error if it doesnt find a matching constructor - or at least configurable to do so.\nI don't want to find out later in the application lifetime when it starts experiencing weird side effects (like I did yesterday and today, only to realize its a minor naming difference for something that has no other constructors).\n. Bar(IFoo foo1, IFoo foo2)\nLists and array ordering has been guaranteed as preserved since about .net 3.0. If the ConstructorArguments are applied in the order supplied, then type matching should suffice. . I don't think you can protect against stupid mistakes (i cant protect me from my own), someone changing parameter ordering should be paying attention, and relatively minor testing would ferret out that kind of parameter swap issue. \nBut it is implemented at your risk/comfort level, and safe is OK. I only brought it up again to re-focus this conversation to be about the original question, which you have addressed. Thanks!. ",
    "omar": "We're starting to do the necessary work to migrate our web applications to ASP.NET Core now, so we're feeling the pains already. However, we're not migrating to .NET Core. We'll continue to target .NET 4.6 probably until netstandard2.0 is released and supported by .NET Core.\nAs it stands, we've had to abstract all the DI logic into a custom/neutral container that then calls into either Ninject's IKernel or the Microsoft.Extensions.DependencyInjection's IServiceCollection depending on the application being bootstrapped. It works but it's less than ideal as that meant we had to touch all of our bindings/modules to use the custom syntax we created.\nAs a note, my original post was incorrect, version 3.2.3 doesn't have the read only kernel. However, it needs a lot of the fixes that are in 4.0.0 to work with Microsoft's DI framework. I'll correct my OP.\n. ",
    "einari": "We (Bifrost) have a dependency on Ninject and specifically .NET Core/.NET Standard. Any plans on getting a release version of Ninject?  We're running into problems with NuGet not wanting to automatically install on Windows in VS2015 because our version is a release version and yours is a pre-release. It kinda makes sense from a semver perspective and not making people dependent on you to actually take a pre-release dependency without being conscious about it.\nInteresting enough; the dotnetCLI is not complaining about this.. ",
    "symon01107": "Sorry , I could not understand what you mean.\nCould you tell me how to do it?. Thank you very much. I got some hope after 3 days.\nSo, what should I do here?. My DbContext implements IDisposable. So, ninject should dispose it. Isn't it.\nI already tried all my Manager & Repository as \nkernel.Bind().To().InRequestScope().WithConstructorArgument(\"_dbContext\",context);\nBut no difference in outcome.. I did using\nkernel.Bind<DbContext>().ToSelf().InRequestScope();. I did some thing like this \n public class NinjectDependencyResolver()\n{\n   var context=new DbContext(\"someparameter\",\"connectionStrin\");\n   kernel.Bind<DbContext>().ToSelf().InRequestScope();\n   kernel.Bind<IMyManager>().To<MyManager>().WithConstructorArgument(\"_dbContext\",context);\n   kernel.Bind<IMyRepository >().To<MyRepository >().WithConstructorArgument(\"_dbContext\",context);\n}. So, how to change this code. Any idea? Our team got stuck for 3 days. No one could solve.. So, should I remove allWithConstructorArgument(\"_dbContext\",context) from all my manager & Repository?. Hi, I got error  here \nkernel.Bind().ToMethod(ctx=>new DbContext(\"someparameter\",\"connectionStrin\")).InRequestScope();\nMessage: The services must contain at least on typeParameter name:services. Sorry, I worked. Let me test. Hi, it seems your code works.\nBut there is one problem.\nWe open dbcontext in manager but when manager goes to repository dbContext connection state gets closed. Do you any idea? Any help would be great. As it seems we are very close to solve the problem.\nThanks.. ",
    "ShaidK": "Hi do you mean Ninject Wiki. Hi, \nWell I check all the links within the Website (Google search as well) but couldn't find any to be honest. I don't think they have any by the look of it.\n. ",
    "ciez": "Hi,\nWell the wiki describes the framework.\nApi reference docs are impossible to find. Do they exist?. ",
    "dansiegel": "\nso v4.0-alpha was released almost 2 years ago\nI'm not sure where a 4.0-alpha was released 2 years ago. I do see though that a 4.0-beta was released in August roughly 9 months ago though. I would echo @davethieben's question about when we might expect either a stable release?. \n",
    "chezuma": "@davethieben: \nDon't know if you have seen this, I assume you have: \nhttps://www.nuget.org/packages/Ninject/4.0.0-beta-0134\nTo me it seems like this project have lost momentum, is this because the product is considered \"good enough, goal of project reached\" or is it loss of interest of the main developers?\nEither way I really love this library, and it would be sad to see if it get discontinued.\nSo I echo the question regarding the release of v4 :) \n. @BrunoJuchli, sounds cool, please keep me posted if you end up doing that .\nDont get me wrong, but it would be really great to get feedback on this thread before everyone branches the current 4.0-beta, if they dont have the time and looking for new maintainers, maybe someone would step up and take the responsibility and keep this repo alive :) \n@BrunoJuchli  @scott-xu  @onovotny \n. ",
    "davethieben": "@chezuma yeah, I saw that, but there's no tag or branch in Github, or documentation anywhere, so I have no idea what's in it.\n@scott-xu @onovotny . wait a minute. what does this have to do with a 4.0 release? . ",
    "MaximRouiller": "Castle Windsor will support .NET Core in its next release.\nhttps://github.com/castleproject/Windsor/issues/145#issuecomment-311992256. ",
    "bayger": "Is the official v4.0-* supporting .NET Core dead?. ",
    "msnelling": "Could we get a comment either way from a maintainer on this? We'd like to know whether we should wait for .Net Core/Standard support or switch to a different library.. @scott-xu Thank you!. I would also like this.\nFrom what I can see, Ninject is missing implementations of the Microsoft.Extensions.DependencyInjection.Abstractions interfaces.\nThis is how Autofac does it...\nhttps://github.com/autofac/Autofac.Extensions.DependencyInjection/tree/develop/src/Autofac.Extensions.DependencyInjection. ",
    "evil-shrike": "I'm also looking forward for any info on .net core support. is there any roadmap? \nI'm sorry, but the project looks abandoned.\n\n\nso v4.0-alpha was released almost 2 years ago\n\nI'm not sure where a 4.0-alpha was released 2 years ago. \n\nit's the latest release here - https://github.com/ninject/Ninject/releases. ",
    "magol": "please, don't let it die. ",
    "szogun1987": "In my opinion There should be overloaded constructor that accepts index instead of name.. Hi. I thought more about \nnew ConstructorArgument(fooOne, 0), new ConstructroParameter(fooTwo, 1)\n. Please close this issue. I will re-open if I I recall why did I need indices (It was some weird case).. ",
    "THammond9": "My project had clickOnce turned on but it is not needed. Turned off clickOnce and the problem went away.. ",
    "AZWN": "I can imagine that, but are there any plans for such a new version? If that will still take some time, I think it is still worth the effort to fix this. If you are willing to accept pull requests, I can do it myself as well.\n. ",
    "PatrickKunz": "That's by design. You need to do something like:\nBind<Demo, IDemo>().To<Demo>().InSingletonScope();\n. ",
    "arnoldpistorius": "Ok thanks for your reply.\nAs I understand the Bind<IDemo>().To<Demo>(); does not occur a kernel.Get<Demo>(), but is using the activator directly on the Demo type.. ",
    "timbussmann": "@scott-xu not that I'm aware of (and the search also didn't yield any results)\nbut it's a quite common approach when running on .net framework < 4.6 to polyfill AsyncLocal. ",
    "romovs": "No deadlocks (inspected both manually and with SOSEX in WinDbg).\nAfter adding ninject symbols, the problem seems to be related to domain unloading here https://github.com/ninject/Ninject/blob/master/src/Ninject/Modules/AssemblyNameRetriever.cs#L60\nAppDomain.Unload never returns. I don't fully understand why would it hang indefinitely. According to the docs if domain cannot be unloaded CannotUnloadAppDomainException is thrown after a period of time (whatever that means, but I am using it's not hours).\n```\n    mscorlib.dll!System.AppDomain.Unload(System.AppDomain domain)   Unknown\n\nNinject.dll!Ninject.Modules.AssemblyNameRetriever.GetAssemblyNames(System.Collections.Generic.IEnumerable filenames, System.Predicate filter) Line 58   C#\n    Ninject.dll!Ninject.Modules.CompiledModuleLoaderPlugin.LoadModules(System.Collections.Generic.IEnumerable filenames) Line 81    C#\n    Ninject.dll!Ninject.Modules.ModuleLoader.LoadModules(System.Collections.Generic.IEnumerable patterns) Line 54   C#\n    Ninject.dll!Ninject.KernelBase.KernelBase(Ninject.Components.IComponentContainer components, Ninject.INinjectSettings settings, Ninject.Modules.INinjectModule[] modules) Line 100  C#\n    Redacted.dll!Redacted.App_Start.NinjectWebCommon.CreateKernel() Line 45 C#\n    Ninject.Web.Common.dll!Ninject.Web.Common.Bootstrapper.Initialize(System.Func createKernelCallback) Line 50    C#\n    Redacted.dll!Redacted.App_Start.NinjectWebCommon.Start() Line 28    C#\n    [Native to Managed Transition]\n    [Managed to Native Transition]\n    WebActivatorEx.dll!WebActivatorEx.BaseActivationMethodAttribute.InvokeMethod()  Unknown\n    WebActivatorEx.dll!WebActivatorEx.ActivationManager.RunActivationMethods(bool designerMode)  Unknown\n    WebActivatorEx.dll!WebActivatorEx.ActivationManager.Run()   Unknown\n    [Native to Managed Transition]\n    [Managed to Native Transition]\n    System.Web.dll!System.Web.Compilation.BuildManager.InvokePreStartInitMethodsCore(System.Collections.Generic.ICollection methods, System.Func setHostingEnvironmentCultures)   Unknown\n    System.Web.dll!System.Web.Compilation.BuildManager.InvokePreStartInitMethods(System.Collections.Generic.ICollection methods)  Unknown\n    System.Web.dll!System.Web.Compilation.BuildManager.CallPreStartInitMethods(string preStartInitListPath, out bool isRefAssemblyLoaded)   Unknown\n    System.Web.dll!System.Web.Compilation.BuildManager.ExecutePreAppStart() Unknown\n    System.Web.dll!System.Web.Hosting.HostingEnvironment.Initialize(System.Web.Hosting.ApplicationManager appManager, System.Web.Hosting.IApplicationHost appHost, System.Web.Configuration.IConfigMapPathFactory configMapPathFactory, System.Web.Hosting.HostingEnvironmentParameters hostingParameters, System.Security.Policy.PolicyLevel policyLevel, System.Exception appDomainCreationException) Unknown\n    System.Web.dll!System.Web.Hosting.HostingEnvironment.Initialize(System.Web.Hosting.ApplicationManager appManager, System.Web.Hosting.IApplicationHost appHost, System.Web.Configuration.IConfigMapPathFactory configMapPathFactory, System.Web.Hosting.HostingEnvironmentParameters hostingParameters, System.Security.Policy.PolicyLevel policyLevel)  Unknown\n    [AppDomain (DefaultDomain\u001e, #1) -> AppDomain (/LM/W3SVC/2/ROOT-2-131500441163972508\u001e, #4)]\n    System.Web.dll!System.Web.Hosting.ApplicationManager.CreateAppDomainWithHostingEnvironment(string appId, System.Web.Hosting.IApplicationHost appHost, System.Web.Hosting.HostingEnvironmentParameters hostingParameters)    Unknown\n    System.Web.dll!System.Web.Hosting.ApplicationManager.CreateAppDomainWithHostingEnvironmentAndReportErrors(string appId, System.Web.Hosting.IApplicationHost appHost, System.Web.Hosting.HostingEnvironmentParameters hostingParameters) Unknown\n    System.Web.dll!System.Web.Hosting.ApplicationManager.GetAppDomainWithHostingEnvironment(string appId, System.Web.Hosting.IApplicationHost appHost, System.Web.Hosting.HostingEnvironmentParameters hostingParameters)   Unknown\n    System.Web.dll!System.Web.Hosting.ApplicationManager.CreateObjectInternal(string appId, System.Type type, System.Web.Hosting.IApplicationHost appHost, bool failIfExists, System.Web.Hosting.HostingEnvironmentParameters hostingParameters)    Unknown\n    System.Web.dll!System.Web.Hosting.ProcessHost.StartApplication(string appId, string appPath, out object runtimeInterface)   Unknown\n```. Indeed, turns out some 3rd party libraries we are using do register DomainUnload events.\nI was able to reproduce this issue outside of Ninject, so it's not related to Ninject.\nThanks.. \n",
    "agostinocinelli": "v 4.0.0-beta-0134 already installed.\nMaybe it's not relevant, but some of solution's projects target .Net Standard 1.4 and some target Full Framework. Does not resolve :(\nI tried both to replace Ninject.dll in the debug folder and install-package c:\\temp\\Ninject.4.0.0-beta.1.52.nupkg in the \"exe\" project. Sorry for the late reply,\nI migrated to .NET Standard 2.0 and installed Ninject 3.3.0\nTadaa, it works :)\nThank you for your support!. ",
    "barbosatek": "@BrunoJuchli \nI guess a piece of code explains more than a simple paragraph. Here's an example...\nWith Microsoft's new Net Core DI framework, you can do something like this:\n```\n      services.Add(new ServiceDescriptor(typeof(IDependency), typeof(Dependency1), ServiceLifetime.Singleton));\n      services.Add(new ServiceDescriptor(typeof(IDependency), typeof(Dependency2), ServiceLifetime.Singleton));\n      services.Add(new ServiceDescriptor(typeof(IDependency), typeof(Dependency3), ServiceLifetime.Singleton));\n  ServiceProvider netCoreServiceProvider = services.BuildServiceProvider();\n  IEnumerable<IDependency> test1 = netCoreServiceProvider.GetServices<IDependency>();\n  IEnumerable<object> test2 = netCoreServiceProvider.GetServices(typeof(IDependency));\n\n```\nand it works as expected, the framework finds all the bindings to IDependency and returns the IEnumerable<IDependency>\nWith Ninject though, the following example throws an exception (details below).\nkernelConfiguration.Bind<IDependency>().To<Dependency1>();\n      kernelConfiguration.Bind<IDependency>().To<Dependency2>();\n      kernelConfiguration.Bind<IDependency>().To<Dependency3>();\n      IReadOnlyKernel ninjectServiceProvider = kernelConfiguration.BuildReadonlyKernel();\n      IEnumerable<IDependency> test3 = ninjectServiceProvider.GetServices<IDependency>(); // THROWS\n      IEnumerable<object> test4 = ninjectServiceProvider.GetServices(typeof(IDependency)); // ALSO THROWS\nException:\n```\nNinject.ActivationException: 'Error activating IEnumerable{IDependency}\nNo matching bindings are available, and the type is not self-bindable.\nActivation path:\n  1) Request for IEnumerable{IDependency}\nSuggestions:\n  1) Ensure that you have defined a binding for IEnumerable{IDependency}.\n  2) If the binding was defined in a module, ensure that the module has been loaded into the kernel.\n  3) Ensure you have not accidentally created more than one kernel.\n  4) If you are using constructor arguments, ensure that the parameter name matches the constructors parameter name.\n```\n. So, it works when the IEnumerable<T> is a dependency, but not when you explicitly ask the IServiceProvider for it, which I speculate is what .Net Core is doing. i.e.\n```\n  public class AwesomeTarget : IAwesomeTarget\n  {\n    private readonly IEnumerable _dependencies;\npublic AwesomeTarget(IEnumerable<IDependency> dependencies)\n{\n  _dependencies = dependencies;\n}\n\n}\n  var bar = ninjectServiceProvider.GetService<IEnumerable<IDependency>>(); // THROWS\n  var foo = ninjectServiceProvider.GetService<IAwesomeTarget>(); // WORKS\n  var foo2= ninjectServiceProvider.GetServices<IDependency>(); // THROWS\n\n```\nEDIT\nI don't like to speculate, so I went deeper to find where exactly the ASP.Net pipeline calls it\nhttps://github.com/aspnet/Hosting/blob/253be73b6fbc4a23b52080bd5e9d5161eb6cfe37/src/Microsoft.AspNetCore.Hosting/Internal/WebHost.cs#L188\n. ",
    "penihel": "I did not see this issue before. So i opened this #255 . ",
    "IronSean": "I'm not sure how to interpret that response. Are those the packages that have been made 3.3.x compatible, with the .Web packages still on the older version? . ",
    "jberke": "I am getting this issue as well. I am unable to upgrade because of the Ninject.Web* projects.. ",
    "kerrmittech": "This is still an issue with Ninject.Extensions.Wf  it does not have any thing beyond 3.2.0 and has a dependency that Ninject be < 3.3. ",
    "rawdrib": "We are running into the same issue trying to upgrade to version 3.3.1 to use on .NET Standard 2.0. ",
    "codecov-io": "Codecov Report\n\nMerging #256 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@          Coverage Diff           @@\nmaster    #256   +/-\n======================================\n  Coverage    83.9%   83.9%         \n======================================\n  Files          89      89         \n  Lines        2181    2181         \n======================================\n  Hits         1830    1830         \n  Misses        351     351\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 666833d...751875d. Read the comment docs.\n. # Codecov Report\nMerging #257 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@          Coverage Diff           @@\nmaster    #257   +/-\n======================================\n  Coverage    83.9%   83.9%         \n======================================\n  Files          89      89         \n  Lines        2181    2181         \n======================================\n  Hits         1830    1830         \n  Misses        351     351\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7006297...937ad26. Read the comment docs.\n. \n",
    "markashleybell": "You're welcome!. ",
    "MatteoSp": "Yes, I close it.. ",
    "michaelestermann": "When we updated the ninject package in our solution, we ran exactly into this issue. We've seen, that its fixed but not yet provided on nuget. \nCould you please create a new package (3.3.4) containing this fix. . Thanks for the fast feedback.  It just works now with the latest version \ud83d\udc4d . ",
    "Xebast": "You perfectly summarized the topic and the expected outcome.\nHere is sample code : \n```\npublic void TestNotRequiredHelloWorld()\n{\n    string exceptionMessage = string.Empty;\n    var ninjectSettings = new NinjectSettings() { AllowNullInjection = true };\n    var kernel = new StandardKernel(ninjectSettings);\n//No Weapon defined in our Program\n//kernel.Bind<IWeapon>().To<Sword>().InSingletonScope();\n\nkernel.Bind<Samurai>().ToSelf().InSingletonScope();\n\nSamurai samurai1;\ntry\n{\n    //So that I expect to have exception during resolution\n    samurai1 = kernel.Get<Samurai>();\n}\ncatch (Exception e)\n{\n    //Yes, I have expected activation exception\n    exceptionMessage = e.Message;\n}\n\n//I try Again...\n//Here, NO EXCEPTION and a Samurai is retrieved with Weapon to null\n//And it is not the expected result\nSamurai samurai2 = kernel.Get<Samurai>();\n\n}\nclass Samurai\n{\n    [Inject]\n    public IWeapon Weapon { get; set; }\npublic Samurai() { }\n\n}\nclass Sword : IWeapon\n{\n    public Sword() { }\npublic void Hit() { Console.WriteLine(\"Sword\"); }\n\n}\ninterface IWeapon\n{\n    void Hit();\n}\n```. Hi BrunoJuchli and scott-xu,\nThank you for your quick feedback and fix !. ",
    "gplwhite": "I wonder if the Array/List/IEnumerable support added to KernelBase.Resolve() in #252 could have been implemented as an IBindingResolver (and maybe a custom Binding)? That would at least allow the possibility of customising or disabling this functionality rather than having it baked right into the Kernel.  . ",
    "cblaze22": "You mean like with Stackoverflow or something?\nhttps://stackoverflow.com/questions/49911846/ninject-thread-blocking-issue-on-high-traffic-site. Guys I am sorry but I switched to SimpleInjector and the problem is resolved.  I am also under 10% CPU all day.. Havent had a problem since I switched to SimpleInjector. Been under 10% CPU the whole time.\n. ",
    "JustinBerger": "We are experiencing this same issue on 3.3.4.\n\nIt's not happening on every request, but we have ones ranging from 30 seconds to 300 seconds.\nUnfortunately we have not been able to reproduce it outside of a production load.. ",
    "evgeniy-bizhanov": "I use plugin based architecture and libraries name conventions doesn't match ninject recommended patterns.\nSo I have to use dynamic module loading.\nBut maybe I don't understand something.. Oh, thanks a lot, but what if I specify interception bindings in ninject modules and they will be loaded before Ninject.Extensions modules? Seems to be an exception?. ",
    "sahilkhan99": "hi, Im looking for the same information. \nCould someone please help in getting the settings right for Ioptions.. Ok, I have got the IOptions working with strongly typed class and Injecting in to Controllers.\nPlease see the code below. \nI followed what mentioned in this blog, setting up Ninject in .net core. \nhttps://dev.to/cwetanow/wiring-up-ninject-with-aspnet-core-20-3hp\nnow my app settings.json looks like \n```\n\"AppConfiguration\": {\n    \"FeatureFlags\": [\n      {\n        \"Name\": \"feature1\",\n        \"Status\": \"on\",\n        \"PilotUsers\": [ \"\" ]\n      },\n      {\n        \"Name\": \"feature2\",\n        \"Status\": \"pilot\",\n        \"PilotUsers\": [ \"lanid1\", \"lanid2\", \"lanid3\" ]\n      },\n      {\n        \"Name\": \"feature3\",\n        \"Status\": \"off\",\n        \"PilotUsers\": [ \"lanid4\", \"lanid5\", \"lanid6\" ]\n      }\n]\n\n}\nCreate a strongly typed class AppConfigOptions.cs, This class implements IOptions interface and returns Value.\n public class AppConfigOption: IOptions\n    {\n        private readonly AppConfiguration _appConfiguration;\n        public AppConfigOption(AppConfiguration appConfiguration)\n        {\n            _appConfiguration = appConfiguration;\n        }\n    public AppConfiguration Value => _appConfiguration;\n}\n\n```\nNow we bind the above class in NinjectWebCommon.cs\n```\n var appConfiguration = configProvider.GetSection(\"AppConfiguration\").Get();\n// we want app configuration in controller;\n  kernel.Bind(typeof(IOptions))\n    .To(typeof(AppConfigOption))\n    .WithConstructorArgument(appConfiguration);\nThat's all done binding now.  Lets make use of it. \nI have controller AppController\npublic class AppController : Controller\n    {\n        private IFeatureFlagServices _featureFlagService;\n        private IOptions _appConfiguration;\n    public AppController (IFeatureFlagServices featureFlagService, IOptions<AppConfiguration> appConfiguration )\n    {\n        _featureFlagService = featureFlagService;\n        _appConfiguration = appConfiguration ;\n    }\n\n}\n```\nHope this helps others.. ",
    "hesourman": "I have not tested whether changes to the Runtime Directives file (https://docs.microsoft.com/en-us/dotnet/framework/net-native/runtime-directives-rd-xml-configuration-file-reference) may effect the behaviour I observed. There are attributes that can be applied via this file that suggest they may merit investigation as a workaround/fix on a per-application basis.. During a build the following warnings appear in the output\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.Create(ConstructorInfo)' will always throw an exception due to the missing method 'DynamicMethod..ctor(string, Type, Type[], bool)' in assembly 'System.Reflection.Emit.Lightweight'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.Create(PropertyInfo)' will always throw an exception due to the missing method 'DynamicMethod..ctor(string, Type, Type[], bool)' in assembly 'System.Reflection.Emit.Lightweight'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.Create(MethodInfo)' will always throw an exception due to the missing method 'DynamicMethod..ctor(string, Type, Type[], bool)' in assembly 'System.Reflection.Emit.Lightweight'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.EmitLoadMethodArguments(ILGenerator, MethodBase)' will always throw an exception due to the missing method 'ILGenerator.Emit(OpCode)' in assembly 'System.Reflection.Emit.ILGeneration'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.EmitMethodCall(ILGenerator, MethodInfo)' will always throw an exception due to the missing method 'ILGenerator.Emit(OpCode, MethodInfo)' in assembly 'System.Reflection.Emit.ILGeneration'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.EmitUnboxOrCast(ILGenerator, Type)' will always throw an exception due to the missing method 'ILGenerator.Emit(OpCode, Type)' in assembly 'System.Reflection.Emit.ILGeneration'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n. Attempting to resolve a type the following exception is raised\nSystem.MissingMethodException\n  HResult=0x80131513\n  Message=Method 'DynamicMethod..ctor(string, Type, Type[], bool)' from assembly 'System.Reflection.Emit.Lightweight' was not included in compilation, but was referenced in DynamicMethodInjectorFactory.Create(ConstructorInfo). There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n  Source=\n  StackTrace:\n\nThis exception can be worked around by setting the 'UseReflectionBasedInjection' setting of NInject to 'true'.\nI was unable to find any other means to resolve this exception.. If 'UseReflectionBasedInjection' setting of NInject is set to 'true', the following method\nExtensionsForMemberInfo.ParentDefinitionMethodInfo\nencounters an ArgumentNullException in the code snippet\nvar runtimeAssemblyInfoType = typeof(MethodInfo).Assembly.GetType(\"System.Reflection.RuntimeMethodInfo\");\n                    parentDefinitionMethodInfo = runtimeAssemblyInfoType.GetMethod(\"GetParentDefinition\", Flags);\nThis is due to 'runtimeAssemblyInfoType' being null.. With this package, using NinjectSettings.UseReflectionBasedInjection = false the application crashes.\nMethod 'DynamicMethod..ctor(string, Type, Type[], bool)' from assembly 'System.Reflection.Emit.Lightweight' was not included in compilation, but was referenced in DynamicMethodInjectorFactory.Create(ConstructorInfo). There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\nand the following warnings are seen in build output window\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0005: Type 'System.Reflection.Emit.DynamicMethod' from assembly 'System.Reflection.Emit.Lightweight' was not included in compilation, but was referenced in method 'DynamicMethodInjectorFactory.Create(ConstructorInfo)'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.Create(ConstructorInfo)' will always throw an exception due to the missing method 'DynamicMethod..ctor(string, Type, Type[], bool)' in assembly 'System.Reflection.Emit.Lightweight'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.Create(PropertyInfo)' will always throw an exception due to the missing method 'DynamicMethod..ctor(string, Type, Type[], bool)' in assembly 'System.Reflection.Emit.Lightweight'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.Create(MethodInfo)' will always throw an exception due to the missing method 'DynamicMethod..ctor(string, Type, Type[], bool)' in assembly 'System.Reflection.Emit.Lightweight'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.EmitLoadMethodArguments(ILGenerator, MethodBase)' will always throw an exception due to the missing method 'ILGenerator.Emit(OpCode)' in assembly 'System.Reflection.Emit.ILGeneration'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.EmitMethodCall(ILGenerator, MethodInfo)' will always throw an exception due to the missing method 'ILGenerator.Emit(OpCode, MethodInfo)' in assembly 'System.Reflection.Emit.ILGeneration'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n.nuget\\packages\\microsoft.net.native.compiler\\2.1.8\\tools\\Microsoft.NetNative.targets(788,5): warning : ILTransform : warning ILT0003: Method 'DynamicMethodInjectorFactory.EmitUnboxOrCast(ILGenerator, Type)' will always throw an exception due to the missing method 'ILGenerator.Emit(OpCode, Type)' in assembly 'System.Reflection.Emit.ILGeneration'. There may have been a missing assembly, or a dependency on a more recent Windows SDK release.\n. With this package, using NinjectSettings.UseReflectionBasedInjection = true the application runs.\nMy application does not rely on method/property injection, so I have not tested if that actually works.. With this package (alpha078), using NinjectSettings.UseReflectionBasedInjection = false the application runs.. ",
    "ternst": "I don't think so.  The implementation  of IAuthenticationService that ninject is returning is Microsoft.AspNetCore.Authentication.AuthenticationService, which has 3 dependencies, none of which depend on an IEnumerable.  Furthermore, the top line of the stack trace is\nSystem.Collections.Generic.Dictionary`2.FindEntry(TKey key)\n, so it's the Dictionary that's throwing the error.. @BrunoJuchli \nI think you're going down the wrong path.  The exception being thrown is a new exception that Dictionary and HashSet will throw as of .NET Core 2.1.  In this case, it's the Dictionary that Ninject.Infrastructure.Multimap is wrapping that's throwing the exception.  There's no IEnumerable touching anything going on here.\nAs the above linked corefx issue shows, IdentityServer and EFCore have both had to fix internal stuff relating to how they were accessing dictionaries because of this.  This certainly looks like the same thing.. ",
    "bollhals": "I've been following the changes you've made so far and they do look very promising. Keep up the wonderful work!\nI was wondering about a potential release, is there an idea about when this will happen? (After all these changes are done or in incremental stages, timeframe e.g. one in March or end of year). ",
    "MrYossu": "@scott-xu Thanks for the reply. Isn't that just ignoring the issue? I assume that the reason there is a max version number on Ninject.Web is because there is some reason why it shouldn't be used with later versions of Ninject. If so, by ignoring dependencies, aren't I just letting myself in for some unseen issue later on?\nSorry if I misunderstood. Please could you clarify. Thanks again.. ",
    "maximejobin": "Why isn't officially supported by 3.3.4 ? Ignoring the dependencies shouldn't be the way to go.. ",
    "JaronPiet": "Run into this issue too. . ",
    "lorddev": "the .orig file is created by merges. "
}