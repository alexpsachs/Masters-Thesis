{
    "jedireza": "Closing since we have this in-flight with #148 . Thanks for creating this PR. I didn't see this before #130 landed.\nAs you're probably aware, the GitHub organization and domain name have changed to neon-bindings and neon-bindings.com. When we made that switch we had to setup hosting and publishing again. Luckily, publishing is automated, so once changes land, they'll show up after a successful Travis build.\nThe neon-bindings/www repo has the website files (https://www.neon-bindings.com/) and the crate docs (https://docs.neon-bindings.com/) are published from the gh-pages branch of this repo (neon-bindings/neon).\nWe still need to move the content from ./docs to the neon-bindings/www repo (exactly how hasn't been decided). But I think that's the same place we should host the lldb content you wrote here, so maybe we should create an issue and/or PR on that repo. \nIf you'd like to update this PR (or create a new one) with the content you have for the crate documentation, I'd like to change the v8 doc links to use the NodeSource domain instead of Paul's..  I see the new PR over at neon-bindings/www, thanks. Should we close this PR or do you plan on updating it for the crate docs?. r+\nI tested using the latest node 4, 6, 7 with mac and linux.. Thanks for creating an issue. I've confirmed this shows up with node 6. This error doesn't show up for node 4 and I get the following error when running with node 7 (not sure if it's a different issue yet):\n```\n\nFatal error in ../deps/v8/src/api.cc, line 1051\nCheck failed: !value_obj->IsJSReceiver() || value_obj->IsTemplateInfo().\n\n```\nI'm going to looking into the Nan solution and also see what #123 did to address this and try to land the fix.. Closing since #127 obsoletes this change.\n. Closing for now. See https://github.com/neon-bindings/neon-cli/issues/35. Resolved in #148 . Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. Consolidated into # 147. @dherman I also noticed we're specifically testing rust nightly-2016-04-29. Is there something special about that release or just something legacy we can remove while we're at it?. \ud83d\udcdf @dherman . r+. r+ :shipit: . @dherman new commits pushed. We should be good to go.. Ah good call. The bug with the failing test was fixed via https://github.com/neon-bindings/neon/pull/161 and the failing tests producing a failing build was fixed via https://github.com/neon-bindings/neon/pull/191.. r+ :shipit: . r+ to the changes, they're simple enough.\nI wonder what we lose by adding --silent? At first glance this sounds like a bug that should be filed up-stream.\nIf we get around this [Windows bug] using --silent do we want to create an issue that tracks this and removes the argument when it's not necessary?\nMaybe we could apply this argument for Windows users only.\nI only hesitate because we're silencing something that may be helpful when looking at build logs or during development.. I see now that the output of cargo build scripts are suppressed anyways, unless an error occurs.\n\nhttps://github.com/rust-lang/cargo/issues/1106\n\nThere is a -vv argument (possibly undocumented) we can pass to cargo to see the output of the build script while it's running.\n\nhttps://github.com/rust-lang/cargo/pull/2630\n\nThis can be helpful in the case of windows builds hanging since an error hasn't actually occurred yet (process hasn't finished). With this [-vv] I'm able to get more insight into what's causing the hang ~~(possibly something related to $ node-gyp rebuild)~~.. Thanks for letting us know. I've created a PR to fix here: https://github.com/neon-bindings/www/pull/4. :shipit: r+. r+ :shipit: . r+ :shipit: . I'm fine with bumping the minimum version of Rust to 1.15 for everything. It seems like a maintenance headache to require different versions of Rust for different environments.\nChanges look good. We should update the README with the minimum version for Rust though.. @dherman there's a failure with compile_tests and it looks like it's been failing for a while now (for the last month, if not longer). Should we open another issue for that or try to fix it in this PR?\nAlso it doesn't look like AppVeyor is running compile_tests for Rust nightly on Windows, is that something we should address here, in another issue or not worry about it?. > The C++ project shows the basic approach to converting a Local to Persistent in v8 in order to preserve between the main addon method and the callback [...]\nIIRC this is where I left off when attempting async callbacks with Neon. We need a way to persist the callback so that Rust doesn't drop it when the call goes out of scope.\nI spoke with @dherman about this (a while back) and we (at the time) thought it was best to not introduce the idea of Persistent handles in the Neon API and instead expose something more specific to async callbacks.. According to the Cloud Functions page:\n\nCloud Functions are written in JavaScript and execute in a standard Node.js runtime environment. We don\u2019t assume anything proprietary all the way down to the operating system, which means your functions will just work\u2014including native libraries you bring to the platform.\n\nVia: https://cloud.google.com/functions/\nCurrently Rust and Cargo are dependencies for Neon modules to be built. Those would probably have to be present in the Google Cloud Function environment for Neon modules to build.\n\nOut of curiosity I looked up how AWS Lambda handles native node modules:\n\nNative modules are similarly installed and deployed, but you\u2019ll need to build them against the Amazon Linux libraries. You\u2019ll need to either ensure that the libraries and their transitive dependencies are statically compiled or use rpath-style linking\n\nVia: https://aws.amazon.com/blogs/compute/nodejs-packages-in-lambda/\nSo with AWS Lambda, you're pre-compiling for their environment and uploading a zip file.. Nice! When this lands... we'll really be cooking with \ud83d\udd25.\nA couple things that crossed my mind:\n\nShould we include \"async\" in any of the naming so it's crystal clear that this is indeed off the main thread? Maybe docs will suffice.\nA JavaScript test/example would be great to see.. Yep, the error is telling the truth. Deep down the Neon representation of the V8 isolate is a c_void (docs here: std::os::raw::c_void). Thus we can't move variables rooted in that isolate off the thread safely. Someone please correct my terminology/understanding if I'm wrong.\n\nDo checkout the wonderful work in https://github.com/neon-bindings/neon/pull/214 though. Once that lands, we'll get proper background work off the main thread.\nIf you don't need async callbacks, but just want to parallelize the work you're doing that is possible today. The home page of neon-bindings.com shows that you can use Rayon this way.\nrust\nlines.into_par_iter()             // iterate in parallel\n     .map(|line| wc(line, word))  // count words for each\n     .sum()                       // calculate the total\nThe full word counting example is a bit old and I'm not sure if it's compatible with the latest Neon, nonetheless you can find it here: https://github.com/dherman/wc-demo\nI hope that helps.. Thanks for giving it a shot.. Not too nit-picky, I like that more.. I feel the least confident about this description.. This is the first time mentioning v8::, I wonder how specific we should be about this throughout the neon_sys docs.. I'm unsure about this description.. Here we redirect index.html (which doesn't have any content) to neon/index.html. This is also because we're going to be hosting the neon-sys and cslice crate docs.. This is my existing token setup for Travis (as per the linked blog post). Unless I missed something, these don't exist for GitHub Organizations, but only for individual users.. If this name is arbitrary, and we're hapy with the one chosen, maybe we could re-phrase this comment and add a link to the crates.io docs about this key.\n```toml\nThis name allows us to re-export the location of node.lib\nto dependent packages so they can link on Windows.\nhttp://doc.crates.io/build-script.html#the-links-manifest-key\n``. Do we expectnode-gypto be installed globally?. So theneon-build` crate isn't required in production? Will production builds still succeed?. Are we going to leave these in here commented out?. Maybe these caused git not to recognize the file name changes.. ",
    "Qard": "You could hack it with macros.\nRather than:\nrust\npub extern fn make_an_array(call: &mut Call) {\n  let result = Scope::run(|scope| {\n    let mut array = scope.array(3);\n    array.set(0, scope.integer(17));\n    array.set(1, scope.integer(42));\n    array.set(2, scope.integer(1999));\n    call.set_return(array);\n  });\n}\nyou could have something like:\nrust\npub extern fn make_an_array(call: &mut Call) {\n  let result = scope_run!({\n    let mut array = v8_array!(3);\n    array.set(0, v8_integer!(17));\n    array.set(1, v8_integer!(42));\n    array.set(2, v8_integer!(1999));\n    call.set_return(array);\n  });\n}\nI feel dirty just thinking about it.\n. @kjvalencik v8::External is the more \"correct\" way to pass something like that around.\n. node-pre-gyp might be helpful.\nI feel like it might be better though, at least in the shorter term, to just make an npm module that installs Rust, if it's not already present. You can use the install lifecycle event in npm to trigger a script which checks if Rust is present and installs it, if necessary. For an example of how that lifecycle event works, see here and here.\n. Should be possible to contain the response data in a movable object with the callback and just hand it to libuv to execute in the uv_default_loop() thread.. It should be noted that it's feature flagged for now, but I'd definitely say it's worth looking into since it'll be a stable target soon and can be used in pure C, so neon could make better use of Rust FFI rather than having to maintain neon.cc. \ud83d\ude38 . Released, but behind a --napi-modules flag.. Yep, just wanted to be clear it's still behind a flag, so not production-ready yet, and could change at any time.. N-API is no longer flagged as of Node.js 8.6.0, by the way. \ud83c\udf89 \nhttps://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V8.md#2017-09-26-version-860-current-jasnell. ",
    "dherman": "I had another hacky idea but I think it's too painful to use: if we could exploit the borrowing rules that prevent multiple simultaneous borrows when one is mutable, maybe we could somehow force the client into a mutable borrow when nesting so that no other borrowing is legal for that duration. I'm not sure if this would work, but the problem is it means you have to declare all scope variables with mut when they're going to be nested, which would just be hacky and ugly.\n. Fixed in 3c596a00c424dc00f71364044f751bf7da24db26\n. Fixed in 3c596a00c424dc00f71364044f751bf7da24db26\n. I take it by \"hypothetical\" this doesn't exist yet. I'll reopen if/when it happens.\n. I think this doesn't work except possibly with non-lexical borrows. Code like\nrust\nlet mut array = Array::new(scope, 3);\narray.set(0, Integer::new(scope, 0));\narray.set(1, Integer::new(scope, 1));\narray.set(2, Integer::new(scope, 2));\nis going to be rejected for (purportedly) attempting multiple simultaneous mutable borrows.\n. OK, nonlexical borrows won't really help enough. It's fundamental in Rust that you can't have multiple live &mut borrows tied to the same source. So for this to work we'd have to impose a mental model that you can only have one live handle at a time. (And it would require nonlexical borrows to be ergonomic, I think.) But this is just too weird and restrictive a mental model.\n. Stop press! Niko suggested a trick to circumvent the &mut restrictions that could work: create a shadow lifetime \"behind\" the Scope object's lifetime, and have the allocators return handles with the shadow lifetime.\n. Thanks to rust-lang PR 29188, my branch works in the latest Rust Nightly! Landing soon.\n. Fixed in 3002c9217dd4f4b39fbde26b8873e98a4f8eeec5.\n. IIUC, this means it's not a great idea to try to distinguish the types, since the distinction doesn't carry strong performance promises. Closing for now.\n. I just this is probably a bad idea. :P. I'm going to attempt to address this with the \"Classes 2.0\" RFC.. @SeanPrashad Go for it! Ping me on Slack any time if you need any help.. I will attempt to start this conversation with a \"VM 2.0\" RFC.. @commandline I just landed Linux support a couple hours ago. Can you update to neon-cli 0.1.2 and try again for me?\n. Should be fixed, so I'm closing this, but do let me know if you still have trouble. Thanks!\n. @ArsalanDotMe @marxo A quick progress report: I've got a docs site set up, and I've stubbed out a hacking guide, but no contents yet. Steadily making progress though!\nFor the time being, if you're interested in contributing please feel free to come hang out on the community slack (grab an automatic invite to join) and ask questions on #neon. (Or you can join #neon on irc.mozilla.org if you prefer IRC.)\n. Let's open an issue in the guides repo for this. @nixpulvis I'm excited you want to help with this and I hear you Re: not wanting to write about stuff that's likely to change. I think Classes 2.0 and VM 2.0 are the biggest changes coming, so maybe we can discuss this during/after those RFCs.. Yep, we'll definitely need something like that. One of my near-term plans is to sketch up an API road map.\n. @Drakulix I'm getting ready to start looking into this, but I haven't used Nan's AsyncWorker etc. Can you help get me up to speed? Where should I go to learn more about them (other than the API docs, of course)?\n. @loyd It's working its way up my priority queue but not at the top just yet\u2014I've been focused on Electron support first. I haven't dropped this but can't give an ETA just yet, I'm afraid\u2026. @kjvalencik Agreed! \\o/. This should be fixed now, but needs a test.\n. Oops, this issue belongs in neon-cli. Closing here; refiled as rustbridge/neon-cli#19.\n. I think this should be fixed by now -- it was reported back before we were testing Windows regularly and in CI. Closing but please do reopen if you see the same issue again!. A set of constraints I think are worth trying to satisfy in the naming:\n- avoid painful collisions with common Rust abstractions, in particular Result and String\n- different names for Object type vs Object trait\n- different names for Value type vs Value trait\n- any boilerplate prefixes of names should be short\n- naming convention for value tags should hew closely to JS naming conventions (e.g. SomeObject isn't great since it's not a familiar JS convention)\n. Here's a proposed set of names. I think I'll try this out in a PR.\nResult\n- neon::vm::VmResult\n- neon::vm::JsResult\nJS Values\n- neon::js::JsArray\n- neon::js::JsBoolean\n- neon::js::JsFunction\n- neon::js::JsInteger\n- neon::js::JsNull\n- neon::js::JsNumber\n- neon::js::JsObject\n- neon::js::JsString\n- neon::js::JsUndefined\n- neon::js::JsValue\nJS Traits\n- neon::js::Object\n- neon::js::Value\nJS Typed Arrays\n- neon::js::binary::JsUint8Array\nJS Errors\n- neon::js::error::JsError\n. An alternative would be to go ahead and call them e.g. neon::js::String and recommend referring to them with qualified paths like js::String, but then we'd have to come up with alternative names for the Object and Value traits. The Value trait could maybe be Js, but what about Object?\n. This should be addressed by the Classes 2.0 and VM 2.0 RFCs.. This will be addressed by the VM 2.0 RFC.. I'm going to go ahead and merge this PR for now, so that we can get some experience with the feel of it. If it doesn't feel good we can iterate on it.\n. Thanks for the heads-up. I don't want to step on anyone's toes, but I think there's room for software projects in significantly difference spaces to have the same name. Note that there's already another neon project in npm as well, so this is certainly not the first. I appreciate your bringing this to my attention, and I'll close for now.\n. I think this was fixed and can't reproduce, but please reopen if you see it happening again! I'll try to keep an eye out for it as well.. The \"smoke test\" portion of this process might be better dealt with using a vargo new --neon abstraction as I sketched quickly in neon-bindings/rfcs#8.. Note to self: investigate using cargo-release for this.. Even though it's not tested, I'm gonna close this issue and call it implemented for now (since #318). I'll open new issues for testing it out with the next release, and for automating it further.. PS For posterity, the simplified/semi-automated process is now documented on the Release checklist wiki page.. The mechanism we can use for hidden properties is v8::ObjectTemplate::{New, SetInternalFieldCount} and v8::Object::{GetAlignedPointerFromInternalField, SetAlignedPointerFromInternalField}.\nThe mechanism we can use to prevent tracing is to restrict the Rust API to requiring the owned Rust data to be bounded by the 'static lifetime.\nI'm not sure what the v8 finalization API is yet but I'll dig.\nI'm also not sure what the v8 approach to object branding is. It must exist since there are all sorts of distinctly branded object types on the web that expose JS predicates to check for the brand. I'll have to keep digging on that too.\n. Forgot to mention: the rust api for the JS object type would implement Lock so you can get a borrowed reference to the internal rust data by locking the JS object.\n. @kjvalencik I think persistent handles are probably pretty easy to expose safely but too leak-prone to be the common case API (because you have to explicitly release them). I think we can do an API that used a finalizer to automatically release Rust data. But it's probably worth experimenting with both -- they may both serve different use cases.\n. Some progress from digging through V8 docs and mailing list threads: looks like the standard way to check if an object is of a particular type is to create it with a FunctionTemplate and use FunctionTemplate#HasInstance. Sadly it looks like the leaner ObjectTemplate doesn't have such functionality.\nA tricky bit to figure out is how and when to allocate a user-defined FunctionTemplate since its lifetime is tied to the implicit v8::Context. Neon has no tracking of this, at least currently. (I hope the answer isn't threading another lifetime variable through all APIs!)\n. Basic shape of what the UX might look like for defining a class:\nhttps://gist.github.com/dherman/18efdc5e6c342513e46b\n. Fixed in #58.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. @msvbg Would you mind leaving the same relicensing comment here too? I believe you're the only contributor who's committed since this bug was filed. Thanks!\n. We'll need to flesh out the error safety design, which will probably need an RFC. See the milestone.. @chpio Does JsString::new_or_throw do what you want? The name is admittedly ugly -- is this a naming issue? Or is there something about new_or_throw that isn't what you're looking for?\n. At least for now, the kinds of patterns of parallelism you can use are limited, because the goal is to retain Rust's memory and concurrency safety guarantees, in particular freedom from data races. I have doubts we'd be able to support shared memory IO but I'd certainly be open to learning safe ways of making that work.\n. I think helping people debug problems relating to the version of Rust they're using is a valid issue, but I think if we did something like this it would belong at the cargo level, not the package.json level. I also want to be careful about this one because the cargo team has been pretty conservative about adding such a feature due to unintended ecosystem effects.\nI'm going to close this for now, because I think it requires an RFC to think through the design. But if someone would like to investigate this I would definitely encourage an RFC!. While this technically isn't a bug, it's an indication that the API design isn't very good. I'm going to close this issue but we probably want to improve the UX of the API, perhaps as part of the VM 2.0 RFC.. I think I want to rename it to Key also, to keep it nice and short. (And JS has precedent for calling it a \"key\" with Object.keys().)\n. Will be implemented similarly to #60 so probably blocked on that.\n. The ClassDescriptor type will need an inherent method extend with a signature something like:\nrust\nfn extend<'b, U: Class<Internals=T::Internals>>(super: Handle<JsClass<U>>, name: &'b str) -> VmResult<ClassDescriptor<'b, U>> { ... }\n. This should either be part of Classes 2.0 or a subclassing RFC.. Closing so we can track this in the RFC issue instead.. @drbo I'm still a bit wobbly on my GC/memory management skills so let me see if I follow:\n- The handles API makes it possible for the stack to safely hold references to JS objects.\n- The class API (implemented in #58) makes it possible for JS objects to safely own Rust objects.\n- But we can't currently have JS objects own Rust objects that hold references back to more JS objects.\nSo is that specifically what this would enable? If we could provide a safe way to implement the trace hooks for a Rust type, then it would be safe for a neon class to own Rust objects of that type.\nDo I have that right?\n. I'd love to see an RFC sketching out the API! I'll open an issue in the RFCs repo.. Candidates for the method name: tap, uncover, unwrap, unpack, open, operate, pierce, puncture, probe, peel, seize, grab, take, zoom, focus\nI like \"grab\". It's kind of evocative of temporarily taking hold of the value, and also hints at grabbing the lock.\n. Never mind this one, v8 doesn't expose it.\n. Here's an RFC for the API: neon-bindings/rfcs#18. I think I can only assign it to committers but your comment is enough! I'll edit the issue description so people don't miss that you've claimed it.. I've noticed that N-API doesn't include RegExp objects, but I'm not sure why. I reached out to one of the N-API team to see if there's a concrete reason:\nhttps://twitter.com/littlecalculist/status/976781367559245825. Sounds like N API hasn't prioritized this:\nhttps://twitter.com/mhdawson1/status/976829150789976064\nSo I think we should not add this unless someone has an explicit need for it, and we can propose that N API add it.. @bennyn That's great to hear you have use cases for Neon! I'm happy to prioritize adding at least Uint8Array. In the meantime would the JsBuffer type work for you? (AIUI the Buffer class is a subclass of Uint8Array.). This deserves an RFC, and we should also think about whether we want to offer a way to get the different typed views on an ArrayBuffer directly within Rust. Right now you can hack your way to doing this with some unsafe Rust skulduggery:\nrust\nbuffer.grab(|mut slice| {\n    let len = slice.len();\n    let raw = slice.as_mut_ptr();\n    let mut slice: CMutSlice<f32> = unsafe { CMutSlice::new(mem::transmute(raw), len / 4) };\n    slice[0] = 1.8;\n    slice[1] = 13.4;\n});\nI think it's important to be able to do this with an ArrayBuffer, without having to require the JS to pass you a view of the right type. Maybe the best way to do this is for the Lock implementation not to directly provide a CMutSlice<u8> but instead a custom type that gives you access to CMutSlice<u8>, CMutSlice<i8>, CMutSlice<u16>, CMutSlice<i16>, etc.. Possible libraries to reuse for this:\n- https://github.com/rednum/interval_trees\n- https://github.com/ptal/intervallum\n- https://github.com/azurespace/segment-tree\n. That's probably a good initial set. It's almost impossible to have any real notion of coverage being \"complete\" for a project like this, but it's at least a good breadth-first start. I'm so excited to grow the test suite over time!\n. To be clear, the reason for this is to prevent a memory leak, which will probably not be severe for light uses of workers. Only apps creating classes in many workers will see an issue.\n. This is so great! If you wouldn't mind fixing the couple minor nits then I'll merge right away.\n. I figured out why the Travis tests are failing: they upgraded to Node.js v6, which requires an upgrade of nan and node-gyp. Can you change the crates/neon-sys/package.json to use \"nan\": \"^2.3.2\" and \"node-gyp\": \"^3.3.1\"?\nAlso, we should start specifying the exact versions of Node.js we support in .travis.yml. I think for now we should support 4.x and later. It's up to you if you want to add that in this PR or we can add it afterwards.\n. \n. Awesome -- just one minor issue, the expected/actual ordering is backwards in the chai tests.\n. The design will need to be sketched out in the error safety RFC.. Closing this since it should be part of the RFC design discussion.. Good catch thanks! Our CI is now testing on v4 - v6 and we'll try to keep up with the latest stable, so I updated the readme.\n. :tada:\n. So sorry I left this PR to bitrot! It was superseded by #108 but I still really appreciate it. <3\n. :tada: Thank you!!\n. Working on an RFC for this! I will post it this weekend, and then if we all like the look of it, the writeup should make it easier for someone to implement!. OK, I looked into this! I actually think we already have what @abrodersen and @mrzenioszeniou are asking for, with JsFunction::construct(). So for example, with @mrzenioszeniou's example, you could do:\n```rust\n        method getAddress(call) {\n            let scope = call.scope;\n            let user_handle = call.arguments.this(scope);\n            let mut user = *user_handle;\n            let address = user.grab(|u| { &u.address });\n        let addressClass: Handle<JsClass<JsAddress>> = JsAddress::class(scope)?;\n        let addressConstructor: Handle<JsFunction<JsAddress>> = addressClass.constructor(scope)?;\n        let constructor = *addressConstructor;\n\n        let args: Vec<Handle<JsNumber>> = vec![];\n        Ok(constructor.construct(scope, args)?)\n    }\n\n```\nI think we can also add a shorthand JsClass::construct method to abstract out the boilerplate of extracting the constructor from the class before invoking it.\nThis issue proposed a slightly different thing, which I think is actually not future-proof for eventually adding support for subclassing and the ES6 super() protocol. I think what I'll do is separate out the two things as RFC issues, and the first one (JsClass::construct) should be a tiny RFC and straightforward, and the second one should be more of an exploration for now, since neither the V8 API nor the N API yet support the super() protocol.. Actually I think we can also add a Class::construct convenience method too. That would simplify the example to:\n```rust\n        method getAddress(call) {\n            let scope = call.scope;\n            let user_handle = call.arguments.this(scope);\n            let mut user = *user_handle;\n            let address = user.grab(|u| { &u.address });\n        let args: Vec<Handle<JsNumber>> = vec![];\n        Ok(JsAddress::construct(scope, args)?)\n    }\n\n```\n. OK here's an RFC for the convenience forms--feedback welcome!\nneon-bindings/rfcs#17. This was partially a dup of #108, which I already merged, so I went ahead and fixed the spurious imports in 520d8abeda768c5abdaca2d538e285348f2c389c -- but thanks for the PR!\n. Thanks for the fix! \ud83c\udf89\n. This is awesome, and I'm sorry for taking so long to review! I'm working with @jedireza to try to keep on top of PRs more regularly.\nBecause this needs to sync with neon-bindings/neon-cli#31 it's worth merging independently of #123, and I think some aspects of #123 won't be able to land as-is anyway. So I think we should merge this one.\nAs far as I can tell, this improvement has the same behavior as the way it originally works, but is simply less brittle. So it seems like a clear win.\nThanks so much!. (I think @jedireza wanted to just test this out in a few versions of Node before merging, so I'll wait to merge till he's ready.). (Next I'll merge the commit that eliminates the env variable entirely.). @KenanSulayman The API you want is the Lock trait, which is implemented by JsBuffer and allows you to get access to the internal buffer as a Rust slice. I made a small example to demonstrate how you can use the Lock::grab method to do this:\nhttps://github.com/dherman/neon-examples/blob/master/populate-buffer/native/src/lib.rs#L10-L15\nDoes this help?\n. @KenanSulayman Yes, it's definitely possible, although unfortunately it's pretty verbose. At least for now, this is what you have to do. For example, let's say you have a helper function that takes an object and wants to get a property from the object:\nrust\nfn my_helper_function<'a, S: Scope<'a>>(scope: &'a mut S, obj: Handle<'a, JsObject>) -> JsResult<'a, JsValue> {\n    // ...\n}\n. A sketch of an even more complete end-to-end UX: https://gist.github.com/dherman/f4131507f070ad049bf557dc0c75de0a\n. /cc @KenanSulayman\n. Moved to https://github.com/dherman/cslice in #181 and resolved in dherman/cslice#1.. I'd left this around because I was never sure what I wanted to do with it, specifically because I wasn't sure how universal the idea of string API's for different string representations would be. (Neon tries to avoid V8-specificity.) But now that the N API, which involved stakeholders from multiple JS engines, includes multiple string representations, I feel better about committing to something like this.\nI think I'd like to write up a mini-proposal for the API first. So I'll go ahead and close this now, but it'll be there in the closed PR list as a reference for the eventual implementation.\n(Max, thanks again for all your help with Neon last year!). @maxbrunsfeld Would you be up for joining the Slack and chatting some time? I want to merge this amazing work but it probably needs a little coordination.. @maxbrunsfeld I guess my main question right now is whether this PR obsoletes #123?. OK I spent a bunch of time understanding this PR, and I think I will split it into 7 separate PRs, in this order:\nConsistent calling convention\n\nUse C calling convention \n\nWindows compilation issues\n\nUse statically-dispatched destructor call to work around MSVC bug\nDisable WholeProgramOptimization along with LinkTimeCodeGeneration\n\nWindows path issues\n\nFix object file path on windows\nFix npm path on windows\n\nWindows npm issues (depends on: Windows path issues)\n\nRun npm with --silent to prevent it from stalling on Windows\n\nWindows linker issues (depends on: Windows npm issues, neon-bindings/neon-cli#32)\n\nResolve and pass node.lib to the linker on Windows \nRemove build dependency on regex crate\n\nWindows node-gyp issues\n\nPrevent cargo build from hanging on Windows\nTemporarily build node bindings only against ia32 for testing\nBase node-gyp --arch flag on Cargo target architecture\nDowncase npm environment variables to ensure they are read by node-gyp\nParameterize node_lib_file in addition to node_root_dir \n\nAppVeyor\n\nAdd appveyor.yml\nTest on both x86 and x64 platforms on appveyor\nUse Visual Studio 15.0 on Appveyor\nInstall the correct node.js for the current platform on appveyor\nBuild on x64 on AppVeyor but compile for x86 as well\nTest 32bit and 64bit compilation on a x86 platform on AppVeyor\n\nI intend to preserve the authors, but splitting the work up in these chunks will help me to understand how it all works as well as to ensure CI keeps passing as we go along.. OK, all the commits in this PR have landed, so I'm going ahead and closing.\nThank you to @as-cii, @nathansobo, @maxbrunsfeld, and @EdShaw, so much! I never would've figured this out on my own.. OK, this PR gave us lots and lots of helpful info and we're making good progress. Windows support is in pretty good shape now, and #194 is tracking the remaining steps we need for Electron support. So I'm closing this one with much gratitude!. Thanks, I will definitely come back to this\u2014right now my top priority is the Windows PR, but after that I will get back into the class system.. I'll close this since it won't land as-is, but I will for sure cite you when we land the final version. :D. I really like the intuitions behind this -- I agree both that npm -e require(\".\") is an icky thing to recommend, and that npm install semantically feels off when you're telling people how to rebuild. But maybe we can open an issue to try to capture what different workflows we might want, so we can think through what the UI should look like for each.. r+. r+. r+\nSo great to start to have more complete docs.. So awesome! About to sit down for dinner but I will merge this tonight and then maybe make a few tweaks to include the couple other doc pages too.. So as I understand it, the odd-numbered versions of Node are unstable and get superseded by the even-numbered versions, which turn into LTS. So that's why we (in theory) could drop support for version 5, since 6 is supposed to be compatible with 5 and it should (again, in theory) always be safe for someone to upgrade from 5 to 6, right?\nI agree that if Node itself isn't supporting versions earlier than the last LTS, it seems unrealistic for us to try to support them, so only going as far back as the most recent LTS seems wise.\nAt any rate, until we have more customers, we don't know for sure what people will need, so we have to start somewhere. Keeping our CI reasonably efficient seems like a good goal for now, but we should be willing to revisit if we end up with customers who raise concerns we hadn't thought of.. @bnoordhuis If it's incompatible to bump from 5 to 6, doesn't that mean we should expect a fair amount of customers not to move right away? I think the open question for me is whether to continue to support the odd-numbered versions or not.. @jedireza Here's what I propose as resolution:\n- We go with your proposed policy for now, to cut back on build times and maintenance burden.\n- We publish our support matrix somewhere clearly. The README is fine if it's not overwhelming but I suspect it'll want a dedicated documentation page.\n- If we find more customers over time are using odd-numbered nodes and unable to migrate immediately to even-numbered nodes when they come out, we should be willing to revisit this policy.\n. @jedireza according to git blame it showed up in 58d41e62e54f267dd0d9bf16338b5e7340fc7ec1. I don't recall what was special about that nightly but I highly doubt it's important anymore. Let's just remove it.\n@mfpiccolo do you know what the story was behind that specific nightly?\n. r? @jedireza -- all checks pass because this doesn't actually care that the CLI is passing the env var still, it just ignores it now. So we can merge first and then release new versions of both neon and neon-cli.. :rocket:. Thanks, @winding-lines - this will actually already be removed in #153 as soon as we fix a couple nits there. But thank you!. On a related note, what I was about to look into was fixing neon-cli to work with rustup instead of multirust.. r? @jedireza. OK, it took a while but the bug has been identified in Rust's Command API, and a PR has been filed:\nhttps://github.com/rust-lang/rust/pull/38835\nSo we should just go ahead with the workaround but leave a comment to remove the workaround once the Rust fix has been in long enough. We may want to wait at least a couple of Rust release cycles so people can use older Rusts.. Yeah, this is an annoying papercut! Thanks for the report. I see in #168 you figured out the workaround but we should definitely make it nicer.\nI'm not sure if allowing ty instead of ident will cause grammar ambiguities but we can try that first. Failing that, we could allow something like ident or (ty) (that is, if you want a more general type syntax you have to parenthesize it). That wouldn't be ideal but it'd be better than the status quo.. This one is a trickier issue: you're wanting to define a JS class for a generic type. Depending on what you're trying to do, you could just define the JS class for a specific instantiation of the type, e.g. BigArchive<i32> (and annoyingly, because of issue #167 you have to do a type alias like:\nrust\ntype BigArchiveOfInt = BigArchive<i32>;\ndeclare_types! {\n    pub class JsBigArchive for BigArchiveOfInt {\n        ... \n    }\n}\nBut I suspect that's going to be horrible as soon as you're looking for more than one instantiation of BigArchive. You could define a macro to generalize this but it'll be painful.\nThe more general solution will be for us to find a way to define JS classes for generic types. One answer might be that you could define a generic class declaration like:\nrust\npub class JsBigArchive<T: Read + Seek> for BigArchive<T> { ... }\nBut you'd still have to instantiate JsBigArchive for each different type, which means you get a different JS class, with a separate constructor and prototype pair for each instantiation.\nWhat this might want instead is to be able to define a single JS class for a generic Rust type, where the type argument has to implement coercion traits. So then you could write something like:\nrust\npub class<T: Read + Seek + ToRust + ToJs> JsBigArchive for BigArchive<T> { ... }\nThe macro would then automatically insert the appropriate coercions when going between Rust and JS.\nBut this is just a sketch of thoughts. We'll need to actually dive in and experiment. Your library could be a great test case! I'll look for you on Slack and see if we can define a minimal \"hello world\" use case that is representative enough to experiment with.. I successfully ran all the tests in my Windows VM, so this should be good to go. After this, all that's left to merge from #122 is the commits that set up AppVeyor CI.. Merging for now since we can't seem to test it without it being in master. We can push new commits to fix any bugs.. r+. r+. @JoeyAcc If you have a second, would you mind trying to create a fresh project and building that, to see if you get the same error? The Windows changes did make some changes to generated projects, so that could be the culprit.. Ah, I see, yeah that is probably at least part of the problem. I'll do a 0.1.12 release very soon.. I'm actually making more progress debugging this on my Windows VM now. I'm not sure why it's working in CI but not here, but at least I'm able to reproduce! Thanks for helping track these issues down, I'm on the trail.... From looking at https://github.com/npm/npm/tree/latest/bin/node-gyp-bin and for example npm/npm#14568, it looks like node-gyp.cmd only came into existence in relatively recent versions of node. But all versions appear to just delegate to $(which npm)/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js, passing all the command-line arguments through unmodified. So it seems like calling that script is a reliable entry point that should work going back to node 4.. zomg I just got everything working on my local machine. Almost ready\u2026. With neon-bindings/neon-cli#47 we should be good to go!. FINALLY\n@JoeyAcc I published 0.1.12 today. If you have a chance, can you give it another try? All you'll need to do is install neon-cli 0.1.12 and try making a project from scratch.\nIf that works, you should be able to get your existing project working, too, but you'll want to look at the differences between your existing project config files and the config files of a new one.. Doh! I was just in the process of moving cslice to https://github.com/dherman/cslice and didn't see this PR. Do you mind re-filing it there? I'll be happy to merge and publish ASAP.. Never mind, I submitted dherman/cslice#2 and set the author to you :). I've published cslice 0.3.0 with your changes. Thanks!. I've just published a new version of neon that fixed a lot of build issues, although I'm still working out the kinks. Would you mind trying updating to neon-cli 0.1.12 and recreating the project and try again?. Argh! OK I'm getting familiar with that error (but oh my heavens do I need to improve the errors). This seems to happen when the neon-runtime build script incorrectly finds the node-gyp script.\nCan you show me the output of which node and ls $(which node) on your system?. Does /usr/local/lib/node_modules/npm/node_modules/node-gyp exist on your system?. OK, so I'm gonna need some more info than the error is giving you -- would you be willing to let me dictate some local hacks to get the build scripts to spew more info?\n(Thank you so much for this help, btw -- you're helping me make this software actually, like, work. :P). OK awesome! So first, clone this repo (neon, not neon-cli) somewhere on your system, and then hack neon/crates/neon-runtime/build.rs -- inside the build_object_file function, right after where it says let output = node_gyp().args(&configure_args).output().expect(...); add another few statements:\nrust\n    println!(\"==================\");\n    println!(\"CONFIGURE:\");\n    println!(\"{}\", String::from_utf8_lossy(&output.stderr));\n    println!(\"==================\");\nThen inside neon/crates/neon-runtime, run cargo build and share the output here -- we'll see if that gives us some more insight.. OK, so that's not where it's going wrong. Let's try the next node-gyp command: at the end of build_object_file, where it says node_gyp().stderr(Stdio::null()).args(&build_args).status().ok().expect(...), change it to:\nrust\n    let output = node_gyp()\n        .args(&build_args)\n        .output()\n        .expect(\"Failed to run \\\"node-gyp build\\\" for neon-runtime!\");\n    println!(\"--------------------\");\n    println!(\"BUILD:\");\n    println!(\"{}\", String::from_utf8_lossy(&output.stderr));\n    println!(\"--------------------\");\nAnd then run cargo build in the neon-runtime directory again.. We're getting warmer... What does ls /usr/local/Cellar/node/7.5.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js do?. How about ls -l $(which node) ?. A few more -- we're making progress :)\nls -l /usr/local/Cellar/node/7.5.0/lib\nls -l /usr/local/lib/node_modules\n(There's something about your node installation setup that is tripping the build script up. It seems like it might have to do with how some symlinks are organized.). Actually since it looks like you have a standard homebrew installation of node, maybe I can just test that on my system. I'm using node via nvm instead of homebrew, so that's probably the root cause.. OK I think that tells me enough -- I'll try it on my system! Thanks again\u2026. OK it looks like homebrew installs node-gyp in yet another subdirectory. Now I know of different directory structures for Windows node, unix node, nvm node, and homebrew node. O_o\nThis does not seem like a sustainable approach to finding and invoking node-gyp!\nIn my head I keep flirting with the idea of just putting the node-gyp npm package as a local dependency. The main reason I was reluctant turns out to be wrong: I thought we'd have to install different versions of node-gyp depending on which version of node the client is using, but I see that node-gyp can be used across multiple node versions, so that's not an issue.\nSo the only real concern then is just that it'll add another 5 or 6 seconds of build time for neon-runtime (for npm to install the node-gyp dependency). I think that's probably preferable to constantly fighting with brittle differences in directory layout across different installation flavors of node.. @squiidz #189 should fix this -- it works in homebrew on my machine. I think it's just a more robust approach. It does bump the Rust version requirement up to 1.15, but I think that's OK.. I ran into a macOS issue yesterday halfway through publishing all the crates, so things were out of sync for a while until late last night. I can't quite tell from reading your logs but it's possible that's what's wrong. Could you just try again one more time and see if by chance the problem fixed itself?\nBut if not, we'll dig in further (feel free to join the Slack if you want me to help you troubleshoot)!. Fixed by #189 (and released in neon 0.1.13).. @jedireza What do you think of bumping the Rust version requirement to the more recent 1.15, at least in Windows? With this PR I'm pretty sure it's required; with 1.13 it was hanging, I think because of rust-lang/rust#38811.. Hi there! Neon requires Rust 1.15 to build. The recommended modern way to install Rust is via http://rustup.rs.. Closing for now but please do report back if you still have trouble installing with a newer Rust!. @jedireza Sorry for the delay. Let's merge this and open another issue for the compile_tests failure.. r+. OK, I got my first \"hello world\" working manually. Here's the steps I took to do it, so we can at least reproduce it. This is obviously not what we want the final workflow to be, but I need to study electron-builder and see if that will have a nice compatibility story. (Otherwise we may have to either build a new electron tool, which I'd rather not do, or work on integrating with electron-rebuild. But my current hunch is that electron-builder may work out better.)\nI got this working with Node v7.5.0. I don't think the version of node on the system has to be a perfect match for the version of node bundled with Electron, but I'm not sure how close it has to be.\n\nCreate a simple neon module (I made one that just has a function that returns \"hello neon\") but don't build it.\nCreate a simple electron app, add the neon module as a dependency, and have the app require and use the neon module (I just did document.write(nativeModule.hello())).\nFollow almost the directions from \"Using Native Node Modules\":\n```\n\nElectron's version.\nexport npm_config_target=1.6.2\nThe architecture of Electron, can be ia32 or x64.\nexport npm_config_arch=x64\nexport npm_config_target_arch=x64\nDownload headers for Electron.\nexport npm_config_disturl=https://atom.io/download/electron\nTell node-pre-gyp that we are building for Electron.\nexport npm_config_runtime=electron\nTell node-pre-gyp to build module from source code.\nexport npm_config_build_from_source=true\nEnsure ~/.electron-gyp exists\nmkdir -p ~/.electron-gyp\nInstall all dependencies, and store cache to ~/.electron-gyp.\nnpm config set cache ~/.electron-gyp\n``\n4. Go into the native module's directory and runnpm install.\n5. Run the electron app to test whether it loads the native module without an error.\n. @ffflorian I was using v7.5.0. I _believe_ the reason it does work is that setting the npm environment variables and configuration settings (step 3 above) tells node-gyp to download the C++ headers from electron's web server, and selects the ones that match the electron version. So when node builds the native module withnpm install, that triggers a cargo build; cargo buildsneon-runtime`, which runs node-gyp, which in turn consults the environment variables to know where to download the C++ headers from.. @paulcbetts Thanks, that's helpful to know. I've almost got a first step working that makes building possible at all but doesn't integrate with either. I'll focus more on electron-rebuild, though. I have had a first conversation with @MarshallOfSound, who's happy to work with us to integrate into electron-rebuild.. @jugglingcats I think you have some of the right ideas, but I don't have the complete picture in my head so I can't spell out exactly what needs to be done. I can give you a few thoughts, though:\nUnfortunately, it's not safe for another Rust thread to call JS on its same thread -- we can't allow that, because a) the GC isn't multithreaded and the callback closes over data from the main thread, and b) having multiple threads work on arbitrary shared data violates JS's run-to-completion semantics. (Does your C code do that, btw? It's possible I'm missing something but I'd expect that generally to crash or cause strange unspecified behavior.) The only safe thing to do, AFAIK, would be to let the Rust background thread add events onto the main thread's queue, to be dispatched on the main thread.\nSimilarly, it's not safe to let Call or other data structures like that implement Send or Sync, because again they are pointing to JS data from the main thread.\nWhat I believe we want to do, at least at a hand-wavy level, is bridge between JS's concept of dynamic transferring (and maybe also structured clone) and Rust's ownership. So for example, it should be possible to transfer a typed array to a background Rust thread and then let Rust transfer it back to the callback when it's done doing the work. If we set the types up so that it's a dynamic error to try to send non-transferrable data to the background thread, then we'll be guaranteed to be thread-safe.\nAnother way of thinking about this is that this is kind of like web workers and postMessage, except that we can probably make the API nicer.\nI'd be happy to collaborate with you on this when I have time, btw. Right now I'm trying to get the web site presentable because we're planning on doing some blog posts about using Neon with Electron and how Wire has recently put Neon into production, and I want people to have a good landing experience. After that I have a couple of hacking projects on various parts of Neon that I want to do, but having more powerful ways to do background computation in Rust is a high-priority use case.. @jugglingcats Are you on the slack today? I'd be happy to chat -- I've been looking into this issue lately.. I wholeheartedly agree! I am labeling this bug help wanted because I think coming up with examples for the documentation is a fantastic way that many people could contribute. I will talk to @divmain about creating an organized list of API items so we can create a master checklist and track our progress.. r+. I agree this is something we should eventually support, and I'd welcome experimentation! We can't switch to it overnight, but if NAPI pans out I would absolutely support switching to it when the time is right.. @Qard Nice! It's still marked as experimental and I don't really know how much it's likely to change in practice. It looks like 8.x will become LTS in a few weeks if I'm reading the schedule right, so we could technically switch to that soon. But it's still pretty new so I think it doesn't hurt to give it some time.\nAnyway, none of that precludes us experimenting with this! I don't think it's the best use of my time right now, since we have bigger issues to fix (especially the safety holes, the high level macro syntax, and fleshing out the API) first. But if anyone is interested in working on this I will be happy to discuss it with them and actively mentor them.. I apologize for not seeing this sooner. It would be helpful to get more information about what you're looking for. If you're looking for a way to iterate over the properties of an object, you can use JsObject::get_own_property_names. I'm closing this issue for now but please feel free to reopen if you'd like to ask followup questions!. Here's the tracking issue: rust-lang/rust#40289\nWhen it lands in Rust stable we can use it ASAP.. Fixed in neon-bindings/neon-cli#57. Yeah, my apologies. It's a CLI bug in 0.1.17. I just fixed it today and I'll spin up a new release ASAP.. OK, I published 0.1.18. Try updating and see if it's fixed for you?. @SeanPrashad I'm dreadfully late on this, but if you're still up for it, that would be great!. @SeanPrashad As a hint, all you should need to do is modify the Cargo.toml file. You can learn more from the Cargo documentation at http://doc.crates.io/guide.html :). Definitely not dead! :D I just don't get to devote work time on it so I have to work on it in bits and pieces. I am still looking for ways to be able to get more time to work on it regularly, and hoping also to get some more contributors as we make progress on the features.. @bnoordhuis @jedireza Thank you both so much! I'll make sure to incorporate all your feedback before merging.. Thanks to a bunch of debugging, we should be back in a state where this can build. Should be able to merge soon!\nI'm re-running the CI builds now to see what's left to fix.. AppVeyor is being very suspiciously flakey lately but I'm pretty confident the builds hanging are AppVeyor's fault since we haven't seen them happen at all on multiple machines. And there were no runtime test failures.\nSo once I reran the CI build a few times and got all green I felt confident enough to merge. I'll reach out to AppVeyor to see what's going wrong.. Yes, I'm afraid this is not something you can do; JS values and APIs can only be accessed from the main thread. We are investigating the possibility of more general threading APIs than the task API, so hopefully you'll be able to do more and more things with threads. But it will always be the case that JS operations are only on the main thread.. @IMRaziel This may be too late, but could you share the full test case?. @ctaggart Thanks for that offer! I just tested this on my Windows machine and it's still failing so I don't think it's specific to AppVeyor. We're just dealing with some finicky issues satisfying the linker in Windows with the right incantations. (If you have suggestions about that let me know!) I'm gonna dig into this and see what I can figure out.. OK, as it turns out, it was only failing on my machine because I had made a mistake with my environment. Now it's building fine.\n@ctaggart So this is indeed an AppVeyor mystery. Any help you can offer would be awesome!. @ctaggart I had installed something with chocolatey that I thought was the same as the Windows Build Tools, but it wasn't. So the build was picking up GNU link in the path instead of the Visual Studio linker.. This is fantastic. @hone thank you so much for your persistence. I'm planning to add some comments and clarifications to the build logic, which has definitely gotten intricate enough to be hard to maintain, but that's on me. :). OK, the API that's missing is the ability to get to the current global object -- filed as #249. From there you can pull off the console object and extract the log method. (We should also add conveniences to eliminate some of the tedium of all those steps.). Fixed in #253:\n```rust\npub fn call_console_log(call: Call) -> JsResult {\n    let scope = call.scope;\nlet global = scope.global();\nlet console = global.get(scope, \"console\")?.check::<JsObject>()?;\nlet log = console.get(scope, \"log\")?.check::<JsFunction>()?;\nlet args: Vec<Handle<JsString>> = vec![JsString::new(scope, \"hello world\").unwrap()];\nlog.call(scope, console, args.into_iter())?;\n// ...\n\n}\n```\n. Very nice, thank you :D\nI'm re-running the build (appveyor builds have been finicky lately). Once it's green I'll merge\u2026. @matklad Thanks! I didn't know bors was still active; I thought it had been superseded by homu.. > Too bad git didn't recognize the file renaming in most of this.\n@jedireza I actually should have done this with git mv, you're totally right. I just copy-pasta'ed because I was thinking it was a merge of multiple files, but the original facade modules were basically empty and not interesting from a file history standpoint. I'll try to re-do this patch to preserve more of the history, by starting from the internal modules and moving them. Thanks for the idea!. @jedireza I redid the history with git mv. At the command-line a git diff seemed to preserve the history but for some reason GitHub isn't showing it.. @ffflorian @bennyn Is it OK with you guys if, starting with the next release, Neon requires at least Rust 1.18?\n@hone Are you OK with this?\nI'm going to go ahead and merge this, but I won't publish a release until I know it's not going to break anyone. We can easily revert in the next couple days.. Awesome, thanks!. Doh, good catch, thank you :). Much appreciated!. Thanks, it's great to get this done. I think I'll try to bundle up a couple of minor incompatible changes with this and do a new release with a new minor version (0.2).. Fixed in #251. Thanks, @robbiepitts!. Blocked on a cargo wrapper.. This would basically come along for free with the xargo-like wrapper. (See #242, #243, #244). From @matklad on April 30, 2017 17:53\nSo after erroneous compilation my artifacts.json looks like this:\n{\"active\":null,\"targets\":{}} . From @matklad on April 30, 2017 17:57\nThese two lines are to blame: \nhttps://github.com/neon-bindings/neon-cli/blob/df442e3b5241ee29920203a13b4a33efeb080e6c/src/target.js#L77\nhttps://github.com/neon-bindings/neon-cli/blob/df442e3b5241ee29920203a13b4a33efeb080e6c/src/target.js#L84\nPerhaps we shouldn't remove artifacts if we were able to execute cargo regardless of exit code?\n. From @jchlapinski on July 23, 2017 18:59\n+1 I have exactly the same problem, could someone from neon team comment on how can this be fixed? Regards. This is related to the need for a xargo-like Cargo wrapper RFC (see #244 and #243), but it's also just a bug in the caching logic and should be fixable before even working out an improved workflow.. @matklad Thank you so much for the detective work! Working on fixing this tonight.. This is also related to the need for a xargo-like cargo wrapper RFC. (See #244). This is related to the need for a clearer, xargo-like wrapper for cargo (until cargo has all the hooks necessary so we don't need a wrapper anymore). Needs an RFC!. Ah, I already did this in b5d19aeb2d9e53c47ca2ce9fb4b07c1c628d9152, sorry for bigfooting your PR :-/. @humphd That would be amazing! I'd be happy to help mentor any students who want to help with this, too. (I have so far been having trouble keeping to a regular schedule monitoring these issue threads, but if you ever need my attention, please feel free -- you or your students -- to ping me on slack or twitter to check a thread, I'll make sure to respond as quickly as possible.). @humphd Looks like @MilanLoveless got to this one already in #255, at least partially. Another infrastructure issue we could really use help with is getting #252 over the finish line -- do you think your students might be interested/able to help with that one?. I believe this was fixed by @MilanLoveless in #255 (with a couple follow-up commits from me for Windows)!. @SeanPrashad Yes, exactly :D When you bring the cli/RELEASES.md comments into RELEASES.md, wherever they reference neon issues/PRs, you can eliminate the explicit reference to neon (e.g., \"neon-bindings/neon#214\" can just become \"#214\"), and wherever they reference neon-cli issues/PRs, please make those explicitly reference the old repo (e.g., \"TypeScript upgrade fixes (#62, #65)\" becomes \"TypeScript upgrade fixes (neon-bindings/neon-cli#62, neon-bindings/neon-cli#65)\").\nAlso, would you mind fixing up the markdown so they render as actual links?. @reSHARMA So sorry, @GabrielCastro got to this one first with #253. I'm planning to spend some time tomorrow finding more good tasks for first-time contributors.. Fixed in #253.. Looks good to me \ud83d\ude03 . Thank you for looking into this--I'm afraid #259 invalidates this one so I can't merge, but you helped me understand that the main problem was nexpect being incompatible with Windows. Thank you for the help!. @GabrielCastro Beautiful work! :D. It looks like the Travis failure was a transient npm issue, and our appveyor config is busted right now, so I'm going to merge. (This is definitely not an acceptable state of affairs for the CI--we should get this fixed soon.). This is awesome, and this PR absolutely makes me feel like an animated gif kitteh. \ud83d\ude3b\ud83d\ude3b\ud83d\ude3b\nI'll add a couple minor notes inline.. Looks great! Now we can just finish up the windows commands when we talk on Wednesday and this will be ready to go. =). I realized the reason it was failing to test in Windows was that I was using cargo test instead of cargo test --release. I'll merge this and then afterwards I'll submit a fix that gives you a clearer compiler error if you build with the wrong profile.. I agree this would be nice to have, but as you say I'm not sure if it's possible. We'll try to triage this with labels that might help people who have the relevant skills to be able to help.\nAlso cc'ing @bnoordhuis and @eddyb who might have some ideas?. @jjpe Ugh I'm slapping my forehead right now, I completely forgot there is already the functionality for this. I just did a quick test and I think it's working. Give it a try if you're still interested and see if it works for you.\nAll you have to do is pass -d or --debug to neon build:\n$ neon build --debug. @SeanPrashad This is fantastic, thank you so much! It's really thorough. Just one request: can you also delete the cli/RELEASES.md file as part of this same PR?. Thank you so much for your contribution!!. I really appreciate these kinds of quality improvements. Thank you, Florian!. Amazing work, especially the persistence to fork nexpect. :D. > We may want to move the code to check release vs. debug build arguments and associated constants into /src/lib.rs.\nThat\u2019s a pretty nice idea\u2014we could provide some metadata about the build that would occasionally be useful for introspection, similar to how Node provides this info via process.versions. (This would also have the nice side benefit of eliminating the duplicated logic and extra boilerplate I just added to test/static.). OK, we're finally passing! I'll merge this and then finish the Windows test logic.. @abrodersen Thanks for this contribution! What I'd like to do over time is have new and/or changed APIs go through RFCs, since they affect the overall design. I don't want to throw process at you since you already did this work but it's definitely worth a good discussion.\nIt's up to you if you want to write an RFC or not but would you mind at least fleshing out some of the motivation and rationale (basically the kinds of stuff that goes in an RFC)?. @matklad What would you do when there are multiple such lifetimes? I'm trying to understand the full convention you're proposing.. (If/when we get to a good consensus on a convention then it should be ready to label as beginner friendly.). @matklad I'm still having a little trouble understanding this. Could you maybe write a concrete example?. I agree they should implement Debug although I'm not sure how useful we can make the output -- in particular I'm trying to figure out whether it's dangerous to actually touch the JS VM at all. If we can't, then we'd only be able to say some very generic (and not super useful) information like struct Arguments {}.. @nixpulvis Awesome, I've been looking to reproduce! Can you provide me as much info as possible about your build environment?\n\nOS?\nNode version?\nRust version?\nElectron vs normal Node?\nContents of your native/artifacts.json file?\nIdeally the full contents of the projects, if you're willing/able to share the source\n\nThanks!. @nixpulvis I'll go ahead and close this for now since we haven't been able to reproduce. But please do keep an eye on it and reopen if you see it happen again!. Yep, this isn\u2019t the first time a minor TS upgrade has broken the build. You\u2019re right I should\u2019ve committed the lockfile! I\u2019ll do that today but meanwhile thanks for fixing the new type error with your PR!. Yeah, just rebased and trying again!. I don't know off the top of my head what's going on here but I also use VSCode so I have some personal motivation to fix this too. ;) It'll require some investigation though.. Oh, ha, our Node version matrix includes versions that have npm < 5. So to get across-the-board lockfiles I guess we'd need to either use Yarn or wait until we don't have to support node < 8.. Great catch, thank you!. My bad! I will revert the removal of JsInteger and push it as 0.1.22 and then yank 0.1.21. I should be able to do this late tonight.. Fell asleep while testing! \ud83d\ude1c Working on getting this done this morning.... Published as 0.1.22 and yanked 0.1.21. Please do keep in mind that JsInteger is deprecated and we'll be removing it for 0.2.. @maciejhirsz Restarted the builds and everything passed. Thanks!\nI'm not an expert at Cell vs RefCell -- can you help me understand why this is both equivalent and faster?\nOne tiny style change I'd make is to replace set_style(bool) with activate() and deactivate() since it never seems to actually need a computed boolean and the names read a little more nicely. But I can make this change after merging this PR.\nLast question: I've never used LTO; how do you enable it?. @maciejhirsz Thank you for this PR <3. @tptee is going to see if he can repro on his Windows machine.. @matklad Would you be up for writing this up as an RFC? I think it would help understand the motivation and design better.. Thank you so much for the detailed report and repro help!. Agreed\u2014it should definitely implement Copy.. Hi @kjvalencik -- thanks so much for this fix! We talked on Slack about how the MakeCallback API has recently been deprecated but let's merge this and we can follow up with the newer AsyncResourcve API.. @Luke-Nukem Totally legit request! Right now we're just inferring the target info from the current machine, which means we don't support cross-compilation. I've filed an RFC issue here:\nhttps://github.com/neon-bindings/rfcs/issues/16\nIn the meantime can any of the suggestions above get you unstuck? If not we can try to prioritize getting the CLI options fleshed out and implemented.. @moonheart08 Totally! I think right now applications are one of the best-served use cases for Neon. (But we do have ideas for making libraries more easily deployable too!). This would be awesome!\nI wouldn't worry about hooking it up to the Neon CLI, since it's really for testing the performance of Neon proper, rather than for benchmarking individual Neon projects. Also, neon bench has to deal with the annoying issue that cargo bench isn't a stabilized feature yet (it uses Nightly-only APIs).\nIt's fine if it's just a custom command to start with. Eventually maybe we could set up performance regression tests by putting them in the test/ directory, but it's fine if we crawl before we walk.. Oh I see, sounds good then!. @jgrund Curious, do you mean yarn workspaces or cargo workspaces? I'm guessing yarn?. This is very much top of mind! There's the beginnings of a discussion of using workspaces in the cargo wrapper RFC. I don't think that RFC is 100% nailed yet, but would love your thoughts about it if you have a chance to read it. I will also run through it again and make sure examples like yours are doable.. Labeling as needs RFC because it should be addressed by the cargo wrapper RFC once it's in a shape we all like (i.e., it doesn't need a separate RFC from that).. Ouch! (Yet another reason why it'd be good to get to a point where Neon libs could dynamically load the neon runtime as a DLL, and possibly avoid having to use node-gyp entirely?)\nAnyway yes, I agree @tptee -- the thing to do is to update the docs (including the setup guide). I'll mark this issue as resolved but file an issue specifically for that.. BTW, I believe this is a backwards-compatible change, since Object implements This.. This would also make it possible for callee() to return a JsFunction<T> instead of a JsFunction<JsObject>.. @kjvalencik I've been googling around and haven't found a ton of recent discussions of this removal from the V8 API. In 2015 there was this conversation, but then they seemed like they were backtracking because of Node plugins, so I'm not sure what led them to decide it was OK to remove after all. Looking at the V8 API changes doc just lists it as a removal but without links to any discussion, and the commit just has a one-line mention of why it's helpful for the V8 implementation.\nI wonder if anyone knows of a discussion that led people to believe this was not a commonly-used feature. I'm leaning towards just removing it from Neon since that's what V8 is doing anyway, and it's not supported in N-API.. Thank you for the informative comment, as always!\n\nI doubt it's necessary, though. Node's citgm project has pretty good coverage of native modules and none that I know of broke due the removal of the Callee() method.\n\nYeah, I think we should avoid providing primitives beyond what V8 and N-API provide, so I'm going to propose we just cut callee() for 0.2.. @mhsjlw Thank you so much for getting the ball rolling with this PR! I ended up submitting the separate PR #314, but I wouldn't have gotten there without your contribution here!. I've documented the Release checklist in the wiki.. @TomPridham Thank you for these! This is really good feedback about the kinds of things a JS programmer can get tripped on coming to Neon and Rust for the first time. And I totally agree more examples can be a great way to help newcomers explore basic use cases.\nIf I make a few suggestions, would you be up for making a few edits before we merge?. This is fantastic, thank you so much.. Excellent, thank you!. Thank you!. Looks like something is wrong specifically with Node 6. Gotta go to bed but I'll investigate that next.. Ugh, and now I can't even build it on my mac to investigate, because Node 6 has been left in an uncompilable state on macOS Mojave.. > Ugh, and now I can't even build it on my mac to investigate\nOK but I can still build on Linux. Investigating\u2026. OK I believe this is the issue: https://github.com/DefinitelyTyped/DefinitelyTyped/pull/32897 \u2014 I'm talking with the handlebars maintainers and I'll track their fix as it lands.. I merged #396 to fix the typescript issue, and I'm rebasing and trying again\u2026. @kjvalencik This PR is ready for experimentation! If you have any time and are still interested, it'd be super interesting to see an experiment or two with real code, both for comparing readability and to ensure there aren't noticeable performance issues.. @kjvalencik Thank you! @amilajack did an updated version of this with #379.. @katyo So if I understand correctly, the cdylib approach statically links the Rust std library into the compiled output, right? So this way if you deploy your Neon app on a machine that doesn't have Rust on it, it won't fail at runtime looking for the shared libstd library?\nI think having this as an option makes sense. The big question in my mind is which should be the default. The main tradeoff seems to me to be: transparency vs sharing. The benefit of transparency is that deployment machines don't need to have anything special installed on them. The benefits of sharing are decreased filesystem and memory footprint (especially when there are multiple Neon modules in a single app's dependency graph) and ugpradability (e.g. for security fixes to libstd).\nIn reality, right now I don't think many people are building libraries with Neon, so the question is not urgent. I'd just like to have a good understanding of the tradeoffs for the long term.. Thanks for the explanation, @retep998! @katyo thank you for the PR!. A followup: I talked with Alex Crichton to learn a little more about cdylib. Alex agreed with @retep998's opinion: cdylib is first and foremost the choice you should use whenever building for linking from a non-Rust language.\nAlex also added that he believes that cdylib does static linking by default, and he argued that this is what we want. In particular, related to my claim above:\n\nThe benefit of transparency is that deployment machines don't need to have anything special installed on them. The benefits of sharing are decreased filesystem and memory footprint (especially when there are multiple Neon modules in a single app's dependency graph) and ugpradability (e.g. for security fixes to libstd).\n\nAlex argued that none of the benefits of dynamic linking are actually there for the Rust stdlib, for several reasons:\n\nThere's no distribution mechanism for shipping updated DLLs of the Rust stdlib.\nThe Rust ABI is not stable so you'd have to recompile to work with an upgraded DLL anyway.\nThe size issue is probably not big enough to worry about.\n\nI find this pretty compelling. Just thought I'd note that here for posterity.. Very nice, thanks!. Thanks @jjpe for this PR, and for your patience \ud83d\ude0a. Looks amazing!!. Great catch! I just talked with @amilajack about how to tackle this one. Here are the steps I think should work:\n\n[ ] BuildSettings.current() should detect the Node version (via child_process.spawnSync(\"rustc\", [\"--version\"])\n[ ] add a private node: string | null property to BuildSettings class\n[ ] BuildSettings.construct() should take the Node version as an extra (string | null) parameter\n[ ] BuildSettings.fromJSON() and BuildSettings.toJSON() should also serialize/deserialize the Node version\n[ ] BuildSettings.match() should also compare the .node fields of the two instances\n\n@amilajack This could definitely use some tests, too. The caching logic has been brittle. If that turns out to be too hard, still best to implement this fix first and we can add tests separately, but see what you think you can do!. Thanks @amilajack !. Thanks @katyo !. > I prefer : instead of ,\nAny particular reason why? : reads like a type annotation to me.\n. Can you put \"The Neon Community\" for this one too?\n. I think we should add **/index.node too, so that tests/native/index.node doesn't end up in source control.\n. I think the API is equal(actual, expected):\nhttp://chaijs.com/api/assert/#method_equal\n. its. \"preventing...from being garbage collected\" isn't quite the right way to say it, I think. Maybe something like, \"allowing the Local value to remain rooted longer than the HandleScope where it was initially rooted.\" If you think that's too confusing and nit-picky, though, don't worry about it.. This doesn't state a minimum Rust stable version. We talked in #149 about our Node version policy but not our Rust version policy.\nRust seems stricter about backwards compatibility than Node, so maybe we'll be able to get away with just stating a minimum Rust stable version. I'm sure we can't realistically test on all Rust versions > min, but we should at least state a minimum. We could say something like:\n\nAlthough Neon is only tested on the latest stable Rust, it will likely work on a range of stable versions of Rust. It is known to require at least Rust 1.13.\n\n(I think we should bump our lower bound from 1.7 to 1.13 so that our programming style can rely on ? now.)\nLet's go with the above verbiage for now, unless you think there's more we could do (maybe a small smoke test for the minimum Rust version in our CI so we can at least do a sanity check whether our recommended minimum is still plausible?) and merits another RFC bug.. use an https link. use https://www.rust-lang.org since that's canonical. I'll tweak the comment but separately I've filed #169 to rename neon-sys. Thanks for calling this out.. Good catch. Will fix.. Also filed neon-bindings/neon-cli#46 and committed a fix for the template in the CLI.. D'oh, yeah, I forgot to delete those -- will do!. I think it'd be better to chain these with && instead of ; so that the whole command fails if any of the individual steps fails.. Again I think && would be better.. Another spot for &&. And one last instance where we should use &&. Let's have this function skip out early if the current Rust version isn't on the nightly channel. Here's a plan for how to do it:\n\nAdd rustc_version as a dev dependency to this crate.\nAdd an extern crate rustc_version; to the top level, and I think we need to wrap that with #[cfg(test)] so it's only included when we're testing.\nCheck if version_meta().unwrap().channel is Channel::Nightly, and if not, return early.\n\n(I wish there was a #[cfg(nightly)] attribute but that hasn't happened yet. If it ever does we can simplify this!). (Yeah, this is such an awful foot-gun in Neon 0.1. We're fixing this in 0.2, which will be shipping very soon. In the meantime this is good, and we can update this example and get rid of the comment once it's no longer necessary. That change won't invalidate the rest of this example project, which will still be useful!). This comment is a little confusing: did you mean () to be a stand-in for \"whatever pattern you want to match\"? As is, () is real Rust syntax, and this statement as you've written it would parse properly but cause a type error. That seems like it could trip someone up who's trying to understand the API. Maybe something like let <<put your pattern here>> = JsBoolean::new();? I guess I'm not completely sure what you're trying to get across in this comment?. Nice! This kind of contextual tip is such a great way to teach newcomers as they go along.. try! is kind of \"old-fashioned Rust\" style, since the ? syntax was introduced in Rust 1.13. The more idiomatic way to write these lines would be:\nrust\narray.set(0, JsInteger::new(scope, 1))?;\narray.set(1, JsInteger::new(scope, 2))?;\narray.set(2, JsInteger::new(scope, 3))?;. Again, ? would be better style than try!.. It's not great style to use .unwrap(), and this is unnecessarily taking apart and then reassembling a Result. You can make this line simpler by just writing:\nrust\nfn get_function_sync(call: Call) -> JsResult<JsFunction> {\n    fn func(call: Call) -> JsResult<JsInteger> {\n        Ok(JsInteger::new(call.scope, 5))\n    }\n    JsFunction::new(call.scope, func)\n}. Also here I'd replace try! with ?.. I wouldn't recommend this way of doing a type check, and the Variant type will be going away. I'll show the better style below.... Again, let's not recommend .unwrap(). It's better style and more concise to use ?:\nrust\nlet js_arr_handle = call.arguments.get(call.scope, 0)?;. ~Use ? instead of .unwrap() here too.~\nSorry, actually here what we want to do is use .check() instead of .downcast():\nrust\nlet js_arr = js_arr_handle.check::<JsArray>()?.to_vec(call.scope)?;\nThe difference is that check throws a JavaScript exception, whereas downcast just returns an Option.. Another thought: since this isn't a JS array anymore but a Rust vector of the extracted elements, maybe a better name would be elements or vec instead of js_arr. It might also add clarity to annotate the variable declaration with : Vec<_>.. This is a great use case! Again let's try to avoid Variant and panics. The idiomatic Rust way to do this would be:\nrust\nlet vec_of_numbers: Vec<_> = js_arr.iter().map(|js_value| {\n    let js_number = js_value::check::<JsNumber>()?;\n    Ok(js_number.value())\n}).collect()?;\nDon't freak out if that seemed magical! It might be worth a comment. This is a good Rust idiom to learn but it's definitely a little dauntingly implicit at first. The short version of the story is, you can map with a function that returns a Result type and get a Result<Vec<...>> with nothing more than .map(...).collect(). Rust's iteration protocol is powerful enough to do the right thing.. One more try! to replace with ?. :). Is there a reason to write this comment here, instead of just having that code in the JS file?. Similar to the other example, let's get rid of this function and just use check() below.. rust\nlet js_obj = js_obj_handle.check::<JsObject>()?;. Replace .unwrap() with ?.. rust\nlet prop_js = js_obj.get(call.scope, \"myProp\")?;\nlet prop_text: String = prop_js::check::<JsString>()?.value();. This is another case of unnecessarily taking apart and reassembling a Result. Instead you can just write:\nrust\nJsString::new(call.scope, prop_text.as_str()). One more try! to replace with ?.. Also here, should we drop this comment and just have the JS in the JS source file?. I think so too. Take a look at std::thread::spawn's signature:\nrust\npub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n    F: FnOnce() -> T,\n    F: Send + 'static,\n    T: Send + 'static,\nThe return type of the function is required to be Send + 'static, and that's the analogous type to Output.. I think you're right: since these are arenas they only deallocate all at once, so pop_front will never be used.. You can remove the | null from this definition once you make the change I suggested above.. I think this is not the safest logic: the case where there's no 'nodeVersion' key is when they used a previous version of Neon, in which case we don't know what Node version they were using, so we should leave it null to allow ourselves to cache-bust.. Based on my comment about defaulting below, this field will need to be string | null.. Forgot to mention in the review: the type of this parameter should also by string | null.. It's worth adding a comment in the code here, explaining that it can be null because older versions of Neon didn't have this key. That will help the null case be understandable/maintainable.. I ended up using an arena crate from crates.io. ",
    "eddyb": "Requires the hypothetical IndexAssign/IndexSet (and you also want IndexGet for let x = array[0];).\n. I have done this before (C++11, not Rust) in the now defunct v8-gearbox.\nIt ended up being easier to not mention types explicitly and overload C++ implicit conversions, which isn't really an option for Rust.\nEventually, a decorator (syntax extension) on a Rust function could generate the shim that handles all of the conversions before calling the function, but we can do most of it in macro_rules for now.\n. I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Go rustfmt the original line, my enter key would break if I formatted it by hand.\n. I prefer : instead of , but that's just nitpicking.\n. No particular reason, just that it looks marginally better IMO.\nMaybe module => {...}? At least it has some syntactical sense then.\n. Why usize here?\n. ",
    "bnoordhuis": "\nwhich suggests that maybe their value tagging scheme distinguishes the two?\n\nIsUint32() returns true when the value is either a tagged integer or a boxed double that can be losslessly converted to uint32_t.\nIsInt32() more or less works the same way except that on 64 bits architectures the tagged value always fits in a word (although it can still end up getting boxed so you still have to check the type tag.)\n. @dherman If you have questions, I should be able to answer them.\n. You're probably well aware but you can clear a pending exception with v8::TryCatch::Reset().  If you consistently guard all entry points into the VM, you can keep on using the result-or-failure idiom.  You will have to deal with empty handle return values anyway (i.e., without an associated exception) so result-or-failure is presumably still going to be necessary.\nThe, ah, exception to the rule is the termination exception introduced by v8::Isolate::TerminateExecution().  It can be cancelled again with a call to v8::Isolate::CancelTerminateExecution() (and detected with v8::TryCatch::HasTerminated() and v8::TryCatch::Continue()) but panicking might be more appropriate.\n. @jedireza It's the same issue.  Node v7 no longer prints the warning, it's a hard error now.. > since 6 is supposed to be compatible with 5 and it should (again, in theory) always be safe for someone to upgrade from 5 to 6, right?\nNo.  Node follows semver, a major version bump means there are backwards incompatible changes.\nI'd stick with supported versions: currently 4, 6 and 7.. Correct me if I'm wrong but doesn't env DEBUG=true neon build turn on debug mode?\nIf you also want debug symbols for the node binary itself, you'll have to build it from source with ./configure --debug && make.. Did you recompile your module for electron and nw.js?  They aren't binary-compatible with node.js.\nNor is node.js with itself between major versions, for that matter.. Have you seen https://guides.neon-bindings.com/electron-apps/ ?  I don't know if it's also supposed to work with nw.js but that's where I would start looking.. When you say \"worked perfectly fine\" you mean with a from-scratch project as described in the link I posted?. Aha.  No idea why Windows would be more problematic than others, sorry.. > Can I just use the gnu toolchain to compile the neon project?\nNope, for the reason you mention.  It goes further than node-gyp: node.exe is compiled with cl.exe and cl.exe does name mangling differently than mingw.  clang-cl might work, though.\n\nAny idea on what those link errors are from when using the static lib?\n\nThe first four look like you linked in code intended for POSIX platforms (i.e., non-Windows.)\nThe __ms_vsnprintf thing looks like a mingw issue, see e.g. https://sourceforge.net/p/libusb/mailman/message/34300859/\n\nCan I point neon at a .dll file when compiling instead of a .lib?\n\nNo, although you could perhaps load the DLL and look up symbols dynamically.  Rather less convenient though.. No idea, sorry.. > I wonder if anyone knows of a discussion that led people to believe this was not a commonly-used feature.\nI believe the main motivation is that on some architectures it adds overhead to API calls and is too little-used for that to be a good trade-off.\n(As well, it might not have a meaningful value when the callee is WASM code.  I'm not 100% sure about that, though.)\nI could take a stab at reimplementing it as e.g. v8::StackFrame::GetFunction():args.Callee() is equivalent to this:\nc++\nauto stacktrace = v8::StackTrace::CurrentStackTrace(args.GetIsolate(), 1);\nauto callee = stacktrace->GetFrame(0)->GetFunction();\nI doubt it's necessary, though.  Node's citgm project has pretty good coverage of native modules and none that I know of broke due the removal of the Callee() method.. It's installed with node (technically, npm) so yes.  Depending on a specific node-gyp version is an anti-pattern in most cases.\nI get bug reports from time to time where people complain node-gyp stopped working for them and then it turns out they've pinned it to a five years old release.. Since you have len, I'd pass that in instead of -1.  You might want to pass in NO_NULL_TERMINATION as well.. There is no (stable) pointer though, V8 only lets you copy out the character data.. This should not be necessary.  If the logic is correct, then len == capacity.. > V8 can use also UTF-8 and Latin-1 as internal representations for the string, which would mean that sometimes this will introduce transforms to UCS-2\nThat's true but it can be avoided with the IsOneByte() and ContainsOnlyOneByte() methods.\n\nCan't we instead construct strings in V8 directly from UTF-8 representation that Rust provides?\n\nYes, if I understand you correctly.  V8 has the concept of external strings where the storage for the string lives outside the JS heap.  Node uses them to avoid copying its built-in scripts.\nThey have some overhead involved compared to regular strings though, so it's only worth it for larger strings.  We established empirically that the turning point is around the 1 MB mark.. I suspect (but didn't verify) it's because external strings are modeled as weak references that need special handling by the garbage collector.  Normal strings are simply collected when unreachable, external strings need to have their destructor invoked.. You should enter an Isolate::Scope and Context::Scope here:\nc++\nv8::Isolate::Scope isolate_scope(isolate_);\nv8::HandleScope handle_scope(isolate_);  // Or Nan::HandleScope\nv8::Local<v8::Context> context = v8::Local<v8::Context>::New(isolate_, context_);\nv8::Context::Scope context_scope(context);\n// ...\nStore the context when the task is created because it can change.\nUsing v8::Isolate::GetCurrentContext() in this method is not sound because it's possible no context has been entered or it's a different one from the one that created the task.. If try_catch.HasCaught() is true, there is still an exception pending here and you can't call into the VM.  If you scope the TryCatch in curly braces, it will have been cleared.\nWhether it's a good idea to catch exceptions and continue is up for debate, though.. Not strictly necessary, ~Persistent() does that by default.. FWIW, we use a container_of-like macro for that in libuv and node.js.  Saves one level of pointer indirection.. try/catch no longer deoptimizes in recent versions of V8.  But even if it did, it wouldn't matter because this is C++ code, not JS code - the performance pitfall only applied to JS functions with a try/catch statement.. The destructor also calls Reset().  Not harmful, just redundant.. The static_cast isn't necessary here.. Ditto.. The changes look okay to me and MakeCallback() is the right method to call but apropos those resource leaks, their destructors should clean out the references.\nAre you saying that isn't happening or is there something that is holding onto the Task longer than necessary?. Oh, I think I see the issue now - those v8::Persistent members should have been of type v8::Global or v8::Persistent<T,M> with M::kResetInDestructor = true.  Might be good to check if the code base has more of these issues.. ",
    "DemiMarie": "Alternatively, the Rust functions could have their parameters and return values bounded by a trait.\n. Neon probably needs to put everything in a C++ TryCatch.\n. Yes, that is what I am thinking of.  It would probably require a compiler\nplugin though.\nOn Thu, Apr 21, 2016 at 7:34 PM, Dave Herman notifications@github.com\nwrote:\n\n@drbo https://github.com/drbo I'm still a bit wobbly on my GC/memory\nmanagement skills so let me see if I follow:\n- The handles API makes it possible for the stack to safely hold\n  references to JS objects.\n- The class API (implemented in #58\n  https://github.com/rustbridge/neon/pull/58) makes it possible for JS\n  objects to safely own Rust objects.\n- But we can't currently have JS objects own Rust objects that hold\n  references back to more JS objects.\nSo is that specifically what this would enable? If we could provide a safe\nway to implement the trace hooks for a Rust type, then it would be safe for\na neon class to own Rust objects of that type.\nDo I have that right?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/rustbridge/neon/issues/63#issuecomment-213159493\n. I don't think panicking should be used by the library during normal operation.  Rust programs can be compiled to abort on panic, and panicking is not optimized at all.\n\nBetter to use Result.  When TerminateExecution is called, all calls into the API should fail.  The cost of a single well-predicted branch is negligible.\nRust-side panics should result in calls to TerminateExecution if they escape to Neon.\n. ",
    "SeanPrashad": "Hi @dherman - me again! I'd like to fix up this bug if it's still available. Hi there! I'm a student at Seneca College who's taking an Open Source course taught by David Humphrey and I'd love to take on this bug as one of my first if it's still available!. I'm on it!!!. @humphd @dherman and I spoke briefly about this on Slack last night! I'd love to try and tackle #252 in the near future if that's ok with everyone \ud83d\ude2c. Hi @dherman! I'd like to tackle this bug if it's still unassigned. Would I be combining all of the content from cli/RELEASES.md into RELEASES.md?. Got it! I will take a look at merging the two files and fixing up the markdown to render links and get back to you if I have any questions!. @dherman Deleted cli/RELEASED.md as requested!. I believe this will also close #252!. ",
    "diorahman": "Nice!\n. ",
    "codearoni": "The readme states that Neon only works on OS X at this time.\n. As an Ubuntu user, I would love aforementioned PR. If getting Neon running on Linux is as simple as making the postInstall conditional to the OS, it seems fairly straightforward, but I digress (I'm not an expert on the matter).\n. ",
    "cmdln": "Yes, I know but the IRC channel has been discussing a PR to expand support to Linux.\n. Yep, confirmed it is fixed--thanks @dherman!\n. ",
    "marxo": "+1\n. ",
    "tomjakubowski": "@dherman I tried to grab an automatic invite, but the site returns an \"Application Error\" page. Could you send one to my email address (on my GitHub profile). Thanks!\n. ",
    "nixpulvis": "I love writing guides FWIW, though I'm hesistent to dive into this until:\n\nI know neon a lot more (working on it).\nI feel like the docs I'm writing are going to stick, pending big API changes.\n\nLet me know if there are any areas in specific we should tackle sooner rather than later.. Screenshot is dead, but I think your point is mainly about avoiding \"bad\" colors.. There is an important distinction between safety (in the static sense) and safety in this sense (dynamic). I'm also not sure I completely understand, but returning null on exception seems like the wrong thing to do for JS. I would want to force an error on the JS programmer if I saw one in Rust land.. Is there a use case for unboxed JsFunctions, other than the tiny memory overhead.. I'm personally a fan of one letter lifetimes, though I don't know why. Types in Rust do tend to get rather long from time to time, I'd propose to aim to keep short lifetime names at least.. This may be a more general version of #242.. @dherman well this is embarrassing... I've updated a few system dependencies since I opened this issue, and now I can't reproduce it either!\nFWIW I'm now running:\n\nLinux x86_64 4.13.11-1-ARCH\nnode v8.8.1\nrustc 1.22.0-nightly (4c053db23 2017-10-22)\nI haven't played with Electron yet.\n\nnative/artifacts.json\n{\"active\":\"release\",\"targets\":{\"release\":{\"rustc\":\"rustc 1.22.0-nightly (4c053db23 2017-10-22)\",\"env\":\"npm_config_target\":null,\"npm_config_arch\":null,\"npm_config_target_arch\":null,\"npm_config_disturl\":null,\"npm_config_runtime\":null,\"npm_config_build_from_source\":null,\"npm_config_devdir\":null}}}}\nSorry for not including this info when I opened the issue, because we might have stood a chance then. I really wish I had an OS that let me rewind.. @dherman I think the issue is with successful crates not being cached on a failing build. So until I get the whole thing to compile once I need to recompile every crate.. You might find something useful in this thread. Sorry if I've misunderstood your use case, since it does say \"linker arguments\". https://github.com/rust-lang/rfcs/issues/1766. This might also be worth looking at since it looks like it lets you set CFLAGS directly. https://github.com/alexcrichton/cc-rs. ",
    "jonathanmarvens": "@kjvalencik Can you please clarify what you mean by \u201can async API\u201d?\n. ",
    "kjvalencik": "Maybe I'm missing something (I'm a noob at Rust), but there doesn't appear to be a way to safely accept a callback, grab a libuv thread for execution and stop blocking the event loop.\nhttps://github.com/nodejs/nan#nancallback\nIf it is possible, an example would be excellent! Thanks.\n. I think this is implemented by https://github.com/neon-bindings/neon/pull/214 and can be closed.. It would also be nice to have a specialized version of v8::Buffer that is used to pack / unpack a Box pointer.  Buffer::new allows you to specify a raw pointer and a callback for a destructor.\nThis way we could have way to pass structs back and forth across the boundary. Simple example with explicit bindings:\nhttps://github.com/kjvalencik/hello-rust-js/blob/0c00f116862c3c2d26a5bfcf5101004dfe0b8e8c/src/binding.cc#L16-L19\nhttps://github.com/kjvalencik/hello-rust-js/blob/0c00f116862c3c2d26a5bfcf5101004dfe0b8e8c/src/lib.rs#L29-L31\n. @Qard What is the correct way to get a GC callback to free the external resource on v8::External? v8::Persistent with SetWeak?\nIt also looks like Nan::ObjectWrap might be good for this use case. https://github.com/nodejs/nan/blob/master/doc/object_wrappers.md#nanobjectwrap\n. I think JS data inside a JS wrapped struct could be safe as long as it uses a persistent handle. Persistent handles require an explicit disposer call and update their internal pointer on GC.\nThese are often used when you need to pass a callback function off into something async. \n. @ffflorian Excellent work! Isn't that benchmark a little unfair? If I'm reading correctly, you are comparing an ECMAScripten compilation to pure JS against a native implementation.\nHow does it compare against something that uses native bindings like sodium-native?. @opensourcegeek, it appears that you are running as root. The key log line:\nnpm WARN cannot run in wd neon-sample@0.1.0 neon build (wd=/home/opensourcegeek/projects/neon-sample\nnpm attempts to step down from root as a security measure, but then it doesn't have access to write to that directory. I recommend not running as root and changing the permissions on the directory. If you must run as root you can do npm install --unsafe-perm.\n. As far as I know, wasm only allows passing byte arrays across the boundaries. Neon passes object references in both directions. This is more powerful, but also has increased risk.\nIn my opinion, wasm is tangential to neon. . Parcel makes it really easy to integrate rust wasm with node, but manually doing it isn't too bad.\nBetter distribution for Neon is still an open question. We aren't currently distributing any neon projects as libraries--only as part of an application. We utilize Docker multi-stage builds to eliminate the rust build tooling in the final image.. Take it with a grain of salt, because I haven't actually tested it, but you should be able to build against the Google Cloud nodejs docker image (gcr.io/google-appengine/nodejs). You will likely need ensure that the compiled binary is included in the zip that is submitted and remove the neon build from postinstall in the package.json.. @roderickmonk It's strange that you are having this same issue in linux. I'm able to build successfully in Ubuntu 16.04. Can you post the log?. Looking into this a bit more deeply, it appears that the event loop isn't get kicked properly. For example, you can resolve/reject synchronously, but schedule some empty method to kick and it also resolves the issue.\njs\nreject(err);\n// Kick the event queue\nsetImmediate(() => {});\nhttps://github.com/nodejs/nan/issues/541\nAdding v8::Isolate::GetCurrent()->RunMicrotasks(); to the neon runtime task complete fixed it, but I'm not sure if this is best.. It seems like the callback should be executed with node::MakeCallback.. @dherman Is there anything I can provide to make this easier to merge?\nWe are currently using my fork in production successfully, but it would be nice to switch to upstream.\nCheers!. Would something like this work?\n```Dockerfile\nFROM lambci/lambda:build-nodejs6.10\nRUN curl https://sh.rustup.rs -sSf | sh /dev/stdin -y\nENV PATH=\"$PATH:/root/.cargo/bin\"\n```\n```sh\ndocker build -t lambda-neon-dev .\ndocker run --rm \\\n    -w /src \\\n    -v $(pwd):/src \\\n    -v $(pwd)/node_modules/.cargo/registry:/root/.cargo/registry \\\n  lambda-neon-dev npm install\n```\nI don't use lambda, but I do all of my development in docker and this pattern works well. You can substitute any preferered location for the shared cargo cache. It can even be removed, but keeping it improves build times. . Given the build constraints, in my opinion, it makes more sense to be integrated into an application.\nI think deploying it as a library seamlessly would need resolution on https://github.com/neon-bindings/neon/issues/117.. I don't think this is safe because the data might not actually be a callee. Should this code be removed or at least feature flagged for future removal?. This sounds like it's attempting to use the binary that was built for macOS in Linux. I recommend adding the built stuff from gitignore (e.g., native/target) to your dockerignore file and doing a clean build in the docker build/container. . I've had that same problem. You can set the cargo path and that might help.\nDockerfile\nENV PATH=/usr/local/cargo/bin:$PATH\nIf I get a chance, I'll add a Dockerfile to a sample neon project as an example.\n@dherman Would you be interested in having official neon docker images? I could probably maintain them.. @PSPanesar I uploaded an example Dockerfile. It has some deficiencies that I would recommend fixing for production (e.g., running as root), but should be enough to demonstrate the idea.\nhttps://github.com/kjvalencik/neon-example/commit/ea19def42b83a41e641151b491eade6b4a999896. neon-serde doesn't need to know about the structure. It can use JsValue. JsValue is the catch-all enum that could be any JS type. The same goes for serde. It has a Value enum.\n```rust\n[macro_use]\nextern crate neon;\nextern crate neon_serde;\nextern crate serde_json;\nuse neon::js::error::{JsError, Kind};\nuse neon::js::{JsString, JsValue};\nuse neon::vm::{Call, JsResult};\nfn parse(call: Call) -> JsResult {\n    let scope = call.scope;\n    let s = call.arguments\n        .require(scope, 0)?\n        .check::()?;\nlet o: serde_json::Value = serde_json::from_str(&s.value())\n    .or_else(|err| JsError::throw(Kind::Error, &err.to_string()))?;\n\nlet o = neon_serde::to_value(scope, &o)?;\n\nOk(o)\n\n}\nfn stringify(call: Call) -> JsResult {\n    let scope = call.scope;\n    let o = call.arguments\n        .require(scope, 0)?\n        .check::()?;\nlet o: serde_json::Value = neon_serde::from_value(scope, o)?;\nlet s = serde_json::to_string(&o)\n    .or_else(|err| JsError::throw(Kind::Error, &err.to_string()))?;\n\nJsString::new_or_throw(scope, &s)\n\n}\nregister_module!(m, {\n    m.export(\"parse\", parse)?;\n    m.export(\"stringify\", stringify)?;\nOk(())\n\n});\n```. @TomPridham did you happen to see the dynamic tests? It's a bit dense, but provides examples of most things that you could do. Could it be worthwhile to clean those up with better documentation and a bit more segmentation to act as examples?\nhttps://github.com/neon-bindings/neon/tree/master/test/dynamic. @dherman Updated.. The trick is to include the neon::js::Object trait to provide the get method (neon::object::Object in upcoming 0.2). You may also want to do a bounds check on each loop iteration since a JS getter could modify the object while iterating.\n```rust\nfn array_process(call: Call) -> JsResult {\n    let scope = call.scope;\n    let arr = call.arguments.require(scope, 0)?.check::()?;\nfor i in 0..arr.len() {\n    let item = arr.get(scope, i)?.check::<JsObject>()?;\n    let operator = item.get(scope, \"operator\")?.check::<JsString>()?.value();\n    let value = item.get(scope, \"value\")?.check::<JsString>()?.value();\n\n    match operator.as_str() {\n        \"print\" => {\n            println!(\"{}\", value);\n        },\n        _ => {\n            let msg = format!(\"Unsupported operator: {}\", operator);\n\n            return JsError::throw(Kind::Error, &msg);\n        }\n    }\n}\n\nOk(JsUndefined::new())\n\n}\n```\nThe below commit implements two methods of deserializing the array:\n1. Writing pure neon code to read the objects from the array and then the keys from the objects.\n2. Using neon-serde to deserialize into a Vec of enums (internally tagged with the operator key).\nhttps://github.com/kjvalencik/neon-example/commit/72f2084741651fd897c5134aae753ec22f039872. Thanks for the bump! N-API is part of the roadmap and could probably use an RFC outlining the plan. Here is my understanding of what's currently happening:\n\n0.2 removes features that don't have N-API counterparts.\nRoadmap item to convert existing features to N-API\nDistribution of pre-built modules relies on N-API. toml\nexclude = [\"artifacts.json\", \"index.node\"]. FYI, Node 6 is end of life in April.. @dherman Yes, I can do that. I'll take notes along the way similar to what I did for the v0.2. I do have a decent amount of clean-up I would like to do prior to trying it out (upgrade dependencies, switch to Rust 2018).. Hi! Thanks for sharing your problem. I'll do my best to answer here, but I also recommend joining us in slack (https://rust-bindings-slackin.herokuapp.com/). The group there is very helpful.\n\nCurrently, the only way to wrap a native value in neon is with a class. The examples need improvement, but there are examples of most functionality in the dynamic tests: https://github.com/neon-bindings/neon/blob/master/test/dynamic/native/src/js/classes.rs.\nClasses wrap a rust native type, apply a brand so that it can be dynamically type checked, and tie their lifetime to the JS object that wraps them. You can wrap your sdl objects in a class and expose methods that use them.. Here is a quick example based on the sdl2 crate example:\n```rust\n// lib.rs\n[macro_use]\nextern crate neon;\nextern crate sdl2;\nuse neon::context::Context;\nuse neon::types::{JsNumber, JsUndefined};\nuse sdl2::pixels::Color;\nuse sdl2::render::WindowCanvas;\npub struct Canvas(WindowCanvas);\ndeclare_types! {\n    pub class JsCanvas for Canvas {\n        init(mut cx) {\n            let sdl_context = sdl2::init()\n                .or_else(|err| cx.throw_error(err.to_string()))?;\n        let video_subsystem = sdl_context.video()\n            .or_else(|err| cx.throw_error(err.to_string()))?;\n\n        let window = video_subsystem.window(\"rust-sdl2 demo\", 800, 600)\n            .position_centered()\n            .build()\n            .or_else(|err| cx.throw_error(err.to_string()))?;\n\n        let mut canvas = window.into_canvas().build()\n            .or_else(|err| cx.throw_error(err.to_string()))?;\n\n        canvas.set_draw_color(Color::RGB(0, 255, 255));\n        canvas.clear();\n        canvas.present();\n\n        Ok(Canvas(canvas))\n    }\n\n    method set_draw_color(mut cx) {\n        let r = cx.argument::<JsNumber>(0)?.value() as u8;\n        let g = cx.argument::<JsNumber>(1)?.value() as u8;\n        let b = cx.argument::<JsNumber>(2)?.value() as u8;\n\n        let color = Color::RGB(r, g, b);\n        let mut this = cx.this();\n\n        cx.borrow_mut(&mut this, |mut canvas| canvas.0.set_draw_color(color));\n\n        Ok(JsUndefined::new().upcast())\n    }\n\n    method present(mut cx) {\n        let mut this = cx.this();\n\n        cx.borrow_mut(&mut this, |mut canvas| canvas.0.present());\n\n        Ok(JsUndefined::new().upcast())\n    }\n\n    method clear(mut cx) {\n        let mut this = cx.this();\n\n        cx.borrow_mut(&mut this, |mut canvas| canvas.0.clear());\n\n        Ok(JsUndefined::new().upcast())\n    }\n}\n\n}\nregister_module!(mut cx, {\n    cx.export_class::(\"Canvas\")?;\nOk(())\n\n});\n```\n```js\n// index.js\nvar { Canvas } = require('../native');\nfunction sleep(n) {\n    return new Promise(resolve => setTimeout(resolve, n));\n}\nasync function run() {\n    const canvas = new Canvas();\nfor (let i = 0; i < 1000; i++) {\n    const m = i % 255;\n\n    canvas.set_draw_color(m, 64, 255 - m);\n    canvas.clear();\n    canvas.present();\n\n    await sleep(10);\n}\n\n}\nrun();\n```. It means that the platform isn't being recognized. May need additional entries here:\nhttps://github.com/neon-bindings/neon/blob/master/cli/src/target.ts#L8\n. Hi! Compiling neon statically is not something that would be easy to accomplish because of linking into the various libraries. Also, glibc is notoriously difficult to build against statically because of things like nss. This is why often statically built linux binaries will use alternative libc like muscl.\nSince you are compiling for lambda, can I recommend building in docker? There is a docker image for compiling code to run in lambda that has matching library versions. This is a common problem and not limited to neon development.\nhttps://github.com/neon-bindings/neon/issues/292#issuecomment-370968765\n. Hi, thanks for the report! This looks like an example that hasn't been updated for v0.2. You can find some more up to date examples in the tests. IIRC, there are a couple of tickets for updating the examples.. I have bad news, interesting news and good news.\nThe bad news is this is not directly possible with the current API. There is no way for a rust thread to grab a VM lock. The only way to lock the VM is to initiate it from JS.\nThe interesting news is that there is an RFC and an implementation for this feature (aka, Worker Task)!\nhttps://github.com/neon-bindings/rfcs/pull/15\nhttps://github.com/neon-bindings/neon/pull/303\nThe good news is that you can fake this using channels, providing an async polling interface and a little bit of glue code in JS. I added a quick example to my kitchen sink project. The general idea:\n\nCreate an enum to map events to their data\nCreate a JsClass to hold the event receiver and a shutdown sender. The receiver needs to be reference counted and wrapped for internal mutability since it will be read from another thread. Arc<Mutex<mpsc::Receiver<Event>>>. A mutex is fine since we only expect poll to be called in our loop and we always need a mutable reference anyway (i.e., no lock contention).\nStart a background thread anyway that makes sense. It should accept a shutdown channel and return a channel that sends our event enums\nCreate an async Task for polling the channel. Keep in mind that since we are polling in a loop, this will pretty much permanently take up one of the libuv threads. You may want to adjust UV_THREADPOOL_SIZE accordingly.\nAdd methods to your JsClass for polling and shutting down. A shutdown isn't explicitly necessary since garbage collection will destroy your JsClass and this will close the shutdown channel which can be interpreted as a shutdown command. However, this is helpful since you will likely need it anyway and it better controls when the shutdown occurs.\nSome glue code in JS. Extend the EventEmitter class. Your constructor can create an instance of your JsClass and poll in a loop, receiving the events and emitting them.\n\nhttps://github.com/kjvalencik/neon-example/commit/2ef932d42e2ce6dc7b5e11a013347de360dd134d. It looks like they are. Is this not working for you?\nhttps://github.com/neon-bindings/neon/blob/master/cli/templates/.gitignore.hbs. Ignore my previous comment. I looked at the code and see that each is being run in a separate thread.. Unfortunately, this is not currently possible (https://github.com/neon-bindings/neon/issues/369) since there is no API provided to lock the VM from Rust; it must be initiated by JS. You can work around it by polling (https://github.com/kjvalencik/neon-example/commit/2ef932d42e2ce6dc7b5e11a013347de360dd134d).\nThere are a couple of proposals for implementing this:\n https://github.com/neon-bindings/rfcs/pull/25\n https://github.com/neon-bindings/neon/pull/375\nIf you try the polling approach, keep in mind that this example doesn't include a poll timeout--and it should. If you needed to a create a few instances of this, you would exhaust the libuv threadpool waiting on empty queues.. @ddibiase You can create and schedule a callback from a class method in the same way as a normal function. Example:\nhttps://github.com/kjvalencik/neon-example/blob/2ef932d42e2ce6dc7b5e11a013347de360dd134d/native/src/lib.rs#L252-L261. I don't think it would be too difficult to implement, but getting the API ergonomics might be tough. \nHow to we delineate the three phases? Might be able to implement Task on an FnOnce that captures it's environment.. You nearly have it. You should be able to swap srv.server for srv.start().. I don't think I follow. When you use this.borrow, the returned value is an instance of the wrapped struct. I've annotated the type here. You are reading a property off of it, but you can also call methods on it.\n```rust\n  let this = cx.this();\n  let guard = cx.lock();\n  let srv: CustomServer = this.borrow(&guard);\nsrv.start();\n  println!(\"Started server\");\n  Ok(cx.undefined().upcast())\n```. Are these exposed to native modules? It's not something I've encountered before. Is passing them in as an argument viable?. You can wrap a Rust object with a JS class. Branding a Rust struct for safe unwrapping is the primary intent the class API--maybe something that the documentation should make more clear.\nHere is example of borrowing &[u8] from a Buffer:\nhttps://github.com/neon-bindings/examples/blob/7bf40be0e05925ac51cca57e73424cd5f26dd42f/word-counting/native/src/lib.rs#L70-L79\nHowever, you shouldn't need to do this. Here is an example of a Rust struct being wrapped in a JS Class.\nhttps://github.com/neon-bindings/examples/blob/7b9430a7bb31a970be2e03ac3de201ac1d385301/classes/native/src/lib.rs\nWhat you're doing sounds very similar to something I've used neon for successfully (verifying a signature on a Buffer).. It looks like it's failing to build neon-runtime, but the actual messages are getting suppressed. Could you try cloning this repo and building neon-runtime directly? Unfortunately, I don't have a mac to test.\nsh\ngit clone https://github.com/neon-bindings/neon.git\ncd neon/crates/neon-runtime\ncargo build. It's still the same error, cargo:warning=ar: build/Debug/obj.target/neon/src/neon.o: No such file or directory.\nDoes neon.o exist anywhere else and the path is just wrong?\nsh\nfind -name 'neon.o'. These missing Reset on the Persistent objects were a memory leak of the callback / closure.. I'm not sure their destructors clean-out the references. They are wrapped in in Nan with a destructor added to call this.\nYou can observe the leak by taking a heap dump, calling an async API a bunch, forcing a GC, and then taking another heapdump.. https://github.com/nodejs/nan/blob/b2455ac52e97568456089c5658bbd64a016112b8/nan.h#L1383-L1385\nI'm not 100% confident on context, but I could see all of the callbacks leaking.. Should this be 'static as well? I think it should.. ",
    "Drakulix": "Whats the current Status on this and how would you like to see this implemented?\nThis is the biggest blocker for using Neon for me, so if I can help you with, I am happy to do so.\nIt mostly comes down to, how you would like to see Callback and AsyncWorker to be interfaced by Rust. Especially AsyncWorker is really tricky.\n. ",
    "kamicut": "@dherman Maybe this resource is useful? http://blog.scottfrees.com/c-processing-from-node-js-part-4-asynchronous-addons \n. ",
    "netgusto": "Maybe would it be possible by chaining scopes like this: \nnodejs -> Nan[dispatch-async-stuff] -> neon[process-sync-stuff] ?\n. ",
    "loyd": "What is the current status on this?. ",
    "andruhon": "This one seems to be related https://github.com/dherman/wc-demo/issues/5\n. ",
    "divmain": "Work tracked here:\nhttps://github.com/neon-bindings/rfcs/issues/7\nhttps://github.com/neon-bindings/rfcs/issues/6. https://github.com/neon-bindings/rfcs/issues/7. ",
    "maxjoehnk": "Why not call it MemoryScope (or MemoryContext)? This is explicit and should remove any confusion regarding the js side.. ",
    "dashed": "@davidblewett Are you suggesting neon (this project) to be renamed to something else? Rust (the language) share the same name as the video game: https://en.wikipedia.org/wiki/Rust_(video_game)\nFolks are smart enough to tell the difference.\n. ",
    "Siilwyn": "Just tried out neon, thank you for this awesome project @dherman !\nBumped into the same error, not sure how small the test case should be but just passing through a string and returning it already shows the error, see this.. ",
    "Nercury": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "mmun": "I license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. ",
    "msvbg": "@dherman Of course!\nI license past and future contributions under the dual MIT/Apache-2.0 license, allowing licensees to chose either at their option.\n. Thanks! A+ effort :)\n. Didn't see that you opened an issue for this :) It seemed like an obvious next step so I went ahead and did it in #49 \n. ",
    "chpio": "sorry, im stupid\n. ",
    "vladikoff": "Okay thanks Dave! . ",
    "tmcw": "I'm hitting the same error in the code example as well as my project (source). I checked out neon itself and ran the test suite, and it works properly in this case and tests the array .set method, so potentially this will be fixed if there's a new tagged release?\n. Unfortunately that doesn't seem to work either:\nInput:\nrust\nlet js_object: Handle<JsObject> = JsObject::new(scope);\n    try!(js_object.set(\"number\", JsInteger::new(scope, 9000)));\n    // Ok(obj)\n    Ok(js_object)\nCompiling node v0.1.0 (file:///Users/tmcw/src/rust-polyline/node/native)\nsrc/lib.rs:28:20: 28:23 error: this function takes 3 parameters but 2 parameters were supplied [E0061]\nsrc/lib.rs:28     try!(js_object.set(\"number\", JsInteger::new(scope, 9000)));\n                                 ^~~\nsrc/lib.rs:28:5: 28:64 note: in this expansion of try! (defined in <std macros>)\nsrc/lib.rs:28:20: 28:23 help: run `rustc --explain E0061` to see a detailed explanation\nsrc/lib.rs:28:20: 28:23 note: the following parameter types were expected: &mut bool, neon::sys::raw::Local, neon::sys::raw::Local\n<std macros>:3:1: 3:42 error: mismatched types [E0308]\n<std macros>:3 $ crate :: result :: Result :: Ok ( val ) => val , $ crate :: result :: Result\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/lib.rs:28:5: 28:64 note: in this expansion of try! (defined in <std macros>)\n<std macros>:3:1: 3:42 help: run `rustc --explain E0308` to see a detailed explanation\n<std macros>:3:1: 3:42 note: expected type `bool`\n<std macros>:3:1: 3:42 note:    found type `std::result::Result<_, _>`\n<std macros>:3:52: 4:15 error: mismatched types [E0308]\n<std macros>:3 $ crate :: result :: Result :: Ok ( val ) => val , $ crate :: result :: Result\n                                                                  ^\nsrc/lib.rs:28:5: 28:64 note: in this expansion of try! (defined in <std macros>)\n<std macros>:3:52: 4:15 help: run `rustc --explain E0308` to see a detailed explanation\n<std macros>:3:52: 4:15 note: expected type `bool`\n<std macros>:3:52: 4:15 note:    found type `std::result::Result<_, _>`\nerror: aborting due to 3 previous errors\n. ",
    "jeandudey": "Solution: use neon::js:Object;\n. ",
    "paulsevere": "I was able to get this sample code working using neon v \"0.1.18\" by removing \"use neon::internal::js::{PropertyName};\" and by explicitly importing the \"Object\" trait from neon::js.\n```\n[macro_use]\nextern crate neon;\nuse neon::vm::{Call, JsResult};\nuse neon::js::{Object, JsString, JsArray, JsInteger, JsObject, JsNumber};\nfn make_an_array(call: Call) -> JsResult {\n    let scope = call.scope; // the current scope for rooting handles\n    let array = JsArray::new(scope, 3);\n    try!(array.set(0, JsInteger::new(scope, 9000)));\n    try!(array.set(1, JsObject::new(scope)));\n    try!(array.set(2, JsNumber::new(scope, 3.14159)));\n    Ok(array)\n}\nregister_module!(m, {\n    m.export(\"main\", make_an_array)\n});\n```. ",
    "shepmaster": "Another way to shoot yourself in the foot: if you use neon::js::Key, which also defines the set method. Removing that import cleared up other cases.. Likely duplicate of #57.. ",
    "mfpiccolo": "\ud83d\udc4d \n. @dherman This is obviously not the whole test suite yet but the idea is that we can continue to add to this issue until you feel that we have covered enough for the initial test suite setup.  Then we can mark the first checkbox off to let us know what to aim for.  Then we can start knocking off the tests.\n. Yeah agree that \"complete\" is a bit ambitious.  Thanks for adding to this!\n. Fixed.  I removed index.node with a commit but I can squash and force if you prefer that.\n. Pushed up the neon-sys dep bumps.  I can mess with travis config later on today or tonight if you don't get to it.\n. Fixes #80 \n. This should cover the JsNumber section of #76.  Let me know if there is any other JsNumber specific tests we should have for 76. @dherman \n. \ud83d\udc4d \n. Yes @dherman \ud83c\udf89 \n. Oh I will get that switched up.  \ud83d\udc4d \n. ",
    "vinipsmaker": "Are there plans to let the heap to safely hold references to JS objects (i.e. a a Rust object that \"owns\" a JS object, prevents a JS object from being GCed, v8::Persistent...)? If this is allowed, then the #26 would be a no-brainer and even more patterns could be implemented.\nEDIT: Actually I forgot about the need to use libuv to execute the v8::Function in the proper thread. So Persistent wouldn't be enough =(\n. Closing as a duplicate of https://github.com/rustbridge/neon/issues/26#issuecomment-167654815\n. ",
    "jaredwy": "I\u2019ll nab this one now there\u2019s an rfc. . I won\u2019t be able to start until next week though. (I can\u2019t seem to assign this to my self on the GitHub mobile website) . ",
    "bennyn": "Hey @dherman, thanks for providing Neon! \nAt Wire we see high potential in it. However, we are dependent on the Uint8Array type. Do you have an outlook when it will be possible to map this type between Rust and JavaScript?\n. ",
    "ffflorian": "@dherman \nThank you for the hint. By using the JsBuffer and afterwards converting it to an Uint8Array in JavaScript, we managed to make it work! :tada:\nBy using neon, our benchmark just got 61.5 times faster!\n\n\nHere is a code example with gen_keypair() from  sodiumoxide:\nlib.rs\n```rust\nfn crypto_sign_keypair(call: Call) -> JsResult {\n    let scope = call.scope;\n    let (kp_public, kp_secret) = ed25519::gen_keypair();\nlet mut kp_public_buf = try!(JsBuffer::new(scope, 32));\nutils::buf_copy_from_slice(&kp_public.0, &mut kp_public_buf);\n\nlet mut kp_secret_buf = try!(JsBuffer::new(scope, 64));\nutils::buf_copy_from_slice(&kp_secret.0, &mut kp_secret_buf);\n\nlet js_object: Handle<JsObject> = JsObject::new(scope);\ntry!(js_object.set(\"keyType\", JsString::new(scope, \"ed25519\").unwrap()));\ntry!(js_object.set(\"publicKeyBuffer\", kp_public_buf));\ntry!(js_object.set(\"privateKeyBuffer\", kp_secret_buf));\n\nOk(js_object)\n\n}\n```\nindex.js\n```js\nconst crypto_sign_keypair = () => {\n    const { publicKeyBuffer, privateKeyBuffer, keyType } = sodiumneon.crypto_sign_keypair();\nreturn {\n    publicKey: new Uint8Array(publicKeyBuffer),\n    privateKey: new Uint8Array(privateKeyBuffer),\n    keyType\n};\n\n};\n```. @kjvalencik \n\nHow does it compare against something that uses native bindings like sodium-native?\n\nI don't know, back then in February, sodium-native was not usable for us because of several reasons. And since we wanted to switch from pure JS to a Rust implementation, I simply compared the results after switching.. > I don't think the version of node on the system has to be a perfect match for the version of node bundled with Electron, but I'm not sure how close it has to be.\nWhich version of Electron were you using? Because the ABI versions of the Node.js installation used to compile the module and Electron have to match - so when you build it with Node v7.5.0 (ABI 51) it won't work with Electron 1.6.3 (ABI 53). You will get an error:\n\nThe module [...] was compiled against a different Node.js version using NODE_MODULE_VERSION 51. This version of Node.js requires NODE_MODULE_VERSION 53. Please try re-compiling or re-installing the module.. @gporrata See https://github.com/neon-bindings/neon-cli/pull/57. No problem for us :). Good idea, let me check.. The original message just contains \"spawnSync rustc ENOENT\" so that isn't too helpful. Nevertheless, if another error beside ENOENT appears, it will also be thrown.. \n",
    "DiThi": "@dherman Is there a way to do that from a buffer that was created in JS and passed as argument? At least for reading.. ",
    "winding-lines": "@dherman I finally have some time to play with neon, will check this out :)\n. I just ran into this while exploring callbacks.\nCompiling neotify v0.1.0 ()\nsrc/lib.rs:23:44: 23:50 error: no method named `expect` found for type `std::result::Result<neon::mem::Handle<'_, neon::js::JsValue>, neon::vm::Throw>` in the current scope\nsrc/lib.rs:23         callback.call(scope,  this_, args).expect(\"invoke js callback\");\n                                                         ^~~~~~\nsrc/lib.rs:23:44: 23:50 note: the method `expect` exists but the following trait bounds were not satisfied: `neon::vm::Throw : std::fmt::Debug`\nerror: aborting due to previous error\n. @jedireza I would love to move over the lldb information. I will create a PR :). We should close this PR, thanks!\nMarius\n\nOn Dec 23, 2016, at 9:23 AM, Reza Akhavan notifications@github.com wrote:\nI see the new PR over at neon/www, thanks. Should we close this PR or do you plan on updating updating it for the crate docs?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Great conversation :-) This is definitely a problem for big shops. However the approach to install rust from npm is non starter. We do not have access to the internet from the build machines. I wish npm would have limited itself to install actual node packages instead of trying to take over system level issues. \n. \n",
    "pitaj": "Just a few resources people might find handy if they want to try implementing this:\n\nThe N-API has first-class Promise creation\nThere's already an N-API sys crate, the higher-order crate is a WIP\nHere's an example of using the Promise creation is C++\n\nSome other things to consider:\n- Rust will soon? have first-class Future support, it would be good to provide an API to convert a Rust Future to a JS Promise\n- As said in the example\n\nNode.js will process the fulfillment/conclusion of the Promise in an asynchronous fashion (compared to \"real-time\" in JavaScript) because the fulfillment is added to the event loop's \"Promise fulfillment microtask queue\", which is processed immediately after the \"nextTick microtask queue\", even when it is fulfilled synchronously in C++.\nIf this ever becomes UNTRUE, then you would need to utilize an AsyncWorker (or a similar concept) in order to ensure this Promise is fulfilled asynchronously.\n- Since the N-API is available since Node 8, it is worth considering supporting it for all Node versions >=8, with instead instructing developers to use a callback native API with a Promise on the JS side for versions older than that. Node 6 has less than a year of maintenance support left, after all.\n- If that is not acceptable, then perhaps it is possible to automate doing that instead, or to provide a Promise through older C++ APIs. I'm unaware of nan supporting Promise creation though, so it would require more direct V8 APIs. Great job. Node 10 support will be perfect for me.\n\nYou may want to consider adding Node 10 to the test matrices in appveyor.yml and .travis.yml. Looks like everything's working. Guess you're luckier than you thought :+1: . @dherman any chance of looking at this? It doesn't require an RFC does it?. ",
    "zmanian": "I'm gonna work on figure out why the CI is failing. May take me a few days to find the time.\n. Hmm...I'm having trouble reproducing this locally.\n. ",
    "Programming4life": "Is there any workaround ?\n. ",
    "jsonnull": "Awesome, thanks!\n. ",
    "opensourcegeek": "I've updated rustc version so I thought I'll give neon a go again but I'm still running into issue as below, any ideas?\n```\nprojects]# neon new neon-sample\nThis utility will walk you through creating the neon-sample Neon project.\nIt only covers the most common items, and tries to guess sensible defaults.\nPress ^C at any time to quit.\n? version 0.1.0\n? description \n? node entry point lib/index.js\n? git repository \n? author \n? email \n? license MIT\nWoo-hoo! Your Neon project has been created in: neon-sample\nThe main Node entry point is at: neon-sample/lib/index.js\nThe main Rust entry point is at: neon-sample/native/src/lib.rs\nTo build your project, just run npm install from within the neon-sample directory.\nThen you can test it out with node -e 'require(\"./\")'.\nHappy hacking!\nneon-sample]# npm install\nnpm WARN package.json neon-sample@0.1.0 No description\nnpm WARN package.json neon-sample@0.1.0 No repository field.\nnpm WARN cannot run in wd neon-sample@0.1.0 neon build (wd=/home/opensourcegeek/projects/neon-sample)\nneon-cli@0.1.7 node_modules/neon-cli\n\u251c\u2500\u2500 semver@5.3.0\n\u251c\u2500\u2500 shallow-copy@0.0.1\n\u251c\u2500\u2500 in-publish@2.0.0\n\u251c\u2500\u2500 minimist@1.2.0\n\u251c\u2500\u2500 toml@2.3.0\n\u251c\u2500\u2500 git-config@0.0.7 (iniparser@1.0.5)\n\u251c\u2500\u2500 validate-npm-package-name@2.2.2 (builtins@0.0.7)\n\u251c\u2500\u2500 rsvp@3.2.1\n\u251c\u2500\u2500 chalk@1.1.3 (escape-string-regexp@1.0.5, ansi-styles@2.2.1, supports-color@2.0.0, strip-ansi@3.0.1, has-ansi@2.0.0)\n\u251c\u2500\u2500 validate-npm-package-license@3.0.1 (spdx-correct@1.0.2, spdx-expression-parse@1.0.2)\n\u251c\u2500\u2500 fs-extra@0.26.7 (path-is-absolute@1.0.0, klaw@1.3.0, graceful-fs@4.1.5, jsonfile@2.3.1, rimraf@2.5.4)\n\u251c\u2500\u2500 inquirer@0.11.4 (strip-ansi@3.0.1, ansi-regex@2.0.0, ansi-escapes@1.4.0, rx-lite@3.1.2, through@2.3.8, cli-width@1.1.1, figures@1.7.0, readline2@1.0.1, string-width@1.0.2, cli-cursor@1.0.2, run-async@0.1.0, lodash@3.10.1)\n\u2514\u2500\u2500 handlebars@4.0.5 (async@1.5.2, source-map@0.4.4, optimist@0.6.1, uglify-js@2.7.2)\nneon-sample]# node -e 'require(\"./\")'\nmodule.js:340\n    throw err;\n    ^\nError: Cannot find module '../native'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:289:25)\n    at Module.require (module.js:366:17)\n    at require (module.js:385:17)\n    at Object. (/home/opensourcegeek/projects/neon-sample/lib/index.js:1:75)\n    at Module._compile (module.js:435:26)\n    at Object.Module._extensions..js (module.js:442:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:313:12)\n    at Module.require (module.js:366:17)\n``\n. Any ideas please? \n. Thanks - I just checked and I cannot figure out what is running as root. The only thing I installed as root isnpm install -g neon. After that project was created as normal user and I rannpm install` as normal user as well. \nCould you please tell me if it's OK to install neon globally as root user and then use it as normal user after that? \n. Interesting, I'd have to look more into it. We use GCP already, so curious to see what I could do with cloud functions. Some of the data transformations we do with data takes slightly more than a minute, which runs approx. every minute and there's few hundred thousands of them in a month. It will be interesting to see how much compute time is required when I use Rust, especially if I could cut down cost with Rust it will help it's adoption in other areas at my work. . I haven't checked out what's possible in production GCP functions yet, however trying to run it in emulator (https://github.com/GoogleCloudPlatform/cloud-functions-emulator) works. \nsudo functions call hello \nWarning: You're using Node.js v8.9.3 but Google Cloud Functions only supports v6.11.5.\nExecutionId: f019z600-dzxf-48ea-ad06-6e0734189f1e\nResult: hello node\nI just used neon hello world example, and created a separate index.js at project root and hooked it to lib/index.js that neon creates.\nAlso, the author of this article has got it working on AWS lambda (https://dev.to/kayis/rust-on-aws-lambda-with-neon--cloud9--4el7) too.. ",
    "brodeuralexis": "Same problem on Windows 10 x64, NodeJS 6.3.1 and Rust 1.10.0 (cfcb716cf 2016-07-03).\nHere are the commands I executed :\nbash\nneon new myproject\ncd myproject\nnpm i\nEDIT: Here is the output of npm i :\n```\n$ RUST_BACKTRACE=1 npm i\n\nnath@0.1.0 install C:\\Users\\Consultant\\code\\nath\nneon build\n\nneon info running cargo\nneon info cargo build --release\n   Compiling neon-sys v0.1.11\nerror: failed to run custom build command for neon-sys v0.1.11\nProcess didn't exit successfully: C:\\Users\\Consultant\\code\\nath\\native\\target\\release\\build\\neon-sys-3509514629677365\\build-script-build (exit code: 101)\n--- stderr\nthread '' panicked at 'failed to run \"npm install\" for neon-sys', ../src/libcore\\option.rs:699\nstack backtrace:\n   0:           0x45c7bc - \n   1:           0x45bcd7 - \n   2:           0x421364 - \n   3:           0x45d865 - \n   4:           0x4232a5 - \n   5:           0x45d4cc - \n   6:           0x470bb5 - \n   7:           0x495e84 - \n   8:           0x4025f0 - \n   9:           0x402288 - \n  10:           0x40552e - \n  11:           0x45b49c - \n  12:           0x46bc78 - \n  13:           0x45b294 - \n  14:           0x40556a - \n  15:           0x4013b4 - \n  16:           0x4014e7 - \n  17:     0x7ffe8c108101 - \nneon ERR! cargo build failed\nnpm WARN nath@0.1.0 No repository field.\nnpm ERR! Windows_NT 10.0.10586\nnpm ERR! argv \"C:\\Program Files\\nodejs\\node.exe\" \"C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js\" \"i\"\nnpm ERR! node v6.3.1\nnpm ERR! npm  v3.10.3\nnpm ERR! code ELIFECYCLE\nnpm ERR! nath@0.1.0 install: neon build\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the nath@0.1.0 install script 'neon build'.\nnpm ERR! Make sure you have the latest version of node.js and npm installed.\nnpm ERR! If you do, this is most likely a problem with the nath package,\nnpm ERR! not with npm itself.\nnpm ERR! Tell the author that this fails on your system:\nnpm ERR!     neon build\nnpm ERR! You can get information on how to open an issue for this project with:\nnpm ERR!     npm bugs nath\nnpm ERR! Or if that isn't available, you can get their info via:\nnpm ERR!     npm owner ls nath\nnpm ERR! There is likely additional logging output above.\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     C:\\Users\\Consultant\\code\\nath\\npm-debug.log\n```\n. ",
    "zethra": "Same problem Windows 10 x64 Node 6.6.0 Rust 1.11.0\nOutput of RUST_BACKTRACE=1 npm i\n\n> hello-node@0.1.0 install C:\\Users\\zethra\\Projects\\Personal\\neon-test\\hello-node\n> neon build\nneon info running cargo\nneon info cargo build --release\n   Compiling neon-sys v0.1.11\nerror: failed to run custom build command for `neon-sys v0.1.11`\nprocess didn't exit successfully: `C:\\Users\\zethra\\Projects\\Personal\\neon-test\\hello-node\\native\\target\\release\\build\\neon-sys-3509514629677365\\build-script-build` (exit code: 101)\n--- stderr\nthread 'main' panicked at 'failed to run \"npm install\" for neon-sys', ../src/libcore\\option.rs:699\nstack backtrace:\n   0:     0x7ff78519a58c - std::rt::lang_start::h162055cb2e4b9fe7\n   1:     0x7ff785199b99 - std::rt::lang_start::h162055cb2e4b9fe7\n   2:     0x7ff78518186d - std::panicking::rust_panic_with_hook::hd7b83626099d3416\n   3:     0x7ff78519cbcb - rust_begin_unwind\n   4:     0x7ff785182edf - std::panicking::begin_panic_fmt::h30280d4dd3f149f5\n   5:     0x7ff78519c80c - rust_begin_unwind\n   6:     0x7ff78519ea95 - core::panicking::panic_fmt::h2d3cc8234dde51b4\n   7:     0x7ff7851a0054 - core::option::expect_failed::ha6269a58a5455f37\n   8:     0x7ff785161a85 - __ImageBase\n   9:     0x7ff78519958c - std::rt::lang_start::h162055cb2e4b9fe7\n  10:     0x7ff78519d381 - _rust_maybe_catch_panic\n  11:     0x7ff7851992c4 - std::rt::lang_start::h162055cb2e4b9fe7\n  12:     0x7ff7851a2e60 - __scrt_common_main_seh\n                        at f:\\dd\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl:253\n  13:     0x7fffee5c8363 - BaseThreadInitThunk\nneon ERR! cargo build failed\nnpm WARN hello-node@0.1.0 No repository field.\nnpm ERR! Windows_NT 10.0.14393\nnpm ERR! argv \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\" \"i\"\nnpm ERR! node v6.6.0\nnpm ERR! npm  v3.10.3\nnpm ERR! code ELIFECYCLE\nnpm ERR! hello-node@0.1.0 install: `neon build`\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the hello-node@0.1.0 install script 'neon build'.\nnpm ERR! Make sure you have the latest version of node.js and npm installed.\nnpm ERR! If you do, this is most likely a problem with the hello-node package,\nnpm ERR! not with npm itself.\nnpm ERR! Tell the author that this fails on your system:\nnpm ERR!     neon build\nnpm ERR! You can get information on how to open an issue for this project with:\nnpm ERR!     npm bugs hello-node\nnpm ERR! Or if that isn't available, you can get their info via:\nnpm ERR!     npm owner ls hello-node\nnpm ERR! There is likely additional logging output above.\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     C:\\Users\\zethra\\Projects\\Personal\\neon-test\\hello-node\\npm-debug.log\n\n. ",
    "janispritzkau": "I get the same error on Windows 10. Will this be fixed someday?. ",
    "KenanSulayman": "@winding-lines try!(callback.call(scope,  this_, args)) maybe?\n. Can you also touch the invocation to not pass the environment variable anymore? This will make the NEON_NODE_ABI an optional override.\n. Actually, it seems like I cannot compile the object test at all on nightly: https://github.com/rustbridge/neon/blob/master/tests/native/src/js/objects.rs - here's the logs:\nSeems like the problem was that this import breaks everything: use neon::js::Key. Also, <Handle<JsBuffer>>.set requires use neon::js::Key to be imported... which breaks <Handle<JsObject>>.set. Looks like I can /either/ have buffers OR objects at this moment.\n. Can I somehow craft a custom Uint8Array? Worst case would be a simple array with ints that could be passed to Buffer. (const publicKey = new Buffer(native.publicKey()))\nFor now I'll go with the latter way\n. Wow, that is a simple, yet truly remarkable solution. It worked straightaway.\nIf you happen to be in Berlin, drop me a note and the beers are on me \ud83c\udf7b\n. Besides that, is it possible to pass a scope around? It would allow for much cleaner and DRY code.\n. Thanks!\n. @dherman @brson @Yoric @kjvalencik \nI've come to conclude that the only sensible way forward is WebAssembly. Recent versions of Node support it natively, out of the box.\nSpecifically, as a real-world example, we have two different kind of production systems running on CoreOS and FreeBSD. When we tried shipping neon modules to the FreeBSD systems we were forced to maintain two binary distributions for either platform.\n\nMost functionality that depended on struct inter-op between Node and Neon can be easily replicated with wasm_bindgen:\n```\n[wasm_bindgen]\npub struct Profile {\n    id: u64,\n    tags: Vec\n}\n[wasm_bindgen]\n[no_mangle]\npub extern fn foo () -> Profile {\n    Profile { id: 1u64, tags: Vec::new() }\n}\n```\nWhen foo is called a reference to the struct inside the WebAssembly module is passed to Node-land. It can be freed using .free() from the Javascript side.\n\nBy leveraging the architecture-independent nature of WebAssembly we were able to get back to a single distribution again. Performance over native dropped significantly (10% to 20%), but frankly, our latency critical systems are fully written in Rust anyway.\nI think Neon has a definitive use-case for environments where artefacts are distributed on-premise within self-contained deployments.\nGoing with WebAssembly and providing a solid foundation and toolchain for future \u201cnear native\u201d Node modules that can't be solved with wasm_bindgen alone, or at least not elegantly, is the only way we can get both wide-spread use of Neon (because those wasm modules can be distributed via npm) and Rust, because some developers will want to understand how these modules work and learn Rust on the way.. Here's how Nan fixed it: https://github.com/nodejs/nan/commit/a90951e9ea70fa1b3836af4b925322919159100e.\n. Wouldn't nan::MaybeLocal be more appropriate here?\n. And here, nan::MaybeLocal?\n. ",
    "abrodersen": "Is there any plan to add this? With the addition of the Task API, it would make it possible to write an asynchronous function that constructs a Class and passes it to a callback.. I have created an RFC for this pull request: neon-bindings/rfcs#12. @rebo Thank you for the feedback! I'll look into it today.. @rebo Can you try out the updated code? I think it should fix the issue you identified.. @dherman I've updated this PR with feedback from you and others. Would you consider merging it?. I have created an RFC for this pull request: neon-bindings/rfcs#13. Thanks, the documentation does not make this clear.. ",
    "mrzenioszeniou": "Are you still planning to implement this?\nIs there currently a workaround for this (e.g. could we call the constructor of the JsClass from Rust)?\nThinking about something like this:\n```rust\n        method getAddress(call) {\n            let scope = call.scope;\n            let user_handle = call.arguments.this(scope);\n            let mut user = *user_handle;\n            let address = user.grab(|u| { &u.address });\n        let addressClass: Handle<JsClass<JsAddress>> = JsAddress::class(scope)?;\n        let addressConstructor: Handle<JsFunction<JsAddress>> = addressClass.constructor(scope)?;\n        let constructor = *addressConstructor;\n\n        let args: Vec<Handle<JsNumber>> = vec![];\n        Ok(constructor.call(scope, JsNull::new(), args)?)\n    }\n\n```\n... which fails with the error message\nTypeError: Address constructor called without new.\n\nare we close to solving this?. ",
    "shawedwa": "Sorry - new to Rust. Worked out the macro_internal stuff, so it all works properly now.\n. Oops. Wrong type. Should be i32 to match __NODE_MODULE\n. ",
    "EdShaw": "Helps if I use the right account too. ><\n. Yup:\nhttps://github.com/rustbridge/neon-cli/pull/31\n. Superseded by: https://github.com/rustbridge/neon/pull/123\n. IMO, it's probably better to get rid of the version override - of you want to target a specific version, it's going to be safer to acquire the right headers. As such, happy for this to go in instead of my pr.\nIf there a corresponding change in neon CLI to not set the env var?\n. Not sure if latest electron requires the changes for node compatibility.\nThe node Abi changes \"fixes\" electron by removing the assumption that your building for the node that you're running neon-cli with. . ",
    "Phrohdoh": "Is this a project someone is willing to mentor?. What about this fixes usage with Electron?. Sorry @hunterlester, I have not. I stopped using Neon not too long after opening this ticket.. ",
    "brson": "This has a lot of overlap with needs in the greater Rust community. I'm just going to braindump some stuff real quick.\nPrecompilation\nRust also has a need to deploy binary versions of crates via Cargo to speed up builds. The most recent motivator for this is the creation of a \"Rust Platform metapackage\", which combines multiple commonly-used crates into a single bundle and makes them accessible seamlessly as though they were part of the standard library. To do this we would expect to be able to securely publish precompiled crates to crates.io. It doesn't look like this exact formulation will come to pass in any near-term timeframe, but there are other reasons for cargo to want this. More generally it would just be nice to accelerate builds by having binaries available in the most common configurations. There are a lot of concerns to a workable design, especially regarding security, and no particular movement on this presently, so it's not clear if Neon could leverage anything upstream for doing binary deployment, but this is a good use case to consider, and a potential motivator for at least syncing up on a compatible direction. It may not make sense for Neon to do its own thing here from scratch because it will need to solve approximately the same security problems as Cargo would, but maybe there are existing systems it could leverage (e.g. if node's publishing mechanisms already provide signature validation).\nOne significant problem with publishing binaries is dealing with all the potential hardware configurations users might have: describing that configuration; building that configuration; determining which configuration is compatible for any user's build. These are all pressing issues for Rust too, and there are no complete solutions, but we probably need to align on them. In Rust we care about this because: there are some compile-time options that affect the behavior of the entire crate dag and which libraries are compatible to link to (allocator and unwinder implementation, cpu features); selection of some such features may be incompatible with the available standard library and force it to be recompiled.\nSome links on this topic (that are probably going to be difficult to digest without context):\n- Discussion about how Cargo should think about code-generation options that affect the entire crate-dag. Variations in code-generation affect compatibility with other libraries and with the host architecture.\n- C linkage customization RFC. Not directly applicable but describes in passing how CPU features (-C target-feature) will influence Cargo's notion of a \"target configuration\", and would affect how Neon needs to think of architecture compatibility.\n- std-aware Cargo. Which describes conditions that would cause Cargo to consider std to be incompatible with the requested configuration. Future work involves folding in consideration of aforementioned CPU features, etc.\nFor Neon this may not be a huge concern - you may just settle on maximally-compatible conservative configurations, and punt on the complexities; but considering that Neon is trying to make JS go fast, ultimately it's probably going to want to e.g. turn on the most aggressive CPU features when it can.\nFor binary deployments Neon has concerns that are unique beyond Rust's; most obviously that Neon wants to use these binaries without acquiring the Rust toolchain. In the Rust world this would probably mean supporting binary deployments of \"staticlibs\" or \"cdylibs\" and publishing them to a location and with a security scheme that is easy to manage without cargo.\nWhen looking for synergies with Cargo binary publication and Neon binary publication one also has to consider that Cargo only publishes binaries for crates registered with crates.io. It's not obvious to me that Neon libraries would want to do that, in which case there is less overlap with a Cargo solution, or which may influence a Cargo solution to be more flexible.\nI can't speak to how binary publishing would interact with the node workflow.\nOne binary per architecture\nThe focus of your requirement here is dealing with node/V8 API/ABI compatibility, but as mentioned above do consider that \"architecture\" can mean something like \"base target triple + cpu features + global runtime configuration\".\nIn order to achieve ABI compatibility, as you've mentioned the obvious thing to do is to is create your own compatibility layer. Since the clients of your published binaries are going to need to target this compat layer without the Rust toolchain the obvious thing to do is write that layer in C/C++ and compile that locally, then link the Neon Rust bins to that. Assumes that you can tolerate having a local g++ dependency, but if not you could consider publishing those bins too for all possible versions of node.\nI don't think there are Rust-specific considerations here, except that if you want to publish bins of Neon's compat layer that could influence the joint binary publication design.\nFallback and source compilation\nThe most Robust solution will definitely have fallback where there is no compatible architecture for published binaries, or where the user wants to customize code generation (turning on aggressive CPU features). Because source compilation is the easiest to implement, even though it is least desirable, I'd suggest pursuing it first, and thus supporting fallback naturally when you do get binary deployment.\nThe way to do this is probably to use rustup. You might do some simple detection of whether rustup/rustc already exists on the system, and if not install and configure it, ask permission to do so, etc. You would ideally want to install it to a shared location so that all neon-enabled projects would share it; you might even just say \"you're about to install Rust\", and then install it normally. As far as installation goes it should be just a matter of detecting the appropriate target triple, coming up with the right URL of rust-init, and running it with the desired options.\nOther ideas\nMake Neon always publish asmjs/wasm versions of Neon libraries. The downsides here are that you need to have emscripten installed, and more than that the correct emscripten; the way to automatically get the correct emscripten to pair with Rust is not clear yet. Rust doesn't support this yet but is very close. The Rust story for publishing asmjs/wasm as libraries is also not done, there are some major bugs, etc. asmjs/wasm can't access lots of useful I/O features, at least not yet.\n. ",
    "corbinu": "For precompiling I suggest you take a look at https://github.com/mafintosh/prebuild\nAs for V8 API stability Node core is working on that here: https://github.com/nodejs/abi-stable-node. ",
    "Yoric": "Now that https://github.com/rust-lang/rust/pull/36339 has landed, how hard would it be to build/deploy Neon-based libraries to wasm?. @brson?. So is there a good solution these days?. Oh, realized it's a dup of #117.. ",
    "ernieturner": "FWIW, we ran into this problem with a Rust cryptography library that we built bindings for using Neon. We ended up making a pretty decent workflow where we compile everything via Neon and use node-pre-gyp to both create the tar file with the expected architecture/node version name and as well as auto download the proper binary when consumers run npm install. node-pre-gyp allows a fallback to compile locally if it can't find the supported architecture, but we just ignore that since it's unlikely that the consumer has the Rust build toolchain locally. We hooked all of this up to TravisCI and have it build for different architectures and Node versions on merge and then publish the code to NPM and push the Neon binary artifacts to GitHub releases when we push a tag to the repo. If interested, the repo is here. \nWhile I agree that using WebAssembly within Node certainly makes all of this easier, the performance degradation compared to Neon (at least for us in a cryptography library) made it so it was definitely worthwhile to have a more complicated build/dependency system in place. I can only assume that the performance of WebAssembly in Node will continue to improve, but at least for our use case it seems like it's a long way off from being able to compete with Neon.. ",
    "bgdavidx": "+1\n. nevermind, this was a stupid mistake by me -- forgot to install Python. ignore!. ",
    "maxbrunsfeld": "@bnoordhuis @RReverser Thanks for the review. I'm no longer using this module, so I probably will not get around to landing this PR. I'm cool with closing it out or leaving it open in case anyone else wants this functionality.. ",
    "as-cii": "\nIMO, it's probably better to get rid of the version override - of you want to target a specific version, it's going to be safer to acquire the right headers. As such, happy for this to go in instead of my pr.\n\nAgreed, that's why we decided to remove it in this pull request. The idea is that node-gyp will automatically take care of that and there are a lots of ways to force a build against a specific version of node (i.e. environment variables, command line arguments, etc.).\n\nIf there a corresponding change in neon CLI to not set the env var?\n\nYes, we have submitted another pull request (https://github.com/rustbridge/neon-cli/pull/32) which fixes some Windows problems and takes care of removing the environment variable as well.\n. ",
    "nathansobo": "I'm going to abandon this PR because we've decided not to use Neon for now, but I'll leave it open in case anybody wants to pick it up and push it forward.\n. ",
    "ckee83": "Is this still a problem? I can't find any failing tests on Travis w/ a passing build. I get an error when trying to access builds from December though.. ",
    "hunterlester": "@Phrohdoh Hi Taryn, have you made any progress on this?\nI want to use serde_json with Neon and as you I also need to figure out how to implement From for Throw with something like the following to get around https://doc.rust-lang.org/error-index.html#E0117:\n```\nuse neon::vm::{ Throw };\nuse serde_json::{ Error };\nstruct CustomThrow(Throw);\nimpl From for CustomThrow {\n  fn from(error: Error) -> Self {\n    Self.0\n  }\n}\n. @RReverser The compiler is asking me to impl for Throw:\nerror[E0277]: the trait bound neon::vm::Throw: std::convert::From<serde_json::Error> is not satisfied\n  --> src\\lib.rs:23:25\n   |\n23 |   let app_info: Value = serde_json::from_str(&app_info_string)?;\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait std::convert::From<serde_json::Error> is not implemented for neon::vm::Throw\n   |\n   = note: required by std::convert::From::from\n```. For anyone else finding this thread with the same issue, please know that the solution explained above by @RReverser worked perfectly.\nThis issue can be closed now.. ",
    "RReverser": "Why do you need Throw for that and not JsError?. @hunterlester Ah it's because you're using ? which tries to return serde error as a Throw (if you're inside of method that returns JsResult).\nInstead, I think you can use e.g. JsError::throw in the error part which will return VmResult directly, and then use can use ? on top of it, like:\nserde_json::from_str(&app_info_string).or_else(|e| JsError::throw(...your preferred kind and message...))?\nCan't check if this actually works at the moment, but I think it should.\nSimilarly, you can wrap JsError::throw into the From / Into trait implementation to use ? directly on serde results, but then you will likely need to use .unwrap_err() to unwrap VmResult back into a Throw, which can be later wrapped back into VmResult by ? operator.. @Qard Doesn't prevent from playing it (with using cfg(feature) for conditional compilation on Neon side).. I could try to start implementing this after the next week unless someone wants to do it earlier. . I would definitely not mark this as beginner friendly, looks like it won't be that easy to preserve API compatibility without hacks.. I did look at extending Neon back in the day, but it seemed relying on V8 implementation details too much to have both implementations for V8 and NAPI. Now that NAPI is stable, full rewrite to get away from V8 API should be likely easier. . @eddyb This is so great. Literally few minutes ago had to workaround this via std::sync::{Once, ONCE_INIT}.. @abhi18av That's question to llvm-sys, not really to this repo.\nBut anyway, as llvm-sys documentation says:\n\nThere must be a compatible version of LLVM available. By default llvm-sys will look for llvm-config on PATH to find a system-wide copy of LLVM and use that if it is a compatible version. \n\nSo you need to have LLVM 4.0 (as you are trying to use it) installed on your target machine. Install it via apt-get or brew or other package manager appropriate to your system and things should work.. > Hey, feel free to close the issue :)\nI don't have that power in this repo, was just passing by :)\n\nBut I'd like to source the llvm part from within a second directory, as\nmentioned in the above tree command.\n\nPersonally I wouldn't recommend that unless you want to patch LLVM itself since it can easily take ~10 GB of space and couple of hours to compile it, but if you really don't want to use precompiled binaries, this is also covered in llvm-sys docs (section about specifying path via an environment variable): https://github.com/tari/llvm-sys.rs#llvm-compatibility. No, it is \"rooting\" (the term related to GC).. So to be clear - is this just a documentation change? Because from consumer point of view you can already name lifetimes you pass in as you wish, and 'a is just a very common placeholder for lifetimes in Rust.. Looks like it all comes back from that single error src/cli.ts(258,9): error TS7030: Not all code paths return a value. which seems to relate to return process.exit(1) where, apparently, process.exit(...) returns never so TypeScript doesn't like it in context of async function.\nNot sure why so, but splitting it into process.exit(1); return; seems to help and everything works after that.. I'm suspecting this happens to me now and didn't on CI due to some npm mismatches. @dherman Would it make sense to commit working package-lock.json you have to this repo?. Well you can also use old good shrinkwraps, and new npm should even generate one for you out of the lockfile with npm shrinkwrap.\nAnother option would be also to use ~ instead of ^ for version ranges of often-breaking packages.. Did you try compiling with LTO instead of manually marking each function? Unless I'm missing something, you're basically enforcing LTO manually (inter-crate inlining is the only effect of #[inline] on already small functions), and there is a flag for that which would keep code clean.. @LifeIsStrange LTO is a common name for link-time optimisation, while ThinLTO is just one of implementations.. @maciejhirsz How did it go, by the way?. I'm not an owner on this repo :) . @dherman Difference in performance comes from the fact that Cell doesn't do dynamic checks to ensure that data is not mutably borrowed elsewhere. It can get away with that because it can hold only Copy types, which allows to 1) return a copy of value on .get() and 2) simply put the new value in place on .set() without worrying that previous value might still be dynamically borrowed.. @dherman As for LTO, you can enable it with something like\n```toml\n[profile.release]\nlto = true\n[profile.bench]\nlto = true\n```\nfor corresponding profiles in Cargo.toml.. I think it might be worth to expose slice directly from pointer & length provided by V8 - that way you need only one method instead of two, and can avoid unnecessary allocations if you just need to read the data.. More specifically, I'm talking about using https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html. Ah true. But then, what's the benefit of doings this - it still doesn't guarantee that data is not being transformed on the fly, because, as far as I remember at least, V8 can use also UTF-8 and Latin-1 as internal representations for the string, which would mean that sometimes this will introduce transforms to UCS-2 which weren't done previously.\nCan't we instead construct strings in V8 directly from UTF-8 representation that Rust provides? (and then cases like Latin-1 and UTF-8 -> Rust usually won't require any conversion, just copies). I guess the overhead mostly comes from processing UTF-8 strings against JS API which works on UCS-2 codepoints (this is why V8 uses UTF-8 internally rarely). Using such strings just for storing & console.log-ging should be fine though, even for small strings.\nAlso, we could try and allocate one-byte-kind strings for anything that is latin-1 string on Rust side, in which case it's also just a copy in the worst case with no need for transform, and then there should be no overhead on JS side either.. Maybe better to store and print original message from stderr? (or is it useless?). ",
    "Vurich": "Workaround: use pub class JsBigArchive as BigArchive for ::BigArchive. This macro only takes an ident instead of ty because it desugars to that.. Alternative workaround: use pub class JsBigArchive as BigArchive for BigArchive<i32>. This macro only takes an ident instead of ty because it desugars to that.. A possible solution to this (but not the issues with lifetimes) is to recreate the syntax in the macro. This doesn't work for lifetimes or traits that need parameters, though you can work around that with:\nrust\ntrait Concrete: Generic<Foo> {}\nimpl<T: Generic<Foo>> Concrete for T {}\nThis bumps the problem up to not being able to supply generic paramters to traits, which is slightly better than the existing situation.. Workaround: use pub class JsTestMe as TestMe for TestMe<'static>. There is no way to do this with a generic parameter right now, but you can make it concrete.. I realise that this would fail because it passes the ty to a pattern expecting a ident.. ",
    "jugglingcats": "Just got caught by this one :)\nI now get the following error:\n104 |             let name = try!(vm::Lock::grab(this, |bridge| {\n    |                             ^^^^^^^^^^^^^^ the trait `neon::vm::Lock` is not implemented for `neon::mem::Handle<'_, shm::JsPlcBridge>`. I found the alternative syntax in the tests:\ncall.arguments.this(call.scope).grab(|x| {\n                // do something with x\n            });. I've made a bit of progress with this but am stuck! @dherman perhaps you can help me.\nI've managed to invoke a Rust function using uv_async_send (ie. on the libuv default thread). In this method/context it's safe to get the current isolate scope and invoke the Javascript callback, but I don't really understand how to encapsulate this information from the Neon Call object and make use of it.\nAm struggling both with Rust basics and the idiomatic Neon way this should work. Any advice/pointers gratefully received. I can't even tell if I'm close or not!!\nMy working Rust project (so far) is here:\nhttps://github.com/jugglingcats/neon-uv/tree/iter1\nMy working C++ project (which does invoke the js callback) is here:\nhttps://github.com/jugglingcats/node-uv/tree/iter1\nThe C++ project shows the basic approach to converting a Local to Persistent in v8 in order to preserve between the main addon method and the callback, although I don't claim to understand this fully. We need to do something similar in Rust-land. C++ snippet:\nv8::Local<v8::Function> func = v8::Local<v8::Function>::Cast(args[0]);\n    auto savedFunc = new v8::Persistent<v8::Function>();\n    savedFunc->Reset(isolate, func);\n    handle->data = savedFunc;\nand (in callback):\n```\n    v8::Isolate *isolate = Isolate::GetCurrent();\n    HandleScope scope(isolate);\nv8::Persistent<v8::Function> *func = (v8::Persistent<v8::Function> *) handle->data;\nfunc->Get(isolate)->Call(isolate->GetCurrentContext()->Global(), 0, NULL);\n\n```. I agree... that's what I meant by finding an idiomatic Neon way of doing it. The Neon developer (hopefully) shouldn't concern themselves with local and persistent.\nI wondered if it would be possible to make Call (or it's arguments) Send or Sync. Then they could be passed across the thread boundary. I don't know if this even makes sense as a suggestion though, or how hard it would be!. Hi @dherman, agree mostly with your analysis. The postMessage analogy is not quite correct though IMO, because with postMessage you are limited strictly to transferring data, whereas within a node addon, you can pass a Javascript callback (function) around. You cannot execute the callback in another thread, but you can pass it around and provided you marshall onto the main node (libuv) thread you can call it later.\nThe key to passing the callback (and any other node data) around is converting from Local to Persistent. I think this is to avoid the possibility that node's GC cleans up the data after the initial addon function returns. It keeps it in memory until you're done with it.\nThere are two methods of marshalling onto the main node thread that I'm aware of, with slightly different semantics:\nuv_queue_work\nThis is what you most commonly see used. In this case your request goes to the node thread pool. You pass two native callbacks: one for the work itself, and one that's invoked after the work is complete. The worker function is executed in the background and the 'complete' function is called on the main thread (ie. can call a Javascript callback, if appropriate).\nThis is convenient for ad-hoc long running native tasks because node does the thread pool management.\nuv_async_send\nThis simply queues a native callback. In this case your callback runs some time later in the main node thread. Anything done in the native callback blocks the main thread, but it's good if you have your own background thread and just want to notify out via a Javascript callback. This is my use case. I guess it's a bit like setImmediate in Javascript-land.\nThe C++ example I posted shows the mechanism for uv_async_send, but doesn't actually do any threading. But the structure is correct regarding Local and Persistent handling.\nNow for my bit of hand waving...\nIt seems to me that Rust should have a way to mutate data when sending it across threads. I don't understand the mechanics of this, but something Sync or Send should be able to say \"hey, I see I'm being transferred across thread boundary, I need to do xxxxx\". If this were possible, you could encapsulate the switch from Local to Persistent in this mechanism, perhaps in the Neon Handle code. Then instead of trying to move the whole Call across, you could pick out any parameters like the Javascript callback and transfer that across. Basically anything that's a Handle.\nAppreciate you are busy with other activity. This isn't super-urgent for us: we don't need this feature right away. But am interested to see how it progresses -- I think it could work very sweetly.. Can you elaborate a little? It is the javascript function handle that needs to be kept around, to be invoked later during the async send native callback (on main thread). Apologies, I think this should have been raised on the neon-cli project!. Looks like node version issue... my Pi and Ubuntu both have node 7.x and when I run this on Windows I get the same error.. Hmmm...\npi@alfie-pi-2:~/tmp/neon-test $ node --version\nv6.6.0\npi@alfie-pi-2:~/tmp/neon-test $ neon build\nneon ERR! Cannot read property 'length' of undefined\nI switched node version using nvm. I wonder if neon is always taking node from /usr/bin/node (still version 7.x) rather than from my path.. I downgraded the node apt package using the following commands:\n```\n$ curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -\n$ apt-cache policy nodejs\nnodejs:\n  Installed: 7.5.0-1nodesource1~jessie1\n  Candidate: 7.5.0-1nodesource1~jessie1\n  Version table:\n *** 7.5.0-1nodesource1~jessie1 0\n        100 /var/lib/dpkg/status\n     6.10.3-1nodesource1~jessie1 0\n        500 https://deb.nodesource.com/node_6.x/ jessie/main armhf Packages\n     0.10.29~dfsg-2 0\n        500 http://mirrordirector.raspbian.org/raspbian/ jessie/main armhf Packages\n$ sudo apt-get install nodejs=6.10.3-1nodesource1~jessie1\n```\nNow I have:\npi@alfie-pi-2:~ $ whereis node\nnode: /usr/bin/node /usr/local/bin/node /usr/include/node /home/pi/.nvm/versions/node/v6.6.0/bin/node /usr/share/man/man1/node.1.gz\npi@alfie-pi-2:~ $ /usr/bin/node -v\nv6.10.3\npi@alfie-pi-2:~ $ /usr/local/bin/node -v\nv6.6.0\npi@alfie-pi-2:~ $ /home/pi/.nvm/versions/node/v6.6.0/bin/node -v\nv6.6.0\nAll versions are 6.x but am still getting the same error for neon build :(. It's fixed for me - thanks!. ",
    "JoeyAcc": "Looking at the logs, it seems like LINK : warning LNK4098: defaultlib 'LIBCMT' conflicts with use of other libs; use /NODEFAULTLIB:library is indicative of what goes wrong.\nFrom what I gather from this MSDN page, it seems like LIBCMT refers to a multithreaded version of the C's stdlib (whatever that means).. I just tried that, and that fails too. Here's the log:\n````\njoey@DESKTOP-P4V3PIP MINGW64 ~/WebstormProjects\n$ neon new newfancyneonproject\nThis utility will walk you through creating the newfancyneonproject Neon project.\nIt only covers the most common items, and tries to guess sensible defaults.\nPress ^C at any time to quit.\n? version (0.1.0)\n? version 0.1.0\n? description\n? description\n? node entry point (lib\\index.js)\n? node entry point lib\\index.js\n? git repository\n? git repository\n? author (Joey Ezechiels)\n? author Joey Ezechiels\n? email (joey@acc.nl)\n? email joey@acc.nl\n? license (MIT)\n? license MIT\nWoo-hoo! Your Neon project has been created in: newfancyneonproject\nThe main Node entry point is at: newfancyneonproject\\lib\\index.js\nThe main Rust entry point is at: newfancyneonproject\\native\\src\\lib.rs\nTo build your project, just run npm install from within the newfancyneonproject directory.\nThen you can test it out with node -e 'require(\"./\")'.\nHappy hacking!\njoey@DESKTOP-P4V3PIP MINGW64 ~/WebstormProjects\n$ cd newfancyneonproject/\njoey@DESKTOP-P4V3PIP MINGW64 ~/WebstormProjects/newfancyneonproject (master)\n$ neon build\nneon info running cargo\nneon info cargo build --release --target=x86_64-pc-windows-msvc\nwarning: build.rs files in the same directory as your Cargo.toml will soon be treated as build scripts. Add build = false to your Cargo.toml to prevent this\n    Updating registry https://github.com/rust-lang/crates.io-index\n   Compiling cslice v0.1.1\n   Compiling gcc v0.3.42\n   Compiling neon-sys v0.1.11\nerror: failed to run custom build command for neon-sys v0.1.11\nprocess didn't exit successfully: C:\\Users\\Joey\\WebstormProjects\\newfancyneonproject\\native\\target\\release\\build\\neon-sys-ae9ff40801d54bac\\build-script-build (exit code: 101)\n--- stderr\nthread 'main' panicked at 'failed to run \"npm install\" for neon-sys', C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libcore\\option.rs:715\nstack backtrace:\n   0:     0x7ff78e64aab8 - std::panicking::default_hook::{{closure}}\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:356\n   1:     0x7ff78e649fc4 - std::panicking::default_hook\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:367\n   2:     0x7ff78e64d90d - std::panicking::rust_panic_with_hook\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:555\n   3:     0x7ff78e64d7a8 - std::panicking::begin_panic\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:517\n   4:     0x7ff78e64d6c4 - std::panicking::begin_panic_fmt\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:501\n   5:     0x7ff78e64d659 - std::panicking::rust_begin_panic\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:477\n   6:     0x7ff78e6506d7 - core::panicking::panic_fmt\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libcore\\panicking.rs:69\n   7:     0x7ff78e65076f - core::option::expect_failed\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libcore\\option.rs:715\n   8:     0x7ff78e611b16 - _FILE_LINE\n   9:     0x7ff78e64fe51 - panic_unwind::__rust_maybe_catch_panic\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libpanic_unwind\\lib.rs:98\n  10:     0x7ff78e64defa - std::rt::lang_start\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\rt.rs:51\n  11:     0x7ff78e654528 - __scrt_common_main_seh\n                        at f:\\dd\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl:253\n  12:     0x7ffb26c58363 - BaseThreadInitThunk\nneon ERR! cargo build failed\njoey@DESKTOP-P4V3PIP MINGW64 ~/WebstormProjects/newfancyneonproject (master)\n$\n````\nI then tried npm run-script install, which barf logs too:\n````\njoey@DESKTOP-P4V3PIP MINGW64 ~/WebstormProjects/newfancyneonproject (master)\n$ npm run-script install\nnpm ERR! Windows_NT 10.0.14393\nnpm ERR! argv \"C:\\Program Files\\nodejs\\node.exe\" \"C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js\" \"run-script\" \"install\"\nnpm ERR! node v4.5.0\nnpm ERR! npm  v2.15.9\nnpm ERR! file C:\\Users\\Joey\\WebstormProjects\\newfancyneonproject\\package.json\nnpm ERR! code EJSONPARSE\nnpm ERR! Failed to parse json\nnpm ERR! Unexpected token 'i' at 5:16\nnpm ERR!   \"main\": \"lib\\index.js\",\nnpm ERR!                ^\nnpm ERR! File: C:\\Users\\Joey\\WebstormProjects\\newfancyneonproject\\package.json\nnpm ERR! Failed to parse package.json data.\nnpm ERR! package.json must be actual JSON, not just JavaScript.\nnpm ERR!\nnpm ERR! This is not a bug in npm.\nnpm ERR! Tell the package author to fix their package.json file. JSON.parse\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     C:\\Users\\Joey\\WebstormProjects\\newfancyneonproject\\npm-debug.log\n````\nIf I change lib\\index.js to lib/index.js, I get:\n````\njoey@DESKTOP-P4V3PIP MINGW64 ~/WebstormProjects/newfancyneonproject (master)\n$ npm run-script install\n\nnewfancyneonproject@0.1.0 install C:\\Users\\Joey\\WebstormProjects\\newfancyneonproject\nneon build\n\nneon info running cargo\nneon info cargo build --release --target=x86_64-pc-windows-msvc\nwarning: build.rs files in the same directory as your Cargo.toml will soon be treated as build scripts. Add build = false to your Cargo.toml to prevent this\n   Compiling neon-sys v0.1.11\nerror: failed to run custom build command for neon-sys v0.1.11\nprocess didn't exit successfully: C:\\Users\\Joey\\WebstormProjects\\newfancyneonproject\\native\\target\\release\\build\\neon-sys-ae9ff40801d54bac\\build-script-build (exit code: 101)\n--- stderr\nthread 'main' panicked at 'failed to run \"npm install\" for neon-sys', C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libcore\\option.rs:715\nstack backtrace:\n   0:     0x7ff63236aab8 - std::panicking::default_hook::{{closure}}\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:356\n   1:     0x7ff632369fc4 - std::panicking::default_hook\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:367\n   2:     0x7ff63236d90d - std::panicking::rust_panic_with_hook\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:555\n   3:     0x7ff63236d7a8 - std::panicking::begin_panic\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:517\n   4:     0x7ff63236d6c4 - std::panicking::begin_panic_fmt\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:501\n   5:     0x7ff63236d659 - std::panicking::rust_begin_panic\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\panicking.rs:477\n   6:     0x7ff6323706d7 - core::panicking::panic_fmt\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libcore\\panicking.rs:69\n   7:     0x7ff63237076f - core::option::expect_failed\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libcore\\option.rs:715\n   8:     0x7ff632331b16 - _FILE_LINE\n   9:     0x7ff63236fe51 - panic_unwind::__rust_maybe_catch_panic\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libpanic_unwind\\lib.rs:98\n  10:     0x7ff63236defa - std::rt::lang_start\n                        at C:\\bot\\slave\\nightly-dist-rustc-win-msvc-64\\build\\src\\libstd\\rt.rs:51\n  11:     0x7ff632374528 - __scrt_common_main_seh\n                        at f:\\dd\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl:253\n  12:     0x7ffb26c58363 - BaseThreadInitThunk\nneon ERR! cargo build failed\nnpm ERR! Windows_NT 10.0.14393\nnpm ERR! argv \"C:\\Program Files\\nodejs\\node.exe\" \"C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js\" \"run-script\" \"install\"\nnpm ERR! node v4.5.0\nnpm ERR! npm  v2.15.9\nnpm ERR! code ELIFECYCLE\nnpm ERR! newfancyneonproject@0.1.0 install: neon build\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the newfancyneonproject@0.1.0 install script 'neon build'.\nnpm ERR! This is most likely a problem with the newfancyneonproject package,\nnpm ERR! not with npm itself.\nnpm ERR! Tell the author that this fails on your system:\nnpm ERR!     neon build\nnpm ERR! You can get information on how to open an issue for this project with:\nnpm ERR!     npm bugs newfancyneonproject\nnpm ERR! Or if that isn't available, you can get their info via:\nnpm ERR!\nnpm ERR!     npm owner ls newfancyneonproject\nnpm ERR! There is likely additional logging output above.\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     C:\\Users\\Joey\\WebstormProjects\\newfancyneonproject\\npm-debug.log\n````\nI did discover something else: \nIn <project>/native/Cargo.toml, there's these lines:\n[dev-dependencies]\nneon-build = \"0.1.11\"\nNow, I've changed these lines:\n````\n[dependencies]\nneon = \"0.1.11\"\nneon = { git = \"https://github.com/neon-bindings/neon.git\" }\n````\nHowever, I'm not sure how to change the build dependency to do the same as Cargo doesn't support paths inside of repos. It's perhaps the source of this issue as version mismatches usually don't end well.\nBut how to change it to something workable between now and the next neon release?\nI see one potential solution but that would require changes to the structure of neon, specifically extracting neon-build and any other potential build dependencies to their own repos. But I'm far from sure it would even be worth it, I suppose a new interim release of neon makes more sense.. Awesome! I needed to regenerate my project, but indeed it works now as I can successfully compile, and then load the index.js file into the node REPL. \nThanks a bunch! :). ",
    "whitequark": "Thanks!. ",
    "squiidz": "I just tried the new version with a new project and got this error: \n```\nerror: failed to run custom build command for 'neon-runtime v0.1.12'\nprocess didn't exit successfully: \n/Users/jchaput/dev/rust/nod/native/target/release/build/neon-runtime-ca6fef9d30530229/build-script-build (exit code: 101)\n--- stdout\nSkipping node-gyp installation as part of npm install.\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nHOST = Some(\"x86_64-apple-darwin\")\nAR_x86_64-apple-darwin = None\nAR_x86_64_apple_darwin = None\nHOST_AR = None\nAR = None\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nrunning: \"ar\" \"crs\" \"/Users/jchaput/dev/rust/nod/native/target/release/build/neon-runtime-46530539b89c1ebd/out/libneon.a\" \"build/Release/obj.target/neon/src/neon.o\"\ncargo:warning=ar: build/Release/obj.target/neon/src/neon.o: No such file or directory\nExitStatus(ExitStatus(256))\ncommand did not execute successfully, got: exit code: 1\n``. which node:/usr/local/bin/nodels:/usr/local/bin/node`\nthanks for the quick response btw. yep. yeah no problem !. ``\nerror: failed to run custom build command forneon-runtime v0.1.12 (file:///Users/jchaput/dev/rust/neon/crates/neon-runtime)process didn't exit successfully:/Users/jchaput/dev/rust/neon/crates/neon-runtime/target/debug/build/neon-runtime-bf06a6f3713ebbc7/build-script-build` (exit code: 101)\n--- stdout\nSkipping node-gyp installation as part of npm install.\n/Users/jchaput/dev/rust/neon/crates/neon-runtime\n\u251c\u2500\u2500 bindings@1.2.1\n\u2514\u2500\u2500 nan@2.5.1\n==================\nCONFIGURE:\n==================\nCONFIGURE:\n==================\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nHOST = Some(\"x86_64-apple-darwin\")\nAR_x86_64-apple-darwin = None\nAR_x86_64_apple_darwin = None\nHOST_AR = None\nAR = None\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nrunning: \"ar\" \"crs\" \"/Users/jchaput/dev/rust/neon/crates/neon-runtime/target/debug/build/neon-runtime-ed514f00c83adf93/out/libneon.a\" \"build/Debug/obj.target/neon/src/neon.o\"\ncargo:warning=ar: build/Debug/obj.target/neon/src/neon.o: No such file or directory\nExitStatus(ExitStatus(256))\ncommand did not execute successfully, got: exit code: 1\n. sorry bad output ...\nprocess didn't exit successfully: /Users/jchaput/dev/rust/neon/crates/neon-runtime/target/debug/build/neon-runtime-bf06a6f3713ebbc7/build-script-build (exit code: 101)\n--- stdout\nSkipping node-gyp installation as part of npm install.\n==================\nCONFIGURE:\nmodule.js:472\n    throw err;\n    ^\nError: Cannot find module '/usr/local/Cellar/node/7.5.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js'\n    at Function.Module._resolveFilename (module.js:470:15)\n    at Function.Module._load (module.js:418:25)\n    at Module.runMain (module.js:605:10)\n    at run (bootstrap_node.js:418:7)\n    at startup (bootstrap_node.js:139:9)\n    at bootstrap_node.js:533:3\n==================\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nHOST = Some(\"x86_64-apple-darwin\")\nAR_x86_64-apple-darwin = None\nAR_x86_64_apple_darwin = None\nHOST_AR = None\nAR = None\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nrunning: \"ar\" \"crs\" \"/Users/jchaput/dev/rust/neon/crates/neon-runtime/target/debug/build/neon-runtime-ed514f00c83adf93/out/libneon.a\" \"build/Debug/obj.target/neon/src/neon.o\"\ncargo:warning=ar: build/Debug/obj.target/neon/src/neon.o: No such file or directory\nExitStatus(ExitStatus(256))\ncommand did not execute successfully, got: exit code: 1\n.\nerror: failed to run custom build command for neon-runtime v0.1.12 (file:///Users/jchaput/dev/rust/neon/crates/neon-runtime)\nprocess didn't exit successfully: /Users/jchaput/dev/rust/neon/crates/neon-runtime/target/debug/build/neon-runtime-bf06a6f3713ebbc7/build-script-build (exit code: 101)\n--- stdout\nSkipping node-gyp installation as part of npm install.\n--------------------\nBUILD:\nmodule.js:472\n    throw err;\n    ^\nError: Cannot find module '/usr/local/Cellar/node/7.5.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js'\n    at Function.Module._resolveFilename (module.js:470:15)\n    at Function.Module._load (module.js:418:25)\n    at Module.runMain (module.js:605:10)\n    at run (bootstrap_node.js:418:7)\n    at startup (bootstrap_node.js:139:9)\n    at bootstrap_node.js:533:3\n\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nHOST = Some(\"x86_64-apple-darwin\")\nAR_x86_64-apple-darwin = None\nAR_x86_64_apple_darwin = None\nHOST_AR = None\nAR = None\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nrunning: \"ar\" \"crs\" \"/Users/jchaput/dev/rust/neon/crates/neon-runtime/target/debug/build/neon-runtime-ed514f00c83adf93/out/libneon.a\" \"build/Debug/obj.target/neon/src/neon.o\"\ncargo:warning=ar: build/Debug/obj.target/neon/src/neon.o: No such file or directory\nExitStatus(ExitStatus(256))\ncommand did not execute successfully, got: exit code: 1\n. `ls: /usr/local/Cellar/node/7.5.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js: No such file or directory`. `lrwxr-xr-x  1 jchaput  admin  29  8 Feb 08:50 /usr/local/bin/node -> ../Cellar/node/7.5.0/bin/node`. `drwxr-xr-x  3 jchaput  admin  102 31 Jan 17:19 dtrace`\ndrwxr-xr-x  19 jchaput  admin  646 11 Feb 15:12 angular-cli\ndrwxr-xr-x   9 jchaput  admin  306 18 Dec 14:26 express\ndrwxr-xr-x   3 jchaput  admin  102 18 Dec 14:25 express-cli\ndrwxr-xr-x  14 jchaput  admin  476 17 Feb 13:03 neon-cli\ndrwxr-xr-x  27 jchaput  admin  918  8 Feb 08:50 npm\ndrwxr-xr-x   9 jchaput  admin  306  4 Dec 16:31 oni-plugin-typescript\ndrwxr-xr-x  21 jchaput  admin  714  4 Dec 16:30 oni-vim\n```. let me know if it's work on your side with homebrew. Great, I will try it this weekend ! To me 5s more to build is not a issue. Good job :). Works fine on my system ! \ud83d\udc4d . ",
    "StarpTech": "Hi @dherman I already installed Rust with this installer so Neon is not compatible with the current Rust release?. ",
    "paulcbetts": "Integrating with electron-rebuild is a better choice, it's integrated with the rest of the Electron ecosystem far better, electron-builder is kind of the legacy solution to a lot of these problems. Just so I don't lose it, I did some research on what we need to fix inside electron-rebuild:\n\nelectron-rebuild uses node-gyp rebuild instead of npm rebuild\nelectron-rebuild explicitly looks for binding.gyp when it prob shouldn't\nelectron-rebuild looks for the build result in build/Release when neon puts it in native. \n",
    "AlexAltea": "Not sure about the second issue, but the first one can be solved by running:\nrustup target add i686-pc-windows-msvc. ",
    "king6cong": "Any updates? @jugglingcats @dherman continuous calls into a javascript function from Rust is a feature I looking forward to for a long time :). ",
    "pietrovismara": "Can confirm, i resorted to search on github for examples, something like neon JsArray language:Rust if you're interested in JsArray. Unfortunately not all use cases i would need are covered in this way.\nAs an example, i still have no idea what is the purpose of a JsValue and how to convert it to something else.. Issue solved, but i would like to notice that i already imported Object.\nThese were my original imports:\n```rust\nuse neon::vm::{Call, JsResult};\nuse neon::mem::Handle;\nuse neon::js::{JsInteger, JsNumber, JsString, JsObject, JsArray, JsValue, Object, Key};\nuse neon::js::error::{JsError, Kind};\n```\nSomehow changing them to the following fixed the issue: \nrust\nuse neon::vm::{Call, JsResult};\nuse neon::mem::Handle;\nuse neon::js::{Object, JsArray, JsInteger, JsObject, JsNumber};\n. ",
    "Awk34": "It was released with Node 8.0.0 yesterday :D \nhttps://nodejs.org/en/docs/guides/publishing-napi-modules/. ",
    "muditsaurabh": "@RReverser Any update on this issue. . Any update?. Please refer to https://dev.to/kayis/rust-on-aws-lambda-with-neon--cloud9--4el7. ",
    "fluxxu": "For reference:\nhttps://github.com/atom/xray/tree/master/napi. ",
    "devsnek": "napi is considered stable at this point: https://github.com/nodejs/node/commit/cd7d7b15c1eeccfe2facdf9a671034d93b6bf467. any word on this?. ",
    "amilajack": "There are plans for this but it will likely be a while support for it gets added. The main focus as of now is to improve the existing API and DX. @dherman should this be closed?. Examples for neon have been congregated into the amilajack/neon-examples. I am working with @dherman on moving those examples to the @neon-bindings org. Now that we have a place for examples this PR should be closed. Please PR the neon-examples repo if you have any examples you would like to add. I've documented this here. \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 Awesome work Dave!. There's no work being done on this just yet. I do, however, have an example that tests my neon binary. Also all the examples in neon-bindings/examples are tested as well. But I think it would make sense to add native support for this to neon-cli at some point. This PR should be closed. New examples have been added here and are linked to from the new docs in the header. @blaazetech Please follow the new guide here. This should be closed. I'm working with Dave on some new docs. Would recommend taking a look. Update: the docs have been moved to the neon-bindings org. See https://github.com/neon-bindings/neon/issues/374#issuecomment-443334344. @manuel2258 should this be closed?. Ahh this was my mistake. I'm working with @dherman to move both of these to the org. We're expecting to get these integrated this week. Update: We just migrated the examples and site to the org:\nThe new site can now be visited at https://neon-bindings.com\n Examples\n Website Source. @PSeitz thanks for reporting that. I'll look into it. Fixed:\n* New API Docs Here: neon-bindings.com/api/neon. @geovie sorry for the delay on this. We'll review this soon. There isn't a way to do this just yet. For the time being you can return a string like we are doing in the fibonacci example. There is a way to do this in neon. You can construct those objects in neon. I can't provide any examples just yet because I haven't done this myself yet. I will look into this soon. What you can do is access the object from the global property with cx.global and then get the BigInt property.\nhttps://neon-bindings.com/api/neon/context/trait.context#method.global. What is the size of the entire swc library compiled? This will make it easy to compare.. I saw https://github.com/swc-project/swc/pull/116, suggesting the issue wasn't related to Neon. If this is true, I think this should be closed. Good catch. I'll start working on a fix for this. @kjvalencik how feasible do you think it would to implement async class methods for Neon? e.g.\nrust\nasync method some_async_method() {\n // ...\n}. Considering that 4.0.1 is a pretty recent major server of electron, it is likely that this might be an electron issue.. Does the example work for you?. ",
    "softprops": "+1. Any motion on this front?. Cargo tooling expects executable examples to live in an directory called examples http://doc.crates.io/guide.html#project-layout. https://github.com/GabrielCastro/neon-serde may be of interest to you. ",
    "tarcieri": "I don't suppose anyone has gotten this to work with or without Neo? This is about all I can find in regard to Rust + Cloud Functions\nhttps://github.com/Byron/google-apis-rs/tree/master/gen/cloudfunctions1\nI guess the next question:\n\nWe don\u2019t assume anything proprietary all the way down to the operating system, which means your functions will just work\u2014including native libraries you bring to the platform.\n\nWhat kinds of native libraries can you \"bring to the platform\"? There's not a whole lot of information here:\nhttps://cloud.google.com/functions/docs/deploying/\nhttps://cloud.google.com/functions/docs/deploying/filesystem\nThere are options for \"ZIP upload\" and \"ZIP from Cloud Storage\" so it seems at least you can provide a package containing several files.\nThe first link says:\n\nWhen deploying, Cloud Functions will look for a file named index.js or function.js. If you've provided a package.json file that contains a \"main\" entry, then Cloud Functions will look for the specified file instead.\n\nSo if nothing else it seems to support package.json files. Would it make sense to do something like create an npm module containing rustup that installs cargo?. ",
    "neoeinstein": "FYI, I have an interest in playing around with this, so I'm going to take some time and see if I can get this working.. ",
    "kanekv": "I've tried to compile a native module and run it on google cloud functions - and I'm getting this error:\nDetailed stack trace: Error: /user_code/index.node: undefined symbol: _ZdlPvm\n@neoeinstein did you manage to get around it?. It seems it here: https://github.com/neon-bindings/neon/blob/master/crates/neon-runtime/package.json#L10\nnan should be in dependencies section instead of devDependencies, after I move it there - it compiles.. ",
    "passcod": "Looks like neon-cli 0.1.17 is broken. 0.1.15 works.. ",
    "Hammster": "I would not say so, this project may not be frequently updated in within weeks but since the maintainers, GH profile has been inactive for 3 weeks now I would assume he's on vacation ;). @mitchhentges the versions for the current electron-quickstart should be the follwing, since you use node 11.9.0 could you try to use node 10.11.0 when building instead.\n|     |     |\n| --- | --- |\n| Electron | 4.0.4 |\n| Node | 10.11.0 |\n| Chromium | 69.0.3497.106 |\n. @mitchhentges electron comes with a chromium to render the content, no worries. I don't have the time to test the issue currently (currently moving into a new flat) if i find some time at work i will try it though.\n. ",
    "crazyfrozenpenguin": "Thanks! I'm new to Rust and to Neon. Even with my little knowledge of the language and Neon I was already able to develop a mini RSA ciphering tool. Quite happy with the results so far. Hence, the reason for being concerned about this project being defunct. Glad it is not because using Neon was a breeze of fresh air when compared to direct use of node-ffi. Thanks for all your hard work. Cheers. Thanks for the answer. I did notice #214 before but since it was not yet available, I decided to try something using Tokio crate.\nThe async callbacks are required as a conduit to resolve a JavaScript side promise:\njavascript\nfunction encryptAsync(decrypted, rsaKey) {\n  return new Promise((resolve, reject) => {\n    addon.encryptAndNotify(decrypted, rsaKey, (result) => resolve(cloneString(result)) );\n  })\n}. ",
    "GabrielCastro": "I've been working on this https://github.com/GabrielCastro/neon-serde , It's got most of the uses cases covered, but is lacking in documentation. @matklad Thanks for the feed back, I've made a couple issues from your comments. Please feel free to comment there . I suspect that it might have to do with the fact the these are out of sync\nhttps://github.com/neon-bindings/neon/blob/d6e58aeb6b213a1878306da11aaba3d77b2246c1/crates/neon-runtime/src/neon.h#L14-L25\nhttps://github.com/neon-bindings/neon/blob/d6e58aeb6b213a1878306da11aaba3d77b2246c1/crates/neon-runtime/src/tag.rs#L8-L18\n. ",
    "matklad": "Thanks a lot, @GabrielCastro! I've used it in my project and it worked great!\nHere's some feedback:\n1) Actually, I find the example in Readme the most helpful, so the docs are great to me \ud83d\udc4d \n2) Looks like it is in theory possible to eliminate some boilerplate from argument parsing, so that instead of doing call.arguments.require(scope, 0)?.check::<JsInteger>(), one can use something like \nlet (foo, bar, baz): (i32, String, MyType) = call.arguments.deserialize()?\n3) to_value function is constrained only to the RootScope, and not T: Scope, so it's impossible to use it, for example, inside Task's complete method.. >I'm re-running the build (appveyor builds have been finicky lately). Once it's green I'll merge\u2026\nBtw, https://bors.tech/ works really great for managing PRs and CI :) . >I didn't know bors was still active; I thought it had been superseded by homu.\nbors.tech is a completely new implementation of bors as a github integration, so it's trivial to setup.\nIt's not used by Rust and Servo, they are still on homu.. A workaround for this issue is to setup sccache: http://doc.crates.io/guide.html#build-cache. To make it clear, I would love to see Call<'j>, RootScope<'j>, Handle<'j, JsValue> :) . Yep! Just code style and documentation: while consumers can use whatever lifetime they choose, it's a high chance they'll use whatever neon itself uses. \nA good example of what I have in mind is how serde consistently uses 'de for lifetime of data to be deserialized. \nContext: i was fixing some lifetime-related problems in serde-neon (https://github.com/GabrielCastro/neon-serde/pull/7), and seeing &'a Scope<'b> and Handle<'b, JsValue> everywhere didn't helped me much :) . >What would you do when there are multiple such lifetimes? I'm trying to understand the full convention you're proposing.\nHm, and are there use-cases for user-facing code when there are several different Scope lifetimes in scope? I would probably go with j1 and j2 for unrelated lifetimes, and j1 and j: j1 for nested lifetimes. . I've tried to dig into \"multiple lifetimes\" use case and I can say that now it's not obvious to me which convention is the best :) \nA good example is ToJsString imls: https://github.com/matklad/neon/commit/7ce9dfcb61152201d71cb8bbe1759488f592e83d#diff-9b4b0129f7401327b05224aec23f343bL354\n```Rust\nimpl<'j2> ToJsString for Handle<'j2, JsString> {\n    fn to_js_string<'j1, T: Scope<'j1>>(&self, _: &mut T) -> Handle<'j1, JsString> {\n        Handle::new_internal(JsString::from_raw(self.to_raw()))\n    }\n}\nimpl<'a> ToJsString for &'a str {\n    fn to_js_string<'j, T: Scope<'j>>(&self, scope: &mut T) -> Handle<'j, JsString> {\n        match JsString::new_internal(scope.isolate(), self) {\n            Some(s) => s,\n            None => JsString::new_internal(scope.isolate(), \"\").unwrap()\n        }\n    }\n}\n```\nHere we see js which mean that there's some v8 scope behind the scene, and a which means just some lifetime of an usual rust reference, not tied to v8 at all.\nBut I don't quite understand how to deal with NestedScope and ChainedScope :) . https://github.com/neon-bindings/neon/pull/273 should fix CI failures I think.. Hm, can JsNumer handle usize? It's an f64, right? The safe solution along this lines would be to have a global HashMap<u32, T> registry of T values on Rust side. However, it also will leak memory and I really want to avoid it, because my types hold onto a lot of stuff. In theory, it's possible to add some acquire/release protocol on JavaScript side, but, at this point, just hacking it via declare_types is simpler :) . @softprops I already do use neon-sreder, however I am interested in round-tripping a Rust struct as is, without serialization, which is not applicable in my particular case. . I am unlikely to write an RFC, but this thing from NAPi is exactly what I need: \nhttps://nodejs.org/api/n-api.html#n_api_napi_create_external. Ping @dherman , I don\u2019t have push access :). Vec should be enough here I think?. ",
    "maciejhirsz": "Just stumbled upon this.\nI think in principle it should be possible for neon to implement a function wrapper with generic implementations for:\nrust\nfn<R>() -> R\nfn<A, R>(A) -> R\nfn<A, B, R>(A, B) -> R\nfn<A, B, C, R>(A, B, C) -> R\n...\nfn<A, B, C, D, E, F, G, H, R>(A, B, C, D, E, F, G, H) -> R\nWith generics being:\nrust\nwhere\n    A: Deserialize,\n    B: Deserialize,\n    C: Deserialize,\n    D: Deserialize,\n    E: Deserialize,\n    F: Deserialize,\n    G: Deserialize,\n    H: Deserialize,\n    R: Serialize,\nWith that in place the end user can just write a fn foo(String, i32) -> String or anything really, without writing any JsValue glue code by hand. With some inlining and ingenuity I don't see why this couldn't also be completely zero cost.. Turns out doing it with traits as I intended wasn't possible (at least not without some nightly features to create a 0-type structs that implement Fn and then pass those as a generic parameter...). Macros do, however, and it looks pretty clean: https://github.com/GabrielCastro/neon-serde/pull/11. @RReverser I wasn't even aware that's a thing (you learn every day, eh), will give it a shot and report back.. @RReverser sorry for leaving this hanging. I did some quick tests but it wasn't super conclusive so I left it on the backburner and got swarmed with other things. IIRC the inlining did have some effect, but there wasn't much to it. I'm on holidays soon, but I'm not sure if I'll have time to pick this up.\nI'll rebase my PR to include only this change:\n\nThere was a RefCell<bool> in scope.rs that I swapped for Cell<bool>.\n\nEdit: fixed, also changed the PR title.. @RReverser can you restarted the failed CI? I don't really see how it could have been affected by this PR.. @dherman ^ :). You could use Box::into_raw, then cast that to usize and return it as JsNumber, then once you get the number back you cast it back to *mut T or *const T and make it a regular reference with &*. This will obviously leak unless at some point in the future you re-create the Box and drop it, but then you also must be sure that JS does not have any references to it left or you can cause use after free.. You have 52 bits of precision on f64, so unless your hardware has more than 4.5 petabytes of RAM you should be fine. Alternatively you can make it a pair of two 32bit integers.\nAlso, instead of hashmap you could just store your stuff on Vec<T> and return the index :p.. ",
    "kokokele": "me too\u3002\n`neon-demo neon build\nneon ERR! Cannot read property 'toString' of null\nTypeError: Cannot read property 'toString' of null\n    at Function.BuildSettings.current (/usr/local/lib/node_modules/neon-cli/dist/neon-cli/build-settings.js:29:13)\n    at Project. (/usr/local/lib/node_modules/neon-cli/dist/neon-cli/project.js:59:61)\n    at step (/usr/local/lib/node_modules/neon-cli/dist/neon-cli/project.js:32:23)\n    at Object.next (/usr/local/lib/node_modules/neon-cli/dist/neon-cli/project.js:13:53)\n    at /usr/local/lib/node_modules/neon-cli/dist/neon-cli/project.js:7:71\n    at __awaiter (/usr/local/lib/node_modules/neon-cli/dist/neon-cli/project.js:3:12)\n    at Project.build (/usr/local/lib/node_modules/neon-cli/dist/neon-cli/project.js:53:16)\n    at Object. (/usr/local/lib/node_modules/neon-cli/dist/neon-cli/ops/neon_build.js:46:50)\n    at step (/usr/local/lib/node_modules/neon-cli/dist/neon-cli/ops/neon_build.js:32:23)\n    at Object.next (/usr/local/lib/node_modules/neon-cli/dist/neon-cli/ops/neon_build.js:13:53)`. ",
    "abhi18av": "Oh, I see. Hey, feel free to close the issue :)\nBut I'd like to source the llvm part from within a second directory, as\nmentioned in the above tree command.\nHow to pass that location to the npm build script?\nI'd like to find  solution and utomate the process for further experiments.\nOn Jul 7, 2017 5:39 PM, \"Ingvar Stepanyan\" notifications@github.com wrote:\n\n@abhi18av https://github.com/abhi18av That's question to llvm-sys, not\nreally to this repo.\nBut anyway, as llvm-sys https://github.com/tari/llvm-sys.rs\ndocumentation says:\nThere must be a compatible version of LLVM available. By default llvm-sys\nwill look for llvm-config on PATH to find a system-wide copy of LLVM and\nuse that if it is a compatible version.\nSo you need to have LLVM 4.0 (as you are trying to use it) installed on\nyour target machine. Install it via apt-get or brew or other package\nmanager appropriate to your system and things should work.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/neon-bindings/neon/issues/217#issuecomment-313664328,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AMNNXllIM8Jj6O8J9zOFarPk9ghNGetfks5sLiAPgaJpZM4OQzdm\n.\n. Actually, I'm not trying to mess with the Dragon here. \n\nI just moved the pre-compiled llvm folder which was in the brew's Cellar location to the local folder, which I installed earlier.\nWhat I want to do is to create the neon-node package, here called lumos_1 and serve all it's llvm needs via the pre-compiled binaries in the llvm_4.0.0 folder.\nSo, I just need to find out how to automate the process of sourcing llvm from this particular folder and passing it to the neon build process.\n```sh\nlumos_vm git/master*\n\u276f tree -L 1\n\u251c\u2500\u2500 llvm_4.0.0\n\u2514\u2500\u2500 lumos_1\n```. ",
    "ctaggart": "@hone, need help getting this to work on AppVeyor?. @dherman What was the mistake in your environment? I opened PR #224 with what I had attempted last night, but it doesn't work yet. . It looks like it is the Node.js version. I downgraded to the latest LTS version and it works:\nRunning `rustc --crate-name neon_helloworld src\\lib.rs --crate-type dylib --emit=dep-info,link -C debuginfo=2 -C metadata=80a09b81c4229a9d --out-dir C:\\Users\\camer\\ts\\neon-helloworld\\native\\t\narget\\debug\\deps -L dependency=C:\\Users\\camer\\ts\\neon-helloworld\\native\\target\\debug\\deps --extern neon=C:\\Users\\camer\\ts\\neon-helloworld\\native\\target\\debug\\deps\\libneon-c1fd326fe713320e.rlib -L\nC:\\\\Users\\\\camer\\\\.node-gyp\\\\6.11.2\\Debug -l node -L native=C:\\Users\\camer\\ts\\neon-helloworld\\native\\target\\debug\\build\\neon-runtime-dfd76f3d82f144d3\\out`\n    Finished dev [unoptimized + debuginfo] target(s) in 16.84 secs. I was able to build helloworld with Node.js 6.11.2 installed, but I get a native module version mismatch error, see #223. I downgraded to Node.js 8.2.1, but I get the same error as above with 8.3.0.. When I search for the error message, the links end up at this pull request:\nhttps://github.com/neon-bindings/neon/pull/221/files\nrelated info: https://github.com/rust-lang/rust/issues/38850#issuecomment-321139970\nI don't understand currently how the Node.js version is related. It is failing the same way with 8.1.4, but working with 8.0.0. cc @hone. Oh I see, this error should indeed be fixed by #221. The errors are complaining about -l C:\\\\Users\\\\camer\\\\.node-gyp\\\\8.3.0\\\\<(target_arch)\\\\node which should just be -l node. That appears to have been broken on Windows with Node.js versions > 8.0.0.. #222 isn't passing tests and isn't quite right yet.\nIt looks like node-gyp switched to just ia32 and x64 folders at 8.1.0.\nC:\\users\\camer\\.node-gyp> Show-Tree.ps1 -MaxDepth 2\n+---6.11.2\n|   +---ia32\n|   +---include\n|   +---Release\n|   +---x64\n+---8.0.0\n|   +---Debug\n|   +---ia32\n|   +---include\n|   +---Release\n|   +---x64\n+---8.1.0\n|   +---ia32\n|   +---include\n|   +---x64\n+---8.1.4\n|   +---ia32\n|   +---include\n|   +---x64\nWhen you run \nC:\\Users\\camer\\rs\\neon\\crates\\neon-runtime [windows \u2261 +1 ~0 -0 !]> npm run configure-release\nthe output looks like this:\ngyp info spawn C:\\Users\\camer\\.windows-build-tools\\python27\\python.exe\ngyp info spawn args [ 'C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\node_modules\\\\node-gyp\\\\gyp\\\\gyp_main.py',\ngyp info spawn args   'binding.gyp',\ngyp info spawn args   '-f',\ngyp info spawn args   'msvs',\ngyp info spawn args   '-G',\ngyp info spawn args   'msvs_version=2017',\ngyp info spawn args   '-I',\ngyp info spawn args   'C:\\\\Users\\\\camer\\\\rs\\\\neon\\\\crates\\\\neon-runtime\\\\build\\\\config.gypi',\ngyp info spawn args   '-I',\ngyp info spawn args   'C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\node_modules\\\\node-gyp\\\\addon.gypi',\ngyp info spawn args   '-I',\ngyp info spawn args   'C:\\\\Users\\\\camer\\\\.node-gyp\\\\8.0.0\\\\include\\\\node\\\\common.gypi',\ngyp info spawn args   '-Dlibrary=shared_library',\ngyp info spawn args   '-Dvisibility=default',\ngyp info spawn args   '-Dnode_root_dir=C:\\\\Users\\\\camer\\\\.node-gyp\\\\8.0.0',\ngyp info spawn args   '-Dnode_gyp_dir=C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\node_modules\\\\node-gyp',\ngyp info spawn args   '-Dnode_lib_file=node.lib',\ngyp info spawn args   '-Dmodule_root_dir=C:\\\\Users\\\\camer\\\\rs\\\\neon\\\\crates\\\\neon-runtime',\ngyp info spawn args   '-Dnode_engine=v8',\ngyp info spawn args   '--depth=.',\ngyp info spawn args   '--no-parallel',\ngyp info spawn args   '--generator-output',\ngyp info spawn args   'C:\\\\Users\\\\camer\\\\rs\\\\neon\\\\crates\\\\neon-runtime\\\\build',\ngyp info spawn args   '-Goutput_dir=.' ]\nWith #222, the cargo ends up passing:\ncargo:rustc-link-search=C:\\\\Users\\\\camer\\\\.node-gyp\\\\8.0.0\\Release\ncargo:rustc-link-search=native=\ncargo:rustc-link-lib=node\nThe 2nd line is what is failing the tests. I'll attempt to rollback some of the changes and see how far I get.\n. @dfcarpenter, the error I created this issue was related a Windows problem related to node-gyp and I think it is fixed with #221. You are on macOS, so a bit different, but looks node-gyp related as well. Did you try running node-gyp configure like the error ERR! stack Error: You must run 'node-gyp configure' first! mentioned?. The issue I reported here is fixed for me with #221. @dfcarpenter, if you continue to have issues on macOS, can you open a separate issue?. The good news is 8.0.0 does work.\nHowever, Node.js 8.0.0 is the only version that works for me right now on Windows. Versions above 8.0.0 are affected by #222 and versions below 8.0.0 are affected by this. I still don't know what is causing this.\n. I'm assuming it does. I'll reopen if it does not.. Looks like #221 is now passing on AppVeyor.. @dherman, pretty please.. I closed this thinking that I would be able to use the chakracore-rs library, but that didn't work out. I'm reopening this, hoping that I can get some help learning to use it.. This matrix looks good & looks like AppVeyor is green!\n:four_leaf_clover: :four_leaf_clover: :four_leaf_clover: :four_leaf_clover:. ",
    "dfcarpenter": "I just came across this and love the idea but I am having some problems with getting the helloworld example to build on OSX. I tried node versions, 8.3.0, 8.0.0, and 6.10.0.\nMacbook Pro 15 Touchbar \nOSX V10.12.6\nRust rustc 1.19.0 (0ade33941 2017-07-17)\nError:\n``\nAdmins-MacBook-Pro-3:threading-hint dan$ neon build\nneon info forcing rebuild for new build settings\nneon info running cargo\n   Compiling neon-build v0.1.19\n   Compiling cslice v0.2.0\n   Compiling gcc v0.3.52\n   Compiling neon v0.1.19\n   Compiling threading-hint v0.1.0 (file:///Users/dan/work/threading-hint/native)\n   Compiling neon-runtime v0.1.19\nerror: failed to run custom build command forneon-runtime v0.1.19process didn't exit successfully:/Users/dan/work/threading-hint/native/target/release/build/neon-runtime-139fe67be68a432e/build-script-build` (exit code: 101)\n--- stdout\nSkipping node-gyp installation as part of npm install.\n\n@ build-release /Users/dan/.cargo/registry/src/github.com-1ecc6299db9ec823/neon-runtime-0.1.19\nnode-gyp build\n\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nHOST = Some(\"x86_64-apple-darwin\")\nAR_x86_64-apple-darwin = None\nAR_x86_64_apple_darwin = None\nHOST_AR = None\nAR = None\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nrunning: \"ar\" \"crs\" \"/Users/dan/work/threading-hint/native/target/release/build/neon-runtime-0af1ff8547b4440d/out/libneon.a\" \"build/Release/obj.target/neon/src/neon.o\"\ncargo:warning=ar: build/Release/obj.target/neon/src/neon.o: No such file or directory\nexit code: 1\n--- stderr\ngyp WARN download NVM_NODEJS_ORG_MIRROR is deprecated and will be removed in node-gyp v4, please use NODEJS_ORG_MIRROR\ngyp ERR! build error \ngyp ERR! stack Error: You must run node-gyp configure first!\ngyp ERR! stack     at ReadFileContext. (/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:51:20)\ngyp ERR! stack     at ReadFileContext.callback (/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/npm/node_modules/graceful-fs/graceful-fs.js:78:16)\ngyp ERR! stack     at FSReqWrap.readFileAfterOpen [as oncomplete] (fs.js:365:13)\ngyp ERR! System Darwin 16.7.0\ngyp ERR! command \"/Users/dan/.nvm/versions/node/v6.10.0/bin/node\" \"/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"build\"\ngyp ERR! cwd /Users/dan/.cargo/registry/src/github.com-1ecc6299db9ec823/neon-runtime-0.1.19\ngyp ERR! node -v v6.10.0\ngyp ERR! node-gyp -v v3.4.0\ngyp ERR! not ok \nnpm ERR! Darwin 16.7.0\nnpm ERR! argv \"/Users/dan/.nvm/versions/node/v6.10.0/bin/node\" \"/Users/dan/.nvm/versions/node/v6.10.0/bin/npm\" \"run\" \"build-release\"\nnpm ERR! node v6.10.0\nnpm ERR! npm  v3.10.10\nnpm ERR! code ELIFECYCLE\nnpm ERR! @ build-release: node-gyp build\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ build-release script 'node-gyp build'.\nnpm ERR! Make sure you have the latest version of node.js and npm installed.\nnpm ERR! If you do, this is most likely a problem with the  package,\nnpm ERR! not with npm itself.\nnpm ERR! Tell the author that this fails on your system:\nnpm ERR!     node-gyp build\nnpm ERR! You can get information on how to open an issue for this project with:\nnpm ERR!     npm bugs \nnpm ERR! Or if that isn't available, you can get their info via:\nnpm ERR!     npm owner ls \nnpm ERR! There is likely additional logging output above.\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     /Users/dan/.cargo/registry/src/github.com-1ecc6299db9ec823/neon-runtime-0.1.19/npm-debug.log\nthread 'main' panicked at '\nInternal error occurred: Command \"ar\" \"crs\" \"/Users/dan/work/threading-hint/native/target/release/build/neon-runtime-0af1ff8547b4440d/out/libneon.a\" \"build/Release/obj.target/neon/src/neon.o\" with args \"ar\" did not execute successfully (status code exit code: 1).\n', /Users/dan/.cargo/registry/src/github.com-1ecc6299db9ec823/gcc-0.3.52/src/lib.rs:1654\nnote: Run with RUST_BACKTRACE=1 for a backtrace.\nneon ERR! cargo build failed\nError: cargo build failed\n    at Target. (/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/neon-cli/dist/neon-cli/target.js:124:35)\n    at step (/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/neon-cli/dist/neon-cli/target.js:32:23)\n    at Object.next (/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/neon-cli/dist/neon-cli/target.js:13:53)\n    at fulfilled (/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/neon-cli/dist/neon-cli/target.js:4:58)\n    at process._tickCallback (internal/process/next_tick.js:103:7)\nAdmins-MacBook-Pro-3:threading-hint dan$ \n. Runningnode-gyp configureproduces this:\nAdmins-MacBook-Pro-3:threading-hint dan$ node-gyp configure\ngyp info it worked if it ends with ok\ngyp info using node-gyp@3.6.2\ngyp info using node@6.10.0 | darwin | x64\ngyp WARN download NVM_NODEJS_ORG_MIRROR is deprecated and will be removed in node-gyp v4, please use NODEJS_ORG_MIRROR\ngyp WARN download NVM_NODEJS_ORG_MIRROR is deprecated and will be removed in node-gyp v4, please use NODEJS_ORG_MIRROR\ngyp http GET https://nodejs.org/dist/v6.10.0/node-v6.10.0-headers.tar.gz\ngyp http 200 https://nodejs.org/dist/v6.10.0/node-v6.10.0-headers.tar.gz\ngyp http GET https://nodejs.org/dist/v6.10.0/SHASUMS256.txt\ngyp http 200 https://nodejs.org/dist/v6.10.0/SHASUMS256.txt\ngyp info spawn /Users/dan/.pyenv/shims/python2\ngyp info spawn args [ '/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/node-gyp/gyp/gyp_main.py',\ngyp info spawn args   'binding.gyp',\ngyp info spawn args   '-f',\ngyp info spawn args   'make',\ngyp info spawn args   '-I',\ngyp info spawn args   '/Users/dan/work/threading-hint/build/config.gypi',\ngyp info spawn args   '-I',\ngyp info spawn args   '/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/node-gyp/addon.gypi',\ngyp info spawn args   '-I',\ngyp info spawn args   '/Users/dan/.node-gyp/6.10.0/include/node/common.gypi',\ngyp info spawn args   '-Dlibrary=shared_library',\ngyp info spawn args   '-Dvisibility=default',\ngyp info spawn args   '-Dnode_root_dir=/Users/dan/.node-gyp/6.10.0',\ngyp info spawn args   '-Dnode_gyp_dir=/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/node-gyp',\ngyp info spawn args   '-Dnode_lib_file=/Users/dan/.node-gyp/6.10.0/<(target_arch)/node.lib',\ngyp info spawn args   '-Dmodule_root_dir=/Users/dan/work/threading-hint',\ngyp info spawn args   '-Dnode_engine=v8',\ngyp info spawn args   '--depth=.',\ngyp info spawn args   '--no-parallel',\ngyp info spawn args   '--generator-output',\ngyp info spawn args   'build',\ngyp info spawn args   '-Goutput_dir=.' ]\ngyp: binding.gyp not found (cwd: /Users/dan/work/threading-hint) while trying to load binding.gyp\ngyp ERR! configure error \ngyp ERR! stack Error: gyp failed with exit code: 1\ngyp ERR! stack     at ChildProcess.onCpExit (/Users/dan/.nvm/versions/node/v6.10.0/lib/node_modules/node-gyp/lib/configure.js:336:16)\ngyp ERR! stack     at emitTwo (events.js:106:13)\ngyp ERR! stack     at ChildProcess.emit (events.js:191:7)\ngyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:215:12)\ngyp ERR! System Darwin 16.7.0\ngyp ERR! command \"/Users/dan/.nvm/versions/node/v6.10.0/bin/node\" \"/Users/dan/.nvm/versions/node/v6.10.0/bin/node-gyp\" \"configure\"\ngyp ERR! cwd /Users/dan/work/threading-hint\ngyp ERR! node -v v6.10.0\ngyp ERR! node-gyp -v v3.6.2\ngyp ERR! not ok \n```. ",
    "hone": "@ctaggart does #221 fix this for you?. I have no issues with this.\nOn Tue, Aug 29, 2017, 11:49 PM Dave Herman notifications@github.com wrote:\n\n@ffflorian https://github.com/ffflorian @bennyn\nhttps://github.com/bennyn Is it OK with you guys if, starting with the\nnext release, Neon requires at least Rust 1.18?\n@hone https://github.com/hone Are you OK with this?\nI'm going to go ahead and merge this, but I won't publish a release until\nI know it's not going to break anyone. We can easily revert in the next\ncouple days.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/neon-bindings/neon/pull/231#issuecomment-325880038,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABASdEeGHZT1RmJ0rGLVfTpzOiSCoMgks5sdOnVgaJpZM4PGlpf\n.\n. Ah, I forgot about the CLI and didn't mean to imply the neon bench command. I was modeling the name after the Ruby Bench project which is run separate from Ruby and Rails itself.. Thanks, yeah I wanted to test both LTS + latest and the old configuration was doing a 2x2 matrix where you'd test x64 toolchain on a x86 machine.. \n",
    "janowsiany": "@dherman Hello, is this still valid issue? I tried to reproduce it and potentially fix it but it seemed to work just fine even for long validation messages.. ",
    "robbiepitts": "Looking into this.. I believe https://github.com/nodejitsu/nexpect/pull/35 is needed to complete this. Would love to be wrong.. Awesome, glad @andrewstucki got Appveyor over the finish line!. ",
    "fasihrana": "Ran into this :/. This is my mistake. Should have read the instructions clearly!\nC:\\> npm install --global --production windows-build-tools did the trick.. Sorry for my ignorance, but how does one go about recompiling the node module for nwjs when building with neon?. Is this recompiling only necessary for windows? Worked perfectly fine on Ubuntu without this additional step.. \"From scratch\" in my case meaning that I only followed Getting Started and Hello, World! links.\n\"Perfectly fine\" means, that I was able to load this module in electron and in nwjs without performing any additional build steps. That is what surprised me when I brought my project onto windows and attempted the same steps.. I'm going to try that extra step on windows and see if that helps with getting it to load in electron. Will update when I know more. Will leave this issue open as I feel either this could be added to FAQs and also we should not neglect nwjs as a platform given that nwjs is on Chrome 62 and nodejs 8.7 for those of us living on the \"edge\".. Ok, so no joy.\nI have two folders as follows:\n-ob //this is my electron app\n   |- package.json\n   |- main.js\n   |- index.html\n-sample //this is my default neon module\n   |- *all default files*\nMy sample/package.json is as follows:\n{\n  \"name\": \"sample\",\n  \"version\": \"0.1.0\",\n  \"description\": \"\",\n  \"main\": \"lib/index.js\",\n  \"author\": \"fasihrana\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"neon-cli\": \"^0.1.20\"\n  },\n  \"scripts\": {\n    \"install\": \"neon build\"\n  }\n}\nMy ob/package.json is as follows:\n{\n        \"name\": \"ob\",\n        \"version\": \"0.1.0\",\n        \"main\": \"main.js\",\n        \"dependencies\": {\n                \"sample\": \"file:../sample\"\n        },\n        \"dev-dependencies\": {\n                \"electron-build-env\": \"^0.2\",\n                \"neon-cli\": \"^0.1.2\"\n        },\n        \"scripts\": {\n                \"build\": \"electron-build-env neon build sample\"\n        }\n}\nI don't understand what i am doing wrong here.. Ok, so figured out that I needed to change the following in ob\\package.json\n\"dev-dependencies\": {\n                \"electron-build-env\": \"^0.2\",\n                \"neon-cli\": \"^0.1.2\"\n        }\nto\n\"devDependencies\": {\n                \"electron\": \"^1.6.2\",\n                \"electron-build-env\": \"^0.2\",\n                \"neon-cli\": \"^0.1.2\"\n        }. ",
    "humphd": "I was about to file a bug on the need for improved docs for running the tests, and I noticed this.  If you don't need this to be fixed immediately, I'd like to do this as an exercise with my students in class.  It would let them learn about npm, TravisCI, Rust, cargo, automated tests, build automation, etc.  Lots of good stuff in here.\nI realize you may need this sooner than I'll have time to do with them, since we'll spend a bunch of time researching it in class, so feel free to fix it if you need to.  Otherwise, I hope we'll have a PR for you in the coming weeks.. OK, thanks for letting me know.  Reading that PR, it also looks like \"make this work fully on Windows\" might be something for them to do in future as well.  RE: #252, I know that @SeanPrashad hit this recently, and I was suggesting he look into it.  Maybe he'd like to try this?\nI'll circle back to this stuff later and do some bugs with my students as it lines up with topics we're covering.. @SeanPrashad I think it would be a good fit for you, and give you some nice exposure to build automation, which is something I remember you expressing interest in at the start of the term.. ",
    "reSHARMA": "I am new to neon , but I really want to contribute on this issue . Can you guide me what should I do next ?. ",
    "MilanLoveless": "I got these failing static tests to pass by switching to the nightly build of Rust.\n\n. review comments and suggestions for improvement have been addressed \ud83d\ude04 . Awesome!. Looks great! I pulled it down and verified that it still runs as intended on my mac.\nIs there a case where we would have rust tests anyplace outside of tests/static? We may want to move the code to check release vs. debug build arguments and associated constants into /src/lib.rs. ",
    "jjpe": "I just tried this on OS X, and here setting it seems to do nothing: \n```\n$ env DEBUG=true neon build\nneon info running cargo\n   Compiling sbr-validate-npm v0.7.4 (file:///Users/j/Development/accept/sbr-validate-npm/native)\nwarning: variable does not need to be mutable\n   --> src/lib.rs:129:1\n    |\n129 | / register_module!(m, {\n130 | |     let repl_class: Handle<JsClass<JsRepl>> = JsRepl::class(m.scope)?;\n131 | |     let repl_ctor: Handle<JsFunction<JsRepl>> = repl_class.constructor(m.scope)?;\n132 | |     m.exports.set(\"Repl\", repl_ctor.as_value(m.scope))?;\n133 | |     Ok(())\n134 | | });\n    | |___^ help: remove thismut`\n    |\n    = note: #[warn(unused_mut)] on by default\n    = note: this error originates in a macro outside of the current crate\nFinished release [optimized] target(s) in 8.15 secs\n\nneon info generating native/index.node\n. That did it. The original trigger for this issue has since been solved, but it is nice to see nonetheless that this is possible. Awesome work guys :). Has anything been done with this yet? \nFTR: It seems that @kanekv's suggestion about the dependency/devDependency issue in neon-runtime/package.json works, at least over here on a fresh Ubuntu system.. I think I've figured out both questions:\n1. rust\n    method foo(call_ctx) {\n        let result: MfroResult = {\n            let guard = call_ctx.lock();\n            let mfro: &mut MyFancyRustObject = &mut this.borrow_mut(&guard);\n            // do things with the mfro \n            Ok(/ yield a result */)\n        };\n    }\n````\nand 2.\n```` rust\nregister_module!(mut ctx, {\n    ctx.export_class::(\"MyFancyRustObject\")?;\n    Ok(())\n});\n````\nUltimately not all that hard to do, but figuring it out was a journey.. @C5H8NNaO4 Note that we've since moved to WASM, which does not exhibit such strange build failures. Perhaps that can be a solution for you as well. . @PSeitz you can but it's completely unsupported, so use at your own risk. . Npm supports both git and path dependencies.\nA git dependency to the fork seems easiest to do, as you wouldn't need to clone the fork.\nFor more info have a look at https://docs.npmjs.com/files/package.json (apologies for the ugly link) . ",
    "andrewstucki": "So, I forked nexpect here, re-wrote it in Typescript and allowed for passing down all child_process.spawn options, which now allows re-enabling the cli tests on windows. . ",
    "ocboogie": "I think it would be nice to see an example of getting js arguments.. ",
    "rm-rf-etc": "@ocboogie \n```\n// in JS:\n// require('neon-module').async_method('show me the money', (n) => console.log(n))\n// >> 'show me the money'\nfn async_method(call: Call) -> JsResult {\nlet fn_handle = call.arguments.get(call.scope, 1).unwrap();\nlet arg_handle = call.arguments.get(call.scope, 0).unwrap();\n\nif let Some(function) = fn_handle.downcast::<JsFunction>() {\n\n    let args: Vec<Handle<JsValue>> = vec![arg_handle];\n    let _ = function.call(call.scope, JsNull::new(), args);\n}\n\nOk(JsUndefined::new())\n\n}\nregister_module!(m, {\n    try!(m.export(\"async_method\", async_method));\n    Ok(())\n});\n```. ",
    "hardliner66": "I have the same error, even after installing the windows-build-tools package.. After adding some debug output to the build script, I fixed the problem. It was a misconfiguration in npm config. I accidently set the config \"target\" to the target triple. node gyp reads this config as target node version.\nAfter cleaning up my node config everything worked as expected.. ",
    "itserg2008": "I have exactly the same issue when running my Electron app on Windows 10. Has anyone resolved it somehow? I found a solution here (https://stackoverflow.com/questions/28486891/uncaught-error-module-did-not-self-register) but don't have an idea what exactly should be changed in neon to implement something like this:\nvoid Init(v8::Handle exports) {\n  NODE_SET_METHOD(exports, \"method\", method);\n}\nNODE_MODULE(method, Init);\n. I have exactly the same issue when running my Electron app on Windows 10. Has anyone resolved it somehow? I found a solution here (https://stackoverflow.com/questions/28486891/uncaught-error-module-did-not-self-register) but don't have an idea what exactly should be changed in neon to implement something like this:\nvoid Init(v8::Handlev8::Object exports) {\nNODE_SET_METHOD(exports, \"method\", method);\n}\nNODE_MODULE(method, Init);. I see exactly the same behaviour - works fine for me on Windows 10 with Electron 3.0.10, but couldn't get it work on 4.0.X.\nAny ideas?. ",
    "weihanglo": "It works after restart the system. Closed.. ",
    "rebo": "Hi, I've tried this pull request, when I call twice a jsFunction defined in this way the runtime crashes with a malloc pointer being freed was not allocated error.\nEdit: ~~Actually something else seems to be going wrong, the foo.clone() within the closure seems to cause the error the second time around, if i remove it, it seems to work fine.~~\n2nd Edit: Actually scratch that!, even with no foo.clone(), it still crashes. In the below code on the third call.\ncode:\n    let scope = call.scope;\n\n    let bar_func = JsFunction::new(scope, Box::new(move |call| {\n        println!(\"called\");\n        Ok(JsString::new(call.scope, \"foo\").unwrap())\n    }))?;\n\n    let args: Vec<Handle<JsValue>> = vec![];\n    bar_func.call(scope,JsUndefined::new(),args.clone());\n    bar_func.call(scope,JsUndefined::new(),args.clone());\n    bar_func.call(scope,JsUndefined::new(),args.clone()); // crashes on third call\n    bar_func.call(scope,JsUndefined::new(),args.clone());\n    bar_func.call(scope,JsUndefined::new(),args.clone());\n\noutput:\ncalled\ncalled\nnode(40302,0x7fffb200b340) malloc: *** error for object 0x102608cf0: pointer being freed was not allocated. Hi @abrodersen , seems to work fine now thanks for fixing.  I have it working with your persistent handles and a neon async task.. Hi,\n\nI have created an example app showing how this pull request's PersistentHandles can be used to reference Node.js objects in callbacks from a Neon Task.\nA MainBackgroundTask signals a DispatchTask to return data from Node.js when it needs it.\nhttps://github.com/rebo/async-neon-example. This would be helpful indeed. As mentioned in the slack channel I had issues compiling from source.\nTurns out typescript compiler was not installed on my system so key files were not compiled.\nOnce i \"npm install tsc -g\" everything worked.. ",
    "orthecreedence": "Thanks, your answers help a lot (and make it clear which direction I need to go in).\nDo you know of a way to tell rustc to pass -D__USE_MINGW_ANSI_STDIO to gcc when building? I've tried setting CFLAGS directly but I don't think it \"takes.\". Thanks for the help!. ",
    "LifeIsStrange": "Isn't LTO superceded by thinLTO ? . ",
    "heroes-coding": "+1. ",
    "tptee": "Hi @MegaBlackLabel ! I tried this out with the latest of MSVC 2017, Node 8, and Yarn and can't reproduce the error on either nightly or stable. I'm going to try to do the global installs like you did to see if npm is the culprit here!. Can't reproduce with npm@4.0.5 either. Can you update MVSC and try again?. Great! Let us know if you run into this again1. Yikes, this is a really unfortunate change on Homebrew's part. Maybe we can just add this caveat to the docs @dherman ?. Welp, bindgen-generated bindings are platform and architecture specific...don't know what I expected. We have two options here:\n- Add bindgen as a build step. This requires users to have libclang installed on their system\u2013annoying and probably not already on CI images\n- Pre-bake and conditionally compile bindings for all of Node's supported architectures. Seems like it'd be hard to track down environments with all of the supported architectures.\nThoughts @dherman ?. Another idea\u2013put this PR behind an async Cargo feature and only run the bindgen build step if the user opts in!. ",
    "MegaBlackLabel": "Hi @tptee\nJust as you said, update to npm 5.6.0 and re-install global modules.\nIt's working as expected. Thanks for the advice!!!. ",
    "AberrantWolf": "I am getting nearly the same kind of error. I just installed the latest NodeJS 8 and followed the guide, so I have:\n\nrustc 1.29.0-nightly (6a1c0637c 2018-07-23)\ncargo 1.29.0-nightly (506eea76e 2018-07-17)\nOS: Windows 10 64bit\nNode.js: v8.11.3\nnpm: 5.6.0\nyarn: 1.9.4\nPython: 2.7.15\ntoolchain: nightly-x86_64-pc-windows-msvc (default)\n\nThe error I have is very similar, but if you want me to make a new issue (since this one is old) please let me know.\n``\nPS C:\\Users\\scott\\Documents\\Programming\\Hybrid\\threading-hint> yarn\nyarn install v1.9.4\n[1/4] Resolving packages...\nsuccess Already up-to-date.\n$ neon build\nneon info forcing rebuild for new build settings\nneon info running cargo\n   Compiling semver-parser v0.7.0\n   Compiling cslice v0.2.0\n   Compiling neon-runtime v0.2.0\n   Compiling semver v0.9.0\nerror: failed to run custom build command forneon-runtime v0.2.0process didn't exit successfully:C:\\Users\\scott\\Documents\\Programming\\Hybrid\\threading-hint\\native\\target\\debug\\build\\neon-runtime-b5be163d18debf83\\build-script-build` (exit code: 101)\n--- stdout\n'Skipping node-gyp installation as part of npm install.'\nup to date in 0.538s\ncargo:node_arch=x64\ncargo:node_root_dir=C:\\Users\\scott\\.node-gyp\\8.11.3\ncargo:node_lib_file=C:\\Users\\scott\\.node-gyp\\8.11.3\\<(target_arch)\\node.lib\n\n@ build-debug C:\\Users\\scott.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\neon-runtime-0.2.0\nnode-gyp build --debug\n\nC:\\Users\\scott.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\neon-runtime-0.2.0>if not defined npm_config_node_gyp (node \"C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin\\....\\node_modules\\node-gyp\\bin\\node-gyp.js\" build --debug )  else (node \"C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js\" build --debug )\nBuilding the projects in this solution one at a time. To enable parallel build, please add the \"/m\" switch.\nTRACKER : error TRK0005: Failed to locate: \"CL.exe\". The system cannot find the file specified. [C:\\Users\\scott.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\neon-runtime-0.2.0\\build\\neon.vcxproj]\nTARGET = Some(\"x86_64-pc-windows-msvc\")\nrunning: \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\bin\\HostX64\\x64\\lib.exe\" \"/OUT:C:\\Users\\scott\\Documents\\Programming\\Hybrid\\threading-hint\\native\\target\\x86_64-pc-windows-msvc\\debug\\build\\neon-runtime-473e261f72bbfe3c\\out\\libneon.a\" \"/nologo\" \"build\\Debug\\obj\\neon\\neon.obj\"\nLINK : fatal error LNK1181: cannot open input file 'build\\Debug\\obj\\neon\\neon.obj'\nexit code: 1181\n--- stderr\ngyp ERR! build error\ngyp ERR! stack Error: C:\\Program Files (x86)\\MSBuild\\14.0\\bin\\msbuild.exe failed with exit code: 1\ngyp ERR! stack     at ChildProcess.onExit (C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\lib\\build.js:258:23)\ngyp ERR! stack     at emitTwo (events.js:126:13)\ngyp ERR! stack     at ChildProcess.emit (events.js:214:7)\ngyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:198:12)\ngyp ERR! System Windows_NT 10.0.17134\ngyp ERR! command \"C:\\Program Files (x86)\\nodejs\\node.exe\" \"C:\\Program Files (x86)\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js\" \"build\" \"--debug\"\ngyp ERR! cwd C:\\Users\\scott.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\neon-runtime-0.2.0\ngyp ERR! node -v v8.11.3\ngyp ERR! node-gyp -v v3.6.2\ngyp ERR! not ok\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ build-debug: node-gyp build --debug\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the @ build-debug script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     C:\\Users\\scott\\AppData\\Roaming\\npm-cache_logs\\2018-08-10T13_39_54_003Z-debug.log\nthread 'main' panicked at '\nInternal error occurred: Command \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.13.26128\\bin\\HostX64\\x64\\lib.exe\" \"/OUT:C:\\Users\\scott\\Documents\\Programming\\Hybrid\\threading-hint\\native\\target\\x86_64-pc-windows-msvc\\debug\\build\\neon-runtime-473e261f72bbfe3c\\out\\libneon.a\" \"/nologo\" \"build\\Debug\\obj\\neon\\neon.obj\" with args \"lib.exe\" did not execute successfully (status code exit code: 1181).\n', C:\\Users\\scott.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\gcc-0.3.54\\src\\lib.rs:1670:5\nnote: Run with RUST_BACKTRACE=1 for a backtrace.\nneon ERR! cargo build failed\nError: cargo build failed\n    at Target. (C:\\Users\\scott\\Documents\\Programming\\Hybrid\\threading-hint\\node_modules\\neon-cli\\lib\\target.js:121:35)\n    at step (C:\\Users\\scott\\Documents\\Programming\\Hybrid\\threading-hint\\node_modules\\neon-cli\\lib\\target.js:32:23)\n    at Object.next (C:\\Users\\scott\\Documents\\Programming\\Hybrid\\threading-hint\\node_modules\\neon-cli\\lib\\target.js:13:53)\n    at fulfilled (C:\\Users\\scott\\Documents\\Programming\\Hybrid\\threading-hint\\node_modules\\neon-cli\\lib\\target.js:4:58)\n    at \n    at process._tickCallback (internal/process/next_tick.js:188:7)\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/install for documentation about this command.\n```. ",
    "roderickmonk": "I have exactly the same error on Ubuntu 16.04, although no problem on my dev machine, but I certainly have this same error when I go to install on an ec2.. ",
    "cztomsik": "@matklad well that is cool but how do you use it from rust? napi crate seems to be year old and without any further updates\nis there a simple way to call napi_create_external_arraybuffer()?. ",
    "ea2973929": "Due to https://github.com/neon-bindings/neon/pull/325/ this is no longer applicable and should be closed?. ",
    "Luke-Nukem": "That is helpful, but not convenient at all for local development.. ",
    "nox": "I think many many others transmute uses could be cleaned up too.. ",
    "jgrund": "Cargo workspaces. Here is an example repo where I'm using neon in a workspace: https://github.com/intel-hpdd/rust-libzfs/. ",
    "jacobwgillespie": "Just ran into this issue - it looks like neon uses node-gyp, node-gyp in turn uses Python, and nowadays brew install python on macOS is installing Python 3, which isn't compatible with node-gyp.\nI was able to solve this by doing the following:\n\nbrew install python@2\nvirtualenv env\nsource env/bin/activate\nnow neon builds as expected. \n",
    "jeffvandyke": "Arch linux-based distros do this as well, where which python is a symlink to python3. ",
    "jamespantalones": "@AviateX14 did you ever get this resolved? having same issue. Ok, think i got it sorted. In my case, i was using neon in context of React/Electron app and the issue was I needed to add a native loader to my webpack config to get this to work.\nI also had to adjust the lib/index.js file in the neon binding to export ../native/index.node explicitly instead of just ../native.. ",
    "theHazzard": "https://pastebin.com/cJ2JLxER. ",
    "mhsjlw": "I'm guessing that if https://github.com/neon-bindings/neon/blob/4e2273c14de6820d81cb377a44e5634b88f69174/crates/neon-runtime/package.json#L11 is bumped to 2.10.0 It'll work. I'll give it a try.. Alright, it appears that \nhttps://github.com/neon-bindings/neon/blob/4e2273c14de6820d81cb377a44e5634b88f69174/crates/neon-runtime/src/neon.cc#L30-L32\nthis function fails to build due to \n../src/neon.cc:32:16: error: no member named 'Callee' in 'v8::FunctionCallbackInfo<v8::Value>'\n  *out = info->Callee();\nSo it looks like it's been removed from V8? I'll keep investigating, but once this builds I'm guessing it will work.. It does appear that it was marked as deprecated:\nhttps://codereview.chromium.org/1582793004/patch/1/10001\nBut has since been removed:\nhttps://chromium-review.googlesource.com/c/v8/v8/+/741600\nI'll look at the possibility of moving to ->Data(). A PR has been opened with my changes. @pitaj Good idea, it has been added. This is a quick way for me to ensure that my changes work across versions as well (I doubt it will). Based on this documentation: https://github.com/neon-bindings/neon/blob/b83ab66a442cc2b26fae7dc9227919be1d11a705/crates/neon-runtime/src/call.rs#L28-L29, when would it ever not be the callee?\nAdditionally, I do not believe that this is the optimal solution, it just just the solution that I immediately know of that fixes this issue. Suggestions are appreciated, removal might not be needed.. Great to have helped! Is there a release on the horizon?. ",
    "justnoxx": "I am sorry, I forgot to provide an update for this issue.\nLooks like I found kinda reason of this error.\n@itserg2008, it is because of updated node.js binaries that are being used for pkg. They are somehow different near the dlopen function. That's why it breaks. For now we using an embedded node for windows systems and pkg on linux/osx.. ",
    "PSPanesar": "Thanks for that. I did give that a try but came across another error. I've installed nodejs npm rust and neon on my docker image but when i run neon build in my docker image to build a fresh i get a new error which says that rust is not installed or the Path for rustc is not correct. I'm sure its installing properly as after the curl command it gives the message installed stable rust. \n. Hi, Thanks for that. I'll test out the dockerfile with my build. I did add the cargo path as above but it didn't solve my problem initially. I'll give your dockerfile a try though thanks.\n. ",
    "enioluwa23": "@kjvalencik This is great. I did not go for using JsValue because I was not sure it would act the same way as JsObject but I guess it is feasible. Exactly what I was looking for! I will close this.. ",
    "aslamplr": "This is supposed to be in guides repo\nCreated an issue there Issue #4 of guides repo. ",
    "TomPridham": "I had looked at them briefly. I'm coming from a JS background and they didn't seem super accessible or relevant. I also wouldn't have thought to look there first off. I only ended up looking in there after having done a bunch of other searches and not finding anything.\nI also feel like having tests act as examples could get sort of messy. I could add some documentation, but I think having the examples is more valuable.. I think I addressed everything. I moved the examples to mirror the output of neon new. let me know if anything else needs work. these won't run with the 0.2.0 release. I can update them sometime this week. Should all the .checks get replaced with calls to downcast? it doesn't seem like check is a thing anymore. @dherman i've updated the examples. i'm not sure if this is the idiomatic way of doing things now or not. let me know if anything should get changed. the travis failed during the apt-get step on the nightly build. so I'm not sure if that just happens sometimes on the nightlies or if i actually broke something or not.. \ud83d\udc4d . I'm not sure what was meant by that. I copied most(all?) of that from #260. I can delete it. I originally did it this way because I wasn't sure what structure would work in the examples and was trying to keep it minimal. I moved everything to mirror the output of neon new since I think that makes more sense.. ",
    "dai875939260": "thank you very much\uff01it helped me a lot.. ",
    "Brooooooklyn": "Here is a minimal N-API library https://github.com/brooooooklyn/napi-rs which is still in developing.. ",
    "jbolila": "202 has a similar question, and N-API is now on stable Node 10, and soon 8 (without the need of a flag), all well described in a recent blog post:\nhttps://medium.com/the-node-js-collection/n-api-next-generation-apis-for-node-js-native-addons-available-across-all-lts-release-lines-4f35b781f00e\nSince this project has already a community of Rust + Node users, can't N-API be supported using the official https://github.com/nodejs/node-addon-api to generate the bindings and simplify the all process ?. ",
    "ZhangHanDong": "@kjvalencik \nThanks\uff0cI see. wait in hope.. ",
    "Lin-H": "I have the similar problem\nwindow 7 64bit\nnode 8.11.3\nRust 1.27.2 stable msvc\nLINK : fatal error LNK1181: cannot open input file 'build\\Release\\obj\\neon\\neon.obj'\nexit code: 1181\nhaven't solve it yet :cry: . I fixed it. My problem it's not the dependency. It's my Python, I reinstall Python 2.7 and it works.. ",
    "maackle": "Is there a chance we could have a neon test cli command? It would be useful to be able to write unit tests within native rust modules, I am currently trying to figure out how to do this.. Thanks, but I should have clarified: I meant the ability to write Rust unit tests, i.e. test the native code.. I don't have the depth to comment on the viability of this, but I would love to have this functionality! I'm currently building something kind of complicated using Task because callbacks in threads are not possible.. ",
    "darkwater": "Attributes have more defined syntax than I expected, so I'm now trying out doc comments instead, like this:\n```rust\npub class JsDbConn for DbConn {\n    /// Connect to the database. Multiple connections can co-exist.\n    ///\n    /// constructor()\n    init(_cx) {\n        ...\n    }\n/// Fetch all Libraries from the database.\n///\n/// getLibraries(): Array<Library>\nmethod getLibraries(mut cx) {\n    ...\n}\n\n}\n```\nThis means we can also add documentation to the definition files, I think that'll look like this:\n```typescript\nexport class DbConn {\n    /~ Connect to the database. Multiple connections can co-exist.\n     /\n    constructor();\n/*~ Fetch all Libraries from the database.\n */\ngetLibraries(): Array<Library>;\n\n}\n```\nI'll post my code when I got everything working, but I think it might be better to rewrite it from the ground up for Neon as this is my first time parsing Rust code and I don't think I used syn properly.. Alright, I got it working for my project now. Here's what I got. I'll document it tomorrow as it's getting late here but I really think it's best to just rewrite proper code from scratch. But if anyone else wants this functionality right now, you should be able to just dump this in your build.rs and have it just work.. ",
    "willmtemple": "@jjpe I propose reopening this, as this is not documented on the neon website and this bug report is the first place I managed to find the answer to this question after more than an hour of searching.. ",
    "C5H8NNaO4": "+1. ",
    "duncanbeevers": "@gbenattar I'm curious about this as well. I'm doing something similar\njson\n{\n  \"scripts\": {\n    \"build\": \"cargo --manifest-path native/Cargo.toml && neon build --release\"\n  }\n}\nIt does seems like this would be generally useful as part of the build process, at least via a command-line flag.. ",
    "cookiengineer": "@kjvalencik Uh, thank you very much, that should help me getting started! Awesome!. ",
    "olup": "Same here, just run it with the release flag, no ? like neon build --release. ",
    "dialogbox": "Similar, but little different here.\nMy Environments\n```console\n% neon version\n0.2.0\n% node -v\nv11.2.0\n% npm -v\n6.4.1\n% rustup show\nDefault host: x86_64-apple-darwin\nstable-x86_64-apple-darwin (default)\nrustc 1.30.1 (1433507eb 2018-11-07)\n```\nBuild and run itself is ok.\nconsole\n% neon new my-project\n...\n% cd my-project\n% neon build\nneon info forcing rebuild for new build settings\nneon info running cargo\n    Updating crates.io index\n   Compiling version_check v0.1.5\n   Compiling cfg-if v0.1.6\n   Compiling libc v0.2.43\n   Compiling ucd-util v0.1.3\n   Compiling regex v0.2.11\n   Compiling lazy_static v1.2.0\n   Compiling utf8-ranges v1.0.2\n   Compiling gcc v0.3.55\n   Compiling neon-build v0.2.0\n   Compiling semver-parser v0.7.0\n   Compiling cslice v0.2.0\n   Compiling regex-syntax v0.5.6\n   Compiling memchr v2.1.1\n   Compiling thread_local v0.3.6\n   Compiling neon v0.2.0\n   Compiling my-project v0.1.0 (/Users/dialogbox/works/rust/my-project/native)\n   Compiling semver v0.9.0\n   Compiling aho-corasick v0.6.9\n   Compiling neon-runtime v0.2.0\n    Finished dev [unoptimized + debuginfo] target(s) in 16.84s\nneon info generating native/index.node\n% node -e 'require(\"./\")'\nhello node\nBut, cargo test fails.\n``console\n% cd native\n% cargo test\n   Compiling my-project v0.1.0 (/Users/dialogbox/works/rust/my-project/native)\nerror: linking withcc` failed: exit code: 1\n  |\n  = note: \"cc\" \"-m64\" \"-L\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.14epkf1b9s0eu4lx.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.14mgytbfuj2h4z0v.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.1gxpkm8fdjdavua5.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.1wor61c1ey36etk8.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.23e8pyazmgu3e389.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.2b4x87fd6kqn94bu.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.2eyi022e5k1uw0gc.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.2m2teyp6596owcoh.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.2o29w6mw6r2zavyp.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.2qgcxusy3crbrtot.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.3015gbbydlzlhstk.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.3mxkp2jzsftrlj3n.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.3qtj9hj1ouu2pga3.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.3ucmrxxiet7mg5nj.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.466d9pval0vf9hvs.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.4arr4zizqwsnr22p.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.4cw8aeyq1ax1acuc.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.4dxv5hg4hxe9arxs.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.4oe4w2qhku5wzzny.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.4ot4ygm7vwx4i2ry.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.4q5kyru7gzu0bdp6.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.4qaviprejw6vfdt6.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.553dzu3pgi8bk4vh.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.556uoze9yki50qvz.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.7gems98o2bpvo0a.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.f6v5kbadjn7e56z.rcgu.o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.seaa2imba682v2m.rcgu.o\" \"-o\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/my_project-07ec78272dd7cf7e.1ml3bdzfsnw6ouub.rcgu.o\" \"-Wl,-dead_strip\" \"-nodefaultlibs\" \"-L\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps\" \"-L\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/build/neon-runtime-8bc2027f8ac5020b/out\" \"-L\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libtest-c2b92ef38bc65339.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libterm-6349508393622615.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libgetopts-f1e85f00c34fa59c.rlib\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/libneon-a8c3ebd2089333f8.rlib\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/libsemver-c9201ffb83659839.rlib\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/libsemver_parser-a914c88bd9416303.rlib\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/libcslice-07c1a1164871e0f1.rlib\" \"/Users/dialogbox/works/rust/my-project/native/target/debug/deps/libneon_runtime-6f2797e2fc93d4a1.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libstd-a5984f6fc2a4870f.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libpanic_unwind-7c9487d161f01b59.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/liballoc_jemalloc-e146b9b98ab73364.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libunwind-acb39784a181deae.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/liballoc_system-89f97a4bae8c89d2.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/liblibc-cd336d4bb1fade3c.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/liballoc-d6545438808205eb.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libcore-8aa8397108285683.rlib\" \"/Users/dialogbox/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libcompiler_builtins-83c21e81fef8188c.rlib\" \"-lSystem\" \"-lresolv\" \"-lpthread\" \"-lc\" \"-lm\"\n  = note: Undefined symbols for architecture x86_64:\n            \"v8::V8::ToLocalEmpty()\", referenced from:\n                v8::MaybeLocal::ToLocalChecked() in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::Isolate::ThrowException(v8::Local)\", referenced from:\n                Nan::ThrowError(v8::Local) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Nan::ThrowError(char const) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::HandleScope::~HandleScope()\", referenced from:\n                Nan::Set(v8::Local, v8::Local, v8::Local) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                _Neon_Scope_Exit in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Nan::HandleScope::~HandleScope() in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::External::Value() const\", referenced from:\n                _Neon_Fun_GetDynamicCallback in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::Function::New(v8::Local, void ()(v8::FunctionCallbackInfo const&), v8::Local, int, v8::ConstructorBehavior, v8::SideEffectType)\", referenced from:\n                _Neon_Fun_New in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::Isolate::GetCurrentContext()\", referenced from:\n                Nan::Set(v8::Local, v8::Local, v8::Local) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                _Neon_Fun_New in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::Exception::Error(v8::Local)\", referenced from:\n                _Neon_Error_ThrowErrorFromUtf8 in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Nan::ThrowError(char const) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::Object::Set(v8::Local, v8::Local, v8::Local)\", referenced from:\n                Nan::Set(v8::Local, v8::Local, v8::Local) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::Isolate::GetCurrent()\", referenced from:\n                _Neon_Call_CurrentIsolate in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Neon_ASCII_Key(v8::Local, unsigned char const, int) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Nan::Set(v8::Local, v8::Local, v8::Local) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Nan::ThrowError(v8::Local) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                _Neon_Error_ThrowErrorFromUtf8 in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Nan::ThrowError(char const) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Nan::HandleScope::HandleScope() in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                ...\n            \"v8::External::New(v8::Isolate, void)\", referenced from:\n                _Neon_Fun_New in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::HandleScope::HandleScope(v8::Isolate)\", referenced from:\n                Nan::Set(v8::Local, v8::Local, v8::Local) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                _Neon_Scope_Enter in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Nan::HandleScope::HandleScope() in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::String::NewFromUtf8(v8::Isolate, char const, v8::NewStringType, int)\", referenced from:\n                Neon_ASCII_Key(v8::Local, unsigned char const, int) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                _Neon_String_New in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                _Neon_Error_ThrowErrorFromUtf8 in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n                Nan::imp::Factory::New(char const, int) in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"v8::V8::FromJustIsNothing()\", referenced from:\n                v8::Maybe::FromJust() const in libneon_runtime-6f2797e2fc93d4a1.rlib(neon.o)\n            \"_node_module_register\", referenced from:\n                my_project::__LOAD_NEON_MODULE::__load_neon_module::h21032fe34cbef846 in my_project-07ec78272dd7cf7e.f6v5kbadjn7e56z.rcgu.o\n          ld: symbol(s) not found for architecture x86_64\n          clang: error: linker command failed with exit code 1 (use -v to see invocation)\nerror: aborting due to previous error\nerror: Could not compile my-project.\nTo learn more, run the command again with --verbose.\n```\ncargo test --release works.\n```console\n% cargo test --release\n   Compiling version_check v0.1.5\n   Compiling cfg-if v0.1.6\n   Compiling libc v0.2.43\n   Compiling lazy_static v1.2.0\n   Compiling ucd-util v0.1.3\n   Compiling regex v0.2.11\n   Compiling utf8-ranges v1.0.2\n   Compiling gcc v0.3.55\n   Compiling neon-build v0.2.0\n   Compiling semver-parser v0.7.0\n   Compiling cslice v0.2.0\n   Compiling thread_local v0.3.6\n   Compiling regex-syntax v0.5.6\n   Compiling memchr v2.1.1\n   Compiling neon v0.2.0\n   Compiling my-project v0.1.0 (/Users/dialogbox/works/rust/my-project/native)\n   Compiling semver v0.9.0\n   Compiling aho-corasick v0.6.9\n   Compiling neon-runtime v0.2.0\n    Finished release [optimized] target(s) in 21.26s\n     Running target/release/deps/my_project-cd47d2683dbb12d3\nrunning 0 tests\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```. ",
    "retep998": "Whether you build as cdylib or dylib is orthogonal to the issue of how libstd is linked. The fact of the matter is that dylib is intended to be consumed as a rust crate while cdylib is intended to be consumed as normal native dynamic library that other languages can call into. dylib has a lot of bloat via rust metdata and exported symbols that is not needed when you're just trying to call into your dynamic library from JS. Please switch to cdylib and never look back.. ",
    "PSeitz": "I took a look on the issue with cargo expand on the user class example.\nIt's a bit lengthy. Important thing is, there is no constructor there, unlike e.g. in JSNumber. \nI think we would need have some auto generated constructor from the macro, which e.g. takes all the parameters required to build a new instance and the generates the new instance via neon_runtime calls.\nIt should already be possible to do this manually via neon_runtimecalls, but it seems neon_runtime is not exposed.\nJSNumber constructor:\nhttps://github.com/neon-bindings/neon/blob/ca17a7ba278f7b02b68c745a27274db77ccb8e75/src/types/mod.rs#L312-L315\nCargo Expand\nrust\npub struct User {\n    id: i32,\n    first_name: String,\n    last_name: String,\n    email: String,\n}\npub struct JsUser(::macro_internal::runtime::raw::Local);\nimpl ::handle::Managed for JsUser {\n    fn to_raw(self) -> ::macro_internal::runtime::raw::Local {\n        let JsUser(raw) = self;\n        raw\n    }\n    fn from_raw(raw: ::macro_internal::runtime::raw::Local) -> Self {\n        JsUser(raw)\n    }\n}\nimpl ::object::Class for JsUser {\n    type Internals = User;\n    fn setup<'a, C: ::context::Context<'a>>(\n        _: &mut C,\n    ) -> ::result::NeonResult<::object::ClassDescriptor<'a, Self>> {\n        ::std::result::Result::Ok(\n            Self::describe(\"User\", {\n                fn _______allocator_rust_y_u_no_hygienic_items_______(\n                    mut cx: ::context::CallContext<::types::JsUndefined>,\n                ) -> ::result::NeonResult<User> {\n                    {\n                        let id = cx.argument::<JsNumber>(0)?;\n                        let first_name: Handle<JsString> = cx.argument::<JsString>(1)?;\n                        let last_name: Handle<JsString> = cx.argument::<JsString>(2)?;\n                        let email: Handle<JsString> = cx.argument::<JsString>(3)?;\n                        Ok(User {\n                            id: id.value() as i32,\n                            first_name: first_name.value(),\n                            last_name: last_name.value(),\n                            email: email.value(),\n                        })\n                    }\n                }\n                ::macro_internal::AllocateCallback(\n                    _______allocator_rust_y_u_no_hygienic_items_______,\n                )\n            })\n            .method(\"get\", {\n                fn _______method_rust_y_u_no_hygienic_items_______(\n                    mut cx: ::context::CallContext<JsUser>,\n                ) -> ::result::JsResult<::types::JsValue> {\n                    {\n                        let attr: String = cx.argument::<JsString>(0)?.value();\n                        let this = cx.this();\n                        match &attr[..] {\n                            \"id\" => {\n                                let id = {\n                                    let guard = cx.lock();\n                                    let user = this.borrow(&guard);\n                                    user.id\n                                };\n                                Ok(cx.number(id).upcast())\n                            }\n                            _ => cx.throw_type_error(\"property does not exist\"),\n                        }\n                    }\n                }\n                ::macro_internal::MethodCallback(_______method_rust_y_u_no_hygienic_items_______)\n            })\n            .method(\"panic\", {\n                fn _______method_rust_y_u_no_hygienic_items_______(\n                    _: ::context::CallContext<JsUser>,\n                ) -> ::result::JsResult<::types::JsValue> {\n                    {\n                        {\n                            ::rt::begin_panic(\"User.prototype.panic\", &(\"src/lib.rs\", 89u32, 13u32))\n                        }\n                    }\n                }\n                ::macro_internal::MethodCallback(_______method_rust_y_u_no_hygienic_items_______)\n            }),\n        )\n    }\n}\n. @jjpe Can I use this directly from your fork?. @jjpe Sorry I meant to ask how. Not sure how to use it, because the only dependency in my package-lock.json is neon-cli.. Ok now I got it, the dependency has to be specified in the Cargo.toml, because from there it starts the npm install\n[patch.crates-io]\nneon-runtime = { git = 'https://github.com/jjpe/neon' }\nThis solved the compile issue!\nWould really appreciate if this gets merged.\n. Much better, but the API Link is down:\nhttps://api.neon-bindings.com/neon/index.html. ",
    "ndarilek": "I'm having a related issue I suspect. I'm trying to use a library with a fairly complex dependency chain from a Neon module. Here's my build.rs:\nhttps://gitlab.com/ndarilek/spatialite-sys/blob/master/build.rs\nYou can see there that I link to all my native dependencies with the form:\nprintln!(\"cargo:rustc-link-lib=static=spatialite\");\nDoes this mean I shouldn't use static when building this crate under Neon, so that it links correctly when built as an NPM module? Apologies if that's a silly question--using native modules from Rust is new to me.\nIf I do in fact need to use dynlib instead of static here, is it possible to detect that the crate is being compiled with Neon to swap them out? I use static because the native libraries are built from vendored sources if the main library isn't found, and part of what I want to do with this NPM module is ensure that the complex dependency chain can build and install alongside the module in an Android/iOS Cordova app. But static linking works fine for Rust-native apps, so I'd like to keep that.\nThanks.. ",
    "katyo": "Link to rust issue https://github.com/rust-lang/rust/issues/54691. I found temporary workaround.\n\nAdd init function which calls __LOAD_NEON_MODULE itself:\n\n```rust\n[no_mangle]\npub extern \"C\" fn node_addon_init() {\n    __LOAD_NEON_MODULE();\n}\nregister_module!(mut cx, {\n  // your module code\n}\n```\nThe no_mangle directive is important.\n\nFix \"install\" script in package.json:\n\njson\n\"scripts\": {\n    \"install\": \"RUSTFLAGS='-C link-arg=-Wl,-init=node_addon_init' neon build --release\",\n  },\nThis solution uses \".init\" section instead of \".ctors\"/\".init_array\".\nOf course, I tested this on linux only.\nSee https://github.com/katyo/ledb/tree/master/ledb-node. See also https://github.com/rust-lang/rust/issues/54691. ",
    "joelgallant": "This also works for me, I had issues with an in-docker build (https://github.com/joelgallant/neon/commit/7469fd1f74ecb28bfcc3bd3c4473a6e68ab58556).. Just saw #346 - @matklad could that be merged?. I'm closing this PR in favor of the other. ",
    "whaqzhzd": "Thank you for your excellent answer, very helpful to me.. ",
    "manuel2258": "Thanks a lot! Gonna look into them later, however they seem atleast up to date! Without this I probably would never learn Neon, so thanks again!. Yes, thank you!. ",
    "Connoropolous": "I figured this out\ntaking out \nia32 from os in package.json\nand switching\nexport NODIST_X64=0\nto\nexport NODIST_X64=1\n. ",
    "vaheqelyan": "Awesome. It is much better than the previous site.. ",
    "jrop": "These were a lifesaver.  Thank you so much!  Any timeline to when they will be published?. ",
    "solderjs": "Thanks. I figured I could just return a string and then handle it in JS if needed.\nI was just curious because I've been doing stuff with BigInts lately, but having it in neon isn't a need I have yet, though I imagine if I get into neon seriously I'll end up use them one way or another.. ",
    "ddibiase": "Aha, that makes a heck of a lot of sense. Hoping this gets added as the polling system imposes a dramatic perf limitation for us. I'll have to work it in for now and pray that the Neon team gets something going for it =) thanks for the great work btw.. Thanks! Appreciate it. =). Mmmmm maybe I wasn\u2019t totally clear. I\u2019d like to call start() and stop()\ndefines directly in the CustomServer struct. I don\u2019t want to touch the\nserver value directly.\nI was thinking I could declare the context then call it as a method off of\nthis? Ie this.start() but that doesn\u2019t work.. Ahhh! Ok yes sorry. I thought I tried to access it on the borrowed value but the error I saw must have been do to something else. Thanks for the clarification. I find myself overthinking things with Rust.. ",
    "kdy1": "libswc.rlib file is 5.6MB (got after running cargo build --release). ",
    "uuhan": "\nAre these exposed to native modules? It's not something I've encountered before. Is passing them in as an argument viable?\n\nI want to expose a logger to my js code and sure I can pass the __filename to my logger.\nBut that means I need to pass __filename to every of my logger like this:\njs\nconst logger = new MyLogger()\nlogger.info(__filename, 'fooooobarrrrrr')\nBut I think this can be done automaticly.. Can I get the current Module just like the ctx.global(), maybe ctx.module() ?. ",
    "alexandermccormick": "Haha, yeah that's actually exactly what I'm doing, or part of it anyway. And you are right, I shouldn't need to borrow from the Buffer. The generated keys result in a Rust struct with the keys inside, and I honestly didn't think I could have a Rust struct in a JS class. This is my first time working with two languages at once like this, I definitely have a lot more to learn when it comes to how memory is handled.\nThank you very much for helping me out with this.. ",
    "mitchhentges": "Hmm, I'm able to reproduce the problem in the example, too :thinking: \n\nnode --version: v11.9.0\nnpm --version: 6.7.0\n(holy that was a fast response! You're crazy :smile:)\n. Using nvm, I've installed node@10.11.0, but I'm still able to reproduce the issue.\nI didn't need to install Chromium locally to run electron-quick-start.\nI did a fresh clone of electron-quick-start - looks like they're still on electron@4.0.3\n|||\n--|--\nElectron | 4.0.3\nNode | 10.11.0\nChromium | N/A\nHmm :thinking: . ",
    "timurista": "@kjvalencik   \nThose steps seem to pass....\n crates/neon-runtime > cargo build   Thu Feb 14 06:34:07 2019\n    Updating crates.io index\n  Downloaded cc v1.0.29\n  Downloaded regex v1.1.0\n  Downloaded regex-syntax v0.6.5\n   Compiling memchr v2.2.0\n   Compiling regex v1.1.0\n   Compiling ucd-util v0.1.3\n   Compiling lazy_static v1.2.0\n   Compiling utf8-ranges v1.0.2\n   Compiling cc v1.0.29\n   Compiling thread_local v0.3.6\n   Compiling regex-syntax v0.6.5\n   Compiling aho-corasick v0.6.9\n   Compiling neon-runtime v0.2.0 (/Users/timurista/projects/neon/crates/neon-runtime)\n    Finished dev [unoptimized + debuginfo] target(s) in 23.40s. but sadly threading hint still fails now with the gyp NVM_NODEJS_ORG_MIRROR warning:\n```\nthreading-hint $ npm i\n\nthreading-hint@0.1.0 install /Users/timurista/projects/rust-examples/threading-hint\nneon build\n\nneon info forcing rebuild for new build settings\nneon info running cargo\n   Compiling memchr v2.2.0\n   Compiling lazy_static v1.2.0\n   Compiling ucd-util v0.1.3\n   Compiling regex v0.2.11\n   Compiling utf8-ranges v1.0.2\n   Compiling gcc v0.3.55\n   Compiling neon-build v0.2.0\n   Compiling semver-parser v0.7.0\n   Compiling cslice v0.2.0\n   Compiling thread_local v0.3.6\n   Compiling regex-syntax v0.5.6\n   Compiling neon v0.2.0\n   Compiling threading-hint v0.1.0 (/Users/timurista/projects/rust-examples/threading-hint/native)\n   Compiling semver v0.9.0\n   Compiling aho-corasick v0.6.9\n   Compiling neon-runtime v0.2.0\nerror: failed to run custom build command for neon-runtime v0.2.0\nprocess didn't exit successfully: /Users/timurista/projects/rust-examples/threading-hint/native/target/debug/build/neon-runtime-dd40f1d9beab69ba/build-script-build (exit code: 101)\n--- stdout\nSkipping node-gyp installation as part of npm install.\nup to date in 0.468s\n\n@ build-debug /Users/timurista/.cargo/registry/src/github.com-1ecc6299db9ec823/neon-runtime-0.2.0\nnode-gyp build --debug\n\nmake: Nothing to be done for `all'.\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nHOST = Some(\"x86_64-apple-darwin\")\nAR_x86_64-apple-darwin = None\nAR_x86_64_apple_darwin = None\nHOST_AR = None\nAR = None\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nrunning: \"ar\" \"crs\" \"/Users/timurista/projects/rust-examples/threading-hint/native/target/debug/build/neon-runtime-e7ed0bbd51c658b3/out/libneon.a\" \"build/Debug/obj.target/neon/src/neon.o\"\ncargo:warning=ar: build/Debug/obj.target/neon/src/neon.o: No such file or directory\nexit code: 1\n--- stderr\ngyp WARN download NVM_NODEJS_ORG_MIRROR is deprecated and will be removed in node-gyp v4, please use NODEJS_ORG_MIRROR\nthread 'main' panicked at '\nInternal error occurred: Command \"ar\" \"crs\" \"/Users/timurista/projects/rust-examples/threading-hint/native/target/debug/build/neon-runtime-e7ed0bbd51c658b3/out/libneon.a\" \"build/Debug/obj.target/neon/src/neon.o\" with args \"ar\" did not execute successfully (status code exit code: 1).\n', /Users/timurista/.cargo/registry/src/github.com-1ecc6299db9ec823/gcc-0.3.55/src/lib.rs:1672:5\nnote: Run with RUST_BACKTRACE=1 for a backtrace.\nneon ERR! cargo build failed\nError: cargo build failed\n    at Target. (/Users/timurista/projects/rust-examples/threading-hint/node_modules/neon-cli/lib/target.js:121:35)\n    at step (/Users/timurista/projects/rust-examples/threading-hint/node_modules/neon-cli/lib/target.js:32:23)\n    at Object.next (/Users/timurista/projects/rust-examples/threading-hint/node_modules/neon-cli/lib/target.js:13:53)\n    at fulfilled (/Users/timurista/projects/rust-examples/threading-hint/node_modules/neon-cli/lib/target.js:4:58)\n    at \n    at process._tickCallback (internal/process/next_tick.js:188:7)\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! threading-hint@0.1.0 install: neon build\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the threading-hint@0.1.0 install script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /Users/timurista/.npm/_logs/2019-02-14T14_38_28_505Z-debug.log\n``. @kjvalencik    thanks the problem was npm install. Needed thisnpm install --global --save neon-cli` I was missing neon.o in global node_modules. \ud83d\udc4d   . ",
    "galvez": "So I updated rustc to the latest version and one of these errors is gone. Still getting:\n```\naurelius:gateway jonas$ neon build\nneon info forcing rebuild for new build settings\nneon info running cargo\n   Compiling cslice v0.2.0\n   Compiling semver-parser v0.7.0\n   Compiling utf8-ranges v1.0.2\n   Compiling neon-build v0.2.0\n   Compiling neon v0.2.0\n   Compiling lazy_static v1.3.0\nerror: associated constants are experimental (see issue #29646)\n  --> /Users/jonas/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.3.0/src/inline_lazy.rs:20:5\n   |\n20 |     pub const INIT: Self = Lazy(Cell::new(None), ONCE_INIT);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nerror: aborting due to previous error\nerror: Could not compile lazy_static.\nBuild failed, waiting for other jobs to finish...\nerror: build failed\nneon ERR! cargo build failed\nError: cargo build failed\n    at Target. (/Users/jonas/.config/yarn/global/node_modules/neon-cli/lib/target.js:121:35)\n    at step (/Users/jonas/.config/yarn/global/node_modules/neon-cli/lib/target.js:32:23)\n    at Object.next (/Users/jonas/.config/yarn/global/node_modules/neon-cli/lib/target.js:13:53)\n    at fulfilled (/Users/jonas/.config/yarn/global/node_modules/neon-cli/lib/target.js:4:58)\n    at process.internalTickCallback (internal/process/next_tick.js:77:7)\n```\n. Turns out my Rust version wasn't really up to date.\nrustup override set 1.33.0\nDid the trick.. ",
    "steveklabnik": "never! Down with globs! :neutral_face: \n. ",
    "barrotsteindev": "Is it necessary to always use try catch?\nIt can cause a big performance hit with some callback since V8 cannot jit complile the functions in the try catch stack. https://news.ycombinator.com/item?id=3797822\nPerhaps a flag could be passed so there is a way to control this?. Please refer to my note about try catch performance.\nWould love to hear your thoughts about this issue. Sorry my bad,didn't notice the try catch was only before the callback, thanks for the answer. Anything I could do to help get this pull request accepted asap?\nI really need async support and would gladly contribute if needed. Sorry my bad,didn't notice the try catch was only before the callback, thanks for the answer. Anything I could do to help get this pull request accepted asap?\nI really need async support and would gladly contribute if needed. "
}