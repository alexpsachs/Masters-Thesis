{
    "Spasi": "This repository is a work in progress and is only useful to LWJGL developers and people that may want to contribute. LWJGL is being redesigned in 3.0 and work on it has started very recently. Details here.\nThese warnings is a known issue and are related to Kotlin, the JVM language used in the code generator.\n. Thank you Thomas.\n. Thank you Thomas.\n. Hey and thanks for your effort. This is a simple extension, all functions return void and all arguments are primitive values, so no modifiers had to be used. You didn't, so that's ok. The functionality is correct, but there are some issues with the documentation:\n- There are missing links on several tokens, for example INVALID_ENUM, MAX_DRAW_BUFFERS and others. All tokens must be linked properly.\n- There's no link on GetIntegerIndexedvEXT. You can either remove that reference completely (should be ok, it's an obvious detail and we don't need too extensive documentation), or add the link to EXTDrawBuffers2. That extension does not exist yet, but we really don't want to have to revisit this one when its added. The link should be set in place and will just work in the future.\n- Some links are broken, e.g. there's GL1.GL_BLEND_SRC (should be GL11) or GL11.GL_FUNC_SUBTRACT (should be GL14). These should be fixed.\n- You don't have to type \"must be one of\" in the parameter documentation. Something similar is added by the generator automatically.\nI'll merge this pull request when these issues are fixed. You may either clean up this one, or make a new PR with a clean commit.\nGoing forward, the easiest way to catch these issues early is to generate the documentation (ant javadoc) before committing. The javadoc tool is actually quite nice and will print warning messages for links that cannot be resolved and other common documentation errors. You can also manually inspect the generated documentation, either from your browser or your IDE (if it can do that). I use IntelliJ and it's quite helpful with highlighting javadoc issues. Directly from the source even, so I only have to use ant generate.\nThanks again!\n. Thanks! I'll make a few changes, please do check my next commit.\n. I'm using VS Express 2013 for Desktop. cl.exe prints version 18.00.30501.\nLooks like a configuration issue. Have you run vcvarsall.bat (with the correct architecture argument) before building? If that doesn't help, could you do an ant clean, then ant and post the full log again?\n. Yes, in the same session.\n. Please read this, under ant compile-native. Most likely, you need to run vcvarsall x86_amd64.\n. Do an ant clean first. The native code has already been compiled with x86 and it's trying to link it with a x64 library.\nIt's normal that x86 didn't work, because you're building with a x64 JVM. So, either use vcvarsall x86 and a x86 JVM, or vcvarsall x86_amd64 and a x64 JVM.\n. This is a known issue with the Intel OpenCL implementation. clGetContextInfo crashes instead of returning CL_INVALID_CONTEXT, if the context passed has already been released.\nI'll keep this issue open, because I'm considering a design change wrt callbacks, so that checking the reference count won't be necessary.\n. Yes.\n. A temporary fix has been implemented with e9beb2efa38d60db0243529284f2668e6c129eac, so you may try OpenCL again.\n. Work on the OpenCL binding is now complete. All unnecessary abstraction/wrappers have been removed and this issue is no longer relevant.\n. There are currently no nightly builds, so you'll need to build it manually.\n. My guess is that @dustContributor meant to post this in the LWJGL 2.x repository. There are currently no plans to implemented this in 2.x, but as you can see it's one of the primary new features in LWJGL 3.\n. You can find all files created during the build process under the top-level generated folder. The generated bindings are also tracked in this repository.\n. This is the LWJGL 3 repository, are you sure you wanted to post this issue here? The current Keyboard class in 3 is not used anywhere.\nIf this is for LWJGL 2, we cannot change the API as that would break existing programs. Though, you could easily provide in your engine a proxy class, that uses enums, and internally forwards everything to the LWJGL Keyboard class as ints.\n. It will most likely be deleted, yes.\nThe only windowing system currently supported by LWJGL 3 is GLFW, which has its own input API. You can read the documentation here. It uses numeric constants, so the question remains if we should convert those to a Java enum.\nThe main issue is that the native GLFW callback returns an int and it is not trivial to convert to the corresponding enum. You can see here that the key constants are mapped to the corresponding ASCII codes, which means a map lookup will be required to do the conversion from int to enum.\nI think I'll leave this issue open and reconsider it at a later point, but let me know what you think.\n. Thanks, I'll try to setup nightly builds soon.\n. Initial testing on Travis CI looks promising, at least for Linux and OS X. Need to figure out a solution for Windows builds (any recommendations?) and for artifact deployment (also for the GLFW and libFFI dependencies).\n. Windows builds and artifact deployment have been resolved, nightly builds will soon be available.\n. Nightly build are now available. Details here.\n. Thanks, this was helpful, but I'll close this PR because we need a cross-platform solution. Until Travis (or another provider) offers a CI process for all 3 major platforms, I'll keep any build infrastructure outside the main repo. Will update #14 when I have more info.\n. Yes, building with gradle would be interesting. Let me know if you still have trouble with the Generator. If you got it to compile, then it's a simple Java application, see the \"generate\" Ant target.\n. I understand the src/main/java thing is the Maven convention (over configuration), but it's not really compatible with how this project is set up. Especially, if you consider the generated code that's written in a different folder hierarchy (and I'd like to keep it this way).\nI believe you can break the convention and configure everything manually in Gradle.\n. Thanks, I didn't know that feature. I didn't have to move the generated code though, just marked the root as generated. Noticed that IDEA disables inspections for the generated classes, do you know if it affects anything else?\n. The PointerBuffer dependency is resolved with classpath += \"src/templates\" in config/Templates.ktm. You should make sure that kotlinc is configured with Templates.ktm, because in the future it will be used for filtering the supported bindings. You'll be able to do custom builds, for example without OpenCL or with only the core OpenGL functionality, filter out old/obsolete extensions, etc.\n. I've been following this issue and porting the Ant scripts to Gradle is still something I'd like to do. I've been struggling with Ant, especially with non-trivial stuff like the modular build. The scripts have become hard to understand and maintain, we need something better.\nWith that said, time for LWJGL development has been limited lately and my main focus is getting the 3.0a released. Once that's done, I'll have time to get comfortable with Gradle and start the porting process. The work you guys have done so far will obviously be a big help, but I don't have the Gradle experience atm to evaluate it (or help with issues).\n. I will of course also consider changing the source layout, as required by Gradle.\n. I didn't want to waste any more time, so did the 3.0.0a release yesterday. Today I started working on the Gradle build, using @dhild's script as reference, but writing everything from scratch. I'd like to take the time to understand every little detail, to avoid wasting time later when I'll have to maintain it. Using Gradle 2.4-rc-1 for the parallel native compilation, LWJGL has tons of native files and I personally can't work without parallel builds.\nFrom the reading I've done, it looks like the best approach would be to refactor the existing modules (templates, generated, core, util) as Gradle (sub)projects. Would that be a good idea?\nAlso, I'd like to keep the project root clean. All modules, except generated, are currently in /src. Would it be a problem if I made a /modules folder and put all sub-projects under there? Or do they really have to be directly under the root project?\n. I have just pushed the gradle branch. For now, the only changes are the new folder structure and the updated Ant scripts & IDEA project. Also clarified terminology a bit; the old \"binding modules\" are now just the \"bindings\" and \"modules\" are the compilation modules (as understood in Gradle or IDEA).\nI would really appreciate any comments or suggestions on the new folder structure. It's a bit painful to refactor, so I'd like to make sure I get it right before pushing to master. If anyone has time to review the changes, please do let me know if you can think of any improvements.\nI'll try to add the actual gradle scripts soon.\n. > Complete failure on the compile-templates over a Java Stack Heap issue.\nI've only seen kotlinc failing when there is not enough memory available. Could you post more details about the error you're seeing?\n\nHas anyone considered using Kotlin to create the Gradle build script.\n\nI've been waiting for two features: a) incremental Kotlin compilation in Gradle builds and b) mature build.gradle.kts support. The former has been available for some time, the latter is getting there.\nThis remains a low priority issue though. The project won't gain anything from moving to Gradle and there are more pressing matters (e.g. ARM/Android support).. > From running compile-templates\n\n...\nCaused by: java.lang.OutOfMemoryError: Java heap space\n\nTry set ANT_OPTS=-Xmx1G before running ant. Or use a 64bit JVM.. > I got a bunch of errors like these\nIs the JAVA_HOME environment variable set to the JDK 8 folder?\n\nbut I'm missing the lwjgl.dll file\n\nNative compilation happens with ant compile-native or (demo or tests that depend on it). You'll need  Visual Studio Community and a properly configured toolchain (usually running vcvarsall amd64_x86 is all you need).. Gradle 5 has been released and the Kotlin DSL is now considered production-ready. The LWJGL codebase structure has also stabilized, so now is a good time to attempt a migration to Gradle.. > There are circular dependencies between templates of some modules (e.g. OpenGL and OpenCL)\nThe cycle is now broken with 7657b20bd19e9e2cf0ecccc571baec37c9c22786. There are still one-way dependencies between modules (e.g. GLFW depends on the EGL, GL and Vulkan modules), but that shouldn't be a problem, right?. Work on the OpenCL binding is now complete. All unnecessary abstraction/wrappers have been removed and this issue is no longer relevant.\n. There is no utility package currently in LWJGL 3. For now, you can use the code from 2 (gluPerspective is here), or you can use lwjgl_util.jar from 2. I haven't tried it, but GLU should work just fine with 3.\n. The utility package is not a priority for 3.0, but in any case it won't have the same functionality as the old one.\nBtw, you may want to read this thread from another user that was asking about GLU.\n. You need to setup a WindowCallback. See the GLFW Events demo, it has everything you need.\nNote, this is different from the GLFW way of setting up a different callback function per event type. It is done this way for technical reasons (related to Java's JNI). There will be an attempt to improve this before 3.0 is released, but in any case, it will be documented properly when the time is right.\n. Yes, it's the scroll(long window, double xoffset, double yoffset) method.\n. The correct call is glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED), see the documentation.\n. Hey @saudet,\nI had a look at JavaCPP; it is very similar to the old generator in LWJGL 2.x. It has the obvious advantage of being pure Java, but shares the same disadvantages. Mainly, no type safety when writing the templates and being overly verbose, i.e. error-prone and time-consuming to write manually.\nOn the other hand, using a parser eliminates these disadvantages. Are all templates in javacpp-presets auto-generated? Does your parser also transfer documentation from headers (when it can)?\nCould you link some examples of how JavaCPP handles templates and other complex C++ features?\n. > so there is some type safety. Could you provide an example where it wouldn't work?\nIt's important when writing the interfaces by hand. It's a pain having to write the same annotations over and over again and frustratingly easy to make mistakes (that was my experience anyway). The LWJGL 3 generator allows you to define the native type mapping once and reuse it many times. This is of course a non-issue if you auto-generate everything.\nWe haven't bothered with header parsing in LWJGL, because of the focus on OpenAL/CL/GL bindings; there aren't any headers to parse for many extensions. It might be worth considering for other APIs though.\n\nIt seems like the best we can do is to let the user declare what they use. In the case of Thrust for example:\nhttps://github.com/bytedeco/javacpp/wiki/Interface-Thrust-and-CUDA\nWould you see a better alternative?\n\nThis is fine if you expect the end-user to go through the JavaCPP process directly. LWJGL provides ready-to-use bindings, so the same approach cannot work. It's not economical to instantiate all possible template types offline either.\n. The main problem is incompatibility with respect to pointer arguments.\nJavaCPP generates methods with Java array arguments and Pointer arguments, in addition to NIO buffer arguments.\nLWJGL uses NIO buffers exclusively (and longs in unsafe methods). It generates additional methods with String/CharSequence arguments or return values, where applicable. It generates convenient methods that accept or return a single value (e.g. glGetInteger). It generates generic and custom runtime checks (optionally enabled or disabled). And more advanced stuff that would take a lot of work to support (mapped pointers, extension dependencies, function address reuse, deprecations, etc).\nIs there a repository that includes the native code JavaCPP generates?\n. > one might want to use them on Android, for example, where NIO buffers are inefficient. Instead, users might want to use a helper class like Pointer to copy data between native memory and the Java heap -- for better performance.\nI don't see how using JNI calls without intrinsics won't result in bad performance.\n\nI'm pretty sure JavaCPP could be useful in one way or another for everything you list up there. I'm still trying to figure out what could be a \"deal breaker\"...\n\nDynamic loading. This could be simple to support, assuming LWJGL does all the hard work and you only add an extra \"function pointer\" argument to the generated functions.\n\nThe generated C++ code isn't useful for users as reference, so I don't put it anywhere. It gets generated at build time when executing mvn install, so it can still easily be referenced by developers.\n\nIt's useful to me as an LWJGL developer. The exact semantics are important (i.e. do you use GetDirectBufferAddress directly or respect the current buffer .position()?), performance is important, the native code size is important. LWJGL 3 has been written such that the generated native code is extremely simple, anything non-trivial is done Java-side. Having no special requirements from native code should (in theory) enable us to use whatever comes out of Project Panama with minimal effort.\nIn the end, the generated native code + native Java method is the simplest part of the LWJGL generator, replacing it with a 3rd-party solution basically gains us nothing. If we do support C++, it should still be simpler to do something custom in LWJGL. I don't think we can reasonably support libraries with user-customizable template types; that's a good reason for users to go to JavaCPP and I wouldn't mind recommending it for such use-cases.\n. > It works fast when copying large enough arrays with memcpy() between Get/ReleasePrimitiveArrayCritical() calls. JNI intrinsics and method inlining are surprisingly inefficient on Android. There's no point in considering Buffer.get()/set() for pretty much anything on that platform: https://code.google.com/p/javacpp/issues/detail?id=11\nA ton of overhead then. LWJGL does not support Java arrays for this reason. Also, there are no plans to support Android. (we do support ARM with a normal Open/OracleJDK though)\n\nHow have you been considering adding support for C++ to LWJGL?\n\nI haven't really. This issue exists just to acknowledge the fact that useful C++ libraries exist and we could maybe do something about it. That doesn't mean we will, unless the solution is decent feature- and performance-wise. It's perfectly OK if users have to use a 3rd party library, if we can't offer C++ bindings.\n\nAnyone can easily have a look at the generated source code by running one of the small samples here:\nhttps://github.com/bytedeco/javacpp#key-use-cases\nI use GetDirectBufferAddress() directly because JNI does not provide an efficient way to query the position or the limit. Again, we can use Pointer for that. There's a lot of other use cases that Buffer does not support. Would you like to have a list of all that I can think of?\n\nJust had a look at the generated native code and there are many JNI calls in there. Instead of passing jobject arguments, you could very easily do the pointer math Java-side (address+position) and pass a jlong directly, like LWJGL does. For non-array access anyway, arrays need GetPrimitiveArrayCritical.\n\nI see that you try to avoid JNI and native code as much as possible. But this has drawbacks too. For example, it forces users to generate both Java code and C/C++ code. It does not allow them to write in Java directly some custom interface they might want to use, and provide documentation comments as they wish. That does not appear possible with the generator of LWJGL, or am I mistaken?\n\nNot sure what you mean. Of course both Java and C code must be generated, JNI requires that.\nThe LWJGL generator is an offline process used when building LWJGL. It's different from JavaCPP, you cannot use the LWJGL artifacts to generate your own bindings. You can of course clone LWJGL and write a custom template for an API that LWJGL doesn't support out of the box, with custom comments, etc.\n\nBTW, I wouldn't count on Project Panana producing anything usable for C++. Although it appears promising for C functions, basically P/Invoke for Java, they are not considering what to do in the case of C++ classes. So, if your plan is to use Panama for C libraries, but JNI for C++ libraries, I'm afraid you would be breaking your rule of simplicity.\n\nAfaict, Panama will support C++ just fine. Why do you think it won't?\n\nMyself, I'd rather use JNI: It works, it's fast, it's portable, and can be used with any native language.\n\nIt's neither fast, nor \"portable\".\nWith Panama, native calls will be \"visible\" to Hotspot. The JIT will be able to inline all the way to the native call and that means zero-overhead + heavy optimization potential.\nWith JNI you must deploy native binaries for all target OSes/architectures. With Panama, you won't have to deploy anything, it will work everywhere automatically.\n\nAnother thing. LWJGL does not seem to provide good support for Maven. We have to add manually plugins to unpack native libraries. Do you have any plans to fix that? That's something else JavaCPP currently provides, so you could check that out for ideas.\n\nFor Maven/Gradle, see this example project.\nAlso note that the official downloads do not have packed native binaries.\n. > Just for my information, do you consider something like JavaCPP to be not \"decent\"?\nOf course it's decent, that's what I mean by \"3rd-party libraries\". But I already explained why it can't be used with LWJGL.\n\nNo, we cannot, not always. For example, how do you get the address of a direct NIO buffer in Java? AFAIK, it's only available through JNI.\n\nUsing reflection or Unsafe. This is what LWJGL does.\n\nYes, that's what I meant. This forces users to write all their code in Java.\n\nYes, writing everything in Java is an explicit goal of LWJGL 3. Which is what makes it future-proof for when Panama is available.\n\nYou do not offer them an option to rewrite their bottlenecks in C/C++, effectively forcing them to write JNI code themselves in those cases.\n\nWhat's the problem here? If someone has the capability to write custom C/C++ code, writing the JNI glue code should be a joke. LWJGL is targeted to people that don't know or don't want to write and build any native code.\n\nBecause everytime I bring up topics related to C++ on the mailing list, I get blank stares.\nSure, like I said, that's great for C APIs. It's basically P/Invoke for Java -- but it doesn't work with C++.\n\nI don't know, Oracle is not very eager to share details in general, especially so early in the development process of a JEP. Keep in mind that Panama is targeted for Java 10 at best. I personally haven't read anything that would suggest C++ won't be supported.\n\nJNI works fine on Android, for example. Couldn't say the same of Panama. And why do you say it's not fast? Do you have some numbers to back this up?\n\nSee http://www.oracle.com/technetwork/java/jvmls2013nutter-2013526.pdf, page 62. There is a difference of course between fast and fast enough. JNI is fast enough for LWJGL to exist and be used since 2002. That's not the point. Any raw JNI overhead test will show a substantial, but probably low enough overhead over the corresponding C code. Who would want to call getpid a million times anyway. But that hides all the nastiness around it. JNI calls force instruction level serialization, force GC safepoints, cause extra cache polution (arguments are copied around). You can't easily objectify the additional effects this has on the surrounding code. It's overhead that's going away with Panama.\n\nSo you rely on badlogic to provide decent Maven support, I see. So, to answer my question, you are satisfied with this?\n\nI have more important priorities at the moment and Maven/Gradle deployment is adequately explained in the getting started guide. LWJGL 3 is in pre-beta state and I haven't had the time to properly evaluate badlogic's SharedLibraryLoader yet. It's very likely that it will be included in the final 3.0 release.\n. > Ok, thanks. I guess time will tell who is right :)\nRight about what? I don't know how many different times I have to explain this. LWJGL does not compete with JavaCPP. LWJGL provides premade bindings to specific libraries, JavaCPP is used by people that want to create their own bindings. The LWJGL code generator is not exposed outside the build process.\n\nBut that makes it as inefficient as JNI while making it less portable in the process. What was the reason to not use the provided JNI function in this case?\n\nAgain, you're making me repeat myself. A few reasons:\n- It requires passing a Java object to native code. This is not necessarily bad and has no immediate benefit in current JVMs. But as I said, LWJGL 3 has a forward-looking design. You need to think about what the JVM can or cannot assume about what happens in the native code. If you pass a Java object down to native code, all bets are off. It has GC and synchronization implications, fields may be accessed, methods called, exceptions thrown. It's why all JNI calls require safepoints. A \"pure\" native call (a call the only accepts/returns plain values and never uses JNI functions) has no such complications and I have the feeling that Panama will be able to fully optimize/inline only such calls.\n- GetDirectBufferAddress returns the base buffer address. All LWJGL APIs use the current position(), by design. This requires passing an extra parameter or calling position() from native code. LWJGL 3 does all pointer arithmetic in Java code and the JNI code is very light.\n- It's faster. I don't know why you think it's as inefficient as GetDirectBufferAddress.\n- LWJGL has fallbacks for all Unsafe usages when it is not available.\n\nWell, for example, if we want an application to run on Windows, Linux, Mac, Android, etc, JNI offers no tools to help us compile C++ code or manage the native libraries produced on multiple platforms. Someone who is knowledgeable in Linux does not necessarily know all the details of Windows, or vice versa. JavaCPP offers a solution to that. JNI by itself, or Panama for that matter, will not.\n\nWhat are you talking about? JNI is a cross-platform API but does one specific thing. It has nothing to do with building the native libraries and I don't think JavaCPP does anything to help with that either. JavaCPP generates the (cross-platform) bindings, building the libraries themselves is an entirely different problem and it still requires users to have a working compiler on their machines.\nUnless you're talking about JavaCPP Presets?\n\nThe fact that the foundation of Panama is basically LLVM, and its support for MSVC is still nowhere near usable http://clang.llvm.org/docs/MSVCCompatibility.html pretty much makes it unusable on the Windows platform. And I don't see Oracle bundling MSVC with Java... Or do you believe Oracle will ship their own C++ toolchain compatible with GCC, Clang, and MSVC? Or maybe there's something weirder going on in the background with Microsoft adopting Clang, and by the time Java 10 comes out...\n\nThis makes no sense whatsoever. You've probably misunderstood what Panama does and you're jumping to conclusions about a project that still at its infancy. The only way Panama deals with native code outside the JVM is for parsing headers. I don't know why you think it has to be compatible with one compiler or the other. It doesn't use a compiler to compile anything, the code for native methods will be generated at runtime (JIT).\n\nYes, that's nice and everything for C, but there is nothing nowhere that shows something that works for C++! You agree that JNI's performance is acceptable, and it works with C++, and it's portable, so unless we get something that's an order of magnitude better, why switch? I would very much like for someone to provide a couple of clues about how something like Panama could work for C++.\n\nDo you even realize that there's nothing special (wrt JNI) about C++ compared to C, other than the implicit this pointer? Anything that applies to a given C call, applies equally to C++. The real problem with C++ is the high-level binding. Features like templates need special handling and decisions that a library like LWJGL cannot easily make. It has to be decided by the end-user, that's why libraries like SWIG/JavaCPP are useful. LWJGL makes the tradeoff of not requiring any expertise from the user. A JavaCPP user has to know C++ and has to compile their own native libraries.\nI don't know what C++ bindings will look like with Panama, it's not ready yet. But C bindings are already mapped to Java interfaces and I imagine it will be something similar with C++. Generics specialization is also coming to Java 10+, it might be used for C++ templates, who knows.\n\nIs it that, when it comes to JNI, you are satisfied with SWIG? It does not even support native NIO buffers, so that's probably not the case... So, what's the plan? Panama? I guess we'll have to wait a couple of years and see who guessed right. :)\n\nAs I said, I'm not satisfied with anything that requires users compiling native code.\n. I think you're underestimating what a major pita it is for most users to handle native compilation and cross-platform support.\nOn C++, the only reason I think Panama will support C++ is because it says so on the project description. Even if it ends up being C only, it's still going to be immensely useful, just like LWJGL is useful without C++ support.\nOn Android, I never said I don't care for it or that it's not a major platform worth planning for. I just said the current LWJGL implementation does not support it. LWJGL will not move to Panama overnight either. It will be a fork that works on Java 9/10+ and the original library will be supported until it's useful to do so. In the same way, one could do a fork for Android right now, with the same bindings but with a different code generation strategy that makes sense for Android.\n. > And we can produce such a function at a higher level very easily with JavaCPP:\n\nhttp://stackoverflow.com/a/10809123/523744\nSee, we do not need to mess with JNI (or Unsafe for that matter) manually to obtain the best possible performance!\n\nI'm not sure how that is relevant to the discussion. Nevermind the fact that it's a pointless benchmark and you aren't comparing apples-to-apples; compile the C version without fast fp math and it's slower than Java.\n\nBTW, if someone is really interested in optimizing their code, they wouldn't use Field.getLong() either. They would cache the address in native memory somewhere, and I've confirmed that this drops the call time of an empty JNI function to 13 ns on my machine. [...] So, I'm not sure I understand the reasons for avoiding the use of GetDirectBufferAddress(). Do you know of a concrete use case where it would be impossible to cache the address in native memory?\n\nI'm not entirely sure what you mean by caching the native address. If you're talking about using GetDirectBufferAddress once, then reusing the address in multiple other calls, this is done transparently by the JIT compiler with the LWJGL approach. This is confirmed and works perfectly.\nFor another (pretty much amazing imho) example of where the LWJGL approach shines, follow this discussion and read carefully my replies here and here. This cannot be done, by definition, if you pass objects in and out of JNI calls.\n\nI still don't understand what the pushback is all about. In your case, it seems to be about trusting Oracle's vaporware more than something that works right now. So I guess it's all about trust, but if you have any technical comments that would help the discussion move forward, please do let me know. Thanks!\n\nI've already explained why, multiple times. And there's no pushback whatsoever. I've already said that I'm perfectly happy to recommend JavaCPP to anyone needing C++ interop. Like @httpdigest above, I sincerely hope JavaCPP works well for him.\n\nSure, there are a lot of useful libraries written in C out there, but... What was the reason you created this thread for anyway?\n\nTo explore viable solutions for a nice to have feature. C++ support is not a showstopper for LWJGL.\n\nSo, if I understand correctly, you meant to say that for now Android isn't your priority, but eventually, just like Panama, it might?\n\nThis is open source. LWJGL has a tiny amount of code that works great on Windows/Linux/OSX. If anyone interested in Android wants to put some effort to adapt that code to work nicely on there, they can fork the project and make it happen easily. The majority of the code can be reused. It will be hard to simply contribute to the main project because, afaik, decent Android support will require API changes (e.g. not using NIO buffers).\nI'm not even qualified to talk about Android. I have never owned an Android device or programmed an Android application. On a personal level, my opinion is that running a VM on such resource constrained devices is a bad idea. Especially the horrible JVM Android has. This is true today and will stay true in a few years when the devices will be many times more powerful. I don't want my battery being drained for JIT compilation. If I ever were to create a mobile app, I would go native or use AOT compilation.\n. > I'm looking at your framework and your posts, but I still don't understand how you're doing automatic caching for user allocated buffers. Let's think of a simple use case. The user allocates a buffer using ByteBuffer.allocate() or ByteBuffer.allocateDirect() -- we do not know which one. How does your framework handle this case? If we happen to be dealing with a direct one, how does the address gets cached across multiple random function calls to your API?\nI'm guessing you didn't look too carefully. :) Otherwise you'd know LWJGL does not support on-heap buffers.\nOn caching, you asked the same question above and I replied that it is handled transparently by the JIT compiler. For example if you have a loop like:\nByteBuffer buffer = ByteBuffer.allocateDirect(len).order(ByteOrder.nativeOrder());\nfor ( int i = 0; i < 1000; i++ ) {\n    myNativeMethod(..., buffer);\n}\nIf myNativeMethod was a standard JNI method, then you'd have to pass the buffer 1000 times to native code and invoke GetDirectBufferAddress() 1000 times.\nWith the LWJGL approach, myNativeMethod is a normal Java method that retrieves the buffer address and passes it to the real JNI method as a long. You might be thinking that it's basically the same thing, but it's not. After inlining the JIT compiler will hoist the address lookup outside the loop, so you'd only be doing it once.\nI hope it's clear now why this is more efficient and doesn't require any special treatment from LWJGL.\n. Your test has no warm-up, it performs long operations that are not optimized very well by hotspot and, well, you aren't testing what we're discussing here. A better test:\n``` java\nprivate static native void blackholeJNI(ByteBuffer buffer);\nprivate static native void blackholeJava(long address);\nprivate static void benchJNI(ByteBuffer buf) {\n    for ( int i = 0; i < 100000; i++ )\n        blackholeJNI(buf);\n}\nprivate static void benchJava(ByteBuffer buf) {\n    for ( int i = 0; i < 100000; i++ )\n        blackholeJava(memAddress(buf));\n}\npublic static void main(String[] args) throws Exception {\n    ByteBuffer buf = ByteBuffer.allocateDirect(1000000);\n// warmup\nfor ( int i = 0; i < 100; i++ )\n    benchJNI(buf);\n// measure\nlong jni = System.nanoTime();\nfor ( int i = 0; i < 1000; i++ )\n    benchJNI(buf);\njni = System.nanoTime() - jni;\n\nSystem.out.println(\" jni: \" + jni);\n\n// warmup\nfor ( int i = 0; i < 100; i++ )\n    benchJava(buf);\n// measure\nlong java = System.nanoTime();\nfor ( int i = 0; i < 1000; i++ )\n    benchJava(buf);\njava = System.nanoTime() - java;\n\nSystem.out.println(\"java: \" + java);\n\n}\n```\nwhere the blackhole functions are:\n``` c\nstatic void* blackhole;\nJNIEXPORT void JNICALL Java_MyClass_blackholeJNI(JNIEnv env, jclass clazz, jobject buffer) {\n    blackhole = (env)->GetDirectBufferAddress(env, buffer);\n}\nJNIEXPORT void JNICALL Java_MyClass_blackholeJava(JNIEnv env, jclass clazz, jlong address) {\n    blackhole = (void)(intptr_t)address;\n}\n```\nand memAddress is the LWJGL method that retrieves the buffer address. It is implemented with either Unsafe or reflection. Results on my machine:\njni: 2687477150\njava:  801049300 (memAddress, unsafe)\njava:  768540411 (memAddress0, unsafe)\njava:  802753758 (memAddress, reflection)\njava:  773348792 (memAddress0, reflection)\nThe memAddress0 method is equivalent to GetDirectBufferAddress, i.e. it returns the raw buffer address. The memAddress method also adds the current buffer position (the default in LWJGL).\nIf you want to be absolutely certain, I would encourage you to use JMH (micro-benchmarking done properly, helps avoid common pitfalls) and JITWatch with -XX:+PrintAssembly enabled.\n. Right, the reflection path in LWJGL uses this for the address field:\nreturn ((sun.nio.ch.DirectBuffer)buffer).address();\nUsing Field.getLong is much harder for hotspot to optimize. It can still be faster, for example in my test it's only 7% slower than .address(). Hotspot can still produce a very efficient inner loop, though the JITed code explodes in total size (~2.5x the instruction count).\nAnyway, I don't think all this is very interesting:\n- As I said the fast path in LWJGL uses Unsafe, which will be replaced with VarHandles for compatibility (when available).\n- Using the address value in arbitrary math operations is an unrealistic way to test hotspot optimizations. The only realistic and useful thing to do is compare it with JNI's GetDirectBufferAddress, which is what we have been discussing above.\n- Even with reflection and sub-optimal JIT, I don't expect it to be slower than GetDirectBufferAddress. If you are able to identify such a case, I'd be interested to know. But for our users... we have Unsafe, so who cares.\nAnd even if we ignore all the above, there's still the escape analysis benefit that is simply thrown away when you pass a Buffer object to JNI code.\n. > sun.nio.ch.DirectBuffer -> That's not going to work on Android. And good luck with Google ever supporting VarHandles.\nHonestly, it feels like I'm talking to a wall. You reply 2 weeks later, only to state the obvious. I've already stated that Android support would require a different strategy altogether.\n\nWhat I'm interested in understanding, is why you feel there is never any advantage in using some custom class like Pointer over Buffer.\n\nI never said that. LWJGL already has custom classes for \"typed pointers\". All callback and struct classes are basically pointer wrappers.\nBut if you're going to be accessing arbitrary/untyped data, then Java already provides a pointer abstraction with the NIO buffers. There's no need to invent a new one and reduce possible interop with other APIs.\n\nSo, for example, about Unsafe, let's assume some of your users are interested in passing to LWJGL a buffer that was allocated with CUDA, and they figured they need to optimize that. How would Unsafe help them?\n\nEverything I said about GetDirectBufferAddress() applies to NewDirectByteBuffer(). LWJGL uses Unsafe to create buffer instances from an arbitrary address & capacity, without going into JNI.\n\nI'm just curious about how that would work, because AFAIK, we can't use Unsafe for memory that was allocated by some other means. Or am I missing something?\n\nYes you are, Unsafe can be used to access both on-heap and off-heap memory and it doesn't matter who (or how) allocated the off-heap memory. If it couldn't do that, stuff like glMapBuffer wouldn't be usable in Java.\n. > Unsafe isn't part of Java SE, so what I'm trying to understand has in fact nothing to do with Android. For example, are you testing LWJGL with IBM JDK and Excelsior JET as well, just to name a few other popular implementations of the JVM? It seems that you are, but why? And why not, for example, Android or RoboVM, for that matter? How do you determine the value that you place on \"Java\" as a standard if not through Java SE?\nI'm afraid I don't have time to test other JVM implementations atm. I'm 100% focused on delivering LWJGL 3 soon, for the platforms that 99% of LWJGL 2 users care about: desktop Windows, Linux and OS X with the Oracle JVM or OpenJDK. LWJGL 3 comes with binaries for these platforms only and doesn't claim to run on anything else.\nHopefully it does run on other JVMs but I haven't tried any and wouldn't be surprised if there are a few minor issues. Besides correct execution, there's also the question of performance, which requires testing too.\nOther than requirements that come up in my personal projects, LWJGL development is driven by what users of the library ask with Github issues/PRs or posts on the forum. So far there haven't been any complains about other JVMs.\nOn Unsafe, Oracle's current plan is to keep it public until at least Java 10. By then, we'll have Variable Handles and Panama, so a future version of LWJGL (4?) will not use Unsafe for anything. There's plenty of time until then though. Remember that LWJGL 3 runs even on Java 6.\n\nI know from experience that releasing GPU resources in a deterministic manner is very important, but NIO buffers offer no way to use the try-with-resources statement, which is surprising given that Oracle/Sun places so much emphasis on it, for example: http://www.oracle.com/technetwork/articles/java/trywithresources-401775.html . What is your opinion on this subject?\n\nI don't think it's interesting for GPU resources. You usually create your resources at the start (e.g. when loading a new level), use them for a long time, then destroy them at the end. Try-with-resources is only useful for short-lived resources.\n. Notes on Project Panama C++ bindings, by John Rose.\n. The problem seems to be in the com.jediminer543.util.display.Display class, the method getWindowID does this:\nreturn windowID = -1L;\nYou're assigning -1L to windowID and you are returning that, hence overriding the ID that was returned from glfwCreateWindow.\nI also noticed a few other issues in your code:\n- You can pass a String directly to the glfwCreateWindow title. You don't have to wrap it with CharBuffer.wrap(title). Any class implementing CharSequence will work (String does).\n- if (display.getWindowID() > Integer.MAX_VALUE) this check is pointless. glfwCreateWindow returns a pointer to an opaque data structure, you can't do anything meaningful with it, except pass it to other GLFW functions.\n- In the Display class constructors you're passing (Long) null to a primitive long parameter. This will auto-unbox and fail with a NPE at runtime.\n. Thank you for this pull request, but the issue has been resolved manually, with 7f286c7b2fdbcbd9ff7eef496e9b9e9889466861. The fix was simpler, just replaced println with print. Also added a private target to avoid seeing the warning more than once.\nOn indentation, I wouldn't accept the change from tabs to spaces. It's unfortunate that tabs in Github are so long, but all editors have a configurable tab size. For reference, the LWJGL codebase has been written with a tab size equal to 4 spaces.\n. Resolved with 3da42a9976b12176270d50dba917aa9dd77678fa. The Callbacks class contains methods that make it straightforward to handle drop callbacks.\n. This is planned for the official 3.0 release, but not earlier.\n. The release is 3.0a, not the final 3.0 release, which is what I meant above. With that said, I plan to do this earlier, possibly before 3.0b. Right now I'm working on porting the LWJGL build to Gradle, will look into maven deployment after that.\n. LWJGL 3 is now on Central, use org.lwjgl:lwjgl:3.0.0a.\nNightly builds are also published as snapshots, use version 3.0.0b-SNAPSHOT and the https://oss.sonatype.org/content/repositories/snapshots repository url.\nSee the demo project for more information.\n. Could you please post the JVM launch arguments and the full output of your program?\n. That's very weird. The file extracts fine for me (Windows 8.1 Pro x64). Do you see the same problem with other files (e.g. the x64 lwjgl.dll)? Have you tried extracting to a different folder?\n. Comments have been added with LWJGL/lwjgl3-www@9c848687611ab36275c9eec45fc9ede5df48b17b\n. Thanks, I'm seeing the same warning on Travis.\n. The codebase is Java 6 compatible, but I'm also building on Java 7 on OS X, for the same reason. Don't worry about it, unless you need to contribute something and worry about using a Java 7+ API.\n. The warning is emitted because _ffi_call_unix64 is hand-coded assembly and it isn't compatible with compact unwind. I have disabled compact unwind until the issue is fixed in libFFI. I don't think this will affect us in any way.\nI've also fixed the build to work out of the box on OS X with JDK 6, with e871deaeffddf78e2cad6572da7d94cdf81ed89d. Thanks @virtuoushub!\n. LWJGL is not yet able to create C++ bindings. Especially to libraries that are template heavy like GLM.\nNative math libraries in general will suffer from JNI overhead (too many calls, doing too little work) and don't offer much over what you can do in Java. A solution like JOML is a better option.\n. There doesn't seem to be anything odd about your account. Have you tried using a different browser or different machine?\nI could delete your account and you can register again, if you'd like to try that.\n. OK, deleted.\n. The roadmap has been updated.\n. It would be helpful if you could post the C code you used and also the LWJGL tests output. The tests report is written in /generated/tests.\n. Could you please try a test that just does glfwInit(), glfwCreateWindow() and glfwTerminate()? Nothing else. Also, try running it with -Dorg.lwjgl.util.Debug=true, see if that prints anything interesting.\n. Hmm, then GLFW 3.1 is most likely the problem. There's literally nothing LWJGL does with that simplified test, it's direct JNI calls to GLFW. Any chance you could build GLFW 3.1 from source and try again with your C code, just to confirm?\n. Here's what I use:\nmkdir BUILD\ncd BUILD\ncmake ..\nmake\nYou'll find the binaries in BUILD/src/.\n. Yup, looks like you did it properly. Well, that's good news I guess, we've verified that it's a GLFW issue. The next step would be opening an issue with GLFW. It will help if you share the C code you used for testing, any details about your environment (OS, GPU, drivers, etc) and that 3.0.4 works correctly.\n. I don't see how that code could possibly work with LWJGL 2. You're trying to draw 400 * 240 BGRA pixels, which is 400 * 240 * 4 bytes, but you're only allocating a buffer with 400 * 240 bytes. The segfault is caused by the OpenGL driver trying to read data outside the pixelBuffer bounds.\nAlso:\n- A rewind or flip is not necessary after an LWJGL call. The current position & limit of buffer arguments are never modified by LWJGL.\n- You should use BufferUtils for allocating buffers. In the code above, you're allocating a direct IntBuffer without setting the native ByteOrder and you're also mixing direct and heap buffers. This will cause bugs on machines with different endianness and has performance implications.\n. Have you checked the GL_SHADING_LANGUAGE_VERSION supported by your GPU driver?\n. You have to explicitly request a 3.2 core context when creating the GLFW window.\nc\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\n. It is a known issue, see this thread. I'm afraid I have not been able to reproduce this locally, so can't offer a solution yet.\nDoes your machine have an Nvidia GPU?\n. Thanks for the information, it's very helpful.\nNote that GL.getFunctionProvider().getFunctionAddress(\"glXGetCurrentDisplay\") does not return a Display handle. It is the function address of glXGetCurrentDisplay in libGL.so. The code nglXGetCurrentDisplay(glXGetCurrentDisplay) invokes the functions and NULL is returned.\nSo, basically, what's happening is that LWJGL opens the MESA libGL instead of the one provided by the nVidia driver. That's why glXGetCurrentDisplay returns NULL, the MESA library doesn't know anything about the connection opened by GLFW (which presumably uses the nVidia libGL). Now the question is, why LWJGL and GLFW load different libraries, when they both use the same code: dlopen(\"libGL.so\", RTLD_LAZY | RTLD_GLOBAL)\nIf you're willing to investigate this further, you could try the following:\n- Install libgl1-mesa-dev again.\n- Locate the full paths to the libGL.so files (the MESA and NV ones).\n- Use -Dorg.lwjgl.opengl.libname= to specify which one to load. Make sure to use an absolute path.\nWhat results do you get?\n. Hmm, looking at this again, GLFW loads \"libGL.so.1\" directly, whereas LWJGL first tries \"libGL.so\" and if that fails loads \"libGL.so.1\". Could you check if there's a libGL.so symlink that points to the MESA implementation, but libGL.so.1 points to the NV one?\n. I'm interested in the symlinks that are in the system library path, i.e. the paths used by dlopen. Search for libGL.so* in /usr/lib (and /usr/lib32, /usr/lib64, depending on the system) and see where those point at.\n. I was able to reproduce this by re-installing the nVidia drivers (after libgl1-mesa-dev had already been installed). What happens is that the mesa paths are above the nvidia paths in /etc/ld.so.conf.d/*.conf. So, when loading libGL.so, the mesa implementation is found first and we get the error.\nThe fix (for my system at least) was to use libGL.so.1 instead of libGL.so. There is no .1 symlink for the mesa implementation, so the nvidia implementation is chosen instead. Even if there was, at least now GLFW and LWJGL will always open the same library, so this will not be an issue anymore.\nThanks again for helping out.\n. You cannot use the x86 library with a x64 JVM and vice versa.\n. The docs say:\n\nGL_INVALID_OPERATION is generated by glEnableVertexArrayAttrib and\nglDisableVertexArrayAttrib if vaobj is not the name of an existing vertex array object.\n\nIf what you're saying is true, then it must be a driver bug. LWJGL does nothing special when you call that method.\nThere are several problems with the SDK reference links, including the one you described. It's a known issue that will be address at a later time.\n. See paragraph 2.6.1.1 of the OpenGL specification:\n\nGenerated names do not initially correspond to an instance of an object. Objects\nwith generated names are created by binding a generated name to the context.\nFor example, a buffer object is created by calling the command BindBuffer with\na name returned by GenBuffers, which allocates resources for the buffer object\nand its state, and associate the name with that object.\n. Resolved with #44.\n. Thanks!\n. Thanks!\n. LWJGL 3 already has controller support, via GLFW. Besides, I don't think wrapping JInput is useful in any way. If you need something from JInput, you can use it directly.\n. The native library lookup has been fixed with 2543603d062a268bea6adf871c8afa592bddd97b.\n\nAs for the rest, there are no plans to support OSGi. If someone really needs OSGi compatibility, LWJGL releases are not signed; they can manually be rebundled with the necessary metadata.\n. The Vulkan spec is currently available only to Khronos members and ISVs under NDA. I can only promise that LWJGL will have Vulkan support within hours of the spec's public release.\n. LWJGL 3 only provides the API bindings, so it's really up to the jMonkeyEngine developers.\nIf you were using LWJGL 3 directly, it would certainly be a lot of work. From what we've seen from AMD's Mantle and Microsoft's Direct3D 12, a naive translation from legacy rendering APIs to the new APIs will often result in many problems and quite possibly worse performance. A deep redesign is often required to take full advantage of the new rendering approach.\nA rendering engine can certainly hide this complexity from end-users, but I don't think the work for it can be done overnight. Vulkan will be very different from OpenGL and heavily multi-threaded, so I'm guessing some new abstractions will be needed to get the most out of it.\n. Looks like Fermi might have Vulkan support.\n. Thanks!\n. Have you checked if the context supports OpenGL 3.0? Note that if you're on OS X, you need to explicitly ask for a 3.2+ forward compatible context (see the glfwWindowHint documentation or this on how to do that).\n. Yes, good point.\n. LWJGL 3.0a has been released without postfix stripping and there were no complains.\n. Hey Ryan,\nThanks for the PR, I've verified that it indeed fails on the Nvidia implementation in the same way it does on Intel's. Both AMD and Apple implementations work as expected, according to the OpenCL spec.\nThe test itself isn't very interesting though, so I simply removed the reference count checks.\n. Thank you!\n. Hey Matthew,\nThe package statements are wrong; core is not part of the Java package hierarchy, it's the module name. All statements much be changed to \"package org.lwjgl...\".\nAlso, I don't think GLFW stands for  OpenGL FrameWork. Even if it does, the official name seems to be just GLFW.\nPlease update the PR and I will merge it.\n. Thanks, merged manually.\n. The stb bindings have been added. See this post for details.\nIf you think there's an important font rendering feature that stb does not provide, please reply here.\n. Did you try pressing 'S'? If you mean arbitrary zoom in/out like the other two demos, this demo doesn't support it.\n. Change the values in this array. They are used in PackFontRange, here.\n. There are two values because there are two font sizes that you can toggle by pressing 'S'. Both sizes are packed in the same texture and the initial texture size is 512x512. It's quite possible that if you increase the font sizes then they won't fit, that's why you might be seeing odd results. Try to increase the font size as well.\nNote that I didn't write this demo. It's a Java port of the same demo in the stb repository.\n. Thanks, it has been added with 053f8758a52e5188da17e43bb1c8d9c85fadc30c.\nWe use a custom code generator, written in Kotlin. The source is here and documentation here.\n. This a known issue (see #54), it would indeed be better to throw a more descriptive exception.\n. I will wait for input from other users before doing anything. But I don't think having a dependency on slf4j would be a good idea (for LWJGL users, I personally don't mind).\n. Well, setupDebugMessageCallback is a \"reference implementation\" really. It is almost too complex for LWJGL, which is supposed to be super lightweight and not provide high-level abstractions. The only reason it's there is because it's so damn useful. My experience so far has been that many users simply ignore that the modern debug mechanisms exist and go through the pain of good old glGetError.\n. > Yes, it almost feels like a \"utility\" method. But there is a pattern to observe: The more something becomes \"utility\" the more people demand for it and the more useful it becomes.\n\nSee for example the math classes. :)\n\nOf course, but there's nothing bad about making standalone libraries out of specialized utility functionality. JOML is a perfect example of that.\nBy adding this method to LWJGL, trying to be helpful, I have created more work for myself. Someone asks for Logger/slf4j integration. Then someone else asks for a high-level callback. Who knows what comes next... You cannot keep everyone happy and the only way to satisfy a request is by making the library opinionated, which LWJGL doesn't want to be.\nThe raw functionality is there, it's simple and publicly available, anyone could roll their own implementation. This is even the primary reason LWJGL 3 exists and the whole point of writing it from scratch.\n. I'm currently experimenting with how to address this issue:\n- Any time LWJGL prints debug information or non-fatal errors, it uses a PrintStream instance in LWJGLUtil.\n- That instance defaults to System.err.\n- It can be overridden with a system property (that specifies a factory class that returns a PrintStream instance).\nUsing the above, I'm able to create a PrintStream implementation that forwards everything to a logger or whatever. Any comments?\n. > My only reservation is that it may be duplicating functionality already provided by java.util.logging.Logger. \n\nIf LWJGLUtil.log(CharSequence) could switch to a Logger based on a system property that might cover it without duplication.\n\nI wanted to avoid such a solution because SLF4J users would then be forced to use the jul-to-slf4j bridge.\nLWJGL now supports (in build 3.0.0b build 37) programmatic configuration with the org.lwjgl.system.Configuration class. It can be used to setup forwarding to any logger with:\nConfiguration.DEBUG.set(true);\nConfiguration.setDebugStreamConsumer(new DebugStreamConsumer() {\n    @Override\n    public void accept(String message) {\n        Logger.getLogger(\"MyLogger\").info(message);\n    }\n});\nI believe that's easy enough and avoids any dependencies to j.u.l.Logger or any other logging framework. \n. Yes, setDebugStreamConsumer has been removed. Its implementation was complicated and its usefulness questionable.\nYou can still use Configuration.DEBUG_STREAM to forward messages to a custom logging solution.. LWJGL 3 is not compatible with AWT on Mac OS X. This has been discussed extensively in the LWJGL forum. Even though certain workarounds can work under very specific conditions, it is highly recommended to not use AWT/Swing with LWJGL 3.\nFor image loading and font rendering LWJGL 3 recently added STB bindings, you can use that instead of AWT. See these samples.\n. The decision to make LWJGL 3 compatible with Java 6+ was made very early on. Java 5 was obsolete 3 years ago and remains so; it is also completely unsupported and unmaintained. The same could be said about Java 6 actually (e.g. on OS X), but at least there are still some recently updated builds out there (from both Oracle and Zing).\nEven Java 7 reached the end of public updates threshold on April 2015. It's more likely to bump the minimum required Java version to 7/8 for the official 3.0 release, than go back to 5.\nLWJGL 3 does not have existing deployments to support (it is not backwards compatible with LWJGL 2) and it's always a bad idea to rely on public JREs on user machines.\n. > Yes, of course. You are right. But that does not stop people from using it. And I am thinking about very old corporate computers for which there are still in-house projects to build and support.\nAs I said, no one should rely on existing JRE installations. Most LWJGL users deploy their applications with private bundled JREs (as do most Java apps these days).\n\nBut is there any reasoning behind this decision? I mean if there is no need for a library to be Java 1.x compatible, because it does not make use of API or language features, then, why make it so?\nIn my opinion the lowest requirement for a broadly used library is always the best choice.\nBut of course, if the decision is final, this issue can be closed.\n\nI explained the reasons above. Technically, we could make LWJGL 3 compatible with Java 1.4 and up, but what would be the point? It only makes developing the library more painful, for no real benefit.\n\nThat would be most unfortunate in my opinion. But of course you decide.\n\nThat was rhetorical; there would be something to gain from going to 7/8. Java 5 compatibility is pointless. But, as I said, the decision has been made, LWJGL 3 is Java 6+ compatible. The next logical step would be making LWJGL 4 require Java 8, for lambda callbacks. Unless Project Panama is available by then, in which case we'll have entirely different things to talk about.\n. The Java 7 language features are mostly syntactic sugar that we can live without. Try-with-resources is very useful, but on the user side. We also have a decent workaround for callbacks using Java 8 lambdas. API-wise, the only time I found myself missing stuff was when writing the Generator, but that's not part of the library.\n. I imagine that LWJGL 4 will be an opportunity to break source compatibility with 3 (just like 3 did with 2). This is obviously years down the line. I'm also very happy with LWJGL 3 and at the moment I can't think of anything other than Project Panama that would justify going to 4. I imagine that we'll get some kind of abstraction for pointers (possibly value-typed) and also interface-based structs. It would be a great opportunity to make the LWJGL API type-safe with respect to pointers.\nBtw, there has been progress on Project Panama for quite some time now and it's starting to shape up.\n. Just noticed that the latest version of TestNG (the testing framework used by LWJGL) has dropped Java 6 support.\n. Thanks Mario, for the gradle script and the deployment tutorial. I don't have access to the org.lwjgl group atm, it will take some time to resolve the situation.\nDon't worry about the gradle branch, I haven't pushed the latest changes anyway. I'll add your script manually when it's ready.\nI'm wondering why you think gradle is a pita. I'm starting to form a similar opinion, but it would be interesting to hear from someone with more experience. My top complains would be:\n- Multiple ways to do the same thing. No two scripts are alike, which I find really strange for a build system that favors convention over configuration.\n- Performance is a joke, even with the daemon. Seriously, multiple seconds for stuff that are instant with Ant.\nOn the other hand, it certainly looks like that the Gradle scripts will be cleaner and more maintainable than the Ant scripts.\n. Hey Mario,\nI had some time to test this script and the tutorial in #70, it works great and actually was much easier than I expected. I will merge this PR soon and will also make the build server publish snapshots to SonaType.\nOne question: why is build.gradle in the artifact list?\n. Yes, the same job that publishes nightly builds on the lwjgl website, now also uploads a snapshot to Sonatype.\n\nI needed something to package for that specific artifact because Gradle\nsucks. The build.gradle was the smallest file, so i eventually gave in and\nused that.\n\nI'm not sure what you mean here. I have removed it and it seems to be working fine.\n. Thanks, the next nightly build (#53) will have the correct OpenAL library.\nThe stack guard warning is caused by libffi (which is statically linked into liblwjgl3). I believe it's harmless. You can ignore it and I will try to get rid of it soon.\n. I cannot reproduce it. Could you run with -Dorg.lwjgl.util.Debug=true and post the output here? Also, please make sure you use the latest nightly build.\n. Looks like there's a problem with the library path(s), dlopen cannot even find the shared libraries. How is your application launched?\n. Are you setting -Djava.library.path to the correct directory?\n. Yes, -Djava.library.path should be set to the native folder.\nAlternatively, you could add the natives to a jar and add that jar to the classpath; LWJGL will auto-extract it to a temp folder and use the natives automatically. (no -Djava.library.path is required in this case)\n. This could be related to SIP. Where did you extract the LWJGL binaries?\n. Just like vecmath, such functionality is outside the scope of LWJGL and belongs in a separate library (see JOML). Even if it's common and simple, it's also application-specific (what color space to use, what data-type/precision/dynamic range, etc).\n. I see this on my machine too (Windows 8.1, AMD GPU). It's an open issue in GLFW.\n\nHowever, it seems that the current glfw head (which I know LWJGL3 does not use) does not exhibit this behaviour anymore (tested with a simple native app).\n\nYou may have done something different, because LWJGL 3 uses the GLFW head (the master-linux64 branch is also used for the Windows builds).\n. > Oh, I thought you switched to some last GLFW release, because of some keyboard issues.\nYeah, thought about doing that, but the current head has many important fixes for issues I didn't want LWJGL users to deal with. I'm currently patching the head to fix the keyboard issue on Linux. Also submitted a PR to GLFW but it hasn't been accepted.\n. Yes, thank you.\n. It could be useful. The API is nice and should be easy to add to LWJGL. But I'm a bit skeptical because I don't think many users will be interested. Also, with Vulkan coming, focus has shifted to SPIR-V and there are many tools/libraries being made for it already. I think we should wait a few months to explore other options.\n. Another option: https://github.com/google/shaderc\n. I don't think there will be much interest for this. It wouldn't be compatible with GLFW either.\n. Updated kotlinc to the latest build. I'm on vacation atm, will find a better solution when I'm back.\n. Thanks! The charset meta has been added to the javadocs now. Note that it might take some time (up to a day) for the CDN to invalidate the cached HTML files.\n. I could not reproduce this. Is it possible that you're destroying the window twice? If not, could you please share a simple code sample that reproduces the crash on your system?\n. There are better replacements for old util functionality in LWJGL 2. Old tutorials are obsolete anyway, the core API has been completely replaced (Display, input, etc).\n. Cannot reproduce. Could you please try it in a debug context and post the error output here?\njava\nglfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);\n// ... (create window) ...\nglfwMakeContextCurrent(window);\nGL.createCapabilities();\ndebugProc = GLUtil.setupDebugMessageCallback();\n. 0x8871 is MAX_TEXTURE_COORDS, not MAX_COMBINED_TEXTURE_IMAGE_UNITS.\n. I cannot reproduce this, with either the LWJGL tests or the code you posted (without libGDX). What does Sys.getVersion() print for you?\n. On Windows 10, same LWJGL build. The tests I tried were:\n- Your code, minus Lwjgl3NativesLoader.load(!Lwjgl3ApplicationConfiguration.disableAudio);.\n- The GLFW Events demo.\n. Have you tried with a different mouse or different computer?\n. I'm fairly sure this isn't an LWJGL bug. To verify, could you please run this test? It's the GLFW events test (similar to the LWJGL Events demo). I just compiled it for Windows x86.\nIf there's a trust issue with the .exe, you could clone GLFW and build it locally. You'll need CMake and Visual Studio Community.\n. It's a false positive, see this thread for more information.\nThe scanner is probably confused because the binaries are compressed with upx.\n. Thanks!\n. My bad. I had fixed this locally but didn't really like the solution, so it didn't make it to a commit and then I forgot about it. Will try to fix it later today.\n. Duplicate string literals are only stored once in the class file and at runtime. So, this change doesn't do anything useful, though it doesn't hurt either.\nSince you're a young programmer I'm going to merge this pull request, if only to encourage you in contributing more to open source software. But... only if you complete the following tasks:\n- Rename the variables to LWJGL_LIBRARY_PATH and JAVA_LIBRARY_PATH.\n- Apply the The seven rules of a great git commit message, i.e. the commit should read \"Change library names to constants\" or \"Extract library names to constants\".\n- Update this pull request without creating a new commit.\n:)\n. Thank you!\n. Hey @Noviv, the repository contains a pre-configured IntelliJ project in the config/ide/idea directory. No one has contributed a project for other IDEs so far.\n. > Remember to copy those two files from config/ide/eclipse to the root folder of the lwjgl3 sources for Eclipse to work properly, and then import the project into Eclipse.\nIs it possible to make it so this isn't required? With IntelliJ you can have the project files in any directory and all paths will be configured relative to it. See this module for example.\n\nThis configuration excludes the packages org.lwjgl.egl, org.lwjgl.opengles, org.lwjgl.demo.ovr as well as the class org.lwjgl.glfw.GLFWNativeEGL.java from the build path, as those give compiletime errors when building LWJGL3 with default settings via ant.\n\nThis is no longer true since 0919613117450c7e050bfc6a45e8bcc035e68f69.\n. @Noviv The gradle script currently handles artifact deployment only. It does not build the project and depends on ant for it.\n@httpdigest Will you update the pull request to remove the EGL/GLES exclusions? Or want me to do it after merging?\n. Hey @Bobo1239, thanks for reporting this issue and taking the time to submit a pull request. I have fixed it with a different implementation, in e8dd93fc7897adfb7b4bd8d83c2067bd4bd12cbb.\n. Thanks! Nightly build 3.0.0b 45 has the fix for this. Please let me know if you encounter any other issues, I haven't tried EGL/GLES on Linux.\n. That's outside the scope of LWJGL. There are other ways to use OpenGL ES on Windows, for example the WGL_EXT_create_context_es_profile extension and the AMD OpenGL ES SDK.\n. Thanks, should be fixed in build 46.\n. Hmm. First of all are you using a GLFW build that supports EGL/OpenGL ES? The build that comes with LWJGL works with desktop OpenGL only. This will change in GLFW 3.2 and you'll be able to select the context API at runtime.\nIf you're using the default LWJGL distribution, then what happens is that GLFW creates a desktop OpenGL context, but LWJGL assumes it's an OpenGL ES context. It works if you fix the API version detection likely because all GLES 2.0 functions are also present in the OpenGL context.\n. I had a better look at nanovg and even though the code is very clean and sensible (for a C project), it basically requires something like GLEW for the OpenGL backends to work. There's also no support for selecting the exact OpenGL version at runtime, it must be a (native-)compile-time decision.\nI don't see a viable approach, other than porting nanovg_gl.h to Java/LWJGL. It doesn't look particularly hard, but I'm not looking forward to it either.\nPlease post here if you're interested, I'd like to decide whether I should do this before the 3.0.0 release or postpone it.\n. I've actually started work on this. NanoVG has several structs, both in the public and the internal API (for the rendering backend) and I decided it is a great opportunity to validate LWJGL's struct API. I'm happy with its current state, but I haven't had experience with how it \"feels\" in a complex environment and implementing the NanoVG backend is complex enough.\nI've done a few fixes and improvements that will be pushed soon, so this is useful already.\n. I had a working Java back-end for this, but it was too slow (30-40% slower than the native implementation) due to C-to-Java callback overhead. It wasn't all for nothing though, LWJGL got improved in the process.\nThe implementation that got committed uses the native back-end, but with important changes (which is a first for LWJGL). The good news is that it's fast and will probably require less maintenance than the Java solution.\n. The latest nightly (3.0.1 build 6) is the first build with modular artifacts. Please give it a go and provide any feedback you may have here.\nThis build is currently available as a monolithic .zip and only via lwjgl.org. Each module is contained in a subfolder (named after the corresponding package), with different JARs for classes, source, javadoc and (for some) per-platform natives.\nMaven support is coming next, when we're happy with the new structure. The site will also be upgraded to support downloading individual modules and a tool will be added that:\n- Generates Maven/Gradle scripts with the modules you select.\n- Generates IDE projects with the modules you select.\n- Packages the modules you select and initiates a download of a .zip with just those modules.\n. > why not put the native libraries in a single * .jar , to facilitate application portability\nWhat do you mean exactly? Having a single lwjgl-<module>-natives.jar per module instead of one per platform?\n\nexample: I need only generate module GLFW or GL or GLFW+GL!\n\nThat's coming, either via Maven/Gradle or the tool I mentioned above.\n. > why no put all natives in only archive*.jar?\nA few reasons:\n- If LWJGL is added as a Maven dependency and we have separate JARs per platform, the download would be quicker (2-4 times faster, depending on the platform). The first time experience for new users matters. LWJGL is also updated quite regularly and downloading unnecessary stuff every time is not ideal.\n- If an LWJGL application is distributed via Java Web Start, having separate JARs per platform means quicker download time for all users.\n- If an LWJGL application is packaged in native installers, one per platform, only the corresponding natives for each platform would be added to the installer. If everything came in a single JAR, the developer would have to separate the natives manually.\nWith that said, the tool on lwjgl.org/download will support merging the natives, so I think you'll be satisfied.\n\nsomething other than the subject, have not thought lwjgl3 made \u200b\u200bcompatible with Android\n\nARM support is scheduled for LWJGL 3.0.2. Android support will also be explored.\n. Modular maven artifacts are now available in the snapshot repository.\nI'm looking for feedback on the current structure. We now have the lwjgl artifact and one artifact for each binding (lwjgl-glfw, lwjgl-opengl, lwjgl-stb, etc). Each artifact contains the following:\n- The java classes\n- The java sources (classifier: sources)\n- The API javadoc (classifier: javadoc)\n- The native libraries for each platform (optional, some bindings have no native code)\n  - Linux (classifier: natives-linux)\n  - MacOS (classifier: natives-macos)\n  - Windows (classifier: natives-windows)\nThe above structure has the benefit that a user may download exactly the artifacts they need and nothing else. On the other hand, since Maven has no concept of dependencies between classified artifacts, setting it up is quite verbose. For example a project that needs GLFW, stb, jemalloc and OpenGL, using the shortcut Gradle syntax:\ngroovy\n// lwjglVersion = '3.0.1-SNAPSHOT'\n// lwjglArch = 'windows'\ncompile 'org.lwjgl:lwjgl:$lwjglVersion' // NOTE: this is optional, all binding artifacts have a dependency on lwjgl\ncompile 'org.lwjgl:lwjgl-glfw:$lwjglVersion'\ncompile 'org.lwjgl:lwjgl-stb:$lwjglVersion'\ncompile 'org.lwjgl:lwjgl-jemalloc:$lwjglVersion'\ncompile 'org.lwjgl:lwjgl-opengl:$lwjglVersion'\nruntime 'org.lwjgl:lwjgl:$lwjglVersion:natives-$lwjglArch'\nruntime 'org.lwjgl:lwjgl-glfw:$lwjglVersion:natives-$lwjglArch'\nruntime 'org.lwjgl:lwjgl-stb:$lwjglVersion:natives-$lwjglArch'\nruntime 'org.lwjgl:lwjgl-jemalloc:$lwjglVersion:natives-$lwjglArch'\nOur options:\nOption A\nKeep the above structure. We're soon going to have a tool on the LWJGL website that will let users choose the bindings they need and it will generate the corresponding Gradle/Maven declarations for them. Verbose, but auto-generated.\nOption B\nDon't use classifiers and make the natives separate artifacts with appropriate dependencies. The above example becomes:\ngroovy\n// lwjglVersion = '3.0.1-SNAPSHOT'\n// lwjglArch = 'windows'\ncompile 'org.lwjgl:lwjgl-glfw-$lwjglArch:$lwjglVersion'\ncompile 'org.lwjgl:lwjgl-stb-$lwjglArch:$lwjglVersion'\ncompile 'org.lwjgl:lwjgl-jemalloc-$lwjglArch:$lwjglVersion'\ncompile 'org.lwjgl:lwjgl-opengl:$lwjglVersion'\nThe above would automatically resolve the other dependencies declared in Option A. I personally don't like this option for aesthetic reasons (too many artifacts under org.lwjgl).\nOption C\nWe could assume that most projects will use only a few of the available bindings and download speed is not a concern (Maven dependencies is a convenience for developers only, not end-users). The natives for all platforms could be merged into the unclassified artifact. The above example becomes:\ngroovy\n// lwjglVersion = '3.0.1-SNAPSHOT'\ncompile 'org.lwjgl:lwjgl-glfw:$lwjglVersion'\ncompile 'org.lwjgl:lwjgl-stb:$lwjglVersion'\ncompile 'org.lwjgl:lwjgl-jemalloc:$lwjglVersion'\ncompile 'org.lwjgl:lwjgl-opengl:$lwjglVersion'\nAs simple as possible to configure, but at the price of downloading bigger artifacts.\n. > it would be useful to have something like \"lwjgl-all\" which would give you an all-in-one package.\nThe website tool is going to have a \"I want everything\" option, which will give you dependency declarations for all bindings. IMHO, that sufficiently covers users that simply want to try what LWJGL offers.\nHaving said that, a particularly annoying aspect of having all bindings in a project is autocompletion of OpenGL APIs in the IDE; LWJGL supports both standard OpenGL and OpenGL ES and they share a lot of identically named functions, constants and extensions. It's very common to invoke autocompletion and get duplicate classes/method/constants in the list. It's annoying and you have to be careful with selecting the element you want from the correct package.\n. > Just updated nightly builds, something seems to have broken on my mac system (OSX 10.11)\nI tracked this down to what seems like a bug in LLVM's optimizer. I had recently changed our CI build to use Xcode 8 (was on 6.1 before), which produced a buggy build. I've now reverted it to Xcode 7.2. You can download a fixed OpenAL build here, it will also be included in the next LWJGL nightly.\n. > It should be possible to have the native library depend on the java one and, while technically not the correct use of dependencies, should allow you to do Option A but with only half of the declared dependencies.\nNote that with Option A the native library is resolved using a classifier. The Java classes, sources, javadoc and native libraries (one for each platform) are all part of the same artifact. E.g. for GLFW the complete artifact is:\n``` groovy\n// Java classes\ngroupId: 'org.lwjgl'\nartifactId: 'lwjgl-glfw'\nversion: '3.0.1-SNAPSHOT'\n// Java sources\ngroupId: 'org.lwjgl'\nartifactId: 'lwjgl-glfw'\nversion: '3.0.1-SNAPSHOT'\nclassifier: 'sources'\n// Javadoc\ngroupId: 'org.lwjgl'\nartifactId: 'lwjgl-glfw'\nversion: '3.0.1-SNAPSHOT'\nclassifier: 'javadoc'\n// Linux Natives\ngroupId: 'org.lwjgl'\nartifactId: 'lwjgl-glfw'\nversion: '3.0.1-SNAPSHOT'\nclassifier: 'natives-linux'\n// MacOS Natives\ngroupId: 'org.lwjgl'\nartifactId: 'lwjgl-glfw'\nversion: '3.0.1-SNAPSHOT'\nclassifier: 'natives-macos'\n// Windows Natives\ngroupId: 'org.lwjgl'\nartifactId: 'lwjgl-glfw'\nversion: '3.0.1-SNAPSHOT'\nclassifier: 'natives-windows'\n```\nAfaik, you cannot specify dependencies between secondary artifacts that belong to the same artifactId.\n\nAlso it seems that LWJGL is unable to find the natives itself currently when using the new system.\n\nHave you added the native JARs to the classpath? If yes, could you share more details on how you've set up your project? It would also be useful to see the output when running with -Dorg.lwjgl.util.Debug=true and -Dorg.lwjgl.util.DebugLoader=true.\n. > Does this mean that you cannot wget/curl a specific URL with just using query parameters in order to get a customized bundled zip file?\nCorrect. Building a service for this would mean additional (bandwidth/computation) cost. The project has no income (donations/ads/etc) so keeping things simple is a priority. Currently the only costs are S3/CloudFront storage/bandwidth and an EC2 t2.small instance (already overwhelmed by TeamCity + build workers).\nDownloads should be faster too. Instead of everything going through our puny US-based server, build files are served from the nearest CloudFront edge.\nIf more customization is required, it can be implemented without a dedicated service. The file structure generated by ant release is now available under https://build.lwjgl.org/nightly/bin/. A bin folder will also be created for stable and release builds after 3.0.0. A simple script could easily download the necessary files in the preferred structure.\n. > However for standalone ui's, SWT is probably the best and most mature option out there. It integrates nicely with the native platform and is small and lightweight. It also strips down pretty nicely (to a few KB's, the Avian example are good examples of how small, less than a meg for SWT support and the Avian JVM!).\n\nSo looking into getting LWJGL3 nicely integrated with SWT should be explored. IMO a much better investment then spending time on AWT or JavaFX.\n\nDo we even need anything special for SWT integration? Looks like @httpdigest already has a sample here.\n. @httpdigest is making good progress with SWT integration, see his latest update.\nI experimented a bit more with JavaFX and have a working OpenGL backend that runs on top of LWJGL. This may seem like a huge step forward, but it's not enough. It would be easy to implement context sharing with the JavaFX context and access the textures directly. The problem is, JavaFX is architected in a such way that the rendering layer has no idea which textures correspond to which GUI elements. I don't have a solution to this yet, I'll explore some more ideas when I have time.\nI don't know if nanovg bindings will make it to the final LWJGL 3.0 release, but I'll try.\n. The latest nightly build has jawt bindings, which in theory allows for the AWT integration in LWJGL 2 to be implemented in terms of LWJGL 3. Sample code can be found here (simplest possible implementation, Windows-only).\n. https://github.com/vurtun/nuklear\n. LWJGL will very soon have Nuklear bindings, see the nuklear branch.\nThere's already support for everything, but I'm working on a Nuklear+GLFW+stb_truetype demo to understand and properly annotate the API (nullability, autosize parameters, etc).\n. @arisona \nThe best approach is cloning the repository, opening the IntelliJ project and exploring the Templates module. There are some important differences between bindings (loaded from a shared library vs baked into LWJGL, custom functionality like the capabilities classes, etc), but the general structure is the same:\n- The org.lwjgl.<library_package> package contains the type, struct and callback definitions. The type definitions provide an important level of type-safety and \"refactorability\".\n- org.lwjgl.<library_package>.templates package contains the actual binding templates, a file per generated class. These might look a bit scary, but it's mostly the documentation that makes it verbose. The most important thing is getting the \"modifiers\" right, but there is a ton of examples you can work with.\nYou should start with studying the GLFW bindings, I think that's the cleanest API. The LibOVR bindings should be fairly similar to OpenVR. You could also look for commit messages in the commit log that look like \"Add <library name> bindings\". These should give you a fairly good idea of everything required to add a new binding.\nWith that said, you don't have to do everything right. Simply contributing the types/structs/callbacks, templates and documentation will be a major help. I can do the rest of the work easily.\nOn OpenVR in particular: The C API has these FnTable structs that contain function pointers. They are loaded with the global VR_GetGenericInterface function (example here). No other library uses this scheme and LWJGL does not support it currently, so some customization will be required. Please open a new issue if you'd like to discuss this further.\n. @nhydock \nYes, see #100. The first 3.0.1 builds will have Nuklear built-in (adds about 200kb to the binaries) so that users can start working with it, but the plan is to split heavyweight bindings to separate artifacts.\n. \nDemo code here.\n. The first LWJGL 3.0.1 nightly build is now available and it includes the Nuklear bindings.\n. Hey @codemuse,\nHave you tried JavaFX Interoperability with SWT?\nAs for a pure JavaFX solution, I will probably try again when I have time, but failure is the most likely outcome. . @dustContributor Yes, OpenJFX being decoupled from the JDK opens up opportunities, you can read some details in this JGO post.\n(No work has been done yet, I grossly overestimated the free time I'd have this summer). This has been implemented with a6525c4997bd407e261a64930fc694718d2d39aa.\n. > What do you think of adding a size check, guarded by if ( LWJGLUtil.CHECKS ), to the functions that take ByteBuffers such that hard crashes are preempted by a good exception message?\n\nI can add these checks to my own middle-ware of course but this seems valuable enough to have in the base library and the functions in scope pretty universally have the guarded GLChecks.ensureBufferObject already.\n\nThe problem is that you cannot cover everything in the API without tons of code and nightmarish maintenance. Just for textures, think about how many formats and types there are, how many more are added with new extensions, how old constraints are being relaxed as new hardware is released. \nThen there's related state like GL_UNPACK_* and GL_PACK_* that further complicate things. You can't have 100% crash-free guarantees without basically writing a small OpenGL driver. I'm afraid this is outside the scope of LWJGL.\n. Hey @domesticmouse,\nGLFW on OSX requires that you run the JVM with -XstartOnFirstThread.\nLWJGL has a check and corresponding error message for this, but not on glfwCreateWindow. I'll add it soon.\n. Hey again,\nThere's actually a reason glfwCreateWindow didn't have the thread check. It is possible to create a hidden GLFW window (GLFW_VISIBLE set to GLFW_FALSE) and only use it as an off-screen rendering context. In that case, you can use AWT/Swing/JavaFX normally if you initialize them before GLFW and don't use -XstartOnFirstThread.\nUnfortunately, LWJGL cannot properly detect this scenario. So, glfwCreateWindow will now print an appropriate message in debug mode (-Dorg.lwjgl.util.Debug=true or Configuration.DEBUG.set(true)), when -XstartOnFirstThread is missing.\n. These bindings were removed with d9c4a1b6f45f665ae2546c0b9c2326fa963e0267. We should re-introduce those that are needed for custom context management.\n. Having them in core is fine. Creating a context using a foreign window handle should be available out of the box.\n. Bindings for wingdi.h are in 3.0.0b build 51. I think you're good to go on Linux/OSX with the existing GLX/CGL bindings, but let me know if you need anything else.\n. Better solution:\nWGL wgl = new WGL(GL.getFunctionProvider());\nlong context = callPP(wgl.CreateContext, hdc);\n. Changes in 3.0.0b build 52:\n- Added the User32 class which provides GetDC and ReleaseDC.\n- Renamed WinGDI to GDI32. I think it's cleaner to use the dll name, rather than the header in which the functions are defined (a single dll might export functions from multiple headers).\n. The platform-specific bindings for this currently live in the offscreen-context branch. It is not complete (mostly what I needed for the JavaFX lwjgl3 backend) and I haven't worked on it for some time, got distracted by the 3.0.0b release.\n. Why do you need a dummy window? You can create a dummy context on the real window, do some queries, then destroy it.\n. The latest nightly build comes with OS-specific window creation bindings. Just a few basic functions are supported for now and more functionality will be added based on feedback. So don't hesitate to ask if you need anything.\n. This is useful indeed. Thanks!\n. Removed the check because the spec allows it, but I wouldn't recommend using a NULL platform. Especially if the same code runs on Windows/Linux.\n. I cannot reproduce this. Could you share some code please?\n. Thanks!\n. This is in my plans, scheduled for a post 3.0 release.\n\nthe person developing LWJGL owns rather a AMD GPU ;)\n\nI've actually upgraded to a GTX a couple of months ago.\n. Yes, I will upgrade the rest of the machine soon and the old parts will be used for Windows and Linux testing. I've been using a Linux VM so far, which is a pain, can't test OpenGL and OpenCL properly.\n. I cannot reproduce this. How are you launching the JVM? Could you post the full output with -Dorg.lwjgl.util.Debug=true? Also, please use the latest nightly build (3.0.0b 60).\n. Thanks, I found the problem and will push a fix soon.\n. Thanks!\n. If you mean OpenGL functions that are not available in the Core Profile, making them @Deprecated would be very annoying for legacy applications or applications that use the Compatibility Profile. There are no easy replacements for such functions, you'd have to rewrite major parts of a renderer to get rid of them.\n. For new development it's easy, just use a Core Profile context. If that is not desired (there's a performance hit due to extra validation), LWJGL supports a pseudo-forward-compatible mode that you can enable with:\nGL.createCapabilities(true);\nThis will make LWJGL not load pointers for deprecated functions, so you'll get an exception if they are used by mistake. Deprecated constants (e.g. GL_QUADS) will continue to work though.\n. > Or another way would be to let GL.createCapabilities figure it out itself whether the active GL context is a forward compatible one. However that would only be possible when using a >= 3.2 context.\nIt works like that already. The forwardCompatible parameter of GL.createCapabilities is useful only when working with legacy/compatibility profile contexts.\n. The generated JavaDoc works correctly, try this for example. Works as expected in IntelliJ too.\nAny NetBeans user that can try this?\n. It's not that I have anything against Eclipse or cba to change the code (it's an one-line change). I've been working on lwjgl3 for 3 years now and I've put thought on almost every little detail. In this particular case, the intent was to make the source javadoc as human-readable as possible.\nIs it worth bloating all javadoc (function signatures with 5+ parameters are not uncommon at all) to fix one action (source navigation) of one IDE?\n. Thanks!\n. Hey @wyozi, there have been several improvements to OpenAL after the beta release, you can download a nightly build to try it out. OpenAL Soft has been updated to 1.17.1 and all extensions are now supported, including SOFT_HRTF.\n. Make sure -Djava.library.path is set correctly.\n. Please reopen this issue if you still have trouble with the latest nightly build.\n. If an LWJGL user decides to use PhysX or any other library that comes with legal/marketing obligations, it's their decision and not LWJGL's. As long as it doesn't affect other users or the library itself, I don't see a problem with supporting such libraries.\nWith that said, PhysX has the same problem with Bullet afaik: it's a C++ API. Technically that's not a major problem, but I personally won't have time to work on C++ bindings support until well after the 3.0.0 release. See #22.\n. This should be fairly easy to implement. I'll work on it soon.\n. Yes, handling JNIEnv turned out nice. But there are a couple of issues, that's why I put jawt in the system package (i.e. subject to change in the future):\n- I would have liked to use \"JAWT\" as the class name, but it clashes with the JAWT struct. Had to come up with a new name (JAWTFunctions).\n- I would like to add support for calling functions in structs directly in the future. Right now you have to get the function pointer from the struct and use the corresponding method in JAWTFunctions to call it. The \"DrawingSurface_\" prefix is also annoying. (this will probably be done when I add support for C++ bindings)\n. Try calling glfwCreateWindow without specifying the monitor (pass NULL instead). The monitor is required only for fullscreen mode.\n. Before going through all that, I'd try another OpenGL application to discard any driver issues.\n. Hey @gitluke2006, could you please try again with the latest nightly build?\n. The WindowProc.create call doesn't work because it's really org.lwjgl.system.libffi.Closure.create, which only works for libffi closures. You cannot use it with an arbitrary function address.\nSee the following code:\n``` java\nprivate static long createDummyWindow(String className) {\n    WNDCLASSEX wc = WNDCLASSEX.calloc();\n    try {\n        wc.cbSize(WNDCLASSEX.SIZEOF);\n        wc.style(CS_HREDRAW | CS_VREDRAW);\n        memPutAddress(wc.address() + WNDCLASSEX.LPFNWNDPROC, User32.getInstance().DefWindowProc);\n        wc.hbrBackground(6); // COLOR_WINDOWFRAME\n        wc.lpszClassName(className);\n    if ( RegisterClassEx(wc) == 0 )\n        throw new IllegalStateException(\"Failed to register dummy window class\");\n} finally {\n    nmemFree(memGetAddress(wc.address() + WNDCLASSEX.LPSZCLASSNAME));\n    wc.free();\n}\n\nlong hwnd = CreateWindowEx(\n    0,\n    className,\n    \"Dummy Window\",\n    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,\n    0, 0, 1, 1,\n    NULL, NULL, NULL, NULL\n);\n\nif ( hwnd == NULL )\n    throw new IllegalStateException(\"Failed to create dummy window\");\n\nreturn hwnd;\n\n}\n```\nThere are two ugly things above that I may fix soon:\n- The lpfnWndProc setter only accepts WindowProc instances. An overload that accepts any function address should be added.\n- The lpszClassName setter uses encodes the string to malloc'ed memory, which is then exceptionally hard to free. The allocator should be parametric and it should be trivial to free the allocated memory.\n. Two problems:\n- You're using malloc() to allocate the WNDCLASSEX struct and you aren't setting all the fields. This might result in garbage values in the fields you don't set. Use calloc() instead.\n- The return value of RegisterClassEx is an ATOM. An error is indicated by a 0 value, not != 0.\n. The problems I mentioned above have been fixed. In the next nightly build the sample code becomes:\n``` java\nprivate static long createDummyWindow(String className) {\n    WNDCLASSEX wc = WNDCLASSEX.calloc();\n    try {\n        wc.cbSize(WNDCLASSEX.SIZEOF);\n        wc.style(CS_HREDRAW | CS_VREDRAW);\n        wc.lpfnWndProc(User32.getInstance().DefWindowProc);\n        wc.hbrBackground(6); // COLOR_WINDOWFRAME\n        wc.lpszClassName(className);\n    if ( RegisterClassEx(wc) == 0 )\n        throw new IllegalStateException(\"Failed to register dummy window class\");\n} finally {\n    wc.lpszClassNameFree();\n    wc.free();\n}\n\nlong hwnd = CreateWindowEx(\n    0,\n    className,\n    \"Dummy Window\",\n    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,\n    0, 0, 1, 1,\n    NULL, NULL, NULL, NULL\n);\n\nif ( hwnd == NULL )\n    throw new IllegalStateException(\"Failed to create dummy window\");\n\nreturn hwnd;\n\n}\n```\n. Thanks, fixed in d746f9e5c6f73c099f391ebc9322639246aff576.\n. Added with 0bfe8f32c48ffaea72d0c8e04c5bc9e54c4dc68b.\n. Added support for partially mutable structs with 2cbfb0c00cabcdeeab44b6e287adcbd9792ce961.\n. Fixed with f4a44205a5ad796313c5838bc001fac639a2f6a9.\n. > Also I think the CharSequence overload is a bit dangerous. \nIndeed, the stringParam methods weren't robust for non-nullable parameters, fixed with e387ad0abdc9d6e7d9a56370be9e407d27680170.\n. Is there any output from the GLFW error callback? Note that glfwSetErrorCallback is one of the few GLFW functions that can be called before glfwInit.\n. Also, please post some information about your OS and JVM. You should get the relevant information if you run the JVM with -Dorg.lwjgl.util.Debug=true (or call Configuration.DEBUG.set(true)).\n. Thanks, reproduced. It's UPX that creates the problem. The x86 dll works fine, but the x64 one fails to initialize.\n. Could you try the new nightly please? (build 14)\n. > GLFW Error: The GLFW library is not initialized\nMove glfwSetMonitorCallback after glfwInit\n\nGLFW Error: There is no current context\n\nglfwSwapInterval requires a current context. You should first create a window and make its context current with glfwMakeContextCurrent.\n\nFailed to locate address for GL function glVertexArrayVertexAttribDivisorEXT\n\nThis is a function that was added to the ARB_instanced_arrays extension at a later time. It is not supported by all drivers (AMD iirc), so it's been made optional in LWJGL. This is from the extension spec:\n\n7) How should EXT_direct_state_access interact with this extension?\n```\n   Resolved:  Add glVertexArrayVertexAttribDivisorEXT selector-free\n   vertex array object command and glGetVertexArrayIntegeri_vEXT\n   query must accept VERTEX_ATTRIB_ARRAY_DIVISOR_ARB to return the\n   vertex array object's vertex attrib array divisor state.\nThe DSA interaction was added July 2013.  If implementations\n   respond to a wglGetProcAddress, etc. query for\n   \"glVertexArrayVertexAttribDivisorEXT\" with a NULL pointer,\n   the DSA functionality is not available.\n```\n\nThe message you see is a simple warning in debug mode and can be ignored.\n. I've renamed the Closure subclasses, they now use the corresponding JNI type signature. This is basically the first character of the previous names, except Boolean (Z) and Long (J).\nMay I ask why you're trying to extend Closure.X? Directly that is, not through one of their subclasses. The current code assumes that shouldn't ever need to do that. Using libffi directly may be more appropriate if customization is required.\n. Right, the super type is in scope implicitly. Thanks.\n. Thanks!\n. Thanks!\n. It must be mutable indeed. Thanks!\n. It should be up now.\n. One of the things vogl does is intercept dlopen(), you can see the source here. Indeed it calls strstr which is the function that crashes in your log.\nA few questions:\n- Did you build vogl from source?\n- What is the command you use to run your program?\n- Does your program successfully pass glfwInit() and glfwCreateWindow()?\n. Hey, could you please try the latest nightly build? (3.0.0 23)\n. Hey @remexre, any updates on this?\n. Thanks!\n. The latest nightly build (3.0.0 23) includes the above fix.\n. Hey guys,\nI'm fully aware how excited everyone is to give Vulkan a try. But as I mentioned in #50, I haven't had access to the spec before today. I'm currently setting everything up and will be working on the bindings until late tonight. It's all new to me, but I'll try to push something usable as soon as possible.\n. Yes, I'll think about that after 3.0 is released, it'd be useful to have a decent parser (libclang bindings?).   The converter we have in LWJGL is too limited and too OpenGL-oriented. I was actually just adding support for enums, there's a ton of them in Vulkan.\nAt least the work on struct support is paying off. 124 struct types in Vulkan 1.0 + first extensions, if my count is correct.\n. Thanks!\n. Thanks, the latest nightly build should have the correct dll.\n. GLFW does not interact with AWT/Swing on Linux. A possible explanation for the crash could be that Swing produces an X error, which is picked up by GLFW and the program aborts. I think this is possible due to how error handling in Xlib works.\nI'm afraid I won't have time to look into this any further. Keep in mind that LWJGL 3 does not (officially) support AWT/Swing integration.\nI'm wondering though, why do you use a custom JFrame for the splash screen and not the JVM's built-in support? What happens if you replace the JFrame with:\njava ... -splash:spinner.gif ...\nand call SplashScreen.getSplashScreen().close() after glfwInit()?\n. > The reason why I wasn't using a regular splash screen is that the functionality is limited. For instance, I wanted to add a message log to show the steps of the initialization.\nIf the initialization process is that long, you could use an undecorated GLFW window as a splash screen. A simple texture and STBTruetype for the text will do just fine.\n(Animated GIFs will be tricky though. Will require some internal functions in STBImage to be exposed, let me know if you need it.)\n\nMaybe official support for Swing might be a nice feature for the future.\n\nPlease see #101.\nThere are ways to make AWT/Swing/JavaFX integration work, but the choices are:\n- It only works on specific OSes or under very specific conditions.\n- It has horrible performance.\n- The user has to write a ton of code to get it right.\nIt's a lot of pain for solutions that don't really satisfy anyone. LWJGL 3 is designed to be extremely lightweight and not make any choices for the user. For example we have JAWT bindings, you can use that to implement LWJGL 2's solution, but it won't be provided out of the box.\n\nMy software for instance is a VR-only application. In such a case it might not be unusual to have some kind of traditional UI on the regular screen (showing some status or even for configuration), with the graphics engine running in \"direct mode\" on the HMD.\n\nThe solution I would use and the one I generally recommend when you have separate \"scene\" and \"GUI\" windows: use two processes (i.e. two JVM instances), one for each window, and an IPC solution for dispatching messages between them. This way you isolate each windowing system and you can basically do whatever you want, even on OS X (which is the most problematic OS for such things).\n. Could you try with LWJGL 3.1.0?\nCan you force your system to use the AMD GPU instead of the Intel HD?\n. > I tried to build with 3.1.0 by editing build.gradle in jme3-lwjgl3 :\n\n...\nbut when running game i am getting this error\n\nUpdating from LWJGL 3.0.0 to 3.1.0 is not trivial because of the new modular architecture. The error above is likely caused by a mismatch between the Java and native libraries. Try running with -Dorg.lwjgl.util.Debug=true and -Dorg.lwjgl.util.DebugLoader=true to get more information about what's wrong.\n\nI forced to use AMD using DRI_PRIME=1 command but Error happens again.\n\nIt will be very hard to diagnose this issue without more details. The simplest thing you could do is try to reproduce the issue with just LWJGL code, not via jME.\n. It sounds like it's a jME or groovy issue then. I have experience with neither, you probably need someone with good knowledge of jME internals to figure out what is going on.\nI can only guess and my suspicion lies with threading. Does loading groovy or running groovy scripts require new threads to be spawned? You can check yourself with ctrl+break before and after setting the GUI style.\n. The proper fix for this is to not use AWT/Swing for the dialog. The second best choice is to use a different process for the dialog (launch VM -> show dialog -> launch another VM -> run LWJGL application in the new VM). Even if a workaround for the X error is found, using AWT/Swing + GLFW in the same process is simply not possible on macOS. Which is a major issue, unless you only care about Linux/Windows.\nFor the X error itself, I still think it's an issue with AWT/Swing and not related to GLFW at all. If someone could prepare an MCVE, I'll try to find what's causing it exactly.\nTwo random things you could try, after discarding the dialog and before calling glfwInit:\n\nRun System.gc(), at least two times. Not sure how AWT handles native resources, maybe there's a finalizable/PhantomRef-ed resource that is not released immediately, but a subsequent GC triggers a (too late) free. Actually, could you also run your application with -XX:+PrintGC (or -Xlog:gc on Java 9+) and see if the crash coincides with a GC cycle?\nRun this snippet:\n\n```java\nlong display = X11.nXOpenDisplay(NULL);\nif (display != NULL) {\n    System.out.println(\"Opened display: \" + display);\ntry (SharedLibrary libX11 = Library.loadNative(\"X11\")) {\n    long XSync = libX11.getFunctionAddress(\"XSync\");\n    if (XSync != NULL) {\n        System.out.println(\"Found XSync: \" + XSync);\n\n        int ret = JNI.invokePI(XSync, display, 0); // try 1 too if 0 doesn't help\n        System.out.println(\"XSync returned: \" + ret);\n    }\n\n    X11.XCloseDisplay(display);\n}\n\n}\n```. I don't know about the X error, but JavaFX and GLFW are in the same way incompatible on macOS.. > Is this something which is worked on, or a situation which can't be fixed?\nIt cannot be fixed without modifying JavaFX. We made a decent attempt last year and there's also JFXGL. Now that JavaFX is being removed from the JDK, we'll try to do better soon, see here for more information.. > 1) My game window starts in the background. If I use a build older than b41 (I think I might be on b37 or b38?), my game properly starts in the foreground. I can ALT+TAB to the background Window in b41-b44, but I shouldn't have to. What changed here?\nThis is likely related to the new glfwFocusWindow functionality in GLFW master. What OS are you on?\n. Lets leave this issue open, because I'm not sure what the correct behavior is. This statement (in the glfwFocusWindow doc):\n\nBy default, both windowed and full screen mode windows are focused when initially created. Set the GLFW_FOCUSED hint to disable this behavior.\n\nand this (from the commit above):\n\nThis removes the (undocumented) behavior where glfwShowWindow would bring the window to front and set input focus.\n\nseem to contradict each other.\n. Ideally it would work like the documentation on glfwFocusWindow says: new windows are focused by default (same behavior as before), unless glfwWindowHint(GLFW_FOCUSED, GLFW_FALSE) is set.\n. > What I was trying to say with \"initially created\" was that this is done by glfwCreateWindow or not at all.\nThanks, that explains it.\n\nShould I track whether the window has ever been shown and then additionally focus it the first time it is shown?\n\nI think I would prefer it. It also doesn't change the behavior of existing programs.\n. More Vulkan examples in the lwjgl3-demos repo, here. Everything in there has been contributed by @httpdigest.\n\nOne thing I noticed. Is the Triangle supposed to have its bottom repeatedly hidden and shown?\n\nYes, see the demo_run method, it's animating the depth clear value.\n. OpenCL also has similar classes (CLPlatform and CLDevice). Like ALDevice and ALContext, they don't do much and technically you could use the bindings without them. They serve two purposes:\n- They create and store the capabilities classes internally.\n- Getting started is easier. The user does not need to be exposed to the capability classes immediately, they only have to deal with the concepts of platform/device/context from the corresponding libraries. The capability classes are LWJGL-specific.\nYou've got a point though. I think I'll make another pass on CL and AL and maybe simplify things a bit before the 3.0.0 release. A problem with AL in particular is that the methods AL.setCurrentProcess and AL.setCurrentThread work with ALContext instances. That's an unnecessary dependency and they should work with ALCapabilities instead (and possibly remove ALContext and ALDevice entirely). \n. Opening the default device and creating a default context with the above changes and no error checks:\n``` java\n// Can call \"alc\" functions at any time\nlong device = alcOpenDevice((ByteBuffer)null);\nALCCapabilities deviceCaps = ALC.createCapabilities(device);\nlong context = alcCreateContext(device, (ByteBuffer)null);\nalcMakeContextCurrent(context);\nAL.createCapabilities(deviceCaps);\n// Can now call \"al\" functions\n``\n. What exactly is broken with the Truetype demo? Did you try the latest nightly build?\n. The recommended way to use LWJGL is via static imports. If you need functionality from a particular OpenGL version, you must explicitly import it. This:\n- is not a big deal. All tokens/functions are one` away in modern IDEs, without any imports present.\n- protects from unintentionally using functionality from a higher OpenGL version than intended.\n- is better for exploring such a massive API.\nBest we could do is make GL12 extend GL11, GL13 extend GL12, and so on. Using inheritance for static functionality is not a Java best practice, but it compiles and works. This way you could do an import static org.lwjgl.opengl.GL33.* and all functionality up to that version will be available.\n. > I ended up manually plugging every ES2 entry to the equivalent GLxx., even though I would've liked to be able to just extend GL33core or something and called it a day. I couldn't extend multiple classes from Java, and the GL* bindings aren't interfaced. Guess I probably should've used a python script or something to do that, but ES2 wasn't that big.\n\nThe use case here can probably be made easier if I just did a bunch of find-replace operations across the app code itself. But the fact that there is no core GLX.X interface in LWJGL is still hardly a selling point, no matter how minor to most people.\n\nHaving interfaces implies having instances that implement those interfaces. This will never happen in LWJGL. You'll never see C bindings that look like gl.glBufferData(...). Many other libraries work like that, but the current style has been LWJGL's differentiating factor from day one.\nEspecially in LWJGL 3, we want the Java code to look as close to the native equivalent as possible. We want the code to feel natural to both Java developers and to developers coming from system languages. The problem of copy/pasting Android code and have it work immediately is far less important and doing the same with native code.\nDo you have any input on my suggestion above? (having GL33 extend GL32, GL32 extend GL31, and so on)\nOn dropping deprecated functions: As @SilverTiger mentioned, a forward compatible context will not load deprecated function pointers. You do not risk crashing the JVM either, there are runtime checks for such functions (unless -Dorg.lwjgl.util.NoChecks=true is specified). If you do not want to see such functions at all (e.g. in IDE auto-complete lists), you can always clone LWJGL locally and change the code generator to exclude deprecated functions. It should be trivial, but let me know if you need help with that.\n. > glbinding can just #include , and get the functionality of the GL 3.2 core exactly, nothing more nothing less.\nJava is not C/C++. There's no preprocessor that could accomplish what glbinding does. The only possibility so far has been to create a custom LWJGL build for your application.\nAnyway, there are two enhancements being suggested here:\n\nCore versions of the existing GL bindings, without any compatibility profile features (functions & constants). This is applicable to OpenGL only.\nBeing able to use all GL11 - GLXX features by statically importing only the GLXX class. This is important for OpenGL because it's old and has many versions, but it's equally applicable to AL, ALC, CL, EGL, GLX, GLES, VK.\n\nI've been doing some experiments and it looks like we cannot easily have both 1 and 2 without breaking compatibility of the OpenGL bindings. The cleanest solution seems to be adding a separate class hierarchy GL11Core, GL12Core, ..., GL46Core and an LWJGL application uses either the existing classes or the core versions, but never both. Any other approach that I tried was either binary incompatible (apps compiled with 3.1.6 wouldn't work with 3.1.7) or source incompatible (javac is too sensitive about ambiguous static imports, even if all resolve to the same method/field in the same class).\nIf anyone has a better suggestion, please let me know. If a solution is clean enough that justifies breaking changes, we could defer it to LWJGL 3.2.0.\nHaving tried this in practice, I can see the value of having clean bindings for the core profile, as @hypernewbie suggested. There's a significant cleanup of the API, not only of deprecated functions, but also of constants. On the other hand, I still believe that being able to access all GL versions up to the version that has been statically imported is not terribly exciting. But if it helps new users, then why not.\nSo, I'm looking for feedback on the available options:\n\nAdd the GL11Core, GL12Core, ..., GL46Core classes, with only core profile functionality and no hierarchy between them. Users will have to statically import each one separately.\nOption 1, but each core class extends the core class of the previous OpenGL version. Users statically import only the core class with the minimum required OpenGL version, which provides all functionality up to that version.\nOption 2, but do the same for the current, \"compatibility profile\" classes too (a separate hierarchy).\nOption 3, but make AL, ALC, CL, EGL, GLX, GLES, VK hierarchical too.\nX. Your idea here.\n. Btw, instead of starting with GL11Core, we could merge 11 to 31 and start with GL31Core, since that was the first version that dropped the deprecated functionality. Or even skip that and start with the more practical GL32Core.. Option 4 has been implemented in the glcore-154 branch. I ended up using GL11C, GL12C, ..., GL46C for the new classes. If you'd like to try it out, a build is available here: https://build.lwjgl.org/res/lwjgl-opengl-core.zip (sources, classes and Windows x64 natives).. A binary incompatibility has been reported: kotlin-graphics/imgui#42. The library has been compiled with 3.1.7 snapshot but the application runs on an earlier version. The problem is that javac compiles:\n\njava\nimport static org.opengl.GL33.*;\n// ...\nglGetInteger(...);\nas GL33.glGetInteger(...) instead of GL11.glGetInteger(...). \nThere are workarounds if the library wants to support earlier LWJGL versions, but still, I'm considering bumping the next release from 3.1.7 to 3.2.0, to signal the potential for incompatibilities.. Thanks!\n. This was just fixed, see #155. Build 55 will be up in a few minutes.\n. I cannot reproduce with Mesa 11.0.5. What build do you use?\n. Do you know where I can find binaries for the latest Mesa version?\nDo you think you could build a debug version of GLFW and see where exactly it crashes?\n. Latest version works for me too.\nI've uploaded a GLFW debug build here.\n. Hmm, this is what I get if I make it crash:\n```\nStack: [0x0000000002160000,0x0000000002260000],  sp=0x000000000225eed8,  free space=1019k\nNative frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\nC  [glfw.dll+0x20e80]  memset+0xc0\nC  [glfw.dll+0x15537]  _glfwRegisterWindowClassWin32+0x27\nC  [glfw.dll+0x11f47]  _glfwPlatformInit+0x97\nC  [glfw.dll+0xa20e]  glfwInit+0x3e\nC  0x0000000002465dd5\nJava frames: (J=compiled Java code, j=interpreted, Vv=VM code)\nj  org.lwjgl.system.JNI.invokeI(J)I+0\nj  org.lwjgl.glfw.GLFW.glfwInit()I+8\nj  org.lwjgl.demo.glfw.Gears.init()V+10\nj  org.lwjgl.demo.glfw.Gears.run()V+1\nj  org.lwjgl.demo.glfw.Gears.main([Ljava/lang/String;)V+7\nv  ~StubRoutines::call_stub\n```\nTested on Windows 10, JDK 8u74.\n. > glfwRegisterWindowClassWin32 sounds like it may have something to do with our setup.\nPlease note that the crash above was triggered on purpose (I made memset write to address 0) to test if the debug symbols made it to the JVM crash log. The real issue could easily be unrelated to window class registration (or even unrelated to GLFW).\n. CTRL+Pause triggers SIGBREAK. The scancode changes from 69 to 326 (I'm testing on Windows) and looks like GLFW doesn't have a mapping for it.\nYou may want to report this to GLFW.\n. Fixed with https://github.com/glfw/glfw/commit/3503cba5d9df2976fa94eeaf852e15f987a00fa0.\n. Current priority is releasing 3.0.1 (modular artifacts). Work on new bindings will start immediately after.\n. The OpenVR bindings are now available in the latest snapshot (LWJGL 3.1.2 build 4).. Thanks!\n. Support for Linux x86 has been dropped.\nIf someone contributes travis build scripts that work (for LWJGL and all its dependencies) and also maintains them, I don't have a problem with restoring support for Linux x86.\nBtw, there's far more interest for ARM builds, so that has priority right now.\n. At the LWJGL-CI account:\n- There are forks for LWJGL and each dependency.\n- Each fork has a branch for each platform/arch.\n- Each branch is being continuously rebased to the latest commit, with a single commit on top that adds the travis build script. (you don't need to worry about that, it's being handled by our teamcity server)\nSome of these are trivial to build on x86, others are painful. You can ignore the aws stuff.\n. LWJGL 3 already supports automatically extracting native libraries from JARs. See the SharedLibraryLoader class for details. Have you tried using LWJGL without your custom loader?\n. Thanks!\n. This is a great idea.\n. It's a good start. Comments:\n- The above example is trying to document the generated code (license header, Java types, alternative methods). We should be documenting the source templates instead (native types, one structure per method, etc).\n- It's better if there's a single file per template (i.e. per generated class), even if it is a bit wasteful for short classes. Classes with no content could be handled specially though (e.g. see ExtensionFlags.kt)\n. Thanks!\n. Yes, assuming we have a good solution for #100.\nLibraries like AMD Compress are useful during production. It wouldn't be a run-time dependency, so being limited to a single OS is not an issue.\n. The build system isn't the issue, it can be implemented in a dozen different ways. The issue is automatically building the artifacts with CI, hosting them somewhere, deploying to Maven Central, etc.\nDeciding which libraries to invest our limited time in (it's always the bottleneck) is also a good question. The open issues are there because someone has expressed interest in those libraries, but that doesn't mean we have to support anything and everything, right now. There are priorities and the current top priority is releasing a stable 3.0.0.\n. Compressonator now supports Linux and macOS. . Thanks!\n. > Also it seems that the explicit parameterized type arguments on those get() method invocations are redundant. At least Eclipse flags them as redundant, because the static Configuration field is already type-parameterized.\nIndeed. The type parameters were there because Configuration was an enum before b4eae8c5a7612ac45c382ae90eb921c2e5d25cb7 and (only) the get method was generic.\nInteresting change of behavior from Java 6 to 7. Also, IDEA didn't show an error or warning, even though I have the project language level set to 6.\n. The binding classes cannot be instantiated anymore and all function addresses have been moved to the capabilities classes. This was part (22e8f34dbcbcbf526ef02fc1db11e063271ae4b8) of the recent function calling optimizations.\nThis issue is partially fixed by 364b881cc138f2cf8ef8d8d8818ea93d7fad5249.\nThe plan is to make all GLX & WGL extensions usable without a current context. I'll add GLXCapabilities and WGLCapabilities classes and all platform-specific extensions will be removed from GLCapabilities.\n. > I assume that this is for the time stamp of when the file was last changed so that it can skip extra work but is that all its for?\nYes, incremental Kotlin compilation in IDEA + checking time stamps was the only way to have a decent workflow while working on templates.\nThe current scheme also uses the Kotlin sources to discover and run the template classes using reflection (using Class.forName(\"$packageName.${it.nameWithoutExtension.upperCaseFirst}Kt\")).\nA few comments on your experiment:\n- First of all, thanks for spending time on improving LWJGL and having the courage to mess with Kotlin. :)\n- Being able to programmatically configure the build would be very useful indeed. Ant works fine for now, but I don't like how the definitions for each binding are scattered in several places/scripts. So if there's no way to refactor that into something clean, we'll have to find a better, scriptable, solution. With that said, I don't think working on #16 is worth the effort. I've had to deal with a lot of horrible stuff while working on LWJGL, but nothing comes close to Gradle.\n- The work on #165 should take place before anything else. I haven't shared my exact thoughts on it yet, but let me just say that I've been thinking about converting all templates to something that isn't Kotlin code. I can now say that writing the generator in Kotlin was worth it, moving away from Java interfaces + annotations was worth it, using Kotlin for the templates themselves was not worth it. The compilation overhead and IDE issues when working on big templates (of which we have many) have become too painful to deal with and I'm willing to sacrifice the (partial) type-safety and other Kotlin goodies we have now. Also, we've had virtually no contributions to binding templates so far... I think moving away from Kotlin will help with that.\n- I don't think #100 is very important yet. With the current LWJGL design, most bindings have literally no native code at all. Anything you don't need from the LWJGL build you can take out easily: strip any packages you don't need from lwjgl.jar and don't include the shared libraries you don't use. The lwjgl shared library is quite small and won't grow that much.\n- I created #100 to be able to easily work on random bindings, that have little or nothing to do with what LWJGL is usually used for and don't make sense in the default distribution. E.g. two years ago I created ODBC bindings with LWJGL 3 (which work fantastically well btw), or earlier this month I wanted to try LMDB and I had it up and running in LWJGL in an afternoon. Just like #169, I don't see a problem with including all that in the LWJGL repo, as long as we have control of what is enabled by default and goes into the official distribution.\n. Hey @ShadowLordAlpha, could you please rebase the gradlebuild branch on top of the current master and push it again? It's very hard to review your changes in the current state.\nBtw, generated sources are ignored in the main repository because tiny changes in the generator can produce massive diffs in the generated code. We do track progress though, in a separate repository, here.\nIn other news, Kotlin 1.0.2-beta now supports incremental compilation in Gradle builds.\n. > decently sure that its 1.0.1-2 that supports it\nAccording to the Change Log, you'll need an 1.0.2 build.\n\nMost of the code was refactored to different areas\n\nOK, I see the new structure, but I don't know why it was necessary. The current structure was chosen to match Gradle/Maven conventions.\n\nThis gradle buildfile was only built to build and run the generator code\n\nCompiling and running the generator is simple enough and I already have a gradle build that does that (locally, haven't pushed it on github anywhere). The issue I had was making Gradle behave like the current Ant build, where inactive bindings are not included in the source path at all. Your build doesn't do that either. It's probably not a big deal now with incremental compilation, but it'd be nice to have.\nAnother thing I had done is use a master build.gradle under the root, then have a separate build.gradle for each module (under modules/core and modules/templates). Not sure if that made things unnecessarily complex and contributed to the trouble I had.\n. > I think it would also be good to see if they actually do speed anything up so a benchmark with a few functions first or something.\nI've actually been testing it for the last couple of days. Got incredibly excited at first, because it sounded like it would improve all JNI methods, even methods that don't use arrays. Results:\n- There is indeed a benefit when doing Java-side computations and passing the array to JNI without a copy. We tested JOML code for this. The alternatives, calc on FloatBuffer or calc on POJO+copy to FloatBuffer, were slower.\n- There is absolutely no benefit to primitive-only JNI methods. Critical Natives do indeed skip some setup overhead in the JNI wrapper, but it's no more than 1-2 CPU cycles (measured with JMH).\n- Critical Natives are only used in a few crypto methods in the JDK, so they have been tuned for exactly that use-case (passing Java arrays). I figured it could get better, so I hacked JDK 9 and produced a build that removes even more stuff from the JNI wrappers. That gave real benefits even for the primitive-only case (for a no-arg method: 9.1ns down to 5.6ns per call). That was just an experiment, I don't think it's worth pushing for something like it, since Project Panama is coming in JDK 10.\n\nAnother con you forgot is that its a JDK 7 feature.\nMaybe it could be a secondary artifact, for those who know users will run on Hotspot JDK 7+\n\nHonestly, I still hate it that LWJGL needs to be Java 6 compatible. If it were up to me, it would support Java 8 and up. Even Android supports Java 8 now. Maybe open this discussion again before the 3.0.0 release?\n\nMaybe LWJGL could have methods (or a utility class) that accept primitive arrays and where not supported (pretty rare situation IMO), automatically copying it to a buffer and using the buffer version of that API. Would allow users to use standard java arrays everywhere without worrying too much about compatibility.\n\nTechnically possible, but would be too much code for very few (if any) users.\n. > but skips the JNI step? If that's the case that'd be amazing.\nYes and a lot more. The current prototype can even generate inline assembly using pure Java.\n\nI'm afraid something like this could prevent developers from pushing their apps to those platforms if this is a change that can't be optional.\n\nUsing array parameters will work on any JVM. If a JVM doesn't support Critical Natives, the only difference will be a performance penalty when using such methods.\n. An initial implementation is available in the array-params branch.\n. Support for Hotspot Critical Natives is now available in LWJGL 3.0.0 build 77.\nThe current implementation does not include byte[] array overloads. They would have low usefulness and would result in a massive number of new overloads. If you have an interesting use-case for byte arrays, please post here. It would be possible to generate byte[] overloads for specific functions only.\n. > Does the only benefit \"Lambdas and default methods in interfaces.\" justifies ignoring the widespread uses of Java 7?\nNo, it doesn't. Callbacks have a very small API surface and most improvements will only be felt by the project maintainers.\nOn the other hand, the widespread use of Java 7 does not justify not moving LWJGL 3 to Java 8. Most such uses are in server applications, stuck on legacy frameworks. The point is that there is no good reason to NOT require Java 8. The votes/responses so far confirm this. LWJGL 3 is not Spring, it isn't backwards compatible and there are no existing huge codebases that need support. We could support Java 6 (or 1.4 even), but we don't have to.\nOn Android support: The current assumption is that it won't be possible to download \"LWJGL for ARM\" and have it work on Android without changes. It will be possible for systems like the Raspberry PI, but Android will probably require special handling and changes to the library core and even the binding APIs. This means a fork maintained separately, we could make a different choice for the required Java version there.\nDisclaimer: I have zero experience with Android development, I don't know what the best approach will be and the above is subject to change. LWJGL 3 depends on low JNI overhead, good NIO buffer performance and Unsafe intrinsics. The situation on Android (no \"real\" JVM, AOT compilation, the NDK) is complicated and everything will be determined by actual testing.\nFWIW, I ordered an Nvidia Shield today and will start experimenting some time after 3.0.0 is released.\n. With the #182 changes, the transition to Java 8 is now complete.\nJava 8 compatibility enabled another nice improvement to the public API: MemoryStack now implements AutoCloseable (a Java 7 feature really), which means it is now possible to write code like:\njava\ntry ( MemoryStack stack = stackPush() ) {\n    // ...use the stack...\n}\n// no pop() required!\nThis is the relevant commit.\n. Why do you think it is a GLFW issue? How did you isolate it down to your GLFW window class? Afaict it crashes in the OpenGL driver, not in GLFW.\nThe Java stacktrace is missing from the log above. Could you please edit your post to remove the log dump and attach the log as a file?\n. You have not provided enough information. There's no Java stacktrace, so we can't see which LWJGL method triggers the crash.\nTextures going translucent suggest a bug in your code, but how can you see translucent textures if the JVM crashes?\n. Sure.\nBtw, have you tried closing Raptr? ltc_game32-109838.dll seems to be involved in the crash.\n. This case is too rare to deserve special support in the generator, there are maybe 1 or 2 such functions in each binding. However, I agree that it's annoying in Java.\nMaybe new memSlice methods in MemoryUtil would help?\n``` java\nMemoryStack stack = stackPush();\ntry {\n    // Multiple buffers\n    IntBuffer major = stack.mallocInt(1);\n    IntBuffer minor = stack.mallocInt(1);\n    IntBuffer rev = stack.mallocInt(1);\nglfwGetVersion(major, minor, rev);\n\n// Unsafe\nIntBuffer nv = stack.mallocInt(3);\nlong a = memAddress(nv);\nnglfwGetVersion(a, a + 4, a + 8);\n\n// If we add new memSlice methods to MemoryUtil\nIntBuffer v = stack.mallocInt(3);\nglfwGetVersion(v, memSlice(v, 1, 1), memSlice(v, 2, 1));\n\n} finally {\n    stack.pop();\n}\n``\n. Have you tried NanoVG? It comes with 4 different back-ends (GL2, GL3, GLES2, GLES3) and has a very simple text rendering API. It also uses the originalfontstash` internally.\n. Technically it's possible (and easy). LWJGL normally does this only when the native API has a dedicated boolean type.\nIs anyone against such a change? It will affect the following functions:\n- glfwInit\n- glfwWindowShouldClose\n- glfwSetWindowShouldClose\n- glfwJoystickPresent\n- glfwExtensionSupported\n- glfwVulkanSupported\n- glfwGetPhysicalDevicePresentationSupport\n. @iamcreasy I mentioned this, int is used because that's what the native API uses. C code can do:\nif ( !glfwInit() )\nbecause C supports numeric values in conditions (they are automatically compared against 0).\n. @arisona Thanks for the reminder, those callbacks have changed too.\n. > I would prefer it be in MemoryUtil instead of Callback as its the class that already does most of the memory manipulation stuff and from what it looks like most of the Callback classes use will be internal except for the free() method.\nA fine idea, thanks!\n\nAlso I would like it if the callbacks return the object instead of a pointer though this is mostly because Java works with objects and not pointers for the most part though I would be fine ether way.\n\nThis is something I'd like to avoid:\n- There's no need for a wrapper object. It would also be an extra indirection in the native-to-Java callback path.\n- I'd like to minimize LWJGL-specific abstractions/utilities visible in user code (in the spirit of making LWJGL code look very similar to the corresponding C code). Note that in example 1 above there's only one mention of GLFWKeyCallback and no mention at all in example 2.\n- I've written a lot of GLFW samples and always find it annoying having to remember callback type names. Auto-complete helps in the glfwSet methods, but not when writing the fields where the callback instances are stored.\n. > No need for one as its fully legal to store it and return it latter as the Interface class without wrapping it in another object. You can even wrap other objects in lambda methods the same way you would wrap lambda methods in full classes.\nThere are two pieces of state:\n- The interface implementation. Can be an anonymous class instance, a lambda, or a method reference.\n- The native callback object (currently implemented with dyncall).\nThe native callback object already contains a (JNI global) reference to the interface implementation. The interface implementation does NOT know anything about the native callback object (it can't know anything if we want lambdas to work). If we want an object return value, the only option is to wrap the native callback object handle in a class. What would be the point of that?\n. Sorry, I'm probably not explaining things clearly. Lets try again.\nThe dyncall callback object (DCCallback*) is a struct. The long value you get from <CallbackInterface>.create(...) is an opaque pointer to that struct. The first member of that struct is the thunk, which is basically the function pointer passed to a native API that expects a callback pointer. Since it's the first member in the struct, the DCCallback* pointer is also the function pointer. You have both using a single long value.\nThe only thing missing now is the Java callback (the instance that implements the callback interface). This is also stored in the callback object struct, in the userdata field. Since the struct is opaque, dyncall has a function for retrieving the userdata field: dcbGetUserData(DCCallback*). So you can do this:\n``` java\nlong keyCB = GLFWKeyCallback.create((windowHandle, key, scancode, action, mods) -> {\n   // ...\n });\nGLFWKeyCallback javaCallback = memGlobalRefToObject(dcbGetUserData(keyCB));\n// or simply\nGLFWKeyCallback javaCallback = Callback.get(keyCB);\n``\n. After implementing the proposed design above and changing all sample code to use it, I ended up not liking it very much. Specifically, I didn't like having to writememFreeCallback(cbHandle);` in clean-up code. After a few more experiments, the final design is a bit weird, but basically what @ShadowLordAlpha requested. If someone reviews the current implementation and has better ideas, please don't hesitate to post here or open a new issue.\nedit: obsolete, see below\n. @kenzierocks Could you share an example please? You're talking about multiple callbacks with compatible function signatures, right?\n. The previous solution was too confusing and error prone. After further discussion a new approach has been implemented that is compatible with existing code, supports all code styles and has no clean-up surprises.\nFinal design\nExample 1 (anonymous class):\njava\nprivate GLFWKeyCallback keyCB;\n// callback setup\nglfwSetKeyCallback(window, keyCB = new GLFWKeyCallback() {\n    @Override\n    public void invoke(long window, int key, int scancode, int action, int mods) {\n        // ...\n    }\n});\n// cleanup\nkeyCB.free();\nExample 2 (indirect lambda):\njava\nprivate GLFWKeyCallback keyCB;\n// callback setup\nglfwSetKeyCallback(window, keyCB = GLFWKeyCallback.create((windowHnd, key, scancode, action, mods) -> {\n    // ...\n}));\n// cleanup\nkeyCB.free();\nExample 3 (direct lambda):\njava\n// callback setup\nglfwSetKeyCallback(window, (windowHnd, key, scancode, action, mods) -> {\n    // ...\n});\n// cleanup\nglfwSetKeyCallback(window, null).free();\nImplementation\n\nEach callback type now generates an interface and an abstract class. For example, the GLFW callback type GLFWkeyfun generates the GLFWKeyCallbackI interface and the GLFWKeyCallback abstract class.\nCallback types as function or struct setter parameters are mapped to the corresponding interface.\nCallback types as function or struct getter return values are mapped to the corresponding abstract class.\nWith the new class hierarchy, there is no free() method in callback interfaces, only in abstract classes. This should make it obvious that clean-up requires a stateful instance and that interfaces are there to enable input lambdas.\n. Method references are perfect for this case. See MouseHelp with method references.\n\nAlso, don't forget to clean up your callbacks. LWJGL provides a convenient method for freeing GLFW callbacks: org.lwjgl.glfw.Callbacks.glfwFreeCallbacks(long window)\n. Yes, the latest nightly build requires project recompilation (it's source compatible, but not binary compatible). If your code references the old SAM interfaces directly (it shouldn't, they were there only for Java 8 lambda conversion), you will also have to refactor your code to the new callback design.\nRead this reply for more details.\n. > Is the buffer to small?\nNot sure what SoundUtils.readVorbis is doing, but it looks like it.\nYou should start by adapting the Vorbis demo. It implements stream decoding to OpenAL in 4kb chunks (see Decoder.BUFFER_SIZE). The source Vorbis Ogg file is entirely in memory though. If you want to stream the file itself, you can:\n- Use stb_vorbis_open_filename. Not an option if the file is inside a JAR.\n- Use a NIO memory mapped file (MappedByteBuffer) and stb_vorbis_open_memory. Not an option if the file is inside a JAR.\n- Implement your own streaming and use the \"pushdata\" API, i.e. stb_vorbis_open_pushdata, stb_vorbis_decode_frame_pushdata and stb_vorbis_flush_pushdata.\n. Your code works fine for me. Things you can try:\n- Don't use a background thread for the decoding.\n- Try a different buffer size.\n- Try a different ogg file.\n. Good idea, thanks!\n. Apparently this change is problematic in IDEs that have try-with-resources warnings enabled.\nSpecifically, a lot of times a NativeResource instance does not own the associated native memory (example: GLFWVidMode vidmode = glfwGetVideoMode(monitor)), so freeing/closing it is not only unnecessary, but also illegal (would crash the JVM). But IDE inspections do not have that information and report warnings in many situations where they shouldn't.\nIn IntelliJ IDEA, the relevant inspection is Java -> Resource management issues -> AutoCloseable used without 'try'-with-resources. If you'd like to keep it enabled, you may add org.lwjgl.system.NativeResource under Options -> Ignored AutoCloseable resource types and the problem is fixed.\nAfaik Eclipse does not offer such customization. The following warnings should be disabled:\n- Code style -> Resource not managed via try-with-resources (1.7 or higher)\n- Potential programming problems -> Potential resource leak\nPlease post below if you have information on NetBeans.\n. See #177, LWJGL 3 requires Java 8.\n. No, sorry, that would effectively make VkInstance objects mutable.\nIt would be possible to make vkCreateInstance return a VkInstance, but it already returns a value (the error code). An option would be to swap the VkInstance parameter and the return value like:\njava\nIntBuffer pi = ...\nVkInstance inst = vkCreateInstance(inst_info, null, pi);\nint err = pi.get(0);\nbut I don't think that's any better.\n. > How would it make it more mutable that it already is?\nBecause between VkInstance foo = new VkInstance() and vkCreateInstance(..., foo), you have an object that is invalid and cannot be used for anything. If vkCreateInstance fails, you still have that object. If vkCreateInstance succeeds, it would be possible to call it again and modify the existing object. It's bad design.\n\nSo I should have added this but It would be more like a builder method than the current allocation method.\n\nBest I can do is a factory method that calls vkCreateInstance for you. Something like (in the VkInstance class):\n``` java\npublic static VkInstance create(VkInstanceCreateInfo pCreateInfo, VkAllocationCallbacks pAllocator) {\n    try ( MemoryStack stack = stackPush() ) {\n        PointerBuffer pp = stack.mallocPointer(1);\n        int err = vkCreateInstance(pCreateInfo, pAllocator, pp);\n        if ( err != VK_SUCCESS )\n            throw new RuntimeException(\"...\");\n    return new VkInstance(pp.get(0), pCreateInfo);\n}\n\n}\n```\nand similarly for VkDevice. Error handling is still a problem though.\n. > Also there are a few unneeded null checks in the generated code that uses stack.UTF8() as that method has a built in null check that it does first thing.\nThanks, fixed with d20f8f1a1bd0819be961ff2a2667bc823e8b8f6e.\n. I cannot reproduce this.\n- Are you running the latest LWJGL nightly build?\n- Is the 4096 value important? Does it also happen with other sizes?\n- What's the output if you run with -Dorg.lwjgl.util.Debug=true?\n- What's the output if you run with -Dorg.lwjgl.system.allocator=system?\n. > Should I send you the source code I was using?\nYes please, a short self-contained example that reproduces the issue would be perfect.\n. > I'm unable to reproduce this with simple example, but the issue persists in my game somewhere.\nYou could try the opposite way: simplify your game until it's simple enough to share or the crash stops happening.\n\nCan I use JEmalloc to allocate memory from other threads?\n\nYes, you can.\n. > Can you kindly explain what's going on?\nThe fact that it happens with jemalloc and not with the system allocator makes no sense to me.\nIt's a good practice, but you don't really have to deallocate everything before exiting your program. The memory is freed when the process ends, regardless of the allocator used.\nIf your process doesn't end, there's nothing in jemalloc that would cause that. The only way the JVM stays alive is if a non-daemon Java thread is still running.\nI also tried the above program (from the command line and from inside IDEA) and can't see any issues. What do you see in your system?\n. Hey @sriharshachilakapati,\nI'm fairly sure I found and fixed the issue and it indeed was triggered by concurrent allocations. Could you please download and try the latest nightly build (87) to verify?\nFor those using custom jemalloc builds, make sure to build with --enable-lazy-lock=no on Windows.\n. Awesome, thanks.\n\nI'm curious, can you please tell me how did you find this out?\n\nFirst step was reproducing it. I recently updated jemalloc to the latest version (4.2.0) and wanted to see if there were any performance improvements. I added a malloc benchmark to the jmh-experiments branch and it was failing randomly with 3-4 or more threads allocating at the same time. I then replaced jemalloc with a debug build and inspected the crash logs; it was failing all over the library, in a different function each time. This suggested a fundamental concurrency-related problem. Going through the jemalloc issues, I finally found this. Did another build without lazy locking and everything was fine.\n. Thanks!\n. Thanks!\n. Thanks!\n. This is intentional. Two reasons:\n- Generating byte[] overloads were applicable would add many (100s) new methods, resulting in API bloat.\n- Array parameters were added so that computations could happen on an array, which is then passed to native code without a copy. Byte data is very rarely involved in computations.\nUsing alBufferData as an example, usually you load an uncompressed audio file or decode a compressed one to a buffer, then pass that buffer to alBufferData. No Java computation is going on. Using byte[] here instead of ByteBuffer provides no benefit. You'd already use a ByteBuffer anyway when loading a file (via NIO) or decoding (via stb_vorbis for example).\nAnother problem with low-frequency functions like alBufferData: LWJGL generates JNI Critical Natives for methods with array parameters. The critical path is only enabled after the method is JIT compiled, which on a modern JVM only happens after it has been called many times (on -server the default CompileThreshold is 10000). So, in normal use, methods like alBufferData would very likely be interpreted and non-critical on the native side, which means an extra copy for your data. And the data passed to *BufferData/TexImage/etc is usually big.\nAn example where array parameters are useful: Computing a 4x4 matrix and loading it to a shader uniform.\n. Thanks!\n. > First: For use language Kotlin then generate the * .java ? Comfort? Speed? Standardization?\nThe code generator and the binding templates are written in Kotlin. Reasons:\n- The generator is incredibly complex and a higher-level (than Java) language helps with making the code easier to understand and maintain.\n- Kotlin enables the definition of a DSL-like API for the templates. This makes the templates much more compact, cleaner and enables an extra level of type safety. LWJGL 2 used Java interfaces + annotations for this and it was a bad experience.\n- Kotlin supports multi-line strings and string interpolation which helps a lot when adding documentation to the bindings.\nWith that said, Kotlin is only used offline to generate code. You don't have to know Kotlin to use LWJGL and there's no runtime dependency to the Kotlin runtime.\n\nSecond : In the build.xml ant file downloading native libraries as * .dll , * .so and * respectively .dylib seen in this part of targue\nWhy libraries are downloaded and files are not generated * .c * .h and then be compiled ?\n\nBinaries are never committed to the LWJGL repository, it's a bad practice. LWJGL downloads:\n- Static library dependencies (.lib and .a files), as part of the native compilation process.\n- Misc resources (images, fonts, sounds), for running the tests and demos.\n- Shared libraries (.dll, .so, .dylib files), as part of the release process.\nThe third one is the one in build.xml that you mention. It's there because LWJGL is cross-platform and you cannot build all binaries in the same system in order to do a release.\n\nThird: As used * .h files found in lwjgl3 \\ modules \\ core \\ src \\ main \\ include since I do not watch * .c files\n\nSome of those are single-header libraries. Others are definitions LWJGL needs for statically linked libraries. Not everything requires a corresponding .c file and that's normal. I can provide more information if you'd like to ask about a particular binding.\n. Could you please post the full output when running with -Dorg.lwjgl.util.Debug=true? It looks like the ShaderLibraryLoader is being used, but it fails to extract libjemalloc.so in the temp folder.\n. Thanks, that was helpful. The problem seems to be that java.library.path includes /usr/lib64/ by default. Both libjemalloc.so and libopenal.so are loaded from there.\nCould you please run the same with -Djava.library.path=.? I'm pretty sure it'll fail again, but I'd like to see the output.\n. The fix is in 3.0.1 build 2. Let me know if it works for you please.\n. You can ignore the exception related to opengl32.dll (your application works, right?). The next build should fix it.\n. The single value overload of glGetBoolean returning byte instead of boolean is a bug. The rest are as designed.\n\nAny reason for this? They're really handy because I dont really deal with views over the byte buffers, avoiding dealing with tons of tiny specialized int/float buffers.\nEDIT: I can work around this by using ngl* variants directly with MemoryUtil.memAddress(ByteBuffer) as the last parameter but dunno if this is intended.\nAlso there seems to be missing a method like:\nGL13.glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, ByteBuffer data)\n\nFor a long time LWJGL 3 was generating a \"base\" version of functions with pointer parameters. This version did no transformations (e.g. automatically passing buffer size parameters) and all pointer parameters were mapped to ByteBuffer, regardless of type. This base version also had the javadoc for the corresponding function; all other overloads were referencing this base version.\nAfter 3.0.0b and the introduction of MemoryStack and the work on optimizing buffer instance creation for escape analysis, there wasn't really an important reason to keep such \"base\" versions. Sure, there may be times that using a single ByteBuffer for different data types is convenient, but they should be very few in any codebase and can easily be implemented using the unsafe version (with the 'n' prefix) and memAddress.\nSo, the decision was made to:\n- Drop the base versions. This was hundreds of (rarely used) methods removed from the public API, which is always nice. Better ship a 3.0.0 that is as lightweight as possible, then add stuff later if there's good reason to.\n- Since we have fewer overloads now, javadoc is replicated to all of them.\nMost existing use-cases can be replaced with stack allocations (using MemoryStack). In general, I now consider reusing buffers or caching buffer instances globally an anti-pattern, rethink your approach if you do this often. It's very likely that you've complicated the code with no real benefits (including performance).\n\nMoreover, when I switched to the the existing overload with a 'long' data pointer parameter, that one does this check for some reason:\njava\nGLChecks.ensureBufferObject(GL21.GL_PIXEL_UNPACK_BUFFER_BINDING, true)\nSo now my texture code raises an exception. No idea why is checking for pixel unpack buffer, I'm just uploading DXT data to the GPU : / EDIT: Well technically I'm just allocating the buffer, passing a null pointer.\n\nThis isn't new and is actually compatible with LWJGL 2. Functions that interact with buffer objects have two versions: one that accepts NIO buffers in client memory and one that accepts an offset into the buffer bound to the appropriate buffer object binding.\n\nIf I switch to the ngl* version, which does no checks, everything works as intended.\n\nYes, the binding check is the only difference between these methods. But the ngl method is inherently unsafe and might not do what you think it does (see next answer).\n\nEDIT2: If I switch to the overload that doesnt receives an 'imageSize' parameter and that checks for pixel unpack buffer false, then I just get brown blobs as textures.\n\nYes, because the imageSize parameter is ignored when the data parameter is NULL. What happens is that a texture is created with unspecified contents. So, there are 3 cases:\n- You have the compressed texture data in a PBO and you use glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data).\n- You have the compressed texture data in client memory and you use glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ByteBuffer data) with a non-null data argument.\n- You don't have the compressed texture data and you use glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ByteBuffer data) with a null data argument.\nThere's no reason to use the unsafe method (unless you're doing pointer arithmetic or something and want to pass a raw address to data).\n. > Attention. You are not leaking this java.lang.AutoCloseable. It is allocated by GLFW. Freeing it will potentially crash your application. Better disable this warning in Eclipse.\nIdea: we could identify structs that are exclusively managed externally and not make them AutoCloseable. We could do that by moving the NativeResource interface down to the concrete classes. For example:\njava\npublic abstract class Struct extends Pointer.Default // NativeResource removed\npublic class GLFWGammaRamp extends Struct implements NativeResource // NativeResource added\npublic class GLFWVidMode extends Struct // no NativeResource\n. > Huh?\nPlease note that I was talking in general, not about you specifically.\n\nI have a stack allocator implemented in Java that returns ByteBuffer instances. Single alloc at application startup then I just shell out slices as needed, similar design to the stack allocator yourself said was faster than using jemalloc. Way more simple code than manipulating type specific views, I already went through that. I had the allocator before jemalloc bindings existed, and worked fine for two years until right now.\n\nHave you tried replacing it with LWJGL's MemoryStack? It's simple (thread-local), optimized (also handles alignment) and comes with a rich API (instance & static, zeroing or not, includes typed buffers, array parameters, string encoding). Note that LWJGL creates typed buffers directly, there's no intermediate ByteBuffer instance created.\n\nWhat I am saying is that when I use the overload that doesn't has imageSize, which you're saying I should be doing since I'm not uploading the data at that time, something gets broken, because the texture data I later write to the buffer doesn't gets shown.\nIf I specify imageSize, it works, if I dont, it doesn't. And the only way I have to specify imageSize without the thing raising exceptions is the ngl* call.\n\nOK, I'll look into that. Indeed, if you do have to specify imageSize and NULL client memory, the only way to do that is via the ngl call. What GPU/driver are you testing on? How do you later specify the texture data? With glCompressedTexSubImage2D or glCompressedTexImage2D again?\n. Tried it, passing a wrong imageSize (or 0) to glCompressedTexImage2D causes an OpenGL error and the texture is not initialized.\nThis is indeed a legitimate case in which the removed overloads would be useful. However, I still don't think it's worth restoring all of them. Instead, I propose the addition of new methods in MemoryUtil that create buffers at NULL (which is currently prohibited). So the above case becomes:\nglCompressedTexImage2D( tmpTarget, i, this.internalFormat, w, h, 0, memNullByteBuffer(imgSize) );\nwhere memNullByteBuffer(imgSize) is the new method that is the equivalent of memByteBuffer(NULL, imgSize), but returns a non-null instance. I'm open to suggestions if you don't like the name memNull<Type>Buffer.\n. I understand the problem and as I said, the existing methods are fully compatible with LWJGL 2, which did the exact same checks. To understand why:\n- PBO enabled + illegal size/offset => OpenGL error\n- PBO disabled + illegal size/pointer => JVM crash\nSo the idea is that, when PBO is enabled LWJGL allows the user to specify the raw values to size and data, because it's safe. When PBO is disabled LWJGL only allows a buffer argument, which is again safe: size and data are populated automatically from the buffer remaining() and memory address. You cannot crash the JVM by mistake.\nLWJGL 2 also had an overload with just size and no data (NULL was passed automatically). The problem is that something like that is missing from LWJGL 3. We agree that we must fix that. So, 3 options:\n1) Do not add an overload and remove the checks. \n2) Do not add an overload and use something like my memNullByteBuffer suggestion.\n3) Add an overload with both size and data and no checks.\n4) Add an overload with size only.\n1 & 3 are unsafe solutions (will crash the JVM when not used correctly).\nAlso note that this particular check is only enabled in debug mode.\n. I cannot reproduce this with the 3.0.0 release build. Could you please try running the test from the command line (no maven or IDE)?\n. The Java version is not important, as long as it's Java 8 or newer.\nA couple of issues with the above output:\n- The LWJGL version printed should be 3.0.0 build 90, not 3.0.0 SNAPSHOT. Are you sure you're using the 3.0.0 release build?\n- When you specify the natives in the classpath, you don't need to specify java.library.path.\n. > But would it be feasible to use Gradle for that job, since it's basically Groovy and can be run as a script, anyway? I actually have no idea, but maybe it would be possible to cut out the intermediate layer?\nThat would require Gradle to be available on the user's machine. The idea here is to not make any assumptions and to be flexible without any dependencies. A web app or a CLI tool that only requires Java to run, satisfy that goal.\n. What about Apache Batik?\nAnother option would be adding support for NanoSVG, by the creator of NanoVG, but I'd like to avoid it if Batik does the job.\n. We usually add bindings to LWJGL when there's no Java option or the native option is better. I personally haven't done any SVG parsing, so I'm just wondering whether Batik is a viable option. Being pure Java is an obvious advantage, but there are certainly other aspects to consider (binary size, runtime performance and GC pressure, features supported, etc).\n. LWJGL now includes NanoSVG in the NanoVG bindings. I've also added a demo that downloads a .svg file, which then gets parsed, rasterized, converted to a texture and displayed on a canvas (similarly to the stb_image demo):\n\n. Thanks!\n. Sounds like the same issue indeed. To verify:\na) Run glxgears. Does it work?\nb) Build GLFW locally and try out its demos. Do they have the same problem?\nIf the answers are \"yes\" and \"yes\":\n- Report this to GLFW.\n- (much more helpful) If you've got the time, try commits newer than 3.1.2 but older than 3.2, until you find the commit that's responsible for the issue. Since there are a ton of commits since 3.1.2, you can limit testing to commits that affected glx_context.c or x11_window.c.\n. Thanks @elmindreda!\nLWJGL users: the current nightly build contains the latest GLFW master changes. Note that it's a \"modular\" build. If you haven't used one before, you'll have adjust your build process accordingly.\n. Not yet. Support for ARM is scheduled for the 3.0.2 release. We're currently working on #100 for the 3.0.1 release.\n. It's hard to tell without knowing more specifics about it. But yes, projects like Kotlin native, Scala native and JEP 295 are very interesting.. Support for Android & ARM is a (very slow) work-in-progress. It currently lives in the android branch. See the android-test repository for build instructions and demos.. > Is there a version of lwjgl2 that works on arm?\nNo.\n\nare there other things to do? (would it be possible to do this work myself?)\n\nYou can find build instructions in android-test. Assuming you have Android Studio installed and you're experienced with building Android programs, it should be straightforward.\nNote that this produces binaries for the core library and native libraries whose code is included in the LWJGL repository (stb, nuklear, nanovg, etc). Libraries built separately (jemalloc, OpenAL Soft, etc.) are currently not supported. This is the biggest piece of the puzzle missing atm.\nAlso note that this produces a build that is Android-specific. It won't work on a generic ARM device. But most of the work done for Android will be useful for generic ARM builds.\n\ndo you have any idea how slow it will be? (several months, several years, unlikely to ever exist?)\n\nSeveral months at best. Reasons:\n\nCurrently there isn't anyone else contributing to this effort. I've repeatedly asked for help with porting the LWJGL-CI projects to Android/ARM.\nI've been very busy the past few months and this will continue for quite a while.\nThis is necessarily a side-project for me, LWJGL needs to progress regardless of what happens with the ARM builds.\nI've been demoralized by how bad Android is at optimizing Java code. The NIO implementation is a joke and we cannot even depend on the most basic of optimizations. To get decent performance may require significant rewrite of LWJGL internals and even API changes. I really don't want to do that.\nRecent advances like Scala Native and Kotlin Native may make this entire effort obsolete, why bother with JNI anymore? On Android for example, you can easily write most of your application in Java/Kotlin and offload performance-sensitive and native-interop code (e.g. OpenGL/Vulkan) to Kotlin Native. Great development experience + zero overhead.. > I guess raspberries are included in \"generic ARM device\"?\n\nYes. Any device that can run a Linux ARM JDK (e.g. Oracle JDK, Zulu Embedded).\n\nI think lwjgl is still very interesting for raspberries.\n\nIndeed. And with a Hotspot JVM it should run great as is.. That article is for lwjgl2, so not applicable to lwjgl3.\nBuilding LWJGL for ARM locally should be simple. The existing scripts should work out-of-the-box, or may require minimal changes. If you try it and encounter problems, please open a new issue and they will be addressed.\nIn order to have official support though, the build needs to be practical. For LWJGL, this means the ARM builds must run on Travis CI. The script that builds the Linux x64 binaries is here. We need a script that installs a cross-compiling toolchain for ARM and then builds LWJGL using it. Then we need the same for (some of) LWJGL's dependencies.\nIf anyone wants to try that, the process is:\n1) Fork lwjgl3.\n2) Register your forked repository with travis-ci.\n3) Push a .travis.yml file with the build script you wrote.\n4) ...repeat 3 until it works.\nYou're done when ant compile-native succeeds. Ignore ant upload-native (you don't need awscli and the secure variables either).\n. > it should actually compile the natives correctly and I'll have a working LWJGL on my raspberry?\nI'm saying it's a good starting point. The master branch doesn't know anything about ARM atm, so it'll think it's doing an x86 or x64 build. This will likely be problematic, but it shouldn't take many changes to make it work. Better build instructions:\n\nant compile-templates (this compiles the Kotlin code, it will take a while)\nant compile (generates the Java/C code, compiles the Java code)\nant compile-native\n\nThe last one will probably fail with an ARM toolchain. You'll have to modify config/build-definitions.xml and config/linux/build.xml to make it work. You can use the android branch as a reference and see what changes were required there. Note that the Android build has its own config/android/build.xml but you won't need to do that for a Raspberry build.. Hmm, yes, doing the Kotlin compilation on a Raspberry is a waste of time. It's very slow, even on a high-end workstation, and there's no support for incremental compilation via the cli. It also needs around 1G of memory, not sure if the Raspberry has enough.\n\nIf I compile the Kotlin on my pc, then transfer the library to my raspberry to proceed to the next two commands is it going to be ok?\n\nIt should. Also copy any touch.txt files and make sure the last modified timestamps are maintained. You should be able to run the following targets on the PC:\n\nant compile-templates (Kotlin compilation)\nant generate (Java/C code generation)\nant compile (Java compilation)\n\nThen copy the modules/core/src/generated/ and bin/ folders to the Raspberry.\nI also recommend disabling most bindings in config/build-bindings.xml (set the corresponding properties to false) until you have the core build working. It should significantly speed-up the build process.. I haven't tried compiling rpmalloc on ARM yet, not sure what the problem is. It seems to support ARM, but you may want to disable it for now (it's optional). Bindings can be disabled in build-bindings.xml.. The following bindings are built externally (see the LWJGL-CI repositories):\n\nAssimp\nbgfx\ndyncall\nGLFW\njemalloc\nOpenAL Soft\n\nThe lwjgl3 Ant script downloads them as necessary, in shared or static library form.\nCurrently there are no CI scripts to build the above for ARM. Only dyncall has been ported to Android/ARM (example .travis.yml), because it's the only binding that the lwjgl3 core requires (that's why you're getting the symbol lookup error above).. > are you fine with using docker to cross-compile the binaries or do you prefer another solution?\nIt must be in the form of a .travis.yml script that can run on Travis CI. For example, this is the script that builds and uploads* lwjgl's linux binaries.\nDocker is supported on Travis CI and I have no objections if that's what you want to use. As long as it works and is not a maintenance nightmare.\n* if you go for it, ignore the uploading part (awscli and the secure vars). @intrigus has almost completed an LWJGL port to ARMv6. This is the CPU architecture of the original Raspberry Pi.\nI'm worried that we'll end up wasting a lot of time and effort on supporting builds that very few people will use. Is it reasonable to support ARMv6 these days?\nWhat are the top architectures in widespread use today? We should focus on those, for both the Android/ARM builds and the generic ARM builds.. liblwjgl must be linked with dyncall (as a static library).. > Not even sure how to turn online mode off\nThe LWJGL repository doesn't contain the source code for all libraries it supports. Some are too big or have complex build systems. These libraries are built externally on Travis CI and AppVeyor. The Ant script downloads the prebuilt binaries as necessary.\nAny attempt to do an ARM build should be done in offline mode, simply because there is no CI infrastructure for ARM yet and no binaries available to download. It's also useful when working with a custom build of a supported library and want to be sure it won't be overwritten.\nYou run export LWJGL_BUILD_OFFLINE=true and then the Ant build will not attempt to download anything.\n\nbut for my build, they are directly in repo/libs/linux/x64\n\nSorry for the confusion, but there's been a major change to the project's directory layout 2 weeks ago (00e1f52cf95c16b0cea34c83372145532b4745ba and 06e044e7bc5eecc841dff78a242dd3f0e453db16). Previously libs was a top-level directory (relative to the repository root), but now lives under bin/. This is cleaner and makes it easier to get the repo to a clean state (simply delete the bin folder).\n\nbin/libs/ is where all (Java & native) dependencies are downloaded and where linked shared libraries are copied to.\nbin/${platform}/${build.arch} is where compiled object files are stored.\n\n\nThe mali drivers came with libEGL.so only so there is no libGL do I need to not be using GL11. GL12. etc. calls in my code or what am I missing?\n\nThere is no simple answer, it depends on the driver used and what you're trying to achieve. Without knowing more details, here are some things you can try:\n\nFirst of all, for OpenGL ES, use the classes from the opengles module. org.lwjgl.opengles.GLES , GLESCapabilities, GLES20, etc.\nTo make sure the correct driver is being loaded, enable the loader debugging with: -Dorg.lwjgl.util.Debug=true and -Dorg.lwjgl.util.DebugLoader=true. It will print out which shared libraries are being loaded at startup.\nTo override the library to load, see the org.lwjgl.system.Configuration class. It supports both system properties and programmatic access. Useful options in your case EGL_LIBRARY_NAME, OPENGL(ES)_LIBRARY_NAME (these can be relative/absolute paths to shared libraries, makes things easier).\nIt's technically possible to use EGL with desktop GL, see #359 for example. (again, depends on the available driver). Ideally, the ARM builds would reuse the current Linux setup (build.xml, version.script, custom headers, etc). Duplicating all that and maintaining it long-term would be a pain. Then there'd be some kind of flag that enables the cross-platform compilation for the target architecture (it would override build.arch, at least).\n\nAndroid will probably require a separate setup though. So, long-term, we should end up with the following platform/architecture matrix:\n|Platform|x86|x64|ARMv7/AArch32|ARMv8/AArch64|\n|-|-|-|-|-|\n|Android|||X|X|\n|Linux||X|X|X|\n|macOS||X|||\n|Windows|X|X|||\nThe preferred naming for branches is master-<platform>-<abi>. I don't think we'll support more than one 32-bit ARM ABI (i.e. v7 hard-float), so the generic aarch32/aarch64 can be used for the ARM branches.\nBtw, there's a branch per platform/ABI because I hate the .travis.yml syntax for running matrix builds. Not sure if it has been improved lately, but if you can write a script that produces both 32 & 64-bit binaries with good readability, go for it and use a single master-linux-arm branch.. LWJGL uses .remaining() in all methods and struct setters. Why would .capacity() be used instead of .remaining()?\nCould you share the code you use to initialize the VkDevice?\nFor a working Vulkan demo using LWJGL, see the HelloVulkan sample.\n. OK, I see the problem. First of all, LWJGL is consistent with typical NIO code: When you pass a NIO buffer to a method, the method consumes (reads from or writes to) the part of the buffer between position() and limit(). In this example, when calling:\njava\nqueueCreateInfo.pQueuePriorities(priorities);\nLWJGL will use the current priorities.position() (not the start of the buffer) to set the pQueuePriorities pointer and priorities.remaining() to set the queueCount value. The remaining number of elements is limit - position, which is exactly how typical NIO code behaves.\nSo, you have two options:\na) Use relative put calls when filling the buffer, then flip() the buffer before passing it to the consuming method, or\nb) Use absolute put calls when filling the buffer, so that position() never changes.\nLWJGL recommends the later, it makes the code shorter and easier to understand. See Strategy 2 in Memory management in LWJGL 3 for more information.\n. All demos are synced with code changes that will appear in the next release (3.0.1). If you'd like to test the current Vulkan sample, you'd have to use the latest nightly/snapshot build.\nIf you're using the 3.0.0 build, you can see the state of the Vulkan sample at the corresponding point in time*, here. There is indeed a breaking change, struct members that accept VK_TRUE/VK_FALSE are mapped to Java booleans now.\n* You can do this for any release by going to releases -> release version -> commit link (e.g. 9bebd53) -> Browse files\n. LWJGL 3.0.1 will be released once the work for #100 is complete. Currently pending is the deployment of the various bindings as separate artifacts on Maven Central.\n. LWJGL 3.1.0 has been released. Maven dependencies for lwjgl-lmdb on Linux:\n``` xml\norg.lwjgllwjgl3.1.0\norg.lwjgllwjgl-lmdb3.1.0\norg.lwjgllwjgl3.1.0natives-linuxruntime\norg.lwjgllwjgl-lmdb3.1.0natives-linuxruntime\n```\n. I'm not sure what's happening here, but I don't think it's something we'll be able to fix from our side. We don't do anything special when building JARs.\nSetting global variables that affect all Java processes doesn't sound like a good idea anyway.\n. I think I found the problem, could you please try again with the above commit?\n. Thanks!\n. The native library loading code in LWJGL has been enhanced in order to output useful information under debug mode. This has been very useful to debug startup issues and helps a ton when users report issues to us.\nIndeed, the current implementation does not call System.loadLibrary anymore; it's opaque and we can't print the information we need.\nLWJGL should work fine without doing anything special for the native libraries, except adding them to the classpath. Do you really have to use OSGi's native library loading functionality? What happens if you skip Bundle-NativeCode:? Is there a benefit you'd miss if you do that?\n. Thanks for the detailed explanation. You were correct to assume that I don't know much about OSGi, the above helped a lot.\n\nAs you may know, there isn't a classpath in OSGi. There is, in some sense, a classpath inside each individual bundle. Bundles cannot see native libraries loaded by other bundles, and each bundle is assigned its own classloader.\nThis means that at a minimum, in order for LWJGL to work, the LWJGL jar and individual platform jars have to be re-packed into a single bundle.\n\nIs there a 1:1 relationship between a \"bundle\" and a JAR? Isn't it possible to define a bundle using multiple JARs?\n\nThis means that the platform jars can no longer be packed into a single OSGi bundle without file collisions unless an extra bit of indirection is added in a manner that LWJGL's library loading code can understand (such as moving each library to natives/linux/x86/liblwjgl.so, natives/linux/armv6/liblwjgl.so directories in each platform jar so that the jars could be merged without any collisions).\n\nLWJGL 3 initially used a similar structure. At some point it became clear that users preferred a flat structure, as in LWJGL 2. For this reason we now have binaries with architecture/ABI suffixes (e.g. lwjgl.dll on Win64, lwjgl32.dll on Win32). When we add ARM support, the new binaries will have appropriate suffixes (e.g. liblwjgl-arm64-vfp-hflt.so and liblwjgl-arm32-vfp-hflt.so), so collisions won't be an issue. Ugly, but it'll work.\n\nI suspected this would be the case, and it's why I suggested a property that can be set at run-time to enable it.\n\nYes, that would be a solution. But I'd like to first consider other, possibly cleaner, options.\n. I made it work without a special flag. Could you please test with the above commit?\nBtw, this applies to \"JNI\" libraries only (native libraries that the JVM links with Java native methods). Other libraries (jemalloc, glfw, openal-soft that are bundled with LWJGL and system libraries like OpenGL, Vulkan, etc) are loaded using platform specific APIs (LoadLibrary, dlopen, etc).\n. Running ant release should do it.\nOr, you could download the latest nightly build (3.0.1 b14), it includes the above commit.\n. It is valid. From Formatter's documentation:\n'x', 'X'    integral    The result is formatted as a hexadecimal integer\n. That bug has been fixed with #194. Try the 3.0.1 nightly build.\n. Not at the moment. There are several options available, but so far we've been trying to focus on more important bindings and keeping the library size small enough (i.e. comparable to LWJGL 2).\nThis will change once the work on #100 is complete. We'll be able to add more bindings without worrying about how it will affect the default distribution. This includes bindings to tools that are used only offline (e.g. SPIR-V/glslang), or heavyweight stuff like video decoding.\n. > I have a weird AL10.alGetError() state stuck on 40964, AL_INVALID_OPERATION the requested operation is not valid, when trying to destroy the context.\nThe alGetError function is an AL function. It can only be called within an active OpenAL context, that's why you're getting an INVALID_OPERATION error. If you switch to ALC10.alcGetError the errors will go away, your cleanup code works fine.\n\nI put 0 to mean NULL, not sure about that but can't pass anything else as it takes a long\n\nLWJGL defines a NULL constant in the MemoryUtil class. When used with static imports (the recommended style), code becomes like boolean test = alcMakeContextCurrent(NULL);, which is clean and easily understandable.\n\nSystem.out.println(context + \" is the current context\");\n\nThe second time this is called it should probably be changed to System.out.println(alcGetCurrentContext() + \" is the current context\");\n. Thanks!\n. > What does GLFW error 65538 means?\nIt's GLFW_NO_CURRENT_CONTEXT:\nThis occurs if a GLFW function was called that needs and operates on\nthe current OpenGL or OpenGL ES context but no context is current\non the calling thread. One such function is #SwapInterval().\n\nIs the bug in our application or are you responsible for this?\n\nThe crash log doesn't help. Could you provide sample code that reproduces the issue?\n. > And why does the application have an context on Windows and Mac OSX, but not on Linux?\nNeed to see some code to reply to that.\nThe crash happens on glfwCreateWindow and you cannot have a context current unless it succeeds and you then call glfwMakeContextCurrent. Sounds like you're calling an illegal GLFW function before glfwCreateWindow.\n. A few questions:\n- Does it happen with both fullscreen and windowed modes?\n- What window hints do you specify? Have you tried without any hints?\n- What are the invoke methods you call inside callbacks? Looks like you could replace the lambdas with method references.\n. It doesn't look like an LWJGL bug. The crash happens in Nvidia's OpenGL driver when GLFW tries to create the context... it's hard to say what could be causing this without knowing details about your machine. One way to verify this is to try GLFW's native demos (they are easy to build and run). You should also verify that other OpenGL applications run fine on your system.\n\nThe invoke methods inside the callbacks are only wrapper methods like an Observer Design Patterns.\n\nYou could replace:\njava\nkeyCallback = GLFWKeyCallback.create((long window, int key, int scancode, int action, int mods) ->\n{\n    invoke(window, key, scancode, action, mods);\n});\nwith a method reference:\njava\nkeyCallback = GLFWKeyCallback.create(this::invoke);\n. The snapshot isn't broken, see this reply. The lwjgl artifact now contains the core library only. There are new artifacts for each binding that you have to declare in your Maven/Gradle builds.\n. > Is there an Changelog available?\nThe work-in-progress 3.0.1 changelog is available here.\n\nWhich modules (maven coordinates) do we have to include to have all features from versions before this SNAPSHOT?\n\nFor now, you can see the list of available artifacts here. Ignore the following: lwjgl-natives-linux, lwjgl-natives-macosx, lwjgl-natives-windows, lwjgl-platform. The Maven coordinates look like 'org.lwjgl:lwjgl:3.0.1-SNAPSHOT'. Many artifacts come with native libraries, you use classifiers to get them, e.g. 'org.lwjgl:lwjgl:3.0.1-SNAPSHOT:natives-linux'.\nWe'll soon have a tool on the website that will generate the Maven/Gradle dependency declarations for you. You'll be able to select only the bindings you need (or all of them), the target platform, the declaration style, etc, then you'll just copy/paste the output in your project.\n. > the setter for the value of queueCount is missing from the VkDeviceQueueCreateInfo struct. \nThis is by design. Note that the spec says: \n\npQueuePriorities must be a pointer to an array of queueCount float values\n\nThe queueCount field is set to .remaining() of the buffer you pass to pQueuePriorities. This simplifies code when populating struct members. It is equivalent to hiding count/length parameters in functions, when the count/length can be derived from a buffer parameter (using its .remaining() value).\n\nIt is possible to set this value with the nqueueCount version.\n\nThis is consistent with the unsafe method overloads (prefixed with an n) in LWJGL bindings; if you find the default behavior problematic, there's always a way to override it and implement custom solutions. \n. > It might be related to something like a FileOutputStream not being closed after the native is extracted from the jar and would explain why on next run it works, as native is not extracted by SharedLibraryLoader on second run, (possibly this one requires a .close() after the write).\nThat's a try-with-resources block. Afaict all streams in the SharedLibraryLoader are being properly closed.\n\nThese errors only happen the first time the jar is run and the natives are extracted, the second time everything works fine. It can be reproduced by visiting %temp% (from run) and deleting the lwjglusername folder and re-running the jar.\n\nI'm afraid I cannot reproduce it on Windows 10. Could you please try again with Windows Defender and other antivirus/anti-malware programs disabled?\n. I don't think the SharedLibraryLoader is a solution that can be relied upon for deploying LWJGL applications to end user systems. A better option is native installers for each target operating system. The SLL is more of a convenience for developers.\nWith that said, we can maybe detect this case, sleep a bit, then try again. I tried installing Panda Free Antivirus, but again, couldn't reproduce it. Could you maybe do a few tests to see if something like that works?\n. Did some quick tests, looks like for it to work we need to write+close the extracted file, then acquire a read lock. This means that the antivirus may grab a lock on the file before us, so we can't avoid a sleep+retry loop.\nI have attached a possible fix, could you please do some tests with it?\nsll_lock_fix.zip\n. Updated SharedLibraryLoader.java to lock in extractFile (before the stream is closed).\n. > Tested updated code however no luck.\nStill slow? Or does it fail?\n\nAfter lots of testing I'm not sure locking files is going to help much\n\nHave you tried taking an exclusive lock instead? (will need to use StandardOpenOption.WRITE and lock(0L, Long.MAX_VALUE, false))\n\nbest we can do is before loading a native, test if its locked, if it is, then do a sleep+retry loop.\n\nUse the original fix and suffer the delays?\n. Unless I missed something important, your description is wrong. In both attempts the file is still locked when System.load runs. Note that I'm locking the FileChannel but never close/release the FileLock. The lock is released when the channel is closed, which happens in Library.java after the call to System.load (the try-with-resources block does it).\n. Could you please try the next nightly build? It's a combination of the first fix and some improvements to diagnostic messages. On the first run with -Dorg.lwjgl.util.Debug=true -Dorg.lwjgl.util.DebugLoader=true you should see the message: File is locked by another process, waiting...\n\nAnother possible way around this is we could extract the natives with the SharedLibraryLoader as early as possible (all of them) but lazy load them only on demand\n\nThis is technically possible. I'll think about it, not sure if it's worth the trouble. What would the API look like?\n. I would prefer Slack, because I'm already using it for work. It's not ideal for open source communities (up to 10k messages archived, user count limits), but some projects use it successfully (e.g. kotlinlang with over 3900 users atm).\n. > up to 10k messages archived\nThis looks like a solution for that. Does anyone have experience with it?\n. A Slack team for LWJGL is now available. Visit this page to invite yourselves.\n. This has been fixed in build 18. See this comment for details.\n. I cannot reproduce any issues with build 18. A couple of things that might help:\n- Post a complete, but minimal code sample that reproduces the issue for you.\n- Run export ALSOFT_LOGLEVEL=3 and run your code with -Dorg.lwjgl.util.Debug=true. Post the output here.\n. Looks like the issue was just fixed.\n. Thanks, the IDEA project has recently been moved to the repository root. The Gradle plugin hated the nested project structure.\n. It looks like it's crashing in the OpenGL driver at glGetProgramInfoLog. This is only called by NanoVG if its shader program fails to link.\nI cannot reproduce this on my Mac (El Capitan with Intel Iris 6100, driver version 10.14.73). Both your code and the LWJGL samples work fine. It could be a bug in the updated Intel driver (10.18.65) on Sierra.\n. Hmm, yes.\n. You're correct, the current SharedLibraryLoader implementation is problematic with the modular structure. It only checks for changes in the core library, which from now on is going to change very rarely.\n. You can make LWJGL load the apitrace wrapper using the Configuration.OPENGL_LIBRARY_NAME option (or the -Dorg.lwjgl.opengl.libname system property).\nThe problem is GLFW though, it also loads the OpenGL library and there may be trouble if LWJGL uses another one. So, depending on your OS, you'll also have to use the workarounds described here, under Tracing Manually.\n. Have you tried using a debug context? Use glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE) and call GLUtil.setupDebugMessageCallback() after GL.createCapabilities().\n. Thanks!\n. I may have fixed the issue, could you please try again?\n. Yes, nk_draw_vertex has been removed in Nuklear 1.13 in order to support custom vertex layouts. See this Nuklear issue and this LWJGL commit for details.\n. It's up to you how you do it exactly (hardcoded or whatever). Nuklear doesn't require a particular layout anymore.\n. Thanks, it was indeed a bug in the binding. In the next nightly build, the table parameter will be an NkColor.Buffer. A Buffer inner class is how an array of structs of the corresponding struct type is represented in LWJGL.\n. Looks like you're building with Visual Studio's x64 toolset. You must call vcvarsall x86 (or vcvarsall amd_x86 if you're on an old version) before building the x86 natives.\nAlso, if you're running on a x86 JVM (which is useful for testing the x86 build) you don't need to override LWJGL_BUILD_ARCH.\n. @code-disaster, thank you for the PR and the above changes. I experimented a bit and decided on a different approach:\n- Special support for va_list parameters has been added with 5ed6ca8e44e3cdb7f6a83b9642dcdcb7e733cae8. The va_list type is in GlobalTypes, so it's available across all bindings.\n- Instead of special-case support for vsnprintf, bindings to stdio.h have been added with e0eb9fac8c663049de58ce459b6e320f1289cc82. You should be able to call vsnprintf from trace_vargs without issues.\n- I have added tests that demonstrate how to call vararg functions using dyncall.\nThanks again and I'm eagerly waiting a PR for the bgfx bindings. :)\n. The bgfx bindings are now complete, including documentation. There have been changes to several functions and structs, mostly because of missing AutoSize modifiers.\n. > maybe bump the next release version to 3.1 instead of 3.0.1?\nMakes sense, yes.\n. Thanks!\n. Hey @andmoos,\nWe have just identified a bug in Hotspot that affects JNI Critical Natives on Linux and MacOS. Specifically, when a JNI method with 6 or more parameters is JIT compiled and Critical Natives are used, the first argument to the native function becomes garbage. The first parameter of all OpenGL functions in LWJGL is the function address, so when this bug is triggered, the JVM ends up calling a random memory address and crashes.\nFor now, you can workaround this issue with -XX:-CriticalJNINatives, or use an IntBuffer instead of a Java array.\n. I reported the issue and a patch that fixes it: JDK-8167409\n. Either add the jemalloc module to your project or call Configuration.MEMORY_ALLOCATOR.set(\"system\") before using LWJGL (equivalently start the JVM with -Dorg.lwjgl.system.allocator=system).\n. Thanks!\n. > It would be nice if you could add a mode for Ant Ivy for generating an ivy.xml for the users who are using Ant for building instead of Gradle and Maven.\nWill do.\n. @SilverTiger: Support for Ivy has been added with https://github.com/LWJGL/lwjgl3-www/commit/27bacff7c23bb4892dc348196c67be089d647084.\nI'm not at all sure whether it's useful in practice though. If you or anyone else has any comments or suggestions on how to improve the current implementation, please let me know. It seems to be working in my local tests, but here's a list of things I find troubling:\n\nIt requires editing 3 separate files (ivy.xml, ivysettings.xml and build.xml).\nI have no idea what is the best way to add the sonatype snapshots repository for the nightly build. What I have now works (although slow for some reason...), but I don't know if changing the defaultResolver is practical in a real project.\nIs there a better way to set lwjgl.natives other than using Ant for it?\nIs there a better way to define custom artifacts for a dependency? Specifically, it seems that by default Ivy downloads the classes jar as well as the sources and javadoc. If custom artifacts are defined, it stops downloading sources/javadoc.\nIs there a better way to define the natives artifacts other than using m:classifier?. > I think you have to change the defaultResolver. But you run into problems if you are using a snaphot build and a release build (for example LWJGL 3.1.1-SNAPSHOT and JOML 1.9.0). In that case it may be advisable to use a chain resolver, like described here in combination with the default resolver from the default ivysettings.xml.\n\nThanks! Fixed with https://github.com/LWJGL/lwjgl3-www/commit/f802e4d29b470a3cf9b52699a19290a4b5ac6893.\n\nI'm fine with getting the natives with Ant, as you have to use both, Ant and Ivy. Just out of curiosity: For Windows you are using os family=\"windows, but for Linux and Mac it generates os name=\"Linux\" and os name=\"Mac OS X\". In that case you could also use os family=\"unix\" and os family=\"mac\", or is there a specific reason?\n\nIt's the same conditions used in the LWJGL Ant build. Note that family=\"unix\" cannot be used, there are multiple Unix-based operating systems (that LWJGL does not support) and Linux is just one of them. family=\"unix\" also matches on macOS. The conditions will probably change as we add support for more platforms, but I'll make sure any changes are synced to the dependency scripts.. > Maybe I should raise the issue there and ask them not to start those functions with \"nk_\"?\nIt's OK, I'll rename the methods in our port.\n. > So the first question is, it works by hijacking and wrapping the Runnable of whatever thread you're running on right?\nYes. It's the dirtiest hack in LWJGL, but faster than the ThreadLocalMap lookup. The performance difference is negligible for most functions, but important in some cases. It inlines better, compiles to much fewer instructions and there is no slow-path fallback.\n\nWhy \"ThreadLocalState.class.isInstance(target)\" instead of \"(target instanceof ThreadLocalState)\"? Shouldn't the instanceof operator run faster than dynamically checking the type through isInstance? Or the VM detects the static receiver there and compiles it down to the same instructions?\n\nI don't remember why I used isInstance, but yes, it should be equivalent to instanceof in this case. I'll re-run the benchmarks to verify.\n. JMH results, in CPU cycles:\n- ThreadLocal: 9-10 (~3.1ns)\n- Unsafe with isInstance: 4\n- Unsafe with instanceof: 3\nI will change it to instanceof in the next nightly.\nI also tested with OPENGL_CAPABILITIES_STATE set to static: 1 CPU cycle. This is also completely eliminated in real code (i.e. when doing multiple OpenGL calls). Make sure you read the documentation before using. OpenAL and OpenGL ES have an equivalent option.\n. > Or do you think, it would be helpful to post a minimal Eclipse project, where the error occurs?\nYes, please.\nYou can also try -Dorg.lwjgl.util.Debug=true and -Dorg.lwjgl.util.DebugLoader=true to get more information on why loading the shared libraries fails.\n. Hey @flortsch,\nThe latest snapshot (3.1.1 build 4) includes the SHA-1 hashes in the natives JAR files, as requested.\nThey also include the git revision used to build the shared library, which lets you know whether the binary includes a specific change in the upstream project. This was requested by @code-disaster and is especially useful with libraries that change frequently (e.g. bgfx and GLFW). For example, lwjgl-glfw-natives-linux.jar now includes:\n\nlibglfw.so (the shared library)\nlibglfw.so.sha1 (SHA-1 digest of the shared library)\nlibglfw.so.git (git revision used to build the shared library)\n\nNote that lwjgl_* shared libraries, whose source is included in LWJGL and are built with the core library, do not have a corresponding *.git file. . Hey @BenMcLean, thank you for the detailed issue.\nThe wiki link above is obsolete, it only applies to LWJGL 2. LWJGL 3 uses GLFW, which supports HiDPI on both Windows and macOS. In more detail:\n\nOn Windows, GLFW calls SetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE). If that function is not available, it calls SetProcessDPIAware.\nGLFW provides both window size and framebuffer size callbacks. The framebuffer size callback must be used to call glViewport whenever the window is resized. This will update the framebuffer to cover the entire window. libGDX should do this already.\nThere are indeed pending GLFW issues related to HiDPI support on Windows. These are scheduled to be fixed in the next GLFW release (3.3). I'm afraid there's nothing we can do on our side but wait. LWJGL nightly builds always include the latest GLFW changes, I'll update this issue once the fixes are implemented.. The GLFW issues mentioned have been fixed.\n\nThe next LWJGL build (and the 3.1.4 release) will also include glfw/glfw#1115. The Vorbis demo has been updated to handle DPI transitions correctly. Using Java 9 is recommended for perfect behavior.. The Assimp bindings are now available in 3.1.1 build 5. Many thanks to @sriharshachilakapati!. Cannot reproduce on Windows 10 x64, Nvidia GTX 970, driver v375.95. A crash dump would be helpful.. I can see how the libgdx and unobtanium implementations could have an issue. There are OpenGL function calls inside the framebuffer size callback handler, which is asking for trouble if the OpenGL context is current in a different thread from the event loop.\nI can't see how Multithreaded in lwjgl3-demos could be suffering from the same issue. The width/height updates are not properly synchronized, but I don't think problems there could bring the driver down.\nA couple more things you could try:\n\nRun the demo from the command line instead of IDEA.\n\nTry setting Threaded optimization in the Nvidia Control Panel to On or Off.. Thank you for the detailed report!. There is no problem with the libraries on Maven Central. LWJGL was refactored in version 3.1.0 to have a modular structure. There have been significant changes because of that.\n\n\nThe LWJGL core and each binding is a separate artifact.\n\nThere is no lwjgl-platform artifact in 3.1.0 or higher. The native libraries are available as a separate artifact for the LWJGL core and each binding (same name, different classifiers).\nThe core native library is indeed smaller in 3.1.0 because a lot of functionality has been moved to other modules.\n\nThe download page on our site does not support Maven/Gradle script generation for 3.0.0. Migrating to 3.1.0 or higher is highly recommended.. This request is similar to #160. I don't think it's worth putting any effort into it after the Khronos Virtual Reality Standard Initiative announcement. Unless:\n\n\nsomeone is seriously making a VR application and needs it asap or\n\nsomeone contributes the bindings, or at least does the majority of the work - like it happened with bgfx and assimp).. Hey @rj93,\n\nThere was a bug in the site's script generator. Either regenerate the script or replace the LWJGL version with 3.1.1-SNAPSHOT.\nFixed with https://github.com/LWJGL/lwjgl3-www/commit/748e13709213d9bef63bd051195f516a65f6e7de. Passing 0 to end is equivalent to: end = string + strlen(string);.\nWhat are the value of text and the contents of byteText?\nThe NanoVG demo also uses an icon font (entypo), this is the code that converts the unicode codepoint to a ByteBuffer.. I cannot reproduce this on 3.1.0 or 3.1.1-SNAPSHOT.\nI've also added additional output to nanovg.c and have verified that start, 0 produces the correct end value and exactly 1 glyph is being rendered. As expected, using start, start + byteText.remaining() produces an end value that is one byte off (includes the null-terminator) and there are 2 glyphs rendered (0xE764 and 0).\nThis is exactly the opposite of what you're reporting. Could you post a minimal code sample that reproduces the problem for you?. The problem in the above code is:\njava\nByteBuffer byteText = memUTF8(text);\nlong start = memAddress(byteText);\nlong end = start + byteText.remaining();\nThe end value is passed to nvgText, but that's not the end of the string. memUTF8 by default encodes the text with a terminating \\0 byte. This is fine if nvgText(ctx, x, y, start, NULL) is used. If an explicit end is used, then it must not include the null-terminating byte. The above code can be fixed in two ways:\njava\nByteBuffer byteText = memUTF8(text);\nlong start = memAddress(byteText);\nlong end = start + byteText.remaining() - 1;\nor better:\njava\nByteBuffer byteText = memUTF8(text, false);\nlong start = memAddress(byteText);\nlong end = start + byteText.remaining();. The next nightly build will apply an auto-size transform to NanoVG functions with an end parameter to the end of the string. This means that end will automatically receive the value of memAddress(string) + string.remaining(). It should hopefully make such functions easier to use and the unsafe versions unnecessary.\n\nGenerated bindings diff.\nNanoVG demo diff.\n\nNote that auto-sized string buffers should not include a null-terminating byte.. Thanks! Fixed with https://github.com/LWJGL/lwjgl3-www/commit/ac3fee637feda92533b7d392f7fdece3cd201273.. You are correct, you don't need to license OpenGL to use it in software.\nThe Khronos license is included with LWJGL distributions because it contains a lot of documentation created by Khronos, in javadoc format.. LWJGL 2 and early versions of LWJGL 3 had that class as part of LWJGL. The reasons was that, indeed, all the clGet*Info functions are error-prone and a pain to use. It was removed before the LWJGL 3.0.0 release, because it was considered overly verbose and against the general lwjgl3 philosophy of keeping things lightweight and close to the original API.  It was also a maintenance issue, because every possible return type of every possible Info function ought to be covered. Note that the current InfoUtil class in the LWJGL tests provides methods only for the small subset of information needed by the demos.\nWith that said, the LWJGL test suite is there for a reason; users are welcome to copy code they need and adjust it to their requirements. It is covered by the same permissive BSD license as the rest of LWJGL. If you add more methods, you're also welcome to contribute it back for other people to use, if you wish so.. Are the crashes random or easily reproducible? Could you reduce your program to something simple that you can share and reproduces the crash?\nCan't help you more without additional information, other than mentioning the basics:\n\nCreate a debug OpenGL context and register a debug callback (e.g. with GLUtil.setupDebugMessageCallback()).\nEnable LWJGL's debug mode (with -Dorg.lwjgl.util.Debug=true or Configuration.DEBUG.set(true)).\n\nSee the Troubleshooting page in the LWJGL wiki for more information.. Try -Dorg.lwjgl.util.DebugAllocator=true and -Dorg.lwjgl.system.allocator=system (if you're using jemalloc).. Thanks! I also went through all other structs to make sure nothing else is amiss.. Java conventions are followed for class names only (including struct and callback classes).\nThe original symbols are used for all constants and functions. This is not an inconsistency in LWJGL, but a deliberate design decision. The idea is that new users looking for tutorials are much more likely to find resources written in native code, rather than in Java/LWJGL. Being able to copy/paste C calls inside your Java code, with minimal porting, is an explicit goal of LWJGL. That's why APIs like OpenGL are completely static, when every other Java library exposes OpenGL via instance methods. It's easier to do that (because of the way GL contexts work), but breaks the aforementioned benefit.\nWith that said, you're welcome to fork LWJGL and change its generator to do exactly what you propose. It should be trivial, but let me know if you need help with it.. I'm afraid being friendly to Java developer aesthetics is not a priority for LWJGL. LWJGL is low level, hard to use, designed for experienced developers that know what they're doing. It's also designed to be easy to wrap in higher-level frameworks and engines (see libGDX etc), which are welcome to expose the functionality in a friendly manner.\nGenerating twice as many classes is not an option. LWJGL is already massive and complex as it is.. Site issues can be reported in the lwjgl3-www repository.\nFixed with https://github.com/LWJGL/lwjgl3-www/commit/340914c17ed93868baef9e37ff000d807c65a276. I replaced the old instructions with a link to the wiki's install page.\nThanks!. The Maven dependencies are wrong:\n\nThe 3.0.1-SNAPSHOT version is invalid. 3.0.1 was promoted to 3.1.0 because of significant changes in that release. The current snapshot version is 3.1.2-SNAPSHOT.\nThe lwjgl-platform artifact does not exist anymore, starting with the 3.1.0 release.\nThe native artifacts for lwjgl and lwjgl-glfw are missing.\n\nIt's very easy to fix the above issues. Visit the build configurator, choose the Maven mode and the modules you need, then simply copy/paste the generated script in your pom.xml. You can find the version in the jar manifest (META-INF/MANIFEST.MF).\nThe native jar files have no manifest, but there's a .git file (e.g. lwjgl.dll.git), which contains the revision used to build the corresponding binary. Both class jar and native jar files contain .sha1 files that can be used to verify their build matches. This is actually done automatically every time LWJGL loads a native library and a warning will be printed when a mismatch is detected.\nThe version number is also part of the name of the zip file that bundles everything in downloaded releases (from the site build configurator or from github releases). Bundles also contain a build.txt file with the exact build number.\nI don't think it's worth doing anything more complex than the above. Adding the version number to jar and native files is only going to make the life of users harder (for those that do not use Maven/Gradle/etc), without adding much value.. > > But creating a single, runnable JAR that can directly be deployed to the \"end user\" is not possible\n\nIt is possible. See for example the lwjgl3-demos pom.xml.\n\nThere's also https://github.com/LWJGL/lwjgl3-www/issues/16.\n\nThere are some Wiki pages mentioning plugins that can unpack natives to a target/natives folder or so. But creating a single, runnable JAR that can directly be deployed to the \"end user\" is not possible. One always has to juggle with the native libraries and the java.library.path. Is this right?\n\nNo. Using -Djava.library.path and/or -Dorg.lwjgl.librarypath is supported in LWJGL 3 (like it was in LWJGL 2), but not required. LWJGL 3 automatically discovers natives in the classpath, extracts and loads them.\n\nI wanted to offer an application (as a one-click-runnable JAR) with LWJGL2 and LWJGL3 as a backends.\n\nI can feel your pain, but LWJGL 2 interop was never a goal for LWJGL 3. Also, one-click-runnable JARs... is that even a thing? Afaik the most common deployment strategy these days is platform-specific installers/executables with application-private JREs.\nWith that said, if that's what you really want to do, there is an easy workaround. Add the version number to LWJGL 3 natives and use -Dorg.lwjgl.libname=<libname> or Configuration.LIBRARY_NAME.set(\"<libname>\") to override the default.. > At which point (in time, and in the code) are the natives unpacked from the JAR?\nThey're unpacked and loaded lazily, whenever Library.loadSystem or Library.loadNative are called. See the calls to SharedLibraryLoader.load in Library.java.\n\nI wonder how you handle the temp files: There's always this issue that DLLs on windows cannot be deleted as long as they are loaded in the JVM, and they can only be \"unloaded\" with ugly reflection hacks. I'm curious how you solved this).\n\nThe extracted libraries are never deleted by LWJGL. By default they're extracted to java.io.tmpdir (and some other fallbacks if that fails). The default location can be overridden with -Dorg.lwjgl.system.SharedLibraryExtractPath or Configuration.SHARED_LIBRARY_EXTRACT_PATH.. The relevant code is here. The final path includes the user name and LWJGL version.. > then people reported that their temp-directory was messed up with hundreds of copies of the native library :-/ Lesson learned....\nIn case it's not clear: The SharedLibraryLoader is not supposed to be a solution you use in production. It's there so that it's super simple for developers to setup and use LWJGL (just add a bunch of jars to the classpath).\nI repeat that the best way to deploy an LWJGL-based application is with platform-specific installers. This usually involves pre-extracting all natives to a sub-directory of the application and using good-old java.library.path.. > Of course, this is not about sophisticated Rich Client Applications, but rather about people who want to publish some GL rendering demo, or maybe a small game.\nSee capsule.io for an alternative solution.\n\nDownload. Doubleclick. Runs.\n\nThe problem is that this requires a public JRE installed globally in the system. You'll find that many users do not have that, or they're on an obsolete version. With Java's security reputation on the client and applets, many users avoid Java like the plague. I personally don't remember the last time I installed the JRE on my systems.\n\nthen why should an installer be the \"best\" way? I agree that writing a resource to a temp-file feels like an odd workaround, but I think that it is reasonable.\n\nBecause, as you've found out, writing to temp or user folders won't be appreciated by users. Certainly many applications do it (especially on Windows), but that doesn't mean it's a good practice.. JNI is dying. If you're looking for new JVM features in this area, keep an eye on Project Panama. Among other things, it includes \"native library management APIs\".. > I would instead recommend that each class-library have some utility class or metadata file which provides \"updater info\" that the main jar will use to seek out updated libraries.\nI'm not sure what you're asking for exactly. There's no \"main jar\" in LWJGL and, as I said in my first reply, there's version information in each jar, in META-INF/MANIFEST.MF.\n. > Would it be feasable to check for these sorts of errors and throw a java error than to cause an access violation\nI'm afraid not. It's outside the scope of LWJGL to fix such issues. Some native libraries are hardened against invalid state/input and others are not. Some have mechanisms to report errors and others just crash. This isn't ideal, but it would be impossible for LWJGL to guard against all failure cases. LWJGL is simply a binding layer over the native libraries and doesn't know anything about what's going on inside them.\nLWJGL does protect Java developers with features such as auto-sizing of buffer parameters and null-checks. If you encounter a function that should not accept NULL but does, you're welcome to report it and it will be fixed asap. For more complicated cases (such as validation of correct API use), your best bet is contacting developers of the affected library.. I don't think there is any documentation, other than what little you can find in the header. The API is fairly simple and consistent though and the examples/demos in the nuklear repo should be enough to get you started.. > Why ASM?\nYes, please. javaassist was a temporary solution because I haven't done any bytecode generation before and wanted something high level. I actually tried Byte Buddy first, which was even heavier and I couldn't find a way to generate native methods...\n\nWhy map jclass to Class?\n\nNice! It hadn't occurred to me that you could pass a Class instance as a jclass directly.\n\nWhy ClassToPointer?\n\nThis method and the change to FindClass are actually illegal JNI. All jclass references are local and you cannot return them from JNI code. It works in our simple demos, but you can see it fail in practice if you run the CallbackTest demo with -Xcheck:jni.\nRequesting the following changes:\n\nRemove javassist from dependencies and code.\nRevert change to FindClass.\nWrap ClassToPointer's jclass in a NewGlobalRef.. > Is there a reason why we would want FindClass to actually return a long, when Class/jclass is a supported JNI type\n\nBecause if you wanted a Class, you'd use Class.forName or whatever. I exposed FindClass for the explicit purpose of storing the jclass handle somewhere in native code.\n\nand would also allow the GC to track references without having to make a global ref?\n\nYou cannot use a plain jclass reference outside the JNI function that created it (either via FindClass or by passing a Class instance). A global reference is absolutely required if the jclass handle must be cached somewhere else (because FindClass is expensive).. > That is actually not at all true.\nOf course it's legal to have a JNI function that returns jclass or any other local reference. But what I said is technically correct: the JNI local reference dies the moment you return it and becomes a Java instance reference. You cannot use the local reference, only the Java instance.\n\nwhich is the reason why you had to put NewGlobalRef to the original FindClass method. Because it returned a primitive long.\n\nWhich, as I said above, was the entire point. Of course the ClassToPointer function is a more efficient way to do the same thing, but for the same reason it again has to use NewGlobalRef. Original code that fails with -Xcheck:jni:\nc\nJNIEXPORT jlong JNICALL ClassToPointer(..., jclass klass) { // klass is a JNI local ref\n    return (jlong)(intptr_t)klass; // klass \"escapes the JNI method other than through its return value\"\n} // klass local ref is deleted automatically\nand fixed:\nc\nJNIEXPORT jlong JNICALL ClassToPointer(..., jclass klass) {\n    return (jlong)(intptr_t)(*env)->NewGlobalRef(env, klass);\n} // klass local ref is deleted automatically, but the global ref is fine. Could you please restore the note in the FindClass documentation?. I ended up removing both FindClass and ClassToPointer, because:\n\nThere is no point to call FindClass  from Java, when you can simply use a Class.\nThe updated ClassToPointer was effectively identical to calling NewGlobalRef with a Class parameter.\n\nI've cleaned-up and rebased the tinycc branch to reflect these changes.. Hi @TheDudeFromCI,\nThis was fixed with 6cb0b271f7c0dcdae97a2a49c5b753fab35644f8. It should be fine with a 3.1.2 snapshot build.. Hey @TheMrMilchmann,\nUnlike demos, tests are assumed to always run with both checks and debug enabled. The workaround looks simple enough though, I guess it can be used. Thanks!. Thanks, that call is indeed missing. Note that it only affects functions that accept Java arrays. You can use the equivalent calls with buffers until this is fixed in the next nightly build.. > Now, again, in an OSGi context, we'd expect JAVA_LIBRARY_PATH not to be set. This means that the call to System.loadLibrary won't happen and an exception is raised.\nThis is a bug and easily fixable. The current implementation indeed assumes that in order for System.loadLibrary to succeed, java.library.path must not be empty. Obviously this is not the case with OSGi, where ClassLoader.findLibrary is used.\n\nThe situation is slightly worse for libraries loaded via loadNative because although most of the above logic is the same, the method doesn't fall back to System.loadLibrary and therefore the library will be loaded from the host's filesystem, even though we've bundled a guaranteed-compatible native library for libraries such as jemalloc and glfw!\n\nThis cannot be fixed with System.loadLibrary, because these libraries are not JNI libraries. As I said here, loading them with System.loadNative is required so that LWJGL has a handle to the native library and can resolve symbols.\nIn theory they could be built as JNI libraries, but this would defeat a very important feature of LWJGL: being able to replace those libraries with custom builds. You may want to do that for a few reasons: enable debugging or stricter validation (all LWJGL libraries are built for top performance), include a fix or feature not present in the LWJGL release, or simply because you don't trust the LWJGL binaries.\nThere are two ways to resolve this:\n1) Do not use Bundle-NativeCode for such libraries. Treat them as resources instead of libraries and simply add them to the classpath. LWJGL will take care of extracting and loading them, just like ClassLoader.findLibrary does. This means losing the benefits of OSGi metadata.\n2) Keep using Bundle-NativeCode, somehow force OSGi to extract the native library, figure out where the library was extracted and use Configuration.<libname>_LIBRARY_NAME options to set the corresponding absolute path.\nI'm not sure how 2) could be implemented. Maybe the OSGi's ClassLoader.findLibrary could be called using reflection?. Well, reflection works on Java 8, but not on Java 9 without --add-opens java.base/java.lang=ALL-UNNAMED.\nIs there an OSGi API that can be used instead?. Please try the next snapshot (3.1.2 build 14). The first issue should be fixed and I have added an option to enable System.loadLibrary emulation in Library.loadNative (using reflection, Java 9 caveat still applies).\n\nThere is still the issue of actually accessing resources when there are multiple classloaders involved, but could this be as simple as just passing in a reference to the right classloader?\n\nCould you explain this a bit more? Do you mean that different LWJGL bindings are loaded from different ClassLoaders? \nCurrently LWJGL uses Library.class.getResource() to resolve shared libraries. The new System.loadLibrary emulation also uses Library.class.getClassLoader(). One solution would be to add an overload that accepts a user-specified Class and uses that instead of Library.. Sorry for the delay, the CI builds broke last night and it was too late to fix them. 3.1.2 build 15 is available now.. > It seems like in the code path I end up taking via OSGi, there are no calls made to either System.load() or System.loadLibrary() for libGL.so.1. Is this expected behaviour?\nYes, libGL.so is loaded with Library.loadNative. It just so happens in your case that java.library.path includes /usr/lib64, so it is loaded via the code path that emulates System.loadLibrary.\n\nThe actual symptom I'm seeing is that everything appears to work correctly right up until the first call to GL11.glClearColor(...)\n\nHas liblwjgl_opengl.so loaded correctly? The OpenGL bindings require both libGL and liblwjgl_opengl.. I cannot reproduce this. Could you please try a simple non-OSGi test on your system to see if it triggers the same error?. The problem may be related to Reflection.getCallerClass() in System.loadLibrary. Even though the loading of lwjgl_opengl is initiated from GL.java, the class that makes the System.loadLibrary call is Library.java, which is in the core bundle, not the OpenGL one. But, if my understanding of OSGi is correct, would it fail to find lwjgl_opengl is that were the case? I.e. you would see an error earlier, not when calling glClearColor.. Could you please test if there's a difference with 3.1.2 build 16?. > I suspect that the only way to work around this is going to be by subverting package-private accessibility and calling the Runtime.load0 method reflectively.\nThe code path that leads to Runtime.load0 is expected to fail under OSGi.\nThere was a bug in the previous commit, which I fixed. But then I realized that any reflection-based solution does not work under Java 9 with the default JVM settings. I ended up using method references so that System.loadLibrary is called in the context of the class that calls Library.loadSystem. Please try the next 3.1.2 build (17).. > This is actually the only code path that's taken when attempting to load lwjgl_opengl. Is this expected?\nOh, I see. No, this is not expected if you use OSGi bundles for all libraries. System.load is only used with absolute paths to shared libraries. In the screenshot above I see /tmp/lwjglsomeone/3.1.2-SNAPSHOT/, which is a path generated by the SharedLibraryLoader. In a pure OSGi run, that path shouldn't be used except for non-JNI libraries.\nNot sure what is happening exactly, but I would recommend cleaning up your setup so that we can test each issue separately. Delete the snapshot folder and make sure the application is launched without -Djava.library.path or -Dorg.lwjgl.librarypath.\n\nI've tried to build the bindings myself to try out a few things, but unfortunately they don't compile at the moment:\n\nYou need to regenerate the bindings. Running ant compile-templates should do it.\n\nI'm curious what will happen if the following change is made to loadSystem\n\nThis is effectively what was done in the previous commit. As I said, it should have worked in theory (if it didn't have the bug), but I want to avoid reflection on java.lang internals as it is not permitted (by default) on Java 9. Also, the necessary calls are different on Android (that I need to worry about from now on).. Again, this right here makes no sense to me: /tmp/lwjglsomeone/3.1.2-SNAPSHOT/liblwjgl_opengl.so.\nHave you cleared that folder before testing the latest build? liblwjgl_opengl.so being there is only possible if LWJGL was able to find it in the classpath and extract it. That is NOT the case in an OSGi bundle (afaict) and that's what this entire issue is about.\nSystem.load is called when:\n\nThe library name is an absolute path.\nThe library is found in java.library.path.\nThe library is found in org.lwjgl.librarypath.\nThe library is found in the classpath and extracted to the temp org.lwjgl.librarypath.\n\nThe lwjgl_opengl library is loaded in the static initializer of the GL class. Using the latest build, this is what should happen when running under OSGi:\n\nThe path is not absolute, so System.load is skipped.\nGL.getResource(\"/liblwjgl_opengl.so\") should return null, so the SharedLibraryLoader is not used.\norg.lwjgl.librarypath is not set, so nothing is loaded from there.\nFinally, System.loadLibrary is called, from a class that exists in the OpenGL module/bundle. Reflection.getCallerClass() should return the correct class, which then returns the correct ClassLoader, which then triggers OSGi's findLibrary.\n\nCould you please verify the above?. Build 18 is up. The call sites are a bit ridiculous now, if this works I'll try to figure out a cleaner implementation when I have more time.. Awesome! Thanks for the great feedback and for having the patience to go through this process.\nI have created the lwjgl3-osgi repository and made you a collaborator. It's currently empty and you're welcome to push anything to it. When I have a better understanding of the OSGi packaging process, I'll let you know how to proceed (if we'll move the scripts to a different repo, what groupId to use on Maven etc).\nLets use the new repository for further discussions.. Hey @io7m, could you please verify that the latest snapshot (LWJGL 3.1.4 build 3) doesn't break the OSGi bundles? See here for details.. Thanks! The next nightly (3.1.2 build 16) should contain correct revisions.. Hey @Immueggpain,\naiGetPredefinedLogStream is the only function in Assimp that returns a struct by value. That's not a problem for LWJGL, but it would require an additional native binary to support. I didn't want to introduce an entire shared library (per platform) just for one function, which does not provide critical functionality anyway and can easily be emulated (with a custom AILogStreamCallback).\nI have this in my todo list though and eventually will be supported.. There always was a shared library for Assimp. The problem with functions that accept or return structs by-value is that a custom JNI wrapper must be created to call them. The Assimp shared library does not currently use custom JNI wrappers; all functions are called via the reusable wrappers in org.lwjgl.system.JNI. Adding support for aiGetPredefinedLogStream would require a second shared library to be built and deployed (just for this function).\nA workaround would be very simple, but unfortunately dyncall does not implement dcCallStruct yet (it supports struct arguments but not struct return values). I'm currently waiting for libffi 3.3 to be released and will consider restoring the LWJGL bindings for it. It was originally replaced because building it (on Windows) was a horrible experience, but looks like the situation is better now.. Thanks!. > Can I specify offset and length of an nio.Buffer? glBufferData simply accepts a buffer object but there is no offset and length parameter.\nYou set the buffer's position() and limit(), just like in any API that consumes NIO buffers. The only difference is that LWJGL only reads and never mutates the current position, which reduces the need for additional flip() and rewind() calls. This is all covered in the Bindings FAQ.\n\nThe put method may be fast, but why should I incur unnecessary copy at all? Also I have to allocate new buffers, which is also a problem.\n\nYou can do anything in LWJGL with zero copies. You don't even have to allocate that much, most short allocations can be replaced with stack allocations (see the MemoryStack class).\n\nThe wiki says that we should use MemoryUtil class to allocate buffers. Are you suggesting me to use BufferUtils instead?\n\nBufferUtils should be your last option. The Memory FAQ contains more information.\n\nI think glBufferSubData is used to modify part of the server-side buffer, not client-side buffer. Am I wrong?\n\nYou are correct.\n\nI found out that glBufferData can also accept a java array, but still, no offset and length parameter.\n\nThat's true, array overloads do not support the equivalent of position/limit. One reason is that it would require introducing synthetic parameters to JNI functions, which is against LWJGL's design. Another reason is that using array overloads for functions like glBufferData is not recommended. This has to do with how Hotspot Critical Natives work (you generally don't call glBufferData enough times for it to be JIT compiled, which means additional copies anyway). Array overloads should only be used with small arrays and such functions either don't require custom offsets/lengths or the overhead from copying such short arrays is negligible.\nUsing a custom position for array parameters is out of the question, but if you really want to use a custom length, you can do it by having a look at LWJGL's source code. For example, glBufferData(int target, float[] data, int usage) is implemented with a call to JNI.callPPV(__functionAddress, target, (long)(data.length << 2), data, usage). You can see that there's an explicit size parameter (in bytes). Parameters like data are called \"auto-sized\" parameters in LWJGL and the corresponding size/length/count parameter is calculated automatically. This protects against crashing the JVM with illegal memory accesses.. > But I really don't think that offset and length are synthetic. The native C APIs have such parameters and almost every java method which operates arrays has them too.\nMost have a length parameter, but not an offset (pointer arithmetic in C does the job just fine). As I said above, for rare cases where you need to use the length parameter explicitly, LWJGL provides access to it via the \"unsafe\" overloads (methods with an n prefix) or via the JNI class.\n\nBut does that mean that the array may still get moved after the function returns? And since OpenGL is highly asynchronous, wouldn't that be a problem?\n\nMost OpenGL functions, including glBufferData, consume the data specified before returning. If the actual work is done later (asynchronously), the driver copies the data internally. The buffer may be deallocated by the user or moved by the GC and nothing bad will happen.\nThis is a problem only for functions that store the pointer to the data, such as glVertexAttribPointer. Which means such functions should not have array overloads. I'm reopening this issue until they are removed. If anyone can compile a list of similar functions, I would appreciate it.. Have you tried other OpenGL applications?. Thanks. GLFW in snapshot builds supports MoltenVK already.. Buffers backed by heap arrays are not supported. Read the Memory FAQ for more information.. Interesting, thanks! It will be fixed in the next 3.1.2 snapshot build.\nIf you'd like to stay on 3.0.0 for some reason, here's a workaround you could use:\njava\nlong glEnableClientState = GL.getFunctionProvider().getFunctionAddress(\"glEnableClientState\");\norg.lwjgl.system.JNI.callV(glEnableClientState, GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV);\nand similarly for glDisableClientState.. Thanks!. @raould Could you share more information about your setup? LWJGL version, OS, GPU, driver version, does the native glxgears application work? Also, what does LWJGL output if you run with -Dorg.lwjgl.util.Debug=true -Dorg.lwjgl.util.DebugLoader=true?. @raould It is weird indeed (specifically this line: libGL.so.1 not found in system paths). It would be helpful if you could test a clean project (without jMonkeyEngine, mixed LWJGL versions, etc). Try cloning lwjgl3-demos and running one of the OpenGL samples.. Yes, you can extend org.lwjgl.system.Struct and implement your own struct types. The code that needs to be written in Struct/StructBuffer subclasses is simple, but overly verbose. It's not meant to be written by hand. So:\n\nIf there are only a few types, you can write struct classes for them manually.\nIf there are too many, you can use the LWJGL generator to generate them for you. Add your types to any of the existing bindings, then copy the generated code to your project and change the package only.\n\nThere's also a more powerful alternative: LibStruct. It should work nicely with LWJGL.. Thank you! All YGMeasureFunc tests used the same value for width/height, so this bug was missed.. It's not a problem, LWJGL can include the bindings without distributing the FMOD binaries. Similar to how bindings like Vulkan, OpenCL and EGL do not have any natives. FMOD provides binaries for all platforms, they can be added to an LWJGL application and the bindings will work.. Thanks!. You also risk a JVM crash (or worse, a silent bug) using BufferUtils there. The struct does not store a strong reference to the FloatBuffer instance, only its memory address. After pQueuePriorities returns, there's nothing stopping the GC from freeing the buffer instance and the associated offheap memory.. There's no single answer. It depends on the use case and expected life-cycle of a given allocation. The ideal choice may be different for the different instances of the same struct type or for different invocations of the same function. It's up to you to make the right trade-offs between performance and ease-of-use.\nYou can read more information in the Memory FAQ.. The AIScene validation code checks the mNum members before checking the corresponding pointer. For example, mAnimations is checked only if mNumAnimations is not 0. It does this for all members, they're all optional.\nIf the above doesn't help, please post a short code sample and the exception being thrown.. Oh, you're on 3.1.1. This bug has already been fixed with 6cb0b271f7c0dcdae97a2a49c5b753fab35644f8. The fix is available in 3.1.2 snapshots.. > I would be using the beta build if it were available for maven.\nIt is available via Sonatype's snapshots repository. See the generated script for Maven under Nightly in the build configurator. Use 3.1.2-SNAPSHOT as the LWJGL version and add this to your pom:\nxml\n<repositories>\n    <repository>\n        <id>sonatype-snapshots</id>\n        <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n        <releases><enabled>false</enabled></releases>\n        <snapshots><enabled>true</enabled></snapshots>\n    </repository>\n</repositories>. LWJGL does not support OpenGL ES 1.x.. Yes, that's the plan. We'll then deprecate and eventually remove the existing LibOVR & OpenVR bindings.. There's no problem with keeping the current bindings, except maintenance overhead. I'm just being hopeful, given the companies involved in OpenXR, that the existing VR libraries will become obsolete. In any case, if deprecation/removal happens, there will be enough time for users to migrate their code.. A lot of effort has been put into LWJGL in order to have decent javadoc. There's also extensive documentation and example code on how C concepts map to Java and the LWJGL API. But beyond that, it's outside the scope of LWJGL to teach users how to use the various bindings. There are plenty of demos available (in this repository, in lwjgl3-demos, or elsewhere), but it's not an objective of this project to create demos for every library or feature.\nThere are many resources one can find to learn a new library and the only issue is how to map C code to Java. There's an objective difficulty associated with that, especially for developers that are only familiar with Java, but it's a necessary step in order to use LWJGL effectively. The concepts involved are generic and can be applied to any binding, but it would be preferable to start with the basics and not dive into Assimp immediately. Assimp does not exactly have a friendly API and there are a lot of structs (which usually cause trouble for new LWJGL users).\nIf in the above process specific questions arise, they will gladly be answered in the LWJGL forum or LWJGL on Slack\nWith that said, demo contributions are more than welcome!\n. > is this still something you'd like done?\nYes please! Just note that if the demo is relatively big (multiple resources/classes, etc), consider opening a PR in the lwjgl3-demos repository instead of this one.\nBtw, the recently added TootleDemo is using Assimp to load simple meshes, here. It does geometry processing on load and basic traversing of the mesh data.. The demo supports the core profile but uses it on macOS only. Try commenting out the if statement at line 114.. > siginfo: ExceptionCode=0xc0000005, reading address 0x0000000000000f00\n\nsiginfo: si_signo: 11 (SIGSEGV), si_code: 1 (SEGV_MAPERR), si_addr: 0x0000000000000f00\n\nLWJGL uses a thread-local array of pointers to call OpenGL functions. f00 is the glGenTextures offset in that array. The crashes you're seeing mean that there is no OpenGL context current in the current thread when the function is called (NULL + f00 == 0x0000000000000f00).\nUsers are not expected to know this of course, but another hint is that the crash happens in lwjgl_opengl.dll/so, rather than in the OpenGL driver. This can only happen if a) no context is current or b) lwjgl-opengl.jar and the corresponding lwjgl_opengl shared library come from different LWJGL releases. LWJGL does not do anything in JNI code except forward the call to the native library.\nSuch application bugs are common and indeed LWJGL does not throw a useful exception in this case. It did in previous releases, but a trade-off has been made; the current implementation prefers optimal performance over debugging utility.. Thanks!. This symptom is usually caused by another Cocoa event loop running in the same process. This can happen if you try to interop with AWT/Swing or JavaFX for example.\nPlease note that even if you don't create a Frame/JFrame and simply try to load a texture in a BufferedImage, it is enough to trigger initialization of AWT. That's why LWJGL offers stb_image as a replacement for ImageIO.. > That indeed makes sense, I am using BufferedImage as internal representation for resizing / editing image data.\n\nWould there be other solutions where I could use ImageIO? I've recently updated from lwjgl-2.9.0 to lwjgl-3.1.1and wouldn't mind rewriting input again, but internal data representation changes would be a lot more work.\n\nUsing stb_image, you get the image data in a ByteBuffer or FloatBuffer. You can use that directly instead of a BufferedImage. You can upload the image data as a texture, resize it with stb_image_resize (STBImageResize in LWJGL), or write it out to disk with stb_image_write (STBImageWrite in LWJGL).. > I know this is using ImageIO, but how would I read a file with a given URL with STBImage? I've already tried using url.getPath(), but that doesn't work in a packed jar file.\nThis should help.. Good job @TheMrMilchmann, we needed these fixes.\nThis PR has been merged manually with 2dbfac3ff742ba9dc884db2649da758382f5ca94, c3e5ea3ffb7c7da4f804ced10f1ac341684547e2 and ec09a19c3ca1227ee0567a43ed27065fd090e07f. There are a couple more cases fixed and the code is closer to the original implementation, for performance reasons. It's still not as efficient as I'd like, but it's hard to do the necessary refactoring (NativeClass::convertDocumentation is the blocker).\n\nA piece of documentation on how commits should be titled would be nice.\n\nI'm currently evaluating Conventional Commits (with Angular convention's flexibility) in LWJGL and some other projects. Not going to use the SemVer automation, but I think it's a useful convention. Especially in LWJGL with the dozens of bindings, it makes it easier to quickly identify what each commit is about.\nI'll post some guidelines if/when I make the decision to adopt it.. Error 193 on Windows happens when LoadLibrary tries to load a 32-bit library in a 64-bit process.\nThis error shouldn't happen though. There shouldn't be an opengl32.dll in the temp 3.1.1-SNAPSHOT folder. The OpenGL library is not bundled with LWJGL, it comes with the GPU drivers on user systems.\nNote that opengl32 is the official name of the OpenGL client library on Windows and it's the same even on x64 systems. It's not related to the 32 suffix LWJGL adds to the x86 shared libraries it bundles.. LWJGL runs fine (better actually) on 64bit JVMs. And as you can see in the debug output, lwjgl.dll, glfw.dll and lwjgl_opengl.dll load successfully. The question is how can there be an opengl32.dll in the classpath. I don't have an explanation for that. But the shared library loader wouldn't try to extract and load it if it wasn't there.\nA few things to try:\n\nAsk the user to reinstall their GPU drivers.\nAsk the user to delete the C:\\Users\\AwVzZhH\\AppData\\Local\\Temp\\lwjglAwVzZhH\\ folder and relaunch your game.\nYou may want to update to 3.1.2-SNAPSHOT. Or wait for 3.1.2, it's going to be released tonight if all goes well.. The glfwSetJoystickCallback function, like all GLFW callback functions, registers a new callback and at the same time returns the previously set callback. The GLFWJoystickCallback.create call creates a GLFWJoystickCallback instance from the native handle returned by glfwSetJoystickCallback, i.e. the previous callback (or null if there was none set).\n\nThe .set() method simply calls glfwSetJoystickCallback, it's a shortcut. So your suggestion would either throw an NPE on the first call or would recurse and fail with a stack overflow.. > I'm creating an application where lwjgl is started in a non-main thread. It shouldn't be a problem, right?\nIt is a problem. Most GLFW functions are required to be called from the main thread, which also has to be the first thread on macOS (see -XstartOnFirstThread). The javadoc of each function mentions if it's callable from any thread or only from main. This is neither an LWJGL nor a GLFW limitation; it's the only way to write a usable cross-platform windowing system. Your application may work on Windows, but will certainly fail on macOS. Note that this applies to GLFW functions only; OpenGL contexts can be made current in other threads and those threads can be used for rendering.\n\nLooks like I am forced to delete that folder upon every start of our application, since this has already been causing a lot of troubles and a lot of different errors.\nAny ideas what could be causing them?\n\nThis is odd, but there is not enough information to provide an answer. Which LWJGL version do you use? Could you please run your application with -Dorg.lwjgl.util.Debug=true and -Dorg.lwjgl.util.DebugLoader=true and attach the output here? (from a run that fails)\n. > when added a text wrap widget with a bunch of text, performance came to a \"crawl\" (as in, perfectly playable 22ms per frame, but really awful considering I'm coming from <1ms per frame).\nI knew Nuklear text rendering is not very efficient, because of the callback overhead in the JVM. But 22ms sounds excessive. Could you please post a small demo I can experiment with?\n\nI'm still spending like 80% of the time in the second call, nnk_utf_decode. Now I'm not sure what to do there nor what is that function supposed to do.\n\nThis function decodes UTF-8 bytes in the text buffer and returns the next available unicode codepoint. I.e. it consumes one or more bytes (that may correspond to a Java char, or two if the codepoint is a surrogate pair). The GLFWDemo doesn't care about performance and calls it in a loop. This will obviously have a performance impact on long strings (e.g. there's the JNI overhead). I'll work on a Java implementation and post it here and maybe add it as a utility in LWJGL.\nBut again, 8ms for 4k characters sounds too much, so there may be another problem here. That's why I want to see your code.\n\nsay that I wanted to cache all stbtt_GetCodepointHMetrics results ahead of time instead of lazily as how I am doing right now, how I'd go about that? ie, where these \"codepoints\" from Nuklear are coming from?\n\nWell, you know the text you're rendering, so you can cache everything in advance. Both the horizontal metrics (or other metrics you may need) and the texture quad data (returned by the NkUserFont::query callback). This should be straightforward, unless you need to support dynamic i18n text (say, in-game chat in chinese) where a dynamic caching scheme is more appropriate (for your font textures too).\nThe Nuklear codepoints are simply the unicode codepoints in your text. The Java String and Character classes have plenty of methods that help you deal with codepoints.. You can replace nk_utf_decode with this:\njava\nprivate static int decodeUTF8(long text, IntBuffer unicodeCP) {\n    int b0 = memGetByte(text);\n    if (0 <= b0) {\n        unicodeCP.put(0, b0);\n        return 1;\n    } else if ((b0 >> 5) == -2 && (b0 & 0x1E) != 0) {\n        int b1 = memGetByte(text + 1);\n        unicodeCP.put(0, (((b0 << 6) ^ b1) ^ (((byte)0xC0 << 6) ^ ((byte)0x80 << 0))));\n        return 2;\n    } else if ((b0 >> 4) == -2) {\n        int b1 = memGetByte(text + 1);\n        int b2 = memGetByte(text + 2);\n        unicodeCP.put(0, ((b0 << 12) ^ (b1 << 6) ^ (b2 ^ (((byte)0xE0 << 12) ^ ((byte)0x80 << 6) ^ ((byte)0x80 << 0)))));\n        return 3;\n    } else if ((b0 >> 3) == -2) {\n        int b1 = memGetByte(text + 1);\n        int b2 = memGetByte(text + 2);\n        int b3 = memGetByte(text + 3);\n        unicodeCP.put(0, ((b0 << 18) ^ (b1 << 12) ^ (b2 << 6) ^ (b3 ^ ((byte)0xF0 << 18 ^ ((byte)0x80 << 12) ^ ((byte)0x80 << 6) ^ ((byte)0x80 << 0)))));\n        return 4;\n    } else {\n        throw new RuntimeException(\"Malformed character sequence\");\n    }\n}\nIt assumes the text is well-formed, so does no validation and drops the length argument. If nk_utf_decode is indeed the bottleneck, you should see a measurable difference.. Thanks, I have confirmed my suspicion that the width callback is being called many more times than necessary. The problem is the internal nk_text_clamp function that has quadtratic behavior. If you have a string like \"foobar\", the callback will be called once for each of:\nf\nfo\nfoo\nfoob\nfooba\nfoobar\nYou can imagine how inefficient this becomes when applied to each line of your long text. A workaround is to cache the last calculated width, like so:\n```java\n// Disclaimer: not tested thoroughly\n.width(new NkTextWidthCallback() {\n    private long lastText;\n    private int lastByteOffset;\n    private float lastTextWidth;\n@Override public float invoke(long handle, float h, long text, int len) {\n    float textWidth = 0.0f;\n    try (MemoryStack stack = stackPush()) {\n        IntBuffer unicode = stack.mallocInt(1);\n\n        int byteOffset;\n        if (lastText == text && lastByteOffset <= len) {\n            byteOffset = lastByteOffset;\n            textWidth = lastTextWidth;\n        } else {\n            byteOffset = 0;\n            lastText = text;\n            lastByteOffset = 0;\n            lastTextWidth = 0.0f;\n        }\n\n        int currentGlyphBytes = nnk_utf_decode(text, memAddress(unicode), len);\n        if (currentGlyphBytes == 0) {\n            return lastTextWidth;\n        }\n\n        IntBuffer advance = stack.mallocInt(1);\n        while (byteOffset <= len && currentGlyphBytes != 0) {\n            if (unicode.get(0) == NK_UTF_INVALID) {\n                break;\n            }\n\n            /* query currently drawn glyph information */\n            stbtt_GetCodepointHMetrics(fontInfo, unicode.get(0), advance, null);\n            textWidth += advance.get(0) * scale;\n\n            /* offset next glyph */\n            currentGlyphBytes = nnk_utf_decode(text + byteOffset, memAddress(unicode), len - byteOffset);\n            byteOffset += currentGlyphBytes;\n        }\n        lastByteOffset = byteOffset;\n    }\n    lastTextWidth = textWidth;\n    return textWidth;\n}\n\n})\n```\nPerformance is reasonable with the above code. Using a metrics cache and Java UTF8 decoding on top makes it even faster, but it's not as impressive as before.\nIt might be a good idea to report this to Nuklear. Not sure if performance can be improved without new API though.. LWJGL does not support C++ bindings yet. See #22 and #124.\nHave you tried libGDX's Bullet wrapper?. Bullet bindings are now available in 3.2.1 snapshot 7.\nI'm not at all familiar with Bullet, so please consider this a beta release. Comments:\n\nBullet's code base is weird, e.g. the C API is under an examples folder.\nThe build process was difficult. I had to build it as a set of static libraries and link to shared a library in LWJGL. This means that custom builds will have to follow the same procedure. The LWJGL build uses the default configuration (single fp precision and no multi-threading).\nThe C API is verbose and hard to use, because of the client/server architecture.\nDirect connections (b3ConnectPhysicsDirect) are tested and seem to work fine. Connecting over TCP/UDP does not seem to be possible with the C API (no way to create a server) and b3ConnectSharedMemory fails (on Windows at least).. The collision filter plugin is available and the C API supports it, see:\n\nc\nb3CollisionFilterCommandInit\nb3SetCollisionFilterPair\nb3SetCollisionFilterGroupMask\nI believe the plugin is loaded immediately but, if not, the following code works for me:\njava\nlong cmd = b3CreateCustomCommand(client);\nb3CustomCommandLoadPlugin(cmd, \"collisionFilterPlugin\");\nlong status = b3SubmitClientCommandAndWaitStatus(client, cmd);\nassertEquals(b3GetStatusType(status) , CMD_CUSTOM_COMMAND_COMPLETED);\nint collisionFilterPluginUID = b3GetStatusPluginUniqueId(status);\nSystem.out.println(\"collisionFilterPlugin UID: \" + collisionFilterPluginUID);. > In any case, very recently (3 days ago as of writing this) Bullet guy added the possibility of creating an arbitrary mesh with passed vertices, something that was missing from the C API.\nYeah, I've noticed the new functionality, it will be added to LWJGL in the next maintenance pass.\n\nI'm wondering, all of the C API seems to be using doubles, but you say you compiled it with single precision, so if I use floats in Java land, the C API casts to doubles, but then Bullet inside casts back to floats?\n\nYes, the API accepts doubles, the client/server messages carry doubles, the server converts to floats when processing the messages.\nI don't have a strong opinion about the default build, I can change it to double precision if that's what users want. Alternatively, LWJGL could provide both single and double precision builds and a Configuration option that flips between the two. But then there's also the question about multi-threading (BULLET2_MULTITHREADING in CMakeLists.txt), so we'd have a matrix 2 x 2 x number of platforms/architectures we support.\nI think it'd be better if LWJGL provided a sane default for game development and users that need something different could do a custom Bullet build. I just don't have any experience with Bullet and have no idea what that default should be.. Good catch, thanks!. It should work, yes.\nBtw, what use do you have for glPixelStoref? Afaik, all pixel store state variables are either boolean or integer.. Nuklear itself does not render anything, it only provides data buffers and draw commands. How these are used depends on the application and the rendering API. Are you sure there are no OpenGL or shader compilation errors when running on the Intel GPU?. I'd like to keep the raw CharSequence encoding implementations in LWJGL simple and avoid adding start/end offsets.\n\nI can make it work with a thin CharSequence implementation anyway.\n\nThat's the expected way to do it. It's why string encoding in LWJGL accepts CharSequence, for cases like this. Building a CharSequence view on top of another implementation (e.g. StringBuilder) should be trivial.\nWith that said, I would avoid a StringBuilder and a UTF-8 encoding loop altogether. Why pay the encoding overhead every frame? You could encode the entire text once, to a single buffer. If we're talking about something like a chat box, you should already have a rough idea of how much text is going to be in there (a chat history limit?) and pre-allocate a buffer with the appropriate size. You'd still probably need to reallocate sometimes, but it should be minimal. Then, for each line, you can call nk_text by either manipulating the buffer's position/limit or by using nnk_text and manual str/len offsets.. Thanks!. Creating a hidden GLFW window is the recommended way to do off-screen rendering.\nI don't see how the window visibility state is related to getting a GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT status from your FBO. Could you share a minimal code sample that reproduces this? Also some information about your OS and hardware would be useful.. Could you please try the org.lwjgl.demo.nanovg.ExampleGL3 or org.lwjgl.demo.stb.Vorbis demos and check whether mouse interaction works as expected?\nIs there a difference if you change the DPI settings on the Surface Pro?. LWJGL 3.1.3 build 5 is now available and it includes updated GLFW and Nuklear. Could you please try it?. It sounds like you're using a core/forward-compatible context, which does not expose the glAlphaFunc function. Alpha test is legacy OpenGL functionality that has been deprecated in modern OpenGL. It can be replaced with discard in the fragment shader.. GL_SAMPLE_ALPHA_TO_COVERAGE works with the alpha value that the fragment shader outputs. If the shader is expensive, you can still use discard to early-out when alpha is 0.0. For all other fragments, the alpha value will be translated correctly to a coverage mask.\nAlso note that the alpha test and discard can always be used, but GL_SAMPLE_ALPHA_TO_COVERAGE requires multi-sampling to work.\nAn expensive alternative to GL_SAMPLE_ALPHA_TO_COVERAGE is GL_SAMPLE_SHADING/glMinSampleShading/gl_SampleID. You can make your fragment shader run for each sample, in which case discard will produce the correct coverage.. GLFW is indeed not up-to-date and so are other bindings. I've been busy at work and leaving for a short vacation tomorrow.\nThis PR looks good. I'll merge it next week and prepare a fresh build asap. Actually, 3.1.3 will be released soon after, due to a critical jemalloc bug on macOS.\nThanks!. Minimal, Complete, and Verifiable example. > But what it says is not true I use glGenVertexArrays\nYou do, but only once, in the first window/context. The other contexts do not recognize the VAO name because OpenGL container objects cannot be shared across contexts.\n. > So if I want to create a new window after all the other windows/threads have already started I get an Exception\nFrom the glfwCreateWindow javadoc:\n\nWindows: The context to share resources with may not be current on any other thread.. My guess is: no context in the share group must be current in any thread.. A common setup is to have a context for rendering and a (shared) context in a secondary thread loading resources asynchronously. Using more than one context for rendering is not beneficial.\n\nOpenGL and Direct3D <12 are known to not fully utilize CPU resources (GPU utilization is usually not an issue). This is the reason APIs like Vulkan, Metal and D3D 12 exist. Vulkan, which LWJGL supports, has been designed to take advantage of multiple CPU cores and can be a lot faster than OpenGL in CPU-bound applications. On the other hand, it's a verbose and difficult API to use.. Documentation could be better (unlike Vulkan, OpenGL docs are written by hand, contributions are welcome), but technically LWJGL is doing the right thing here. From the NV_vertex_buffer_unified_memory spec:\n\nIf the context version is greater than 3.0 and does not include ARB_compatibility functionality, then EnableClientState and DisableClientState have been deprecated and removed. This extension adds back those commands, but only requires that they accept the VERTEX_ATTRIB_ARRAY_UNIFIED_NV and ELEMENT_ARRAY_UNIFIED_NV tokens.\n\nCurrently LWJGL will load the function pointers for EnableClientState and DisableClientState, but it won't check whether they're available or not. This will work in any combination of compatibility profile, core profile and presence of NV_vertex_buffer_unified_memory. A strict check could be added, but honestly it would be a waste of effort, this is the only occurrence of a deprecated function being undeprecated.. Nevermind, it was simple enough. Generated code diff: LWJGL/lwjgl3-generated@8cfd34369928fa36096018fed4e12b2c841880b2.\nThanks!. The OpenGL templates used by the generator are here. They are written in Kotlin.. The latest snapshot (3.1.3 build 9) includes OpenGL 4.6 and latest extensions.. The APIUtil functionality is used internally by LWJGL to implement the bindings. The apiArray methods specifically are used in this way:\njava\nlong arrayAddress = apiArray(...);\nnativeMethod(..., arrayAddress, ...);\napiArrayFree(arrayAddress, len);\ni.e. there is no memory leak, the encoded strings are freed by a subsequent call to apiArrayFree.. Rebased manually with 925784825a912bd6b19347375617fa9ecc2f1ac2. Thanks!. LWJGL 3 works great on Java 9. You don't have to do anything special and it runs without --illegal-access warnings.\nThere are no JPMS modules, but the JARs include Automatic-Module-Name entries in their manifests. This should be good enough for users that want to make their projects modular. I don't think we'll do anything more involved with modules until LWJGL 4.\nThe other Java 9 feature in LWJGL is multi-release JAR files. The core library is such a JAR and it includes custom code that uses the new StackWalker API to improve performance when MemoryStack debugging is enabled.\n\nsomething about moving to VarHandles instead of relying on sun.misc.Unsafe\n\nUnfortunately java.lang.invoke.VarHandle is not a full replacement for sun.misc.Unsafe. The first problem is worse performance when accessing off-heap memory. The second is that the security mechanisms in VarHandle won't let you access private class details. This is required for a very simple, but also very critical, reason in LWJGL: to be able to instantiate direct buffers in Java code (see Strategy #3 in Memory Management in LWJGL 3 for more information).\nsun.misc.Unsafe is a special case in Java 9. It is obviously not removed and there are no warnings for accessing it. There is now a more powerful but inaccessible Unsafe, used internally by the JDK itself, but the old Unsafe will remain public as long as there are so many projects using it. The plan is to get rid of it in LWJGL 4, but it all depends on when and in what form Project Panama becomes available.. @TheMrMilchmann indeed, LWJGL 3.1.1 and up should not produce a warning.\n@francogp it looks like you're on 3.1.0, upgrading to the latest release is highly recommended.. That's a problem with the lwjgl3-generated repository, the two EXRMultiPart* classes shouldn't be there.  Remove them (or run ant clean-generated), try again and it should work.\nBtw, the targets init-generated and init-wiki are optional. The former is useful when developing bindings and the latter if you're interested in contributing to the wiki.. > Do we close this then? Or leave it open for any other Java 9 questions people might have?\nLets keep it open for a while.\nThe latest 3.1.4 snapshot (build 3) has a change that fixes the SharedLibraryLoader when all LWJGL binaries are added to the module path (as automatic modules). See here for more information.\nAlso, all natives JARs now have a manifest, with an automatic module name similar to the corresponding binding (e.g. org.lwjgl.glfw and org.lwjgl.glfw.natives.windows). This makes --list-modules cleaner for example.. > Will there be support for those multi-jar things to allow one native jar file?\nNot sure what you mean exactly. Multi-release JAR files allow you to have a class multiple times, implemented differently for different Java versions.\nThere's no technical issue with having all natives in one JAR file. They are in different files to avoid excessive download times (you only need 1/3 of them on a given system). If necessary, they can be recombined in whatever way makes sense for the application that uses LWJGL.. I've been experimenting with modules in another project and found an important problem with automatic modules; the jlink tool cannot use them to create a custom run-time image. The entire project must be contained in explicit modules.\nIt is possible to add module-info to a non-modular jar. I used the ModiTect maven plugin, it's simple and it works, but it's a massive pita if you have lots of dependencies (all transitive dependencies must be fixed too).\nUsing jlink won't be critical for a lot of projects, but I think projects using LWJGL (e.g. games) will be very interested in having a compact runtime (or using AOT compilation in the future). I'll try to make the build produce binaries with automatic modules when building on Java 8 and with explicit modules when building on Java 9+.. The latest 3.1.4 snapshot (build 5) has replaced Automatic-Module-Name with explicit JPMS modules. LWJGL can now directly participate in jlink builds, assuming your other dependencies are also explicitly modular.\nTechnical details\nLWJGL classes continue to be compiled with Java 8 and all jars are Java 8 compatible. The above change adds a module-info.class to the jar file root, that has been compiled with Java 9 and describes the module. The Java 8 run-time will simply ignore it, as there's nothing that attempts to load that class file, but please report any issues that tools/IDEs/etc might have with it.\nThe LWJGL module definitions can be found here. It is not valid Java code, these files would normally be called module-info.java in the appropriate folder of a modular code base. We don't want to refactor LWJGL to do that now, so there's a tool that uses them to generate the corresponding module-info.class. Notes:\n\nModules are named: org.lwjgl for the LWJGL core and org.lwjgl.<binding> for everything else. Note that the module name does not necessarily match the package of the binding (e.g. the LMDB classes are in the org.lwjgl.util.lmdb package, but the module is named org.lwjgl.lmdb).\nEvery binding module has a transitive dependency to org.lwjgl.\nEvery module with natives has a transitive dependency to the corresponding org.lwjgl.<binding>.natives module.\nNative modules for a binding have the same name, regardless of platform.\n\nExample\nAssuming the LWJGL jars have been downloaded to lwjgl3/ and you want to run a non-modular application, compiled to bin/, that uses GLFW & OpenGL, you can do so with:\njava --module-path lwjgl3 --add-modules org.lwjgl.glfw,org.lwjgl.opengl --class-path bin <main-class> <args>\nNotes:\n\nBecause of requires transitive in the module definitions, you only need to add org.lwjgl.glfw and org.lwjgl.opengl. Everything else is resolved automatically, including the natives.\nBecause all native modules for a binding have the same name, the lwjgl3/ folder cannot contain native jars for more than 1 platform. For example, having both lwjgl-glfw-natives-linux.jar and lwjgl-glfw-natives-windows.jar in lwjgl3/ would result in an error when the application is launched.. No further issues related to Java 9 have been reported, so I'm closing this. Thanks everyone!. I'm not familiar with Eclipse so I cannot advise about the project setup.\n\nYou could try running the generated command line manually, with --validate-modules. It should provide enough hints to help you resolve the issue. Note that you don't have to specify each LWJGL jar individually in -p, using <libs_path>/lwjgl/3.1.5 should be enough.\nUnless demonstrated otherwise, there are no bugs related to JPMS in LWJGL. We even have applications in production running via jlinked images using LWJGL. Btw, jlink requires everything to be in the module path, in explicit modules (Automatic-Module-Name does not work). So there are no shortcuts taken and usually the problem is other libraries that have not been modularized, not LWJGL.. Looks like native modules must be required explicitly after #363. Before:\njava\nrequire org.lwjgl;\nrequire org.glfw;\nrequire org.opengl;\nAfter:\njava\nrequire org.lwjgl;\nrequire org.lwjgl.natives;\nrequire org.lwjgl.glfw;\nrequire org.lwjgl.glfw.natives;\nrequire org.lwjgl.opengl;\nrequire org.lwjgl.opengl.natives;\nCompilation works without the native modules, but:\n\nIntelliJ does not add them to the runtime module path, unless explicitly required.\njlink does not add them to the image, unless explicitly required. Manually adding them with --add-modules fails too.\n\nGiven the above, using requires static <natives module> in Java modules doesn't do anything useful. We could do the opposite though:\n\nRemove requires static <natives module> from the Java module.\nAdd requires transitive <java module> to the natives module.\n\nThat way the native modules remain optional, but if used, the above example becomes:\njava\nrequire org.lwjgl.natives;\nrequire org.glfw.natives;\nrequire org.opengl.natives;\nand everything resolves nicely in both javac and jlink/IDEs.. I tested again using --add-modules and jlink indeed adds the natives module to the image (it is listed in java --list-modules). However, the natives are not resolved when the application runs. I just figured out that if you do java --add-modules <native modules>, then it works.\nMy argument is that even though the current setup is technically correct, it is not very helpful. You need to worry about lwjgl3 natives when running jlink (which is not trivial in the first place) and also when running the output image.. @philipguin Isn't there a ProGuard option to ignore module-info.class when obfuscating?. The latest 3.1.6 snapshot (build 11) includes the following changes:\nA natives module now has a transitive dependency to the corresponding Java module.\nAs described above, this fixes applications that deploy shared libraries in a custom way. Such an application would declare:\njava\nrequire org.lwjgl;\nrequire org.lwjgl.glfw;\nrequire org.lwjgl.opengl;\n// ...\nrequire org.lwjgl.vulkan;\nand then use a custom classpath or library path when launching the application.\nApplications that need to ensure that the natives are in the module path, again declare one line per binding (like on LWJGL 3.1.5), but with the .natives suffix. For example:\njava\nrequire org.lwjgl.natives; // read as: \"org.lwjgl with natives\", org.lwjgl will be resolved by the transitive dependency\nrequire org.lwjgl.glfw.natives;\nrequire org.lwjgl.opengl.natives;\n// ...\nrequire org.lwjgl.vulkan; // the Vulkan bindings do not have natives\nWarning to Maven users: \nMaven tries to produce an appropriate --module-path when compiling a modular project. Unfortunately it does not honor transitive dependencies and compilation will fail if they are not explicitly declared. This is not an issue with LWJGL or javac, but a Maven bug. It has not been fixed as of 3.5.3-SNAPSHOT-20171222.\nmodule-info.class is now stored under META-INF/version/9/\nThat means that all LWJGL jars are now multi-release JAR files. It should hopefully eliminate issues with tools that do not support Java 9 yet, like @philipguin describes above.\nJava 9 sources are also stored under META-INF/version/9/\nThis currently includes module-info.java files and StackWalkUtil.java in the core module. I'm not sure if that's the official way to include multi-release sources in a sources JAR file (IntelliJ IDEA for example is not able to resolve them). But I couldn't find any information about it and I guess it's better than not shipping those sources at all.. This will be fixed in the first 3.1.4 snapshot. Thanks!. EGLConfig  is an opaque pointer type. There is no way to know the size of the data structure behind it and it doesn't matter (you query it with eglGetConfigAttrib).\nThe standard way to use eglChooseConfig is to first call it with configs == NULL. Example code:\n```java\ntry (MemoryStack stack = stackPush()) {\n    IntBuffer attribList = stack.ints(\n        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,\n        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,\n        EGL_COLOR_BUFFER_TYPE, EGL_RGB_BUFFER,\n        EGL_RED_SIZE, 8,\n        // ...more here...\n        EGL_NONE\n    );\nIntBuffer numConfig = stack.mallocInt(1);\n\nif (!eglChooseConfig(glfwGetEGLDisplay(), attribList, null, numConfig)) {\n    throw new IllegalStateException(String.format(\"eglChooseConfig failed [0x%X]\", eglGetError()));\n}\n\nPointerBuffer configs = stack.mallocPointer(numConfig.get(0));\n\neglChooseConfig(dpy, attribList, configs, numConfig);\n\n// ...query the returned configs and choose one...\n\n}\n```\nThe first call returns the number of available configs (based on the specified attribute list) to numConfig. Then you know how big the configs buffer must be.. > does not disable any debug messages\nI was able to reproduce this on Windows with the latest Nvidia drivers. However, this works (and doesn't do a redundant allocation):\nglDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, (IntBuffer)null, false);\nIn both cases 0 is passed to the native count parameter, only the ids parameter is different (null vs not-null). This is probably a driver bug, according to the spec: if count is zero, the value if ids is ignored.\n\nI have also tested this with only specific id's disabled\n\nThis is not allowed, when count is not zero then: if source or type is DONT_CARE, or severity is not DONT_CARE, the error INVALID_OPERATION is generated.. > GL43.glDebugMessageControl(GL43.GL_DEBUG_SOURCE_API,GL43.GL_DEBUG_TYPE_OTHER,GL43.GL_DEBUG_SEVERITY_NOTIFICATION,BufferUtils.createIntBuffer(1).put(131185)[.flip()],false);\n\nIt still shows all notifications, even 131185 as detailed above. Am I still doing it incorrectly? \n\nYes, see the end of my previous reply. When ids are specified, severity must be GL_DONT_CARE.. Sounds like a bug in Eclipse. Which version do you use? I'm not familiar with the state of module support in Eclipse, but updating to a newer version (possibly beta) may fix the issue.\nFirst issue I notice is that Eclipse doesn't recognize Automatic-Module-Name in the LWJGL manifests. The modules lwjgl, lwjgl.glfw, ..., should be org.lwjgl, org.lwjgl.glfw, etc.\nThe org.lwjgl.glfw module contains only the org.lwjgl.glfw package with the GLFW classes. It shouldn't trigger the The package org.lwjgl is accessible from more than one module error. It's probably an issue with how Eclipse treats automatic modules.\nYou could verify that this isn't an LWJGL issue with: java -p <path_to_LWJGL_jars> --add-modules ALL-MODULE-PATH --validate-modules with LWJGL 3.1.4 build 3 or newer.. Indeed, not all Nuklear functions are documented, but the native header contains usage documentation that has not been added to LWJGL yet (PRs welcome).\nMy recommendation would be:\n\nRead the usage sections and have a look at the code examples (in nuklear.h).\nPlay with the native demos.\nAttach nuklear.h to your project and inspect the code when you're having trouble. Most functions are very simple and you can easily figure out if you're doing something wrong.\n\nIf you really want to use a debugger, then yes, it should be possible to build lwjgl_nuklear with debug symbols. There's no system property for Nuklear that overrides the shared library location, but it shouldn't be a problem. Use either java.library.path or org.lwjgl.librarypath to point to the folder containing the debug binary and make sure the bundled binary isn't in the classpath (if the SharedLibraryLoader is used). You can use -Dorg.lwjgl.util.Debug=true and -Dorg.lwjgl.util.DebugLoader=true to verify that the correct one is being loaded.\nThe compiler options that need to change in order to produce a debug binary are in config/<platform>/build.xml, in the \"compile\" macrodef.. > Do you compile nuklear.h as-is or are there any defines set anywhere else? There are tons of things that can be #ifdef'd inside Nuklear and I'm not sure which ones LWJGL uses in particular, if any.\nThe generated C file that includes nuklear.h is here.. GLFW forces the swap interval to 0 (i.e. vsync disabled) in windowed mode if desktop compositing is enabled on Windows. Instead, it uses DwmFlush when glfwSwapBuffers is called. This is the relevant commit.\nMy guess is that with the AMD driver you sync to a v-blank with DwmFlush, then the driver syncs to the next v-blank when SwapBuffers is called (because of the forced v-sync setting). This effectively cuts your frame rate in half.. The next snapshot (3.1.6 build 9) will have all the latest updates in bindings, but not the nullability annotations. It will be promoted to stable when it's up. Starting from build 10,  the above changes will be available for testing.\nThank you @TheMrMilchmann for the great work!. There's indeed something wrong with the Metal backend. I'm seeing a different problem with the latest snapshot (on a macbook pro, early 2015): there's no vsync and the window flickers like crazy. It's not blank though, there's definitely rendering going on.\nI spent a few hours yesterday trying to identify the issue, but had no luck. The native bgfx demos seem to work fine on Metal. I tried both BGFX_CONFIG_MULTITHREADED=0 and =1. It looks like either a threading issue or a bad interaction with GLFW.. It looks like BGFX_RESET_VSYNC is ignored in the Metal backend. Adding a Thread.sleep(16) fixes the flickering issue for me.\nI also tried using correct multithreaded rendering and didn't see a difference. All backends work fine, except Metal. Since the Metal backend is considered a WIP in bgfx, I'll revisit this in the future.. The bgfx Metal backend is now fully featured and working correctly and has been made the default backend on macOS. Available in LWJGL 3.1.7 snapshots.. The LWJGL page on Open Collective is now ready and this PR can be merged. Thank you @asood123.\nIf you're interested in becoming a backer or sponsor for LWJGL, the plan is to use donated funds:\n\nto cover server hosting & bandwidth expenses (currently ~$30 per month)\nto cover software & hardware expenses\nto offer bounties for documentation work (priorities: adding EGL & GLES javadoc, updating GL)\nto offer bounties for new bindings\nto offer bounties for new platform ports (priorities: ARM/Android). Thanks!. Thanks!. Obsolete as of 0d7917de5839436af36fc3908c7b4cb30e410a8c.. LWJGL contains bindings to WGL, GLX, etc. You can use them to create, manage or access OpenGL contexts. GLFW also exposes the native window/context, with the platform-specific classes (GLFWNativeWGL, GLFWNativeGLX, etc).\n\nWhat you're trying to do sounds hard, unless Servo has a decent embedding API. You may want to start with https://github.com/paulrouget/servo-embedding-example.\nBtw, Display.setParent(java.awt.Canvas) does not exist in lwjgl3, it's an lwjgl2 API. In lwjgl3, see the JAWT bindings.. The 3.1.4 build on Maven is bugged, it has been compiled with Java 9. The bytecode version is fine (Java 8), but not the boot classpath. JDK 9 introduced covariant returns in certain NIO methods and that's the error you're seeing.\nWorkarounds:\n\nuse Java 9\ndownload the latest 3.1.4-SNAPSHOT (it's identical to the 3.1.4 release but compiled properly)\ndownload LWJGL from the website or github (the binaries have been updated)\n\nThere will be a 3.1.5 release immediately (hopefully tonight or tomorrow morning) that will fix the Maven build.. Fixed with the 3.1.5 release.. Hey @Sylvyrfysh,\nDo you think you'll be able to continue work on this PR? Other than fixing the current conflicts, the template DSL will also have to be updated to the latest version.\nBtw, LWJGL now includes a tool that extracts template definitions from C/C++ headers, including documentation. I would recommend using it to recreate all templates and then adding the necessary modifiers (AutoSize etc).. The latest release (2.0.2) looks stable enough now, I don't see a reason to go with 1.11.. You're not supposed to use msvc to compile the Android branch. You must set the ANDROID_SDK_HOME environment variable to point to the Android SDK and LWJGL will use the NDK toolchain to build everything.. This could be an issue with NDK 16, which has the unified headers only. In my setup there are 64 different inttypes.h files, but I have not upgraded to 16 yet. I'll post again when I have time to test it.. Reproduced it, I think it's related to the asymmetry of min/max width/height between lNode/tNode and rNode/bNode. Looks like a bug to me, I tried to do the same in html/css and it didn't happen there. You may want to report it to facebook/yoga.. Thanks!. LWJGL does not expose internal state that is not part of the public API, unless it's useful somehow. Sounds like you can do something interesting with stbtt_pack_context, so I'll make sure it's readable in the next 3.1.6 snapshot.\nIn the meantime, you could easily access its members with MemoryUtil unsafe memory accessors (memGetInt, memGetAddress, etc). To get ctx->width for example:\njava\nint width = memGetInt(ctx.address() + 2 * POINTER_SIZE);. In the next snapshot, structs stbrp_context, stbrp_node and stbtt_pack_context won't be opaque and stbtt_packedchar will be mutable. If you need setters in any other struct, please reply here.\nThanks!. > Should probably just have written that there are some members on that struct that are not public visible yet (h_oversample, v_oversample) which are used in the code I am replicating.\nDone.\n\nbut when modifying the behaviour on the java side access to the stbtt__* functions would be neat\n\nThat's a ton of internal, mostly simple, functions. I would consider exposing a subset of those, if you could post a list of functions that you think would be useful and are not trivial to port to Java.. Thanks!. Sounds reasonable, but I'm not sure how it will interact with jlink. I'm merging this anyway so that it can be tested more widely (will be available in 3.1.6 build 10).. #### Cross-platform/architecture compatibility\nLMDB files are indeed sensitive to CPU word size and endianness. We can reasonably assume little-endian CPUs everywhere, so 32-bits vs 64-bits is the real issue. The only 32-bit binaries we currently ship are on Windows x86, but we may have to worry about 32-bit ARM soon too. Some options:\n\nGenerate the application data twice, once to a 32-bit DB and once to a 64-bit DB. Ship the appropriate DB for the user's platform.\nGenerate the application data to a 32-bit DB, convert to a 64-bit DB (the opposite is not safe afaik). Again, ship the appropriate DB for the user's platform.\nLWJGL switches to building 32-bit binaries with MDB_VL32. This indeed makes LMDB files compatible across architectures, at the expense of slightly lower performance on 32-bit (internal structures become 64-bit). Looks like Monero did this about a year ago (uses LMDB to store the blockchain) and I've also just tested it with success, so I guess this mode is supported and mature now. Obvious drawback: we break existing DBs, but I'm not aware of any LWJGL users that work with LMDB, except on server applications (x64-only).\n\nIn-memory mode\nLMDB indeed does not have a pure in-memory mode, unless you count storing the DB on a RAM disk / tmpfs. However, you can get pretty close to it by enabling one or more of MDB_WRITEMAP, MDB_NOMETASYNC, MDB_NOSYNC, MDB_MAPASYNC. See the documentation for what they do exactly and how they interact with each other. You then use mdb_env_sync() to persist changes to disk, whenever is appropriate for your application.\nMake sure to also use zero-copy reads/writes (see MDB_RESERVE).. Have you considered using two separate databases (i.e. two MDB_env *)? One in \"safe\" mode and one in nosync/async mode. Store all transient data to the async db and when it's time to save the game, copy the modified data over to the safe db. Whether the OS has persisted the transient data to disk or not shouldn't make a difference.. I'll close it soon, when the VL32 change is live.. You should first do a successful Ant build before attempting to setup the Eclipse project.\n\nDownload and extract Ant.\nAdd Ant's bin folder to the path.\nExport/set JAVA_HOME to a version 8+ JDK.\nRun ant compile-templates compile-tests in lwjgl3's root directory.\nRun ant tests if there's a working C/C++ compiler available. (optional)\n\nThis will download all dependencies and build the project.. > ant test failed in the same place in the linux build as it did before.\nLooks like you're missing libgtk-3-dev.\n\nI did get things working, but probably not in the way you'd like. I added a pom.xml file and used Maven to gather the missing libraries.\n\nIf ant compile-templates compile-tests was successful, then you should already have the necessary libraries in bin/libs/java/.\n\nThe one thing that gave me problems is the com.sun.javadoc.* package. I had to manually add the tools.jar\n\nCorrect, this needs to be set up in the IDE project using tools.jar from the JDK. There's a related issue: #349. Looks like it's failing at remotery now (build.xml:237). Try installing xorg-dev.\nFor reference, here's how the official binaries are built.. They are not missing. Assets are downloaded automatically when you run the demo target, to avoid bloating the repository. For example:\nant demo -Dclass=org.lwjgl.demo.stb.Vorbis. Indeed, there is no reason to map _vendorId to an int. The same applies to the _side parameter of bgfx_update_texture_cube.\nThe situation with bgfx_set_view_clear and other functions with bitfield parameters (e.g. buffer creation flags) is more complicated. As soon as you need to || two or more flags together, mapping the parameter to a short becomes painful. In both Java and Kotlin. For example in Kotlin you'd need to do:\nkotlin\n(BGFX_CLEAR_COLOR.toInt() or BGFX_CLEAR_DEPTH.toInt()).toShort()\nThere is an or that works on Short in kotlin.experimental, but it would still be painful in Java (and Java usability takes priority over Kotlin).\nMay I suggest a simple extension property:\nkotlin\nval Short.i get() = this.toInt()\nThen you can do:\nkotlin\nBGFX_CLEAR_COLOR.i or BGFX_CLEAR_DEPTH.i // or\n(BGFX_CLEAR_COLOR or BGFX_CLEAR_DEPTH).i // with kotlin.experimental.or. @malobre Thanks!\nIf you have more suggestions, please post in this issue.. I'm working on fixing this asap. It's trivially resolved by adding:\njava\nrequires static org.lwjgl.vulkan;\nto the GLFW module.\n\nSomewhat unrelated, but I'm noticing that there's also a number of @NativeType annotations missing throughout the GLFWVulkan source, is this sort of thing considered a bug?\n\n@NativeType is in lwjgl.jar. I think you mean the @Nullable annotations from jsr305 (see #344). Annotation classes are not resolved unless you introspect them, so it's not a real dependency. Users have the option to add it to their project if they wish, we didn't want to enforce it to everyone.. The next snapshot (3.1.6 build 13) will have the missing requires static declarations and the unnecessary annotations have been removed (there should be no annotation when the native type matches the Java type exactly).\nThanks @cwb123!. > -Dbinding.spaceui=true\nLooks like you're working on new bindings there. There should be a directory:\nmodules/lwjgl/spaceui/src/main/kotlin/spaceui/templates/\nthat contains Kotlin templates. The exception happens because it's missing.. Afaict, the updated classpath includes the core module only. Isn't it possible to add the binding modules as well? (they each have one or more of main, generated and test sources). > I may not understand exactly what you're requesting though.\nHopefully, when compiling the project from Eclipse, it should generate classes to the same locations as Ant. I'm not familiar with Eclipse, but this is what it looks like in IDEA:\n\nEach Java module (the LWJGL core module or a binding module) corresponds to an IDEA module. Each IDEA module has its content root and can have multiple source and test folders. The source classes are compiled to one folder (bin/classes/lwjgl/<module>), the test classes are compiled to another folder (bin/classes/test). Each IDEA module can also have dependencies to other IDEA modules (e.g. the glfw module depends on core, egl and vulkan). This helps with isolation (making sure there are no illegal dependencies, etc) and IDE performance.\nThere are also the Kotlin modules (generator and binding templates) with similar setup. Not sure if the Eclipse Kotlin plugin is any good though.\nThe samples module depends on all other modules and compiles to bin/classes/samples. \nThe IDEA project also has run configurations for running the tests with the TestNG plugin and running the code generator. That's just ant generate but IDEA builds the Kotlin source before launching the Ant target. This is very useful because it does incremental compilation, which is not available via Ant (a full rebuild takes too long).. Having a premade IDE project is useful for the following reasons:\n\nMakes it easy for interested users to explore the codebase.\nMakes it easy to run tests/samples (existing, or modified, or new).\nMakes it easy to develop new bindings.\n\nOnly the first two are important in our case. The third one is good to have but not critical. It's OK if we require use of IntelliJ for a good experience, at least until there's a mature Kotlin plugin for other IDEs.\nWith that said, LWJGL indeed supports Java 9 and its artifacts are explicit JPMS modules. But this is only done in the ant release target, in a somewhat hacky way. There is no clean way to develop a Java 8 library and also support Java 9 modules (that I know of, with the current tooling).\nHowever, LWJGL has been modular for a long time, meaning you could choose exactly the subset of bindings that are useful to your project. To reflect that (and also the Java 9 module organization), the codebase has been recently changed in such a way that the source of each binding is isolated in its own directory. The output directories are also split, just like the LWJGL jars. The new layout is easier to understand and helps when you want to focus on a specific binding or set of bindings.\nAnyway, the IDE setup does not have to support Java 9 modules. The IntelliJ project doesn't either and in fact module-info.java files are not even marked as sources. You don't have to organize the bindings in \"IDE modules\" either, as long as the right paths are added to the classpath and the output directories are configured properly.\nYour latest commit has two issues that must be fixed before this PR is merged:\n\nThe modules/lwjgl/<module>/src/generated/java sources must be compiled to bin/classes/lwjgl/<module> (just like the main sources).\nThe modules/lwjgl/<module>/src/main/kotlin sources must all be compiled to bin/classes/templates.\n. No progress, so closing this PR.. The original goal of this PR was fixing the design mistake of making const a modifier, instead of having support for it in the type system. Also, const is now always rendered to the right side of the type to which it applies, for consistency.\n\nBut the real breakthrough came from using Kotlin lazy properties to avoid excessive allocations when applying the new DSL. It led to a major refactoring of the entire type system: it's now simpler, hides implementation details more effectively, provides more type-safety at (kotlinc) compile time.. > Can you also generate Kotlin sources?\nNot at the moment, but you can use LWJGL in Kotlin, just like any other Java library. Also, nullability annotations have been added recently which improves Kotlin interop.\nGenerating Kotlin sources could be beneficial for certain things. E.g. making struct access syntax look like C, with Kotlin properties. However, Kotlin/Native is maturing quickly and I'm waiting to see what options open there, before committing to anything.. Cannot reproduce on LWJGL 3.1.6, Java 1.8.0_161, macOS 10.13.3.\nHave you set -XstartOnFirstThread when running via Gradle?. Looks like lwjgl-3.1.6-natives-windows.jar is not in the class/module-path for some reason. Try enabling Maven's debug output to check if it has been downloaded and added to the path.. I cannot reproduce this. Running a simple test from both:\n\ncommand-line with Maven, and\nan IntelliJ project created from the Maven POM\n\nworks fine. The LWJGL loader is able to find the natives and then extract/load them. I tracked down the loading process with a debugger, the shared library is resolved with findMiscResource, which:\n\nReturns the list of URLs to a \"miscellaneous\" resource in modules defined to this loader. A miscellaneous resource is not in a module package, e.g. META-INF/services/p.S.\n\nSo, this is quite literal:\n\nthis method will only find resources in packages of named modules when the package is opened unconditionally\n\nIt doesn't apply to LWJGL shared libraries because they're stored in the JAR roots, not inside a package.. > LWJGL version: 3.1.0\nCould you please try with 3.1.6 instead? Also, could you post the full output of java -version?. Are you running your application in a debugger? Does it happen if not?. Apparently it's a known low-priority issue marked as won't fix:\nJDK-6476706\nThere's a call to GetEnv somewhere, probably a race condition when exiting the debugging session makes it return NULL.\nIMHO it's harmless and can be ignored. It's not related to LWJGL and won't happen in non-debugging runs.. Yes, of course. The Vulkan bindings are generated with lwjgl3-vulkangen, which needs significant updates to properly support Vulkan 1.1. It will take a few days.\nThere is one non-trivial issue that I'd like feedback on:\nA lot of struct types that were previously defined in extensions (usually with the KHR suffix), have been promoted to the Vulkan 1.1 core. There are now two such struct types, with and without the suffix. Most (if not all) are identical, the new type is just an alias. The problem is that struct types are mapped to classes in LWJGL, with a significant amount of code in them. The question is, how should this situation be handled in the bindings?\n\nRename the existing classes to drop the suffix, use the new name for both core and extension functionality (assuming no changes have been made during the promotion, other than the name). Obviously, this breaks existing code that uses the extension types.\nKeep the existing classes and create new ones without the suffix.\nLike 2, but use inheritance to reuse whatever code can be reused and maybe make the two types compatible. For example, make VkBindBufferMemoryInfo extend VkBindBufferMemoryInfoKHR, then VkBindBufferMemoryInfo can be used with the extension, but VkBindBufferMemoryInfoKHR cannot be used with the core functionality. Somewhat cleaner, but also weird.\nHybrid: Do 1 for KHX (experimental) extensions, 2/3 for other extensions.\n\nWhatever choice is made, it will have to be honored in future Vulkan updates too.. Thanks!. Thanks!. Thanks!. Modules names start with org.lwjgl. Does this comment help?. Yes, that's the problem I guess. The module-info.class files are under META-INF/versions/9/ inside the JAR files. This is the recommended way to deploy modular JARs that may also run on Java versions lower than 9. Putting module-info.class at the JAR root was causing too many issues with various tools/build systems that are not up-to-date with the Java Module System.\nYou can probably work around this by putting LWJGL in --class-path instead of --module-path.. Unless you need to use jlink, there shouldn't be a problem with mixing modules and classpath libraries.\nI don't know about Eclipse, have only used it once many years ago. But it does seem from reported issues so far that their Java 9 support is lacking.\nAnother suggestion (assuming switching to another IDE is out of the question): set up everything without modules in Eclipse, but do modular builds using Maven or Gradle.. @EdvinasKilbauskas You should be using the BufferUtils class instead, to avoid surprises related to the buffer byte order (which defaults to big-endian). Specifically, you can use:\njava\n// preferred:\nval pixel = BufferUtils.createFloatBuffer(1920*1080);\n// which is equivalent to:\nval pixel = ByteBuffer.allocateDirect(1920*1080*4).order(ByteOrder.nativeOrder()).asFloatBuffer()\nAlso, read Memory management in LWJGL 3 to get familiar with other available options. Usually, going through ByteBuffer.allocateDirect is the most convenient but also much less efficient method. In your case for example, the allocated buffer is always zeroed-out, even though its contents are going to be completely replaced by the glReadPixels call. You don't have the option to not zero-fill with allocateDirect, but you do with MemoryUtil.. Yes, the stack has a fixed capacity. It defaults to 64kb, can be changed programmatically with Configuration.STACK_SIZE or via the command line with -Dorg.lwjgl.system.stackSize=<value in kb>.\nNote that MemoryStack is supposed to be used for local/short-lived/small allocations. Model data do not qualify (it's typically large) and heap allocation (e.g. via MemoryUtil) is more appropriate.. EXT_descriptor_indexing is available in the developer beta driver version 397.40. See Vulkan Driver Support.. Thanks!. The aiMesh struct defines mVertices and mTextureCoords as:\nc\nC_STRUCT aiVector3D* mVertices;\nC_STRUCT aiVector3D* mTextureCoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];\nThe first is a pointer to an array of aiVector3D structs, with length mNumVertices.\nThe second is an array of pointers to arrays of aiVector3D structs, with length AI_MAX_NUMBER_OF_TEXTURECOORDS. Each element of the array is either NULL or points to an array of aiVector3D structs, with length mNumVertices. This is correctly mapped to a PointerBuffer.\nThe same applies to mColors. A mesh can have multiple sets of vertex colors and texture coordinates. E.g. there may be multiple textures applied to a mesh, each with a different set of texture coordinates.. See the AIMesh javadoc. Each member is adequately documented and there's also the C struct layout at the end.\nIf you're looking for a more fluent and type-safe API, then I'm afraid this is not currently possible (without performance sacrifices). I guess this deserves an explanation.\nFirst of all, LWJGL 3 had a few important goals:\n\nBe easier to maintain than LWJGL 2.\nHave better performance than LWJGL 2.\nHave more features than LWJGL 2.\nHave bindings that are source compatible with LWJGL 2 (as much as practically possible).\n\nThese goals were mostly met, but that last point is why the classes BufferUtils and PointerBuffer are still there in the package root. Refactoring PointerBuffer to something better was not an option. Even if it were, Java 8 (our compilation target) does not offer anything interesting.\nThis is going to change in LWJGL 4, which is going to target whatever Java version first ships with projects Panama & Valhalla. Under the current proposal (State of the Isthmus v0.3 - May 2018), instead of a PointerBuffer, a member like mTextureCoords would be mapped to an:\nArray<Array<AIVector3D>>\nThis does look like something that could be done right now, but in that future Java version:\n\nAIVector3D would be a value type (Project Valhalla - value types).\nArray<AIVector3D> would be a generic value type, without boxing (Project Valhalla - generic specialization).\nArray<Array<AIVector3D>> would be natively supported by the JVM (Project Panama - FFI).\n\nWith the above, the API becomes fluent and type-safe, as well as zero-overhead (no boxing, the JVM can use these types directly in native function calls).. LWJGL does not provide any Vulkan layers. You need to separately download and install the Vulkan SDK. This document explains how layers are discovered and made available at runtime.. Sure, but could you reopen this issue in the lwjgl3-www repository please?\n\nTo use LWJGL with SBT the build.sbt needs to include the following snippet:\n\nThanks. If you'd like to submit a PR, the script generation source is in BuildScript.jsx. Note that a flatMap cannot be used like that, e.g. not all modules have natives and whether a module has natives or not may depend on the LWJGL version. The details are reasonably abstracted though and you only have to worry about generating the proper syntax/formatting. For reference, see the functions generateMaven, generateGradle and generateIvy.. I think I'll just remove the clSetKernelArg3x overloads. Any objections?. My thinking is that removing them is not a breaking change in practice, since there's no kernel argument type for which they could have worked without an error.. I've already considered going back into Java from functionMissingAbort and throwing a \"friendly\" exception or error. The problem is that Java throwables can be caught and the user may be tempted to ignore or attempt to recover from the situation. But this situation is not recoverable. A call to a function of unknown arity and return type is being dispatched to a void f(void) function. Depending on the function called and the platform's calling convention (note: OpenGL uses __stdcall on Win32) stack corruption can easily occur, which will bring down the JVM in an unpredictable fashion. Throwing an exception may work for glGenTextures or even all OpenGL functions on a particular platform, but it's not a general solution.\nTwo more things:\n\nThis error is as serious as dereferencing an invalid pointer. It's OK for the JVM to crash then and there.\nAfter 622d5a2b41ee9f1e423626ea294a08bbba5c48e6, the user has the information they need to resolve the issue, in all cases. (friendly message on stderr and stacktrace in the crash log file). > I do see that JNI has a FatalError function, which logs the stacktrace and a message and (more importantly) doesn't return but instead kills the JVM.\n\nActually, that's perfect. The stack trace is better than the one you get in the crash log (includes Java source lines) and is much less intimidating to new users. Changed to FatalError with f18cf23f9aa7e5fbf1d2d103cf1cbc48b8bb9ae6.\nThe stderr output can be easily redirected to a file, with or without log4j.. It is mentioned in the documentation for work_dim:\n\nIf global_work_size is NULL, or the value in any passed dimension is 0 then the kernel command will trivially succeed after its event dependencies are satisfied and subsequently update its completion event. The behavior in this situation is similar to that of an enqueued marker, except that unlike a marker, an enqueued kernel with no events passed to event_wait_list may run at any time.. > I'm not really sure what would be the best way to handle this - maybe provide two versions of the method, CL10.enqueueNDRangeKernel and CL21.enqueueNDRangeKernel?\n\nLWJGL checks exist to protect the user from crashing the JVM, as much as is practically possible. In this case, passing NULL has a predictable outcome (not a crash) covered by the spec, which is why the parameter was always nullable, even before the OpenCL 2.1 release.\nNote that, in general, enforcing correct API usage via checks or custom API requires massive effort and/or runtime overhead. It is outside the scope of LWJGL. The maintenance burden is already high and being lightweight + low overhead has always been top priority. Maybe LWJGLX/debug could be extended to detect cases like this one. But for a huge API like OpenCL, the best solution would be something maintained by the designers/implementors, like the Vulkan validation layers.. Thanks @TheMrMilchmann, JOML 1.9.10 should now be available.. Hey @Zamundaaa,\nI do not have access to a HMD yet, so I've personally never tested the OVR and OpenVR bindings. I depend on users reporting issues with enough information to fix them. I'm afraid the crash logs you shared do not indicate anything obvious. Maybe posting a minimal code sample that reproduces the issue would help.\nI don't know why GetControllerStateWithPose crashes, but in 1.0.16 is has been deprecated in favor of the new IVRInput system (introduced in 1.0.15).\n\nVRSystem_CaptureInputFocus seems to be gone now ... wonder why? It's still there in OpenVR\n\nIt's not, it was completely removed in 1.0.12. Note that the LWJGL bindings follow the latest OpenVR C API header exactly.\n\nI've created an issue for OpenVR, but as other programs work just fine it seems like this could be an issue with the transfer from C++ to Java.\n\nA good method to identify if that's the case, is to port an existing native demo to Java/LWJGL. You can then easily validate if there are issues with the bindings. We could also use a decent OpenVR sample in the repository, if you'd like to contribute.. Cannot reproduce on Windows 10, latest nvidia drivers. Please post more details and an MCVE if possible.. Thanks @TheMrMilchmann!. Thanks @Alex-----! The fix will be available in 3.2.1 snapshot 2.. There is no lwjgl-vulkan-natives for Linux/Windows. On macOS it contains the MoltenVK binary, which emulates Vulkan over Metal.\nIt is recommended to use the official build customizer to generate Maven dependency scripts, etc. It knows which platforms are supported by each module and whether natives are necessary, saves a lot of time.. If macOS is unchecked under Natives, there won't be a natives dependency for Vulkan in the generated script.. Thanks!. @vearp Thanks!. Hey @DavidYKay,\nI cannot test your code without a HMD. Could you please post the NPE stacktrace? Also, try printing the value of OpenVR.VRSystem.GetStringTrackedDeviceProperty & OpenVR.VRSystem.GetRecommendedRenderTargetSize, they should not be 0. If they are, it means that LWJGL failed to retrieve function pointers from your OpenVR runtime. Which version do you have installed? Another thing you could try is running the program with -Dorg.lwjgl.util.Debug=true -Dorg.lwjgl.util.DebugLoader=true and seeing if there's any useful output.\nOne thing that's definitely wrong with your code is this line: return String(stringBuffer.array()). LWJGL buffers are never backed by a Java array on the heap, they are always direct. Try returning MemoryUtil.memUTF8(stringBuffer, unRequiredBufferLen - 1) instead.\n. Thanks!. Yes, with a few changes1 you could render Chinese text in the TruetypeOversample sample, but it's not a practical solution for real-world applications. The problem is that you'd need a massive texture2 to store all chinese glyphs. It requires lots of memory and packing the glyphs with stb_truetype and uploading the data to the GPU would cause a substantial delay to the application startup.\nRendering Chinese, and other languages with lots of glyphs, usually requires a caching scheme for efficiency. I.e. you pack only the glyphs currently/recently visible on screen, rather than every possible glyph. This is not implemented in any LWJGL demo, but you should be able to find more information elsewhere.\n1 I was able to render (google-translated) Chinese by doing the following:\n\nChanged the bitmap dimensions from 512 x 512 to 16k x 16k. If your GPU does not support such a big texture, you could drop it to 8k x 8k and also reduce the font sizes in the scale array (or use a single size instead of two).\nChanged the font from FireSans to a font that contains Chinese glyphs. On Windows 10, C:/Windows/Fonts/simsun.ttc worked fine.\nChanged the packing/rendering code to work with around 37000 glyphs instead of only 128.\n\n2 To check if the glyph packing is working correctly, add stbi_write_bmp(\"font_texture.bmp\", BITMAP_W, BITMAP_H, 1, bitmap) after the stbtt_PackEnd(pc) call, then open the generated bitmap in your favorite image viewer.. Thanks!. Hey @chengenzhao,\nYou don't need dependencies in jmod format to use jlink, normal jars work just fine. The only prerequisite is that all dependencies must be explicit modules (i.e. include module-info.class, simply adding an Automatic-Module-Name in the manifest is not enough).. Since LWJGL 3.1.4 artifacts are jlink-able without any changes. module-info.class was moved into META-INF/versions/9 in 3.1.6 for compatibility with older software that tried to parse it and failed.. It's a false positive. VirusTotal reports: lwjgl-3.2.0.zip & lwjgl-javadoc.jar.. You can find an attempt to port LWJGL (at least the parts Minecraft needs) to FreeBSD here.\nOfficial support won't be possible without a CI service (like Travis, AppVeyor, etc.) that supports FreeBSD. Afaik, such a service does not exist and cross-compilation from Linux is painful. If someone would like to host a solution (Jenkins or whatever) for us, please let me know.. Hey @nkfilis,\nA FreeBSD environment with the tools (GCC, git, CMake, etc.) and development headers necessary to build the projects listed here. You can check the .travis.yml file in each repository to see what's involved. Currently the build workflow is:\n\nI push latest version to an LWJGL-CI repository.\nThis triggers a new build at Travis CI (Linux & macOS) and AppVeyor (Windows).\nWhen the build is done, the new artifacts are uploaded to LWJGL's S3 bucket.\n\nIdeally, the FreeBSD solution would work as simply as that.. That is an image generated by Open Collective. You may want to open an issue with them (probably in the opencollective-images repository).. > As I mention in the comments, b3GetStatusType returns status type 22 which is a failed status.\nI can reproduce this, but I don't see anything wrong with the bindings.\n\nIf I let it continue it makes the VM crash because\n\nIf you change var ptr = mem.mallocPointer( 1 ); to callocPointer, you'll get a NPE in the ptr.getDoubleBuffer call, instead of a crash.\n\nAny ideas? Should I ask in Bullet's repository?\n\nNope, sorry, I don't have any experience with Bullet. Before asking upstream, you could try reproducing the issue in C.. Thanks!. Thanks!. Thanks!. Yes, the generator takes care of it. Try ant compile-templates generate.. You may want to wait a few days before attempting to create new bindings. I've been working on a tool that extracts LWJGL template definitions from C/C++ headers. I'm currently in the process of trying different headers to fix corner cases and polish it up.\nThe tool uses libclang (via new Clang/LLVM bindings) to parse the headers and traverse the AST. It detects both declarations and associated comments for documentation. Comments in doxygen format are supported and can be traversed to detect e.g. param/return documentation, but the tool tries to attach any comments it can find.\nThis is what it currently generates for Newton.h with a single click.. On the Bullet bindings: I'm considering disabling Bullet for the 3.2.1 release until there's more feedback. \nThe bindings will still be available in snapshots after the release. This should give us enough time (until 3.2.2?) to evaluate other options before committing to anything. Maintenance effort should not be wasted on bindings that no one is going to use.. > Any updates on the template generator tool magic thingy?\nYes, it's been available for a while. It's fully featured now, but I'm sure there are still corner cases that are not handled properly, so please consider it a beta and report any issues you face.\nYou'll need to download or build LLVM/Clang on your machine, then run the tool with:\nant extract -Dclang=<path to libclang>. This usually means that static initialization of the inner Functions class failed. For example, it can happen if you're using an older libclang version that doesn't expose a newer function pointer. I haven't done any work on versioning the LLVM/Clang bindings, it's likely that the latest version is required.\nTry running the tool with:\nant extract -Dclang=<path to libclang> -Djvmargs=\"-Dorg.lwjgl.util.Debug=true -Dorg.lwjgl.util.DebugLoader=true\"\nIs there any useful output?\n\nI use the debug configuration \"GENERATOR\" but it wont stop at any breakpoint on the Kotlin code.\n\nProbably because this launches the Generator via Ant in a forked JVM process. Try setting fork to false (build.xml:271).. > started generating like half of the JNI.java class\nThe LWJGL generator gathers all native calls necessary to support the various bindings and creates a deduplicated set (based on call convention and signature) that goes into the JNI.java class. This makes the core LWJGL shared library smaller. When some bindings are disabled, the set usually becomes smaller, so that's what's happening.\n\nYour tool hates me, Spasi.\n\nHmm, yeah, ant extract also uses fork=\"true\" spawn=\"true\". Fwiw, if I change a ClangIndex function name to something random, I can see the stacktrace in the tool's \"console\" panel. With spawn=\"false\", I also get the same output on the terminal that runs ant extract.\nAnyway, you can run the tool from within IntelliJ with the Template Extraction Tool run configuration. Just edit it to set the correct org.lwjgl.llvm.clang.libname. You should be able to debug normally like that.. > What version of clang are you using?\nI'm using version 8, built from source (~Oct 27), on Windows.\n\nif I point to Clang 8 I get a segfault\n\nPlease attach a crash dump, it might be helpful.\nWhen I have time, I'll do some testing on Linux. I'll also try to make 8.0 functions optional, so that the tool can run on a stable 7 build.\nFor now, I have updated the gist above to the latest Newton.h. I did have some trouble parsing it, because the tool runs in C mode basically and the header had some invalid constructs (that are valid in C++). Fixed them manually and I also had to add --include=stdbool.h to the compiler arguments.\n\nI was getting NPEs on the callbacks since those used structs that were defined later in the file.\n\nYes, this might happen, the tool outputs callbacks before structs. I can probably change this so that the header order is respected.\n\nWhat does it means? I can just add \"Unsafe..\" to them but I'm not sure what is it doing, what kind of validation is it expecting? Like a length/size parameter?\n\nAdding appropriate modifiers to pointer parameters is the most important part of creating LWJGL bindings and it's something that cannot be automated. You must carefully examine the documentation/implementation of each function and, at the very least, add the following modifiers:\n\nnullable to optional pointer parameters/members. When missing, LWJGL ensures (at runtime) that such values are never NULL.\nCheck to pointer parameters/members with known length (Check(1) is very common).\nAutoSize/AutoSizeResult to integer parameters/members that specify the size of other, pointer parameters/members or return values. Several different cases here, you can find examples in other bindings.\nchar<Encoding>  to null-terminated string parameters/members (e.g. plugInPath in NewtonLoadPlugins). This is not a modifier, you simply change the char type to a more specific one.\nUnsafe to pointer parameters/members that cannot be made safe with any of the above (e.g. ptr in NewtonFree).. > Which generates a callback with a void argument. Legal in C, not so legal in Java.\n\nNot related to Java. The template DSL is supposed to look like C and it actually has some of its quirks (e.g. using (void) on functions with no arguments). This must be the first time it's occurred on a callback though. It's a minor bug and will be fixed soon. For now, simply drop void().\n\nit seems the tool also confuses multi dimensional arrays\n\nThanks, will have a look.\n\nI'm guessing those kind of libraries are the ones you don't commit to the repo because they're too big, so you make it download the artifacts from a build server, right?\n\nCorrect. Unfortunately, Bullet doesn't support shared library builds, so LWJGL links it statically. We should use Newton as a shared library if possible.. >  tries to fetch it from your build server.\nIf you export the LWJGL_BUILD_OFFLINE=true environment variable, the Ant build will stop looking online for anything.\n\nI'm not understanding if LWJGL supports loading multiple .so/.dll for a single library, or if it expects everything to be packaged into a single dependency. Which one is it?\n\nMultiple shared libraries for a single binding should be fine. Currently the LLVM/Clang bindings work like that. The CUDA bindings will also use multiple shared libraries soon, when more CUDA Toolkit libraries are supported.\nIn case multiple shared libraries need to be bundled with LWJGL, the release-module target must be configured with a custom natives definition (examples: GLFW, OpenAL, OpenVR).\n\nyou can make a single .so out of multiple .a with GCC\n\nThis is the preferred solution. Should be done for all platforms in CI, then LWJGL simply downloads and bundles a single shared library (like bgfx, GLFW, OpenAL, etc.).\n\nWell I think I managed to compile something [...] how do I package all of this up?\n\nThis is different from using a shared library and calling it via org.lwjgl.system.JNI (the preferred solution I mentioned above). Sounds like it's exactly the same setup as Bullet, so use that as a reference (search for binding.bullet in the Ant scripts).\nJust to be clear:\n\n\nSolution A: CI builds a shared library that exports all Newton functions. The LWJGL build downloads and bundles the shared library. At runtime, LWJGL loads the shared library and the function addresses, calls them via org.lwjgl.system.JNI. There is no generated C code in this case (i.e. no liblwjgl_newton.so, just a libnewton.so) and you don't need to add the Newton headers anywhere.\n\n\nSolution B: CI builds a bunch of static libraries. LWJGL downloads the static libraries, links them to a shared library that exports JNI functions (that call the corresponding Newton functions). There is generated C code in this case (so you need the Newton headers and appropriate nativeDirective calls) and there should be a liblwjgl_newton.so that will be used by LWJGL at runtime.\n\n\nThe first solution is very simple to configure in LWJGL, but you'll need to worry about bundling the static libraries as a shared library in the CI scripts. Doing this for all 3 platforms and making sure the functions are properly exported (see _NEWTON_BUILD_DLL in Newton's header, is there a CMake option that sets it?) might be a bit of work.. Both issues sound odd. Is there a fork/branch somewhere I could clone and test locally?\n\nI was launching the ant generate/compile/etc tasks with Java 8 as JAVA_HOME, should I have used Java 11?\n\nNo, Java 8 is fine. Later versions are only used in release (for ModuleInfoGen and javadoc generation).. I've fixed some of the issues mentioned above:\n\nThe LLVM/Clang bindings now require version 5.0 or higher (down from 8.0).\nvoid() can now be used in callbacks with no parameters.\nMulti-dimensional arrays are now supported. Both in the extract tool and in the LWJGL generator's type system.\n\nI'm now changing the extract tool so that it respects the order of declarations in parsed headers, then I'll have a look at your fork.. Hey @dustContributor, please try the following:\n\nRebase your commit against the current master HEAD (f376e5a95937154715c4e057578e33a2c2fdd3c4).\nApply this patch.\nRun ant clean compile-templates compile-native. This should produce a working liblwjgl_newton.so than you can test.\n\nI've fixed a few issues, did some cleanup and other tedious stuff (license, README, gradle, etc.) and uploaded Linux & Win64 static libraries for Newton to build.lwjgl.org. This commit, built locally, I'll set up LWJGL-CI at a later time. Use LWJGL_BUILD_OFFLINE=true if you'd like to replace them with a newer build.\nIf you'd like, open a pull request, which will give me access to push more fixes directly to your branch.. > Was that the reason it was trying to build Nuklear regardless of the configuration?\nI could not reproduce the ant release issue (tried it after working on everything else), but probably not. That flag controls native compilation only. I think the issue was in Newton's module-info.java, the module name was wrong (module org.lwjgl.nuklear).\nBtw, don't bother with ant release, it doesn't support local builds yet. It always tries to download artifacts from build.lwjgl.org.. > Hmm... So what do I use to package the module into a .jar then?\nNormally I don't need this when working on new bindings, because all tests & samples are written within LWJGL. It is not necessary to package anything to run them. But since many users have made this request, I added support for offline releases and incomplete local Maven deployments with 9485e8b7c9471d9aac3d5dc6c9ad95e1eeaaaff9.\nWhen the LWJGL_BUILD_OFFLINE=true environment variable is set, ant release will copy files from bin/libs instead of downloading anything from build.lwjgl.org. Missing files (e.g. shared libraries for other platforms) will be ignored and the corresponding .jar files won't be generated. You can comment out the javadoc generation section of release-module for faster builds.\nThe Gradle build now also supports incomplete deployments to the local Maven repository. Source, javadoc and natives artifacts that are missing will be silently ignored. I would recommend adding a -LOCAL suffix to such builds (see build.gradle, line 44).. > https://build.lwjgl.org/nightly/linux/x64/liblwjgl_newton.so\nI have not uploaded liblwjgl_newton.so, just Newton's various .a libraries (see nightly/linux/x64/newton). Using the above patch you should be able to easily build liblwjgl_newton.so. With 9485e8b7c9471d9aac3d5dc6c9ad95e1eeaaaff9, you can then do an offline ant release.. > Is there a difference between using SomeType.opaque and just using void.p?\nYes, they're mapped differently in the Java API.\n\"SomeType\".handle and \"SomeType\".opaque.p are always mapped to long. They both represent handles (i.e. pointers to opaque structures). Their data is private to the native library and never accessed directly.\nvoid.p is mapped to ByteBuffer and sometimes to IntBuffer/FloatBuffer/etc. when it makes sense (using the MultiType modifier). For example, glBufferData takes a void.const.p and glMapBuffer returns a void.p. The data can be anything, but the application knows what it is and can directly manipulate it.\nThere's no difference in the native API of course, both are passed as jlong to JNI.\n\n<...> looks like type safety is lost along the way. <..> Is this done on purpose? Or am I doing something wrong?\n\nThat's correct, handles are not type-safe in LWJGL. This is a trade-off that favors performance, i.e. avoiding (Java) allocation overhead for handles. Many handles have long life-cycles and cannot benefit from escape analysis as much as data pointers wrapped in NIO buffers. Also, most handles in non-demo code are wrapped & encapsulated in other Java classes anyway, so the drawbacks are limited in practice.\nThis is all going to change in LWJGL 4 of course, handles will become value types (see Project Valhalla), which are type-safe and zero-overhead.\n\nI think it's trying to cast the address to the callback/function pointer type, but my compiler (GCC 8.2) complains\n\nThe callback definitions are missing native typedefs. I've fixed the template extraction tool to emit them and updated the Newton gist (callbacks have a nativeType parameter now). I'll also fix the generator to support function protos without a typedef as function parameters, they're currently supported as struct members only.. > I am not entirely sure why it didn't pop up before since I never touched the \"FIXME\" links.\nCallbacks are evaluated in a final step after the generation of all bindings has succeeded. Most likely, you were hitting errors earlier in the process and never got to generating callbacks before.\nSo, I'll be waiting your evaluation on how the Newton bindings feel. My biggest worry is that there are too many callback types and upcalls are super-slow via JNI (at least an order of magnitude slower than downcalls). I'm not familiar with Newton's API, but if the number of callback invocations depends on scene complexity, JNI overhead will probably limit scalability.. Hey @NgocLuu-Incepit. 3.2.1 build 11 is now available, glfwAttachWin32Window will be there.. Hey @nicktalbot,\nOOM maybe? What happens if you replace MemoryUtil.memAlloc( 1 << 12 ) with memFree(memAlloc(1 << 12))?. Reproduced and fixed. It was caused by building jemalloc with --enable-lazy-lock, it will not be used in the next snapshot. jemalloc has also been updated to pre-release 5.2.0, which is stable now and contains important fixes.\nThanks!. The current snapshot (build 11) is a release candidate. 3.2.1 will be released in about a week, if no serious issues are reported in the meantime.\nThere are no plans to do a 3.1.7 release. If you'd like to use the fixed jemalloc with 3.1.6, you may do so by downloading it directly (https://build.lwjgl.org/nightly/linux/x64/libjemalloc.so) and using -Dorg.lwjgl.system.jemalloc.libname=<path_to_libjemalloc.so>. It should be compatible with 3.1.6.. It's a false positive, see #420.. There is an allocation happening in the above code: The nvgFontFace(NVG_ID, font.getName()); call must serialize the font name string and LWJGL currently allocates a ByteBuffer via the MemoryStack internally. Assuming nothing else allocates, this would account for ~400k instances at 20k fps.\nBut, this would only happen when running inside a profiler which, ironically, screws up with escape analysis and you end up with useless measurements. Running nvgFontFace in a tight loop produces zero garbage normally, EA eliminates the ByteBuffer allocation.\nSo, two questions:\n\nIs it really a memory leak? Does memory usage continuously increase and never goes down after a GC?\nHow do you measure memory usage exactly in that video?. > When converting the name of the Font to a ByteBuffer instead of a string the ram \"leak\" is indeed fixed.\n\nThis is odd. It sounds like EA is unable to eliminate the internal ByteBuffer allocation for some reason. Could you please share more information on how you run the application? What JVM do you use? Does -XX:+/-DoEscapeAnalysis make a difference? If you've got time to spare, you could try capturing a log and analyzing it in JITWatch, it will tell you exactly why the allocation isn't eliminated. E.g. a method might be too large, or the call hierarchy is too deep.. @Masy I think we're seeing different results because we are on different LWJGL versions. Could you please confirm that you're on 3.2.0 or earlier and that allocations (with the original nvgFontFace call, passing a String) are eliminated when running with the 3.2.1 snapshot build?\nBtw, this is useful just to verify that the recent performance work that has gone into LWJGL helps in such cases. For performance-sensitive code, converting the string to a buffer ahead of time is preferable even with no allocations, it avoids the memory copy. Which can also be much more than a simple memcpy when dealing with UTF-8 encoding.. Thanks!. Currently, the choice between X11 and Wayland cannot be made at runtime, GLFW must be built to support one or the other. That's why lwjgl-glfw-natives-linux.jar includes two binaries. LWJGL defaults to X11. You can use -Dorg.lwjgl.glfw.libname=glfw_wayland (or call Configuration.GLFW_LIBRARY_NAME.set(\"glfw_wayland\") before initializing GLFW) to enable the shared library that supports Wayland.. Hey @SergeySave, this is interesting. Two suggestions:\n\nCould you make the script download the shaderc binaries automatically? You could use the LWJGL version and operating system to construct the appropriate URL (e.g. https://build.lwjgl.org/release/3.2.1/windows/x64/bgfx-tools/shaderc.exe).\nThe include directory could be an absolute path configured separately from tools, so that it can point to a cloned bgfx repository (easier to update without copying anything).\n\nI'm also not sure how to make this available to bgfx users, ideas are welcome.. Hey @layus,\nI'm not sure what this means:\n\nif you happen to build in /build/lwjgl-xxx/, the relative path will be truncated\n\nThe Ant build is meant to be executed from the repository root. What are you doing differently exactly?. Thank you @layus!. Cannot reproduce. Please check that you're making these calls in the main thread and that GLFW reports no errors.. Thank you @Dinnerbone!. LWJGL probably won't play well with AOT compilation, but I haven't tried it.\nThe bundled MoltenVK is built for x64, a separate ARM build is required for iOS, which LWJGL does not provide.. Yes, making the generator produce Kotlin bindings is a long-term goal of LWJGL (the survey asks about it too). Of course, LWJGL is perfectly usable from Kotlin right now, but native Kotlin bindings would have significant advantages:\n\nZero-overhead type-safety for handles (opaque pointers) via Kotlin inline classes.\nStruct API closer to C via Kotlin properties for struct members.\nMultiplatform support.\n\nGenerating the Kotlin bindings should be straightforward (needs a lot of work though) and can be done in the same code base.\nThe native multiplatform target would require a new core module, a different API (e.g. replacing NIO buffers with CPointer and such) and build scripts. This work could be done either in a fork (painful conflicts on every sync with upstream?) or in the same repository using a copy of the existing core & generator modules (features/fixes will need to be synced manually).. A good option for GLES on macOS is MoltenGL. I have tried it and works great with LWJGL.. This disables all warnings and treat-warnings-as-errors for the entire LWJGL core. It's better to isolate this in MemoryAccess.c, using a pragma like:\n``` c\nifdef LWJGL_WINDOWS\n__pragma(warning(disable : 4710))\n\nendif\n``\n. This can be removed.\n. I think this is the only method we should keep. It will be used very rarely and it's OK to write some extra code to handle the other overloads.\n. I have changed the wording a bit.. There's nothing special about the encoding methods, they fail in the same way as other stack allocation methods with anOutOfMemoryError(\"Out of stack space.\")`.. Fixed.. Thanks! I refactored some aspects of the type system a bit and this was simplified to:\nkotlin\nthis !is ValueType && (this.mapping !== PointerMapping.OPAQUE_POINTER || this is ObjectType)\nThe property was also renamed to isReference, which I think is more appropriate.. ",
    "TeamworkGuy2": "The documentation errors should be fixed now.\n. ",
    "max96at": "Hmm, as far as I can tell my mac only supports OpenCL 1.2 and cl_pipe_properties/clCreatePipe was introduced in 2.0, is there any way to build LWJGL 3 without OpenCL 2.0?\n. ",
    "kenzierocks": "It might be due to the cl.exe I'm using, which one should I be using? Currently it points to Visual Studio's compiler under the 'VC' folder.\n. It doesn't seem to do anything, do I need to run it in the same session?\n. That fixed it; but there's new stuff now. New issue!\n. I tried that and it didn't work, it complained that x64 wouldn't work with x86, so I tried x86 and it gave all the errors again.\n. Okay, I see. Will tell if it it works.\n. Build successful!\n. So I am free to go ahead and use the OpenGL side then?\n. Fix is working.\n. Okay. Is there any way I can get notified when those are available besides just watching this space?\n. GL20.glDrawBuffers:\npublic static void glDrawBuffers(int n, ByteBuffer bufs) {\n        if ( LWJGLUtil.CHECKS )\n            checkBuffer(bufs, n << 2);\n        nglDrawBuffers(n, memAddress(bufs));\n    }\nGL20.glUniforms:\npublic static void glUniform1f(int location, int count, ByteBuffer value) {\n        if ( LWJGLUtil.CHECKS )\n            checkBuffer(value, count << 2);\n        nglUniform1fv(location, count, memAddress(value));\n    }\nThey're already there.\n. That did indeed fix it, thanks!\n. If I'm not mistaken the ints correspond to the values received from the C code, so the enums will need the ints coded in them.\n. Oh, I wasn't working on it, just laying down some information. I can work on it if need be.\n. It's not really my call as I'm not part of the development team.\n. As a side note, I think it could be useful.\n. The CI platform is hard to build LWJGL3 on (at least, I had enough problems that I just have it compile against my precompiled version)\n. @dhild I've got a Mac.\n. I think I only have time to test right now, so you should probably get started.\n. ~~Your latest commit (878664b3e08d701ca63f946421a2f8210378afad) should use it.options, not options.~~\nNever mind, I don't know what's failing it.\n. I do know, it's just quicker for me to use what I've already got.\n. Yes, Macs are Darwin->BSD->FAMILY_UNIX so that check is probably true\n. No problem :)\n. I don't get this freeze on Windows -- possibly platform specific?\n. You may want to retarget this for the gradle branch, just a thought.\n. Oh, I was really thinking about some of the more advanced stuff awt Color provides, I guess I'll take what I can from that then.\n. http://rebaseandsqua.sh\nOn Thursday, September 24, 2015, Matthew Webb notifications@github.com\nwrote:\n\nThank you so so very much! I will get right on it during my lunch period!\nQuick question: how do I change the commit that I made to this PR without\npushing another commit? Do I have to revert that commit and push a new one\nto my fork?\nP.S. I promise my next PRs will be more useful!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/pull/89#issuecomment-142988240.\n\n\n~Kenzie Togami\n. I like Option A, and I could even write a simple Gradle plugin to allow you to do code similar to Option C:\ngroovy\n// +natives signals to the plugin that there is natives\n// Might be possible to allow something like +natives(osx,linux)\ncompile 'org.lwjgl:lwjgl-glfw:$lwjglVersion+natives'\ncompile 'org.lwjgl:lwjgl-stb:$lwjglVersion+natives'\ncompile 'org.lwjgl:lwjgl-jemalloc:$lwjglVersion+natives'\n// opengl has no natives, no +natives\ncompile 'org.lwjgl:lwjgl-opengl:$lwjglVersion'\nEdit: The plugin might even be able to do natives detection, though I fear it might not always be 100% accurate.\n. Do you know when a new nightly will go out with the fix?\n. Yep, thanks!\n. I agree with @huhlig about making this a subproject. I think that if LWJGL starts including a lot of bindings then #100 should become a much higher priority.\n. I think YAML might require tabs (I know some implementations do) which could be troublesome/time-consuming if spaces are used accidentally.\n. Maybe it could be a secondary artifact, for those who know users will run on Hotspot JDK 7+ (e.g. they provide it) and want to get more speed. I could see that being very interesting for video games that bundle the JRE.\n. OK, that looks like it'll cover me. Thanks!\n. The change you made makes it impossible to implement multiple callbacks now, since the shared callback(long) and set(long) defaults conflicts among the different callbacks. Is it just not advised to directly implement more than one callback?\n. This is what I used to do @Spasi, extending the SAM interface. This might not be supported, would you recommend I do something like this instead?\n. OK, I'll do that instead. Thanks!\n. I think gitter would be better, but there is still a very inactive IRC channel on Freenode.\n. Interesting, I updated and I'm still getting this problem. I'll poke around with it some more.\n. Ok, I copied the code reported in that comment, and I'm still getting 0s with build 18. Looks like it didn't get fully fixed somehow?\n. Here's a program that prints all 0s for me, and no errors: https://gist.github.com/kenzierocks/ca114ad0f10bf248a3f134c95bf74e33.\nHere's the log from that program: https://gist.github.com/kenzierocks/33bfb80d1f9a449b757fbc15ad74be09\n. I just built a fresh copy of openal-soft and loaded it instead of the packaged one, and it was fine. So I have a workaround for now.\n. Ah, I see. I'll use my workaround until the next build then.\n. Interestingly, I didn't get this crash in build 18 of LWJGL. Did you change something recently related to this?\n. I tried out the ExampleGL3 demo, and it worked fine, so it might be something in my code, although I'm not sure what yet.\n. I've figured out the problem. I guess that the library extractor doesn't clean up old versions of files, so I had old natives lying around that I needed to remove. Perhaps the extractor should be cleaning these up when the build number differs?\n. Ok, that works well. I'm currently trying to track down a mysterious INVALID_OPERATION that only appears if I check errors more often, which is very curious.\n. It looks like there's no support for that on OSX: My OpenGL version only goes up to 4.1 and none of the extensions are available.\n. Is there plans to implement this now that the Assimp binding has a shared library?. Sounds good, thank you for explaining.. I think an OpenGL context can only safely be active on one thread at a time. You can set the active context for a thread using glfwMakeContextCurrent, which can be called from any thread.. If I recall correctly, you can directly specify the absolute path to the library using an system property, which should be easier than LD_PRELOAD. . It looks like it takes two int*, aka pointers to ints, which in Java is either int[] or IntBuffer, so this signature is correct.. Unless things have changed, LWJGL is still 100% Java at compile time, and only uses Kotlin for generation of sources. It's not really a Kotlin library. . Don't you need to use allocateDirect, so the buffer is stored off-heap? . That makes sense. However, it's not clear (in LWJGL) that the pointers are to AIVector3d.Buffers. Could this be documented somewhere?. That sounds exciting! Thanks for the explanation, and I'll look into learning more about C type declarations.. java\nGLFWImage.Buffer gb = new GLFWImage.Buffer(icon);\nGLFWImage iconGI = new GLFWImage(icon);\nThis treats your image data as the specified struct, which is not what you want. You want to store your data in the structs, like so:\njava\nGLFWImage.Buffer gb = GLFWImage.create(1);\nGLFWImage iconGI = GLFWImage.create().set(<width>, <height>, icon);\ngb.put(0, iconGI);\n(I used #create because the memory will be automatically freed for you, if you know how to manage memory then you can use #malloc.)\nYou'll need to pass the width and height from the BufferedImage as well.\nAs an aside, your buffer copy code can be simplified, as there's no need to specify native order (it's already done for you):\njava\n            ByteBuffer ib = createByteBuffer(iconData.length);\n            ib.put(iconData);\n            ib.flip();. Why do you think your buffer is deleted? It looks just fine.\nYour window, however, is a null pointer. You have an error in your window creation, so you won't be able to call glfwSetWindowIcon.. How are you running the demos? The feature used there is only present in the latest snapshots, so if you're attempting to run it on 3.1.6 it won't work. . Works for me with Chrome on Windows. Are you able to save the specific config you're using? Perhaps there's something wrong with what you've chosen.. ARM is still unsupported, see #206. . I believe it's already in there, check the META-INF/versions/9 folder. . Looks like a false positive -- the Javadoc jar should contain no compiled classes, and therefore no Java code. . I'm getting a similar crash: https://gist.github.com/kenzierocks/4f3159ff99994872d7dcfbf557d410d9\nLWJGL 3.2.0, JVM 1.8.0_181-8u181-b13-1ubuntu0.18.10.1-b13, Platform Linux. A newline \\n was added to the end of the file. It is a convention in git to end all files with a newline for better diffs when appending to the end of a file. . ",
    "dustContributor": "Nope, I meant to post it here. I don't have a build of LWJGL 3 and since I don't quite know Kotlin I tried to find the calls in the sources (or in the generator files) but I couldn't find them :D In any case, its great that its already in LWJGL 3 then, thanks!\n. Bullet bindings? Awesome. I'm using LibGDX's wrapper but it has the habit of using LibGDX's classes where it can, which makes it a hassle to use if you happen not to use the rest of LibGDX.\n. I'm not even terribly sure why LWJGL would be useful in Android. Android already has OpenGL bindings for the ES versions it supports...\n. Except its Android what we're talking about, and having the same API in Android and desktop (same window creation, same input handling, etc) means something like a tiny game engine. You already have things to fill that spot around.\nLWJGL does Java OpenGL bindings. Android already has those, its own way to setup surfaces, its own way to handle input, hell its own set of particular necessities and weird abstractions (intents, activities, fragments, etc). It doesn't needs LWJGL, it needs a higher layer of abstraction, which would use LWJGL for its desktop backend, and standard GL stuff for its Android backend. You already have that, its called libGDX.\nIf you do your OpenGL calls like GL20.glSomething instead of gl.glSomething (or whatever) is going to be the least of your issues there.\n. You can watch one of the Vulkan presentations Khronos did after the one from GDC https://www.youtube.com/watch?v=EUNMrU8uU5M (Graham Sellers, one of the presenters in AZDO talk is there). They said they'll upload the GDC talk with good quality later.\nI've seen Spasi mention in java-gaming forums the need for Vulkan to be given a custom memory allocator but Graham mentions its optional.\n. Aaaand no Fermi support :sob:  Well, have fun with it.\n. They said it would work on GL ES 3.1 cards and up. So yeah, it is a surprise.\n. That's Wikipedia and uncited, you know why it isn't cited? Because its not what they originally said in Khronos slides. I went by what they said in their slides. They didn't said it could work, they said it would.\nHonestly I don't need the explanations, I already read an nvidia's employee answer about it. I'm just pissed that they didn't mentioned it before.\n. Yeah it is time to upgrade, but where I live I'd pay 350+ USD for a GPU the yanks pay 200 USD for, while I am also earning much less. So its not something I am terribly looking forward to : /\nI think I'll just stick to GL for now, maybe buy an used card down the road or something.\n. No texture formats reported, hm... Thats weird. There is no OS version report on the other Fermi GPUs either (520M, GTX 560 Ti). Prolly people editing the .INF and installing the beta driver anyway.\nThey've been pretty quiet about D3D12 on Fermi too. Maaaaaybe they're planning on wrapping up D3D12 and Vulkan together, but I doubt it.\n. Yeah, good points. Prolly we'll get a bunch of similar tools \"later this year\". In the meanwhile I'll be trying nVidia's Linux OpenGL debugger.\n. Death to Display/Mouse/Keyboard!\n. Ohhh, core OpenGL backend. Nice.\n. I'm with kappa.\nEDIT: Not physically :stuck_out_tongue_closed_eyes: \n. What do you mean? I can use a core context with SWT on Linux right now? Or you're saying it works as long as you use a compatibility profile?\nBecause OSX isnt the only one that doesn't provides compatibility profiles, Intel's Linux drivers don't support them either.\n. In my humble opinion its more of an issue if a GUI lib doesn't supports core OpenGL than not supporting LWJGL 3 (TWL is really nice but it's renderer is GL 1.1 exclusively).\nNiftyGUI is there, has a core OpenGL backend, but doesn't supports LWJGL 3 (mainly Display/Keyboard/Mouse related changes and some function name changes).\nAlso another concern of mine is the state in which the GUI lib leaves OpenGL. This should be very well defined, ie, what state OpenGL needs to be before the GUI lib can do whatever it needs to do, and what state is OpenGL left with once it finishes. This is vital for efficient state tracking.\n. That sounds both slow and bound to hit driver specific issues. No, I'd rather handle the state change myself.\nAt the very least it should have a renderer interface that doesn't assumes fixed-function pipeline working underneath, TWL has that issue in various places last time I checked, which makes it a pain in the butt to code a core renderer for.\nI still propose NiftyGUI as a better alternative, right now it just needs a couple of classes using a LWJGL 3 backend. I opened an issue about it a while ago https://github.com/void256/nifty-gui/issues/304\nThere is literally no other GUI library that has a core renderer that I know of (for Java that is), thus why I think its an important matter. OpenGL 3.0 has been out there for 7 years, with hardware supporting it going as back as 2006 (GeForce 8xxx, Radeon HD2xxx), that was almost ten years ago.\n. I recall digging through the sources and finding no clear way to hijack the SWT's component so I could use it with my core context (although my experience with window management APIs is limited).\nBoth JavaFX and SWT (since 4.2 I believe) are theme-able with CSS, which is a pretty cool thing to have.\nI wonder if we could nag SWT developers about this...\nEDIT: Still no interest in NiftyGUI?\n. I've been thinking. Now that NanoVG bindings are up, it might be possible to use it as backend for other GUI libs that lack an OpenGL core context, like TWL for example.\nI'm looking at TWL's sources, seems a lot of work though -_-\n. I completely forgot about libRocket: http://librocket.com/\nIts C++ though.\n. Sweet, it even leaves rendering up to the user by just giving you commands to execute, perfect.\n. https://github.com/glegris/nuklear4j\nDafuq, never saw what O_o\nEDIT: Oh, SWIG : /\n. Awesome! I didnt see that branch. I better read up on Nuklear then :smile: \n. Awesome man, thanks a lot for your work!\n. I was reading some Java articles and it popped up that Gluon published release/support plans for OpenJFX. For those who don't know, JavaFX is being removed from core JDK, and it will be released separately. So to use it you'd need it to import it like any other dependency (maven, raw jars, etc). And now it will be called OpenJFX.\nhttps://gluonhq.com/javafx-11-release-and-support-plans/\nThey have a GitHub mirror of the OpenJFX repository and they say they pay attention to the issues there. https://github.com/javafxports/openjdk-jfx\nMoreover, they say they have their bug tracking on the JDK thingy (although the site works like ass for me and I cant find it) https://bugs.openjdk.java.net/secure/Dashboard.jspa\nAnyway, I'm wondering if that given the changes JFX is going through, if it would be possible to push for direct access to the GL internals from it? As a means to integration with other GL rendering.\nAll the stack is open source now so you got in that repo their \"Prism\" rendering engine and all, plus the HLSL/GLSL shader transpiler (Decora I think?) and some other nifty things.\nIn any case, they went a different route for it so instead of making bindings and \"lower\" the layer of native interop, they instead \"raised\" it by making the rendering part in C/C++ (doing all their multi platform context management on their own and all) and exposing higher level operations to Java. That doesn't sounds like it'd interact well with how LWJGL works but I wouldn't know.\nIt gets complicated because OpenJFX uses three backends, OpenGL ES 2, Direct3D and software. So what happens if you want to use OpenGL Core? Or Vulkan?\nIt's pretty complex, and I personally believe that The One True Way\u2122 to do an UI lib for games is doing it like Nuklear does, handing out buffers of vertices/uvs/indices at rendering stage and have the user be responsible of displaying that to the screen, but I thought someone might be interested.. I see you know already how to tackle it. \nI inspected a bit OpenJFX code and it seems to have a rather direct rendering, in the sense that it has fairly hard codes operations in a bunch of classes that do specific things. \nI'm guessing that achieving Nuklear-style of integration (ie, making it spit out vertices and texture bindings, API agnostic) would be pretty hard.. > If anyone want to contribute, request any changes - you are welcome.\nI'll repeat what I said above (except longer!). I dont think having your own rendering backends is a good idea. You don't know how I, library user, do my rendering, you don't know what API I run, you don't know what version I run, and you really shouldn't.\nThings that did their own drawing like Scaleform on big AAA games were phased out, because you have a complete subsystem trying its best to group rendering commands, group state and shader changes, and drawing all of that efficiently, and then you stuff your code with some other renderer that has some other API with some other concepts that just doesn't fits on how your engine does its drawing.\nYou have libraries like NanoVG, Nuklear and (now defunct) libRocket that are really really easy to integrate because they have a clear distinction between what is UI handling, what is rendering and what is input handling.\nWithout the library setup code, this is my rendering loop for Nuklear:\njava\ntry ( MemoryStack mem = MemoryStack.stackPush() ) {\n    // setup buffers to load vertices and elements\n    final NkBuffer vbuf = NkBuffer.mallocStack( mem );\n    final NkBuffer ebuf = NkBuffer.mallocStack( mem );\n    nk_buffer_init_fixed( vbuf, tmpVertices/* , max_vertex_buffer */ );\n    nk_buffer_init_fixed( ebuf, tmpIndices/* , max_element_buffer */ );\n        // converts buffers to the layout specified in the config\n    nk_convert( context, commands, vbuf, ebuf, bufferLayoutConfig );\n}\n// Upload data to the GPU\nglAttribBuffer.bind().updateUnsafe( tmpVertices );\nglIndicesBuffer.bind().updateUnsafe( tmpIndices );\n// Process task commands.\nint offset = 0;\n// Compose render tasks out of nuklear's draw commands.\nfor ( NkDrawCommand cmd = nk__draw_begin( context, commands ); cmd != null; cmd = nk__draw_next( cmd, commands,\n        context ) ) {\n    final int elmCount = cmd.elem_count();\n    if ( elmCount < 1 ) {\n        continue;\n    }\n    // Submit task to the queue.\n    // Matrices computed in shader.\n    renderer.addToQueue( taskBuilder.reset()\n            .type( RenderTask.Type.NUKLEAR )\n            .meshId( glVao.id )\n            .material( materialsById.get( cmd.texture().id() ) )\n            .vertexCount( elmCount )\n            .indicesOffset( offset )\n            .build() );\n    offset += elmCount * 2;\n}\nI just ask for Nuklear to fill vertex/index buffers, upload them to the GPU, then compose render tasks that use them and that's it. \nI know that will best fit my rendering scheme because it is my rendering scheme. It will use the API I use, it will use the version I use, it will track state changes like I do, it will batch UBO updates like I do, and run without switching shaders unnecessarily like I do, and if I wanted I could make it use my instanced rendering by grouping by material first.\nI dropped things like NiftyGUI because literally the first time I use them it turns out that there was some GL context interaction that they didn't account for so I had to spend time debugging what state my renderer was leaving GL with, what state the UI lib really needed (that may or may not be what the documentation says) and what state the GL context ended being in that made things not work correctly. \nThe GPU is a big fucking thing, wouldn't it be nice if you (lib author) didn't have to account for these things? Wouldn't it be a concern better suited for myself the library user since I know what API I target and how I want to use it?\nI'd say: Write an UI lib, or a renderer, but not both in the same thing. They're separate concerns, and big enough to warrant their own separate libraries.\nThe same argument can be made for input handling but that'd make this too long. I have an input system that translates GLFW's stuff for my own scheme, and those events get pushed to Nuklear, Nuklear doesn't cares how do I map my keys, devices or anything, it just cares for being fed input events in a format it understands.\nAt least that's my POV after trying out integrating JavaFX, Swing, TWL and NiftyGUI multiple times over time. Nuklear, being the pain in the ass of a library it is to use, was way, way easier to integrate. And since the API is so clean cut on that regard, it was easier to debug. I know when it renders because I render it. I know when it processes input because I tell it to.\nThat said, I know UI is hard, that's why I'm always in the lookout for a lib that does it for me. I understand making such a simple integration point isn't easy, and may require rethinking a lot of abstractions. For example, it's really hard  to move TWL as-is to such scheme, or even to using a core GL context (nevermind Vulkan) with it because not only believes it should draw itself, it believes it should draw itself like they did with OpenGL 1.1 in 1998, which for any kind of recent project is a problem. The right abstractions just aren't there.\nMoreover, I will argue that moving to such scheme not only opens up the integration possibilities, it has no drawbacks. Nothing prevents you from implementing a GL 1.1 renderer for Nuklear, or a Vulkan one, or a software renderer, nothing prevents you from supplying separately your own backends to draw it if you really really want to code an UI renderer. Hell, it wouldn't surprise me if data-driving it that way made the whole thing faster via handling flat buffers of draw commands and vertices. It just makes the whole ordeal way easier for everyone involved.\nI'm not writing this for you specifically anyway, so dont take it as a big ass critique of your code, I've only skimmed through your library and it probably does a lot of things right that aren't even on my mind right now. I'm just writing it for anyone who is interested in doing/using an UI library in Java for videogame (or any real-time graphics) purposes. . You should use KHR_debug_output and/or ARB_debug_output for these kinds of things. Driver might let you know something. LWJGL provides a handy utility method for doing so:\njava\n// So we can set a breakpoint inside the callback.\nGL11.glEnable( KHRDebug.GL_DEBUG_OUTPUT_SYNCHRONOUS );\n// Now setup and pass the callback to GL.\nClosure debugCallback = GLUtil.setupDebugMessageCallback();\nIts really really handy when you have some \"invalid param\" GL error somewhere and you can't figure out what call is causing it. Put a conditional breakpoint inside the callback, wait for the error and bam, actually usable stack trace :smile: \nSpasi even made it so it can choose the debug implementation that is best for the current GL context.\n. Um where exactly?\nIt only says \" use of the NVIDIA GameWorks Licensed Software with platforms other than the Authorized Platforms requires entering into a separate commercial license agreement with NVIDIA. \"\nThat means you're free to use it on Windows, Linux and Android as long you accept that EULA you linked. It mentions the \"Authorized Platforms\" a little bit above.\nAlthough now that you mention it, OSX isn't included, hm.\n. > where as LWJGL would not be distributing the games, everyone who makes games with LWJGL would be.\nNo. Only if you use PhysX, not if you use LWJGL. You have the option to use PhysX or not. And I already mentioned those kind of conditions. You have to put a few nVidia logos here and there, and let them know you're going to release a game with it. It literally says just send a mail. Not \"applying\" for anything, it doesn't says they have to greenlight your game, it doesn't says you have to pay for it. It only says you have to accept those conditions. Thats it.\nStill I understand why some of this might be annoying to do for some people. Plenty wouldn't want to put nVidia's logo in their game. Then again, if anybody is going to sell their game, certainly it isn't the biggest paperwork he/she is going to do (taxes, company papers, bank accounts, steam eulas, etc). And as I said, simply go and use Bullet or something if it annoys you.\nGah, this obviously won't go anywhere, better just close it.\n. I understand. Glad that you're open to the idea though.\n. It being a C++ API is still an issue. I've detailed a few other options in #428 Personally I take a jab at Newton bindings every now and then when I have time for example.. It is, nobody is saying that it isn't possible at all.\nLWJGL is built around a bindings generator engine, which with a (fat) bit of manual input in a DSL Spasi made in Kotlin, and some magic sprinkled on top, it can generate Java bindings, with native interop code and all, from C libraries. It can generate the Java side and the native glue that casts JVM types back and forth when calling said native libraries, with all the LWJGL ecosystem supporting it (ie, type safe struct handling, memory management utilities,  debug mode that checks for nulls and array sizes on each call, etc).\nMind you, this is all still using JNI. It's just that JNI alone isn't enough to make bindings work as you would expect. You might have a nk_font_color(nk_color* color) function in C, but LWJGL makes sure you have a \"NkColor\" class that has neat set_red(float) and set_blue(float) methods that place those 4 bytes each in the right offset from the memory allocation, it makes sure that NkColor gets unwrapped nicely into a long/int64 and passed to nk_font_color as a pointer like it expects, all the while making it so it's easier for HotSpot to allocate that NkColor object in the stack if you play your cards right.\nWhat I am saying is that C++ library bindings aren't possible within the LWJGL framework for now, it has no concept of classes, methods and all that jazz that makes C++ the Zee Plus Plus. That's why all the bindings right now are pure C libraries like stb, or C++ libraries that expose a C API like bgfx. . > It seems like AWT/Swing is still a very popular solution for doing GUI programming in Java.\nYou shouldn't hang out with those people :stuck_out_tongue_closed_eyes: \n. Yeah I was implying JavaFX is a better option :smile: \n. > Having interfaces implies having instances that implement those interfaces. This will never happen in LWJGL.\nPraise Spasi \\o/\nI agree, its not a big deal. And extending classes just to import static functions is plain fugly, and a bad practice as it is. I doubt anyone here wants to encourage that kind of usage.\nIt'd be nice to have a \"import org.lwjgl.opengl.CoreGL33.*\" and get all the stuff in core OpenGL 3.3 but its far from a dealbreaker.\n. Windows only?\n. Pretty much, want something like SDL2? Use libGDX.\n. Android LWJGL doesn't seems reasonable until Google has OpenJDK running on most of the devices.\nThe whole mix and match between Apache Harmony libs and Google's stuff is a pain in the butt to work with honestly, at least coming from desktop Java.\n. I have no issue with opaque pointers. It'd be really straightforward to make wrapper \"create\" that call Callback.get(cb) inside if needed. \nAlso not a lot of code would actually call these \"GLFWKeyCallback.create\" anyway, so making it slightly more verbose for the cases where you do want to retrieve the callback object shouldn't have much impact, if at all.\n. lol thanks!\n. Also there seems to be missing a method like:\n- GL13.glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, ByteBuffer data)\nMoreover, when I switched to the the existing overload with a 'long' data pointer parameter, that one does this check for some reason:\njava\nGLChecks.ensureBufferObject(GL21.GL_PIXEL_UNPACK_BUFFER_BINDING, true)\nSo now my texture code raises an exception. No idea why is checking for pixel unpack buffer, I'm just uploading DXT data to the GPU : / EDIT: Well technically I'm just allocating the buffer, passing a null pointer.\nIf I switch to the ngl* version, which does no checks, everything works as intended.\nEDIT2: If I switch to the overload that doesnt receives an 'imageSize' parameter and that checks for pixel unpack buffer false, then I just get brown blobs as textures.\n. > In general, I now consider reusing buffers or caching buffer instances globally an anti-pattern, rethink your approach if you do this often. It's very likely that you've complicated the code with no real benefits (including performance).\nHuh? I have a stack allocator implemented in Java that returns ByteBuffer instances. Single alloc at application startup then I just shell out slices as needed, similar design to the stack allocator yourself said was faster than using jemalloc. Way more simple code than manipulating type specific views, I already went through that. I had the allocator before jemalloc bindings existed, and worked fine for two years until right now.\nIn any case, if it is intended, I'll just use the 'long' pointer overloads then. Easy enough to do with MemoryUtil. No problem.\n\nYes, because the imageSize parameter is ignored when the data parameter is NULL. What happens is that a texture is created with unspecified contents.\n\nI know. I'm doing what you'd do if you had ARB_texture_storage for example. Do the allocation first for all the mip map levels then upload the data later. I am passing null/0L to the ngl* call that does works too.\nWhat I am saying is that when I use the overload that doesn't has imageSize, which you're saying I should be doing since I'm not uploading the data at that time, something gets broken, because the texture data I later write to the buffer doesn't gets shown.\nIf I specify imageSize, it works, if I dont, it doesn't. And the only way I have to specify imageSize without the thing raising exceptions is the ngl* call.\nThat GL_PIXEL_UNPACK_BUFFER \"true\" check shouldn't be there, or might be a driver thing, the docs dont say anything about \"ignoring\" imageSize at all for example.\n\nThe single value overload of glGetBoolean returning byte instead of boolean is a bug\n\nAh okay.\n\nIdea: we could identify structs that are exclusively managed externally and not make them AutoCloseable.\n\nSounds good to me.\n. > Have you tried replacing it with LWJGL's MemoryStack?\nHaven't had the time. Working on an editor right now. Its on the backlog though :smile: \n\nWhat GPU/driver are you testing on? How do you later specify the texture data?\n\nGTX680, driver 364.12, Debian x64. OpenGL 3.3 core.\nAllocation code is the following:\n``` java\nprivate void allocCompressed ( final int tmpTarget ) {\n    int w = width;\n    int h = height;\n        // This depends on the DXT compression used.\n    final int blockSize = this.compressedBlockSize;\nfor ( int i = this.baseLevel; i <= this.maxLevel; ++i ) {\n    // Calculating the size of the current mip map.\n    final int imgSize = blockSize * ((w + 3) / 4) * ((h + 3) / 4);\n    // This would be the call that worked on lwjgl 3.0.0 build 44 \n    glCompressedTexImage2D( tmpTarget, i, this.internalFormat, w, h, 0, imgSize, null );\n\n    // Further mip maps will be power of two.\n    w = max( prevPowerOfTwo( w - 1 ), 1 );\n    h = max( prevPowerOfTwo( h - 1 ), 1 );\n}\n\n}\n```\nThen the code for the uploading is a bit more involved, but it uses:\njava\npublic static void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ByteBuffer data)  { /* stuff  */ }\nFor each mip map level.\n. The issue on that particular call isn't that there is an overload missing, but that it checks for GL_PIXEL_UNPACK_BUFFER_BINDING when it shouldn't.\nThis works because LWJGL does no checks inside:\njava\nnglCompressedTexImage2D( tmpTarget, i, internalFormat, w, h, 0, imgSize, 0L );\nThis doesnt, because LWJGL itself throws an IllegalStateException, not because its an invalid OpenGL call:\njava\nglCompressedTexImage2D( tmpTarget, i, internalFormat, w, h, 0, imgSize, 0L );\nThe implementation does this:\njava\n  public static void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data) {\n    if ( CHECKS )\n      GLChecks.ensureBufferObject(GL21.GL_PIXEL_UNPACK_BUFFER_BINDING, true); \n    nglCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);\n}\nThe gl call is checking for state that isn't needed, whereas the ngl call with the same arguments works fine. It just happens that the removed overload with ByteBuffer didn't had the GL_PIXEL_UNPACK_BUFFER_BINDING check (or checked for 'false' instead of 'true').\nLWJGL is preventing me from making a perfectly valid OpenGL call.\n. I noticed only recently there were bgdx bindings, great work dude! :smile: \n. > We cannot programmatically change the download's filename because we initialize the download from a different origin\nAhh I understand. What about the root folder inside the zip then?\n. I get now that its a direct port from Nuklear demos. Maybe I should raise the issue there and ask them not to start those functions with \"nk_\"?\n. Thanks!\n. You could call it like \"25% performance gain in thread locals!\" for the next stable changelog :stuck_out_tongue_closed_eyes: \n. Who is awesome? You're awesome! Thanks a lot for your work!. Sweet :smile: . Sweet. I'll look into the generator in the future. Thanks!. All right, I grabbed the GLFWDemo.java file you have in the repo.\nMade the following changes:\n- Removed vsync via glfwSwapInterval( 0 );\n- Removed Calculator.layout and Demo.layout calls so nothing else gets drawn.\n- Added both the codepoint cache (albeit with HashMap, so with a few differences from the previous snippet) and your decodeUTF8 method.\n- Drawing this view class below:\n```java\npublic class TextTest {\n  private final IntBuffer compression = MemoryUtil.memAllocInt( 1 ).put( 0, 20 );\n    private final String text;\n    {\n      StringBuilder bld = new StringBuilder( 2048 );\n      for ( int i = 100; i-- > 0; ) {\n      bld.append( \"asddas asd asd ssd asd ddsasd asdasd \" + i + \". \" );\n      }\n      text = bld.toString();\n    }\npublic void accept ( NkContext ctx, int width, int height ) {\n  try ( MemoryStack stack = stackPush() ) {\n    final NkRect rect = NkRect.mallocStack( stack );\n    // Widget takes 1/6 of screen height, and 1/3 of the width, centered at the bottom.\n    int windowWidth = width / 3 * 2;\n    int windowHeight = height / 6;\n    int xpos = width / 2 - windowWidth / 2;\n    int ypos = height - windowHeight;\n\n    if ( nk_begin( ctx, \"Asd\", nk_rect( xpos, ypos, windowWidth, windowHeight, rect ), 0 ) ) {\n      nk_layout_row_dynamic( ctx, 25, 1 );\n      nk_label( ctx, \"Header\", NK_TEXT_CENTERED );\n      nk_layout_row_dynamic( ctx, 25 * 50, 1 );\n      nk_text_wrap( ctx, text );\n      nk_layout_row_dynamic( ctx, 25, 1 );\n      nk_property_int( ctx, \"Compression \", 0, compression, 100, 10, 1 );\n    }\n  nk_end( ctx );\n}\n\n}\n}\n```\nResults are:\n- Without cache nor Java side decoding: 13ms to 14ms per frame.\n- With Java side decoding:  11.5ms to 12ms.\n- With codepoint cache: 5.5ms to 6ms per frame.\n- With both cache and Java side decoding: 3.3ms to 3.5ms.\nIn the last case, the nnk_text_wrap call is the one showing in the sampling profiler, taking 70% of the time. Second call is DynCallback.ndcbArgPointer with 7% of the time. It shows 4% GPU utilization so it doesn't seems Nuklear is generating excessive geometry or something (or at least if it does, it's cheap enough to upload it to the GPU).\nFor comparison, my project can render a few omni lights, a directional light, and a bunch of cubes, with deferred rendering, normalmapping and shadowmapping for the directional light in less than 1ms per frame.\nIf I render the default Demo and Calculator views, without caches (so pretty much like the default GLFWDemo), it takes 0.5ms to 0.8ms per frame. But it has very little text.\nMy code to measure frame time is like this:\n```java\ndouble acc = 0.0d;\nint frames = 0;\nwhile ( !glfwWindowShouldClose(win) ) {\n  long timerStart = System.nanoTime();\n  ++frames;\n / All rendering here. /\n  long diff = (System.nanoTime() - timerStart);\n  acc += (diff / 1000000.0d);\n  if(acc > 1000.0d) {\n    System.out.printf( \"Millis per frame ----- %.3f\", Double.valueOf( acc / frames ) );\n    System.out.printf( \"FPS: %.3f\", Double.valueOf( frames ) );\n    System.out.println();\n    acc = 0;\n    frames = 0;\n  }\n}\n```. I see, makes sense. @vurtun Hello? How do I lots of text in Nuklear? We're having issues here with text wrapping widget with long (4k+ characters) strings. Apparently nk_text_wrap eatus up the CPU with long strings due internal behavior. I believe what I am intending to do is fairly reasonable, think something like Pillars of Eternity or Tyranny dialogue boxes, they have lots of scrollable text since conversations with NPCs can be long. But if it takes half of my frame budget I'm in trouble :sob: \nHopefully he has notifications enabled :smile: . > My question here is are these dialog boxes persistent?\nNo idea what you mean by \"persistent\" but they're like this\nYou can scroll up to see the previous responses in the widget, you have differently colored text in the same lines, and the responses are selectable text basically. Not quite sure how to do the last one in Nuklear. Moreover, a feature they added in Tyranny was text that when you hovered over, it'd spawn a popup explaining what it was. Say,  when someone said \"Back in the [War of the Tides] we...\", hovering over \"War of the Tides\" would spawn a pop up explaining what that meant. Dialogue box isn't closed until you stop talking with the NPC.\nIn short, what you're saying is that I should do the text wrapping widget myself and use Nuklear like more of a drawing API. I guess I can do that, it'll take me a while with scrolling and all.\n\nBy the way the reason why text takes up so much memory is because each glyph takes up 4 vertexes plus 6 indicies so if you multiply that out for all text visible that is quite a lot.\n\nEh, say that we have 8k characters visible (I dunno, player is reading an in-game book or something), that is 4 verts * 8000 chars * 4 bytes per vert + 6 indices * 8000 chars * 2 bytes per index. 220kB. My GTX680 from 5 years ago has... 2GB. I think it should be fine.\nBut that's secondary. I think the CPU time spent is way more important given it can shave off half of your expected rendering time.. > I would have never imagined STBTrueType to be something which should recalculate and rerender the glyphs each frame. I would always bake it into a texture and render that texture then.\nYup, that's exactly what the demo code does, we're not talking about STB's font rendering. It's about the glyph width calculation Nuklear uses for computing text line widths, which decides what geometry vertices/indices Nuklear generates. Glyphs are already there in the GPU, not the issue there given it's relatively very few draw calls (3 for all the text I was showing in my tests, for example) and no state changes whatsoever besides binding the baked glyph texture once. \nWhat we did with Spasi was to cache the width results (among other things), which gets rid of a lot of the run time of each glyph width call. The next issue is that it's just called a lot for long texts in the nk_text_wrap widget, so no matter how cheap we make those 'width' calls, it's going to drag frame time down. Something a stateful widget could improve on.\nThe text in its entirety could be baked into a texture, then simulate the scrolling via offsetting the UVs, but I don't think it's really necessary to go that far. Avoiding the 'width' calls should be enough for normal game text usage and then some, since in the grand scheme of things it's not that much geometry, and its drawn with very few calls/state changes anyway.\nHowever, it could become a problem as you add things like various fonts in various sizes, different colors and/or effects, etc. ie, piling up draw calls and state changes. I don't have such test case yet though, but I'm not too worried. I doubt any game UI has that much text crazy-ness going on, and even if it did, I'm not planning on doing such thing anyway.\n\nHow I would do it is [...]\n\nAh I see, I'll check out nk_selectable then. I'm guessing I'll have one nk_text per colored text right? What would the purpose of nk_group be in this case? I was just thinking of drawing each nk_text line in a static row and add as many as I needed.\n. Okay but what nk_group has to do with scrolling? I'm not finding any related doc in the sources that explains what they're used for.. Alright, thanks a lot! I'll see what I can do. I guess I'll go ahead and close this since it isn't LWJGL related.. Just a heads up. Apparently Bullet 3 has a C API\nhttps://github.com/bulletphysics/bullet3/blob/master/examples/SharedMemory/PhysicsClientC_API.h\nAccording to Bullet 3's repo, this is a \"new physics-engine agnostic C-API\" that they themselves are using for creating Python Bullet bindings in the PyBullet project. According to the authors it's a more higher level API (which sounds nice!).\nThe API uses a client/server architecture apparently, where each \"server\" has their own \"world\" instance.\nThe PyBullet Quickstart Guide has some details about it.. Thanks a lot Spasi, you're the best! I'll try it out when I can, hopefully this will allow me to get rid of libGDX as a dependency at last :smile:\nDo you know how the plugin thingy works? Something rather useful are the collision filter masks, which seems to be a plugin rather than in the core API.. I'm halfway through moving my physics stuff to this C API.\nSo far it's going ok. It's a fair bit higher level than the base Bullet API for a few things. Like initialization is just like in your example, set a timestep and gravity and you're good to go.\nSomething I also think I got down is ray casting:\njava\nvar cmd = b3CreateRaycastCommandInit( hnd, from.x, from.y, from.z, to.x, to.y, to.z );\nb3SubmitClientCommand(hnd, cmd);\ntry ( var mem = MemoryStack.stackPush() ) {\n    var info = B3RaycastInformation.mallocStack( mem );\n    b3GetRaycastInformation( hnd, info );\n    var hitsLen = info.m_numRayHits();\n    if ( hitsLen < 1 ) {\n        return -1;\n    }\n    var hit = info.m_rayHits().get( 0 );\n    return hit.m_hitObjectUniqueId();\n}\nI'm pretty sure you don't need the \"b3SubmitClientCommandAndWaitStatus\" with the status check after because the direct server just works straight with the API underneath. For instance the status check underneath just checks if the command processor is connected, and the direct command processor always returns true for that.\nIn any case, very recently (3 days ago as of writing this) Bullet guy added the possibility of creating an arbitrary mesh with passed vertices, something that was missing from the C API. You could only create basic shapes or load one from that robot format thingy. I have no need for it now but it'll be useful later (specially for heightmaps).\nNow I'm researching how to create shapes that aren't boxes. For boxes you got 3 or 4 functions, but for every other shape it seems you have to create a b3CreateCollisionShapeCommandInit and then do b3CreateCollisionShapeAddCapsule (or any other shape) on it.\nI'm wondering, all of the C API seems to be using doubles, but you say you compiled it with single precision, so if I use floats in Java land, the C API casts to doubles, but then Bullet inside casts back to floats? I don't really mind, just curious.\nI've been using his implementation of the PyBullet bindings as a reference, since it has all of the API implemented and used there:\nhttps://github.com/bulletphysics/bullet3/blob/master/examples/pybullet/pybullet.c. > Yeah, I've noticed the new functionality, it will be added to LWJGL in the next maintenance pass.\nSweet! Thanks!\n\nI can change it to double precision if that's what users want.\n\nOh not at all, I am fine with single precision. At least my project is for game stuff so best performance by default sounds like the better option. I was just curious about how it worked.\nI don't know if there are that many \"simulation\" oriented users that would want double precision in this case. At least in games I think all big engines out there use single precision. At worst they just implement workarounds to preserve the lower memory usage and single precision performance, much like renderer people do by using linear/log depth to keep their depth buffer under 32 bits.  \n\nBut then there's also the question about multi-threading (BULLET2_MULTITHREADING\n\nAh that's true. It sucks that it's a compile time thing. IMHO I'd leave it single threaded (or whatever is the default), whoever needs the multi threaded performance probably knows how to do their custom build to suit their needs.\nSo in short, as it is it's perfect for my needs.. > With that said, I would avoid a StringBuilder and a UTF-8 encoding loop altogether. Why pay the encoding overhead every frame?\nOne step at a time :smile: I'll see about optimizing it like you suggested once I have it working.\nAnyway, yeah, it makes sense, I'll just use a CharSequence implementation. Thanks for the feedback! .. > Unfortunately java.lang.invoke.VarHandle is not a full replacement for sun.misc.Unsafe. The first problem is worse performance when accessing off-heap memory. The second is that the security mechanisms in VarHandle won't let you access private class details. \nAhh that sucks. Well at least with the 6 month release cycle we might get Panama sooner, I hope.\n\nThe other Java 9 feature in LWJGL is multi-release JAR files. The core library is such a JAR and it includes custom code that uses the new StackWalker API to improve performance when MemoryStack debugging is enabled.\n\nMulti-release JARs are pretty cool, I didn't know about them. On the other hand, StackWalker API was long overdue. Makes no sense hoping the JIT works it's magic when you only want to traverse a single stack level to find the calling method name rather than printing the whole stack trace.\nThanks for your answer! Do we close this then? Or leave it open for any other Java 9 questions people might have?. > Read the usage sections and have a look at the code examples (in nuklear.h).\nAttach nuklear.h to your project and inspect the code when you're having trouble. Most functions are very simple and you can easily figure out if you're doing something wrong.\nYup that's exactly what I have been doing and as I mentioned, comments just stop happening 1/4 into the sources and after that it's just a stream of not terribly intuitive code where each function depends on an unknown function that has to be called before to use it.\n\nPlay with the native demos.\n\nYeah, I'll do that first. It involves half of what I'd have to do to get a debugger going (ie, setting up the environment to compile the lib) so I might as well just try that first. Hopefully since it's a single header lib that ought to simplify things.\nDo you compile https://github.com/LWJGL/lwjgl3/blob/master/modules/core/src/main/c/nuklear/nuklear.h as-is or are there any defines set anywhere else? There are tons of things that can be #ifdef'd inside Nuklear and I'm not sure which ones LWJGL uses in particular, if any.\n\nUse either java.library.path or org.lwjgl.librarypath to point to the folder containing the debug binary and make sure the bundled binary isn't in the classpath\n\nSweet, I'll use that then.. Ah, LMDB doesn't seems to have a pure in-memory mode. Hm, this puts a dent on what I was trying to accomplish.\nI wanted to have read only LMDB files storing base game data and mods, and an in-memory representation of all of them combined. Then later write out \"diffs\" of what the player does as the would-be game save files.\nSay, base game defines an apple on the counter. A mod modifies the apple's value. And a save game file modifies it's position (because the player moved it).\nEDIT: This looks pretty interesting: UnQLite. Made in ANSI C, works in a similar way but it allows you to make it persistent or in-memory, and it says the stored data is platform independent. Can't find benchmarks for it though.. Cool, the VL32 flag would work, it isn't much different from what LWJGL does when mapping all pointers to long, regardless of \"bitness\". The use case I was thinking on is using it as backend for storing game data and game save files. Having in mind the case where a player wants to copy save game files across systems, or like what Obsidian does with Tyranny, request the player's save game to reproduce the bug they're having.\nAs for the in-memory part, I saw that before and from what I googled around, it might have issues:\nhttps://stackoverflow.com/questions/36170778/in-memory-databases-with-lmdb\nFor instance, SO people say that the OS can have a max amount of dirty pages before they get commited to disk regardless of how LMDB was setup, moreover, such mechanism varies by OS.\nI also looked at this a while ago MVStore, made in Java and from H2 people, but the internals looked... icky, specially the crazyness of how it deals with serializing fields (some weird recursive calling of type handlers).. Wouldn't it be simpler just to straight use a normally persisted DB for the save file in that case? I'd gain nothing from having two DBs if the idea is to serialize it anyway.\nIn any case, the thing is that I needed an in-memory version but not for the save file, but for the merging of base game data and mods. Save game stuff goes into another instance, which would work like a diff rather than an intersection of the game data.\n\nRead-only file-backed: Game data, mods.\nIn-memory: Intersection between game data and mods. This one is constructed at runtime based on mod load order and never serialized.\nRead-write file-backed: Game save file with \"diffs\" between the composed in-memory db and what the player does.\n\nProcess would work like: Reading game data, overwrite/add entries with mod data, and start recording changes from the playthrough into a separate db, which gets to a file when the player saves the game.\nGame would be continuously recording what the differences are, since LMDB would be mapping that data to a file, then when the player saves I'd copy the db into another file backed db, close the first one (player's game save file) and keep recording in the new one.\nIn any case, I'll check this one first OpenHFT - ChronicleMap Makes some good promises, specially the low allocations part.\nIf that doesn't flies, I'll try that workaround for LMDB or another Java library.\nEDIT: Nvm, lib is LGPL. F**k me.\nThanks for your input! Do I close the issue? Will next LWJGL builds have the VL32 define?\n  . Cool, thanks!. > I can reproduce this, but I don't see anything wrong with the bindings.\nWell that's something at least :smile: \n\nIf you change var ptr = mem.mallocPointer( 1 ); to callocPointer, you'll get a NPE in the ptr.getDoubleBuffer call, instead of a crash.\n\nRight! Good idea.\n\nNope, sorry, I don't have any experience with Bullet. Before asking upstream, you could try reproducing the issue in C.\n\nAnd I have no experience with C :smile: I can read C code just fine, but setting up a build environment is a different thing. I'll submit the issue to them, hopefully the Java code will be enough, otherwise I'll research how to do it in C and try again. Thanks!. I'm an idiot, I forgot that (even in normal C++ Bullet) you have to create collision shapes first, then add them to a rigid body, and then you can do position/orientation stuff with them -_- So I'll probably have to go and use b3CreateMultiBody* functions for this, make a body, and then request the stuff. . > There is a Java port of it but it uses 64 bit floats everywhere and the first issue you see in the repo is an unresolved high garbage creation complaint from 2015, both of them bad signs.\nI do mind.. > it will add bunch of dependencies though ;)\nYeah, trading libGDX for jMonkeyInterop is a side step for me, maybe a step back since jme is even bigger.\nIn any case, I think this is an issue better suited for a native lib rather than a Java solution, the question is which one.\nI didn't know there were other physics engines with a C API, for some reason I thought the other physics engines were C++ only like Bullet was. So I suggested Bullet's C API to Spasi as soon as I found it existed out of ignorance mostly, didn't know about Newton Engine's .\nMy line of thinking was \"Hey, I used Bullet before and it was really straightforward and easy to integrate, its C API cant be that much different!\". I was wrong.. Well I cloned Newton's repo and LWJGL's repo since this is a good moment as any to try learn how to make a new binding with it (not that I have the expectation of getting something usable out of my attempt).\nFrom what I've read in https://github.com/LWJGL/lwjgl3/tree/master/doc what I ought to do, since I've followed the setup steps and everything seems to work, is just grab this header file, create a newton.kt and NewtonTypes.kt file, grab a cup of coffee and start typing the data type definitions, and the function definitions?\nFor the function definitions a chunk of the work could be done with some clever find+replace, but for the data type definitions it seems it's just a lot of typing.. That is awesome, dude! Really, really cool.\nSadly now you solved the part I thought I understood better, and now I have to actually try to compile the thing :smile: . I agree. I do think that LWJGL should offer a physics engine binding, since at least for game development it'd leave LWJGL more rounded. I just don't think Bullet's C API is the one.. Any updates on the template generator tool magic thingy?\nI gave a quick jab at making that gist working. It's missing a couple things. For example, the definition of the type 'long_long' (which I believe it'd just map like an int64_t), also _Bool, \nand after all the types were defined, it was missing the initial section that goes something like:\nkotlin\nval Newton = \"Nuklear\".nativeClass(Module.NEWTON, prefix = \"\", prefixMethod = \"\", library = \"lwjgl_newton\") {\n// yadda yadda\n}\nAnd I'm getting an NPE while ant generate'ing NewtonUserMeshCollisionRayHitCallback that I don't understand because I have zero clue about Kotlin :smile:  \nProbably there is more stuff I haven't reached yet.. Ah cool, then I already had it and didn't notice it :smile: Thanks!. To try out the tool, it seems I have to compile first LLVM bindings. So I try to do that with just enabling LLVM in build-bindings.xml, then doing 'ant compile-templates' but I'm having issues.\nFirst there is this:\nhttps://github.com/LWJGL/lwjgl3/blob/master/modules/lwjgl/llvm/src/templates/kotlin/llvm/templates/ClangIndex.kt#L3059\nlong_long seems to be missing from the type definitions:\nhttps://github.com/LWJGL/lwjgl3/blob/master/modules/generator/src/main/kotlin/org/lwjgl/generator/GlobalTypes.kt\nI add it like:\nkotlin\nval long_long = IntegerType(\"long long\", PrimitiveMapping.LONG)\nAnd if I try to compile again, I get an \"overload resolution ambiguity\" error on those long_long returning functions.\nEDIT: Nevermind, I mixed up with the old 'long_long' I had added for Newton, turns out LLVM's bindings had its own long_long defined which clashed with the global one I added.. I can launch the tool, but once I add Newton's folders and headers, I get this exception:\njava.lang.NoClassDefFoundError: Could not initialize class org.lwjgl.llvm.ClangIndex$Functions\n    at org.lwjgl.llvm.ClangIndex.clang_createIndex(ClangIndex.java:2706)\n    at org.lwjgl.extract.ExtractionContext.<init>(Extract.kt:60)\n    at org.lwjgl.extract.ExtractKt.parse(Extract.kt:174)\nIt's like ClangIndex is there, but the inner Functions class isn't.\nEDIT: Yeah I really don't get it, inspecting the generated ClangIndex.class and ClangIndex$Functions.class, they're there. No idea why the tool can't find it.\nEDIT2: Tried re-compiling and and running everything in both Java 8 and Java 11, still having the same issue. \nEDIT3: I can't for the life of me make IDEA debug the ant process. I use the debug configuration \"GENERATOR\" but it wont stop at any breakpoint on the Kotlin code.. I'm not entirely sure why but I fired up IntelliJ today and it started generating like half of the JNI.java class, a lot of \"invokeXYZ\" functions were missing. I just reverted it to the repo's version since that had everything but I have no clue what went wrong.\nIn any case: \n\nProbably because this launches the Generator via Ant in a forked JVM process\n\nYou're right, changed the fork to false and breakpoints started working.\n\nIs there any useful output?\n\nIt launches normally but there isn't any additional output. I mean, it launches in a separate process like you said at first, so there is no debug output (or any output) from the terminal where I launch it. \nIf I prevent the 'extract' tool to be forked with the flags, I can no longer pass the required arguments to the process (like clang's path). They seem to be getting ignored. \nI mean, if I launch with the debugger from IntelliJ like:\nant extract\nIt complains that Dclang wasn't passed, if I pass it like:\nant extract -Dclang=path\nIt complains  \"-Dorg.lwjgl.llvm.clang.libname=path\" wasn't passed. If I pass that like:\nant extract -Dclang=path -Dorg.lwjgl.llvm.clang.libname=path\n// or\nant extract -Dclang=path -Djvmargs=\"-Dorg.lwjgl.llvm.clang.libname=path\"\nIt also gets ignored, it doesn't seems to reach the Configuration class.\nI also tried setting it directly from the build.xml file like\n<jvmarg value=\"-Dorg.lwjgl.llvm.clang.libname=path\"/>\nBut it's still null in the program when I put a breakpoint in main.\nI'm guessing the debug flags are getting ignored too.\n. All right. Managed  to get the debugger working via adding a bunch of flags to the extract tool in build.xml (Xdebug, debugging agent and friends) then attaching IntelliJ's debugger after the ant task forked the process and adding an exception breakpoint.\nWith that I managed  to inspect the inner exceptions on a \"ExceptionInitializerError\" that occurred the first time (after that the JVM just throws the NoClassDefFoundError exception if you try to extract the definitions again).\nTurns out the message is:\nA required function is missing: clang_Type_getObjCObjectBaseType\n... But Google knows nothing about \"getObjCObjectBaseType\"\nIn any case, my libclang version is 7.0.1-1, from Debian's \"testing\" repositories, is that recent enough? Or am I pointing to the wrong .so?\nant extract -Dclang=/usr/lib/llvm-7/lib/libclang.so.1 \nEDIT: Turns out 'experimental' repositories have libclang 8, so I used that instead and now ClangIndex gets initialized correctly, but I am getting an UnsatisfiedLinkError on JNI.invokeP when ClangIndex.clang_createIndex gets called. I'm not understanding if it means there is some clang stuff missing, or if the native core of LWJGL isn't getting loaded.\nEDIT2: Well turns out that even the native part of the JNI.java class got halfway generated so it was also missing a bunch of invokeXYZ functions, that's why invokeP threw an unsatisfied link error. So I recompiled that, with the complete .c file, and now my grand error message is:\n\u043e&\ufffd>\u007f\nYour tool hates me, Spasi.. What version of clang are you using?\nEDIT: \n\nWhen some bindings are disabled, the set usually becomes smaller, so that's what's happening.\n\nSo I only had LLVM/Clang bindings enabled, but the generated JNI.java class (and its native counterpart) didn't have invokeP and others in it, which is used by the LLVM/Clang bindings. Is that ok?\n\nAnyway, you can run the tool from within IntelliJ with the Template Extraction Tool\n\nGeezus you're right, why didn't I see it before. That launches the tool fine, if I point to Clang 7 I get the initialization error, if I point to Clang 8 I get a segfault so the debugger ain't much help there.\nFirst segfault was in some deep Swing code, second was in a native stack frame I think. So it looks like a memory corruption thingy. Kinda weird.\nWhat I do is:\n1. Launch it from IntelliJ pointing to libclang 8.\n2. Add dNewton, dgNewton and dgCore to the include paths.\n3. Add dgNewton/Newton.h as the main header.\n4. Click extract.\nAm I doing something wrong?\nEDIT2:\nEven if I cant use the generator, I can try with the gist you posted earlier. So far I'm stuck on the generate part. First thing I noticed was that the order of declaration was important in the type definitions. I was getting NPEs on the callbacks since those used structs that were defined later in the file. \nOnce I got that sorted out I started to get \"Data pointer not validated\" exceptions on a few of the functions like:\nhttps://gist.github.com/Spasi/0d064d5382ab2e037d04eca42aefa459#file-newton-kt-L1054\nhttps://gist.github.com/Spasi/0d064d5382ab2e037d04eca42aefa459#file-newton-kt-L1062\nWhat does it means? I can just add \"Unsafe..\" to them but I'm not sure what is it doing, what kind of validation is it expecting? Like a length/size parameter?. >Please attach a crash dump, it might be helpful.\nhs_err_pid10248.log\nFor some reason I get a segfault if I launch it from IDEA. If I launch it from a terminal, then attach the debugger, I get garbled console output in the tool. This is testing with libllvm 8.\n\nI'm using version 8, built from source (~Oct 27), on Windows.\n\nI'm using libllvm 8 from revision 350193 in their SVN repo, which is ~700 commits behind current master (350916), it's what Debian 'experimental' repos have. The 'testing' repos have libllvm 7.0.1\n\nI have updated the gist above to the latest Newton.h\nI'll do some testing on Linux. I'll also try to make 8.0 functions optional, so that the tool can run on a stable 7 build.\n\nAwesome, thanks!\n\nYes, this might happen, the tool outputs callbacks before structs. I can probably change this so that the header order is respected.\n\nYeah I think that'd be good.\n\nAdding appropriate modifiers to pointer parameters is the most important part of creating LWJGL bindings [...] You must carefully examine the documentation/implementation of each function \n\nAh so you're saying I should know what I am doing, any more unreasonable requests? :smile: \nI have one question, when you do the 'nativeClass' extension method, the \"prefixMethod\" is the string that every method will be prefixed with (\"Newton\" in this case), but what is the plain \"prefix\"? Is it for constants?. I found this thing with the generator, look at this callback:\nc\n    typedef dLong (*NewtonGetTimeInMicrosencondsCallback) ();\nSeems fine, no args and returns a long.\nNow the generated template for this is:\nkotlin\nval NewtonGetTimeInMicrosencondsCallback = Module.NEWTON.callback {\n    long_long(\n        \"NewtonGetTimeInMicrosencondsCallback\",\n        \"\",\n        void()\n    ) {\n        documentation = \"Instances of this interface may be passed to the #FIXME() method.\"\n    }\n}\nWhich generates a callback with a void argument. Legal in C, not so legal in Java.\nThis has the problem that when you ask it to generate the .java files, it does this:\njava\n        @Override\n        public long invoke(void *) {\n            return delegate.invoke(*);\n        }\nWhich is invalid. The C code seems fine so I'm guessing this is something the template generator has to transform? Or the template processor should not add an argument if it's void?\nEDIT:\nGoing a bit further, it seems the tool also confuses multi dimensional arrays. There are a couple fields in Newton's C code that are like:\nc\ndFloat m_offsetMatrix[4][4]\nWith the tool seemingly generating:\nkotlin\nfloat.p(\"m_offsetMatrix\", \"\")[4]\nWhich causes issues later on on .java code generation, since it tries to pass a FloatBuffer to a function that doesn't accepts one when generating the accessor for that field.\nI fixed it with\nkotlin\nfloat(\"m_offsetMatrix\", \"\")[16]\nEDIT2:\nWell I wanted to try out just generating bindings for one of Newton's C examples, so far I got the types and I'd need to generate bindings for a couple functions only.\nI got NewtonTypes.kt working, so I wanted to try out the native compilation step before making the few function bindings in Newton.kt. \nI'm not understanding the build process, is it trying to download compiled artifacts from your  build server? I'm getting exceptions like:\nCan't get https://build.lwjgl.org/nightly/linux/x64/newton/libdVehicle.a to /home/user/git/lwjgl3/bin/libs/linux/x64/newton/libdVehicle.a\nEDIT4:\nI think I understand, I copied the build section from Bullet, and that one has a bunch of  sections.\nxml\n<!-- NEWTON -->\n<build module=\"newton\" simple=\"true\" linker=\"g++\" if:true=\"${binding.newton}\">\n    <beforeLink>\n        <mkdir dir=\"${lib}/${platform}/${build.arch}/newton\"/>\n        <parallel threadsPerProcessor=\"2\" failonany=\"true\" unless:set=\"lib-uptodate\">\n            <update-dependency name=\"Newton01\" artifact=\"${build.arch}/newton/libdMath.a\"/>\n            <update-dependency name=\"Newton02\" artifact=\"${build.arch}/newton/libdgCore.a\"/>\n            <update-dependency name=\"Newton03\" artifact=\"${build.arch}/newton/libdScene.a\"/>\n            <update-dependency name=\"Newton04\" artifact=\"${build.arch}/newton/libnewton.a\"/>\n            <update-dependency name=\"Newton05\" artifact=\"${build.arch}/newton/libdNewton.a\"/>\n            <update-dependency name=\"Newton06\" artifact=\"${build.arch}/newton/libdVehicle.a\"/>\n            <update-dependency name=\"Newton07\" artifact=\"${build.arch}/newton/libdgPhysics.a\"/>\n            <update-dependency name=\"Newton08\" artifact=\"${build.arch}/newton/libdAnimation.a\"/>\n            <update-dependency name=\"Newton09\" artifact=\"${build.arch}/newton/libdContainers.a\"/>\n            <update-dependency name=\"Newton10\" artifact=\"${build.arch}/newton/libdCustomJoints.a\"/>\n            <update-dependency name=\"Newton11\" artifact=\"${build.arch}/newton/libtinyxml.a\"/>\n        </parallel>\n    </beforeLink>\n    <link>\n        <arg value=\"-ldl\"/>\n        <arg value=\"-L${lib}/${platform}/${build.arch}/newton\"/>\n        <arg value=\"-lNewton01\"/>\n        <arg value=\"-lNewton02\"/>\n        <arg value=\"-lNewton03\"/>\n        <arg value=\"-lNewton04\"/>\n        <arg value=\"-lNewton05\"/>\n        <arg value=\"-lNewton06\"/>\n        <arg value=\"-lNewton07\"/>\n        <arg value=\"-lNewton08\"/>\n        <arg value=\"-lNewton09\"/>\n        <arg value=\"-lNewton10\"/>\n        <arg value=\"-lNewton11\"/>\n    </link>\n</build>\nI'm guessing those kind of libraries are the ones you don't commit to the repo because they're too big, so you make it download the artifacts from a build server, right?. >  This must be the first time it's occurred on a callback though. \nLiterally uncharted lands :smile: \n\nWe should use Newton as a shared library if possible.\n\nYeah it has a shared library flag and everything. But now I'm wondering, it looks like it wont be possible to build it with just the  script, it has a bunch of CMakeLists.txt inside defining each a separate module, this means I'd have to pull all .so files from somewhere in my local file system for now.\nHow do I do that? <update-dependency> tries to fetch it from your build server.\nAlso I'm not understanding if LWJGL supports loading multiple .so/.dll for a single library, or if it expects everything to be packaged into a single dependency. Which one is it?\nEDIT:\nI just found out that you can make a single .so out of multiple .a with GCC, by simply sitting on the output folder and doing:\ngcc -shared -o newton.so -Wl,--whole-archive libdAnimation.a libdContainers.a libdCustomJoints.a libdgCore.a libdgPhysics.a libdMath.a libdNewton.a libdScene.a libdVehicle.a libnewton.a libtinyxml.a -Wl,--no-whole-archive\nI had read it before but I didn't understood what it was until Newton guy pointed it out to me. I'm not entirely sure if there is any drawback in using it that way instead of going and editing the ~10 CMakeLists.txt in Newton so it outputs a single .so, maybe some optimizations are lost in the way since it works with pre-compiled code? No idea honestly. \nEDIT2:\nWell I think I managed to compile something, I mean, a 1.2MB liblwjgl_newton.so file at least. I ended up with this build config:\nxml\n<!-- NEWTON -->\n<build module=\"newton\" simple=\"true\" linker=\"g++\" if:true=\"${binding.newton}\">\n    <beforeLink>\n        <mkdir dir=\"${lib}/${platform}/${build.arch}/newton\"/>\n        <copy todir=\"${lib}/${platform}/${build.arch}/newton\" flatten=\"true\">\n            <path>\n                <pathelement path=\"${src.main}/src/build/lib/libdMath.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libdgCore.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libdScene.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libnewton.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libdNewton.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libdVehicle.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libdgPhysics.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libdAnimation.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libdContainers.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libdCustomJoints.a\"/>\n                <pathelement path=\"${src.main}/src/build/lib/libtinyxml.a\"/>\n            </path>\n        </copy>\n    </beforeLink>\n    <link>\n        <arg value=\"-ldl\"/>\n        <arg value=\"-L${lib}/${platform}/${build.arch}/newton\"/>\n        <arg value=\"-ldMath\"/>\n        <arg value=\"-ldgCore\"/>\n        <arg value=\"-ldScene\"/>\n        <arg value=\"-lnewton\"/>\n        <arg value=\"-ldNewton\"/>\n        <arg value=\"-ldVehicle\"/>\n        <arg value=\"-ldgPhysics\"/>\n        <arg value=\"-ldAnimation\"/>\n        <arg value=\"-ldContainers\"/>\n        <arg value=\"-ldCustomJoints\"/>\n        <arg value=\"-ltinyxml\"/>\n    </link>\n</build>\nThat is, cmake && make'ing the library manually, then letting the script copy back the resulting .a, then linking them up all together into a single .so.\nI noticed I wasn't getting any generated C file and I didn't realize that the libraries have a \"nativeDirective\" call in the template to include the required header files. So I copied Newton.h into the main/c folder, fixed two warnings, and compiled all the types plus just two random functions (WorldGetVersion and something else) to try it out.\nNow, given that I have a lwjgl_newton.so, and a bunch of .class files, how do I package all of this up?  . So I found the release target while searching for binding.bullet but it fails with:\n[module-info-gen] core: OK\n[module-info-gen] core.natives: OK\n[module-info-gen] nuklear: FAILED\n[module-info-gen] compiler.err.package.empty.or.not.found\n[module-info-gen] ERROR\n[module-info-gen] 180\n[module-info-gen] 171\n[module-info-gen] 187\n[module-info-gen] org.lwjgl.generator.util.ModuleInfoGen$1MemoryJavaFileObject[file:///home/user/git/lwjgl3/modules/lwjgl/nuklear/src/main/java/module-info.java]\n[module-info-gen] package is empty or does not exist: org.lwjgl.newton\nThe only binding I (think) have enabled is Newton. I dont understand why it says \"nuklear: FAILED\", it isn't even compiled.\nI have no clue why it says the \"package is empty or does not exist\" either. The Newton .class files are generated and with that exact package... Although I don't see a module-info.class in the Newton folder inside bin now that I think of it. I added it in newton/src/resources/module-java.info though.\nI was launching the ant generate/compile/etc tasks with Java 8 as JAVA_HOME, should I have used Java 11?. All right, I've made a fork with the stuff I changed.\nhttps://github.com/dustContributor/lwjgl3\nI omitted the generated stuff, Newton's source code and some IDEA files.\nThe Newton revision I'm trying is:\nhttps://github.com/MADEAPPS/newton-dynamics/tree/4b82923fd3172c4ddbccc3dfe2ed68b5652d8376\nThis was after the author saw some GCC incompatibility that I stumbled upon trying to compile it, he fixed it in that commit.\nNewton's source was placed in modules/lwjgl/newton/src/main/c/ like the other bindings. It's CMake lists config was:\noption(\"NEWTON_BUILD_SANDBOX_DEMOS\" \"generates demos projects\" OFF)\noption(\"NEWTON_BUILD_PROFILER\" \"build profiler\" OFF)\noption(\"NEWTON_BUILD_MULTI_THREADED\" \"multi threaded\" ON)\noption(\"NEWTON_DOUBLE_PRECISION\" \"Generate double precision\" OFF)\noption(\"NEWTON_STATIC_RUNTIME_LIBRARIES\" \"use windows static libraries\" OFF)\noption(\"NEWTON_WITH_SSE_PLUGIN\" \"adding asse parallel solver\" OFF)\noption(\"NEWTON_WITH_SSE4_PLUGIN\" \"adding avx parallel solver\" OFF)\noption(\"NEWTON_WITH_AVX_PLUGIN\" \"adding avx parallel solver\" ON)\noption(\"NEWTON_WITH_AVX2_PLUGIN\" \"adding avx parallel solver\" OFF)\noption(\"NEWTON_WITH_DX12_PLUGIN\" \"adding direct compute 12 parallel solver\" OFF)\noption(\"NEWTON_BUILD_SHARED_LIBS\" \"Build shared library\" OFF)\nI built it manually from the console and had that build step in linux/build.xml copy back the .a files and link them together.\nI also copied Newton.h into modules/lwjgl/newton/src/main/c/ so the #include Newton.h would work on the generated C code.\nAs you can see the .kt files have a lot of stuff commented out because I wanted to just try to see if I could get a few functions working and the structures.\nAlso my build-bindings.xml file has everything disabled but newton bindings.\nThat's about it. Give me a heads up if you need anything else.. Thank you Spasi, I'm on it.\nReceiving objects:  24% (1885/7828), 284.00 KiB | 11.00 KiB/s\n... albeit slowly :smile:\n\nuploaded Linux & Win64 static libraries for Newton to build.lwjgl.org [...] Use LWJGL_BUILD_OFFLINE=true if you'd like to replace them with a newer build.\n\nNo problem, If I can get my thingy to be able to push boxes around again I'll be happy. Besides it seems Julio is coding away some crazy inverse kinematics stuff currently, dunno when he will make a stable(ish) release.\nI have one question, in the patch you have:\nxml\n<build simple=\"true\" module=\"nuklear\" if:true=\"${binding.nuklear}\">\nWas that the reason it was trying to build Nuklear regardless of the configuration? I thought I had deleted the 'if:true' check by mistake or something but I see the flag check isn't in master either.. > I think the issue was in Newton's module-info.java, the module name was wrong (module org.lwjgl.nuklear).\nAh duh, I didn't notice it. Yeah probably it was that.\n\ndon't bother with ant release\n\nHmm... So what do I use to package the module into a .jar then? Besides doing it myself by stuffing a .zip file I mean.. Great! In this case since you set it up I was going to use your uploaded natives.\n... But I'm having issues with them:\n[get] Error opening connection java.io.IOException: Server returned HTTP response code: 403 for URL: https://build.lwjgl.org/nightly/linux/x64/liblwjgl_newton.so\nSince it returns access denied on everything (ie, can't navigate it like an FTP directory) I'm not sure if they're missing or what exactly is happening.. You're right, I misunderstood your instructions, it worked like you said. I managed to get all the lwjgl-newton*.jar files.\nNow I should be able to setup some test code... . java\npublic static final void main ( final String[] args ) {\n  System.out.println( Newton.NewtonWorldGetVersion() );\n  System.out.println( Newton.NewtonGetMemoryUsed() );\n}\n314\n0\nWooo! Hopefully the next two functions wont take me 3 months and asking you what do I do 40 times :smile: . I have a question about opaque pointers, of which Newton makes heavy use of for its C bindings.\nWhen you have a pair pf functions like:\nkotlin\n    NewtonWorld.p(\n        \"Create\",\n        \"\",\n        void()\n    )\n    void(\n        \"Destroy\",\n        \"\",\n        NewtonWorld.const.p.const(\"newtonWorld\", \"\")\n    ) \nWhile NewtonWorld's definition being:\nkotlin\nval NewtonWorld = \"NewtonWorld\".opaque\nLWJGL essentially treats it as a void*, since makes it so it returns a long, and methods that accept NewtonWorld instances just accept a long.\njava\n    @NativeType(\"NewtonWorld *\")\n    public static native long NewtonCreate();\n    public static void NewtonDestroy(@NativeType(\"NewtonWorld const * const\") long newtonWorld)\nIs there a difference between using SomeType.opaque and just using void.p?\nSince it doesn't seems to generate a NewtonWorld class for the opaque pointer, looks like type safety is lost along the way. ie, NewtonCreate just returns a long, and NewtonDestroy(long) just receives a long in Java side, instead of returning and accepting a NewtonWorld instance respectively. \nIs this done on purpose? Or am I doing something wrong? \nOn a different issue, this function here:\n```kotlin\n    void(\n        \"SetMemorySystem\",\n        \"\",\n    NewtonAllocMemory(\"malloc\", \"\"),\n    NewtonFreeMemory(\"free\", \"\")\n)\n\n```\nWhere NewtonAllocMemory is a callback that receives an int parameter and returns a void, and NewtonFreeMemory is a callback that receives a void and returns nothing.\nI'm getting this bit of native code generated for it in the first line:\nc\nvoid * (*) (int) malloc = (void * (*) (int))(intptr_t)mallocAddress;\nWhich I think it's trying to cast the address to the callback/function pointer type, but my compiler (GCC 8.2) complains:\nvoid * (*) (int) malloc = (void * (*) (int))(intptr_t)mallocAddress;\n         ^ \nerror: expected identifier or \u2018(\u2019 before \u2018)\u2019 token\nI'm unfamiliar with C so I don't outright understand if the syntax is really okay or not.\nEDIT1:\nDisregard what I said, it happens the same on a callback that doesn't returns void*, C glue code wont compile:\nc\n// Callback definition\ntypedef void (*NewtonApplyForceAndTorque) (const NewtonBody* const body, dFloat timestep, int threadIndex);\n// Function that uses it\nNEWTON_API void  NewtonBodySetForceAndTorqueCallback (const NewtonBody* const body, NewtonApplyForceAndTorque callback);\n// Generated C code that doesn't compiles\nJNIEXPORT void JNICALL JavaCritical_org_lwjgl_newton_Newton_nNewtonBodySetForceAndTorqueCallback(jlong bodyAddress, jlong callbackAddress) {\n    NewtonBody const * const body = (NewtonBody const * const)(intptr_t)bodyAddress;\n    void (*) (NewtonBody const * const, float, int) callback = (void (*) (NewtonBody const * const, float, int))(intptr_t)callbackAddress;\n    NewtonBodySetForceAndTorqueCallback(body, callback);\n}\nKotlin code:\n```kotlin\nval NewtonApplyForceAndTorque = Module.NEWTON.callback {\n    void(\n        \"NewtonApplyForceAndTorque\",\n        \"\",\n        NewtonBody.const.p.const(\"body\", \"\"),\n        float(\"timestep\", \"\"),\n        int(\"threadIndex\", \"\")\n    ) {\n        // documentation = \"Instances of this interface may be passed to the #FIXME() method.\"\n    }\n    void(\n        \"BodySetForceAndTorqueCallback\",\n        \"\",\n    NewtonBody.const.p.const(\"body\", \"\"),\n    NewtonApplyForceAndTorque(\"callback\", \"\")\n)\n\n}\n```. > Yes, they're mapped differently in the Java API.\nRight, forgot void.p is mapped to a XYZBuffer, which doesn't makes sense for an opaque pointer.\n\nThat's correct, handles are not type-safe in LWJGL. This is a trade-off that favors performance\n\nYeah I imagined it to be the case.\n\nThis is all going to change in LWJGL 4 of course, handles will become value types (see Project Valhalla), which are type-safe and zero-overhead.\n\nAnd coming in like 2021 with a lot of luck :smile: I don't know about struct passing but it seems GraalVM doesn't uses JNI for its native interop. I wonder if they'll test drive a JNI 2.0 with that.\n\nThe callback definitions are missing native typedefs. I've fixed the template extraction tool to emit them and updated the Newton gist\n\nCool, thanks! Although...\nI botched my merge of those changes :sob: :sob: :sob: I had a conflict, apparently I messed up the resolution, and now I'm missing commits all the while git says everything is up to date... I think I'll fork again :pensive:  . All right, re-made my fork and updated with the latest changes. Now, of course, I'm hitting another error:\n[Generator] Caused by: java.lang.IllegalStateException: Failed to resolve link: #FIXME() in NewtonWorldDestructorCallback\n[Generator]     at org.lwjgl.generator.GeneratorTarget$processDocumentation$1.invoke(GeneratorTarget.kt:254)\nThe error makes sense, because it isn't a valid javadoc link, but I am not entirely sure why it didn't pop up before since I never touched the \"FIXME\" links. \nI'm checking the history of GeneratorTarget.kt and CallbackFunction.kt but I don't see any recent changes that would have changed this behavior.\nEDIT: I just replaced all #FIXME() with whatever else so it doesn't tries to resolve them as javadoc links for now.\nEDIT2: Wohoo, made this tiny example work in Java.\njava\npublic static final void main ( final String[] args ) {\n    var world = Newton.NewtonCreate();\n    long body;\n    var force = new Vector3f( 0, 1, 0 ).get( MemoryUtil.memCallocFloat( 3 ) );\n    try ( var mem = MemoryStack.stackPush() ) {\n        var mat = new Matrix4f().identity().get( mem.mallocFloat( 16 ) );\n        var empty = mem.callocFloat( 16 );\n        var coll = Newton.NewtonCreateSphere( world, 1.0f, 0, empty );\n        body = Newton.NewtonCreateDynamicBody( world, coll, mat );\n        Newton.NewtonBodySetMassMatrix( body, 1.0f, 1, 1, 1 );\n        Newton.NewtonBodySetForceAndTorqueCallback( body, ( bod,tstep,thi ) -> {\n            Newton.NewtonBodySetForce( bod, force );\n        } );\n    }\n    for ( int i = 0; i < 60; i++ ) {\n        Newton.NewtonUpdate( world, 1.0f / 60.0f );\n        if ( (i % 5) == 0 ) {\n            try ( var mem = MemoryStack.stackPush() ) {\n                var bmat = mem.mallocFloat( 16 );\n                Newton.NewtonBodyGetMatrix( body, bmat );\n                System.out.println( new Matrix4f().set( bmat ) );\n            }\n        }\n    }\n    System.out.println( \"used before: \" + Newton.NewtonGetMemoryUsed() );\n    Newton.NewtonDestroyAllBodies( world );\n    Newton.NewtonDestroy( world );\n    System.out.println( \"used after: \" + Newton.NewtonGetMemoryUsed() );\n}\nKinda impressed it didn't SIGSEGV immediatly :smile:  \nEDIT4: While this is very good, to be completely honest I skimmed Newton's forums and the author... scares me a little.. >  Most likely, you were hitting errors earlier in the process and never got to generating callbacks before\nYeah, now that you mention it, you're probably right.\n\nMy biggest worry is that there are too many callback types and upcalls are super-slow via JNI \n\nIt's true, but I don't think it can be helped. AFAIK most physics engines do most of their contact/collision/intersection events through callbacks, I don't think Newton is \"special\" in that regard.. You should probably ask in GLFW's repo itself: https://github.com/glfw/glfw. I get what you mean and I particularly dislike demos/showcases/examples that basically do their own little library of utility functions to do stuff so you end up having to do the double work of figuring out the framework and the \"demo framework\" built around the examples (Vert.x I'm looking at you very, very angrily).\nThat being said, I think the idea is that to learn to actually use the library, you go to the library's documentation and examples, not LWJGL's. Since the whole thing about LWJGL is to provide the most thin binding possible so the knowledge about the original library is directly transferable.\nThat's why when people ask \"How do I learn to use LWJGL's OpenGL?\" we direct them to learn to use OpenGL itself, since that's pretty much it (+/- MemoryUtil and friends).\nMoreover, a lot of those demos are direct ports of their original counterparts in each library's repo. So often if you're looking at them and wondering why the weird naming scheme for instance, that's most certainly because it was directly ported from the original library examples.\nAlthough in this case (stb) it seems those examples were coded by Spasi from scratch.. Shouldn't this be reported in GLFW's repo?\nhttps://github.com/glfw/glfw\nIf it's a GLFW issue, there is nothing Spasi can do.. See https://github.com/LWJGL/lwjgl3/issues/428#issuecomment-441650023. ",
    "Portals": "@kenzierocks We could create a enum class which had the int value stored and if necessary, the name of the key. \n. @kenzierocks Any updates?\n. @kenzierocks Do you like the idea? Or should I close the issue?\n. I'm going to wait until someone from the team answers. \n. Is this going to get deleted then? How does input work in LWJGL 3? @Spasi \nI wanted to post here because the LWJGL 3 isn't done yet, and I wanted to give my opinion on the Keyboard class before release.\n. Yeah, stainrya is right. \n. ",
    "jediminer543": "If you are still trying to develop your own class you could use reflection on the GLFW class to create a Map of all keys as a string, integer pair then any you could use strings to reference key positions. I got the idea from the LWJGL 2 keyboard class Line 230. May not be what your after but may help.\n. Yep I just copied the Project class from the util package which has both perspective() and lookat() functions built in (I had to copy code from GLU Util class also). It should work perfectly though as it is just doing fancy matrix code with float buffers then passing it off to OpenGL with glMultiMatrix(). What I am now doing is trying to build a replacement for the mouse and keyboard classes (Mainly mouse as getDX and getDY were the most useful methods for a camera I have found) which is \"fun\". \nBy the way will there be a return of a utility package?\n. Thanks I was wondering how to implement events properly. Also is there a good way of reading mouse wheel?\n. Thanks. Another question, how do I grab the mouse as I thought that this should but it isn't:\nglfwSetInputMode(window, GLFW_CURSOR_DISABLED, GL_TRUE)\nHow do I grab the cursor then?\n. Thanks, apparently I misread the GLFW documentation.\n. Thanks, Apparently I am a moron. However the Char Buffer code was from debugging some other error I managed to create and the size calculation was for me being silly and using an ArrayList instead of a Map. Thanks and sorry for being a moron.\n. > Rendering GUI components inside 3D content (e.g. monitor/panel in 3D space displaying 2D content).\nIs this something that can be done with nuklear?. Thanks, is there some good documentation for nuklear or should I just be looking at the samples?. ",
    "stanirya": "Conversion from GLFW int codes to Java enums is IMHO a higher level abstraction than what LWJGL should support. LWJGL should expose the various APIs like GLFW and OpenGL but abstracting them should either be up to the user or part of a completely optional util package, because it involves a tradeoff of speed vs convenience/API independence, and the game developer must decide for himself whether it makes sense to use the higher level abstraction or the native version.\n. ",
    "futjikato": "I agree with @stanirya \n:-1: \n. ",
    "AGausmann": "+1 @stanirya - LWJGL is meant to provide the lowest-level native bindings possible, as well as some conversions for equivalent Java classes/types where needed (buffers, strings, pointers etc). Having enumerated types mapped to integer values would be considered an abstraction, and that is not LWJGL's primary goal.\n. ",
    "huhlig": "I just submitted a patch for this. Have fun.\n. If you are going to stick with Ant, why not just use ivy. \nhttp://stackoverflow.com/questions/5111831/how-to-publish-3rdparty-artifacts-with-ivy-and-nexus\n. Motion carries? I wish we had a little more firm date. \n. Wait... There are test drivers? Where! I haven't even seen a draft spec so far.\n. Gotcha, Thanks for the clarification. I have been looking for some piece of the spec but not finding anything.\n. Thanks\n. Its already in upstream. See: https://github.com/LWJGL/lwjgl3/issues/50\n. Ok, perhaps we should push this link somewhere findable. :)\nBetter link: https://raw.githubusercontent.com/LWJGL/lwjgl3/master/modules/core/src/test/java/org/lwjgl/demo/vulkan/HelloVulkan.java\nOne thing I noticed. Is the Triangle supposed to have its bottom repeatedly hidden and shown?\n. This seems very out of scope for lwjgl. If included it seems like it should be a separate subproject.\n\nThe Oculus Platform is designed to provide you with the infrastructure you need, so you can focus on creating a great game or experience. The Oculus Platform currently provides the following features:\nFriend Management\u2014to enable social functionality and increase engagement, this enables players to add friends and find friends that are currently online.\nRooms\u2014your app can create rooms where players gather or you can enable players to create them.\nAchievements\u2014you can create trophies, badges, awards, medals, or challenges in your app and Oculus will manage it.\nLeaderboards\u2014if your app or experience is competitive, you can create leaderboards to track the top players.\nMatchmaking\u2014if players can't find a match, you can help them find available games. The platform supports both standard and skill-based pools.\nIn-App Purchases\u2014enables you to monetize your games and experiences.\nPeer-to-Peer Networking\u2014enables players to communicate directly.\n. What value are you looking to derive from SDL2 you cannot get from GLFW?\n. @intrigus Java 7 had its end of life in April of 2015. Also the article you mentioned seems to be specifically indicating server side. Client side I am betting is much much higher, given the nag screens oracle implemented in 7. Since most customers running lwjgl will be desktop users who likely are running whatever latest version is available and NOT have a severely locked down machine. I doubt this will be much of an issue. I do admit that if you're running on a server for OpenCL/Cuda this might be an issue however. I vote for :+1: \n. @Guichaguri Just to note, Plumbr is a server performance monitoring application and its numbers arn't really reflective of the desktop market. \n. \n",
    "Arcnor": "Ok, I'll continue then :).\nYeah, I know it's just a program, but it was strange that the Kotlin code was compiled using a Java tool. I need to look a bit more into it.\nAlso, do you mind if I move the code around? For ease of integration with gradle, it will be nice to have a module per \"unit\", i.e. \"core\" for the core library, \"templates\" for the templates library, and \"natives\" for the native library (or maybe \"natives-linux\", \"natives-macosx\" and \"natives-windows\", I need to check what needs to be generated). That means the code for each module will be inside /src/main/[java|kotlin]\n. Yeah, I can break the convention, although some things like the Kotlin plugin might not like it. Also, it will be way more verbose.\nI'll try to see what I can do.\nAlso, if you change where the generated code goes, IDEA will pick that up automatically and will detect the code as generated. I like that, but this it's your project ;)\n. You can either mark it as generated all the time, or put it on target/generated. Then IDEA will mark it automatically.\nIt doesn't affect much, although if you try to modify a generated class, IDEA will warn you.\n. Ok, an update on this.\nI've managed to compile everything, although hardcoding some paths for now to make it simpler. Also, I managed to do it moving the code around like I said before.\nI'm now trying to convert my code to use your non standard paths. However, it seems that the Kotlin plugin chokes on that, it compiles the Kotlin code fine, except for Types.kt (that depends on Java code, PointBuffer, that's going to be compiled at the same time). When I move everything into src/main/java and src/main/kotlin (it compiles Kotlin and Java code separatedly) everything works again.\nI'm going to continue trying to make it work, but if I can't, will you accept that module (src/templates) being converted to some more standard? I'll also ask on the Kotlin forums in case I'm doing something wrong.\n. Ok, I'll try to use the Templates.ktm file, although so far no luck with that one. Also, what that script is doing can be done with Gradle as well, and using Gradle flavors it will be even more elegant. But I'll try to make it work.\n. Hi,\nSorry, but I don't have anything on the intertubes yet. I got it to compile, more or less, but never got it to use that Templates.ktm file (asked in their forums about the .ktm file, but got no response other than \"use the mechanism native to Gradle: https://devnet.jetbrains.com/message/5527371)\nI really want this to get with some project of mine (or even LibGDX) sooner or later, so if you can help, that'd be great :)\nI'll try uploading what I had as soon as I get the time.\n. @dhild if @kenzierocks doesn't have time to test it, I can also do it after you've submitted what you need to submit.\nAwesome that you got this to work. I stopped at the native libraries compilation for lack of time.\n. I did ./gradlew build and that didn't go well:\n``` bash\n/tmp/lwjgl3@gradle_project\u2717\u2717\u2717\u2717\u2717\u2717% ./gradlew build\n:compileTemplatesKotlin\n:compileTemplatesJava\nwarning: [options] bootstrap class path not set in conjunction with -source 1.6\n1 warning\n:processTemplatesResources UP-TO-DATE\n:templatesClasses\n:compileKotlin\nNo Kotlin files found, skipping Kotlin compiler task\n:generate\nException in thread \"main\" java.lang.IllegalArgumentException: Invalid generation target path: /private/tmp/lwjgl3/generated\n    at org.lwjgl.generator.GeneratorPackage$Generator$4582b1a4$main$validateDirectory$1.invoke(Generator.kt:37)\n    at org.lwjgl.generator.GeneratorPackage$Generator$4582b1a4$main$validateDirectory$1.invoke(Generator.kt)\n    at org.lwjgl.generator.GeneratorPackage$Generator$4582b1a4.main(Generator.kt:41)\n    at org.lwjgl.generator.GeneratorPackage.main(Unknown Source)\n:generate FAILED\nFAILURE: Build failed with an exception.\n\n\nWhat went wrong:\nExecution failed for task ':generate'.\n\nProcess 'command '/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/bin/java'' finished with non-zero exit value 1\n\n\n\nTry:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\n\nBUILD FAILED\nTotal time: 36.119 secs\n```\n. @kenzierocks you can add comments directly to commit lines if you like :smile: \n. @dhild ok, that got me further. Now:\n``` bash\n warnings\n:processResources UP-TO-DATE\n:classes\n:jar\n:compileX64DebugLwjglSharedLibraryLwjglC\nIn file included from /private/tmp/lwjgl3/src/native/system/common_tools.c:5:\nIn file included from /private/tmp/lwjgl3/src/native/system/common_tools.h:26:\n/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/../include/jni.h:45:10: fatal error: 'jni_md.h' file not found\ninclude \"jni_md.h\"\n     ^\n\n1 error generated.\n:compileX64DebugLwjglSharedLibraryLwjglC FAILED\n```\njni_md.h is on /Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/include/darwin/jni_md.h, not sure if you can automate that\n. Ok, commented too quickly. I edited build.gradle and added the include for /darwin, but now:\nbash\n:compileX64DebugLwjglSharedLibraryLwjglC\n/private/tmp/lwjgl3/src/native/system/org_lwjgl_system_MemoryUtil.c:24:19: fatal error: use of undeclared identifier 'intptr_t'\n        return (jobject)(intptr_t)globalRef;\n                         ^\n1 error generated.\n:compileX64DebugLwjglSharedLibraryLwjglC FAILED\n. If I add #include <stdint.h> at the top of the file, I get past that error, so it seems stdint.h is not being included...\n. Ok, found the problem. Your defines inside build.gradle should not include the initial D\n. Next error:\nbash\n:compileX64DebugLwjglSharedLibraryLwjglC\nIn file included from /private/tmp/lwjgl3/generated/native/system/linux/org_lwjgl_system_linux_DynamicLinkLoader.c:7:\n/private/tmp/lwjgl3/src/native/system/linux/LinuxLWJGL.h:8:11: fatal error: 'X11/X.h' file not found\n        #include <X11/X.h>\n                 ^\n1 error generated.\n:compileX64DebugLwjglSharedLibraryLwjglC FAILED\nWhy is this trying to compile Linux is unknown to me :smile: \n. It did. Final one:\nbash\n:compileX64DebugLwjglSharedLibraryLwjglC\n/private/tmp/lwjgl3/generated/native/system/macosx/org_lwjgl_system_macosx_CGL.c:106:15: fatal error: 'CGLCopyContext' is deprecated: first deprecated in OS X 10.8 [-Wdeprecated-declarations]\n        return (jint)CGLCopyContext(src, dst, mask);\n                     ^\n/System/Library/Frameworks/OpenGL.framework/Headers/OpenGL.h:51:17: note: 'CGLCopyContext' has been explicitly marked deprecated here\nextern CGLError CGLCopyContext(CGLContextObj src, CGLContextObj dst, GLbitfield mask) OPENGL_DEPRECATED(10_0, 10_8);\n                ^\n1 error generated.\n:compileX64DebugLwjglSharedLibraryLwjglC FAILED\nI added Wno-deprecated and it worked for now, and then when linking:\nbash\n:linkX64DebugLwjglSharedLibrary\nclang: error: unknown argument: '-framework AppKit'\nclang: error: unknown argument: '-framework CoreVideo'\nclang: error: unknown argument: '-framework IOKit'\nclang: error: unknown argument: '-framework OpenGL'\n:linkX64DebugLwjglSharedLibrary FAILED\n. @dhild problem was in the passing of the arguments.\nIt should be \"-framework\", \"AppKit\" and not \"-framework AppKit\" because that will pass the name of the argument as the whole thing :smile: \n. Next error:\n``` bash\n:updateMacosxX64 UP-TO-DATE\n:linkX64DebugLwjglSharedLibrary\n:x64DebugLwjglSharedLibrary\n:compileX64DebugLwjglStaticLibraryLwjglC\n:createX64DebugLwjglStaticLibrary\n:x64DebugLwjglStaticLibrary\n:compileX64ReleaseLwjglSharedLibraryLwjglC\n:linkX64ReleaseLwjglSharedLibrary\n:x64ReleaseLwjglSharedLibrary\n:compileX64ReleaseLwjglStaticLibraryLwjglC\n:createX64ReleaseLwjglStaticLibrary\n:x64ReleaseLwjglStaticLibrary\n:compileX86DebugLwjglSharedLibraryLwjglC\n:linkX86DebugLwjglSharedLibrary\nFAILURE: Build failed with an exception.\n\n\nWhat went wrong:\nStatic library file /private/tmp/lwjgl3/build/libs/macosx/x86/libglfw3.a does not exist for prebuilt library 'glfw3'.\n\n\nTry:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\n\nBUILD FAILED\n```\n. Yeah, I removed the UNIX stuff before continuing because as Kenzie said,\nOSX is UNIX. I thought you added that on purpose :).\n@Arcnor https://github.com/Arcnor Added the warning, fixed the framework\nstatements. I also pushed up a change in the OS detection, I think that's\nwhy it's trying to do the x86 compile. The original build script only has\nx64 for Mac, so I copied that. It's probably picking that up because of the\nlinux configurations....\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/16#issuecomment-93213974.\n. Ok, after fixing & pushing a few things, now I got to tests failing! I'll try to find out what the problem is, but if anybody has some clue, please comment.\njava\norg.gradle.api.internal.tasks.testing.TestSuiteExecutionException: Could not complete execution for process 'Gradle Test Executor 2'.\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at com.sun.proxy.$Proxy2.stop(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:116)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:360)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: org.testng.TestNGException: \nAn error occurred while instantiating class org.lwjgl.opencl.CLTest: Failed to load the native library: lwjgl\n    at org.testng.internal.ClassHelper.createInstance1(ClassHelper.java:398)\n    at org.testng.internal.ClassHelper.createInstance(ClassHelper.java:299)\n    at org.testng.internal.ClassImpl.getDefaultInstance(ClassImpl.java:115)\n    at org.testng.internal.ClassImpl.getInstances(ClassImpl.java:200)\n    at org.testng.internal.TestNGClassFinder.<init>(TestNGClassFinder.java:120)\n    at org.testng.TestRunner.initMethods(TestRunner.java:409)\n    at org.testng.TestRunner.init(TestRunner.java:235)\n    at org.testng.TestRunner.init(TestRunner.java:205)\n    at org.testng.TestRunner.<init>(TestRunner.java:153)\n    at org.testng.SuiteRunner$DefaultTestRunnerFactory.newTestRunner(SuiteRunner.java:536)\n    at org.testng.SuiteRunner.init(SuiteRunner.java:159)\n    at org.testng.SuiteRunner.<init>(SuiteRunner.java:113)\n    at org.testng.TestNG.createSuiteRunner(TestNG.java:1299)\n    at org.testng.TestNG.createSuiteRunners(TestNG.java:1286)\n    at org.testng.TestNG.runSuitesLocally(TestNG.java:1140)\n    at org.testng.TestNG.run(TestNG.java:1057)\n    at org.gradle.api.internal.tasks.testing.testng.TestNGTestClassProcessor.runTests(TestNGTestClassProcessor.java:136)\n    at org.gradle.api.internal.tasks.testing.testng.TestNGTestClassProcessor.stop(TestNGTestClassProcessor.java:80)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:59)\n    ... 21 more\nCaused by: java.lang.UnsatisfiedLinkError: Failed to load the native library: lwjgl\n    at org.lwjgl.LWJGLUtil.loadLibrarySystem(LWJGLUtil.java:339)\n    at org.lwjgl.Sys$1.run(Sys.java:36)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at org.lwjgl.Sys.<clinit>(Sys.java:33)\n    at org.lwjgl.LWJGLUtil.initialize(LWJGLUtil.java:309)\n    at org.lwjgl.system.MemoryUtil.<clinit>(MemoryUtil.java:36)\n    at org.lwjgl.Pointer.<clinit>(Pointer.java:22)\n    at org.lwjgl.PointerBuffer.<init>(PointerBuffer.java:24)\n    at org.lwjgl.PointerBuffer.allocateDirect(PointerBuffer.java:281)\n    at org.lwjgl.BufferUtils.createPointerBuffer(BufferUtils.java:190)\n    at org.lwjgl.system.libffi.Closure.<clinit>(Closure.java:45)\n    at org.lwjgl.opencl.CLTest.<clinit>(CLTest.java:47)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)\n    at org.testng.internal.ObjectFactoryImpl.newInstance(ObjectFactoryImpl.java:29)\n    at org.testng.internal.ClassHelper.createInstance1(ClassHelper.java:387)\n    ... 39 more\n. Ok, fixed that one but now I'm getting:\n6:49:37.581 [ERROR] [system.err] 2015-04-15 16:49:37.581 java[5884:18423] +[NSUndoManager(NSInternal) _endTopLevelGroupings] is only safe to invoke on the main thread.\n1\n...\n...which clearly indicates that the XstartOnFirstThread flag is not being correctly passed. I think that flag is getting to the wrong process, but not sure how to fix that one.\n. @Spasi if you don't mind changing the layout, @dhild and me can take care of the whole building stuff & doing the porting if you want, even if you don't have the time to learn Gradle, and even for 3.0a.\n. @big-guy even if you were not somebody that useful (that's awesome btw :smile:) no need to ask for permission, all the help we can get is welcome!\n. Yes. Main problem was passing the parameters for OSX to run on the first thread, but fix what you think is wrong :P. Also, not sure if it works after the modules work @Spasi did, but @dhild knows more.\n. That's awesome, congrats for the release.\nAs for your question, you can really put things wherever you want, so putting everything under modules will work perfectly fine. You will just need to reference it by doing modules/myModule and that's it. You can also have multiple build.gradle, so having one inside the modules directory will also be a good idea to keep everything more clean.\nYou can check any LibGDX project for a simple example if you want\n. ",
    "big-guy": "hey @Arcnor, have you done anything with this yet that's available publically?\n. @dhild @Arcnor I'm one of the native support maintainers for Gradle, would you mind if I pitch in a bit?\n. Is https://github.com/dhild/lwjgl3/blob/gradle_project/build.gradle the latest?\n. ",
    "virtuoushub": "Hi @Arcnor , like @big-guy, I am wondering if you have any code for the Gradle build I can take a look at.\n. Thank you for pointing that out @kenzierocks, I fixed it. It now actually prints\n[script] The environment variable JAVA6_HOME has not been set. Using JAVA_HOME (version 1.8).\ninstead of ignoring it like it did in commit 536321fddfff032aa9537fccb2d88fed9f38f367\n. You are welcome. Quick question that is semi related:\nShould I be using Java 6 or 7? Looking at your Travis config for the OS X branch and the Setup Wiki it looks like 7.\nHowever, looking at build.xml it looks like 6.\nI have gotten it to work with 6-8, however using Apple's JDK 6 was a PITA.\n. Understood. I am not worried about it, however if you want me to open a pull request, I did get building the project on OS X using Apple's JDK 6 to work in one of my fork's branches.\n. You are most welcome. Thank you for looking into the linker warning and getting an OS X/JDK 6 build working.\n. My OpenCL knowledge is very limited and I do not fully understand what the failing test is actually meant to test. After a quick investigation, the following evaluates to true in my environment:\njava\n\"NVIDIA CUDA\".equals(clGetPlatformInfoStringUTF8(platform.getPointer(), CL_PLATFORM_NAME)\nI also saw that there is a comment in the code \njava\n// TODO: Intel has broken reference counting atm\nUsing those two pieces of information, I implemented a quick and dirty fix to get the test to pass in my fork.\nIs the issue local to my environment? I updated the original issue to reflect my graphics card model and driver version.\n. Tested w/ commit: 2699070935e3c7aaf032a4670d6e5609826c9dd5\n\"Remove reference count checks from the SubBuffer test\" fixed the failure I was seeing. :+1: \n. @Sylvyrfysh, I had not yet. I just did and now.\njava\nglfwSetErrorCallback((error, description) -> {\n    System.out.println(\"error \" + error);\n    System.out.println(\"description \" + GLFWErrorCallback.getDescription(description));\n});\nResulted in.\nerror 65537\ndescription The GLFW library is not initialized\nI was attempting to call glfwUpdateGamepadMappings before org.lwjgl.glfw.GLFW#glfwInit... :man_facepalming:\nI made sure to call it after and now I am all set.\nThank you for the quick reply.. ",
    "dhild": "@Arcnor I think I figured out the kotlin configuration; I ended up just adding 'config' as a source directory for the templates compile. https://github.com/dhild/lwjgl3/tree/gradle_project if anyone is interested. Currently the java & kotlin files compile (haven't verified that they're functionally identical), and I've started looking at using gradle's native compilation mechanisms. Still a work in progress, but might give @big-guy or @virtuoushub a reference.\n. I've spent a little more time figuring out the native compilation, and got it working on windows. Using entirely the gradle build for compilation, I was able to get the WGLDemo and UniformArrayDemo classes to run.\nStill remaining:\n- Setting up the Linux build (I'll probably do this later)\n- Setting up the Mac build (I can write the script, but I don't have a Mac to test with)\n- Consolidating the existing config (there's a lot of \"if windows ...\" statements, this could be handled better)\n- Extending with a few more tasks, etc. to fully replicate the ant scripts:\n  - Javadoc needs some tweaking\n  - Release task has not been started\n  - demo task (or tasks) could be created\n  - I'm still figuring out exactly how the generated & wiki pieces fit into the build / workflow\nI'll keep updating the fork I made as I progress.\n. @kenzierocks Cool - would you want to tackle adding it into what I have, or would you like me to get it started first?\n. @kenzierocks @Arcnor Sounds great. I've been doing a lot of gradle configuration at work lately so it flows pretty quickly for me. From the gradle docs, not too sure how the Mac config even works; it looks like it uses the Clang configurations, so it could be pretty easy after getting the linux build down.\n. Okay - haven't tried it out on my linux environment yet, but I have an initial configuration for mac & linux uploaded. There was one hiccup in the mac setup, some sort of config relating to the sysroot setting and another related to the version in use. I left those out for the moment, so you might have to manually set them up. I'm betting that gradle does some of that configuration for us, but I'd have to try it out to find out....\nLook for the TODO statement in the build.gradle file to see what I'm talking about.\n. @kenzierocks Whoops. I've always just used the implicit reference to the delegate object though, mostly because I think it reads easier.\n@Arcnor Okay, I'm guessing that the generate failed because that directory didn't exist. I added a quick fix to create the directories first. I'm a little nervous about that because of the symlinks in the original script (don't yet know about those), but it might fix it.\n. @Arcnor That's weird. stdint.h should have intptr_t defined (or at least include its definition). Not sure where to go with that one.\nhttps://github.com/LWJGL/lwjgl3/blob/master/src/native/system/macosx/MacOSXConfig.h#L7\n. @Arcnor Gotcha - copy/paste error, I think\n. Try commenting out https://github.com/dhild/lwjgl3/blob/gradle_project/build.gradle#L278-L279 and see if that fixes it. Might need some more powerful checks there?\nDoing \"gradlew components\" should show the source directories it's picking up.\n. @Arcnor As far as the frameworks go, that's totally out of my league in Mac-know-how.\n. @kenzierocks Good old ant.taskdefs.condition.Os is letting me down!\n. @Arcnor Added the warning, fixed the framework statements. I also pushed up a change in the OS detection, I think that's why it's trying to do the x86 compile. The original build script only has x64 for Mac, so I copied that. It's probably picking that up because of the linux configurations....\n. Nope, totally not intentional. Should have thought about that one a bit more :)\n. I looked around to try to find the correct test configuration, but didn't have much luck.\nIn other news: we might not even need to have the JVM argument to get the Mac display working. I'm totally unsure about how much work that would be though, but here' my thought process:\nLooks like there's a check to ensure that certain code runs on the main thread:\nhttps://github.com/LWJGL/lwjgl3/blob/master/src/core/org/lwjgl/system/macosx/EventLoop.java#L18-L21\nThis method appears to be called only in one place; in the generated code: https://github.com/LWJGL/lwjgl3-generated/blob/master/java/org/lwjgl/glfw/GLFW.java#L427-L430\nA little searching turned up http://stackoverflow.com/questions/12937762/invalid-thread-access-even-with-xstartonfirstthread-in-vm-args, which leads to https://bugs.eclipse.org/bugs/show_bug.cgi?id=303869 (see the very bottom for their solution). Looks like there's some apple-specific classes that can be used to run an arbitrary code block on the main thread, and that it's been used for some other projects successfully.\nNot knowing about what exactly is being started & needs to run on the main thread, I'm a little unsure as to how this would integrate, or if there would be a significant refactor for it.\n. So I pulled down the latest set of changes from upstream, and saw that module support is being started. Awesome! It does make the gradle configuration a great deal more complex though.\nI understand that this project has a custom layout, which has worked so far. That being said, I'm much more in favor of reorganizing the sources according to modules, which would be a good opportunity to move to a conventional layout, e.g. src/main/java, src/main/kotlin, and organizing each module as it's own sub-folder. Test sources specific to a given module could live alongside each module's main source, and a larger, integration test module would also make sense.\nAs @Arcnor said, moving to gradle would help make LWJGL3 easier to use for developers, both internal and external to the project. As far as I can tell, I've been able to duplicate the build functionality from the ant scripts. The only hiccup so far is the mac issue where the tests are not honoring the -XstartOnFirstThread flag, which is a separate (but relevant) issue.\nIn conclusion, the gradle configuration will end up being more complicated than it is worth, unless a source reorganization is acceptable. I could knock this out pretty quick, and I think I'll try just to see what it looks like in the end. Any input from @Spasi would be appreciated here.\n. @Spasi I completely understand limited time. Sounds like @Arcnor and I will keep working on the port in parallel for now. Thanks for the quick response!\n. @Spasi Very cool, release done!\nThe modules subdirectory sounds like a great idea.\nThere was one other idea I'd like to at least throw out for you to consider: splitting the modules along functionality lines, rather than by core, native, util. I tried this out, got it mostly working (just needed some more native build attention): https://github.com/dhild/lwjgl3/tree/source_reorganization\n. ",
    "upsonp": "I know this has been dead for quite some time other than tangentially mentioned from other topics, but...\nHas anyone considered using Kotlin to create the Gradle build script. I was brushing up on my technologies because I'd like to make more use of LWJGL but there are a lot of things I don't understand and I get a lot of errors, which I don't know if they're me, my set up or the LWJGL itself. One of my biggest issues at the moment is just getting through the Ant build on my Windows machine. I had no issues on my personal Linux machine and had a few minutes today so I thought I'd check out my eclipse .classpath update on my work machine #373. Complete failure on the compile-templates over a Java Stack Heap issue.\nI was doing a lot of reading into Gradle, which is what some people in my shop are using and I stumbled on Gradle with Kotlin.  I know Kotlin is being used in LWJGL pretty heavily at the moment and at first I was like, \"Oh great yet another language\", but after spending some time watching conferences and tutorials on it, I'm quite excited. One of the conferences I watched was on how Gradle will be supporting Kotlin (that was in 2016, seems to be a done deal now). I pointed the Devs in my shop doing Gradle builds to it and they seem pretty interested in it as well.\nNot promising I'm going to do it, mainly because I'm new to Kotlin and only vaguely acquainted with Gradle, but I might consider doing more research into and playing around more with it if I/it might be of use somewhere.. From Running Ant Init\nBuildfile: E:\\_JBuilder\\Personal\\lwjgl3\\build.xml\nbindings:\ninit:\ncheck-dependencies:\n  [kotlinc] E:\\_JBuilder\\Personal\\lwjgl3\\bin\\libs\\kotlinc\\build.txt doesn't exist\nupdate-dependencies:\n    [mkdir] Created dir: E:\\_JBuilder\\Personal\\lwjgl3\\bin\\libs\n    [mkdir] Created dir: E:\\_JBuilder\\Personal\\lwjgl3\\bin\\libs\\java\n-lib-download:\n-kotlinc-download:\n  [kotlinc] Getting: https://github.com/JetBrains/kotlin/releases/download/v1.2.20/kotlin-compiler-1.2.20.zip\n  [kotlinc] To: E:\\_JBuilder\\Personal\\lwjgl3\\bin\\libs\\kotlin-compiler-1.2.20.zip\n  [kotlinc] https://github.com/JetBrains/kotlin/releases/download/v1.2.20/kotlin-compiler-1.2.20.zip moved to https://github-production-release-asset-2e65be.s3.amazonaws.com/3432266/83bc653a-fb8b-11e7-86d0-cb2dc1dc4b30?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180215%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20180215T193417Z&X-Amz-Expires=300&X-Amz-Signature=3ca28f5affa86bd389a68657c87c1765b1adf410907e5277d30f1addddbcdf36&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment%3B%20filename%3Dkotlin-compiler-1.2.20.zip&response-content-type=application%2Foctet-stream\n  [kotlinc] ....................................................\n.\n.\n.\n  [kotlinc] ..........................\n  [kotlinc] Expanding: E:\\_JBuilder\\Personal\\lwjgl3\\bin\\libs\\kotlin-compiler-1.2.20.zip into E:\\_JBuilder\\Personal\\lwjgl3\\bin\\libs\n  [kotlinc] Deleting: E:\\_JBuilder\\Personal\\lwjgl3\\bin\\libs\\kotlin-compiler-1.2.20.zip\n  [kotlinc] The Kotlin compiler was updated to build: 1.2.20\nBUILD SUCCESSFUL\nTotal time: 1 minute 25 seconds\nFrom running compile-templates\n```\nBuildfile: E:_JBuilder\\Personal\\lwjgl3\\build.xml\nbindings:\ninit:\ncheck-dependencies:\n-compile-generator:\n[Generator] Compiling Kotlin generator...\n  [kotlinc] Compiling [E:_JBuilder\\Personal\\lwjgl3\\modules\\generator\\src\\main\\kotlin] => [E:_JBuilder\\Personal\\lwjgl3\\bin\\classes\\generator]\n  [kotlinc] info: kotlinc-jvm 1.2.20 (JRE 1.8.0_111-b14)\n  [kotlinc] info: PERF: INIT: Compiler initialized in 1145 ms\n  [kotlinc] info: PERF: ANALYZE: 18 files (8561 lines) in 8258 ms - 1036.692 loc/s\n  [kotlinc] info: PERF: GENERATE: 18 files (8561 lines) in 8143 ms - 1051.332 loc/s\n  [kotlinc] info: PERF: GC time for Copy is 592 ms\n  [kotlinc] info: PERF: GC time for MarkSweepCompact is 218 ms\n  [kotlinc] info: PERF: JIT time is 2102 ms\n  [kotlinc] info: PERF: Find Java class performed 17 times, total time 3 ms\n  [kotlinc] info: PERF: Type info performed 28505 times, total time 5967 ms\n  [kotlinc] info: PERF: Call resolve performed 16207 times, total time 4556 ms\n  [kotlinc] info: PERF: Binary class from Kotlin file performed 263 times, total time 171 ms\n    [touch] Creating E:_JBuilder\\Personal\\lwjgl3\\bin\\classes\\generator\\touch.txt\n[javac: Generator Tools & Doclets] Compiling 7 source files to E:_JBuilder\\Personal\\lwjgl3\\bin\\classes\\generator\ncompile-templates:\n[Templates] Compiling Kotlin templates. This will take 1-2 minutes...\n    [mkdir] Created dir: E:_JBuilder\\Personal\\lwjgl3\\bin\\classes\\templates\n  [kotlinc] Compiling [E:_JBuilder\\Personal\\lwjgl3\\modules\\lwjgl\\core\\src\\main\\kotlin\\core\\dyncall, ...] => [E:_JBuilder\\Personal\\lwjgl3\\bin\\classes\\templates]\n  [kotlinc] info: kotlinc-jvm 1.2.20 (JRE 1.8.0_111-b14)\n  [kotlinc] ERROR: Exception while analyzing expression at (371,11) in E:/_JBuilder/Personal/lwjgl3/modules/lwjgl/opengl/src/main/kotlin/opengl/templates/GL45.kt\n.\n.\n.\n  [kotlinc] Caused by: java.lang.OutOfMemoryError: Java heap space\n.\n.\n.\n  [kotlinc] Caused by: java.lang.OutOfMemoryError: Java heap space\n.\n.\n.\nBUILD FAILED\nE:_JBuilder\\Personal\\lwjgl3\\build.xml:255: Compile failed; see the compiler error output for details.\nTotal time: 2 minutes 1 second\n```\nEdit: cut out the stack trace. I gave up trying to run Ant from the command line.\n\nI checked out the project fresh and started by copying the eclipse .classpath file to the root.\nAdded lwjgl3 as a project.\nThen I created a \"Run External Tool\" under the \"External Tools Configuration\" dialog\nFrom there it was a piece of cake.\nOn the Targets tab I selected (Clean, init, compile-templates, compile-tests) and made sure that was the order they'd execute in.\nOn the JRE tab I added '-Xmx1G', at @Spasi suggestion.\nClicked Run and got a full build, no issues.\nI updated the Class path for the tools.jar file\nClicked on the project and hit F5 for a refresh. (Then waited for a workspace rebuild)\n\nIt looks like it completed, but I'm missing the lwjgl.dll file though. I assume that was suppose to go in the bin/libs folder the same as the Linux *.so files.\nEdit: Should also mention I did set ANT_OPTS and switched my default JDK to the 64-bit 1.8.0_161 install before trying the eclipse ant interface.\nI got a bunch of errors like these\n```\nBuildfile: E:_JBuilder\\Personal\\lwjgl3\\build.xml\nbindings:\ninit:\ncheck-dependencies:\n-compile-generator:\n[javac: Generator Tools & Doclets] Compiling 7 source files to E:_JBuilder\\Personal\\lwjgl3\\bin\\classes\\generator\n[javac: Generator Tools & Doclets] E:_JBuilder\\Personal\\lwjgl3\\modules\\generator\\src\\main\\java\\org\\lwjgl\\system\\ExcludeDoclet.java:7: error: package com.sun.javadoc does not exist\n[javac: Generator Tools & Doclets] import com.sun.javadoc.*;\n[javac: Generator Tools & Doclets] ^\n```\nEdit 2: I started looking at issue #349, just because, and I now realize the errors being generated on my Windows machine from the command line may be related to the deprecation of com.sun.javadoc.* Which if I'd actually read the error I might have made the connection sooner. No idea why I'd get them from the command line and not the Eclipse Ant plug-in. I made sure both were using the same JVM and Ant version.. JAVA_HOME is set, I think it might be pointing to an Oracle DB or ArcGIS or [something else] install of the JDK though.\nMy work machine is sometimes locked down in terms of what I can install (depends on what my group policy permissions has decided is ok that day) and I don't have access to another windows box to develop on. So I'll have to see if I have permissions to install Visual Studio.\nI appreciate the help, sometimes it takes me awhile to get familiarized with project and it's tools, but if there's some way I can give back, I'd like to help out. . Glad I finally checked the issue tracker... I thought it was just me.\nI've been playing around with it a bit to see if I can fix the build path issues, but I seem to be missing a libs/testng.jar, which I'm assuming is where the org.testing.* package is coming from and why most of the modules/lwjgl/core/src/test/java/ classes are broken.\nThe other thing that's showing up broken for me is the @Nullable annotation. I'm not sure where that's linked from. Eclipse is telling me to import the com.sun.istack.internal package, but something tells me that's not right and the annotation is defined in one of the other source folders that was refactored.\nLots of other missing and broken imports as well, it'll take me some time to track them all down. I tried to run the build.xml with ant from the root, but it craps out on me when it gets to building the config/linux/build.xml\nunfortunately Ant and Gradle are foreign territory for me so I'm not sure how to debug them.. ant compile-templates compile-tests completed successfully\nant test failed in the same place in the linux build as it did before. I think it might be related to the \nBUILD FAILED\n/home/pram/development/eclipse/lwjgl3/build.xml:442: The following error occurred while executing this \nline:\n/home/pram/development/eclipse/lwjgl3/config/linux/build.xml:197: \nThe following error occurred while executing this line:\n/home/pram/development/eclipse/lwjgl3/config/linux/build.xml:201: exec returned: 1\nThe following error occurred while executing this line:\n/home/pram/development/eclipse/lwjgl3/config/linux/build.xml:83: The following error occurred while executing this line:\n/home/pram/development/eclipse/lwjgl3/config/linux/build.xml:33: apply returned: 1\nI did get things working, but probably not in the way you'd like. I added a pom.xml file and used Maven to gather the missing libraries.\nIt mainly grabs the TestNG testing.jar file and points to the missing resource jars jsr305-3.0.5.jar (for the missing nullable, and a couple other, annotations.)\nThe one thing that gave me problems is the com.sun.javadoc.* package. I had to manually add the tools.jar from my /usr/lib/jvm/jdk1.8.0_121_64/lib/ directory. Apparently that's a common issue.. I finally went back and cleaned up my linux system. (I really need to spend more time on keeping things up-to-date.)\nI got libgtk-3-dev but when I run ant tests I still get an error\n```\n      [gcc] Linking lwjgl_opengl\n      [g++] Linking lwjgl_tootle\nBUILD FAILED\n~/development/eclipse/lwjgl3/build.xml:442: The following error occurred while executing this line:\n~/development/eclipse/lwjgl3/config/linux/build.xml:237: The following error occurred while executing this line:\n~/development/eclipse/lwjgl3/config/linux/build.xml:83: The following error occurred while executing this line:\n~/development/eclipse/lwjgl3/config/linux/build.xml:33: apply returned: 1\n``\nwhich seems to be this section of theconfig/linux/build.xml`\n```\n        \n\n\n\n\n        <mkdir dir=\"@{dest}\"/>\n\nThis line--> \n\n\n\n\n\n            <arg value=\"-I${jni.headers}\"/>\n            <arg value=\"-I${jni.headers}/linux\"/>\n\n            <arg value=\"-I${module.lwjgl.rel}/core/src/main/c\"/>\n            <arg value=\"-I${module.lwjgl.rel}/core/src/main/c/${platform}\"/>\n\n            <arg value=\"-I${src.main.rel}\" if:true=\"@{simple}\"/>\n\n            <source/>\n            <fileset dir=\".\" includes=\"${src.generated}/*.c\" if:true=\"@{simple}\"/>\n\n            <regexpmapper from=\"(\\w+)\\.c(?:c|pp)?$\" to=\"\\1.o\"/>\n        </apply>\n    </sequential>\n\n```\n. It wasn't xorg-dev, but that was helpful. I was on gcc and g++ 5, I updated to gcc and g++ 6 and it's compiling properly now.\ndemo/FiraSans.ttf is missing. I got a copy of fire-sans.regular.ttf here and renamed it and it worked fine. I could add that to the git repo.\nalso missing demo/Phero.ogg. There was a class path missing from this request that I discovered this morning when I re-re-re-followed my steps.. It is possible. I may not understand exactly what you're requesting though.\nI set up mine with the following as source folders\n1. module/samples/src/test/java/\n2. module/lwjgl/core/src/generated/java/\n3. module/lwjgl/core/src/test/java\n4. module/lwjgl/core/src/main/java\nThen I added all of the bin/classes/<module>/ folders as part of my class path libraries.\nI did so specifically to play with the EasyFont.java class to figure out how fonts work. And it does work for me, I have unrelated questions for you about that at some point. Let's keep this concise.\nI think the way you want it is set up is so all the\n1. /module/lwjgl/<module>/src/generator/java\n2. /module/lwjgl/<module>/src/main/java\n3. /module/lwjgl/<module>/src/test/java\nare all added as source folders as well. \nThe advantage to that is everything is available for development immediately, the down side is it really clutters up the package explorer.. I'll digest and think on this for awhile. I'm pretty much out of time for the weekend and have to get a sick daughter to bed. I might have some time tomorrow at some point to work on this some more.\nI know I can set the source folders in eclipse to compile to specific output folders, I think that's closer to what you're describing. At the moment everything gets compiled to lwjgl/bin/eclipse rather than to the ant output folders. I'll have to go through and individually set each source folders output.. I've done what I can here. Unfortunately Eclipse doesn't really seem to be set up, or easily set up, to manage projects the way intellj is. What I have seems to work and outputs compiled classes to the proper bin/generator, bin/samples, bin/tests or bin/lwjgl/<module>, including the Kotlin classes if you have the Kotlin extension installed in eclipse (Kotlin extension doesn't seem to do package management, just compiles), but this whole set up is really unwieldy for the way I would typically do my development.\nThe Eclipse TestNG plug-in does pretty well for running the tests (although I prefer jUnit myself)\nI'm really not sure how useful this would be to do a full project build from scratch because you can't specify source dependencies and the priority order things need to be built in. Running the Ant build is by far the best way to compile the whole project. I have found I have to run Ant twice, I assume that's because of what @Spasi said about incremental building not available via Ant. In the first run the Kotlin packages are missing, even though they do get compiled out of order with the rest of the build. The second build has the required Kotlin packages already built... I could be way off base on that. I don't typically work with projects this large that have these kinds of interdependencies.\nI would probably set a project up to only include the module sources I need to work on at any one time and link the bin/lwjgl/<module> classes as build path Libraries, then use the ant build, onece, to compile the modules into the bin/lwjgl/<module> folders for anything I'm not currently working on.. We may want to cut this pull request.\nI've been doing a lot or reading up on Java 9 modules after seeing the module-info.java files in the module directories and wasn't really sure what they were about. I'm wondering if there isn't a better way to set this up in Eclipse. When @Spasi was talking about how the modules were set up in IDEA I thought that was a feature specific to IntelliJ, but now I'm wondering if he wasn't using the modules feature in Java 9 (with some IntelliJ support). I do less Java development than I use to and only recently moved to Java 8 so I might need to get caught up on the latest trends. Apparently Eclipse Oxygen 4.7 (which I haven't used) does something with Java 9 and modules and I need some time to research and play with the feature to find out what's possible.\nIn the meantime, I'll leave it to @Spasi to either close this off or to merge the pull request. It might be a \"better than nothing\" solution for the moment. Although I think including an Eclipse .classpath file with the bare-bones (just the core and sample modules) and a tutorial on adding sources would be better than what this has become. I've always preferred eclipse (for more than just Java development), but for this type of project setup it's just a mess. I'd rather learn IntelliJ at the moment than develop with the set up I have.. Ok, Thanks for clearing that up. I should have realized the generated/java should compile to the same class dirs as the main/java. Should be an easy fix I'll start on.. ",
    "TheMrMilchmann": "I have already experimented with porting the build process to Gradle in the past and had a look at it again quite recently. I might publish my progress later this week to give you an idea of what it could look like.\nHowever, one issue that's stopping me from cleanly transitioning to Gradle remains: There are circular dependencies between templates of some modules (e.g. OpenGL and OpenCL). While it is possible to compile all templates together this eliminates some of Gradle's benefits and I'd rather see those circular dependencies removed (if this is reasonable without too much duplication).. Hey @Spasi,\nI have updated the pull request and removed the (now) unecessary commit. You're indeed right. I was only building a small subset of LWJGLs bindings in order to reduce the build time.. @francogp This should already be fixed in more recent releases (starting from 3.1.1 as pointed out by @Spasi). \nSee https://github.com/LWJGL/lwjgl3/commit/e3879b20b4a89f92422cb2b1f6eeb2d893963827. > * jlink does not add them to the image, unless explicitly required. Manually adding them with --add-module fails too.\nI'm not quite sure what you mean here. What exactly fails? (btw: The option is called --add-modules. I assume this is just a typo though.)\nFor me the following is working perfectly fine:\n\n(I'm fully aware that those are not the actual modules but the behaviour should theoretically be the same.). This is likely a duplicate of #338.\nIt does look like it is a bug in Oxygen 4.7.1a. Take a look at https://github.com/LWJGL/lwjgl3/issues/338#issuecomment-334400562 for a more detailed answer.\nA possible workaround is adding LWJGL's jars to the classpath instead of the module path.. I just cloned this branch into a fresh environment and realized that the latest commits seem to be missing some changes. I'll quickly rebase and fix this.. Rebased and updated. Should be good to go now (this time for real)!. In my opinion, your changes improve the overall readability of the file. However, I think if this is done the environment variables mentioned under \"Build Configuration\" should also be highlighted. (See here.). Such a constant does already exist. (See org.lwjgl.system.MemoryUtil.NULL)\nFor convenience I suggest using import static org.lwjgl.system.MemoryUtil.*;. This way your method call looks like this: glfwCreateWindow(640, 480, \"Inception\", NULL, NULL);. You set the -XstartOnFirstThread property in IntelliJ but Gradle is not tied to the IDE an therefor does not know about it.\nYou can set the property in Gradle by adding the following line to your build script:\napplicationDefaultJvmArgs = [\"-XstartOnFirstThread\"]\nGradle is a bit messy to get into but you can find the documentation of the application plugin here if you feel like it.\nEDIT: I guess I was a bit late.. This is a bug in the module declaration of the GLFW binding. More precisely: GLFWVulkan uses parts of the Vulkan binding without this being specified in the module-info.java file of the GLFW binding.\nThe latter looks like this:\n```java\n/\n * Copyright LWJGL. All rights reserved.\n * License terms: https://www.lwjgl.org/license\n /\nmodule org.lwjgl.glfw {\n    requires transitive org.lwjgl;\nexports org.lwjgl.glfw;\n\n}\n```\nI'm however not sure how this could be solved without making the GLFW binding depend on the Vulkan binding or splitting GLFWVulkan into a separate artifact.. Hey @cwb123,\n\nRegarding the dependency, I'm brand new to LWJGL and these APIs in general so hopefully this isn't a silly idea. But from the docs for public static long glfwCreateWindow(..., we see that it Creates a window and its associated OpenGL or OpenGL ES context. and yet glfw somehow isn't dependent on opengl?\nIt seems to me this is because all OpenGL related things are internal to native GLFW and only exposed as pointers (if at all)?\n\nYour assumption is correct. OpenGL types are not exposed by GLFW and since LWJGL's bindings are basically bridges to native APIs, the binding does not require types of OpenGL (or the respective binding) either.\n\nEdit: Upon investigation, VkInstance extends DispatchableHandleInstance extends Pointer.Default which is part of org.lwjgl.system so shouldn't GLFWVulkan simply use Pointer.Default instead of VkInstance (and similar for the other vulkan dependent types)?\n\nWhile this is possible (and already available in the \"unsafe\" version of GLFWVulkan::glfwGetInstanceProcAddress) I would argue that this would defy LWJGL's purpose of being as type-safe as possible without hurting performance. However, unless we want to split GLFWVulkan into a separate artifact, I suppose an exception would be necessary.\n\nRegarding the Eclipse error, does module-info.java affect libraries configured on the classpath (not modulepath)? My Eclipse 'User Library' also has each listed jar file identified as Is not modular - non modifiable.\n\nI'm not sure about how Eclipse handles dependencies internally but a module declaration should generally be ignored on the classpath. There is nothing else that could prevent the GLFW binding to access code from the Vulkan binding though.\n\nSomewhat unrelated, but I'm noticing that there's also a number of @NativeType annotations missing throughout the GLFWVulkan source, is this sort of thing considered a bug?\n\nThis is something I didn't dig into too much yet. I'll refer this one to @Spasi.\nAdditional notes:\nThis bug has technically (although in another way) been present in LWJGL since the project has been modularized or the GLFWVulkan functionality has been added (whatever came last). The org.lwjgl:lwjgl-glfw artifact does not depend on the org.lwjgl:lwjgl-vulkan artifact, yet the fromer uses and exposes types from the latter.. The COCOA_FRAME_AUTOSAVE hint has been replaced with the string hint COCOA_FRAME_NAME back in December last year. (See here for the relevant commit to GLFW and here for relevant commit to LWJGL.)\nKeep in mind that LWJGL releases may ship with pre-release versions of libraries which means that there can be (minor) breaking changes.. The issue is that attempting to fetch JOML from https://build.lwjgl.org/addons/joml/joml-1.9.10.jar yields a 403 error. I assume some \"behind-the-scene\" step accidentially got skipped in LWJGL/lwjgl3-www#55.\n@apostolos Could you please look into this?\n@Zamundaaa In the meantime you could exclude JOML from your ZIP bundle and download it manually from maven central (http://central.maven.org/maven2/org/joml/joml/1.9.10/).. Hi, could please add some more information on how you are running the demo and during which step (compile/runtime) it fails?\nSince you cannot find NkColorf (which does actually exist) I assume you are building LWJGL from sources. Did you follow the steps in this document to become familiar with how LWJGL is build?. You can go back in git history to find an older version of the demo. This revision should work for you: https://github.com/LWJGL/lwjgl3/blob/3.1.2/modules/core/src/test/java/org/lwjgl/demo/nuklear/GLFWDemo.java. I'm curious: What happened in this line?. This, currently, does not seem to include JObjectTypes which I think I fixed and is something that was lost at some point. IIRC this was also the reason to make JObjectType a class.\nChanging the expression to (this is PointerType && (this.mapping !== PointerMapping.OPAQUE_POINTER || this is ObjectType)) ||  this is JObjectType should to the trick.. Since the documentation of \"text encoding\"-methods does not refer to any \"allocation\"-method we should probably explicitly document what happens if the operation fails here.. This method is missing documentation.. There should probably be a dot (.) at the end of the last bullet point.\nI'm not quite sure whether I like the current wording. Any objections?. ",
    "afiskon": "I tryed, lwjgl_util 2.9.3 does NOT work with lwjgl 3. For example, gluPerspective throws an exception:\nException in thread \"main\" java.lang.NoSuchMethodError: org.lwjgl.opengl.GL11.glMultMatrix(Ljava/nio/FloatBuffer;)V\n    at org.lwjgl.util.glu.Project.gluPerspective(Project.java:218)\n    at org.lwjgl.util.glu.GLU.gluPerspective(GLU.java:286)\n...\nI believe a lot of people would appreciate if GLU would be included in lwjgl 3.\n. ",
    "httpdigest": "I recommend you use the very nice lwjglx project by kappa, which is a compatibility layer on top of LWJGL 3 to adapt some of the APIs of LWJGL 2, including GLU, Display, Mouse and Keyboard.\nIt works really well with existing projects that require LWJGL 2, such as the Themable Widget Library.\nIf you merely want to have the \"math\" aspect of GLU (without the procedural geometry), such as building a lookat or projection matrix, you could use JOML.\n. Basically, all OpenGL extensions. They come as ASCII text specifications like the IETF RFCs with conventionally named sections containing the C prototypes of new functions.\nThose functions are then implemented by driver vendors. And clients, like the OpenGL extension wrangler project GLEW, usually need to copy/write the prototypes in their own header files.\nLWJGL as another OpenGL client uses many handcrafted template files written in the Kotlin language for supporting extensions, because there is no single OpenGL header file containing everything.\nOr at least I don't know of any.\n. I was following this conversation, and became curious because I always wanted to have a Direct3D binding in LWJGL (please no debates on the usefulness of a non-cross-platform binding for Java here, most people are using Windows so if you want to do a Direct3D game with actual OS/driver support, like I do, this would be a very nice solution ;) and I invested a bit to get something handcoded working: lwjgl3-d3d11\nNow I think your JavaCPP generator could really help me with that, so that we can finally have a full optional Java/Direct3D binding added to LWJGL.\nIs it true that JavaCPP can simply parse the header files of Direct3D and generate all appropriate Java classes and native code? If so, this would be exactly what I need.\nAnd do you know whether there is already such an attempt on using JavaCPP to generate Direct3D bindings?\nAnd how does JavaCPP handle cases like COM interface methods that return a void* where ultimately you want it to return a type-parameterized object instead in Java? I solved this by having the user specify the Class and type-parameterized the method to return an instanceof that class T.\nSee an example of this in the IUnknown class where the user usually has to provide the REFIID of the COM object to lookup and is being handed the object in a supplied void*.\nI think to really make CPP convenient to be used with Java, there are potentially a lot of those corner cases where one would need some mechanism, such as annotations, to hint to the parser/generator how that construct should be mapped to Java to make using CPP convenient with Java. What do you think?\n. In my opinion it's not so much a question of whether LWJGL provides something that is not already there. Instead consistency is the most useful property here. LWJGL clients would use the same API over all platforms without having to port the code.\n. You might want to have a look at JOML: https://github.com/JOML-CI/JOML\nIt does however not (yet) reflect the design of GLM, but rather that of Sun's javax.vecmath, due to being allocation-free.\n. There is the GL45.glCreateVertexArrays function creating the name of a VAO without the need to bind it in order to make it a VAO object.\nCorrespondingly, there are all those other glCreate* functions, such as GL45.glCreateBuffers (buffer creation without needing to bind it) as well as GL45.glCreateTextures for texture objects, GL45.glCreateFramebuffers for FBOs and GL45.glCreateRenderbuffers for render buffers.\n. 'course no Fermi support. I am a bit suprised that it even supports Kepler. :)\nNvidia, like every other vendor, is ultimately interested in selling GPUs.\nAnd they do it in very close cooperation with the game industry, which demands faster and more portable APIs, so they can sell games to a wider audience with less effort. So they get Vulkan, so that people buy more games and ultimately buy more graphics cards.\nBut since Vulkan is cross-vendor and cross-platform (demands from the game industry), that does not really play into the cards of Nvidia (and co.), so Nvidia will make sure that they have better tools (like debuggers/profilers/tracers which of course will only work on Nvidia hardware) and extensions than the others with which you'll always be better off than with anything else... that's the plan. :)\nSo: buy yourself a new graphics card. ;)\n. There is a paragraph on the Vulkan Wikipedia article about that argument: \n\nInitial specifications state that Vulkan will work on hardware that currently supports OpenGL ES 3.1 or OpenGL 4.X and up.[32] As Vulkan support will require new graphics drivers, this does not necessarily imply that every existing device that supports OpenGL ES 3.1 or OpenGL 4.X will have Vulkan drivers available.\n\nSo, it seems that they decided that patching drivers or writing complete new drivers for one of their old GPU generations is just not feasible/economical, albeit probably technically possible.\n. Yeah, sorry about that explaining. I feel with you. I too have a Fermi laptop around with me, which I cannot use with Vulkan then anymore. But maybe it's really time for us to upgrade? :)\n. Personally, I would like to have more control over the formatting of the generated messages.\nAnd this would usually be done with a common callback interface that the user can set.\nHaving had a look into the relevant code in LWJGL 3 the problem seems, though, that the callback interface and the actual formatting of the messages are intertwined because both depend on the underlying native extension/GL core function being used, which have differing signatures and provided information.\nThe only thing I can think of right now is a common interface which is the union of the information provided by all different underlying callbacks.\nThis way the user can adapt any logging library he/she wants to use, without introducing a dependency into LWJGL 3.\nThe native callbacks' signatures seem to be mostly:\n  int source, int type, int id, int severity, int length, long message, long userParam\nwith AMD being an exception there with:\n  int id, int category, int severity, int length, long message, long userParam\nTherefore I propose a user-implemented callback interface with the signatures:\n  void onAmdMessage(int id, int category, int severity, String message)\nvoid onAllOtherMessage(int source, int type, int id, int severity, String message)\nI am not sure whether both methods should be united, or kept separate.\n. > It is almost too complex for LWJGL ...\nYes, it almost feels like a \"utility\" method. But there is a pattern to observe: The more something becomes \"utility\" the more people demand for it and the more useful it becomes.\nSee for example the math classes. :)\n\n... and go through the pain of good old glGetError\n\nThat's a pitty. But glGetError of course has its use. I once used a very old Intel card with a GL 2.0-only driver, that had neither of these debugging extensions. But of course, I wouldn't develop and debug on that, but glGetError was still necessary to catch errors only occurring there.\n. I agree with you on all points there. I was actually never in favor of having \"utility\" things in LWJGL itself, just mentioned that those things are useful. :)\nLWJGL is fine as it is and that particular utility method shouldn't be there in the first place.\nAnd yes, clients should roll their own utilities on top of what LWJGL provides as low-level library.\nIt's just that most users probably woudn't know how to do that properly, or even that the GL debugging extensions exist. And there we have the dilemma at hand: If someone provides utility methods, those are readily being used. But if they aren't, then people wish that they were, and we need to tell people again and again that LWJGL already provides the fundamental to roll a custom library on top of LWJGL. It's just that this seems to be too much to ask. :)\nThat's probably why that utility method is in GLContext.\n. > Java 5 was obsolete 3 years ago and remains so\nYes, of course. You are right. But that does not stop people from using it. And I am thinking about very old corporate computers for which there are still in-house projects to build and support.\n\nThe decision to make LWJGL 3 compatible with Java 6+\n\nBut is there any reasoning behind this decision? I mean if there is no need for a library to be Java 1.x compatible, because it does not make use of API or language features, then, why make it so?\nIn my opinion the lowest requirement for a broadly used library is always the best choice.\nBut of course, if the decision is final, this issue can be closed.\n\nIt's more likely to bump the minimum required Java version to 7/8 for the official 3.0 release\n\nThat would be most unfortunate in my opinion. But of course you decide.\n. Don't get me wrong, all I am saying is that no writer of a framework can imagine all scenarios and environments that his framework is going to be used in.\nAnd that he should always target for the least restrictions, unless absolutely unavoidable, so as to not patronize a client to use a specific minimum JRE version when technically unnecessary.\nSo if LWJGL 3.0 is going to absolutely have to make use of Java 7 or even Java 8 API and language features, then it be so.\n. Yes, that's what I am thinking too. There seems to be very little gain in using Java 7 and 8 in a framework compared to a very high compatibility price to pay, just because \"one was feature-happy or lazy.\" ;)\nI know that non-capturing Lambdas in Java 8 can have a nice performance gain compared to handwritten anonymous classes which get instantiated with every call, but then again a framework should not make use of anonymous classes anyway. :)\nBut apart from that, do you have any nice new features for LWJGL 4? Apart from a modularized build?\nI mean, considering the current state, LWJGL 3 is pretty perfect for me in its use. I cannot think of anything I would like to have changed on it.\n. Panama looks very promising. Would be great if LWJGL can make use of it to get rid of the JNI overhead.\nOkay, I am closing this PR now, because Java 1.6 is fine and 1.5 compatibility can as of now be obtain easily in a fork if desired.\n. Just like you added -XstartOnFirstThread to the \"VM arguments\" field in your run configuration, you also can add -Djava.library.path=/the/path/to/your/natives in that edit field. Either separate it from the other argument via a space or via newline.\n. I think the point of Spasi's question was not to know whether you extracted the files, but where they reside now. In some SIP-secured folder or something.\n. I very much agree with @Spasi there, and thanks for pointing to JOML!\nRoll your own class or use JOML's Vector3f or Vector4f for that.\nJust to prevent any upcoming feature request: No, JOML is not going to include a Color/Color3f/Color4f class, for that matter. :)\n. Can confirm that. Win7 x64, latest LWJGL3 head, msvc 2013 build.\nHowever, it seems that the current glfw head (which I know LWJGL3 does not use) does not exhibit this behaviour anymore (tested with a simple native app).\n. > You may have done something different, because LWJGL 3 uses the GLFW head (the master-linux64 branch is also used for the Windows builds).\nOh, I thought you switched to some last GLFW release, because of some keyboard issues. But anyhow, now that I tried it again, the flicker is gone with both lwjgl and glfw-native solutions... the only thing remaining is the taskbar getting hidden when going fullscreen, whereas when offsetting the window position by (1, 0), the taskbar remains visible. This seems to be an indicator, too, that GLFW is going fullscreen there.\n. Huh? \"Framebuffer bindings?\"\nThere are bindings for GLFW which provide the necessary functions to create an operating system window with a default framebuffer to render to.\nThere is also the possibility to create some kind of offscreen context/framebuffer using a hidden window glfwWindowHint(GLFW_VISIBLE, GL_FALSE) in GLFW. This in fact uses the window-provided context and framebuffer. It's just that the window itself is not visible to the user.\nOpenGL also provides the possibility to create offscreen framebuffers either via the EXT_framebuffer_object (see class EXTFramebufferObject), ARB_framebuffer_object (see class ARBFramebufferObject) or the core functions in OpenGL 3.0 (see class GL30).\n. It seems that neither the webserver, serving those HTML files, nor the HTML files themselves declare them to have UTF-8 encoding. And then CP-1252 encoding is being used. When viewing the corresponding .java file and the contained JavaDoc, everything is displayed correctly.\n. It must have been fixed during the last days. I had the exact same issue with the cursor position callback being fired every second without moving the mouse. I tested it with a LWJGL nightly build that was about a week old or so. Now, I built everything fresh and the issue is no more.\nMaybe use the current nightly build of LWJGL from http://www.lwjgl.org/download. With this, I also do not have that issue anymore.\nI was also using Windows 7 x64.\n. @Spasi, @Noviv: If you don't mind then I'll PR my Eclipse project configuration (.project and .classpath) inside the config/ide/eclipse folder. Those are created in Eclipse Luna (4.4), but should work with any previous Eclipse versions.\n. Okay, pull is in: https://github.com/LWJGL/lwjgl3/pull/90\n. Usage hint: Remember to copy those two files from config/ide/eclipse to the root folder of the lwjgl3 sources for Eclipse to work properly, and then import the project into Eclipse.\nThis configuration excludes the packages org.lwjgl.egl, org.lwjgl.opengles, org.lwjgl.demo.ovr as well as the class org.lwjgl.glfw.GLFWNativeEGL.java from the build path, as those give compiletime errors when building LWJGL3 with default settings via ant.\nAlso the library path is configured to point to the libs/ directory, so any other project referencing this lwjgl3 project will have the correct native libraries location and should work instantly.\n. Unfortunately, the .project and .classpath files have to be at the project root directory. See: https://bugs.eclipse.org/bugs/show_bug.cgi?id=78438\nIt is also not possible to use relative paths that use .. in them. The paths must be absolute or must be a direct child path of the path where the .classpath file resides. Eclipse gives horrible error messages when I altered the .classpath file manually to have relative paths and then imported the project.\nHaving the .classpath and .project files in the project root directory is sadly pretty much standard with any Eclipse-based project I saw so far and people generally svn:ignore or .gitignore those files.\n. > ... and Eclipse has the ability to import Netbeans projects.\nAre you sure? I've never seen that. Maybe with an additional plugin, though?\n. Screwed the git history up with an additional commit... have to figure out how to do it in 1 commit. :)\nI do another PR.\n. Now without the EGL sources exclusion. Also Eclipse builds into the bin/eclipse folder. One can configure different output directories for different source directories, but I thought that was not really needed here.\nAlso I thought it would be better not to let Eclipse interfere with ant-built classes.\n. Thanks, kappa, for mentioning Slick2D. I had a look at LibGDX but their triangulations (ear and delaunay) all cannot handle holes.\nI would definitely favor a Java solution before going native :) so I'll take a look at Slick2D.\nCan you say something about the quality of the triangulators there, because sadly neither of the Slick2D triangulators reference any paper of the algorithms they implement, so it is unclear what is implemented there to read about the properties of the algorithm.\nAlso, only the \"Mann\" triangulator supports holes.\n. Thanks, @kappaOne, for all the information; appreciate it!\nI finally got to trying the JavaScript earcut library. This one works really great on the browser. I had no issues so far triangulating three million OSM buildings in no time. The resulting triangles are as good as can be with such a triangulation algorithm that only works on existing nodes and does not introduce intermediate vertices to produce less degenerate triangles.\nI begun porting it to Java, because I also need to triangulate on the server.\n. I think this issue can be closed now, since I have no further need for clip2tri.\n. After some discussing, here is what my current perspective of a modular build is with respect to deployment:\nMotivation\nJust to reiterate what Spasi said above in the first post:\n\nLWJGL currently has several bindings, with more coming in the future. Many users will only use a subset of those, but they all come in a single, monolithic archive. We should consider updating the build process to create separate archives for each binding, that can be downloaded and deployed independently. This should be in addition to the fat archive that will still be available, for convenience.\n\nSo, from the deployment perspective, I as a user want to choose from the list of possible libraries/modules the ones I would like to use. The result should be that I only have to download the chosen modules and their transitive dependencies, but nothing else.\nProject setups\nThis now raises the question how to go about users with different project setups and build tools. Maven users will likely want to add the modules as Maven dependencies in their pom.xml. Together with the SharedLibraryLoader which extracts the native shared libraries from the classpath, this will work out of the box. This then necessitates that all modules are Maven artifacts being deployed in a public Maven repository.\nFor Gradle users it's basically the same.\nLWJGL Initializr\nNon-Maven/Gradle users will ideally be provided with a distribution zip file that can be downloaded from lwjgl.org, as is the case now with the fat distribution. For this, some kind of web application is desirable that lets the user choose which modules should be included in the distribution and then provide an assembled zip download for that, much like the Spring Initializr for Spring Boot.\nSo, we have a scenario where dependency management is handled by the build tool (Maven/Gradle) and a scenario where we have to bundle all artifacts into the download zip.\nBuilding\nTo satisfy the Maven/Gradle users, the existing deployment mechanism with Gradle and generated Maven pom.xml files can still be used. Every module will get a pom.xml that describes that module and its dependencies.\nFor non-Maven users who download a customized zip file, we need a way to automatically provide a selection of available modules to the user. Preferably, the user will be shown a web UI which asks him which version of LWJGL to use and based on that, which modules with which versions are available.\nFor this to work, the same Maven project comprehension can be used.\nMaven project structure\nThe basis is a parent Maven project. This project (probably named org.lwjgl:lwjgl) uses \"pom\" packaging and simply enumerates all modules as optional dependencies.\nEach module has a main pom.xml with packaging \"jar\" that describes its Java classes artifact.\nIn addition to the Java classes artifact, this artifact has profile-dependent dependencies to its native platform artifacts containing the respective shared libraries for the particular platform (windows/linux/osx).\nThis way, when a Maven user adds a single dependency to org.lwjgl:lwjgl-opengl (example for the OpenGL bindings) he will also get the correct platform jar as dependency.\nEach profile can then be activated via Maven profile OS activation rules so that Maven users only download the platform jar they need.\nIf a user wants to deploy his application for all platforms, he can just enable all profiles explicitly during a Maven build.\nThe pom.xml files for each module can probably be generated just like now via the Gradle build script. The only dependency so far is that every module will depend on the lwjgl-core module.\nNon-Maven Users\nNon-Maven users will be given a web UI to select and download a customized distribution zip file.\nFor this, we will reuse the already established Maven project structure.\nThe project Eclipse Aether (see demos) can be used to query a Maven repository for all available versions of a particular artifact and enumerate its sub-modules.\nWith proper pom.xml files describing the modules, their dependencies and versions, the complete selection UI can be generated (the available modules and their versions need not be maintained manually!), also respecting possible dependencies between modules. (when user selects module A then also module B must be used, because B is a (transitive) dependency of A).\nTo build the distribution with binaries and sources, either all of the selected modules' artifacts can be downloaded and packaged into a single distribution zip, or the modules' artifacts can be unpacked and repackaged into a single binary and source jar. The native shared libraries can also either be provided with their platform jar files or extracted and repackaged in a \"natives\" directory.\nTechnically, the actual download can be triggered via a single GET URL containing as query parameters the selected modules, such as:\nhttp://lwjgl.org/starter/download.zip?version=3.0.1&platform=windows&modules=core,stb,opengl,glfw\nBehind that, the server-side of the web application can assemble the correct zip distribution and stream it as download.\nVersion management\nCurrently, to ease version management, whenever a new version of LWJGL appears, all modules' versions will be updated accordingly to point to the same new version.\nRelease management\nJust like now, every new release will build all module artifacts and deploy them to Maven Central. Like mentioned above, whenever a non-Maven user wants to obtain a new release distribution, he selects the modules he wants to use and will get a customized distribution.\n. When we eventually have the personalized/modularized build download available, in my opinion there won't be any need anymore for downloading separate platform native jars and even for separating the Java classes jars from the platform jars.\nEverything can be downloaded as a single lwjgl.jar. This currently would be my perferred solution for non-Maven and non-Gradle users.\nMaven users on the other hand can/should use the Shade plugin to create an \"uber\" jar for final distribution/deployment containing everything in a single jar.\nGradle users can use the Shadow plugin (similar to Maven's Shade plugin) to achieve the same.\nFor all those solutions to work we however need separated native platform jars and separate Java classes jars.\nDepending on the build system the users uses, the point of consolidation just changes between either download-time (for IDE users) or build-time for Gradle/Maven users.\n. > why no put all natives in only archive*.jar? (lwjgl-glfw-natives.jar)\nThe zip download currently provided on the lwjgl.org/download page is just one way of assembling a distribution, which currently chooses to separate the platforms' natives and the Java classes into separate jars for each module.\nAnd you apparently want to have all platforms' natives in a single jar. This is certainly doable.\nIt will be possible to download such a combined jar from the lwjgl.org/download site soon.\nWe should not merge all platforms' natives too soon in the build process, though, because depending on the deployment mechanism a user chooses for his/her application, he/she may want to distribute the native jars separately for each platform.\n. Certainly. We could have an \"external modules\" section on the lwjgl.org/download site, where you can select lwjgl3-swt to be included in the download for all project types (Maven, Gradle, IDE).\nPlease note that SWT already brings support for OpenGL and perfect integration with LWJGL3.\nJust create a GLCanvas and afterwards do GL.createCapabilities() and you're set.\nHowever, on OS X you only get a \"legacy\" 2.1 context and you cannot have a multisampled default framebuffer.\n. Does this mean that you cannot wget/curl a specific URL with just using query parameters in order to get a customized bundled zip file?\n. Also I have a running version of Themable Widget Library, which works really awesome with LWJGL 3 and kappa's lwjglx library.\nI would really love for someone to do the porting to native LWJGL3 without needing an adaptation layer.\nThe render code of TWL is really nicely decoupled from everything else and can be swapped once a new LWJGL3 implementation is available.\n. I think using Nashorn and JavaScript would not be the problem; the library implementation and its API would be, as it sounds rather like the tasks of browser engines like WebKit or Blink and the domain of the Web platform in general. However it would sure be great. :)\nIMHO when layouting with HTML/CSS, I would then switch to WebGL (like with three.js), Canvas \"2d\" based 3D frameworks such as phoria.js or CSS 3D Transformations, instead of developing a desktop application with Java/LWJGL.\ndukescript however sounds fascinating! :)\n. This \"awesomium\" seems to be what you were looking for:\n- http://gamedev.stackexchange.com/questions/47361/draw-user-interface-in-opengl-using-web-technologies\n- http://awesomium.com/\n- http://wiki.awesomium.com/general-use/working-with-offscreen-web-views.html\nIt also allows to render into an OpenGL surface (one can define its own surface factory).\nThat could be an option.\n. Supporting OpenGL 1.1 and not >= 3.2 core is an issue if you yourself want to use a \"modern\" OpenGL context and functions therein, which would both not be possible in a single context. Either TWL would not function correctly because it used deprecated OpenGL functions or you would not be able to use \"new\" OpenGL functions. This is an issue with Mac OS X, which either supports OpenGL <= 2.1 if you don't ask for a new context specifically, or you would only get a \"core\" context if specifically asked for, but then TWL would not work.\nOne solution to this problem, and also to the problem of touched OpenGL state, could be multiple sharing contexts. One \"deprecated\" OpenGL context for TWL and another one for your own rendering.\nTWL could be issued to render into a texture using a Framebuffer Object and then that texture can be shared between both contexts to simply blit the texture onto your own \"new\" context's window.\nSharing between an \"old\" deprecated context and a \"new\" core/forward compatible context does work at least under Windows with Nvidia.\nHowever, only \"requiring\" OpenGL 1.1 is the smartest thing one can do for such a widespread library like TWL, in my opinion. Whenever you require anything higher than OpenGL 2.0 it will not work on some person's machine. Compatibility is a very big thing here!\n. The only downside of SWT is that it still (even in the very latest nightly build) cannot produce a GL >=3.2 core context. I had a look at the sources and found that the WGL solution at least is devised but commented out... But this problem can be solved by letting LWJGL3 do the GL context creation. So we would need a cross-platform way to create GL contexts in LWJGL3 based on a window handle. This handle is easily API-accessible in SWT.\nAnother solution would of course be to hack SWT, but I heard that their OS X backend is really heavily outdated, so it would be quite some hacking.\nI also dug out an old LWJGL forum entry about this: http://forum.lwjgl.org/index.php?topic=5531.0\n. I am going to build an own GLCanvas, something like a org.lwjgl.opengl.swt.GLCanvas or org.lwjgl.swt.opengl.GLCanvas, based on the platform API exposed by LWJGL3. The native/JNI code of SWT is really horrible. They do like a thousand (*env)->GetField(...) invocations and other slow/nasty hacks.\nPersonally I think, an own custom SWT Canvas would be the best solution, and I don't think it will require much maintenance, since it is only about creating the GL context and that should be common knowledge how to do that.\n. Like @Spasi said:\n\nThe first 3.0.1 builds will have Nuklear built-in\n\nYou are using the 3.0.0 Release, which does not have Nuklear included.\nThe sources of the Nuklear module, as well as the demo you are referring to, live in the nuklear branch, and you could build LWJGL with Nuklear from that branch manually.\n. It seems that has already been requested:\n- http://mail.openjdk.java.net/pipermail/openjfx-dev/2016-December/020058.html\n- http://mail.openjdk.java.net/pipermail/openjfx-dev/2016-December/020059.html\nAlso for JDK8:\n- http://mail.openjdk.java.net/pipermail/openjfx-dev/2013-May/007451.html\nBut I fear, because one of JavaFX's design goals being \"abstract all and everything away\" so that JavaFX is able to run on phones, on the Desktop, on the Browser platform and everywhere while being accelerated by either D3D, OpenGL or Vulkan (or what happens to be the hardware acceleration on that particular device), that Oracle will not break with this abstraction to actually expose an \"OpenGLNode\" (or even just a proposed \"3D Canvas Node\" telling the client that everything is currently being accelerated by D3D, OpenGL or Vulkan) on the API layer.. You are feeding glTextureSubImage2D too few data. Please note that the format RGBA with type FLOAT requires 128 bits per texel, since it is 4 channels \u00e0 4 bytes. Using type UNSIGNED_BYTE worked because you still had 4 channels (RGBA) but each only used 1 byte, and you had 4 bytes in your pixels ByteBuffer per texel.\nSo, you should create a pixels ByteBuffer like so: ByteBuffer pixels = BufferUtils.createByteBuffer(width * height * 4 * Float.BYTES);\nIf you maybe don't require 4 channels in your texture, but just need one, you could instead use GL_RED as format and GL_R32F as internal format.\nOh, and also please have a look at the raytracing demos in the lwjgl3-demos repository.\nThose are variations of my original demo from the mentioned article and use all kinds of OpenGL techniques (from OpenGL 2.0 through OpenGL 4.5), also with DSA.\nHowever, those do not require glTextureSubImage2D to initialize the texture via host memory, since every texture there is being rendered to before being sampled from.\nBy the way: invoking glTextureImage2D with a null data parameter (and when no pixel buffer object is bound) is in essence what glTextureStorage2D does. It creates storage for the texture without initializing the data of the texture.\nSo, you would actually only need glTextureStorage2D and no glTextureSubImage2D.\nI admit that the ByteBuffer named black is very misleading in the original code. :)\nThat was a relict from a previous version of that code which did create a real ByteBuffer with black texels to initialize the texture, only to later find out that this was not necessary.\n. Absolutely! Or if you don't want to have it in core LWJGL3, then we can maybe also make a shared library / optional module out of these?\n. Cool! When those functions are reintroduced, having full SWT support with GL 3.0 contexts is a walk in the park. Just augmenting SWT's GLCanvas to use the additional context attributes.\nI would provide the Windows implementation for it, and rely on someone else to do the Linux and OS X version, or just sneak over at GLFW how that is done.\n. Thank you for reintroducing it! So far only GetDC and ReleaseDC is missing.\nThose are in Winuser.h.\n. I used GetDC and ReleaseDC so far from SWT and now I have a problem that I think I did stumble on a year ago when creating a custom GL context with LWJGL3. The chicken-egg-problem with LWJGL3 that I cannot use wglCreateContext unless I already have a context.\nException in thread \"main\" java.lang.IllegalStateException: No GLCapabilities instance has been set for the current thread.\n    at org.lwjgl.opengl.GL.getCapabilities(GL.java:214)\n    at org.lwjgl.opengl.WGL.getInstance(WGL.java:101)\n    at org.lwjgl.opengl.WGL.wglCreateContext(WGL.java:126)\n    at org.lwjgl.swt.win32.GLCanvas.<init>(GLCanvas.java:64)\nHow would I go about solving this without using GLFW?\nI think LWJGL3 needs special entry points that omit loading all OpenGL function and extension pointers and requiring a full context being active, such as with wglCreateContext.\nI can of course also just use SWT's native functions for this part (those are available anyways). That does work great. And only use LWJGL3 for the WGLARBCreateContext extended context attribute creation. \n. Sorry, I forgot that LWJGL3 even provides more lowlevel facilities to access native functions. I now resort to:\nDynamicLinkLibrary lib = new WindowsLibrary(\"opengl32.dll\");\nlong wglCreateContextAddress = lib.getFunctionAddress(\"wglCreateContext\");\nlong context = callPP(wglCreateContextAddress, hdc);\nWorks like a charm without needing to initialize a full LWJGL3 context. :)\nI would initialize the GLCapabilities once I have an extended context created via wglCreateContextAttribsARB.\n. Nice! :D\nThat works really nice. Now it's tidying up and a new SWTGLCanvas is ready.\nI would also like to make the SWTGLCanvas cross-platform. SWT decided to basically completely duplicate/redesign all major classes for each platform.\nThat's why one always gets the full swt.jar with everything in it (there is no swt-common.jar) when downloading it for a specific platform, as sadly there are very few \"common\" classes.\nI want to have runtime checks in a single class to decide which platform-specific functions to use.\n. Thanks for the quick changes! I think we can close this issue now and track the progress of the new SWT GLCanvas in #107.\n. Closing this since this is not possible in a cross-platform/cross-windowtoolkit/cross-framework way, so an interface would possibly be just a heavily leaky abstraction.\nEvery solution is necessarily tailored to the window toolkit being used (win32, gtk, cocoa) and the framework (SWT, AWT, ...), since each needs different information and must intertwine window-system-specific calls in-between context creation.\n. Cool, thanks, CreateWindow back again! :) Now I can revive my begun Direct3D 11 bindings.\nWould be cool if we could figure out a way to auto-parse those C++ header files and generate pleasing mappings without generic Pointer>> things. :)\nMaybe I am having a look at clang's parser API, like you mentioned once.\nBut damn, I want a Direct3D binding! :)\nIt's not about losing cross-platformness - it's about gaining guaranteed driver compatibility across all GPU vendors. :)\n. Hey @oparisy. Yes, @Spasi was so anticipatory as to make that possible right away with LWJGL3. :)\nI already have a Windows-working version of a GL context creation right now. Only need to tidy it up.\n. I had a look at that posted code from Florent in that Bugzilla issue.\nThe context creation in LWJGL3 should not assume that if a pixel format is unaccepted/unsupported this was due to a too high multisample count and then should not silently decrease that multisample count until the pixel format gets accepted. It might have had other reasons why that pixel format was not accepted.\nI would prefer the client to be responsible for coping with an unsupported format and be informed (if possible) why the format was unaccepted. Also, the code assumes that WGL_ARB_pixel_format is available, which it may not. Old drivers are likely to require the respective Opengl32.lib functions to be used.\nI try to take care of all those issues.\n. Hm... this is an insane PITA trying to both support everything (all WGL, ARB, ...) extensions for pixelformat and context creation including multisampling, as well as trying to keep context creation as separate from windowing as possible. Now I kinda know why GLFW chose to bind those two aspects together.\nCurrently, the platform-independent interface for a GLContext implementation looks like this:\nJava\nlong create(long windowHandle, long dummyWindowHandle, GLContextAttributes attribs);\nboolean isCurrent(long context);\nboolean makeCurrent(long windowHandle, long context);\nboolean deleteContext(long context);\nThe second parameter dummyWindowHandle to create is what the proposed SWT code for multisampling does with the dummy Canvas. This is needed to create a pixelformat and a dummy context just to get a hold of wglChoosePixelFormatARB and to figure out whether multisampled pixelformats are supported or not.\nI have it right now that this querying is done on that dummyWindowHandle and after that all is figured out, it will use the determined pixelformat and also immediately use wglCreateContextAttribsARB to create the real context (GL <= 3.0 or >= 3.0 or core/compatibility) on the real target windowHandle.\nThis all works this way iff the windowHandle and dummyWindowHandle actually use the same SWT Display and henceforth the same graphics card/driver, if different cards are associated with different displays when on a multi-GPU system. The caller has to ensure this and the new SWTGLCanvas does this.\n. To create a dummy pixelformat. This is necessary on Windows, since pixelformats can only be set once on a window handle.\n. I committed a first working (alpha) win32 implementation of the new GLCanvas into:\nhttps://github.com/httpdigest/lwjgl3-swt\nIt supports multisampled framebuffers and OpenGL 3.0 and 3.2 core/compatibility contexts, and has support for v-sync/swap-interval.\nIt is a drop-in replacement for SWT's GLCanvas. Just change the imports from org.eclipse.swt.opengl.* to org.lwjgl.opengl.swt.*. Also SWT's GLData can be used as is. The new version just adds additional fields (with sensible defaults) to support the new features. If the fields are unset, everything should behave like the current Eclipse's implementation.\n. The Windows implementation of the new GLCanvas is working well so far for me.\nThe pixel format and GL context creation is quite straight forward, although ugly as hell, because of a lot of duplicated error checking and undo code paths. This could of course be done more pretty. But you know: \"First make it work, then make it better.\" :)\nI am also certain that I've not yet run into all issues GLFW had to cope with and fix/workaround during its life, so there are sure to be bugs/quirks, which require testing on some Windows machines to find.\nCurrently, I could only get hold of two Windows 7 x64 machines with Intel HD3000, Intel HD4000 and Nvidia GK107 chips.\nPlaying with all sorts of configurations (singlebuffered vs doublebuffered, multisampling, swap interval, OpenGL 2.1 vs OpenGL 3.0 and 3.2 core/compatibility and forward-compatible, context sharing) seemed to work fine.\nSo, I would be happy if someone with a different Windows version (maybe Windows 10 or 8) or even Windows XP could test it on their machines.\nAlso, if someone wants to have support for more WGL extensions, such as OpenGL ES support or swapbuffer groups when rendering via multiple cards/video outputs with Nvidia Quadro's framelock/G-Sync, this can be added if requested.\nThe current implementation works for me and suits my usecases, so I won't put any more effort into the Windows implementation, unless someone asks for features or finds issues.\nI'd also be happy if someone could provide the Linux and especially the OS X implementations, since I cannot test the latter.\n. Thanks a lot for testing! Currently that's it for now. If you need anything, just tell. :)\n. The remaining GLCanvas method getGLData() to query the effective pixel format and context attributes is now also implemented. I successfully tested it on the machines I have available.\n@Bobo1239 I'd be glad if you could test it too, though it should work just fine. :)\nAlso, since when you tested support has been added for the following:\n- NV swap groups\n- ARB robustness\n- ARB robustness isolation\n- NV delay before swap\n. Okay, I'm now on the Linux implementation. Since context creation and GTK window management is really strongly coupled in general and even more so in SWT, I will abandon the initial idea of decoupling context creation from windowing for SWT - it simply seems not feasible on Linux.\nSo, the design now got actually simpler, without any superfluous indirections. And everything now living in org.lwjgl.opengl.swt.\n. Glad you like it. Write if you need anything.\nHmm... now that I think of it, especially great would be the possibility to change display mode in a fullscreen SWT Canvas. SWT cannot do that currently, only AWT can. But we don't want AWT, do we? :) Will add that to lwjgl3-swt with a little help from @Spasi .\n\n[LWJGL], which of course is my preferred lib :)\n\nGive it a star, then. :)\n. Progress and further issues should be tracked on the lwjgl3-swt repository.. I am also in favor of not resetting the Buffer's position.\nRealloc is usually used in situations where one does not know the required size of a buffer when filling it and therefore need to dynamically grow the buffer as it reaches its capacity, like the example with the InputStream shows. And one generally wants to resume filling the buffer at the last position after reallocating it.\n. Aha, I could get away with the \"OpenCL has already been created.\" exception by specifying:\nJava\nConfiguration.EXPLICIT_INIT_OPENCL.set(true);\nAnd that NPE within Checks.checkPointer is actually for the first parameter platform of clGetDeviceIDs, which is allowed to be NULL as per:\nhttps://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetDeviceIDs.html\nI guess the \"If platform is NULL, the behavior is implementation-defined\" on OS X means: You'll get the default platform, whatever that is.\nCould the null-check for this parameter be disabled?\n. Thanks! Yes, I won't. Nvidia returns -32 (CL_INVALID_PLATFORM) with NULL platform.\n. I get this error, too.\nOnly happens when explicitly setting Configuration.LIBRARY_PATH to a non-null string.\nAfter looking into it, it happens, because the static initializer which runs this code happens before actually initializing/instantiating Library.LOADER_SYSTEM, which is used there.\nIt seems this can be fixed by moving the initialization of LOADER_SYSTEM and preferably LOADER_NATIVE to the beginning of the class.\n. Huh??? This is exactly the same as #112 , and you even commented on #112 with \"Thanks)\"...\n. Judging from the line numbers you are seemingly still using an old version.\nI confirm that the bug in #112 is resolved with the latest build # 3.0.0b build 58, 09 Nov 15 11:53. (download from lwjgl.org/download)\n. And it also does work with the latest lwjgl3 Maven library version 3.0.0b-SNAPSHOT from oss.sonatype.org.\n. > I've actually upgraded to a GTX a couple of months ago.\nNice. :) But you do have your old AMD ready in case one needs a standard-conforming card/driver, right? ;)\n. Yes, it is possible to pass the ownership of an OpenGL context between threads. Your observed behaviour also happens like that on Windows. This is because you must first explicitly detach the OpenGL context from a thread before making it current in another thread.\nRead the documentation of GLFW's glfwMakeContextCurrent.\nSo before making the context current in thread B you first have to call glfwMakeContextCurrent(0L) in thread A.\n. Sorry, just saw it is already there :/\n. > GL.createCapabilities(true);\nThat's interesting. In this case it might be desirable to not force the user to tell LWJGL that those functions should not be loaded because they would not be available anyways (i.e. lead to GL errors) when using a forward compatible context. Instead one could let LWJGL figure it out that such a context was requested.\nEither by intercepting the GLFW context window attributes or in the case of SWT have its context creation function notify LWJGL about it.\nOr another way would be to let GL.createCapabilities figure it out itself whether the active GL context is a forward compatible one.\nWhat do you think?\n. Yes, thanks. It does not work in Eclipse with source navigating. JavaDoc view works fine but not in-source navigating the link elements.\nAnd generating proper link targets with their parameter types and not relying on the first overload being the jump target in declaration order should be best practice.\n. No, it's probably not worth it if I'm being honest.\nSorry, I just want to give you the most possible feedback to \"improve\" LWJGL in any way I see. Of course I can only give you feedback how I see things. People might of course see things differently.\nThe proposition is just based on how I use JavaDoc. For once, I never spent any minute reading generated HTML JavaDocs of any framework/library I used, because one generally never knows which part of the documentation is the most valuable at the current situation. This can only be found when being in the IDE and start interfacing with the API in Java. And then, I find myself navigating through the API JavaDoc sources and its JavaDoc links to figure things out. That's just how I work.\nAnd then I found that following those link targets does not work in Eclipse, because it does not seem to follow the undocumented implementation convention of the JavaDoc tool to use the first overload method in declaration order.\nThat's just how that came up. :)\nDid not want to disrespect your work on LWJGL.\n. Thanks a lot! This is a great solution. Especially with the implicit JNIEnv parameter not being exposed in Java.\n. You could have fullscreen mode without display mode change in GLFW with using the GLFW_DECORATED = GLFW_FALSE window hint and using the resolution of the desktop display mode, like so:\nJava\nglfwWindowHint(GLFW_DECORATED, GLFW_FALSE);\nGLFWVidMode vidMode = glfwGetVideoMode(glfwGetPrimaryMonitor());\nwindow = glfwCreateWindow(vidMode.width(), vidMode.height(), \"Desktop fullscreen\", NULL, NULL);\nglfwSetWindowPos(window, 0, 0);\n. Can you try the following with the latest LWJGL3 night build 14? It should show a fullscreen window (at the desktop resolution) with some blueish color and with a crosshair cursor. It should also react on the ESC button by closing itself.\n``` Java\nimport static org.lwjgl.system.windows.WinBase.;\nimport org.lwjgl.system.windows.MSG;\nimport org.lwjgl.system.windows.WNDCLASSEX;\nimport org.lwjgl.system.windows.WindowProc;\nimport static org.lwjgl.system.windows.User32.;\npublic class DesktopFullscreenWindow extends WindowProc {\n    void run() {\n        long hInstance = nGetModuleHandle(0L);\n        WNDCLASSEX wcex = WNDCLASSEX.calloc();\n        wcex.cbSize(WNDCLASSEX.SIZEOF);\n        wcex.style(CS_HREDRAW | CS_VREDRAW);\n        wcex.lpfnWndProc(this);\n        wcex.hInstance(hInstance);\n        wcex.hbrBackground(3);\n        wcex.hCursor(nLoadCursor(0L, IDC_CROSS));\n        wcex.lpszClassName(\"MyLwjgl3WindowClass\");\n        if (RegisterClassEx(wcex) == 0)\n            throw new AssertionError(\"Could not register window class\");\n        int width = GetSystemMetrics(SM_CXSCREEN);\n        int height = GetSystemMetrics(SM_CYSCREEN);\n        long hWnd = CreateWindowEx(WS_EX_APPWINDOW, \"MyLwjgl3WindowClass\", \"Test window\",\n                WS_VISIBLE | WS_POPUP, 0, 0, width, height, 0L, 0L, hInstance, 0L);\n        if (hWnd == 0L)\n            throw new AssertionError(\"Could not create window\");\n        MSG msg = MSG.calloc();\n        while (true) {\n            while (PeekMessage(msg, hWnd, 0, 0, PM_REMOVE) == 1) {\n                TranslateMessage(msg);\n                DispatchMessage(msg);\n            }\n            if (msg.message() == WM_QUIT)\n                break;\n        }\n    }\n    public static void main(String[] args) {\n        new DesktopFullscreenWindow().run();\n    }\n    public long invoke(long hWnd, int msg, long wParam, long lParam) {\n        if (msg == WM_KEYDOWN && wParam == VK_ESCAPE)\n            System.exit(0);\n        return DefWindowProc(hWnd, msg, wParam, lParam);\n    }\n}\n```\n. That tells us that basic windowing works, since GLFW does that too in the same way (or maybe slightly different). However that also tells us that OpenGL context creation might be buggy.\n. What I'd do in your place is first to debug the program in Java. Step over each method invocation in your own class and see where it hangs. (unless the fullscreen window makes Windows unresponsive and not able to get back to the IDE, that is).\nIf that does not get you anywhere, you could use \"Visual Studio 2015 Community Edition\" and actually debug the native code of GLFW and see where that hangs. To do that you also need \"cmake\" to build GLFW locally with debugging information/symbols. Building GLFW yourself is really easy. It has documentation on how to do that with cmake.\nHaving a GLFW Visual Studio project/solution in place (which the cmake build gets you) you could then use the native GLFW API (which does not differ at all from the API exposed by LWJGL3) to build a Minimal Working Example in C to finally post that error as bug/issue with the GLFW project on GitHub.\n. Yepp, that's better. :) Like some GLUT application. The sources for fullscreen demo GLUT programs are out there in C. I could build some small executable for you.\nEDIT:\nThis (https://www.dropbox.com/s/4l8ms4llc8fq147/test.zip?dl=0) is a dropbox link to a zip file containing:\n- the test executable (32-bit Windows)\n- the shared library of freegut\n- the sources of the simple C file\nThe application should show a blue fullscreen window and respond to ESC by exiting.\n. That's what I wanted to test with the 32-bit version. Whether your SysWOW64 DLLs also cause this problem. Apparently, they do. :(\nThen the bitness will not make a difference, because it both happens with 32-bit and your 64-bit JRE with LWJGL3. Well, try to reinstall or upgrade the graphics driver.\n. Ah, okay. Thanks for the info and the example code!\nI went another route now by implementing a custom WindowProc class and then just delegate the invoke method to User32.DefWindowProc(hwnd, uMsg, wParam, lParam)\n. Hmm... no matter what I try, somehow CreateWindowEx will always error with 1407 -> \"Cannot find window class.\" (ERROR_CANNOT_FIND_WND_CLASS)\nDo you know what's wrong with this code?\n``` Java\nimport java.nio.ByteBuffer;\nimport org.lwjgl.system.MemoryUtil;\nimport org.lwjgl.system.Pointer;\nimport org.lwjgl.system.windows.User32;\nimport org.lwjgl.system.windows.WNDCLASSEX;\nimport org.lwjgl.system.windows.WinBase;\nimport org.lwjgl.system.windows.WindowProc;\npublic class WindowWin32 extends WindowProc {\n    public void run() {\n        ByteBuffer className = MemoryUtil.memEncodeUTF16(\"MyUniqueWindowClass1234\");\n        ByteBuffer windowName = MemoryUtil.memEncodeUTF16(\"MyWindow\");\n    WNDCLASSEX wnd = WNDCLASSEX.malloc();\n    wnd.cbSize(WNDCLASSEX.SIZEOF);\n    wnd.hbrBackground(1);\n    wnd.lpfnWndProc(this);\n    wnd.lpszClassName(className);\n    short err = User32.RegisterClassEx(wnd);\n    if (err != 0) {\n        throw new AssertionError(\"Could not register window class!\");\n    }\n\n    long hwnd = User32.CreateWindowEx(0, className, windowName,\n            User32.WS_OVERLAPPEDWINDOW | User32.WS_VISIBLE,\n            0, 0, 800, 600, 0L, 0L, 0L, 0L);\n    int lastError = WinBase.getLastError();\n    if (lastError != 0) {\n        throw new AssertionError(\"CreateWindowEx produced error: \" + lastError);\n    }\n    System.err.println(hwnd);\n}\npublic static void main(String[] args) {\n    WindowWin32 main = new WindowWin32();\n    main.run();\n}\npublic long invoke(long hwnd, int uMsg, long wParam, long lParam) {\n    return User32.DefWindowProc(hwnd, uMsg, wParam, lParam);\n}\n\n}\n``\n. D'oh. :( Now it works. Thanks!\n. That was quick. Awesome work! Thanks.\n. Erm... now it always complains whatever I do with User32 thatSetWindowText` is unavailable.\nLine 732 in User32.java:\nJava\nSetWindowText = checkFunctionAddress(provider.getFunctionAddress(\"SetWindowText\"));\nStacktrace:\nException in thread \"main\" java.lang.ExceptionInInitializerError\n    at Win32Window.run(Win32Window.java:21)\n    at Win32Window.main(Win32Window.java:37)\nCaused by: java.lang.IllegalStateException: This function is not available.\n    at org.lwjgl.system.Checks.checkFunctionAddress(Checks.java:86)\n    at org.lwjgl.system.windows.User32.<init>(User32.java:732)\n    at org.lwjgl.system.windows.User32.<clinit>(User32.java:757)\n    ... 2 more\n. When I append a 'W' suffix to all failing lookups, it works. I had to change the following function names to make it work (append 'W' suffic):\nSetWindowTextW\nGetMessageW\nPeekMessageW\nDispatchMessageW\nSetWindowLongPtrW\nGetWindowLongPtrW\nSetClassLongPtrW\nGetClassLongPtrW\n. Now only two more and then I have everything that I had with a past LWJGL3 beta/alpha release for the D3D11 binding window creation:\n- User32.LoadIcon\n- User32.LoadCursor\nBut so far Win32 programming with LWJGL3 feels great! :D\n. Just some info: \n\nSadly GLFW does not support touch at the moment...\n\nThat was untrue. It turns out it does have some touch support in the \"touch\" branch.\n. According to this: http://stackoverflow.com/questions/2382464/win32-full-screen-and-hiding-taskbar#answer-5299718\na proper fullscreen solution might also need:\n- User32.SendMessage()\n- User32.GetMonitorInfo()\n- User32.MonitorFromWindow()\n- User32.GetWindowPlacement()\n- User32.SetWindowPlacement()\n- User32.IsZoomed()\n. Thanks alot for adding this so quick, again!\nHowever, I cannot set any fields on the MONITORINFOEX struct. I need to set at least the cbSize field, but there is no setter for it, only an instance and a static getter.\nEDIT: Or is the size being set implicitly internally in LWJGL?\nEDIT 2: Ah no, a quick check with the cbSize() getter returns 0 and consequently User32.GetMonitorInfo fails with it\n. Ah, it seems to be because of that \"mutable = false\" on the struct definition in the kotlin template.\nThat is good, and can stay this way, if we could automatically let LWJGL compute and set the cbSize, which is present in many structs that can be \"extended\"/subclassed.\nBut since LWJGL would probably provide each such overwrite/subtype as a separate struct definition, it can also calculate and set the cbSize field on instantiation of that struct.\nExamples of such structs are:\n- WNDCLASSEX (extension of WNDCLASS).\n- MONITORINFOEX (extension of MONITORINFO)\n. Cool. Next problem is ChangeDisplaySettingsEx. Its first parameter LPCTSTR lpszDeviceName allows null, but LWJGL crashes with a null ByteBuffer.\n. Also I think the CharSequence overload is a bit dangerous. When invoked with null the __buffer.stringParamUTF16(lpszDeviceName, true) will return -1 and then the address is __buffer.address(-1) o.O\nCharSequence overloads of other methods seem to use __buffer.addressSafe(value, offset) for that.\n. Ah, sorry, it was fixed with your last commit also.\n. Okay, everything working great so far. Fullscreen SWT application at 640x480 :)\n. Erm... I get the exact same error too, now with the latest sonatype deployed 3.0.0-SNAPSHOT version.\nEverything was working fine until a minute ago because I was using self-built lwjgl3. Now that I use the sonatype-provided version, no applications work anymore. :(\nRight the first GLFW call to glfwSetErrorCallback freezes the process for about three seconds and then crashes the JVM without it producing a hserrlog. Very strange.\nEDIT:\nI tried with jdk1.6.0_45, jdk1.7.0_79 as well as jdk1.8.0_66.\nSame results: Process freeze for about two-three seconds and then the process goes away hard without the JVM even noticing it.\nOS: Windows 7, 64 bit\nEDIT2: Debug output is:\n[LWJGL] Version: 3.0.0 build 13\n[LWJGL]      OS: Windows 7 v6.1\n[LWJGL]     JRE: 1.6.0_45 amd64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v20.45-b01 by Sun Microsystems Inc.\n[LWJGL] Extracted shared libraries to: C:\\Users\\kai\\AppData\\Local\\Temp\\lwjglkai\\4c54c88e\n. Okay, the process dies away while trying to load the native library \"lwjgl\", so not while trying to execute a JNI call.\nI put a method entry breakpoint at System.loadLibrary. Actual argument to System.loadLibrary is the string lwjgl.\nThis is the stacktrace from the debugger while being trapped at System.loadLibrary before the crash. When I step over there the process crashes:\nThread [main] (Suspended (entry into method loadLibrary in System)) \n    System.loadLibrary(String) line: 1028   \n    Library.loadSystem(String) line: 97 \n    Library.<clinit>() line: 48 \n    MemoryUtil.<clinit>() line: 56  \n    Closure.<clinit>() line: 57\nMaybe you could provide a non-UPX'ed version of the library and one with debugging symbols, so that I could attach to the process and debug the native code?\n. Okay. I upx'ed my VS2013 build with upx -9 too, that however still loads fine.\n. Build 14 works. Thanks!\n[LWJGL] Version: 3.0.0 build 14\n[LWJGL]      OS: Windows 7 v6.1\n[LWJGL]     JRE: 1.6.0_45 amd64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v20.45-b01 by Sun Microsystems Inc.\n[LWJGL] Loaded library from java.library.path: lwjgl\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n[LWJGL] Loaded native library: D:\\workspace-neon-M4\\lwjgl-libs\\lib\\jemalloc.dll\n[LWJGL] MemoryUtil allocator: JEmallocAllocator\n[LWJGL] Loaded native library: D:\\workspace-neon-M4\\lwjgl-libs\\lib\\glfw.dll\n[LWJGL] Loaded native library: opengl32.dll\n...\n. > GLFW Error: The GLFW library is not initialized\nYou did not call org.lwjgl.glfw.GLFW.glfwInit().\n. The error message is plain and clear: \"GLFW windows may only be created on the main thread\"\nThe main thread is the thread that runs your public static void main(String[] args) method.\nYou however immediately spawn a new java.lang.Thread in which you do everything.\nDon't do that. :)\nSimply run all your code on the main thread and don't spawn a new Thread.\n. The flashing is likely because you don't actually render anything and the backbuffer contains garbage. You should at least GL11.glClear(GL11.GL_COLOR_BUFFER_BIT) the backbuffer before swapping buffers. But for this you must also initialize LWJGL properly. See the getting started guide again for how to do that.\nThat run method comes from the java.lang.Runnable interface, because your class implements that. That can be removed. It was needed in order for the spawned Thread to execute.\n. I think @kenzierocks wasn't extending the inner classes of Closure, but subclasses of Closure themselves, such as GLFWFramebufferSizeCallback, which is very common, like so:\nJava\nglfwSetFramebufferSizeCallback(window, fbCallback = new GLFWFramebufferSizeCallback() {\n    Float notYourJavaFloat;\n    public void invoke(long window, int width, int height) {\n        // Do something with notYourJavaFloat\n        notYourJavaFloat += 0.2f; // <- compile error. why?! Oh, not actually java.lang.Float\n    }\n});\n. In the root directory of your checkedout lwjgl3 sources do this on the command line:\nant compile-templates generate\n(requires an internet connection).\nIf that says that the command \"ant\" was spelled wrongly or could not be found, download Ant, have it in your PATH and execute above command again.\nYour IDE will also be able to execute ant buildscripts, but how to do that depends on the specific IDE.\nThat will get rid of the Java compile errors but in order to execute the demos you still need the native library of lwjgl3. Better to just download that from the lwjgl.org site.\n. Oh, and please add User32.SetLayeredWindowAttributes() :)\n. Sorry, didn't see the native API is in another GLFWNativeWin32 class and not GLFW :(\n. This is definitely a bug in GLFW. You should post it there, if it has not already been reported. It is also very simple to reproduce, so it should get quick attention.\nHowever it is still questionable whether you should do something like this (initializing and terminating whole GLFW) multiple times in an application.\n. Indeed this can be reproduced with the current master of GLFW at 386b603 using this native app:\n``` C\ninclude \ninclude \nint main(int argc, char** argv) {\n    int succ = glfwInit();\n    fprintf(stderr, \"%d\\n\", succ);\n    glfwTerminate();\n    succ = glfwInit();\n    fprintf(stderr, \"%d\\n\", succ);\n    glfwTerminate();\n}\n```\nIt prints 1 followed by 0.\n. I can confirm that the fix https://github.com/glfw/glfw/commit/f7228bb56294714e8cdb8b39be3b7c6967240c54 in GLFW does fix this issue. We just have to wait for a new LWJGL build to appear. :)\n. The utmost respect to you, @Spasi , and all the sympathy for pulling this off and realizing a 631 pages spec with LWJGL. :)\nI mean, it took a lot of time and effort for you guys to fully reflect the OpenGL API.\nBut now that there actually are C header files for Vulkan, it'd probably be good to first invest (if not already happened) to some automatic C header file to Kotlin template files generator?\nPersonally, I really don't expect anything finished for until a year from now on, because it looks like a huge amount of work, especially with the documentations.\nBut it'd be great of course if there will be. Happy coding! :)\n. I'll see if I can help you with that. I started a clang project for that some months ago, which however made use of clang as a command line tool and interfaced with its printed AST output to parse that.\nBut that might not be your preferred solution, of course.\n. It builds flawlessly under cmake 3.5.0-rc3 and msvc 2015 x64.\nBut so far the spirv-as tool fails to recognize any spir-v example file I feed it with.\nEven the one on the SPIR-V specification is rejected.\nEDIT: Adding a single empty new line at the end of the spir-v assembly source file fixed it. So it basically works. Only desperately needs a newline at the end of the input. :)\n. Okay, the actual C API is braindead simple. Probably the most common usecase (to assemble a spir-v assembly text into binary) is done like this: https://github.com/KhronosGroup/SPIRV-Tools/blob/master/tools/as/as.cpp#L130-L140\n(and additionally the call to spvBinaryDestroy())\n. Are you actually planning to use LWJGL for a real project? Just asking, because the confronting tone in your posts so far make it apparent that you don't want to do anything real with LWJGL, but instead just tell how terrible you think everything is and to grind up on such minor things as the binding strategy used in LWJGL.\nWhy does it bother you to have glBegin when you import GL11 for GL_ARRAY_BUFFER?\nIn my opinion it does not make the binding terrible or hard to use in any way.\nIt's not like you use LWJGL to actually learn OpenGL and help you avoid its pitfalls. There is better documentation for learning OpenGL than the IDE's auto-complete on the LWJGL API.\n. Instead of trying to find ways to extend a LWJGL class to bring its GL methods into scope, why didn't you just search GLES20. in your OpenGL ES application sources and replaced it with the empty string and then just import static org.lwjgl.opengl.GLxx.* for every needed GLxx class.\nThat'd work too, I guess. No need to manually lookup the correct GLxx class for a given OpenGL function and use GLxx.gl....\nI am not saying which way is best, just trying to plot a way for you to work with the current binding strategy.\n. In OpenGL only those OpenGL objects can be shared which are not container objects and which hold data on the server-side/graphics card. This means that, like @ppiastucki said, VAOs are not shared because it is a container object and references other objects. This also means that in OpenGL 3.0+ FBOs are not shared.\nSee: https://www.opengl.org/wiki/OpenGL_Object#Object_Sharing\n. With me, in about 90% of executions of a LWJGL3/GLFW application, glfwInit() also crashes when executing the application the first time after a PC boot. I thought this was strange, but it only ever happens only the very first time I execute any application after a boot/reboot. The next executions are fine.\nThat's why I thought \"ah, what the hell. be it like it be.\"\nBut now that you provided the debug DLL I might have a look at it, too.\n. Also it seems that the explicit parameterized type arguments on those get() method invocations are redundant. At least Eclipse flags them as redundant, because the static Configuration field is already type-parameterized.\n. > all three of those are basically just key-value pair mappings\nConceptually, you are right. But in practice there is much more to that than simply saying \"this format is just a mathematical tree structure, so it is just as good as any other format.\"\nLike kappa said, with XML (for example) there are uncountably many IDE plugins, validators and transformation tools already existing that can be let loose on the data and that can aid in authoring the templates and in transforming them. Just think about XSLT to transform XML templates into Java sources or HTML documentation output or use XSL-FO to build printable PDF documentation documents, which would be one possible argument for using XML. (not saying that you should use that!)\nYou simply don't have any of that with a custom format.\nYou have to work everything from scratch and do everything by yourself, starting with a grammar definition which you, if you're smart, define in some form of EBNF and let a parser generator generate a working lexer, parser and AST for you. By no means would you implement a lexer and parser by hand.... :)\nSo, like kappa said: Be smart and use a format that already has a healthy ecosystem around it.\n. I am quite interested in this, too. Just to make sure that I would not invest time needlessly into JOML redesigning/extending it to make use of Java arrays, I would like to gather some benchmark results from users interested in using JOML with LWJGL 3.\nI created a small JMH benchmark project here: https://github.com/JOML-CI/joml-bench\nI would request for anyone interested to just download and run the prebuilt jar file and post their results into this GitHub issue.\nYou don't have to mention your hardware stats, and also not the exact numbers if you don't want to. Just which test performed better. Higher numbers (ops/s) are better.\n. JNA is slower than using handwritten/generated JNI. JNA just allows bridging Java and native without writing native code ourselves. And that comes at a price, because the lowest denominator is just JNI. Everything wanting to bridge between Java and native has to use JNI. JNA simply has its own \"hub\" JNI dispatcher function and we pay the price for having JNA store the call arguments in its own data structure. Yes, it uses FFI, but that also adds to runtime.\n. You can create slices/views of the same Buffer and use those as the separate buffer arguments:\nJava\nIntBuffer major = ...;\nIntBuffer minor = major.slice();\nminor.position(1);\nIntBuffer rev = major.slice()\nrev.position(2);\nIt looks a bit ugly, but works. :)\nIf you don't like to do that, then I find that those 'n' methods are exactly the right thing to use when wanting to do this manual Buffer aliasing. Also, in general for every other method that happens to take two or more NIO buffers as out parameters, how would LWJGL know that you wanted to store all out values in the same buffer?\n. It should be: System.out.println(glfwInit ? \"OK\" : \"ERROR\");\ntrue means \"success\" = everything okay.\n. This is something which a layered library on top of LWJGL should be responsible for. Not LWJGL itself. IMO, LWJGL should be as lean and mean and close to native code as possible. Any fancy OO and convenience stuff like easy to use factory methods and ways to translate vk error codes to Java exceptions should be in another library.\n. > Really nice that NativeResource implements Closeable, now Eclipse warns me if any resource wasnt closed, didn't noticed I was leaking a GLFWVidMode instance\nAttention. You are not leaking this java.lang.AutoCloseable. It is allocated by GLFW. Freeing it will potentially crash your application. Better disable this warning in Eclipse. See: https://github.com/LWJGL/lwjgl3/issues/186#issuecomment-213733539\n. I think your post touches two things, which I'd like to address separately.\n1. Project scaffolding/setup\n   This can certainly be done for different IDEs and build systems and be put into a GitHub repository.\n   Like you mentioned, the lwjgl3-demos repository does this with Maven, but people may use Gradle or wish to have a readily usable IntelliJ, Eclipse or NetBeans project.\n   Providing this should not be a problem.\n2. Simple examples/demos\n   It is hard to know in advance what people would like to learn about OpenGL to make a sufficiently simple demo that addresses this aspect. Like you mentioned, the lwjgl3-demos tries to contain single-file demos addressing various aspects. And I promise you that these demos will always be kept in sync with the most recent LWJGL version. Maybe you could tell what you'd have liked to be in there?\nAnother aspect which I read between the lines is: Learning OpenGL.\nYes, learning OpenGL is hard. It is a very complex industry standard API that takes years to learn and alot of practice/experimenting. I think that, as much as all the nice tutorials/books/videos/... try to ease this learning process, the amount that has to be learnt is still the same and it is indeed hard.\nRegarding what demo to pick: With the complexity and versatility of OpenGL comes the fact that different people want to learn different things, based on what they want to achieve or already know.\nIn my opinion, the only point that can be addressed successfully is providing scaffolding/setup, so that people at least don't have to fight with their IDEs anymore. :)\n. I'd like to also throw JOML's demo repository in here. It contains some \"camera\" demos, such as the FirstPersonCameraDemo where you can walk around or the ShaderExample with a rotating cube.\n. I agree. Also in order to fully implement #100 the way I envision it, we would need some small start project packed alongside the packaged modules/dependencies to get people going.\nAgain I'd like to refer to how Spring Initializr does it, which provides a working (very small) demo program which can be started right away. That demo program however does not depend on the actually selected modules/dependencies.\nWe could do better and provide a starter example for a few of the most frequently used module combinations, such as OpenGL + GLFW + stb.\n. In my opinion, the goal should not be to provide people with whole render or game engines. Neither should the goal be to teach people OpenGL/OpenAL/Vulkan/.... There are better resources for this.\nIn my opinion, the most important thing a starter kit should offer is to show the design decisions and concepts of LWJGL 3:\n- direct NIO buffers as out-parameters\n- memory management with BufferUtils/MemoryStack/MemoryUtil\n- how to use structs\n- callbacks\nWe should focus on getting people to understand the design decisions made by LWJGL 3 so that they can feel comfortable using the various libraries without being surprised by unknown constructs/concepts.\n. As a first quick proof of concept: https://github.com/httpdigest/lwjgl3-cli\nThis currently only supports up to version 3.0.1-SNAPSHOT. Support for the new module system in #100 will be added once that is done.\n. Creating Maven projects is already supported. Next step is ~~native IntelliJ projects~~ Gradle support.\n. Generating proper Maven, Gradle and Eclipse build files is in now. Currently, the set of needed artifact ids (\"lwjgl\" and \"lwjgl-platform\") are fixed, because there are currently no dependency management information in the deployed Maven pom.xml files. That is also the goal of #100 to provide these.\nThe Maven, Gradle and Eclipse build/project files have the needed jar and natives for the platform which the cli tool is invoked on.\nIn the future when #100 is properly implemented, the user will also have the ability to select all platforms to generate a project for.\n. Thanks for giving feedback!\nI agree with you that there are ways to accomplish everything using existing tools, or requiring the user to look up a documentation. This is the case with every CLI tool for any framework I know of.\nWhile your argumentation revolves mostly around using Gradle, I thought of users who don't like to do this. People who want to get going with LWJGL3 in the quickest way possible and basically only know about Eclipse or their IDE of choice.\nTo get those people going it likely means scaffolding an IDE project right away. No Gradle or Maven installation. The CLI tool targets this audience.\nI do agree that using Maven and Gradle in the long run would be benefitial for everyone in any project. That's why the CLI tool also generates Maven and Gradle build scripts.\nIndeed, the goal is to use the experience earned in developing that CLI tool for building the web application. And there on the backend, using the services Gradle provides is sure the better way, I agree.\nI could also think about the CLI tool being a simple HTTP client for the web application in the future, only requesting the web application to generate a distribution and downloading that. Thus making it a true command line \"interface\", in the truest sense of the word, by interfacing the backend services, and not providing any services itself.\n. Stopped development of the cli, because LWJGL now has a nice download site.. Sounds good. If people stick to deploying to a Maven repository (can also be done with Gradle) then the only thing necessary is a sources jar. Such a sources jar will for example be built when using the Maven Source Plugin.\nThe current idea is to automatically download that sources jar from the repository, unpack it and use that as the content of the \"src\" directory in a downloaded LWJGL3 project zip, along with the LWJGL3 libraries.\nSo, preferably you also have a hosted source repository somewhere to look at and test a build, and also to direct interested users to.\n. It should be noted that there is also issue #199, which discusses possible starters. This issue here is rather meant to document the design and the progress on a system that supports centralized management of such starters.\n. The Raspberry Pi 3 is a 64 bit system and you probably do not have a cross-compile toolchain installed, but also don't need any. Just leave the \"-m32\" out. It should produce 64 bit binaries then.\nThe Pi also has an ARM cpu and no x86, so it has no SSE. Try -mfpmath=neon or -mfpmath=vfp. Also remove the -msse and -msse2.. Ah, never mind. Was mixing up Maven dependencies with local lwjgl3 project sources.\n. Thanks for reporting! This was indeed a bug in the demo.\nShould be fixed by https://github.com/LWJGL/lwjgl3-demos/commit/ae5added4bf731b67f74ed629d7b01d39d58423e.\nThough this issue should've been posted to the lwjgl3-demos repository. Probably, @Spasi can move it there.\n. I just noticed that the style of memory allocations done in these demos is now rather discouraged. Instead of manually allocating and freeing the NIO buffers, better use the MemoryStack with the try-with-resources statement.\nSee the HelloWorld demo in the lwjgl3 repository.\n. Here is a simple test case that can be used to verify this: https://gist.github.com/httpdigest/e3144a96880ee518aae88960b987d59f\n(requires a C compiler)\n. Adding the native jar libraries to the normal Java build path suffices and should work.\nHowever, if you want to avoid having to manage the modules' jar files manually in Eclipse, the by far easiest setup would be to use Maven or Gradle.\nFor this, go to https://lwjgl.org/download , hit the \"Nightly\" tab, select \"Mode\" = \"Maven\" and copy the resulting \"Snippet\" into your pom.xml. Eclipse supports generating a scaffold pom.xml for you in the default installation, by simply right-clicking your project (either in \"Package Explorer\" view or in the \"Navigator\" view) and selecting \"Configure -> Convert to Maven Project\".\nNow you can just paste the Snippet from the lwjgl.org/download site into the generated pom.xml as child of the  root element and you will automatically get a working setup.\n. Does it happen with native GLFW applications, too?\nI prepared a simple test which in essence does the same as the lwjgl3-demos Multithreaded application. (except it just swaps buffers)\n64-bit Win32 exe download here (statically linked against msvc 2015 runtime): https://www.dropbox.com/s/4nvducku9moxqbx/glfwtest.exe?dl=1\nSource code: https://www.dropbox.com/s/9rda5rkiehucpay/main.c?dl=1. As luck would have it, this already exists, contributed by @code-disaster ! :)\nLook at the https://www.lwjgl.org/download page, hit any of the three versions and observe that \"steamworks4j\" can be selected in the \"Addons\" section.. I adapted LWJGL's GLUtil class to this: https://gist.github.com/httpdigest/5178da20f32b05700e7f957cdbdc94e8\nto synchronously get an exception stack trace.. Yeah, sorry. The DebugCallback implementation in the Gist should of course first check for \"ERROR\" type and only then throw the exception. I modified the linked code, also including proper license.\nIf by notification messages you mean something like this:\nNOTIFICATION API OTHER: Buffer detailed info: Buffer object 1 (bound to GL_ARRAY_BUFFER_ARB, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.\nthen this is normal and can be ignored.. I think the goal was never to make the method names consistent with the Java conventions. (it's a mere coincidence that the OpenGL function names comply with that).\nThe goal has been to have the names identical to their native function names, which LWJGL provides bindings for, so as to simplify porting C/C++ code to LWJGL/Java.. In the first pom.xml you are not using the same version for the natives than what you use for the Java class jar files. You also see [LWJGL] [WARNING] Mismatch detected between the Java and native libraries. in the log. This means that LWJGL3 is picking up natives from another version than the Java classes it loads from the jar files.\nAlso: With LWJGL3 you don't have to unpack the natives or do anything to the natives anymore. You can just add the jar files containing the natives to the classpath and it will work.\nNeither do you need to set -Djava.library.path or the LWJGL counterpart. That might probably be the issue why the natives are still wrong with the second version.. > But creating a single, runnable JAR that can directly be deployed to the \"end user\" is not possible\nIt is possible. See for example the lwjgl3-demos pom.xml.. > ... but https://github.com/httpdigest/lwjgl3-awt basically seems to work\nIf you plan to release your app for Windows only, then yes. :). As far as the question of simple deployment (with an assumed JRE being installed on the end-users system) is concerned: You already have a solution for this, right? If you work with Maven you can just use the Shade plugin. Gradle has this also (Shadow plugin). And every IDE provides a way to export a run configuration as a standalone jar, too.. > The best thing would be if Java started allowing to load natives from memory, as in System.load(byte libraryData[]) or even from the JAR, as in System.load(URI resourcePath), but I assume that there are reasons of why this is not possible (security issues, probably).\nYes, that would be nice. But fyi, the reason why this is not supported is that the underlying platform (Windows, Linux, ...) does not support loading and linking shared libraries from memory. It always needs to be a file on the file system, accessed via file system operations. At least this is the case for Windows and Linux.\nWhile it always is possible to load executable code at runtime from memory, you cannot load and most importantly link a shared library (PE or ELF format) from memory.\nIf Java were to support it, the JVM would also need to go the way through a temporary file much like the SharedLibraryLoader.\n\nEven though such a solution does not exist yet, I'm pretty sure that something like this (only better) will be available in the near future.\n\nSince it is not a problem with Java, but with the OS, don't hold your breath for it.. There are other problems to be solved for this to work, of course:\n- defining what \"compatibility\" actually means: mere binary/signature compatibility or semantic compatibility (methods still behave in the same way), both of which can be defined as an API break\n- either actually following a semantic versioning scheme (by which today LWJGL would probably called LWJGL 74)\n- or: maintaining and deploying a compatibility matrix (declaring whether it is actually okay to just \"swap out\" one library for another). Are you on Windows and does your installed Nvidia driver version happen to be 378.49?\nIf so, then see:\n- http://forum.lwjgl.org/index.php?topic=6439.msg34284#msg34284\n- http://forum.lwjgl.org/index.php?topic=6443.0\nIt is a bug in Nvidia's driver and Nvidia is aware of this.\nOne solution is to start your Java application on the command line via java.exe .... It is very important to name the .exe extension after java.. > Revert change to FindClass\nIs there a reason why we would want FindClass to actually return a long, when Class/jclass is a supported JNI type and would also allow the GC to track references without having to make a global ref?. > You cannot use a plain jclass reference outside the JNI function that created it (either via FindClass or by passing a Class instance). A global reference is absolutely required if the jclass handle must be cached somewhere else (because FindClass is expensive).\nThat is actually not at all true. A global reference is only required iff the reference to the jclass escapes the JNI method other than through its return value. Returning a jclass local reference from a JNI function (or any local reference by the way) is fine.. > Returning a jclass local reference from a JNI function (or any local reference by the way) is fine.\nI should add to that, that this of course only works iff the Java-side return type of the Java method is a Java reference type, and not a primitive type such as long, which is the reason why you had to put NewGlobalRef to the original FindClass method. Because it returned a primitive long.. Yes, that's much cleaner. Nice!. You are missing this in your org.lwjgl repo's pom.xml:\nxml\n<repositories>\n  <repository>\n    <id>oss.sonatype.org</id>\n    <url>https://oss.sonatype.org/content/repositories/snapshots/</url>\n    <snapshots>\n      <enabled>true</enabled>\n    </snapshots>\n  </repository>\n</repositories>\nPeople with a clean Maven local repository are otherwise not able to build your project.. I see you are using some sort of synchronization/lock. Are you calling all GLFW.glfw*() methods only on the main thread?\n(the thread that the public static void main(String[] args) method is called in at the start of the JVM)\nEDIT: Okay, you are not. You must call GLFW methods only on the main thread.. > glfwWindowShouldClose can be called from any thread according to the Javadocs, so that shouldnt be an issue..?\nOh yes, you're right.\nWhat's strange is that in the video the window does close but the process does not end. The window only closes when either the JVM/process exits or the user application calls glfwDestroyWindow() explicitly itself. Neither happens with you, it seems.. I think I know what happens:\n- the main thread sees that the window should be closed (Renderer:32 ends the loop)\n- then the main thread destroys the window (Renderer:40) and afterwards also terminates GLFW\n- now the spawned thread takes another turn at Renderer:141 but the window is already gone (and probably the memory freed), thus it works on garbage memory. You mean, the boolean destroyed field will be set to true by the main thread once the window is being destroyed/closed, but the spawned thread still sees false?. In the meantime you can switch to \"Maven\" or \"Gradle\" mode on the download site and simply create a Maven or Gradle project, which is also by far easier than configuring the individual module artifacts.\nInstructions can be found here: https://github.com/LWJGL/lwjgl3-wiki/wiki/1.2.-Install#gradle-or-maven. No need for further head-banging All overloads of that method have their uses. But you should use this overload instead when you are using buffer objects and not client-side arrays.. It of course depends on the exact usecase:\n1. if you have an off-heap source memory address and an off-heap destination memory address and want to copy contiguous arrays of memory to copy, then MemoryUtil.memCopy() is probably fastest\n2. if you have an on-heap source Java array and an off-heap destination memory address then using Buffer.put(array) is probably fastest (maybe MemoryUtil has other methods accepting Java source arrays)\n3. if you have an off-heap source memory address and an on-heap destination Java array then using MemoryUtil to create a NIO Buffer and then using method 2 is probably fastest.\n4. if you have an on-heap source Java array and an on-heap destination Java array then probably System.arraycopy is fastest\n5. if you cannot copy contiguous ranges of memory from source to destination but must put individual values into an off-heap destination address, then using MemoryUtil.memPut*(offset, value) is probably fastest.\nThere are probably other cases I missed.. BufferUtils.createFloatBuffer(1).put(1.0f)\nThis is wrong. You must .flip() the buffer so that it has a remaining() of 1.\nOr use the absolute method:\nBufferUtils.createFloatBuffer(1).put(0, 1.0f). Of course there can exist multiple OpenGL contexts at the same time. However an OpenGL context is inherently not thread-safe and therefore only one thread can access the same OpenGL context at any given time. It is up to you which thread that is (can be changed).\nOpenGL uses thread-local memory to keep track of which context is associated with the current thread to direct OpenGL API calls to the right context (in case OpenGL function addresses are the same for all OpenGL contexts) and to enforce this single-threadedness. This goes in cooperation with the windowing subsystem of the operating system, such as WGL on Windows or GLX on Linux, which provide methods (such as wglMakeCurrent - wrapped via GLFW's glfwMakeCurrent) to switch the current thread of the context associated to a given drawable/window.. > I think the CPU time spent is way more important given it can shave off half of your expected rendering time.\nFor static content there is always the obvious solution of simply rendering once into a (compressed) texture and drawing a texture-mapped quad afterwards.\nActually, I would have never imagined STBTrueType to be something which should recalculate and rerender the glyphs each frame. I would always bake it into a texture and render that texture then.. I cannot reproduce this.\nFor some reason, your IntelliJ is not putting the \"compile\"-scoped dependencies in the runtime classpath, which it must do (only 'compileOnly'-scoped dependencies are not put into the runtime classpath).\nOpen View -> Tool Windows -> Gradle in the menu and in the now visible \"Gradle projects\" view hit the \"blue rotating arrows\" button to reimport/refresh the Gradle project. And then try again.. > I can provide more info on my setup if needed.\nIt certainly is needed. What OS, what CPU arch, etc. However, this seems more like a GLFW issue than one of LWJGL 3. You should instead clone the GLFW repo, build their native examples and see whether running them also takes seconds. If so, open an issue with GLFW and detail exactly your system specs and the exact steps to reproduce the behaviour.. Please provide a single-file MCVE. From the information you gave it is impossible to diagnose the problem.\nBut the odds are very much that you have an (OpenGL) error somewhere in your code.. To rule out some possible errors (like not calling GL.createCapabilities() - even though the original class did it correctly) or ignoring GL errors, you can download this jar and run your app via the VM argument\n-javaagent:debug.jar (where debug.jar resides in the current working directory of the application) and see what gets output.\nIf you don't know what a VM argument is or how you can set it on the command line or your IDE, please Google for like \"Java pass VM argument command line / \\<your IDE>\".. Lookup what the Markdown syntax for code blocks is. It is not a single backtick. It is three backticks plus the language (i.e. \"Java\"). The reason why the rest seems to be code (which it is not) is because it is indented and will be Markdown-interpreted as monospace font text.. The reported error is correct. Your problem is this line:\nif (i == 0) { // Load Model only once, but I need a GL context\nYou have multiple OpenGL contexts which are completely independent of each other, so you cannot just glGenVertexArray() once in the first context. You have to do it in all contexts.. Please make yourself familiar with OpenGL first. There are ways to share the data in an OpenGL context between multiple OpenGL contexts. However, there are also limitations. You should really read up on that first.. Everything that represents actual data stored on the graphics card. That includes shaders, renderbuffers, textures and buffer objects. Things that typically are not shared are per-context \"bindings\", such as which vertex attributes are enabled and what source/pointers they are initialized with (for example from buffer objects), which index buffer is enabled, by extension of the previous also VAOs, what buffer objects are bound to the various buffer bindings, which shader is currently bound, which textures are currently bound to their various texture bindings, FBOs (since FBOs are also just binding state of renderbuffers/textures to FBO attachments), the states of all glEnable'able things, etc.. @Spasi and I already told you that VAOs do not get shared across OpenGL contexts. And yet, you still have if (i == 0) { // Load Model only once, but I need a GL context in there. That will not work. You have to create the VAO in each context. And you only have to create the VAO in each context. Creating and initializing the VBO can be done in just one context, since that is actual data that is shared across contexts.. Also, GitHub issues here is not about \"please teach me OpenGL and fix my code.\" It is for bug reports and feature requests. Stackoverflow would probably be better for you.. If you want you can use the latest version of debug.jar which now tells you what went wrong.. Are you sure that you are printing the GL_ELEMENT_ARRAY_BUFFER_BINDING exactly before the glDrawElements call?. You likely have more than 1 CPU core. So, the 1 thread (that one running the loop) alone cannot result in 100% CPU usage, since the other cores are more or less idle.. There are no ways to do this other than what is described here: http://developer.download.nvidia.com/devzone/devcenter/gamegraphics/files/OptimusRenderingPolicies.pdf\nAlso, the Stackoverflow answer you are referring to about WGL_NV_gpu_affinity mentions this: But it is only supported on QUADRO series. and hardly anyone has a Quadro card in their Laptops.\nHowever, I do, and I've tested WGL_NV_gpu_affinity on my Laptop, and funny enough, that extension is only exposed/exported by the driver iff you are already running on the dedicated Quadro card.\nSo, WGL_NV_gpu_affinity is really only meant to be used on workstations that have multiple Quadro cards installed.. Please note that even a native shared library will not help. The process module file must export that symbol. Even if lwjgl.dll did export it, it would not work. Your only option in that regard is to provide a custom java.exe/javaw.exe launcher, which is quite simple to do. Have a look at the JNI Invocation API.. glfwCreateWindow (read the section \"Thread safety\") as well as a lot of other GLFW functions may only be called in the main thread (which is the thread that initially calls your main method).\nAlso make sure you call glfwInit before doing anything with GLFW (except setting its error callback via glfwSetErrorCallback).. Thanks @sriharshachilakapati for inspecting and solving this!\nI've added a check for this potential error to https://github.com/LWJGLX/debug.. The msvc environment defaults to 32-bit/x86.\nIn order to switch to 64-bit/x86-64/amd64 use VsDevCmd.bat -arch=amd64. Duplicate of https://github.com/LWJGL/lwjgl3/issues/206. @AwfulMint I wonder how you got this information from JOML's wiki. There is not a single reference in JOML's wiki to LWJGL's MemoryStack or MemoryStack.stackPush() and nowhere is there a mention that this is \"the recommended allocation method\" (though it might be for small matrices).. There is nothing on the LWJGL3 side to \"support\" there.\nThe question is really only whether the version of your installed Vulkan validation layer supports this extension and whether your graphics card driver supports it.\nSince that error message seems to be generated by the validation layer, check the version of your validation layer.\nAlso, make sure that you actually enable that extension.. Yes, go back in Git history and use this revision: https://github.com/LWJGL/lwjgl3/tree/00e1f52cf95c16b0cea34c83372145532b4745ba/modules/samples/src/test/java/org/lwjgl/demo/nuklear. You should first use a memory profiler (such as JProfiler or YourKit - both available as fully functional time-limited evaluation versions) to identify the source (call stack) of the memory allocations.. The binding of nvgText() itself does not do anything, and what the implementation of nvgText() may do could not be picked up by any JVM profiler, so the assumption is that your own code is doing the ByteBuffer allocations. What is the exact callstack doing the ByteBuffer allocations?. If you call MemoryUtil.memASCII() indeed every frame, then that's the issue. You need to manually release the memory afterwards with MemoryUtil.memFree(). Or you may be better off using the MemoryStack. See https://blog.lwjgl.org/memory-management-in-lwjgl-3/ for more information.. I see. Well, then I'm out of ideas. You should just check the callstack of the memory allocations. You need to enable CPU profiling to see that. Consult the JProfiler documentation about that.. Cannot reproduce. The zip download contains only 52.0 class files as does the Maven Central download of the classes in the jar artifacts for version = 3.2.1.. > Since the Stencil Test is important\nImportant for what? Are you (not NanoVG) making active use of it in your own rendering?\nAdditionally, you haven't really given any hint to how the end result should look like. With the information given, I'd say the second image looks right. So just disable stencil testing. NanoVG enables stencil testing anyways for itself to work properly. See: https://github.com/memononen/nanovg#opengl-state-touched-by-the-backend\nIf you need stencil testing for your own rendering, then clear the stencil buffer and reset the stencil function and stencil operation accordingly for your own rendering.. The purpose of such demos/examples/tests is not to teach people about that library (or the bindings to the library) or to make those tests particularly readable, but rather to validate the basic functionality of the binding (such as to avoid regression when updating the library to a new version).\nIt's not in the scope of the LWJGL project to provide tutorial/guide-like demos to all the external libraries LWJGL provides bindings for.. ",
    "ghost": "This will be very helpful, my engine will support both DirectX12 and OpenGL 4.5 and i wont have to write the engine in 2 different languages\n. Oh, oops. The original code I had tested with had it allocated as 400 * 240 * 4 bytes, I just changed it accidentally when posting it here. Also, a rewind doesn't hurt, does it? It should only be setting the position back to 0 and removing any marks, which I didn't use in the example above.\nEDIT: Looks like I just forgot to allocate using BufferUtils. Sorry about that, I'll make sure to check things like that next time.\n. Oh my bad. It returns 1.20 and I only checked 1.5 and above. Thanks!\n. I mean fbdev or directfb, so you can play your game without X11\n. Yes I can, but beware it's scala code (shouldn't matter, Scala is creating JVM-Bytecode so this is really not a problem and it started to occur in one of the latest nightlies, but not before!)\nTest.scala\n```\nclass Test\n{\n  private val mainWindow: Window = new Window(1024, 768, \"Test\")\ndef run(): Unit =\n  {\n    try\n    {\n      mainWindow.init\n      mainWindow.update\n    }\n    finally\n    {\n      mainWindow.destroy\n      glfwDestroyWindow(mainWindow.id)\n      glfwTerminate()\n    }\n  }\n}\nobject Test\n{\n  def main(args: Array[String]): Unit =\n  {\n    new Test().run\n  }\n}\n```\nWindow.scala\n```\nimport org.lwjgl.glfw.Callbacks.\nimport org.lwjgl.glfw.GLFW.\nimport org.lwjgl.glfw.\nimport org.lwjgl.opengl.GL11.\nimport org.lwjgl.opengl.\nimport org.lwjgl.system.MemoryUtil.\nclass Window(val width:Int, val height:Int, val title:String)\n{\n  // Window id / handle\n  var id : Long = _\n  // Callback instances\n  val errorCallback: GLFWErrorCallback = errorCallbackPrint(System.err)\n  val keyCallback: GLFWKeyCallback = initKeyCallback()\nprivate def initKeyCallback(): GLFWKeyCallback =\n  {\n    new GLFWKeyCallback() {\n      override def invoke(windowHandle: Long,\n                          key: Int,\n                          scancode: Int,\n                          action: Int,\n                          mods: Int): Unit =\n      {\n        if(key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE)\n          glfwSetWindowShouldClose(windowHandle, GL_TRUE) // We will detect this in our rendering loop\n      }\n    }\n  }\ndef init(): Unit =\n  {\n    glfwSetErrorCallback(errorCallback)\nif(glfwInit() != GL11.GL_TRUE)\n  throw new IllegalStateException(\"Unable to initialize GLFW\")\n\nglfwDefaultWindowHints()\nglfwWindowHint(GLFW_VISIBLE, GL_FALSE)\nglfwWindowHint(GLFW_RESIZABLE, GL_TRUE)\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2)\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE)\n\nid = glfwCreateWindow(width, height, title, NULL, NULL)\n\nif(id == NULL)\n  throw new RuntimeException(\"Failed to create GLFW window\")\n\nglfwSetKeyCallback(id, keyCallback)\n\n// Get resolution of primary monitor\nval videoMode = glfwGetVideoMode(glfwGetPrimaryMonitor())\n// Center the window\nglfwSetWindowPos (\n  id,\n  (GLFWvidmode.width(videoMode) - width) / 2,\n  (GLFWvidmode.height(videoMode) - height) / 2\n)\n// Make the OpenGl context current\nglfwMakeContextCurrent(id)\n// Enable v-sync\nglfwSwapInterval(1)\n// Make the window visible\nglfwShowWindow(id)\n\n}\ndef update(): Unit =\n  {\n    GL.createCapabilities()\nglEnable(GL_TEXTURE)\n// Render window as long as user hasn't attempted to close it\nwhile (glfwWindowShouldClose(id) == GL_FALSE)\n{\n  // Poll for window events (key callback is only invoked here)\n  glfwPollEvents()\n\n  glfwSwapBuffers(id)\n}\n\n}\ndef destroy() : Unit =\n  {\n    Shaders.destroy()\n    keyCallback.release()\n    errorCallback.release()\n    glfwDestroyWindow(id)\n  }\n}\n``\n. Ah, well, ya... I see now. Thank you very, very much! That explains a lot... especially how that error came to be all of a sudden.\n.GLFWCursorPosCallback.release()is nowGLFWCursorPosCallback.free()` in the nightly build. Not sure about the window opening in the background though.\n. > For example org.lwjgl.opengles.GL33 does not contain a GL33.GL_ARRAY_BUFFER define.\nThats probably because org.lwjgl.opengles.GL33 does not exist. In OpenGL, GL_ARRAY_BUFFER is available under org.lwjgl.opengl.GL33. In OpenGL ES (the package you imported), it is available under org.lwjgl.opengles.GLES20. The javadoc covers this fully.\n. While it would be nice to see SDL2 get a working port to Java, I think it would be pointless in LWJGL as GLFW already handles everything in terms of window, input and context handling.\n. You're right. Still throws an exception for me. Java 8, precompiled LWJGL.\nThe error is a + instead of a comma in that version.\n. \nWell, I'm an idiot.. Is using struct.create okay though or should I use malloc for it?. Wow, that was quick.. Thank you very much!. Ah sorry, my version is actually 3.1.6, build 14, I was looking at wrong numbers. And here is output of java version\njava version \"1.8.0_162\"\nJava SE Runtime Environment (build 1.8.0_162-b12)\nJava HotSpot 64-Bit Server VM (build 25.162-b12, mixed mode)\nBTW, I am using Eclipse to build project. It is hard to tell, since the error dosn't display always. I had to test it multiple times and here are the results (numbers represent number of times tested):\n|             | No crash | Crash |\n|:-----------:|:--------:|:-----:|\n| Debugger    | 92       | 3     |\n| No debugger | 88       | 0     |. Ok, I'm closing this issue.. I got lazy on that last CLI bit. Which brought up another issue, easily fixed.  This is what worked for me:\njava -XstartOnFirstThread -cp \"./lwjgl.jar:./lwjgl-assimp-natives-macos.jar:./lwjgl-assimp.jar:./lwjgl-bgfx-natives-macos.jar:./lwjgl-bgfx.jar:./lwjgl-egl.jar:./lwjgl-glfw-natives-macos.jar:./lwjgl-glfw.jar:./lwjgl-jawt.jar:./lwjgl-jemalloc-natives-macos.jar:./lwjgl-jemalloc.jar:./lwjgl-lmdb-natives-macos.jar:./lwjgl-lmdb.jar:./lwjgl-lz4-natives-macos.jar:./lwjgl-lz4.jar:./lwjgl-nanovg-natives-macos.jar:./lwjgl-nanovg.jar:./lwjgl-natives-macos.jar:./lwjgl-nfd-natives-macos.jar:./lwjgl-nfd.jar:./lwjgl-nuklear-natives-macos.jar:./lwjgl-nuklear.jar:./lwjgl-odbc.jar:./lwjgl-openal-natives-macos.jar:./lwjgl-openal.jar:./lwjgl-opencl.jar:./lwjgl-opengl-natives-macos.jar:./lwjgl-opengl.jar:./lwjgl-opengles-natives-macos.jar:./lwjgl-opengles.jar:./lwjgl-openvr-natives-macos.jar:./lwjgl-openvr.jar:./lwjgl-par-natives-macos.jar:./lwjgl-par.jar:./lwjgl-remotery-natives-macos.jar:./lwjgl-remotery.jar:./lwjgl-rpmalloc-natives-macos.jar:./lwjgl-rpmalloc.jar:./lwjgl-sse-natives-macos.jar:./lwjgl-sse.jar:./lwjgl-stb-natives-macos.jar:./lwjgl-stb.jar:./lwjgl-tinyexr-natives-macos.jar:./lwjgl-tinyexr.jar:./lwjgl-tinyfd-natives-macos.jar:./lwjgl-tinyfd.jar:./lwjgl-tootle-natives-macos.jar:./lwjgl-tootle.jar:./lwjgl-vma-natives-macos.jar:./lwjgl-vma.jar:./lwjgl-vulkan-natives-macos.jar:./lwjgl-vulkan.jar:./lwjgl-xxhash-natives-macos.jar:./lwjgl-xxhash.jar:./lwjgl-yoga-natives-macos.jar:./lwjgl-yoga.jar:./lwjgl-zstd-natives-macos.jar:./lwjgl-zstd.jar:./lwjgl.jar:.\" HelloWorld. ",
    "saudet": "I believe what you are looking for is already available as JavaCPP: https://github.com/bytedeco/javacpp\nBut please do let me know of anything that you might need to make this useful for LWJGL! Thanks\n. I am basically aiming to make the Java interface file with annotations and such resemble a C/C++ header file as closely as could possibly be done in the Java language. It wasn't designed for anything else, but the C++ compiler does fail anyway when the types between the Java interface and the native header file don't match, so there is some type safety. Could you provide an example where it wouldn't work?\nYes, everything is generated from the header files, including the documentation comments yes. It doesn't do any fancy translation to accommodate Javadoc, just the minimum, but more could be done, that's the point.\nThe most complex C++ API I've dealt with until now is Caffe:\nhttps://github.com/bytedeco/javacpp-presets/blob/master/caffe/src/main/java/org/bytedeco/javacpp/presets/caffe.java\nThe C++ template instances are given names within for loops. :) For pure template libraries though it gets a bit more complicated. It seems like the best we can do is to let the user declare what they use. In the case of Thrust for example:\nhttps://github.com/bytedeco/javacpp/wiki/Interface-Thrust-and-CUDA\nWould you see a better alternative?\n. If we don't have header files for many of the extensions, how are C/C++ users supposed to use them in the first place? Whatever the mechanism, I'm sure we can do the same in Java, without any special functionality beyond what a tool like JavaCPP could provide automatically. And then, the point is that something like LWJGL could pick it up from there to provide a nicer Java interface, that has little to do with the native API.\nSo, I'm curious. What extension would best exemplify this lack of header files?\n. So, we could make our header files, right?\n. I've thought about this and it's really not about header files and the parser. I've designed JavaCPP so that we could use the C++ code generator independently from the C++ header file parser. So, in principle, it would be possible to have the Kotlin templates of LWJGL produce interfaces that are compatible with JavaCPP, and leave it generate the necessary code in C++. Why would we want to do that? Well, it would make it a lot easier for users to move data between Bullet, CUDA, OpenCL, OpenGL, OpenCV, DirectX, etc as easily as one could do it from C++, instead of having one API for LWJGL, another one for JCuda, another set for JavaCPP, yet another API for SWIG, etc. We don't need to make things more complicated in Java. We can make them simpler.\nSo, I would have one question. What would be missing from the C++ code generator of JavaCPP to make it useful as a target for the Kotlin templates? I know dynamic loading would be one of those things, but that can be added easily enough, so do you guys see anything else that would be missing?\n. The header file parser generates methods with Pointer arguments, as well as String and what not as appropriate. The C++ code generator doesn't care if we don't actually use any of them. Still, Pointer is more or less required for custom data structures. This might not be an issue with LWJGL, but even in the case of OpenAL/CL/GL, one might want to use them on Android, for example, where NIO buffers are inefficient. Instead, users might want to use a helper class like Pointer to copy data between native memory and the Java heap -- for better performance.\nConvenience methods like glGetInteger() and runtime checks could still be generated by LWJGL. I see no problem with that. Actually, that's exactly how I see the role of projects such as LWJGL: adapt C/C++ APIs in a way to make them Java friendly. That's not one of JavaCPP's goals. The main goal is to map native APIs as closely as possible to Java, and offer (eventually) a common foundation to projects like LWJGL. I'm pretty sure JavaCPP could be useful in one way or another for everything you list up there. I'm still trying to figure out what could be a \"deal breaker\"...\nThe generated C++ code isn't useful for users as reference, so I don't put it anywhere. It gets generated at build time when executing mvn install, so it can still easily be referenced by developers.\n. Sorry for the late reply. Been busy with things for the past couple of weeks.\n\nI don't see how using JNI calls without intrinsics won't result in bad performance.\n\nIt works fast when copying large enough arrays with memcpy() between Get/ReleasePrimitiveArrayCritical() calls. JNI intrinsics and method inlining are surprisingly inefficient on Android. There's no point in considering Buffer.get()/set() for pretty much anything on that platform: https://code.google.com/p/javacpp/issues/detail?id=11\n\nDynamic loading. This could be simple to support, assuming LWJGL does all the hard work and you only add an extra \"function pointer\" argument to the generated functions.\n\nOr the hard work could be done in C++, but that depends on the design obviously. There's a lot of factors to take into account. How have you been considering adding support for C++ to LWJGL?\n\nIt's useful to me as an LWJGL developer. The exact semantics are important (i.e. do you use GetDirectBufferAddress directly or respect the current buffer .position()?), performance is important, the native code size is important. LWJGL 3 has been written such that the generated native code is extremely simple, anything non-trivial is done Java-side. Having no special requirements from native code should (in theory) enable us to use whatever comes out of Project Panama with minimal effort.\n\nAnyone can easily have a look at the generated source code by running one of the small samples here:\nhttps://github.com/bytedeco/javacpp#key-use-cases\nI use GetDirectBufferAddress() directly because JNI does not provide an efficient way to query the position or the limit. Again, we can use Pointer for that. There's a lot of other use cases that Buffer does not support. Would you like to have a list of all that I can think of?\nI see that you try to avoid JNI and native code as much as possible. But this has drawbacks too. For example, it forces users to generate both Java code and C/C++ code. It does not allow them to write in Java directly some custom interface they might want to use, and provide documentation comments as they wish. That does not appear possible with the generator of LWJGL, or am I mistaken?\nBTW, I wouldn't count on Project Panana producing anything usable for C++. Although it appears promising for C functions, basically P/Invoke for Java, they are not considering what to do in the case of C++ classes. So, if your plan is to use Panama for C libraries, but JNI for C++ libraries, I'm afraid you would be breaking your rule of simplicity. Myself, I'd rather use JNI: It works, it's fast, it's portable, and can be used with any native language.\nAnother thing. LWJGL does not seem to provide good support for Maven. We have to add manually plugins to unpack native libraries. Do you have any plans to fix that? That's something else JavaCPP currently provides, so you could check that out for ideas.\n. > I haven't really. This issue exists just to acknowledge the fact that useful C++ libraries exist and we could maybe do something about it. That doesn't mean we will, unless the solution is decent feature- and performance-wise. It's perfectly OK if users have to use a 3rd party library, if we can't offer C++ bindings.\nJust for my information, do you consider something like JavaCPP to be not \"decent\"?\n\nJust had a look at the generated native code and there are many JNI calls in there. Instead of passing jobject arguments, you could very easily do the pointer math Java-side (address+position) and pass a jlong directly, like LWJGL does. For non-array access anyway, arrays need GetPrimitiveArrayCritical.\n\nNo, we cannot, not always. For example, how do you get the address of a direct NIO buffer in Java? AFAIK, it's only available through JNI.\n\nNot sure what you mean. Of course both Java and C code must be generated, JNI requires that.\nThe LWJGL generator is an offline process used when building LWJGL. It's different from JavaCPP, you cannot use the LWJGL artifacts to generate your own bindings. You can of course clone LWJGL and write a custom template for an API that LWJGL doesn't support out of the box, with custom comments, etc.\n\nYes, that's what I meant. This forces users to write all their code in Java. You do not offer them an option to rewrite their bottlenecks in C/C++, effectively forcing them to write JNI code themselves in those cases.\n\nAfaict, Panama will support C++ just fine. Why do you think it won't?\n\nBecause everytime I bring up topics related to C++ on the mailing list, I get blank stares.\n\n\nMyself, I'd rather use JNI: It works, it's fast, it's portable, and can be used with any native language.\n\nIt's neither fast, nor \"portable\".\n\nJNI works fine on Android, for example. Couldn't say the same of Panama. And why do you say it's not fast? Do you have some numbers to back this up?\n\nWith Panama, native calls will be \"visible\" to Hotspot. The JIT will be able to inline all the way to the native call and that means zero-overhead + heavy optimization potential.\nWith JNI you must deploy native binaries for all target OSes/architectures. With Panama, you won't have to deploy anything, it will work everywhere automatically.\n\nSure, like I said, that's great for C APIs. It's basically P/Invoke for Java -- but it doesn't work with C++.\n\n\nAnother thing. LWJGL does not seem to provide good support for Maven. We have to add manually plugins to unpack native libraries. Do you have any plans to fix that? That's something else JavaCPP currently provides, so you could check that out for ideas.\n\nFor Maven/Gradle, see this example project.\nAlso note that the official downloads do not have packed native binaries.\n\nSo you rely on badlogic to provide decent Maven support, I see. So, to answer my question, you are satisfied with this?\n. > Of course it's decent, that's what I mean by \"3rd-party libraries\". But I already explained why it can't be used with LWJGL.\nOk, thanks. I guess time will tell who is right :)\n\nUsing reflection or Unsafe. This is what LWJGL does.\n\nBut that makes it as inefficient as JNI while making it less portable in the process. What was the reason to not use the provided JNI function in this case?\n\nWhat's the problem here? If someone has the capability to write custom C/C++ code, writing the JNI glue code should be a joke. LWJGL is targeted to people that don't know or don't want to write and build any native code.\n\nWell, for example, if we want an application to run on Windows, Linux, Mac, Android, etc, JNI offers no tools to help us compile C++ code or manage the native libraries produced on multiple platforms. Someone who is knowledgeable in Linux does not necessarily know all the details of Windows, or vice versa. JavaCPP offers a solution to that. JNI by itself, or Panama for that matter, will not.\n\nI don't know, Oracle is not very eager to share details in general, especially so early in the development process of a JEP. Keep in mind that Panama is targeted for Java 10 at best. I personally haven't read anything that would suggest C++ won't be supported.\n\nThe fact that the foundation of Panama is basically LLVM, and its support for MSVC is still nowhere near usable http://clang.llvm.org/docs/MSVCCompatibility.html pretty much makes it unusable on the Windows platform. And I don't see Oracle bundling MSVC with Java... Or do you believe Oracle will ship their own C++ toolchain compatible with GCC, Clang, and MSVC? Or maybe there's something weirder going on in the background with Microsoft adopting Clang, and by the time Java 10 comes out...\n\nSee http://www.oracle.com/technetwork/java/jvmls2013nutter-2013526.pdf, page 62. There is a difference of course between fast and fast enough. JNI is fast enough for LWJGL to exist and be used since 2002. That's not the point. Any raw JNI overhead test will show a substantial, but probably low enough overhead over the corresponding C code. Who would want to call getpid a million times anyway. But that hides all the nastiness around it. JNI calls force instruction level serialization, force GC safepoints, cause extra cache polution (arguments are copied around). You can't easily objectify the additional effects this has on the surrounding code. It's overhead that's going away with Panama.\n\nYes, that's nice and everything for C, but there is nothing nowhere that shows something that works for C++! You agree that JNI's performance is acceptable, and it works with C++, and it's portable, so unless we get something that's an order of magnitude better, why switch? I would very much like for someone to provide a couple of clues about how something like Panama could work for C++.\n\nI have more important priorities at the moment and Maven/Gradle deployment is adequately explained in the getting started guide. LWJGL 3 is in pre-beta state and I haven't had the time to properly evaluate badlogic's SharedLibraryLoader yet. It's very likely that it will be included in the final 3.0 release.\n\nI see. Though, badlogic uses SWIG to provide support for C++. Is it that, when it comes to JNI, you are satisfied with SWIG? It does not even support native NIO buffers, so that's probably not the case... So, what's the plan? Panama? I guess we'll have to wait a couple of years and see who guessed right. :)\n. > Right about what? I don't know how many different times I have to explain this. LWJGL does not compete with JavaCPP. LWJGL provides premade bindings to specific libraries, JavaCPP is used by people that want to create their own bindings. The LWJGL code generator is not exposed outside the build process.\nWe were primarily arguing over whether Panama would support C++ or not. You believe it will, I believe it won't. There's nothing factual to debate here. Your belief is that it will, so you are waiting for it, planning in consequence, and not taking into consideration Android, among other platforms. I have other beliefs, so I am planning differently. There's not much we can argue about here, unfortunately.\nJavaCPP also provides premade bindings to specific libraries, that I've named \"presets\". It's no different from LWJGL in that respect. But it is different in that it is designed to support more libraries than the limited set of LWJGL.\n\n\nGetDirectBufferAddress returns the base buffer address. All LWJGL APIs use the current position(), by design. This requires passing an extra parameter or calling position() from native code. LWJGL 3 does all pointer arithmetic in Java code and the JNI code is very light.\nIt's faster. I don't know why you think it's as inefficient as GetDirectBufferAddress.\nLWJGL has fallbacks for all Unsafe usages when it is not available.\n\n\nYou're right about that. I've just tested an empty JNI function that either calls GetDirectBufferAddress() on the native side, that takes about 40 ns, or Field.getLong() on the address field in Java, and that takes 17 ns. Good to know :) That's something we could do in JavaCPP for optimization when parsing header files, but it would clutter the Java interface, especially because we would also have to provide fallback implementations... We'll see if that becomes the bottleneck at some point for too many applications. It's not for now, and I am also hoping that we can turn most of those into intrinsics in the future anyway, but we still have no idea what that's going to look like.\n\nWhat are you talking about? JNI is a cross-platform API but does one specific thing. It has nothing to do with building the native libraries and I don't think JavaCPP does anything to help with that either. JavaCPP generates the (cross-platform) bindings, building the libraries themselves is an entirely different problem and it still requires users to have a working compiler on their machines.\nUnless you're talking about JavaCPP Presets?\n\nThe presets are part of it, but that's not all. Check the install guide here of a library using JavaCPP without presets: http://nd4j.org/getstarted.html\nThe additional instructions are:\n\nTo compile certain ND4J dependencies on Windows or a Linux OS, you will need to install some dev tools for C, including gcc. To check if you have gcc, enter gcc -v on your terminal or command prompt.\n\nThat's pretty much it. There's no additional commands to run, nothing else to do. (Unless they make it complicated to install development tools like it is the case on the Windows platform, but that's another story.)\nAbout Panama supporting C++ and Android not being of importance, you have your beliefs, I have mine. Let's leave it at that. :)\n. BTW, if someone is really interested in optimizing their code, they wouldn't use Field.getLong() either. They would cache the address in native memory somewhere, and I've confirmed that this drops the call time of an empty JNI function to 13 ns on my machine. And we can produce such a function at a higher level very easily with JavaCPP:\nhttp://stackoverflow.com/a/10809123/523744\nSee, we do not need to mess with JNI (or Unsafe for that matter) manually to obtain the best possible performance! So, I'm not sure I understand the reasons for avoiding the use of GetDirectBufferAddress(). Do you know of a concrete use case where it would be impossible to cache the address in native memory?\n\nI think you're underestimating what a major pita it is for most users to handle native compilation and cross-platform support.\n\nI understand perfectly how much trouble it is. That's one reason why I'm working on the presets. Check the list of binaries available here:\nhttp://search.maven.org/#search|ga|1|bytedeco\nIt's not in any way complete or perfect, but I think I've proven that the concept works. I'm trying to get people interested to contribute (time, money, etc), but even though it's getting pretty popular, I still don't understand what the pushback is all about. In your case, it seems to be about trusting Oracle's vaporware more than something that works right now. So I guess it's all about trust, but if you have any technical comments that would help the discussion move forward, please do let me know. Thanks!\n\nOn C++, the only reason I think Panama will support C++ is because it says so on the project description. Even if it ends up being C only, it's still going to be immensely useful, just like LWJGL is useful without C++ support.\n\nSure, there are a lot of useful libraries written in C out there, but... What was the reason you created this thread for anyway?\n\nOn Android, I never said I don't care for it or that it's not a major platform worth planning for. I just said the current LWJGL implementation does not support it. LWJGL will not move to Panama overnight either. It will be a fork that works on Java 9/10+ and the original library will be supported until it's useful to do so. In the same way, one could do a fork for Android right now, with the same bindings but with a different code generation strategy that makes sense for Android.\n\nSo, if I understand correctly, you meant to say that for now Android isn't your priority, but eventually, just like Panama, it might?\n. @httpdigest Thanks for your interest! I am not aware of an attempt at wrapping a COM library, so it's probably going to require some amount of tinkering, but I'm sure it's something that could be made tractable with JavaCPP. After all, COM is pretty much just a version of C++ that requires MSVC. We can use JavaCPP to parse header files yes, but we usually need to provide some amount of config, thus the presets project. Some details here: https://github.com/bytedeco/javacpp-presets/wiki/Create-New-Presets As for something like IUnknown, it's always possible to cast them to whatever we need. For example, by providing an extra Class parameter, we can cast the returned object to the user-specified type for this function from Caffe:\njava\n  public native @Const @Cast({\"\", \"boost::shared_ptr<caffe::Layer<float> >\"}) @SharedPtr @ByVal <L extends FloatLayer> L layer_by_name(Class<L> cls, @StdString String layer_name);\nThere's a lot of annotations there. It doesn't usually look that scary, but it's flexible. :) And the parser takes extra info from the config file too... BTW, should we bring this discussion somewhere else?\n. @dustContributor Android does not and most likely never will provide support for OpenCL, so LWJGL could be useful for that there. And I know people who might be needing that, but no one seems willing to work on it, so it looks like I'll eventually be wrapping OpenCL 2.0 with JavaCPP. :)\n. > I'm not entirely sure what you mean by caching the native address. If you're talking about using GetDirectBufferAddress once, then reusing the address in multiple other calls, this is done transparently by the JIT compiler with the LWJGL approach. This is confirmed and works perfectly.\nI'm looking at your framework and your posts, but I still don't understand how you're doing automatic caching for user allocated buffers. Let's think of a simple use case. The user allocates a buffer using ByteBuffer.allocate() or ByteBuffer.allocateDirect() -- we do not know which one. How does your framework handle this case? If we happen to be dealing with a direct one, how does the address gets cached across multiple random function calls to your API?\n\nI've already explained why, multiple times. And there's no pushback whatsoever. I've already said that I'm perfectly happy to recommend JavaCPP to anyone needing C++ interop. Like @httpdigest above, I sincerely hope JavaCPP works well for him.\n\nOk, I guess we just haven't fully bridged the technical gap in understanding yet. Let's keep working on that.\n\nI'm not even qualified to talk about Android. I have never owned an Android device or programmed an Android application. On a personal level, my opinion is that running a VM on such resource constrained devices is a bad idea. Especially the horrible JVM Android has. This is true today and will stay true in a few years when the devices will be many times more powerful. I don't want my battery being drained for JIT compilation. If I ever were to create a mobile app, I would go native or use AOT compilation.\n\nAOT is standard since Android 5.0, check the news release:\nhttps://developer.android.com/about/versions/android-5.0-changes.html\nIt's not doing JIT anymore.\n. > I'm guessing you didn't look too carefully. :) Otherwise you'd know LWJGL does not support on-heap buffers.\nNot very carefully because it didn't seem to be doing anything special. I was missing the obvious that it is relying on the JIT compiler to optimize stuff away.\n\nOn caching, you asked the same question above and I replied that it is handled transparently by the JIT compiler. For example if you have a loop like:\n\nBut does it actually work? I've just tried it here, and it doesn't seem to work.\n``` java\n    static Field addressField;\nstatic long sum1(Buffer buf) throws Exception {\n    long foo = 0;\n    for (int i = 0; i < 1000000; i++) {\n        foo += addressField.getLong(buf);\n    }\n    return foo;\n}\n\nstatic long sum2(Buffer buf) throws Exception {\n    long foo = 0;\n    long addr = addressField.getLong(buf);\n    for (int i = 0; i < 1000000; i++) {\n        foo += addr;\n    }\n    return foo;\n}\n\npublic static void main(String[] args) throws Exception {\n    addressField = Buffer.class.getDeclaredField(\"address\");\n    addressField.setAccessible(true);\n\n    Buffer buf1 = ByteBuffer.allocateDirect(1000000);\n    Buffer buf2 = ByteBuffer.allocateDirect(1000000);\n    long foo1 = sum1(buf1), foo2 = sum2(buf1);\n    long t0 = System.nanoTime();\n    foo1 = sum1(buf2);\n    long t1 = System.nanoTime();\n    foo2 = sum2(buf2);\n    long t2 = System.nanoTime();\n    System.out.println((t1-t0)/1000000 + \" \" + (t2-t1)/1000000 + \" \" + foo1 + \" \" + foo2);\n}\n\n```\noutputs something like 4 0 -7035888222044412928 -7035888222044412928 on my machine (openjdk version \"1.8.0_51\"), so it appears there is some overhead that the JIT compiler isn't able to get rid of. What I am missing?\n\nI hope it's clear now why this is more efficient and doesn't require any special treatment from LWJGL.\n\nWell, could you explain why I cannot seem to reproduce those results? AFAIK, the only way to make this more efficient is by offering another version of each function that use, instead of Buffer, a class named, say, Pointer, that doesn't require either reflection or JNI to obtain the native address.\n. Sure, I don't mind using your methodology:\n``` java\nstatic Field addressField;\nstatic long benchReflection(ByteBuffer buf) throws Exception {\n    long foo = 0;\n    for ( int i = 0; i < 100000; i++ )\n        foo += addressField.getLong(buf);\n    return foo;\n}\nstatic long benchOptimized(ByteBuffer buf) throws Exception {\n    long foo = 0;\n    long addr = addressField.getLong(buf);\n    for ( int i = 0; i < 100000; i++ )\n        foo += addr;\n    return foo;\n}\npublic static void main(String[] args) throws Exception {\n    addressField = Buffer.class.getDeclaredField(\"address\");\n    addressField.setAccessible(true);\nByteBuffer buf = ByteBuffer.allocateDirect(1000000);\n\n// warmup\nlong foo = 0;\nfor ( int i = 0; i < 100; i++ )\n    foo += benchReflection(buf);\n// measure\nlong reflection = System.nanoTime();\nfor ( int i = 0; i < 1000; i++ )\n    foo += benchReflection(buf);\nreflection = System.nanoTime() - reflection;\n\nSystem.out.println(\" reflection: \" + reflection + \" \" + foo);\n\n// warmup\nfoo = 0;\nfor ( int i = 0; i < 100; i++ )\n    foo += benchOptimized(buf);\n// measure\nlong optimized = System.nanoTime();\nfor ( int i = 0; i < 1000; i++ )\n    foo += benchOptimized(buf);\noptimized = System.nanoTime() - optimized;\n\nSystem.out.println(\" optimized:  \" + optimized + \" \" + foo);\n\n}\n```\noutputs something like:\nreflection: 629529643 2956596699404400640\n optimized:  46978111 2956596699404400640\nAnd I am still left under the impression that reflection-only is much slower than the manually optimized version. What am I missing? The long operations? Let's get rid of those:\nreflection: 597761393 606042112\n optimized:  3382292 606042112\nWhat else?\n. sun.nio.ch.DirectBuffer -> That's not going to work on Android. And good luck with Google ever supporting VarHandles.\nOf course GetDirectBufferAddress() is slow, I got that, that's OK. What I'm interested in understanding, is why you feel there is never any advantage in using some custom class like Pointer over Buffer.\nSo, for example, about Unsafe, let's assume some of your users are interested in passing to LWJGL a buffer that was allocated with CUDA, and they figured they need to optimize that. How would Unsafe help them? I'm just curious about how that would work, because AFAIK, we can't use Unsafe for memory that was allocated by some other means. Or am I missing something?\n. > Honestly, it feels like I'm talking to a wall. You reply 2 weeks later, only to state the obvious. I've already stated that Android support would require a different strategy altogether.\nSorry for stating the obvious, but I'm just still not sure where the misunderstanding lies, and I'm trying to think things through before replying... And also busy with other things, such as my day job, everyday life, and making a new release of JavaCPP, so thank you for your patience.\nLet's try to clarify things. When I speak of \"Android\", it's just one example. Unsafe isn't part of Java SE, so what I'm trying to understand has in fact nothing to do with Android. For example, are you testing LWJGL with IBM JDK and Excelsior JET as well, just to name a few other popular implementations of the JVM? It seems that you are, but why? And why not, for example, Android or RoboVM, for that matter? How do you determine the value that you place on \"Java\" as a standard if not through Java SE?\n\nI never said that. LWJGL already has custom classes for \"typed pointers\". All callback and struct classes are basically pointer wrappers.\nBut if you're going to be accessing arbitrary/untyped data, then Java already provides a pointer abstraction with the NIO buffers. There's no need to invent a new one and reduce possible interop with other APIs.\n\nI appreciate the interop argument, and that's why I'm trying to get something like JavaCPP in the JDK at some point in the probably far future: It's hard to get people to understand what one might consider obvious. ;) For example, among many other shortcomings, NIO buffers don't implement the AutoCloseable interface, and thus cannot participate in try-with-resources statements. The Pointer class of JavaCPP does:\nhttp://bytedeco.org/news/2015/10/25/moving-to-java-se-7/\nI know from experience that releasing GPU resources in a deterministic manner is very important, but NIO buffers offer no way to use the try-with-resources statement, which is surprising given that Oracle/Sun places so much emphasis on it, for example: http://www.oracle.com/technetwork/articles/java/trywithresources-401775.html . What is your opinion on this subject?\n\n\nSo, for example, about Unsafe, let's assume some of your users are interested in passing to LWJGL a buffer that was allocated with CUDA, and they figured they need to optimize that. How would Unsafe help them?\n\nEverything I said about GetDirectBufferAddress() applies to NewDirectByteBuffer(). LWJGL uses Unsafe to create buffer instances from an arbitrary address & capacity, without going into JNI.\n\nI'm just curious about how that would work, because AFAIK, we can't use Unsafe for memory that was allocated by some other means. Or am I missing something?\n\nYes you are, Unsafe can be used to access both on-heap and off-heap memory and it doesn't matter who (or how) allocated the off-heap memory. If it couldn't do that, stuff like glMapBuffer wouldn't be usable in Java.\n\nRight, Unsafe lets us allocate objects without executing their constructors. Sorry for missing the obvious.\n. ",
    "dannypurcell": "I created a quick bash script that installs a snapshot zip in the local maven repo.\nhttps://gist.github.com/dannypurcell/0c86ac1087eadd02d605\nRuns in msys on windows, should also run fine in cygwin\n. I think that sounds workable. My only reservation is that it may be duplicating functionality already provided by java.util.logging.Logger. \nIf LWJGLUtil.log(CharSequence) could switch to a Logger based on a system property that might cover it without duplication.\n. Thanks for the detailed reply! \nIt figures I would have missed something silly like that. I thought I had that angle covered in trying different internal formats but the others probably either made the buffer more than enough or just right.\nSince the native side is reading from a pointer location that has too little memory, the crash should be due to an access violation. Unfortunately, the only place this shows up is in the Windows Application logs as a crash report for java with Exception Code: 0xc0000005 which denizens of the internets report can be triggered by access violations. \nFrom the user side the lack of reporting reduces the debugging options to research, guess, and check. (when the user is a newb like me it seems like the error could be anywhere :sweat_smile:)\nWhat do you think of adding a size check, guarded by if ( LWJGLUtil.CHECKS ), to the functions that take ByteBuffers such that hard crashes are preempted by a good exception message?\nI can add these checks to my own middle-ware of course but this seems valuable enough to have in the base library and the functions in scope pretty universally have the guarded GLChecks.ensureBufferObject already.\nRegarding DSA texture initialization:\nThanks again for the info! Your examples, docs, and comments are seriously speeding up the learning process for me.\nTo be honest, I've been using those functions in pairs as part of a one shot texture creation method in my middle-ware library. I'll probably break them up again if the initial state of the texture space can be used right away.\nAlso, I found ByteBuffer black = null; very intuitive actually. When I got the exception blocking null for glTextureSubImage2D it also made sense that zero-ing a sub-section of a texture space would not have been as easy to implement as doing the whole space at once.\n. I've actually been using that through GL43. I have my initialization code set up to detect if assertions are enabled and configure all the debugging and checking I could find if they are.\nUnfortunately for this case, the OpenGL implementers at NVidia decided to forego the boundary check (likely due to the performance cost). So, all we get is a hard crash.\nGreat idea about grabbing the stack from the debug callback! \nI have been just sending the messages to SLF4J without including any stack info; I just figured it wouldn't be useful. Prompted by your comment, I tried adding a contrived RuntimeException to the Logger messages for GL_DEBUG_SEVERITY_MEDIUM and GL_DEBUG_SEVERITY_HIGH and indeed, we get a very nice stack trace to help shed some light on why that message was cast.\nThanks for the post!\n. ",
    "xiurobert": "LWJGL 3 release is out, maybe put it up now?\n. ",
    "philipwhiuk": "Gradle and Maven use the same repositories (e.g. Nexus) so it should only be necessary to do it once and deploy it somewhere.\n. ",
    "WisdomMage": "I'm using the latest nightly build (11/26/14 19:45)\n. It's actually not a JVM launch problem.\nI use Windows 8.1 Pro x86. I went to lwjgl.org website and downloaded the newest nightly build. After doing the setup in IntelliJ Idea, I've figured out there was an error saying that the native couldn't be found. So I went to \".../native/windows/x86\" and there was only OpenAL32.dll. I extracted and re-extracted it many times, trying to realize where was the error. So, I noticed whenever I try to move the file, It didn't 'come'. \nSo I tried to open the file in common Windows' notepad. If it wasn't empty, so I was the error, but... http://prntscr.com/5aj8jk - It's portuguese, it means: \"We couldn't find lwjgl.dll. Would you like to create a new file?\"\nBefore extracting: http://prntscr.com/5aj5zo\nAfter extracting: http://prntscr.com/5aj6qh\n. Ok, thank you, it was a problem maybe with my Downloads folder. \nExtracted it to another disk, and the problem's solved. Thanks!!\n. ",
    "renannprado": "Is the zip file corrupted?\nMore important: isn't your antivirus deleting the dll after it's extracted? :)\n. Awesome!\nThanks!\n. I wonder if it would be possible to somehow render HTML+CSS (and possible code the UI logic in javascript via nashorn maybe) for HUD? \nI've researched quite a bit some time ago but couldn't find anything like that or even a reference.\nIt would also be nice to check how games such as Heroes of Storm and Starcraft 2 (which, IMO, have nice HUD) are doing their HUD.\nAnother thing that maybe could help is the project dukescript.\n. Yeah, that's the thing. I didn't mean to create something like WebKit, but if we could create a binding for it and use it to somehow render the HUD, that is what, IMO, would be awesome.\n(I don't have any clue if it's possible, maybe I'm saying some non-sense here. I'm just trying to think from the library end user POV and, for me, HTML+CSS (and possible javascript) is the most flexible way to write UI today)\n. It's been a long time since I last used it, BUT when I did more or less a year ago, the big win for me was the simplified graphics API over OpenGL one (well it's an abstraction on top of it).\nBut I'm certainly not expert in OpenGL nor SDL2.\nOther people will probably have better arguments (against or for) than me.\n. @intrigus I believe that the kind of software developed with LWJGL (games, in general) shouldn't rely on the JDK/JRE that is in the user's machine, so it would be a better practice to bundle the JDK/JRE which is known to work with your software and it's much better experience for the end user.\nI don't see why not upgrade to JDK8. :+1: \n. ",
    "QuantumFractal": "As a newcomer, I agree wholeheartedly. \n. ",
    "bluenote10": "I tried both Firefox and Chrome (most recent Ubuntu 14.04 versions), but not on another machine so far. Yes, let's just try a delete/reregister then.\n. I have been trying to contribute to exactly this thread for a few weeks now, but I still can't due to this issue.\nNow I'll post it here instead...\n\nI am having the exact same problem when running the minimal lwjgl3 Hello World example. I'm running Ubuntu 14.04 with the default NVIDIA drivers (GTX 670). I'm using the lwjgl3 version which was the current \"stable\" download around Dec 5th.\nI had libgl1-mesa-dev installed (contains the libGL.so) and I can confirm: Uninstalling libgl1-mesa-dev works as a workaround, i.e., no more \"Invalid X server connection specified\". However, I'm not yet really sure whether this will work as a true solution for me, since some of my projects depend on freeglut3-dev, which depends on mesa-common-dev, which depends on the problematic libgl1-mesa-dev...\nI also tried to manually call LinuxGLContext.createFromCurrent(display) instead of the generic GLContext.createFromCurrent(). Some observations:\n- GL.getFunctionProvider().getFunctionAddress(\"glXGetCurrentDisplay\") does return a (probably valid?) handle but apparently the handle becomes NULL after it is passed through nglXGetCurrentDisplay here.\n- I also tried to pass in the display ID that is returned from GLFWLinux.glfwGetX11Display(), which seems to be different from GL.getFunctionProvider().getFunctionAddress(\"glXGetCurrentDisplay\"). If I remember correctly this lead to a crash in the line GL.createCapabilities(false). The error I got depends on whether I also call GL.getFunctionProvider().getFunctionAddress(\"glXGetCurrentDisplay\") before createFromCurrent(display)... Very strange.\n. Interesting: I was trying to compare what you suggested but now I also fail to reproduce the problem. I now have installed libgl1-mesa-dev, libglu1-mesa-dev, mesa-common-dev, and even freeglut3-dev but the HelloWorld seems to work. Maybe some of the NVIDIA symlinks has changed? The result of locate libGL with resolved symlinks now looks as like this:\n/usr/lib/i386-linux-gnu/mesa/libGL.so.1 -> libGL.so.1.2.0\n/usr/lib/i386-linux-gnu/mesa/libGL.so.1.2.0\n/usr/lib/nvidia-331/libGL.so -> libGL.so.1\n/usr/lib/nvidia-331/libGL.so.1 -> libGL.so.331.113\n/usr/lib/nvidia-331/libGL.so.331.113\n/usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 -> libGL.so.1.2.0\n/usr/lib/x86_64-linux-gnu/mesa/libGL.so.1.2.0\n/usr/lib32/nvidia-331/libGL.so -> libGL.so.1\n/usr/lib32/nvidia-331/libGL.so.1 -> libGL.so.331.113\n/usr/lib32/nvidia-331/libGL.so.331.113\nMaybe @ShiroiTenshio can spot a difference to their system.\n. On my system, there are no matches for any of these:\n/usr/lib/libGL* \n/usr/lib32/libGL* \n/usr/lib64/libGL* (directory does not exist)\n/lib/libGL* \n/lib32/libGL* \n/lib64/libGL*\nOtherwise, locate should have reported them (iirc) in the above output.\n. I have tracked down the problem and can now offer a minimal reproducing example. The problem is caused by a small \"loading\" splash screen that is shown during the OpenGL initialization. It looks like there are some kind of side effects between LWJGL/GLFW and Java Swing. In can reproduce the problem like this (I hope it is okay to post in Scala, let me know I should provide a Java version):\n```\nimport java.awt.BorderLayout\nimport java.awt.Color\nimport javax.swing.ImageIcon\nimport javax.swing.JFrame\nimport javax.swing.JLabel\nimport org.lwjgl.glfw.GLFW.glfwInit\nclass SplashScreenMinimal extends JFrame {\nval icon = new ImageIcon(getClass().getClassLoader().getResource(\"animated.gif\"))\n  val label = new JLabel(icon)\n  getContentPane().add(label, BorderLayout.CENTER)\n// transparent frames must be \"undecorated\"\n  setUndecorated(true)\n  // in general the following allows to use transparency in an animated gif,\n  // but this seems to trigger the problem:\n  setBackground(new Color(0, 0, 0, 0))\npack()\n  setLocationRelativeTo(null)\n  setVisible(true)\ndef close() {\n    setVisible(false)\n    dispose()\n  }\n}\nobject SplashScreenMinimal {\n  def main(args: Array[String]): Unit = {\n    val splashscreen = new SplashScreenMinimal()\n    // now glfwInit will crash\n    glfwInit()\n  }\n}\n```\nIt looks like the splash screen must satisfy a few conditions in order to trigger the RenderBadPicture (a regular JFrame is not an issue):\n- The background of the frame must have an alpha value != 255. Not using setBackground at all or setting setBackground(new Color(0, 0, 0, 255)) does not crash, but e.g. setBackground(new Color(0, 0, 0, 254)) fails.\n- Apparently, the frame must display some kind of graphics like an ImageIcon. In my case it was an animated GIF with transparency. It looks like it is not necessary for the GIF to be transparent though (crashed with this one as well). A transparent PNG also seem to crash.\nNow the question is: Why and how does LWJGL 3 or GLFW interfere with this Swing stuff? I'm not sure if this really is a LWJGL bug, but at least this code seem to work in general and also with LWJGL 2.\n. Ah I see, now that's a bit tricky. Thanks for the feedback!\nI ran some tests with the regular -splash approach and this seems to work fine (it looks like the implementation of SplashScreen does not use any kind of Swing dialog at all, but relies entirely on native functionality).\nThe reason why I wasn't using a regular splash screen is that the functionality is limited. For instance, I wanted to add a message log to show the steps of the initialization.\nMaybe official support for Swing might be a nice feature for the future. My software for instance is a VR-only application. In such a case it might not be unusual to have some kind of traditional UI on the regular screen (showing some status or even for configuration), with the graphics engine running in \"direct mode\" on the HMD.\n. ",
    "larlin": "Here is the C code it is mostly their example. To make it similar to the LWJGL test I create the window invisible and then show it.\n/generated/tests is sadly empty.\nHere is the output:\ntests:\n[Tests] [LWJGL] Version 3.0.0a | Linux | amd64\n[Tests] [LWJGL] MemoryUtil MemoryAccessor: MemoryAccessorUnsafe\n[Tests] [TestNG] Running:\n[Tests]   /home/larlin/Build/lwjgl3/config/tests.xml\n[Tests]\n. Will try that tonight.\nI did try to remove:\nglfwWindowHint(GLFW_VISIBLE, GL_FALSE); // the window will stay hidden after creation\n    glfwWindowHint(GLFW_RESIZABLE, GL_TRUE); // the window will be resizable\nBut it behaved the same, but will do a smaller test with just creating a window and report back.\nI did a test with -Dorg.lwjgl.util.Debug=true and all I got extra was these two:\n[LWJGL] Version 3.0.0a | Linux | amd64\n[LWJGL] MemoryUtil MemoryAccessor: MemoryAccessorUnsafe\n. Here is a simplified test that fails in the same way. Output when running with debug flag have the following output:\nglfwInit\n[LWJGL] Version 3.0.0a | Linux | amd64\nrunning glfwCreateWindow\n[LWJGL] MemoryUtil MemoryAccessor: MemoryAccessorUnsafe\nOne other thing the C code I tested is built against my system version of glfw which is version 3.0.4 while the one in lwjgl3 seems to be 3.1.0.\n. I'm sorry their build process seems to be above my paygrade. I tried to run cmake and then make but I don't get any file generated that I can see how to link to my test program. I really avoid program C any time I can so my memory of C build process is spotty and probably not up to date. If there is a straight forward way to do it I could test, but I don't want to spend days figuring out how to build the library file.\n. Thanks I think that works. Just to make sure I didn't mess up here is what I did.\nI copied the result(libglfw3.a) to a GLFW folder in my test directory. Where I also copied the headerfiles from the include directory in the glfw repo.\nThen I change the import for the header files to local and built using this:\ngcc test.c -LGLFW -lglfw3 -lXrandr -lX11 -lGLU -lGL -pthread -lm -lXxf86vm -lXi -lXinerama -lXcursor\nThat results in a a.out that hangs in the same way as lwjgl3 never returning from glfwCreateWindow().\nI hope this make any sense. =)\n. Looked around a bit and this sounds like it could be the same issue. So I guess I will have to wait for the fix to be pushed out. Probably in ubuntu 15.04.\nThanks for the help and sorry for the problems.\n. ",
    "landolphia": "Thank you!\nI'll make sure to check around glfw before I jump to conclusions next time.\n. ",
    "ShiroiTenshio": "Yes, GeForce GTX 680. Is there a workaround? I would like to continue working on my project, but as it seems I have to port it to lwjgl 2. \n. Oh of course not. Thought I have changed to 32-Bit.\n. ",
    "tdaniel22": "Ok then, I don't really know how LWJGL implements OpenGL methods. I will make some more tests and see if I can get it working with another driver version.\n. Well, I finally figured out how to get it working: in fact, you need to bind a VAO or VBO at least one time after creation before using it with a DSA function. So after calling glGenVertexArrays() or glGenBuffers(), I bind the object and unbind it once. I don't know if this behaviour is intended, but it is for sure not in the documentation (or I might be blind).\n. Well, thank you. Shame on me .. My mistake will maybe help someone else. Since this property is invisible when using non DSA functions, it's kind of easy to forget. And sorry for turning this issue into a forum thread.\n. ",
    "SilverTiger": "That's because there is a new homepage for LWJGL3.\nThe old homepage is available at http://legacy.lwjgl.org/ and the update site should be http://legacy.lwjgl.org/update/\n. The first thing that would spring to my mind is that FreeType would support the OpenType format and stb only supports the TrueType format.\nBut on the other hand FreeType is a huge library.\n. With NetBeans the navigation works like expected, tried navigating inside the JavaDoc and also inside the source code.\n. Have you tried creating a key callback?\nIn the simplest example you should be able to close the windows with ESC:\njava\nGLFWKeyCallback keyCallback = new GLFWKeyCallback() {\n    @Override\n    public void invoke(long window, int key, int scancode, int action, int mods) {\n        if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {\n            glfwSetWindowShouldClose(window, GLFW_TRUE);\n        }\n    }\n};\nNote that you should have a strong reference to that callback, e.g. store it as field of your class.\nAfter creating the window you should call glfwSetKeyCallback(window, keyCallback); to register it to the window.\n. You can create a forward compatible context by calling GL.createCapabilities(true). This will prevent LWJGL from loading deprecated functions. You can read this in the JavaDoc.\nAlso calling a deprecated function with an OpenGL context >= 3.0 should not work when creating a forward-compatible context with GLFW. Have you requested a context like in the following code?\njava\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);\n. Another thing to consider would be the OpenGL version.\nSome people may want boilercode for Legacy OpenGL like 1.5 or 2.1 and others do just want core OpenGL 3.2+ or 4.5. This could be done by creating different branches.\nBut I like the idea and it shouldn't be too complex to create some boilercode with some basic classes and a default vertex and fragment shader.\n. > a) Run glxgears. Does it work?\nglxgears works like expected.\n\nb) Build GLFW locally and try out its demos. Do they have the same problem?\n\nThe examples work for 3.1.2, but with 3.2 it has the same issue.\nI will test some of the commits since 3.1.2 and will report back if I find the commit which caused it.\n. Looked through some commits and it seems like the issue exists since GLFW/glfw@ef80bea.\n. You can compile GLFW yourself with commit glfw/glfw@9d50a34 and put it in your natives folder/jar until this bug is fixed.\n. @elmindreda \nWith the current master the issue is resolved. Tested it just now.\n. Another suggestion:\nIt would be nice if you could add a mode for Ant Ivy for generating an ivy.xml for the users who are using Ant for building instead of Gradle and Maven.\n. Just tried the ivy.xml Generation. Seems good so far. Here are some notes:\n\nThat's no problem in my opinion. The version properties can also be placed inside the ant.xml. And if you aren't using a snapshot build, one has to import the default ivysettings.xml or else it won't find the default resolver if a local ivysettings.xml is present.\nI think you have to change the defaultResolver. But you run into problems if you are using a snaphot build and a release build (for example LWJGL 3.1.1-SNAPSHOT and JOML 1.9.0). In that case it may be advisable to use a chain resolver, like described here in combination with the default resolver from the default ivysettings.xml.\nI'm fine with getting the natives with Ant, as you have to use both, Ant and Ivy. Just out of curiosity: For Windows you are using os family=\"windows, but for Linux and Mac it generates os name=\"Linux\" and os name=\"Mac OS X\". In that case you could also use os family=\"unix\" and os family=\"mac\", or is there a specific reason?\nI'm not sure about that, but the solution for this could be custom configurations.\nThis may also get solved with custom configurations.. Although this issue is closed, this may be interesting for adding to the download page. I tested a bit with Ivy configurations and now I have a solution for downloading javadoc and sources independently.\n\nFirst you have to add this to ivy.xml:\nxml\n<configurations defaultconfmapping=\"default\">\n    <conf name=\"default\"/>\n    <conf name=\"javadoc\"/>\n    <conf name=\"sources\"/>\n</configurations>\nThe default mapping will download the jar and the native files. The configurations for javadoc and sources have to be added for each dependency as a new dependency. For example the core dependency will be like this:\nxml\n<dependency org=\"org.lwjgl\" name=\"lwjgl\" rev=\"${lwjgl.version}\">\n    <artifact name=\"lwjgl\" type=\"jar\"/>\n    <artifact name=\"lwjgl\" type=\"jar\" m:classifier=\"${lwjgl.natives}\"/>\n</dependency>\n<dependency org=\"org.lwjgl\" name=\"lwjgl\" rev=\"${lwjgl.version}\" conf=\"javadoc;sources\"/>\nThe first dependency doesn't need to set a conf because it will get the defaultconfmapping automatically. After that you need to download the dependencies in build.xml via:\nxml\n<ivy:retrieve conf=\"default\"/>\nAnd if you also want to get the javadoc and/or sources you can change that line to (alternatively if you won't specify a conf everything will get downloaded):\nxml\n<ivy:retrieve conf=\"default,javadoc,sources\"/>. ",
    "C-Otto": "Thank you!\n. ",
    "io7m": "Apologies for digging up a corpse, but I've recently put together a small project that produces an OSGi bundle in an automated manner:\nhttps://github.com/io7m/org.lwjgl\nIt appears to work, but hasn't had anywhere near enough testing yet. I'll be pushing the bundles to Central when the various platforms have been verified to work.\n. Hi. I'll try to address each thing individually:\n\nLWJGL should work fine without doing anything special for the native libraries, except adding them to the classpath.\n\nAs you may know, there isn't a classpath in OSGi. There is, in some sense, a classpath inside each individual bundle. Bundles cannot see native libraries loaded by other bundles, and each bundle is assigned its own classloader.\nThis means that at a minimum, in order for LWJGL to work, the LWJGL jar and individual platform jars have to be re-packed into a single bundle. This isn't an issue, can be done in an automated manner externally, and doesn't require any changes on the part of LWJGL right now. However, I can see a problem looming ahead introduced by the need to merge the jars. This ticket for example: #206 \nRight now, the binaries inside each LWJGL platform jar are named generically and placed in the root of the jar file. This means that (assuming the current structure stays the same) if, for example, LWJGL gains ARM support on Linux, there'll be a liblwjgl.so in the root of the x86 platform jar, and a liblwjgl.so in the root of the ARM platform jar. This means that the platform jars can no longer be packed into a single OSGi bundle without file collisions unless an extra bit of indirection is added in a manner that LWJGL's library loading code can understand (such as moving each library to natives/linux/x86/liblwjgl.so, natives/linux/armv6/liblwjgl.so directories in each platform jar so that the jars could be merged without any collisions).\nWe could instead avoid all of this, unpack the native libraries manually into the filesystem and use java.library.path. Unfortunately, this would then seriously complicate OSGi's live upgrades of packages/bundles (some code would have to run somewhere to manually clean up the directory used to hold the natives).\n\nDo you really have to use OSGi's native library loading functionality?\n\nThere's one major thing that would be lost without it. The metadata in each bundle specifies exactly which native libraries are present and on which platform they work. When a bundle is installed, it begins in the INSTALLED state and is then moved to the RESOLVED state when all dependencies have been accounted for and the system is sure that the bundle can actually work in the current execution environment. If the metadata for the native libraries states that the bundle doesn't support the current platform, you get a very unambiguous error message describing the exact problem, and the bundle will not be RESOLVED. This sort of error reporting is standardized across OSGi, and various OSGi services use this information for performing deployments and the like. If OSGi's native library loading can't be used, the LWJGL bundle basically becomes a second class citizen with any native library issues occurring at the latest possible moment and in a manner that the OSGi container can't \"see\".\n\nIndeed, the current implementation does not call System.loadLibrary anymore; it's opaque and we can't print the information we need.\n\nI suspected this would be the case, and it's why I suggested a property that can be set at run-time to enable it. Something along the lines of -Dlwjgl.i.am.using.osgi.and.know.what.i.am.doing=true that would cause the loading code to fall back to the mindless loadLibrary path for use in OSGi. In other words, if you don't turn on that property, nothing about LWJGL's library loading code changes.\n. > Is there a 1:1 relationship between a \"bundle\" and a JAR? Isn't it possible to define a bundle using multiple JARs?\nYes, a bundle is just a single jar file with some extra data in the manifest that says what packages are exported, what packages are imported, etc. Now you mention it, there actually is a way to split a bundle across several jars, but I'm not sure it was ever intended for doing things like this. There's such a thing as \"fragment bundles\". Basically, a bundle can specify a \"host\" bundle and its contents are effectively added to the host. It's usually used for localization (overriding resources with locale-specific strings and the like). All things being equal, it probably could be used for adding native libraries (but we'd still miss out on the nice benefits of OSGi's native library loading).\nIt's also just occurred to be that fragment bundles have the serious downside in that there's no effective dependency between the fragment and the host. That is, if you install the host and don't install any fragments, the native libraries would be missing and you'd not get any decent error message like \"You need to install these fragment bundles\".\n\nWhen we add ARM support, the new binaries will have appropriate suffixes (e.g. liblwjgl-arm64-vfp-hflt.so and liblwjgl-arm32-vfp-hflt.so), so collisions won't be an issue.\n\nGood to know!\n. Silly question: I've compiled the java and native code, but what's the right command to use to produce the jar files? I'd like to make sure I'm producing them exactly the same way that you would in order to have some degree of confidence that I'm giving the OSGi tools the same sort of input that I'd receive had I just downloaded the LWJGL binaries.\n. It'll take me a little longer than expected to report results as I was still working with the old monolithic jar from 3.0.0, as opposed to the new modular jars from 3.0.1. Currently redoing the scripts that produce an OSGi bundle.\n. OpenGL seems to work. Thanks!\n. I'm still giving it some consideration, but I suspect that 2 is impossible. The reason being is that OSGi doesn't seem to have any APIs at all related to native code; the native code is supposed to be configured entirely via static metadata with the only interface being the standard Java loadLibrary methods. Additionally, each OSGi container implementation handles the actual loading of native libraries differently, so it's not really something we can predict.\nI think handling the JNI libraries via System.loadLibrary once the java.library.path bug is fixed will be fine. As for the non-JNI libraries, I think it would be better to treat them as resources in the manner you suggested.\nThere is still the issue of actually accessing resources when there are multiple classloaders involved, but could this be as simple as just passing in a reference to the right classloader?  For example, the code that loads libglfw could pass a reference to its own classloader to Library.loadNative and the passed in classloader would be responsible for returning the resource that LWJGL then unpacks.. > Please try the next snapshot (3.1.2 build 14).\nI'll give it a go today, thanks!\n\nCould you explain this a bit more? Do you mean that different LWJGL bindings are loaded from different ClassLoaders?\n\nLet's assume that I create one bundle per LWJGL module. For example, I put lwjgl-jemalloc  and all of its natives into one bundle, and then I put lwjgl and its natives into a separate bundle. \nThen, JEmalloc calls Library.loadNative which then calls Library.class.getResource(\"/libjemalloc.so\"); to locate the native library as a resource. The problem here is that Library is loaded by a different classloader than JEmalloc, because they're in different bundles. The resources of JEmalloc are not accessible via Library.\nI've put together a small example of resource lookups across bundles here:\nhttps://github.com/io7m/osgi-resource-lookups-20170205\nThere's a class in the loader module that presents an interface somewhat like Library.loadNative in that it tries to load a given resource. An example class in the module0 module tries various calls to the loader and prints the results. The loadFromLoaderClass(\"/module0.txt\") \u2192 null case is the one that matches what LWJGL currently does: The com.io7m.cltest.module0.Example class asks the Loader class in a different bundle to load /module0.txt. It fails, because /module0.txt is not in the same bundle as Loader.\nGoing by the results obtained above, I think what needs to happen is for JEmalloc to pass its own class reference (JEmalloc.class)  to Library.loadNative and that class reference is then used look up the resource. This matches the loadFromGivenClass(class com.io7m.cltest.module0.Example, \"/module0.txt\") and as you can see, it appears to work correctly.\nOne alternative to this stuff is to pack literally every LWJGL module into one large bundle. But the reasons for not doing this are the same reasons that you don't currently pack all of the LWJGL modules into one large jar the way you used to. \ud83d\ude04 . A bit of experimentation appears to show that the JNI libraries are loaded correctly in an OSGi context in the 3.1.2 snapshot. \ud83d\udc4d \nI'm currently investigating a failure to load non-JNI libraries via the new reflection path which I think may actually be a bug in the OSGi runtime I'm using, but from the results I posted in the example code above, I suspect that there's an issue in the LWJGL code too: Loading should fail because you're invoking the findLibrary method on Library's classloader instead of the classloader of a possibly different bundle (such as the hypothetical lwjgl-jemalloc bundle).\nhttps://github.com/LWJGL/lwjgl3/blob/master/modules/core/src/main/java/org/lwjgl/system/Library.java#L219. Nice! Any chance you could push a snapshot so that I can verify this?. Thanks! I'll be giving this a go tomorrow. Couldn't get to it today. From reading the changes, I'm optimistic that it'll work.. Hi. Small issue discovered when testing the latest snapshot:\n[INFO] --- maven-bundle-plugin:3.2.0:bundle (default-bundle) @ org.lwjgl.monolithic ---\n[ERROR] Bundle com.io7m.bundles:org.lwjgl.monolithic:bundle:3.1.1 : Classes found in the wrong directory: {META-INF/versions/9/org/lwjgl/system/StackWalkUtil.class=org.lwjgl.system.StackWalkUtil}\n[ERROR] Error(s) found in bundle configuration\nThis is a bug in the maven-bundle-plugin plugin, so my testing of the LWJGL changes may be delayed slightly until I can get that one fixed. Guess they aren't quite Java 9 ready yet.... Er, by \"they\",  I mean the maven-bundle-plugin maintainers.. Hi!\nWell, there's still something not quite right: It seems like in the code path I end up taking via OSGi, there are no calls made to either System.load() or System.loadLibrary() for libGL.so.1. Is this expected behaviour? I don't understand enough of the LWJGL internals to determine how it handles native code in all cases. It seems like either one of those calls would need to happen though in order for native methods to be resolved. If this isn't expected behaviour, I'll try to trace the sequence of calls and get more information. The other libraries such as libjemalloc.so, libglfw.so, etc, are loaded correctly and work properly.\nThe actual symptom I'm seeing is that everything appears to work correctly right up until the first call to GL11.glClearColor(...) whereupon I straight away receive:\n[LWJGL] Loading library: libGL.so.1\n[LWJGL]     libGL.so.1 not found in org.lwjgl.librarypath=/tmp/lwjglsomeone/3.1.2-SNAPSHOT\n[LWJGL]     Loaded from java.library.path: /usr/lib64/libGL.so.1\n[com.io7m.bundles.org.lwjgl.example.LWJGLExample][renderer]: clearing window\nException in thread \"renderer\" java.lang.UnsatisfiedLinkError: org.lwjgl.opengl.GL11.glClearColor(FFFF)V\n    at org.lwjgl.opengl.GL11.glClearColor(Native Method)\n    at com.io7m.bundles.org.lwjgl.example.LWJGLExample.doExample(LWJGLExample.java:104)\n    at java.lang.Thread.run(Thread.java:745). I don't get any errors when loading liblwjgl_opengl.so:\n[LWJGL] Version: 3.1.2 SNAPSHOT\n[LWJGL]      OS: Linux v4.8.13-1-ARCH\n[LWJGL]     JRE: 1.8.0_121 amd64\n[LWJGL]     JVM: OpenJDK 64-Bit Server VM v25.121-b13 by Oracle Corporation\n[LWJGL] Loading library (system): lwjgl\n[LWJGL]     Using SharedLibraryLoader...\n[LWJGL]     Found at: /tmp/lwjglsomeone/3.1.2-SNAPSHOT/liblwjgl.so\n[LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsomeone/3.1.2-SNAPSHOT/liblwjgl.so\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n[LWJGL] Loading library: jemalloc\n[LWJGL]     Using SharedLibraryLoader...\n[LWJGL]     Found at: /tmp/lwjglsomeone/3.1.2-SNAPSHOT/libjemalloc.so\n[LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsomeone/3.1.2-SNAPSHOT/libjemalloc.so\n[LWJGL] MemoryUtil allocator: JEmallocAllocator\n[LWJGL] Loading library: glfw\n[LWJGL]     Using SharedLibraryLoader...\n[LWJGL]     Found at: /tmp/lwjglsomeone/3.1.2-SNAPSHOT/libglfw.so\n[LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsomeone/3.1.2-SNAPSHOT/libglfw.so\n[com.io7m.bundles.org.lwjgl.example.LWJGLExample][renderer]: creating window\n[LWJGL] Loading library (system): lwjgl_opengl\n[LWJGL]     Using SharedLibraryLoader...\n[LWJGL]     Found at: /tmp/lwjglsomeone/3.1.2-SNAPSHOT/liblwjgl_opengl.so\n[LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsomeone/3.1.2-SNAPSHOT/liblwjgl_opengl.so\nAre there any methods I can call that would provoke an error had it not been loaded correctly?. Oh, it works correctly outside of OSGi; that's never been an issue! Running the same code with the latest snapshot outside of OSGi works without issue.\nI'm still trying to work out exactly what assumption the OSGi environment changes that LWJGL apparently depends on.\nWhat I'm really looking for right now is a method that would raise some sort of error if and only if lwjgl_opengl hadn't been loaded correctly. . It appears to be a classloader issue. If I pack all of the LWJGL libraries and classes into a single bundle (so that they're all loaded via the same classloader), everything works correctly. This is less than ideal (and makes some of the work you did on LWJGL kind of pointless) but it's at least available as a last resort if I can't work out why LWJGL doesn't like multiple classloaders.. I'm not sure. I think I may need to enlist the help of someone who knows the OSGi internals a little better. I'll send a message to the osgi-dev mailing list.. https://mail.osgi.org/pipermail/osgi-dev/2017-February/006123.html. Good point, I had this configured as a local profile. I'll add it to the pom.xml now.. I'll give it a shot today, thanks!. No change, unfortunately, but I think your suspicion about Reflection.getCallerClass() is correct. Tracing the execution of the attempt to load lwjgl_opengl in the debugger shows that Runtime.load0 is called with the first argument set to Library.class despite the explicit passing around of class references such as GL.class:\n\nI suspect that the only way to work around this is going to be by subverting package-private accessibility and calling the Runtime.load0 method reflectively.\n. Still no luck with build 17, unfortunately.\n\nThe code path that leads to Runtime.load0 is expected to fail under OSGi.\n\nThis is actually the only code path that's taken when attempting to load lwjgl_opengl. Is this expected?\nI've tried to build the bindings myself to try out a few things, but unfortunately they don't compile at the moment:\ncompile:\n[javac: Core] Compiling 1256 source files to /home/someone/git/com.github/LWJGL/lwjgl3/bin/Core\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/nanovg/LibNanoVG.java:17: error: no suitable method found for loadSystem(Class<LibNanoVG>,String)\n[javac: Core]       Library.loadSystem(LibNanoVG.class, libName);\n[javac: Core]              ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/nuklear/Nuklear.java:1182: error: no suitable method found for loadSystem(Class<Nuklear>,String)\n[javac: Core]   static { Library.loadSystem(Nuklear.class, Platform.mapLibraryNameBundled(\"lwjgl_nuklear\")); }\n[javac: Core]                   ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/openvr/OpenVR.java:39: error: no suitable method found for loadSystem(Class<OpenVR>,String)\n[javac: Core]       Library.loadSystem(OpenVR.class, libName);\n[javac: Core]              ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/stb/LibSTB.java:17: error: no suitable method found for loadSystem(Class<LibSTB>,String)\n[javac: Core]       Library.loadSystem(LibSTB.class, libName);\n[javac: Core]              ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/util/lmdb/LMDB.java:327: error: no suitable method found for loadSystem(Class<LMDB>,String)\n[javac: Core]   static { Library.loadSystem(LMDB.class, Platform.mapLibraryNameBundled(\"lwjgl_lmdb\")); }\n[javac: Core]                   ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/util/nfd/LibNFD.java:17: error: no suitable method found for loadSystem(Class<LibNFD>,String)\n[javac: Core]       Library.loadSystem(LibNFD.class, libName);\n[javac: Core]              ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/util/par/LibPar.java:17: error: no suitable method found for loadSystem(Class<LibPar>,String)\n[javac: Core]       Library.loadSystem(LibPar.class, libName);\n[javac: Core]              ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/util/simd/LibSSE.java:15: error: no suitable method found for loadSystem(Class<LibSSE>,String)\n[javac: Core]       Library.loadSystem(LibSSE.class, libName);\n[javac: Core]              ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/util/tinyexr/TinyEXR.java:73: error: no suitable method found for loadSystem(Class<TinyEXR>,String)\n[javac: Core]   static { Library.loadSystem(TinyEXR.class, Platform.mapLibraryNameBundled(\"lwjgl_tinyexr\")); }\n[javac: Core]                   ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/util/tinyfd/TinyFileDialogs.java:35: error: no suitable method found for loadSystem(Class<TinyFileDialogs>,String)\n[javac: Core]       Library.loadSystem(TinyFileDialogs.class, Platform.mapLibraryNameBundled(\"lwjgl_tinyfd\"));\n[javac: Core]              ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/util/xxhash/LibXXHash.java:17: error: no suitable method found for loadSystem(Class<LibXXHash>,String)\n[javac: Core]       Library.loadSystem(LibXXHash.class, libName);\n[javac: Core]              ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] /home/someone/git/com.github/LWJGL/lwjgl3/modules/core/src/generated/java/org/lwjgl/util/yoga/Yoga.java:309: error: no suitable method found for loadSystem(Class<Yoga>,String)\n[javac: Core]   static { Library.loadSystem(Yoga.class, Platform.mapLibraryNameBundled(\"lwjgl_yoga\")); }\n[javac: Core]                   ^\n[javac: Core]     method Library.loadSystem(String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Consumer<String>,Class<?>,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,Configuration<String>) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core]     method Library.loadSystem(Class<?>,String,String,String) is not applicable\n[javac: Core]       (actual and formal argument lists differ in length)\n[javac: Core] 12 errors\n```\n$ git log -n 1\ncommit 396b02333a77d54722182c99c73736b6f02bdf44\nAuthor: Ioannis Tsakpinis iotsakp@gmail.com\nDate:   Sat Feb 18 15:00:26 2017 +0200\nUpdate kotlinc to 1.1-rc\n\n```\nI'm curious what will happen if the following change is made to loadSystem but I can't try it locally due to the above compilation error:\n```\n    private static boolean loadSystem(Class<?> context, String libName, String property, String paths) {\n        Path libFile = findLibrary(paths, libName);\n        if (libFile == null) {\n            apiLog(String.format(\"\\t%s not found in %s=%s\", libName, property, paths));\n            return false;\n        }\n    try {\n        final Method m = ClassLoader.class.getDeclaredMethod(\"loadLibrary\", Class.class, String.class, boolean.class);\n        m.setAccessible(true);\n        m.invoke(null, context, libFile.toAbsolutePath().toString(), true);\n    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n        apiLog(String.format(\"\\tError loading library (%s) via reflective ClassLoader call: %s %s\", libName, e, e.getMessage()));\n    }\n\n    System.load(libFile.toAbsolutePath().toString());\n    apiLog(String.format(\"\\tLoaded from %s: %s\", property, libFile));\n    checkHash(context, libFile);\n    return true;\n}\n\n```. > Not sure what is happening exactly, but I would recommend cleaning up your setup so that we can test each issue separately. Delete the snapshot folder and make sure the  application is launched without -Djava.library.path or -Dorg.lwjgl.librarypath.\nAgreed. To be clear, I'm running the program with:\n-Dorg.lwjgl.util.Debug=true -Dorg.lwjgl.system.EmulateSystemLoadLibrary=true -Dorg.lwjgl.util.DebugLoader=true -Xcheck:jni -verbose:jni\nI have to run a Maven task to repackage the published LWJGL jars into OSGi bundles each time, so I'll be sure to routinely nuke ~/.m2/repository/org/lwjgl and ~/.m2/repository/com/io7m/bundles/ each time from now on.\n\nYou need to regenerate the bindings. Running ant compile-templates should do it.\n\nGot it. Seemed like I needed an ant clean as well, for some reason.\n\nI want to avoid reflection on java.lang internals as it is not permitted (by default) on Java 9.\n\nYes, definitely best to avoid this stuff if at all possible.. Hah, making the change I described instead gave me:\nException in thread \"renderer\" java.lang.UnsatisfiedLinkError: Native Library /tmp/lwjglsomeone/3.1.2-SNAPSHOT/liblwjgl_opengl.so already loaded in another classloader\n    at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1907)\n    at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1824)\n    at java.lang.Runtime.load0(Runtime.java:809)\n    at java.lang.System.load(System.java:1086)\n    at org.lwjgl.system.Library.loadSystem(Library.java:170)\n    at org.lwjgl.system.Library.loadSystem(Library.java:152)\n    at org.lwjgl.system.Library.loadSystem(Library.java:119)\n    at org.lwjgl.opengl.GL.<clinit>(GL.java:76)\n    at com.io7m.bundles.org.lwjgl.example.LWJGLExample.doExample(LWJGLExample.java:101)\n    at java.lang.Thread.run(Thread.java:745)\nI can't help but be amused by how awkward this problem is.. Eliminating the second call to System.load seems to work correctly:\n```\nprivate static boolean loadSystem(Class<?> context, String libName, String property, String paths) {\n        Path libFile = findLibrary(paths, libName);\n        if (libFile == null) {\n            apiLog(String.format(\"\\t%s not found in %s=%s\", libName, property, paths));\n            return false;\n        }\n    try {\n        final Method m = ClassLoader.class.getDeclaredMethod(\"loadLibrary\", Class.class, String.class, boolean.class);\n        m.setAccessible(true);\n        m.invoke(null, context, libFile.toAbsolutePath().toString(), true);\n    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n        apiLog(String.format(\"\\tError loading library (%s) reflectively: %s %s\", libName, e, e.getMessage()));\n    }\n\n    apiLog(String.format(\"\\tLoaded from %s: %s\", property, libFile));\n    checkHash(context, libFile);\n    return true;\n}\n\n```\nThis code is wrong, obviously: Assuming that the call was going to be made reflectively, then presumably there should be an attempt made to call System.load if the reflective call failed.. > 2. GL.getResource(\"/liblwjgl_opengl.so\") should return null, so the SharedLibraryLoader is not used.\nThis assumption is incorrect. Thanks to the change you made a couple of commits back:\n// METHOD 2: org.lwjgl.librarypath\n        URL libURL = context.getResource(\"/\" + libName);\n        if (libURL == null) {\n            if (loadSystem(context, libName, Configuration.LIBRARY_PATH))\n                return;\n        } else {\n            // Always use the SLL if the library is found in the classpath,\n            // so that newer versions can be detected.\n            boolean debugLoader = Configuration.DEBUG_LOADER.get(false);\n            try {\n                if (debugLoader)\n                    apiLog(\"\\tUsing SharedLibraryLoader...\");\n                // Extract from classpath and try org.lwjgl.librarypath\n                try (FileChannel ignored = SharedLibraryLoader.load(name, libName, libURL)) {\n                    if (loadSystem(context, libName, Configuration.LIBRARY_PATH))\n                        return;\n                }\n            } catch (Exception e) {\n                if (debugLoader)\n                    e.printStackTrace(DEBUG_STREAM);\n            }\n        }\nFor lwjgl_opengl, the returned URL looks like bundle://10.0:1/liblwjgl_opengl.so which is sufficient for OSGi to locate the resource and for LWJGL to extract it. A reference to the library is also present in the OSGi metadata so we still get the benefits of that.. To clarify: Yes, I'm deleting the temporary directory between each build/run.\nI think the main issues up to this point have been:\n\n\nLocating the native libraries as resources so that LWJGL could extract them. This was originally broken because LWJGL was assuming one global classloader but was fixed when you started passing around explicit class references.\n\n\nLoading the extracted native libraries in the right class loader. This one's still an issue but works given my to-be-avoided reflective call to  ClassLoader.loadLibrary. This one seems to be fixable if we can just get Reflection.getCallerClass() to return the right value via System.load. I think your previous changes would have worked, if not for the misunderstanding about which path the code would be taking on OSGi (which may've been my fault, perhaps I didn't communicate it clearly).. SUCCESS!\n\n\n\ud83c\udf89 \nNice work, thank you! This has certainly been one of the best responses I've had to a bug report in recent memory. It's very life-affirming when developers work to assist with use-cases that they themselves don't have.\nRight now, my plan is to maintain a set of OSGi bundles published to Maven Central under the com.io7m.bundles groupId. I'd be happy to move these into a repos in the LWJGL organization (perhaps with packages published under a separate org.lwjgl.osgi groupId) and maintain them in perpetuity, if you want them. They're really just a set of Maven POMs that turn the published LWJGL jars into OSGi bundles. The nice thing about this is that it can be kept strictly separated from any existing build processes or systems that you have, and can be applied after-the-fact to LWJGL releases. This is actually how I produce Maven packages for JOGL, although there haven't been too many of those recently.. Filed a ticket for this, just for future reference: https://github.com/LWJGL/lwjgl3-osgi/issues/4. Doing it now!. It works correctly.\nI had to introduce a couple of small bundle metadata fixes for OSGi containers that are running on Java 9 VMs, but other than that, the bundles continue to work on both OpenJDK 8 and OpenJDK 9.. ",
    "mikeant42": "Second this\n. ",
    "sriharshachilakapati": "I would like to see Vulkan support in LWJGL too, but I don't think it will happen anytime sooner because this is still so early and there haven't been public drivers except for test drivers by the developers. We should wait for at least until the Vulkan headers were available to the public. Looking forward to this anyways.\n. I mean by test drivers, not public ones. These are the drivers used by the developers of Vulkan demo, it's debuggers, and other things. Additionally, it was known that Valve is making drivers for Intel GPUs, as stated here, http://www.phoronix.com/scan.php?page=news_item&px=Valve-Intel-Vulkan-Driver and also that driver will be opensource. However still, the drivers are not available to the public.\n. Alexander Overvoorde, the author of Open.GL has already started a tutorial site for Vulkan. You can find it online at http://vulkan-tutorial.com/\n. @adoxian \nLWJGL3 just wraps the GLFW library for windowing, and it is not supported to set the icon at runtime with GLFW. However, this is planned with the next release of GLFW. For more information, see these issues in the GLFW Repository.\nhttps://github.com/glfw/glfw/issues/453 - Window icon support\nhttps://github.com/glfw/glfw/pull/467 - Add glfwSetWindowIcons\nAccording to the comments in the above mentioned pull-request, it is known that the feature is implemented in Windows and X11, but no Cocoa support till now. I think it is going to be introduced with GLFW 3.2 release. I'm also hoping to see it as early as possible.\n. @Spasi said that he is looking at STB (which is great because it does fonts, images and also ogg sounds) on the forums. At the same time, a friend of mine is working on a JNI library to Freetype. You can find his repository here: https://github.com/gamingchris3/jfreetype/\n. This is because using those objects will cause the AWT to run it's event loop, and on OSX, the main thread is already used by GLFW. The solution is to set the headless property of the AWT to true.\njava\nSystem.setProperty(\"java.awt.headless\", \"true\");\nSet that property before creating the window, then create the window. Also note that you have to create the fonts or the resources only after the window is created.\n. You are destroying the window twice, once in window.destroy and again with glfwDestroyWindow\n. Are you using value instead of the constant name? MAX_COMBINED_TEXTURE_IMAGE_UNITS is equal to 0x8B4D when I printed it out.\n. @apostolos I think you should allow multiple natives too, as one might want a cross platform configuration.\nAnd the version is 3.0.1-SNAPSHOT but is generated as 3.0.0-SNAPSHOT I think, for the nightly.\n. I think multiple natives do actually make sense. Consider a scenario where me and another guy working on the same project using LWJGL, and we are on different OS. We do want to have the gradle script on the repository, and changing it on one system will cause the new script to go with commit (of course, we can ignore it, but..) making it a bit of a headache maintaining.\nInstead, making the radio buttons into check boxes will suit everyone. In case other platforms are unnecessary, the user can of course un-check them right?\n. @jediminer543\nYou can render the GUI to a texture using a framebuffer and then use it to render the monitor panel triangles in the 3D space. I never worked with Nuklear, but this is how you will be doing normally.. Now that we have JAWT bindings, can't we have it embedded into Swing and embed it into JavaFX using SwingNode?. Aren't you keeping references to your callbacks in code? I'm not sure but I think that might cause these memory leaks too.\n. In case if the problem is not solved, please re-open your previous issue instead of creating new issue which is exactly a copy of your old issue.\n. @Spasi \nHere's the complete log file as produced in my IDE (IntelliJ IDEA Ultimate 15.0.1): http://pastebin.com/jRJjU1dx\nThe only thing I could not understand is why it attempted to load jemalloc32.dll when it should be using jemalloc.dll. This output is with version 3.0.0b Nightly 60.\nWill test with the latest build soon.\n. Thanks, build 61 is now working.\n. Shouldn't the first call of LWJGL should be glfwInit() ?\n. This is not a bug, it's just that the location of natives is referring to a non existing path I think. What I do is to keep a folder called as natives alongside the src dir, and add this before calling glfwInit() function.\njava\nConfiguration.LIBRARY_PATH.set(\"natives\");\nAnd it should work automatically.\n. This is not a valid issue, as all it does is refer to another issue and says that it is resolved in nightlies. I think this should be closed.\n@germangb Please do not create an issue to say that it is resolved. GitHub issues are used to track on real existing issues, and creating an issue which is not valid is not just good.\n. I don't think so, since we already got support for Vulkan in GLFW that LWJGL3 already provides support for, it is better to use existing library here. Also there went a lot of work into LWJGL 3 till now.\n. Wait, this is a duplicate and already mentioned in #50 so I'm closing this issue. Sorry for not looking up early before posting.\n. @johnnic431 It's now available to public, and LunarG has also released a complete Vulkan SDK.\n. Output with -Dorg.lwjgl.util.Debug=true\n[LWJGL] Version: 3.0.0 build 78\n[LWJGL]      OS: Windows 8.1 v6.3\n[LWJGL]     JRE: 1.8.0_51 amd64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v25.51-b03 by Oracle Corporation\n[LWJGL] Shared library extract path: C:\\Users\\Harsha\\AppData\\Local\\Temp\\lwjglHarsha\\7a5bd1ea\n[LWJGL] Loaded library from org.lwjgl.librarypath: lwjgl\n[LWJGL] ThreadLocalUtil state: UnsafeState\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n[LWJGL] Loaded native library: C:\\Users\\Harsha\\AppData\\Local\\Temp\\lwjglHarsha\\7a5bd1ea\\glfw.dll\n[LWJGL] Loaded native library: C:\\WINDOWS\\system32\\opengl32.dll\n[LWJGL] [GL] GL_ARB_shader_subroutine was reported as available but an entry point is missing.\n[LWJGL] Loaded native library: C:\\Users\\Harsha\\AppData\\Local\\Temp\\lwjglHarsha\\7a5bd1ea\\OpenAL.dll\n[LWJGL] Loaded native library: C:\\Users\\Harsha\\AppData\\Local\\Temp\\lwjglHarsha\\7a5bd1ea\\jemalloc.dll\n[LWJGL] MemoryUtil allocator: JEmallocAllocator\nWhen used with -Dorg.lwjgl.system.allocator=system everything runs as expected. However, the loaded data is corrupt.\nException in thread \"Thread-1\" com.shc.silenceengine.core.SilenceException: Failed to load image: Image not of any known type, or corrupt\n    at com.shc.silenceengine.backend.lwjgl.LwjglImageReader.lambda$readImage$1(LwjglImageReader.java:57)\n    at com.shc.silenceengine.backend.lwjgl.LwjglImageReader$$Lambda$65/1335050193.run(Unknown Source)\n    at java.lang.Thread.run(Thread.java:745)\nI'm allocating this buffer to store the bytes from the File and pass them to STB image. This is not happening with BufferUtils class usage.\nShould I send you the source code I was using? I can also create a runnable JAR for this.\n. Wait, the image issue is in my own image, the image is corrupted somehow. Using another image worked as expected. The JEmalloc issue still remains.\n. I'm unable to reproduce this with simple example, but the issue persists in my game somewhere. Can I use JEmalloc to allocate memory from other threads?\n. I just found something else, but related to this issue. This was caused indeed on my way, I forgot to deallocate some buffers (assumed that OS will deallocate memory after JVM exits). But however, I notice that the JVM (java.exe) is still running even though IDEA reported that process terminated successfully with error 0, and that is using all the memory, and force quitting it got my data back.\nHowever, this is not happening if I use system allocator, or BufferUtils. This is the small test that I used to check the behaviour (not sure if there are any issues).\n``` java\nfinal long[] totalMemory = { 0 };\nRandom random = new Random();\nfinal ByteBuffer[] buffer = { null };\nIntStream.range(0, 100).forEach(i ->\n{\n    int size = Math.abs(random.nextInt());\nif (buffer[0] != null)\n    MemoryUtil.memFree(buffer[0]);\n\nSystem.out.println(\"Total Memory Allocated: \" + totalMemory[0] + \" bytes\");\nSystem.out.println(\"Requesting \" + size + \" bytes\");\n\ntotalMemory[0] += size;\n\nbuffer[0] = MemoryUtil.memAlloc(size);\n\n});\nMemoryUtil.memFree(buffer[0]);\n```\nI'll be more cautious from now on this issue, and remember to free up all the unnecessary memory. However, I don't understand why the JVM keeps running. I'm using Windows 10 64 bit and Java 8 update 73. Can you kindly explain what's going on?\n. Thanks spasi. I'm currently on my way home, will let you know in an hour.\nOn Sun, 22 May 2016 8:18 pm Ioannis Tsakpinis, notifications@github.com\nwrote:\n\nHey @sriharshachilakapati https://github.com/sriharshachilakapati,\nI'm fairly sure I found and fixed the issue and it indeed was triggered by\nconcurrent allocations. Could you please download and try the latest\nnightly build (87) to verify?\nFor those using custom jemalloc builds, make sure to build with\n--enable-lazy-lock=no on Windows.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/188#issuecomment-220836320\n. Thank you! This is working pretty much fine now. It was tough to reproduce this. I'm curious, can you please tell me how did you find this out?\n. What about creating maven of gradle scripts instead so to allow importing\ninto any supported IDEs?\n\nOn Sat, 18 Jun 2016 6:23 pm Kai Burjack, notifications@github.com wrote:\n\nAs a first proof of concept: https://github.com/httpdigest/lwjgl3-cli\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/200#issuecomment-226940969, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AEYWNCc_FrDq4kUhaXm3VEmInQHMKB4qks5qM-o7gaJpZM4I46YT\n.\n. It might be that you are having the non-modular version natives with the new 3.0.1 SNAPSHOT. This line explains that error:\n[LWJGL] [WARNING] Mismatch detected between the Java and native LWJGL libraries.\n  Launch the JVM with -Dorg.lwjgl.util.Debug=true for more information.\n\nAnd as far as I know, LWJGL uses the platform's library loading instead of Java's System.loadLibrary method for the natives. Maybe that is the issue you are having.\n. It maybe that Windows and Linux OSes already have the natives in the temp directory. The natives are only extracted when the libraries aren't available in the temp directory. Clean the temp directory and try again on Windows or Linux, maybe that will reveal something.\n. That means you have not included JEmalloc bindings in your project. Either do that, or you can set the allocator to Stdlib.\njava\nConfiguration.MEMORY_ALLOCATOR.set(\"system\");\nThis should fix it.\nedit: Oops, late by seconds!!\n. You also need the JEmalloc natives. Add this runtime configuration.\ngroovy\nruntime \"org.lwjgl:lwjgl-jemalloc:3.0.1-SNAPSHOT:natives-windows\"\n. I think GLFW already had support for clipboard on all platforms it supports. What are the additional features offered by this library?\n. Thanks a lot for your support @Spasi, I learned a lot from you in this process. Thanks for patiently answering all my questions regarding the generator.. For this purpose, I recommend to use either maven or gradle, where you can say the version like this:\n~~~\ncompile \"org.lwjgl:lwjgl-core:${lwjglVersion}\"\n~~~\nThat would be the better solution than changing the naming of the files.. What's the point in removing existing bindings when they are not officially deprecated on their own? Even when OpenXR came, someone might want to use OpenVR or LibOVR directly. Since LWJGL 3 is modular, I don't think keeping them available will not raise any problems.. @nickdbush Yes iOS is Swift / Objective C based, but Multi OS Engine is an AOT transpiler that translates Java code to ARM binary code ahead of time. So if proper efforts are made, LWJGL could run on both Android and iOS with the same code.\nI do however doubt the amount of boilerplate code that MOE adds and whether LWJGL port on iOS is necessary at all. IMO LWJGL is a low-level bindings library, and porting it to iOS requires quite a good amount of abstractions which doesn't fit the goal of LWJGL.. I don't think that matters here because to get mouse in world you'd want to\nunproject it anyways with the combined matrix of the camera.\nOn Wed, 10 May 2017, 8:52 p.m. EmpsThomy, notifications@github.com wrote:\n\nQuick follow-up. Setting -Djava.awt.headless=true works like a charm,\nreally good tip, thanks! I've now run into an issue with DPI scaling\nthough, also on the Mac.\nI know that display of the mac I am testing the application with is\nscaling down the application to run in 1440x900. This works correctly when\nquerying the cursor's position with glfwSetCursorPosCallback, I get\ncursor position values between 0x0 and 1400x900. However, the\nglfwSetFramebufferSizeCallback returns the actual size of the window,\nwithout taking any scalings into consideration. This in fact screws up the\nentire internal mouse pointer handling, because positions are off.\nIs that correct behavior, or is there a way of disabling/enabling DPI\nscaling for position values of\nboth methods glfwSetCursorPosCallback and glfwSetFramebufferSizeCallback?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/306#issuecomment-300517427, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AEYWNBBxh7MLOjjnLM6i0z3NlXcSymtRks5r4dZBgaJpZM4NWWm1\n.\n. Thinking from the docs, I assume that main thread in that context means the thread that called the glfwInit() function right? Even after the change, it should work if that was the cause. He also do seem to set the GLFW error callback.\n\n@BlakeBarnes00 Could you delete all the error logs and retry? Upload the new log after the rerun.. Remove the call to init() in the Window class constructor, it's already being initialized by the game engine. Did you try the native GLFW to verify if this is a problem of your system instead?\nCan you run my game (self running fat jar) http://downloads.goharsha.com/ld38/PlanetDefenseDesktop.jar ?. I guess that line 49 of Window.java is your error. You had this:\n~~~java\nthis.windowHandle = glfwCreateWindow(this.width, this.height, this.title, 1, 0);\n~~~\nThe fourth parameter is the monitor to use, and that is only used to make your window fullscreen on start. For other windows, it should be MemoryUtil.NULL or 0.\nThe error you are having is a SIGSEGV, which means that something got a segmentation fault, like accessing un-owned memory location, and that might be the unknown monitor handle.\nTo get the correct monitor handle, you have to use glfwGetPrimaryMonitor() function to get the ID of the primary monitor. Hope this helps.. Now try to get your threading code back into place. I'm sure running with thread is fine on non-mac machines which your initial code does in the gameEngine.start() method. I'm curious about this.. Good, as I believed, the main thread in this context is the thread that invoked glfwInit() and not the thread that ran your main method. This becomes the later on MacOS, because Cocoa doesn't allow two application event loops in a single application and that contradicts with the EDT of Swing/JavaFX. Congrats on getting this solved, and I guess we both learned a new thing.. @ThePerkinrex Spasi always runs with IntelliJ IDEA, and so do I. That should never be a problem because IntelliJ runs it as a separate process, it is not executed from within the IDE.\nI had this kind of issue happened previously, when I run a project stored on a NTFS formatted USB drive from a linux box. It takes around 10 seconds to properly start. However, neither LWJGL nor IntelliJ are responsible for it, as I can see that even a JavaFX program takes the same amount of time to load from that drive. If I just copied the entire project to the local hard disk, it was fast enough like every other application.\nI seriously doubt if there is anything wrong with LWJGL in this case. Do you have a kinda similar situation as me?. The issue is because you are not giving the class path to the runtime. Give that to the java command as well.\n\nOn 03-Aug-2018, at 7:29 PM, matrximode notifications@github.com wrote:\nbug\nEnvironment\nLWJGL version: 3.2.0\nLWJGL build #: 12\nJava version: 10.0.2\nPlatform: macOS\nModule: org.lwjgl.glfw.Callbacks\nDescription\nIt's been over 10 years since I touched java, I apologize if it is something obvious, but eclipse, and netbeans no longer match the \"Getting Started\" descriptions. I did not try to use IntelliJ. I am trying to compile from CLI (bash terminal) at this point, and the following step appears to be working:\nFirst I just put the HelloWorld.java file in the same folder as all the \".jars\" from the zip. (I also tried it minus the doc and source .jars, seems irrelevant)\njavac HelloWorld.java -classpath lwjgl-assimp-natives-macos.jar:./lwjgl-assimp.jar:./lwjgl-bgfx-natives-macos.jar:./lwjgl-bgfx.jar:./lwjgl-egl.jar:./lwjgl-glfw-natives-macos.jar:./lwjgl-glfw.jar:./lwjgl-jawt.jar:./lwjgl-jemalloc-natives-macos.jar:./lwjgl-jemalloc.jar:./lwjgl-lmdb-natives-macos.jar:./lwjgl-lmdb.jar:./lwjgl-lz4-natives-macos.jar:./lwjgl-lz4.jar:./lwjgl-nanovg-natives-macos.jar:./lwjgl-nanovg.jar:./lwjgl-natives-macos.jar:./lwjgl-nfd-natives-macos.jar:./lwjgl-nfd.jar:./lwjgl-nuklear-natives-macos.jar:./lwjgl-nuklear.jar:./lwjgl-odbc.jar:./lwjgl-openal-natives-macos.jar:./lwjgl-openal.jar:./lwjgl-opencl.jar:./lwjgl-opengl-natives-macos.jar:./lwjgl-opengl.jar:./lwjgl-opengles-natives-macos.jar:./lwjgl-opengles.jar:./lwjgl-openvr-natives-macos.jar:./lwjgl-openvr.jar:./lwjgl-par-natives-macos.jar:./lwjgl-par.jar:./lwjgl-remotery-natives-macos.jar:./lwjgl-remotery.jar:./lwjgl-rpmalloc-natives-macos.jar:./lwjgl-rpmalloc.jar:./lwjgl-sse-natives-macos.jar:./lwjgl-sse.jar:./lwjgl-stb-natives-macos.jar:./lwjgl-stb.jar:./lwjgl-tinyexr-natives-macos.jar:./lwjgl-tinyexr.jar:./lwjgl-tinyfd-natives-macos.jar:./lwjgl-tinyfd.jar:./lwjgl-tootle-natives-macos.jar:./lwjgl-tootle.jar:./lwjgl-vma-natives-macos.jar:./lwjgl-vma.jar:./lwjgl-vulkan-natives-macos.jar:./lwjgl-vulkan.jar:./lwjgl-xxhash-natives-macos.jar:./lwjgl-xxhash.jar:./lwjgl-yoga-natives-macos.jar:./lwjgl-yoga.jar:./lwjgl-zstd-natives-macos.jar:./lwjgl-zstd.jar:./lwjgl.jar\neverything good so far.\nbut this is a problem\njava -cp \"./lwjgl.jar:.\" HelloWorld\nResults in this error.\nHello LWJGL 3.2.0 build 12!\nException in thread \"main\" java.lang.NoClassDefFoundError: org/lwjgl/glfw/GLFWErrorCallback\nat HelloWorld.init(HelloWorld.java:37)\nat HelloWorld.run(HelloWorld.java:22)\nat HelloWorld.main(HelloWorld.java:112)\nCaused by: java.lang.ClassNotFoundException: org.lwjgl.glfw.GLFWErrorCallback\nat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:582)\nat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:190)\nat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:499)\n... 3 more\nIs this a legit issue, or just user error. I cannot find GLFWErrorCallback.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub https://github.com/LWJGL/lwjgl3/issues/401, or mute the thread https://github.com/notifications/unsubscribe-auth/AEYWNAEe6GFZqVdfFieHBWx-7CmPVDzZks5uNFclgaJpZM4VuALI.\n\n\n. ",
    "phase": "I can't wait to see this in LWJGL!\n. ",
    "Blunderchips": "This would be amazing to see!\n. will do\n. ",
    "phr00t": "As virtual reality takes hold, this \"enhancement\" would be a big improvement. Any updates on this?\n. I suppose I can't ask for much more!\nI'm working with jMonkeyEngine, which has LWJGL 3 support. Do you suspect LWJGL's support of Vulkan will require significant changes to a rendering pipeline to benefit from it, or will it be an \"under the hood\" kind of change that LWJGL 3 users will benefit from mostly automatically?\n. Windows 10 x64. This something that has to be newly called somewhere?\n. Calling glfwFocusWindow after glfwShowWindow does the trick. Changing .release to .free also fixes the other problem. Should be all set, thank you!\n. Windowed.\n. If I'm not mistaken, I set GLFW_VISIBLE to false, because the documentation says you should if you want to reposition it (which I was doing). I later didn't \"focus\" it, like I should have (did a function exist then to do so?). Previously, it showed anyway, so I didn't think anything of it. I think the current behavior is more correct, if it is following @Spasi's description of the documentation.\n. ",
    "adoxian": "Thanks for the reply. I'm hoping so as well. \n. ",
    "neon64": "Yes I just realised I needed to do that :)\nAfter asking for a 3,2 context with core profile etc it works fine.\nPerhaps it could help to have a bit better error message though?\n. Thanks for the info. I think stb is what I (and probably many others) require. Shall I close the issue?\n. ",
    "Tetramputechture": "@Spasi I don't see a way change the font size in the OverSample demo. \n. @Spasi I mean change  the font size directly, like specifying a point size for it to use, like in the previous demo (not Oversample, just TrueType)\n. @Spasi Right, but that gives odd results, and it's questionable how to change that. Why are there two values? \n. ",
    "SmashMaster": "Nothing to see here--false alarm. The OpenGL wiki has a typo. The specs are clear, rectangle textures are core in 3.1:\nhttps://www.opengl.org/registry/doc/glspec31.20090528.pdf\n. Fixed the typo on the OpenGL wiki.\n. ",
    "nlacombe42": "Personally I would like to be able to customize log message format by having LWJGL using SLF4J.\nI am using SLF4J in my project so that would make it very easy to me.\n. ",
    "mufumbo": "@Spasi this haven't been released to the maven release 3.1? or changed since there?. ",
    "FortressBuilder": "Just in case there's an error with GLFW, you should set up an error callback.\npublic class SnakeGame {\n    GLFWErrorCallback errorCallback;\n    // ...\n    private void init() {\n        errorCallback = Callbacks.errorCallbackPrint();\n        glfwSetErrorCallback(errorCallback);\n        // ...\n    }\n}\n. Turns out I was calling Callbacks.glfwReleaseCallbacks after destroying the window and only now with the latest build the memory leaks were detected. It's working fine now.\n. ",
    "Cethric": "The freeze also occurs on Mac (tested on OSX 10.10)\n. ",
    "badlogic": "Honestly, i think you should stick with the Ant build. Gradle is a major pain in the butt, and i see no benefit in using Gradle for the general build. This is non-invasive and self-contained, and almost easy to understand.\nGive up on the Gradle build and focus on the code instead.\n. Eh, nm, just saw the Gradle branch. Not much Gradle in there yet. But i guess it has the new modules separation as well. Let me retarget.\n. Actually, to much work, it's 1:25am over here. I let you decide what to do with the single build.gradle file :)\n. In short: it's a mess, as big if not bigger than Ant. Wgile the scripts may\nlook more maintainable at first, they'll only be maintainable by yourself,\nespecially if you do anything other than standard Java projects. The LOC\ncount is likely the same as with Ant. You also get a metric ton of magic\nnobody understands and Gradle is still a moving target. I'd recommend\nsticking with Ant and keep my simple Gradle file to deploy Maven artifacts\nlocally or to SonaType/Central.\nOn Jun 25, 2015 10:56 AM, \"Ioannis Tsakpinis\" notifications@github.com\nwrote:\n\nThanks Mario, for the gradle script and the deployment tutorial. I don't\nhave access to the org.lwjgl group atm, it will take some time to resolve\nthe situation.\nDon't worry about the gradle branch, I haven't pushed the latest changes\nanyway. I'll add your script manually when it's ready.\nI'm wondering why you think gradle is a pita. I'm starting to form a\nsimilar opinion, but it would be interesting to hear from someone with more\nexperience. My top complains would be:\n- Multiple ways to do the same thing. No two scripts are alike, which\n  I find really strange for a build system that favors convention over\n  configuration.\n- Performance is a joke, even with the daemon. Seriously, multiple\n  seconds for stuff that are instant with Ant.\nOn the other hand, it certainly looks like that the Gradle scripts will be\ncleaner and more maintainable than the Ant scripts.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/pull/70#issuecomment-115169864.\n. I fixed up the build and published 3.0.0a to Maven Central. I'm setting up a Jenkins job that publishes SNAPSHOT builds to SonaType if that's OK with you. For that, i had to increase the version in build.gradle to 3.0.0b. For the next release, we need to set the version to whatever you deem good.\n. Closed in favor of #71 \n. I needed something to package for that specific artifact because Gradle\nsucks. The build.gradle was the smallest file, so i eventually gave in and\nused that.\n\nThanks for the merge! Did you setup a build job for snapshots? Still happy\nto do that on my end if you want.\nOn Jul 1, 2015 8:05 PM, \"Ioannis Tsakpinis\" notifications@github.com\nwrote:\n\nMerged #71 https://github.com/LWJGL/lwjgl3/pull/71.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/pull/71#event-345686283.\n. \n",
    "b23prodtm": "I find this as good guidelines to Maven2 publishing. I'm sure it can help. \nNervertheless I'm not used to the POM form for the desktop application.. In my opinion, POM is a pattern designed to maintain over Web Apps, which stand onto web HTML/JS API bindings (and the maven central dependencies), that update faster than OS SDK.\nRegards\n. ",
    "Bobo1239": "It's working now. Thank you!\n. This only works for \"normal\" LWJGL log messages. OpenGL debug log messages use LF as line separator.\n. Appears to work fine on Windows 10 x64.\nI just cloned the repo, ran Swt33CoreMsDemo, and played around with the values of the GLData structure.\nAre there other things to test?\n. getGLData() as well as the the SharedContextsDemo work. Unfortunately, I'm still an OpenGL beginner and haven't worked with extensions yet so I can't help you test them without assistance.\n. 17:09:22.408 [main] INFO LWJGL - Version: 3.0.0 build 90\n17:09:22.409 [main] INFO LWJGL -     OS: Linux v4.6.2-1-ARCH\n17:09:22.409 [main] INFO LWJGL -    JRE: 1.8.0_92 amd64\n17:09:22.409 [main] INFO LWJGL -    JVM: OpenJDK 64-Bit Server VM v25.92-b14 by Oracle Corporation\n17:09:22.409 [main] INFO LWJGL - Loading library (system): lwjgl\n17:09:22.431 [main] INFO LWJGL -    liblwjgl.so not found in java.library.path=.::/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib\n17:09:22.431 [main] INFO LWJGL -    Using SharedLibraryLoader...\n17:09:22.432 [main] INFO LWJGL -    Extracting: file:/home/bobo1239/.gradle/caches/modules-2/files-2.1/org.lwjgl/lwjgl-platform/3.0.0/f622d9e6aea3ab20e8d57ea02083310f067209d0/lwjgl-platform-3.0.0-natives-linux.jar!/liblwjgl.so\n17:09:22.462 [main] INFO LWJGL -    Loaded from org.lwjgl.librarypath: /tmp/lwjglbobo1239/c055ad3b/liblwjgl.so\n17:09:22.490 [main] INFO LWJGL - ThreadLocalUtil state: UnsafeState\n17:09:22.497 [main] INFO LWJGL - MemoryUtil accessor: MemoryAccessorUnsafe\n17:09:22.508 [main] INFO LWJGL - Loading library: glfw\n17:09:22.511 [main] INFO LWJGL -    Loaded from org.lwjgl.librarypath: /tmp/lwjglbobo1239/c055ad3b/libglfw.so\n17:09:22.875 [main] INFO LWJGL - Loading library: libGL.so.1\n17:09:22.879 [main] INFO LWJGL -    libGL.so.1 not found in org.lwjgl.librarypath=/tmp/lwjglbobo1239/c055ad3b\n17:09:22.880 [main] INFO LWJGL -    Loaded from java.library.path: /usr/lib64/libGL.so.1\n17:09:23.237 [main] INFO LWJGL - [GL] Using KHR_debug for error logging.\n17:09:23.248 [main] INFO LWJGL - Loading library: openal\n17:09:23.248 [main] INFO LWJGL -    libopenal.so not found in org.lwjgl.librarypath=/tmp/lwjglbobo1239/c055ad3b\n17:09:23.249 [main] INFO LWJGL -    Loaded from java.library.path: /usr/lib64/libopenal.so\nconnect(2) call to /dev/shm/jack-1000/default/jack_0 failed (err=No such file or directory)\nattempt to connect to server failed\n17:09:23.534 [main] INFO LWJGL - Loading library: jemalloc\n17:09:23.534 [main] INFO LWJGL -    libjemalloc.so not found in org.lwjgl.librarypath=/tmp/lwjglbobo1239/c055ad3b\n17:09:23.535 [main] INFO LWJGL -    Loaded from java.library.path: /usr/lib64/libjemalloc.so\nException in thread \"main\" java.lang.ExceptionInInitializerError\n    at org.lwjgl.system.MemoryManage$JEmallocAllocator.config(MemoryManage.java:100)\n    at org.lwjgl.system.MemoryUtil$LazyInit.<clinit>(MemoryUtil.java:81)\n    at org.lwjgl.system.MemoryUtil.nmemAlloc(MemoryUtil.java:162)\n    at org.lwjgl.system.MemoryUtil.memAlloc(MemoryUtil.java:180)\n    at org.lwjgl.system.MemoryUtil.memUTF8(MemoryUtil.java:1530)\n    at org.lwjgl.system.APIUtil.apiArrayi(APIUtil.java:430)\n    at org.lwjgl.opengl.GL20.glShaderSource(GL20.java:425)\n    at bms.opengl.Shader.<init>(Shader.java:36)\n    at bms.font.Font.initialize(Font.java:86)\n    at bms.font.FontManager.initialize(FontManager.java:17)\n    at bms.Bms.initialize(Bms.java:82)\n    at bms.Bms.main(Bms.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\nCaused by: java.lang.IllegalStateException: This function is not available.\n    at org.lwjgl.system.Checks.checkFunctionAddress(Checks.java:89)\n    at org.lwjgl.system.APIUtil.apiGetFunctionAddress(APIUtil.java:121)\n    at org.lwjgl.system.jemalloc.JEmalloc$Functions.<clinit>(JEmalloc.java:46)\n    ... 17 more\nThe temp directory contains the extracted libglfw.so and liblwjgl.so. If I rename my system libjemalloc.so, libjemalloc.so also gets extracted to the temp directory and everything works. Starting the application after libjemalloc.so is present in the temp directory, there is no problem as the temp directory apprantly has a higher precedence in the load path.\n. 17:53:14.444 [main] INFO bms.Bms - Hello LWJGL 3.0.0 build 90!\n17:53:14.466 [main] INFO LWJGL - Version: 3.0.0 build 90\n17:53:14.466 [main] INFO LWJGL -     OS: Linux v4.6.2-1-ARCH\n17:53:14.467 [main] INFO LWJGL -    JRE: 1.8.0_92 amd64\n17:53:14.467 [main] INFO LWJGL -    JVM: OpenJDK 64-Bit Server VM v25.92-b14 by Oracle Corporation\n17:53:14.467 [main] INFO LWJGL - Loading library (system): lwjgl\n17:53:14.482 [main] INFO LWJGL -    liblwjgl.so not found in java.library.path=.\n17:53:14.483 [main] INFO LWJGL -    Using SharedLibraryLoader...\n17:53:14.489 [main] INFO LWJGL -    Extracting: file:/home/bobo1239/.gradle/caches/modules-2/files-2.1/org.lwjgl/lwjgl-platform/3.0.0/f622d9e6aea3ab20e8d57ea02083310f067209d0/lwjgl-platform-3.0.0-natives-linux.jar!/liblwjgl.so\n17:53:14.520 [main] INFO LWJGL -    Loaded from org.lwjgl.librarypath: /tmp/lwjglbobo1239/c055ad3b/liblwjgl.so\n17:53:14.542 [main] INFO LWJGL - ThreadLocalUtil state: UnsafeState\n17:53:14.548 [main] INFO LWJGL - MemoryUtil accessor: MemoryAccessorUnsafe\n17:53:14.561 [main] INFO LWJGL - Loading library: glfw\n17:53:14.565 [main] INFO LWJGL -    Loaded from org.lwjgl.librarypath: /tmp/lwjglbobo1239/c055ad3b/libglfw.so\n17:53:14.907 [main] INFO LWJGL - Loading library: libGL.so.1\n17:53:14.908 [main] INFO LWJGL -    libGL.so.1 not found in org.lwjgl.librarypath=/tmp/lwjglbobo1239/c055ad3b\n17:53:14.910 [main] INFO LWJGL -    libGL.so.1 not found in java.library.path=.\n17:53:14.911 [main] INFO LWJGL -    Loaded from system paths\n17:53:15.254 [main] INFO LWJGL - [GL] Using KHR_debug for error logging.\n17:53:15.267 [main] INFO LWJGL - Loading library: openal\n17:53:15.267 [main] INFO LWJGL -    libopenal.so not found in org.lwjgl.librarypath=/tmp/lwjglbobo1239/c055ad3b\n17:53:15.267 [main] INFO LWJGL -    libopenal.so not found in java.library.path=.\n17:53:15.268 [main] INFO LWJGL -    Loaded from system paths\nconnect(2) call to /dev/shm/jack-1000/default/jack_0 failed (err=No such file or directory)\nattempt to connect to server failed\n17:53:15.612 [main] INFO LWJGL - Loading library: jemalloc\n17:53:15.612 [main] INFO LWJGL -    libjemalloc.so not found in org.lwjgl.librarypath=/tmp/lwjglbobo1239/c055ad3b\n17:53:15.613 [main] INFO LWJGL -    libjemalloc.so not found in java.library.path=.\n17:53:15.613 [main] INFO LWJGL -    Loaded from system paths\nException in thread \"main\" java.lang.ExceptionInInitializerError\n    at org.lwjgl.system.MemoryManage$JEmallocAllocator.config(MemoryManage.java:100)\n    at org.lwjgl.system.MemoryUtil$LazyInit.<clinit>(MemoryUtil.java:81)\n    at org.lwjgl.system.MemoryUtil.nmemAlloc(MemoryUtil.java:162)\n    at org.lwjgl.system.MemoryUtil.memAlloc(MemoryUtil.java:180)\n    at org.lwjgl.system.MemoryUtil.memUTF8(MemoryUtil.java:1530)\n    at org.lwjgl.system.APIUtil.apiArrayi(APIUtil.java:430)\n    at org.lwjgl.opengl.GL20.glShaderSource(GL20.java:425)\n    at bms.opengl.Shader.<init>(Shader.java:36)\n    at bms.font.Font.initialize(Font.java:86)\n    at bms.font.FontManager.initialize(FontManager.java:17)\n    at bms.Bms.initialize(Bms.java:82)\n    at bms.Bms.main(Bms.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\nCaused by: java.lang.IllegalStateException: This function is not available.\n    at org.lwjgl.system.Checks.checkFunctionAddress(Checks.java:89)\n    at org.lwjgl.system.APIUtil.apiGetFunctionAddress(APIUtil.java:121)\n    at org.lwjgl.system.jemalloc.JEmalloc$Functions.<clinit>(JEmalloc.java:46)\n    ... 17 more\n. Perfect; Thank you!\n. ",
    "CaesarCGS": "I'm having the same issue but on mac, there is an error:\nException in thread \"main\" java.lang.ExceptionInInitializerError\n    at audio.AudioMaster.init(AudioMaster.java:22)\n    at test.Main.main(Main.java:9)\nCaused by: java.lang.RuntimeException: Failed to dynamically load library: /[there was path to my project]/lwjgl3/native/libopenal.dylib\n    at org.lwjgl.system.macosx.MacOSXLibraryDL.(MacOSXLibraryDL.java:23)\n    at org.lwjgl.system.macosx.MacOSXLibrary.create(MacOSXLibrary.java:20)\n    at org.lwjgl.system.APIUtil.apiCreateLibrary(APIUtil.java:80)\n    at org.lwjgl.system.Library$2.load(Library.java:33)\n    at org.lwjgl.system.Library$2.load(Library.java:30)\n    at org.lwjgl.system.Library.loadLibrary(Library.java:196)\n    at org.lwjgl.system.Library.loadNative(Library.java:135)\n    at org.lwjgl.openal.ALC.create(ALC.java:49)\n    at org.lwjgl.openal.ALC.create(ALC.java:45)\n    at org.lwjgl.openal.ALC.(ALC.java:24)\n    ... 2 more\n. With the latest nightly version:\n[LWJGL] Version: 3.0.0 build 78\n[LWJGL]      OS: Mac OS X v10.11.4\n[LWJGL]     JRE: 1.8.0_74 x86_64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v25.74-b02 by Oracle Corporation\n[LWJGL] Loaded library from java.library.path: lwjgl\n[LWJGL] ThreadLocalUtil state: UnsafeState\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n[LWJGL] Failed to extract glfw library\njava.lang.RuntimeException: Failed to dynamically load library: /[path to my project]//lwjgl/native/libglfw.dylib(error = dlopen(/[path to my project]/lwjgl/native/libglfw.dylib, 9): image not found)\n    at org.lwjgl.system.macosx.MacOSXLibraryDL.(MacOSXLibraryDL.java:24)\n    at org.lwjgl.system.macosx.MacOSXLibrary.create(MacOSXLibrary.java:20)\n    at org.lwjgl.system.APIUtil.apiCreateLibrary(APIUtil.java:84)\n    at org.lwjgl.system.Library.lambda$static$1(Library.java:32)\n    at org.lwjgl.system.Library.loadLibrary(Library.java:230)\n    at org.lwjgl.system.Library.loadNativeRelative(Library.java:167)\n    at org.lwjgl.system.Library.loadNative(Library.java:146)\n    at org.lwjgl.glfw.GLFW.(GLFW.java:463)\n    at sun.misc.Unsafe.ensureClassInitialized(Native Method)\n    at sun.reflect.UnsafeFieldAccessorFactory.newFieldAccessor(UnsafeFieldAccessorFactory.java:43)\n    at sun.reflect.ReflectionFactory.newFieldAccessor(ReflectionFactory.java:142)\n    at java.lang.reflect.Field.acquireFieldAccessor(Field.java:1088)\n    at java.lang.reflect.Field.getFieldAccessor(Field.java:1069)\n    at java.lang.reflect.Field.getInt(Field.java:574)\n    at org.lwjgl.system.APIUtil.apiClassTokens(APIUtil.java:258)\n    at org.lwjgl.glfw.GLFWErrorCallback$1.(GLFWErrorCallback.java:79)\n    at org.lwjgl.glfw.GLFWErrorCallback.createPrint(GLFWErrorCallback.java:78)\n    at audio.AudioMaster.init(AudioMaster.java:28)\n    at test.Main.main(Main.java:9)\nException in thread \"main\" java.lang.ExceptionInInitializerError\n    at sun.misc.Unsafe.ensureClassInitialized(Native Method)\n    at sun.reflect.UnsafeFieldAccessorFactory.newFieldAccessor(UnsafeFieldAccessorFactory.java:43)\n    at sun.reflect.ReflectionFactory.newFieldAccessor(ReflectionFactory.java:142)\n    at java.lang.reflect.Field.acquireFieldAccessor(Field.java:1088)\n    at java.lang.reflect.Field.getFieldAccessor(Field.java:1069)\n    at java.lang.reflect.Field.getInt(Field.java:574)\n    at org.lwjgl.system.APIUtil.apiClassTokens(APIUtil.java:258)\n    at org.lwjgl.glfw.GLFWErrorCallback$1.(GLFWErrorCallback.java:79)\n    at org.lwjgl.glfw.GLFWErrorCallback.createPrint(GLFWErrorCallback.java:78)\n    at audio.AudioMaster.init(AudioMaster.java:28)\n    at test.Main.main(Main.java:9)\nCaused by: java.lang.RuntimeException: Failed to dynamically load library: /[path to my project]/lwjgl/native/libglfw.dylib(error = null)\n    at org.lwjgl.system.macosx.MacOSXLibraryDL.(MacOSXLibraryDL.java:24)\n    at org.lwjgl.system.macosx.MacOSXLibrary.create(MacOSXLibrary.java:20)\n    at org.lwjgl.system.APIUtil.apiCreateLibrary(APIUtil.java:84)\n    at org.lwjgl.system.Library.lambda$static$1(Library.java:32)\n    at org.lwjgl.system.Library.loadLibrary(Library.java:230)\n    at org.lwjgl.system.Library.loadNativeRelative(Library.java:167)\n    at org.lwjgl.system.Library.loadNative(Library.java:140)\n    at org.lwjgl.glfw.GLFW.(GLFW.java:463)\n    ... 11 more\nps. Thank you very much for quick answer.\n. With eclipse and code(in run configurations):\n-XstartOnFirstThread\nIt is breaking when call ALC.create();, or when I try to set GLFWErrorCallback\nps. I'm using JavaSE-1.8\n. No I'm not...\n. So how should I set this?\n. I'm only add jar(lwjgl.jar) to the java build path and set native folder to native(from lwjgl folder).\n. I must read something about it, because I really don't know how to do it...\nI'm sorry for wasting your time. I have to learn more about it. I'm just a beginner but can you recommend me some tutorial?\n. I did it as you say but I still receive error(I'm sure that path is right).\n. Ok now it starts getting weird. I copied version  of LWJGL from older project(which work pretty good), but I still have the same error(even if copy whole code)!\n. There was no need to extract the files(no .zip formats).\n. I finally managed to fix it. I have to reinstall eclipse and recreate all projects. It seems that with old eclipse(before reinstall) all projects was creating with some kind of bug/malfunction(or something like that), and with the new version it seems to work.\nps. Thank you all guys for suggestions and quick answers. You helped me a lot.\n. ",
    "Wolftein": "Just found out i forgot to cast.\n. ",
    "hoinshembl": "thanks, i guess I'll just leave the issue open until a newer glfw version is used\n. ",
    "kappaOne": "have you tried the latest nightly build of LWJGL3? I recall this issue being there in an older build but should be fixed in the most recent build.\n. in case it helps, was looking into this problem a while back too, found that both LibGDX and Slick2D have a nice collection of 2d triangulators written in Java which seem to work well.\n. From my tests so far LibGDX's EarClippingTriangulator seems the most robust triangulator. The MannTriangulator is also good and even faster in a few cases than the EarClippingTriangulator, however found it glitched on a few use cases (maybe I was using an unsupported draw order or something).\nAs for holes, I've found that adding a double edge slice and the hole in reverse to the original points/shape allows you to then pretty much use any triangulator (even those that don't support holes), the full technique can be read about at section 3 of this link http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\nI've also written a triangulator based on the technique found here http://www.emanueleferonato.com/2011/09/12/create-non-convex-complex-shapes-with-box2d/ which basically splits any concave shape into convex. Then just brute forces the convex shape into triangles (picks a point in the shape and draw lines to all other points in the shape) which works fast. However at the moment it has a few kinks that I'm trying to iron out before it's usable.\nDepending on your usecase GPU triangulation seems to be pretty popular (implemented by browser vendors) using the stencil buffer technique (probably could also implement it using a FBO and shaders these days). Some details of the implementation can be found here and here. If usable for your usecase its pretty fast (and supports holes) however has the disadvantage in that it doesn't provide you with the actual points for the new triangles.\n. Also I came across this library which looks pretty nice feature wise, though haven't got round to trying it yet. It has a slightly out of date java port here. It's not much code (single class) so porting the latest javascript version to java doesn't look like a huge task.\n. I'd recommend focusing on getting the 3.0 release done first, once the core and basic bindings (GLFW, OpenGL and OpenAL) are done/released then the rest can be added in later releases (like in 3.1). I'd go with a release early, release often, approach.\n. really nice work, looks awesome especially for game gui's.\n. Just updated nightly builds, something seems to have broken on my mac system (OSX 10.11) between \"LWJGL 3.0.1 build 13\" and \"LWJGL 3.0.1 build 17\" with OpenAL, the following calls now return just '0', whereas previously they returned proper values:\njava\nint bytes = AL10.alGetBufferi(buffer, AL10.AL_SIZE);\nint bits = AL10.alGetBufferi(buffer, AL10.AL_BITS);\nint channels = AL10.alGetBufferi(buffer, AL10.AL_CHANNELS);\nSame code with build 17 works fine on linux.\n. > I've now reverted it to Xcode 7.2. You can download a fixed OpenAL build here, it will also be included in the next LWJGL nightly.\nJust updated to LWJGL 3.0.1 build 18 and can confirm it works great on macOS now.\n. Looks great, would love to be able to download custom zip bundles.\n. Would merging smaller jars/zips (possibly the maven ones) on the client side (using maybe a javascript zip libraries) be a viable option to create a custom zip?\n. Do agree that TWL is a great option for rendering GUI on top of 3d content. It only supports LWJGL2 atm, though looking at the code base it doesn't seem all that much work to port to LWJGL3.\nHowever for standalone ui's, SWT is probably the best and most mature option out there. It integrates nicely with the native platform and is small and lightweight. It also strips down pretty nicely (to a few KB's, the Avian example are good examples of how small, less than a meg for SWT support and the Avian JVM!).\nSo looking into getting LWJGL3 nicely integrated with SWT should be explored. IMO a much better investment then spending time on AWT or JavaFX.\nInterestingly, l33tlabs (who host TWL), work on a really interesting project called Bling. They've somehow integrated SWT with TWL! I think they also use LWJGL2. They already have a full IDE running on the same, so pretty far along. There is a pretty long video here explaining how it works and theres a quick preview of what it looks like here.\nI'm not sure what l33tlabs plans are but if they released the underlying SWT/TWL library or if something similar could be written, it could probably be the ultimate and complete solution for LWJGL3 i.e. a small lightweight API that can render ui inside OpenGL applications, create native platform widgets (like dialog's, system tray integration, native controls, etc) or even enable full blown native applications that can render opengl content inside it (e.g. particle editors, game engine editors, etc).\n. IMO any proper solution is really going to need help from the JavaFX team at Oracle, such as them adding an API for this sort of stuff or for them to expose certain internals of JavaFX which we can use to implement it properly.\nWithout the above, any solution is just going to be a hack, likely non-optimal and subject to breakage. JavaFX at present just isn't designed to allow this sort of integration.. Interestingly, planning for JavaFX.next (Java 10+) is currently taking place over at http://mail.openjdk.java.net/pipermail/openjfx-dev/2016-December/020025.html and Oracle are asking for suggestions.\nMight be a good opportunity to chime in and request support for OpenGL/Vulkan via LWJGL.. Implementing AWTGLCanvas with LWJGL3 on Windows and Linux shouldn't be too difficult. The real problem however is implementing it on OSX as there is currently no nice solution. It was really messy getting it working on LWJGL2 and IMO LWJGL3 would be better off just avoiding going down the same path again.\n. Another possible solution for showing a splash screen could be using the SWT library instead of AWT/Swing/JavaFX. Its works well with LWJGL3 and supports loadings and displaying animated gifs (or even a native progress bar).\n. Hopefully XML won't be the chosen format (tis really horrid). Not sure it offers enough but YAML might be a good option to consider, its nice to look at and read.\n. Using an existing format has the advantage of already having existing libraries, tools and validators that can be used. IDE's like Eclipse, Intellij, Netbeans (even GitHub) already support XML, JSON, YAML (via plugins if not built in support) which can provide syntax highlighting and error checking. Further there is existing documentation and tutorials for these formats and developers may already be familiar with them allowing lower entry for contributions.\nThis is something a custom format will be missing and therefore require a lot more work to implement and maintain.\n. This looks like an awesome feature to have and would really allow clean looking LWJGL code (without the horrid NIO buffers).\nMaybe LWJGL could have methods (or a utility class) that accept primitive arrays and where not supported (pretty rare situation IMO), automatically copying it to a buffer and using the buffer version of that API. Would allow users to use standard java arrays everywhere without worrying too much about compatibility.\n. Just some points to note, dropping Java 6 will mean dropping support for OS X 10.6 (and lower) as Java 7 requires OS X 10.7+. Dropping Java 7 will mean dropping support for OS X 10.7 (and lower) as Java 8 requires OS X 10.8+. Although it should be noted that subsequent OS X updates have been free for most, so shouldn't be that much of an issue.\n. While we're talking licence, on the footer of the lwjgl.org site it says \"Licensed under GPL\" shouldn't that say \"Licensed under BSD\" ? \n. This is a message thrown by OpenAL-Soft (libopenal.so) and not LWJGL3. If it is a problem and you need a quick fix you could always just replace libopenal.so with an older version (such as the one bundled with LWJGL2).\nhttps://github.com/kcat/openal-soft/issues/53\n. Ah, you are correct, disabling Panda Free Antivirus, causes the issue not to happen. So the antivirus is temporarily locking the files when extracted. Annoying problem to workaround for end users.\n. Sleeping and retrying should work, however another possible solution on Windows might be to use Java's FileChannel/FileLock classes. \nSo we could extract a native and get a file lock on it (or even lock the FileOutputStream while extracting), then load the natives using LWJGL after which the native file can be unlocked.\nIf this works, it might be a good solution, since in theory would prevent other applications from getting an exclusive lock on the native file and/or deleting it before its loaded/unlocked.\nA shared file lock should even allow other application like a virus scanner to scan the file while its in use.\nGuess this will need a bit of experimenting to see if it works.\n. Thanks, I'll give it a test and report back. \nWe might be able to avoid the sleep look by using FileChannel.lock() instead of FileChannel.tryLock(), as that method waits for any existing locks to unlock before returning.\n. Just finished testing the sll_lock_fix code and can confirm that it works and there is no in use by another process error.\nEverything is fine when the antivirus is disabled, however when enabled there is a 1.5 second delay for each native that is extracted (which adds up due to number of natives). We could leave code as is and leave the delay as its the scanner which is interfering but is pretty annoying and may not be clear to end users where delay is coming from.\nI've done some debugging to see where in the code the delay happens and it appears to be to kicking in straight after the line:\njava\nwhile ( (n = input.read(buffer)) > 0 ) output.write(buffer, 0, n);\nwhen the extractFile method returns.\nIt appears the scanner is getting in before the lock and after the native has been written. \nOne idea could be to get the lock in the extractFile method. This could be done just before or with the FileOutputStream by getting a FileChannel and storing it in a static global variable. Then after the native has been loaded by LWJGL the FileChannel/Lock can be released in the sll.\n. Tested updated code however no luck. The first code seems cleaner. \nAfter lots of testing I'm not sure locking files is going to help much, best we can do is before loading a native, test if its locked, if it is, then do a sleep+retry loop.\n. Same behaviour as before, i.e. still slow when antivirus is running\nYeh, tested exclusive lock too, same issue.\n1) The plan was to lock the file, get Java's System.load to load the locked native file and then unlock the native file, however this doesn't work, in my testing System.load fails if the native file is locked, even if it's by the same process.\n2) Your initial code, did the following:\na) extracted the natives and \nb) then tries using a sleep+retry until it gets a file lock. \nc) Thereafter it unlocks native file and \nd) System.load loads the unlocked native file. \nThe problem was the antivirus kicked in immediately after a) and blocks the process for 1.5 seconds. Maybe there is some sort of notification by the OS to antivirus as soon as a file is created.\n3) Your second code did the following\na) extracts the native file and \nb) obtains the lock immediately on the file before the stream closes.\nc) then unlocks the native file on the method extractFiles returning and cleaning up\nd) System.load loads the unlocked native file.\nThe problem was the antivirus kicked in immediately after c) when the file is unlocked and blocks the process for 1.5 seconds. Maybe there is some sort of notification by the OS to antivirus as soon as a file is created.\nI've tried maintaining a lock on the native file for as long as the jvm runs, however running into the problem at 1).\nTherefore the easiest solution atm seems to be 2) above i.e. extract the natives, let the antivirus get the file lock, wait until we can get a lock then continue.\n. very likely I've got it wrong then, which would mean the antivirus is interfering even with the lock on. Searching for solutions online seem to point to the the catch file in use error, sleep and try again method.\nAnother possible way around this is we could extract the natives with the SharedLibraryLoader as early as possible (all of them) but lazy load them only on demand, this gap might be enough for an antivirus to scan the files but not lock them when they are needed by System.load. \n. Nice work, can't wait to test out BGFX. There have been substantial changes (module system) and additions (BGFX) to LWJGL since the 3.0.0 release, a lot more than one would expect for a minor point release, maybe bump the next release version to 3.1.0 instead of 3.0.1?\n. If you must use some parts of AWT (such as BufferedImage or ImageIO) on OSX with GLFW, then a quick hack to make it work is to use the \"-Djava.awt.headless=true\" vm argument.\nA better long terms solution as mentioned above is to not use AWT at all and uses solutions such as STB for image loading.. ",
    "mertcanekiz": "It does indeed work with the latest nightly build. Thanks a lot!\n. ",
    "gerbi7": "We've gotten everything set up and it seems to be working fine. Thanks and enjoy your vacation!\n. ",
    "therealergo": "Updated to the latest nightly build, debug output is:\n(Sun Sep 06 09:57:29 CDT 2015)(Render Thread)> [LWJGL] OpenGL debug message\n(Sun Sep 06 09:57:29 CDT 2015)(Render Thread)>  ID: 0xC80\n(Sun Sep 06 09:57:29 CDT 2015)(Render Thread)>  Source: API\n(Sun Sep 06 09:57:29 CDT 2015)(Render Thread)>  Type: ERROR\n(Sun Sep 06 09:57:29 CDT 2015)(Render Thread)>  Severity: HIGH\n(Sun Sep 06 09:57:29 CDT 2015)(Render Thread)>  Message: Using glGetIntegerv in a Core context with parameter <pname> and enum '0x8871' which was removed from Core OpenGL (GL_INVALID_ENUM)\nA forward-compatible 3.2 core context is being used, and the error can be stopped either by allowing a backwards-compatible context or by calling GL.createCapabilities() at any point before the error in versions before 3.0.0b build 10.\n   It seems that GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS is removed in 3.2+, is there any way of me verifying this? Googling seems to reveal nothing on the subject, and I don't see how I'd get the maximum number of texture units correctly without it.\n. Well, I've at least figured out what it was -- My Eclipse now only saves files from the project that is being run when that project is run, rather than saving all open files -- Which means that because I run more than 1 project with referenced source directories between them when I deleted GL_MAX_TEXTURE_COORDS  it didn't save and kept triggering the error, leading me to believe that it was GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS instead of GL_MAX_TEXTURE_COORDS. It makes sense now that GL_MAX_TEXTURE_COORDS was removed because it is for the fixed pipeline and should no longer be used. Anyways, thanks for all the help, I'm glad I got this dealt with.\n. ",
    "intrigus": "@Spasi Could you please either verify that this is a bug or say what I have done wrong?\n. On which platforms did you try the tests?\nSys.getVersion() returns 3.0.0b.\nMaven/Eclipse says that I use lwjgl-3.0.0b-20150920.083825-36.jar.\nCould you maybe post your test/link to your test?\n. The GLFW Events demo, has the same problem.\nI also tried it without Lwjgl3NativesLoader, but the Issue persists :(\n. Another mouse did not change anything.\nIt works on Win7 64, but I did not test that myself. Somebody tested it for me.\nI also tested it on Win XP 32bit and I have the same problem :(\n. It's indeed a GLFW bug, I'm going to report it.\nShould I close this Issue now or should I leave it open for some time?\n. Search for similar issues before creating a new: https://github.com/LWJGL/lwjgl3/issues/119\n. Have a look at https://github.com/LWJGL/lwjgl3/blob/b670b2b5dcce28091f2bf2253ddf787da3a07d9c/modules/core/src/test/java/org/lwjgl/demo/vulkan/HelloVulkan.java\n. Against. \nI think that Java 8 is still not enough used. \nSee http://www.baeldung.com/java-8-adoption-march-2016\nI'm fine with dropping Java 6.\n. Dropping Java 6 should be ok, since GLFW doesn't support OS X 10.6 anymore. \n. I'm currently trying to crosscompile for my raspberry pi using this docker image https://github.com/sdt/docker-raspberry-pi-cross-compiler . I'm currently having some setup-problems but I hope to solve those by the weekend.. I finally got NanoVG running on my Pi:\nhttps://twitter.com/intrigus_/status/951588386002874369\n@Spasi are you fine with using docker to cross-compile the binaries or do you prefer another solution?. I got all but one external binding building.\nThe remaining one should also build soon.\nThe lwjgl3 build should work, but there are some open problems that need to be solved as some of my solutions are hard-coded.. @Spasi In my opinion it would probably be better to support ARMv7 since all bindings would work with it. (Excluding tootle and sse)\nI'm not sure but I think that for using opengl es on pi's before model 2, you had to use a pi specific api. (Please correct me if I'm wrong)\nThe pi 2 is also ARMv7.. So what do you expect the maintainer to do?\nWhy don't you simply copy the InfoUtil class to your project?. Sorry, I thought that you meant the included tests when you said \"demos\".. ",
    "Noviv": "Thank you so so very much! I will get right on it during my lunch period!\nQuick question: how do I change the commit that I made to this PR without pushing another commit? Do I have to revert that commit and push a new one to my fork?\nP.S. I promise my next PRs will be more useful!\n. Alright, @Spasi , I fixed it! Also, thank you @kenzierocks , I now know how to rebase a commit haha\n. Hey @Spasi , I'm sorry to bother you on a closed PR, but I am having some trouble: I am trying to import the entire LWJGL3 source into an IDE, and so far I have had no success. How do I set up LWJGL in an IDE (Netbeans, Eclipse, BlueJ, IntelliJ, I don't care) such that I can edit code in the modules? I have a few things that I want to contribute, but they require refactoring and IDE shortcuts :(\n. Thank you @httpdigest and @Spasi , I will stop bothering you now! :D\n. I'm not sure if this would be a solution, but couldn't you just add a .nbproject folder? Netbeans would be able to open the project, and Eclipse has the ability to import Netbeans projects. This would also remove the need to copy any files into the root directory.\nNetbeans has the option for a free form project so the default Netbeans build.xml can be replaced with the LWJGL build script. Therefore, only the .nbproject is required.\n. Oh man, I'm sorry, I got it the wrong way! Netbeans can import Eclipse, not the other way around. Sorry!\n. What if you just add apply plugin: \"eclipse\" to the build.gradle file? According to this post Gradle will automatically generate Eclipse files.\nI haven't worked with Gradle that much, so please tell me if I missed something.\n. @Spasi is this still something you'd like done? I recently worked with Assimp a bunch, and I'd love to start contributing to this project!. Awesome, I'll get to work @Spasi! Small problem though: HelloTootle says my computer does not support GL 3.3. I'm running pretty old integrated hardware (Intel Haswell i915 from more than 5 years ago), but my glxinfo dump still says\nGLX version: 1.4\n    Max core profile version: 3.3\n    Max compat profile version: 3.0\n    Max GLES1 profile version: 1.1\n    Max GLES[23] profile version: 3.1\nOpenGL core profile version string: 3.3 (Core Profile) Mesa 17.2.8\nOpenGL core profile shading language version string: 3.30\nOpenGL version string: 3.0 Mesa 17.2.8\nwhich makes me believe I should be able to run it. Not sure what's going on with that (any help would be appreciated), but I'll start with a small Assimp demo!\n. Yep, that worked perfectly. I'll come up with a basic Assimp demo!. ",
    "chriscamacho": "I notice ANGLE isn't ditributed...\nI was able to get it working on linux using opentk binary dependencies, but their 32/64 bit libs have the same name... maybe need angle32 agle64 sub dirs in native for the windows lib loader ?\nit would be nice if ANGLE was part of the binary download, so it works \"out of the box\" for windows users too \n. build 45 doesn't fix this?\n     [java] LWJGL Version 3.0.0b build 45\n     [java] Exception in thread \"main\" java.lang.ExceptionInInitializerError\n     [java]     at test.initAndLoop(test.java:57)\n     [java]     at test.run(test.java:26)\n     [java]     at test.main(test.java:64)\n     [java] Caused by: java.lang.RuntimeException: Failed to dynamically load library: liblibGLESv2.so(error = null)\n     [java]     at org.lwjgl.system.linux.LinuxLibrary.(LinuxLibrary.java:23)\n     [java]     at org.lwjgl.system.APIUtil.apiCreateLibrary(APIUtil.java:56)\n     [java]     at org.lwjgl.LWJGLUtil.loadLibraryNative(LWJGLUtil.java:215)\n     [java]     at org.lwjgl.opengles.GLES.create(GLES.java:95)\n     [java]     at org.lwjgl.opengles.GLES.create(GLES.java:86)\n     [java]     at org.lwjgl.opengles.GLES.(GLES.java:65)\n     [java]     ... 3 more\n     [java] Java Result: 1\n. Thanks!\nbtw sym linking liblibGLESv2.so to libGLESv2.so works - only tried it out of curiosity ! \n. FYI just tried build 46, the issue as been resolved, thanks very much - blisteringly fast response!\n. while I agree with you its the only way to make the Arduino SDK actually readable! and its a pain if I forget, the feed back from Java of\nPicked up _JAVA_OPTIONS: -Dswing.defaultlaf=com.sun.java.swing.plaf.gtk.GTKLookAndFeel\nmust be somehow be getting included into parsed output and included in the meta by the build process, is there any parsing done by the build system to make the manifest ?\nI had a quick look but time was limited and its a reasonably complex build, thought it would be better reporting here for those more familiar with how it works...\n. I think you did indeed, top work, much appreciated, keep up the good work!\n. ",
    "limeygopher": "So I've just revealed how ignorant I am.\nI'm using the latest nighlty build (46) and the libglfw in it. After adding the hints GLFW_CLIENT_API, GLFW_CONTEXT_VERSION_MAJOR, and GLFW_CONTEXT_VERSION_MINOR to the window, all seems to be fine, and I don't have to hack anything.\nThanks for your time.\n. ",
    "ShadowLordAlpha": "This would go hand in hand with the gradle build script but you could try subprojects. That way it would also handle any dependencies that they have on other parts of the lib though it might need some refactoring of the codebase (I would work on it but i still don't really get how the generator works and don't have time to sit down and mess with it right now).\n. It should be possible to have the native library depend on the java one and, while technically not the correct use of dependencies, should allow you to do Option A but with only half of the declared dependencies.\nAlso it seems that LWJGL is unable to find the natives itself currently when using the new system.\n. Sorry it was me derping with the new system and forgetting to import the proper native file for it to actually make the link though. I didn't have it importing the base dependencies native file and that what was causing my problem.\n. This is kind of late but a while ago I did manage to make TWL run with LWJGL 3 though it wasn't good by any means and TWL does use old OpenGL functions.\nI should also bring up that one of the main problems I was having was figuring out a good way to get the event data from GLFW and processes it. As there can only be one listener it would be easy to make a version that just splits that up however it gets more complicated for the end user and taking over isn't a very good option as its not very easy to detect if your listener has been removed and could lead to problems with the end users code.\n. @pierr3 could you post a small sample that errors out or can you only get it to happen when you have a large amount of code.\n. My main thing was that its not really possible to use OpenAL without going through the ALContext class so we can't make code that looks basically the same as it would if we were programming it in C.\nAnother pass over those two libraries is probably a good idea and maybe some way around those classes so they are there if people want to use them but not needed. That way getting started is still easy but going that way is not required. Though to me it seems like returning the pointer and using that makes more sense here simply because that's how it seems to be done in the other common libraries (GLFWwindow for example)\n. could make a class that only contains wrapper methods for the core functions.\n. Ok so I was thinking more on what the format could look like and came up with this\nGLFW.dtpl\nIt should be easy to understand if you read it but basically it goes\ndoc:type:${name|group}:$identifier\nwhere type is \n- package \n- class \n- field\n- method\nthe next part is group or name and it tells what the identifier after it is so if its name it will be the name of the method or if it is group (for field) then it will be a single comment for that whole group.\nso it would look something like \ndoc:field:group:function_keys {\nFunction keys.\n}\nOR\ndoc:field:name:MOD_SHIFT {\nIf this bit is set one or more Shift keys were held down.\n}\nmethods are a bit more tricky as they also have different annotations that can be used so after the main documentation they would have their annotations in the same fashion like so\ndoc:method:name:$identifier{}:$annotation:$arg\nor\ndoc:method:name:$identifier{}:$annotation\nwhere arg is optional and simply turned into a string and added as the first word after the annotation so  the above would be turned into something like this \n```\n/\n * @annotation arg\n \n/\nidentifier() {\n}\n```\nexample\n```\ndoc:method:name:GetVersion {\nRetrieves the major, minor and revision numbers of the GLFW library. It is intended for when you are using GLFW as a shared library and want to ensure\nthat you are using the minimum required version.\nNotes:\n\nAny or all of the version arguments may be $NULL.\nThis function always succeeds.\nThis function may be called before #Init().\nThis function may be called from any thread\n\n}:param:major {\nwhere to store the major version number, or $NULL\n}:param:minor {\nwhere to store the minor version number, or $NULL\n}:param:rev {\nwhere to store the revision number, or $NULL\n}.since {\nversion 1.0\n}\n```\nwould turn into something like\n/**\n * Retrieves the major, minor and revision numbers of the GLFW library. It is intended for when you are using GLFW as a shared library and want to ensure\n * that you are using the minimum required version.\n * \n * <p>Notes:</p>\n * \n * <ul>\n * <li>Any or all of the version arguments may be {@code NULL}.</li>\n * <li>This function always succeeds.</li>\n * <li>This function may be called before {@link #glfwInit Init}.</li>\n * <li>This function may be called from any thread.</li>\n * </ul>\n *\n * @param major where to store the major version number, or {@code NULL}\n * @param minor where to store the minor version number, or {@code NULL}\n * @param rev   where to store the revision number, or {@code NULL}\n *\n * @since version 1.0\n */\npublic static void glfwGetVersion(ByteBuffer major, ByteBuffer minor, ByteBuffer rev) {\n. . .\n}\nthey could also just be fully formatted inside the main documentation part.\nalternate methods should also have some way of documenting them though for now simply auto generated methods that point to the original documented version like it currently does should be fine.\n. I'll be posting a JSON version later that would most likely be much better to use for the reasons being talked about in #173 \n. Wall of text\n``` JSON\n{\n    \"type\": \"documentation\",\n    \"filename\": \"GLFW.java\",\n    \"max_line_length\": 100,\n    \"overall\": \"Copyright LWJGL. All rights reserved.\\nLicense terms: http://lwjgl.org/license.php\\nMACHINE GENERATED FILE, DO NOT EDIT\",\n    \"package\": \"LISENCE.txt\",\n    \"classes\": [{\n        \"name\": \"GLFW\",\n        \"doc\": \"Native bindings to the GLFW library.\\n\\nGLFW is a free, Open Source, multi-platform library for opening a window, creating an OpenGL context and managing input. It is easy to integrate into existing applications and does not lay claim to the main loop.\",\n    \"variables\": [{\n        \"name\": \"GLFW_VERSION_MAJOR\",\n        \"group\": null,\n        \"doc\": \"The major version number of the GLFW library. This is incremented when the API is changed in non-compatible ways.\"\n\n    },\n    {\n        \"name\": null,\n        \"group\": \"function_keys\",\n        \"doc\": \"Function keys.\"\n\n    }],\n    \"methods\": [{\n        \"name\": \"glfwGetMonitorPos\",\n        \"alt\": [{\n            \"arguments\": [\"long\", \"ByteBuffer\", \"ByteBuffer\"],\n            \"doc\": \"Returns the position, in screen coordinates, of the upper-left corner of the specified monitor.\\n\\nAny or all of the position arguments may be {@code NULL}. If an error occurs, all non-{@code NULL} position arguments will be set to zero.\\n\\nThis function must only be called from the main thread.\",\n            \"annotations\": [{\n                \"name\": \"param\",\n                \"arg\": \"monitor\",\n                \"doc\": \"the monitor to query\",\n            },\n            {\n                \"name\": \"param\",\n                \"arg\": \"xpos\",\n                \"doc\": \"where to store the monitor x-coordinate, or {@code NULL}\",\n            },\n            {\n                \"name\": \"param\",\n                \"arg\": \"ypos\",\n                \"doc\": \"where to store the monitor y-coordinate, or {@code NULL}\",\n            },\n            {\n                \"name\": \"since\",\n                \"arg\": null,\n                \"doc\": \"version 3.0\",\n            }] \n        },\n        {\n            \"arguments\": [\"long\", \"IntBuffer\", \"IntBuffer\"],\n            \"doc\": \"Alternative version of: {@link #glfwGetMonitorPos GetMonitorPos}\",\n            \"annotations\": [{\n                \"name\": \"param\",\n                \"arg\": \"monitor\",\n                \"doc\": \"the monitor to query\",\n            },\n            {\n                \"name\": \"param\",\n                \"arg\": \"xpos\",\n                \"doc\": \"where to store the monitor x-coordinate, or {@code NULL}\",\n            },\n            {\n                \"name\": \"param\",\n                \"arg\": \"ypos\",\n                \"doc\": \"where to store the monitor y-coordinate, or {@code NULL}\",\n            },\n            {\n                \"name\": \"since\",\n                \"arg\": null,\n                \"doc\": \"version 3.0\",\n            }] \n        }]\n    }]\n}]\n\n}\n```\nso then lets go over the new wall of text i have.\nstarting off this file is\n\"type\": \"documentation\",\nthis tells the reader that this Json object contains the documentation. The next line\n\"filename\": \"GLFW.java\",\ntells the reader what file this Json objects documentation is for. Then comes \n\"overall\": \"Copyright LWJGL. All rights reserved.\\\\nLicense terms: http://lwjgl.org/license.php\\\\nMACHINE GENERATED FILE, DO NOT EDIT\",\n\"package\": \"LISENCE.txt\",\nThis allows us to document the very top of the page and the package of the file separately. both of these could be files or contain what is printed.\nnow for the more complex parts. As java allows for nested classes we need the ability to have multiple class objects. inside each class object is its name so we can line up the documentation and the documentation that goes over the class deceleration. each class has a list of variables and methods that are documented in a similar way to above.\nIf I missed anything that would be needed please tell me.\n. > The above example is trying to document the generated code (license header, Java types, alternative methods). We should be documenting the source templates instead (native types, one structure per method, etc).\nThe name methods are strings so they can be whatever is needed. They follow what the java files are currently because that's what I had when I came up with it. Because it will be documenting java code I thought it would be better if the documentation templates looked more like the java code they were documenting. For the variables part to change it to mimic the templates would be change the name field like this.\n{\n      \"name\": \"VERSION_MAJOR\",\n      \"group\": null,\n      \"doc\": \"The major version number of the GLFW library. This is incremented when the API is changed in non-compatible ways.\"\n}\nThough I have no idea what your thinking for the acutal template files. For methods just change it so that there is no alt array and the names are different though I think it would be a good idea to be able to document the alternate methods differently but it is up to you what is done.\n\nIt's better if there's a single file per template (i.e. per generated class), even if it is a bit wasteful for short classes. Classes with no content could be handled specially though (e.g. see ExtensionFlags.kt)\n\nI don't see anything keeping this from happening (maybe just change the array to a single object) though my idea was to have the template point to its documentation file so that all the generator has to look for is the templates and those tell it where the proper documentation template is.\n. If all we need to do is tell the generator not to generate those files the it should be decently easy. Currently the generator looks for system values and can choose not to build libraries off of that. We could probably use that system as if you look at the gradle build system I have mostly working on my fork all the system variables are set though gradle using easy to edit variables in a separate file.\nThough it may not be that easy it seemed to work when I was testing it as long as you don't leave out a library needed by other libraries\n. I wouldn't mind having libraries like this though #100 should really be finished first and maybe with it add a set of libraries that are less used and have less work put into them and are not part of the main jar but can be added if they are wanted by the user.\n. (On a phone so quotes are hard)\n- I MESS WITH ALL THE THINGS. But really I learned kotlin doing this so one more language I can say I know how to use.\n- gradle isn't that bad (It can look ugly though if you set it up like my experiment is) though normally it looks much cleaner.\n- if you move over to non compiled templates that would make almost everything easier. \n- while I would agree with this people are lazy and it can cause problems if they remove something they shouldn't \n- I agree but would say that makes it more important and if you rewrite the generator for template files and desperate documentation it would probably be a good time to introduce #100 as well\nAs a side note it took me 1 1/2 days to do it but the current generator will compile and generate the sources in my experiment (not on github yet as I'm on a bus) but it does work. \nEDIT: code is now up on github\n. @Spasi currently on my lwjgl3 fork there is a gradlebuild branch that is working with the current generator and can tell it to build or not to build parts though its still very simple. If you want to try it just open a command window and run the command gradlew generate and it will generate all the different source files though I still have a bit of work to do on it.\n. Ya give me a bit to fully do it\n. > Btw, generated sources are ignored in the main repository because tiny changes in the generator can produce massive diffs in the generated code. We do track progress though, in a separate repository, here.\nI know but they have to go somewhere.\n\nIn other news, Kotlin 1.0.2-beta now supports incremental compilation in Gradle builds.\n\ndecently sure that its 1.0.1-2 that supports it\n. @Spasi ok the gradle-build branch should be what you want. To run it correctly open up a command window in the same folder and use the command gradlew run you will probably get errors from the missing java files so use gradlew copy to get those from the core source set to the main source set.\nSome notes\n- Most of the code was refactored to different areas but its all still one project and should be easy enough to navigate around. ask if you have any problems with it though it should be very similar to the current code.\n- This gradle buildfile was only built to build and run the generator code so that is all it does.\n- It will probably give you errors if you only have a JRE and not a JDK.\n- I removed the signing and maven plugins for now as i have not used them and don't want to mess with them right now\n- if something doesn't makes sense ask me though it should explain itself decently well\n- it can build the lwjgl jar using the command gradlew jar though I haven't really worked on that part so it may not work properly or fully as expected right now\n. > According to the Change Log, you'll need an 1.0.2 build.\noh ok ya that is 1.0.2 though i think i was getting that with 1.0.1-2 though i could be wrong\n\nOK, I see the new structure, but I don't know why it was necessary. The current structure was chosen to match Gradle/Maven conventions.\n\nIt technically wasn't needed however its the convention that gradle uses so you don't have to configure each plugin like the kotlin and java plugins though those two are not all that hard to compile and should make using some other plugins easier as no obscure configurations would be needed.\n\nCompiling and running the generator is simple enough and I already have a gradle build that does that (locally, haven't pushed it on github anywhere). The issue I had was making Gradle behave like the current Ant build, where inactive bindings are not included in the source path at all. Your build doesn't do that either. It's probably not a big deal now with incremental compilation, but it'd be nice to have.\n\nI can do that (I wrote this at 5 in the morning so I had to go to sleep) its set up so that it can be done. I just didn't do it. Anything else you need it to do that it currently does not do?\n\nAnother thing I had done is use a master build.gradle under the root, then have a separate build.gradle for each module (under modules/core and modules/templates). Not sure if that made things unnecessarily complex and contributed to the trouble I had\n\nI find that doing that does makes things more complex as you have to keep track of the code in bunch of different places (I only ever use that for multiproject builds and even then I don't normally use it as if I keep everything in one file I can reuse a lot of variables most of the time).\n. @Spasi done, inactive bindings should now be excluded from the generated code. This includes the kotlin files (both compiled and templates though this might need to be modified with a shift over to non-compiled templates) and core files. Be careful though as excluding some things may cause problems. Currently it should work based on the system arguments you gave generator before (they are in gradle.properties). It looks messy and can be cleaned up a lot though so its only showing how to do it really.\n. I was thinking a more custom format but xml, yaml, or json would also work\n. > Using an existing format has the advantage of already having existing libraries, tools and validators that can be used. IDE's like Eclipse, Intellij, Netbeans (even GitHub) already support XML, JSON, YAML (via plugins if not built in support) which can provide syntax highlighting and error checking. Further there is existing documentation and tutorials for these formats and developers may already be familiar with them allowing lower entry for contributions.\nIt wouldn't really be any lower as all three of those are basically just ways to format data that can then be read so it would basically be its own format built on top of a more general format. It forces a set format which can be useful for parsing and validating data though so that would be useful.\n\nThis is something a custom format will be missing and therefore require a lot more work to implement and maintain.\n\nagain all three of those are basically just key-value pair mappings so there isn't much syntax highlighting to miss in the first place but it could be useful.\n. I agreed with him on that part I just disagreed with it lowering the entry point really (though thinking on it more it would technically lower it a bit more but not by all that much)\non the other side if one of those 3 is chosen I would hope that it is JSON as XML looks messy and confusing (its not that bad once you know how to use it though). YAML I haven't used much so I can't really speak for it but the indentation part would both be good for readability but also a headache I think though like I said I haven't really used it.\n. I would love to have this as it would make the java and c look basically identical though it is undocumented and for internal use from what I see so it could change at any time especially with jigsaw coming in 9.\nAnother con you forgot is that its a JDK 7 feature.\nI think it would also be good to see if they actually do speed anything up so a benchmark with a few functions first or something.\n. I like the memSlice idea more and your right it is a bit rare so it probably shouldn't have its own thing in the generator though I do think a clear, clean way of splitting a single buffer so it can be used as multiple arguments should be included (memSlice would do this perfectly)\n. I would prefer it be in MemoryUtil instead of Callback as its the class that already does most of the memory manipulation stuff and from what it looks like most of the Callback classes use will be internal except for the free() method. Also I would like it if the callbacks return the object instead of a pointer though this is mostly because Java works with objects and not pointers for the most part though I would be fine ether way. Though I would very much like this change as my code already does something similar to your second example though looks less nice because of the way lambdas have to be used\n. I am probably misunderstanding what you are trying to say so correct me if I get something wrong but\n\nThere's no need for a wrapper object. It would also be an extra indirection in the native-to-Java callback path.\n\nNo need for one as its fully legal to store it and return it latter as the Interface class without wrapping it in another object. You can even wrap other objects in lambda methods the same way you would wrap lambda methods in full classes.\n\nI'd like to minimize LWJGL-specific abstractions/utilities visible in user code (in the spirit of making LWJGL code look very similar to the corresponding C code). Note that in example 1 above there's only one mention of GLFWKeyCallback and no mention at all in example 2.\n\nThe return type would simply change from a long to the callback interface. Nothing else would need to change as it would still be a Functional interface. It would also allow for the extra overload methods that take the long (though I suppose the object type methods would be the helper methods) to be removed and not seen from the user code.\n\nI've written a lot of GLFW samples and always find it annoying having to remember callback type names. Auto-complete helps in the glfwSet methods, but not when writing the fields where the callback instances are stored.\n\nI don't know how garbage collection works with lambda functions as I have not really looked that closely at it however you said that currently you use a weak reference to an object to store it. You could do something similar for the lambda functions if needed without the weak reference part though I don't really know why lwjgl was storing that in the first pace instead of a normal reference unless memory was a concern for some reason in which case it should have been a soft reference not a weak one.\n. Its supposed to return the previously set callback or null so I was suggesting a way to possibly do that (a map or something with the long value as the key and the function as the value) in object form but it should be fine ether way if nothing other than the long is needed to reset the function to what it was before if it is changed\n. I still think it would be more like java to return the actual callback (return memGlobalRefToObject(dcbGetUserData(keyCB)) instead of just the long value) though as long as its easy enough to reach the java object it would be fine and getting the long would probably also save some calls to recreate or get the object pointer later if it is reset as the callback.\nMostly I was thinking of libraries that may chose the way of simply overriding the current callback with their own and calling the former callback after they have finished processing the data. Not the best way of doing things but far easier than some other ways. Though again as long as the java callback can be easily reached its fine.\n. How would it make it more mutable that it already is? Currently you create a PointerBuffer outside of the object then just pass it in later so why not make it so that the object itself (or a static method) creates the pointer?\n. So I should have added this but It would be more like a builder method than the current allocation method. so\nVkInstance inst = VkInstance.malloc(inst_info);\nwhere the method would automatically create an address for the object and then that address would be used in the vkCreateInstance() method instead of a PointerBuffer so almost nothing would change overall but it would make it look cleaner and less work for an end user. It would also be a bit more like the C code. probably call it something different than malloc though\n. > Because between VkInstance foo = new VkInstance() and vkCreateInstance(..., foo), you have an object that is invalid and cannot be used for anything. If vkCreateInstance fails, you still have that object. If vkCreateInstance succeeds, it would be possible to call it again and modify the existing object. It's bad design.\nThats how the current vulkan method works anyway and you can just keep using the same pointer over and over and over as well.\n\nBest I can do is a factory method that calls vkCreateInstance for you. Something like (in the VkInstance class)\n\nIt would probably be better to leave it up to the user but that is similar to what I currently do.\n. So something kind of like one of the things you had above but slightly different using Java's ability to limit methods to other classes inside the package. also If someone wants to overwrite the data in the instance they are free to do so but the old data will become garbage if its natively allocated, should be just the instance but still something to be considered. It could be cleaned up if an object is not empty or something in the setData method but it seems like a lot of work LWJGL shouldn't be worrying about.\nJava\npublic static int vkCreateInstance(VkInstanceCreateInfo pCreateInfo, VkAllocationCallbacks pAllocator, VkInstance pInstance) {\n        MemoryStack stack = stackGet(); int stackPointer = stack.getPointer();\n        try {\n        PointerBuffer pointer = stack.callocPointer(1);\n        int code = nvkCreateInstance(pCreateInfo.address(), pAllocator == null ? NULL : pAllocator.address(), memAddress(pointer));\n        if(code != VK_SUCCESS) {\n            return code;\n        } else {\n            pInstance.setData(pointer.get(0), pCreateInfo);\n        }\n        } finally {\n            stack.setPointer(stackPointer);\n        }\n    }\nthough setData could just always run but the way I did it is if there is an error code it just returns that code and VkInstance would be basically invalid anyway.\nAnd the VkInstance code would be something like this.\n``` Java\n. . .\n/* Wraps a Vulkan instance handle. /\npublic class VkInstance extends DispatchableHandle {\npublic VkInstance() {\n\n}\n\n/* \n * Allows the vkCreateInstance() method to set the proper data to the container\n * without allow subclasses to access the method.\n */\nvoid setData(long address, VkInstanceCreateInfo ci) {\n    this.address = address;\n    capabilities = getInstanceCapabilities(address, ci);\n}\n\n. . .\n\n}\n```\nThough other container type objects used by the Vulkan bindings would also need to be modified as well. Also in the above samples I made it look a lot like what the code would look like if done currently though it might look better if the VkInstance was allocated and the handle placed there. I think it is just a pointer value so normally we would represent it as a long but the VkCapabilities are also stored in the Instance as well as in several other objects used by Vulkan.\nnow to go off my own topic but maybe something similar could be done with OpenAL to get rid of us needing to set the ALCapabilities when we change the context.\nAlso there are a few unneeded null checks in the generated code that uses stack.UTF8() as that method has a built in null check that it does first thing. (OpenAL code)\n. ",
    "J-Ibarra": "why not put the native libraries in a single * .jar , to facilitate application portability\nfor  generator explained here you may have the option to generate only the *.jar needed for developers, example: I need only generate module GLFW or GL or GLFW+GL!\n. > > why not put the native libraries in a single * .jar , to facilitate application portability\n\nWhat do you mean exactly? Having a single lwjgl--natives.jar per module instead of one per platform?\n\ni see the archives: lwjgl-glfw-natives-linux.jar, lwjgl-glfw-natives-macos.jar, lwjgl-glfw-natives-windows.jar, why no put all natives in only archive*.jar? (lwjgl-glfw-natives.jar)\nSome time ago work with JOGL, and I put libraries in a single *.jar as follows:\n- Native\n  - Windows\n    - x86\n    - x64\n  - Linux\n    - x86\n    - x64\n  - Mac\n    - Univelsal\nsomething other than the subject, have not thought lwjgl3 made \u200b\u200bcompatible with Android\n. Looks excellent!\n. i have a problem is the code of the demos,\nimport static org.lwjgl.nuklear.Nuklear.*;\nin the version of lwjgl 3.0.0 build 90 no have the package\n. Doing some research I got with this post!\nhttps://engineering.riotgames.com/news/under-hood-league-client%E2%80%99s-hextech-ui\nHere mention the use of javascript to create the client of this game, it would be interesting to be able to create GUI with HTML\nOpenGL GUI using Chromium Embedded Framework (CEF). Thank you so much! I will continue reading and studying the form generator used in this project, I'll take a project in C and try to do the generator and JNI on Kotlin similar to LWJGL way, and thought of USB HID communication and serial communicatiThank you so much! I will continue reading and studying the form generator used in this project, I'll take a project in C and try to do the generator JNI Kotlin similar to LWJGL way, and thought of USB HID communication and serial communication for micro and pic's, because I use it a lot every day! I hope to learn a lot more and thus help direct the project, then I am very excited, thank you very much, if you have something to add, as references, books, links, videos, or some source to help be grateful!on because I use it a lot every day! I hope to learn a lot more and thus help direct the project, then I am very excited, thank you very much, if you have something to add, as references, books, links, videos, or some source to help be grateful!\n. I would like to contribute two small example I have done on physics, from the book Game Physics Engine Development by Ian Millington, the source code is in C ++ and uses the GLUT library , I 'm doing in Java using LWJGL and JOML\nI want to make a physics engine for LWJGL3\n. ",
    "iceman197369": "Are you considering easy integration of LWJGL in SWT applications? I managed this with LWJGL 2, but have had a few issues with LWJGL 3. Know there's a project on Github to accomplish this. \n. https://github.com/httpdigest/lwjgl3-swt link to project. \n. ",
    "arisona": "The ongoing modularisation ist very welcome! At the same time, for those who'd just like to hack away, it would be useful to have something like \"lwjgl-all\" which would give you an all-in-one package. \n. NanoGUI is C++ and probably hard to wrap. But it could make sense to port NanoGUI to Java on top of lwjgl's NanoVG.\nEdit: NanoGUI is quite decent, btw. IMHO would be a good choice.\n. Very cool! \n@Spasi: It seems to be pretty fast to add bindings. I'd be interested contributing by adding bindings (in particular Valvoe / OpenVR). I couldn't find much documentation how to get this started. What's the normal procedure to start with bindings for a new library? Cheers :)\n. @spasi thanks re generator. this should get me started.\n. That would be great! In addition, there are a few callbacks that have boolean type arguments, such as the iconify callback or the cursor enter callback. Could this be done there as well for consistency?\n. I have started an independent project some time ago. The idea is to use the native OS libraries (AVFoundation on Mac, WMF on Windows) for decoding. It's incomplete as of now, but decoding on Mac works reasonably well. I will continue when I find time, but contributions are of course welcome. https://github.com/arisona/avion\n. ",
    "apostolos": "We just deployed a first version of the new download page and it includes the Maven & Gradle script generators ( only for the nightly build at the moment ).\nIt is still a work-in-progress but we would appreciate your feedback!\nCommit:\nLWJGL/lwjgl3-www@86c647109699a83f934b506b57547fad6a137779\n. @sriharshachilakapati Just fixed the nightly version. Thanks\nI've discussed multiple natives with @Spasi but it makes no sense for Gradle & Maven. You can just generate a new script for your \"other\" computer.\nFor the ZIP bundle it will be possible to select one or more platform and include them all in a single download.\n. @kappaOne Started work on the bundles. To tell you the truth I'm kind of worried about server performance if we get simultaneous requests from multiple people.\nI might offload everything on Lambda since we are on Amazon and artifacts are stored on S3 already. Unfortunately we cannot really cache generated files on the CDN since potential bundle combinations are thousands.\n. @sriharshachilakapati We now use Maven profiles and Gradle's org.gradle.internal.os to generate a single cross-platform configuration.\nWe hid the Natives radio box for both Maven and Gradle since it is no longer necessary. We'll use it just for the ZIP bundle when the generator is ready.\n. The ZIP bundle generator is now live! Initially only enabled for nightly builds but it's feature complete. It will be available for stable and release builds as soon as 3.1.0 is released.\nSurprisingly, it works on all modern browsers and on IE10+\nWhat we ended up doing is uploading all files on S3 uncompressed. We then retrieve the folder structure in JSON format which is quite fast and pick all the file paths that were selected by the user. We then download each file and generate the ZIP file, both processes are done 100% client-side.\n@kappaOne There was no point in downloading ZIP files per binding since the JARs are already compressed. There is a performance penalty because we do many HTTP requests to download the files, but we've minimized it by doing up to 4 parallel downloads at a time ( actually we do a naive batch of 4 files at the time, will refactor it later to a real parallel download queue ).\n@Spasi I think you can close the issue!\n. We've implemented a proper download queue. Downloads now complete at almost half the time in a good connection.\n@httpdigest I'll put up a page with the file catalog so people can manually curl whatever they need.\n. @httpdigest There is now a file browser on the download page that you can use to either download the files directly or copy the paths and put them on a script.\n. Temporarily fixed with an NGINX rewrite ( 301 Moved Permanently ) to the correct URL https://www.lwjgl.org/license\n@Spasi Please update license URL to avoid redirects ( one from http://lwjgl.org to https://www.lwjgl.org  and one for the actual path ).\n. @kappaOne It should! My bad.\nhttps://github.com/LWJGL/lwjgl3-www/commit/9ec95247f5996fbe99b7fc7066d735a0aa6d3e07\n. @iamcreasy No I did not, just did a simple multi-file search & replace. I used 'Replace in Path' in IntelliJ IDEA.\n. We already append build type and build version for custom builds. The build number part is not easy to do because we have to get this information from another server. I'll look into into it.\nUnfortunately, for the full pre-built bundles we hit a browser security feature. We cannot programmatically change the download's filename because we initialize the download from a different origin (hostname). Browsers ignore the filename we want to use and just use the original file's name.\n. @hyfloac Assimp bindings have just been added to LWJGL so, for the moment, are only available on Nightly builds.\nMaybe we should just hide them on other builds to avoid confusion.. @hyfloac You're right, it will be fixed later tonight.. @hyfloac Fixed via f17639b18e4a6b67c36d5eb9d7491cedf1ed774b. @Bobbyjoness Please try again, you should now be able to download the ZIP bundles.. ",
    "JustGregory-zz": "Unlike @dustContributor I'm not concerned with supporting \"core OpenGL\" standing as much as if it fits in the \"lwjgl wheelhouse\" of libraries and functionality, and if the general API fits thematically with other, existing lwjgl API calls. I don't have a specific recommendation on how to do that, so long as I would be able to pass in some UI component hierarchy, and just tell it to \"show the gui\".\nWhat would be wrong with basically \"copying\" the AWT and making it render for lwjgl?\n. I will second what sriharsha said above, except I fear that Swing/JavaFX/SwingNode adds altogether more of the abstraction-complexity to the mix. If it could be done easily, it would have been already; but maybe it will take a complex implementation to simplify it somewhat.. @dustContributor \nEh, actually if you're programming in Java anyway, using AWT or Swing is an attractive option for me, if at least because it's already part of the JRE/JDK. JavaFX as well, as that's the newer alternative to the older UI methodologies....\n. @pakoito I think in some respects, yes this needs to happen. Consumers will have to push-back against the Android implementations not upgrading at all, or not upgrading so speedily. I will 1000% prefer dropping compatibility with older Java releases, so long as the long-term outcome will be better down the road.\nI mean, the older lwjgl versions will still be available, will they not? So that forward-looking developers will be required to update their Javas as well, and those who want to stay with an older lwjgl release still have an option; just not the most current.\n. I believe providing default method implementations means that an implementation of an interface no longer has to provide their own methodology for interface methods in which a default methodology will suffice -- thereby reducing to an extent the duplication of code which might be common across all uses of said interface.\nI would admit to not having all that much practice with usage of lambdas; where my IDE gives conversion to a lambda as an option, I hesitate, perhaps because I hold to some legacy-code way of doing some things... But, I'm getting there....\n. Believe it or not @iamcreasy some of us developers may have no idea what regex is, or how to use it...\nThat said, most IDEs provide all the search-and-replace functionality we will ever need, without having to figure out \"regular expressions\". It's a \"dark art\", I tell you.... lol\n. ... anyhow. Back to the issue mentioned in the issue title. Apologies in advance, but I'm opinionated on this subject.\nI'm not, repeat NOT, in favor of enforcing adding version numbers to any jar, EXCEPT for a \"main jar\" in a multi-jar program installation. Class-libraries which may be replaced by an updated jar file in situ by an end-user, should not be versioned by name. Doing so allows the possibility of different versions of the same class-library to be found in the library path. I've experienced this before, and I would assume I'm not the only one who has.\nI would instead recommend that each class-library have some utility class or metadata file which provides \"updater info\" that the main jar will use to seek out updated libraries. I have this feeling that developers should be getting into the habit of coding in a way that allows a multi-jar program to effectively handle dependency management. My favorite IDE does this, many non-Java applications do this too, even first-tier Java applications and games should do this.\nAgain, apologies for being so vocal on the subject, ... but I just had to say something.. Ah, okay. I somehow missed the \"native\" part of the issue. Mea culpa.\n@Spasi \nI wasn't asking for anything to be done on the part of the lwjgl libraries (or natives, it seems). My misunderstanding came from overlooking the discussion of \"native\" libraries and latching onto the \"versioning by library name\" aspect.\n@javagl \nYes, I did mean mostly about an RCP updating things at runtime, although a post-update is often mandatory (and recommended).\nIn my direct case, in a somewhat ironic example at that, is of NetBeans IDE with the 3rd-party NbGradle plugin (which is itself, at least in part, a \"dependency managament\" infrastructure over maven), I have found multiple copies of gradle support libraries (not the gradle wrapper, something else) in the NetBeans IDE path, same base archive name but incremental version strings before the \".jar\" extension. It is apparent that the NbGradle plugin must have been retaining dependencies instead of releasing/deleting them from the path on \"upgrade\".. ",
    "crisp00": "So any update on lwjgl native gui rendering methods? \nAny news on nanovg implementation?\nPlease keep us updated!\n. ",
    "AdMaioremDeiGloriam": "Hey, if at all interested, I'm making a library for lwjgl, but for a broader spectrum*, from scratch. It'll allow direct support for GLFW in LWJGL3, support for the latest OpenGL (4.5+), and a way to build shaders on the fly during runtime (in GLSL). The window component system will be made to support XHTML and XML based layouts for quick building of GUIs and easy management, so you could simply build it in a browser or other development environment.\n(~~I don't have a repository yet, and I have a(n empty) repository~~I have a repository, but don't have internet. ~~ but I'll get one up as soon as possible. It's pretty bare bones right now anyways...)~~\n*By which I mean it's for more than just lwjgl. It'll support GLFW, but it'll support other GUI systems as well: AWT, SWT, Swing, etc.\n. SGL now has code in it\n. ",
    "ShchAlexander": "Hey! It would be great if you add bindings to this library NanoGUI\nCan you please take a look on it? :)\n. Hi all, currently I working on GUI oop solution with api little bit similar to swing...\nHere is my repository: legui\nHere is result: \n\n\nRadio button and text input\nWidgets\nTextArea with horizontal and vertical alignment\n\n\n\n\n\n\n\nButton, togglebutton, checkbox, selectbox\nSliders\nScrollPanel\n\n\n\n\n\n\n. @Barteks2x it looks like it's hard to make it work with Oracle java as standalone library, am I right?. Hello everyone again. \nI  have several changes since last comment here. \nHere is image of my gui library's current state:   \n\nIf anyone want to contribute, request any changes - you are welcome. \nGitHub repo - https://github.com/LiquidEngine/legui/. I understand what you mean, @dustContributor, and of course big projects often use their own decisions that fit better to the project and work faster.\nI'm not saying that my decision is good, but I tried to make it as much extensible as it could be.\nRenderers could be implemented using OpenGL, Vulkan or and any other technology.\nAny way every solution is good for it's purposes. If you need best performance - you implement something in your own way, if you need fast development without pain - you can choose existing solution. \ud83d\udc4c. Thanks)\n. I assumed that the problem is solved. But.... It happens again... Maybe I'm doing something wrong?)\n. I'm sorry, everything works\n. I post it on https://github.com/glfw/glfw/issues/704\n. Oops... My mistake... that's after change from int GLFW_TRUE / FALSE to boolean ....\nSorry to trouble...\n. Thank you! :)\n. Thank you, I didn't know that\n. Okay, I've modified entypo font and added image symbol for NULL symbol (0x0000)\n\nThen I've used 0xE764 codepoint to render arrow which was passed as 'text' variable:\njava\nString text = new String(Character.toChars(0xE764))\nHere is what I have when I passed pointer to end of string\n\nAnd when I used '0'\n\n. ```java\nimport org.liquidengine.legui.util.IOUtil;\nimport org.lwjgl.glfw.GLFW;\nimport org.lwjgl.nanovg.NVGColor;\nimport org.lwjgl.nanovg.NanoVGGL3;\nimport org.lwjgl.opengl.GL;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport static org.lwjgl.glfw.GLFW.;\nimport static org.lwjgl.nanovg.NanoVG.;\nimport static org.lwjgl.nanovg.NanoVGGL3.nnvgDeleteGL3;\nimport static org.lwjgl.nanovg.NanoVGGL3.nvgCreate;\nimport static org.lwjgl.opengl.GL11.;\nimport static org.lwjgl.system.MemoryUtil.;\npublic class IssueExample {\n    public static final String ENTYPO = \"ENTYPO\";\n    public static final int WIDTH = 400;\n    public static final int HEIGHT = 200;\n    public static NVGColor bgcolor = NVGColor.create();\n    private static volatile boolean running = false;\n    private static long context;\n    private static String text = new String(Character.toChars(0xE764));\n    private static NVGColor textColorN = NVGColor.create();\n    private static ByteBuffer fontData;\npublic static void main(String[] args) throws IOException {\n    if (!GLFW.glfwInit()) {\n        throw new RuntimeException(\"Can't initialize GLFW\");\n    }\n    running = true;\n    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);\n    long window = glfwCreateWindow(WIDTH, HEIGHT, \"TEST\", NULL, NULL);\n    glfwShowWindow(window);\n    glfwSetKeyCallback(window, (w1, key, code, action, mods) -> running = key == GLFW_KEY_ESCAPE && action != GLFW_RELEASE);\n    glfwSetWindowCloseCallback(window, w -> running = false);\n\n    glfwMakeContextCurrent(window);\n    GL.createCapabilities();\n    glfwSwapInterval(0);\n    initializeNanovg();\n\n    while (running) {\n        glClearColor(1, 1, 1, 1);\n        glViewport(0, 0, WIDTH, HEIGHT);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        renderNanovg();\n\n        glfwPollEvents();\n        glfwSwapBuffers(window);\n    }\n\n    nnvgDeleteGL3(context);\n    glfwDestroyWindow(window);\n    glfwTerminate();\n}\n\nprivate static void renderNanovg() {\n    glDisable(GL_DEPTH_TEST);\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    nvgBeginFrame(context, WIDTH, HEIGHT, 1);\n\n    renderText();\n\n    nvgEndFrame(context);\n    glDisable(GL_BLEND);\n    glEnable(GL_DEPTH_TEST);\n}\n\nprivate static void renderText() {\n    nvgFontSize(context, 100);\n    nvgFontFace(context, ENTYPO);\n    nvgTextAlign(context, NVG_ALIGN_TOP | NVG_ALIGN_LEFT);\n\n    ByteBuffer byteText = memUTF8(text);\n    long start = memAddress(byteText);\n    long end = start + byteText.remaining();\n\n    {\n        int x = 5;\n        int y = 5;\n        int w = (WIDTH - 20) / 2;\n        int h = HEIGHT - 20;\n        renderRect(x, y, w, h);\n        renderText(x, y, start, 0);\n    }\n    {\n        int x = 15 + (WIDTH - 20) / 2;\n        int y = 10;\n        int w = (WIDTH - 20) / 2;\n        int h = HEIGHT - 20;\n        renderRect(x, y, w, h);\n        renderText(x, y, start, end);\n    }\n    memFree(byteText);\n}\n\nprivate static void renderText(int x, int y, long start, long end) {\n    nvgBeginPath(context);\n    nvgFillColor(context, textColorN);\n    nnvgText(context, x, y, start, end);\n}\n\nprivate static void renderRect(int x, int y, int w, int h) {\n    nvgBeginPath(context);\n    nvgRoundedRect(context, x, y, w, h, 0);\n    nvgFillColor(context, bgcolor);\n    nvgFill(context);\n}\n\nprivate static void initializeNanovg() throws IOException {\n    int flags = NanoVGGL3.NVG_STENCIL_STROKES | NanoVGGL3.NVG_ANTIALIAS;\n    context = nvgCreate(flags);\n    fontData = IOUtil.ioResourceToByteBuffer(\"org/liquidengine/legui/font/entypo_ed.ttf\", 1024);\n    nvgCreateFontMem(context, ENTYPO, fontData, 0);\n    textColorN.r(0); textColorN.g(0); textColorN.b(0); textColorN.a(1);\n    bgcolor.r(1);    bgcolor.g(0);    bgcolor.b(0);    bgcolor.a(1);\n}\n\n}\n```\nentypo_ed.zip. Thank you very much!. Check if it the same issue as https://github.com/LWJGL/lwjgl3/issues/271?. Is there some usage examples in java?. I'll upload gif in higher resolution little bit later. Unexpected behavior is white space between nodes if Max and min dimensions are different.. Created issue on  facebook/yoga - facebook/yoga#674. ",
    "nhydock": "Will the nuklear bindings be moved into separate module that can be included optionally instead of being part of lwjgl3?  I just feel that something like this, while valuable to the project and those who wish to use barebones lwjgl3, adds bloat and redundancy to other libraries that rely on lwjgl but provide their own gui solution, such as libgdx.\n. > I don't think it's worth pushing for something like it, since Project Panama is coming in JDK 10\nIf you're worried about JNI wrappers and performance, have you looked into depending on JNA.  It looks like what Panama is going to be based around, and it would provide a compatible solution for older JVMs even after 10 comes out.\n. Ah, so does Panama's goal more or less provide what JNA's interface does, but skips the JNI step?  If that's the case that'd be amazing.\nBundling a JRE with your app on desktop isn't uncommon, and is more than not recommended, especially if your app is distributed on Steam.  I wonder how these changes would effect people who are trying to release apps on PS4/Xbox.  I don't know what the distribution requirements are and if they have a specific requirement of what JVM to use or package.  I'm afraid something like this could prevent developers from pushing their apps to those platforms if this is a change that can't be optional.\n. ",
    "pierr3": "Great job, thanks!\n. I have the same problem using the nightly build, my application uses LWJGL to draw a map, and uses Swing GUI to, for instance, allow the user to select the map he wants to display. I have a Swing Dialog before the creation of the glfw window that works fine, but after creating the glfw window, I use events to open other GUIs, such as glfw Key Press callback, despite using the Swing EDT, my application crashes with the same error message a few seconds after the GUI has closed, which is very strange. \nThat means I can have the Swing Dialog open, I can interact with it, and upon closing it, I can retrieve the data set by the user in the lwjgl thread and update my map accordingly, but after 20-40 seconds, the application crashes:\n\nX Error of failed request:  RenderBadPicture (invalid Picture parameter)\nMajor opcode of failed request:  139 (RENDER)\n Minor opcode of failed request:  7 (RenderFreePicture)\n Picture id in failed request: 0x400004b\n Serial number of failed request:  16948\n Current serial number in output stream:  16967\n\nI guess I'm going to have to change my approach to GUIs using LWJGL.\n. @ShadowLordAlpha I don't have a small sample, but it happens with basically this kind of code: https://gist.github.com/pierr3/630fc76dd8c987500d8ed7895e46ec59\n. I'm having a similar error with the latest build on Windows:\n[LWJGL] Version: 3.0.1 build 2      \n[LWJGL]          OS: Windows 10 v10.0\n[LWJGL]         JRE: 1.8.0_73 amd64 \n[LWJGL]         JVM: Java HotSpot(TM) 64-Bit Server VM v25.73-b02 by Oracle Corporation\n[LWJGL] Loading library (system): lwjgl\n[LWJGL]         Using SharedLibraryLoader...[LWJGL]     Extracting: file:/C:/Users/Pierre/.gradle/caches/modules-2/files-2.1/org.lwjgl/lwjgl-platform/3.0.1-SNAPSHOT/7b0656b2cd70e44f\n29e0205acf12af777bcbe424/lwjgl-platform-3.0.1-SNAPSHOT-natives-windows.jar!/lwjgl.dll\nfound                               \n[LWJGL]         Loaded from org.lwjgl.librarypath: C:\\Users\\Pierre\\AppData\\Local\\Temp\\lwjglPierre\\e31e074f\\lwjgl.dll\n[LWJGL] ThreadLocalUtil state: UnsafeState\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n[LWJGL] Loading library: jemalloc   \n[LWJGL]         Loaded from org.lwjgl.librarypath: C:\\Users\\Pierre\\AppData\\Local\\Temp\\lwjglPierre\\e31e074f\\jemalloc.dll\n[LWJGL] MemoryUtil allocator: JEmallocAllocator\n[LWJGL] Loading library: glfw       \n[LWJGL]         Loaded from org.lwjgl.librarypath: C:\\Users\\Pierre\\AppData\\Local\\Temp\\lwjglPierre\\e31e074f\\glfw.dll\n[LWJGL] Loading library: opengl32   \n[LWJGL]         opengl32.dll not found in org.lwjgl.librarypath=C:\\Users\\Pierre\\AppData\\Local\\Temp\\lwjglPierre\\e31e074f\n[LWJGL]         Using SharedLibraryLoader...failed\njava.lang.RuntimeException:     Failed to extract opengl32 library\n        at org.lwjgl.system.SharedLibraryLoader.load(SharedLibraryLoader.java:65)\n        at org.lwjgl.system.Library.loadNative(Library.java:152)\n        at org.lwjgl.system.Library.loadNative(Library.java:225)\n        at org.lwjgl.opengl.GL.create(GL.java:102)\n        at org.lwjgl.opengl.GL.<clinit>(GL.java:86)\n        at net.vatsim.vsky.radar.RadarWindowRenderer.initializeContext(RadarWindowRenderer.java:80)\n        at net.vatsim.vsky.radar.RadarWindowRenderer.run(RadarWindowRenderer.java:73)\nCaused by: java.lang.RuntimeException: Failed to locate resource: opengl32.dll\n        at org.lwjgl.system.SharedLibraryLoader.extractFile(SharedLibraryLoader.java:80)\n        at org.lwjgl.system.SharedLibraryLoader.load(SharedLibraryLoader.java:63)\n        ... 6 more                  \n[LWJGL]         Loaded from java.library.path: C:\\WINDOWS\\system32\\opengl32.dll\n[LWJGL] [GL] GL_ARB_shader_subroutine was reported as available but an entry point is missing.\nThe folder \"C:\\Users\\Pierre\\AppData\\Local\\Temp\\lwjglPierre\\e31e074f\" contains only glfw.dll, jemalloc.dll and lwjgl.dll\n. It does work, thanks!\n. ",
    "codemuse": "Are there still plans to further explore JavaFX integration \"natively\" in lwjgl3, or is LWJGL-FX the current best alternative?\nMost discussion in this ticket is about adding UI in a native GL display, what I have is an SWT based GUI that embeds lwjgl through an SWT GLCanvas to display a 3D representation that can be inspected using the SWT UI components around it, but we are looking at rewriting the GUI with JavaFX.. @Spasi, @kappaOne  and @httpdigest: thanks for all your quick replies!\nYour comments are similar to what I could find myself as I was investigating this. I'm looking for a \"pure\" JavaFX solution, i.e. embedding it in SWT wouldn't really make sense, since the idea is to move our application away from SWT.\n@httpdigest thanks for the pointers to the OpenJDK mailinglist, I'll follow that to see what comes out of it.\nIn the meantime, I'll toy around what sort of hack would -- although suboptimal -- work for our specific situation.. ",
    "Barteks2x": "Someone actually made JavaFX work with lwjgl3, ~~but it seems like it doesn't really use opengl core profile~~ ~~and it uses opengl 3.2 core profile~~: https://bitbucket.org/cuchaz/jfxgl\nAs it says in readme, it's a giant hack but it works and has good performance.. @ShchAlexander I'm not the author so beyond what it says in the readme and what I see I can't tell you much. Based on my testing, it works as standalone library, but it uses implementation-specific hacks, including modifying the bytecode using asm library.\nObviously when using JFXGL you can't use normal JavaFX without lwjgl at the same time (and why would you?). ",
    "cuchaz": "Hi There. I'm the JFXGL author. It's still very much a work in progress, but it's getting better all the time. I've been talking to Spasi about it too, so it's already on the radar.\nIf you have any questions about JFXGL, ask away. Although maybe don't spam this issue thread?. ",
    "jjYBdx4IL": "SWT uses native OS widgets, why would one want to use that?\nDid anyone evaluate whether it is possible to extend Graphics2D class/override repaint() methods and thereby redirect Java Swing UI painting to OpenGL/NanoVG?\nBesides that, one could set JFrames as transparent and place them on top of the OpenGL window... :)\nHowever, the best solution would be some generic Java UI lib that can be plugged into NanoVG, ie. a rewrite of Nuklear. CSSBOX provides html/css rendering, though I'm not sure how efficient animations would be. And interactions? In general, I'm not sure how efficient GUI animations would be with pre-written GUI libs. It would be an interesting task to think about the required structure of such a library to efficiently support all sorts of GUI animations.\nBTW: because Vulkan support is now quite widespread, is NanoVG compatible with it?\n. ",
    "elect86": "Hi guys,\nI'd like to propose also another possibility..\nI'm doing a full jvm port of imgui here (nuklear is based on its concept), it's almost complete, text input/handling needs still to be addressed but all the rest is done\nplus, it's also libgdx compatible :)\nSee the Screenshots Thread for some user creations. Also see the Mega screenshots for an idea of the available features.\n. https://blog.kotlin-academy.com/multiplatform-native-development-in-kotlin-now-with-ios-a8546f436eec. First of all, one important thing to know is if all the new structs are identical or less.\nMoreover, if I take you example as reference, I can see in the docs that VkBindBufferMemoryInfoKHR is so defined:\ntypedef VkBindBufferMemoryInfo VkBindBufferMemoryInfoKHR;\nThis is a clear intention of what is primary and what is secondary: VkBindBufferMemoryInfo is the primary class name, VkBindBufferMemoryInfoKHR is just an alias to smooth the update. \nI'd interpreter this on jvm as: you can also pass a VkBindBufferMemoryInfoKHR class where VkBindBufferMemoryInfo is expected. In this term, If you want to exploit inheritance, I'd VkBindBufferMemoryInfoKHR : VkBindBufferMemoryInfo\nIf you would like to have exactly the same behavior on jvm as c, you may create a sort of native nVkBindBufferMemoryInfo and then have VkBindBufferMemoryInfoKHR : nVkBindBufferMemoryInfo and VkBindBufferMemoryInfo : nVkBindBufferMemoryInfo. In this way they are exactly interchangeable.\nOr simply forget about java and use typealias Kotlin.\nA couple of observations to do:\n\neverything that got vk1 is very much likely going to get also vk1.1 \nthe more time passes by, the more core structs will be used instead of their extension counterpart (future code is very likely to use core structs)\nit's possible that extensions will be also removed in future versions\n\nPersonally, I'd also avoid a duplication, because the huge effort to maintain it and the confusion given by duplication is not worth the advantage of avoiding renaming existent class names.\nMy preferred choice remains typealias or VkBindBufferMemoryInfoKHR : VkBindBufferMemoryInfo\nmy 2c. ",
    "RUSshy": "https://tomsondev.bestsolution.at/2018/12/04/announcing-efxclipse-driftfx-integrating-native-rendering-pipelines-into-javafx/. JSON is horrible, can't even put comments\nKotlin + DSL is 1000x better than everything mentioned. Maybe with release of kotlin native it'll be easier? do you plan to support kotlin native btw?. In slack they shown video of kotlin native running on iOS, and Raspberry Pi (Tetris game using SDL2), exciting news!!\nhttps://files.slack.com/files-tmb/T09229ZC6-F4LKMA03U-237bd9b959/attachment-1_360.gif\nhttps://files.slack.com/files-tmb/T09229ZC6-F4M751GP3-cb8b9c18e8/videotogif_2017.03.22_12.27.53_360.gif\nSlack -> #kotlin-native. Kotlin Native Technical Preview released: https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/. @code-disaster Already ported it for libGDX, since it use LWJGL it would make sense to implement it directly in it so everyone will be able to use it easily :) \nhttps://github.com/code-disaster/libgdx-snippets/tree/master/src/main/java/com/badlogic/gdx/profiler. ",
    "domesticmouse": "Thanks for the quick turn around @Spasi =)\n. ",
    "oparisy": "Indeed this is a long-standing request with regard to SWT GLCanvas, as described by https://bugs.eclipse.org/bugs/show_bug.cgi?id=136514.\nA code sample using JNA to address it was attached to this issue two years ago.\nClearly a higher-level, portable, LWJGL3-oriented solution would be great.\n. Oh, looking at #105, I see that you have already walked most of that path \u263a\n. ",
    "obidobi": "Awesome! Thanks for this one httpdigest.\nI found this nice tool: http://synthclipse.sourceforge.net/\nYour lwjgl3-swt will come in handy making similar stuff with lwjgl. Which of course is my preferred lib :)\n. ",
    "gudenau": "I just went looking for an issue for this, I started working on some stuff that uses CUDA for a game. Got to do that in C at the moment.. Not sure if this is the issue, but by default the debug library does not have a thread as the main GLFW thread. You need to set that yourself for it's checks to pass.. In the meantime Float.floatToRawIntBits would work the same correct?. Oh, making a compatibility layer and found that mistake.. It also appears as though it is not building correctly, but knowing me it is me screwing it up and not Java 9. .-.\nJava version:\njava version \"9\"\nJava(TM) SE Runtime Environment (build 9+181)\nJava HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode)\nHere is what I did:\n```C:\\Users\\gudenau\\Desktop\\LWJGL3>\"D:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\nC:\\Users\\gudenau\\Desktop\\LWJGL3>git clone\nC:\\Users\\gudenau\\Desktop\\LWJGL3>git clone https://github.com/LWJGL/lwjgl3.git\nCloning into 'lwjgl3'...\nremote: Counting objects: 46118, done.\nremote: Compressing objects: 100% (290/290), done.\nremote: Total 46118 (delta 165), reused 288 (delta 91), pack-reused 45642\nReceiving objects: 100% (46118/46118), 16.51 MiB | 4.10 MiB/s, done.\nResolving deltas: 100% (23877/23877), done.\nChecking out files: 100% (1356/1356), done.\nC:\\Users\\gudenau\\Desktop\\LWJGL3>cd lwjgl3\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3>ant init\nBuildfile: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml\ninit:\n    [mkdir] Created dir: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\n    [mkdir] Created dir: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\core\\src\\generated\n    [mkdir] Created dir: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Core\n    [mkdir] Created dir: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Generator\n    [mkdir] Created dir: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Templates\n    [mkdir] Created dir: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Tests\n    [mkdir] Created dir: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\windows\\x64\ncheck-dependencies:\n  [kotlinc] C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\libs\\kotlinc\\build.txt doesn't exist\nupdate-dependencies:\n    [mkdir] Created dir: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\libs\n-lib-download:\n-kotlinc-download:\n  [kotlinc] Getting: https://github.com/JetBrains/kotlin/releases/download/v1.1.4/kotlin-compiler-1.1.4.zip\n  [kotlinc] To: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\libs\\kotlin-compiler-1.1.4.zip\n  [kotlinc] https://github.com/JetBrains/kotlin/releases/download/v1.1.4/kotlin-compiler-1.1.4.zip moved to https://github-production-release-asset-2e65be.s3.amazonaws.com/3432266/76b69b30-8129-11e7-9006-d4debf387f70?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20170929%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20170929T182902Z&X-Amz-Expires=300&X-Amz-Signature=ab764e9097ac5c3c65ef2ebbb97f265711e152dba9bc0474d80e0484ba1d659f&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment%3B%20filename%3Dkotlin-compiler-1.1.4.zip&response-content-type=application%2Foctet-stream\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ....................................................\n  [kotlinc] ...................................................\n  [kotlinc] Expanding: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\libs\\kotlin-compiler-1.1.4.zip into C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\libs\n  [kotlinc] Deleting: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\libs\\kotlin-compiler-1.1.4.zip\n  [kotlinc] The Kotlin compiler was updated to build: 1.1.4\nBUILD SUCCESSFUL\nTotal time: 7 seconds\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3>ant init\nBuildfile: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml\ninit:\ncheck-dependencies:\nBUILD SUCCESSFUL\nTotal time: 0 seconds\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3>ant init-generated\nBuildfile: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml\ninit-generated:\n    [input] The modules\\core\\src\\generated directory contents will be replaced with a fresh clone of the lwjgl3-generated repository. Continue? (y, [n])\ny\n   [delete] Deleting directory C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\core\\src\\generated\n    [mkdir] Created dir: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\core\\src\\generated\n     [exec] Cloning into 'modules\\core\\src\\generated'...\n     [exec] Checking out files:  22% (501/2262)\n     [exec] Checking out files:  23% (521/2262)   Checking out files:  24% (543/2262)   Checking out files:  25% (566/2262)   Checking out files:  26% (589/2262)   Checking out files:  27% (611/2262)   Checking out files:  28% (634/2262)   Checking out files:  29% (656/2262)   Checking out files:  30% (679/2262)   Checking out files:  31% (702/2262)   Checking out files:  32% (724/2262)   Checking out files:  33% (747/2262)   Checking out files:  34% (770/2262)   Checking out files:  35% (792/2262)   Checking out files:  36% (815/2262)   Checking out files:  37% (837/2262)   Checking out files:  38% (860/2262)   Checking out files:  39% (883/2262)   Checking out files:  40% (905/2262)   Checking out files:  41% (928/2262)   Checking out files:  41% (947/2262)   Checking out files:  42% (951/2262)   Checking out files:  43% (973/2262)   Checking out files:  44% (996/2262)   Checking out files:  45% (1018/2262)   Checking out files:  46% (1041/2262)   Checking out files:  47% (1064/2262)   Checking out files:  48% (1086/2262)   Checking out files:  49% (1109/2262)   Checking out files:  50% (1131/2262)   Checking out files:  51% (1154/2262)   Checking out files:  52% (1177/2262)   Checking out files:  53% (1199/2262)   Checking out files:  54% (1222/2262)   Checking out files:  55% (1245/2262)   Checking out files:  56% (1267/2262)   Checking out files:  57% (1290/2262)   Checking out files:  58% (1312/2262)   Checking out files:  59% (1335/2262)   Checking out files:  60% (1358/2262)   Checking out files:  61% (1380/2262)   Checking out files:  62% (1403/2262)   Checking out files:  62% (1422/2262)   Checking out files:  63% (1426/2262)   Checking out files:  64% (1448/2262)   Checking out files:  65% (1471/2262)   Checking out files:  66% (1493/2262)   Checking out files:  67% (1516/2262)   Checking out files:  68% (1539/2262)   Checking out files:  69% (1561/2262)   Checking out files:  70% (1584/2262)   Checking out files:  71% (1607/2262)   Checking out files:  72% (1629/2262)   Checking out files:  73% (1652/2262)   Checking out files:  74% (1674/2262)   Checking out files:  75% (1697/2262)   Checking out files:  76% (1720/2262)   Checking out files:  77% (1742/2262)   Checking out files:  78% (1765/2262)   Checking out files:  79% (1787/2262)   Checking out files:  80% (1810/2262)   Checking out files:  81% (1833/2262)   Checking out files:  82% (1855/2262)   Checking out files:  83% (1878/2262)   Checking out files:  84% (1901/2262)   Checking out files:  84% (1912/2262)   Checking out files:  85% (1923/2262)   Checking out files:  86% (1946/2262)   Checking out files:  87% (1968/2262)   Checking out files:  88% (1991/2262)   Checking out files:  89% (2014/2262)   Checking out files:  90% (2036/2262)   Checking out files:  91% (2059/2262)   Checking out files:  92% (2082/2262)   Checking out files:  93% (2104/2262)   Checking out files:  94% (2127/2262)   Checking out files:  95% (2149/2262)   Checking out files:  96% (2172/2262)   Checking out files:  97% (2195/2262)   Checking out files:  98% (2217/2262)   Checking out files:  99% (2240/2262)   Checking out files: 100% (2262/2262)   Checking out files: 100% (2262/2262), done.\nBUILD SUCCESSFUL\nTotal time: 14 seconds\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3>ant init-wiki\nBuildfile: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml\ninit-wiki:\n     [exec] Cloning into 'wiki'...\nBUILD SUCCESSFUL\nTotal time: 1 second\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3>ant compile-templates\nBuildfile: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml\ninit:\ncheck-dependencies:\n-compile-generator:\n[Generator] Compiling Kotlin generator...\n  [kotlinc] Compiling [C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\generator\\src\\main\\kotlin] => [C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Generator]\n  [kotlinc] info: kotlinc-jvm 1.1.4 (JRE 1.8.0_144-b01)\n  [kotlinc] info: PERF: INIT: Compiler initialized in 461 ms\n  [kotlinc] info: PERF: ANALYZE: 18 files (8246 lines) in 13496 ms - 610.996 loc/s\n  [kotlinc] info: PERF: GENERATE: 18 files (8246 lines) in 7471 ms - 1103.734 loc/s\n  [kotlinc] info: PERF: GC time for PS Scavenge is 277 ms\n  [kotlinc] info: PERF: GC time for PS MarkSweep is 505 ms\n  [kotlinc] info: PERF: JIT time is 45158 ms\n  [kotlinc] info: PERF: Find Java class performed 0 times\n  [kotlinc] info: PERF: Type info performed 27155 times, total time 10660 ms\n  [kotlinc] info: PERF: Call resolve performed 15813 times, total time 8239 ms\n  [kotlinc] info: PERF: Binary class from Kotlin file performed 259 times, total time 70 ms\n    [touch] Creating C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Generator\\touch.txt\n[javac: Generator Tools & Doclets] Compiling 5 source files to C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Generator\nbindings:\ncompile-templates:\n[Templates] Compiling Kotlin templates. This will take 1-2 minutes...\n  [kotlinc] Compiling [C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\assimp, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\bgfx, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\egl, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\glfw, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\nanovg, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\nuklear, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\openal, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\opencl, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\opengl, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\opengles, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\openvr, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\stb, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\vulkan, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\dyncall, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\jawt, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\jemalloc, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\rpmalloc, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\jni, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\libc, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\linux, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\macosx, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\templates, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\system\\windows, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\util\\lmdb, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\util\\nfd, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\util\\par, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\util\\simd, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\util\\tinyexr, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\util\\tinyfd, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\util\\xxhash, C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\util\\yoga] => [C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Templates]\n  [kotlinc] info: kotlinc-jvm 1.1.4 (JRE 1.8.0_144-b01)\n  [kotlinc] info: PERF: INIT: Compiler initialized in 253 ms\n  [kotlinc] info: PERF: ANALYZE: 1032 files (168295 lines) in 48504 ms - 3469.714 loc/s\n  [kotlinc] info: PERF: GENERATE: 1032 files (168295 lines) in 33655 ms - 5000.595 loc/s\n  [kotlinc] info: PERF: GC time for PS Scavenge is 2585 ms\n  [kotlinc] info: PERF: GC time for PS MarkSweep is 0 ms\n  [kotlinc] info: PERF: JIT time is 45960 ms\n  [kotlinc] info: PERF: Find Java class performed 0 times\n  [kotlinc] info: PERF: Type info performed 278404 times, total time 53635 ms\n  [kotlinc] info: PERF: Call resolve performed 144272 times, total time 45970 ms\n  [kotlinc] info: PERF: Binary class from Kotlin file performed 528 times, total time 124 ms\n  [kotlinc] C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\templates\\src\\main\\kotlin\\org\\lwjgl\\util\\yoga\\templates\\yoga.kt:479:47: warning: parameter 'type' is never used\n  [kotlinc]     fun YG_NODE_STYLE_EDGE_PROPERTY_UNIT_AUTO(type: NativeType, name: String) {\n  [kotlinc]                                               ^\n    [touch] Creating C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Templates\\touch.txt\nBUILD SUCCESSFUL\nTotal time: 1 minute 47 seconds\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3>ant generate\nBuildfile: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml\ninit:\ncheck-dependencies:\nbindings:\ngenerate:\n[Generator]     UPDATING: modules\\core\\src\\generated\\java\\org\\lwjgl\\system\\JNI.java\n[Generator]     UPDATING: modules\\core\\src\\generated\\c\\system\\org_lwjgl_system_JNI.c\nBUILD SUCCESSFUL\nTotal time: 2 seconds\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3>ant generate\nBuildfile: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml\ninit:\ncheck-dependencies:\nbindings:\ngenerate:\n[Generator]     UPDATING: modules\\core\\src\\generated\\java\\org\\lwjgl\\system\\JNI.java\n[Generator]     UPDATING: modules\\core\\src\\generated\\c\\system\\org_lwjgl_system_JNI.c\nBUILD SUCCESSFUL\nTotal time: 2 seconds\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3>ant compile\nBuildfile: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml\ninit:\ncheck-dependencies:\nbindings:\ngenerate:\n-init-compile:\ncompile:\n[javac: Core] Compiling 1841 source files to C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Core\n[javac: Core] C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\core\\src\\generated\\java\\org\\lwjgl\\util\\tinyexr\\EXRMultiPartHeader.java:292: error: sizeof() in Buffer cannot override sizeof() in CustomBuffer\n[javac: Core]           protected int sizeof() {\n[javac: Core]                         ^\n[javac: Core]   attempting to assign weaker access privileges; was public\n[javac: Core] C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\core\\src\\generated\\java\\org\\lwjgl\\util\\tinyexr\\EXRMultiPartImage.java:292: error: sizeof() in Buffer cannot override sizeof() in CustomBuffer\n[javac: Core]           protected int sizeof() {\n[javac: Core]                         ^\n[javac: Core]   attempting to assign weaker access privileges; was public\n[javac: Core] 2 errors\nBUILD FAILED\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml:364: Compile failed; see the compiler error output for details.\nTotal time: 24 seconds\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3>ant compile-native\nBuildfile: C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml\ninit:\ncheck-dependencies:\nbindings:\ngenerate:\n-init-compile:\ncompile:\n[javac: Core] Compiling 304 source files to C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\bin\\Core\n[javac: Core] C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\core\\src\\generated\\java\\org\\lwjgl\\util\\tinyexr\\EXRMultiPartHeader.java:292: error: sizeof() in Buffer cannot override sizeof() in CustomBuffer\n[javac: Core]           protected int sizeof() {\n[javac: Core]                         ^\n[javac: Core]   attempting to assign weaker access privileges; was public\n[javac: Core] C:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\modules\\core\\src\\generated\\java\\org\\lwjgl\\util\\tinyexr\\EXRMultiPartImage.java:292: error: sizeof() in Buffer cannot override sizeof() in CustomBuffer\n[javac: Core]           protected int sizeof() {\n[javac: Core]                         ^\n[javac: Core]   attempting to assign weaker access privileges; was public\n[javac: Core] 2 errors\nBUILD FAILED\nC:\\Users\\gudenau\\Desktop\\LWJGL3\\lwjgl3\\build.xml:364: Compile failed; see the compiler error output for details.\nTotal time: 3 seconds```\nEdit:\nSo nice that it does not have a vertical scroll bar. .-.. I understand that those are optional, figured it would be best to do those just in case.. Will there be support for those multi-jar things to allow one native jar file?. I guess I mis-read, thought you could do resources and code per-platform with those. My mistake.. Sorry about the new line thing, the editor I used messed up the new line thing.\nI'll highlight the build variables and fix the new line when I get home.. No problem!. Oh my god I'm an idiot.. ",
    "ppiastucki": "Thank you very much for the info. I have read the documentation but it is not obvious you must detach the context first. \n. https://www.opengl.org/registry/specs/ARB/vertex_array_object.txt\nexplicitly states that: \"It also differs in that vertex array objects are explicitly not sharable between contexts.\"\nYou need to create and use VAOs in the same context.\n. Unrelated to LWJGL, but you can try ode4j if you do not mind pure Java solution.. ",
    "Superharz": "However, it would be easier for new Users to see which functions should not be used\n\nIf you want to make an application using the latest stuff\n\n. Alright, you win :smile: \nMy only idea was, that you could spot these functions more easy with an IDE like NetBeans, but your way is better\n. ",
    "infernalbuild": "with glfwInit() i get\nException in thread \"main\" java.lang.UnsatisfiedLinkError: org.lwjgl.glfw.GLFW.nglfwInit()I\n    at org.lwjgl.glfw.GLFW.nglfwInit(Native Method)\n    at org.lwjgl.glfw.GLFW.glfwInit(GLFW.java:429)\nand -Djava.library.path is set correctly\n. but i have an another project where it work perfectly and the sources are the same !!!?????\n. when i try with Configuration.LIBRARY_PATH.set(\"natives\"); i get the same error\nbefore i used \nSystem.setProperty(\"org.lwjgl.librarypath\", new File(\"native\").getAbsolutePath()); \nbut the result was the same\nand File(\"native\") is the right one \n. ",
    "Sylvyrfysh": "While signing up for the developer program, the EULA clearly statess that if you wish to use nVidia's SDKs you must either: use personally; or apply for a commercial license through their gameworks licensing team. The former is impossible for this and the latter MAY be possible but I doubt this.\nEDIT: agreement here https://developer.nvidia.com/content/apply-access-nvidia-physx-source-code\n. I would say this part\nYou are required to notify NVIDIA prior to use of the NVIDIA GameWorks Licensed Software in the development of any commercial Game, Expansion Pack or Demo.  Please send notification by email to: gameworkslicensing@nvidia.com and provide the following information in the email:\n      -     Company Name\n      -     Publisher and Developer Name\n      -     Game Title or Application Name\n      -     Platform (i.e. PC, Linux)\n      -     Scheduled Ship Date\n      -     WebLink to product/video\nwhere as LWJGL would not be distributing the games, everyone who makes games with LWJGL would be.\nBut hey, I'm 16, and am not by any means a legal expert.\n. @Spasi I'll look into that. And without the custom loader, the program will run if I set the natives path correctly.\n. This might get you a starting point\nhttps://github.com/johnnic431/Terminus-Engine/blob/master/src/com/form2bgames/terminusengine/model/AssimpModelWrapper.java\nOn Wed, Mar 21, 2018, 10:10 Matthew Webb notifications@github.com wrote:\n\n@Spasi https://github.com/spasi is this still something you'd like\ndone? I recently worked with Assimp a bunch, and I'd love to start\ncontributing to this project!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/302#issuecomment-374972075, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AOafQOeQCQS_IuTFUNRFhjeOoA4BWfaaks5tgm1YgaJpZM4NIJme\n.\n. Have you tried GLFW error callbacks? This would be my go-to.\n\nhttp://www.glfw.org/docs/3.0/group__error.html\nOn Nov 3, 2017 14:48, \"Peter Colapietro\" notifications@github.com wrote:\n\nI am attempting to update the gamepad mappings. So far, without any luck.\nI have tried using both methods:\n\norg.lwjgl.glfw.GLFW#glfwUpdateGamepadMappings(java.nio.ByteBuffer)\n   https://javadoc.lwjgl.org/org/lwjgl/glfw/GLFW.html#glfwUpdateGamepadMappings-java.nio.ByteBuffer-\norg.lwjgl.glfw.GLFW#glfwUpdateGamepadMappings(java.lang.CharSequence)\n   https://javadoc.lwjgl.org/org/lwjgl/glfw/GLFW.html#glfwUpdateGamepadMappings-java.lang.CharSequence-\n\nHere is an example of what I have tried using glfwUpdateGamepadMappings(\njava.lang.CharSequence)\nfinal String string = \"030000004c050000c405000000010000,PS4 Controller,a:b1,b:b2,back:b8,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,dpup:h0.1,guide:b12,leftshoulder:b4,leftstick:b10,lefttrigger:a3,leftx:a0,lefty:a1,rightshoulder:b5,rightstick:b11,righttrigger:a4,rightx:a2,righty:a5,start:b9,x:b0,y:b3,platform:Mac OS X,\";assert glfwUpdateGamepadMappings(string);\nThe code above results in a Exception in thread \"main\"\njava.lang.AssertionError in my environment. From the documentation\nglfwUpdateGamepadMappings\nReturns:\ntrue, or false if an error occurred\nNot sure what is causing the error.\nSee also:\n\nhttp://www.glfw.org/docs/3.3/input_guide.html#gamepad_mapping\nhttps://github.com/gabomdq/SDL_GameControllerDB/blob/\n   master/gamecontrollerdb.txt\ngabomdq/SDL_GameControllerDB#110\n   https://github.com/gabomdq/SDL_GameControllerDB/issues/110\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/343, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AOafQFR4MEdP4O5WIz9S5m3mFgX_ig03ks5sy230gaJpZM4QRmCZ\n.\n. Please add this line at the beginning of your program:\nSystem.setProperty(\"org.lwjgl.util.Debug\",\"true\"):\nIf any output shows up then, respond with it.. First link 404's. Anybody know what this is?. This should be good for the base commit. I'll keep working on adding when I have the time. Yeah, I'll get back to this and restart what's needed.\n\nOn Mon, Nov 26, 2018, 10:45 Ioannis Tsakpinis <notifications@github.com\nwrote:\n\nHey @Sylvyrfysh https://github.com/Sylvyrfysh,\nDo you think you'll be able to continue work on this PR? Other than fixing\nthe current conflicts, the template DSL will also have to be updated to the\nlatest version.\nBtw, LWJGL now includes a tool that extracts template definitions from\nC/C++ headers, including documentation. I would recommend using it to\nrecreate all templates and then adding the necessary modifiers (AutoSize\netc).\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/pull/352#issuecomment-441709884, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AOafQBgbrGrqp4Ds6QKi8LgQRMrDl4vNks5uzBqQgaJpZM4QpeFY\n.\n. hwloc 2.0 or old stable 1.11? 2.0 is extremely new, and supports modern processor layouts. 1.11 is the ultrastable branch but may not work as well on newer systems. The depth buffer is likely not one byte per pixel. If you change the\nallocate to allocateDirect and replace 19201080 with 19201080*3 (assuming\na 24bpp depth buffer) you should be ok. This error is likely happening\nbecause the buffer your creating isn't large enough and the video driver is\noverwriting memory it shouldn't.\n\nOn Tue, Apr 24, 2018, 12:11 Kenzie Togami notifications@github.com wrote:\n\nDon't you need to use allocateDirect, so the buffer is stored off-heap?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/386#issuecomment-384009599, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AOafQCqVKLLzGw6o4gzFel5NThq-khZdks5tr1y5gaJpZM4TiEi7\n.\n. \n",
    "Pitj3": "PhysX is now open-source, Should this become an active idea again?. I very much enjoy PhysX due to its physx visual debugger. I've never used Newton before, Bullet3D was nice back in the day, but I really think PhysX is the way forward. I see how C++ API might be an issue. @Spasi said it wasn't a huge problem but he just didn't have time until 3.0 released. Which would be now :) ?. ",
    "tlf30": "I have heard of people doing JNI bindings to PhysX, is that not a possibility? . ",
    "gitluke2006": "Thanks for the response!\nI just tried adding a callback; same problem. I also tried using the static imports on the off chance that was making a difference; all the examples I see do that. Problem persists. I believe it's hanging somewhere in the glfwCreateWindow() function; otherwise it would hit the close and terminate statements... Here's the new offending code:\njava\nimport org.lwjgl.*;\nimport org.lwjgl.glfw.*;\nimport org.lwjgl.opengl.*;\nimport static org.lwjgl.glfw.GLFW.*;\nimport static org.lwjgl.opengl.GL11.*;\nimport static org.lwjgl.system.MemoryUtil.*;\npublic class Game {\n    public static void main(String args[]) {\n        glfwInit();\n        long monitor = glfwGetPrimaryMonitor();\n        GLFWKeyCallback keyCallback = new GLFWKeyCallback() {\n            @Override\n            public void invoke(long window, int key, int scancode, int action, int mods) {\n                if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n                    glfwSetWindowShouldClose(window, GLFW_TRUE);\n            }\n        };\n        long window = glfwCreateWindow(640, 480, \"Game\", monitor, NULL);\n        glfwSetKeyCallback(window, keyCallback); \n        glfwDestroyWindow(window);\n        glfwTerminate();\n    }\n}\nFiles:\n- Test\n  - bin\n    - Game$1.class\n    - Game.class\n  - lib\n    - lwjgl.jar\n    - all dlls\n  - src\n    - Game.java\nCompilation command:\n\njavac -cp src;lib\\lwjgl.jar -d bin src*\n\nRun command:\n\njava -Djava.library.path=lib -cp bin;lib\\lwjgl.jar Game\n\nIf there's anything else I can do to assist diagnosis, let me know!\nCheers,\nLuke\n. That works, and it's what I'm doing so I can continue development, but I want full screen mode!\n. Apologies, haven't been at my computer this week. Tried the previous suggestion; still no bueno :( I'll try running on another machine, though I suspect that'll work given you've all been unable to reproduce the issue.\n. Thanks for your continued help! I have (hopefully) good news; I ran the above code (with the latest night build), and got a full screen window with a bluish color and cross hair that exited on escape!! What does that tell us?\nNote that reattempting full screen through GLFW with the new jar and natives still caused the black screen.\n. Okay! How can I get you more information? :)\n. Thanks, all! :)\nOkay, so I ran that .exe and saw the exact same symptoms as described above; screen went black and locked up. Note that I'm running Win 7 64 bit, though; is that likely to make a difference?\nAlso, I'm not sure if this is remotely correct, but I downloaded a whole lot of GL/GLUT .h, .dll and .lib files, chucked them in a single folder, put together a .cpp script using GLUT to create a fullscreen window, and that worked. I'm not working with Visual Studio or Cygwin or anything; I've just got some Microsoft c++ build tools. So maybe (is this possible?) the opengl lib on my system is broken or something?\n. Interesting. I downloaded some new drivers for a Radeon HD 7700M (also have an Intel HD Graphics 4000), restarted, and then ran that .exe you (httpdigest) sent earlier. And it worked!\nBut then I attempted to run my game and the JVM crashed when creating a window. Tried it with both the nightly and release versions of LWJGL. Hopefully I didn't do something stupid in setup - pretty much, I just copy all the .dll files from lwjgl\\natives and the .jar from lwjgl\\jar to my project's lib folder, compile, and run. The crash spits out the attached log file (previously with a .log extension, which I've changed).\nhs_err_pid5872.txt\n. Hi,\nThanks for revisiting this Spasi. I think it's best to just close the bug. It's almost certainly not the fault of LWJGL, given that I have other games that crash on full screen (e.g. tried to play Batman Arkham Asylum yesterday in FS). Just something wrong with my machine somewhere.\nCheers,\nLuke\n. ",
    "JuKu": "Hi,\nI have changed the code to following:\n``` java\nif (DeveloperOptions.isRendererLogActivated()) {\n    Logger.getRootLogger().debug(\"create glfw error callbacks.\");\n}\n//create error callback\nerrorCallback = GLFWErrorCallback.create((int error, long description) -> {\n    Logger.getRootLogger().error(\"OpenGL Error: \" + error + \", description: \" + description + \".\");\n    GLFWContextMaster.this.invoke(error, description);\n});\nmonitorCallback = GLFWMonitorCallback.create(this);\nif (DeveloperOptions.isRendererLogActivated()) {\n    Logger.getRootLogger().debug(\"set glfw error callbacks.\");\n}\n//set error callback\nGLFW.glfwSetErrorCallback(errorCallback);\nGLFW.glfwSetMonitorCallback(monitorCallback);\nif (DeveloperOptions.isRendererLogActivated()) {\n    Logger.getRootLogger().debug(\"GLFWContextMaster: try to initialize glfw context master.\");\n}\nif(GLFW.glfwInit() == GL11.GL_FALSE)\n{\n    throw new IllegalStateException(\"Initialization of glfw failed.\");\n}\nif (DeveloperOptions.isRendererLogActivated()) {\n    Logger.getRootLogger().debug(\"set glfw swap interval to 1.\");\n}\nGLFW.glfwSwapInterval(1);\n```\nBut there isnt any error shown.\nThe Application thread is like frozn and will be exit after a few seconds with the exit code:\nProcess finished with exit code -1073741819 (0xC0000005)\nThe LWJGL Debugger Output shows the following:\n[LWJGL] Version: 3.0.0 build 13\n[LWJGL]      OS: Windows 7 v6.1\n[LWJGL]     JRE: 1.8.0_65 amd64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v25.65-b01 by Oracle Corporation\n. Build 14 works also fine for me.\nThanks!\nBut there is some new logger output:\n[LWJGL] Failed to locate address for GL function glVertexArrayVertexAttribDivisorEXT\nHere is also some logger output, which doesnt do some affects:\n[LWJGL] Version: 3.0.0 build 13\n[LWJGL]      OS: Windows 7 v6.1\n[LWJGL]     JRE: 1.8.0_65 amd64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v25.65-b01 by Oracle Corporation\n[LWJGL] Loaded library from org.lwjgl.librarypath: lwjgl\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n[LWJGL] Loaded native library: <Path>/jemalloc.dll\n[LWJGL] MemoryUtil allocator: JEmallocAllocator\n[LWJGL] Loaded native library: <Path>/glfw.dll\nGLFW Error: The GLFW library is not initialized\n574 [ui-thread] ERROR root  - OpenGL Error: 65537, description: 8791501830200.\nGLFW Error: There is no current context\n596 [ui-thread] ERROR root  - OpenGL Error: 65538, description: 8791501830240.\n596 [ui-thread] DEBUG root  - initRenderer() Thread: ui-thread\n603 [ui-thread] DEBUG root  - create GLFWContext in Thread ui-thread.\n[LWJGL] Loaded native library: opengl32.dll\n[LWJGL] Failed to locate address for GL function glVertexArrayVertexAttribDivisorEXT\n. Thanks!\nI could fixed it and it works now for me.\n. Thanks for your answer!\nExecuse me for my english, i am from Germany and my english is not the best.\nI have implement the example from your vorbis demo:\nhttps://github.com/LWJGL/lwjgl3/blob/master/modules/core/src/test/java/org/lwjgl/demo/stb/Vorbis.java\nNow i have the problem, that it doesnt runs liquid, its like the application loads 0,5 seconds of the sound, plays it, wait a moment, load the next part, play it and so on.\n```\n//create new instance of sound track\nSound soundTrack = new VorbisSoundTrack();//new SoundTrack();\nString path = \"sound.ogg\";\n//load soundtrack\nsoundTrack.load(path);\n//play music\nsoundTrack.play();\n//create new thread to updating decoder and buffers\nThread updateThread = new Thread(() -> {\n  while (!isInterrupted()) {\n    //update soundtrack buffers for decoder and looping\n    soundTrack.updateBuffers();\n  }\n});\n//start thread\nupdateThread.start();\n```\nI have copied your decoder in a extra class:\n```\n/\n * vorbis decoder from lwjgl demo\n \n * @link https://github.com/LWJGL/lwjgl3/blob/master/modules/core/src/test/java/org/lwjgl/demo/stb/Vorbis.java\n \n * Created by Justin on 22.04.2016.\n */\npublic class VorbisDecoder {\nprivate static final int BUFFER_SIZE = 1024 * 4;\n\nfinal ByteBuffer vorbis;\n\nfinal long handle;\nfinal int  channels;\nfinal int  sampleRate;\nfinal int  format;\n\nfinal int   lengthSamples;\nfinal float lengthSeconds;\n\nfinal ShortBuffer pcm;\n\nint samplesLeft;\n\npublic VorbisDecoder(String filePath) {\n    try {\n        vorbis = ioResourceToByteBuffer(filePath, 256 * 1024);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n\n    IntBuffer error = BufferUtils.createIntBuffer(1);\n    handle = stb_vorbis_open_memory(vorbis, error, null);\n    if ( handle == NULL )\n        throw new RuntimeException(\"Failed to open Ogg Vorbis file. Error: \" + error.get(0));\n\n    STBVorbisInfo info = STBVorbisInfo.malloc();\n    VorbisDecoder.getInfo(handle, info);\n    this.channels = info.channels();\n    this.sampleRate = info.sample_rate();\n\n    this.format = getFormat(channels);\n\n    switch (this.format) {\n        case AL_FORMAT_MONO16:\n            Logger.getRootLogger().debug(\"sound format: AL_FORMAT_MONO16, mono, 16kbit/s\");\n            break;\n\n        case AL_FORMAT_STEREO16:\n            Logger.getRootLogger().debug(\"sound format: AL_FORMAT_STEREO16, stereo, 16kbit/s\");\n            break;\n        default:\n            Logger.getRootLogger().debug(\"unknown sound format: \" + this.format);\n            break;\n    }\n\n    this.lengthSamples = stb_vorbis_stream_length_in_samples(handle);\n    this.lengthSeconds = stb_vorbis_stream_length_in_seconds(handle);\n\n    this.pcm = BufferUtils.createShortBuffer(BUFFER_SIZE);\n\n    samplesLeft = lengthSamples;\n}\n\nprivate static void getInfo(long decoder, STBVorbisInfo info) {\n    System.out.println(\"stream length, samples: \" + stb_vorbis_stream_length_in_samples(decoder));\n    System.out.println(\"stream length, seconds: \" + stb_vorbis_stream_length_in_seconds(decoder));\n\n    System.out.println();\n\n    stb_vorbis_get_info(decoder, info);\n\n    System.out.println(\"channels = \" + info.channels());\n    System.out.println(\"sampleRate = \" + info.sample_rate());\n    System.out.println(\"maxFrameSize = \" + info.max_frame_size());\n    System.out.println(\"setupMemoryRequired = \" + info.setup_memory_required());\n    System.out.println(\"setupTempMemoryRequired() = \" + info.setup_temp_memory_required());\n    System.out.println(\"tempMemoryRequired = \" + info.temp_memory_required());\n}\n\nprivate static int getFormat(int channels) {\n    switch ( channels ) {\n        case 1:\n            return AL_FORMAT_MONO16;\n        case 2:\n            return AL_FORMAT_STEREO16;\n        default:\n            throw new UnsupportedOperationException(\"Unsupported number of channels: \" + channels);\n    }\n}\n\nprivate boolean stream(int buffer) {\n    int samples = 0;\n\n    while ( samples < BUFFER_SIZE ) {\n        pcm.position(samples);\n        int samplesPerChannel = stb_vorbis_get_samples_short_interleaved(handle, channels, pcm);\n        if ( samplesPerChannel == 0 )\n            break;\n\n        samples += samplesPerChannel * channels;\n    }\n\n    if ( samples == 0 )\n        return false;\n\n    pcm.position(0);\n    alBufferData(buffer, format, pcm, sampleRate);\n    samplesLeft -= samples / channels;\n\n    return true;\n}\n\npublic float getProgress() {\n    return 1.0f - samplesLeft / (float)(lengthSamples);\n}\n\npublic float getProgressTime(float progress) {\n    return progress * lengthSeconds;\n}\n\npublic void rewind() {\n    stb_vorbis_seek_start(handle);\n    samplesLeft = lengthSamples;\n}\n\npublic void skip(int direction) {\n    seek(min(max(0, stb_vorbis_get_sample_offset(handle) + direction * sampleRate), lengthSamples));\n}\n\npublic void skipTo(float offset0to1) {\n    seek(round(lengthSamples * offset0to1));\n}\n\nprivate void seek(int sample_number) {\n    stb_vorbis_seek(handle, sample_number);\n    samplesLeft = lengthSamples - sample_number;\n}\n\npublic boolean play(int source, IntBuffer buffers) {\n    for ( int i = 0; i < buffers.limit(); i++ ) {\n        if ( !stream(buffers.get(i)) )\n            return false;\n    }\n\n    alSourceQueueBuffers(source, buffers);\n    alSourcePlay(source);\n\n    return true;\n}\n\npublic boolean update(int source, boolean loop) {\n    int processed = alGetSourcei(source, AL_BUFFERS_PROCESSED);\n\n    for ( int i = 0; i < processed; i++ ) {\n        int buffer = alSourceUnqueueBuffers(source);\n\n        if ( !stream(buffer) ) {\n            boolean shouldExit = true;\n\n            if ( loop ) {\n                rewind();\n                shouldExit = !stream(buffer);\n            }\n\n            if ( shouldExit )\n                return false;\n        }\n        alSourceQueueBuffers(source, buffer);\n    }\n\n    if ( processed == 2 )\n        alSourcePlay(source);\n\n    return true;\n}\n\npublic void cleanUp () {\n    stb_vorbis_close(this.handle);\n}\n\n}\n```\nAfter this i have implemented an class VorbisSoundTrack, which is responsible for 1 vorbis sound:\n```\n/*\n * Created by Justin on 22.04.2016.\n /\npublic class VorbisSoundTrack implements Sound {\n/**\n* flags, if sound is loaded, playing and looping\n*/\nprotected AtomicBoolean isLoaded = new AtomicBoolean(false);\nprotected AtomicBoolean isPlaying = new AtomicBoolean(false);\nprotected AtomicBoolean isLooping = new AtomicBoolean(false);\n\n/**\n* vorbis decoder\n*/\nprotected VorbisDecoder decoder = null;\n\n/**\n* path to vorbis sound file\n*/\nprotected String path = \"\";\n\n/**\n* sourceID of vorbis sound in OpenAL\n*/\nprotected int source = 0;\n\n/**\n* sound buffer\n*/\nprotected IntBuffer buffers = BufferUtils.createIntBuffer(2);\n\npublic VorbisSoundTrack () {\n    //\n}\n\n@Override\npublic void load(String path) throws SoundNotFoundException, SoundFileException, OpenALException {\n    this.path = path;\n\n    Logger.getRootLogger().debug(\"try to load vorbis soundtrack \" + path + \".\");\n\n    if (!new File(path).exists()) {\n        throw new SoundNotFoundException(\"Couldnt find vorbis sound file \" + path + \".\");\n    }\n\n    if (!isVorbisFile(path)) {\n        throw new SoundFileException(\"Currently only .ogg soundtracks are supported.\");\n    }\n\n    //generate and get sourceID of sound file in OpenAL\n    this.source = AL10.alGenSources();\n\n    //generate buffer for vorbis sound file in OpenAL\n    AL10.alGenBuffers(buffers);\n\n    //create new instance of vorbis decoder\n    this.decoder = new VorbisDecoder(path);\n\n    //set gain and pitch\n    this.setGain(1.0f);\n    this.setPitch(1.0f);\n    this.setLooping(true);\n\n    isLoaded.set(true);\n}\n\n@Override\npublic void play() throws OpenALException {\n    checkIfSoundIsLoaded();\n\n    if (!decoder.play(source, buffers)) {\n        System.err.println(\"Playback failed.\");\n\n        throw new OpenALException(\"Error oncurred while trying to play soundtrack \" + path);\n    }\n\n    isPlaying.set(true);\n}\n\n@Override\npublic void stop() {\n    checkIfSoundIsLoaded();\n\n    isPlaying.set(false);\n}\n\n@Override\npublic void setGain(float gain) throws OpenALException {\n    //set source gain\n    AL10.alSourcef(source, AL10.AL_GAIN, gain);\n    checkALError();\n}\n\n@Override\npublic void setPitch(float pitch) throws OpenALException {\n    //set pitch\n    AL10.alSourcef(source, AL10.AL_PITCH, pitch);\n    checkALError();\n}\n\n@Override\npublic void setLooping(boolean looping) {\n    /*if (looping) {\n        //lets loop the sound\n        AL10.alSourcei(source, AL_LOOPING, AL_TRUE);\n    } else {\n        AL10.alSourcei(source, AL_LOOPING, AL_FALSE);\n    }\n\n    checkALError();*/\n\n    isLooping.set(looping);\n}\n\n@Override\npublic void updateBuffers() throws OpenALException {\n    if (!decoder.update(source, isLooping.get())) {\n        Logger.getRootLogger().warn(\"Cannot update vorbis decoder for soundtrack \" + this.path);\n        throw new OpenALException(\"Cannot update soundtrack \" + path + \".\");\n    }\n}\n\n@Override\npublic boolean isPlaying() {\n    return isPlaying.get();\n}\n\n@Override\npublic void release() {\n    isLoaded.set(false);\n\n    AL10.alDeleteBuffers(buffers);\n    AL10.alDeleteSources(source);\n\n    this.decoder.cleanUp();\n    this.decoder = null;\n}\n\nprivate void checkIfSoundIsLoaded () {\n    if (!isLoaded.get()) {\n        throw new IllegalStateException(\"sound isnt loaded yet.\");\n    }\n}\n\nprivate boolean isVorbisFile (String path) {\n    return path.endsWith(\".ogg\");\n}\n\n}\n```\nBy the way, SoundUtils (for old version, see first post in this issue):\n```\npublic class SoundUtils {\n/*\n* from lwjgl demo\n*/\npublic static ShortBuffer readVorbis(String resource, int bufferSize, STBVorbisInfo info) {\n    ByteBuffer vorbis;\n    try {\n        vorbis = ioResourceToByteBuffer(resource, bufferSize);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n\n    IntBuffer error = BufferUtils.createIntBuffer(1);\n    long decoder = stb_vorbis_open_memory(vorbis, error, null);\n    if ( decoder == 0l )\n        throw new RuntimeException(\"Failed to open Ogg Vorbis file. Error: \" + error.get(0));\n\n    stb_vorbis_get_info(decoder, info);\n\n    int channels = info.channels();\n\n    int lengthSamples = stb_vorbis_stream_length_in_samples(decoder);\n\n    ShortBuffer pcm = BufferUtils.createShortBuffer(lengthSamples);\n\n    stb_vorbis_get_samples_short_interleaved(decoder, channels, pcm);\n    stb_vorbis_close(decoder);\n\n    return pcm;\n}\n\n}\n```\n. @TheOnlySilverClaw Maybe this project can be interesting for you:\nhttps://github.com/JuKu/java-2drenderer-prototyp\nIn Release 0.0.4 pre-alpha you have an working triangle example.\nLink to release: https://github.com/JuKu/java-2drenderer-prototyp/releases\n. @TheOnlySilverClaw It should be an little game engine prototype, but its Work in Progress.\nBut you can use release 0.0.4 pre-alpha for an working example with an little abstraction.\nWhat do you want?\nMore abstraction to draw polygons / meshs easier, so also people without OpenGL skills can use LWJGL?\n. @TheOnlySilverClaw But as @httpdigest said, LWJGL isnt an game engine.\nThere are some differents.\njMonkeyEngine ist an 3D game engine, based on LWJGL and other tools. There are many abstraction, so you dont need to use OpenGL anymore, only for extensions.\nLWJGL ist also an Gaming Library, but its goal isnt to add more abstraction to OpenGL.\nIts gool is to give all the tools together in one library, so that Java Developer can use this tools, like the OpenGL pipeline with all its native calls very easy.\nSo i dont know if its an good idea to build an example for an game engine, for what LWJGL isnt builded.\nIf you want to know, how you can draw an triangle (an rectangle is only 2x triangle), take a look of this classes on my project:\nGPUTriangle.java: https://github.com/JuKu/java-2drenderer-prototyp/blob/master/prototyp-game-engine/src/main/java/com/jukusoft/renderer2d/prototyp/engine/mesh/data/GPUTriangle.java\nTriangle: https://github.com/JuKu/java-2drenderer-prototyp/blob/master/prototyp-game-engine/src/main/java/com/jukusoft/renderer2d/prototyp/engine/mesh/data/Triangle.java\nIn my project i have added more abstraction, so class Triangle holds data of triangle (coordinates of all 3 edges and color) and class GPUTriangle contains the specific OpenGL calls for this, so i want to add support for other graphic pipelines without changing your program code.\nSo the prototyp can maybe support DirectX, Vulkan and also OpenGL.\nBut its an higher abstraction level than LWJGL.\n. And why does the application have an context on Windows and Mac OSX, but not on Linux?\nEDIT:\nIt works with Windows and Mac OSX.\n. Here is the code of createWindow() method:\n``` java\nprotected void createWindow(final HashMap windowHints, boolean defaultHints)\n    {\n        if (defaultHints)\n        {\n            GLFW.glfwDefaultWindowHints();\n        }\n    for (HashMap.Entry<Integer,Integer> entry : windowHints.entrySet())\n    {\n        GLFW.glfwWindowHint(entry.getKey(), entry.getValue());\n    }\n\n    //create the window\n    if(!fullscreen)\n    {\n        window = GLFW.glfwCreateWindow(800, 600, \"Window Title\", 0, 0);\n    }\n    else\n    {\n        //save the current monitor\n        monitor = GLFW.glfwGetPrimaryMonitor();\n        GLFWVidMode vidmode = GLFW.glfwGetVideoMode(monitor);\n        //create the window on the primary monitor\n        window = GLFW.glfwCreateWindow(vidmode.width(), vidmode.height(), \"Window Title\", GLFW.glfwGetPrimaryMonitor(), 0);\n    }\n\n    keyCallback = GLFWKeyCallback.create((long window, int key, int scancode, int action, int mods) ->\n    {\n        invoke(window, key, scancode, action, mods);\n    });\n\n    cursorCallback = GLFWCursorPosCallback.create((long window, double xpos, double ypos) ->\n    {\n        invoke(window, xpos, ypos);\n    });\n\n    closeCallback = GLFWWindowCloseCallback.create((long window) -> {\n        Logger.getRootLogger().debug(\"close window\");\n\n        //call callback\n        invoke(window);\n    });\n\n    focusCallback = GLFWWindowFocusCallback.create((long window, boolean focused) ->\n    {\n        invoke(window, focused);\n    });\n\n    //set the com.pentaquin.core.input callbacks\n\n    //set keyboard callbacks\n    GLFW.glfwSetKeyCallback(window, keyCallback);\n\n    GLFW.glfwSetCursorPosCallback(window, cursorCallback);\n\n    //set the window callbacks\n    GLFW.glfwSetWindowCloseCallback(window, closeCallback);\n    GLFW.glfwSetWindowFocusCallback(window, focusCallback);\n}\n\n```\n. @Spasi Its windowed mode.\nWindow hints:\n``` java\n//set the default window hints\nGLFW.glfwDefaultWindowHints();\n//set window not resizeable and enable double buffering\nGLFW.glfwWindowHint(GLFW.GLFW_RESIZABLE, GLFW.GLFW_FALSE);\nG\nLFW.glfwWindowHint(GLFW.GLFW_DOUBLEBUFFER, GLFW.GLFW_TRUE);\n```\nThe invoke methods inside the callbacks are only wrapper methods like an Observer Design Patterns.\nExample of such invoke method for GLFWKeyCallback:\n``` java\n/\n         * @see org.lwjgl.glfw.GLFWKeyCallback.SAM#invoke(long, int, int, int, int)\n         /\n    public void invoke(long window, int key, int scancode, int action, int mods) \n    {\n        if(action != GLFW.GLFW_PRESS && action != GLFW.GLFW_RELEASE)\n        {\n            return;\n        }\n    if (action == GLFW.GLFW_PRESS) {\n        //key pressed\n\n        //iterate through keyboard listeners\n        for (KeyboardListener keyboardListener : this.keyboardListeners) {\n            keyboardListener.keyPressed(window, KeyConverter.getKey(key), key, scancode, action, mods);\n        }\n    } else if (action == GLFW.GLFW_RELEASE) {\n        //key released\n\n        //iterate through keyboard listeners\n        for (KeyboardListener keyboardListener : this.keyboardListeners) {\n            keyboardListener.keyReleased(window, KeyConverter.getKey(key), key, scancode, action, mods);\n        }\n    }\n\n    //keyboard event handling\n    KeyEvent e = new KeyEvent(this, (action==GLFW.GLFW_PRESS) ? true : false, KeyConverter.getKey(key));\n\n    for(int i = 0; i < keylistener.size(); i++)\n    {\n        keylistener.get(i).handleEvent(e);\n    }\n}\n\n```\nIts only for our internal input event / listener system.\n. Thanks for your answer!\n. @Spasi Thanks!\nIs there an Changelog available?\nWhich modules (maven coordinates) do we have to include to have all features from versions before this SNAPSHOT?\n. @Spasi Thanks! :D\n. Gitter is newer.\nThe best thing of Slack are the integrations, you can add an channel, where Github post, if someone pushed an commit or if an build failed. Or you can be notified, if someone write an issue.\nhttps://medium.freecodecamp.com/so-yeah-we-tried-slack-and-we-deeply-regretted-it-391bcc714c81#.mysggpdd6\nBut Slack has a few limitations, Gitter not (exception: max 25 users in private chats).\nhttps://gitter.im/#pricing-panel\nGitter has also Integrations:\nhttps://gitter.im/#integrations-panel\nAlso Gitter is modern, but its an little bit IRC like.\n. @Spasi You need an Slack account for every team, so you need an new slack account to use it for LWJGL.\nMaybe Gitter can be the better choice.\n. Maybe also Discord can be interesting for you:\nhttps://discordapp.com/\nIts an Text and voice messanger in one app.\nBut i havent tested it yet.\n. @sriharshachilakapati Thanks for your answer!\nBut why does it works with windows and linux?\n. @Spasi Thanks for your answer!\nThis means we have to hard code this values now, like in your example code?\nCode:\njava\nglVertexAttribPointer(attrib_pos, 2, GL_FLOAT, false, 20, 0);\nglVertexAttribPointer(attrib_uv, 2, GL_FLOAT, false, 20, 8);\nglVertexAttribPointer(attrib_col, 4, GL_UNSIGNED_BYTE, true, 20, 16);\n. @Spasi Thanks for your answer!\nI have replaced the constants by their values now.\n. Thanks to your answers!\nI have fixed this issue with adding dependencie for JEmallocAllocator.\nBut now, i get an new exception:\n[LWJGL] Loading library: jemalloc\n[LWJGL]     Extracting: file:/D:/Users/<User>/.gradle/caches/modules-2/files-2.1/org.lwjgl/lwjgl-jemalloc/3.0.1-SNAPSHOT/1390bc6f4282cf33f4f31608ce89ac64fd581edc/lwjgl-jemalloc-3.0.1-SNAPSHOT-natives-windows.jar!/jemalloc.dll\n[LWJGL]     jemalloc.dll not found in java.library.path=D:\\Users\\<User>\\IdeaProjects\\pentaquin-client\\build/natives/windows/\n[LWJGL]     jemalloc.dll not found in system paths\n[LWJGL] Failed to load a library. Possible solutions:\n    a) Set -Djava.library.path or -Dorg.lwjgl.librarypath to the directory that contains the shared libraries.\n    b) Add the JAR(s) containing the shared libraries to the classpath.\njava.lang.UnsatisfiedLinkError: Failed to locate library: jemalloc.dll\n    at org.lwjgl.system.Library.loadNative(Library.java:202)\n    at org.lwjgl.system.jemalloc.JEmalloc.<clinit>(JEmalloc.java:37)\n    at org.lwjgl.system.jemalloc.JEmallocAllocator.<clinit>(JEmallocAllocator.java:17)\n    at java.lang.Class.forName0(Native Method)\n    at java.lang.Class.forName(Class.java:264)\n    at org.lwjgl.system.MemoryManage.getInstance(MemoryManage.java:36)\n    at org.lwjgl.system.MemoryUtil$LazyInit.<clinit>(MemoryUtil.java:76)\n    at org.lwjgl.system.MemoryUtil.getAllocator(MemoryUtil.java:138)\n    at org.lwjgl.system.Callback.<clinit>(Callback.java:67)\n    at com.pentaquin.core.context.GLFWContextMaster.init(GLFWContextMaster.java:41)\n    at com.pentaquin.core.application.BasicGameStateEngine.createAndInitContext(BasicGameStateEngine.java:186)\n    at com.pentaquin.core.application.BasicGameStateEngine.init(BasicGameStateEngine.java:157)\n    at com.pentaquin.client.game.GameMain.main(GameMain.java:66)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n[LWJGL] Failed to instantiate memory allocator: org.lwjgl.system.jemalloc.JEmallocAllocator\n. Thanks! :D\nWe have resolved this issue now. :D \nThe native wasnt correct extracted in the right directory.\n. ",
    "NozzyEz": "Obviously... I feel ashamed I didn't see that.... I didn't come up with the code, but I typed it in so I should have realized. I commented it out, and also made a call to run() (How the code is supposed to work without it I don't know?) \nlong story short, it works, although I expected an all black window, it seems to be flashing rapidly...\n. ",
    "sci4me": "Sorry and thanks.\n. ",
    "remexre": "I self-built vogl, I'm using java -jar test.jar in vogleditor64, and now I'm getting a \"normal\" failure to create a window after a successful glfwInit(). This is from a box with Intel Graphics; I can check on my nvidia box when I get home.\n. ",
    "nidefawl": "Wouldn't it make more sense to make a complete new library (similiar to lwjgl) but on top of vulkan?\n. ",
    "johnnic431": "Check issue #50.\nSpecifically this comment: https://github.com/LWJGL/lwjgl3/issues/50#issuecomment-159048360\n. @sriharshachilakapati I'm aware, but the comment mentions that it will take a little while to release a LWJGL update.\n. Correct me if I am wrong, but from that I gether that this should disable the error ID 131185, which produces the output\nID 131185: OTHER of NOTIFICATION severity, raised from API: Buffer detailed info: Buffer object 12 (bound to GL_ELEMENT_ARRAY_BUFFER_ARB, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.\nThis is the new code I tried:\nGL43.glDebugMessageControl(GL43.GL_DEBUG_SOURCE_API,GL43.GL_DEBUG_TYPE_OTHER,GL43.GL_DEBUG_SEVERITY_NOTIFICATION,BufferUtils.createIntBuffer(1).put(131185)[.flip()],false);\nIt still shows all notifications, even 131185 as detailed above. Am I still doing it incorrectly? I have the correct source, debug type, and severity level, which are not DONT_CARE, along with the correct ID.\nChanging that line to GL43.glDebugMessageControl(GL43.GL_DEBUG_SOURCE_API,GL43.GL_DEBUG_TYPE_OTHER,GL43.GL_DEBUG_SEVERITY_NOTIFICATION,(IntBuffer)null,false);\nfixes it, but obviously kills all other notifications in that level. Minor issue, and I know i could just return on bad ID's in my callback (which I'm currently doing), but this just doesn't seem right.. ",
    "juanmf": "Thanks! \n. ",
    "Ali-RS": "I have the similar problem.Mine has nothing to do with Swing but in jMonkeyengine.\nI recently update my jme game from lwjgl 2.9.x (which is default by jMonkeyengine) to lwjgl 3.0.0 and now when running game i get \nX Error of failed request:  RenderBadPicture (invalid Picture parameter)\n  Major opcode of failed request:  139 (RENDER)\n  Minor opcode of failed request:  7 (RenderFreePicture)\n  Picture id in failed request: 0x2c00023\n  Serial number of failed request:  1422\n  Current serial number in output stream:  1423\nAL lib: (EE) alc_cleanup: 1 device not closed\n:run FAILED\nI am on \nLenovo laptop\nUbuntu 16.10\nIntel HD 3000 and AMD HD 6370m switchable graphic.\nI asked my problem in jme forum but i got no response so decided to ask it here.\nFull detail is here : \nhttps://hub.jmonkeyengine.org/t/experimenting-lwjgl3/37275\n. > Could you try with LWJGL 3.1.0?\nI tried to build with 3.1.0 by editing build.gradle in jme3-lwjgl3 : \n```\nif (!hasProperty('mainClass')) {\n    ext.mainClass = ''\n}\ndef lwjglVersion = '3.1.0'\ndef lwjglNativesVersion = '3.0.0'\nsourceCompatibility = '1.8'\ndependencies {\n    compile project(':jme3-core')\n    compile project(':jme3-desktop')\ncompile \"org.lwjgl:lwjgl:${lwjglVersion}\"\ncompile \"org.lwjgl:lwjgl-platform:${lwjglNativesVersion}:natives-windows\"\ncompile \"org.lwjgl:lwjgl-platform:${lwjglNativesVersion}:natives-linux\"\ncompile \"org.lwjgl:lwjgl-platform:${lwjglNativesVersion}:natives-osx\"\ncompile \"org.lwjgl:lwjgl-glfw:${lwjglVersion}\"\ncompile \"org.lwjgl:lwjgl-openal:${lwjglVersion}\"\ncompile \"org.lwjgl:lwjgl-opencl:${lwjglVersion}\"\ncompile \"org.lwjgl:lwjgl-opengl:${lwjglVersion}\"\n\n}\n```\nbut when running game i am getting this error \n```\nExecuting: gradle :run\nArguments: [-PmainClass=example.Main, -PcmdLineArgs=, -c, /media/idea/01D0ABF282E1DD20/Java/jME_NB-PW-11-6-2015/Examples/sim-eth-es/settings.gradle]\n:compileJava UP-TO-DATE\n:processResources UP-TO-DATE\n:classes UP-TO-DATE\n:assets:compileJava UP-TO-DATE\n:assets:processResources UP-TO-DATE\n:assets:classes UP-TO-DATE\n:assets:jar UP-TO-DATE\n:run\nSimEthereal Example 2\nSetting root JUL log level to:INFO\nlogger config:root\nSetting JUL Log: level to:INFO\nlogger config:com.simsilica.sim\nSetting JUL Log:com.simsilica.sim level to:FINER\nlogger config:example\nSetting JUL Log:example level to:FINE\n18:14:01,702 INFO  [JmeSystem] Running on jMonkeyEngine 3.2-1\n * Branch: master\n * Git Hash: c50b4db\n * Build Date: 2016-09-22\n18:14:01,860 ERROR [LegacyApplication] Uncaught exception thrown in Thread[main,5,main]\njava.lang.ExceptionInInitializerError\n    at org.lwjgl.glfw.GLFW.nglfwSetErrorCallback(GLFW.java:794) ~[lwjgl-glfw-3.1.0.jar:?]\n    at org.lwjgl.glfw.GLFW.glfwSetErrorCallback(GLFW.java:823) ~[lwjgl-glfw-3.1.0.jar:?]\n    at com.jme3.system.lwjgl.LwjglWindow.createContext(LwjglWindow.java:129) ~[jme3-lwjgl3-3.2.0-SNAPSHOT.jar:3.2.0-UNKNOWN]\n    at com.jme3.system.lwjgl.LwjglWindow.initInThread(LwjglWindow.java:353) ~[jme3-lwjgl3-3.2.0-SNAPSHOT.jar:3.2.0-UNKNOWN]\n    at com.jme3.system.lwjgl.LwjglWindow.run(LwjglWindow.java:479) ~[jme3-lwjgl3-3.2.0-SNAPSHOT.jar:3.2.0-UNKNOWN]\n    at com.jme3.system.lwjgl.LwjglWindow.create(LwjglWindow.java:324) ~[jme3-lwjgl3-3.2.0-SNAPSHOT.jar:3.2.0-UNKNOWN]\n    at com.jme3.app.LegacyApplication.start(LegacyApplication.java:463) ~[jme3-core-3.2.0-SNAPSHOT.jar:3.2-1]\n    at com.jme3.app.LegacyApplication.start(LegacyApplication.java:424) ~[jme3-core-3.2.0-SNAPSHOT.jar:3.2-1]\n    at com.jme3.app.SimpleApplication.start(SimpleApplication.java:125) ~[jme3-core-3.2.0-SNAPSHOT.jar:3.2-1]\n    at example.Main.main(Main.java:107) ~[main/:?]\nCaused by: java.lang.IllegalStateException: This function is not available.\n    at org.lwjgl.system.Checks.checkFunctionAddress(Checks.java:94) ~[lwjgl-3.1.0.jar:?]\n    at org.lwjgl.system.APIUtil.apiGetFunctionAddress(APIUtil.java:120) ~[lwjgl-3.1.0.jar:?]\n    at org.lwjgl.glfw.GLFW$Functions.(GLFW.java:621) ~[lwjgl-glfw-3.1.0.jar:?]\n    ... 10 more\n:run FAILED\nFAILURE: Build failed with an exception.\n\n\nWhat went wrong:\nExecution failed for task ':run'.\n\nProcess 'command '/usr/local/jmonkeyplatform/jdk/bin/java'' finished with non-zero exit value 1\n\n\n\nTry:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\n\nBUILD FAILED\nTotal time: 24.616 secs\nBuild failure (see the Notifications window for stacktrace): gradle :run\n```\n\nCan you force your system to use the AMD GPU instead of the Intel HD?\n\nI forced to use AMD using DRI_PRIME=1 command but Error happens again.\nAs you see in log below it switched to AMD  Renderer: Gallium 0.4 on AMD CEDAR (DRM 2.43.0, LLVM 3.8.0)\n```\nExecuting: gradle :run\nArguments: [-PmainClass=example.Main, -PcmdLineArgs=, -c, /media/idea/01D0ABF282E1DD20/Java/jME_NB-PW-11-6-2015/Examples/sim-eth-es/settings.gradle]\n:compileJava UP-TO-DATE\n:processResources UP-TO-DATE\n:classes UP-TO-DATE\n:assets:compileJava UP-TO-DATE\n:assets:processResources UP-TO-DATE\n:assets:classes UP-TO-DATE\n:assets:jar UP-TO-DATE\n:run\nSimEthereal Example 2\nSetting root JUL log level to:INFO\nlogger config:root\nSetting JUL Log: level to:INFO\nlogger config:com.simsilica.sim\nSetting JUL Log:com.simsilica.sim level to:FINER\nlogger config:example\nSetting JUL Log:example level to:FINE\n18:30:25,057 INFO  [JmeSystem] Running on jMonkeyEngine 3.2-1\n * Branch: master\n * Git Hash: c50b4db\n * Build Date: 2016-09-22\n18:30:25,679 INFO  [LwjglContext] LWJGL 3.0.0 build 90 context running on thread main\n * Graphics Adapter: GLFW 3.2.0 X11 GLX EGL clock_gettime /dev/js Xf86vm shared\n18:30:26,015 INFO  [GLRenderer] OpenGL Renderer Information\n * Vendor: X.Org\n * Renderer: Gallium 0.4 on AMD CEDAR (DRM 2.43.0, LLVM 3.8.0)\n * OpenGL Version: 3.0 Mesa 11.2.0\n * GLSL Version: 1.30\n * Profile: Compatibility\n18:30:26,068 WARN  [AssetConfig] Cannot find loader com.jme3.scene.plugins.ogre.MeshLoader\n18:30:26,069 WARN  [AssetConfig] Cannot find loader com.jme3.scene.plugins.ogre.SkeletonLoader\n18:30:26,070 WARN  [AssetConfig] Cannot find loader com.jme3.scene.plugins.ogre.MaterialLoader\n18:30:26,071 WARN  [AssetConfig] Cannot find loader com.jme3.scene.plugins.ogre.SceneLoader\n18:30:26,071 WARN  [AssetConfig] Cannot find loader com.jme3.scene.plugins.blender.BlenderModelLoader\n18:30:26,074 WARN  [AssetConfig] Cannot find loader com.jme3.scene.plugins.fbx.FbxLoader\n18:30:26,077 WARN  [AssetConfig] Cannot find loader com.jme3.audio.plugins.OGGLoader\nCannot connect to server socket err = No such file or directory\nCannot connect to server request channel\njack server is not running or cannot be started\nJackShmReadWritePtr::~JackShmReadWritePtr - Init not done for 4294967295, skipping unlock\nJackShmReadWritePtr::~JackShmReadWritePtr - Init not done for 4294967295, skipping unlock\n18:30:26,219 INFO  [ALAudioRenderer] Audio Renderer Information\n * Device: OpenAL Soft\n * Vendor: OpenAL Community\n * Renderer: OpenAL Soft\n * Version: 1.1 ALSOFT 1.17.2\n * Supported channels: 64\n * ALC extensions: ALC_ENUMERATE_ALL_EXT ALC_ENUMERATION_EXT ALC_EXT_CAPTURE ALC_EXT_DEDICATED ALC_EXT_disconnect ALC_EXT_EFX ALC_EXT_thread_local_context ALC_SOFTX_device_clock ALC_SOFT_HRTF ALC_SOFT_loopback ALC_SOFT_pause_device\n * AL extensions: AL_EXT_ALAW AL_EXT_BFORMAT AL_EXT_DOUBLE AL_EXT_EXPONENT_DISTANCE AL_EXT_FLOAT32 AL_EXT_IMA4 AL_EXT_LINEAR_DISTANCE AL_EXT_MCFORMATS AL_EXT_MULAW AL_EXT_MULAW_BFORMAT AL_EXT_MULAW_MCFORMATS AL_EXT_OFFSET AL_EXT_source_distance_model AL_LOKI_quadriphonic AL_SOFT_block_alignment AL_SOFT_buffer_samples AL_SOFT_buffer_sub_data AL_SOFT_deferred_updates AL_SOFT_direct_channels AL_SOFT_loop_points AL_SOFT_MSADPCM AL_SOFT_source_latency AL_SOFT_source_length\n18:30:26,220 INFO  [ALAudioRenderer] Audio effect extension version: 1.0\n18:30:26,226 INFO  [ALAudioRenderer] Audio max auxiliary sends: 4\n18:30:26,530 INFO  [GuiGlobals] Initializing GuiGlobals with:com.simsilica.lemur.GuiGlobals@15ca7889\n18:30:26,577 INFO  [GuiGlobals] Lemur build date:20161107\n18:30:26,579 INFO  [BaseStyles] loadStyleResource(com/simsilica/lemur/style/base/glass-styles.groovy)\n18:30:27,549 INFO  [BaseStyles] Loading base resource:jar:file:/home/idea/opt/packages/gradle/gradle-3.0/caches/modules-2/files-2.1/com.github.jMonkeyEngine-Contributions.Lemur/lemur/4493c92a1f/986a10b5b402eb34a8b4a7131a2457374e1cc8f4/lemur-4493c92a1f.jar!/com/simsilica/lemur/style/base/glass-styles.groovy\n18:30:28,729 INFO  [BaseStyles] Loading extension resources for:com/simsilica/lemur/style/base/glass-styles.groovy\n18:30:28,730 INFO  [BaseStyles] Loading extension resource:jar:file:/home/idea/opt/packages/gradle/gradle-3.0/caches/modules-2/files-2.1/com.github.jMonkeyEngine-Contributions.Lemur/lemur-props/4493c92a1f/dd4fa62d0c0b13608b9752e18c0c04fa49cfd23e/lemur-props-4493c92a1f.jar!/com/simsilica/lemur/style/base/glass-styles.groovy\n18:30:28,798 INFO  [BaseStyles] Loading extension resource:jar:file:/home/idea/opt/packages/gradle/gradle-3.0/caches/modules-2/files-2.1/com.github.jMonkeyEngine-Contributions.Lemur/lemur-proto/4493c92a1f/b4c98ff4774f83d85cbd6fefad2c2e42e4680d94/lemur-proto-4493c92a1f.jar!/com/simsilica/lemur/style/base/glass-styles.groovy\n18:30:29,108 INFO  [BaseStyles] Loading extension resource:jar:file:/home/idea/opt/packages/gradle/gradle-3.0/caches/modules-2/files-2.1/com.simsilica/lemur/1.8.2/6be7911edec09aca630ebda559f2cfd01ed403f1/lemur-1.8.2.jar!/com/simsilica/lemur/style/base/glass-styles.groovy\nX Error of failed request:  RenderBadPicture (invalid Picture parameter)\n  Major opcode of failed request:  139 (RENDER)\n  Minor opcode of failed request:  7 (RenderFreePicture)\n  Picture id in failed request: 0x5600023\n  Serial number of failed request:  900\n  Current serial number in output stream:  901\nAL lib: (EE) alc_cleanup: 1 device not closed\n:run FAILED\nFAILURE: Build failed with an exception.\n\n\nWhat went wrong:\nExecution failed for task ':run'.\n\nProcess 'command '/usr/local/jmonkeyplatform/jdk/bin/java'' finished with non-zero exit value 1\n\n\n\nTry:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\n\nBUILD FAILED\nTotal time: 14.924 secs\nBuild failure (see the Notifications window for stacktrace): gradle :run\n```\nEdit : I also tested on java 9 but the problem happened again.\n. Also I tested on Windows and everything works OK in windows using lwjgl 3.0.0.\n. Just found that when i disable Groovy Glass Style on game GUI (which uses groovy-all.jar)  that error happens just occasionally and it runs fine most of the time. \n\nThe error above is likely caused by a mismatch between the Java and native libraries\n\nWhat version for natives library matches with lwjgl 3.1.0 then? If i set 3.1.0 for natives it can not find jars for this reason i set 3.0.0. \n. > What version for natives library matches with lwjgl 3.1.0 then?\nNever mind. I can see your new download page do generate gradle snippet automatically. That's very cool.\nI will try it, hope it works this time. \n. Okay, I could build successfully with 3.1.0. when i ran the game for the first time after build, setting groovy glass style on, it ran like a charm but when i closed and reopened it failed with same error.\nBut turning off glass style it runs fine.\n. @Spasi  sorry for late reply ...\nI could solve the problem. \nActually it was related to Swing ... \nI disabled Settings menu in jME (which is a splash screen with some settings like vsync, screen resolution , antialiasing ,...) which is a swing canvas. \nBy disabling it, game runs fine.\n. You can also take a look at jMonkeyengine bullet wrapper \nhttps://wiki.jmonkeyengine.org/jme3/advanced/physics.html#technical-overview\nhttps://github.com/jMonkeyEngine/jmonkeyengine\nAnd if you want a sever side bullet physic simulation with an EntityComponentSystem design like what I am doing for my mmorpg, you can consider \nhttps://hub.jmonkeyengine.org/t/ecs-in-complex-3d-games-how-deep-should-it-go/40665/5?u=ali_rs\nhttps://hub.jmonkeyengine.org/t/is-jmonkey-the-right-engine-for-simulating-basic-physics/40714/13?u=ali_rs\nit will add bunch of dependencies though ;)\n . ",
    "floyd1982": "Hey everyone,\nI wondered if there is any news on this topic, besides @Ali-RS managed to avoid the problem.\nUnfortunately I'm facing the same issue. My setup:\n\nUbuntu 17.10\nLWJGL 3.1.6\n\nBefore the actual game built with OpenGL 3.2 I have a small resolution picker dialog written in Java-Swing. Then after some time the game crashes with the following command line output:\nX Error of failed request:  RenderBadPicture (invalid Picture parameter)\n  Major opcode of failed request:  139 (RENDER)\n  Minor opcode of failed request:  7 (RenderFreePicture)\n  Picture id in failed request: 0x4c0001d\n  Serial number of failed request:  6928\n  Current serial number in output stream:  6931\nIf I omit the picker dialog and set the resolution hard coded, everything works fine. Is there anything I can do? I didn't have the problem with the same project and LWJGL 2.9.3\nThank you very much for your great work in LWJGL!. Thanks for the quick anwer!\nOkay, this means I could replace the resolution picker with a e.g. FX variant?. I see... Is this something which is worked on, or a situation which can't be fixed? I think about the engines and editors (JMonkeyEngine) mixing a UI (Swing/FX) with LWJGL 3.\nI migrated my own level editor from Swing to FX first, and then switched from LWJGL 2 to 3. No problems so far, but I didn't run it on a Mac yet.\n(my new JavaFX resolution picker doesn't crash the game btw.). ",
    "elmindreda": "@phr00t Is your window full screen or windowed?\n. @Spasi Yup, this is totally my fault. It's a regression I was hoping to get away with to introduce separation of behavior. If you prefer I'll revert to the old behavior (though still using the newer code).\n. (Due to headache I'm probably saying at least some obvious things below. Sorry.)\n\nBy default, both windowed and full screen mode windows are focused when initially created.\n\nThis was poorly written. What I was trying to say with \"initially created\" was that this is done by glfwCreateWindow or not at all. If one turns off GLFW_VISIBLE (which appears to be what @phr00t did, hence the call to glfwShowWindow) then the default behavior of show plus focus is overridden.\nShould I track whether the window has ever been shown and then additionally focus it the first time it is shown?\n. The previous behavior has been restored with glfw/glfw@89f438de5a862802717a5d6e32ebfe462775cccf.\n. Looking into this.\n. @dannycalleri Not yet. Working on it.\n. This is quite possibly resolved in GLFW master.\n. So this technically isn't fixed yet; I just made it much harder to hit. Until I've fixed it properly, it may still happen if people play with the GLFW_CONTEXT_CREATION_API hint on the X11 backend.\nIn the meantime, I'll put out a 3.2.1 to give everyone this workaround (and a few unrelated fixes).\n. ",
    "r41d": "2000 lines for a triangle, what kind of joke is this? ^^. ",
    "Guichaguri": "That explains why. Thanks\n. Sorry, but I think this is being more problematic than useful. I think this is the first Java 8 functionality in LWJGL 3, and I think it should be removed to keep it compatible with Java 7, since a lot of users still use Java 7.\nThe only thing I can suggest is renaming free to close or implementing both of them without default methods :/\n. No problem. At least I still have a Swing alternative for older Java versions, and I can always go back to LWJGL 2. Thanks.\n. ",
    "hypernewbie": "I disagree.\nIt is not a big deal for your use cases, but that doesn't make the bindings any less terrible. It's just terrible in a way that doesn't affect the way you're using it.\nThis protects from unintentionally using functionality from a higher OpenGL version, but does not protect from unintentionally using a deprecated function from lower OpenGL when creating a core context. glBegin() doesn't exist on a core 33 context, but importing GL11.* gets me glBegin() :(. Yet I can't not use GL11 if I want GL_ARRAY_BUFFER.\nI argue we should at least have a org.lwjgl.opengl.GL33core.* and should have EXACTLY all the entries in core 3.3, nothing more nothing less. For a library that claims to bind OpenGL, is this too much to ask? :P\n. Hi,\nThanks for the suggestions.\nThe forward compat would help by crashing on null funcptr. I don't see how LWJGL's bindings can not have these functions in the first place by exposing only the core profile.\nI do not intend to sound confrontational. I apologise if I sounded like that. I do intend to use LWJGL, I am complaining because I hope to make LWJGL better. If I didn't care then I wouldn't even post here. I am not intending to learn OpenGL with LWJGL, and agree it's not the best doc to do that.\nI'm running intro trouble because I'm trying to port an ES2 app over to GL without using desktop ES compatibility extension. ES2 should be mostly subset of GL3 (save a few things). The app calls GL using the Android GLES20.gl style.\nI ended up manually plugging every ES2 entry to the equivalent GLxx., even though I would've liked to be able to just extend GL33core or something and called it a day. I couldn't extend multiple classes from Java, and the GL* bindings aren't interfaced. Guess I probably should've used a python script or something to do that, but ES2 wasn't that big.\nThe use case here can probably be made easier if I just did a bunch of find-replace operations across the app code itself. But the fact that there is no core GLX.X interface in LWJGL is still hardly a selling point, no matter how minor to most people.\nHaving an accumulative version of org.lwjgl.opengl.GLXX would help something like my use case. That would be pretty sweet. I argue Core profile version should exist regardless of what people's opinions are regarding accumulative version.\n. I'm not asking for the incremental versions.\nOpenGL 3.3 core is a very specific API. When you create a 3.3 core context you get this exact set of functions and definitions and nothing more, nothing less. Anything more is illegal without extensions. Calling GL2 functions will certainly break the spec. All I wanted is a binding to 3.3 core, nothing more, nothing less, and if there's a GL2 function that doesn't actually exist in the driver for 3.3 core, why should it exist as a function in my bindings?\nLWJGL3 effectively models compatibility. It does not bind core context. It binds a superset of core context, but that's not binding the core context.\nFWIW I worked for and with the OpenGL Khronos group as member and part of the vendor driver team, and my ex co-workers (some of whom designed OpenGL and implemented it) would probably agree that an OpenGL binding library should have the ability to bind core.\nFor example, glbinding can just #include , and get the functionality of the GL 3.2 core exactly, nothing more nothing less. glBegin() is not part of the GL 3.2 core and calling that is illegal even though it works in a subset of drivers.. ",
    "TheOnlySilverClaw": "\nI agree, its not a big deal. And extending classes just to import static functions is plain fugly, and a bad practice as it is. I doubt anyone here wants to encourage that kind of usage.\n\nI was tempted to shout yes, since it would kind of make sense that newer versions extend older ones, but a @dustContributor mentioned, it's probably inappropriate for static methods.\nI still don't thin static importing everything is the greatest of all ways to handle this, especially for people who do not know OpenGL that well and try to find out how the whole thing works together. On the other hand, there is probably no perfect solution to bind Java methods to native calls, to the best course would be to leave it alone and focus on more useful things.\n. > It is hard to know in advance what people would like to learn about OpenGL to make a sufficiently simple demo that addresses this aspect. Like you mentioned, the lwjgl3-demos tries to contain single-file demos addressing various aspects. And I promise you that these demos will always be kept in sync with the most recent LWJGL version. Maybe you could tell what you'd have liked to be in there?\nI know what you mean and I fully agree, there will be no \"one fits all solution\", but I think that's not necessary. JMonkeyEngine used a colored cube as the initial setup and i think that's a good place to start. It should just bring people to the point where they can try around with stuff, like change the cube colors, make two cubes, rotate one of them, etc. That's how I would have wanted to start learning, instead of spending the first few hours going through crash reports and looking at empty screens. And from that point on, I would be much more eager to experiment knowing that I could always start with a fresh copy when I would mess everything up.\nI would love to know what other people would consider a good starting setup, but for me it would basically be what I would have after working through the first half of the lwjglwook:\nBasic classes for\n- Window\n- ShaderProgram(, Shader)\n- Mesh\n- Camera\n  and some very basic shaders, maybe one for color and for 2dtexture.\nAaaand yeah, optionally package the whole thing with a good build script. I did not find the setup that complicated, but adding the native dependencies might help some people. Also, I would not mind putting a dependency on JOML into the Starter Kit, since that's probably the first thing I install anyway. ;)\n. The JOML stuff looks neat, such a shame I did not find that earlier...\nI was assuming LWJGL3 was not really intended to be used with Legacy OpenGL anyway. I would at least not make the Starter Kit support using Legacy stuff. But maybe that's just my impression.\nAnd yes, having something like and Initializr for LWJGL3 would be pretty great.\nLooking at the labels...I would love to contribute, I'm just not really sure how. I suspect with my current knowledge about most of the stuff involved, I would break more than help. :/\n. @JuKu I skimmed over it and I'm not entirely sure what it is supposed to be.  Looks like a small game engine?\nAnyway, I already played around with 2D shapes. It's the 3D projection and all where things got tricky. I will continue to play around with LWJGL after my bachelor's thesis again, maybe if I figure something out, I'll contribute an Example for rendering a simple cube.\nI think the most important thing would be to make it minimalistic, but also extensible, so when someone starts using LWJGL, they can start by changing the color, size, rotation, etc. of the cube and when they got the hang of it, throw that away and start tinkering.\n. > What do you want?\n\nMore abstraction to draw polygons / meshs easier, so also people without OpenGL skills can use LWJGL?\n\nI think it should be as little as possible, but show what Kai mentioned.\nWhen you use JMonkeyEngine, you usually start looking at this.\nJust a blue cube. The starter kind could show how cube coordinates are put into a buffer, sent through a simple shader and maybe have a callback to move the screen around.\nI don't even know what structs are in LWJGL, but maybe that can be worked into that, too?\n. For the second or third time... I know how to create a triangle. I also know that LWJGL is not a game engine. I'm just saying it would make sense to have a clean example to show how the work-flow for rendering something would be and rendering a cube would be a good starting point for a lot of users. That assumption might be biased, but it's usually one of the examples all OpenGL tutorials go through, too.\nFrom my experience, OpenGL is intimidating, because you spend a lot of time going through boilerplate code before see any visible result and you cannot use System.out.println or anything inside of shaders to figure out why it does not work. Giving a good starting point would probably help a lot of users.\nAnd yes, I know there are also other backends like Vulkan, but is anyone actually using that to start with graphics programming? Honest question, I know I'm not the expert here.\n. Sorry, but I guess I fail to understand at what point your CLI would make things much easier. I can already just create a build.gradle, put those few lines of dependences in, run \"gradle eclipse\" and it works fine. I'll just go through the features in the readme:\n\n\nlist all available versions of LWJGL 3\n\n\nOkay, that's nice, but I do not really have a problem with checking the latest version manually every few weeks/months.\n\n\ncreate a Maven project from the latest or a given LWJGL 3 version with a working example file\n\n\nWould \"working example file\" be what I suggested in #199 ? If yes, great, but that would be a typical job for a build tool.\n\n\ncreate a Gradle project with proper build.gradle file\n\n\nThat would be cool, but why no just stay in Gradle for that?\n\n\ncreate an Eclipse project with proper .classpath and .project files\n\n\nDoesn't this already work?\nTo sum it up, I would not see the benefit of using an extra command line tool.\nYou already have this Download Page, put a proper, automatically updated, version history there. Then, a nice-to-have would be something that builds a build.gradle file from a set of checkboxes/dropdown lists, like \"Version\", \"IDE\", \"Natives\", \"Modules\", etc. Gradle's Maven Plugin  could take care of creating Maven poms and stuff for those who want to use Maven instead.\n. Okay, I see your point. I was one of those people who did not want to use a build tool for quite a long time and I haven't dug that deep into Gradle, yet. But even if the goal is to get those people running, wouldn't it be just as easy to pre-build a bunch of zip files until the real Initializr works?\n\nI could also think about the CLI tool being a simple HTTP client for the web application in the future, only requesting the web application to generate a distribution and downloading that. Thus making it a true command line \"interface\", in the truest sense of the word, by interfacing the backend services, and not providing any services itself.\n\nThat would have been my next suggestion. But would it be feasible to use Gradle for that job, since it's basically Groovy and can be run as a script, anyway? I actually have no idea, but maybe it would be possible to cut out the intermediate layer?\n. Not on the end user's machine, but behind your initializer. The end user would just get a zip or something.\n. ",
    "jmaasing": "I know this is closed but I want to say that I started my project in 3.1.7 and ran into the same questions as OP. The new 4xC classes really made it easier. \ud83d\udc4d . ",
    "germangb": "okay! Sorry for the duplicate\n. I've been using Newton lately and the C API is indeed very clean and nice to work with :100: . It would be a great addition to lwjgl. ",
    "rreleford": "@ppiastucki  @httpdigest  Thank you both for the quick replies and helpful links.\n. ",
    "xupwup": "GL Version: 3.3 (Core Profile) Mesa 11.1.2 (git-38e8691)\nGL Renderer: Gallium 0.4 on llvmpipe (LLVM 3.8, 128 bits)\n. I got my mesa dll from here: https://sourceforge.net/projects/msys2/files/REPOS/MINGW/x86_64/\nI'll look into building my own glfw, but that may take a while (I'm not very experienced with building c++ on windows).\n. Ok, this is with your GLFW build:\n```\nStack: [0x000000001a520000,0x000000001a620000],  sp=0x000000001a61e4e0,  free space=1017k\nNative frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\nC  [glfw.dll+0x1436f]\nC  [glfw.dll+0xa22c]\nC  0x0000000001575874\nJava frames: (J=compiled Java code, j=interpreted, Vv=VM code)\nj  org.lwjgl.system.JNI.invokeI(J)I+0\nj  org.lwjgl.glfw.GLFW.glfwInit()I+8\nj  com.vi.render.core.Main.initWindow()V+15\nj  com.vi.render.core.Main.run()V+18\nv  ~StubRoutines::call_stub\n```\nFor some reason it's still not showing me any symbols...\n. glfwRegisterWindowClassWin32 sounds like it may have something to do with our setup. We're running this from a windows service, so no window actually opens when we start our application. For some reason this worked in the current stable version, but maybe it broke?\n. We've \"fixed\" the issue on our end, by running the application differently. I don't know exactly what our configuration manager did, but now the program no longer runs from a service, so it can open windows. That makes it not crash.\nThat means the crash itself was probably caused by glfw not being happy in a windows service.\n. ",
    "pderoovere": "Hi guys,\nI have a similar problem. Switching from 3.0.0b to 3.0.0 results in a VM crash when running tests on our Jenkins server. The server has no OpenGL support, so previously we got the following error:\n[LWJGL] GLFW_API_UNAVAILABLE error\n  Description : WGL: The driver does not appear to support OpenGL\n  Stacktrace  :\n    org.lwjgl.glfw.GLFW.nglfwCreateWindow(GLFW.java:1168)\n    org.lwjgl.glfw.GLFW.glfwCreateWindow(GLFW.java:1251)\nWith v3.0.0 the VM crashes when calling glfwInit(), see hs_err_pid3356.txt\n```\nStack: [0x000000005d7a0000,0x000000005d8a0000],  sp=0x000000005d89e1f0,  free space=1016k\nNative frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\nC  [glfw.dll+0x71ae]\nC  [glfw.dll+0x2047]\nC  0x00000000014d7974\nJava frames: (J=compiled Java code, j=interpreted, Vv=VM code)\nj  org.lwjgl.system.JNI.invokeI(J)I+0\nj  org.lwjgl.glfw.GLFW.glfwInit()Z+5\n```\n. ",
    "0-00": "Spasi, is there currently an ETA on OpenVR bindings?\n. ",
    "Kingwad": "Where are the Travis build scripts located currently?\n. ",
    "darkyellow": "I think LWJGL should move with the times and push forward with a modern jvm, Java 8 has been out for 2 years so its not new and its not unreasonable to assume a large proportion of non corporate users will be on this version\n. ",
    "pakoito": "\nMany other libraries, frameworks and tools are moving to Java 8+ compatibility. Even Android supports Java 8 now.\n\nBeware. Android supports lambdas at compiler level, and some APIs if you target the latest version or above. It'll be at least 5 years until the transition is complete, as we're still in Android 4.1.1 cutoff, and Android 5.1 at ~6%\nIf you break Java 6 compatibility by using any of the Java 7/8 APIs, you're cutting any Android possibility out. Maybe that's what's intended.\n. If you open up lambdas you open up functional and reactive programming, including the Stream apis, CompletableFutures, and more QOL improvements Java users have to get used to. They're also available in Java 6/7 through frameworks too, but it gets very verbose.\n. ",
    "gustav3d": "its time to move forward to java 8, people who need older platforms can use older LWJGL.\nThere will always be arguments to stay at 10 year old technologies, but no one forces them to upgrade to latest LWJGL\n. ",
    "quazi-irfan": "Does the only benefit \"Lambdas and default methods in interfaces.\" justifies ignoring the widespread uses of Java 7?\n. In GLFW we do,\nif (!glfwInit())\nBut in LWJGL 3 we write the same things as,\nif ( glfwInit() != GLFW_TRUE )\n@Spasi Why GLFW_TRUE was chosen instead of native Java boolean?\n. Do you prefer Batik over NanoSVG because Batik is a entirely Java?\n. Out of curiosity, did you use regular expression to find all occurrences? and what tool did you use to replace the text?\n. @apostolos Thanks.\n. ",
    "nickclark2016": "Okay.  I isolated it down to this by seeing which file was causing it.  It may be something that is called inside the class itself.  Not 100% sure the issue.  How would I go about fixing it in the OpenGL driver?  I have both reverted to old drivers and updated to the newest and neither would fix my issue.\n. Would it be helpful if I linked a runnable jar? Also, I don't know why there is no stacktrace.\n. Here is the Jar Test.  After I stopped it, it started working, but there is a lot of lag that used not to be there.\n. @Spasi I am getting a wrong component type or count.  Is there any way to see which line is causing the error, or do I need to debug my entire program to determine this.  Either way, I have not found a way to reproduce the crash.  It sometimes crashes, other times it doesn't.. Working so far.  I will let you know how that does @httpdigest .  Thank you so much!  Do you mind if I adapt this for my own needs?  If so, shoot me a link to the license for the code.. Sorry for the reopen, but the issues have reappeared.  All I get now is the \"Notification\" messages when I load models and textures, but there is nothing that points me to a specific issue.. Yup.  I have ignored those, but they are very helpful. Those are the only notifications I get now, even when I am using the GLUtil implementation of it.  Not sure what else could be the issue.  I have found no way to reproduce the error consistently.. I am not using jemalloc.  Also, I am having an issue with Run/Debug on Eclipse, so I cannot add any VM arguments.. Update:  Went to 3.1.1 and it currently seems to work.  I will keep you all  posted.  Thanks to everyone for their help thus far!. Found the error.  Not all of the natives linked properly, but I have that issue fixed.  Thanks for the help all.. In my opinion, the bindings should be kept for several releases as deprecated, then eventually they should be removed from further releases.  Thanks @Spasi for your response!. No compilation issues, no OpenGL errors or notifications.  It runs, renders everything, but it doesn't update the screen after the first glfwSwapBuffers call by the looks of it.. They do as far as I can tell, but the change in DPI does not help my problem.. I will in a few.  I have found that there is an issue with OpenGL based applications on the device, as I experience similar issues with Blender.  This may be driver related.. ",
    "juliencl": "You're welcome!\n. ",
    "YohBen": "Hi and thanks. I just ran it from the command prompt too, but no window. What Java version are you using?\n$> javac HelloWorld.java  -cp .:lwjgl-3.0.0.jar:lwjgl-platform-3.0.0-natives-osx.jar\n$> java -cp .:lwjgl-3.0.0.jar:lwjgl-platform-3.0.0-natives-osx.jar -Djava.library.path=./natives/ -Dorg.lwjgl.util.Debug=true -XstartOnFirstThread HelloWorld\nHello LWJGL 3.0.0 SNAPSHOT!\n[LWJGL] Version: 3.0.0 SNAPSHOT\n[LWJGL]      OS: Mac OS X v10.11.5\n[LWJGL]     JRE: 1.8.0_92 x86_64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v25.92-b14 by Oracle Corporation\n[LWJGL] Loading library (system): lwjgl\n[LWJGL]     Loaded from java.library.path: ./natives/liblwjgl.dylib\n[LWJGL] ThreadLocalUtil state: UnsafeState\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n[LWJGL] Loading library: glfw\n[LWJGL]     Loaded from java.library.path: ./natives/libglfw.dylib\n[LWJGL] Loading library: objc\n[LWJGL]     libobjc.dylib not found in java.library.path=./natives/\n[LWJGL]     Loaded from system paths\n$> java -version\njava version \"1.8.0_92\"\nJava(TM) SE Runtime Environment (build 1.8.0_92-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)\nThank you for looking into this.\n. I'm going to double check that. Thanks\n. Ok, This time I downloaded the stable from LWJGL's main webpage. Still no window.\nThis is the call that is never returned:\nreturn invokePPPP(__functionAddress, width, height, title, monitor, share);\nit is called in:    \npublic class GLFW {...}\npublic static long nglfwCreateWindow(int width, int height, long title, long monitor, long share) {...}\nI.e.: \nGLFW.nglfwCreateWindow(...)\nI wonder if it could be something wrong in my libobjc.dylib?\n```\n$> ls -al /usr/lib/libobjc.dylib \nlrwxr-xr-x  1 root  wheel    15B 13 Jan  2015 /usr/lib/libobjc.dylib@ -> libobjc.A.dylib\n$> cat /usr/lib/libobjc.A.dylib | md5 \n20fa59e01787d76a8de77170e0eca416\n```\nHere is the output from running with the latest download:\n$ java -cp .:./jar/*:./native -Djava.library.path=./native/ -Dorg.lwjgl.util.Debug=true -XstartOnFirstThread HelloWorld\nHello LWJGL 3.0.0 build 90!\n[LWJGL] Version: 3.0.0 build 90\n[LWJGL]      OS: Mac OS X v10.11.5\n[LWJGL]     JRE: 1.8.0_92 x86_64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v25.92-b14 by Oracle Corporation\n[LWJGL] Loading library (system): lwjgl\n[LWJGL]     Loaded from java.library.path: ./native/liblwjgl.dylib\n[LWJGL] ThreadLocalUtil state: UnsafeState\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n[LWJGL] Loading library: glfw\n[LWJGL]     Loaded from java.library.path: ./native/libglfw.dylib\n[LWJGL] Loading library: objc\n[LWJGL]     libobjc.dylib not found in java.library.path=./native/\n[LWJGL]     Loaded from system paths\n. Solved, thank you so much for your time. \nI uninstalled CUDA drivers and the JDK. Rebooted and installed Java 8 build 91, instead of build 92. \nAnd it worked. However I still do not know if it was something wrong with my CUDA installation, or if it was the JDK.\nBig thanks,\njava -cp .:./jar/*:./native -Djava.library.path=./native/ -Dorg.lwjgl.util.Debug=true -XstartOnFirstThread HelloWorld\nHello LWJGL 3.0.0 build 90!\n[LWJGL] Version: 3.0.0 build 90\n[LWJGL]      OS: Mac OS X v10.11.5\n[LWJGL]     JRE: 1.8.0_91 x86_64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v25.91-b14 by Oracle Corporation\n[LWJGL] Loading library (system): lwjgl\n[LWJGL]     Loaded from java.library.path: ./native/liblwjgl.dylib\n[LWJGL] ThreadLocalUtil state: UnsafeState\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n[LWJGL] Loading library: glfw\n[LWJGL]     Loaded from java.library.path: ./native/libglfw.dylib\n[LWJGL] Loading library: objc\n[LWJGL]     Loaded from java.library.path: ./native/libobjc.dylib\n[LWJGL] Loading library: /System/Library/Frameworks/OpenGL.framework\n[LWJGL]     Success\n. ",
    "czyzby": "I went for simplicity when suggesting a possible solution - hence the listed Android libraries. I thought Batik relies on Swing/AWT, but it does seem highly modular.\n. ",
    "integeruser": "Same here, everything works fine with 3.0.0b build 35 but not with build 90 (checked on Windows and OS X). ~~Has this been reported to GLFW?~~\n. ",
    "dannycalleri": "Hi guys, any news?\n. ",
    "SuperWangCC": "Thanks,I think we can add a schedule on the website.\n. ",
    "datahaki": "i tried 3.1.3 on Nvidea Jetson TX2 which has aarch64 but there doesn't seem to be the right binary available\njava.lang.UnsatisfiedLinkError: /tmp/lwjglidsc/3.1.3-SNAPSHOT/liblwjgl.so: /tmp/lwjglidsc/3.1.3-SNAPSHOT/liblwjgl.so: cannot open shared object file: No such file or directory (Possible cause: architecture word width mismatch)\n    at java.lang.ClassLoader$NativeLibrary.load(Native Method)\n    at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1941)\nThe project is here\nhttps://github.com/idsc-frazzoli/owly3d\nPlease let me know, if I am making an obvious mistake. Is arm supported by lwjgl?. @Spasi thank you for the reply!\nfor now, I only would like to read out a joystick, so I probably will look for a simple, quick alternative.. ",
    "Sliveer": "Where can I check when lwjgl will be supported on arm?\nWhen you say \"(very slow) work-in-progress\", do you have any idea how slow it will be? (several months, several years, unlikely to ever exist?)\nIs there a version of lwjgl2 that works on arm?\nI'm not very good at all this, but from what I understood the code is currently compiled for different OS, but appart from compiling it for a device using arm are there other things to  do? (would it be possible to do this work myself? I read that several years ago some people did so, but they did not provide a download link for it). Thank you for the quick and detailed answer!\nI'm not working on android actually, I'm working on raspberry.\nSo when you say \"It won't work on a generic ARM device.\", I guess raspberries are included in \"generic ARM device\"?\nI don't know about android, but I think lwjgl is still very interesting for raspberries.. After spending some time trying to figure out what would be the best solution for me I found this tutorial : http://rogerallen.github.io/jetson/2014/07/31/minecraft-on-jetson-tk1/\nThe second point explains how to build lwjgl for arm (raspberry), but it is 3 years old. I'll try this as soon as I get my raspberry back, but until then could you tell me if it seems to be a proper way to do it? (I guess things have change in 3 years, maybe it's not a good idea to do it anymore, if it actually ever worked). Oh sorry, I forgot it was for LWJGL3.\nSo you're saying if I follow the steps described on this link: https://www.lwjgl.org/guide#build-instructions\nwith my raspberry it should actually compile the natives correctly and I'll have a working LWJGL on my raspberry? (I just want to make sure I'm following the right instructions, I'm really not familiar with all this yet). I finally found some time to try this!\nThe first build takes approximately 2 hours, but does not reach the end because of a java.lang.OutOfMemoryError: Java heap space.\nApparently in order to increase this space and avoid the issue I have to add -Xmx<space> to the java command lines. So I added <jvmarg value=\"-Xmx800m\"/> each time I could in the build.xml file (probably not the best way to solve the issue, but it could've work I think), but I ended up with the same issue.\nAs 800MB should be enough for the build to succeed, I guess I did not add the arguments at the necessary places, but I don't have any idea where to put it.\nAnd then I thought \"hey, this is not compiling the C code, this doesn't have to be done on the raspberry!\". Am I right? If I compile the Kotlin on my pc, then transfer the library to my raspberry to proceed to the next two commands is it going to be ok? (sadfully it's hard for me to test this, because the last steps will generate errors, and I need to be sure the error is not a consequences of the first step that I might've done the wrong way). Here I am again.\nI tried several thing, nothing worked... As I mentioned before I really don't have any skill in packaging and building projects so I kinda try things whithout actually knowing what I'm doing...\nI guess it's better for me to wait until an arm version is released, even if it takes a long time.\nBy the way if anyone has an arm compiled version of lwjgl3 that he can share (or even just the right config files to build it) don't hesitate to share it!. Did you make a program using lwjgl3 work on rasp using this configuration for the build?\nIs it just about commentating these 3 lines from build.xml and disable lines 41 (tootle) and 36 (rpmalloc) from build-binding.xml ?. ",
    "mikehooper": "I got this to complete the build on my Pi3 albeit with 1 error.\nIncrease the swapfile size:\nsudo nano /etc/dphys-swapfile\nChange CONF_SWAPSIZE=100 to CONF_SWAPSIZE=1024\nReboot\nSet an ant environment variable to allow java more memory:\nexport ANT_OPTS=\"-Xmx1g\"\nant\nUse \u2018free -h\u2019 in a separate terminal window to see how much swap space gets used.\n. The result of building on the Pi:\n\ncompile-native-platform:\n [Compiler] gcc: error: unrecognized command line option \u2018-m32\u2019\n [Compiler] gcc: error: unrecognized command line option \u2018-mfpmath=sse\u2019\n [Compiler] gcc: error: unrecognized command line option \u2018-msse\u2019; did you mean \u2018-fdse\u2019?\n [Compiler] gcc: error: unrecognized command line option \u2018-msse2\u2019\nBUILD FAILED\n/home/pi/lwjgl3/build.xml:388: The following error occurred while executing this line:\n/home/pi/lwjgl3/config/linux/build.xml:101: The following error occurred while executing this line:\n/home/pi/lwjgl3/config/linux/build.xml:30: apply returned: 1\nTotal time: 3 seconds. Although the Pi is 64bit, I'm using raspbian which is only 32bit. I've removed the unrecognised flags but still get errors reported though no detail. The -mfpmath flags didn't work. Any way to get more detail?\nBuildfile: /home/pi/lwjgl3/build.xml\ninit:\ncheck-dependencies:\nbindings:\ngenerate:\n-init-compile:\ncompile:\ncompile-native:\ncompile-native-platform:\nBUILD FAILED\n/home/pi/lwjgl3/build.xml:388: The following error occurred while executing this line:\n/home/pi/lwjgl3/config/linux/build.xml:178: The following error occurred while executing this line:\n/home/pi/lwjgl3/config/linux/build.xml:182: exec returned: 1\nTotal time: 3 seconds\n. Using Pi3 Raspbian Stretch (32bit)\n\nAfter commenting out the following in the build xml :\nline 36:\n<!-- <arg line=\"-m32 -mfpmath=sse -msse -msse2\" unless:true=\"${build.arch.x64}\"/> -->\nline 88:              \n<!-- <arg value=\"-m32\" unless:true=\"${build.arch.x64}\"/> -->\nline 266:\n<!--\n         <build name=\"lwjgl_sse\" dest=\"${bin.native}/sse\" if:true=\"${binding.sse}\">\n             <source>\n                 <arg value=\"-msse3\"/>\n                 <arg value=\"-I${src.native.rel}/util\"/>\n                 <fileset dir=\".\" includes=\"${src.generated.native}/util/simd/*.c\"/>\n             </source>\n         </build>\n         -->\nI get this far :\n```\nBuildfile: /home/pi/lwjgl3/build.xml\ninit:\ncheck-dependencies:\n-compile-generator:\nbindings:\ncompile-templates:\ngenerate:\n-init-compile:\ncompile:\ncompile-tests:\ncompile-native:\ncompile-native-platform:\n      [gcc] Linking lwjgl_rpmalloc\n   [Linker] /tmp/ccWmgx5U.s: Assembler messages:\n   [Linker] /tmp/ccWmgx5U.s:26: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:101: Error: selected processor does not supportdmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:642: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:755: Error: selected processor does not supportdmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:956: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:1017: Error: selected processor does not supportdmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:1146: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:1211: Error: selected processor does not supportdmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:1333: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:1394: Error: selected processor does not supportdmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:1525: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:1552: Error: selected processor does not supportdmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:1726: Error: selected processor does not support dmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:1945: Error: selected processor does not supportdmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2011: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2139: Error: selected processor does not supportdmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2160: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2193: Error: selected processor does not supportdmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2246: Error: selected processor does not support dmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2274: Error: selected processor does not supportdmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2320: Error: selected processor does not support dmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2385: Error: selected processor does not supportdmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2419: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2481: Error: selected processor does not supportdmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2495: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2521: Error: selected processor does not supportdmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2557: Error: selected processor does not support dmb ish' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2598: Error: selected processor does not supportdmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2627: Error: selected processor does not support dmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2646: Error: selected processor does not supportdmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2726: Error: selected processor does not support dmb ishst' in ARM mode\n   [Linker] /tmp/ccWmgx5U.s:2760: Error: selected processor does not supportdmb ishst' in ARM mode\n   [Linker] lto-wrapper: fatal error: gcc returned 1 exit status\n   [Linker] compilation terminated.\n   [Linker] /usr/bin/ld: error: lto-wrapper failed\n   [Linker] collect2: error: ld returned 1 exit status\nBUILD FAILED\n/home/pi/lwjgl3/build.xml:403: The following error occurred while executing this line:\n/home/pi/lwjgl3/config/linux/build.xml:258: The following error occurred while executing this line:\n/home/pi/lwjgl3/config/linux/build.xml:84: apply returned: 1\nTotal time: 25 seconds\n```. That seemed to work, had to disable 'tootle' as well.\nI was expecting libglfw32.so to also be created - is this not the case ?\n```\nBuildfile: /home/pi/lwjgl3/build.xml\ninit:\ncheck-dependencies:\n-compile-generator:\nbindings:\ncompile-templates:\ngenerate:\n-init-compile:\ncompile:\n[javac: Core] Compiling 1865 source files to /home/pi/lwjgl3/bin/Core\ncompile-tests:\ncompile-native:\ncompile-native-platform:\n-init-runtime:\ntests:\n    [Tests] [LWJGL] Version: 3.1.6 SNAPSHOT\n    [Tests] [LWJGL]      OS: Linux v4.9.59-v7+\n    [Tests] [LWJGL]     JRE: 1.8.0_65 arm\n    [Tests] [LWJGL]     JVM: Java HotSpot(TM) Client VM v25.65-b01 by Oracle Corporation\n    [Tests] [LWJGL] Loading library (system): lwjgl32\n    [Tests] [LWJGL]     Loaded from java.library.path: libs/liblwjgl32.so\n    [Tests] [LWJGL] Loading library: lwjgl32\n    [Tests] [LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n    [Tests] [LWJGL]     Loaded from java.library.path: libs/liblwjgl32.so\n    [Tests] /usr/lib/jvm/jdk-8-oracle-arm32-vfp-hflt/jre/bin/java: symbol lookup error: /home/pi/lwjgl3/libs/liblwjgl32.so: undefined symbol: dcNewCallVM\n    [Tests] The tests failed.\nall:\nBUILD SUCCESSFUL\nTotal time: 3 minutes 22 seconds\n```. I'm trying to get the latest experimental build of Minecraft working. Its now got past the liblwjgl32.so requirement, but now needs libglfw32.so The only other change was commenting out the threadsPerProcessor=\"4\". Trying to build this on the Pi again. (Pi3B+ Raspbian 32bit OS)\nWhy would I get missing header files when they do exist?\n```\npi@raspberrypi:~/lwjgl3 $ ant compile-native\nBuildfile: /home/pi/lwjgl3/build.xml\nbindings:\ninit:\n [override] Build offline: true\ncheck-dependencies:\ngenerate:\ncompile:\ncompile-native:\ncompile-native-platform:\n [Compiler] /home/pi/lwjgl3/modules/lwjgl/nanovg/src/generated/c/org_lwjgl_nanovg_NanoSVG.c:13:21: fatal error: nanosvg.h: No such file or directory\n [Compiler]  #include \"nanosvg.h\"\n```\nFile exists here:\n```\npi@raspberrypi:~/lwjgl3 $ find . -name nanosvg.h\n./modules/lwjgl/nanovg/src/main/c/nanosvg.h\npi@raspberrypi:~/lwjgl3 $ \n```. Is anyone able to explain this missing header files issue ? Are we missing a library path or some dependency?. Seem to have more success setting relative=\"false\" in every occurrence in config/linux/build.xml. These patches seem to solve the missing header files issue:\n```\n!/bin/bash\nfile=~/lwjgl3/config/linux/build.xml\nset relative to false\nsed -i -e 's+++g' $file\nsed -i -e 's+relative=\"true\"+relative=\"false\"+g' $file\nset threads to 1\nsed -i -e 's+threadsPerProcessor=\"2\"+threadsPerProcessor=\"1\"+g' $file\nsed -i -e 's+threadsPerProcessor=\"4\"+threadsPerProcessor=\"1\"+g' $file\nset path\nsed -i -e 's+++g' $file\ncomment out -m32\nsed -i -e 's++ <arg line=\"-m32 -mfpmath=sse -msse -msse2\" unless:true=\"${build.arch.x64}\"/> +g' $file\nsed -i -e 's++ <arg value=\"-m32\" unless:true=\"${build.arch.x64}\"/> +g' $file\n```\n. > http://fxzjshm.github.io/blog/Build-LWJGL-On-Raspberry-Pi/ these instructions are good enought to build them for rpi3\nThats for lwjgl2 not lwjgl3. If you building on a Pi you can increase the swap file size https://github.com/LWJGL/lwjgl3/issues/206#issuecomment-345512525. ",
    "zhiyb": "build.xml:182, it is checking for gtk-3.0.\nYou can try install the libgtk-3-dev package.. I got the master branch to compile on aarch64.\nI have commented out some flags in build script, replaced dyncall libraries using offline build mode LWJGL_BUILD_OFFLINE=true.\n```diff\ndiff --git a/config/linux/build.xml b/config/linux/build.xml\nindex 41f340d..8d8e6ce 100644\n--- a/config/linux/build.xml\n+++ b/config/linux/build.xml\n@@ -30,7 +30,7 @@\n             \n\n\n-                \n+        <arg line=\"-m64\" if:true=\"${build.arch.x64}\"/> \n\n\n@@ -51,7 +51,7 @@\n         \n\n\n-        \n+        \n\n\n\n@@ -77,7 +77,7 @@\n             \n\n\n-                \n+        <arg value=\"-m64\" if:true=\"${build.arch.x64}\"/> \n\n             <arg line=\"-z noexecstack\"/>\n\n@@ -256,13 +256,13 @@\n         \n     <!-- SSE -->\n\n\n\n<!-- \n\n\n\n\n\n\n --> <!-- stb -->\n <build name=\"lwjgl_stb\" dest=\"${bin.native}/stb\" if:true=\"${binding.stb}\">\n\ndiff --git a/modules/core/src/main/c/system/linux/wrap_memcpy.c b/modules/core/src/main/c/system/linux/wrap_memcpy.c\nindex 239c958..a71effb 100644\n--- a/modules/core/src/main/c/system/linux/wrap_memcpy.c\n+++ b/modules/core/src/main/c/system/linux/wrap_memcpy.c\n@@ -2,7 +2,7 @@\n\n\nvoid old_memcpy(void , const void *, size_t);\n-asm(\".symver old_memcpy,memcpy@GLIBC_2.2.5\");\n+//asm(\".symver old_memcpy,memcpy@GLIBC_2.2.5\");\nvoid __wrap_memcpy(void dest, const void *src, size_t n) {\n     return old_memcpy(dest, src, n);. Download and build dyncall library, replace the pre-built binaries in LWJGL, then build LWJGL use offline mode:\nLWJGL_BUILD_OFFLINE=true\n. Can't remember, but you can try build in online mode once, then search for libdyncall.a (should be downloaded automatically, but for i386/amd64). I was building lwjgl3 natively (on `aarch64`). In my build, I can find `libdyncallback_s.a libdyncall_s.a libdynload_s.a` in `libs/linux/x64`. However, if I use online mode, it seems to overwrite those binaries every time, so I need to use offline mode.. It's not in the `bin` folder. I could be using an outdated version, but for my build, they are directly in `repo/libs/linux/x64`:\n$ ls\nbin                gradlew.bat\nbuild.gradle       libs\nbuild.xml          LICENSE.md\nconfig             modules\ndoc                README.md\ngradle             settings.gradle\ngradle.properties  update-dependencies.xml\ngradlew\n$ ls libs/linux/x64/\nlibdyncallback_s.a  libdyncall_s.a  libdynload_s.a\n```. They are not generated, the binaries are downloaded directly from a server somewhere.. ",
    "Zamundaaa": "Has there been any progress on running lwjgl 3 on a raspberry pi 3 without putting too much effort into configuring etc (although I would do it anyway with effort)? If so, can someone give me a tutorial on how to make it work? If not, could someone point me to an alternative I can use as a openGL wrapper until lwjgl supports arm?. Did you manage to get it to work?. How far is the progress with ARM support? Because I'd very much like to use LWJGL in a project with a Raspberry PI 3B. I'm just using very few of the modules, Assimp, OpenGL & OpenGL ES is what is necessary for me.\nAnd I would like to offer my help. If I can. (pretty much no experience with this at all). Yes I am. But github apparently doesn't like json files, so you'll have to rename it back for use... I've tried multiple different selections, too, so that's probably not the issue. Tried Chrome on Windows now, no download either. Also tried on Android now, Firefox and Chromium. Nothing works\nlwjgl-release-custom-zip.txt\n. I need to clarify this: it's not VRSystem_getControllerStateWithPose that crashes but VRSystem_GetDeviceToAbsoluteTrackingPose.\nI was a bit confused about the input focus thing as it's still there in OpenVRs wiki. Thanks for clarifying that.\nPorting an existent demo to Java will take probably more than an hour... But as I want to use this, I'll consider doing it\nAlso I'm working on my own little engine that wraps the OpenVR stuff into neat objects (like \"Controller\" and \"HMD\"). Maybe I'll just do a quick minimal demo with that, it's very easy to follow\nI also saw that the crash logs had little information in it. The one even said that it couldn't properly report the error itself.... I think I may have found out why the Controller State was always 0... https://github.com/ValveSoftware/SteamVR-for-Linux/issues/35#issuecomment-411257729.\nYet I've still not succeeded using the IVRInput system as SteamVR just shows a dark blue background at some point when trying to create bindings. I guess that's an error on their side but didn't get a response yet on it. So all problems I had with OpenVR that may be related to LWJGL are gone or just resolved to be Valve's fault and have been fixed, so I'll close this now. ",
    "l3eta": "So I've gotten everything to build except for a few modules (Mainly Tootle, which I don't use so that's fine) However after going through and removing some methods from GLFW which are no longer used in the repo I've ran into this error which I have yet to figure out since it's so general.\n/usr/local/jdk1.8.0_161/bin/java: symbol lookup error: /home/alarm/NetBeansProjects/OpenGL/libs/natives/liblwjgl32.so: undefined symbol: dcbNewCallback\nI have yet to edit any of the natives except my own drop in glfw.so. That would make sense, so how would I go about doing that?. So I've build dyncall, where are the pre-built's to replace?\nNevermind, simple find | grep dyn helped.. I've been running online mode this whole time, I had to build kotlin on my windows computer as don't have enough ram on my laptop. Not even sure how to turn online mode off, I don't really use ant very often\nI have yet to find a libdyncall.a \nI actually deleted the c code from the lwjgl3/modules/core/ and it still compiles which makes me kinda wonder however it could be picking up the headers from /usr/include/\nFound something useful to me:\n<link>\n<fileset dir=\"${lib}/${platform}/${build.arch}/\">\n<include name=\"libdyn*.a\"/>\n</fileset>\n</link>\n. the bin/libs/linux/x86 folder doesn't even get used for me, it uses bin/linux/x86/\n. What folder is it in? I'm not seeing any .a's being generated. I've got a bunch of .o's\nI just checked my echo command from the build and my stuff is getting placed in bin \nEdit 2: I think I fixed it, I had to place the built .a's into bin/libs/linux/x86 for it to link them, about to replace my .so and see if it works now.\nEdit 3: Got it to work and make a window just gotta fix something that seems to return null now.. Yeah mine never seemed to download hence why it wasn't loading. I got it to work now, however I had to inject myself into library class, so at the moment I'm fixing libGL.so.1 path resolve and then I'll know if it works to render my 3d playground. Thanks for the detailed steps and what not, currently I'm trying to get accelerated graphics going that way I'm not stuck at 5fps. LWJGL3 built and runs great. \nWhat all do you guys have left to push ARM support 100% out?\n. ",
    "MJansson": "@mikehooper @Spasi Regarding rpmalloc on ARM, should work fine but if the target processor doesn't have the instructions I used for atomic fences you could try using c11 atomics instead.\n\n\nWhich processor are you targeting? Could you post the compiler flags so I could incorporate this into the rpmalloc build tests?\n\n\nTry replacing line 106 & 107 in rpmalloc\n```\n\n\ndefine atomic_thread_fence_acquire() __asm volatile(\"dmb ish\" ::: \"memory\")\ndefine atomic_thread_fence_release() __asm volatile(\"dmb ishst\" ::: \"memory\")\nwith the following C11 atomics instead\ninclude \ndefine atomic_thread_fence_acquire() __atomic_thread_fence(memory_order_acquire)\ndefine atomic_thread_fence_release() __atomic_thread_fence(memory_order_release)\n```. ",
    "tristeng": "@Spasi I have followed your directions and am attempting to get this project and its dependencies building on ARM through Travis CI, so looking for your guidance on a few things.\nHere is where I am at - I have successfully used an ARM cross compiler (provided by Raspberry Pi) to get this project building - I had to also get Dyncall (CI repo) built with the cross compiler and have it building -  code here and its also building on Travis CI. \nI didn't have to build any of the other 3rd party projects you mentioned for an LWJGL build to succeed, but shouldn't be too difficult to get them building in a similar fashion (I'm happy to take that on).\nIn the LWJGL project, I've created a new platform (arm) and created various sub-directories based on the linux platform to get it working - changes here. I haven't tested the built native libraries on a Pi yet, but that is my next step - I'm guessing I might have to tweak some compiler options etc but at least the build succeeds.\nLooks like the various branches in the CI projects are named in a specific fashion - I just went with \"arm\" and \"arm64\" to start but if you have suggestions on naming etc. let me know and I can clean it all up and make pull requests on the dependent projects first.\nAny other guidance or tips are appreciated.. Thanks for the quick reply and that all makes sense. I'll start with the Dyncall CI project first to make sure I'm on the right track.. I updated a few of the dependent libraries to use a x-compiler within Travis CI but ran into an issue where the x-compiler doesn't recognize an assembler command (memcpy is wrapped and points to a specific version of glibc). I tried a simple file on the Pi itself and it also doesn't recognize this compiler command. For 32 bit build, this might not be necessary, but that is where I left it. You can look at the forks in my repo (look for the repos forked from LWJGL-CI and then look at the arm branches).. ",
    "gounthar": "I'm having some troubles compiling because of header files not found. Are there some dependencies to install beforehands?\nbash\n [Compiler] lwjgl3/modules/lwjgl/tootle/src/main/c/RayTracer/JRT/JRTH2KDTreeBuilder.cpp:6:23: fatal error: TootlePCH.h: No such file or directory\nBut...\nbash\n find . -name TootlePCH.h\n./modules/lwjgl/tootle/src/main/c/TootlePCH.h\nAny idea?\nThanks.\n. I went further, but will have to try it on another machine:\n[kotlinc] info: kotlinc-jvm 1.3.21 (JRE 1.8.0_181-8u181-b13-2~deb9u1-b13)\n  [kotlinc] exception: java.lang.OutOfMemoryError: Java heap space. Thanks. I tried on another machine and got:\n```\ncompile-native:\n    [mkdir] Created dir: /root/lwjgl3/bin/linux/x64\ncompile-native-platform:\n [Compiler] gcc: error: unrecognized command line option \u2018-m64\u2019\nBUILD FAILED\n/root/lwjgl3/build.xml:406: The following error occurred while executing this line:\n/root/lwjgl3/config/linux/build.xml:149: The following error occurred while executing this line:\n/root/lwjgl3/config/linux/build.xml:39: apply returned: 1\nTotal time: 8 minutes 10 seconds\n```\ngcc --version\ngcc (Ubuntu/Linaro 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609\nCopyright (C) 2015 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nuname -a\nLinux machine 4.15.0-34-generic #37~16.04.1-Ubuntu SMP Tue Aug 28 10:44:16 UTC 2018 aarch64 aarch64 aarch64 GNU/Linux. ",
    "Askmewho": "http://fxzjshm.github.io/blog/Build-LWJGL-On-Raspberry-Pi/ these instructions are good enought to build them for rpi3. yeah... I need to build the lwjgl-3.1.6.jar armhf one for rpi3. how I get that one? I download the source of the 3.1.6 than I need and I am failing on building it. please, help me with this nightmare. . Zram? . Delete that option? 32 bit arm libs should work anyway on 64 bits arm os. Just for testing porpoise delete it. The -m64 its an x86_64 flag. Dont know the equal to arm64 but anyway, if you delete that one it should pass.. So, has anyone build successfully lwjgl3 for the pi3 and other armhf and arm64 devices? If any. Please give us a precompiled lib sources. Sorry if I am repetitive. . ",
    "gijswl": "I thought .capacity() would be used because the C++ tutorial (https://vulkan-tutorial.com) i was following did that.\nIt does:\nqueueCreateInfo.queueCount = 1; and the LWJGL version would do queueCreateInfo.queueCount = 0; since .remaining(); returns 0 for a buffer of capacity 1\n```\n            int queueFamily = getQueueFamily(physicalDevice);\n    VkDeviceQueueCreateInfo.Buffer queueCreateInfos = VkDeviceQueueCreateInfo.create(1);\nFloatBuffer priorities = BufferUtils.createFloatBuffer(1);\npriorities.put(1.0f);\n\nVkDeviceQueueCreateInfo queueCreateInfo = new VkDeviceQueueCreateInfo(BufferUtils.createByteBuffer(VkDeviceQueueCreateInfo.SIZEOF));\nqueueCreateInfo.sType(VK10.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO);\nqueueCreateInfo.queueFamilyIndex(queueFamily);\nqueueCreateInfo.pQueuePriorities(priorities);\nqueueCreateInfos.put(queueCreateInfo);\n\nVkDeviceCreateInfo createInfo = new VkDeviceCreateInfo(BufferUtils.createByteBuffer(VkDeviceCreateInfo.SIZEOF));\ncreateInfo.sType(VK10.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO);\ncreateInfo.pQueueCreateInfos(queueCreateInfos);\n\nPointerBuffer pDevice = BufferUtils.createPointerBuffer(1);\nif (VK10.vkCreateDevice(physicalDevice, createInfo, null, pDevice) != VK10.VK_SUCCESS) {\n    throw new RuntimeException(\"Failed to create logical device\");\n} else {\n    logicalDevice = new VkDevice(pDevice.get(), physicalDevice, createInfo);\n}\n\n```\n. Ah I see, it works now. Thanks for the help\n. ",
    "samestep": "I am also interested in the release of 3.0.1. The modular artifacts will make it possible to write wrappers of specific LWJGL bindings that work together in a way that makes sense, rather than wrapping all LWJGL bindings together (waste of time) or forcing users of wrapper libraries to pull in parts of LWJGL that they don't need.\n. ",
    "benalexau": "@Spasi thanks for making the release. I reverted the removal in the LmdbJava benchmarks, and also updated to LWJGL 3.1.0 in commit https://github.com/lmdbjava/benchmarks/commit/e5209d65604619e57f2b4bdfb257c31a79da0bd9.. ",
    "CreamyCookie": "@kappaOne Oops, sorry! I'll report it there. \nThanks for the quickfix suggestion!\n. ",
    "DeepSnowNeeL": "Allright my bad then, couldn't find the information about alGetError only working with an active context !\nThanks for the help ! And thanks for the lib :)\n. ",
    "JulianKunze": "I see, sorry for the false assumption and thanks for the explanation.\n. ",
    "Moocow9m": "nvm dumb error with maven (witch i don't remember adding)\n. ",
    "Firenox89": "So I had a quick look at gitter and slack, my impression was that slack is a bit richer feature-wise. Like share files or select a language for highlighting code snippets. On slack it seems that you need to give permission for joining, while on gitter you don't need to do this, don't know if that is a up or downside for you.\nWhen googling for it, this story pops up about the guys who regret using slack, but they seem to have +8000 users and then reached the limits for free usage. Also as you already pointed out, there are solutions for the message limit, so I would suggest to go with slack. \n. ",
    "code-disaster": "Yes, can confirm it's working now. Thanks!\n. Ah thanks, I didn't think of switching vcvars. It's compiling now.\n. Updated & squashed the commits.\n\n... if we could maybe also support functions like bgfx_dbg_text_vprintf.\n\nYes, I thought about that for a while, but decided to let it go and just use bgfx_dbg_text_printf and String.format() for now. So far I can't think of a use case for such a binding.\n. Nice! This is both ingenious and a little scary at the same time! ;)\n. @BenMcLean how does it behave if you run your game with \"java -jar game.jar\" directly? A packr issue and a customer bug report for our game on Steam made me look into this topic recently. The former states that the scaling problem doesn't appear when running the JAR manually.\nMy first attempt to call SetProcessDpiAwareness() didn't seem to work at all. It's possible that I screwed up though. What did resolve it was to embed a manifest in the packr executable.\nAccording to our tests, this fix resolved the scaling issues with our game which is running on LWJGL 2. Sadly, I'm still waiting on user feedback to confirm.. Note that though there is a \"flat C API\" for Steamworks, with header files which look like they are auto-generated, all Valve documentation and code samples target the C++ API. I didn't work with the C API myself, but from what I gathered from the developer forums, it doesn't seem to be easy to handle.\nNow the C++ API itself is heavy on asynchronous callbacks, which doesn't fit very well with the LWJGL model. I could see some benefits of utilising LWJGL library functions though, like MemoryStack and SharedLibraryLoader. That's something I want to look into soon'ish.. My JNI wrapper does some book-keeping which may not be required when used properly with LWJGL 3 (MemoryStack et al). One more item on my \"would be nice to look into\" backlog.\nAlso note that Remotery's GL profiling doesn't work on MacOS, because Apple does not support GL_TIMESTAMP.. Oh, that's been a bad idea then. The problem is that this warning is reported by the linker(!), because of link time code generation I suppose, and so far I didn't find a nice solution which works and is limited to this one function or compilation unit.\n. ",
    "surGeonGG": "I'm helping\n. ",
    "andmoos": "@Spasi: Ok, i'll do that. Thanks so far.\n. ",
    "Lein4d": "I added them to the build path and it didn't work. I've also tried extracting the natives from the jars and adding them by setting the native library location, without success.\nSo for the moment I'll stick to the 3.0.0 version and switch to your suggested solution when I actually need the 3.1.0 version. Maybe someone else encounters the same problem and comes up with a solution.\n. Or do you think, it would be helpful to post a minimal Eclipse project, where the error occurs?\n. I created the demo project and - I don't know why - it worked with just adding the jars to the build path. Afterwards I've cleared and set the build path of the original project again and suddenly it also worked fine. So I guess it was a spurious Eclipse problem.\nAnyway, thanks for your help.\n. ",
    "flortsch": "Nice, thank you for the reply @Spasi.. ",
    "BenMcLean": "@Spasi I suspect those \"pending GLFW issues related to HiDPI support on Windows\" are probably all this same issue, but I'm not sure why they weren't coming up in my searches last night. Maybe I misspelled something. Oh well.\n@code-disaster I'll see if I can test that when I get a chance.. ",
    "voidburn": "Here's some more data:\nCrash in my own application (I still cannot get a dump reliably) that I got yesterday. For all intents and purposes all calls in UnobtaniumGL* classes can be considere the equivalent of libgdx's Lwjgl3 backend in their current snapshot, while working on some backend fixes I simply duplicated the code so I had the reference base always at hand while making changes: http://pastebin.com/3AMArDQ2\nRelated libgdx issue, describing how I avoid the crash by commenting the buffer swap: https://github.com/libgdx/libgdx/issues/4434\nOther notes: the resize triggers almost exclusively when the resize motion is circular, resizing from the corner in or out in a straight line does not trigger the issue.. Tested out with the 375.95 drivers, still get it, also lucked out and got a crash dump with the multithreaded demo! See attachment.\nhs_err_pid1372.zip\n. Probably unhelpful, but I also captured the screen while generating the dump above\n2016-11-23 12-47-48.zip\n. I swear, I don't enjoy crashing it (I secretly might..) but while I was bashing it hard I randomly got this console message during a crash, maybe unrelated, but I thought it could provide some additional clues maybe..\nIf needed, I have a minidump as well, but it's 55MB compressed, I can provide on request.\n\n[LWJGL] OpenGL debug message\n  ID: 0x501\n  Source: API\n  Type: ERROR\n  Severity: HIGH\n  Message: GL_INVALID_VALUE error generated. Invalid texture format.. @httpdigest Yes! Crashed exactly like the lwjgl3 demo.\n\nTrying building and running from command line and then disabling the threaded optimization.\n. @Spasi Regarding the implementations: I'm rewriting the backend on my own because I'm not sure if I can keep the multi-window feature AND multithread the render loop, but the latter is more important to me, thanks for the heads-up, I'll definitely make sure to get rid of those.. @Spasi Built an artifact and ran via command line: crashed as usual. Also crashed when the global Threaded optimization in the drivers was set to Off (It was defaulting to Auto).\nAttaching the built executable jar (entry point is the multithreaded demo) and the crash dump.\nlwjgl3_demos_jar.zip\n. I can reproduce it with the integrated GPU as well, I guess it's not an Nvidia driver issue. Updated hardware info including the cpu I'm using and tested with.. It's proving extremely hard to reproduce outside this machine, I've tested 5 different PCs and 3 different OSs so far, it only affects this one. If someone by any chance happens to have the same issue I'd love to take note of the hardware and os involved.. Well well, inspired by the uniqueness of this I started looking into other running processes in my system and excluding them one by one. \nTurns out that what was interfering with GLFW was Asus's Sonic Suite, which was reinstalled automatically with the latest driver updates. Somehow that thing hooks itself into everything (Autoruns.exe and Procmon.exe would crash immediately).\nSo sad that the first thing I noticed this problem with was my own project.\nGlad I can close this and leave it up for future reference, in case someone ends up into the same goose chase as I did.. It sure does, this should start by inquiring about the intent to provide\nthe bindings and seeing how the respond to it.\nI'd be willing to contact them and push it forward if there's interest for\nthese bindings.\nOn Mar 19, 2017 11:18 AM, \"Ranie Jade Ramiso\" notifications@github.com\nwrote:\n\nDoes this matter?\nhttp://www.fmod.com/licensing#faq\nQ. Can I distribute FMOD as a standalone library or as part of a game engine or toolset.\nA. No, you are not permitted to distribute FMOD in that way. Contact us if you would like to discuss a special arrangement.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/295#issuecomment-287606633, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABXycez56WRBZyCShGSB-To2-GHJ_Jf-ks5rnQDegaJpZM4MhkNF\n.\n. \n",
    "sormuras": "Can not reproduce with the executable jar linked in https://github.com/LWJGL/lwjgl3/issues/254#issuecomment-262536401 -- all resizing works.. I wonder, if someday, the linker will support native libraries.. ",
    "hyfloac": "Alright I found where I screwed up, I was calling a runtime dependency for lwjgl-platform and not lwjgl.\nMinor problem with the build script generator I thought I should mention: when you have the Everything radio box selected it generates dependency downloads for Everything, the problem with this is that some things like Assimp bindings aren't enabled and can't be enabled but are still generated, which is a bit of a problem because the reason you can't enable them is they have been removed/don't exist on Maven.. @apostolos My point was the generated build script has errors in them which should be fixed.. ",
    "irufus": "What does your pom file look like?. ",
    "rj93": "Literally just set up a test project, and copied the generated code into it:\n```\n\n4.0.0\nTestProject\nTestProject\n0.0.1-SNAPSHOT\n\n1.8\n1.8\n3.1.0-SNAPSHOT\n\n\n\nlwjgl-natives-linux>\n\nunix\n\n\nnatives-linux\n\n\n\nlwjgl-natives-macos>\n\nmac\n\n\nnatives-macos\n\n\n\nlwjgl-natives-windows>\n\nwindows\n\n\nnatives-windows\n\n\n\n\n\norg.lwjgl\nlwjgl\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-bgfx\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-egl\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-glfw\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-jawt\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-jemalloc\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-lmdb\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-nanovg\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-nfd\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-nuklear\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-openal\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-opencl\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-opengl\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-opengles\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-ovr\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-par\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-sse\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-stb\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-tinyfd\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-vulkan\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl-xxhash\n${lwjgl.version}\n\n\norg.lwjgl\nlwjgl\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-bgfx\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-glfw\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-jemalloc\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-lmdb\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-nanovg\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-nfd\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-nuklear\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-openal\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-ovr\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-par\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-sse\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-stb\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-tinyfd\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\norg.lwjgl\nlwjgl-xxhash\n${lwjgl.version}\n${lwjgl.natives}\nruntime\n\n\n\n\n\nmaven-compiler-plugin\n3.5.1\n\n1.8\n          1.8\n\n\n\n\n\n```. ",
    "brainscript": "@httpdigest Many developers use LWJGL, because they prefer Java over C (or C++). One (probably trivial sounding) good thing about Java is, that - unlike with other programming languages - developers actually care about coding style and conventions - including casing of variableNames, methodNames and CONSTANT_NAMES (static finals).\nJust because the methods I'm talking of are \"just\" bindings they are still being used inside actual Java code and it just makes the code look a lot less clean.\n\n@Spasi Mhh, what about allowing both? :confused:\nDue to the fact that many developers use static imports to use the methods we could have two classes:\n- A \"normal\" one with no changes to the method names\n- A class with a special suffix (like \"J\" for \"Java\" or \"CC\" for \"CamelCase\") and renamed methods\nDevelopers would be able to decide what they want then:\n- Be able to copy-paste C code without renaming the methods\n- OR: Have a clean code by renaming the methods. @Spasi Fine, I give up.. ",
    "kellerkindt": "Forced maven to redownload lwjgl dependencies (deleted in ~/m2/), but still having the same issue:\njava\n    private static final ByteBuffer ENGINE_NAME     = MemoryUtil.memASCII(\"kellerVulkan\");\n[LWJGL] Version: 3.0.1 build 35\n[LWJGL]      OS: Linux v4.8.0-32-generic\n[LWJGL]     JRE: 1.8.0_111 amd64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v25.111-b14 by Oracle Corporation\n[LWJGL] Loading library (system): lwjgl\n[LWJGL]     Found at: /tmp/lwjglmichael/3.0.1-build-35/liblwjgl.so\n[LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglmichael/3.0.1-build-35/liblwjgl.so\n[LWJGL] [WARNING] Mismatch detected between the Java and native libraries.\n[LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\njava.lang.ClassNotFoundException: org.lwjgl.system.jemalloc.JEmallocAllocator\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n    at java.lang.Class.forName0(Native Method)\n    at java.lang.Class.forName(Class.java:264)\n    at org.lwjgl.system.MemoryManage.getInstance(MemoryManage.java:36)\n    at org.lwjgl.system.MemoryUtil$LazyInit.<clinit>(MemoryUtil.java:76)\n    at org.lwjgl.system.MemoryUtil.nmemAlloc(MemoryUtil.java:145)\n    at org.lwjgl.system.MemoryUtil.memAlloc(MemoryUtil.java:163)\n    at org.lwjgl.system.MemoryUtil.memASCII(MemoryUtil.java:1321)\n    at org.lwjgl.system.MemoryUtil.memASCII(MemoryUtil.java:1306)\n    at com.kellerkindt.vulkan.VulkanApplication.<clinit>(VulkanApplication.java:26)\n    at com.kellerkindt.vulkan2d.Main.main(Main.java:12)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\n[LWJGL] Failed to instantiate memory allocator: org.lwjgl.system.jemalloc.JEmallocAllocator\n[LWJGL] MemoryUtil allocator: StdlibAllocator\n[LWJGL] ThreadLocalUtil state: UnsafeState\n[LWJGL] Loading library: glfw\n[LWJGL]     Found at: /tmp/lwjglmichael/3.0.1-build-35/libglfw.so\n[LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglmichael/3.0.1-build-35/libglfw.so\n[LWJGL] [WARNING] Mismatch detected between the Java and native libraries.\nException in thread \"main\" java.lang.ExceptionInInitializerError\n    at org.lwjgl.glfw.GLFW.nglfwSetErrorCallback(GLFW.java:853)\n    at org.lwjgl.glfw.GLFW.glfwSetErrorCallback(GLFW.java:882)\n    at org.lwjgl.glfw.GLFWErrorCallback.set(GLFWErrorCallback.java:111)\n    at com.kellerkindt.vulkan.VulkanApplication.<init>(VulkanApplication.java:69)\n    at com.kellerkindt.vulkan2d.Main.main(Main.java:12)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\nCaused by: java.lang.IllegalStateException: This function is not available.\n    at org.lwjgl.system.Checks.checkFunctionAddress(Checks.java:94)\n    at org.lwjgl.system.APIUtil.apiGetFunctionAddress(APIUtil.java:120)\n    at org.lwjgl.glfw.GLFW$Functions.<clinit>(GLFW.java:620)\n    ... 10 more\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n4.0.0\n<groupId>com.kellerkindt</groupId>\n<artifactId>vulkan2d</artifactId>\n<version>1.0-SNAPSHOT</version>\n\n<properties>\n    <lwjgl.version>3.0.1-SNAPSHOT</lwjgl.version>\n</properties>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.5.1</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n\n    </plugins>\n</build>\n\n<dependencies>\n    <dependency>\n        <groupId>org.lwjgl</groupId>\n        <artifactId>lwjgl</artifactId>\n        <version>${lwjgl.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.lwjgl</groupId>\n        <artifactId>lwjgl-glfw</artifactId>\n        <version>${lwjgl.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.lwjgl</groupId>\n        <artifactId>lwjgl-vulkan</artifactId>\n        <version>${lwjgl.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.lwjgl</groupId>\n        <artifactId>lwjgl-platform</artifactId>\n        <version>${lwjgl.version}</version>\n        <classifier>natives-linux</classifier>\n    </dependency>\n    <dependency>\n        <groupId>org.lwjgl</groupId>\n        <artifactId>lwjgl-platform</artifactId>\n        <version>${lwjgl.version}</version>\n        <classifier>natives-windows</classifier>\n    </dependency>\n    <dependency>\n        <groupId>org.lwjgl</groupId>\n        <artifactId>lwjgl-platform</artifactId>\n        <version>${lwjgl.version}</version>\n        <classifier>natives-osx</classifier>\n    </dependency>\n</dependencies>\n\n\n\n<repositories>\n    <repository>\n        <id>lwjgl-nightly</id>\n        <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n    </repository>\n</repositories>\n\n\n```. Woah. Thanks, thanks a lot :). ",
    "javagl": "I think that appending a version number to the library name would make sense, and this is a maven convention. For the JARs, it is done automatically in Maven Central. For the download package, it may not be so important. But the fact that the natives cannot be distinguished via their name is a bit irritating.\n\nSome context, or the things that I'm currently struggling with:\nAs far as I see, a one-click-runnable JAR involving LWJGL cannot be created with Maven. There are some Wiki pages mentioning plugins that can unpack natives to a target/natives folder or so. But creating a single, runnable JAR that can directly be deployed to the \"end user\" is not possible. One always has to juggle with the native libraries and the java.library.path. Is this right? The workarounds for this are either \"manual\" ones, like http://stackoverflow.com/q/12036607 , or the \"JarSplicer\" that was mentioned on some LWJGL Wiki site. The JarSplicer works fine for me, but will only allow one file with a certain name. Name collisions and version conflicts are becoming more likely when the number of native libraries increases...\n\n(Admittedly, my actual use-case is not a realistic one: I wanted to offer an application (as a one-click-runnable JAR) with LWJGL2 and LWJGL3 as a backends. When the DLL in both cases is named lwjgl.dll, this turns out to be difficult. But the fact that the package names are the same in both versions makes it impossible right from the beginning...)\n. Although this may now turn out to be off-topic regarding the original issue:\n- At which point (in time, and in the code) are the natives unpacked from the JAR?\n- Did this also work with LWJGL2? (I think LWJGL2 did not yet have the option to place the natives into the JAR, right?)\n. >  LWJGL 3 automatically discovers natives in the classpath, extracts and loads them.\nUntil now, I had only used LWJGL2, where this was not possible AFAIK. I wasn't aware of the fact that LWJGL3 finally supported this. \n(I went through the same issues, and will probably have a look at the current solution in LWJGL. My https://github.com/jcuda/jcuda/blob/master/JCudaJava/src/main/java/jcuda/LibUtils.java may need a cleanup+refactoring, and I considered using https://github.com/scijava/native-lib-loader instead, but maybe the LWJGL approach is superior to both. I wonder how you handle the temp files: There's always this issue that DLLs on windows cannot be deleted as long as they are loaded in the JVM, and they can only be \"unloaded\" with ugly reflection hacks. I'm curious how you solved this). \n\nI can feel your pain, but LWJGL 2 interop was never a goal for LWJGL 3.\n\nSure, that this is a very unusual intention. Do not take this too serious - it was rather an experiment. As I said, the fact that the package names are the same makes it nearly impossible to combine both versions in one application anyhow. (One could have called the package org.lwjgl3 just for the \"semantic versioning\" sake, but considering that there usually will be no reason to combine the versions, this may not be so important).\nIn general, I still think that version numbers in the native library names could add some clarity and help to disambiguate, but of course: When the fiddling of unpacking natives and messing with the java.library.path is no longer necessary in LWJGL3, then the natives will usually never be visible to the user, so this is far less critical. \nEDIT: \nBTW, the main reason of why I did not switch to LWJGL3 earlier was the lack of the AWTGLCanvas, but https://github.com/httpdigest/lwjgl3-awt basically seems to work, at least during my first tests.. Um... there is https://github.com/httpdigest/lwjgl3-awt/blob/master/src/org/lwjgl/opengl/awt/PlatformLinuxGLCanvas.java , but your statement suggests that it does not work in some way... (I couldn't try it out). I'll probably still stick to LWGL2 for a while. The attempt to mix both versions also was intended to allow a \"smooth\" transition between versions, but I think this is not yet really an issue.\n. Thanks, I already started browsing into the relevant classes here. \nThe fact that the native libraries are never deleted makes me wonder, now, again related to the original issue here: What happens when you start a LWJGL 3.1.1 application and keep it running, and then addtionally start a LWJGL 3.1.2 application - won't that mess up the temp files? (Yes, I know, once more an unlikely scenario, but these are the things that don't let me sleep at night ;-) - maybe you solved this somehow, I just started examining the code....)\n(I remember that I once naively wrote the libraries into a file created with File#createTempFile. They could not be automatically deleted on Windows, and then people reported that their temp-directory was messed up with hundreds of copies of the native library :-/ Lesson learned....)\n. I don't have experience with installers, but imagine that it may be a considerable overhead regarding the implementation effort. Of course, this is not about sophisticated Rich Client Applications, but rather about people who want to publish some GL rendering demo, or maybe a small game. The'd likely prefer to have a single JAR that others can try out easily - since it also refers to the users: It may be a matter of attitude (or convenience, aka laziness), but I think that many people prefer the \"\u00fcber-JAR\" solution: Download. Doubleclick. Runs. \n(\"Write once, run anywhere\" - I have not given it up yet ;-)).\nAnd if this can be solved with a (versioned) temp-file, then why should an installer be the \"best\" way? I agree that writing a resource to a temp-file feels like an odd workaround, but I think that it is reasonable. \n. Again, my disclaimer: I'm not really familiar with the (many!) options of deployment, and will certainly have to read mode about it. Also, I don't know about possible preferences by end-users in practice - where \"end-users\" may refer to geeks and other programmers who want to have a look at what someone else has built, and real end users who might ask: \"What is a JVM?\"\nThe latter touches this point:\n\nThe problem is that this requires a public JRE installed globally in the system. You'll find that many users do not have that, or they're on an obsolete version. With Java's security reputation on the client and applets, many users avoid Java like the plague. I personally don't remember the last time I installed the JRE on my systems.\n\nAdmittedly, an installed JVM is what I usually assume. When deploying a Java application, this is as a requirement, period. And deploying a 30MB JVM just to run your 50KB JAR with some OpenGL demo is simply not reasonable. But of course, I see that there may be the \"real end-users\" (as described above) who don't want a JAR, but essentially \"something like a .EXE\". And for this, there are different solutions on various levels. I didn't know capsule.io, but for this purpose, it may be worth a look.\n\nBecause, as you've found out, writing to temp or user folders won't be appreciated by users. \n\nI also don't really like this solution. But without an installer, it's the only option. And it is by far the most convenient option. We all went through the trauma of the UnsatisfiedLinkError for much too long. And at least for JCuda and JOCL, since I started packing the natives into the JAR, these complaints have essentially disappeared. \nThe best thing would be if Java started allowing to load natives from memory, as in System.load(byte libraryData[]) or even from the JAR, as in System.load(URI resourcePath), but I assume that there are reasons of why this is not possible (security issues, probably). Even though such a solution does not exist yet, I'm pretty sure that something like this (only better) will be available in the near future.\n\nAs far as the question of simple deployment (with an assumed JRE being installed on the end-users system) is concerned: You already have a solution for this, right? If you work with Maven you can just use the Shade plugin. Gradle has this also (Shadow plugin). \n\nWhen I looked at the shade plugin, I thought it was mainly intended to resolve ambiguities (i.e. overlaps) in the package names. At least, the \u00fcber-JAR-creation is something that I've done with the assembly plugin. (Followed by applying JarSplice to the result, because ... native libraries, yes)\n\nAnd every IDE provides a way to export a run configuration as a standalone jar, too.\n\nFrom my experience, this also causes some glitches when natives are involved (but again, my experience is very limited here). And for easy deployment, and automated, command-line based way to do this may be preferable. . OK, when these are OS constraints, then things may become more difficult. There are so many legacy issues that have to be coped with (or: \"What you never wanted to know about -fPIC, but had to dig into nevertheless, just to get your JNI library running\"). \nI've even heard rumours that newer MacOS versions introduce some constraints: It was said that they do not allow a native library B to be loaded as a dependency of library A when A is contained in the temp-folder. (This has not been confirmed for me until now, but sounds concerning - did anybody hear something similar, or can dispel my concerns?)\n\nI wonder, if someday, the linker will support native libraries.\n\nMy hopes that Java will receive an extended functionality here was related to this project, and the general efforts for a better support and integration of native libraries in other projects. \n\nIf Java were to support it, the JVM would also need to go the way through a temporary file \n\nThis would at least be a first step. Moving the responsibility for this \"upwards\" into the JVM would tremendously simplify things for all JNI developers and it would feel more reliable than manual workarounds (like the SharedLibraryLoader, LibUtils or https://github.com/scijava/native-lib-loader ). All the OS-specific information about the architecture and OS name and bitness that the JNI developer has to assemble manually and tediously are inherent for the JVM. \nAnd, most importantly: It would make the process transparent. If there was a method like System.load(URI jarUri), then it could be implemented based on a temp-file, and later be changed to load from the JAR/memory directly (maybe after they implemented the required functionality in the linker, or somehow coped with the OS constraints), without affecting the JNI developers' code.\n. That's one of the projects that I referred to above, but admittedly, I'm not up to date about the current state and planning of the \"native library management APIs\" that they refer to. \nOf course, right now there is a plethora of options for interfacing Java and native code: https://github.com/java-native-access , https://github.com/jnr , https://github.com/nativelibs4java/BridJ , https://github.com/bytedeco/javacpp (the latter summarizing more than a dozen more \"\"failed attempts\"\"). Many of them are basically JNI code generators. Some of them go one level deeper and try to create a \"generic\" function call interface. \nBut I think that these will always be kinds of workarounds, as long as the support for interfacing native libraries is not intrinsically supported by the JVM. This goal is ambituous, of course, and may even be considered as a step away from the idea of \"Write once, run anywhere\". But experience shows that there is a need for this.\nIn any case, I'm curious how things will turn out here.. (Just a reminder: The issue is closed, so strictly speaking, it may not be \"necessary\" to \"convince\" anybody - but of course, these points may be relevant for the discussion nevertheless)\n@JustGregory I'm not entirely sure what you referred to with the \"in situ update by an end-user\". If this refers to sophisticated things like RCP with underlying OSGi or some Spring magic where JARs can be replaced at runtime, then I can't say anything here. But can imagine that having two different versions of the same JAR in the classpath can cause arbitrary problems. (I think that these infrastructures are aware of this, and try to cope with this, using some ClassLoader magic, but I'm not familiar with that - or how well it works).\nBut to emphasize this again: \nThis issue originally mainly referred to the native libraries. And it was mainly based on the fact that I did not know that LWJGL3 now also allows keeping the natives in the JAR. For LWJGL2, it was still necessary to unpack them so \"some\" directory, and set the java.library.path accordingly, and there, the problem of two different lwjgl.dll files overwriting each other is obvious. \nAs for the JAR libraries: They are versioned automatically by Maven. So there's not much freedom here anyhow. (This freedom only exists for the downloadable release packages, and there, one can say that it's up to the user to rename the library file or not). \n. (It's not really \"your fault\". I was not so clear here: The issue originally did refer to the JARs and natives. But the JARs part is not so important and handled by Maven. The natives part was what most of the actual discussion eventually referred to). \nThe RCP scenario that your described sounds like a source of headaches even if it only refers to JARs. But I think that this also becomes really ugly when natives are involved. As mentioned above: There is hardly a way to \"unload\" a native library at all. Hopefully, the upcoming projects (Jigsaw/Panama/...) will offer some nice and clean solutions here, to justify the \"D\" in \"DLL\"....\n. ",
    "ThomasAunvik": "Thanks, now that i know that i could just downgrade my driver version. ",
    "TheDudeFromCI": "Awesome. I'll grab it in the next stable release.. ",
    "stelar7": "glfwWindowShouldClose can be called from any thread according to the Javadocs, so that shouldnt be an issue..?\nThe main calls into the run method in that file, so there are only 3 glfw calls in the new thread:\nglfwMakeContextCurrent(window);\nglfwWindowShouldClose(window);\nglfwSwapBuffers(window);\nEDIT: Removing the call to glfwWindowShouldClose in the new thread (thus making it basically a copy of the multithreaded demo) still produces the same issue. I changed the code to match the multithread example, so even if it would act on garbage, it now acts on a boolean. BUT, the issue is still there.. The main thread will set the boolean destroyed to true, but the spawned thread still sees it as false, yes.\nEdit: Turns out i forgot one instance of the glfw call, that most likely fixed it.... ",
    "Immueggpain": "@Spasi Oh I see. That totally makes sense. I will use AILogStreamCallback instead. Also thank you for your reply!\nP.S. It seems to me that beta has less bugs and is more stable than the current 3.1.1 release, is it just my illusion? LOL. @HackeurD Hi, thank you for your reply. But there are still some problems.\n1. The put method may be fast, but why should I incur unnecessary copy at all? Also I have to allocate new buffers, which is also a problem.\n2. The wiki says that we should use MemoryUtil class to allocate buffers. Are you suggesting me to use BufferUtils instead?\n3. I think glBufferSubData is used to modify part of the server-side buffer, not client-side buffer. Am I wrong?\n. @Spasi Oh thank you very much for the info. position() and limit() are exactly what I am looking for. \nAnd the binding FAQ is quite informative. I have read the Memory FAQ but not the binding one, should've done that.\nBut I really don't think that offset and length are synthetic. The native C APIs have such parameters and almost every java method which operates arrays has them too. But of course, I guess nio.Buffer is our official choice now so it might not worth the trouble.\nAnother problem. Though that I see Hotspot Critical Natives will block GC when calling in the JNI function. But does that mean that the array may still get moved after the function returns? And since OpenGL is highly asynchronous, wouldn't that be a problem?. Oh, wait... Does the indices mean different things whether there is a GL_ELEMENT_ARRAY_BUFFER or not?. @httpdigest Okay, I googled the client-side arrays things and found out what's going on. I guess there are still some old hidden deprecated secrets in OpenGL LOL.. Thanks for the help!. ",
    "rustyTheClone": "\nThe method put of direct buffers is really fast. So it shouldn't be an issue. The best way to do is to use them directly. You can allocate them with \njava\nBufferUtils.create<Float|Int|Byte|Char|Double|Int|Long|Pointer|Short>Buffer(int capacity);\nFor the offset, you have to use glBufferSubData. (available in org.lwjgl.opengl.GL15). \n",
    "NatanielBR": "\nsame problem.\n. Yes, i tested the Minecraft and Blender, all works well.. ",
    "attilanyers": "I just met this issue. The posted workaround works. Thank you.. ",
    "raould": "here i am in 2018 wishing for better docs around this somewhere, anywhere i could find on the internet, since i am hitting a runtime exception java.lang.UnsatisfiedLinkError: Failed to locate library: libGL.so.1 and have yet to suss out how to resolve it :-)\nupdate: this helped me debug a little more and make progress toward a /different/ runtime exception.. thanks...\njava.vm.version 25.181-b13 OpenJDK 64-bit Server VM\nlwjgl 3.1.2\nubuntu 16.04 lts 64 bit\ngeforce gtx 480\nos claims \"using nvidia binary driver 384.130 from nvidia-384\"\n/usr/lib32/nvidia-384/libGL.so.1                                                                                                                                                  \n /usr/lib/i386-linux-gnu/mesa/libGL.so.1                                                                                                                                           \n /usr/lib/nvidia-384/libGL.so.1                                                                                                                                                    \n /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1   \nI have a version that runs, via some magic (using mill build tool for scala) vs. not working when i try to do it with raw java command with \"-D\" and \"-cp\" flags. Somehow the broken one is loading a different LWJGL, 3.2.0 whereas the working one is using 3.1.2. I have no idea where the 3.2.0 is coming from, the only jars on the classpath afaict are the 3.1.2 ones. I will keep trying to figure it out.\ngood\nINFO: Running on jMonkeyEngine 3.2-stable\n  * Branch: HEAD\n  * Git Hash: f85624a\n  * Build Date: 2018-01-21\n [LWJGL] Version: 3.1.2 build 29\n [LWJGL]      OS: Linux v4.15.0-36-generic\n [LWJGL]     JRE: 1.8.0_181 amd64\n [LWJGL]     JVM: OpenJDK 64-Bit Server VM v25.181-b13 by Oracle Corporation\n [LWJGL] Loading library (system): lwjgl\n [LWJGL]     Using SharedLibraryLoader...\n [LWJGL]     Found at: /tmp/lwjglsuperman/3.1.2-build-29/liblwjgl.so\n [LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsuperman/3.1.2-build-29/liblwjgl.so\n [LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n [LWJGL] Loading library: jemalloc\n [LWJGL]     Using SharedLibraryLoader...\n [LWJGL]     Found at: /tmp/lwjglsuperman/3.1.2-build-29/libjemalloc.so\n [LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsuperman/3.1.2-build-29/libjemalloc.so\n [LWJGL] MemoryUtil allocator: JEmallocAllocator\n [LWJGL] Loading library: glfw\n [LWJGL]     Using SharedLibraryLoader...\n [LWJGL]     Found at: /tmp/lwjglsuperman/3.1.2-build-29/libglfw.so\n [LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsuperman/3.1.2-build-29/libglfw.so\n Oct 09, 2018 8:54:42 PM com.jme3.system.lwjgl.LwjglContext printContextInitInfo\n INFO: LWJGL 3.1.2 build 29 context running on thread main\n  * Graphics Adapter: GLFW 3.3.0 X11 GLX EGL clock_gettime /dev/js shared\n [LWJGL] Loading library (system): lwjgl_opengl\n [LWJGL]     Using SharedLibraryLoader...\n [LWJGL]     Found at: /tmp/lwjglsuperman/3.1.2-build-29/liblwjgl_opengl.so\n [LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsuperman/3.1.2-build-29/liblwjgl_opengl.so\n [LWJGL] Loading library: libGL.so.1\n [LWJGL]     libGL.so.1 not found in org.lwjgl.librarypath=/tmp/lwjglsuperman/3.1.2-build-29\n [LWJGL]     Loaded from system paths\n Oct 09, 2018 8:54:42 PM com.jme3.renderer.opengl.GLRenderer loadCapabilitiesCommon\n INFO: OpenGL Renderer Information\n  * Vendor: NVIDIA Corporation\n  * Renderer: GeForce GTX 480/PCIe/SSE2\n  * OpenGL Version: 4.5.0 NVIDIA 384.130\n  * GLSL Version: 4.50 NVIDIA\n  * Profile: Compatibility\nbad\nINFO: Running on jMonkeyEngine 3.2-stable\n  * Branch: HEAD\n  * Git Hash: f85624a\n  * Build Date: 2018-01-21\n [LWJGL] Version: 3.2.0 build 12\n [LWJGL]      OS: Linux v4.15.0-36-generic\n [LWJGL]     JRE: 1.8.0_181 amd64\n [LWJGL]     JVM: OpenJDK 64-Bit Server VM v25.181-b13 by Oracle Corporation\n [LWJGL] Loading library (system): lwjgl\n [LWJGL]     Using SharedLibraryLoader...\n [LWJGL]     Found at: /tmp/lwjglsuperman/3.2.0-build-12/liblwjgl.so\n [LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsuperman/3.2.0-build-12/liblwjgl.so\n [LWJGL] MemoryUtil accessor: MemoryAccessorUnsafe\n [LWJGL] Loading library: jemalloc\n [LWJGL]     Using SharedLibraryLoader...\n [LWJGL]     Found at: /tmp/lwjglsuperman/3.2.0-build-12/libjemalloc.so\n [LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsuperman/3.2.0-build-12/libjemalloc.so\n [LWJGL] MemoryUtil allocator: JEmallocAllocator\n [LWJGL] Loading library: glfw\n [LWJGL]     Using SharedLibraryLoader...\n [LWJGL]     Found at: /tmp/lwjglsuperman/3.2.0-build-12/libglfw.so\n [LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsuperman/3.2.0-build-12/libglfw.so\n Oct 09, 2018 9:02:59 PM com.jme3.system.lwjgl.LwjglContext printContextInitInfo\n INFO: LWJGL 3.2.0 build 12 context running on thread main\n  * Graphics Adapter: GLFW 3.3.0 X11 GLX EGL clock_gettime /dev/js shared\n [LWJGL] Loading library (system): lwjgl_opengl\n [LWJGL]     Using SharedLibraryLoader...\n [LWJGL]     Found at: /tmp/lwjglsuperman/3.2.0-build-12/liblwjgl_opengl.so\n [LWJGL]     Loaded from org.lwjgl.librarypath: /tmp/lwjglsuperman/3.2.0-build-12/liblwjgl_opengl.so\n [LWJGL] Loading library: libGL.so.1\n [LWJGL]     libGL.so.1 not found in org.lwjgl.librarypath=/tmp/lwjglsuperman/3.2.0-build-12\n [LWJGL]     libGL.so.1 not found in system paths\n [LWJGL]     libGL.so.1 not found in java.library.path=/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/u\\\n sr/lib\n [LWJGL] Failed to load a library. Possible solutions:\n     a) Install the library or the driver that provides the library.\n     b) Ensure that the library is accessible from the system library paths.\n [LWJGL] Loading library: libGL.so\n [LWJGL]     libGL.so not found in org.lwjgl.librarypath=/tmp/lwjglsuperman/3.2.0-build-12\n [LWJGL]     libGL.so not found in system paths\n [LWJGL]     libGL.so not found in java.library.path=/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr\\\n /lib\n [LWJGL] Failed to load a library. Possible solutions:\n     a) Install the library or the driver that provides the library.\n     b) Ensure that the library is accessible from the system library paths.\n Oct 09, 2018 9:02:59 PM com.jme3.app.LegacyApplication handleError\n SEVERE: Uncaught exception thrown in Thread[main,5,main]\n java.lang.UnsatisfiedLinkError: Failed to locate library: libGL.so.1. p.s. glxgears works fine. :-). p.s. glxgears works fine. :-). ok fixed, i somehow managed to exorcise all the 3.2.0 (lwjgl and opengl) jars. phew. weird that 3.2.0 is worse than 3.1.2?. ",
    "raniejade": "Does this matter?\nhttp://www.fmod.com/licensing#faq\nQ. Can I distribute FMOD as a standalone library or as part of a game engine or toolset.\nA. No, you are not permitted to distribute FMOD in that way. Contact us if you would like to discuss a special arrangement.. @Coppyhop are you calling loadTexture from a different thread? This happened to me, I just changed my code to upload the texture in thread owning the OpenGL context.. Based on experience, any window icon setting API never really work on OS X and Linux. For OS X, I usually create an application bundle (https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html#//apple_ref/doc/uid/10000123i-CH101-SW1) and for linux, a desktop file (https://linuxcritic.wordpress.com/2010/04/07/anatomy-of-a-desktop-file/) usually does the trick.. ",
    "lenis0012": "@Spasi \nUnless i'm missing something\naiReleaseImport(AiScene) calls naiReleaseImport(long)\nwhich then calls AiScene.validate(long)\nin there each memory addressed is checked against NULL.\nThere is no reference to any num values.\nI am using version 3.1.1 of LWJGL\nThis is the code in question:\nhttps://gist.github.com/lenis0012/141ed69e8e58230de8d6e0658d83c17b\nThis is the program output:\nAnimation count: 0\nException in thread \"main\" java.lang.NullPointerException\n    at org.lwjgl.system.Checks.check(Checks.java:94)\n    at org.lwjgl.assimp.AIScene.validate(AIScene.java:439)\n    at org.lwjgl.assimp.Assimp.naiReleaseImport(Assimp.java:2560)\n    at org.lwjgl.assimp.Assimp.aiReleaseImport(Assimp.java:2572)\n    at com.flipfire.arbor.engine.content.AssimpLoader.loadModel(AssimpLoader.java:61)\n    at com.flipfire.arbor.ArborGame.initialize(ArborGame.java:42)\n    at com.flipfire.arbor.engine.ArborEngine.run(ArborEngine.java:39)\n    at com.flipfire.arbor.ArborGame.main(ArborGame.java:60)\nIt throws the error after checking MANIMATIONS.. @Spasi Ah my bad.\nI  actually looked the the changes to the bindings since december 2016, but I overlooked that commit.\nSo I thought it wasn't fixed.\nI would be using the beta build if it were available for maven.\nI guess ill just wait for the next stable release to replace the unsafe code in my project.\nThank you for your swift response.. ",
    "nickdbush": "LWJGL is written in Java, and iOS is Swift / Objective C based. So, unless I'm missing something, you'd need to get Java working on iOS if you wanted the LWJGL library specifically.\nNote \"library\", as LWJGL is not a game or graphics engine - it just exposes the raw OpenGL (and other) bindings and makes them easy to consume in Java. You can use OpenGL bindings on iOS too, but you'll need to use the ones Apple provide. LWJGL would not be required there then.. ",
    "AAbhishek1234": "\n@Coppyhop are you calling loadTexture from a different thread? This happened to me, I just changed my code to upload the texture in thread owning the OpenGL context.\n\nHow exactly did yo do that ?? . ",
    "EmpsThomy": "Thanks for the quick reply. That indeed makes sense, I am using BufferedImage as internal representation for resizing / editing image data.\nWould there be other solutions where I could use ImageIO? I've recently updated from lwjgl-2.9.0 to lwjgl-3.1.1and wouldn't mind rewriting input again, but internal data representation changes would be a lot more work.\n. Thanks to both of you, kappaOne and Spasi! I'll try to run the application with -Djava.awt.headless=true and reconstruct image handling in future expansions with the stb_ functions. Their ByteBuffer or FloatBuffer can directly be used with the lwjgl functions to store textures on the graphics card. That's actually really handy.. Quick follow-up. Setting -Djava.awt.headless=true works like a charm, really good tip, thanks! I've now run into an issue with DPI scaling though, also on the Mac.\nI know that display of the mac I am testing the application with is scaling down the application to run in 1440x900. This works correctly when querying the cursor's position with glfwSetCursorPosCallback, I get cursor position values between 0x0 and 1400x900. However, the glfwSetFramebufferSizeCallback returns the actual size of the window, without taking any scalings into consideration. This in fact screws up the entire internal mouse pointer handling, because positions are off. \nIs that correct behavior, or is there a way of disabling/enabling DPI scaling for position values of \nboth methods glfwSetCursorPosCallback and glfwSetFramebufferSizeCallback? . I was wrongly using glfwSetFramebufferSizeCallback to listen on window resize events. However, it works fine and as expected if I use the glfwSetWindowSizeCallback. I can find the DPI scaling factors by dividing the window sizes by the frame buffer sizes and can fix the issue. Thanks. :). Thanks a lot. :). Okay, thanks! Is this related to the user trying to run the game with a 64bit jvm? What Could I do to avoid that from happening? Could it be a faulty driver installation on the user's end?. Deleting the C:\\Users\\AwVzZhH\\AppData\\Local\\Temp\\lwjglAwVzZhH\\ folder has worked. I will keep this in mind and recommend it to users in the future. Cheers!. Deleting following folder fixed the problem:\nC:\\Users\\User\\AppData\\Local\\Temp\\lwjglUser\nLooks like I am forced to delete that folder upon every start of our application, since this has already been causing a lot of troubles and a lot of different errors.\nAny ideas what could be causing them?. Thanks a lot! :)\nI am already using -xStartOnFirstThread on macOS and user have reported that it's working fine, no errors there.\nThe issue is indeed odd. I will provide an outprint if I find a user having this issue again. It was only happening on a user's computer with Windows 10 and lwjgl-3.1.1. Deleting the lwjgl folder in the user's temp directory completely fixed the problem for the user.\nThough, in theory, I should be able to run lwjgl on the non-main thread on Windows if using the code from above. It works fine on my computer, no matter in which thread I run it.\n. Thanks for the quick reply! In that case I have to add a native binding. Will there be support in the future by the lwjgl library to enable that behavior by default?. ",
    "piegamesde": "\nNote that this applies to GLFW functions only; OpenGL contexts can be made current in other threads and those threads can be used for rendering.\n\nBut, if you need an GLFW window (even if hidden) to create an OpenGL context, how would one go at having the OpenGL context in a different thread than the main thread? And how to have two parallel OpenGL contexts on different threads?. And how does this work on the larger scale level? In the OS, there must be multiple OpenGL contexts open at the same time without problems, what's the difference there? Where does this limitation come from (Java, GLFW, OS allowing one context per process, ...)?. What happens on this topic if the machine used has multiple graphics cards?. That's weird. I tried to remove the glfwShowWindow(window); line again and this time, no errors. I sadly don't have the broken code anymore so maybe I had an error somewhere else that just got triggered when the window was closed and it was thrown at the wrong place for different reasons.\nI'll reopen this issue if I manage to get this error back \"working\".. There are multiple possible solutions I could think of:\n\nMove InfoUtil to the same package as the demo\nMake InfoUtil part of the official release again\nRemove the InfoUtil dependency\n\nIn my understanding, when using demo code, you:\n\nDownload the package or (if possible) copy the class\nAdd the needed dependencies to the project (if not done yet)\nTry out the demo\nModify it to get started\n\nIn this example, this expected flow is interrupted by compile errors due to the missing class. In this situation, most people expect that something with the dependency is broken (wrong version, ...) which is quite common. If all seems correct there (which it is), most people will go their way and try another library if they do not absolutely need this exact thing to work. And I think this is a bad user experience.. ",
    "nedtwigg": "Gradle, Maven, and Ant all at once!!  The jvm build tool trifecta ;-). ",
    "vurtun": "Hey @dustContributor and @Spasi. Text is an absolute nightmare in nuklear or rather this type of GUI design, since everything needs to be recalculated and drawn each frame. That is especially noticeable with text since it involves font glyph lookup, text width calculation requiring a text width callback as well as UTF-8 rune decoding which are awful performance hogs.\nOne issue I saw was related to high vertex count caused by text in nuklear which seems to quite high and the other  was general slowness of text width calculations. Biggest problem here is that nk_text_wrap was not designed for a lot of text.\n\nI believe what I am intending to do is fairly reasonable, think something like Pillars of Eternity or Tyranny dialogue boxes,\n\nMy question here is are these dialog boxes persistent? If so I would recommend creating some custom text state for these dialog boxes to store metrics for each line that only need to be recalculated if the size changes. Then for drawing you could iterate over each line and draw by nk_draw_text. This would also allow nuklear to clip text that is currently not visible and therefore hopefully further improves performance and vertex count.\nBy the way the reason why text takes up so much memory is because each glyph takes up 4 vertexes plus 6 indicies so if you multiply that out for all text visible that is quite a lot.. > No idea what you mean by \"persistent\" but they're like this\nPersistent as in frame persistent. Nuklear throws away almost everything every frame. As it looks to me your dialog lifetime is persistent.\n\nYou can scroll up to see the previous responses in the widget, you have differently colored text in the same lines, and the responses are selectable text basically. Not quite sure how to do the last one in Nuklear. \n\nHow I would do it is have a class/struct for the dialog. The dialog object would both hold the complete string as well as a list of text objects (each holding number of characters in line or in your dialog case for different colored text sections as well) that get calculated in the beginning or on resize. Then for UI I would use a nk_group and iterate over all text objects and draw them with nk_text. The scrollbar would be handled by nuklear while the selectable options could be done with nk_selectable.\n. > What would the purpose of nk_group be in this case? \nnk_group mainly for scrollbar handling. Of course you could use nk_begin and nk_end as well depending on how you structure your code.. nk_group is for panels inside panels. It is mainly used as a layouting widget. You could also say it is a scrollable section inside a panel. For example the nodes inside the node editor are groups.. ",
    "BinarSkugga": "As said in the Minecraft issue report site, this is a nvidia crash not a LWJGL's. Either bad drivers or your graphic card is too old.. ",
    "jfelrod1960": "@httpdigest I had to rebuild the project.  Now it is working.  Thank you for your help.  I must have done something wrong when I first built the project.. ",
    "fynnfluegge": "Alright, that helps me, thank you!. But then I have to implement GL_SAMPLE_ALPHA_TO_COVERAGE by myself right? GL_SAMPLE_ALPHA_TO_COVERAGE isn't applied to textures with Alpha Test in Fragment Shader with discard.. Alright thank you, I forgot to check whether extension is supported by device. Anyways it's not working due to latest Nvidia driver versions (See below).\nI have another issue, since I updated LunarG Vulkan SDK to 1.1.73 on my device, I get a NullPointerException by calling vkCreateDebugReportCallbackEXT. The Exception occurs at \nnvkCreateDebugReportCallbackEXT.check(__functionAddress) where __functionAddress = instance.getCapabilities().vkCreateDebugReportCallbackEXT. So the vkCreateDebugReportCallbackEXT of the instance seems to be null. However, I never got that error before, so it's strange to me\nEDIT: sorry, solved it, I flipped the extension name PointerBuffer two times somehow - facpalm\nHowever, the EXTDescriptorIndexing is available since Vulkan 1.1.72. The latest Nvidia driver provides just 1.1.70. That's a very sad. I got Titan Xp and can't use the EXTDescriptorIndexing extension, because Nvidia is behind with it's drivers.... ",
    "malobre": "I ran the GLFW examples and it also take 10s to launch.\nI will open an issue on the GLFW repo asap.\nI'm also closing this issue as everything is fine with lwjgl.. Seems to be the same with bgfx_set_view_clear() and its second parameter, short constants needs to be casted to ints. I'm currently using toInt() but isn't it possible to just declare the constants that are used in bitfield parameters as Ints insteads of Shorts ? Or am I missing something ?. ",
    "Klotzi111": "Sorry for the stupid question but what is a \"MCVE\"?. First a CVE (Why not MCVE because its not that small, but i couldn't make it smaller to show the error)\nI don't know why the imports are not in the code field.\nFixxed the code block\n```Java\nimport static org.lwjgl.glfw.Callbacks.glfwFreeCallbacks;\nimport static org.lwjgl.glfw.GLFW.*;\nimport static org.lwjgl.opengl.GL11.GL_COLOR_BUFFER_BIT;\nimport static org.lwjgl.opengl.GL11.GL_DEPTH_BUFFER_BIT;\nimport static org.lwjgl.opengl.GL11.glClear;\nimport static org.lwjgl.opengl.GL11.glClearColor;\nimport static org.lwjgl.system.MemoryUtil.NULL;\nimport java.nio.FloatBuffer;\nimport java.nio.IntBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport org.lwjgl.BufferUtils;\nimport org.lwjgl.glfw.GLFWErrorCallback;\nimport org.lwjgl.glfw.GLFWKeyCallbackI;\nimport org.lwjgl.opengl.GL;\nimport org.lwjgl.opengl.GL11;\nimport org.lwjgl.opengl.GL15;\nimport org.lwjgl.opengl.GL20;\nimport org.lwjgl.opengl.GL30;\nimport org.lwjgl.opengl.GLCapabilities;\n/* GLFW demo that showcases rendering to multiple windows from a single thread. /\npublic final class MultipleWindows {\npublic static class Model {\n\n    private final Vao vao;\n\n    public Model(Vao vao) {\n        this.vao = vao;\n    }\n\n    public void delete() {\n        vao.delete();\n    }\n\n    public Vao getVao() {\n        return vao;\n    }\n\n}\n\npublic static class ModelData {\n\n    private static final int DIMENSIONS = 3;\n\n    private float[] vertices;\n    private float[] textureCoords;\n    private float[] normals;\n    private int[] indices;\n    private float furthestPoint;\n\n    public ModelData(float[] vertices, float[] textureCoords, float[] normals, int[] indices, float furthestPoint) {\n        this.vertices = vertices;\n        this.textureCoords = textureCoords;\n        this.normals = normals;\n        this.indices = indices;\n        this.furthestPoint = furthestPoint;\n    }\n\n    public float getFurthestPoint() {\n        return furthestPoint;\n    }\n\n    public int[] getIndices() {\n        return indices;\n    }\n\n    public float[] getNormals() {\n        return normals;\n    }\n\n    public float[] getTextureCoords() {\n        return textureCoords;\n    }\n\n    public int getVertexCount() {\n        return vertices.length / DIMENSIONS;\n    }\n\n    public float[] getVertices() {\n        return vertices;\n    }\n\n}\n\npublic static class ModelLoader {\n\n    protected Model loadModel() {\n        ModelData data = new ModelData(vertices, textureCoords, normals, indices, furthestPoint); // OBJFileLoader.loadOBJ(modelFile);\n\n        Vao vao = Vao.create();\n        vao.bind();\n        vao.createIndexBuffer(data.getIndices());\n        vao.createAttribute(0, data.getVertices(), 3);\n        vao.createAttribute(1, data.getTextureCoords(), 2);\n        vao.createAttribute(2, data.getNormals(), 3);\n        vao.unbind();\n        return new Model(vao);\n    }\n\n}\n\npublic static class Vao {\n\n    private static final int BYTES_PER_FLOAT = 4;\n\n    public static Vao create() {\n        int id = GL30.glGenVertexArrays();\n        return new Vao(id);\n    }\n\n    public final int id;\n    private List<Vbo> dataVbos = new ArrayList<Vbo>();\n    private Vbo indexVbo;\n\n    private int indexCount;\n\n    private Vao(int id) {\n        this.id = id;\n    }\n\n    private void bind() {\n        GL30.glBindVertexArray(id);\n    }\n\n    public void bind(int... attributes) {\n        bind();\n        for (int i : attributes) {\n            GL20.glEnableVertexAttribArray(i);\n        }\n    }\n\n    public void createAttribute(int attribute, float[] data, int attrSize) {\n        Vbo dataVbo = Vbo.create(GL15.GL_ARRAY_BUFFER);\n        dataVbo.bind();\n        dataVbo.storeData(data);\n        GL20.glVertexAttribPointer(attribute, attrSize, GL11.GL_FLOAT, false, attrSize * BYTES_PER_FLOAT, 0);\n        dataVbo.unbind();\n        dataVbos.add(dataVbo);\n    }\n\n    public void createIndexBuffer(int[] indices) {\n        indexVbo = Vbo.create(GL15.GL_ELEMENT_ARRAY_BUFFER);\n        indexVbo.bind();\n        indexVbo.storeData(indices);\n        indexCount = indices.length;\n    }\n\n    public void createIntAttribute(int attribute, int[] data, int attrSize) {\n        Vbo dataVbo = Vbo.create(GL15.GL_ARRAY_BUFFER);\n        dataVbo.bind();\n        dataVbo.storeData(data);\n        GL30.glVertexAttribIPointer(attribute, attrSize, GL11.GL_INT, attrSize * BYTES_PER_FLOAT, 0);\n        dataVbo.unbind();\n        dataVbos.add(dataVbo);\n    }\n\n    public void delete() {\n        GL30.glDeleteVertexArrays(id);\n        for (Vbo vbo : dataVbos) {\n            vbo.delete();\n        }\n        indexVbo.delete();\n    }\n\n    public int getIndexCount() {\n        return indexCount;\n    }\n\n    private void unbind() {\n        GL30.glBindVertexArray(0);\n    }\n\n    public void unbind(int... attributes) {\n        for (int i : attributes) {\n            GL20.glDisableVertexAttribArray(i);\n        }\n        unbind();\n    }\n\n}\n\npublic static class Vbo {\n\n    public static Vbo create(int type) {\n        int id = GL15.glGenBuffers();\n        return new Vbo(id, type);\n    }\n\n    private final int vboId;\n\n    private final int type;\n\n    private Vbo(int vboId, int type) {\n        this.vboId = vboId;\n        this.type = type;\n    }\n\n    public void bind() {\n        GL15.glBindBuffer(type, vboId);\n    }\n\n    public void delete() {\n        GL15.glDeleteBuffers(vboId);\n    }\n\n    public void storeData(float[] data) {\n        FloatBuffer buffer = BufferUtils.createFloatBuffer(data.length);\n        buffer.put(data);\n        buffer.flip();\n        storeData(buffer);\n    }\n\n    public void storeData(FloatBuffer data) {\n        GL15.glBufferData(type, data, GL15.GL_STATIC_DRAW);\n    }\n\n    public void storeData(int[] data) {\n        IntBuffer buffer = BufferUtils.createIntBuffer(data.length);\n        buffer.put(data);\n        buffer.flip();\n        storeData(buffer);\n    }\n\n    public void storeData(IntBuffer data) {\n        GL15.glBufferData(type, data, GL15.GL_STATIC_DRAW);\n    }\n\n    public void unbind() {\n        GL15.glBindBuffer(type, 0);\n    }\n\n}\n\nprivate static class Window {\n    final long handle;\n\n    GLCapabilities capabilities;\n\n    Window(long handle) {\n        this.handle = handle;\n    }\n}\n\npublic static int[] indices = new int[] {0, 1, 2, 3, 4, 5, 4, 6, 7, 8, 0, 9, 1, 3, 2, 6, 49, 7, 2, 5, 10, 7, 50, 11, 12, 2, 13, 5, 14, 15, 14, 7, 11, 9, 12, 16, 17, 16, 18, 13, 10, 19, 11, 51, 20, 16, 13,\n        18, 10, 15, 21, 15, 11, 21, 52, 22, 23, 53, 24, 25, 24, 52, 26, 54, 53, 25, 27, 23, 28, 29, 30, 31, 25, 26, 32, 23, 55, 33, 30, 25, 31, 26, 27, 28, 56, 57, 34, 57, 58, 35, 36, 59, 37, 38, 56, 34,\n        58, 60, 35, 59, 38, 39, 34, 40, 41, 40, 35, 42, 37, 43, 44, 39, 34, 45, 35, 61, 46, 43, 39, 47, 41, 42, 48, 42, 46, 48, 44, 47, 48, 45, 41, 48, 46, 62, 48, 47, 45, 48, 63, 54, 29, 22, 64, 23, 12, 0,\n        2, 4, 14, 5, 14, 4, 7, 0, 12, 9, 3, 5, 2, 49, 50, 7, 13, 2, 10, 50, 51, 11, 16, 12, 13, 10, 5, 15, 15, 14, 11, 17, 9, 16, 65, 17, 18, 10, 66, 19, 67, 11, 20, 13, 19, 18, 66, 10, 21, 11, 67, 21, 27,\n        52, 23, 24, 26, 25, 52, 27, 26, 30, 54, 25, 23, 33, 28, 68, 29, 31, 69, 25, 32, 55, 70, 33, 25, 69, 31, 32, 26, 28, 57, 40, 34, 40, 57, 35, 59, 43, 37, 39, 38, 34, 60, 61, 35, 43, 59, 39, 40, 42,\n        41, 35, 46, 42, 43, 47, 44, 34, 41, 45, 61, 62, 46, 39, 45, 47, 54, 30, 29, 64, 55, 23};\n\npublic static float[] normals = new float[] {-0.8921F, -0.4426F, 0.0906F, -0.3677F, -0.4426F, 0.8179F, -0.4099F, -0.0221F, 0.9119F, 0.5245F, -0.4427F, 0.7273F, 0.8921F, -0.4427F, -0.0906F, 0.5848F,\n        -0.0221F, 0.8109F, 0.3676F, -0.4427F, -0.8179F, 0.4098F, -0.0221F, -0.9119F, -0.5245F, -0.4427F, -0.7273F, -0.5848F, -0.0221F, -0.8109F, 0.5616F, 0.2793F, 0.7788F, 0.3937F, 0.2793F, -0.8758F,\n        -0.9946F, -0.0221F, 0.101F, -0.3937F, 0.2793F, 0.8758F, 0.9946F, -0.0221F, -0.101F, 0.9553F, 0.2793F, -0.097F, -0.9553F, 0.2793F, 0.097F, -0.5617F, 0.2793F, -0.7788F, -0.7455F, -0.6622F, 0.0757F,\n        -0.3072F, -0.6622F, 0.6835F, -0.4383F, -0.6622F, -0.6077F, 0.7455F, -0.6622F, -0.0757F, 0.3072F, -0.6622F, -0.6835F, 0.305F, -0.6682F, -0.6786F, 0.4383F, -0.6622F, 0.6078F, -0.305F, -0.6682F,\n        0.6786F, 0.4352F, -0.6682F, 0.6034F, 0.7402F, -0.6682F, -0.0752F, 0.993F, 0.0608F, -0.1008F, -0.4352F, -0.6682F, -0.6035F, -0.7402F, -0.6682F, 0.0751F, -0.993F, 0.0607F, 0.1008F, 0.5838F, 0.0608F,\n        0.8096F, 0.4092F, 0.0608F, -0.9104F, 0.4523F, 0.6342F, 0.6271F, 0.317F, 0.6342F, -0.7052F, -0.5838F, 0.0608F, -0.8096F, -0.4522F, 0.6342F, -0.6271F, -0.4092F, 0.0608F, 0.9104F, -0.317F, 0.6342F,\n        0.7052F, 0.7692F, 0.6342F, -0.0781F, 0.2882F, 0.8702F, 0.3996F, 0.4901F, 0.8702F, -0.0498F, -0.7692F, 0.6342F, 0.0781F, -0.2882F, 0.8702F, -0.3996F, -0.202F, 0.8702F, 0.4493F, 0.202F, 0.8702F,\n        -0.4493F, -0.4901F, 0.8702F, 0.0498F, -0.0F, 1.0F, -0.0F, -0.5245F, -0.4427F, -0.7273F, -0.5848F, -0.0221F, -0.8109F, -0.5617F, 0.2793F, -0.7788F, 0.7455F, -0.6622F, -0.0757F, -0.3072F, -0.6622F,\n        0.6835F, -0.7455F, -0.6622F, 0.0757F, -0.4352F, -0.6682F, -0.6035F, 0.5838F, 0.0608F, 0.8096F, 0.993F, 0.0608F, -0.1008F, 0.4092F, 0.0608F, -0.9104F, -0.993F, 0.0607F, 0.1008F, -0.5838F, 0.0608F,\n        -0.8096F, -0.4522F, 0.6342F, -0.6271F, -0.2882F, 0.8702F, -0.3996F, -0.4383F, -0.6622F, -0.6077F, -0.4383F, -0.6622F, -0.6077F, -0.4383F, -0.6622F, -0.6077F, 0.4383F, -0.6622F, 0.6078F, 0.3072F,\n        -0.6622F, -0.6835F, -0.5838F, 0.0608F, -0.8096F, -0.4092F, 0.0608F, 0.9104F, -0.5838F, 0.0608F, -0.8096F};\n\npublic static float[] textureCoords = new float[] {0.0989F, 0.26380002F, 0.1583F, 0.26599997F, 0.1595F, 0.21200001F, 0.2191F, 0.26819998F, 0.2816F, 0.26880002F, 0.2193F, 0.21270001F, 0.3463F, 0.26810002F,\n        0.3445F, 0.2058F, 0.0395F, 0.2697F, 0.0214F, 0.21039999F, 0.2187F, 0.1437F, 0.333F, 0.13559997F, 0.0979F, 0.21069998F, 0.1624F, 0.1419F, 0.2801F, 0.21109998F, 0.2753F, 0.1419F, 0.1051F, 0.13599998F,\n        0.0457F, 0.12449998F, 0.1237F, 0.023400009F, 0.1707F, 0.029699981F, 0.3574F, 0.011900008F, 0.2644F, 0.030099988F, 0.8322F, 0.22060001F, 0.9453F, 0.24220002F, 0.8033F, 0.16930002F, 0.7106F, 0.0776F,\n        0.8263F, 0.058499992F, 0.9223F, 0.12589997F, 0.954F, 0.10750002F, 0.6593F, 0.3121F, 0.641F, 0.17500001F, 0.6035F, 0.16390002F, 0.8364F, 0.023100019F, 0.9807F, 0.24940002F, 0.4759F, 0.875F, 0.7583F,\n        0.58790004F, 0.2198F, 0.2909F, 0.3105F, 0.35869998F, 0.1956F, 0.8532F, 0.2824F, 0.7832F, 0.6768F, 0.7954F, 0.4809F, 0.7513F, 0.5876F, 0.70640004F, 0.2127F, 0.57739997F, 0.4095F, 0.4731F, 0.3766F,\n        0.70239997F, 0.6271F, 0.5925F, 0.3415F, 0.58889997F, 0.4836F, 0.61109996F, 0.4153F, 0.2697F, 0.4254F, 0.19639999F, 0.3904F, 0.121200025F, 0.8282F, 0.18910003F, 0.7717F, 0.17259997F, 0.7517F,\n        0.19749999F, 0.877F, 0.36009997F, 0.4663F, 0.9874F, 0.7537F, 0.8809F, 0.8779F, 0.5925F, 0.103F, 0.5694F, 0.7631F, 0.28210002F, 0.6593F, 0.356F, 0.5612F, 0.4753F, 0.7581F, 0.22909999F, 0.8125F,\n        0.24620003F, 0.0771F, 0.012700021F, 0.2177F, 0.032000005F, 0.3107F, 0.023599982F, 0.6188F, 0.3244F, 0.6926F, 0.045000017F, 0.9061F, 0.384F};\n\npublic static float[] vertices = new float[] {-0.144087F, -0.034334F, 0.008855F, -0.130818F, -0.034334F, 0.027257F, -0.136179F, -0.007832F, 0.039189F, -0.108244F, -0.034334F, 0.024965F, -0.098942F,\n        -0.034334F, 0.004271F, -0.100592F, -0.007832F, 0.035577F, -0.112215F, -0.034334F, -0.014131F, -0.106852F, -0.007832F, -0.026064F, -0.134787F, -0.034334F, -0.011838F, -0.142439F, -0.007832F,\n        -0.022451F, -0.108244F, 0.022372F, 0.024966F, -0.112214F, 0.022372F, -0.014131F, -0.157103F, -0.007832F, 0.010176F, -0.130818F, 0.022372F, 0.027258F, -0.085926F, -0.007832F, 0.00295F, -0.098942F,\n        0.022372F, 0.004272F, -0.144087F, 0.022372F, 0.008856F, -0.134787F, 0.022372F, -0.01184F, -0.139845F, 0.054427F, 0.008425F, -0.129069F, 0.054427F, 0.023367F, -0.132292F, 0.054427F, -0.00838F,\n        -0.103186F, 0.054427F, 0.004702F, -0.113963F, 0.054427F, -0.010241F, -0.085061F, 0.075747F, -0.074545F, -0.110739F, 0.054427F, 0.021507F, -0.157971F, 0.075747F, 0.087672F, -0.0695F, 0.075747F,\n        0.078688F, -0.033045F, 0.075747F, -0.00242F, -0.024521F, 0.097956F, -0.003285F, -0.173529F, 0.075747F, -0.065562F, -0.209984F, 0.075747F, 0.015545F, -0.218512F, 0.097956F, 0.016411F, -0.06449F,\n        0.097956F, 0.085639F, -0.081547F, 0.097956F, -0.082361F, -0.074837F, 0.129936F, 0.071291F, -0.088799F, 0.129936F, -0.066225F, -0.178542F, 0.097956F, -0.072513F, -0.168194F, 0.129936F, -0.058164F,\n        -0.161484F, 0.097956F, 0.095488F, -0.154232F, 0.129936F, 0.079353F, -0.04212F, 0.129936F, -0.001498F, -0.096669F, 0.156142F, 0.041016F, -0.079256F, 0.156142F, 0.002273F, -0.200911F, 0.129936F,\n        0.014624F, -0.146361F, 0.156142F, -0.027889F, -0.13893F, 0.156142F, 0.045307F, -0.104102F, 0.156142F, -0.032181F, -0.163775F, 0.156142F, 0.010854F, -0.121516F, 0.171244F, 0.006563F, -0.134787F,\n        -0.034334F, -0.011838F, -0.142439F, -0.007832F, -0.022451F, -0.134787F, 0.022372F, -0.01184F, -0.103186F, 0.054427F, 0.004702F, -0.129069F, 0.054427F, 0.023367F, -0.139845F, 0.054427F, 0.008425F,\n        -0.173529F, 0.075747F, -0.065562F, -0.06449F, 0.097956F, 0.085639F, -0.024521F, 0.097956F, -0.003285F, -0.081547F, 0.097956F, -0.082361F, -0.218512F, 0.097956F, 0.016411F, -0.178542F, 0.097956F,\n        -0.072513F, -0.168194F, 0.129936F, -0.058164F, -0.146361F, 0.156142F, -0.027889F, -0.132292F, 0.054427F, -0.00838F, -0.132292F, 0.054427F, -0.00838F, -0.132292F, 0.054427F, -0.00838F, -0.110739F,\n        0.054427F, 0.021507F, -0.113963F, 0.054427F, -0.010241F, -0.178542F, 0.097956F, -0.072513F, -0.161484F, 0.097956F, 0.095488F, -0.178542F, 0.097956F, -0.072513F};\n\npublic static float furthestPoint = 0.2400254F;\n\npublic static Model staticmodel = null;\n\nprivate static void demo() {\n    glfwDefaultWindowHints();\n    glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n\n    Window[] windows = new Window[2];\n\n    AtomicInteger latch = new AtomicInteger(windows.length);\n\n    for (int i = 0; i < windows.length; i++) {\n        int windowIndex = i + 1;\n\n        long handle = glfwCreateWindow(300, 300, \"GLFW Demo - \" + windowIndex, NULL, NULL);\n        if (handle == NULL) {\n            throw new IllegalStateException(\"Failed to create GLFW window\");\n        }\n\n        Window window = new Window(handle);\n\n        glfwSetKeyCallback(handle, new GLFWKeyCallbackI() {\n            @Override\n            public void invoke(long windowHnd, int key, int scancode, int action, int mods) {\n                if (key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE) {\n                    Arrays.stream(windows).filter(new Predicate<Window>() {\n                        @Override\n                        public boolean test(Window w) {\n                            return w != null;\n                        }\n                    }).forEach(new Consumer<Window>() {\n                        @Override\n                        public void accept(Window w) {\n                            glfwSetWindowShouldClose(w.handle, true);\n                        }\n                    });\n                }\n            }\n        });\n\n        glfwMakeContextCurrent(handle);\n        window.capabilities = GL.createCapabilities();\n\n        if (i == 0) { // Load Model only once, but I need a GL context\n            staticmodel = new ModelLoader().loadModel();\n        }\n\n        glClearColor((i & 1), (i >> 1), (i == 1) ? 0.f : 1.f, 0.f);\n\n        glfwSwapInterval(1);\n\n        glfwShowWindow(handle);\n        glfwSetWindowPos(handle, 100 + (i & 1) * 400, 100 + (i >> 1) * 400);\n\n        windows[i] = window;\n    }\n\n    while (latch.get() != 0) {\n\n        for (int i = 0; i < windows.length; i++) {\n            Window window = windows[i];\n            if (window == null) {\n                continue;\n            }\n\n            glfwMakeContextCurrent(window.handle);\n            GL.setCapabilities(window.capabilities);\n\n            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n            // if (i == 0) { // makes it work, but not what I want. It should be rendered on all windows\n            render(); // crashes. If it works, a white little Mushroom appears\n            // }\n\n            glfwSwapBuffers(window.handle);\n\n            if (glfwWindowShouldClose(window.handle)) {\n                glfwFreeCallbacks(window.handle);\n                glfwDestroyWindow(window.handle);\n                windows[i] = null;\n\n                latch.decrementAndGet();\n            }\n        }\n        glfwPollEvents();\n\n    }\n}\n\npublic static void main(String[] args) {\n    GLFWErrorCallback errorfun = GLFWErrorCallback.createPrint();\n    glfwSetErrorCallback(errorfun);\n    if (!glfwInit()) {\n        throw new IllegalStateException(\"Failed to initialize GLFW.\");\n    }\n\n    try {\n        demo();\n    } finally {\n        glfwTerminate();\n        glfwSetErrorCallback(null).free();\n    }\n}\n\nprivate static void render() {\n    GL11.glDisable(GL11.GL_BLEND);\n    GL11.glEnable(GL11.GL_DEPTH_TEST);\n\n    Vao model = staticmodel.getVao();\n    model.bind(0, 1, 2);\n    GL11.glDrawElements(GL11.GL_TRIANGLES, model.getIndexCount(), GL11.GL_UNSIGNED_INT, 0); // Crashed App when second Window wants to render\n    model.unbind(0, 1, 2);\n}\n\nprivate MultipleWindows() {\n}\n\n}\n```\nLine 406 lets the JVM crash. Running the code with the javaagent gives me following exception:\nJava\n[LWJGL] OpenGL debug message\n    ID: 0x20071\n    Source: API\n    Type: OTHER\n    Severity: NOTIFICATION\n    Message: Buffer detailed info: Buffer object 1 (bound to GL_ELEMENT_ARRAY_BUFFER_ARB, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.\n[LWJGL] OpenGL debug message\n    ID: 0x20071\n    Source: API\n    Type: OTHER\n    Severity: NOTIFICATION\n    Message: Buffer detailed info: Buffer object 2 (bound to GL_ARRAY_BUFFER_ARB, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.\n[LWJGL] OpenGL debug message\n    ID: 0x20071\n    Source: API\n    Type: OTHER\n    Severity: NOTIFICATION\n    Message: Buffer detailed info: Buffer object 3 (bound to GL_ARRAY_BUFFER_ARB, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.\n[LWJGL] OpenGL debug message\n    ID: 0x20071\n    Source: API\n    Type: OTHER\n    Severity: NOTIFICATION\n    Message: Buffer detailed info: Buffer object 4 (bound to GL_ARRAY_BUFFER_ARB, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.\n[LWJGL] OpenGL debug message\n    ID: 0x502\n    Source: API\n    Type: ERROR\n    Severity: HIGH\n    Message: GL_INVALID_OPERATION error generated. VAO names must be generated with glGenVertexArrays before they can be bound or used.\nException in thread \"main\" java.lang.RuntimeException: glBindVertexArray produced error: 1282\n    at org.lwjglx.debug.Transformer.checkError(Transformer.java:61)\n    at MultipleWindows$Vao.bind(MultipleWindows.java:131)\n    at MultipleWindows$Vao.bind(MultipleWindows.java:135)\n    at MultipleWindows.render(MultipleWindows.java:405)\n    at MultipleWindows.demo(MultipleWindows.java:367)\n    at MultipleWindows.main(MultipleWindows.java:393)\nBut what it says is not true I use glGenVertexArrays. So i must load all the data to all GL Contexts?\nWhat if i want 10 Windows showing the same content?. What can be shared and what can't?. I have changed my code so (I hope) that the each Context creates his own VAO.\nVBOs are shared so have to to create them new.\nBut it still crashes and the javaagent cant find anything.\nCan someone please tell me what I do wrong?\nSo here is my code:\n```Java\nimport static org.lwjgl.glfw.Callbacks.glfwFreeCallbacks;\nimport static org.lwjgl.glfw.GLFW.*;\nimport static org.lwjgl.opengl.GL11.GL_COLOR_BUFFER_BIT;\nimport static org.lwjgl.opengl.GL11.GL_DEPTH_BUFFER_BIT;\nimport static org.lwjgl.opengl.GL11.glClear;\nimport static org.lwjgl.opengl.GL11.glClearColor;\nimport static org.lwjgl.system.MemoryUtil.NULL;\nimport java.nio.FloatBuffer;\nimport java.nio.IntBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport org.lwjgl.BufferUtils;\nimport org.lwjgl.glfw.GLFWErrorCallback;\nimport org.lwjgl.glfw.GLFWKeyCallbackI;\nimport org.lwjgl.opengl.GL;\nimport org.lwjgl.opengl.GL11;\nimport org.lwjgl.opengl.GL15;\nimport org.lwjgl.opengl.GL20;\nimport org.lwjgl.opengl.GL30;\nimport org.lwjgl.opengl.GLCapabilities;\n/* GLFW demo that showcases rendering to multiple windows from a single thread. /\npublic final class MultipleWindows {\npublic static class Model {\n\n    private final Vao vao;\n\n    public Model(Vao vao) {\n        this.vao = vao;\n    }\n\n    public void delete() {\n        vao.delete();\n    }\n\n    public Vao getVao() {\n        return vao;\n    }\n\n}\n\npublic static class ModelData {\n\n    private static final int DIMENSIONS = 3;\n\n    private float[] vertices;\n    private float[] textureCoords;\n    private float[] normals;\n    private int[] indices;\n    private float furthestPoint;\n\n    public ModelData(float[] vertices, float[] textureCoords, float[] normals, int[] indices, float furthestPoint) {\n        this.vertices = vertices;\n        this.textureCoords = textureCoords;\n        this.normals = normals;\n        this.indices = indices;\n        this.furthestPoint = furthestPoint;\n    }\n\n    public float getFurthestPoint() {\n        return furthestPoint;\n    }\n\n    public int[] getIndices() {\n        return indices;\n    }\n\n    public float[] getNormals() {\n        return normals;\n    }\n\n    public float[] getTextureCoords() {\n        return textureCoords;\n    }\n\n    public int getVertexCount() {\n        return vertices.length / DIMENSIONS;\n    }\n\n    public float[] getVertices() {\n        return vertices;\n    }\n\n}\n\npublic static class ModelLoader {\n\n    protected Model loadModel() {\n        ModelData data = new ModelData(vertices, textureCoords, normals, indices, furthestPoint); // OBJFileLoader.loadOBJ(modelFile);\n\n        Vao vao = Vao.create();\n        vao.bind();\n        vao.createIndexBuffer(data.getIndices());\n        vao.createAttribute(0, data.getVertices(), 3);\n        vao.createAttribute(1, data.getTextureCoords(), 2);\n        vao.createAttribute(2, data.getNormals(), 3);\n        vao.unbind();\n        return new Model(vao);\n    }\n\n}\n\npublic static class Vao {\n\n    private static final int BYTES_PER_FLOAT = 4;\n\n    public static Vao create() {\n        int id = GL30.glGenVertexArrays();\n        return new Vao(id);\n    }\n\n    private final HashMap<GLCapabilities, Integer> loadedcontexts = new HashMap<>();\n\n    private final List<VaoAttribute> attributes = new LinkedList<>();\n\n    private final List<Vbo> dataVbos = new ArrayList<Vbo>();\n    private Vbo indexVbo;\n\n    private int indexCount;\n\n    private Vao(int id) {\n        loadedcontexts.put(GL.getCapabilities(), id);\n    }\n\n    private void bind() {\n        if (!loadedcontexts.containsKey(GL.getCapabilities())) {\n            recreateAndBind();\n        } else {\n            GL30.glBindVertexArray(loadedcontexts.get(GL.getCapabilities()));\n        }\n    }\n\n    public void bind(int... attributes) {\n        indexVbo.bind();\n        bind();\n        for (int i : attributes) {\n            GL20.glEnableVertexAttribArray(i);\n        }\n    }\n\n    public void createAttribute(int attribute, float[] data, int attrSize) {\n        Vbo dataVbo = Vbo.create(GL15.GL_ARRAY_BUFFER);\n        dataVbo.bind();\n        dataVbo.storeData(data);\n        attributes.add(new VaoAttribute(dataVbo, attribute, attrSize));\n        GL20.glVertexAttribPointer(attribute, attrSize, GL11.GL_FLOAT, false, attrSize * BYTES_PER_FLOAT, 0);\n        dataVbo.unbind();\n        dataVbos.add(dataVbo);\n    }\n\n    public void createIndexBuffer(int[] indices) {\n        indexVbo = Vbo.create(GL15.GL_ELEMENT_ARRAY_BUFFER);\n        indexVbo.bind();\n        indexVbo.storeData(indices);\n        indexCount = indices.length;\n    }\n\n    public void createIntAttribute(int attribute, int[] data, int attrSize) {\n        Vbo dataVbo = Vbo.create(GL15.GL_ARRAY_BUFFER);\n        dataVbo.bind();\n        dataVbo.storeData(data);\n        attributes.add(new VaoAttributeI(dataVbo, attribute, attrSize));\n        GL30.glVertexAttribIPointer(attribute, attrSize, GL11.GL_INT, attrSize * BYTES_PER_FLOAT, 0);\n        dataVbo.unbind();\n        dataVbos.add(dataVbo);\n    }\n\n    public void delete() {\n        GL30.glDeleteVertexArrays(loadedcontexts.get(GL.getCapabilities()));\n        for (Vbo vbo : dataVbos) {\n            vbo.delete();\n        }\n        indexVbo.delete();\n    }\n\n    public void deleteForContext() {\n        GL30.glDeleteVertexArrays(loadedcontexts.get(GL.getCapabilities()));\n    }\n\n    public int getIndexCount() {\n        return indexCount;\n    }\n\n    private void recreateAndBind() {\n        int id = GL30.glGenVertexArrays();\n        loadedcontexts.put(GL.getCapabilities(), id);\n        GL30.glBindVertexArray(id);\n        for (VaoAttribute b : attributes) {\n            if (!(b instanceof VaoAttribute)) {\n\n            } else {\n                VaoAttribute attrib = b;\n                attrib.getVbo().bind();\n                if (attrib instanceof VaoAttributeI) {\n                    GL30.glVertexAttribIPointer(attrib.getAttribute(), attrib.getAttrSize(), GL11.GL_INT, attrib.getAttrSize() * BYTES_PER_FLOAT, 0);\n                } else {\n                    GL20.glVertexAttribPointer(attrib.getAttribute(), attrib.getAttrSize(), GL11.GL_FLOAT, false, attrib.getAttrSize() * BYTES_PER_FLOAT, 0);\n                }\n                attrib.getVbo().unbind();\n            }\n        }\n    }\n\n    private void unbind() {\n        GL30.glBindVertexArray(0);\n    }\n\n    public void unbind(int... attributes) {\n        for (int i : attributes) {\n            GL20.glDisableVertexAttribArray(i);\n        }\n        unbind();\n        indexVbo.unbind();\n    }\n\n}\n\npublic static class VaoAttribute {\n\n    private final int attribute;\n    private final int attrSize;\n    private final Vbo vbo;\n\n    public VaoAttribute(Vbo vbo, int attribute, int attrSize) {\n        this.vbo = vbo;\n        this.attribute = attribute;\n        this.attrSize = attrSize;\n    }\n\n    public int getAttribute() {\n        return attribute;\n    }\n\n    public int getAttrSize() {\n        return attrSize;\n    }\n\n    public Vbo getVbo() {\n        return vbo;\n    }\n\n}\n\npublic static class VaoAttributeI extends VaoAttribute {\n\n    public VaoAttributeI(Vbo vbo, int attribute, int attrSize) {\n        super(vbo, attribute, attrSize);\n    }\n\n}\n\npublic static class Vbo {\n\n    public static Vbo create(int type) {\n        int id = GL15.glGenBuffers();\n        return new Vbo(id, type);\n    }\n\n    private final int vboId;\n\n    private final int type;\n\n    private Vbo(int vboId, int type) {\n        this.vboId = vboId;\n        this.type = type;\n    }\n\n    public void bind() {\n        GL15.glBindBuffer(type, vboId);\n    }\n\n    public void delete() {\n        GL15.glDeleteBuffers(vboId);\n    }\n\n    public void storeData(float[] data) {\n        FloatBuffer buffer = BufferUtils.createFloatBuffer(data.length);\n        buffer.put(data);\n        buffer.flip();\n        storeData(buffer);\n    }\n\n    public void storeData(FloatBuffer data) {\n        GL15.glBufferData(type, data, GL15.GL_STATIC_DRAW);\n    }\n\n    public void storeData(int[] data) {\n        IntBuffer buffer = BufferUtils.createIntBuffer(data.length);\n        buffer.put(data);\n        buffer.flip();\n        storeData(buffer);\n    }\n\n    public void storeData(IntBuffer data) {\n        GL15.glBufferData(type, data, GL15.GL_STATIC_DRAW);\n    }\n\n    public void unbind() {\n        GL15.glBindBuffer(type, 0);\n    }\n\n}\n\nprivate static class Window {\n    final long handle;\n\n    GLCapabilities capabilities;\n\n    Window(long handle) {\n        this.handle = handle;\n    }\n}\n\npublic static int[] indices = new int[] {0, 1, 2, 3, 4, 5, 4, 6, 7, 8, 0, 9, 1, 3, 2, 6, 49, 7, 2, 5, 10, 7, 50, 11, 12, 2, 13, 5, 14, 15, 14, 7, 11, 9, 12, 16, 17, 16, 18, 13, 10, 19, 11, 51, 20, 16, 13,\n        18, 10, 15, 21, 15, 11, 21, 52, 22, 23, 53, 24, 25, 24, 52, 26, 54, 53, 25, 27, 23, 28, 29, 30, 31, 25, 26, 32, 23, 55, 33, 30, 25, 31, 26, 27, 28, 56, 57, 34, 57, 58, 35, 36, 59, 37, 38, 56, 34,\n        58, 60, 35, 59, 38, 39, 34, 40, 41, 40, 35, 42, 37, 43, 44, 39, 34, 45, 35, 61, 46, 43, 39, 47, 41, 42, 48, 42, 46, 48, 44, 47, 48, 45, 41, 48, 46, 62, 48, 47, 45, 48, 63, 54, 29, 22, 64, 23, 12, 0,\n        2, 4, 14, 5, 14, 4, 7, 0, 12, 9, 3, 5, 2, 49, 50, 7, 13, 2, 10, 50, 51, 11, 16, 12, 13, 10, 5, 15, 15, 14, 11, 17, 9, 16, 65, 17, 18, 10, 66, 19, 67, 11, 20, 13, 19, 18, 66, 10, 21, 11, 67, 21, 27,\n        52, 23, 24, 26, 25, 52, 27, 26, 30, 54, 25, 23, 33, 28, 68, 29, 31, 69, 25, 32, 55, 70, 33, 25, 69, 31, 32, 26, 28, 57, 40, 34, 40, 57, 35, 59, 43, 37, 39, 38, 34, 60, 61, 35, 43, 59, 39, 40, 42,\n        41, 35, 46, 42, 43, 47, 44, 34, 41, 45, 61, 62, 46, 39, 45, 47, 54, 30, 29, 64, 55, 23};\n\npublic static float[] normals = new float[] {-0.8921F, -0.4426F, 0.0906F, -0.3677F, -0.4426F, 0.8179F, -0.4099F, -0.0221F, 0.9119F, 0.5245F, -0.4427F, 0.7273F, 0.8921F, -0.4427F, -0.0906F, 0.5848F,\n        -0.0221F, 0.8109F, 0.3676F, -0.4427F, -0.8179F, 0.4098F, -0.0221F, -0.9119F, -0.5245F, -0.4427F, -0.7273F, -0.5848F, -0.0221F, -0.8109F, 0.5616F, 0.2793F, 0.7788F, 0.3937F, 0.2793F, -0.8758F,\n        -0.9946F, -0.0221F, 0.101F, -0.3937F, 0.2793F, 0.8758F, 0.9946F, -0.0221F, -0.101F, 0.9553F, 0.2793F, -0.097F, -0.9553F, 0.2793F, 0.097F, -0.5617F, 0.2793F, -0.7788F, -0.7455F, -0.6622F, 0.0757F,\n        -0.3072F, -0.6622F, 0.6835F, -0.4383F, -0.6622F, -0.6077F, 0.7455F, -0.6622F, -0.0757F, 0.3072F, -0.6622F, -0.6835F, 0.305F, -0.6682F, -0.6786F, 0.4383F, -0.6622F, 0.6078F, -0.305F, -0.6682F,\n        0.6786F, 0.4352F, -0.6682F, 0.6034F, 0.7402F, -0.6682F, -0.0752F, 0.993F, 0.0608F, -0.1008F, -0.4352F, -0.6682F, -0.6035F, -0.7402F, -0.6682F, 0.0751F, -0.993F, 0.0607F, 0.1008F, 0.5838F, 0.0608F,\n        0.8096F, 0.4092F, 0.0608F, -0.9104F, 0.4523F, 0.6342F, 0.6271F, 0.317F, 0.6342F, -0.7052F, -0.5838F, 0.0608F, -0.8096F, -0.4522F, 0.6342F, -0.6271F, -0.4092F, 0.0608F, 0.9104F, -0.317F, 0.6342F,\n        0.7052F, 0.7692F, 0.6342F, -0.0781F, 0.2882F, 0.8702F, 0.3996F, 0.4901F, 0.8702F, -0.0498F, -0.7692F, 0.6342F, 0.0781F, -0.2882F, 0.8702F, -0.3996F, -0.202F, 0.8702F, 0.4493F, 0.202F, 0.8702F,\n        -0.4493F, -0.4901F, 0.8702F, 0.0498F, -0.0F, 1.0F, -0.0F, -0.5245F, -0.4427F, -0.7273F, -0.5848F, -0.0221F, -0.8109F, -0.5617F, 0.2793F, -0.7788F, 0.7455F, -0.6622F, -0.0757F, -0.3072F, -0.6622F,\n        0.6835F, -0.7455F, -0.6622F, 0.0757F, -0.4352F, -0.6682F, -0.6035F, 0.5838F, 0.0608F, 0.8096F, 0.993F, 0.0608F, -0.1008F, 0.4092F, 0.0608F, -0.9104F, -0.993F, 0.0607F, 0.1008F, -0.5838F, 0.0608F,\n        -0.8096F, -0.4522F, 0.6342F, -0.6271F, -0.2882F, 0.8702F, -0.3996F, -0.4383F, -0.6622F, -0.6077F, -0.4383F, -0.6622F, -0.6077F, -0.4383F, -0.6622F, -0.6077F, 0.4383F, -0.6622F, 0.6078F, 0.3072F,\n        -0.6622F, -0.6835F, -0.5838F, 0.0608F, -0.8096F, -0.4092F, 0.0608F, 0.9104F, -0.5838F, 0.0608F, -0.8096F};\n\npublic static float[] textureCoords = new float[] {0.0989F, 0.26380002F, 0.1583F, 0.26599997F, 0.1595F, 0.21200001F, 0.2191F, 0.26819998F, 0.2816F, 0.26880002F, 0.2193F, 0.21270001F, 0.3463F, 0.26810002F,\n        0.3445F, 0.2058F, 0.0395F, 0.2697F, 0.0214F, 0.21039999F, 0.2187F, 0.1437F, 0.333F, 0.13559997F, 0.0979F, 0.21069998F, 0.1624F, 0.1419F, 0.2801F, 0.21109998F, 0.2753F, 0.1419F, 0.1051F, 0.13599998F,\n        0.0457F, 0.12449998F, 0.1237F, 0.023400009F, 0.1707F, 0.029699981F, 0.3574F, 0.011900008F, 0.2644F, 0.030099988F, 0.8322F, 0.22060001F, 0.9453F, 0.24220002F, 0.8033F, 0.16930002F, 0.7106F, 0.0776F,\n        0.8263F, 0.058499992F, 0.9223F, 0.12589997F, 0.954F, 0.10750002F, 0.6593F, 0.3121F, 0.641F, 0.17500001F, 0.6035F, 0.16390002F, 0.8364F, 0.023100019F, 0.9807F, 0.24940002F, 0.4759F, 0.875F, 0.7583F,\n        0.58790004F, 0.2198F, 0.2909F, 0.3105F, 0.35869998F, 0.1956F, 0.8532F, 0.2824F, 0.7832F, 0.6768F, 0.7954F, 0.4809F, 0.7513F, 0.5876F, 0.70640004F, 0.2127F, 0.57739997F, 0.4095F, 0.4731F, 0.3766F,\n        0.70239997F, 0.6271F, 0.5925F, 0.3415F, 0.58889997F, 0.4836F, 0.61109996F, 0.4153F, 0.2697F, 0.4254F, 0.19639999F, 0.3904F, 0.121200025F, 0.8282F, 0.18910003F, 0.7717F, 0.17259997F, 0.7517F,\n        0.19749999F, 0.877F, 0.36009997F, 0.4663F, 0.9874F, 0.7537F, 0.8809F, 0.8779F, 0.5925F, 0.103F, 0.5694F, 0.7631F, 0.28210002F, 0.6593F, 0.356F, 0.5612F, 0.4753F, 0.7581F, 0.22909999F, 0.8125F,\n        0.24620003F, 0.0771F, 0.012700021F, 0.2177F, 0.032000005F, 0.3107F, 0.023599982F, 0.6188F, 0.3244F, 0.6926F, 0.045000017F, 0.9061F, 0.384F};\n\npublic static float[] vertices = new float[] {-0.144087F, -0.034334F, 0.008855F, -0.130818F, -0.034334F, 0.027257F, -0.136179F, -0.007832F, 0.039189F, -0.108244F, -0.034334F, 0.024965F, -0.098942F,\n        -0.034334F, 0.004271F, -0.100592F, -0.007832F, 0.035577F, -0.112215F, -0.034334F, -0.014131F, -0.106852F, -0.007832F, -0.026064F, -0.134787F, -0.034334F, -0.011838F, -0.142439F, -0.007832F,\n        -0.022451F, -0.108244F, 0.022372F, 0.024966F, -0.112214F, 0.022372F, -0.014131F, -0.157103F, -0.007832F, 0.010176F, -0.130818F, 0.022372F, 0.027258F, -0.085926F, -0.007832F, 0.00295F, -0.098942F,\n        0.022372F, 0.004272F, -0.144087F, 0.022372F, 0.008856F, -0.134787F, 0.022372F, -0.01184F, -0.139845F, 0.054427F, 0.008425F, -0.129069F, 0.054427F, 0.023367F, -0.132292F, 0.054427F, -0.00838F,\n        -0.103186F, 0.054427F, 0.004702F, -0.113963F, 0.054427F, -0.010241F, -0.085061F, 0.075747F, -0.074545F, -0.110739F, 0.054427F, 0.021507F, -0.157971F, 0.075747F, 0.087672F, -0.0695F, 0.075747F,\n        0.078688F, -0.033045F, 0.075747F, -0.00242F, -0.024521F, 0.097956F, -0.003285F, -0.173529F, 0.075747F, -0.065562F, -0.209984F, 0.075747F, 0.015545F, -0.218512F, 0.097956F, 0.016411F, -0.06449F,\n        0.097956F, 0.085639F, -0.081547F, 0.097956F, -0.082361F, -0.074837F, 0.129936F, 0.071291F, -0.088799F, 0.129936F, -0.066225F, -0.178542F, 0.097956F, -0.072513F, -0.168194F, 0.129936F, -0.058164F,\n        -0.161484F, 0.097956F, 0.095488F, -0.154232F, 0.129936F, 0.079353F, -0.04212F, 0.129936F, -0.001498F, -0.096669F, 0.156142F, 0.041016F, -0.079256F, 0.156142F, 0.002273F, -0.200911F, 0.129936F,\n        0.014624F, -0.146361F, 0.156142F, -0.027889F, -0.13893F, 0.156142F, 0.045307F, -0.104102F, 0.156142F, -0.032181F, -0.163775F, 0.156142F, 0.010854F, -0.121516F, 0.171244F, 0.006563F, -0.134787F,\n        -0.034334F, -0.011838F, -0.142439F, -0.007832F, -0.022451F, -0.134787F, 0.022372F, -0.01184F, -0.103186F, 0.054427F, 0.004702F, -0.129069F, 0.054427F, 0.023367F, -0.139845F, 0.054427F, 0.008425F,\n        -0.173529F, 0.075747F, -0.065562F, -0.06449F, 0.097956F, 0.085639F, -0.024521F, 0.097956F, -0.003285F, -0.081547F, 0.097956F, -0.082361F, -0.218512F, 0.097956F, 0.016411F, -0.178542F, 0.097956F,\n        -0.072513F, -0.168194F, 0.129936F, -0.058164F, -0.146361F, 0.156142F, -0.027889F, -0.132292F, 0.054427F, -0.00838F, -0.132292F, 0.054427F, -0.00838F, -0.132292F, 0.054427F, -0.00838F, -0.110739F,\n        0.054427F, 0.021507F, -0.113963F, 0.054427F, -0.010241F, -0.178542F, 0.097956F, -0.072513F, -0.161484F, 0.097956F, 0.095488F, -0.178542F, 0.097956F, -0.072513F};\n\npublic static float furthestPoint = 0.2400254F;\n\npublic static Model staticmodel = null;\n\nprivate static void demo() {\n    glfwDefaultWindowHints();\n    glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n\n    Window[] windows = new Window[2];\n\n    AtomicInteger latch = new AtomicInteger(windows.length);\n\n    for (int i = 0; i < windows.length; i++) {\n        int windowIndex = i + 1;\n\n        long handle = glfwCreateWindow(300, 300, \"GLFW Demo - \" + windowIndex, NULL, NULL);\n        if (handle == NULL) {\n            throw new IllegalStateException(\"Failed to create GLFW window\");\n        }\n\n        Window window = new Window(handle);\n\n        glfwSetKeyCallback(handle, new GLFWKeyCallbackI() {\n            @Override\n            public void invoke(long windowHnd, int key, int scancode, int action, int mods) {\n                if (key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE) {\n                    Arrays.stream(windows).filter(new Predicate<Window>() {\n                        @Override\n                        public boolean test(Window w) {\n                            return w != null;\n                        }\n                    }).forEach(new Consumer<Window>() {\n                        @Override\n                        public void accept(Window w) {\n                            glfwSetWindowShouldClose(w.handle, true);\n                        }\n                    });\n                }\n            }\n        });\n\n        glfwMakeContextCurrent(handle);\n        window.capabilities = GL.createCapabilities();\n\n        if (i == 0) { // Load Model only once, but I need a GL context\n            staticmodel = new ModelLoader().loadModel();\n        }\n\n        glClearColor((i & 1), (i >> 1), (i == 1) ? 0.f : 1.f, 0.f);\n\n        glfwSwapInterval(1);\n\n        glfwShowWindow(handle);\n        glfwSetWindowPos(handle, 100 + (i & 1) * 400, 100 + (i >> 1) * 400);\n\n        windows[i] = window;\n    }\n\n    while (latch.get() != 0) {\n\n        for (int i = 0; i < windows.length; i++) {\n            Window window = windows[i];\n            if (window == null) {\n                continue;\n            }\n\n            glfwMakeContextCurrent(window.handle);\n            GL.setCapabilities(window.capabilities);\n\n            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n            // if (i == 0) { // makes it work, but not what I want. It should be rendered on all windows\n            render(); // crashes. If it works, a white little Mushroom appears\n            // }\n\n            glfwSwapBuffers(window.handle);\n\n            if (glfwWindowShouldClose(window.handle)) {\n                glfwFreeCallbacks(window.handle);\n                glfwDestroyWindow(window.handle);\n                windows[i] = null;\n\n                latch.decrementAndGet();\n            }\n        }\n        glfwPollEvents();\n\n    }\n}\n\npublic static void main(String[] args) {\n    GLFWErrorCallback errorfun = GLFWErrorCallback.createPrint();\n    glfwSetErrorCallback(errorfun);\n    if (!glfwInit()) {\n        throw new IllegalStateException(\"Failed to initialize GLFW.\");\n    }\n\n    try {\n        demo();\n    } finally {\n        glfwTerminate();\n        glfwSetErrorCallback(null).free();\n    }\n}\n\nprivate static void render() {\n    GL11.glDisable(GL11.GL_BLEND);\n    GL11.glEnable(GL11.GL_DEPTH_TEST);\n\n    Vao model = staticmodel.getVao();\n    model.bind(0, 1, 2);\n    GL11.glDrawElements(GL11.GL_TRIANGLES, model.getIndexCount(), GL11.GL_UNSIGNED_INT, 0); // Crashed App when second Window wants to render\n    model.unbind(0, 1, 2);\n}\n\nprivate MultipleWindows() {\n}\n\n}\n```. You have to look at the VAO class\nI create a new VAO if a context wants to bind that VAO but has not created it. the new javaagent gives me following:\nJava\nException in thread \"main\" java.lang.IllegalStateException: glDrawElements called with index offset but no ELEMENT_ARRAY_BUFFER bound\n    at org.lwjglx.debug.Transformer.GL11_glDrawElements(Transformer.java:324)\n    at MultipleWindows.render(MultipleWindows.java:478)\n    at MultipleWindows.demo(MultipleWindows.java:439)\n    at MultipleWindows.main(MultipleWindows.java:465)\nI am printing the ELEMENT_ARRAY_BUFFER out to see that, but that gives me always 1 (thats how it should be). \n```Java\n            System.out.println(\"GL_ELEMENT_ARRAY_BUFFER_BINDING: \" + GL11.glGetInteger(GL15.GL_ELEMENT_ARRAY_BUFFER_BINDING));\n```. no, now I did it correctly and I fixxed that error, but the next error comes:\nJava\n[LWJGL] OpenGL debug message\n    ID: 0x0\n    Source: API\n    Type: ERROR\n    Severity: HIGH\n    Message: Unknown internal debug message. The NVIDIA OpenGL driver has encountered\nan out of memory error. This application might\nbehave inconsistently and fail.\n[LWJGL] OpenGL debug message\n    ID: 0x505\n    Source: API\n    Type: ERROR\n    Severity: HIGH\n    Message: GL_OUT_OF_MEMORY error generated. Failed to allocate memory for buffer object.\n[LWJGL] OpenGL debug message\n    ID: 0x0\n    Source: API\n    Type: ERROR\n    Severity: HIGH\n    Message: Unknown internal debug message. The NVIDIA OpenGL driver has encountered\nan out of memory error. This application might\nbehave inconsistently and fail.\n[LWJGL] OpenGL debug message\n    ID: 0x505\n    Source: API\n    Type: ERROR\n    Severity: HIGH\n    Message: GL_OUT_OF_MEMORY error generated. Failed to map memory for buffer.\nException in thread \"main\" java.lang.AssertionError: glDrawElements produced error: 1285\n    at org.lwjglx.debug.Transformer.checkError(Transformer.java:76)\n    at MultipleWindows.render(MultipleWindows.java:480)\n    at MultipleWindows.demo(MultipleWindows.java:440)\n    at MultipleWindows.main(MultipleWindows.java:466). I found the problem myself (maybe you should add this to you javaagent) it was because I wanted to use the shared VBOs but I had not parsed the \"share\" parameter to the window creation.\nThis fixed it:\n```Java\n...\n        long share = 0;\n    for (int i = 0; i < windows.length; i++) {\n        int windowIndex = i + 1;\n\n        long handle = glfwCreateWindow(300, 300, \"GLFW Demo - \" + windowIndex, NULL, share);\n        if (handle == NULL) {\n            throw new IllegalStateException(\"Failed to create GLFW window\");\n        }\n\n        if (i == 0) {\n            share = handle;\n        }\n\n...\n```\nThanks for your help!. Now I tried doing the exact same but multi-threaded and it worked in a way. So if I want to create a new window after all the other windows/threads have already started I get an Exception:\nJava\n[LWJGL] GLFW_VERSION_UNAVAILABLE error\n    Description : WGL: Failed to create OpenGL context\n    Stacktrace  :\n        org.lwjgl.glfw.GLFW.nglfwCreateWindow(GLFW.java:1491)\n        org.lwjgl.glfw.GLFW.glfwCreateWindow(GLFW.java:1655)\n        MultipleWindows.createNewThread(MultipleWindows.java:448)\n        MultipleWindows.demo(MultipleWindows.java:519)\n        MultipleWindows.main(MultipleWindows.java:546)\nException in thread \"main\" java.lang.IllegalStateException: Failed to create GLFW window\n    at MultipleWindows.createNewThread(MultipleWindows.java:450)\n    at MultipleWindows.demo(MultipleWindows.java:519)\n    at MultipleWindows.main(MultipleWindows.java:546)\nCode: \n```Java\nimport static org.lwjgl.glfw.GLFW.*;\nimport static org.lwjgl.opengl.GL11.GL_COLOR_BUFFER_BIT;\nimport static org.lwjgl.opengl.GL11.GL_DEPTH_BUFFER_BIT;\nimport static org.lwjgl.opengl.GL11.glClear;\nimport static org.lwjgl.opengl.GL11.glClearColor;\nimport static org.lwjgl.system.MemoryUtil.NULL;\nimport java.nio.FloatBuffer;\nimport java.nio.IntBuffer;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\nimport org.lwjgl.BufferUtils;\nimport org.lwjgl.glfw.Callbacks;\nimport org.lwjgl.glfw.GLFWErrorCallback;\nimport org.lwjgl.glfw.GLFWKeyCallbackI;\nimport org.lwjgl.opengl.GL;\nimport org.lwjgl.opengl.GL11;\nimport org.lwjgl.opengl.GL15;\nimport org.lwjgl.opengl.GL20;\nimport org.lwjgl.opengl.GL30;\nimport org.lwjgl.opengl.GLCapabilities;\n/* GLFW demo that showcases rendering to multiple windows from a single thread. /\npublic final class MultipleWindows {\npublic static class Model {\n\n    private final Vao vao;\n\n    public Model(Vao vao) {\n        this.vao = vao;\n    }\n\n    public void delete() {\n        vao.delete();\n    }\n\n    public void deleteForContext() {\n        vao.deleteForContext();\n    }\n\n    public Vao getVao() {\n        return vao;\n    }\n\n}\n\npublic static class ModelData {\n\n    private static final int DIMENSIONS = 3;\n\n    private float[] vertices;\n    private float[] textureCoords;\n    private float[] normals;\n    private int[] indices;\n    private float furthestPoint;\n\n    public ModelData(float[] vertices, float[] textureCoords, float[] normals, int[] indices, float furthestPoint) {\n        this.vertices = vertices;\n        this.textureCoords = textureCoords;\n        this.normals = normals;\n        this.indices = indices;\n        this.furthestPoint = furthestPoint;\n    }\n\n    public float getFurthestPoint() {\n        return furthestPoint;\n    }\n\n    public int[] getIndices() {\n        return indices;\n    }\n\n    public float[] getNormals() {\n        return normals;\n    }\n\n    public float[] getTextureCoords() {\n        return textureCoords;\n    }\n\n    public int getVertexCount() {\n        return vertices.length / DIMENSIONS;\n    }\n\n    public float[] getVertices() {\n        return vertices;\n    }\n\n}\n\npublic static class ModelLoader {\n\n    protected Model loadModel() {\n        ModelData data = new ModelData(vertices, textureCoords, normals, indices, furthestPoint); // OBJFileLoader.loadOBJ(modelFile);\n\n        Vao vao = Vao.create();\n        vao.bind();\n        vao.createIndexBuffer(data.getIndices());\n        vao.createAttribute(0, data.getVertices(), 3);\n        vao.createAttribute(1, data.getTextureCoords(), 2);\n        vao.createAttribute(2, data.getNormals(), 3);\n        vao.unbind();\n        return new Model(vao);\n    }\n\n}\n\npublic static class RenderThread extends Thread {\n\n    public final Window window;\n\n    public boolean isFinished = false;\n\n    public RenderThread(Window window) {\n        this.window = window;\n    }\n\n    @Override\n    public void run() {\n        glfwMakeContextCurrent(window.handle);\n        window.capabilities = GL.createCapabilities();\n\n        if (window.windowID == 0) { // Load Model only once, but I need a GL context\n            staticmodel = new ModelLoader().loadModel();\n        } else {\n            while (staticmodel == null) {\n                try {\n                    Thread.sleep(10L);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        glClearColor((window.windowID & 1), (window.windowID >> 1), (window.windowID == 1) ? 0.f : 1.f, 0.f);\n\n        glfwSwapInterval(1);\n\n        while (!glfwWindowShouldClose(window.handle)) {\n            render(); // If it works, a white little Mushroom appears\n\n            glfwSwapBuffers(window.handle);\n        }\n\n        int i = latch.getAndDecrement();\n        if (i == 1) {\n            staticmodel.delete();\n            System.out.println(\"Complete delete by \" + window.windowID);\n        } else {\n            staticmodel.deleteForContext();\n            System.out.println(\"Partly delete by \" + window.windowID);\n        }\n\n        isFinished = true;\n        glfwPostEmptyEvent();\n    }\n\n}\n\npublic static class Vao {\n\n    private static final int BYTES_PER_FLOAT = 4;\n\n    public static Vao create() {\n        int id = GL30.glGenVertexArrays();\n        return new Vao(id);\n    }\n\n    private final HashMap<GLCapabilities, Integer> loadedcontexts = new HashMap<>();\n\n    private final List<VaoAttribute> attributes = new LinkedList<>();\n\n    private final List<Vbo> dataVbos = new ArrayList<Vbo>();\n    private Vbo indexVbo;\n\n    private int indexCount;\n\n    private Vao(int id) {\n        loadedcontexts.put(GL.getCapabilities(), id);\n    }\n\n    private void bind() {\n        if (!loadedcontexts.containsKey(GL.getCapabilities())) {\n            recreateAndBind();\n        } else {\n            GL30.glBindVertexArray(loadedcontexts.get(GL.getCapabilities()));\n        }\n    }\n\n    public void bind(int... attributes) {\n        bind();\n        indexVbo.bind();\n        for (int i : attributes) {\n            GL20.glEnableVertexAttribArray(i);\n        }\n    }\n\n    public void createAttribute(int attribute, float[] data, int attrSize) {\n        Vbo dataVbo = Vbo.create(GL15.GL_ARRAY_BUFFER);\n        dataVbo.bind();\n        dataVbo.storeData(data);\n        attributes.add(new VaoAttribute(dataVbo, attribute, attrSize));\n        GL20.glVertexAttribPointer(attribute, attrSize, GL11.GL_FLOAT, false, attrSize * BYTES_PER_FLOAT, 0);\n        dataVbo.unbind();\n        dataVbos.add(dataVbo);\n    }\n\n    public void createIndexBuffer(int[] indices) {\n        indexVbo = Vbo.create(GL15.GL_ELEMENT_ARRAY_BUFFER);\n        indexVbo.bind();\n        indexVbo.storeData(indices);\n        indexCount = indices.length;\n    }\n\n    public void createIntAttribute(int attribute, int[] data, int attrSize) {\n        Vbo dataVbo = Vbo.create(GL15.GL_ARRAY_BUFFER);\n        dataVbo.bind();\n        dataVbo.storeData(data);\n        attributes.add(new VaoAttributeI(dataVbo, attribute, attrSize));\n        GL30.glVertexAttribIPointer(attribute, attrSize, GL11.GL_INT, attrSize * BYTES_PER_FLOAT, 0);\n        dataVbo.unbind();\n        dataVbos.add(dataVbo);\n    }\n\n    public void delete() {\n        int id = loadedcontexts.get(GL.getCapabilities());\n        GL30.glDeleteVertexArrays(id);\n        loadedcontexts.remove(GL.getCapabilities());\n        if (loadedcontexts.size() > 0) {\n            try {\n                throw new IllegalStateException(\n                        \"[WARNING] VAO's VBOs were completely deleted (by VAO ID: \" + id + \") but other contexts have still VAOs available that have reference on the VBOs. This maybe causes a crash.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        for (Vbo vbo : dataVbos) {\n            vbo.delete();\n        }\n        indexVbo.delete();\n    }\n\n    public void deleteForContext() {\n        GL30.glDeleteVertexArrays(loadedcontexts.get(GL.getCapabilities()));\n        loadedcontexts.remove(GL.getCapabilities());\n    }\n\n    public int getIndexCount() {\n        return indexCount;\n    }\n\n    private void recreateAndBind() {\n        int id = GL30.glGenVertexArrays();\n        loadedcontexts.put(GL.getCapabilities(), id);\n        GL30.glBindVertexArray(id);\n        for (VaoAttribute b : attributes) {\n            if (b instanceof VaoAttribute) {\n                VaoAttribute attrib = b;\n                attrib.getVbo().bind();\n                if (attrib instanceof VaoAttributeI) {\n                    GL30.glVertexAttribIPointer(attrib.getAttribute(), attrib.getAttrSize(), GL11.GL_INT, attrib.getAttrSize() * BYTES_PER_FLOAT, 0);\n                } else {\n                    GL20.glVertexAttribPointer(attrib.getAttribute(), attrib.getAttrSize(), GL11.GL_FLOAT, false, attrib.getAttrSize() * BYTES_PER_FLOAT, 0);\n                }\n                attrib.getVbo().unbind();\n            }\n        }\n    }\n\n    private void unbind() {\n        GL30.glBindVertexArray(0);\n    }\n\n    public void unbind(int... attributes) {\n        for (int i : attributes) {\n            GL20.glDisableVertexAttribArray(i);\n        }\n        unbind();\n        indexVbo.unbind();\n    }\n\n}\n\npublic static class VaoAttribute {\n\n    private final int attribute;\n    private final int attrSize;\n    private final Vbo vbo;\n\n    public VaoAttribute(Vbo vbo, int attribute, int attrSize) {\n        this.vbo = vbo;\n        this.attribute = attribute;\n        this.attrSize = attrSize;\n    }\n\n    public int getAttribute() {\n        return attribute;\n    }\n\n    public int getAttrSize() {\n        return attrSize;\n    }\n\n    public Vbo getVbo() {\n        return vbo;\n    }\n\n}\n\npublic static class VaoAttributeI extends VaoAttribute {\n\n    public VaoAttributeI(Vbo vbo, int attribute, int attrSize) {\n        super(vbo, attribute, attrSize);\n    }\n\n}\n\npublic static class Vbo {\n\n    public static Vbo create(int type) {\n        int id = GL15.glGenBuffers();\n        return new Vbo(id, type);\n    }\n\n    private final int vboId;\n\n    private final int type;\n\n    private Vbo(int vboId, int type) {\n        this.vboId = vboId;\n        this.type = type;\n    }\n\n    public void bind() {\n        GL15.glBindBuffer(type, vboId);\n    }\n\n    public void delete() {\n        GL15.glDeleteBuffers(vboId);\n    }\n\n    public void storeData(float[] data) {\n        FloatBuffer buffer = BufferUtils.createFloatBuffer(data.length);\n        buffer.put(data);\n        buffer.flip();\n        storeData(buffer);\n    }\n\n    public void storeData(FloatBuffer data) {\n        GL15.glBufferData(type, data, GL15.GL_STATIC_DRAW);\n    }\n\n    public void storeData(int[] data) {\n        IntBuffer buffer = BufferUtils.createIntBuffer(data.length);\n        buffer.put(data);\n        buffer.flip();\n        storeData(buffer);\n    }\n\n    public void storeData(IntBuffer data) {\n        GL15.glBufferData(type, data, GL15.GL_STATIC_DRAW);\n    }\n\n    public void unbind() {\n        GL15.glBindBuffer(type, 0);\n    }\n\n}\n\nprivate static class Window {\n    final long handle;\n\n    final int windowID;\n\n    GLCapabilities capabilities;\n\n    Window(long handle, int windowID) {\n        this.handle = handle;\n        this.windowID = windowID;\n    }\n}\n\npublic static int[] indices = new int[] {0, 1, 2, 3, 4, 5, 4, 6, 7, 8, 0, 9, 1, 3, 2, 6, 49, 7, 2, 5, 10, 7, 50, 11, 12, 2, 13, 5, 14, 15, 14, 7, 11, 9, 12, 16, 17, 16, 18, 13, 10, 19, 11, 51, 20, 16, 13,\n        18, 10, 15, 21, 15, 11, 21, 52, 22, 23, 53, 24, 25, 24, 52, 26, 54, 53, 25, 27, 23, 28, 29, 30, 31, 25, 26, 32, 23, 55, 33, 30, 25, 31, 26, 27, 28, 56, 57, 34, 57, 58, 35, 36, 59, 37, 38, 56, 34,\n        58, 60, 35, 59, 38, 39, 34, 40, 41, 40, 35, 42, 37, 43, 44, 39, 34, 45, 35, 61, 46, 43, 39, 47, 41, 42, 48, 42, 46, 48, 44, 47, 48, 45, 41, 48, 46, 62, 48, 47, 45, 48, 63, 54, 29, 22, 64, 23, 12, 0,\n        2, 4, 14, 5, 14, 4, 7, 0, 12, 9, 3, 5, 2, 49, 50, 7, 13, 2, 10, 50, 51, 11, 16, 12, 13, 10, 5, 15, 15, 14, 11, 17, 9, 16, 65, 17, 18, 10, 66, 19, 67, 11, 20, 13, 19, 18, 66, 10, 21, 11, 67, 21, 27,\n        52, 23, 24, 26, 25, 52, 27, 26, 30, 54, 25, 23, 33, 28, 68, 29, 31, 69, 25, 32, 55, 70, 33, 25, 69, 31, 32, 26, 28, 57, 40, 34, 40, 57, 35, 59, 43, 37, 39, 38, 34, 60, 61, 35, 43, 59, 39, 40, 42,\n        41, 35, 46, 42, 43, 47, 44, 34, 41, 45, 61, 62, 46, 39, 45, 47, 54, 30, 29, 64, 55, 23};\n\npublic static float[] normals = new float[] {-0.8921F, -0.4426F, 0.0906F, -0.3677F, -0.4426F, 0.8179F, -0.4099F, -0.0221F, 0.9119F, 0.5245F, -0.4427F, 0.7273F, 0.8921F, -0.4427F, -0.0906F, 0.5848F,\n        -0.0221F, 0.8109F, 0.3676F, -0.4427F, -0.8179F, 0.4098F, -0.0221F, -0.9119F, -0.5245F, -0.4427F, -0.7273F, -0.5848F, -0.0221F, -0.8109F, 0.5616F, 0.2793F, 0.7788F, 0.3937F, 0.2793F, -0.8758F,\n        -0.9946F, -0.0221F, 0.101F, -0.3937F, 0.2793F, 0.8758F, 0.9946F, -0.0221F, -0.101F, 0.9553F, 0.2793F, -0.097F, -0.9553F, 0.2793F, 0.097F, -0.5617F, 0.2793F, -0.7788F, -0.7455F, -0.6622F, 0.0757F,\n        -0.3072F, -0.6622F, 0.6835F, -0.4383F, -0.6622F, -0.6077F, 0.7455F, -0.6622F, -0.0757F, 0.3072F, -0.6622F, -0.6835F, 0.305F, -0.6682F, -0.6786F, 0.4383F, -0.6622F, 0.6078F, -0.305F, -0.6682F,\n        0.6786F, 0.4352F, -0.6682F, 0.6034F, 0.7402F, -0.6682F, -0.0752F, 0.993F, 0.0608F, -0.1008F, -0.4352F, -0.6682F, -0.6035F, -0.7402F, -0.6682F, 0.0751F, -0.993F, 0.0607F, 0.1008F, 0.5838F, 0.0608F,\n        0.8096F, 0.4092F, 0.0608F, -0.9104F, 0.4523F, 0.6342F, 0.6271F, 0.317F, 0.6342F, -0.7052F, -0.5838F, 0.0608F, -0.8096F, -0.4522F, 0.6342F, -0.6271F, -0.4092F, 0.0608F, 0.9104F, -0.317F, 0.6342F,\n        0.7052F, 0.7692F, 0.6342F, -0.0781F, 0.2882F, 0.8702F, 0.3996F, 0.4901F, 0.8702F, -0.0498F, -0.7692F, 0.6342F, 0.0781F, -0.2882F, 0.8702F, -0.3996F, -0.202F, 0.8702F, 0.4493F, 0.202F, 0.8702F,\n        -0.4493F, -0.4901F, 0.8702F, 0.0498F, -0.0F, 1.0F, -0.0F, -0.5245F, -0.4427F, -0.7273F, -0.5848F, -0.0221F, -0.8109F, -0.5617F, 0.2793F, -0.7788F, 0.7455F, -0.6622F, -0.0757F, -0.3072F, -0.6622F,\n        0.6835F, -0.7455F, -0.6622F, 0.0757F, -0.4352F, -0.6682F, -0.6035F, 0.5838F, 0.0608F, 0.8096F, 0.993F, 0.0608F, -0.1008F, 0.4092F, 0.0608F, -0.9104F, -0.993F, 0.0607F, 0.1008F, -0.5838F, 0.0608F,\n        -0.8096F, -0.4522F, 0.6342F, -0.6271F, -0.2882F, 0.8702F, -0.3996F, -0.4383F, -0.6622F, -0.6077F, -0.4383F, -0.6622F, -0.6077F, -0.4383F, -0.6622F, -0.6077F, 0.4383F, -0.6622F, 0.6078F, 0.3072F,\n        -0.6622F, -0.6835F, -0.5838F, 0.0608F, -0.8096F, -0.4092F, 0.0608F, 0.9104F, -0.5838F, 0.0608F, -0.8096F};\n\npublic static float[] textureCoords = new float[] {0.0989F, 0.26380002F, 0.1583F, 0.26599997F, 0.1595F, 0.21200001F, 0.2191F, 0.26819998F, 0.2816F, 0.26880002F, 0.2193F, 0.21270001F, 0.3463F, 0.26810002F,\n        0.3445F, 0.2058F, 0.0395F, 0.2697F, 0.0214F, 0.21039999F, 0.2187F, 0.1437F, 0.333F, 0.13559997F, 0.0979F, 0.21069998F, 0.1624F, 0.1419F, 0.2801F, 0.21109998F, 0.2753F, 0.1419F, 0.1051F, 0.13599998F,\n        0.0457F, 0.12449998F, 0.1237F, 0.023400009F, 0.1707F, 0.029699981F, 0.3574F, 0.011900008F, 0.2644F, 0.030099988F, 0.8322F, 0.22060001F, 0.9453F, 0.24220002F, 0.8033F, 0.16930002F, 0.7106F, 0.0776F,\n        0.8263F, 0.058499992F, 0.9223F, 0.12589997F, 0.954F, 0.10750002F, 0.6593F, 0.3121F, 0.641F, 0.17500001F, 0.6035F, 0.16390002F, 0.8364F, 0.023100019F, 0.9807F, 0.24940002F, 0.4759F, 0.875F, 0.7583F,\n        0.58790004F, 0.2198F, 0.2909F, 0.3105F, 0.35869998F, 0.1956F, 0.8532F, 0.2824F, 0.7832F, 0.6768F, 0.7954F, 0.4809F, 0.7513F, 0.5876F, 0.70640004F, 0.2127F, 0.57739997F, 0.4095F, 0.4731F, 0.3766F,\n        0.70239997F, 0.6271F, 0.5925F, 0.3415F, 0.58889997F, 0.4836F, 0.61109996F, 0.4153F, 0.2697F, 0.4254F, 0.19639999F, 0.3904F, 0.121200025F, 0.8282F, 0.18910003F, 0.7717F, 0.17259997F, 0.7517F,\n        0.19749999F, 0.877F, 0.36009997F, 0.4663F, 0.9874F, 0.7537F, 0.8809F, 0.8779F, 0.5925F, 0.103F, 0.5694F, 0.7631F, 0.28210002F, 0.6593F, 0.356F, 0.5612F, 0.4753F, 0.7581F, 0.22909999F, 0.8125F,\n        0.24620003F, 0.0771F, 0.012700021F, 0.2177F, 0.032000005F, 0.3107F, 0.023599982F, 0.6188F, 0.3244F, 0.6926F, 0.045000017F, 0.9061F, 0.384F};\n\npublic static float[] vertices = new float[] {-0.144087F, -0.034334F, 0.008855F, -0.130818F, -0.034334F, 0.027257F, -0.136179F, -0.007832F, 0.039189F, -0.108244F, -0.034334F, 0.024965F, -0.098942F,\n        -0.034334F, 0.004271F, -0.100592F, -0.007832F, 0.035577F, -0.112215F, -0.034334F, -0.014131F, -0.106852F, -0.007832F, -0.026064F, -0.134787F, -0.034334F, -0.011838F, -0.142439F, -0.007832F,\n        -0.022451F, -0.108244F, 0.022372F, 0.024966F, -0.112214F, 0.022372F, -0.014131F, -0.157103F, -0.007832F, 0.010176F, -0.130818F, 0.022372F, 0.027258F, -0.085926F, -0.007832F, 0.00295F, -0.098942F,\n        0.022372F, 0.004272F, -0.144087F, 0.022372F, 0.008856F, -0.134787F, 0.022372F, -0.01184F, -0.139845F, 0.054427F, 0.008425F, -0.129069F, 0.054427F, 0.023367F, -0.132292F, 0.054427F, -0.00838F,\n        -0.103186F, 0.054427F, 0.004702F, -0.113963F, 0.054427F, -0.010241F, -0.085061F, 0.075747F, -0.074545F, -0.110739F, 0.054427F, 0.021507F, -0.157971F, 0.075747F, 0.087672F, -0.0695F, 0.075747F,\n        0.078688F, -0.033045F, 0.075747F, -0.00242F, -0.024521F, 0.097956F, -0.003285F, -0.173529F, 0.075747F, -0.065562F, -0.209984F, 0.075747F, 0.015545F, -0.218512F, 0.097956F, 0.016411F, -0.06449F,\n        0.097956F, 0.085639F, -0.081547F, 0.097956F, -0.082361F, -0.074837F, 0.129936F, 0.071291F, -0.088799F, 0.129936F, -0.066225F, -0.178542F, 0.097956F, -0.072513F, -0.168194F, 0.129936F, -0.058164F,\n        -0.161484F, 0.097956F, 0.095488F, -0.154232F, 0.129936F, 0.079353F, -0.04212F, 0.129936F, -0.001498F, -0.096669F, 0.156142F, 0.041016F, -0.079256F, 0.156142F, 0.002273F, -0.200911F, 0.129936F,\n        0.014624F, -0.146361F, 0.156142F, -0.027889F, -0.13893F, 0.156142F, 0.045307F, -0.104102F, 0.156142F, -0.032181F, -0.163775F, 0.156142F, 0.010854F, -0.121516F, 0.171244F, 0.006563F, -0.134787F,\n        -0.034334F, -0.011838F, -0.142439F, -0.007832F, -0.022451F, -0.134787F, 0.022372F, -0.01184F, -0.103186F, 0.054427F, 0.004702F, -0.129069F, 0.054427F, 0.023367F, -0.139845F, 0.054427F, 0.008425F,\n        -0.173529F, 0.075747F, -0.065562F, -0.06449F, 0.097956F, 0.085639F, -0.024521F, 0.097956F, -0.003285F, -0.081547F, 0.097956F, -0.082361F, -0.218512F, 0.097956F, 0.016411F, -0.178542F, 0.097956F,\n        -0.072513F, -0.168194F, 0.129936F, -0.058164F, -0.146361F, 0.156142F, -0.027889F, -0.132292F, 0.054427F, -0.00838F, -0.132292F, 0.054427F, -0.00838F, -0.132292F, 0.054427F, -0.00838F, -0.110739F,\n        0.054427F, 0.021507F, -0.113963F, 0.054427F, -0.010241F, -0.178542F, 0.097956F, -0.072513F, -0.161484F, 0.097956F, 0.095488F, -0.178542F, 0.097956F, -0.072513F};\n\npublic static float furthestPoint = 0.2400254F;\n\npublic static Model staticmodel = null;\n\npublic static AtomicInteger latch;\n\npublic static List<RenderThread> threads = new ArrayList<>();\n\npublic static boolean createNewThread = false;\n\npublic static int windowIndex = 0;\n\npublic static long share = 0;\n\nprivate static RenderThread createNewThread() {\n    long handle = glfwCreateWindow(300, 300, \"GLFW Demo - \" + windowIndex, NULL, share);\n    if (handle == NULL) {\n        throw new IllegalStateException(\"Failed to create GLFW window\");\n    }\n\n    if (windowIndex == 0) {\n        share = handle;\n    }\n\n    Window window = new Window(handle, windowIndex);\n\n    glfwSetKeyCallback(handle, new GLFWKeyCallbackI() {\n        @Override\n        public void invoke(long windowHnd, int key, int scancode, int action, int mods) {\n            if (key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE) {\n                threads.forEach(new Consumer<RenderThread>() {\n                    @Override\n                    public void accept(RenderThread w) {\n                        glfwSetWindowShouldClose(w.window.handle, true);\n                    }\n                });\n            } else if (key == GLFW_KEY_N && action == GLFW_RELEASE) {\n                createNewThread = true;\n            }\n        }\n    });\n\n    glfwSetWindowPos(handle, 100 + (windowIndex & 1) * 400, 100 + (windowIndex >> 1) * 400);\n    glfwShowWindow(handle);\n\n    windowIndex++;\n    RenderThread ret = new RenderThread(window);\n    threads.add(ret);\n    latch.incrementAndGet();\n\n    return ret;\n}\n\nprivate static void demo() {\n    glfwDefaultWindowHints();\n    glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n\n    latch = new AtomicInteger(threads.size());\n\n    for (int i = 0; i < 3; i++) {\n        createNewThread();\n    }\n\n    for (RenderThread thread : threads) { // I have to do start them after all windows have been created. Otherwise window creation will throw an Exception\n        thread.start();\n    }\n\n    while (latch.get() != 0) {\n\n        glfwWaitEvents();\n\n        Iterator<RenderThread> itera = threads.iterator();\n        while (itera.hasNext()) {\n            RenderThread thread = itera.next();\n            if (thread == null) {\n                continue;\n            }\n            if (thread.isFinished) {\n                Callbacks.glfwFreeCallbacks(thread.window.handle);\n                glfwDestroyWindow(thread.window.handle);\n\n                itera.remove();\n            }\n        }\n\n        if (createNewThread) {\n            createNewThread = false;\n\n            createNewThread() // Throws Exception, because it creates a window after the other threads have started. But what is the reason for this?\n                    .start();\n        }\n    }\n\n    Iterator<RenderThread> itera = threads.iterator();\n    while (itera.hasNext()) {\n        RenderThread thread = itera.next();\n        if (thread == null) {\n            continue;\n        }\n        if (thread.isFinished) {\n            Callbacks.glfwFreeCallbacks(thread.window.handle);\n            glfwDestroyWindow(thread.window.handle);\n\n            itera.remove();\n        }\n    }\n}\n\npublic static void main(String[] args) {\n    GLFWErrorCallback errorfun = GLFWErrorCallback.createPrint();\n    glfwSetErrorCallback(errorfun);\n    if (!glfwInit()) {\n        throw new IllegalStateException(\"Failed to initialize GLFW.\");\n    }\n\n    try {\n        demo();\n    } finally {\n        glfwTerminate();\n        glfwSetErrorCallback(null).free();\n    }\n}\n\nprivate static void render() {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    GL11.glDisable(GL11.GL_BLEND);\n    GL11.glEnable(GL11.GL_DEPTH_TEST);\n\n    Vao model = staticmodel.getVao();\n    model.bind(0, 1, 2);\n    GL11.glDrawElements(GL11.GL_TRIANGLES, model.getIndexCount(), GL11.GL_UNSIGNED_INT, 0);\n    model.unbind(0, 1, 2);\n}\n\nprivate MultipleWindows() {\n}\n\n}\n```\nCan you tell me what I have to do to create a new window/thread after the initial ones?. Must only the context to share with not current in any other thread? Or must all other contexts that already share resources with the context to share also not current in any other thread?\n(Perhaps it is confusing, sorry for that). Thanks. I got that working.\nAn other question maybe you are more experienced: Is it usefull/worth to use multiple threads to render on ONE single context/window?\nBecause I use only one thread for one context/window and this single thread get my CPU only up to 30% usage and my GPU up to 50% usage, but I want to use 100% GPU and the single thread can not run faster (I think).. I thaught that uses only 30% CPU because the while cant run faster, for example if I make a simple \nJava\nwhile (true) {}\nit only uses 30% CPU. So how can then Vulkan or other APIs be faster? I have also to call them render and show it to the display, right?. If  I run that while loop I can see that my 4 CPU cores are sharing the work. Why cant they run all at full speed? I would more understand it if one single core would use 100%.. ",
    "dotSp0T": "Sweet! I assumed the doc to be generated and didn't really look for the generator code...\nIf you can link me to it I'll go through it and make sure deprecated methods link to the correct doc/spec versions? (making a pullrequest for it in the end). Thank you for the tip with the MemoryUtil. I've spent some time going over the whole thing again before digging into it and I realized that there is a similar stumbling stone with stbtt_packedchar only providing read, but no write-access.\nAs the intializing of the STBTTPackedchar.Buffer is performed within the stbtt_packFontRanges(...) method I need to rewrite, I need not only read-, but also write-access. I am looking if I can do it with the MemoryUtil as well for now.\n\nbelow is the code of the original method and markers to where you can add additional glyphs and stuff with the least effort, for anyone interested/doing the same and struggling as well (//> comments):\n```\nSTBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context spc, const unsigned char fontdata, int font_index, stbtt_pack_range ranges, int num_ranges)\n{\n   stbtt_fontinfo info;\n   int i,j,n, return_value = 1;\n   //stbrp_context context = (stbrp_context ) spc->pack_info;\n   stbrp_rect    rects;\n// flag all characters as NOT packed\n   for (i=0; i < num_ranges; ++i)\n      for (j=0; j < ranges[i].num_chars; ++j)\n         ranges[i].chardata_for_range[j].x0 =\n         ranges[i].chardata_for_range[j].y0 =\n         ranges[i].chardata_for_range[j].x1 =\n         ranges[i].chardata_for_range[j].y1 = 0;\nn = 0;\n   for (i=0; i < num_ranges; ++i)\n      n += ranges[i].num_chars;\nrects = (stbrp_rect ) STBTT_malloc(sizeof(rects) * n, spc->user_allocator_context);\n   if (rects == NULL)\n      return 0;\ninfo.userdata = spc->user_allocator_context;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));\nn = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);\n//> PACK additional rects (see method above) with the glyphs or other things\nstbtt_PackFontRangesPackRects(spc, rects, n);\nreturn_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);\n//> RENDER your additional rects the way you want them to, if it's only glyphs you can almost copy the above method\nSTBTT_free(rects, spc->user_allocator_context);\n   return return_value;\n}\n```. Hey @Spasi , thank you for your help in this!\nAfter playing around with the code I managed to do what I want by abusing the nature of Unicode Codepoints instead, allowing me to not having to rewrite any-much logic at all which was very nice.\nRight now though I am working on making the packer render SDF-bitmaps instead of regular ones into the eventual texture. For that I need to replace stbtt_PackFontRangesRenderIntoRects(...) with my own code that either uses the provided SDF method(s) or a custom implementation (doesn't really matter at this stage).\nCurrently I reproduce the above mentioned method to make sure it works properly and thus need read access to the stbtt_pack_range struct. Currently solving it with the MemoryUtil again.\nCheers. Should probably just have written that there are some members on that struct that are not public visible yet (h_oversample, v_oversample) which are used in the code I am replicating. They can easily be accessed using the MemoryUtil so it's probably just convenience. I know these are no public API functions, but when modifying the behaviour on the java side access to the stbtt__* functions would be neat (such as stbtt__h_prefilter(...). This would allow reusing code instead of writing it oneself. Although it's again just some convenience, no real blocker. > That's a ton of internal, mostly simple, functions. I would consider exposing a subset of those, if you could post a list of functions that you think would be useful and are not trivial to port to Java.\nI'll spend more time with the code and assemble a list of functions necessary to easily expand the API . ",
    "parlough": "https://github.com/LWJGL/lwjgl3/commit/fee37bac713ed9a0c14c97b9ed21accc1ee1c633. ",
    "Atry": "Sorry I misunderstood the code.. ",
    "BlakeBarnes00": "I still get the same error for when I completely go away from starting on another thread. \nHere is my recent push: https://github.com/BlakeBarnes00/Sandbox/commit/42c7571690ae3b77487c982df873aa894804ff58 it shows that I have removed the thread, and went straight to calling run(). Still getting the same error from within the inside of the function.. @sriharshachilakapati \nnew log\nmost recent commit. That was the fix! I can't believe I overlooked that this entire time. Thank you so much @sriharshachilakapati . With gameEngine.start() it works now! Funny how one number can ruin an entire program, eh?. I am still new to threading, so this did help me out a lot. Thank you so much!. ",
    "francogp": "It works for me, but I'm getting this warning when I use java 9  only:\nWARNING: An illegal reflective access operation has occurred\nWARNING: Illegal reflective access by org.lwjgl.system.MemoryAccess (file:/C:/Users/franc/.gradle/caches/modules-2/files-2.1/org.lwjgl/lwjgl/3.1.0/fae7a04425666311d5dfe5ef7d89021ca0308d8d/lwjgl-3.1.0.jar) to field java.nio.Buffer.address\nWARNING: Please consider reporting this to the maintainers of org.lwjgl.system.MemoryAccess\nWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations\nWARNING: All illegal access operations will be denied in a future release. ",
    "philipguin": "So I may be missing something here, but I'm attempting to modularize a previously working project in Eclipse Oxygen 4.7.2, with Java 9 and LWJGL 3.1.5 stable, and am receiving this message (with org.lwjgl.util.DebugLoader=true and org.lwjgl.util.Debug=true)\n[LWJGL] Version: 3.1.5 build 1\n[LWJGL]      OS: Windows 10 v10.0\n[LWJGL]     JRE: 9.0.1 amd64\n[LWJGL]     JVM: Java HotSpot(TM) 64-Bit Server VM v9.0.1+11 by Oracle Corporation\n[LWJGL] Loading library (system): lwjgl\n[LWJGL]     lwjgl.dll not found in java.library.path\n[LWJGL] Failed to load a library. Possible solutions:\n    a) Add the directory that contains the shared library to -Djava.library.path or -Dorg.lwjgl.librarypath.\n    b) Add the JAR that contains the shared library to the classpath.\nException in thread \"main\" java.lang.UnsatisfiedLinkError: Failed to locate library: lwjgl.dll\n    at org.lwjgl/org.lwjgl.system.Library.loadSystem(Library.java:146)\n    at org.lwjgl/org.lwjgl.system.Library.loadSystem(Library.java:66)\n    at org.lwjgl/org.lwjgl.system.Library.<clinit>(Library.java:49)\n    at org.lwjgl/org.lwjgl.system.MemoryAccessJNI.<clinit>(MemoryAccessJNI.java:13)\n    at org.lwjgl/org.lwjgl.system.Pointer.<clinit>(Pointer.java:22)\n    at org.lwjgl/org.lwjgl.system.Platform.mapLibraryNameBundled(Platform.java:80)\n    at org.lwjgl.glfw/org.lwjgl.glfw.GLFW.<clinit>(GLFW.java:642)\n    at phil.glfw/phil.glfw.GlfwDisplayManager.<init>(GlfwDisplayManager.java:196)\n    at cafun/main.CaMain.startApp(CaMain.java:24)\n    at cafun/main.CaMain.main(CaMain.java:16)\nGenerated command line (sanitized slightly):\njavaw.exe -Dorg.lwjgl.util.DebugLoader=true -Dorg.lwjgl.util.Debug=true -Dfile.encoding=Cp1252 -p <workspace_path>\\CellularAutomataFun\\bin;<workspace_path>\\PhilMath\\bin;<workspace_path>\\Uphilities\\bin;<libs_path>\\trove-3.1a1\\3.1a1\\output\\lib\\trove-current.jar;<workspace_path>\\GameCommon\\bin;<workspace_path>\\PhilInput\\bin;<workspace_path>\\PhilGlfwInput\\bin;<libs_path>\\lwjgl\\3.1.5\\lwjgl-glfw-natives-linux.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-glfw-natives-macos.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-glfw-natives-windows.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-glfw.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-natives-linux.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-natives-macos.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-natives-windows.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl.jar;<workspace_path>\\PhilGl\\bin;<libs_path>\\jdom\\2.0.6\\jdom.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-egl.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-opengl-natives-linux.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-opengl-natives-macos.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-opengl-natives-windows.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-opengl.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-opengles-natives-linux.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-opengles-natives-macos.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-opengles-natives-windows.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-opengles.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-stb-natives-linux.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-stb-natives-macos.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-stb-natives-windows.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-stb.jar;<libs_path>\\lwjgl\\3.1.5\\lwjgl-vulkan.jar -m cafun/main.CaMain\nBasically, imagine I have two projects, \"GameProject\" and \"LwjglProject,\" both of which are modules compiled with Java 9.  In Eclipse terminology, underneath Project Properties -> Java Build Path, LwjglProject includes the appropriate LWJGL jars on its \"Modulepath\" under \"Libraries,\" and exports all of them under \"Order and Export.\" Meanwhile, GameProject requires LwjglProject on its Modulepath under \"Projects,\" and requires the LwjglProject module in its module-info.java. Running this configuration produces the above error message, I'm guessing because LWJGL is searching whatever \"Classpath\" is funneled into rather than wherever Modulepath goes.\nThrowing everything into the Classpath isn't a great option for a number of reasons (firstly because I'd like to use jlink to create a compressed runtime image for my project, secondly because Eclipse chokes even harder when I attempt to do so (projects fail to import anything from modules placed on the classpath, weirdly), which is probably an issue on their end. Eclipse is giving me a lot of dang issues with this.)\nIf this isn't a bug an your end, then any ideas would still be greatly appreciated. Thank you!. Ahah!\nI ran with --validate-modules as you described, and discovered that the different natives jars were \"shadowing\" each other. Removing all native jars except the ones for the current system from the modulepath resolved it (though that was definitely working before modularizing things, not sure what the intended behavior actually is.)\nThanks much, never would have guessed that without that command line option.. I'll just add for anyone reading - given the difficulty of getting anything\nworking with Java 9 (e.g. Eclipse, VisualVM, ProGuard, etc), I wound up\njust falling back to Java 8, but still shipping a minimal runtime image\nwith jlink by explicitly adding the required  modules via --add-modules.\nSeems to work just fine, and saves you the massive burden of migrating and\ndealing with tools that haven't been updated yet. You just have to make\nsure you're really including every module needed, otherwise you'll get\nruntime exceptions.\nI'll also note that I had to fall back to an earlier version of LWJGL,\nbecause ProGuard would choke on the module-info.class files when\nattempting to obfuscate everything. Not really an LWJGL issue, but it's\nworth mentioning.\nOn Sat, Jan 13, 2018 at 4:08 AM, Ioannis Tsakpinis <notifications@github.com\n\nwrote:\nI tested again using --add-modules and jlink indeed adds the natives\nmodule to the image (it is listed in java --list-modules). However, the\nnatives are not resolved when the application runs. I just figured out that\nif you do java --add-modules , then it works.\nMy argument is that even though the current setup is technically correct,\nit is not very helpful. You need to worry about lwjgl3 natives when running\njlink (which is not trivial in the first place) and also when running the\noutput image.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/334#issuecomment-357423337, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AA2wNhTSCfVk2jNJj5JtyznzEgDR0juqks5tKIC5gaJpZM4PhWzF\n.\n. Any other possible workarounds for this? Just slapping LWJGL into the classpath results in a whole bunch of  imports getting \"The type XXX is not accessible,\" which isn't any better than the original issue. (It's as though sticking it on the classpath only results in nothing getting exported.)\n\nUsing Java 9, LWJGL 3.1.5 stable, Eclipse Oxygen 4.7.2.\nEDIT: Nevermind, I was doing something wonky, which was including both legacy LWJGL 2 and LWJGL 3 in one project, which resulted in a naming conflict on BufferUtils. Resolved by splitting into two separate projects.. ",
    "blobjim": "The module validation worked. I'm using the latest Eclipse Oxygen with the updated Java 9 support. However, I wasn't .still using LWJGL 3.1.3 so that's definitely my mistake. I'll try the library on the module path again and see how it goes.. Another work around option: Opening the JARs as zip archives (using 7-Zip) and copying the module-info.class from the versions folder to the root of the JARs makes them recognized by Eclipse. This doesn't seem to work for the natives, so keep those on the classpath. It is tedious but it works.\nSide note: I wonder if multi-release JAR support is lacking because IBM (main Eclipse IDE contributor) is still salty about the Java 9 module system.. ",
    "kevsters": "Can you explain what you did to get around this?  I tried to add the JARS to the classpath, but I think I might have done it wrong, because the error message is still there.. nvr mind I got it.  Wasn't adding it to the classpath through eclipse.. ",
    "otoomey": "That makes much more sense.. ",
    "asood123": "Updated the first link. Our automated script picks up the default repo name and I thought it would make more sense to use the general name. We can change it easily. It looks like @Spasi signed up for Open Collective.. ",
    "hc-codersatlas": "https://cs.chromium.org/chromium/src/third_party/zlib/ also has a zlib fork that has x86 and arm patches. Might be a better alternative (since Cloudflare's is a few versions behind).. ",
    "LunarWatcher": "ANDROID_SDK_HOME is set, it points to the root where the NDK is installed in the default install location.  The NDK was used in the first place, my attempt on using a downloaded inttypes.h file was an attempt to get it to work. With or without the NDK, it doesn't compile.\nI have done about 5 re-clones by now, and every single time it fails to build with some kind of error. After pushing through errors with retrolambda missing, jdk tools missing and a bunch of other errors I get to this, which I can't get past because it doesn't exist and can't be used any more. The SDK home is set, Java home is set, running the ant build still fails. Using the NDK archive I manually downloaded the previous NDK version (r15c). It's transferring into the NDK-bundle folder right now, I'll post again if I can get it to work with a different version. I'm going to try the previous three versions until I either get through all or find one that works. Using r15c works perfectly, it compiles now. Some of the other issues I had were related to sloppy environment variable setting cough\nRevision 16 breaks the build, probably due to the unified headers you mentioned. . ",
    "Jochen0x90h": "I found a solution. Before GL.createCapabilities(), to use eglGetProcAddress instead of glXGetProcAddress as function provider I do\nConfiguration.OPENGL_EXPLICIT_INIT.set(true);\n        GL.create(EGL.getFunctionProvider());. ",
    "erikmartinessanches": "It was a problem related to my configuration of Gradle and the application plugin. The solution is to put the arguments in the build.grade directly, instead of run configuration:\napplicationDefaultJvmArgs = [\"-XstartOnFirstThread\"].\n",
    "elusivellama": "Regarding the dependency, I'm brand new to LWJGL and these APIs in general so hopefully this isn't a silly idea. But from the docs for public static long glfwCreateWindow(..., we see that it  Creates a window and its associated OpenGL or OpenGL ES context. and yet glfw somehow isn't dependent on opengl? It seems to me this is because all OpenGL related things are internal to native GLFW and only exposed as pointers (if at all)? So could this approach be used for GLFWVulkan, replacing occurrences of the Java object org.lwjgl.vulkan.VkInstance with the long typed native handle that it wraps?\n\nEdit: Upon investigation, VkInstance extends DispatchableHandleInstance extends Pointer.Default which is part of org.lwjgl.system so shouldn't GLFWVulkan simply use Pointer.Default instead of VkInstance (and similar for the other vulkan dependent types)?\n\nRegarding the Eclipse error, does module-info.java affect libraries configured on the classpath (not modulepath)? My Eclipse 'User Library' also has each listed jar file identified as Is not modular - non modifiable. Not sure if this is relevant though.. Somewhat unrelated, but I'm noticing that there's also a number of @NativeType annotations missing throughout the GLFWVulkan source, is this sort of thing considered a bug?. requires static looks awesome, I had no idea that feature existed until just now.\n@TheMrMilchmann I'll go ahead and put in an Eclipse bug report then.\n@Spasi Regarding @NativeType, I didn't mean anything about it being a dependency. Its presence just seems to be inconsistent, for example the first argument of the functions at lines 156 and 193; not sure if this happens anywhere else in the code. Sorry for going off topic, I can open a separate issue if you'd like.\nL156\n@NativeType(\"GLFWvkproc *\")\npublic static long glfwGetInstanceProcAddress(@Nullable VkInstance instance, @NativeType(\"const char *\") ByteBuffer procname) {\n...\nL193\n@NativeType(\"GLFWvkproc *\")\npublic static long glfwGetInstanceProcAddress(@Nullable @NativeType(\"VkInstance\") VkInstance instance, @NativeType(\"const char *\") CharSequence procname) {\n.... ",
    "shathor": "Can you also generate Kotlin sources?. ",
    "ThePerkinrex": "Yes, maybe it is IntelliJ idea?. @sriharshachilakapati Just tried to recreate it and I couldn't. Only removed another Class with a main() method (I thought it wouldn't be a problem as it wasn't running but obviusly I was wrong). ",
    "GingerGeek": "Hi,\nI have been struggling with a glfwCreateWindow hang as well.\nI too am running my application within IntelliJ\nAfter far too much time and effort, I tracked down that macOS had a nice popup hidden away causing the hang\n\nThe glfwCreateWindow hangs until the dialogue is acknowledged.\nIn order to reproduce you have to create a fatal error which forces the JVM to abort execution. Upon the next execution of the program, the glfwCreateWindow will hang. Taking the guide as the example removing glfwMakeContextCurrent(pointer); and GL.createCapabilities(); causes glClearColor(1.0f, 0.0f, 0.0f, 0.0f); to create such an error:\nFATAL ERROR in native method: Thread[main,5,main]: No context is current or a function that is not available in the current context was called. The JVM will abort execution.\n    at org.lwjgl.opengl.GL11C.glClearColor(Native Method)\n    at org.lwjgl.opengl.GL11.glClearColor(GL11.java:1075)\n        ...\nWhen this happens macOS pops up with this dialogue:\n\nFrom my testing, clicking ignore will still cause the above behaviour where it will hang for user acknowledgement before opening the window on the next and all subsequent runs of the process - until you do something about dialogue.\nHope this helps someone!\nEDIT: To follow up, you can disable this macOS following instructions here: https://stackoverflow.com/questions/20226802/disable-the-last-time-you-opened-it-unexpectedly-quit-while-reopening-window. ",
    "void256": "Thanks for the quick answer Spasi.\nI've checked and lwjgl-3.1.6-natives-windows.jar is on the module-path in my case. I've attached the complete call at the end of this post.\nI'm using Java 9 with modules and doing\nrequires org.lwjgl.opengl.natives;\n  requires org.lwjgl.glfw.natives;\nin my module-info as described in that comment on issue #334\nI did some debugging of the loadSystem(Consumer<String> load, Consumer<String> loadLibrary, Class<?> context, String name) method in org.lwjgl.system.Library and this call URL libURL = context.getClassLoader().getResource(libName); is successful when running 3.1.5 but returns only null in 3.1.6.\nThe JavaDoc of context.getClassLoader().getResource() states:\n* Additionally, and except for the special case where the resource has a\n     * name ending with \"{@code .class}\", this method will only find resources in\n     * packages of named modules when the package is {@link Module#isOpen(String)\n     * opened} unconditionally (even if the caller of this method is in the\n     * same module as the resource). </p>\nSince \"lwjgl.dll\" is IMHO a resource in that sense and the 3.1.6 lwjgl comes with a proper module-info.class because of #334 could this eventually be the reason? The native module which is now a proper named module is not open?\nThe complete call as executed by IntelliJ looks like this:\n\"C:\\Program Files\\Java\\jdk-9.0.1\\bin\\java\"\n-Dorg.lwjgl.util.Debug=true\n\"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2017.3.4\\lib\\idea_rt.jar=50226:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2017.3.4\\bin\"\n-Dfile.encoding=UTF-8\n-p\nC:\\Users\\jensh\\IdeaProjects\\ttf-parse\\target\\classes;\nC:\\Users\\jensh\\.m2\\repository\\org\\apache\\pdfbox\\fontbox\\2.0.8\\fontbox-2.0.8.jar;\nC:\\Users\\jensh\\.m2\\repository\\commons-logging\\commons-logging\\1.2\\commons-logging-1.2.jar;\nC:\\Users\\jensh\\.m2\\repository\\com\\lessvoid\\coregl-lwjgl3\\3.0.0-SNAPSHOT\\coregl-lwjgl3-3.0.0-SNAPSHOT.jar;\nC:\\Users\\jensh\\.m2\\repository\\com\\lessvoid\\coregl\\3.0.0-SNAPSHOT\\coregl-3.0.0-SNAPSHOT.jar;\nC:\\Users\\jensh\\.m2\\repository\\com\\lessvoid\\coregl-ext\\3.0.0-SNAPSHOT\\coregl-ext-3.0.0-SNAPSHOT.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl\\3.1.6\\lwjgl-3.1.6.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-glfw\\3.1.6\\lwjgl-glfw-3.1.6.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-jemalloc\\3.1.6\\lwjgl-jemalloc-3.1.6.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-openal\\3.1.6\\lwjgl-openal-3.1.6.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-opengl\\3.1.6\\lwjgl-opengl-3.1.6.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-stb\\3.1.6\\lwjgl-stb-3.1.6.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl\\3.1.6\\lwjgl-3.1.6-natives-windows.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-glfw\\3.1.6\\lwjgl-glfw-3.1.6-natives-windows.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-jemalloc\\3.1.6\\lwjgl-jemalloc-3.1.6-natives-windows.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-openal\\3.1.6\\lwjgl-openal-3.1.6-natives-windows.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-opengl\\3.1.6\\lwjgl-opengl-3.1.6-natives-windows.jar;\nC:\\Users\\jensh\\.m2\\repository\\org\\lwjgl\\lwjgl-stb\\3.1.6\\lwjgl-stb-3.1.6-natives-windows.jar\n-m ttf.parse/ttfparse.Main\nRunning it with the option --list-modules gives this:\n...\norg.lwjgl file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl/3.1.6/lwjgl-3.1.6.jar\norg.lwjgl.glfw file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-glfw/3.1.6/lwjgl-glfw-3.1.6.jar\norg.lwjgl.glfw.natives file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-glfw/3.1.6/lwjgl-glfw-3.1.6-natives-windows.jar\norg.lwjgl.jemalloc file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-jemalloc/3.1.6/lwjgl-jemalloc-3.1.6.jar\norg.lwjgl.jemalloc.natives file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-jemalloc/3.1.6/lwjgl-jemalloc-3.1.6-natives-windows.jar\norg.lwjgl.natives file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl/3.1.6/lwjgl-3.1.6-natives-windows.jar\norg.lwjgl.openal file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-openal/3.1.6/lwjgl-openal-3.1.6.jar\norg.lwjgl.openal.natives file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-openal/3.1.6/lwjgl-openal-3.1.6-natives-windows.jar\norg.lwjgl.opengl file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-opengl/3.1.6/lwjgl-opengl-3.1.6.jar\norg.lwjgl.opengl.natives file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-opengl/3.1.6/lwjgl-opengl-3.1.6-natives-windows.jar\norg.lwjgl.stb file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-stb/3.1.6/lwjgl-stb-3.1.6.jar\norg.lwjgl.stb.natives file:///C:/Users/jensh/.m2/repository/org/lwjgl/lwjgl-stb/3.1.6/lwjgl-stb-3.1.6-natives-windows.jar\nIn both cases the *-natives-windows.jar is on the module path I would assume?\n. require org.lwjgl.natives; was missing from my module-info! \ud83e\udd26\u200d\u2642\ufe0f \ud83e\udd26\u200d\u2642\ufe0f \nSorry for the unnecessary trouble and thanks for the support Spasi!. ",
    "tbotting": "Thanks for your reply and your work on LWJGL! That's a tough question, it would be sweet to not have a lot of duplicate classes. But I can also see people not upgrading LWJGL just because they can't or don't want to fix the renaming of the classes used.. ",
    "Ealrann": "Not really :'(\nIt seems that the module-info.java of lwjgl jars are not read, and I just saw that Eclipse doesn't support multi release jars for now (https://bugs.eclipse.org/bugs/show_bug.cgi?id=509985). Maybe the problem is here?\n. I think I can't do that, because I need to use modules, and (at least in Eclipse?) modules doesn't see the jars defined in classpath.. New specific issue for this point: \nhttps://bugs.eclipse.org/bugs/show_bug.cgi?id=534624. The issue is corrected (cf the bugzilla).\nI tested with the very last JDT nightly build: the lwjgl module-info.class is correctly read.\nEclipse 2018-09_M3 will have the fix.. Oh, my bad. Thank you !. ",
    "EdvinasKilbauskas": "Thank you so much! I changed it to\nvar pixel = ByteBuffer.allocateDirect(1920*1080*4).asFloatBuffer()\nAnd now it works like a charm. I should've asked for help earlier :D. ",
    "AwfulMint": "Thanks @Spasi for the tips, and to @httpdigest to tell me this important info about small matrices, I fixed the \"bug\" :D. ",
    "Guerra24": "This is a Sets bug, GLFW has nothing to do about it. If the resize is the issue I suggest you add Java to the exclusion list until they fix it.. ",
    "CorruptComputer": "This probably isn't an issue anymore, as Microsoft has removed the sets feature entirely because of how many issues it caused.. ",
    "Jldevictoria": "@kenzierocks thanks for the quick response.\nI tried what you recommended, as well as using malloc with the appropriate size.\nHowever, it looks like the GLFWImage.Buffer object is going out of scope and being deleted as I enter the glfwSetWindowIcon(long window, Buffer images) function.\nThis is what I see as I step through the debugger:\n\n\nperhaps GLFW.java is losing access to this variable somehow?\nmaybe Java is cleaning it up too early?\n. @kenzierocks doh!  Yes. I can't believe I have been spending so much time on this and all I needed to do was move the glfeSetWindowIcon below the window creation.  Sorry to submit this silly issue!\nYou can mark this resolved or closed, I'm back on track!\n\n. ",
    "Nerogar": "\nI think I'll just remove the clSetKernelArg3x overloads. Any objections?\n\nUsing the clSetKernelArg4x overloads with 0 as the last parameter works fine.\nRemoving methods could potentially be a breaking change though.\nApart from that I don't think this would be a problem.\nMaybe add a line to the javadoc telling the user to use the clSetKernelArg4x overloads for 3 component vectors.\n. A quick search on Github shows that there are a few projects that wouldn't compile anymore after the change:\nhttps://github.com/search?l=Java&q=clSetKernelArg3f&type=Code\nConsidering those methods never worked anyway, that might not be a bad thing.. ",
    "Pokechu22": "I was worried that there might be some kind of calling issue that would make it complicated...\nI do see that JNI has a FatalError function, which logs the stacktrace and a message and (more importantly) doesn't return but instead kills the JVM.  I decided I didn't like it because it doesn't actually create the full crash log file in that case, but only logs a message and the stacktrace to stderr; the issue with that is that stderr messages aren't redirected by e.g. log4j (as far as I can tell) and that means the message won't show up in any logs; the JVM will just exit without an explanation.  But I don't know if there is a better way to do it.. Alright, sounds good (I didn't notice that the other one didn't have line numbers and this one does, definitely much better).  I'll close this PR for now.. ",
    "dmarcuse": "Ah, this seems to be a change in OpenCL 2.1. The 2.0 reference manual has no such statement, and states that CL_INVALID_GLOBAL_WORK_SIZE should be returned if global_work_size is NULL.\nI'm not really sure what would be the best way to handle this - maybe provide two versions of the method, CL10.enqueueNDRangeKernel and CL21.enqueueNDRangeKernel?. ",
    "codedcosmos": "I was copying the classes required (Calculator, Demo, GLFWDemo and IOUtil).\nIt works on 3.17 Nightly. Is there a way to run it on 3.16?. ",
    "the-coding-fox": "I am sorry, I have the version wrong, the version is actually is 3.1.2 in which the examples won't work.\nI did not run it before because the NetBeans couldn't find NkColorf or nmemAllocChecked. I have updated to 3.2.0 to see if that solved the issue and it does fix the compiler errors.\nIs there any documentation describing the use of Nuklear for older versions of LWJGL?. ",
    "maxbryarsmansell": "I have filled in the area that is effected with the red colour.\n\nUnfortunately I don't have time to put together an MCVE at the moment, sorry. But I can give you the link to the repository containing the project that I am having this problem with - see if it happens for you. \nRepository\n[EDIT]\nI have noticed just now that tabbing out, then back in to the program seems to fix the issue.. ",
    "Bawbby": "I should have probably stated that I did use the official build customizer for generating the build.gradle but from what I see the customizer doesn't give an exception for vulkan natives being only for macos and attempts to download the natives for the platform the build is being run on based on the lwjgl-native property.. Im just wondering for when building an LWJGL game for mac, sorry for the silly issue.. ",
    "DavidYKay": "First, thank you SO much for the prompt reply. I am hugely in your debt. :)\nSecond, it looks like it was user error. I followed your instructions and found that VRSystem wasn't being initialized properly. Because I was missing a call to it. I am so sorry for sending you on a goose chase!\nHere's a working Hello World for any future OpenVR devs: https://gist.github.com/DavidYKay/639760f4f3be8ca77658a076fdf55916\nThanks again!. ",
    "XenoAmess": "Yes you are right.\nIt can do this way , but cost me 300MB memory and 10 seconds or so to load one ttf on my PC.\nI get a SSD, 6700K, 1060, and 24GB DDR4, so I guess it can be far slower on some older machine.\nBut it is still acceptable.\nBy the way, a caching scheme for efficiency is better, but we have to figure out what characters are offen used and what not, and pick them one by one. I choose not to do this. Just, let it load.\nAnother way is to get it dynamic. Do not load the ttf totally from the beginning, but when use a char,we set a flag, and load it. And next time we see this flag on, then just use it.\nBut I'm afraid the check itself can have a cost in performance too.\nAlso, load one char seems far slower than load many chars in one time.\nAnyway, I will try to find a better way to achieve this, but I'm just use the primitive way for now.\nI really appreciate your precious help.\nThank you.\n--XenoAmess. > You should probably ask in GLFW's repo itself: https://github.com/glfw/glfw\nOK, that make sense.. ",
    "chengenzhao": "\nHey @chengenzhao,\nYou don't need dependencies in jmod format to use jlink, normal jars work just fine. The only prerequisite is that all dependencies must be explicit modules (i.e. include module-info.class, simply adding an Automatic-Module-Name in the manifest is not enough).\n\nThanks for reply, so basically we need to add module-info.class manually, and then use jlink to link this modified jar to generate jre right?\nIt looks feasible but if we could add module-info.class in the native jar, would it be more convenient for users?. > I believe it's already in there, check the META-INF/versions/9 folder.\nfound it, cool, thanks. > Since LWJGL 3.1.4 artifacts are jlink-able without any changes. module-info.class was moved into META-INF/versions/9 in 3.1.6 for compatibility with older software that tried to parse it and failed.\nthanks a lot, test it successfully. ",
    "nkfilis": "@Spasi we could be willing to provide that, what would you need there?. ",
    "graemeg": "Just to let you know, I followed those instructions and managed to compile LWJGL3 and what was needed for Minecraft 1.13.2. It worked perfectly fine on my FreeBSD 11.2 64-bit system. . If @nkfilis can't manage the CI setup for FreeBSD, I'll happily give it a go too. My FreeBSD server already runs 24/7 for other open source projects. . ",
    "Dico200": "There might be a problem with this as the corresponding JNI.invoke....(...) method isn't present. Sorry I forgot to mention.\nEDIT: I'm guessing that's generated automatically because it's needed?. It's a similar concept - LWJGL makes the raw C libraries easy to consume from Java. Kotlin multiplatform needs something similar. Currently, it is a cumbersome task to implement the stubs on each target in multiplatform projects.\nNot to mention, the quality of the bindings would probably be a lot better and more robust, plus it could include documentation.. Yes, exactly. I am busy now but I would be interested in starting/contributing in some months time!. ",
    "nicktalbot": "I don't believe so. I originally had memFree in the test but removed it to\nbe sure the failure came from memAlloc. This was run on a machine with\n192GB memory and is only allocating 4GB so should not be OOME.\nOn Tue, 27 Nov 2018, 11:47 Ioannis Tsakpinis <notifications@github.com\nwrote:\n\nHey @nicktalbot https://github.com/nicktalbot,\nOOM maybe? What happens if you replace MemoryUtil.memAlloc( 1 << 12 )\nwith memFree(memAlloc(1 << 12))?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/LWJGL/lwjgl3/issues/431#issuecomment-442030555, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ADJ3MMdVxn62dYlW-w_3-V7y4DRotsEeks5uzSZggaJpZM4Y1EKe\n.\n. Thanks! :smiley:\n\nDo you know when 3.2.1 will be available? I noticed the issue exists in 3.1.6 as well. Do you have any plans for a 3.1.7 release?. Thanks. I have tested with 3.2.1 build 11 and working well.. ",
    "Masy": "JProfiler says that there are 9 million nio DirectByteBuffers using 572 mb after a while.\nAs soon as i start rendering the debug screen, which consists of 18 text labels, therefore 18 ByteBuffers, there is an increase of about 400k byte buffers per second. I'm having around 20k fps, so i guess every time i call nvgText it copies all 18 ByteBuffers when calling nvgText(). I create a ByteBuffer using MemoryUtil.memASCII(\"Text\") when creating a text label object and then passing it to nvgText() on every render call. Not sure where to look up where objects where created in JProfiler. I'm not calling it every frame. I once create the ByteBuffer when creating the object. I then store it as a private attribute in the TextLabel object and when calling the render method of the TextLabel it calls the nvgText() method with the ByteBuffer attribute of the TextLabel object as parameter. Oh i see, it's in fact nvgFontFace creating the buffers. I would guess because i pass the fonts name as string which then gets converted to a byte buffer so the native method has access to the pointer of the char array. Well, of course the GC clears them after a while.\nI measure ram usage by calling this method every 50ms (20 times per second):\njava\npublic static void update() {\n    usedMemory = allocatedMemory - (RUNTIME.freeMemory() / 1024 / 1024);\n    allocatedMemory = RUNTIME.totalMemory() / 1024 / 1024;\n    usedMemoryBuffer = LongUtil.toText(usedMemory, usedMemoryBuffer);\n    allocatedMemoryBuffer = LongUtil.toText(allocatedMemory, allocatedMemoryBuffer);\n}\nThe LongUtil.toText() is just a copy of the original Long.toString() method but instead of creating a string it just reallocates the memory of the given byte buffer and then writes the numbers of the long directly into the byte buffer.\nWhen converting the name of the Font to a ByteBuffer instead of a string the ram \"leak\" is indeed fixed.. Java version:\nopenjdk version \"1.8.0_181\"\nOpenJDK Runtime Environment (build 1.8.0_181-8u181-b13-1ubuntu0.18.04.1-b13)\nOpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode)\nI start the application via IntelliJ or, when i profiled, run the jar that was created by maven with JProfiler.\nStarting the game with the -XX:+/-DoEscapeAnalysis does not make a difference.. I am currently using 3.2.0, but when running the latest 3.2.1-SNAPSHOT the bug is fixed. ",
    "Ant01n3": "Thanks a lot for this answer !\nMay I suggest to point to these configurations options in the exception error message if possible ?\nThanks again. ",
    "SergeySave": "Alright, I added those two suggestions to the file.\nIn terms of making this available to bgfx users, if this is made into a proper gradle plugin it could be included in the LWJGL gradle file generator. It could be made to work in such a way where you have to add it by only including the apply plugin line similarly to how you apply the java or kotlin plugins.\nOther than that this plugin can also probably be made to clone the bgfx repository (or just the src folder in it) so that it can automatically fetch those include files, however I'm not really sure where it should put these.\nAgain it should work on windows and linux, but no guarantees.. ",
    "Perso11": "Thanks you, after some research, i think now then the stencil test is not necessarily required. I think then i am going to de without him.\nThanks you again.\nPerso11\n. ",
    "Shryne": "Ok, but shouldn't a regression test be readable, too? For example reducing the jumping would raise the maintainability and some statements about the expected behaviour would add some value, too. . ",
    "DesertCookie": "\nIf it's a GLFW issue, there is nothing Spasi can do.\n\nThat's the question. Is it really or is it because of something to do with the Java binds.... ",
    "layus": "What I am saying is that building from the repository root, when that repository root is not deep enough in the filesystem tree, fails.\nFor example, assuming the repository root is in a dir named lwjgl-xxx, building with the repository root in /home/user/projects/lwjgl-xxx will work, and building in /build/lwjgl-xxx will not. Most probably, building in /lwjgl-xxx or /var/test/lwjgl-xxx will not. The build is somehow dependent of the (filesystem) depth where the checkout is made.\nI of course always start the build in the checkout root. . Or said differently, that the ../../../.. in module.lwjgl.rel was meant to be used in a different cwd than where it is defined. It was not ported correctly in the build system refactoring and was not intended to be used in a <property name=\"...\" location=\"...\" relative=\"true\"/>. ",
    "TTSKarlsson": "In all scopes that makes calls to glfw* Thread.currentThread() reports as \"Thread[main,5,main]\"\nI'm not 100% sure how glfw reports errors, but I've tried both of below:\nkotlin\n    GLFWErrorCallback.createPrint(System.out).set()\nand\nkotlin\n    GLFWErrorCallback.create {\n        error, description ->\n        println(\"GLFW ERROR: $error, $description\")\n    }.set()\nThe error callback is setup before anything else (or right before glfwInit)\nThere is no output of any errors to System.out in either variant.\nThe code also \"works\", as in, it creates a window and renders some stuff with custom shaders and so on and the glfwSetKeyCallback itself also works, as in, it calls the callback when I press a key. It just doesn't return anything else than null when setting a new callback or resetting the callback by sending null to it.\nI'll keep looking around, and if I can't find anything I will create a smallest possible reproduction.. I confirmed what you said, it works fine in a minimal test case.\nYou can close this as it's obviously on my end.\nThank you very much for your time! \ud83d\udc4d \n. ",
    "Werehog": "A dependency was missing, nevermind.. ",
    "oakes": "I'm guessing this is because opengl ES isn't implemented in Mac OS?. "
}