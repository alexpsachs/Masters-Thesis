{
    "czeluff": "FLK used @ for priorities:\n[view alignLeadingEdgeWithView:otherView predicate:@\"20@750\"];\nI think that symbol makes a little more sense. Any reason it can't be used?\n. Oh right, of course, nothing's in strings. Well, I suppose I'd prefer ~ over anything else listed.\n. I definitely do prefer this, though I understand the purpose of the proxy method. \n. ",
    "robb": "From  The Swift Programming Language.:\n\n\u201cYou can declare and implement your own custom operators in addition to the standard operators provided by Swift. Custom operators can be defined only with the characters / = - + * % < > ! & | ^ . ~.\n\nWhile some additional characters currently work anyway (such as \u221a), @ isn't one of them :-/\n. Closed by #7\n. Using proxy objects inside a closure gives us complete freedom.\n. Fron what I can gather, we'd still have to prefix the properties and I think I'd prefer what we have now over foo.cat_width == bar.cat_width\n. Closing this for now, but let's keep this in mind as Swift changes\n. Guess this is kinda blocked by not having Swift support in Travis-CI yet. Is there a good, paid CI service that does support it already? :money_with_wings: \n. Good to know, thx\n. Sure thing\n. This seems to have been addressed in Xcode 6.3beta1\n. @orta do we have Swift support in Cocoapods yet and is there anything to watch out for?\n. Hmm, if they don't work yet, I feel like I rather wait to avoid confusion\u2026\n. I totally see where you're coming from but I think it's easier to declare something with the correct operators rather than to make up new ones.\nIt's not great that == and friends have side effects but it's at least scoped within the layout block.\nI'd be more inclined to do something like EasyLayout and have the block passed to layout return a bunch of conjugated expressions, e.g.\nswift\nlayout(view1, view2) { view1, view2 in\n    // i believe the return is implicit\n    return view1.width  == view2.width  / 2 &&\n           view1.height == view2.height / 3\n}\nbut that makes capturing an individual constraint more complicated. You'd have to\n``` swift\nvar width: NSLayoutConstraint!\nlayout(view1, view2) { view1, view2 in\n    width = view1.width == view2.width / 2\nreturn width && view1.height == view2.height / 3\n\n}\n```\nWhat's your thoughts on that one?\n. The == operator isn't used to imperatively make two things equal though, it's there to express an equality and have the computer figure out values for width and such to make that statement hold true.\nI believe == is the correct operator to express an equality, or at least the one that is least surprising\u2122.\nI think there are two issues here, which token we use for the operator that declares an equality (== vs. .== vs. |==|) and how those statements are passed to Cartography and then Auto Layout.\nI agree that it is not pretty that the operators have side effects and the conjugation would be one possible way to have that be \"out in the open\".\n. > My issue is that wrapping the closure in the layout call does not seem to provide enough context to make it clear that the statements within are part of a DSL. I wish the \"delimiters\" were clearer.\n:+1: How about renaming layout to something like declareLayout?\n\nLooking at the code again, I see that part of the problem is that the repeated view1, view2 is quite noisy. Is there any way to eliminate that bit of ceremony\n\nYeah, that's unfortunate. The arguments of the block (view1 and view2) are wrapper objects that allow us to have all kinds of properties for width etc. without running into collisions on UIView. If Swift gains macro support, we may be able to make those implicit somehow, so that we only have to write\nSwift\nlayout(view1, view2) {\n    view1.width == view2.width / 2\n}\nOf course, you can also use the $0 syntax\nSwift\nlayout(view1, view2) {\n    $0.width == $1.width / 2\n}\nbut that doesn't help much I'm afraid.\n. I'm closing this one for now\n. Wow, this actually seems to solve the problem I ran into when building a mac target. :sparkling_heart: \n. I think this is related to #9, try making it\nswift\nlayout(contentView) {\n    view.edges == inset(view.superview!.edges, 20); return\n}\nSwift error messages are all over the place right now :disappointed_relieved: \n. Closing this one out for lack of activity, feel free to reopen it if the error persists.\n. Have you tried using a workspace?\n. Does this still persist?\n. Feel free to reopen this if it's still a problem\n. I'm looking into it\n. I'm looking into it\n. I'm not sure how to incorporate those into the DSL, since those are properties of the view, whereas Cartography is currently only concerned with setting up constraints.\n. Yeah, I agree.\n. Thanks for submitting this! :sparkling_heart: \nHowever, this strikes me as a little abusive of operator overloading. I think we can get away with 3 * view.size since that follows scalar multiplication, but I'm not sure view.size == view.superview!.size - 20 is a huge improvement over\nswift\nview.width == view.superview!.width - 20\nview.height == view.superview!.height - 20\nalthough, arguably the same could be said for inset\u2026\n. I have a branch for that, but I'd rather wait for Swift to settle down first\n. Oddly enough, I can't find any documentation for them.\n. Having a constraint replace another one turns out to be trickier than I anticipated. You can capture the constraint however and remove it manually, if you know what view it is attached to. (this is where the abstraction starts leaking :umbrella:)\nE.g.:\n``` swift\nvar constraint = NSLayoutConstraint?\nlayout(view) { (view) in\n    //...\n    constraint = view.left == view.superview!.left\n}\nview.superview.removeConstraint(constraint!)\n``\n. Hmm, I suggest for the time being, you simply copy over the files. I plan to eventually use Cocoapods to take care of the lib/framework issue.\n. See #52 \n. Thanks. I have some of these in my [~/.gitignore](https://github.com/robb/.dotfiles/blob/master/git/.gitignore.symlink) already but it's a good idea replicating them here.\n. @lsavino this turned out to be much ado about nothing, would you mind giving this a spin?\n. You can use the~` operator for that:\nswift\nlayout(view) { view in\n    view.width  >= 200 ~ 100\n    view.height >= 200 ~ 100\n}\n. Thanks! :sparkling_heart: \n. Thanks for the PR! :sparkling_heart: \nThere is also the need for replacing existing constraints (#26, which is currently dealt with in #29).\nMy current plan was to add a replaceConstraints method, but having four different variations seems a little too much.\nWhat's your take on either \n``` swift\nlayout(view1, view2, replace: yes) {\n    // \u2026\n}\nconstrain(view1, view2, replace: no) {\n    // \u2026\n}\n```\nor\n``` swift\naddConstraints(view1, view2, layout: yes) {\n    // \u2026\n}\nreplaceConstraints(view1, view2, layout: no) {\n    // \u2026\n}\n```\n?\n(I'd guess replace could default to no. I'm not sure what layout should default to, which I guess is a reason to go with the first example\u2026)\n. > I think I'd be worried with replace that I would end up removing constraints that another caller had added\nYeah, I modeled my behavior after Masonry, the idea being that only constraints added with Masonry (or this case, Cartography) are going to be replaced.\nI hope this to be the least intrusive way to replace constraints, what do you think?\n\n@kongtomorrow thanks for taking the time and sharing your insights, it's not everyday you get to talk to the person who wrote the thing.\n\nOk, my other objection to Cartography in particular is that it's equation oriented. \n\nTotes.\n\nBut VFL is actually much more the essence of auto layout than the equations. Maybe I shouldn't even have exposed the equation layer, only VFL and specific methods for making each  kind of relationship.\n\nI totally get where you are coming from. That being said, I feel that the syntax of VFL is almost too dense sometimes. Is |-10-[view]-20-| setting the leading or the left edge to 10pts? If [view(100)] sets the width, couldn't it say that?\nVertical layouts always felt a little weird, too, e.g.: V:[topField]-10-[bottomField] is a vertical constraint but code is horizontal. Mixing vertical and horizontal constraints, isn't possible.\nimageView.width == imageView.height * 2 may not be as visual appealing but it get's the job done.\n(Then there is stuff like having to create correct bindings using NSDictionaryOfVariableBindings and it being stringly typed but those are problems of todays VFL and can probably change now that we have Swift.)\n\nIf you emphasize equations, you really are asking the user to be a constraint solver.\n\nAgreed, yet at the same time, these equations don't require the user to learn a new syntax or remember the implicits of VFL. I'm not sure if that is simpler, but I found it to be easier.\nI can totally see how Catography can become a mess of equations once you're juggling too many views, however.\n\nbutton1.left == button2.right + 12 has button1 to the right of button2, and it's reeeeeally hard to see that. \n\n:+1: You should be able to make this button2.right + 12 == button1.left, if that doesn't work, it's a bug in Cartography :-)\nAnyway, I'm not sure Cartography is the ultimate solution (not even sure code is), but this discussion certainly got me a little closer :sparkling_heart: \n. @lsavino \n\nI'd probably prefer addConstraints:layout: (with maybe a default false layout), so I could avoid the flag that opts out of this replace action that gives me the heebie-jeebies.\n\nWhat about layout/constrain with replace defaulting to false though? So you'd end up with\nswift\nconstrain(view) {\n    view.width == view.superview!.width / 2\n    view.height >= view.superview!.height / 2\n}\n. I'll probably just cherry pick it or redo it :ok_hand: \n. I feel like I've seens this during my work on #29, would you mind giving that a quick spin to check if the problem persists?\n. Cool, leaving this one open as a reminder for now.\n. Probably copypasta, thanks!\n. LGTM, closing this for now then :tulip: \nI'd like to eventually offer some convenience methods for \"make all these the same width/height/size\" and distribute these views like so. Feedback is of course more than welcome.\n. What error are you getting?\nHave you tried casting to CGFloat?\n. Hmm, it's not affected by #9, is it?\n. That would be great\n. Ah, dang, you have to cast to Float, not CGFloat. This works for me\n``` swift\nlet margin = 20.0 as Float\nlayout(label) { label in\n    label.left == label.superview!.left + margin\n    label.right == label.superview!.right - margin\n}\n```\n(sorry for the late reply)\n. This looks like it's related to #32, I have a fix in #29 which is to add a separate constrain function which does what you want, am I right?\n. Have you tried it in your app? Did it work as expected? I'm just looking for a little more feedback but otherwise it should be merged without API changes real soon\u2122.\n(Is Swift ready for production use? :trollface:)\n. Thanks! :sparkling_heart: \nLooks good to me, would you mind throwing in a test case, too?\n. Sorry, would you mind re-opening this PR against the master branch?\n. Thanks for the PR :christmas_tree: \nHowever, this seems a little too much for my taste.\n. That's a good idea!\n. > One more thing, I decided to target the refactor branch because I thought the implementation might change dramatically between refactor and master (turns out, that it didn't really matter), and because it's the branch that I'm using.\nMissed this before merging refactor, would you mind creating a new PR against master?\n. Thanks for the PR :sparkling_heart: \n. You can use\nCartfile\ngithub \"robb/Cartography\" \"master\"\nfor now.\nI forgot to make the schemes public, should work now\n. I've tagged 0.1.0, can you check if it validates correctly now?\n. Merged it manually, thanks!\n. Thanks\n. Cartography by itself supports iOS 7.\nThe podspec specifies iOS 8 since I am under the impression that CocoaPods only supports Dynamic Frameworks for Swift, which in turn require iOS 8. (@orta right?)\nCarthage only builds Dynamic Frameworks.\nYou can, however, use git submodules and pull in the source files manually into your project,  or concatenate them all in a single file, if you'd prefer.\n. Thanks\n. Thanks!\n. Thanks for the pull request :sparkling_heart: \nHowever, I've looked into this before but I considered the implicit replacement of constraints to yield to many edge cases. Consider this spec:\n``` Swift\nimport Cartography\nimport XCTest\nclass UpdateTests2: XCTestCase {\n    var superview: View!\n    var view1: View!\n    var view2: View!\noverride func setUp() {\n    superview = View(frame: CGRectMake(0, 0, 400, 400))\n\n    view1 = View(frame: CGRectZero)\n    superview.addSubview(view1)\n\n    view2 = View(frame: CGRectZero)\n    superview.addSubview(view2)\n}\n\nfunc testUpdate() {\n    layout(view2) { view2 in\n        view2.height == 300\n        view2.width  == 300\n    }\n\n    layout(view1, view2) { view1, view2 in\n        view1.center == view2.center\n\n        view1.width  == view2.width\n        view1.height == view2.height\n    }\n\n    layout(view1) { view1 in\n        // This should replace `view1.height == view2.height`\n        view1.width == 200; return\n    }\n\n    XCTAssert(CGRectGetWidth(view1.frame) == 200, \"It should update existing constraint\")\n}\n\n}\n```\nYou would expect view1.width  == 200; to replace the earlier view1.height == view2.height constraint, but since that one is attached to view1.superview, we get unsatisfiable constraints \u2013 a symbolic breakpoint in UIViewAlertForUnsatisfiableConstraints confirms this.\n(Note that the spec may actually pass if UIKit decides to break the right constraint. For me it breaks view2.width  == 300 which is definitely not what I wanted)\n\nBecause Cartography immediately layout subviews after constraints are installed.\n\nHave you tried the new (and undocumented :pensive:) constrain function?\nYou should be able to do something like \n`` swift\n// this won't callsetNeedsLayout()`\nconstrain(view) { view in\n    view.left == view.superview!.left + 200\n}\n// layout in animation block\nUIView.animateWithDuration(0.5, animations: view.layoutIfNeeded)\n```\n. > What I wanted to make layout function to do was 'Create new constraints or update existing'. Not replace whole constraints.\nHmm, not sure I follow. Let's stick with width and height since those actually allow referencing constants, where I think most of the confusion comes into play. Consider this example:\n``` swift\nlayout(view1, view2) { (view1, view2) in\n    view1.width  == view2.width  - 10\n    view1.height == view2.height - 10\n}\nlayout(view1, view2, anotherView) { (view1, view2, anotherView) in\n    view1.width  == anotherView.width + 20\n    view1.height == view2.height - 20\n}\n```\nAssuming view1, view2 and anotherView and all share the same common superview, this works as expected.\nHowever, just from looking at it, I would expect this to work as well:\n``` swift\nlayout(view1, view2) { (view1, view2) in\n    view1.width  == view2.width  - 10\n    view1.height == view2.height - 10\n}\nlayout(view1, view2) { (view1, view2) in\n    view1.width  == 100\n    view1.height == view2.height - 20\n}\n```\nwhich doesn't because of the aforementioned reasons.\n\nI've just tried constrain function, it works perfectly as I expected :D\n\n:ok_hand: \n. Hmm, I'm not sure this will do more harm than good. What part of an expression ends up being updatable is more of an implementation detail of Auto Layout. I think allowing constraints to be (partially) updated is going to be very confusing.\nE.g. this would work:\n``` swift\nconstrain(view1) { view1 in\n    view1.width  == 100\n    view1.height == 100\n}\nconstrain(view1) { view1 in\n    view1.width  == 200\n    view1.height == 200\n}\n```\nand this would work:\n``` swift\nconstrain(view1, view2) { view1, view2 in\n    view1.width  == view2.width  + 100\n    view1.height == view2.height + 100\n}\nconstrain(view1, view2) { view1, view2 in\n    view1.width  == view2.width  + 200\n    view1.height == view2.height + 200\n}\n```\nbut this wouldn't\n``` swift\nconstrain(view1) { view1 in\n    view1.width  == 100\n    view1.height == 100\n}\nconstrain(view1) { view1 in\n    view1.width  == view2.width  + 200\n    view1.height == view2.height + 200\n}\n```\nThen there's stuff like:\n``` swift\nlet leftColumnHeight: Double = // \u2026\nconstrain(marginView) { marginView in\n    marginView.height >= leftColumnHeight\n}\nlet rightColumnHeight: Double = // \u2026\nconstrain(marginView) { marginView in\n    marginView.height >= rightColumnHeight\n}\n```\nWould this update the height constraint or create a second one? I have no clue\u2026.\nI think a better way to update constraints is capturing them, e.g.:\n``` swift\nvar width: NSLayoutConstraint? = nil\nconstrain(view1) { view1 in\n    width = view1.width == 100\n}\n// Later\nwidth.constant == 200\n```\nwhich can get unwieldy but it overall simpler, imho.\n. For the time being, you need to cast to Float like so:\n``` swift\nvar margin: Float = 15\nlayout(productView) { view in\n    // \u2026\n}\n``\n. You can't paircenterYwithheight`, a position can only be specified relative to another point.\n. Duplicate of #26, see #55 for an ongoing discussion.\n. Can you provide some more information, like a stack trace for example?\n. The offending line is this one\nswift\nl.top == 100\nYou need to specify top relative to something, try l.top == l.superview!.top + 100.\nThis shouldn't actually compile so I'm leaving this open as a reminder.\n. Fixed by #63\n. Maybe ConstantEquality should be NumericalEquality instead? Could a native speaker chime in on this? :gb: :us: \n. Paging @orta, speaker of ye olde tongue and giver of names.\n. :bow:\n. See #9\n. Sorry for the terseness, was just about to head out. Thanks for filing the issue! \n. @devxoul what do you think about this?\n. These tests fail since they run on 10.9 where NSLayoutConstraint.active is not available. :pensive: \ntravis-ci does not currently offer 10.10 images.\n. Thanks for the Pull Request :sparkling_heart: \nJust to make sure I understand this correctly:\nWhen building a framework, setting APPLICATION_EXTENSION_API_ONLY assures the linker that no APIs flagged as NS_EXTENSION_UNAVAILABLE_IOS are being used?\n. :boom: \n. @mono0926 do you need me to tag HEAD?\n. Have you tried\nswift\nconstrain(imageView) { imageView in\n    imageView.center == imageView.superview!.center; return\n}\n?\n. You need to either specify the imageViews dimensions as Auto Layout constraints or set its image, so that intrinsicContentSize will return something meaningful. The frame and bounds you set will be overridden during a layout pass.\nThis should work\nI'd recommend doing something like this:\nswift\nlayout(imageView) { imageView in\n    imageView.width  == 75\n    imageView.height == 75\n    imageView.center == imageView.superview!.center\n}\n(Note that if you want to use imageSize here, you currently need to cast it to Float. See #56)\n. :ok_hand: \n. Looks like layout is getting shadowed by NSView.layout inside NSView instance methods, hadn't realized this.\nThis should do the trick:\nswift\nfunc sizeToFillSuperview(view: NSView) {\n    Cartography.layout(view) { box in\n        box.size == box.superview!.size; return\n    }\n}\n. you need to cast your variable to Float, as per #56. So\nswift\nlayout(splitView, boxStatus) { split, box in\n    box.height == CGFloat(someVar)\n    split.height == box.superview!.height - CGFloat(someVar)\n    split.bottom == box.top\n}\nshould do the trick\n. Glad to be of help :smiley_cat: \n. Weird\nDid you just build Cartography in Xcode or through Carthage or Cocoapods? What version of Xcode were you using?\n. Yeah, I can replicate it in Xcode 6.1 (6A1052c), I'll push a fix but probably wouldn't bother to tag 0.2.1 if it's already fixed in Xcode 6.1.1\n. Yeah, you need CocoaPods 0.36 for Swift and frameworks support. You were using 0.34.4, right?\n. :ok_hand: \n. left is just a point on the x axis whereas width is a length. You could imagine something like a.left == b.left + c.width but Auto Layout cannot express constraints with three variables, yet.\nI haven't had much experience in mixing Cartography with IB but maybe a higher priority (which can be set with the ~ operator) would help?\n. To me it's the other way round, I'm still surprised view.centerX == view.superview!.centerX * 0.5 works and I don't find it very intuitive, either. (view.centerX will be halfway between superview.left and superview.center, right?)\nMaybe it's just something Apple designers needed really badly so it was hacked in?\n. Tentatively closing this once, since this is fundamentally an Auto Layout issue, but feel free to reopen if you have more questions.\n. First of all, thanks for providing a way to recreate that issue :sparkling_heart: \nThere are some subtleties to this, let me try to address them one by one:\n\nOrder off adding the constraints appears to matter. If view A is put inside view B, then if view B has it's constraints added before A's then the phantom constraint isn't added. In practice this workaround is pretty clunky.\n\nI've been able to confirm this. if contentView does not have a superview of its own when it is being layouted, that extra NSLayoutConstraint is added, even if translatesAutoresizingMaskIntoConstraints is explicitly set to false.\nHowever, I'm not sure that I agree that setting up the view hierarchy before adding constraints is clunky, considering that NSLayoutConstraints may leak outside a sub-tree and affect the entire window. I'd probably suggest the opposite, trying to always set up the view hierarchy before adding constraints where possible. Ultimately, it's your decision though.\n\nAdding the same constraints using the NSLayoutConstraint methods doesn't exhibit this behavior. \n\nThis is true, but the two code snippets in your example are not 100% equivalent.\nThis\n``` swift\nlayout(label) { label in\n    label.left == label.superview!.left\nlabel.right == label.superview!.right - 10\n\nlabel.top == label.superview!.top\nlabel.bottom == label.superview!.bottom\n\n}\n```\nwill call layoutIfNeeded on label.superview once the constraints are installed. That call, since label.superview does not yet have a superview of its own, will install that phantom constraint as outlined above.\nOn the other hand, your alternative solution\nswift\nself.contentView.addConstraint(NSLayoutConstraint(item: label, attribute: .Left, relatedBy: .Equal, toItem: self.contentView, attribute: .Left, multiplier: 1, constant: 0))\nself.contentView.addConstraint(NSLayoutConstraint(item: label, attribute: .Right, relatedBy: .Equal, toItem: self.contentView, attribute: .Right, multiplier: 1, constant: -10))\nself.contentView.addConstraint(NSLayoutConstraint(item: label, attribute: .Top, relatedBy: .Equal, toItem: self.contentView, attribute: .Top, multiplier: 1, constant: 0))\nself.contentView.addConstraint(NSLayoutConstraint(item: label, attribute: .Bottom, relatedBy: .Equal, toItem: self.contentView, attribute: .Bottom, multiplier: 1, constant: 0))\nwill only set up the constraints. Since that code is almost immediately followed by self.view.addSubviews([contentView]), layouting will occur after contentView has been added to view, not resulting in a phantom constraint.\nIf you'd like to set up the constraints before adding the subviews, you would need to defer the layout pass. You can do this by using Cartography's constrain function like so:\n``` swift\nconstrain(label) { label in\n    label.left == label.superview!.left\nlabel.right == label.superview!.right - 10\n\nlabel.top == label.superview!.top\nlabel.bottom == label.superview!.bottom\n\n}\n```\nThat seems to work fine in the example project you provided :ok_hand:\n. Closing this one then, feel free to reopen it if you have any more questions.\n. Thanks :sparkling_heart: \n. Most likely not\n. Yeah, Non-associative operator is adjacent to operator of same precedence is kind of a dealbreaker, I really don't want to override the associativity of ==.\nAlso, it would complicate capturing constraints.\n. There could be something like alignTopEdges(view1, view2, view3), too, but I'm not sure what the syntax should be.\n. I guess you could also have something like\nswift\nlayout(view1, view2, view3) { view1, view2, view3 in \n    combine(view1, view2, view3).top == view1.superview!.top\n}\nbut that looks even more complicated\n. Thanks for the example project :sparkling_heart: \nThe issue was a file from the test target being assigned to the Mac framework target, should be fixed in 0.2.1.\n. Unfortunately, a LayoutProxy or its properties cannot currently outlive their layout blocks.\nThis is basically because the layout function needs to know where to look for constraints to install but properties from other blocks may not be available to it.\nI wish there was a way to prevent your example from compiling, to make this behavior more obvious, but I don't there's a way for that, currently.\n. Not sure what you mean, but view.bottom isn't a value but rather a symbolic variable (after all, it's Auto Layout's job to figure out the value).\nYou could do this\n``` swift\nlayout(self.view) { view in\n   view.height == ...\n   view.top == ...\n}\nlayout(self.view, self.view2) { view, view2 in\n   view2.top == view.bottom + 10\n}\n```\nhowever.\n. :ok_hand: \n. how about\nswift\nconstrain(clear: group)\nand\nswift\nlayout(clear: group)\n?\n. :sparkling_heart: \n. Are you saying you want to make a green square inside a red rectangle?\nIf so, try this:\n``` swift\nlayout(green) { green in\n    green.center == green.superview!.center\n    green.width  == 300\n    green.height == 400\n}\nlayout(red, green) { red, green in\n    red.center == red.superview!.center\n// Make `red` square\nred.height == red.width\n\n// Attempt to make `red` the size of `green`.\n//\n// By giving this a lower priority, we ensure that the square aspect ratio\n// of `red` is being maintained.\nred.size == green.size ~ 100\n\n}\n```\n. This does it for me\n``` swift\nred.backgroundColor = UIColor.redColor()\nview.addSubview(red)\ngreen.backgroundColor = UIColor.greenColor()\nred.addSubview(green)\nlayout(red) { red in\n    red.center == red.superview!.center\nred.width  == red.superview!.width  - 40\nred.height == red.superview!.height - 80\n\n}\nlayout(red, green) { red, green in\n    green.center == red.superview!.center\ngreen.height == green.width\ngreen.width  <= red.width  * 0.9\ngreen.height <= red.height * 0.9\n\ngreen.width  == red.width  * 0.9 ~ 100\ngreen.height == red.height * 0.9 ~ 100\n\n}\n``\n. I should probably addcenter` et all, too.\nFor width/height/size, I'll add something like equal(width: view1, view2).\n. Hmm, I feel like the method should be called alignedBy to be more aligned (ha) with the declarative nature of Auto Layout.\n. I'm going with align since people seem to find that easier to read. I reserve the right to change that before 1.0 though #semver\n. No need, ~ just works\u2122.\nE.g.:\nswift\nalign(top: viewA, viewB, viewC) ~ 100\n. Or maybe rather distribute(by: 10, horizontally: view1, view2, view3)?\n. I think I'm pretty :-1: on mucking with the view hierachy as a side-effect. Too bad Auto Layout can't express distance(view1.right, view2.left) == distance(view2.right, view3.left).\n. > I think I'll stick to my own helper function for this then.\nFeel free to gist it up and attach it to this discussion in case some is looking for something similar :sparkling_heart: \n. @mergesort I went ahead and merged #88, lemme know if this fixes this one and then I'll cut 0.3. :sparkles: \n. This seems not to be an issue on the Mac after a quick test with NSViewController.\n. > Am I replacing the groups in the wrong way?\nI think what happens here is since you iterate over multiple buttons in self.topicButtons, you only ever going to end up with the last button property laid out, since you keep replacing the constraints set up by the previous iteration of the loop, e.g.:\n``` swift\nlet topicConstraints = ConstraintGroup()\nlet topicButtons = [ buttonA, buttonB, buttonC ]\nfor (i, button) in enumerate(topicButtons) {\n    self.topicConstraints = constrain(button, replace: topicConstraints) { viewbutton in\n        button.width == i * 100.0\n    }\n}\n```\nis equivalent to:\nconstrain(buttonA, replace: topicConstraints) { /* \u2026 */ }\nconstrain(buttonB, replace: topicConstraints) { /* \u2026 */ }\nconstrain(buttonC, replace: topicConstraints) { /* \u2026 */ }\nwhich most likely isn't what you want. This also explains why it works if you remove the replace parameter.\nconstrain has a version that allows you to pass in an Array that you could use, something like\n``` swift\nconstrain([view, avatarView] + topicButtons) { proxies in\n    let view = proxies[0]\n    let avatarView = proxies[1]\n    let topicButtons = proxies[2..<proxies.count]\n/* \u2026 */\n\n}\n```\n\nWould it be possible to make the replace parameter of ConstraintGroup? type so you could pass it nil when it's the first time its being laid out?\n\nYou can pass in an empty ConstraintGroup just fine, no need to optionalize it.\n. No worries :ok_hand: \n. Hmm, the Adopting Auto Layout guide paints a grim picture:\n\nThe principal circumstance in which you should not call setTranslatesAutoresizingMaskIntoConstraints: is when you are not the person who specifies a view\u2019s relation to its container. For example, an NSTableRowView instance is placed by NSTableView. It might do this by allowing the autoresizing mask to be translated into constraints, or it might not. This is a private implementation detail. Other views on which you should not call setTranslatesAutoresizingMaskIntoConstraints: include an NSTableCellView object, a subview of NSSplitView, a view of NSTabViewItem, or the content view of an NSPopover, NSWindow, or NSBox object.\n\nSo unless we want to maintain an epic black list, it would seem like we shouldn't call setTranslatesAutoresizingMaskIntoConstraints at all, even though it's what the user wants 90% of the time?\n. I gave this some thought and I'm currently leaning towards not calling setTranslatesAutoresizingMaskIntoConstraints at all, since it's ultimately an implementation detail of the view and Cartography can't know for sure what's appropriate to do. :unamused: \nWe can, however, make it more convenient by adding something like\nswift\nstopTranslatingAutoresizingMaskIntoConstraints(view: View...)\nwhich allows turning off the behavior for multiple views at once. The example from the Readme would thus turn into \n``` swift\n// Assuming view1.superview is owned by a UIViewController\nstopTranslatingAutoresizingMaskIntoConstraints(view1, view2)\nlayout(view1, view2) { view1, view2 in\n    view1.width   == (view1.superview!.width - 50) * 0.5\n    view2.width   == view1.width - 50\n    view1.height  == 40\n    view2.height  == view1.height\n    view1.centerX == view1.superview!.centerX\n    view2.centerX == view1.centerX\nview1.top >= view1.superview!.top + 20\nview2.top == view1.bottom + 20\n\n}\n```\nAt least this only needs to be called once in the whole lifetime of a view.\n. @smileyborg Do you happen to have any insights here that you gained from PureLayout?\n. Yeah, I wonder if it's best to formalize this through the type system so that\nproperty == expression | property | numerical constant\nis the only form Cartography works with. Symmetry would be nice but it's a fight against Auto Layout's windmills :pensive: \n. @smileyborg thanks for the insights :sparkling_heart: \n. Closing this one out in favor of #94\n. Have you tried Carthage or Cocoapods or submodules or building a framework and copying it manually?\n. :ok_hand: \n. Fixed.\n. - [ ] ~~Mentioned the lhs.setTranslatesAutoresizingMaskIntoConstraints(false) behavior in the README~~\n- [x] Make sure align and distribute make sense\n. Yeah, it's being fixed in #99 \n. Thanks, I updated the xcode6-3 branch.\n. Thanks\n. I don't really want to officially keep supporting iOS 7 if we're closer in time to iOS 9 than 7. Have you considered using a local podspec?\n. The new properties in #93 are iOS 8 exclusive, so that ship has sailed I'm afraid.\n. That took care of itself :v:\n. Can you confirm this is not related to #105?\n. @VincentWenShuo can you try master now? It was hopefully fixed in #111\n. Are you importing Cartography?\n. It's there to make testing ViewUtils easier, but you might want to upgrade to at least Cartography 0.3.0, which should work.\nI'm probably going to remove the tests for ViewUtils rather than exposing them this awkwardly.\n. Thanks\n. Well, we don't have Xcode 6.3 running on travis-ci yet. What could possibly go wrong?\n. Sorry, it's up now! :sweat: \nI'll automate this once travis supports Xcode 6.3.\n. > Would you be interested in merging them in?\nNot really :grimacing: I don't really support iOS 7 nor static libraries. Maybe there's a way for you to automate the search and replace process so pulling in changes from upstream is easier?\nBest of luck!\n. @eholshouser This is only a problem where people need to manually bring in Cartography and e.g. that SQLite wrapper into the same namespace.\nSwift has proper namespaces (at last) so this is really just a short time inconvenience until people can drop iOS 7 support. Since Cartography is a pure Swift framework that can't even be used from Objective-C files, it doesn't need to be bogged down by Objective-C conventions.\n. @eholshouser no worries :green_heart: \n. I begin to doubt the usefulness of the current approach, I think it may make more sense to use the layoutMargins of the parent view instead, but those would only be available on iOS.\n. Sounds interesting, thanks for offering to help :sparkling_heart: \nDo you think it's possible to have this happen exclusively in the gh-pages branch? The idea being that gh-pages includes master as a submodule and generates the docs from that.\n. The branch exists now.\n. Thanks for putting in the work :sparkles: \nIs there a way to hide certain classes, structs or methods?\nSome of these are only exposed for make the compiler happy work but have no public properties, e.g. Context. Even if we documented them as \"Don't use this\", I think having them in the docs is just unnecessary noise. \nI don't suppose there is a way to move the operators under their respective protocol?\n. :bow:\n. Just add\nCartfile\ngithub \"robb/Cartography\" ~> 0.5\nand you should be good to go :ok_hand: \n. This being screenshots makes it a little hard on commenting on specific parts of the code.\nHave you tried performing your layout call -updateConstraints and overriding [+requiresConstraintBasedLayout](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/clm/UIView/requiresConstraintBasedLayout) to returntrue`?\n. First of all, thanks for the pull request :sparkling_heart: \nHowever, I'm a little unsure about this one. It removes the compile time guarantee for there being at least two views present while doubling the API surface (we'd have to do the same for all the align methods, too).\n. Thanks. :sparkling_heart: \nI pushed it to the swift-2.0 branch on this repo. Feel free to target further PRs at that branch if anythings needs tweaking. \n. @3webbg It's been merged into master :sparkles: \n. @sdgandhi This can be merged once Xcode 7 is released publicly and all the tests pass\n. Merged manually.\n. Yeah, I feel like Cartography in its current form isn't well suited to work with UILayoutGuide without major refactoring. I don't have a good idea off the top of my head but I'd be happy to review any proposals.\n. iOS 7.1 is not officially supported by Cartography, but are you sure you're installing the constraints in the right place?\n. Looks like those have been addressed by @derrh already :v:\n. I can't reproduce this on my end, do you have more code that you can share?\n. :+1: \n. Closed by #146 \n. @smileyborg what's your opinion on this?\n. > I agree with #143 for sure, is that what you're asking? \nYeah, basically. No need to review this, I'm confident enough in the diff ;-)\n. Oh, and thanks :sparkling_heart: duh\n. Closed in favor of #146 which targets 1.0-development.\n. I'm just gonna take your word for it :p\n. You shouldn't have to, can you share some code maybe?\n. Could you try this:\n``` Swift\nlayout(label) { label in\n    label.left   == label.superview!.left + 33\n    label.bottom == label.superview!.centerY - 1\n}\nlayout(self.contentView, label) { contentView, label in\n    label.height == contentView.height + 46\n}\n```\nI think what's happening is that the contentView relies on its resizing masks getting translated into constraints automatically, which Cartography will disable for the left hand side of every constraint.\n. Hey, sorry for not checking back in sooner.\nDoes the problem still persist?\n. Does it help if you don't have the contentView as the left hand side argument of the == operator? Btw,  I recommend keeping the names consistent with the parent scope, so you don't need to translate between thisView and contentView all the time :v: \n. Does contentView.height == label.height - 45 not work?\n. Does this help? From http://johnszumski.com/blog/auto-layout-for-table-view-cells-with-dynamic-heights\n\nAnother less obvious pain point is using multi-line UILabels in a layout. I expected that if a label's text had more than one line of content at its current width, that the label's intrinsicContentSize would simply expand to a height that fits the entire text string. Assuming appropriate constraints existed to allow the label to grow to that height, it would be fully visible in the layout. Unfortunately, Auto Layout instead will only render the label with one line of text and truncate the rest. The fix is to set preferredMaxLayoutWidth to the width of your label, which allows the layout engine to correct compute the full height. Having to know the proper width ahead of time is a major restriction, and I created a UILabel subclass that keeps its preferredMaxLayoutWidth updated as its bounds change:\n\n``` objc\n- (void)layoutSubviews {\n    [super layoutSubviews];\nself.preferredMaxLayoutWidth = CGRectGetWidth(self.bounds);\n\n[super layoutSubviews];\n\n}\n``\n. I'm happy to merge this, but I'm not really willing to commit to iOS 7 support in a Swift 2.0/Xcode 7/iOS 9 world.\n. iOS 7 is not officially supported by Cartography, so while I think you can make it work by e.g. copying all files into your project, it's really not something I can help you with, sorry.\n. You can useConstraintGroup'sactiveproperty which should really be documented better :sweat_smile: \n. Unfortunately, I don't think there is a way to do this without storing a reference to the groups. If you made another call toconstrain, Cartography couldn't really figure out reliably which constraints to replace.\n. Always happy to help.\n. That should work, as long as the variable is ofCGFloat. Are you seeing any error messages on your end?\n. Happy to help :v:\n. [Yes](https://github.com/robb/Cartography/blob/70a3c5876d4ff1e355d9c8e1f2ef9a71d7108c46/Cartography/Layout.swift#L109-L115).\n. Oh, yeah, you're right.\n. Sure thing.\n. What version of Xcode and Carthage are you using?\n. You could use the variant oflayoutthat uses an array instead. :ok_hand: \n. Even better :v:\n. Cool :v:\n. You could declareintroMarginasCGFloat`?\n. It's not possible with Auto Layout, I'm afraid. You could do an empty spacer view (Cartography doesn't support layout guides yet) and do something like\nswift\nconstrain(spacer, timestamp) { spacer, timestamp in\n    spacer.left == spacer.superview!.left\n    spacer.width == spacer.superview!.height\n    spacer.right == timestamp.left\n    // etc.\n}\n. That's not quite how that's supposed to work. You need to add Cartography to the workspace and drag the framework product into the Embedded Binaries section, not the project itself.\nI would recommend Carthage to simplify this process though.\n. Feel free to reopen this if you have any further questions :smile_cat: \n. Thanks :sparkling_heart: \n. Done. \ud83c\udf51\n. Thanks for the Pull Request :sparkling_heart: \n. Does\nswift\nUIView.animateWithDuration(1.5, delay: 0.8, options: .CurveEaseInOut, animations: image.superview!.layoutIfNeeded, completion: nil)\nwork?\n. You probably need to embed the binaries, please refer to the Carthage instructions.\n. Sorry for the terse reply. :bow: Unfortunately, I'm not sure what the cause of your problem is, can you post more information about your workspace/Podfile/etc.?\n. It does sound like your workspace is misconfigured and the Cartography framework is not copied when you build it for your device. Are those DEBUG builds?\nI'm not using Cocoapods myself for Swift stuff, so I'm just stabbing in the dark here.\n. Yup, that's the idea. You can also create your wrapper around the constrain(views: [View]) overload that takes however many views you like. \n. You need to capture the first set of constraints, not create an empty ConstraintGroup, e.g.:\nswift\nself.coinConstraint = constrain(self.coin, self.slot) { coin, slot in\n     coin.centerX == slot.centerX\n     coin.bottom == slot.top - 10\n}\n. Thanks for the pull request :sparkling_heart: \n. Is either of swipeableView or view a reference of type UIView! and nil, by chance?\n. Not sure this is actually Cartography related, googling fastBindLazySymbol turns up multiple similar errors with other libraries. Could it be a Cocoapods/setup problem as it was here or here?\n. Nothing really changed with Cartography in that timeframe.\n. LGTM, thx\n. \ud83d\udc96 Thanks!\n. LGTM, thx :sparkling_heart: \n. Thanks for the Pull Request :sparkling_heart: \nWould you mind adding a test that verifies the intended behavior?\n. Fair enough, let's leave this for future generations to worry about \u00af(\u30c4)/\u00af \n. yes :smile: \n. Yeah\n. Thanks!\n. I've not found a way to have the arity of the block match the number of views without having one overload per arity. It should be reasonable straightforward to add your own if you need more and have it map to the one that takes an array.\n. Currently not possible, see #95. Thanks!\n. Closed in #208, thanks!\n. Thanks for the pull request! \ud83d\udc96 \nWould you mind adding some tests that also exercise the new API?\n. Thanks for the pull request! \ud83d\udc96 \nIs there any way to get this build on travis?\n. Closed in #208, thanks!\n. Closed in #208, thanks!\n. You could attach the outer top to the top of the upper label and the same for the bottom of the other label. \n. Thanks everyone!\n. Thanks for the pull request \ud83d\udc96! Would you mind adding specs as well?\n. LGMT, thanks!\n. Thanks!\n. A duplicate of #221 I reckon?\n. \ud83e\udd18\ud83c\udffc\n. What type is height? You might have to cast to Int or Double\n. Oh, nevermind, it tries to convert the lhs Dimension to Int (which it can't). Try casting e.g. view.height == Doule(imgHeight)?\n. Would you mind providing more\u2026 context?\nIt's difficult to help if we don't know the expression.. Does the multiplier have an effect on NSLayoutAttributeTop and friends? I was under the impression that they weren't affected.\n(Sorry for the late reply, for some reason, I didn't see a notification)\n. I had not consider that, I'll make Edge conform then\n. Let's make this layout<T: Equatable, Hashable>(views: [T: View], block:([T: LayoutProxy] -> ())) so users can use arbitrary identifiers (tags, strings, even the views themselves)\n. Yes\n. Unfortunately, these give me an expression too complex error without the return statement.\n. Not sure if this is intentional\n. What issue does this fix for you? I don't have a Mac code signing identity and it would suck if I couldn't run the specs anymore ;-)\n. But this changes it from doing no codesigning to signing with the Mac Developer identity, right?\nBtw, if you're only dealing with iOS, you can use carthage build --platform ios to skip building for Mac altogether.\n. Did you make this public for your testing or is there a reason for those changes?\n. Same as above re making this public\n. Nitpick: can you add a space here?\n. Nitpick: missing new line\n. ",
    "devxoul": "Try Circle CI.\n. Cool\n. CocoaPods 0.36 beta released and finally supports swift. Now this issue can be done soon, I think.\n. It would be great if there is NSDictionaryOfVariableBindings macro in swift... I don't like to write view1 again and again :p\n. Why the deployment target is 8.0?\n. @robb \nOh, that isn't what I want to do. What I wanted to make layout function to do was 'Create new constraints or update existing'. Not replace whole constraints.\nFor example:\n``` swift\nlayout(view1, view2) { (view1, view2) in\n    view1.top == view2.top + 10 // (1)\n    view1.left == view2.left + 10 // (2)\n}\n// at this time:\n// (1) view1.top = view2.top + 10\n// (2) view1.left = view2.left + 10\nlayout(view1, view2, anotherView) { (view1, view2, anotherView) in\n    view1.top == anotherView.bottom + 20 // (3) update\n    view1.height == view2.height - 10 // (4) create new one\n}\n// then:\n// (1) -> (3) view1.top = anotherView.bottom + 20 (replaced)\n// (2) view1.left = view2.left + 10 (existing, not changed)\n// (4) view1.height = view2.height - 10 (newely created)\n```\nI've just tried constrain function, it works perfectly as I expected :D\n. @robb, you're right. I didn't catch that :astonished:\nThen, how about 'create new constraint or update constant of existing'?\n. Totally agree with that, but how about this approaches?\n1) Capture referencing views:\n``` swift\n// block A (init block)\nconstrain(view1) { view1 in\n    view1.width  == view2.width  + 200\n    view1.height == view2.height + 200\n}\n// block B (update block)\nconstrain(view1) { view1 in\n    view1.width  == 100\n    view1.height == 100\n}\n```\nAt block A, constraints installed on view1.superview. We can capture view1.superview from view1 at install time, so at block B, we can use captured view to find existing constraints. I just wrote some prototype and it seems to be working.\n2) Update layout explicitly:\n``` swift\nlet leftColumnHeight: Double = // \u2026\n// force create\nlayout(marginView) { marginView in\n   marginView.height >= leftColumnHeight\n}\nlet rightColumnHeight: Double = // \u2026\n// force update\nupdateLayout(marginView) { marginView in\n   marginView.height >= rightColumnHeight\n}\n```\nCapturing each constraints is the most simple way to update constants, but it's too messy if there are many UI elements and various exceptional cases.\n. Nice approach! It'll be great if ConstraintGroup supports NSLayoutConstraint's active property that  introduced at iOS 8.\n\nThe receiver may be activated or deactivated by manipulating this property.  Only active constraints affect the calculated layout.  Attempting to activate a constraint whose items have no common ancestor will cause an exception to be thrown. Defaults to NO for newly created constraints.\n. Travis CI doesn't support new beta of Xcode yet?\n. \n",
    "mxcl": "I went to swift lab about this, it's s compiler bug. Should be fixed!\n. ",
    "lsavino": "Still not fixed in 6.1--wanna update the one-line examples on the readme? <3\n. Hm, that's a good question. replace seems like it might be a little fragile in general--there's not a removeAllConstraints method on purpose, I think (and I am displaying my ignorance here, but I've heard you can get unexpected behavior if you grab a view's .constraints and iterate over them, removing them all).\nI think I'd be worried with replace that I would end up removing constraints that another caller had added, and I wouldn't replace them with constraints that would still work within the system. I guess this is always a problem with installing constraints, but it seems especially tricky to successfully remove all previous constraints (added from who-knows-where), and replace them correctly with new ones.\nSorry this is mostly thinking out loud! As long as there's an option to not replace the constraints, I'd be happy; to that end, I'd probably prefer addConstraints:layout: (with maybe a default false layout), so I could avoid the flag that opts out of this replace action that gives me the heebie-jeebies.\n. hehe yes, also Ken has some thoughts/feels here.\n. Sure, that works! (Sorry, I've been conferencing for a few days and\ncompletely ignoring code.)\nWant me to update the pull request, or is this part of the refactor you're\nworking on?\nOn Sun, Oct 26, 2014 at 8:44 AM, Robert B\u00f6hnke notifications@github.com\nwrote:\n\n@lsavino https://github.com/lsavino\nI'd probably prefer addConstraints:layout: (with maybe a default false\nlayout), so I could avoid the flag that opts out of this replace action\nthat gives me the heebie-jeebies.\nWhat about layout/constrain with replace defaulting to false though? So\nyou'd end up with\nconstrain(view) {\n    view.width == view.superview!.width / 2\n    view.height >= view.superview!.height / 2}\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/robb/Cartography/pull/32#issuecomment-60516167.\n. \n",
    "marcelofabri": "You can also do this (I prefer):\nswift\nlayout(view, superview) { view, superview in\n    _ = view.top == superview.top + 100\n}\n. ",
    "DJBen": "Good advice. That's what I am looking for too.\n. It can be something earlier than 8.0. I am just playing safe.\n. I modified it and it passed the validation.\n. ",
    "kreeger": "It's been so long since I've been in the game of writing pod specs; I know a few things have changed. That said I'd be happy to take a look tomorrow morning and try to draft one up for this repo. I'll open a PR.\n. Edited my comment to remove any trace of my prior ignorance! There's indeed some exciting things happening in the @CocoaPods front with regards to Modules / Frameworks and Xcode 6: CocoaPods/CocoaPods#2218. There's also CocoaPods/CocoaPods#2222 which has to happen to include .swift files into the library build target.\nI'll hold off on writing a podspec!\n. ",
    "orta": "no support yet, but @kylef has been making them regardless, https://github.com/kylef/QueryKit/blob/master/QueryKit.podspec\n. ^ will just work, when it works in the cocoapods pipeline.\n. Yep, same deal.\n. NumericalEquality is probably better, constant feels like it comes with extra baggage. DistanceEquality may work, but might imply more than you want.\n. Yep, and I shipped it last week\n. Not sure, you're welcome to check out the PR https://github.com/robb/Cartography/pull/203 and improve the README ( I don't use Cartography, I'm just maintaining the repo )\nand Swift 3.0 seems to be stuck on the CI #228 alas\n. Closing, there's no +1's, and it's not been touched in over a year. If someone wants this feature, feel free to take these commits and build on it \ud83d\udc4d \n. \ud83d\udc4d Sounds good to me. Please don't +1, provide a useful example so people can help you in a new issue.\n. Any chance you can rebase this? I'd like to see if it greens. ( Given that the library supports macOS )\n. Yeah, that's what I figured, any chance you can make this happen for iOS targets only? And if that works, I'm happy to have the podspec's iOS version go down to iOS 7 \ud83d\udc4d \n. Ace \ud83d\udc4d \n. hah, yeah - would be nice\n. @TimothyChilvers this looks good \ud83d\udc4d  - it's worth trying to get this tested and merged \n. @robb that opinion is on you I'm afraid ^\n. Alright, given the comprehensive docs / tests on this PR, I'm gonna merge it tomorrow unless I hear a good to not\n. Hah - nice. OK, let's get this in.\n. This came in with #203 \ud83d\udc4d and was released on 0.7.0 I think\n. No updates, so you're welcome to take a look \ud83d\udc4d . There is an active PR for 3.0 #228 would recommend using that instead \n. Swift 3.0 support is now in 1.0 \ud83d\udcaf \n. Yep - binaries only work on a specific version of Swift. Any minor swift changes requires a new binary.\n. If you can rebase this, I'm happy to get this in \ud83d\udc4d \n. Awesome \ud83d\udc4d \n. Alright - this library is now Swift 3.0 compatible as of v1.0 - thanks for the PR, we got it sorted in #228 \ud83d\udc4d \n. I've given this a look over, and it looks \ud83d\udc4d \nWant to rebase this, and we can have it as a part of the next release?\n. ah, damn - sorry, I just merged #200 and it conflicted with this, any chance you can re-rebase \ud83d\udc6f \n. CocoaDocs is up to date, http://cocoadocs.org/docsets/Cartography/1.0.1/\nI'd recommend sending a PR updating the README to this. funny, I was just working on this - https://github.com/raphaelcruzeiro/Cartography/pull/1\n. No credit to me - it's all @raphaelcruzeiro's work - I'm just getting the CI working\n\ud83d\udc6f \n. Swift 3.0 support is now in 1.0.0 \ud83d\udcaf \n. Rockin' - I think this will also need the travis file updating to Xcode 8 - it's currently 7.3\n. \ud83d\udc4c cool\n. \ud83d\udc4d \n. I've just merged #203  to master, so you might have a little bit more porting to do - sorry!\n. Should also consider switching these deps to CocoaPods, every time I look at the build fails it's because of Carthage using the GitHub API \nAnyway, @raphaelcruzeiro - is the ~ and rpecedencegroup a blocker?\n. Hrm, I haven't looked at Swift 3 but I remember this tweet perhaps you  can try making the name CartographyPriorityGroup ?\n. I've made a note and some PR changes in https://github.com/raphaelcruzeiro/Cartography/pull/1\n. Submitted another PR to hopefully fix CI - https://github.com/raphaelcruzeiro/Cartography/pull/2\n. awww, we got one green \n. env NSUnbufferedIO=YES the random things you have to do to appease the Xcode gods\nOK, IMO this is good to go, will give it a look over tomorrow and give this a good to go, IMO this library has been used in production long enough that this should be the 1.0 given there there is now literally thousands of people relying on it in production\n\n. You should be fine to use 0.7.0 on trunk now\n. Shipped a build to trunk\n\n. It's using the existing tag, I didn't need to do anything there.\n. Hrm, might be worth adding something like - https://github.com/Moya/Moya/pull/630 \nBTW, while we have your attention any idea what this issue might be about? https://github.com/robb/Cartography/pull/228#issuecomment-246684389\n. Cool - no worries - thanks\n. Yeah, please see the README:\n\nIf you need Swift 2.x support, then please use 0.7.0 and below.\n\nhttps://github.com/robb/Cartography\n. \ud83d\udc4d Awesome - thanks!\n. I'm afraid I'm unsure, we're running all the unit tests in Xcode 8, and with Swift 3. Could you be using a version of CP that doesn't support Xcode 8? E.g. are you not using the current release candidate?\n. \ud83d\udc4d great work @vfn \n. Yeah, the implicit LayoutPriority was something we couldn't figure out when porting to Swift 3 - I'd love for you to dig in here and see if you can figure that one out? \n. Perfect! Shipped as 1.0.1 - thanks!\n. \ud83d\udc4d  awesssome\n. Sounds like a good thing for the README - yep\n. (ba dum tsch) . Cool - thanks for the issue, want to try send a PR to fix it for everyone?. Do you know if these are covered by existing tests? OR should I be bugging you to add some? :D. Awesome \ud83d\udc4d . yep, just shipped in 1.1.0 now. Nope, you want to try fix it?. \ud83d\udc4d . \ud83d\udc4d . This is quite a lot of code to just drop without any description, can you please write up a summary of your changes and why?. It currently exists in a vacuum, I'm not really done any Swift in a year, and have never used this library -yet I am the maintainer. I would struggle to judge whether to merge and take over your changes without some kind of explanation?. Thanks for the PR - given the number of of conflicted files and lack of response in a while - I'm going to close this \ud83d\udc4d . \ud83d\udc4d cool, thanks. shipped in 1.1.0. This is a general iOS question, you'd be better off using stack overflow for questions like this.. Sure, PRs are welcome.. Cartography is now a Swift 4 lib, so I'm going to close this, TBH I think this is CocoaPods' responsibility to get right. Sure, want to look at doing it?. Someone else did it, https://github.com/robb/Cartography/pull/262. You'll need to update travis too, I believe. Yep, cool, this looks good, I'll get this major bumped and released.. This looks great - as this is a library used by a lot of people and we don't want to break features in the future, can you add some tests to cover your changes \ud83d\udc4d . These tests are \ud83d\udcaf - amazing. Shipped as 2.1.0 \n\n. OK, so this will need a bit of a rebase - I've released #267 as a 2.1.0 release\nThe idea behind this all seems \ud83d\udc4d  to me, I'm happy to 3.0 it. Oh yeah, my bad \ud83d\udc4d . I'll give this a one over. Ah yeah, can I get an example of how to migrate from 2.x to 3.0? To add to the release notes. Then this is good to go from my side \ud83d\udc4d . Ah yeah, thanks, OK, let's get the 3.0 train going. Yep \ud83d\udc4d . I want to get this merged and in 3.0, so I'm happy for the slight duplication. Rockin'. Interesting, the podspec allows 10.9 - so really that should get an update. I'm going to wait on https://github.com/CocoaPods/Core/pull/417 to add something like this - thanks for the PR though. Want to take a look at debugging this? . Yeah, this looks good to me - thanks for the comprehensive PR text too - will ship a release now. \n. No, those are only for the older last per-swift versions, the full changes are here: https://github.com/robb/Cartography/releases. Sure thing, send a PR?. Use CocoaPods. There's extensive documentation on how to set up to use any dependencies.. Rockin'  -thanks. Cool, thanks!. Seems fine to me, I've seen it on my projects too.. Loop through the property constraints on a view and make them perform removeConstraint. Looks \ud83d\udc4d to me. Sure thing \ud83d\udc4d . Cool, yep - I've shipped a pod and the tags \ud83d\udc4d . Is it this a semver break?. I'm basically the person running this repo, but I've never used it, nor really grok it's trade-offs as I've been absent from Swift for enough years. \nSo I'm happy to go with consensus, and those compilation speed improvements make any pain worth it IMO - it's bad enough without a library making it worse. Did tests pass for you locally? Do we need to update travis?. You'll need to update CI to make this pass \ud83d\udc4d \nCould these changes work in such a way so that it can support both? Assuming 4.2 is the beta version anyway. Yeah, I agree, I've used something like this in our app a few times \ud83d\udc4d \nThis could top with README docs, but I'm ok without it for now.. Very cool, yeah!. Thanks for the non-trivial work, I've shipped this as 3.1.0\n\n. Cool, sure, there's no documentation in the README for this - which it probably needs, but I'm gonna ship it anyway. Would love to see that later \ud83d\udc4d . Cool beans \ud83d\udc4d . \ud83d\udc4d . Do you need a release?. ",
    "phatmann": "The conjugated expressions are interesting, but not really any clearer to me. In fact they are less readable.\nI would not say that == is the \"correct\" operator for \"make two things equal\". On the other hand, you are making a DSL and I understand you want it to be concise. I encourage you to play around with operator punctuation combinations and see if any strike you as acceptable. .== and .> look rather nice :-)\n. @robb You have convinced me that you are using the right operators and that your current approach is semantically sound. My issue is that wrapping the closure in the layout call does not seem to provide enough context to make it clear that the statements within are part of a DSL. I wish the \"delimiters\" were clearer. Looking at the code again, I see that part of the problem is that the repeated view1, view2 is quite noisy. Is there any way to eliminate that bit of ceremony?\n. Actually the $0 and $1 syntax seems like a great improvement in this case. It is quite clear who the players are.\n. ",
    "KristopherGBaker": "I just tried this an a different Mac and it built fine without making the CGFloat change, same version of Xcode, only difference I can think of is the Mac it built fine on is running OS X Yosemite, while the Mac I had issues on is running OS X Mavericks.  Perhaps it's just a bug with Xcode/Swift...\n. ",
    "stevenleeg": "Yes, I just tried adding the project via a workspace and compiling the framework and dragging it into the project, which yields\nld: framework not found Cartography\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\nThis is all on beta 4 now. Sorry for the late response, been super busy over the last few weeks!\n. ",
    "mstfy": "I think content compression resistance and hugging priority is not belong to setting constraints. It should be seperate.\n. ",
    "mazz": "That's great to hear. I can't wait to try Cartography with a playground .. would be a great way to teach autolayout.\n. ",
    "aubrey": "Also hoping for some more docs. Having some issues with subclassing UIViews and using Cartography to lay them out.\nLovely helper library so far though, just can't figure out the subclassing bit :)\n. ",
    "sean-hill": "Same. I'm also curious if this can be used for UIScrollView, UIButton, and UILabel views.\n. So after some playing with the library, I came up with this, is this a correct implementation of Cartography? Or what could I do better?\n```\noverride func viewDidLoad() {\n    super.viewDidLoad()\nlet max = 5\nvar views = [View]()\n\nfor index in 0...max {\n    var view = View()\n    view.backgroundColor = UIColor.blueColor()\n    views.append(view)\n    self.view.addSubview(view)\n}\n\n\nlayout(views) { layoutViews in\n\n    for (index, aView) in enumerate(layoutViews) {\n\n        aView.height == 50\n        aView.width == aView.superview!.width\n\n        if index == 0 {\n            aView.top == aView.superview!.top\n        }\n        else {\n            aView.top == layoutViews[index - 1].bottom + 10\n        }\n\n    }\n\n}\n\n}\n```\nThis yielded the following results.\n\n. ",
    "smileyborg": "@robb Justin has a nice write up on the new attributes here: http://carpeaqua.com/2014/07/24/auto-layout-in-ios-8-layout-margins/\n. BTW, after just implementing support for these myself in PureLayout, I recommend that you (or whoever does this work) tries using them first so you understand what they do :)\nThere are also currently some bugs with iOS 8.0.x auto layout that I've gotten confirmed by Apple, they're working on them. One of them impacts layout margins, specifically the leading and trailing ones don't correctly invert in right-to-left languages.\nJust a heads up!\n. Nice title on this issue, @robb :smile:\nAs far as which views to implicitly call setTranslatesAutoresizingMaskIntoConstraints:NO on, I originally added similar functionality to PureLayout's predecessor, UIView+AutoLayout, in this commit. In the commit message I described a little bit about the approach taken.\nBasically, I found that it only made sense to change this value on views being sent the layout message (in other words, the lhs view in Cartography). The main reason I came to this conclusion is because I had numerous places where I would mix auto layout and non-auto layout views (sometimes it's just easier to use the autoresizing mask, or you want to do animations or interactions that just don't play well with auto layout). In these mixed cases, I found that the lhs view was always the one using auto layout, whereas the rhs view may or may not be (as you note, it could be a table view cell's contentView, or a view controller's view, etc). And in the cases where both the lhs and rhs were auto layout views, I found that there was always some other layout constraint where the rhs view was used in the lhs -- meaning, it would get translates... set correctly at that point.\nI definitely tried to err on the conservative side. I haven't seen a single issue (from myself or anyone else) about this behavior, and it was implemented ~9 months ago, so at this point I'm pretty comfortable saying it's probably the right way to do it. Trying to maintain a blacklist or whitelist of views is definitely going to be an exercise in futility :stuck_out_tongue:.\nI do encourage use of these methods when creating views you know will use auto layout. But the implicit behavior above helps if you forget to do that.\nLet me know what you think.\n. A side note, I don't think your reasoning about the == operator (as used here in Cartography) being \"symmetric\" is accurate. Because of how it gets translated down into a linear equation in the constraint, there is a difference with whether a view is on the left or right side. Your == is just syntactic sugar for that, not a true \"equality\".\n. You're welcome! Cartography is definitely my favorite take on auto layout, for those who have the luxury of working in a pure-Swift world.\n. I agree with #143 for sure, is that what you're asking? There are a bunch of changes in this PR though so I didn't look them over closely, did you want me to look at anything in particular?\nBTW, on the note of significant breaking changes like this, I'd love to also explore what Cartography would look like if it didn't use closures passed to constraint (or layout) and instead added some \"NSLayoutAnchor-like\" properties of type LayoutProxy to UIView/NSView, which would let you use the custom operators to create constraints without having to pass the view(s) into a closure first. Not sure if you've thought about this at all -- I haven't had time to fully think it through, but it seems like it could be a huge improvement.\n. Yeah, that's the general idea of how it would work. Except the main difference in what I was thinking is that we do not need any prefix (car_ in your example) for the methods added to UIView/NSView. There are two reasons why I think a prefix is not necessary:\n1. Swift has proper namespacing so that two methods of the same name don't actually collide and cause undefined behavior at runtime, like Objective-C. So if Cartography defines some methods in an extension that even UIKit decides to adopt in some future SDK version, the implementations remain separate (and if you had to, you can explicitly call one based on its module). Disclaimer: I've not tried this myself yet.\n2. Even with point 1 above, I think it's completely reasonable to come up with a slightly more unique name than just width, height, etc -- very much like NSLayoutAnchor names: widthAnchor, heightAnchor, etc. What about layoutWidth, layoutHeight, etc? Or we could even just hang 1 property on UIView/NSView: layout, and then expose each attribute without a prefix on that one property. So it would look like:\nview1.layout.width == view2.layout.width\nview1.layout.height == view2.layout.height\nPersonally, I definitely lean towards eliminating the need to call a function and especially the need to pass in everything you want to constrain up front, when clearly it's not actually necessary. This would remove code from and simplify Cartography itself (c.f. ec439ab6e33b3fd0c5b94b03d4157e91e7cc0ef3) as well. I think it would be a lot cleaner, and would be worth the tradeoffs.\nI don't think it's our responsibility to force users of the library to organize their code in a certain way, so I don't buy that justification of using a constrain function. For the layout function it made sense, because it was creating a scope at the end of which we'd run layoutIfNeeded, but that function was just removed.\nAnd Cartography's operator overloading is very reasonable because it only applies to the LayoutProxy type. So I don't find it \"risky\" to have it available globally.\nAnd to #97, this should be completely doable with either approach. (I considered doing this for PureLayout in fact, just never got around to it!)\nUltimately I'd love to see this implemented in a separate branch, to compare against the current way of doing things. It should be fairly easy. I think that's the best way to truly judge the merits of each approach, and other users of Cartography would be able to weigh in.\n. ",
    "ReedD": ":+1:  removing a constraint would be helpful too.\n. ",
    "PiersonBro": ":sparkles: :tada: Thanks!\n. Nope! #29 fixes the issue!\n. Also, Should we add Unit tests for this? I didn't see a place where the Array based variant was tested so I didn't add a test. If you want me to I'll gladly add it. \n. Shouldn't Edge conform to Multiplication?\n. Well I use it for CenterX and CenterY like this: \nSwift\nconstrain(view) { (view) in {\n   view.centerX == view.superview!.centerX  * 2\n}\n. \ud83d\udc4d\n. ",
    "mwhuss": "let margin = 10.0\nview.top == view.superview!.top + margin`\nResults in:\n\nCannot invoke '==' with an argument list of type '(Edge, $T9)'\n\nview.top   == view.superview!.top + CGFloat(margin)\nResults in: \n\nCannot invoke '+' with an argument list of type '(Edge, $T11)'\n. No, it happens in multiple line blocks as well. Let me know if you'd like\nan example project.\n. Here you go https://dl.dropboxusercontent.com/u/14393/CartographyConstants.zip\n. Ah great, thanks!\n. \n",
    "hfossli": "What I'm saying here might not be related to constraints, but FYI UIKit is quite trigger happy when it comes to (re)layout. See my example project here https://github.com/hfossli/LayoutSubviewsInconsistency\n. ",
    "zdnk": "yes, awesome, however is branch \"refactor\" ready for production use?\n. haha, nice, ok\nI will add it to my project and test it out :)\nHaha nice one :+1: \n. If you accept this, please do merge it into refactor branch also :)\n. \nI hope that is enough. It crashes in Context.swift:36\n. Ok, the weird thing is there really are not common ancestors after updating to Xcode 6.3 and Swift 1.2 :O \n. The issue was on my end with initializers since the approach changed in Swift 1.2\n. ",
    "GarthSnyder": "Sure! However, the tests may need closer scrutiny than the original patch -- I'm not certain I did this right. \nSince this is not a public part of the API, I broke it out into a separate file that is compiled into both the framework and the test target. I had to add a -DTEST compiler flag to allow it to compile in both contexts.\nIt looks like the Mac tests haven't been groomed yet, so I didn't try to pursue that. However, it should just work when that's all ready to go.\n. ",
    "ratkins": "So it seems what I'm attempting to do (link directly with a binary framework) is not possible, or at least not recommended at this point in Swift's evolution. So you do indeed have to go through the whole git submodules palaver, and build 3rd party libraries such as Cartography as dependencies of your main target. I have managed to get everything to build by following the installation instructions for Alamofire.\n. ",
    "dkrdennis": "I still got this issue. \nAfter a import to Xcode of all the files in the Cartography i get the error: \"Use of unresolved identifier 'layout' \" And I have no idea how to solve this problem.\nAnyone have a walkthrough to use Cartography in your iOS project supporting iOS 7\n. :+1:\n. Hey\nThe problem is that Cocoapods doesn't support iOS 7, i haven't tried Carthage. \nBut now i fixed my problem, all the Cartography swift files also needed \"target membership\" to my test target.\n. ",
    "guibury": "change the layout(tableView) { to constrain(tableView) {\n. I had this issue after import.\nJust change the layout(contentView) { contentView1 in to constrain(contentView) { contentView1 in\n. ",
    "jimjeffers": "Nevermind. Spoke to soon. Some more fooling around and I realized it was trivial. Sorry about that. Here's a quick snippet as an example.\n```\nlayout([UIView(), UIView(), UIView(), UIView(), UIView()]) { (views) -> () in\n// Pin first and last views to edges.\nviews[0].left               == views[0].superview!.left\nviews[views.count-1].right  == views[views.count-1].superview!.right\n\nfor (index, view) in enumerate(views) {\n\n    // All views should match the height of their parent\n    view.top                == view.superview!.top\n    view.bottom             == view.superview!.bottom\n\n    if(index > 0) {\n        // All views should be the same width.\n        view.width          == views[index-1].width\n\n        // All views should be 2dp apart\n        view.left           == views[index-1].right + 2 ~ 400\n    }\n\n}\n\n}\n```\n. ",
    "martinnormark": "I think everything you need here is to add a tag so that Carthage can keep track of versioning. Right now, I get this error: No tagged versions found for github \"robb/Cartography\"\n. ",
    "michaeleisel": "Thanks, I'll do that then :)\n. ",
    "ngoccuong291": "Looks like I have the same issue:\n```\n        var margin = 15\n    layout(productView) { view in\n        view.left   == view.superview!.left + margin\n        view.right   == view.superview!.right - margin\n        view.top   == view.superview!.top + margin\n        view.height == view.width\n    }\n\n```\n. @robb Looks like it's a good solution for the time being. Thanks\n. ",
    "CVertex": "@robb Would you ever consider adding CGFloat support? I started implementing this and realized it's not really worth it.. Thoughts?\nI suppose you could abstract the Double, Float and CGFloats into a common data type like this library https://github.com/seivan/ScalarArithmetic/blob/master/ScalarArithmetic/ScalarArithmetic.swift\n. Nice solution\n. +1 :)\n. Where's this at? Would love to see this in my favourite AutoLayout library :)\n. great! Can't wait! :)\n. Is it to do with type inference? Swift is still a dog with that. @solomon23 nice!\n. ",
    "felixjendrusch": "How about context.clear() (or remove, uninstall, ..)?\n. Did you mean constrain(view, replace: group) { view in (not calling constrain on group)?\n. ",
    "onselakin": "Thanks for the help :-) Must've read the other issues first.\n. Didn't help. The code is already the same with the one you posted. I still get this error.\n. ",
    "mono0926": "Thanks, that's right :+1: \n. > do you need me to tag HEAD?\nI use my fork for the time being, so don't worry about that.\n. ",
    "whisper-bye": "yes, I did it, but there have nothing in the screen\n. Aha!\nIt seems to work very well\nI think I know how to use the Cartography\nThanks for your great work!\n. ",
    "drosenstark": "Ok, got it, thank you!\n. Hmmm... on the one hand, this is very simple. I must use Cartography as a separate .framework instead of including the sources directly in the Xcode project... \nOn the other hand, I'll have to open up another ticket about all my issues getting Cartography to work as a framework, whether via CocoaPods or just grabbing the .framework directory and pulling it in (runtime errors).\nThanks for your time and this framework!\n. Wow, okay! I'm using Float(someVar) instead of CGFloat but it all works now. Thanks for responding (and for Cartography, again)!\n. Would be nice to have a FAQ instead of having to look through issues. Not sure if GitHub does that....\n. Sorry, I should explain. \nRed is a rectangle that might be tall or it might be wide at runtime. It sizes so its superview, which might rotate and change size.\nGreen should be a square that is 90% the width/height of the smallest side of red.\n. This is your code, remixed, but it works perfectly, thank you!\n```\nlet percent = 0.3\nlayout(red, green) { red, green in\n    red.center == red.superview!.center\n    red.size == red.superview!.size\n    green.center == red.superview!.center\n// lower priority\ngreen.width  == red.width  * percent ~ 100\ngreen.height == red.height * percent ~ 100\n\ngreen.height == green.width  // higher than ~ 100 priority\ngreen.width  <= red.width  * percent\ngreen.height <= red.height * percent\n\n}\n``\n. Got it:percentwas aFloat, but now you need aCGFloat`\n. Got to delete a lot of code thanks to this response, which is, for me, the most exciting thing in writing code. Also managed to figure out my autolayout conflicts. \nThank you!\n. Use the built-in stuff:\nconstrain(view1, view2, view3) { view1, view2, view3 in\n    distribute(by: 10, horizontally: view1, view2, view3)\n}\nSee the readme!\n. The built-in stuff is just a convenience method. Doesn't do either of these:\n- size views to distribute (as above)\n- size gaps to distribute\n. Use UIStackView for distribution stuff like this. Make sure to set alignment, distribution, axis, and spacing. \n. ",
    "tcurdt": "CocoaPods (0.34.4) with Xcode 6.1 (6A1046a).\nDownloading Xcode 6.1.1 as we speak.\n. Yup. I guess it's update time today then. Thanks.\n. Turning off AL for the view controller in IB did the trick.\nWith the left I am still not totally clear on how that is e.g. different from view.centerX == view.superview!.centerX * 0.5 - which works.\n. ",
    "brandonroth": "Using constrain works in my situation and eliminates the problem.  Thanks for cluing me into the constrain method.\nthink the phantom constrain thing is either a bug / feature / something else in the layout engine itself because I experienced it again when working with a dynamically sized tableview header.  My problem there is that I had called layoutIfNeeded on my header before adding it to the tableview and I was seeing the same phantom constraint.\n. ",
    "jamescmartinez": "Hey @robb, Swift 1.2 is out of beta. Let me know if I can help in any way.\n. ",
    "mergesort": "Fair points. I think https://github.com/robb/Cartography/issues/77#issuecomment-73859870 might be too specific, but is closest to what I'd envision. There could be a function that takes in a set of views, and an edge/dimension/size.\nlayout(view1, view2, view3) {\n    equal([view1, view2, view3], Edge.top) // or Dimension or size\n}\n. @truppelito Var args sound good to me. :+1: \n. All good. \\o/\n. ",
    "truppelito": "@mergesort Just my two cents: if you exchange the order of the arguments you can dispense with the square brackets by using variadic parameters equal(Edge.top, view1, view2, view3). That's probably better?\n. By the way, in the case of the project that I'm working on I actually don't want to layout the views after removing the constraints (hence the constrain instead of layout), but I'm sure there will be need for both, so I'd suggest adding a method to ConstraintGroup like uninstall(#layout: Bool). Pretty much what you already have with replaceConstraints(constraints: [Constraint], performLayout: Bool) except that constraints here is an empty array.\n. @robb That's perfectly fine with me.\n. Well, I do prefer align. :+1: Cartography functions are mostly verbs (i.e. constrain, layout, replace, clear, align, etc), so alignedBy is not as good IMO.\n. Oh, btw, have you considered adding a priority argument to the align functions (with a default value of 1000)? It's probably not that necessary, though.\n. Oh! Nice one! Yeah, makes sense, ~ operates on NSLayoutConstraint and arrays thereof. :sparkling_heart:\n. That sounds awesome! Great idea. Also, what about something akin to dstribute that automatically creates spacer views (and the correct constraints) for when spaces between views should be the same? This is a pretty common pattern with auto-layout (at least for me).\nFor example: distribute(by: .Equal, horizontally: view1, view2, view3) would be equivalent to:\n```\n// Add spacers to superview\nlet spacer1 = UIView()\nlet spacer2 = UIView()\nview1.superview!.addSubview(spacer1)\nview1.superview!.addSubview(spacer2)\n// Assume superview exists? Assume all views (view1, view2) are siblings\nview1.right == spacer1.left\nspacer1.right == view2.left\nview2.right == spacer2.left\nspacer2.right == view3.left\nspacer1.width == spacer2.width\n```\nPS: distribute by equal horizontally doesn't sound very good. The syntax should probably be different.\n. > I think I'm pretty :-1: on mucking with the view hierachy as a side-effect.\nI understand that perfectly. I think I'll stick to my own helper function for this then.\n. Here's the gist. It's not exactly what I was using, so I had to modify it a bit. And Xcode wasn't compiling anything, so I couldn't test it. If anyone's interested and finds a problem, feel free to leave a comment there.\n. ",
    "brow": "Thank you! \u2728\ud83c\udfb8\nOn Wednesday, February 11, 2015, Robert B\u00f6hnke notifications@github.com\nwrote:\n\nClosed #78 https://github.com/robb/Cartography/issues/78.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/robb/Cartography/issues/78#event-233820043.\n. \n",
    "Arvkon": "How about copying the value that I'm after (view.bottom)? Would that be possible?\n. Thanks! The solution you propose does solve my problem =)\n. ",
    "TosinAF": "This is pure gold ! #stackViews\n. ",
    "lbrndnr": "Oh shit, was a long day yesterday. Sorry for taking your time with such a dumb issue :)\n. ",
    "johnnyoin": "I was about to post the exactly same issue :)\n. ",
    "ghost": "I think we should have this feature as well. In the time being, I simply adjust the frame during viewDidLayoutSubviews operation to accommodate topLayoutGuide.\n. Solved. Managed it by subclassing UIView, overriding didMoveToSuperview and calculating width and height with methods returning CGFloat\n. ",
    "remzr7": "+1\n. ",
    "leftspin": "+1\n. ",
    "JohnCoates": "Just ran across the need for this also. What would be a good way to implement it? Would a significant amount of code have to be changed to adopt this? I'd be interested in contributing to making this happen.\n. adding higherThan: AssignmentPrecedence to precedencegroup CarthographyPriorityPrecedence fixes the first error.\nNot sure what the best fix for the second & third errors are, but wrapping the priority in LayoutPriority() makes it compile at least.\nconstraint = view.width == 200 ~ LayoutPriority(100)\n. Okay, sure I'll have a go at it\n. I believe this is a bug with the compiler.\nI've filed a Swift bug report and a radar about this issue. The more radars that get filed, the more traction the bug gets, so I recommend filing one also.\n. ",
    "leszarna": "+1\n. ",
    "nuudles": "Moving the discussion here from #137 \nI played around with this a bit and have what may at least be a workaround for now until we can properly extend protocols with inheritance. What do you think of something like adding a method like this:\n``` swift\n    internal func addConstraint(from: Property, to: UILayoutSupport, coefficients: Coefficients = Coefficients(), relation: NSLayoutRelation = .Equal) -> NSLayoutConstraint {\n        from.view.car_translatesAutoresizingMaskIntoConstraints = false\n    let layoutConstraint = NSLayoutConstraint(item: from.view,\n        attribute: from.attribute,\n        relatedBy: relation,\n        toItem: to,\n        attribute: NSLayoutAttribute.Bottom,\n        multiplier: CGFloat(coefficients.multiplier),\n        constant: CGFloat(coefficients.constant))\n\n    var view = from.view\n    while let superview = view.superview {\n        view = superview\n    }\n    constraints.append(Constraint(view: view, layoutConstraint: layoutConstraint))\n\n    return layoutConstraint\n}\n\n```\nAnd then adding new operators like such:\n``` swift\npublic func == (lhs: P, rhs: UILayoutSupport) -> NSLayoutConstraint {\n    return lhs.context.addConstraint(lhs, to: rhs)\n}\npublic func == (lhs: P, rhs: Expression) -> NSLayoutConstraint {\n    return lhs.context.addConstraint(lhs, to: rhs.value, coefficients: rhs.coefficients[0])\n}\n```\nThis would enable you to do something like:\nswift\nconstrain(view) {\n    (view) in\n    view.top == topLayoutGuide\n}\nI don't like the fact that I explicitly use NSLayoutAttribute.Bottom, so I'm wondering if there's a more elegant way there. I'm not sure, for instance, what would happen if you use the bottom attribute with a bottomLayoutGuide\n. I'd really like to get this working and am willing to help implement. The hard part is figuring out the best way to do this without ripping out a lot of the safety type checking inherent in the current iteration.\nMy first hope was to create a protocol like Constrainable and remove most instances of View for Constrainable, then extending View to conform to Constrainable, which would work, but then using the current version of Swift, we can't extend the UILayoutSupport protocol to conform to the Constrainable protocol, even if it's empty...\nIt sucks because even the NSLayoutConstraint initializer takes in AnyObject rather than any sort of view of protocol, so we could change the Cartography API to use AnyObject in all the constrain functions, but then you lose the type safety.\nThoughts on the best way to refactor the library to support this?\n. @robb So I played around with it a bit and have what may at least be a workaround for now until we can properly extend protocols with inheritance. What do you think of something like adding a method like this:\n``` swift\n    internal func addConstraint(from: Property, to: UILayoutSupport, coefficients: Coefficients = Coefficients(), relation: NSLayoutRelation = .Equal) -> NSLayoutConstraint {\n        from.view.car_translatesAutoresizingMaskIntoConstraints = false\n    let layoutConstraint = NSLayoutConstraint(item: from.view,\n        attribute: from.attribute,\n        relatedBy: relation,\n        toItem: to,\n        attribute: NSLayoutAttribute.Bottom,\n        multiplier: CGFloat(coefficients.multiplier),\n        constant: CGFloat(coefficients.constant))\n\n    var view = from.view\n    while let superview = view.superview {\n        view = superview\n    }\n    constraints.append(Constraint(view: view, layoutConstraint: layoutConstraint))\n\n    return layoutConstraint\n}\n\n```\nAnd then adding new operators like such:\n``` swift\npublic func == (lhs: P, rhs: UILayoutSupport) -> NSLayoutConstraint {\n    return lhs.context.addConstraint(lhs, to: rhs)\n}\npublic func == (lhs: P, rhs: Expression) -> NSLayoutConstraint {\n    return lhs.context.addConstraint(lhs, to: rhs.value, coefficients: rhs.coefficients[0])\n}\n```\nThis would enable you to do something like:\nswift\nconstrain(view) {\n    (view) in\n    view.top == topLayoutGuide\n}\n. @aocenas You're absolutely right! My mistake. I was going on the assumption that UILayoutGuide was the same as topLayoutGuide and bottomLayoutGuide based on the name of those properties. Silly me. I'll move my discussion regarding topLayoutGuide and bottomLayoutGuide to issue #95 \nSince UILayoutGuide is just a class, not a protocol, we can probably do the Constrainable protocol as described above and simply extend View and UILayoutGuide to conform to it. For the translatesAutoresizingMaskIntoConstraints I wonder if it makes sense to have another protocol to conform to or if you should just do the cast like:\nswift\nif let view = from.constrainable as? View {\n    view.car_translatesAutoresizingMaskIntoConstraints = false\n}\nEither way, I think that would be the only unclean aspect to the Constrainable approach, other than having to implement the various anchors for UILayoutGuide as Edges. Once Swift allows protocols to be extended to conform to protocols, we can even look towards having the topLayoutGuide and bottomLayoutGuide conform to Constrainable.\n. @robb It might be worth noting that I built this using the tvos branch of the CocoaPods project. It may cause problems if someone tries to use it with an official CocoaPods release.\n. ",
    "domhof": "+1\n. ",
    "namanhams": "I made a Pull Request to enable this feature.\nBasically, NSLayoutConstraint functions require params to be AnyObject, not UIView. That's how you can pass in the topLayoutGuide and bottomLayoutGuide object. \nSo i exploit this and change the type of View to NSObject, and change in few places that assume View is UIView. The changes are actually very minor. \nI tested this in my app and it works fine. \n. UIKit and CoreGraphics always use CGFloat for size/dimension, they never use Double. So i think we should use CGFloat here.\n. Sorry for that. I've already fixed it. This is simple fix. \n. You look at the init function of NSLayoutConstraint. The param type is AnyObject, not UIView. This is Apple provided framework. And why is that so ? Because that's how Apple allows NSLayoutConstraint to work with LayoutGuide. \n. ",
    "ryanthon": "Any chance this will be integrated soon?\n. ",
    "Sajjon": "Is the support for layoutGuide merged yet? :) \n. @orta Nice! So with support for Swift 3 as well?\n. @orta What is the syntax? I did not find it in the README \n. @orta I took a look at the build log for #228 travis job fails due to\n\n\u274c  /Users/travis/build/robb/Cartography/CartographyTests/Matchers.swift:2:8: no such module 'Nimble'\n\nUp in the log I see that Cartography is using a alpha version of Nimbl\n\nInstalling Nimble (5.0.0-alpha.30p1)\n\nThen I took a look at the Nimble repo\nSeems like 5.0.0 was released 7 hours ago!\nMaybe using that version will fix it? :)\n. ",
    "aranasaurus": "My initial thought was that it would be really nice if there were an operator like the ~ used for priority that would allow us to specify the identifier per statement.\nDoing automatically with filename and line is also an interesting concept.\n. ",
    "mortenholmgaard": "My bad - it is already there.\nBut please add it to the documentation in the README\n. Yes that was the problem - but I have tried to it do it but I didn't seem to exist..\n. ",
    "akolov": "That was super fast! Thank you a lot! :)\n. Our CI doesn't have development identities installed, and fails to build at codesign step if we leave it at is.\nI'm building on Bitrise with Carthage.\nAs for Mac, you could probably keep them as iOS. But then again, if someone tries to build that with real identities or w/o iOS ones...\nThe main issue is that Carthage takes whatever identity is specified in the project, without any way to override.\n. No, originally you had \"iPhone Developer\" identity in the global project setting, which is then propagated to Mac Framework as well.\nAs for the platform setting, I'm aware of it, but thanks :)\n. ",
    "solomon23": "Looks like the latest is still leaking. Here's a sample project it has a branch for the old and new:\nhttps://github.com/solomon23/CartographyLeak\nhttps://github.com/solomon23/CartographyLeak/tree/latest\nIf you run it you can see if you click the red view a deinit never happens\nI think the other issue I'm facing is that the newer cartography sets \nsetTranslatesAutoresizingMaskIntoConstraints(false)\nOn both views where the old version just set it on the left view.  The problem is I have something I want to autolayout set inside a view constructed with frames ( because I want to animate it without autolayout ) so that breaks things for me\n. Looks like the translatesautorisingmask on the right hand item was fixed as #99 which hasn't made it over to the 6.3 branch\n. I've created this fork that should get you at least to compile: \nhttps://github.com/solomon23/Cartography/tree/3.0\nor via pods\npod 'Cartography', :git => 'https://github.com/solomon23/Cartography.git', :branch => '3.0'\n. You might want to look at mine here : \nhttps://github.com/solomon23/Cartography/tree/3.0\nI could do a pull too\n. ",
    "aral": "Thanks for the tip :)\n. ",
    "VincentWenShuo": "Thanks for reply. I tried with the latest code, it is still the same.\nMaybe LayoutProxy is keeping the strong reference to the passed in view.\nCheers\n. Yes, it is fixed now. Thanks a lot. \n. ",
    "hermanolsson": "Thanks, I'll give it a try.\n. constrain takes a maximum of 5 views, but there is an overload taking an array of views you probably can use.\nIf each of the views don't have a relation to all other views, consider splitting them up into multiple constrain blocks.\n. ",
    "sixcircuit": "Makes my life easier. You might want to remove the part in the docs that says \"file bug reports about name collisions.\"\nOn Fri, Apr 17, 2015 at 2:12 PM, Robert B\u00f6hnke notifications@github.com\nwrote:\n\nClosed #119.\nReply to this email directly or view it on GitHub:\nhttps://github.com/robb/Cartography/issues/119#event-284251400\n. \n",
    "eholshouser": "Yeah, I somehow briefly forgot that this was a Swift framework and deleted my comment shortly afterwards when I realized my mistake. Sorry for the misunderstanding.\n. ",
    "jessesquires": "I think that should be possible. As the owner, you would need to create the gh-pages branch, then I could submit a PR there\n. After merging, everything should appear at http://robb.github.io/Cartography\n. Hey @robb - my thoughts for this PR were to simply get everything setup. Then subsequent PRs could refine actual documentation. That process would likely be:\n1. Submit PR to master that adds documentation\n2. Submit PR to gh-pages that regenerates docs from master\nBut, I'm happy to help with documentation changes too.\n\nIs there a way to hide certain classes, structs or methods?\n\nYes, using the /// :nodoc: comment will prevent members from being documented. (example)\n\nI don't suppose there is a way to move the operators under their respective protocol?\n\nUnfortunately, not that I know of since these are top-level functions. But, we could open an issue on jazzy.\n. ",
    "zwaldowski": "gh-pages can indeed exist with its own separate history, great for deploying docsets.\n. I will speak to really liking the constrain scopes, and regardless of it \"actually\" being a problem in practice or not, having foo == bar in a bare scope reads like an unused equality statement and not anything even remotely related to layout.\n. ",
    "AaronZhang2015": "I tried it, and fixed it. Thanks!!!!\n. ",
    "wiggzz": "Yea.  The alternative would be to still specify first and rest, but to allow rest to be specified as an array.  Or we could ensure that the code is still safe (and does nothing) if none or only one view is specified in the array, as you would expect.\n. ",
    "tyregor": "I'm pretty new to Carthography and I would really like the addition of arrays of views to align and distribute. I do understand the concern regarding the compile time guarantee for the presence of at least two views, but what about situations in which you don't know the number of items at compile time? Since there is no way of converting an array to something that can be used as varargs, there is just no elegant way of handling this with cartography right now. \n. Perfect! Exactly what I was looking for. Thx\n. ",
    "JohnEstropia": "@robb First of all, Cartography has been a great help for us and we've been using it as default now, so thanks a lot!\nI'd like to request the ability to pass array views as well, and to be honest I am not convinced of the current arguments against them:\n\nIt removes the compile time guarantee for there being at least two views present \n\nThe current align() and distribute() methods don't as well. You can still write\nalign(trailing: view0)\ndistribute(by: 0, horizontally: view0)\nwithout any compiler warnings or errors.\n\nwhile doubling the API surface (we'd have to do the same for all the align methods, too).\n\nThis is burden on the implementer, not on the API consumer, right? So once the methods are implemented I don't think there would be disadvantages from then on.\nThe problem right now is that if I pass an array to constrain(), there is no clean way to use align() and distribute() methods without prior knowledge of the array count. This forces writing something like:\nconstrain(viewArray) { views in\n    switch viewArray.count {\n    case 2: align(trailing: views[0], views[1])\n    case 3: align(trailing: views[0], views[1], views[2])\n    case 4: align(trailing: views[0], views[1], views[2], views[3])\n    // ... and so on ...\n    }\n}\nEven worse, if the array has no guaranteed maximum (user-added views perhaps) then there's clearly no way to work around it at all.\n. ",
    "shergin": "Or, please, just make reduce method public.\n. ",
    "corujautx": "Should we consider closing this PR as these changes were made in this merged pull request?. I added four more tests, all of them covering the cases in which no constraint should be returned when the array contains a single or no instance of LayoutProxy.. Also, because I extended the number of constrain overloads this should also fix #263 . The breaking change that this PR introduces is that code that today looks like this\nswift\nconstrain(view) { view in \n    view.top == vc.topLayoutGuideCartography\n}\nwill change to:\nswift\nconstrain(view, vc.car_topLayoutGuide) { view, guide in \n     view.top == guide.bottom\n}\nThis adds more flexibility as you can also now constrain to the top/height attributes of an UILayoutSupport.\nThe whole idea in this PR is to unify UIView (or NSView in macOS), UILayoutGuide and UILayoutSupport as constrainable elements, represented by the protocol LayoutElement.. @inamiy I added the requested fixes and I also think this PR also deprecates #267 as it also solves that problem.\nps: #265 is also a duplicate of this. Okay, I merged the current master with my fork. Please check if everything is okay and we can merge and release Cartography 3.0 :). Can you check it @orta , @inamiy ?. I posted above but:\nThe properties topLayoutGuideCartography and bottomLayoutGuideCartography have been replaced by car_topLayoutGuide and car_bottomLayoutGuide respectively. Those now are to be injected in constrain instead of the block that is supplied to the method.\nCode that today looks like this:\nswift\nconstrain(view) { view in \n    view.top == self.topLayoutGuideCartography\n    view.bottom == self.bottomLayoutGuideCartography\n}\nnow will look like this:\nswift\nconstrain(view, self.car_topLayoutGuide, self.car_bottomLayoutGuide) { view, topLayoutGuide, bottomLayoutGuide in\n    view.top == topLayoutGuide.bottom\n    view.bottom == bottomLayoutGuide.top \n}. @orta I posted the explanation above, please check.. @pprevalon That is why I added more overloads to constrain to support more than 5 elements (now it supports up to 10 elements).\nThe reason why this happens is because Swift doesn't allow us to use covariant generics, but instead all are invariant, making the array conversion a problem. e.g. the signature is func constrain<T: LayoutElement>(elements: [T], block: ([T.LayoutProxy]) -> Void) which basically means that if you use an array of View it'll generate a constrain method that takes necessarily a block that uses [ViewProxy] instead. Perhaps I could use LayoutProxy instead, but I feel that'd be more of a hassle than a solution, given that it'll create a casting hell and messes with type-safety.\nIf anyone has any solution to this problem, or a way to work around it, it'd be nice to hear, but I can't think of a way in Swift to create a working interface for that.. @NachoSoto if you need to use top layout guide and bottom layout guide you could use:\nswift\nconstrain(self.scrollView, self.car_topLayouGuide, self.car_bottomLayoutGuide) { scroll, topGuide, bottomGuide in \n    scroll.top == topGuide.bottom\n    scroll.bottom == bottomGuide.top\n    scroll.leading == scroll.superview!.leading\n    scroll.trailing == scroll.superview!.trailing\n}. I think there is a deeper issue with this one. Is there a way on Mac OS X 10.9 of enabling constraints without appending them to a view? Because the support to layout guides implies that the API should enable constraints for those without needing the reference view.. I fixed that on my fork but I want to add more things before opening a PR to 3.0.2 as I recently opened the 3.0.1 PR. \nPlease see discussion in #277 . The fix I provided in my fork should work without problems for users of Swift 3.2, so you don't need to manually change that.\nPlease check @ https://github.com/corujautx/Cartography. Which functions are you thinking of making public and what extension are you thinking of adding to LayoutProxy? I'm think of refactoring it a bit to add type safety (aka Edge will be turned into a protocol instead, and we will have TopEdge, BottomEdge... as type-safe edges to make sure Edges, Point and Size are initialized with the correct types).\nI did not expose those functions because it means that people would have access to an API that would not be meaningful to them externally.\nPS: if you are thinking of being capable of constraining view controllers, I've been thinking of a similar idea, creating a layout proxy that would not be positionable but would instead offer properties as view, topLayoutGuide and bottomLayoutGuide so we could ditch car_topLayoutGuide and car_bottomLayoutGuide type erasures.. Hmm, I'm thinking of avoiding this in Edges because it semantically represents the edges of a certain layout element (its top, leading, bottom and trailing edges respectively).\nWhat you do basically exposes to runtime errors, as the edges on each side have to match the edges on the other side otherwise we would have a fatal error. I kinda wanna avoid this type of things, plus I feel it's not semantically representative.\nOne option maybe is creating an == operator for arrays of Property? e.g. [statusView.bottom, statusView.left, statusView.right] == [statusView.superview!.bottom, statusView.superview!.left, statusView.superview!.right] but that still is prone to runtime errors and I have no clue what is the proper behavior to be applied to operators like + and * in an expression like that.. @orta could you please check this? Thanks!. It was removed because Cartography now supports constraining UILayoutSupports and UILayoutGuides by using the constrain function.\nConsider replacing your code where topLayoutGuideCartography is used to something akin to:\nswift\nconstrain(view, self.car_topLayoutGuide) { view, guide in \n     view.top == guide.bottom\n}. iPhone X in landscape mode has different guides for left, right, leading and trailing. Do you mean as making the old API available again and using it as a proxy to safe area's top and bottom automatically? I mean, I think it's good but it'd need quite a bit of refactoring as the logic is different. \nWhen you pin to a safeAreaLayoutGuide, you match .top to .top, where as by using one of the UILayoutSupport guides you'd usually match the .top of a view to the .bottom of the guide, and vice-versa.. I'll be patching up that. Thanks @inamiy . Also, owningView has been implicitly tested. I think the missing test cases are for safeAreaLayoutGuide which I'll also add. I'll also rename LayoutElement to LayoutItem.\nI'll try to figure out something about the IUOs.\n. Yeah, sorry about that.\nHere's the problem tho: this introduces a bug/breaking change on the library depending on how people use it, and I kinda discovered that by pointing out my fork to a project we are developing at our company.\nWhen I centralized the translatesAutoresizingMaskIntoConstraints in the proxy generation step I was thinking \"Hey this is going to make the library a lot more simple\", but the issue is that lot of people use the syntax as in: \nswift\nconstrain(view, superview) { view, superview in ... }\ninstead of:\nswift\nconstrain(view) { view in \n    view.top == view.superview!.top\n}\nin order to avoid IUOs\nWhen we moved to the proxy code, the first case generated a side effect of setting up translatesAutoresizingMaskIntoConstraints in the superview, and this broke the layout of several root views in UINavigationController or any container view controller. \nI couldn't predict this side effect being generated by the code I made, so I changed back into the original behavior of the library, even if it looks ugly, to avoid more breaking changes.. ",
    "3webbg": "I can not find swift-2.0 branch?\n. ",
    "sdgandhi": "@robb What still needs to be done on this? Would love to help out.\n. ",
    "aocenas": "Hi, just wanted to ask whether it makes sense for me to try and do a PR for this. I see that you have \"help wanted\" tag on some issues, but not here so I am not sure if that means you want, or you are, already working on this yourself.\n. @nuudles maybe you wanted to solve this issue: #95 ? At least I understood that this one is about ability to use UILayoutGuide objects directly the same way as views, for example:\nconstrain(view, myLayoutGuide) { view, guide in\n    view.center == guide.center\n}\nMaybe there is some solution that would allow both to work seamlessly, but I am not sure how as top or bottomLayouteGuides can be used only on right hand side.\nIn case of UILayoutGuides, I think that something like the Constrainable protocol, as you mention, extending both UIView and UILayoutGuide could work. constrain() would take Constrainable instead of UIView and constrains would be created with anchors (or maybe not, not sure if you could just put UILayoutGuide into NSLayoutConstraint.init(), but it takes AnyObject so I need to check). Maybe there will be some ugly casts somewhere, for example when setting translatesAutoresizingMaskIntoConstraints, but otherwise I think it could be fairly clean.\n. ",
    "davidbarsky": "So it seems to me (and I might be wrong! Please correct me) that you don\u2019t have a type error for the first two statements, but your Constants.height and Constants.width are defined as CGFloats. I\u2019ve had something similar happen to me; try dropping the Constants.file, and instead use a raw numerical value. That might solve your type error.\n. Are you saying that the values of the Constants file are updated dynamically at runtime, or are these organizational issues at hand?\n. Alright \u2014\u00a0I\u2019m largely ignorant of your codebase, but updating a Constants file at runtime seems to be a bit of an anti-pattern. What might get you to the same solution is to pass in height and width values whenever you initialize a view (using a custom initializer), set them to a class\u2019s properties (like buttonHeight, etc.) and use those values to set your button\u2019s height and width. \ud83d\ude03\n. Fair point.\nUpon further reflection, have you considered that maybe you might be approaching this problem incorrectly? Auto Layout encourages you to think in relative, constraint-based way, and updating button dimensions at runtime with absolute values goes against that philosophy \u2014\u00a0that shouldn\u2019t be your job, it\u2019s Auto Layout\u2019s. A constants file make me think that you might be approaching this problem incorrectly.\nThis apple documentation might prove useful \u2014 it explains the philosophy of Autolayout in a really good way. \ud83d\udc4d\n. I understand that \u2014\u00a0but those dynamic values should be calculated by Auto Layout.\nAnd again! I don\u2019t understand your codebase, nor the decisions you made. I am totally ignorant. It just seems the problem you\u2019re describing is solved by Auto Layout far more directly.\n. Whoops, I missed #147. Feel free to close this issue.\n. ",
    "WilliamHua": "Yes exactly, sorry if it wasn't clear. It works if I just use numerical values.\nThe only issue is that I can't drop the Constants.file, I the number isn't something I can hardcode. \n. Yes, the values Constants are updated dynamically at runtime\n. I understand your concern, it's a bit counter-intuitive. It's dependent on the screen size; that's the only reason it's updated at run-time. \nWith regards to your solution, wouldn't that still cause an issue since you're using a variable instead of a hardcoded number?\n. Thanks for your input (not sarcasm, I appreciate you taking the time to respond to me)! I will look into your suggestions.\nHowever, there are cases (outside of this) where I just need to set the height and width of something based off of dynamic values. If I don't solve this issue, I don't see how I could do that with cartography \n. I want to create a button of a certain width and height: \nlayout(button) { button in\n        button.right == button.superview!.right - 16\n        button.bottom == button.superview!.bottom - 16\n        button.height == 56\n        button.width == 56\n}\nHowever, I would also like to tie the numbers to variables rather than hard coded so I can change all button sizes at once. Ideally it would look like this\nlayout(button) { button in\n        button.right == button.superview!.right - 16\n        button.bottom == button.superview!.bottom - 16\n        button.height == Constants.height\n        button.width == Constants.width\n}\nIn a different file I have this structure\n@objc class Constants: NSObject {\n    static let height: Float == 56\n    static let width: Float = 56\n}\nWith this setup I receive the error Binary operator '==' cannot be applied to operands of type 'Dimension' and 'Float'. \n\nFor some reason I was under the impression that I attempted this with CGFloat and it failed before, however now when I force the Constants to use CGFloat instead of Float, it works perfectly. \n. ",
    "kazmasaurus": ":+1:\nI imagine constrain / layout usage changes from project to project, but all of the projects I work in only use constrain. In these projects, almost every view builds constraints on init and then leaves the layout system to do its thing.\nI also like that this encourages Cartography to be used as a tool to create Auto Layout constraints, instead of a tool to \"do layout\".\n. Isn't this asking about something like align(centerX: LayoutProxy, rest: [LayoutProxy]) so that you don't have to unpack the array into the variadic rest:?\nMaybe just align(centerX: [LayoutProxy]) would make more sense at this point.\n. What's happening is that the operators and the align functions have slightly different behaviors around setting translatesAutoresizingMaskIntoConstraint.\n- Operators sets translatesAutoresizingMaskIntoConstraint = false for any item on the left hand side as stated in the README.\n- align sets translatesAutoresizingMaskIntoConstraint = false for all items passed to the function, which is currently only documented in the code.\nI've ran into this problem myself when the superview is a UIViewControllers .view, because UIViewController needs it's .view to have translatesAutoresizingMaskIntoConstraint set to true in order for it to lay everything out properly.\nIn cases where you want to use align on a VC's view, you can set translatesAutoresizingMaskIntoConstraint back to true after the constrain.\n. ",
    "AliSoftware": "I'd personally lean to a syntax like viewA.layout.left = 0.3 * viewB.layout.height + 10, feels more natural.\nThe constrain scope is nice, but would need to pass the views ahead of time which could maybe not always match the constraints of the code and context, so I'd agree with @smileyborg on that. Let the user add some code formatting to organize its code and constraints himself if he wants to but not impose it.\n. ",
    "marclove": "@robb the Travis build failed due to a GitHub API limit being reached, not because the PR broke the build. can you kick off a retry?\n. ",
    "iaomw": "Hi, that's it.\n```\nlazy var nameLabel:UILabel = {\nlet label = UILabel()\n\nlabel.font = someFont\nlabel.textColor = someColor\n\nself.contentView.addSubview(label)\n\nlayout(label) { thisView in\n\n    thisView.left == thisView.superview!.left + 33\n    thisView.bottom == thisView.superview!.centerY - 1\n}\n\nlayout(self.contentView, label) { thisView, anotherView in\n\n    thisView.height == anotherView.height + 46\n    thisView.width == thisView.superview!.width  // There will be problem without this line\n}\n\nreturn label\n\n} ()\n\n```\n. But I have another cell works well with pure NSLayoutConstraint without bug and warning\n```\nlazy var nameLabel:UILabel = {\nlet label = UILabel()\n\nlabel.setTranslatesAutoresizingMaskIntoConstraints(false)\n\nlabel.font = someFont\n\nself.contentView.addSubview(label)\n\nlet leftConstraint = NSLayoutConstraint(item: label, attribute: .Left, relatedBy: .Equal, toItem: self.contentView, attribute: .Left, multiplier: 1, constant: padding)\nlet centerYConstraint = NSLayoutConstraint(item: label, attribute: .CenterY, relatedBy: .Equal, toItem: self.contentView, attribute: .CenterY, multiplier: 1, constant: 0)\n\nlet heightConstraint = NSLayoutConstraint(item: self.contentView, attribute: .Height, relatedBy: .Equal, toItem: label, attribute: .Height, multiplier: 1, constant: 38)\n\nself.contentView.addConstraints([leftConstraint, centerYConstraint, heightConstraint])\n\nreturn label\n\n} ()\n\n```\n. Thanks, I have tried your code. There is no crash nor warning, but the cell lost it's height, then it's using the default height provided by TableVIew.\n. Yes, I still need to set the width if using the self-sizing cell. And sometimes I also need to set the left of contentView to make sure it's not positioned to some strange place in the cell.\n```\nlayout(self.contentView, label, replace: self.sizeC4ContentView) { thisView, anotherView in\n        thisView.height == anotherView.height + 45\n        thisView.width == thisView.superview!.width\n        thisView.left == thisView.superview!.left\n\n}\n``\n. Sorry, I miss the point. If I don't put thecontentViewon the left of==operator, how could I update the height of contentView based on the height of label?\n. Then the contentView become very small, and everything get weird. Why-the height ofcontentViewshould be larger? I don't understand.  \ud83d\ude35\ud83d\ude35\ud83d\ude35\n. Thanks @vfn The height ofcontentViewreally work in this way. But the the width ofcontentViewis still not correct, it should go with the width of cell. \nSo everything incontentViewshould adjust in this style. I will rewrite other AL code to see how it works.\n. @vfn This method does resolved the size problem of contentView, but the label will not resize itself properly. It's a muti-line label, but it will appear to be a single line label after that.\n. Thanks, I know that. But I have different elements for touching and normal. And they also have different sizes and positions for touching and normal. So, basically the width is also not a const, I cannot usepreferredMaxLayoutWidth`, it should be ruled by other AL code like constraint.\n. ",
    "vfn": "@iaomw, set all the constrains of your label and at the end set the contentView's bottom to match the label's bottom\n``` Swift\nself.contentView.addSubview(label)\nconstrain(label) { view in\n        let superview = view.superview!\n    view.top == superview.top\n    view.left == superview.left\n    view.right == superview.right\n\n    superview.bottom == view.bottom + 45\n\n}\n```\n. Just make sure that the content view has the correct constraints are in place\n``` Swift\nself.contentView.translatesAutoresizingMaskIntoConstraints = false\nconstrain(self.contentView) { view in\n    let superview = view.superview!\nview.top == superview.top\nview.left == superview.left\nview.right == superview.right\n\n}\n```\n. @iaomw, you'll need to inspect your view hierarchy and try to understand what is going wrong there. There is probably one or more constraints missing. Tools like http://revealapp.com/ can help you with that\nAlternatively, you can create a sample project and we can try to help you by looking at your code. I do have a couple of self sizing cells on the project I'm using Cartography on and They work as expected.\n. @caohrong If you need to get the height of one specific cell, than you might need to create that cell and query it's height, given the current constraints.\nIf you are not sure how to implement the delegate method tableView:heightForRowAtIndexPath: then you should read the docs, specially the docs for tableView:estimatedHeightForRowAtIndexPath:\nhttps://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDelegate_Protocol/\n. @Mma2s I'll assume you are a little lost and your questions is legit.\nFirst of all, your question is a generic swift question that has nothing to do with this library in particular. You should post questions like that to stackoverflow.com.\nNow, to your problem, you are getting that error because there is no operator defined for [Int] * [Int]. What would you expect as a result of that call? If what you expect is an array like:\nSwift\nN = [(p1*q1), (p2*q2), ..., (pn*qn)]\nThen, you should implement the operator yourself or just run a loop. The operator would look like:\n``` Swift\nvar p = primeNumbers\nvar q = primeNumbers\nfunc *(lhs: [Int], rhs: [Int]) -> [Int] {\n    assert(lhs.count == rhs.count, \"Arrays must have the same length\")\n    var result = Int\n    for i in 0..<lhs.count {\n        result[i] = lhs[i] * rhs[i]\n    }\n    return result\n}\nvar N = p * q\n``\n. The podspec has not been updated with the correct version number. It is stuck on version 0.5.0. I'm not sure if it has any effect on how cocoapods work.\n. @tryadelion CP =CocoaPods`\nI'm not sure you are using Swift 3, because Alamofire 3.5.0 is Swift 2.3. Please check all your dependencies are compatible with Swift 3.0, then try to build your project again.\nAlso, your version of SwiftJSON is Swift 2.3 compatible https://github.com/SwiftyJSON/SwiftyJSON/releases\n...And Alamofire-SwiftJSON does not support Xcode 8 or Swift 3.0: https://github.com/SwiftyJSON/Alamofire-SwiftyJSON\n. @tryadelion It can be Xcode getting confused about what version of Swift to use. You cannot have a mix of Swift 2.3 & 3 in the same project.\nYou should first make sure all your dependencies (Managed by CocoaPods) are set to a version that supports Swift 3, then you perform the migration on your code.\nOne of the reasons that Alamofire might not be updating is that you project has a minimum target of iOS 8, and Alamofire 4.0.0 that support Swift 3, only supports iOS 9 & 10.\n. @tryadelion I might be wrong, but I believe you can get rid of SwiftJSON and Alamofire-SwiftJSON, if you are using SwiftJSON only for JSON object from requests' responses. If that's the case, Alamofire has a response serializer that outputs [AnyHashable: Any] dictionary, that's equivalent to the other 2 libs together.\nIf you remove these 2 dependencies and can drop support to iOS 8, you should have no problems on migrating to Swift 3\n. Depending on how big you code base is, prepare for hours of painful manual migration. Xcode will do only half of the job for you. I spent the last 2 days migrating one of my project and it was not fun.\nI can assure you that Cartography 1.0.0 is working with Xcode 8 & Swift 3.0\n. @tryadelion no problems!\nI just checked another dependency of your project and https://github.com/bizz84/MVCarouselCollectionView is really outdated and does not support Swift 3.0\nUntil you can get these dependencies updated I guess you'll need to keep using Xcode 7 & Swift 2.2 \u00af(\u30c4)/\u00af\n. @samkhawse UITabBarItem is not a subclass of UIView.\nhttps://developer.apple.com/reference/uikit/uitabbaritem\n. @brunomacabeusbr can you please post the whole code for constrain(self.viewCircle, self.labelResult, self.viewDashed) { ...?. @brunomacabeusbr 2 things:\n\nYou should not reference views directly inside the constrain block.\nIf dashed view goes from the bottom of the circle to the bottom of the superview, just set the constrain that way\n\n```swift\nconstrain(self.viewCircle, self.labelResult, self.viewDashed) { circle, label, dashed in\n    circle.top == circle.superview!.top\n    circle.centerX == circle.superview!.centerX\n    circle.height == circle.superview!.width\n    circle.width == circle.superview!.width\nlabel.center == circle.center\n\ndashed.top == circle.bottom\ndashed.centerX == dashed.superview!.centerX\ndashed.bottom == dashed.superview!.bottom\ndashed.width == 1\n\n}\n```\nAbra\u00e7o!. ```Swift\nlet padding: CGFloat = 20\nconstrain(self.viewCircle, self.labelResult, self.viewDashed, self.greenCircle) { circle, label, dashed, greenCircle in\n    circle.top == circle.superview!.top\n    circle.centerX == circle.superview!.centerX\n    circle.width == circle.superview!.width - 2 * padding // Use some sort of padding to make it smaller than the super view\n    circle.height == circle.width\nlabel.center == circle.center\n\ndashed.top == circle.bottom\ndashed.centerX == dashed.superview!.centerX\ndashed.bottom == greenCircle.top // This will make the line stop just before the green circle\ndashed.width == 1\n\n}\n```. @brunomacabeusbr looking at the example where you have multiple circles, I'd suggest you to rethink your view hierarchy. Break it in smaller chunks, where each magenta-ish circle, dashed line, and text are a self contained view.\n\nThen you create constraints placing one view after the other.\nBy doing that, you can make the dashed line go form the circle to the bottom of it's own container view. @brunomacabeusbr the issue there has nothing to do with Cartography. If you change the background color of your viewDashed to something that's not .clear you'll see that the height is correct when you make it go to the bottom of its superview.\nThe issue you have there is due to the fact that the dashed sublayer does not resize with the main layer.\nIn the image below the dashed view, in red, has the correct height, but the dashed layer does not.\n\nHave a look at http://stackoverflow.com/questions/29111099/calayer-not-resizing-with-autolayout. @brunomacabeusbr your code works because you force viewDashed to layout before it should and then you add the sublayer, by calling viewDashed.addDashedBorder(). At that point viewDashed gets the correct height.\nFor now, your code works, but it's not future proof and you'll find issues as soon as you need to change the size of dashed view change, and the dashed layer will be stuck with the initial height.\nAnother issue with your code, is that your cell is not reusable. Any new attempt to reuse it will add another dashed layer to it.\nI'd suggest you to create a UIView subclass, and manage the dashed layer inside the UIView subclass.\nMake your viewDashed to use the following class\n```Swift\nfinal class DashedView: UIView {\noverride class var layerClass: AnyClass {\n    return CAShapeLayer.self\n}\n\noverride init(frame: CGRect = .zero) {\n    super.init(frame: frame)\n}\n\nrequired init?(coder aDecoder: NSCoder) {\n    super.init(coder: aDecoder)\n}\n\noverride func layoutSubviews() {\n    super.layoutSubviews()\n\n    self.setupDash()\n}\n\nprivate func setupDash() {\n    self.alpha = 0.2\n    self.backgroundColor = .clear\n    self.clipsToBounds = true\n\n    guard let shapeLayer = self.layer as? CAShapeLayer else {\n        preconditionFailure()\n    }\n    let frameSize = self.frame.size\n    let shapeRect = CGRect(x: 0, y: 0, width: frameSize.width, height: frameSize.height)\n\n    shapeLayer.fillColor = UIColor.clear.cgColor\n    shapeLayer.strokeColor = UIColor.white.cgColor\n    shapeLayer.lineWidth = 1\n    shapeLayer.lineJoin = kCALineJoinRound\n    shapeLayer.lineDashPattern = [1, 1]\n    shapeLayer.path = UIBezierPath(roundedRect: shapeRect, cornerRadius: 1).cgPath\n}\n\n}\n```\nand then, make the startCell() look like\n```Swift\n    func startCell() {\n        viewCircle.asCircle()\n    constrain(self.viewCircle, self.labelResult, self.viewDashed) { circle, label, dashed in\n        circle.top == circle.superview!.top\n        circle.centerX == circle.superview!.centerX\n        circle.height == 32\n        circle.width == 32\n\n        label.center == circle.center\n\n        dashed.top == circle.bottom\n        dashed.centerX == dashed.superview!.centerX\n        dashed.bottom == dashed.superview!.bottom ~ UILayoutPriorityRequired\n        dashed.width == 1\n    }\n}\n\n```. ",
    "tbavaro": "Fair enough. We are hoping to not have to support iOS 7 too much\nlonger, and if we come across more troublesome cases we'll just fork for\nthe few months. But this particular pull request does seem pretty harmless\n(aside from maybe signaling that ios7 support is happening)\nThanks!\nOn Tue, Aug 4, 2015 at 3:31 AM Robert B\u00f6hnke notifications@github.com\nwrote:\n\nI'm happy to merge this, but I'm not really willing to commit to iOS 7\nsupport in a Swift 2.0/Xcode 7/iOS 9 world.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/robb/Cartography/pull/150#issuecomment-127559213.\n. \n",
    "SoonKong": "But I can use in ios 7, is there any wrong?\n. ",
    "haaakon": "Allright. I'll store them then. Thanks for quick reply & making the best framework for working with constraints!\n. ",
    "mineschan": "OMG @robb you're awesome!\nYeh, I changed the variable a bit to let viewHeight:CGFloat = 1000 and it works like a charm!\nThanks for your rapid reply, love Cartography even more now ;)\n. ",
    "Artwalk": "sorry to bother you again, how should I write the Cartfile?\njust like: github \"robb/Cartography\" ?\n. Yeah, I found why.\nI'm using Xcode 6.4 and running it on 10.11\nEven though I set the default Xcode to 6.4 instead of 7.0 beta and reboot Mac, carthage still using 7.0. \nI changed to a 10.10 OS X, everything works fine.\n. ",
    "kaandedeoglu": "Thank you, I noticed you increased the limit to 5 views recently. I only had one place that used 6 views, splitting that into two layout calls solved the issue\u270c\ufe0f \n. ",
    "nyc": "I had a similar code-signing issue and after looking at this issue, I realized that I didn't have an iPhone Distribution certificate set up. To do so, go to \nPreferences > Accounts > View Details > Signing Identities > iOS Distribution > Create\nThis fixed it for me and Cartography is building properly. @robb I don't think this is an actual issue with the library.\n. ",
    "alvivi": "@nyc, Thank you. Adding an account distribution certificate fixes the problem.\n. ",
    "ninjudd": "Yeah. Declaring it as a CGFloat solves the issue. That's what I meant actually :) Casting every use would be crazy.\nI'm curious what caused this to change since it worked fine before. Is not working with Double a change in Cartography, or due to something in Swift 2.0?\n. Is there a release on CocoaPods with this update?. We have a two extensions that I added in my fork that we use extensively throughout our code. Here is an example of the usage:\nconstrain(statusView) { statusView in\n      statusView.edges(.bottom, .left, .right) == statusView.superview!.edges(.top, .left, right).inset(-4, 0, 0)\n      statusView.width == 70\n      statusView.height == 30\n    }\nThe edges function takes a variable number of LayoutAttributes and returns an Edges object. Inset is an extension to Edges since the built-in inset function requires an Edges object with exactly 4 edges.. Yeah. Type safety is a good thing. I'd love a way to use the shortened syntax for anchoring multiple edges while still having it be type safe. But there will be a lot of permutations if there is a separate type for top, bottom, leading, trailing, etc.\nAre you sure you need that many types? Wouldn't just two types (HorizontalEdge and VerticalEdge) be sufficient?. ",
    "orkhanalizade": "@robb I use Podfile, not Cartfile and I cannot to add your framework to Embed Binaries. Why you closed an issue? It didn't solve my problem =/\n. My podfile content is:\nuse_frameworks!\npod 'performSelector-swift'\npod 'UIColor+FlatColors'\npod 'Cartography'\npod 'ReactiveUI'\nWhen I compile it in my simulator, it works perfectly, but when I try to run it on my iPhone, it crashes, that Reason: image not found\n. @robb  did you find any solutions for this issue?\n. @robb no. You can look at my SO question here http://stackoverflow.com/questions/33057235/strange-trap-error-in-xcode-swift\n. @robb any news?\n. @robb this error appears 2-3 days ago. Before it all was good! So strange\n. ",
    "cobear25": "Same thing is happening for me.\n. ",
    "fiveze": "+\n. ",
    "codeOfRobin": "@robb Couldn't you also use variadic parameters to do something like this?\n. ",
    "ivan-ushakov": "As I wrote I don't use dependency management tools like CocoaPods. I hope there is a way to use this library as it is, without building a framework.\n. ",
    "samuelbeek": "Did you add import Cartography?\n. Oh, didn't test it well enough.\n. Both @MPiccinato and I dove into this and it is slowest when combining assignment and comparison operators. So for instance in a line like this one\nview1.centerX == view.centerX + 10. \nAnything we can do about that? \n. I've added a couple of functions to my project to replace the == operator in cartography. You can find them in this Gist (WIP). It slimmed down the compile time of most Cartography blocks to 30% of the original time, which are pretty impressive results.\n. ",
    "wratke": "Error code I copied and pasted didn't post, going to try that again:\n,\n\n. NSLayoutConstraint:0x18272f40 TonicTutor.PigCoin:0x16e18950.bottom == UIImageView:0x16d113e0.top - 10\nNSLayoutConstraint:0x16e1a220 TonicTutor.PigCoin:0x16e18950.bottom == UIImageView:0x16d113e0.top + 500\n. That definitely makes sense. I think it would be helpful to update the wiki since it's not immediately clear that you need to capture the constraint group in the variable, it looks like it captures the constrain directly preceding it.\n. ",
    "AnbuIOS": "HI ,\nWhile build the cordova project ,below error occured.\nunknow attribute available\nerror occurred from the line : @available(iOS 8.0,*)\nScreenshot attached.any body reply to resolve this issue.\nThanks\nAnbu\n\n. ",
    "mluisbrown": "No problem \ud83d\ude0e\n. btw, might be worth tagging a new version (0.6.1) as Carthage by default grabs the latest tagged version so it wouldn't pick up this commit unless someone specified \"master\" or \"HEAD\" in the Cartfile.\n. Thanks @solomon23. It compiles and, at least in my usage of it, also works fine! \ud83d\udc4d \n. Hi @GP000 looks like that fork hasn't been updated to the latest Swift 3.0 syntax. Try my fork instead, which I'm using in a shipping app: \npod 'Cartography', :git => 'https://github.com/mluisbrown/Cartography.git', :branch => 'swift3'\nI haven't tried using it with CocoaPods (I use Carthage) but it should be fine.\n. Sorry, closed the issue by mistake :blush: . Re-opened.\n. Just looking at your screenshot more, I can't see the full error but it looks like it's saying Unknown attribute 'discardableResult' . If that's the case then maybe your project is not using Swift 3.0? That is a new attribute introduced in Swift 3.0.\n. ",
    "ozgur": "Same problem here. It happens only when using align() with a view and its superview. Not with siblings.\n. ",
    "JackieQi": "@kazmasaurus :+1:   Thanks very much. That's the cause! It works well after i do view. translatesAutoresizingMaskIntoConstraint = true \n. ",
    "EliaCereda": "Alright, let me look into it. ;)\nElia Cereda\n\nIl giorno 12 dic 2015, alle ore 08:42, Robert B\u00f6hnke notifications@github.com ha scritto:\nThanks for the Pull Request \nWould you mind adding a test that verifies the intended behavior?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/robb/Cartography/pull/184#issuecomment-164119642.\n. Looking at the code, I don't see any test for baseline and firstBaseline either. It's not entirely clear to me how should we test for correctness. The relation between the baselines of a view and its frame is not straightforward.\n. \n",
    "stanchiang": "\n\n. ",
    "wyefei": "The original is correct because animation takes a function/block.\n. ",
    "BenchR267": "Thank you for this awesome framework!\nVon Outlook Mobile gesendet\nOn Mon, Jan 18, 2016 at 4:55 PM -0800, \"Robert B\u00f6hnke\" notifications@github.com wrote:\nThanks!\n\u2014\nReply to this email directly or view it on GitHub.\n. ",
    "jderrough": "Something like\nswift\npublic func distribute(by amount: CGFloat, horizontally array: [LayoutProxy]) -> [NSLayoutConstraint] {\n    return reduce(array.first!, rest: Array(array.dropFirst())) { $0.trailing == $1.leading - amount }\n}\n?\n. ",
    "joslinm": "Yes \n. ",
    "portellaa": "Ups i missed this issue and i created a new one exactly with the same \ud83d\ude1e \nDon't know if you guys have a branch with this already, but i open a pull request with a suggestion to this\n. Ups sorry for the duplication\n. I did something like this:\nswift\nextension ViewProxy {\n    var safeArea: SupportsPositioningLayoutProxy {\n        if #available(iOS 11.0, *) {\n            return safeAreaLayoutGuide\n        } else {\n            return self\n        }\n    }\n}\nIt's not the best solution or the most elegant one, but it's better than spreading if @available through all the code.\nJust an idea \ud83d\ude05 \ud83d\ude07 . just opened a PR \ud83d\udc49 #301 . Cool, i will do it in the meanwhile \ud83d\ude09 thanks \ud83d\ude4f \ud83d\ude80 . ",
    "Tesseractian": "Yes; this will make it easier to use for beginners (like me ;) ).\n. also, the command I'm using is carthage update --platform iOS.\nIn the same Carfile, I have PeerKit v. 1.2 listed. PeerKit is built properly (I think; there's a framework file in the build folder).\n. ",
    "raphaelcruzeiro": "Listen to NSNotification.Name.UIKeyboardWillShow and then update your constraint to take into account the keyboard height.. Turns out that I was using the constraints on a scroll view with an incorrect content size. My fault for trying to do this in my sleep deprived state.\n. @orta: I haven't bothered yet with the travis file as Quick and Nimble are still not Swift 3 ready.  As soon as they have it working we can start migrating the tests and configuring travis to use the xcode8 image.\n. Also, I just realised that the ~ operator is not working as expected as of Beta 6. I really wish I could run those tests now...\n. Quick and Nimble have been successfully migrated to Swift 3 (Xcode 8 Beta 6). I'm gonna start fixing the tests for this branch later today \ud83e\udd18\ud83c\udffc\n. No worries. I'll rebase this branch and port the new code. \n. I have converted the tests to Swift 3 and all is well except for the Priority operator which has a problem of precedence. I have tried fixing it as per SE-0077 but it seems that I got it wrong as the following test fails to build:\n```\nit(\"should operate on a single constraint\") {\n    var constraint: NSLayoutConstraint!\nconstrain(view) { view in\n    constraint = (view.width == 200 ~ 100)\n}\n\nexpect(constraint.priority).to(equal(100))\n\n}\n```\nI will take a deeper look into that later today and hopefully a commit will follow \ud83d\ude09\n. @orta @robb I had no luck in getting the ~ operator working with the new precedencegroup \ud83d\ude1e \n. XCode 8 GM didn't break anything on this branch \ud83d\ude2e \n. @orta I pushed a commit switching to CocoaPods. Hopefully travis will at least get to trying to build the tests. About the ~, I really have no idea how to solve that. From what I understood of SE-0077, the precedence group is correctly set for this operator. However, when trying to build the tests I get a CartographyTests/PrioritySpec.swift:22:49: Ambiguous reference to member '~'.\n. I can rename the precedence group to avoid possible name clashes but this will most likely not solve the operator problem.\n. @orta \ud83c\udf89\n. ",
    "hboon": "There you go.\n. Sorry, had to push a second time to use spaces instead of tabs. (Danger anyone? :P)\n. ",
    "TimothyChilvers": "I've been using it for months now and it's been fine, I'd like to add the tests and change the names to match styles that have been discussed elsewhere\u2026. But I haven't done it. I'll see if I can do that by the end of the week.\n. All right, all right\u2026 I'll pick it up again now.\n. Is my approach preferred over #212 ?\n. I added tests, but I'm not happy with them. The reason being I can't make the UILayoutGuide of the view controller have a non-zero length just using UIKit components straight off. I only spent an hour or so fiddling with it, so I might have missed something. I have another branch which stubs the view controller and layout guide classes, but the compiler warnings for availability are a nightmare.\nIf the tests are adequate (In my mind they're not the greatest), feel free to merge. If someone wants to have a go at populating the layout guide with a length, also be my guest. I'll put some time aside on Monday if no further action has been taken.\n. So\u2026\nHaving tried subclassing UIViewController and giving custom UILayoutGuide subclasses to the guides and failed, and failing to populate the UIKit supplied top and bottom layoutGuide objects with properties, and finally with UILayoutSupport not being equatable / internal behaviour and constraint generation being unreliable, I'm calling this as the limit of what I can achieve with the tests.\n. I hate that too. Fixed.\n. ",
    "dcharbonnier": "@sebastianvarela the build fail ;-)\n. ",
    "jpsim": "\nIs there any way to get this build on travis?\n\nSure! Just set the Xcode 7.3 image in .travis.yml: osx_image: xcode7.3\n. ",
    "lyptt": "Just saw this was done already!\n. ",
    "mjarvis": "Spec added. (Hopefully it is as you were looking for, let me know if not)\n. ",
    "dougbeal": "It doesn't build on OS X.\n. ",
    "reeveyew": "Maybe try\nview.setNeedsUpdateConstraints()\nview.updateConstraintsIfNeeded()\n. ",
    "gpoitch": "This worked:\nswift\nview.setNeedsUpdateConstraints()\nUIView.animateWithDuration(1.0, animations: {\n  view.layoutIfNeeded()\n})\n. ",
    "MPiccinato": "Just wanted to chime in and say I am seeing this also. Currently a huge chunk of my build time is spent in these methods. I use the same tool as @samuelbeek posted.\n. ",
    "LucasVanDongen": "I'm seeing the same things. Compile times over 100ms for not overly complex stuff\nNoticed one thing:\n    constrain(self.contentView, self.titleLabel, self.contentLabel, self.newMessages) { (view: LayoutProxy, titleLabel: LayoutProxy, contentLabel: LayoutProxy, newMessages: LayoutProxy) in\n        titleLabel.bottom == contentLabel.top\n\n        titleRight = titleLabel.right == view.right - (intraCellSpacing + MessageCountIndicator.counterWidth) // Much faster\n        contentLabel.right == titleLabel.right\n\n        newMessages.centerY == view.centerY\n        newMessages.right == view.right - intraCellSpacing\n        newMessages.width == newMesagesWidth\n\n        contentLabel.bottom == view.bottom - intraCellSpacing\n        contentLabel.left == titleLabel.left\n    }\n\nvs\n    constrain(self.contentView, self.titleLabel, self.contentLabel, self.newMessages) { (view: LayoutProxy, titleLabel: LayoutProxy, contentLabel: LayoutProxy, newMessages: LayoutProxy) in\n        titleLabel.bottom == contentLabel.top\n\n        titleRight = titleLabel.right == view.right - intraCellSpacing - MessageCountIndicator.counterWidth  // Slow version\n        contentLabel.right == titleLabel.right\n\n        newMessages.centerY == view.centerY\n        newMessages.right == view.right - intraCellSpacing\n        newMessages.width == newMesagesWidth\n\n        contentLabel.bottom == view.bottom - intraCellSpacing\n        contentLabel.left == titleLabel.left\n    }\n\nThis shaved off 200ms from originally >300ms. Still not really great having them over 100ms but at lot better at least.. Always felt it was due to something like this. It's a pity. But the == operator is a lie anyway as with a true == it doesn't matter what you put left or right and that clearly isn't the case with Cartography.. ",
    "Lascorbe": "I've come into this as well (having big compile times on all Cartography closures). \nLooks like function overload could be the cause (constrain has various method overloads). I've been thinking how can we change it to solve the problem, but it is so good like it is right now...  \nDoes someone think there's a good way of fixing it? Or should we just keep relying on thinking it'll get better on a future Xcode release?\nI've thought of just having the constrain(_ view: [View] ...) one, and rename the other ones so it's clear which one is used, but I don't really like it :(. ",
    "ianyh": "I'm not sure it's the constrain overloads. I've tried reducing it to only the array call with no meaningful difference in compile time.. For what it's worth, anecdotally this seems to be a lot faster for me nowadays.. Nothing. Swift compiler changes seem to have improved the type inference, which is what I think was slowing it down.. Again, this is somewhat anecdotal. I haven't done any thorough timing tests.. Yes. It's possible I've just adjusted to my capricious robot overlords. I'll do some more thorough timing when I get a chance.. ",
    "rvi": "@ianyh What did you change to reduce the compile time?. Building my app after cleaning is more than 11min... Xcode 8.3.2 ?. ",
    "pedromcunha": "Any update on this issue? We have some large (30 line) constrain functions that are giving us 600-700ms compile time. Is there anything we can do to decrease this? Btw it looks like it hasn't been mentioned before but you can measure the compile time of functions by following this guide here: https://www.jessesquires.com/blog/measuring-compile-times-xcode9/?utm_campaign=iOS%2BDev%2BWeekly&utm_medium=web&utm_source=iOS_Dev_Weekly_Issue_320. ",
    "s4cha": "Hi, reading this thread it seems very similar to an issue we had on Stevia a while ago, due to operator overloading, we're all in the same boat !\nThe way I understand it is that == is a common operator so the compiler has a hard time finding the right overload. \nFor instance, in our project replacing '-' operator by '--' made it easier on the compiler yielding faster compile times.\nThe bad news is this approach means touching the api :/\nMy best guess is to wait for the compiler to get better and better with each release as it seems to have improved over the past releases.\nMore details on the similar issue here: http://freshos.org/SteviaDocs/knownIssues/\nHope it helps :). ",
    "acrookston": "I've added PR #293 as a potential solution. At Instacart we use Cartography heavily in one of applications and after migrating most of the code over to the new syntax the (clean) build time has been halved (from about 5 min to 2.5). All of our view constraint setups run in a few milliseconds where most were in the hundreds, if not thousands (worst case we had was 8800ms for one view).\nStrongly recommend the core team looks over this issue and applies some (maybe not my) solution.\nFeel free to use github \"instacart/Cartography\" \"acr/custom-operator\" (carthage) if you wish to get the improvements, unfortunately you must add the ~ prefix to all your ==, +, -, *, /, <= and >= operators, but hopefully we'll see a more permanent solution to this.\nThanks for a great library!. Another example, much simpler takes 3600ms.\nconstrain(self, textLabel, helpButton) { superview, textLabel, helpButton in\n            let textWidth = superview.width - iconWidth - padding - GUI.Constant.tableInset * 2\n            textLabel.left == superview.left + GUI.Constant.tableInset\n            helpButton.width == iconWidth\n            textLabel.width == textWidth\n            helpButton.right == superview.right - GUI.Constant.tableInset\n            textLabel.centerY == superview.centerY\n            helpButton.centerY == superview.centerY\n            textLabel.height == GUI.Constant.rowHeight\n            helpButton.height == GUI.Constant.rowHeight\n        }. After migrating most of the code in one of our apps over to the new syntax the build time has been halved (from about 5 min to 2.5). All of our view constraints all run in a few milliseconds where most were in the hundreds, if not thousands. Strongly recommend the core team looks over this issue and applies some (maybe not my) solution. Thanks for a great library!. @orta technically no, but it's adding to the API and suggesting a new API so \"perhaps\"? With the current iteration I'm not replacing the current operators, I've only copied or \"aliased\" them (hence non-DRY). Was hoping to spark a discussion on how this would be best implemented upstream. I'm willing to take lead on any required changes.. ",
    "jberkel": "It's difficult to find a satisfying solution without compromising the API.\nAs a workaround, one thing you can do is to help the type checker:  \ndiff\n- label.baseline == otherLabel.firstBaseline + 10\n+ let _:NSLayoutConstraint = label.baseline == otherLabel.firstBaseline + 10 as Expression<Edge>\nLess readable but improves compile times considerably. If it looks like the compiler performance problems won't be addressed (soonish) then a new API is probably in order.. ",
    "GP000": "\nI have have problem with converting to the latest Swift 3 syntax\nI use \"pod 'Cartography', :git => 'https://github.com/solomon23/Cartography.git', :branch => '3.0'\" to install Cartography\n. \nafter conversion to the latest syntax passed the following errors appeared\n. it is an empty project with only Cartography imported via pods\n. ",
    "blackphnx": "When I import cartography onto my project I get this error.\nModule compiled with Swift 3.0 cannot be imported in Swift 3.0.1: /Carthage/Build/iOS/Cartography.framework/Modules/Cartography.swiftmodule/arm64.swiftmodule\n. ",
    "NachoSoto": "@orta done.\n. So I was about to close this since it got done in #267, but I just posted a question in #269 cause I think the support became worse?. See my response there, this works great!. I'm confused about this change. With #267 we could do view.edges == view.superview!.safeArea.edges. That doesn't seem possible anymore?. Never mind, I'm silly, view.edges == superview.safeAreaLayoutGuide.edges works great :)\nThis is actually what I'm doing:\nswift\nif #available(iOS 11.0, *) {\n    constrain(self.scrollView, self) { scroll, superview in\n        scroll.edges == superview.safeAreaLayoutGuide.edges\n    }\n} else {\n    constrain(self.scrollView, self) { scroll, superview in\n        scroll.edges == superview.edges\n    }\n}\nThis happens to be enough in my case cause this view isn't affected by top or bottom layout guides (it's in the middle of the screen).. This can be closed now? :). This seems very weird.\n. Would it makes sense to delegate this to the other operator instead?\nswift\nreturn lhs ~ LayoutPriority(rawValue: rhs). ",
    "strangeliu": "That's great\n. I just disarranged my branch, i should create a new request for this.\n. layout func is removed from the newest version, you should use constrain and setNeedsLayout  instead\n. before change the height constrain you need to replace the old one\n. ",
    "WangCrash": "update documentation, please!\n. ",
    "morgz": "what type is viewHeight? Double etc. won't work it needs to be a CGFloat. You could try \n\nview.height == CGFloat(viewHeight)\n. \n",
    "galenom": "I was having similar issue, you have to store the original constraints inside of a ConstraintGroup. Then re-state all of the constraints + the one you want updated. Like this:\n`\nlet group = constrain(self.bgView!, self.introduce!) { (view1, view2) in\n        view1.height == 20\n        view1.left == view1.superview!.left+10\n        view1.right == view1.superview!.right-10\n        view1.top == view1.superview!.top+10\nview2.left == view1.left\n    view2.right == view1.right\n    view2.top == view1.bottom + 10\n    view2.bottom == view2.superview!.bottom - 10\n}`\nThen:\n`\nconstrain(self.bgView!, self.introduce!, replace: group) { (view1, view2) in\n        view1.height == 80\n        view1.left == view1.superview!.left+10\n        view1.right == view1.superview!.right-10\n        view1.top == view1.superview!.top+10\nview2.left == view1.left\n    view2.right == view1.right\n    view2.top == view1.bottom + 10\n    view2.bottom == view2.superview!.bottom - 10\n}`\n. ",
    "rodrigoruiz": "So, when is this going to be merged into the main one?\n. Somehow it's now downloading the same source code as the one on the repo when I do pod 'Cartography', :git => 'https://github.com/alexiosdev/Cartography.git'\n. ",
    "NeuralGlue": "You may not be including the branch for the Swift3 project. It you're wanting to use alexoisdev's work try this in your pod file:\n\npod 'Cartography', :git => 'https://github.com/alexiosdev/Cartography.git',  :branch => 'swift3_alex'\n. \n",
    "magpali": "@orta has just released a new branch for swift3 ... haven't tested it yet tho... plan on doing it during the weekend. Anyway.. Thanks for the effort Orta \ud83d\udc4d \nhttps://github.com/robb/Cartography/tree/swift3_ci\n. ",
    "originell": "in this case it's already an Int . That's also why the error message confuses me.\nYou should be able to reproduce this pretty easily, at least with XCode 7. Didn't try it with 8b for now.\n. Ah. Now we have a different error :)\nlet imgHeight = apiData.bgImage.height  // Int\nconstrain(self.imgView) { view in\n    view.height == Double(imgHeight)\n}\nLeads to\n\nAmbiguous reference to member '=='\n. Oh amazeballs. I'll try this and report back :)\n. yep indeed this works. Thanks a lot @turekj  :)!\n. \n",
    "turekj": "I stumbled upon similar problem yesterday. I could not multiply height by a ratio variable:\n```\nlet ratio = 0.45\nconstrain(self.entryView) { v in\n    v.height == v.superview!.height * ratio\n}\n```\nFigured it out looking at Coefficients.swift:\n```\npublic func * (m: CGFloat, rhs: Coefficients) -> Coefficients {\n    return Coefficients(rhs.multiplier * m, rhs.constant * m)\n}\npublic func * (lhs: Coefficients, rhs: CGFloat) -> Coefficients {\n    return rhs * lhs\n}\n```\nSince multiplier should be defined as CGFloat, I did the following:\n```\nlet ratio = CGFloat(0.45)\nconstrain(self.entryView) { v in\n    v.height == v.superview!.height * ratio\n}\n```\nI guess it fixes your problem too. I just did a quick test and below solution works:\nlet imgHeight = CGFloat(apiData.bgImage.height)\nconstrain(self.imgView) { view in\n    view.height == imgHeight\n}\nHope it helps :)\n. ",
    "MingLoan": "same here, please help to make carthage support.\n. ",
    "ninjaprox": "@joshharington: You could try Cartography.Expression<String> instead.\n. ",
    "Douvi": "Currently you can do this \npod 'Cartography', :git => 'git@github.com:robb/Cartography.git', :tag => '0.7.0'\n. ",
    "sparga": "Thank you, that's what I am already doing but then you loose the versioning benefits of Cocoapods.\nIs there a specific reason why this release is not published on the Cocoapods repo?\n. ",
    "andymatuschak": "\nBTW, while we have your attention any idea what this issue might be about? #228 \n\nI'm afraid I have no idea! ~ seems to be working OK with 2.3.\n. ",
    "tryadelion": "Current cartography pod version : Installing Cartography (1.0.0)\n. CP? (cartography?)  , anyway,  to ensure that all pods upgrade nicely, i uninstalled them all, removed all files and folders ,and installed them back, and then i got those errors. there are 50 of them that i can't fix, and there are others that by removing an annotation on CP's source got fixed.\nthis is my pod result log : \nInstalling Alamofire (3.5.0)\nInstalling Alamofire-SwiftyJSON (0.1.1)\nInstalling Cartography (1.0.0)\nInstalling ImagePicker (1.4.1)\nInstalling MVCarouselCollectionView (1.0.9)\nInstalling SDWebImage (3.8.2)\nInstalling SwiftEventBus (2.1.0)\nInstalling SwiftSpinner (1.0.2)\nInstalling SwiftyJSON (2.4.0)\nGenerating Pods project\nIntegrating client project\nSending stats\nPod installation complete! There are 9 dependencies from the Podfile and 9 total pods installed.\n. My code is converted to Swift 3.0, the dependencies should automatically upgrade to the latest version possible afaik.My Alamofire and SwiftyJson versions shouldn't affect cartography build, right?\nSadly all these Xcode and swift changes are destabilizing and unnecessary, i don't see any positive change. \n. I'm checking it up right now.\n. will do that. it's still weird because Xcode tells me that my code is already swift 3.0, and the migration was sucessful. i'm 90% lost, but will do as you say. nothing to loose.\n. Okay, thank you very much for your comprehension and help. my codebase is eiffel tower sized.\n. ",
    "mrcoolbiz": "Also, about constraingroup, it has memory leak that I can't clear it as I mention on \nhttps://github.com/robb/Cartography/issues/248. Any update for this bug ? I still can't fix this memory leak.. I made this for long time ago. But I think this leak was solved in new updated version.\nYou can try to test again. . ",
    "577528249": "Wow! That\u2018s cool, I want to try this, Thanks!. Hello,I'm sorry for the issue , because my project use Carthage to manage the library,which real cause Cartography\uff0cAlamofire\uff0cCharts memory leak in my project.So it not Cartography cause the problem. I'm sorry for what I say before,I will more cautious in next time. Thanks!. ",
    "micromanc3r": "@mrcoolbiz Are you sure about that leak? Can you post a screenshot of Instruments session? \nI tried to setup a minimal app to reproduce the problem based on your description in my fork...can you look at it and suggest changes to create a leak? (it's in a fix/memory_leak branch)\n\nI also added constraintGroup leak check into tests. should this be closed then?. \n",
    "sendyhalim": "@MingLoan Hi, I've been using carthage to install Cartography, paste below code to your Cartfile\ngithub \"robb/Cartography\" ~> 1.0.1\nthen\ncarthage update. ",
    "adamnemecek": "It's all refactoring of the current code? Why? I believe that my refactorings increase clarity or reduce source code size.. ",
    "Lucashuang0802": "@orta Sorry, I should haev added more details. Is Cartography able to translate constraints into group that is recognizable and replacable?. ",
    "macabeus": "@vfn  Of course\n```swift\nconstrain(self.viewCircle, self.labelResult, self.viewDashed) { circle, label, dashed in\n    circle.top == circle.superview!.top\n    circle.centerX == circle.superview!.centerX\n    circle.height == self.viewCircle.frame.width\n    circle.width == self.viewCircle.frame.width\nlabel.center == circle.center\n\ndashed.top == circle.bottom\ndashed.centerX == dashed.superview!.centerX\ndashed.height == self.frame.height - viewCircle.frame.height\ndashed.width == 1\n\n}\n```\nMy UI is this:\n. @vfn  I wrote self.viewCircle.frame.width instead of circle.superview!.width because I want get the value setted in storyboard (well... this value is \"constant\"... is better I set literal number where... thank you).\nBut circle.superview!.width not work for my situation because my circle should not fill the whole width in superview.\nAnd, I tested dashed.bottom == dashed.superview!.bottom instead of  dashed.height == self.frame.height - viewCircle.frame.height, but...\n\n... not work correctly (image in left side). With dashed.height == self.frame.height - viewCircle.frame.height work (image in right side).\nI know that is weird use self.frame in constrain closure, but, I don't know a better way.\nI'm working with Cartography inside one of the cell of CollectionView. Big example:\n\nObrigado =]. @vfn Wait, please. I'm creating a separate pod and I will create a new repository coming soon.. @vfn Finish: https://github.com/brunomacabeusbr/InputStepByStep\nYou can run the Example and see the code in InputStepByStep.\nThank you very much for your attention.. @vfn Interesting. I don't know this expected behavior about UIKit. I thought that CALayer was resizing automatically when the constrains was update.\nOne question:\n```swift\nconstrain(self.viewCircle, self.labelResult, self.viewDashed) { circle, label, dashed in\n    ...\n    dashed.height == self.frame.height - viewCircle.frame.height\n    //dashed.bottom == dashed.superview!.bottom\n}\nviewDashed.setNeedsLayout()\nviewDashed.layoutIfNeeded()\nviewDashed.addDashedBorder()\n```\nThis code work. The function addDashedBorder draw the dash correctly. But, when I use dashed.bottom == dashed.superview!.bottom instead of dashed.height == self.frame.height - viewCircle.frame.height, not work correctly. It's equal as your photo.\nDo you know why I need set one height value? And, do you have any idea about one better way, without setNeedsLayout and layoutIfNeeded?\nThank you very much =]. @vfn Many, many, many thank you!! Now, it's working elegantly.\nI learned a lot because of your help =]. ",
    "tzm41": "iOS 11 comes out next Tuesday. ",
    "stel": "Alright, seems to work now. ",
    "bryanjclark": "@pprevalon To ad more than 5, you can pass in an array of objects, and then unpack that array inside the closure. Here's an extreme example from the KA app:\n```\nconstrain([container, googleButton, facebookButton, orLabel, textBackground, textSeparator, usernameField, passwordField, forgotButton, passwordManagerLoginButton, signInButton, errorLabel]) { proxies in\n            let (container, googleButton, facebookButton, orLabel, textBackground, textSeparator, usernameField, passwordField, forgotButton, passwordManagerLoginButton, signInButton, errorLabel) = (proxies[0], proxies[1], proxies[2], proxies[3], proxies[4], proxies[5], proxies[6], proxies[7], proxies[8], proxies[9], proxies[10], proxies[11])\n            let itemWidth: CGFloat = 256\n            let itemHeight: CGFloat = 48\n            let buttonSpacing = SignInDefaultView.buttonSpacing\n            let forgotButtonMargin: CGFloat = 14\n        errorLabel.centerX == container.centerX\n        errorLabel.width == itemWidth\n        errorLabel.bottom == googleButton.top - buttonSpacing\n\n        googleButton.centerX == container.centerX\n        googleButton.width == itemWidth\n        googleButton.height == itemHeight\n\n                    // etc\n\n}\n```. See also the discussion over here: https://github.com/robb/Cartography/issues/197. ",
    "pprevalon": "Thank you a million. There is an issue with this if we are adding more than five views we have to use let views:[LayoutItem] = [view1,view2,self.car_topLayoutGuide, self.car_bottomLayoutGuide ]\nerror \n\"Protocol 'LayoutItem' can only be used as a generic constraint because it has Self or associated type requirements\". ",
    "inamiy": "See Also: #267. API changed in https://github.com/robb/Cartography/pull/269 for ver 3.x.. Done in #269.. UILayoutGuide doesn't support firstBaseline/ lastBaseline, so this should not conform to SupportsBaselineLayoutProxy (super protocol).. In 767821e4ccda5641d5edb2eca310c33af9dce7d2...da5e483451565ec1122c3f6ef0a2087468e1581e, why did translatesAutoresizingMaskIntoConstraints = false move to other methods?\nIt seems scattered than before \ud83d\ude15 . Thanks for explanation!\nSo, translatesAutoresizingMaskIntoConstraints = false impl is actually back to the original code now \ud83d\ude44 . ",
    "yysskk": "@orta Thanks, review! I am glad to accept you. I added tests, so please take a look.\n. ",
    "mathieutozer": "Did this change get reverted? I don't see it in the latest release via Cocoapods!. ",
    "philippelatulippe": "I've submitted a PR that adds this: https://github.com/robb/Cartography/pull/271. ",
    "dhmspector": "Is there an update on this issue? . ",
    "Dimillian": "Don't even know if this was the right solution, was just a bit bothered that since having a project using both Swift 4 and 3.2 pods, I have to manually set the version of each projects in my podfile. \nWaiting for the cocoa pods attribute then ;). ",
    "zackshapiro": "I also get this error. I solved this by downgrading from 3.0 but obviously that's not the ideal solution. ",
    "FranciscoAmado": "I also got this error but it is an intermittent problem..\nDowngrading to 2.1.0, running pod install --repo-update and bumping again to 3.0 seemed to fix the problem \ud83d\ude04 \nI've looked into the method definition in Priority.swift and everything looks fine \u00af_(\u30c4)_/\u00af. ",
    "follyxing": "+1   swift 3.2. ",
    "rodericj": "I was able to get around this by cloning the repo, deleting one of the duplicate definitions of ~ and replacing another duplicate definition of ~ with ~~. This is not an elegant solution and isn't going into production for me. I'm definitely open to discussing a proper solution.\nSwift 3.2 \nXcode Version 9.1 (9B55). ",
    "ajself": "I was able to fix this by choosing the Pods project in the work space, selecting the Cartography target, selecting Build Settings, and changing Swift Language Version to Swift 4.0. This isn't a permanent fix but did allow me to move on in the meantime. . ",
    "trusk89": "I also have this fix, and as a workaround I went and set the pod swift version to 4.0 manually, but it's not a long term solution. ",
    "huang1988519": "Versioning\nFor Swift 3.x: Versions <= 1.1.0\nFor Swift 4.x: Versions >= 2.0.0. ",
    "dcordero": "I see, it makes sense thanks for your reply @orta \nWould it make sense to rephrase it to make it more clear? \nI mean something like this:\n```diff \nVersioning\n-For Swift 3.x: 1.1.0\n+For Swift 3.x: Versions <= 1.1.0\n-For Swift 4.x: 2.0.0\n+For Swift 4.x: Versions >= 2.0.0\n```. Sure, and thanks a lot for your time \nPR: #282 \n. ",
    "omochi": "@orta Thanks!. ",
    "ptc-amulloni": "Closing this issue as I believe it is actually due to environment settings on my machine. I can reproduce it on a colleague's machine working on a same project, but not on another colleague's who's working on a different project. It is likely due to some settings in our project's build environment. \nI will get back here and report any finding, in case somebody has the same problem.. ",
    "AlessandroMulloni": "I just found a fix for this issue, which was a Carthage+XCode issue and not specifically related to Cartography. It is a rather hidden XCode setting. Please refer to my latest comment on the thread here: https://github.com/Carthage/Carthage/issues/2220. ",
    "khanhshopback": "I see. Thank @corujautx . ",
    "kylemilloy": "Can we get this as a release (v3.0.2) so I can specify a version in my cartfile please :). ",
    "fssilva": "Is there an ETA for this fix to be merge ? . ",
    "djyouyou321": "295.",
    "johndoehelloworld": "Sorry wrong project!. ",
    "aleix616": "Same problem here!. ",
    "slni": "Same problem !!!!. ",
    "nikunjazilen": "Facing same issue in Swift 4.2 and Cocoa Pod Version 3.1.0. ",
    "oci300": "Nevermind. ",
    "valexa": "Precisely !?\n. ",
    "Tylerian": "Yes, that's exactly what I meant. It would save us a lot of boilerplate code when defining UILayoutGuide related constraints.. ",
    "Monkey-D-Mark": "I got this errors as well. It's ok in Xcode 10, appears in Xcode 10.1 beta2 anyone can help?. ",
    "uhavemysword": "Same issue,Help!. ",
    "timdonnelly": "For anyone still having trouble with this: NSLayoutAttribute was renamed to NSLayoutConstraint.Attribute in Swift 4.2.\nI opened a PR to add swift_version = 4.2 to the podspec, which will remove the requirement that Cartography is integrated into a target that also uses 4.2 (for those using Cocoapods, at least).. ",
    "micnguyen": "It looks to be there? I've just tried it and it works with Swift 4.2\nhttps://github.com/CocoaPods/Specs/blob/master/Specs/9/9/2/Cartography/3.1.0/Cartography.podspec.json. ",
    "jackfreeman": "Thanks! It would be awesome to get one to properly update my dependency management and point it to the new version. . "
}