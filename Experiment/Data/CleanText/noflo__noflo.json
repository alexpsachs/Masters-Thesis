{
    "bergie": "We need a nice web graph library for doing this. Some options I've found:\n- jsPlumb (see example), MIT license, works with jQuery, MooTools or YUI\n- Draw2D (see example), LGPL but interestingly website says purchase. Works with MooTools\n- UMLCanvas (see example)\n- WireIt (see example), MIT license, YUI\n. Here is also an interesting example from the proprietary world\n. In essence a running FBP graph should be possible to visualize a bit like nuclear plant control rooms where you see the flow and throughput of processes with a simple glance.\n. @nka11 agreed, jsPlumb seems like the best option. It doesn't impose any particular editing UI, so we can implement our own UX. And it is MIT-licensed which fits NoFlo licensing.\nWireIt would've been most feature-complete of the bunch, but I feel it tries to do too much.\n. Current status of the GUI with jsPlumb:\n\nWe can now visualize existing networks, but editing them doesn't do anything yet.\nTo get here, do the following:\n- Start the NoFlo shell with $ noflo\n- Either load an existing graph (load file) or create a new one (new graphname)\n- Start HTTP server startserver 8003\n- Direct your browser to the server\n. Met the developer of JointJS recently. The DEVS example is pretty good fit, including showing port names.\n. @mwawrusch: lists are good for debugging, but some sort of visualization (throughput, number of packets processed) would probably work better for getting an overview of the state of a running application.\nAgreed that JointJS is a closer match to the needs of FBP visualization, and I'm, also a bit allergic on Google Code.\nI also heard an interesting idea of visualizing ports as jigsaw puzzle connectors. That way you could directly see what components fit together. But that is something to be explored later.\n. @jrz in nutshell, jsPlumb appears to be more mature, but JointJS has some features that we really would like to have in NoFlo (like named ports).\nA big difference is that in jsPlumb nodes are regular DOM elements (DIVs, for instance), and only the edges are drawn with canvas. In JointJS the whole graph is a canvas. It appears the jsPlumb approach performs slightly better with large graphs.\nAnother potential differentiating point may be mobile support. I've been able to edit jsPlumb graphs using the HP TouchPad browser.\n. There is also an effort to make DrawFBP able to create NoFlo networks. While we'll still also want a nice web-based editor, this is also a great thing for having a UI.\n. Interesting, this new demo of jsPlumb appears to support named ports.\n. @mwawrusch great! I'd be happy to integrate any results of that :-)\n. It looks like http://meemoo.org/dataflow/ will be the way to go\n. As required by #49, the UI work has been moved to a separate repository: https://github.com/bergie/noflo-ui\n. @mchogan I'm starting to lean towards SVG. Works better on high-res displays, and probably also performs better in the long run.\n. Here is my latest thinking on the matter: http://bergie.iki.fi/blog/inspiration-for-fbp-ui/\n. \nSome interesting progress in https://github.com/forresto/dataflow-noflo/\n. @kenhkan for showing components there is forresto/dataflow-noflo#15\nPort exporting is part of the requirements in forresto/dataflow-noflo#11\n. Closing this issue here as we now can track the progress in https://github.com/noflo/noflo-ui and https://github.com/noflo/noflo-ui-server\n. Update on the state of things: http://bergie.iki.fi/blog/noflo-update/\n. First proposal:\n{\n    \"properties\": {\n        \"name\": \"Count lines in file\"\n    },\n    \"processes\": {\n        \"Read File\": {\n            \"component\": \"ReadFile\",\n            \"position\": [\n                1,\n                2\n            ]\n        },\n        \"Split by lines\": {\n            \"component\": \"SplitStr\",\n            \"position\": [\n                1,\n                2\n            ]\n        },\n        \"Count Lines\": {\n            \"component\": \"Counter\",\n            \"position\": [\n                1,\n                2\n            ]\n        },\n        \"Display\": {\n            \"component\": \"Output\",\n            \"position\": [\n                1,\n                2\n            ]\n        }\n    },\n    \"connections\": [\n        {\n            \"data\": \"foo.txt\",\n            \"tgt\": [\n                \"Read File\",\n                \"source\"\n            ]\n        },\n        {\n            \"src\": [\n                \"Read File\",\n                \"out\"\n            ],\n            \"tgt\": [\n                \"Split by lines\",\n                \"in\"\n            ]\n        },\n        {\n            \"src\": [\n                \"Read File\",\n                \"error\"\n            ],\n            \"tgt\": [\n                \"Display\",\n                \"in\"\n            ]\n        },\n        {\n            \"src\": [\n                \"Split by lines\",\n                \"out\"\n            ],\n            \"tgt\": [\n                \"Count Lines\",\n                \"in\"\n            ]\n        },\n        {\n            \"src\": [\n                \"Count Lines\",\n                \"count\"\n            ],\n            \"tgt\": [\n                \"Display\",\n                \"in\"\n            ]\n        }\n    ]\n}\n. Latest proposal after some discussion on the FBP list:\n{\n    \"properties\": {\n        \"name\": \"Count lines in a file\"\n    },\n    \"processes\": {\n        \"Read File\": {\n            \"component\": \"ReadFile\"\n        },\n        \"Split by Lines\": {\n            \"component\": \"SplitStr\"\n        },\n        \"Count Lines\": {\n            \"component\": \"Counter\"\n        },\n        \"Display\": {\n            \"component\": \"Output\"\n        }\n    },\n    \"connections\": [\n        {\n            \"data\": \"package.json\",\n            \"tgt\": {\n                \"process\": \"Read File\",\n                \"port\": \"source\"\n            }\n        },\n        {\n            \"src\": {\n                \"process\": \"Read File\",\n                \"port\": \"out\"\n            },\n            \"tgt\": {\n                \"process\": \"Split by Lines\",\n                \"port\": \"in\"\n            }\n        },\n        {\n            \"src\": {\n                \"process\": \"Read File\",\n                \"port\": \"error\"\n            },\n            \"tgt\": {\n                \"process\": \"Display\",\n                \"port\": \"in\"\n            }\n        },\n        {\n            \"src\": {\n                \"process\": \"Split by Lines\",\n                \"port\": \"out\"\n            },\n            \"tgt\": {\n                \"process\": \"Count Lines\",\n                \"port\": \"in\"\n            }\n        },\n        {\n            \"src\": {\n                \"process\": \"Count Lines\",\n                \"port\": \"count\"\n            },\n            \"tgt\": {\n                \"process\": \"Display\",\n                \"port\": \"in\"\n            }\n        }\n    ]\n}\n. Updated proposal. This is what the componentapi branch of NoFlo now uses. As you can see, now components need to do a lot less port juggling:\n```\nnoflo = require \"noflo\"\nclass Counter extends noflo.Component\n    description: \"The count component receives input on a single input port, and sends the number of data packets received to the output port when the input disconnects\"\nconstructor: ->\n    @count = null\n    @inPorts =\n        in: new noflo.Port()\n    @outPorts =\n        count: new noflo.Port()\n    @inPorts.in.on \"data\", (data) =>\n        if @count is null\n            @count = 0\n        @count++\n    @inPorts.in.on \"disconnect\", =>\n        @outPorts.count.send @count\n        @outPorts.count.disconnect()\n        @count = null\n\nexports.getComponent = ->\n    new Counter()\n```\n. Marking closed, we'll go with this API for now.\n. On longer term, NoFlo should have some component repositories API for knowing what components are available (as this will be required for the GUI), but for now this approach is enough.\n. This will be handled via #49\n. The FBP parsing implementation should additionally be moved out of NoFlo core into its own module\n. The work on this is under way in https://github.com/noflo/fbp\n. Doesn't look like this is going to happen after all. Hook.io should be handled via components, a bit like Message Queues\n. The issue seems to be with the shell library parsing commands, as shown here:\nCount lines in a file>> disconnect ReadFile source\nCount lines in a file>> send ReadFile source README.md\nCommand failed to execute\nCount lines in a file>> send ReadFile source README\n{ [Error: ENOENT, no such file or directory 'README'] errno: 34, code: 'ENOENT', path: 'README' }\nI'll investigate if we can have some workaround.\n. Docco-Husky is something we already have a Cake task for. Just run:\n$ cake doc\nAnd it will regenerate the documentation. But indeed, the component docs need to be written!\n. Generated documentation can now be found from http://noflojs.org/docs/\n. @rybesh sorry about taking my time with these. This pull req doesn't apply cleanly any longer, unfortunately. Can you rebase and push so it gets updated?\nThis may also be somewhat related to #40\n. @rybesh there is an initial callback support there now with the new Component Loader from #49. I'll try to merge that with your PR\n. Thanks for the PR! I'm mostly offline this week in Istanbul, so I'll be able to look at these in details next week\n. @kenhkan sorry about taking my time with these. This pull req doesn't apply cleanly any longer, unfortunately. Can you rebase and push so it gets updated?\n. @kenhkan the API switch will require some changes that affect all NoFlo components, and so I'm thinking we may want to make a bit nicer \"base class\" that abstracts some of this away. We will also need to provide an expanded stream implementation with the grouping stuff included.\nAnother thing to check is how to deal with disconnect/reconnect in the API.\n. Stream support will be quite easy to do, but that will be another point where server-side NoFlo and client-side NoFlo then diverge, so we must be careful.\nEssentially input ports will be readable streams and output ports writable. We need to add grouping support to steam data however to support \"bracket IPs\".\nThen the connection API can be as simple as:\nFooNode.outPorts.out.pipe BarNode.inPorts.in\n. Interesting, I'll look at that tomorrow!\n. This is also interesting https://github.com/inh3/nPool\n. As it happens, we had a long discussion with @igorw about defining a wire protocol for NoFlo (and FBP in general) that could then be used via ZeroMQ, WebSockets, etc, allowing graphs to span multiple systems and even client/server.\nIn nutshell, JSON payload, and different packet header for all the relevant message types:\n- connect\n- begingroup\n- data\n- endgroup\n- disconnect\n. @kenhkan unfortunately it was a casual conversation. But maybe @igorw would like to write something here?\n. I've added an issue #107 for discussing the wire protocol.\n. Now that NoFlo supports both browsers and Node.js it seems we won't be able to move cleanly to the stream API.\n. @xcambar Browserify is interesting, but would require quite big tooling changes for NoFlo as we're using Component now\n. @xcambar I have nothing against Browserify, I'm just reluctant to do the porting work (busy on the UI and components!)\nSo if there was a PR, I'd definitely be interested. The actual execution of course decides whether we'd stay with Component or go Browserify.\n. I think we can actually remove the daemon dependency if it is misbehaving\n. @kenhkan great point about making it possible to package and distribute graphs!\n. Here is the first repository of restructured components: https://github.com/bergie/noflo-yaml\n. Things are starting to look quite good. We have the new component loader that is aware of modules, and I've starting moving components to their own modules.\nBTW, you can see what components are available in your project by running:\n$ noflo list .\n. Some information about this change on the FBP mailing list: https://groups.google.com/d/topic/flow-based-programming/zgrOci3Q_Y0/discussion\n. We should do some additional work here:\n- Move all core components out of this repository and create modules by their category, like filesystem (see #61), DOM (see #66), and routing (see kenhkan/noflo-routers)\n- Move the FBP parser to its own repository (see #8)\n- Remove the dependency on Underscore.js, given that the NoFlo core only utilizes reduceRight which is now available natively on modern JS engines\nThis is especially important given that we're supporting browsers now. This way we could keep the NoFlo browser builds a lot smaller. Current builds of NoFlo core are 60KB, and we can go a lot smaller than that.\n. @kenhkan yes, in my view all components should be moved out of the core. Things like Split could be moved to a \"routing\" package, or maybe we could just have something like \"core components\" package.\nEspecially with the browser, the more specific we can make the packages, the smaller the downloadable JS file will be.\n. The new Grunt scaffold should make it a lot easier to publish lots of small, specialized component packages \n. @kenhkan I think we should release 0.4 soon. The core is well ready for that, but I'd like to remove components from there before we release to have a stable API ( ComponentName vs. package/ComponentName)\n. @kenhkan the categorization sounds very good! How far are you in this process? If you have the repositories up already, might be handy to give me also commit access :-)\nAlso, note that these should probably go with #82 \n. All filesystem components have now been moved to https://npmjs.org/package/noflo-filesystem, therefore closing #61 \n. @robingl so the main issue is the parsing rules, then. Can you create an issue against https://github.com/noflo/fbp\nShould be a quick fix, see for example https://github.com/noflo/fbp/pull/1/files\n. @robingl your component loading issue should be fixed by this fbp commit. I'll publish on NPM soon.\n. @kenhkan thanks, great work! Getting close to 0.4 release...\nAs for the questions:\n1. That depends on whether we can find the same dependency for Component. Your example of Underscore is available for example. The require statements may need some minor if/else magic, though. See example \n2. I'm planning to port noflo-test to use Mocha instead of Vows so we can run it also for the browser side, so I'd stick with that\n3. Ok. That should be in couple of days\n. The DataFlow library uses the following types:\n- all\n- string\n- number\n- int\n- object\n- array\nWhile we may want to go deeper with something like \"year\" or \"mimetype\", these would be a good start \n. We also support color\n. @kenhkan why is this necessary? Your project can just as easily register its components and subgraphs in the package.json just like any other module\n. Thanks for the PR! However, I'm really sorry but the indentation level change from #56 makes this impossible to merge. Can you tweak the indentation in your files correspondingly?\n. If we're buffering IPs, then the important thing to take care of is also that they're sent out in the same order as they've been received. This would simplify a lot of flows.\nFor example, if I have a component that fetches the contents of a web page asynchronously, and I send it a bunch of URLs, right now the results are sent out in whatever order the async callbacks fired. Instead, they should be sent out in the order the component received the original URLs.\n. A bit of continuation to this, from the FBP book:\n\nNow how do we prove to our satisfaction that this connection is processing our data correctly? Well, there are two constraints that apply to IPs passing between any two processes. If we use the names in the above example, then:\n- every IP must arrive at SELECTOR after it leaves FILTER\n- any pair of IPs leaving FILTER in a given sequence must arrive at SELECTOR in the same sequence\nThe first constraint is called the \"flow\" constraint, while the second is called the \"order-preserving\" constraint. If you think about it using a factory analogy, this is all you need to ensure correct processing. Suppose two processes A and B respectively generate and consume two IPs, X and Y. A will send X, then send Y; B will receive X, then receive Y (order-preserving constraint). Also, B must receive X after A sends it, and similarly for Y (flow constraint). This does not mean that B cannot issue its \"receives\" earlier - it will just be suspended until the data arrives. It also does not matter whether A sends Y out before or after B receives X. The system is perfectly free to do whatever results in the best performance. We can show this schematically - clearly the second diagonal line can slide forward or back in time without affecting the final result.\n\nWe should ensure that NoFlo obeys these rules, also with async components.\n. ...and even more from the FBP mailing list:\n\n\"Flow Based Programming\" mentions three general constraints.  To \nthese I have added two more.  They are: \n(FBP) The flow constraint: Basically this says a package cannot \nbe delivered until it has been sent.  This may seem obvious but \nit implies that data flows follow a flow diagram. \n(FBP) The one place at a time constraint:  In FBP an information \npacket can only be in one place at a time - either in a queue, \nwithin another IP, or within an auton.  I distinguish between \ndocuments and data;  Documents are objects that can only be in \none place at a time.  Data are not objects; they are only values. \n(FBP) The consistent ordering constraint:  The general statement \nis that objects must be processed in the same order that they are \nsent.  The ordering constraint implies that packages must be \nstored in queues before they are delivered. \nThere are three variants of this constraint, inport order, auton \norder, and nest order. \nInport order: The inport queue (or its image in a larger queue) \npreserves the order in which the packages were sent. \nAuton order: Packages sent to an auton are processed in the order \nthey were sent.  Auton order is usually associated with an auton \nqueue. \nNest order: A master queue holds all undelivered packages in the \norder that they were sent. \n. Thanks for the work on this! Let me know how that external package proceeds :-)\n. @kenhkan this already works, actually. For a good example, check out noflo-yaml:\n- Subgraph that exports some ports\n- The subgraph declared in package.json\n- Example of a NoFlo program using that subgraph\n\nSo yes, with the EXPORT statement and declaring in package.json, you can use any graph from any NPM module just like a component.\nIf you need to know whether something is a component or a subgraph, the instances have a isSubgraph method that returns a boolean.\n. Wrote a bit longer version to https://groups.google.com/d/topic/flow-based-programming/ycrFDIu2RHw/discussion\n. @atian25 there is a Google Group available for flow-based programming. That should be a good place for NoFlo questions. I'm also usually available at #fbp on FreeNode, though not for the next couple of days because of the New Year celebrations.\nThat particular example should actually be moved to the separate noflo-webserver repository, as the HTTP components have been moved there.\n. This will be useful for the-grid/the-graph#43\n. @forresto so that loadJSON and toJSON will produce consistent results.\n. @forresto not yet, only unit tests. I'll set up something next week\n. @subtleGradient sure. I wrote something about the why and how of Component in this case earlier, and there was more discussion about browserify in the comments.\nIn nutshell, I wanted something that would enable easy code-sharing, but also would be meaniningful for JavaScript developers outside the Node.js ecosystem. After all, there is no reason to limit browser-side NoFlo to just Node.js users :-)\n. Thanks for the quick fix!\n. Yep, the concept of Macro Patches is very similar to subgraphs in NoFlo, and a regular patch would be the same as a NoFlo component. Publishing ports on a macro patch is also similar to NoFlo's exported ports (see #59)\nThere are some subtle differences. For instance, I don't see why inside a subgraph the published outports would need to be exposed via a special \"Feedback component\" when simply a Splitter and looping connection would do.\nSimilar thing with the special way of connecting visual components and interaction components together, should in my view be a regular port connection. As should be the handling of z-indexes (layering). \n. @subtleGradient thanks for the clarification! I think that part will work a bit differently in NoFlo, as we will be manipulating DOM instead of working with \"display PDF\". So visual components will probably have an outport where their containing DOM element is sent so that you can then place them in the chosen places on your document or documentFragment.\nThe benefit here is that you could quite easily embed NoFlo-driven parts to almost any regular web page. Or if you're prototyping a UI, just write everything to the body :-)\nInteraction components (purple patches) executing only on idle is quite close to how JavaScript's event loop works.\nAs for things not executing unless connected, that is already covered by normal FBP concepts like most components requiring some input before they actually start sending stuff out.\n. Will do! I want to do some experimentation with visual components next week.\nAnd yeah, for performance requestAnimationFrame and WebWorkers will both be quite relevant for NoFlo\n. @forresto shared a link to Toolkitchen which could provide some interesting ideas for the visual NoFlo components\n. @subtleGradient this is something we could probably do quite easily with the throttling support that already exists in https://github.com/bergie/noflo/blob/master/src/lib/AsyncComponent.coffee \n. @subtleGradient it will, just like you can wrap any Node.js modules into NoFlo components. But we need to start with something that gives us reasonable widgets to demo with :-)\n. Baby steps. GetElement is our first visual component. Essentially runs document/element.querySelector and sends out the resulting element. Next up: mouse and touch interaction listeners.\n. @subtleGradient @forresto @d4tocchini highly initial demo of some touch interaction with NoFlo on browser: http://noflojs.org/demo/touch.html\nSo far tested only on Chrome on an Android device and Safari on iPad. Note that there is currently no mouse listening active, so you can move the image only with touch-capable devices\n. Alright, now there is also a demo of springiness added to http://noflojs.org/demo/touch.html\nMakes the graph slightly more complicated, but a lot of that can be removed by moving stuff to subgraphs.\ncc / @subtleGradient @d4tocchini\n. I was thinking about QC components like Sprite and Billboard a bit. In NoFlo the best way to see these would probably be a set of \"templated HTML\" components that provide their own input and output ports, and which you could easily place into the DOM.\nFor example, a Button component could have a \"label\" inport, and outports providing \"element\" and \"click\". With the element outport you can then place the newly-created button element anywhere in the DOM (other option would be to provide a container via inport), and the click would send an event whenever the button is pushed.\nTo construct visual components like this, we first need some barebones DOM handling components, like something for creating new elements and placing content to them, and the positioning/interaction components we already have. With those, each widget could just be a packaged subgraph :-)\n. @subtleGradient we certainly need to start with quite low-level components (which would then be specific to DOM, canvas, or whatever), but those can be used as the building blocks for more generic components/subgraphs.\nFor Sprite, can you provide some use cases? That would help in design, as my experience with QC is quite limited.\n. The DOM handling components have been moved from core to https://github.com/bergie/noflo-dom\n. Individual component libraries and requests for new components are better handled in the issue trackers of their respective libraries\n. @subtleGradient this should probably be handled as its own NoFlo package as it introduces a new dependency. Luckily, our latest ComponentLoader supports working with multiple packages also on the browser :-)\nHowever, to make it, I would need to know a little bit more about the intended use case. Should there be a single component, or multiple? What inputs and outputs should they have?\n. Individual components are better handled as their own libraries\n. I'm not so sure on this one. I think the output component should just do that: output the package contents. My usual use case for it is giving feedback on things for CLI scripts, not debugging.\nYou can already get this debug information through:\n$ noflo -d somegraph.json\n(or by listening to the events from the network in your custom runner)\n. You have to install the dependencies via Component first:\n$ component install\n. @kenhkan the way I see it, the NoFlo engine should be buildable for both platforms from the single source tree. We already have the platform-specific build and test tasks also available (like grunt test_nodejs), but these could be made more apparent.\nAnyway, agreed that our NPM installation should be done so that it is self-sufficient. See also Also related, see smhg/grunt-component#2\n. I've now been able to automate component dependency installation (pushing fix soon). Please note that your local builds may still fail until CamShaft/component-json#2 is pushed to NPM.\n. Each registered graph (not yet on browser, will be there tomorrow) will be available just like if it was a component.\nIf you want to do this manually instead of registering your subgraphs with the ComponentLoader, feed your graphs directly to an instance of the Graph component. That is how ComponentLoader does it too.\n. @subtleGradient I don't see why you would need a JSON-only solution. Each graph is its own JSON document. They are registered to ComponentLoader with a name (just like components are). ComponentLoader loads them via the Graph component when you use them as subgraphs.\n. @subtleGradient the idea was to promote reusability of subgraphs by keeping them separate. But we could quite easily tweak the Graph component to support receiving them directly.\nThen you could \"inline\" your subgraphs as IIPs, like this:\n{\n  \"processes\": {\n    \"MyGraph\": {\n      \"component\": \"Graph\"\n    }\n  },\n  \"connections\": [\n    {\n      \"data\": {\n        // some graph JSON\n      },\n      \"tgt\": {\n        \"process\": \"MyGraph\",\n        \"port\": \"graph\"\n      }\n    }\n  ]\n}\nWould this work for you?\n. @subtleGradient did the fix I pushed work for you?\n. In general, this looks good. However, I'd rather see the logic in Network itself, not in NoFlo.createNetwork. However, I'm ready to merge this as-is, too.\n. Also related, see smhg/grunt-component#2\n. I think this patch is a bit problematic, for couple of reasons:\n1. npm install -g may require additional privileges and can fail because of this\n2. these dependencies are only needed when building a custom NoFlo\nTherefore I'd rather improve the devDependencies setup, and ensure all commands use locally-installed versions, not global. \n. @kenhkan just a quick note: grunt test does a build implicitly, so need to run both :-)\nDid you try grunt watch yet?\n. @kenhkan it appears the build issues arise from CamShaft/component-json#2 I hope a new version will hit NPM soon.\n. Thanks a lot for this patch! I wonder what kind of tests we should have for verifying that the order is indeed correct...\n. Take your time :-)\nThe reason I mentioned tests is that things like order of sent packets are something where regressions happen easily.\nMocha tests would be best, as those we can already run on both browser and node.\n. The version of NoFlo available on NPM should already include the built JavaScript files. Note that there are no releases of 0.4 series yet.\n. @d4tocchini the exported ports should be directly available as if they were ports of the graph component itself. So, something like:\ngraph.addEdge('Sub', 'start', 'SomeNode', 'in');\n. Oh, and to clarify: the same export mechanism is used for both in and out ports\n. Great work, thanks!\n. It appears we already had https://github.com/noflo in place\n. This migration is now complete\n. #51 gave us primitive type annotations like integer or object, but agreed that it would be cool to dig deeper into the objects being sent. Having as accurate port type annotations as possible would help in bergie/noflo-ui#7, as we could filter out any components or ports you can't connect with\n. @forresto that is already doable, if verbose, with the GetObjectKey component:\nfbp\n'pointer 1' -> KEY GetPointer1(GetObjectKey)\n'x' -> KEY GetX(GetObjectKey)\nPointerEvent OUT -> IN GetPointer1\nGetPointer1 OUT -> IN GetX\n. This also should have editor-level support in NoFlo UI, see meemoo/dataflow#61, and we need to be able to carry this information over the Component protocol described in #107 \n. I think the way to go about this would be to follow the JSON-LD type convention. Here the ports can specify the type of data by pointing to an ontology URL (essentially, a string). They can also provide multiple types they're able to work with by giving them as an array.\n. The thing about RDF-style type URIs is that there may or may not be a machine-readable definition behind them. It would of course be useful if there was, but in any case you're able to use the URIs as unique type identifiers. And this enables people to write components that say I'm able to convert from employee to a person\n. Currently initials are removed with the removeEdge method, but it indeed makes more sense to move this to its own method.\n. You need two Component plugins for building NoFlo:\n- https://github.com/CamShaft/component-json (for including JSON files into packages)\n- https://github.com/anthonyshort/component-coffee (for compiling CoffeeScript to JS) - however, see the workaround in anthonyshort/component-coffee#3\n. If you're using Grunt, here is the relevant build config that works with NoFlo:\nhttps://github.com/bergie/polymer-noflo/blob/master/Gruntfile.coffee#L6\n. I'll close this bug when we have proper documentation on Component building and installation on the site.\n. @forresto I've been thinking about that. There could be, but that would somewhat clutter the commit history. Not yet fully decided, but for now the plugins seem to work. In GSS we include the built versions, in NoFlo we don't.\n@visionmedia seems to feel strongly that precompiled JS should be there, however.\n. The new GitHub Releases feature could potentially solve the issue of serving compiled assets without having to put them into the repository.\nOf course, it will take a while before the ecosystem around us (Component, NPM, etc) will support it.\n. I suppose http://noflojs.org/download/ will also help :-)\n. I found the issue in Component builder, see component/builder.js#125\nHopefully @visionmedia will have time to merge and release soon, as then we can greatly simplify the build process to:\n$ component build --use component-coffee,component-json\n. @kenhkan correct. Since every regular port will now behave like ArrayPorts used to, Split and Merge won't be needed any longer. You can just wire things up directly with less \"micromanagement\" needed.\nThings like Collate and routing are of course still valid cases, and will still use ArrayPorts since they treat the different connections they have separately (so, in[0], in[1], etc)\n. Quick sketch to clarify the difference. In both cases we have a component with a single inport. In the first one it is a regular port (allowing multiple connections as clarified here), and in the second one it is an ArrayPort.\nSince each connection of an ArrayPort can be addressed separately, they should also be shown separately with the array index added to the port name.\n\nAnd of course outports would need to be treated/visualized in the same way.\n. @jpaulm deep cloning is sort of an issue with anything more complex than simple JavaScript literals. For example, objects are handled as references, and would have to be cloned always to ensure there is no shared memory between processes.\nAlso, the port will know how many connections it has. If there is just a single one, send the packet as-is. If there are multiple, then clone.\nThe relevant NoFlo source line is https://github.com/bergie/noflo/blob/master/src/lib/Port.coffee#L56\n. @kenhkan we need the separation because in this new way of thinking, ArrayPorts should always address different sub-ports, not the combination of all their connections. And see the different visualization for them as well that touches @forresto 's UI work.\n. Sorry for jumping the gun and responding before reading the whole thread. However, there were couple of points that I wanted to touch:\n- There are lots of ways to clone a deep object in JavaScript. See this performance comparison for some of them. Cloning could be handled transparently inside a port when needed (i.e. when an outport has multiple connections attached)\n- In NoFlo we work around the coroutine issue by relying on JavaScript's event loop. Here is the sequence of events as it happens in NoFlo when you send a packet:\n1. You call the send method on the outport you want to send the packet to. In case of ArrayPorts, you must specifiy the connection index (port.send(data, 1) instead of port.send(data))\n2. The port looks up the right socket (or sockets), and calls their send method\n3. The socket emits a data event, which is put to the event queue of the JS VM\n4. When the VM has completed anything else it has been doing, a callback function on the receiving input port will be called\n5. The input port also emits a data event with the packet, which is put to the event queue of the JS VM\n6. When the VM has completed anything else it has been doing, the event listener function of the receiving NoFlo process will be called\nCouple of quotes from the book Async JavaScript explaining how the event queue works:\n\nWhen we call setTimeout, a timeout event is queued. Only when our JavaScript code has finished running does the runtime ask, \u201cOK, what\u2019s on the queue?\u201d\nInput events work the same way: When a user clicks a DOM element that you\u2019ve attached a click handler to, the click event is queued. But the event won\u2019t fire until after any running code has finished.\nTo summarize: Events can be queued while code is running, but they can\u2019t fire until the runtime is free.\n. On browser we utilize an EventEmitter implementation which is API-compatible with Node.js. I just went through its (very short) source code, and indeed it appears to be fully synchronous. This means we're not using the regular JS event queue as I described above, but instead those spots are just direct function calls as @kenhkan implied earlier.\n\nThis means that the asynchronous part of NoFlo - at least on browser - only comes from the components itself, not from the way the network is wired. The advantage of this is of course performance... in simpler networks where you only do synchronous operations (say, DOM access), packets will simply flow through a series of function calls, which is what JS is optimized for.\nHowever, enforcing asynchronicity here would be more true to the form of FBP, but as @kenhkan also noted, we don't have the fast process.nextTick available on browsers.\nThe current NoFlo is already working in both environments, browser and Node.js, and I'd like to keep it that way and still utilize as much of the current codebase as possible.\nI believe @forresto 's solution to this has been to utilize postMessage between the different processes, as that does end up in the JS event queue.\nIn any case, what we have in NoFlo appears to work, but there are certainly many parts where we may want to tweak the behaviour to be closer to how JavaFBP and other similar environments work.\n. here is an interesting implementation of process.nextTick for browser that uses the browser's event queue. This would make the packet transmission following the sequence I described\n. For threading, there are different approaches. WebWorkers are available on browsers, and there have been Node.js implementations as well, even if they don't seem to be actively maintained.\nOn paper, WebWorkers would have been the perfect way to implement FBP processes. Completely isolated, no shared memory, and communications between them and the coordination process via a message-passing interface. However, in practice they do have disadvantages, mainly through a quite high cost of spinning them up, and in that they're not universally available in browsers.\nInstead of making every process a WebWorker, I had some plans for being able to run whole NoFlo networks as separate workers when needed.\nNode.js child processes sort of have the same time and cost issue, and of course the API is slightly different from WebWorkers.\nAs for the earlier question of Why JavaScript, I think I answered better in my The Universal Runtime blog post than space allows here :-)\n. @jpaulm fully agreed with @kenhkan here... what I meant was that JS is a universal runtime, something that can run from clusters of servers to even the mostly tightly locked down appliances like the iPad. This doesn't mean that JS is the ultimate language to write in -- and as a matter of fact, NoFlo is written in CoffeeScript, a much nicer language that compiles down to JS.\nI also agree that FBP should strive towards being able to mix-and-match different languages and runtimes. I can easily see the sense of having flows where some parts run Java, others Python, and yet others JS. Actually, we have a little bit of that in the ReadDocument component where we invoke the JVM in order to parse Microsoft Office documents using the superior utilities for that provided by the Java ecosystem.\nHowever, even if we pursue this multilingual and multi-runtime vision, we still need maintain the capability of NoFlo running its flows self-contained, as that is the only way we can serve FBP to the walled gardens of the post-PC appliances.\nSo given this requirement, we need to be able to make NoFlo provide the full FBP environment, and at the same time live with the limitations of the JS runtime (multiple runtimes, actually... each major player in the world of computing provides their own JS runtime, and we run on all of them). I hope the current NoFlo architecture strikes the right balance here.\n. @jpaulm compatibility between NoFlo and JavaFBP is certainly an area which we should explore together. This includes common interfaces and practices in several areas:\n- Common format for flow definitions (see my takes for JSON and .fbp)\n- \"Standard library\" of components that are named in the same way, and behave the same... things like Collate or ReadFile\n- Common interface for talking to a FBP runtime, including loading and saving of graphs, and retrieving the list of components and their metadata (ports, etc). This could be HTTP, for instance\n- Way for different FBP environments to send packets to each other\nSolving these in a satisfactory way would help also the rest of the FBP ecosystem, as other environments (say, @forresto's Meemoo, or the Pypes environment for Python) could also adopt the same practices.\nThese would also help with tooling, as then it would be a lot easier to make things like DrawFBP and dataflow support the different FBP environments with minimal adaptation work.\n. @jpaulm the reason for disabling Java to make browsers more secure has to do with the fact that Java code from the web will be run by the browsers, whether sanctioned by the IT department or not. And the JVM is full of security issues. This combination makes it highly dangerous.\nJavaScript, on the other hand, has been designed ground-up for being used for random third-party snippets of code. There have been security issues (lately with WebGL if my memory serves me right), but far less than with Java where a secure sandbox wasn't really part of the original design.\nThat said, both of them have their roles and places. But Web is not a place for Java.\n. @kenhkan I think the component/graph declaration has to stay there... otherwise NoFlo's ComponentLoader would have to do a lot of directory traversal to load them, and that would be slow.\nBut having a tool for automatically maintaining them would be great! Let me know if you need any help there.\nOne tricky part is knowing which components work on which platform (Node and browser), and so should appear in either package.json, component.json, or both. Maybe we could do some comment annotation thing in the component files for this?\n. @kenhkan I don't think we should strictly enforce Grunt, but probably most NoFlo developers will use it for reasons of convenience.\nI'd see tools like this done on two levels:\n1. As a standalone Node.js library with a command-line tool you can invoke\n2. As a Grunt plugin that utilizes the library\nThis way developers have the freedom of going either way.\nAs for Node.js vs. browser, the current way to tell which engine a component works in is to include it in the platform-specific JSON file. But this information could be somewhere in the component file as well.\nThere are lots of components that are platform-independent, but practically any component doing I/O will probably be specific to one platform due to their differences.\n. As an example of the approach above, see https://github.com/the-gss/compiler as a library, and https://github.com/the-gss/grunt-gss-compiler as the Grunt plugin utilizing that library.\n. @kenhkan since grunt watch can be set up to run any task(s), having a task to generate and place the component and graph declaration to the JSON files should be enough.\nAs for how the task should work... I think it should always update the component declarations to the latest state.\nWe could use an annotation, like:\n``` coffeescript\n@engine browser\n```\nto specify the engine. Accepted values could be nodejs, browser, or any.\n. @kenhkan that could work, but then we need to ensure all components are possible to require on Node.js without errors.\n. @kenhkan component might not be requireable in situations where it tries to load libraries that are only available on a specific platform, or when it expects to have globals available that only work in the browser. We could try to enforce that everything should at least be possible to require and instantiate on Node.js, even if they don't actually target it as a platform. This could help also with noflo-ui, as it would be easier to get the ports of each component this way.\n. @kenhkan yep, this only affects component developers, not users.\n. @kenhkan agreed. It is also more consistent. The second approach would allow more lazy graph definitions that could break easily in the future when there are more component name clashes.\nAlso, implementing #49 will free us from this chunk of code\n. @kenhkan yeah, why not.\n. @kenhkan maybe browser_modules/ would be a good place for the Component dependencies, similarly to node_modules/ from NPM. Our default builds already place the built browser JS versions to browser/\n. It seems component is unfortunately not configurable for doing this.\n. @AtKaaZ unfortunately I don't have access to Windows to debug this, but certainly I'd love to support that platform as well. Let me know if you find out what is going wrong there!\n. @AtKaaZ ah, reading the error again, it seems the issue is with detecting the Node.js environment on Windows, so it tries to run with browser version of dependencies. We're using the following for detection:\ncoffeescript\nif typeof process is 'object' and process.title is 'node'\nCan you check what console.log(process.title); returns in your environment?\n. you can create a .js file with that and run it with Node\n. @AtKaaZ thanks! Can you try this as well?\njavascript\nconsole.log(process.title.indexOf('node') !== -1);\nIt think that will be the platform check to use.\n. @AtKaaZ I just pushed a potential fix. Can you try it out? If it works, I'll roll it to the various component libraries as well.\nIf you have the time, this would help me to ensure NoFlo works on Node.js on Windows before I push 0.4 out :-)\n. @AtKaaZ that seems to be the same error as before. Did you do a git pull to get my fixes in?\n. @AtKaaZ ok, I think you need to re-run grunt build\n. BTW, this is the main remaining issue before I feel confident to release NoFlo 0.4\n. @AtKaaZ ok, and can you run noflo now?\n. Note that I didn't apply the platform check fix to other component libraries yet. I'll do that once you confirm NoFlo runs after it ;-)\n. @AtKaaZ ok, sounds like the platform check we made is still failing on Windows. Thanks for trying it. Let me figure out another way...\n. @AtKaaZ I changed the approach for platform detection again. Can you pull and rebuild/test again?\n. Can you run this for me?\njavascript\nconsole.log(process.execPath);\n. @AtKaaZ great, thanks a lot! We'll need to roll out the fix to the other component libraries and then NoFlo should be fine on Windows :-)\n@kenhkan we now have:\ncoffeescript\nnoflo = require 'noflo'\nif noflo.isBrowser()\n  # Load browser deps\nelse\n  # Load Node.js deps\n. @AtKaaZ I'll ping you once 0.4 launches with these fixes in. If there is anything else that fails on Windows, just let me know.\nI fixed that CoffeeLint error in my latest push, so if you can pull again and try npm test, that would be great\n. @AtKaaZ yeah, shame about the path difference. But grunt test completes successfully?\n. @AtKaaZ ok, saw that. Pushed a probable fix, so if you can try again.\n(sorry for the commit tennis, remote debugging is never easy)\n. @AtKaaZ ok, pushed a fix for that as well\n. @AtKaaZ awesome, thanks!\nI'll close this issue now, and we'll roll the Windows-compatible platform checks to the NoFlo component libraries over the next few days with @kenhkan \n. Thanks for posting that @adri ! There is also an online version to play with at http://noflo.github.io/dataflow-noflo/demo/\nPlease note that this is still an early prototype of the UI we're building in http://www.kickstarter.com/projects/noflo/noflo-development-environment\nAlso follow the issue #1 \n. @igorw super-cool! I'll need to add this to our testing process\n. There is now a way to experiment (and implement) different component APIs in NoFlo. If a NoFlo library provides a CommonJS module path at the noflo.loader key, the ComponentLoader will require that module and run it, allowing it to register its own components outside of the standard noflo.components and noflo.graphs methods.\nThe registered components should be JavaScript constructor functions that expose a NoFlo-esque API (i.e. inPorts, outPorts, and a shutdown method). However, this way you can easily write wrappers that take a new kind of component API and bind it to NoFlo.\nFor example, https://github.com/noflo/noflo-polymer does this for Polymer web components, exposing the attributes of the custom Polymer elements as the inports, and the events emitted by the elements as the outports.\nThe wrapping layer is quite simple: https://github.com/noflo/noflo-polymer/blob/master/lib/PolymerComponent.coffee\n@Gozala and @visionmedia, would be awesome to try wrapping your proposed component APIs similarly to get some mileage on them.\n. With the new Port API from #136 and the simpler component declaration from #137, we could probably boil down a simple NoFlo component to:\ncoffeescript\nnoflo = require 'noflo'\nmodule.exports = class DoSomething extends noflo.Component\n  constructor: ->\n    do super\n    @inPorts.add 'in', (packet, outPorts) ->\n       return unless packet.event is 'data'\n       # Do something with the packet, then\n       outPorts.out.send packet.data\n    @outPorts.add 'out'\n. @visionmedia agreed on that one. I'd like to simplify this further. But that was just to show where we can get without major API changes apart from the Port handling changes we're doing already.\nBTW, while you're here, have you had the chance to look at component/builder.js#125 ?\n. @forresto yeah, I think that sounds about right... the constructor function for ports will be able to take either one or two options, and ports.add just calls it with the args it gets\n. @kenhkan @forresto there is a test with this in action now at https://github.com/noflo/noflo/commit/57c21d1a3a4553d3c5942bed260a6144857f9725#diff-4bb915eb24d75b380178cb632443c179R39\n. I think we need to do some work using this new component API. I'm closing this ticket, as we should open new, more specific issues in any shortcomings we encounter there.\n. Good point. I'll write it here first, and then migrate over to http://noflojs.org/api/Port.html\nThe NoFlo Port class is used for both inports and outports. As inports, the Ports are seen as event emitters that the component instance listens to.\nThe events are (in the typical sequence they'll appear in, though sometimes you don't get all of these):\n- attach - a connection is made to the port from an IIP or an outport of another node\n- connect - the port is starting to receive data\n- begingroup the following packets should be in this group (may be called multiple times for deeper group hierarchies, see http://www.jpaulmorrison.com/fbp/tree.shtml)\n- data - an individual data packet has arrived \n- endgroup - a packet group ends, similar semantics to begingroup\n- disconnect - end of transmission. There may be new transmissions later, but the current stream is now done\n- detach - a connection is removed to the inport\nExample usage:\ncoffeescript\n@inPorts.in.on 'data', (packet) ->\n  # Do something about an individual packet\nWhen ports are used as outports, they have the corresponding methods to these (attach and detach are called by the network coordinator, so they're not relevant to inside-component use):\n- connect(): about to start transmitting data\n- beginGroup(groupname): packets after this should belong to this group\n- send(data): send an individual packet to a receiver\n- endGroup(): end a packet group\n- disconnect(): end of transmission\nGroup names are always strings. Packet data can be any valid JS value.\n. See also http://noflojs.org/documentation/components/#portevents\n. and http://noflojs.org/documentation/components/#port\n. There is quite a minimal overhead once the NoFlo network is up and running (components instantiated and wired up). After that all messaging happens using events, which essentially mean just JS function calls like you'd have on regular Node.js code.\nThis can probably shed some light on the performance potential: http://bergie.iki.fi/blog/8998693776/\nAudio is still a little bit tricky because of the spotty support for proper webaudio in different browsers. @forresto from the NoFlo team has done some experimentation on it, however: http://forresto.github.io/dataflow-webaudio/\n. Agreed, it should be:\n- Node names (component instances) are CamelCased\n- Port names are UPPERCASE (like in .fbp)\n. In fd9494fece38de30ef9feb0a438df60fdcb49514 I've now added port name validation to NoFlo. Ports must match the following regexp:\n/^[a-z0-9_\\.]+$/\n. The main issue here is that NoFlo alone won't do much. For that you'd also need components. Obviously one way would be to do like we did with the default preview runner in noflo-ui, and have a build of NoFlo that includes all known component libraries that are compatible with the browser.\n. Since the new debounced way of handling NoFlo end events, I'm not seeing those in the timeline any longer. Here is how one 'tick' of the clock looks like:\n\n. @yanko can you try running grunt test instead (make sure to first install Grunt with npm install -g crunt-cli)\n. @yanko @kenhkan actually, looking at that error message the issue is that you're running npm install in the root of your filesystem, not where the NPM module you're trying to get installed is.\nGo to the right folder and run it there.\nI'm closing this issue since installation on Windows is actually not a problem. However, we have still #111 that needs to be handled for full Windows support.\n. See https://github.com/noflo/noflo-runtime-iframe for a testbed of the network communications, this time using postMessage with an IFRAME\n. The new iteration of NoFlo UI is also using the protocol to talk to actual NoFlo runtimes: https://github.com/noflo/noflo-ui\n. @jonnor looks very promising! Are you now in Berlin or Norway? Would be fun to meet and integrate this with the UI.\nAs for the questions:\n\nI think that it should be possible to observe a remote graph, and get messages of graph changes without resorting to polling. Is that what you have in mind?\n\nSure, already implemented in the IFRAME runtime using the \"port-to-port\" protocol over the network channel: https://github.com/noflo/noflo-runtime-iframe/blob/master/runtime/network.js#L129\n\nMinor: Why not call \"graph\" for \"clear\" or \"reset\"?\n\nGood point, I guess clear is better. I'll change that.\n. @trustmaster there is a bunch of components that ignore the group/tree information anyway, so I don't see that as a problem.\nIf GoFlow could talk the network protocol over WebSockets, then the UI could fully work with that :-)\n. The network protocol seems to be working fine now. We still need to write more formal documentation for it, but I'll close this issue.\n. @jonnor that is the main reason I haven't written down the protocol docs yet, as there may be things we still want to tune.\nSoon we will need some additional capabilities as well:\n- Registering multiple graphs to the runtime (for subgraph support)\n- Getting the source code of components, and sending modifications to them (on platforms where this makes sense)\n. Initial documentation for the protocol: http://noflojs.org/documentation/protocol/\n. @jpaulm DOM handling, as @forresto mentioned, is one of the cases where we have to deviate somewhat from the traditional FBP \"single responsibility principle\", and allow the same element to be sent to multiple places. However, one could argue that since the DOM element is actually living inside the browser DOM tree and not in the IP, we're really not duplicating the element, but instead telling different components to perform operations on the element. A bit like a file path is not really the file itself :-)\nHowever, #136 gives us a way to parametrize ports, and this could be the way you could instruct your outports to make clones of IPs they send around for situations where that is necessary.\n. @jpaulm wow, Tobago sounds quite a bit nicer than the late-winter Berlin :-)\nThe \"copy\" block (in this case, core/Split) was necessary before #90 got resolved, as regular ports refused multiple connections. That will be unnecessary with NoFlo 0.5\nYou can actually do \"legends\" in the UI now, thanks to the-grid/the-graph#43\n. This is now pretty much addressed via #136 \n. The current setup is sort of a hack because we're using isAttached to see if a new connection should be allowed. But I agree, isAttached should return true for ArrayPorts that have connections, and we should add a separate canAttach method to check if a new one is allowed.\nThis is also related to #90 \n. @p0wl ok, just comment out the phantomjs dependency on package.json and the Gruntfile.coffee\n. We should note that this includes other subtle path issues, like #122 \n. Doesn't seem to be a problem any longer. I just verified by running tests of a rather large NoFlo app on Node.js/Win8\n. @Bartvds thanks! Added\n. Seems path resolution is fine: these tests actually run a graph that depends on components from other libraries\n. I'm sort of reluctant to do type conversions on NoFlo level, as that would still be potentially error-prone, as you could be sending the number to an all port first and then forwarding it to a number port, in which case conversions wouldn't happen.\nIn JSON graph format you can keep IIPs in correct type, so the main issue appears to be with the FBP parser. I've created a ticket for this at noflo/fbp#10. Please close this one if you agree that that would be the right place to fix this ;-)\n. Subgraphs run in their own NoFlo Network instance, which is connected to the parent graph by exposing the exported ports (if any) or the free ports of the subgraphs as the ports of the 'subgraph component'.\nHowever, there is only one NoFlo network instance for an instance of a subgraph, not one per packet. So there may be multiple packets simultaneously being processed by the subgraph.\nYou can see the behavior in more detail by looking at the Graph component source code, which is how NoFlo provides subgraph support:\nhttps://github.com/noflo/noflo/blob/master/src/components/Graph.coffee\n. @fb55 usually the way to handle this is via \"bracket IPs\" (groups in NoFlo terms). webserver/Server adds a unique ID for each request/response pair when it sends them out.\nA little bit of background: http://www.jpaulmorrison.com/fbp/tree.shtml\n. @fb55 groups are a special type of a packet that do not affect the datatype of ports. So, a number port will also receive any begingroup/endgroup events and can pass them on.\n. There is some relation also with this and #98 \n. @jonnor that doesn't sound too bad. However, this would have to be carried also to the FBP parser, as currently there we only recognize this syntax:\nfbp\nEXPORT=SPLIT.IN:IN\nWe could think of supporting the same syntax, but with keys INPORT and OUTPORT instead of EXPORT. But the old syntax also has to remain, since there are tons of graphs out there using it.\n. We could use the metadata property of graph exports for expressing directionality when needed. The bigger issue is that we need this supported in noflo/fbp\n. @forresto I'm fine with separating private node and port, in which case only port name needs to be lowercased. Do you want to work on that?\nNote however that we need to keep backwards compatibility in a way that old FBP and JSON files still work. Easiest would probably be to check for the old . syntax at loadJSON and convert when needed.\n. For easier backwards compatibility we should keep the old-style \"mixed\" exports in the exports array, and then have separate outports and inports arrays for the new ones. We can even make the Graph component reassign the mixed ones when it finds them, as that is the first place where we can really know the direction.\n. While we're fiddling with this, I think inports and outports should be objects keyed by the published port, since there can be only one port with a given name anyway.\n. @jpaulm character support isn't directly connected with this issue, but anyway...\nNoFlo itself doesn't care how the nodes and ports are named, except for the fact that we do normalization via toLowerCase().\nThe character limitations are mostly coming from the FBP parser where ports are recognized with the regular expression [A-Z0-9_]+.\nThis limits ports to alphanumeric and uppercase only (on FBP language level, not in NoFlo core). This is bigger limitation than regular JavaScript identifiers which allow unicode characters.\nHowever, as we've discussed before, I'd rather have people target an international community where  ASCII characters are pretty much the standard everybody is able to read and write. If we start allowing anything from UTF-8, we risk ending up in a situation where a Chinese programmer can't contribute to a Finnish FBP program and vice versa. I'd rather not fragment the FBP community in that way, at least yet.\n. @forresto @jpaulm can we get another issue for the i18n question? :-)\n. I'm sort of biased towards CoffeeScript, but indeed reimplementing NoFlo core in pure JS wouldn't be a big task. The bigger issue would be the hundreds of components out there.\nThe way to go forward here for those who favor a pure JavaScript solution would be to:\n1. Ensure that we have a component API that is super-friendly for JavaScript development (see #97)\n2. Gently guide users to creating new components in JavaScript by having that well supported in NoFlo UI's component editor (see noflo/noflo-ui#8)\nI'm closing this ticket now, as before these two targets are met there is not much we can (or should) do to decide which language to prefer. Thanks everybody for the comments and viewpoints!\n. As part of this we should make a noflo.Ports class that components can use. The difference with the traditional \"plain ports object\" would be that the Ports object would have events notifying when ports change.\nSo, the old way (which would still also work):\ncoffeescript\nconstructor: ->\n  @inPorts =\n    in: new noflo.Port 'string'\nNew way would be something like:\ncoffeescript\nconstructor: ->\n  @inPorts = new noflo.Ports\n    in: new noflo.Port 'string'\nAnd then you could do:\ncoffeescript\ninstance.inPorts.on 'changed', =>\n  # We have changes to the available ports\nWith this, NoFlo Networks could defer connections to unavailable ports until the given port is available.\n. This is also related to #118 if we go changing EXPORTS definition\n. Fixed now.\nWe have in graphs:\njson\n{\n  \"inports\": {\n    \"layouts\": {\n      \"process\": \"Build\",\n      \"port\": \"layouts\"\n    }\n}\nand similarly an outports key. We also have INPORT and OUTPORT declarations in FBP.\n. Moved to noflo/fbp#12\n. @forresto if we want to have nodes belonging only to a single group, we can constrain that on UI level. Typically with groups you want to be able to have a many-to-many relationship, so that is what we have on JSON level\n. Here is the original groups format ticket: #62 \n. I'd start with what we have now, and consider changes only if necessary\n. @forresto I'd try to avoid tree structures as long as possible\n. You can actually register components dynamically if you use the delayed initialization parameter of createNetwork.\nHere is an example (though using subgraphs instead of components):\nhttps://github.com/noflo/noflo-ui/blob/the-graph/app/noflo.js\nThe basic steps are:\n- Load your custom components\n- Create a network with delayed initialization (give true as the third param of createNetwork)\n- Register your custom components using network.loader.registerComponent\n- Connect the network\n- Start the network\n. This needs a compatibility fallback, i.e. setting index based on order edges are specified when loading the JSON specification if no index is provided there.\n. This is also connected with the UI-side of things: noflo/noflo-ui#14\n. I think this won't be safe to do with the old-style ArrayPort, but should work with the new isAddressable() ports from #136 \n. @alfa256 I just added array port index support into the FBP parser:\nfbp\nSomeNode OUT -> IN[2] OtherNode\n. @forresto ok, initial support is now in. Would you like to experiment with how that would connect with the UI?\n. Isn't this pretty much covered by the FBP network protocol? http://noflojs.org/documentation/protocol/#network\n. We're currently looking at rebasing the browser build of NoFlo on Browserify which would make the Node.js stream API available on both platforms.\n. Theoretically we should use 'node' for nodes when talking about graphs, and 'process' for nodes when talking about networks.\n. Still missing metadata methods & events:\n- Group metadata\n- Exported port metadata\n- Graph properties\n. Should be reasonably easy to do using WebRTC datachannels. See https://github.com/noflo/noflo-runtime-websocket for an example of a transport provider.\n. This is now in.\n. @forresto yeah, we could have a schema type string for DOM elements, and possibly also for the specific tag.\nRemember than RDF schemas are a decentralized system where anybody can provide their own type definitions (ontologies) in their own URL space. Schema.org is just a common example since that is the list of types search engines support for rich snippets.\nWe're free to define our own schemas for common things like \"HTML element\" or \"JavaScript error\".\nThis would also allow people to provide converter components between different schemas.\n. @forresto we don't. But the runtime protocol also has to be amended to provide the values data for ports.\nBut go ahead, ticket would be good.\n. We will do the full #97 instead.\n. @RangerMauve it is perfectly fine to make components in pure JS. Here is one example: https://github.com/burkostya/noflo-lemox/blob/master/components/Select.js\nOur new component API in #97 seeks to make pure-JS components even easier to write\n. Handled by #189 via an option.\n. @jonnor can you look at this?\n. Moved to flowbased/fbp-graph#3 since Journal is now outside of NoFlo repo.. Those events were left out on purpose, since output ports should be write-only, and input ports read-only\n. @djdeath yeah, they shouldn't listen to their outPorts, only inPorts.\n. OK, runtime support is now there. Needs implementation in noflo/noflo-ui#199\n. Using the new ports API you can mark outports optional with required: false. Then there won't be an error if it isn't attached and you try to write\n. The UI should be made to utilise this information and \"validate\" the graph before running. We could have some visual indicator on non-connected required ports\n. Right now the assumption is that a port exists for a reason :-) \n. Note that required boolean is provided for all ports in Component Protocol\n. @kenhkan I was thinking no runtime in the compiled version, rather a \"hardcoded\" network a bit like you might do when writing a unit test.\n. @kenhkan I think API is now stable enough, but having time for this depends on some other things I need to get done. But we have some front-end projects where this would be extremely useful.\n. @kenhkan if you have ideas for this, that'd be great! I only have some sketches in my head\n. @jpaulm it should be noted that every browser-side NoFlo flow already runs on the user's machine -- the browser downloads NoFlo and the other associated JavaScript code, parses, and executes it. When you're running the Flowhub UI you're actually executing a NoFlo graph on your own machine, since the UI itself is built with NoFlo.\nWith server-side (Node.js) NoFlo graphs you can also execute the graphs on your local computer (which is usual for development), or on some remote server on the internet. The browser-side Flowhub UI can't however execute system software on the local computer due to browser sandboxing limitations. To bridge the system software world, and the browser-based UI we built the FBP protocol where the browser can interact with server-side FBP environments via a simple messaging protocol.\nThe additional benefit of the FBP protocol is that this opens the Flowhub UI to be usable with any other FBP environment that can talk the protocol. For example, we already have non-JavaScript environments like MicroFlo and ImgFlo that the UI can interact with very similarly to how it interacts with NoFlo on Node.js. And in this case there is no NoFlo in the loop.\n@kenhkan currently deploying NoFlo graphs on either Node.js or browser includes several steps:\n1. Loading NoFlo and its component libraries via a CommonJS module container (Node.js provides one out-of-the-box, and on browser we use Component.io)\n2. Loading a graph (and possible subgraphs) into NoFlo Graph instances. This may involve first parsing the graph information from the FBP syntax\n3. Passing the main graph to a NoFlo Network\n4. Instantiating NoFlo components for the Graph nodes\n5. Connecting the ports of the nodes as specified in the graph\n6. Starting the NoFlo network by sending the IIPs\nYou can see this in action for example in noflo-ui\nThe purpose of this ticket is not to create any new capabilities -- we can already ship NoFlo-based JavaScript applications to the client. Instead, it is to enable slimming them down to the barest of essentials. Since a browser has to download and parse all the code used in an application, making the file size as small as possible matters. So, essentially this ticket is about an optimization step relevant only for client-side NoFlo software.\nFor this purpose we should do at least the following:\n- Remove all components from the CommonJS build that are not in use in the graphs\n- Remove all third-party libraries from the CommonJS build that are not use in the graphs\n- Remove the NoFlo runtime (Graph, Network, etc), and slim NoFlo itself down to only to the parts that components use (ports, component baseclasses, internal sockets)\n- Flatten the graph and its subgraphs to a single structure (so that we don't need the NoFlo runtime)\n- Hard-wire all connections and IIPs similarly to how we often do this in unit tests\nThis way instead of a set of a graphs and a network initialization code, we'd end up with a JavaScript file that does all of that \"manually\".\nThese should happen as a build step where we \"strip\" a NoFlo program to the essentials that are needed to run this. On a quick estimate this should slim the file size down to about 10-20% of what it is when we ship all the bells and whistles.\n. I'm looking at Component's new builder2.js as an option for making this possible.\nHowever, some issues with this:\n- We will have to change all requires that use a .js suffix for a .coffee file (mainly in unit tests) to use .coffee\n- The new component downloader requires GitHub authentication for any more active use which presents a significant usability problem\n- They do normalization of require() statements inside the source code, which causes problems with string replacements in our setSource method (see component/builder2.js#33)\n- Out of the box the file size is only maybe 5% smaller\n- Removing or replacing files has to happen quite early in the builder2 run, which can be tricky\n- Conditional requires (like Node.js vs. browser requiring different files) can break the build component/builder2.js#56\nOn the positive side, with builder2 we will be able to boil the NoFlo browser build process down to:\ncoffeescript\nnoflo_browser:\n  build:\n    files:\n      'target.js': ['component.json']\n. @aaronz8 yep, our problem is the other way around. Our old build renamed everything to .js and so that is what a lot of places now expect\n. @aaronz8 what would help us immensely would be if plugins would be allowed to rename or add/remove files in builder2.js. Somewhat related to component/builder2.js#45\n. Here is a Grunt plugin based on current stable Component.io version. This removes the need for the big number of different plugins for the browser build:\nhttps://github.com/noflo/grunt-noflo-browser\nAlso, it fetches HTML contents from graphs and generates runnable demo HTML files for each. Example: https://github.com/noflo/grunt-noflo-browser/blob/master/test/expected/Clock.html\nWhat is still missing is \"minimizing\" the build by removing any files we don't want to have there.\n. There is some highly experimental work on a optimized building using Browserify. Depending on the number of library dependencies this can cut some 60-80% of the NoFlo JavaScript file size compared to the traditional browser builds.\n. @ab34 additionally there is noflo-iot by @djdeath that can build a single Node.js executable file of a NoFlo project. This is mainly meant for situations with slow I/O\n. This can now be done either directly with webpack, or by using grunt-noflo-browser and specifying the graph option to scope the bundle only to the dependencies of a particular graph.\nExample: https://github.com/noflo/grunt-noflo-browser/blob/master/Gruntfile.js#L40\n. @KevinHoward maybe you could update Travis to test with current stable Node.js (0.10)? We've stopped testing NoFlo with 0.8\nSee the .travis.yml file\n. @trustmaster I think this would be a UUID generated when a NoFlo Network is instantiated that would get emitted with all the network events. This would also be useful for noflo/noflo-ui#145\nEvent emitting, see: https://github.com/noflo/noflo/blob/master/src/lib/Network.coffee#L315 and https://github.com/noflo/noflo/blob/master/src/lib/Network.coffee#L80\n. @trustmaster we could use that for the default value when running networks via the protocol\n. This will be provided via the scope feature in #356\n. Scopes are in released NoFlo, so for correlation IDs one just needs to send the initial packets (from outside, from a generator) with a scope set.\n. @jonnor can you list the messages lacking a response, and propose responses that would be useful in those?\n. Moved to flowbased/fbp-protocol#9\n. At least 80% of NoFlo components boil down to four variations:\n- Components that operate on a single inport and single outport, with possible additional config ports\n  - Synchronous variant\n  - Async variant\n- Components that operate on multiple inports and a single outport, with possible additional config ports\n  - Synchronous variant\n  - Async variant\nWe should make writing these much easier than it is now by providing helpers for these scenarios instead of component baseclasses like AsyncComponent.\nThe first one was added in b9584c6a4d92cc0aff513adab9a212e50a753142 to make the synchronous single inport -> single outport scenario easy. With this you can do:\ncoffeescript\nc = new noflo.Component\n  inPorts:\n    in:\n      datatype: 'number'\n  outPorts:\n    out:\n      datatype: 'number'\nnoflo.helpers.MapComponent c, (data, groups, out) ->\n  out.send data * 2\nThis will handle all group and disconnection stuff for you.\nNext up: async variant and the ones where we combine multiple inputs.\n. In NoFlo UI we could do some visual things around these traits... for example, ports that require input in each before an operation starts could be grouped together:\n\nThen we could maybe show the activation model of a port by shape. For example, round for packet, diamond for disconnect:\n\n. If the activation and data handling models are clear enough, maybe we can even show a component's  \"circuit diagram\" when you zoom in?\n\n\nI think @forresto can probably do something cool with this if we give him enough data :-)\n. @djdeath yeah, I was thinking about that as well, maybe via config.\n. @trustmaster we want people to migrate to the new Port API as soon as possible anyway. For the minimized browser build that helps shaving unnecessary code away, and allows for neat things in the UI.\n. @trustmaster I think 0.6 would be too soon, but maybe we'll start logging warnings on the old API at that point.\n. @trustmaster thanks, added to CHANGES.md\n. @trustmaster sounds good. We were talking about the naming too. Would GroupedInput work for you?\nAnother thing that would be handy would be the ability to reject a job if the component isn't ready for it yet, for example because it is waiting to get some state initialised. In this case the job should go back to buffer\n. @trustmaster some options on reactivation on a quick thought:\n1. helpers.GroupedInput could return an activation callback, since activation is likely to happen outside of it\n2. the rejection callback could return an activation callback\n. The GroupedInput helper is now in the NoFlo 0.5.3 release. For other helpers and postpone/resume we should do more specific tickets\n. @Anticom we actually have enough type information coming in from the component messages via the runtime protocol.\nCurrently mostly the base datatype information is usable (i.e. object, boolean), but see also the higher-level types from noflo/noflo#136 that are based on RDF and MIME types.\nThe older NoFlo UI had this feature where we would filter out incompatible ports when connecting:\n\nHere was the implementation: https://github.com/meemoo/dataflow/blob/6d36d8b8d9183243a43e64f017795953f68c6d69/src/modules/graph-view.js#L346\n@forresto we should indeed bring this feature back. \n. As an addition, the UI should still make it possible to connect \"incompatible\" ports if the user really wants to do so. But it should emphasize compatible ones.\n. Moved to the-grid/the-graph#143\n. @Anticom thanks! You might also be interested in the long discussion on port types in #84 \n. @Anticom the compatible ports now grow in size when you're creating a connection\n\n\n. @trustmaster Node.js or browser, which graph? What version did you upgrade from?\n. Check via npm list if some component library you're using pulled in a pre-0.5 NoFlo. I tried with NoFlo Jekyll and there at least everything worked\n. @trustmaster which libraries? We should prioritise updating them\n. @forresto interesting that this pops up now, given that the stricter type checking has been in place since 0.5 and only affects the new port API\n. The new manifest format in https://github.com/flowbased/fbp-manifest allows providing a separate source path from \"executable path\". We could make the browser builds point these to a URL.\nOr maybe use sourcemaps?\n. Moved to noflo/grunt-noflo-browser#19. Moved to flowbased/fbp-protocol#8\n. This would break a lot of things in NoFlo, including ending of groups and components that transmit multiple packets per transmission.\nInstead, we should focus on helpers as defined in #166 \n. For now, please use https://github.com/noflo/grunt-noflo-browser\n. Keeping this issue open as it relates to switching from component.io to NPM+WebPack\n. As of grunt-noflo-browser 1.0.0-alpha4 we can now build noflo, typical module packages, and noflo-ui with webpack. Closing this issue.\n. @trustmaster preferably we'd get CoffeeScript 1.7 everywhere.\n. OK, now we have updated deps, and it looks like gruntjs/grunt#911 is the last place with older CoffeeScript.\n. @trustmaster it might be cool to provide similar support per-connection with addressable ports (ArrayPorts), so merging by group coming via IN[0], IN[1], etc.\n. @trustmaster can you check that Windows build failure? And preferably also update the CHANGES file\n. @trustmaster I'm wondering if these settings of GroupedInput should be made global and configurable on network level. This would enable us to provide a \"classical FBP\" mode in NoFlo where:\n- Packets would be ordered\n- Execution model would be changed to breadth-first instead of depth-first, with a slight performance penalty\n. @trustmaster you might want to update #130 regarding streams\n. @trustmaster you can include JSON files via the json key in component.json (note that they also have to appear in scripts to get downloaded)\n. @trustmaster agreed. There should be the preferred (and documented) way of doing these using the modern port API and traits, and then compatibility wrappers in NoFlo that have the old API but utilize traits internally.\nUp for debate is whether using the deprecated baseclasses should log warnings.\n. @cwohlman +1 I've been thinking about this as well. Shouldn't be hard to do, just standardise the graph properties to use and make NoFlo graph component aware of them\n. @cwohlman yeah, I think we don't actually transmit graph properties over the protocol. Should be fixable.\n. Moved to flowbased/fbp-protocol#10\n. the exports key is kept around in JSON loading purely for backwards compatibility reasons. All modern implementations should use the new inports and outports keys.\nWhen you load a legacy graph into a NoFlo network, the exports are turned to the new format by the Network.\n. However, note #202 \n. OK, we've settled on Process API (#392) now.\n. Should be fixed with #535, please reopen if necessary. @hayesmg can you reapply this patch on top of latest master?\n. @trustmaster the former. After shutdown components should be reset to be as close to freshly instantiated as possible\n. @hayesmg can you rebase this patch on latest master?\n. @dremekie I just tried your graph and runner code (adapting them to my local filesystem path, and error callbacks), and I get:\n\u21d2  node run.js             \ntest.txt\nnetwork end!\nThe versions used are:\n\"noflo\": \"^0.8.3\",\n    \"noflo-core\": \"^0.4.0\",\n    \"noflo-filesystem\": \"^1.1.1\"\nSo from that, it seems this has been fixed in NoFlo 0.8. @hayesmg thanks for the report! Would you be able to write a test that reproduces this?\n. It looks like with #231 the output changes to be:\n<group1>\n<group2>\ndata\n</group2>\n</group1>\n<group1>\n<group2>\ndata\n</group2>\n</group1>\n<group1>\n<group2>\ndata\n</group2>\n</group1>\nDISC\nThis is better than it was, but the in-between end/begingroups shouldn't be necessary since the groups are not changing between the data entries.\nEven though the group identifiers remain similar, it still loses the context that the three data entries belong to the same group\n. As an additional clarification, I have a flow like:\nAsyncProcess OUT -> IN SyncProcess OUT -> IN PacketsToArray\nAsyncProcess is an async WirePattern that receives some grouped inputs, does multiple sends, and finally calls the callback function. SyncProcess is a sync WirePattern that manipulates each packet slightly. And then in the end we want to collect all packets from the same execution of the AsyncProcess into an array using PacketsToArray\n. Fixed\n. @trustmaster @hayesmg I think we need to revert this logic.\n- By default, subgraphs should be auto-started\n- If there is a start port attached, then they are not auto-started and should be started when they receive a bang to the start port\n. @paulyoung basically this means that loadFile can either take two or three arguments, but the last one always has to be the callback function.\n. @paulyoung yep, ArrayPort is the old port API and addressable is the new, post-0.5 port API. It is still an \"array port\" in FBP terminology, though\n. As a clarification, the foo example above should wait for all connected inputs only it it is an addressable param port. Input ports should cause processing on any packet, but pass the index to the processing function\n. Requires travis-ci/travis-ci#249 so probably not happening anytime soon.\n. @forresto we probably could, but this would require writing a lot of machinery\n. @paulyoung but this would have the disadvantage that we would need a lot more file I/O to find out about the components, instead of just using read-installed.\n. @paulyoung ah, I see. That does actually make sense. And the presence of a fbp.json file would make it easier for applications like Flowhub to recognize which of your repositories are FBP projects.\nRelated:\n- noflo/noflo-ui#132\n- noflo/noflo-ui#136\n. Another benefit of fbp.json would be that it would make it a lot easier to have cross-platform projects. For example, a project that needs to ship .coffee files to NoFlo and some .hpp files for MicroFlo.\n. @oleksandr I could see some Java environments also being able to provide the FBP protocol getsource (and maybe even setsource) functionality. The source file is useful for that. For compiled-only it probably shouldn't be necessary\n. @oleksandr the JSON format is not really meant to be written by humans, but instead by tools like Flowhub and DrawFBP.\nNow that Flowhub starts to be in a good shape I'm mostly only writing FBP when building Flowhub itself, everything else I do visually.\n. I finally started setting this up. First part is agreeing on the schema format. Initial proposal at https://github.com/flowbased/fbp-manifest/tree/master/schemata\n(JSON schema formatted as YAML for more human-friendly editing)\n. Here's an example of a fbp.json file generated with the tool: https://gist.github.com/bergie/159b7df7139af48018ea\nThis one is interesting since the noflo-image module has three types of NoFlo components:\n- Components that work in both browser and Node.js (runtime noflo)\n- Components that work only in Node.js (runtime noflo-nodejs)\n- Components that work only in Node.js (runtime noflo-browser)\nThis dump didn't go through the NoFlo componentloader, so it hasn't been enriched with the port information.\n. Closing this ticket in favor of continuing the discussion over at https://github.com/flowbased/fbp-manifest\n. This is because of the auto-release process we have:\n- You tag a commit\n- Travis tests it\n- Travis updates manifests and publishes\n. Fixed via the Process API port of WirePattern #526. Moved to https://github.com/flowbased/fbp-graph/issues/2. @forresto @trustmaster in a running network there is a .fbp-esque identifier for edges:\nhttps://github.com/noflo/noflo/blob/master/src/lib/InternalSocket.coffee#L126\n. Should be moved to fbp-graph project. @sjaakiejj port names are lowercase in NoFlo. We should probably throw an error if trying to define mixed-case port names?\n. @sjaakiejj BTW, note that underscores are allowed. So you can use customer_id if you want\n. This is now in noflo-nodejs. The noflo command will be going away in the next major release.\n. This should be fixed now.\n. I think this requires some standardization discussion first. Can you or @trustmaster write a description of it to either the FBP mailing list or flowbased issue tracker\n. See definition of ArrayPorts there: https://github.com/flowbased/flowbased.org/wiki/Advanced%20Features#array-ports\n. Closing in favor of tracking at flowbased/flowbased.org#20 since this is a question that should be handled on the cross-runtime standardization level\n. Probably less of an issue when using --cache? But anyway, looks like read-installed is now at 4.0\n. We're now using fbp-manifest which does read packages concurrently\n. We have Process API now, and hence it doesn't really make sense to add features to WirePattern.. We're also seeing duplicated groups on error callback of async components: https://travis-ci.org/noflo/noflo-rss/builds/134564008#L266\ncc/ @jonnor \n. This no longer happens with the Process API implementation from #526. @robhawkes on a quick look you should only need to add asyncly/eventemitter2 to component.json to get it installed for the browser build.\nIf you need to do some special-casing between Node.js and browser, look at noflo.isBrowser()\n. Since then we've moved browser builds to WebPack, and use the EventEmitter library from there. Closing since there has been no further information. This sounds very interesting for environments like https://github.com/c-base/ingress-table where the start-up time is long due to slow IO and slow processor.\nAnother approach is building a single file out of the NoFlo Node.js project, as is done in https://github.com/djdeath/noflo-iot\n. @ensonic sounds great! I think enabling/disabling cache could be a command-line option for noflo and noflo-nodejs commands\n. I've added coffee-cache support to noflo-nodejs. NoFlo 0.5.12 also has a component registry cache.\nhttps://github.com/noflo/noflo-nodejs/commit/3c092b4c4063fa47fe5db38cfea9821c8830f339\n. Merged the fix in #274\n. Should be fixed via #526. Bracket forwarding should be a lot more robust now that we're using Process API internally in WirePattern (#526). Good point. I think in general we should retire that interface and instead focus on providing NoFlo to browsers via component.io (already works well) and NPM/browserify\n. Duplicate of #175\n. This should no longer be the case in 0.6 (current master). noflo.graph.loadFile program.graph, (err, graph) ->\n. - fbp-protocol-client: JavaScript client library for connecting to various FBP runtimes (NoFlo, MicroFlo, JavaFBP, etc)\n- noflo-runtime-base: transport-agnostic library for exposing NoFlo as a FBP runtime (with transports at -websocket, -iframe, -webrtc)\n- noflo-runtime: set of NoFlo components for working with FBP runtimes, used mainly by NoFlo UI\n- noflo: the actual NoFlo library/runtime\n. BTW, questions like this would be awesome to have on Stack Overflow NoFlo tag\n. Duplicate of #175\n. Here is an example: https://github.com/noflo/noflo-tika/blob/master/components/ToHtml.coffee\n. :+1: from me, given that we sort out the backwards compatibility question. This switch may best be coupled with redesign of the component API to move firing patterns out of helpers and into component API itself.\nThis way old-style components would use the old (and deprecated) API, and still get the events and data they expect, and components could be written (and ported) to new API as we go.\n. I suppose they can. connect and disconnect are essentially the outermost brackets anyway\n. We should also have a tool for recognizing components using the legacy API. Would help tracking down stuff that needs to be ported\n. ``` javascript\nvar noflo = require('noflo');\nexports.getComponent = function () {\n  var c = new noflo.Component();\n  c.description = 'This component does async stuff';\n  c.inPorts.add('in', { datatype: 'object' });\n  c.outPorts.add('out', { datatype: 'object' });\n  c.outPorts.add('error', { datatype: 'object' });\nnoflo.helpers.WirePattern(c, {\n    in: 'in',\n    out: 'out',\n    async: true,\n    forwardGroups: true\n  }, function (data, groups, out, callback) {\n    someAsyncFunction(data, function (err, result) {\n      if (err) {\n        return callback(err);\n      }\n      out.send(result);\n      callback();\n    });\n  });\nreturn c;\n};\n``\n. With regular outports, you can justsendto all connections at once. With addressable ports you need to provide a connection index\n.out.send(data, 0);seems correct. Interesting, that error should only happen if the providedsocketIdisNULL. OK, I tested that this works with regular ports, so seems this is a WirePattern issue. Ping @trustmaster \n. WirePattern is now using Process API internally, so this should be fixed.. Thanks! See also noflo/noflo-ui#300\n. @jpka would you like to adapt the Node.js component loader also? https://github.com/noflo/noflo/blob/master/src/lib/nodejs/ComponentLoader.coffee#L200\n. Thanks!\n. @jonnor @trustmaster any qualms about merging and releasing this?\n. @trustmaster this at least makes the errors localized and easier to deal with than before for cases like Stripe. You can just donetwork.on('process-error')or even attach to theerror` event of an individual edge.\nAs for disabling it, run network.setDebug(false).\n. The big issue this is solving is that errors thrown downstream would in the old setup percolate up the callback chain until they hit the first async component. And if that async component was a WirePattern with forwardGroups, it would fail to end the groups the job was in, causing subsequent jobs to be grouped wrongly.\n. So scope could be also used for flow isolation with https://github.com/noflo/noflo-runtime-msgflo ?\n. The checklist items can be handled as separate issues. However, would be nice to have something about IP objects in the CHANGES file\n. The basics of this are now in place with https://github.com/flowbased/fbp-manifest\nNeeds to be integrated into the component loader\n. Seems like there isn't much we can do:\n\nThis feature is non-standard and is not on a standards track.\n\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack. Needs to address #221 and #261\n. Also see #385\n. So, basics:\n- There should be only a single start event emitted by the network per execution\n- There should be only a single end event emitted by the network per execution\n- Between the start and end events the network is considered to be \"running\"\n- Execution starts by calling network.start()\n- Execution ends either by calling network.stop() or when all components have finished processing\n- No packets may be transmitted, and components may not do any work while network is not running\nInformation we have currently available:\n- Socket status (connected, disconnected, packet count in buffer)\n- Component processing functions (return state/callback): c.process, WirePattern callback, AsyncComponent.doAsync\n- We have components that use one of the above, and also components that use the \"pure\" port API\n. @trustmaster regarding generator components, won't they work exactly the same way as \"regular\" components in this sense? They're anyway activated by an inbound packet (for example, a \"bang\") and so can use the process function. HTTP server as a \"generator\" example:\n``` coffeescript\nc = new noflo.Component\nc.inPorts.add 'start',\n  datatype: 'int'\nc.inPorts.add 'stop',\n  datatype: 'int'\nc.outPorts.add 'request',\n  datatype: 'object'\nc.servers = {}\nc.process (input, output) ->\n  if input.has 'start'\n    # We start the server when we receive a port to listen for\n    port = input.get 'start'\n    return unless port.type is 'data'\n    return output.sendDone new Error \"Already listening to #{port.data}\" if c.servers[port.data]\n    c.servers[port.data] = http.createServer (req, res) ->\n      # New requests are sent out with send but without calling done\n      output.send\n        request: req\n    c.servers[port.data].listen port.data, (err) ->\n      if err\n        c.servers[port.data] = null\n        output.sendDone err\n        return\n    c.servers[port.data].on 'close', ->\n      c.servers[port.data] = null\n      # Done for this processing function is called only when the server closes\n      output.done()\nif input.has 'stop'\n    port = input.get 'stop'\n    return unless port.type is 'data'\n    return output.sendDone new Error \"Not listening to #{port.data}\" unless c.servers[port.data]\n    c.servers[port.data].close (err) ->\n      return output.sendDone err if err\n      output.done()\n``\n. @trustmaster I think a generator should be considered \"active\" when it is listening to some external stuff, and \"deactivated\" when it stops listening. Doesn't really matter whether we're talking about a network service, a stream reader, or evensetInterval`.\nIf we don't want to keep the processing closure open during that time, we could of course do something like:\ncoffeescript\noutput.done keepActive: true\nand then later when stopping the listening do a c.emit 'deactivated'\n. Here's a quick-and-dirty diagram of how the network states change:\n\n. @jonnor manually :-)\n. Regarding component state, here's what the Dataflow book says:\n\nA node can be in one of a few states:\n- Not yet initiated: The initial state of all nodes\n- Terminated: Signifies that nodes will never be activated again\n- Active: The node is currently activated. This may be further subdivided into active-normal and active-suspended (active but waiting on an external event)\n- Inactive: The node is not activated but it is not terminated\n\nOne could treat the Network state as a composite of the state of its nodes.\n. Regarding generators, here is a simple one that can be used as an example about the lifecycle notifications:\nhttps://github.com/noflo/noflo-core/blob/97c365ad7c0b1e5211d4f93a1ca792df9e6db92b/components/RunInterval.coffee\n. @trustmaster is this fine now that #455 is merged?. @jonnor it is, yes. So I think mainly needs documentation.\n. Available as CLI tool and JS lib in fbp-manifest, as well as in grunt-noflo-lint.\n. I think reasonably soon. @trustmaster is working on some things we still want to include related to #373\n. Note: this should be safe to backport to NoFlo 0.5 if we want\n. c.error is easy to use, but the problem is that it carries a risk of not knowing the right context for the error. This has been especially problematic with MsgFlo where knowing the message scope for ACK/NACK purposes is critical. So, we would need to ensure c.error is aware of both brackets and scope.\n. @jonnor kinda makes sense, and sounds like would also make it easier to wrap existing Node.js libraries into NoFlo\n. @jonnor agreed, ordering should not be necessary if we still maintain bracket and scope correctly, as you can always put things back together downstream as needed.\n. @coderany have you npm installed the dependencies? What does ./node_modules/.bin/noflo list . say?\n. @coderany two options: noflo-nodejs and then Flowhub live mode, or sync the project to Flowhub from GitHub. I'm closing this issue here since this is more about noflo-ui.\n. @aretecode can you remove the \"version bump\" part? We're going 0.6.x now.\n. @jonnor @trustmaster ready for review\n. @jonnor this doesn't affect browser builds so far. That is a separate project involving the migration away from component.io. Hence, for browser components the discovery works as it has.\nFor Node.js modules, adding components to package.json is no longer necessary, though package.json can still be used for registering a default icon, and for custom component loaders.\n. and now we're green also on Windows!\n. @jonnor this plus #409 would warrant going 0.7.0, agreed. However, the main difference with old behavior is that we don't need the grunt-noflo-manifest step for Node.js, since fbp-manifest discovery provides that functionality.\nComponent libraries can provide their own fbp.json files, and down the line this will be a perf boost. However, they don't have to.\n. @jonnor I'd rather deprecate the grunt-noflo-manifest tool as soon as we've gotten rid of component.io. But generating an fbp.json is the other option. We can also do it with noflo-cache-preheat\n. @jonnor well, that is anyway beside the point of this PR :-)\n. @jonnor this PR should not break a single NoFlo module. Projects/modules can ship with an fbp.json file, but that is not required since fbp-manifest can still discover components the \"old-school\" way.\n. @jonnor the fbp-manifest noflo runtime support has a similar discovery mechanism as what grunt-noflo-manifest uses.\n. @jonnor ComponentLoader runs fbp-manifest's list helper if cache is not found.\n. Here's an example of the same test passing on Windows: https://ci.appveyor.com/project/bergie/noflo/build/1.0.547#L1238\n. @jonnor ready for review\n. @jonnor listComponents errors are not caused by faulty components. Faulty components were already covered in the error handling improvements that landed in 0.6.\nInstead, this is errors related to the project setup, like a corrupted fbp.json file.\n. @automata yes, good idea!\n. It should be noted that porting components to Process API is pretty important, as this will ensure more consistent behavior (especially for pre-WirePattern components). It will also open the door for #373\n. Since switching to Process API often implies changes to group handling, we may want to resolve #419 before we do that porting all around.\nAnd in any case, it is advisable to do the modernization in two rounds:\n- First do the other modernization tasks and make a new release (example: noflo/noflo-yaml#33)\n- Then port to Process API and make a release with a major version bump (example: noflo/noflo-yaml#34)\n. Modules should have reasonably relaxed version dependency on noflo. Recommended: 0.x >= 0.5.\nIf using noflo-nodejs (for example for fbp-spec) use the same range.\nModules using Process API should replace the 0.5 with a 0.7.\n. This is pretty much done now. Next round is going to be Process API. @trustmaster @jonnor should be ready to review\n. Can you update changes file?\n. ah, yes. this was the reason I added the error to the callback, but I didn't remember to plug it in\n. This is roughly equivalent to WirePattern's forwardGroups: true, and is useful for map-style components where the original brackets are useful to forward.\nHere was a quick-and-dirty stab at implementing this on the component side: https://github.com/noflo/noflo-yaml/blob/9a53edd6c43fb5522d399ec6739035cabb478ecf/components/ParseYaml.coffee\n. Example where bracket forwarding is useful:\nfbp\nSplitArray OUT -> IN SomeOperation OUT -> IN PacketsToArray\nThis is roughly equivalent to a Promisified version:\ncoffeescript\nPromise.map someArray, someOperation\n.then (result) ->\n. A map-style component is something that generally:\n- has a single input port (and maybe some control ports)\n- has a single output port (and maybe error)\n- sends a packet per each received packet\nI would guess that majority of NoFlo components falls into this category.\n. Agreed that this should be an option. Something like:\nc.process\n  forwardBrackets: 'in'\n, (input, output) ->\n. @jonnor @trustmaster indeed, we should remove all \"brackets as metadata\" usage from components as we modernize (#410) them, and ensure it is only used for substream handling. But when it is used for substreams, it is pretty important to forward them, as otherwise many programs will have problems knowing when something is \"complete\".\nThe old \"metadata groups\" should be placed in IP.groups instead. Examples include filenames, URLs, and such.\n. Once this issue is resolved, we should document the new \"best practices\" around brackets and packet metadata, and update the \"modernization\" issue accordingly\n. One option is to do the following: We impose ordered mode when we receive an openBracket, until exiting bracket context.\nPackets A B < C D > can come out as A B < C D >, B A < C D >, or A < C D > B etc\nIf C and D get routed to different outports, we'll need to send brackets to both. So OUT would get A B < C > and ERROR would get < D >. So they still are \"substreams\" but the stream gets split to however many places packets from it get sent to.\nFor example if routers/SplitInSequence receives < A B C D > it would send to OUT[0] < A C > and to OUT[1] < B D >\n. The right way would be to make fbp-manifest's NoFlo loader aware of subdirectories. Can you report a corresponding issue there?\n. This should be fine now @trustmaster ?\nI think after #518 lands, I would consider starting to move at least the easier WirePattern cases to run Process API internally... Thanks!\n. The other option would be to utilize the index notation helper we already have, so you could do:\ncoffeescript\noutput.send 'out[2]', ip. In practice, sending with IP index has been fine. Closing.. cc/ @trustmaster\n. @trustmaster test added\n. Fixed via #449\n. Current workaround is to set c.autoOrdering = false in the Process API callback, but a better fix would be to automatically enable auto-ordering only if it is not set (so, NULL default)\n. @trustmaster we need to document this in the CHANGES file. Any suggestions on the wording?\n. I noticed that this causes problems when the error port is set to required: true, as it will always try sending empty groups and then throw an error because there are no connections to the port\nExample: https://travis-ci.org/noflo/noflo-core/builds/135647741#L580\n. Fixed via #451\n. @trustmaster can you rebase on master?. @trustmaster apart from the typo above, do you feel this is good to go?. @jonnor ready for review\n. @jonnor please review\n. @jonnor correct. And the test refractorings still work with Node which this PR doesn't change\n. #463 contains some red tests for this\n. @trustmaster you should find some interesting puzzles to solve here\n. Fixed in  #467\n. Some snippets from a discussion with @trustmaster yesterday:\nBergie:\n\nso basically:\ninput.get -> prepare preceding brackets for forwarding\noutput.send -> forward brackets first, then send data. Keep track of which port(s) we sent to. Each should get brackets forwarded\noutput.done -> forward all closing brackets that came after the data to all ports we forwarded brackets (and sent output) to\nso if the stream was\n<1 <2 A 2> B 1>\nwe'd send on first firing:\n<1 <2 A\nthen on first done:\n2>\nthen second firing:\nB\nsecond done:\n1>\n\nTrustmaster:\n\nright, nice, but doesn\u2019t cover the case when the input stream is closed after the 2nd done\n\nBergie:\n\ntrue. But if there is no in-flight process, we can probably just forward closeBrackets as-is\n\nTrustmaster:\n\nok, next: what if there are get() and done() but not send() to a forwarded port? drop all the brackets or wait until next activation which may utilize them?\n\nBergie:\n\n[drop, and] so in the example, if A didn't send, we'd have to keep <1 in stock for next firing\nbut not <2 2> since they were only related to A\n. Now another stab at this in #518, able to pass the curveballs from #463. Fixed via #455. Components now clear their inports on shutdown: https://github.com/noflo/noflo/pull/531/files#diff-2951f8a110c937286802e489b93bf9b2R95. I'm wondering also if we should deprecate async: false for easier #370 handling\n. Explained in http://bergie.iki.fi/blog/noflo-process-api/. Bracket forwarding has landed couple months ago, and was released in 0.8. However, not sure if this PR is needed anymore, getData already does the right thing. With #526 this should only happen when providing name for the WirePattern. Should be fine now. We also have a input.hasData convenience method. @trustmaster the problem here is that in noflo-ui we send packet objects through the graph, and they suspiciously resemble an IP object even though that is not the intent.\n\nSee noflo/noflo-runtime#88\n. @trustmaster here is the original outport.send command: https://github.com/noflo/noflo-runtime/blob/2afb74aacb345e6a2dcf55a90b6db44958e781b3/components/ListenNetwork.coffee#L43\nAs you can see the payload is an object that contains type: 'data'\n. BTW, it is possible to compile CoffeeScript to ES6 now as well: http://coffeescript.org/v2/\nRegarding TypeScript, I agree with @trustmaster and @jonnor that porting NoFlo is unlikely to bring big benefits right now. However, what might be interesting would be to add TypeScript declarations for the NoFlo API.\nThis way we wouldn't need to change NoFlo core, but TypeScript developers would still benefit from the types being declared and available.\n. The component get its node name via this.nodeId, which NoFlo Network sets after instantiation.. @jomeier here are the schemas for those:\n\nhttps://github.com/flowbased/fbp-protocol/blob/master/schema/yaml/network.yml#L245\nhttps://github.com/flowbased/fbp-protocol/blob/master/schema/yaml/runtime.yml#L35\n\nAnd yes, those can be used to see the live status. See for example Flowhub. Look at the setSource method on component loader.\n. This is more properly tracked in flowbased/fbp-protocol#25. More properly tracked in flowbased/fbp-protocol#26. Maybe related to #465 ?\n. We might want to move the graph schemas in the same place as well: https://github.com/flowbased/fbp/tree/master/schemata. Here we go: https://github.com/flowbased/fbp-graph. @jonnor yup, #519. @trustmaster would you like giving this a look?. @trustmaster added rough outline to description above. @jonnor while process API supports synchronous code, calling done is now required whenever your process function reads from the input buffers.\nWhile you're only checking preconditions (input.has and friends), you can just return.. @trustmaster when checking preconditions we don't activate. We only activate when you read from the buffers (input.get etc), after which you need to call done. The versioneye fail is probably because they didn't fetch the new library yet. NPM shows license correctly: https://www.npmjs.com/package/fbp-graph. There is a test in spec/ComponentLoader.coffee but it is for some reason commented out. Let me revive it. @jonnor added tests in 1d29626. @trustmaster if your precondition is hasStream, then only on the full stream. @trustmaster I know, but they're a little difficult to implement without reading packets from buffer in different order they were added in.\nAlso, scopes kind of provide a lot of the functionality group and field were originally designed for.. OK, with the current state the only failing tests are related to group de-duplication and arrayport handling. Looking pretty promising.. Now only failing on dupe groups (when we forward < a < b from in1 and same < a <b from in2 you get < a < b < a < b sent to out). @jonnor couple of reasons:\n\nSome tests were reusing same component instance across different WirePattern setups, which doesn't work with Process API\nCleaned some test interdependencies (using proper before/after etc)\nAdded async/sync versions of some tests to verify correctness in both modes\n\nSome tests were kind of wrong (doing async things in sync wirepattern) that only worked because WirePattern didn't actually care. Legacy mode is indeed pretty easy to add since we already have fallback logic in place for couple of the options (group, field) we didn't add Process API support for yet. OK, now we should be essentially complete. No fallbacks except if you enable them manually, either with:\n\n\nPassing a legacy: true to WirePattern\n\n\nSetting the NOFLO_WIREPATTERN_LEGACY env var. @trustmaster would be good to give this an initial review round. Follow-up would be to add convenience methods for checking / fetching input data by connection idx. Shutdown doesn't drop the graph reference, since typically graphs can be restarted as needed. However, if you drop the reference to the NoFlo network, then it should get garbage collected eventually. @afshin2003 no, loader doesn't keep instance references, only the list of components available.. OK, sounds like this one is resolved. Please reopen if there are still issues.. I think there are two options here:\n\n\nMake control ports unscoped\n\nAdd a unscoped property for ports. WirePattern is the legacy way, and the process API is the new recommended way. As a matter of fact, in NoFlo 0.8 WirePattern just sets up Process API internally.\n\nYou can find documentation on the component lifecycle in https://noflojs.org/documentation/components/#component-lifecycle\nIn 0.8, I'd recommend providing setUp and tearDown functions for components that need them instead of overriding shutdown.\nBTW, if you're wondering which component(s) keep your network running, you can get a list of them with the network.getActiveProcesses() method.. @enib29 you can do per-port data processing also with Process API. Something like:\ncoffeescript\nc.process (input, output) ->\n  if input.hasData('in2')\n    data = input.getData('in2')\n    # Do something, send outputs, then\n    output.done()\n    return\n  if input.hasData('in3')\n   # ....\nIf you want to keep the latest packet from a given port, you have two options:\n\nStore it to component state and add appropriate tearDown logic to remove at network stop\nSet the port you want to retain latest from to control: true. Control ports keep the latest packet and allow you to getData it multiple times. Hey! This would be a great question for Stack Overflow\n\nHowever, here's how to do it: When you want to use a graph as a component in another graph, you need to export the ports you want from it. In Flowhub this works the following way:\n\nGo to the subgraph\nRight-click (or long-press on touch screens) a port you want to expose to the outside\nClick \"Export\"\n\nAfter this the in (or out) port will appear as exported and will be usable from outside the graph\n\n\nYou can export multiple in and outports, and give them whatever names you want (right-click to rename)\n. @trustmaster tests added. Well, this is the first step towards that (and type-aware packet introspection). Next will be to pass this info via fbp protocol to the IDE. Note: PhantomJS is not ES6 compatible. We should either configure the browser bundle to be babelized to ES5, or switch to chrome-headless. The generated JS looks pretty clean:\n\n. We should be able to merge this as soon as #570 is in. @jibe-b thanks! What would be needed? The available components in a NoFlo installation can be discovered using the fbp-manifest tool (which also supports other FBP systems).. Closing the issue NoFlo-side, subscribed to the upstream one.. Part of #555. Part of #555. Based on a chat with @trustmaster today, the way forward would be to allow graph designers to add a load port to component instances. If such port is present, component activation/deactivation would send current load out to that port. Throttling logic can then be implemented as another component on the graph level.\nDepends on #594. Docs in https://github.com/noflo/noflo.github.io/pull/76. Might be nice to call this asComponent, as it is basically the opposite of asCallback.\nCases to handle:\n\nBasic synchronous function (return value sent to out, thrown error sent to error)\nFunction returning a Promise (resolved sent to out, failed sent to error)\nFunction that has a callback as last argument (given (err, out) => function)\n\nThe asComponent function should return a component instance. As the second argument one could supply an options object for things like icon, description, list of control ports, etc.\nThen it can be as easy as:\njavascript\nconst foo = require('some-library');\nconst noflo = require('noflo');\nmodule.exports = noflo.asComponent(foo, {\n   description: 'Do foo',\n});. This is handled correctly in NoFlo itself (and we have a test for this). However, the issue is in noflo-runtime-base which has no clean way to handle errors happening via the constructor.. Please check out https://github.com/noflo/noflo-runtime-base/pull/115. False negative. The thing is, control ports are non-firing (by design). But indeed, I agree that there should be the exception that they probably should fire if there is unprocessed input in the other ports. @sfescape can you provide an example to verify this?. Seems to be fixed now?. Check your browser's console to see the output.\nOr you can just click on a wire to see the data passing through. Yes, use:\njavascript\nnetwork.on('end', () => {\n  console.log('all processes have finished!');\n});\nThere is also the network.getActiveProcesses() method that you may find interesting.. We should add a clonable property that components could use to tell downstream that their packets are not cloning-safe\n. Should we add an option to clone?\n. Could be useful to add a toString that would provide as much information about the packet as possible. Output something like:\nFrom: NodeA\nTo: NodeB\nGroups: a/b/c\nData: 124\n. I think an options object would be better here\n. @ifitzpatrick I think name can go to options if you ensure backwards compat with something like:\ncoffee\nconstructor: (options) ->\n  if typeof options is 'string'\n    options =\n      name: options\n. Doesn't this one reset us from FALSE to NULL?\n. Because some additional error handling was added to the Subgraph component. Previously these had failed, but silently\n. Just added because I happened to look at it and noticed errors were ignoredd\n. Correct, I'll fix that\n. That is something we could indeed do quite easily\n. And of course the nice thing is that the manifest file can just as well be generated using fbp-manifest-deps or other similar tools\n. Well spotted, this had always been wrong\n. Why are you instantiating in every test now? We should make sure components are safe for multiple runs\n. Scope handling is pretty crucial. Can we get this into the PR?\n. This needs a CHANGES entry\n. This needs a CHANGES entry\n. I wonder if we should swap the default now to true, just like forwardBrackets\n. Attaching output socket in beforeEach, and detaching in afterEach is fine, however\n. I would maybe phrase it something like this:\n- Added stream helpers for Process API. hasStream checks if the input buffer contains a complete stream (matching brackets and data, or only data), getStream returns a complete stream of packets. These require forwardBrackets to be disabled for the port\n. Typo here? Should be throw. Not necessarily. If you only have a single forwarding inport, you'll only get called for data packets. That is a good question. Could also be internal, but in any case useful since we were duplicating this code in multiple methods. With this PR, connect/disconnect are no longer sent as IP objects, and so this was needed to allow WirePattern to disconnect. I think additional tests would be useful for that. PRs welcome ;-). it should work given that noflo.Graph is now just an alias of fbp-graph.Graph. Fixed in a93cff8. Yep. Might be good to change that to a more duck-typed check, but that can be done separately from this.. Yes, this is based on what we agreed as being a \"stream\" in the meetup last summer. Either:\n\nData packet not surrounded by brackets\nData packet(s) surrounded by matching brackets\n\nSo empty brackets are not considered a stream.. I consider it somewhat dangerous, given that it doesn't actually read from the port buffer, and doesn't provide any activation/deactivation logic.\nIf users must, they can of course still do component.inPorts.foo.on 'ip', (ip) -> # do custom stuff. @trustmaster because we populate array per port index under it. Yeah, though if you don't care about index then better not to use an addressable port. But indeed, input.has('portname') could probably wrap attached and the loop for convenience. Yep, groups is a bit finicky because in Process API it is resolved properly only when dealing with output queue, so after the processing callback has fired.. grouping by RegExp is supported (top-level group only, see here. gc is indeed unnecessary here.. @trustmaster nope. But the problem is that you might do (data, groups, out, callback, null, null, scope) which is why this can't be fatal. Also, in general this kind of thing being done in this test works better with forwardGroups: true than doing it manually. Though I suppose we could check if postpone and resume are functions and then throw. Well, except we can't see the argument usage from the outside. Plugged the deprecation warning back in. It will throw anyway if user tries to call the (non-provided) function.. typo with services.. Yeah, those should probably be direct throws now. Fixed in c8f357f. Yep, will do that when I prep the release. @jonnor I guess we should just document it.. It is actually a bit worse than that. The defaults will work in ES5, but the arguments with defaults are not visible. So it'll always send the default and you won't get a port.. Not a major issue as most browsers support ES6 now. Mainly affects using PhantomJS as test runner.. Good point, fixing. ",
    "nka11": "Had a look on all of the options.\nMy preference go to jsPlumb, cause it's the only one who provides svg visualization, and therefore, may be the most appropriate for dynamic process monitoring vizualisation.\nadditionally, it supports jQuery which is good for it.\nSo, +1 for jsPlumb\nRegards\n. ",
    "mwawrusch": "Hi everyone, new to NoFlo, here are my 2 cents:\nAfter looking at all the libs mentioned I think it should be either JointJS or jsPlumb,\nRequirements for me would definitely be MIT license and jquery compatibility. \njsPlumb seems to be more stable, but is hosted on google code, so contributing, fixing the diagramming layer is a pain. In addition to that it does not seem to be as feature rich as JointJS\nThe JointJS is on github which is a major plus, and it seems that it has a better architecture (I only glanced over it) and supports hierarchical components, which is hard to add after the fact. JointJS is using Raphael under the hood, which is a very solid product.\nSo to sum it up I would go with JointJS.\nRegarding the UI: My experience having developed a workflow package and some diagramming packages in the far past is that simplicity is key. Nodes in, nodes out, may some color coding and an icon and one sentence description. More can be shown when a user hovers over a node (or does a single tap on the ipad)\nVisual Debugging\nPeople in general have a hard time visualizing flow once you have more than a couple nodes, which is why visual debugging (e.g. animating the flow) is nice for marketing but not often used in practice. If debugging is needed users are mostly in an aggravated state and just want to get the job done, which is why lists are preferred (events in, events out+ errors + filtering)\n. An update: jsPlumb is now on github, and I really like how it progressed over time. So I am changing my preference to it.\n. Thanks for the link, going to watch the video now. One more thing: You might want to create the organization noflo on github  , even if you don't use it yet it might prove to be useful in the future.\n. Yep, they did a great job. I played with the lib for an hour or so and found only one bug so far, which is a good sign. Downside right now is no support for touch events on the IPad, but that could be added. I need something sooner than later, so I am probably going to try to whip something up using jsPlumb. \n. Damned, I got shanghaied into an OS project ;)\n. ",
    "jrz": "Just a question outside of this project.\nWhat other pros/cons are there between jointjs and jsplumb?\nThe demos of jsplumb seem less nicely designed, but the interface is a lot better by default (hovers etc and performance)\n. Hi bergie, thanks for the explanation.\nI had already started with jsPlumb, and it indeed seems that jsPlumb is only for connecting elements.\nWhile it works for what I'm doing, I did run into the hierarchical issue though.\nI like that I can use DOM to do some styling, and use jquery draggables.\n. ",
    "mchogan": "Have you made a decision on Canvas vs SVG? Where is the best place to discuss and ask questions that maybe aren't issues?\n. The subway map metaphor is really interesting.\nI like a map metaphor in general, such as the interface of Google Maps that allows zooming in and out.\nWhat I like about a map interface is that detail can be either shown or abstracted in meaningful ways. So I can show a node as a coordinate, a city, a country, a continent, a planet, but each is just a view-appropriate representation of a single node.\nAnother powerful thing about that sort of representation is that it aids refactoring of code. Maybe I don't know the details of the US, but I know I want to visit the Gand Canyon and Empire State Building. I can draw a node called US and give it those two attributes. Later, I can decide the huge US node is unwieldy and create sub-nodes inside of US for Arizona and New York and move the attributes to those sub-nodes, which are then easier to reuse across programs.\nFrom my work with Canvas and SVG so far, I think it would be far more achievable to implement an \"infinite map\" or \"zoom user interface\" in HTML5 Canvas (for example with Kinetic.js) than with SVG.\nCheck out a simple Canvas site I made and bump up the number of paint dabs and it keeps running. Slowdown starts detracting from the animation up around 1000 nodes. I've not tried an equivalent exercise with SVG.\nmchogan.com/html5/i-still-use-canvas/\nOn Feb 8, 2013, at 9:30 AM, Henri Bergius notifications@github.com wrote:\n\nHere is my latest thinking on the matter: http://bergie.iki.fi/blog/inspiration-for-fbp-ui/\n\u2014\nReply to this email directly or view it on GitHub..\n. \n",
    "kenhkan": "This looks really sweet! I like that it's pretty basic-feature-complete with the menu bar. One quick suggestion is to include the component's name in the box so it's clear what you're dealing with without opening the Source panel.\nSo this would obviously be a \"graph\" and we'd be able to add the ports to export? Or when you save it's automatically exporting unbound ports?\nAll in all, this is an amazing feat so far!\n. So this turned out to be more of a systemic problem than I thought. Here's a documentation of what I went through.\nCurrently (i.e. w/o this patch), if you do:\n'graph.fbp' -> GRAPH Graph(Graph)\n   'A' -> PROCESS.IN Graph()\nThis would work, but not this:\n'graph.fbp' -> GRAPH Graph(Graph)\n   'A' -> IN Merge(Merge) OUT -> PROCESS.IN Graph()\nThis is because only sending of initial tests for the readiness of the immediate downstream process. My initial patch solves this.\nBut this wouldn't work with the patch:\n'graph.fbp' -> GRAPH Graph(Graph)\n   'A' -> IN Merge(Merge) OUT -> PROCESS.IN Graph() PROCESS.OUT -> IN Output(Output)\nIPs are buffered before PROCESS.IN when Graph is not ready, but as soon as it's ready, a 'ready' event is emitted and the inport connection between the upstream process (i.e. Merge) and the graph is made before it has time to make a connection between PROCESS.OUT and the downstream, Output process.\nBecause of how 'Graph' is currently implemented, the above is in reality something this:\n'A' -> IN Merge(Merge) OUT -> IN * OUT -> IN PROCESS OUT -> IN * OUT -> IN Output(Output)\nThe interfacing pseudo-ports are set up during addEdge after everything has set up so I need to make IPs buffer until all addEdges have been called. Since addEdge is called by an event and I have no control over which addEdge is called first, I have to make a stack and flush everything at the end when the stack is emptied.\nI know there must be a less hacky way. I still haven't grasped the entire codebase so it's difficult for me to think at the highest level. Please let me know if you have any idea! Thanks! But for now, this works for all intents and purposes.\n. See #42\n. Just a clarification. The above currently prints:\na\nb\nb\nc\nc\nc\nwhere it should print:\na\nb\nc\n. I have this crazy thought... Would this problem persist if the whole noflo is implemented asynchronously? Say:\n'SomeInitial' -> IN A(Something) OUT -> IN B(Graph) OUT -> IN C(SomethingElse)\nIn the current implementation, 'SomeInitial' is sent to A and then sent to B immediately. If data flow is async, wouldn't B setting up be run before 'SomeInitial' is passed to it, making the ports to be available for attachment between A and B?\n. See #42\n. @bergie Humorously the same thing happened to me. I was in Vietnam for several weeks so I'm sorry that I couldn't comment any earlier.\n41 should not be an issue if #42 is fixed. It's two solutions to the same problem. Well, #42 is a more complete solution. I'm closing this now.\n. I have been reading Morrison's book and realized that the concept of a graph is to look like a regular component. Having the dot-notation breaks the black-box-ness of FBP.\nSo I guess we should always stick with the PROCESS.PORT convention, but I'd still be for the idea of compiling the graphs before execution.\n. That guy was definitely on drug. He thinks way too fast for my taste, but that's what makes the presentation great.\nComplying with Node.js standards is a great move. I'm curious whether this would solve this problem I have been having: the ending process disconnects before the beginning process does. In this overly simplified graph:\nA -> B -> C\nC would fire a disconnect signal before A, because currently as soon as A send an IP, it loses control. Not until C disconnects does A have a chance to disconnect. This spells trouble in some cases where the disconnect signal actually does matter, like Counter and Kick.\nI did have a fix that I've been testing but hesitated to PR because I wasn't sure whether it was a bug or a feature. I'm not familiar with Node.js streams but I'm assuming that using a pause stream (had we implemented Node.js streams already) would solve this problem?\n. There is an update to Node.js' Stream API recently. Finally had time to read through it. The major difference is there is no more data event and pause(), resume() methods. Well, I lied. There are but are not preferred as they're to be replaced with readable event and read() method.\nFor more info, read the Node.js blog post on it. I don't know how this would impact this but figured just to make a note here in case anyone has the time to implement this: http://blog.nodejs.org/2012/12/21/streams2/\nHappy coding!\n. That's an interesting thought! This would make interfacing with other FBP systems or any other systems in general much easier.\nThis may also serve as a solution to the long thread that JPM and others are currently engaged in on message passing in NoFlo. It would render NoFlo to be more similar to other FBP implementations in that the IPs are not passed onto downstream processes by rather sent to a connection buffer which could be configured according to the needs of the receiving processes. Not a shabby idea at all!\n. Neat! Is it recorded somewhere for read at this point?\n. Did you build it manually? Try using npm install instead. If you did that, did you install noflo globally? I believe noflo was designed to work locally. Better yet, if what you're working on isn't sensitive, you can maybe share it so we can try to reproduce the error?\n. I completely agree with this approach. I was thinking to propose to write a command-line tool like NPM just for noflo components but this is an obviously better approach.\nWouldn't it be the case that a developer's components would be isolated as a separate NPM package? We should have a conventional file structure in a NoFlo component package. This is so that we don't even need to declare anything in package.json, just a flag to indicate that it is a NoFlo package, like this:\n{\n  \"noflo\": true\n}\nThen NoFlo can take the components directory (see below) and push it to an array of include paths. When a component is used in a graph, it could then be found.\nName conflict is a concern. That can be mitigated by specifying which one to use possibly in the graph or elsewhere.\nMy other suggestion is to include graphs, which are just as reusable as components (the appeal of FBP to me!).\nA potential package file structure:\n(package's root)\n  +-- components\n          +-- (.coffee component files here)\n  +-- tests\n          +-- (tests here)\n  +-- graphs\n          +-- (.fbp graph files here)\n. +1\nCompletely agreed. Just want to confirm: does that mean that even basic components like Split and Merge would be in a separate package?\n. I see. This Grunt scaffold is neat.\nI was thinking we may need a template for app creation since Split and Merge are likely to be required for any non-trivial noflo apps, but I suppose with noflo-ui in the future that part is done (or alleviated) for the programmers anyway.\n. @bergie I've ported GroupRouter to noflo-routers so that the existing GroupRouter is compatible with the noflo one. Do we have a timeline as to when 0.4.0 will be released? Currently 'noflo-routers' as a package doesn't work with 0.3.3. I'm considering whether I want to spend the time debugging that if we're close to a new release or if we're officially dropping components in 'noflo' much later anyway.\n. May I suggest that we have 0.4 released still with the components retained in noflo for one more minor version? I feel that there will be confusion in the migration process as legacy programs using 0.3.x are updated.\nWe can update the documentation for 0.4 so new users would know to use components using the new stable API. When 0.5 hits all components are removed, unless space is a primary concern or the majority of the current noflo users are okay with the plunge.\nI'm okay with the plunge by the way, just worry about the community. :)\n. Hi all, I took the liberty to try to allocate the components to their appropriate packages. Could you please glance through the list and see if they're categorized correctly? These packages (with the exception of 'noflo-core') are ones that I've created for my own use. I'd really appreciate the creator of the component to tell me if the categorization is correct since he'd know best.\nMy intention is to keep compatibility for as long as possible. If these are grouped correctly, I'll copy them as-is and hopefully document and write test cases against them when I have the time. Some functionalities may collide with others so I'll refactor some and document only the clean versions in the packages. However, the original components would still be retained in the packages indefinitely.\nnoflo-core\nReally just the essentials and the oddballs that don't quite fit anywhere else. I also have a 'noflo-swiss' for \"miscellaneous\" components like 'Callback' so maybe 'noflo-core' for essentials and 'noflo-swiss' for utility components?\n- Drop\n- Kick\n- Split\n- Callback\n- Repeat\n- Merge\n- RepeatAsync\n- Group\n- Output\nnoflo-objects\nManipulation of packets that are objects and/or arrays. I put array-related components here as well because some functionalities in existing components take both arrays and objects, partly due to the fact that JavaScript treats them more or less the same way anyway.\n- SliceArray\n- SplitArray\n- FilterProperty\n- FilterPropertyValue\n- FlattenObject\n- MapProperty\n- RemoveProperty\n- MapPropertyValue\n- GetObjectKey\n- UniqueArray\n- SetProperty\n- CreateObject\n- SetPropertyValue\n- SimplifyObject\n- DuplicateProperty\nnoflo-packets\nManipulation of individual packets\n- FilterPacket\n- UniquePacket\n- GroupByPacket\n- LastPacket\n- Counter\nnoflo-strings\n\nBase64Encode\nSplitStr\nCompileString\nSubStr\nReplace\nSendString\nParseJson\n\nnoflo-groups\n\nReadGroup\nCollectGroups\nFirstGroup\nMapGroup\nRemoveGroups\nMergeGroups\nGroupByObjectKey\n\nnoflo-flow\nFlow of packets. This is different from 'noflo-packets' in that 'noflo-flow' tries to control the flow of packets based on some context or parameters whereas 'noflo-packets' manipulates packets individually.\n- Gate\n- Throttle\nnoflo-adapters\nTransform one type of packet to another: say an \"array\" packet to an \"object\" packet.\n- PropertiesToObjects\nnoflo-routers\n\nGroupRouter\nSplitInSequence (I believe this is like 'routers/PacketRouter' where the position of the incoming packet determines which port it's going to with an ArrayPort as an out port. Please confirm.)\n\nOther\nThe following components should belong to some other packages which I have not created:\nReadDocument\nReadEnv\nListenMouse\nReadFile\nListenTouch\nReadFileRaw\nMakeDir\nCollectUntilIdle\nSpring\nStat\nCopyFile\nTemplate\nCountSum\nGraph\nCreateDate\nWriteFile\nDirName\nReadDir\nWriteFileRaw\n@bergie what does the 'Concat' component do? It may fit in with one of the existing packages.\n. @bergie Good! I haven't created anything yet because, like you said, I want them to be in the noflo organization. In addition to that, I want to move what I currently have over to the noflo organization. I think it'd be more appropriate for me to ask you for commit access to the noflo organization so I can help out with the migration process. How does that sound? :)\n@Bartvds That's a good idea. I think as we consolidate everything, it'd be nice to scan for that in packages in question. Going forward it shouldn't be a problem as developers should be using grunt-init-noflo anyway.\n. @bergie The component diaspora has taken place. The components listed under https://github.com/bergie/noflo/issues/49#issuecomment-18457843 now belong to their respective repositories outlined above. The repositories have also been sent to the noflo organization. Please confirm if these placements are appropriate. Note that I have not touched the components under the label \"Other\".\nIn addition, I have several question:\n1. Components that have dependencies such as Underscore.js, util, etc defined in package.json should be excluded from the client-side in component.json, correct?\n2. I have not finished with the test suite integration because the existing repositories use the now-old method of noflo-test. Are we using the Jasmine-style test cases as used in grunt-init-noflo going forward? Is that likely to change?\n3. Some repositories were using a tailored-made pre-0.3.4 noflo. I was going to wait until 0.4.0 to upgrade en masse. Don't be surprised if you see a funky repository path for the noflo dependency in those repositories. Once you release 0.4.0, I can make the change.\n. I was thinking it would be very convenient to just start writing components and it'd also be good to retain \"privacy\" for some components just like you would with private properties and methods in the OOP world. But I understand you now. It's better to do some work (i.e. registering in package.json) and force all components to be public as best practice so everything is shareable. I'm closing this now.\n. This is very nice! I use two spaces myself and always had to tab twice for the legacy code. It should now be in sync. Let me know if I'm missing something.\n. @bergie There were some mess-ups during the conversion. The delta was too large. Let me close this and start afresh. Will get back to you.\n. Oh sorry. I forgot to add. The tests don't pass because test cases would have to be updated to take into account the fact that IPs are buffered. AsyncComponent would also be updated for that change. I'm simply looking for some feedback on the validity of this PR. If the idea is sound, I'd update the tests and relevant codes to make it pass the tests.\nBy the way, when I said backward-compatible, I meant the interface is backward-compatible. If a component currently expects IPs to be sent immediately without buffer, it'll break. So I don't know rather it's good to enforce some best practices like always disconnect after sending and always expect IPs to arrive as one connection rather than \"split up\" by types.\nThis is why I PR'ed for feedbacks. ;) Thanks!\n. Hmmm. That's true. Do you think this is the only major con to it? I used to have this as a BufferedPort which I would instantiate instead of noflo.Port but later I realized that the inconsistency between how two handle flow really doesn't work out.\nI haven't had a chance to play around with AsyncComponent so I'm going to experiment with it and fix this problem and write some test cases if buffering does sound like a good direction to pursue.\n. It's been a while! Yes, the description of an FBP system makes a lot of sense here. Let me confirm I have a good grip on this before moving on to fix this.\nDo you think the idea of buffering violates any of the constraints?\n1. Flow constraint: the receiving process does not get the second packet before the first because packets are put in a queue when buffered.\n2. Time constraint: the buffer is as described in the FBP book in the way that once you send one, it's in the buffer until it hits the receiving process. See below though.\n3. Ordering constraint: order should be preserved in the buffer as a queue.\nThe problem may lie in that manipulation may take place after a packet has been sent as you can access the buffer after sending packets. Would that be one of your concerns? If that's the case, would it be a good idea to make this into a separate component built on top of noflo.Component that handles easy buffering should anyone needs to manipulate the entire stream rather than on a packet-to-packet basis?\nI obviously wrote it to suit my needs so there are a lot of blindspots for me. Please feel free to point them out as I want to make this work for the NoFlo community.\n. Thinking more on this, I just want to blast this out to see if my thinking is logical.\nThe problem I'm trying to solve here is that FBP documents are sometimes hierarchical. That is, each sub-group is not necessarily the only child of the parent group. Therefore, under the way current components are constructed, as soon as you don't send an IP out after manipulating it upon receiving it, the paradigm breaks. This is because this assumes the grouping structure to be linear (i.e. each sub-group is the only child of its parent).\nThere's quite a few examples of existing components that follow this pattern. One is the Throttle component. It pushes incoming IPs into a queue and release upon process() but by that time the hierarchy structure has been lost. There should be a community standard when it comes to a situation like this, even if we end up mandating end users who program the resulting graph to not use hierarchical grouping, although this is very unlikely and also very difficult to avoid.\nIf hierarchical grouping is allowed for the end users, the biggest issue then is that each receiving function (i.e. begingroup, data, or endgroup) must then manipulate and could only manipulate each IP individually, given that (1) the function has no information of the next IP unless the function caches the IP itself within the process, and even if it does that (2) the function cannot act upon any IP because once it has information about the next IP, the IP in question must already have been sent out.\nThis is obviously not a problem if you record each incoming IP and act on the current IP based on the IPs collected so far. The more likely case in real life is that you have to manipulate the IPs en masse within a particular group.\nAnother example would be to turn all IPs in a specific grouping (possibly identified by some regex on the group) into an array. Now, one may argue that this should be implemented as a graph. A process extracts the matching group and forwards only that part to a process that combines the IPs into an array. Then yet another process puts the array (now just one IP) back into the spot from which the original IPs were extracted.\nI'm completely okay with this approach and I agree that although this greatly complicates things, it does align with the spirit of FBP. And of course you can reuse a generalized version of the above as a graph. I'm looking more for a standardized way to do something like this because if the graph approach is acceptable and preferred, we should not encourage component authors to write a component that processes any connection that postpones processing with a hierarchical grouping structure.\nIf this is not the desirable approach, then the solution is what I was trying to accomplish, which is to provide a Port that allows programmers to preserve the hierarchy while manipulate the IPs before sending them out. Though I must say I'm having second thoughts on this as I think the graph approach may be better.\nIs there anything that I'm missing? I feel like this could be brought over to the FBP Google Group. I'm afraid that this is too contextual or too NoFlo-specific. Do you think it would be appropriate?\n. I realized that there is a better way to implement this functionality as an external package. I have it implemented and just testing it internally. Will update to this thread once it's good to go. Keeping NoFlo's core small is a better route now that I see how it should work. Closing this but will post updates on that package.\n. I also have a question on subgraphs. Is there a reason why graphs would have a different syntax than components? Shouldn't I easily do the following?\n'test' -> IN Subgraph(graphs/SomeGraph) OUT -> IN Output(Output)\nThe fact that now we can register components and graphs in package.json means that we can simply declare our graphs with names in package.json and reference the graphs just like components by name. How does this idea sound?\n. You know what. I actually agree now. This wouldn't work because all groups are stacked up when I have more than 1 output in a graph. Closing this now. Thanks for the trick with noflo -d. Didn't know that.\n. Is component only temporarily needed as the web portion will be refactored out into a separate package? Either way, I figure it's a good idea to nclude the instruction for now. See #74.\n. Got it. I understand that this portion is the most unstable part of NoFlo at the moment so I'm going to wait it out since this is not something that I feel confident contributing for now. Thanks for the explanation.\n. Flawless. Thanks @bergie! Though rather than running grunt first, I need to link with npm link first, as opposed to the reverse order as described in the README.md. Is that normal? Either way, it finally works for me!\n. Closing this because this is related to #75.\n. I think I'm getting confused. I see that you have component installed in before_script in the travis.yml instead. Is installing component globally required?\n. How about with the latest commit? Since we're forcing users to install component globally anyway, why not just do it for them?\n. This is odd. I realized that building noflo with the new commits works but not when testing packages using noflo on Travis. #71 appears on Travis but not on my local machine. Has anyone encountered this problem?\nAnd just as I asked on #71, are component and grunt dependencies here to stay for the long-run?\n. Yea... I figured too after tinkering with it for a while. I had been using a much older version of NoFlo so this whole Grunt + Component thing threw me off as I updated. This PR grew into an issue rather than a PR. :)\nEither way, I somehow still cannot get it to pass the tests for a package using NoFlo on Travis but the same tests pass flawlessly on my machine, for both NoFlo itself or a package using NoFlo. Anyway, it's the same issue as #71 so I'm closing this. Sorry for the confusion.\n. OK... This is something similar to #71 that I've been constantly experiencing on Travis for the past few days. The error for this commit on Travis:\nRunning \"component:noflo\" (component) task\nWarning: Cannot read property 'json' of undefined\u0007 Use --force to continue.\nI don't think this is due to the changeset as it's just a continuation from the merged code and nothing Travis- or build-related has been changed. Let me know if I'm wrong.\n. Hmmm... I thought I would have more luck after dinner. So I tried running this:\n$ npm link; component install; grunt build; npm test\nfor each commit all the way from my latest commit until the master branch. The same error persists. I even removed the entire directory, re-pull from master, and re-installed all global packages. The same thing happens. Running grunt build:nodejs yields the same result. Is there an external dependency somewhere that I'm not aware of?\n. Wow. grunt watch is very handy. Thanks for the recommendation!\nAs for a unit test for Network, the easiest way I can think of is to use something like Jasmine to stub the add* methods that check for correct sequence. I don't think we're ready to put in another dependency just for this so it may be just better to whip something up really quick.\nLet me take care of it if you don't mind. I just can't give you a timeframe since these days I'm a little pressed for time.\n. Oh that's certainly true. Having unit test is a good idea anyway. I haven't\nused Mocha but it looks solid. I'll look into it when it comes time.\nOn Fri, May 3, 2013 at 7:48 PM, Henri Bergius notifications@github.comwrote:\n\nTake your time :-)\nThe reason I mentioned tests is that things like order of sent packets are\nsomething where regressions happen easily.\nMocha tests would be best, as those we can already run on both browser and\nnode.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bergie/noflo/pull/76#issuecomment-17424053\n.\n. Oh my my. It's my bad. I must have forgotten to remove the master build before installing the one on NPM. Thank you for the quick response!\n. +1\n\nThis is a great idea! I have scheduled each day to make sure tests pass (and/or expand test caes) and to document for my own packages for the next week or so. I'd like to help out with others if necessary.\n. Does this mean that we no longer need components 'Split' and 'Merge' because now you can simply connect a regular port to multiple processes? Or by \"connections\" you mean something else?\n. It's amazing to see @jpaulm here!\nJavaScript, being a much newer language (and an interpreted one), takes on a lot of the requirements of FBP into the language layer. For one, objects/hash/dictionaries/\"trees\" are all the same thing in JS and are treated more or less the same as a number or a string (well, technically they get passed by reference, which leads to the problem of cloning that I'm describing below). That's why in noflo, @socket.send data is completely ok since JS essentially sees them all the same way. A component putting individual IPs together into a tree structure would create the tree in \"newly allocated memory\", if you will. This effectively \"clones\" it. And of course, these are all automatically handled by JS at the language level, with no \"option\" to turn it off. In other words, we can't \"ban\" trees since it's a language-level feature.\nSide note: JS_malloc is a Mozilla SpiderMonkey (read: non-standard) feature. It's unavailable on the V8 JS engine, which means unavailable on Node.js, which means unavailable to noflo.\nThe cloning issue is a major problem when processes modify values within a tree, which is quite common in JS. I think there is really no way around it, because deep cloning is particularly expensive in JS compared to other more traditional languages. The best way to deal with that is in the debugging tool. And like you said, the designers should be aware of this and put a Copy component where it should anyway.\nOn the note on Merge, this is another one that is (forcibly) automatically handled by JS. JS is single-threaded and based on noflo's current implementation, let's say there are two IPs being sent on two different out-ports into an in-port, the first IP being sent actually must reach the end of the entire graph before the second IP hits the receiving in-port. JS's limit in this case nicely fits FBP's requirement. I was actually baffled by this oddity at first but it makes sense after understanding how FBP is expected to work and how JS works. See #58.\nTraditional FBP is expected to be implemented at a much lower level in terms of language abstraction than what JS provides and imposes. noflo simply must adapt FBP to JS to make it work on Node.js. It's great that @jpaulm is here to join the conversation in hashing out the discrepancies!\n. @bergie I completely forgot about my own question... Assuming that the FIFO issue that @jpaulm raised isn't an issue (this is my understanding for now), a Port and an ArrayPort basically do the exact same thing except the programmer can address individual \"sub-port\" with an ArrayPort. If that's the case, why do we even have two different types of Port?\nA programmer may simply not address sub-port individually to use an ArrayPort as a Port. Because an FBP component is a blackbox, the designer of the component should know what she's doing without having to consider whether the user understands the difference between a Port and an ArrayPort. If that is true, I'd always use an ArrayPort, because with the current implementation, I would get an error for attaching two out-ports with a regular in-port. With the new implementation, I'm free to attaching however many out-ports with any in-port. So why wouldn't we make Port an \"ArrayPort\" as it stands?\nI know this makes a huge change in FBP semantics, but like I've outlined in my reply above, a lot of the considerations put into FBP are resolved by JS at the language level. To a JS programmer, it would cause less confusion if there's only one type of Port when there is no value in using one over another.\nI suppose the overarching theme is: do we want to adapt FBP to JS or JS to FBP?\n. @bergie Ah. I see. If the programmer must address the sub-ports, it makes a lot of sense. Thanks for the clarifications.\n@jpaulm I have lost my responses before too. Not fun. :(\nI'm definitely not qualified to \"educate\" by any means because I'm still figuring this out as I go as well, but to your question: yes, JS is green-threaded, but like memory management in JS, it's handled at the language level. To a programmer, there is no concept of \"a thread\". You may \"delay\" execution of a function by calling process.nextTick() which puts it on a queue of \"threads\". The difference is that the queue is executed strictly FIFO, meaning one has to finish before another one is started, which makes it just like a function call except it's put at the \"end\" of your stack, if you will.\nThat is the limit that JS imposes. In your graph, let's assume it's a Copy rather than a LoadBalance. noflo has to use function calls to accomplish message passing. Testing_2 calls Copy, which calls RandomDelay#1, and so on. This means that Discard has to return the call and let the stack rewind before Copy can call (i.e. send to) RandomDelay#2.\nThis strategy works because if Discard is Collate, it'll have to wait until the stack rewinds two times (for # 1 and # 2) and the third copy reaches it. In the end, it still resolves, albeit in an odd way.\nThe only real alternative is using nextTick() as described above but it is an order or two magnitudes slower. With a large graph, it's detrimental. Aside from that reason, there's also constraint considerations required in FBP, which were outlined in #58. And of course, the change breaks nearly all existing code. So it's unfortunately a dilemma...\n. No worries. It's sad to say, but I do agree with you. This is a huge trap for new users. I was banging my head into the wall for several days on this at first. I need to thank @bergie for bearing with me on all the issues I opened on GitHub regarding this model.\nGranted though, I understand why @bergie structured noflo the way he did. Like you mentioned regarding your conversation with @bergie, There's currently no coroutine in standard JavaScript, and Rhino is 2-3 orders of magnitude slower than V8, which is the engine used by Node.js, and indirectly by noflo. The faster engines, which are usually substantially faster than the slower ones, all sacrifice features for performance.\nFFI-based solutions are definitely another alternative, if noflo is only for Node.js. The current roadmap of noflo is to make it portable so that it can run even in browsers. FFI dependencies would render that impossible. This also speaks to why we can't use non-standard JavaScript, which, being an interpreted scripting language, puts a huge constraint in what we can do. This is what I meant by JS' limits.\nOn the issue of \"trees\", I'm sorry if I wasn't clear. I totally agree that they should not be copied, and they're not right now. Deep copying in JS is even slower than copying in Java. That's why there must be a Copy component so that the programmer has to explicit copy if that's the desired behavior. Sorry for the confusion.\n. Hey @jpaulm, sorry for the late reply but I was at a party.\nThe main problem here is portability. Sorry for the acronyms, by FFI I was referring to Foreign Function Interface. What I meant was on the browser you simply can't have dependencies that are not within the standard specification of JavaScript. You may be able to run libraries in C in Chrome with Native Client but it wouldn't be runnable in most modern browsers.\nPerformance is a more minor problem, but if noflo needs to be run in the browser, speed is actually quite paramount. You have people using older browsers, on slower computers, or simply with many tabs opened at once. It's actually much worse on the browser side if we want to simulate threads without external dependencies because there isn't the nextTick() that I talked about. We have to resort to the yet slower setTimeout(). We're talking about 1000x slower for each message being passed. Given that FBP is all about messages being passed around, this is less than desirable.\nThe root cause of all these requirements is because we want noflo to run on browser. @bergie and I have had a brief discussion on how to deal with this duality of noflo: browser and server. There is simply not enough development resources (nor does it make sense) to put into managing two separate noflo's.\n@jpaulm Correct me if I'm wrong. The major concern that you have is whether noflo can interface with other FBP systems. May I ask why you don't think the current noflo cannot interface with, say, JavaFBP once the API is stable?\n. Ah. I see. So you're really concerned about race condition? The limitation of JS all of a sudden becomes a benefit in that case. It's single-threaded! That means that I can consistently predict which process is receiving what packet in what order. That implies that I can also consistently predict which state a process is in at any point of time. In fact, incoming external signals, like a web request if a noflo system is a web service, are queued up. Only one web request is handled by the graph at any point in time. Does that resolve your concern?\nI must admit: this is not the ideal setup as I now must look at the packet flow of the entire graph rather than by looking at individual processes. Perhaps this is where the problem arises as you see it?\nOn the trajectory of noflo, I should let @bergie chime in. I'm only explaining how noflo works on the inside as I've browsed through enough of the source to do that. I do see the pitfalls but I understand why they exist and the trade-offs that @bergie made. If we were to go with what we have right now, these must definitely be documented for new users of noflo. However, if there is a way around it, I'd be happy to invest some of my time in it.\nSo it's great that @jpaulm you are raising these concerns! For myself, I just need to understand the basis for why calls should not be used, since from my perspective this is an unfortunate but reasonable compromise.\n. Oh, my bad! That was quite a jump indeed.\nThis turns out to be a philosophical issue that is way out of my expertise. I agree that noflo is bending FBP a bit. One of the more fundamental problems is that JS simply doesn't offer coroutines (actually, it doesn't even offer parallel computing concepts in any way) so thinking in terms of coroutines with the premise of using standard JS is futile IMO. Perhaps we can slip an external dependency in somewhere like you've suggested. If that could be done, that would be perfect as that really solves the issue that you raised.\nTo your last question. Node.js isn't \"standard\" JS. Or I should say, Node.js isn't even a dialect of JS. It offers a server-sides API for usual back-end stuff. It's really the V8 engine on which Node.js runs that implements the JavaScript. I believe JS is \"asynchronous\" from the very beginning. It started out as more or less an event-driven scripting language as part of Netscape. With XHR and other features added in the decades after all JS implementations are simply asynchronous by design.\n. > \"Coroutine\" is IMO an all-embracing term, but this can be implemented using green threads, red threads, or some hybrid. When I heard about Node.js' event queue, I thought this might be like green threads - maybe I have to do more reading...\nOh my. I almost posted a rebuttal and something struck me. Thanks for pushing this!\nI realized that newer browsers support web workers and Node.js of course supports child_process, which are essentially threads. So upon more research, there is a library called Parallel.js which smoothes out the edges: it uses child_process for Node.js and web workers for browsers, or traditional setTimeout if web workers are unavailable.\nI do not know how much overhead this is going to bring to noflo, especially when there is no web workers. Web workers are definitely more resource demanding than traditional calls but definitely a better choice than using a Java plugin by any measure. This is another trade-off, but with less clear a choice.\n@jpaulm Could you take a look at Parallel.js and see whether this would resolve your concern? It definitely sounds like it would to me.\n@bergie Do you think it's a good idea to sacrifice some performance for this on the browser, especially those with no support of web workers?\n\nIf we are not using standard JS, why do you say we have to use standard JS elsewhere?!\n\nThis is definitely a source of confusion for non-JS programmers. The world of JS is not unlike the world of Lisp in terms of fragmentation. Just like you have Scheme, Clojure, etc in Lisp, you have different JS implementations. However, whereas you have Common Lisp, the closest equivalent in JS is ECMAScript, which is the only JS \"implementation\" that is standardized. The problem is, no one actually uses ECMAScript directly. Browser vendors use ECMAScript, which itself has multiple editions, and put a layer of features on it and use that as the JavaScript for the particular browsers.\nBy \"standard JS\" I really meant ECMAScript edition 5, which is the foundation for all modern browsers and Node.js. Think of it this way: \"standard JS\", or ECMAScript edition 5, is the lowest common denominator, which allows us to deploy noflo to as many platforms (browser and server-side) as possible. Technically, there's no \"standard\" JS, just \"standard\" ECMAScript, but I was just using the term as a reference to this lowest common denominator.\n\nin which case, we may not even need Node.js...\n\nWe do need noflo to run on Node.js simply because that is the de facto standard of server-side JavaScript.\n\nHowever I see the big problem with pure event-driven is how do you maintain \"state\" in a process? E.g. how do you implement a counter?\n\nAh, I see where the confusion is. JS is not pure in any sense. In fact, it's probably one of the most multi-paradigm language you can find. Any variable you declare that is not local to a function retains its state across events. That's how state is achieved.\n\nWhat FIFO issue did I raise?! Sorry, couldn't find it!\n\nHaha, my bad. It's one of my logic jumps again. You said: \"multiple output ports feeding one regular port or array port element happens on a 'first-come, first-serve' basis, and avoids the possibility of deadlock.\" In JS, \"first-come, first-server\" implies FIFO because of its nature of single-threaded execution.\n\nA non-array port doesn't have to ask this (even though it can be processed as an array with only one element), so array vs. non-array should really be part of the external spec of the component.\n\nSorry that this has lost me a bit. If I'm interpreting this correctly, the difference is just how the users of a component see the component from the outside. Why should the user of the component need to know whether he's attaching to an ArrayPort or not?\nAccording to @bergie response, \"ArrayPorts should always address different sub-ports, not the combination of all their connections\". The difference then lies in how the designer interacts with the component on the inside. Maybe we are really talking about the same thing, just different perspectives?\n. 1. Yea... This is why it has been my position that using features other than what ECMAScript provides isn't exactly a good idea.\n2. Ah, I see where you're coming from now. The thing is: Node.js never runs on browsers. noflo just chooses to be able to run on both Node.js and the browsers. I was referring to two separate platforms when I said, \"@bergie and I have had a brief discussion on how to deal with this duality of noflo: browser and server.\" The two have no connections whatsoever.\n3. That's the thing. JavaScript is a minefield with lots of limitations. This is why I appreciate how noflo is constructed. It takes a lot of extra effort for a programmer to directly change the state of a particular process in run-time. In practice, to the programmer at least, noflo has no global state. My initial answer was to your question on how noflo maintains state. To the programmer, the state is localized to the process.\n4. I must admit. I got the book but shamefully did not finish it. I think I need to hit the shelf again. :) This is also the basis for my comment of this being a \"philosophical issue that is way out of my expertise\". I'm obviously more from the JS side and I just want to make FBP work on JS. That's where I'm coming from.\n5. Have you tried noflo's examples? Take a look at the linecount example. From the programmer's perspective, it's as close to FBP as it can get with its FBP DSL.\n. 1. child_process is definitely not part of any JS standard, mainly because it has no use on the client (i.e. browser) side, where JS originated.\n2. I'm sorry that the confusion continued... \"Node.js never runs on browsers\" because Node.js is the server-side JS platform.\n3. I think this is simply an issue of semantics because of differences in programming language constructs. I suppose all that matters is that, in practice, a programmer using noflo wouldn't be exposed to global states, if that is the concern.\n4. Haha, I'd agree. JS is not well-adapted for anything IMO. I'd much prefer running something like python in the browser. I come from the position that JS is what we have and there are all these restrictions, so how do we make the most out of it. It is definitely what you said--\"forcing FBP into a JS mould\"--because JS is such an unforgiving platform (note: only if running on the browser is a requirement). In this regard I need to take a more abstract perspective like yourself because unfortunately I'm a hammer and everything looks like a nail to me... :(\n5. I stand corrected on the issue of DSL. That was a quick thought that got passed onto paper. My apology.\nI come to a realization that I'm not helping at all, if not bringing in more confusion. I'll stop here and let @bergie chime in. Thanks for bearing with my partial opinions along the way and my apology to @bergie for making a mess in trying to explain.\n. @bergie Very succinct and informative. Thanks for the clarifications.\n@jpaulm I know I'm supposed to stay away :) but I feel the need to clarify what I said: \"JS is what we have\". it's related to @bergie 's concept of a \"Universal Runtime\". To me, that doesn't imply a \"Universal Language\" at all. That'd be outrageous, because as a language, JS sucks, but there is a reason why there's a high level of interest in compilers from different languages to JavaScript. It is exactly because of the universality of the JS runtime without using JS as a language.\nThe JS runtime is \"universal\" because that's what all modern browsers support out of the box. Running your own JS interpreter, which implies a separate JS runtime from the browser's own, on the browser requires a plugin, most likely in the form of Java applets. In that case you may as well run just JavaFBP on the browser as an applet and forego JS to leverage the full power of Java.\nGiven that there's no Java support on iOS, Apple doesn't like Java applets on the desktop, many low-end Android phones sold outside of western countries don't support Java by default (I mean, even my Galaxy SII doesn't run Java applets in the stock browser), and of course smart IT departments and users would always disable Java. It is safe to say that by using Java, which is already the most widespread non-ECMAScript plugin on the browser side, we would literally limit noflo to a tiny subset of savvy internet users who know how to get a Java applets working for them.\nSo no, the main appeal of JavaScript isn't that it's interpreted. The main appeal is that it's supported everywhere where there is a browser installed.\nI MUST STATE THAT JS + Java would most definitely work on the server-side. If we do pursue that, we're effectively splitting noflo into two FBP implementations, which leads back to my comment on the duality of noflo and the lack of resources to make that work.\nI hope I'm not confusing anyone. :(\n. @jpaulm Unfortunately, like you said, we are indeed training the \"pig to sing\" when it comes to putting FBP on JS... This is why we need someone like you to keep a close eye because while we want to make it work on JS, we don't want it to stray too far from the true spirits of FBP, even though a bit of that is inevitable. So thank you for this conversation!\nOn Java vs JS, I'd take it one step further: technically, Java isn't even run by the browser, but by the Java VM. Java VM is inherently an \"operating system\" in its own right with file access capabilities and everything you can do with C (or so it was intended). JS on the other hand wasn't designed to have any interface with the \"outside\" world other than the web page in which it runs, like what @bergie suggested.\nI think of it as Java = running as root and hoping that the program is well written and JS = running as a chroot'ed user with sudo for certain (very limited) operations, if this analogy helps.\n. @jpaulm I'm not aware of invisible windows (not necessarily that they don't exist). I believe WebSockets as mentioned before were invented for that purpose: allowing more than one thread per window, effectively giving one the ability to create \"invisible windows\".\n. Are we enforcing the use of grunt going forward? If so, this can simply be a grunt task that gets triggered upon compiling. If I need grunt for other tasks (mainly getting noflo to work in the first place) I may as well be encouraged to always use grunt to compile before publishing, no? If we're not enforcing the use of grunt to run a noflo graph, the programmer will need to run a separate command manually if they want this managed \"automatically\" before publishing anyway. We should try to encourage a standardized build process.\nOn the issue of Node vs browser, I still can't see it clearly yet because I've only been using noflo on the server side, so correct me if I'm wrong. I would assume that each package works either in Node, the browser, or both. It doesn't make sense to have a constituent component to be Node-only while another is browser-only. The only scenario is when the package has to deal with platform-specific code, but doesn't that suggest that you should split the package up anyway because noflo/FBP is all about composability?\n. The dual-level approach makes a lot of sense. I now see a \"third\" level which is part of grunt watch that rebuilds the declarations upon new components or graphs.\nClosing this and will return with a PR.\n. Oh I forgot to mention. This is a \"shortcut\" task, so it makes sense that if you've already declared a component/graph in either component.json or package.json, the task will simply ignore that particular component/graph. This means that if you haven't specified any component/graph in either json files, all components and graphs will be included on both platforms. This makes sense, right?\n. By \"always update ... to the latest state\", you mean that we always refresh the declarations regardless of what's currently in package.json or component.json, correct?\nFor annotation, what do think of this?\n```\nclass Component extends noflo.Component\n  constructor: ->\n    ...\nexports.getComponent = -> new Component\nexports.engine = \"browser\"\n```\nAccepted values are as you've prescribed. Default to any.\n. Sorry. You lost me there. Would a component ever not be requireable? I assume developing in noflo requires npm, which implies Node.js' CommonJS style.\n. This tool should apply only when you're developing. When you publish it to npm, you should run something like grunt build-declarations; npm publish or more likely grunt build; npm publish with build calling it implicitly. This needs to be done once before publication.\nAs a user of a noflo package on npm, I shouldn't have to worry about this tool. In this setting, it's safe to assume we always have access to require, no?\n. I'd vote for the first option. The second sounds like it happens in runtime and requires more code than a static list of aliases. We could just make all the changes for the next major version and freeze the list of aliases until another major version. That sounds like a cleaner approach.\n. @bergie Which one do you prefer? I'm assuming you were referring to putting the source in src? I opened this issue mainly because it affects where the tool from #91 would look for source.\n. That sounds good. I'll assume components still reside in the components/ directory when writing #91 then.\n. Update: most core libs have been updated with the isBrowser() helper. Test will fail unless you're using master until 0.4.0 is pushed out.\n. Because CoffeeScript's class system is simply a syntactic layer on top of JS' prototypic system, you can easily do this as well:\n``` coffee\nnoflo = require 'noflo'\nmodule.exports = ->\n  c = new noflo.Component\n  c.inPorts.add 'in', (packet, outPorts) ->\n    return unless packet.event is 'data'\n    # Do something with the packet, then\n    outPorts.out.send packet.data\n  c.outPorts.add 'out'\n  c\n```\n... or ...\n``` js\nvar noflo = require('noflo');\nmodule.exports = function() {\n  var c = new noflo.Component();\nc.inPorts.add('in', function(packet, outPorts) {\n    if (packet.event !== 'data')\n      return;\n    // Do something with the packet, then\n    c.outPorts.out.send(packet.data);\n  });\nc.outPorts.add('out');\nreturn c;\n};\n```\n. This question is kind of hard to answer. I'm not sure if it is even worth answering at this stage. NoFlo is too nascent for performance hacks.\nThe value of NoFlo/FBP is so that you don't have to worry about most of the code that you would otherwise have to write. Bugs from incremental improvements and refactoring are also kept to the minimal. These two qualities alone should eliminate much need for \"high\" performance, because you simply allocate what would otherwise be salary to a programmer (e.g. you) having to program, to more servers to scale out.\nCurrently, design mode is run mode. Unfortunately, it is not on the roadmap at this point, but developers are welcomed if there is a need for it. :)\n. I believe most noflo devs right now are on mac/linux boxes so it's hard for us to debug... Could you please post how you got to that point? Which tutorial did you follow?\n. @yanko This is a grunt-related issue. It's complaining that there's no instance of grunt. grunt-cli is only the command-line client. You need to run npm install to get all the dependencies, including grunt itself.\n. @yanko Sorry for the late response. I've been out of commission (i.e. a nasty cold). It says there that your package.json can't be read. Most likely it's malformed (i.e. not a JSON). Could you post your package.json?\n. Having looked into the Travis log, apparently the new CoffeeLint looks into comments to check as well? I could remove the semicolons in the JS examples in the comment if necessary.\nThe output is:\n[error] src/lib/NoFlo.coffee:83 Line contains a trailing semicolon (no_trailing_semicolons)\n[warn] src/lib/NoFlo.coffee:112 Line exceeds maximum allowed length (max_line_length)\n[error] src/lib/NoFlo.coffee:117 Line contains a trailing semicolon (no_trailing_semicolons)\n. Hi Lee, these are interesting thoughts, and definitely apply to any JS-based projects. You're offering solutions to multiple questions at once so I'll try to respond to them separately. Please do point me out if I've misinterpreted your position.\n1. CoffeeScript is less suitable for reliable development than JavaScript because of its syntax: The syntax of a particular language has very little to do with whether it's successful or whether it could produce quality code. For starter, JS itself would not have succeeded if it wasn't picked as the language of choice for NetScape and consequently all browsers; it's definitely not its syntax at work here. On the other hand, languages that have been traditionally been associated with elegant syntax like Lisp never really took off. Well, you may say Clojure but that's because of JVM, not the syntax.\n2. Indent-based syntax is inferior in development: I only need to name Ruby, Python, Haskell, etc.\n3. JavaScript and CoffeeScript do not interoperate: On the server side, requiring the CoffeeScript lib would automatically set Node.js to include .coffee files as CoffeeScript and start interpreter from there. On the client side, it's not because it does not support client-side CoffeeScript, but it's because you want every last bit of performance on the web. This requirement is going to deteriorate as time passes.\n4. Using JavaScript in a project enables wider adoption: This is a confounding statement. It could very well be that JS started way before CoffeeScript did (duh), so the community is substantially larger. This was the same argument back when Java (or any new tech) was started. Should you really start investing in a new language/framework/technology when there's always one with a sizable community? If this question is clear cut, there would never be Java (b/c of C), Ruby/Rails (b/c of PHP), JS SPA (b/c of Flash), and the list doesn't ever end. Likewise, NoFlo should never succeed because there's already Ember/Angular on the browser side and Express on the server side. And of course, there's always FBP implementations like JavaFBP and C# FBP.\n5. NoFlo should be in JavaScript: This continues from the previous point.  There is a clear problem space that each new tech attacks. As long as the barrier to entry is low enough and/or the value of using it is high enough, nothing else matters much. You could very well write a NoFlo component in JavaScript and it would work like a charm. The promise of NoFlo is that each module is an isolated codebase that only needs to adhere to a general FBP interface. In theory you could write in C and interact with NoFlo.\nI'm not against using JavaScript. I write JS a whole lot too. And I'm exclusive in the JS ecosystem. There just isn't that much value in converting what already works into JS. What is missing here for NoFlo to take off isn't technology; it's people's habit. We're in the same moment that the C guys are laughing at the \"Write-Once Run-Everywhere\" coffee-sipping guys.\n. Thanks for the great response, @Bartvds! Yea, what you said is absolutely true. Technically CS isn't an issue. I'd say the marketing benefit alone is enough for someone to start an open-source project in JS rather than CS.\nThe decision here is this: if we ditch CS in favor of JS, how much more adoption would we get? The biggest cost that would incur right now is the cost of conversation to JS. Compilers definitely work, but you would want maintainable code, not generated code.\nGiven that there is no cost in potentially breaking things and definitely no \"unlocking of additional features\" by using either language, the only real cost is whether we as a community want to sink in additional dev hours in conversion while there is so much to be built for NoFlo. Wouldn't it be much better use of time if instead of turning a working codebase from one language to another, we create more tutorials, build tools, and other resources while using JavaScript as the language of choice?\n. @CMCDragonkai I don't think anyone would doubt that a JS open-source project would garner more attention. The problem here is how best to spend our resources going forward. Like @Bartvds said, I agree that a complete rewrite is probably not the best idea. Going forward if tutorials and documentation examples could be in JS that'd be the best we can do at this point.\n. Because CoffeeScript's class system is simply a syntactic layer on top of JS' prototypic system, you can easily do this as well:\n``` coffee\nnoflo = require 'noflo'\nmodule.exports = ->\n  c = new noflo.Component\n  c.inPorts.add 'in', (packet, outPorts) ->\n    return unless packet.event is 'data'\n    # Do something with the packet, then\n    outPorts.out.send packet.data\n  c.outPorts.add 'out'\n  c\n```\n... or ...\n``` js\nvar noflo = require('noflo');\nmodule.exports = function() {\n  var c = new noflo.Component();\nc.inPorts.add('in', function(packet, outPorts) {\n    if (packet.event !== 'data')\n      return;\n    // Do something with the packet, then\n    c.outPorts.out.send(packet.data);\n  });\nc.outPorts.add('out');\nreturn c;\n};\n```\nTo be even more elegant, you should theoretically also be able to write:\n``` coffee\nnoflo = require 'noflo'\nmodule.exports = ->\n  new noflo.Component\n    inPorts:\n      # Note that the second argument is component so we can call\n      # component.outPorts later (or anything else in the component)\n      in: (packet, component) ->\n        return unless packet.event is 'data'\n        # Do something with the packet, then\n        component.outPorts.out.send packet.data\n    outPorts:\n      out: new noflo.OutPort\n```\n. I have actually been thinking quite a lot on this one. FBP makes it relatively easy to optimize given computation across processes are pure just like functions in FP. Are you thinking of a small NoFlo runtime or no runtime at all?\n. @bergie Awesome! Exactly what I had been thinking as well. Were you going to start on this any time soon, or this is for the record? This is something that I'm really fascinated with. (And it's also that something that I told you I was waiting for a stable API to work on as a changing API would easily break the compiler :)).\n. @bergie What's the roadmap on this for you guys? After finishing up my NoFlo to-dos, I'd like to chime in if you are starting work on this. Otherwise, I could also put what I have been thinking together just for some ideas?\n. @bergie Great! Before that, let me finish up other NoFlo stuff first... :D\n. @jpaulm Would the compiled version help in running or understanding the program? What I've been thinking is it'd be compiled down to pure JavaScript. It wouldn't look anything related to FBP in any way at all.\n. @jpaulm Ah. Got it. I agree that NoFlo should be able to run locally, and it does, as I'm using it personally. I think you were referring to Flowhub specifically rather than NoFlo? Unfortunately I'm not the right person to ask in that department. Sorry that I couldn't be of help...\n@forresto The photobooth source looks interesting! So currently it simply uses component.io to stitch everything together and you call into it via some events on the page?\nI actually have a question for you and @bergie. There are two things that I am still chewing on before writing a prototype. One is how is non-NoFlo code incorporated. I suppose that is handled by Component.io or Node.js CommonJS. That deserves an entirely separate issue.\nThe second one is how do you guys think on how to initialize a NoFlo program? The demo that you have seems to starting the graph using NoFlo and attaching event handlers to it. On the other hand, I remember Dan said you guys were using React to manipulate DOM. That gave me the impression that the graph should be self-bootstrapped in the sense that there would be a \"start\" IIP that would tell it to set React up and initialize everything.\nIt'd be great if you guys could shed some light on a \"standard\" way (or at least a preferred way) in starting NoFlo as the compiled version should not include the NoFlo runtime and I believe we would want devs to interact with the normal and the compiled versions in the same way.\n. ",
    "sirwobin": "The dataflow-noflo demo looks quite impressive!  That interface is quite familiar; relational data processing products that are very widely used use the same sort interface.  Informatica and SQL Server Information Services come to mind.\n. +1\nAnything that isn't just about the noflo system should be in a different package.\n. Quick question about how to advertise a package's components in the upcoming 0.4 release:\nShould we still put them in package.json under noflo.components?  If so how should we reference them in projects that depend on our components?\nI ask this because I've created an npm called myOrg-topic-libraryName with components in it.  When I depend on this in another package, I create a graph in a .fbp file referencing my components something like this:\n'blah' -> IN ComponentA(myOrg-topic-libraryName/MyComponent)\nComponentA() OUT -> IN ComponentB(myOrg-topic-libraryName/MyOtherComponent)\nThe parsing rules in the new FBP package dont like the hyphens in my package name so this FBP fails with parse errors.  Is FBP going to put name constraints on packages that might be awkward on npm?  Can I alias packages or package components to suit the range of characters allowed in FBP?\nPerhaps you could enable the wiki on this repo and write a quick example?  Alternatively I'll write a quick wiki how-to if you let me know your intended policy and enable the wiki.  Perhaps the wiki might serve as a start to the noflo documentation.\n. Perhaps I'm a bit late to this issue but would like to contribute.\ntl;dr\nNoFlo is glue to make good programmes.  Let's give good tools and support without forcing a structured system that might make NoFlo unattractive or move it too far away from the flexibility that we enjoy in Javascript.  Perhaps let's offer schema checking components in another package.\nImportant issues raised: how to document components for FBP authors who may not be programmers?  How to find available components without reading every npm dependency of noflo?\n\nI'm very fond of node/javascript & other scripting languages precisely because of the flexibility and speed they give us.  If we add the ability to type check inputs and outputs it should be advisory or optional.  If your programmers are of such low quality that they require a B&D language then perhaps you're better off not using Node/JS at all and simply using a B&D language and one of the many fine FBP systems that exist for those languages.\nThere may very well be value in expressing message structure with a schema, whether that's JSON schema or XML schema, YAML, MessagePack and goodness knows how many other information encoding methods that might be introduces in the future.  To incorporate all of those many different flavours, or to be less flexible and prescribe only one type, changes the nature of NoFlo quite substantially.\nPerhaps we can add message schema checking components in a package outside of noflo-core.  Such a module might be attractive at design and testing time but may impose an unacceptable speed penalty on production systems.  If you've tested and designed well then you probably don't need that sort of type/schema system in production anyway.  If you're processing external data then perhaps there's a case for message validation at the very start of a graph but once the starting data is valid and the rest of the flow is well tested, further validation between components isn't desirable.\nIf someone offers a module like node-schema-check with JSONSchemaCheck and XmlSchemaCheck components, that to my mind fits the philosophy of FBP better than integrating type checking into NoFlo.\n\nTo help advance the noflo ecosystem that is forming, now might be a good time to begin a directory of components that we know about.  Perhaps this could live somewhere on noflojs.org?  If component authors are really good with including keywords in their npm packages, we could write a programme to query npm and index components and keywords.  Someone authoring flows in fbp-ui could then type a search phrase to look for a component that fills a spot in a flow they are authoring.  That will really empower noflo users who might otherwise reinvent components that already exist but are undocumented or not easy to find.\nFor that to really work, each component needs to document what it accepts in and what it sends out.  This is where schema documentation would be really helpful.  How should we as programmers write component documentation that makes sense to someone compiling a flow in the future who may not be a component programmer?\n. I actually love the idea of providing easy schema validation for messages.  As long as its optional.  JSON is what I prefer to use too.  :-)\n. ",
    "tomByrer": "TL;DR: Could link colors & connector types be considered to signify data types please?\nI don't know how solidified your are on the GUI, but here is a \"Flow-Programming\" platform I've programmed on for 5 years called FlowStone:\n\nThe colors & symbols on the modules' links and connector points signify what kind of data they carry; blue is for 'streaming DSP' data (usually audio) that is Packed Single Floats (SSE), green is for triggered (on demand) data, the circular (F) green circles are for Floats, (I) Integers, odd-shaped {F} connectors mean is it is a Float-Array, etc.\nIn the picture above I selected the \"Wet+Dry\" module.  Notice how there are extra controls that appear when the module is selected (I'm not suggesting you to add that).  Let's look inside that module:\n\nAs you can see, FlowStone tends to be more of a GUI programming system than NoFlo is, though some direct coding is possible.\nI'm not suggesting you need to rework everything, but I do find the extra colors & connector symbols to be helpful when quickly scanning a program to understand what data is being transferred between modules.  There are also 'empty'/blank connectors so you know when a connector is not active.\nThanks for all your hard work; I'm a KickStarter supporter!\n. Anyone can download a more or less fully functioning copy: http://www.dsprobotics.com/download.php\nYou can download the programs/'schematics' (.fsm) from FlowStone's forum.  The old forum & WIKI has many many .osm schematics.\nI used to be a super-user with SynthMaker (the old version), so let me know if you have any questions!\nEdit:\n\nplatform I've programmed on for 5 years\n\nI did not write the actual platform, just programed on it ;)\n. ",
    "arboleya": "@tomByrer Looks great, I'd like to test it. Any kind of free license for OSS?\n. ",
    "jonnor": "A kickstarter is in progress now: http://www.kickstarter.com/projects/noflo/noflo-development-environment\n. We moved the preview runner build of NoFlo, which include essentially all known components, to https://github.com/noflo/noflo-browser - which deploys to  https://noflojs.org/noflo-browser/everything.js\nWarning: giganormous\n. Hi Henri. I've been playing with a FBP implementation for microcontrollers like Arduino, with integrating with NoFlo in mind: https://github.com/jonnor/microflo (wanted a couple of more things fixed before announcing..)\nIt uses a binary command stream (for effective parsing) based on something like the proposed protocol to load graphs into the runtime. See https://github.com/jonnor/microflo/blob/master/microflo/commandformat.json \nCurrently it can only load from what is baked into the firmware image, but eventually this will happen over serial etc. - and hopefully be possible from NoFlo UI and similar.\nComments:\n- I think that it should be possible to observe a remote graph, and get messages of graph changes without resorting to polling. Is that what you have in mind?\n- Minor: Why not call \"graph\" for \"clear\" or \"reset\"? \n. @bergie Getting together to integrate with the UI would be great! I am in Norway these days, but would like to go to Berlin soon...\n. @rektide I agree that docs would be nice. However, its easy to hook up NoFlo UI to a WebSocket based runtime and see the exact format of the messages described here. I know as I already did it.\nBeware of issue described in https://github.com/noflo/noflo-ui/pull/21 though\n@bergie when implementing support in MicroFlo I found it annoying that the naming conventions for edges are different in the WebSocket protocol compare to the .json format. I ended up normalizing it internally. Any chance of unifying this or do you consider the protocol locked?\n. @bergie Ok, cool.\nI'll try to add subgraph support in MicroFlo at the same time as we define the protocol (issue jonnor/microflo#4).\nI would like it also to be possible for subgraphs (or similar mechanism in the UI) to be able to use different runtimes. Usecase is hetrogenous FBP, where you have a system which may consist of clients (using NoFlo client-side), a server/host (using NoFlo node.js) and microcontrollers/sensors (using MicroFlo). I want to be able to look at my entire system as the interconnect between these different devices/roles, and then be able to drill-down/move-into a specific device/role (and thus runtime) to be able to see and change that part of the system.\n. Agreed with explicit arrays but I'd be wary of using the names \"imports\" and \"exports\". \"inPorts\" and \"outPorts\" would fit the semantics better. If it is imaginable that other things can be exported, perhaps have \"exports\": { \"inports\": [], \"outports\": []} inside the graph JSON.\n. Implementing subgraph components in MicroFlo now, and hit this snag (not a showstopper though).\nMy current thinking is that the EXPORT/INPORT/OUTPORT=foo syntax could be a general attribute/annotation when normalized to JSON.\n. I think the important thing is that it is possible, and clearly communicated, that one can:\n1. Use (embed) NoFlo into a plain JavaScript codebase\n2. Write NoFlo components in plain JavaScript\nAs long as that is the case, the use of Coffeescript for the implementation of the NoFlo framework and existing component-sets is a practical problem only for those who contribute directly to those.\n. Quasi-related to streams (more the general concept of event streams that node.js ones), this is an interesting framework: https://github.com/paldepind/flyd\n. The \"edges\" command also uses \"process\", so that should at least be made consistent.\n. Closing as wont-fix. We've got too many using the FBP protocol as specified now :)\n. https://github.com/noflo/noflo-runtime-webrtc\n. Hi @jpaulm\n\nI had understood that - what I can't find is the actual network definition.\n\nYes, this is noflo/noflo-ui#153\n\nIt also doesn't make sense to me that I have to fire up app.flowhub.io to run my app - in other words, the execute step should be decoupled from the downloading and parsing. You just need to save it somewhere and provide a separate execute engine.\n\nYes, we need to streamline deployment of browser applications (and combined noflo-nodejs + noflo-browser). Right now there is not a good story for running outside the IDE (Flowhub) at all...\nIt should also be possible to debug deployed applications in Flowhub. Need #134 for that\n. In case you missed it, there exists experimental support in grunt-noflo-browser (3 comments up)\n. It was pointed out that all the graph commands should be responded by the same message coming from runtime, so this issue could be invalid. Need to re-check the other commands.\nCurrently NoFlo UI does not enforce this however.\n. Basically all should have specfied replies in the protocol now, and noflo-runtime-base is pretty compliant with this.\nNoFlo UI does not enforce/respect a lot of it, but that is another issue.\n. Needs re-testing.\n. On component classification, these are the ideas I have for MicroFlo. I want to use these to verifiy components against the associated invariants.\n- I/O: has real-world side-effect / external state\n- Pure: not stateful, without side-effects\n- Syncronous: Sends message out as direct result of message in\n- Generator: Creates messages on its own (without requiring input)\n- 1-1: One message out for every message out\n- Deterministic: Same sequence of inputs results in same sequence of outputs\n- State-free: Same input message always results in same output message\n- Real-time/bounded-time: A message in is guaranteed to have its corresponding output within a certain time\n- Cooperative: Yields the compute within a certain time\n. Sourcemaps are also interesting, as they allow exception etc to also refer to the correct place in the code.\n. Is this still relevant?\n. @trustmaster created some sketches/proposals for new Component APIs here: https://gist.github.com/trustmaster/2a292e23e61642fa148d\n. Some quick feedback/idea first. I see that Promises are used in the proposals, which I think is good. I'd be fine with requiring Promises for async stuff (can use promisify function if one doesn't have one already).\nBut why don't we let the NoFlo Component/HelperFoo handle .catch and calling done() - by attaching to the Promise? Less verbose and error-prone, though routing to many outports or doing special things with error becomes hard(er) - is that really important?\n. Another quick one. I think the most classical FBP style component would be to have InPort.read() be a function which takes port name, and return a promise which will resolve when data comes on that inport.\n. @trustmaster OK, fair enough I think. Only the super-classical FBP style is ruled out by such a choice. (...writing more tricky feedback)\n. For more context, we also have some earlier proposals/discussions here:\nhttps://docs.google.com/document/d/1_7ExwbugP8Q8LNaaysRwWxny9sgb9FomXL0Vs8sU0cc/edit#heading=h.ggqvo151ftpf\n. Now for some more tricky/general discussion. I think there are several interface/API-pieces involved here. Primary being: 1) Getting data from input queues 2) When/how to process the collected input data (firing pattern)*.\nThe first has implications only for inside the component, whereas the second also affects the outside world - because the semantics of the component changes. And thus influencing a lot how one programs with NoFlo on the graph level. So I think that is the most critical to get right...\nFor instance, one thing I think is bad right now, is that it is the Component - instead of the graph using it - that decides which ports are Controls (non-triggering) and which are not (triggering). I fear that trying to have a general / very configurable firing pattern mechanism cause such problems to explode.\nSo, can we try to define what kind of firing patterns we think are important to support, and which ones are too esoteric to have first-level support for (the rare cases can use old basic/manual API)?\nI give it a go here. Important:\n- map - takes input on 1 port, transform into something new (or sends same on)\n- combineLast - takes 1 input on each of the N ports, creates something new\n- combineSameRequest - takes 1 input on each of the N ports, matched by IP correlation ID, creates something new\n- more? maybe some sort of splitting?\nNot important:\n- Sending errors on arbitrary outports. I think all failures, should go a port name/type established by convention, like error.\n- Matching on groups instead of correlation id. If wanting this, use a dedicated component, which changes the correlation ID to be that of group[N].\n* the last part of Component API, declaring information about component for outside world (ports etc) is not up for discussion now/here. As I see it, it mostly works fine.\n. Who is the component developer to say that database must always be a Control. What if I (the graph developer, and user of the component) want to shard database access, say based on user groups. Then I need to specify a which database to use per request?\n. Database components would just take a DB instance (or connection handle), and call some method on it. I don't see why it would require special-casing.\nWith current-style Control handling, I do not see how we can provide facilities to treat them as inputs.\nWe don't have a way to let data on control use matching on correlation ids, like inputs have?\n. Using RxJS on that level, where inports subscribe directly to outports, would take us even further away from the bounded-queues concept of FBP. I really think we should move towards having queues more observable, not less.\n. Is this issue still present?\n. Current thinking is to allow a list (or map?) of component sets.\nEach set has properties\n- \"libraryName\": \"mylib\" (prefix used for lib/Foo in full component names)\n- \"runtimeType\": \"javafbp\" / \"microflo\" / \"noflo-browser\"\n- \"baseDir\": \"src/somedir/components/\"\n- \"components\": { \"MyComponent\": \"sourcecode.java\", ... } paths are relative to baseDir\n. Component sets should also have properties:\n- \"icon\": \"android\" , default icon for component set (overridable by individual component in runtime specific way)\nOn fbp.json toplevel\n- \"main\": \"path-to-main-graph.json\". In the future we might extend this to optionally be a list\nSimilarly to component sets, we need graph sets. They would have same properties except \"components\" would be \"graphs\"\n. @oleksandr Yeah, I think we should avoid separate component/graph keys. Currently I'm thinking to just have .json as source imply that it is a subgraph. Anything else is a component\n. We could optionally allow .fbp in the graphs list too, sure. But I don't want to mandate it, as one can always \"compile\" .fbp into the canonical json representaton.\n. I'm leaning towards having ids for edges as metadata, at least in the protocol.\nSomewhat related: noflo/noflo-ui#293\n. @sjaakiejj You could have a component which sends a message on outport when it receives an IIP in, and then monitor the outport. Attach this IIP at the end of the connections list.\nI'm not sure if we have a better way right now. What is your usecase?\n. Ran into the same issue in noflo-runtime-msgflo now, trying to set/override some 'IIPs' after a NoFlo component has been started.\nDue to the way Network.sendInitials() do work async, there is no way to know when all IIPs have been sent...\n. Needs re-testing.\n. This would force the API call to always be syncronous, it would not be possible to introduce async behavior.\n. Only breaks if you're doing the work that depends on nfGraph not inside the callback...\nBut yes, if sync is desirable, dedicated loadJSONSync method is my preference.\n. Don't think we're gonna do something about this. Closing\n. @robhawkes Interesting. Can you run some tests with multiple listeners? 3 and 10 for instance?\n. With 10 the differences between current and EventEmitter3 are much smaller, but EventEmitter3 is still significantly faster.\n. @ensonic What happens with dynamically registered components, like when editing in Flowhub? Is there risk of stale cached .js in that case?\n. Browserify is experimental, will be that way until someone gives it another couple of days of dedicated time.\n. noflo-nodejs now has essentially all of the commonly used functionality.\nMissing is the create-component and interactive mode, and I think we should keep it that way. I'm not aware of anyone who uses it.\nInteractive/REPL mode would be better to do using the FBP protocol (maybe using fbp-protocol-client, cause then it would work with any FBP runtime (NoFlo, MicroFlo, JavaFBP, imgflo) - and be network transparent.\n. Need to decide on deprecation/migration strategy for the noflo executable.\nNormally I'd say make noflo (in a transition period) depend on noflo-nodejs, and call that executable while printing out a message. But this will probably introduce a circular dependency(?).\nCould maybe do some hack where noflo executable will npm install noflo-nodejs? \n. What are you trying to achieve with for/while loop?\nThese constructs are used for many different purposes in imperative programming (mapping a set of values to another set, filtering a set with a predicate, reduce a set down to a single value).\n. Ah, yes, that is yet another use of for loops in imperative code: a (ordered) sequence of actions on some data. Or on multiple pieces of data, or in some cases on no data (sideeffects only).\nAssuming a static or semi-static number of actions, this would be done in dataflow/FBP by:\nLet Action1 send data on an outport out when its done with its work. \nConnect that to the inport which starts the work of Action2.\nContinue in this manner until all actions are done.\nIf you want to do this in a loop, then you let ActionN send its output back to\nAction1 again. If you want to do this conditionally, you use a router/filter type component which only sends it back in case the condition matches.\n. The API was specced some years after the JSON graph format.\nReason it was split out in the API I suspect is that often or nearly always there is different code paths that need to be triggered depending on if something is an IIP or a connection. A bit cleaner\nwith dedicated messages in that case.\nEvery implementation I know of checks whether something is an IIP when iterating the connections in the JSON graph format.\n. Hi, sorry for the late reply.\nYou can either implement the FBP protocol (typically over WebSockets) in your backend, and then Flowhub/noflo-ui directly against it.\nAlternatively, you can use the underlying editor library the-graph and then communicate with your backend however you'd like.\n. Yes, it has been broken since forever. Install noflo and component libs using NPM/component.io\n. Here is a helper grunt task: https://github.com/noflo/grunt-noflo-browser\n. I'm generally pro this suggestion. It will make group forwarding just-work in most cases (just manipulate ip.data) instead of having to use some special magic (like WirePattern).\nI think it is critical that we have compatibility though, at least in a transition phase. Flag-day migration don't work.\n. A graph becomes a new component. The exported ports of the graph becomes the externally visible ports. You can use this in another graph by referring to it by name.\nIn Flowhub, you can also group nodes, but this is just a visual queue ('these are related'), not a way to reuse functionality.\n. Apart from all the noise in the commits, looks good.\nTested it locally on my Arch Linux system with nodejs updated to 4.1.2 - all tests passed.\n. noflo and all NoFlo component libraries which noflo-ui depends on have now been fixed. So noflo-ui builds again: https://travis-ci.org/noflo/noflo-ui/builds/101126378\n. Hm, it could be that this particular Error had no stack because it came from C++ (native node.js module).\n. No, when caught manually inside the component, it did have stack.\n. @bergie how did you generate that diagram?\n. Isn't this done now in fbp-mmanifest? If not, what more needs to be done?\n. Most of the time a component should either provide output, or send error. Therefore I propose a node.js style send(err, outputMap).\n. I don't think ordered: true makes sense as a default. In fact I'm not sure it makes sense to provide as a component-level feature at all.\nIn classical FBP, there is a single thread executing inside a component, and it can only do one thing at a time. Ordering here comes natural (and it does have some benefits). If one wants concurrency, one instantiate several components, each handling a request at a time.\nHowever, in NoFlo each component executes a (currently boundless) number of input/activations concurrently. Having the component try to enforce order will just make\n1. The latency of results on subsequent inputs be increased to the maximum of the inputs before it. This is particularly damaging in timeout/error situations, say one request takes 100x time the other ones -> everything else gets delayed that amount the same.\n2. Related, the memory needed will pile up uneccesarily\nOrdering like this is in most node.js and browser applications not-necessary. And if it is needed in a particular application, I think it can, and should be handled there - using by wiring in a component.\n. Buffer bounds can go into a separate PR.\n. Re 2:\nAre rolled back transactions common, or do they only happen in error conditions or rare conflicts due to concurrency?\nIf so I'm tempted to say just let it float around until the process dies/is restarted.\nAlternatively, when a scope 'is completed', ie it has produced results or errored - then one could maybe remove all unclaimed IPs belonging to that scope. But this requires a notion of network/execution completion beyond that of counting IPs.\n. How is this typically done in Node.js ?\n. @bergie are we still reading from package.json / component.json if there is no fbp.json manifest file?\n. Does this change anything for browser, or just for node.js?\n. Missing documentation on how one creates an fbp.json manifest for a project.\nAlso, are only apps required to have fbp.json manifests? Or should component libraries have them too?\n. If we require fbp.json and don't read from package.json this is a breaking change. This cannot be introduced in a patch version bump. At minimum needs to be 0.7.x, (if we followed semver this would be a major bump).\n. The question about whether component libraries also need to generate fbp.json files is unanswered.\n. @bergie should grunt-noflo-manifest generate a fbp.json file when noflo version is 0.7.x (or just always, since old noflo just won't care)? Then we don't need to change every single project that uses noflo, as most have grunt-noflo-manifest in there already...\n. We're gonna need something just like grunt-noflo-manifest to integrate into the Gruntfile anyway. So why not spare the trouble of having to change one grunt task for another in each and every NoFlo project there is?\n. Yes and no. This PR breaks every single project which uses NoFlo. A plan for unbreaking them is needed for this to be a responsible change, imo.\n. When there is no fbp.json file, how are components found on node.js then?\n. @bergie That I understand. But how is that setup in all the existing projects? Practically no existing projects run fbp-manifest anywhere? Is there something I'm missing?\n. Ok\n. Do we abort on first failure?\nIs the Error object the original one caused by component failure?\nShouldn't the error contain the names of component(s) which failed? Or at least we print the stacktrace?\n. Ok\n. Can we please make this default for map-style components somehow?\n. Most are also deterministic and state-free.\n. forwardBrackets:\n    'in': 'out'\n    'in': 'error'\nThis could be default, with 'in' being auto-detected to be first non-control inport, and 'out' to be the first outport.\nIf you don't want it, use forwardBrackets: {}. Or set it to be complex config you want.\nAlternatively\nforwardBrackets:\n    'in': ['out', 'error']\n. The problem is how this interacts with async IP processing. Ordering wrt to the 'contained' IPs should be maintained for bracket IPs to make sense.\n(aside, this is why I was so happy to see groups being on the IP object, and then dissapointed when all that went away, cause it feels like we've effectively just renamed groups to brackets without solving any of the deep issues...)\n. Yes, hopefully we'll use it less now. But for instance, what is the pattern we use for a case like the following:\n- Make an HTTP request to get a collection\n- Fetch data over HTTP for each item in the collection\n- For each data, do a couple different asyncronous work (maybe process using 3 different algorithms)\n- When all the work for one piece of data is completed, write the combined results\nThis needs to be able to merge/collate based on which data a particular packet belongs to.\nIn NoFlo 0.6 we'd use groups for this. What do we do now?\n. But the way we make components right now, SomeOperation will not forward collectionId and collectionLength with the IPs. To require each operation used with a Map / Reduce (or something similar) to be aware of the particular IP properties to pass seems at best tedious.\nThis is why I wanted map-style components to pass the input IP onwards, and just replace .data property with the result data. Then all metadata on the IP is preserved, without requiring knowledge of what other things are on the IP.\n. This code allows to use NoFlo in Webpack builds for Node.js (browser not tested).\nHere are the basic snippets of the webpack config needed:\nmodule: {\n    noParse: [\n      /loader\\/NodeJs/,\n      /loader\\/ComponentIo/\n    ]\n  }\nplugins: [\n    new webpack.NormalModuleReplacementPlugin(/loader\\/register/,\n                                              require.resolve('./staticloader'))\n  ]\nexternals: {\n    'noflo': 'commonjs noflo'\n  }\n. PR in #469\n. In general I think this kind of refactoring - where the changes in tests, should also work with the existing setup - should be done in a separate PR. Then the new things which actually change stuff, like going from component.io to webpack be in a next one (probably based on same).\nBut changes here are really minor, so guess it is fine.\n. @bergie just making sure: getsource/setsource should still work for component.io builds, right?\n. If we chose to do this then I think:\n1) We need to add JSON schema type validation. The types that exist here are simply not expressive enough to be very useful in a non-trivial program.\n2) Strictness should be configurable on the program level (topmost Network), and set by the one who runs the program/network. Not set inside individual components\n3) We should plan to migrate quickly to having strictness enabled by default (maybe with option to opt-out)\nCC @bergie @trustmaster \n. Sending data which does not match the declared (failed post-condition) it the fault of the component which sends. This should probably become a process-error?\nReceiving data which does not conform of the requirements on the inport (failed pre-condition) is the fault of the sender. The receiving component should then send to error port?\n. Related, JSON schema types in FBP protocol. https://github.com/flowbased/fbp-protocol/issues/15\n. The noflo directory you are in, it is an empty directory, right? In which case this behavior is exactly as expected...\n. npm install noflo --save means \"install noflo and mark it as a dependecy of my project\". You don't seem to have a package.json for your project, hence the warnings. Do npm init first. Should maybe name the directory that better reflects what it contains, like \"first-noflo-project\".\n. Closing as there does not seem to be an issue here (see above comments). Reopen if you think there is.\n. What benefits would it have? \nMaintaining two implementations of a code base  is a lot of extra work, large risk of incompatibilities, and user confusion (should I use this or that version?). \n. If people interested in Typescript would like to contribute to NoFlo I would recommend adding Typescript annotations to the interfaces. And document how to make components in Typescript. \n. Ideally make a PR that puts it under documentation on noflojs.org, then it will appear on the main website>\nhttps://github.com/noflo/noflo.github.io/tree/master/documentation/_posts\n. Right now you would have to tear it down explicitly, by removing all existing nodes, then adding your changes.\nI agree that there should be a destroy/remove message in the FBP protocol, which would remove a graph.\n. NoFlo UI uses component:source for that, and basically all runtimes implement that. Even though it should just use the normal graph building parts: https://github.com/noflo/noflo-ui/issues/390\n. That is exactly how it is used, see the linked issue.\n. Looking at the Component code there does not seem to be an easy way.\nWhy do you want to do this? It is generally bad practice. A component should ideally not care about anything in the outside world that is not passed on its input ports. This includes the instance name.\n. So you're building a UI for your program? And each process which has UI representation talks to the WebSocket server?\nSome alternate approaches would be:\nDedicated WebSocket sender\nHave a dedicated component, with a single instance, for sending to webUI. Use one input port, with a descriptive name, per piece of data you want to send. Connect these ports to the outports of the processes which produce the data. Benefits:\n- Only one component needs to know about UI/WebSocket, the rest of the program remains agnostic.\n- Encourages that all state/data needed for the UI is sent on outports of components. This is good practice for future extensability and for testability.\nUse FBP runtime protocol\nDon't put any WebSocket code into components/network. Instead mount the graph in a runtime, like noflo-nodejs, and let the UI connect to the WebSocket interface and talk on the FBP runtime protocol.\nUse network:data to follow changes of data on internal ports, or runtime:packet to receive/send on exported ports. Benefits:\n- The entire program is agnostic to the UI/WebSocket. Can add UIs to existing programs without modifying them.\nNote that I don't do a lot of UI programming with NoFlo/FBP, so take these more as ideas than canon :)\n. Or the component:source message in the FBP runtime protocol. http://flowbased.github.io/fbp-protocol#source\n. It is defined for nodes, connections and exported ports in the graph, but not for components or component ports it seems. \nWhat kind of data do you want/need in there? \nNeed an issue/PR on the protocol spec, \nhttps://github.com/flowbased/fbp-protocol\nand implement it in noflo/noflo-runtime-base\n. Reading data from server is likely an async operation? I.e. not completed by time the WirePattern process function returns. For such cases you must use async: true and call the done callback when done. Otherwise WirePattern cannot disconnect correctly for you...\n. Also, if the inport is what is not receiving a disconnect() then the problem likely exists in the upstream component connected to that port.\n. Is there data coming in on all 7 ports of QueryDataCollectionBulk? Which inport(s) is it that you don't see disconnects on?\n. I think that the Journal code should go with it, as that is also separate from the runtime-aspects, and only depends on Graph. And is used in non-NoFlo-specfic places like Flowhub.. @bergie there is not much point to that, it is fine where it is?. In fact the thing discussed here (lets call it fbp-graph) will likely depend on fbp, for parsing the DSL. So it would be problematic (circular) if fbp had to depend on fbp-graph in order to make use of the schema.. @bergie nice. Will you make a PR which uses that library in NoFlo? Otherwise the two will diverge very quickly.... Semi-related, can we kill the sync mode for Process API? I don't think a sync special-case is really worth it. Call continuation is common both in nodejs and browser, and can be used in sync and async case. Not good that we don't have test coverage for our component/graph loading, as that is quite key functionality.. Was commented out in d1a55d3d778ca1afb484fda1ce8727033efec721. The test was introduced in 311d724f2907db15a0df92f4c40f077f2f45675f and probably its expectations are not right for current behavior. Flowhub is an IDE. It's an alternative to using your text editor + terminal. Has graph/component editing tools (incl live programming), debugging support etc. \nThe integration in noflo-nodejs is for discovery. It is opt-out, but should be opt-in:  https://github.com/noflo/noflo-nodejs/issues/45. Why all the changes to the tests in spec/Helpers.coffee?. > Some tests were kind of wrong (doing async things in sync wirepattern) that only worked because WirePattern didn't actually care.\nThere will very likely be components like these in the wild, especially since async is opt-in.\nIn general we're very likely to have components, graphs and programs, which rely on WirePattern \"bugs\" to function correctly. This makes me very skeptical to forcing use of this new WirePattern implementation. I think we should at least add a way to opt-out, \"give me the old WirePattern\". Ideally settable for a whole process (for instance via envvar, module-level variable), so one can quickly test whether old/new WirePattern is cause of behavior changes. And per-component, so that one can isolate only the broken component.. What do you mean \"shutting down the graph\"? There is no shutdown/stop for a graph (nor is there a start). It is a Component. Which may be a direct instance/subclass if the thing is defined in code. Or if the loaded thing is a graph, then its a noflo.components.Graph instance (which subclasses Component). This is different from a noflo.Graph (which is just a description of a graph, doesnt/cannot be started).\nAnd to answer the questions. Yes, component.shutdown for a subgraph causes this.network.stop. Looking at the code, it does not unset/unreference this.network though.... Yes. There is at least one webservice which creates a new Graph instance per HTTP request, and I have not heard of any such problems there.\nIf you see something else will probably need a small executable example of the problem to be able to help. Btw, Chrome devtools heap debugger can be very helpful for checking memory issues. Can attach to the built-in Node.js debugger. No, this has not been implemented yet, which is why this issue is still open.\nThe code in noflo-runtime-base has an API, you can try to use that. Looking at the implementation will basically show what mechanisms NoFlo exposes that can be used. Note the major limitation of not collecting from subgraphs, https://github.com/noflo/noflo-runtime-base/issues/32. Nice, fixes the issue of IIP-changes not triggering when live-programming NoFlo in browser (using noflo-runtime-webrtc) for me. I do expect that same issue existed also for noflo-nodejs. One little odd thing is that in Flowhub the connection still goes to \"not started\" after a network execution (sometimes flashes by \"finished\" briefly). But doesn't seem to impact the functionality any. And it was like that before also.. @bergie fixed now. I looked over the removals in #555 - one comment there. Why is this required now?\n. Is this and the below error handling needed here, or just added since passed over this area of code?\n. This throw is dead code? After a return\n. I don't think we should do this implicitly on readCache(). Only noflo-cache-preheat should write it\n. Probably unintentional ;)\n. unintentional\n. unintentional\n. unintentional\n. unintentional\n. unintentional\n. unintentional\n. unintentional\n. deserves comment why skipped\n. deserves comment why skipped\n. Like you broke the test here? Or it was broken in first place? Should be fixed anyhow\n. Same, think this check is broken\n. Each function should have this comments, and it should also include mentioned of the license and copyright.\n. So checking that port had input data is now mandatory, even for the simplest cases? . Do we really want this to be public API? . Other places this is fbpGraph.graph.loadFile?. Hm, will this break compatibility? If people have an existing nofloGraph.Graph that they are passing in?. Same here, isn't. Might be best to make the imports be fbpGraph = require('fbp-graph').graph ?. ... assuming that the code uses the exact same NoFlo version? But I guess that may have been a requirement before also.. This deletes options.process afterwards, leading me to think using it does not work at all? If so this is not a depreciation warning but an Error (functional is already removed, not scheduled to be removed) . Usage example should be JavaScript instead of CoffeeScript ?. Need a changelog entry for asComponent feature. Worthy of a comment to explain that this is due to missing ES6 support. So we can remove when we can assume that. This only works for functions that don't take any arguments? Test description suggests otherwise... And considering this limination, isn't it almost better if it just throws Error explaining that function arguments cant be introspected - and one should create a wrapper function with arguments?. Hm... This will make a component interface change between ES6->ES5. In ES6 defaults with be presents, input is not required. But when transpiling to ES5 no defaults, and must send inputs in the graph, otherwise network will not start?. Tempted to say that we should not support this feature.... Ok. With docs its OK. Is this component name duplicated from other tests? Should be something like 'return-null' ?. ",
    "jerryjj": "\n\"On longer term, NoFlo should have some component repositories API for knowing what components are available\".\n\nTrue\n. ",
    "rybesh": "I don't see a doc task in the Cakefile. \n. Sweet. They look great!\n. ",
    "travisbot": "This pull request passes (merged 4df50bbf into 5f4fcfa7).\n. This pull request passes (merged bb020123 into 5f4fcfa7).\n. This pull request passes (merged ff096199 into 5f4fcfa7).\n. This pull request passes (merged 7f68b389 into 5f4fcfa7).\n. This pull request passes (merged 12c1ec38 into 5f4fcfa7).\n. This pull request passes (merged 707a274c into 5f4fcfa7).\n. This pull request passes (merged 8cbfff26 into 5f4fcfa7).\n. This pull request passes (merged 19caeb65 into 5f4fcfa7).\n. This pull request passes (merged 06f38ada into 5f4fcfa7).\n. ",
    "subtleGradient": ":+1: \n. https://github.com/substack/stream-handbook\nIt'd be epic if a through stream could be used as a NoFlo node.\n. http://browserify.org/ gives you Node.js streams in the browser. Search for \"stream\" here: http://browserify.org/search\n. Another thing to look at related to this: https://github.com/dominictarr/pull-stream\n. Have you seen browserify?\n. QC uses a push/pull model.\nA QC patch execute method is given the current patch time and a GL context. It can then read from its in ports and write to its out ports.\nA QCPatch (or a subclass) may also have its own subgraph. It can call executeChildren.\nA Macro Patch in QC is simply a regular QCPatch with children. It executes its children once when it itself is executed.\nAn iterator is a QCPatch subclass. It accepts an iterations index from an in post and then executes its children that many times in its execution method.\nAn entire QC composition is the same as a single Macro Patch.\n. The z-index layer number on blue parches in QC is really just the execution order. When a QCPatch executes its subpatches, it does so in execution order as defined by the layer number on each blue patch.\nA blue patch then pulls the values of its in ports. Nothing executes unless it's a blue patch or connected to a blue patch.\nBlue patches cannot have out ports. They are purely consumers only. \nPurple patches often execute on idle, pulling in data from hardware like the mouse or the network. When one of its output ports is updated, the runtime marks dirty every node in the graph that is connected to it so that they dump their cache and execute again when their own out ports are next needed.\n. A push only model usually causes havok and poor performance in the DOM.\nThe trick is to figure out a way to separate all the reading and writing to and from the DOM in at least two phases no more frequently than in a requestAnimationFrame loop.\nSee how MontageJS does it. Their bindings system is almost flow based programming, but not quite.\n. It may be as simple as making a node 'class' that has a frame number input and buffers all its other inputs until the frame number changes. By default plug the frame number up to a single requestAnimationFrame loop node with a frame number out port.\nThat way all the event driven push stuff doesn't cause any havok in the DOM and everything happens at the right time.\nAlso, you could choose to manage time separately for one part of the graph if you want to do something custom.\nThis doesn't solve the problem of something like canvas drawing instruction execution order though.\n. There are a million frameworks for building UI components. Ideally NoFlo would work with them all\n. Whew, good. I'm really excited!\n. :+1: \n. :+1: * :100: \n. There are lots and lots of ways to do it. The essential thing is that at the design level, the implementation details are cleanly abstracted away and encapsulated in the patches. You may want to have a DOM+CSS renderer, but you may want to swap it out for Canvas or WebGL or something else. You need to be able to make the decision about renderer completely separately from the composition itself.\nAs long as all the implementations of \"Sprite\" use the same interface, you could easily swap implementations by sed 's/CSSDOMSprite/WebGLSprite/g'\n. Ideally there would be a way to write compositions (graphs) that depend on a specific component interface. That interface could then have many implementations.\ne.g.\nThere could (should?) be a generic Layer component with\u2026\n- visible\n- size (width & height)\n- position (x, y & z)\n- 3d matrix transform (translation, scale, rotation, skew, \u2026)\n- opacity\n- content (color / image data )\n- cropChildren\n- parentLayer\nTons of compositions are already built using this generic component (e.g. Facebook Home prototypes).\nYou should be able to drop in one of many implementations of this component without modifying your compositions at all.\ne.g. Many implementations each using Canvas, WebGL or CSS3DOM. Three.js implements those renderers, but so do a bunch of other toolkits.\n. Ideally things like Layer would be generic and could support swapping out the underlying implementation without modifying the graph source itself.\ne.g. Run the Noflo network in a web worker and render using WebGL or CSS or Canvas or whatever.\nOr run the Noflo network in a headless JS context and use a custom native compositing engine.\nMinimal dependencies FTW\n. How do you do that with json only?\n. I'm trying to convert existing Quartz Composer qtz graphs. These files use a lot of subgraphs for each composition. Exploding a single qtz into whole bunch of separate JSON files is going to be a huge pain to maintain.\nThe Meemoo Dataflow editor ui allows for editing subgraphs within the same composition. \n. I think that would work, yeah!\n. Using Noflo should require:\n1. Want it\n2. Get it\n3. Use it\nIf you add more steps than that, you lose people.\nComponent.io is for people who want everything to work this way. That's the whole point. Requiring a build step is totally counter to that.\nIf you're worried about cluttering the commit history, maybe keep component compatible builds in a separate repo?\n. Most of the overhead of typical JavaScript UI is in inefficient use of the DOM.\nWith everything being so nicely encapsulated with Noflo, you should be able to swap out the implementation of your DOM patches for more efficient versions if necessary without modifying the rest of your network. That's after profiling of course.\n. I vote for camelCasePortNames.\n. The main usecase of having NoFlo on a CDN is for people to try it out with the most seamless startup process possible (include a script tag, paste in some demo code, done). This is especially important for sites like JSFiddle.net that let you create runnable demos in a few seconds and share them. So, I recommend adding to cdnjs the NoFlo core as well as the minimum number of components necessary to get a few demos running.\n. What about jsx? Also, ES6 and ES7 are called ES2015 now AFAIK.\nAtom uses babel if it sees \"use babel\" in the code. Cf. http://blog.atom.io/2015/02/04/built-in-6to5.html\n. ",
    "ThomasDeutsch": "For the goal to implement NoFlo for other platforms, it might be a good idea to use ZeroMQ or RabbitMQ instead of node-streams.\nThere are a LOT of bindings for ZeroMQ: http://zeromq.org/bindings:_start\nWhat is ZeroMQ?   http://zeromq.org/intro:read-the-manual\nPresentation: ZeroMQ with node.js and coffeescript: http://vimeo.com/27245799\n. I would like to add a point to the discussion. The \"Types of Transport\"\nAt one point, there will be the need for different types of transport between the components.\nExample:\nFor components on the same machine, i would like to use Inter-Process or Process-to-Process communication for performance or security reasons, and when i want to talk to other machines, i may choose TCP or broadcast it via UDP. \nNow to my point:\nIt will be difficult to develop a hole System via NoFlo with more then one machine.\n(because of:  deployment, monitoring, different languages or OS, ... not impossible but very difficult )\nSo, i think that NoFlo needs to make clear that the components need to be on the same machine.\nThose IPC or InProc communications between components can be implemented with ZeroMQ.\nFor the communication with other machines, there could be Gateways, like:\n- a Gateway to talk to remote ZeroMQ / NoFlo components or networks.\n- To Redis, WebRTC, WebSockets, ... \n. ",
    "xcambar": "@bergle Streams can be used and piped and everything in the browser .\n@substack's browserify project (which is the speaker in the video above) makes use of streams in the browser for the packages that require it.\nThat could be a good move for NoFlo\n. Actually, I already did some work on the PR! The process is more tedious than difficult.\nI've also seen (after starting) those 2 discussions:\n- https://github.com/noflo/noflo/issues/63#issuecomment-16584623\n- http://bergie.iki.fi/blog/sharing-javascript-libraries-node-browser/#comment-860542387\nIt's not worth it to spend some time on porting NoFlo to browserify if your opinion about it is already strong enough to reject the PR no matter what.\nYou do not seem that opinionated about browserify when reading the discussions, but I'd rather be sure about that before going any further! I'm sure you understand.\n. ",
    "elf-pavlik": "newer video where @substack talks about modularity and making modules work both in node and in a browser: http://youtu.be/DCQNm6yiZh0\n. @xcambar where do I find your work on PR, can you maybe just submit it in its current state? This way we can discuss it together and I could also help with getting it working...\n. ",
    "elhakimz": "I had commenting  noflo.js generated in bin, now it's run.. but I cant make noflo become a http service. \n(function() {\n  var cli, noflo, nofloRoot, path;\nnofloRoot = \"\" + __dirname + \"/..\";\nnoflo = require(\"noflo\");\ncli = require(\"cli\");\npath = require(\"path\");\ncli.enable(\"help\");\ncli.enable(\"version\");\ncli.enable(\"glob\");\n//cli.enable(\"daemon\");     //COMMENTED\ncli.setApp(\"\" + nofloRoot + \"/package.json\");\n. ",
    "d4tocchini": "+1\n. Awesome!\n. You're the man @bergie!\n. on a side note, @bergie, here's that remix of your springy drag demo that works with mouse and touch.   I just hacked @desandro's Draggabilly into a NoFlo component\n. Front-end FBP is a pandora's box, there are too many ways of doing things!  From the looks of the hacky work arounds in those Facebook Home Quartz Composer Tutorials, some best practices are badly needed...\nShould we have fat components with many inports/outports, or thin ones that pipe sprites around and add functionality ie \"decorator pattern\"?  @subtleGradient in #67 you seem to be implying fat, generic ones.  \nShouldn't Sprite inports also be exposed as exports?  I found it irritating in QC that Sprites had no outports.  It would be nice to be able to pipe size & position in and out of Sprites to capture more dynamic layout logic without subgraphing or additional components.  Does this cross the encapsulation line?  Or, maybe it's not in place because circular dependencies arise?  In which case, we can bust out some Cassowary! \n. ooh...\n. ",
    "Bartvds": "I was browsing noflo on npm and see some of the packages don't have their package.json use a repository element to point back to their github repos. This makes it cumbersome to browse the implementations.\n. Some random inspiration: \nJSONSchema is a classic way to define JavaScript data formats and could even be embedded as it's a JSON format.\nTypeScript's declaration format (used to define type info for existing JavaScript code) is really versatile. It's mostly used for interactive code but can define pure data as well. See the repo at DefinitelyTyped for examples. Very definitve but cannot easily be embedded.\n. Does noflo support sending complex and interactive objects (with functions, prototype chain etc) by design? \nOr is there a focus on JSON-like primitive structures? What about primitive but non-JSON types like Buffers and TypedArrays?\nI don't have an opinion or need for it but this has some implications so I was wondering if this is defined.\nIf it's plain-objects-only you could easily serialize everything but having full objects is useful for passing around wrappers and class-instances between components.\nMaybe should this should also be a field on the component (per port)? \nBecause if you know this upfront you can filter connections that encode well over runtime boundaries (threads, processes, client/server etc) and even (live-)split certain sub-graphs to different shards (with component auto-install and good standard serialisation pipes that'd be sweet :).\n. This project looks interesting as well: resource / resources. The resources could maybe mesh into noflo's model, and adapt easily as they have a focus on introspection.\nThey're also looking into object descriptors and consider jsonscheme: https://github.com/bigcompany/resources/issues/41\n. I agree with most of this very elaborate reply but I would like to clarify why I think json-schema might be a good standard to define the formats.\nBecause noflo is javascript based it seems a good choice to use a javascript oriented type definition, which of course is not limited to validating JSON but can check any javascript object (as JSON represents any of the basic javascript values). There are validators that work in any environment that can run javascript.\nJson-schema has the extra benefit of being an IETF standard so there are plenty validators, schema creators, mock-data generators and various additional toolings available.\nLike you said it's not needed to run typechecking continuously but it's very useful to have it at the external edges or be able to activate it when testing and debugging. Because json is so ubiquitous there is support for json-schema in many different languages and systems which would improve interoperability.\nAlso the current drafts have build-in support for using URI's to identify and retrieve (sub)schema's which would make it easy to interoperate components from different authors. There could be a central repos on noflo.org with commonly used schemas for developers to use and ensure compatibility.\nAnd of course schema's are in itself basic javascript object structures, so can be parsed into a user-friendly display format using common web development techniques.\n. Defining types by URI (IRI) would be great if you can supply a set of common types and setup a community pool for complex types; to facilitate interop.\nIf the descriptor is sufficiently detailed (JSON-Schema?) you could do automated testing and compatibility matching (check for possibility of negative values etc), even do optional filtering of input data, default values, debugging, fuzz testing etc. \nIf data is described by a common set of URI's the user can also pool type converters (ship basic ones). The UI tool can then be extra clever in hinting edges (eg: a uint32 can be a rgba32 but not a Person) by inserting a converter. \n. +1 On more examples and demos. It would be great to be able to pull up some graphs for simple flows and even some real world tasks and compare the interactive visual to the FBP output.\n. FYI: If you need Windows based node.js CI testing there is now http://www.appveyor.com, it is very similar to Travis-CI except it is focussed on Microsoft platforms (but with node and github and a nice .yml setup etc).\n. If I (as lurker) may pitch in on this as ittouches my interest in\ntechnology adoption:\nSummary: as technology CofffeeScript is a valid choice but from\ncommunity-adoption / 'marketing' standpoint it is far from ideal and might\nbe a net. negative effect on adoption from regular (JS) programmers.\n\nFor noflo maintainers it could be good to note that in the JS/code\ncommunity as a whole there is a considerable sub-section with a very strong\nbias against CofffeeScript. I see this on blogs and communities like reddit\nor hackernews all the time. Regardless if this is (partially) valid or not,\nor whether it is just people-being-people, it is a real phenomenon. Many of\nthese people are very worthy programmers you'd otherwise want to be a part\nof your ecosystem .\nNoflo and FBP is already a controversial technology to adopt, we've all\nseen the reactions on the public announcements. Again, not all of it is\nvalid and much is just FUD or preconception or just bias against FBP in\ngeneral. It is hard to overcome this, I'm sure you know this better then I.\n\nBut my point is: by using CoffeeScript as main language noflo does take a\nextra penalty in adoption rate.\n\nIf a potential user is already a bit insecure then a controversial choice\nsuch as CoffeeScript as core language is an easy argument to dismiss the\nwhole of noflo system. Of course that is not a good way to judge a\ntechnology, but then, many people are like that (we're entering the realm\nof psychology here).\nFrom a technological standpoint I can see how CoffeeScript should not be an\nissue, but from a purely 'marketing' viewpoint it is a risk.\nIt makes the whole noflo ecosystem even more 'alien' to the regular\nJavaScript programmers then it already is. Using a controversial technology\nmight loose them on the first few moments, while if they would not have\n'bounced' on the implementation they might have stuck around long enough to\novercome their bias against FBP.\n\nI personally don't really favour CoffeeScript (many reasons like OP\ndescribed) but I can see how it is attractive (it looks very clean in small\ncomponents).\nBut still, personally I'd never use it for a Open Source project, simply\nbecause I would prefer not to alienate the support from all the people\nwho'd walk away or be biased because they hate CS.\nAll those users who will never send Pull Request or make extensions or find\nbugs or talk positive about this to friends, simply because an\ninter-changeable technology choice. To put it very bluntly, it is a waste\nof a percentage of potential.\nI love noflo though :)\nMy penny,\nB.\n. Sure, but this:\n\n.. for the implementation of the NoFlo framework and existing\ncomponent-sets is a practical problem only for those who contribute\ndirectly to those.\n\nThat is exactly the point.\nA percentage of people might not contribute. People might not start\nbuilding plugins because there is a threshold to reading the existing code.\nThey might not investigate bugs in other modules as much, or send in\nextension PRs.\n2013/11/26 Jon Nordby notifications@github.com\n\nI the important thing is that it is possible, and clearly communicated,\nthat one can:\n1. Use (embed) NoFlo into a plain JavaScript codebase\n2. Write NoFlo components in plain JavaScript\nAs long as that is the case, the use of Coffeescript for the\nimplementation of the NoFlo framework and existing component-sets is a\npractical problem only for those who contribute directly to those.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/119#issuecomment-29341187\n.\n. Kenneth,\n\nhow much penalty there is, and how much that weights against all the added\nvalue you mention is the big question.\nI have no idea how to rate such things. Rewrites are never attractive, that\nis for sure. But the CS bias issue is real in one grade or another.\nI'm not saying you must convert (not at all as it is a classic bad idea to\nrewrite (Nestscape....)), but I guess a slow migration could help, and at\nleast making sure all examples are in plain JS. (CS developers  can do JS,\nwhile many JS can't be bothered to do CS).\nFor the core code I don't know, maybe not worth it. But on the other hand,\nit will only get worse as more time is invested in the codebase and the\nunknown-ratio of other devs bounce off.\nAnd of course I don't know how CS is rated by non JS developers (those\ncoming from other fields just for the modern FBP). I believe it is pretty\npopular by Ruby and Python folks coming to JS (which is of course why it\nexists).\n2013/11/27 Kenneth Kan notifications@github.com\n\nThanks for the great response, @Bartvds https://github.com/Bartvds!\nYea, what you said is absolutely true. Technically CS isn't an issue. I'd\nsay the marketing benefit alone is enough for someone to start an\nopen-source project in JS rather than CS.\nThe decision here is this: if we ditch CS in favor of JS, how much more\nadoption would we get? The biggest cost that would incur right now is the\ncost of conversation to JS. Compilers definitely work, but you would want\nmaintainable code, not generated code.\nGiven that there is no cost in potentially breaking things and definitely\nno \"unlocking of additional features\" by using either language, the only\nreal cost is whether we as a community want to sink in additional dev hours\nin conversion while there is so much to be built for NoFlo. Wouldn't it be\nmuch better use of time if instead of turning a working codebase from one\nlanguage to another, we create more tutorials, build tools, and other\nresources while using JavaScript as the language of choice?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/119#issuecomment-29360832\n.\n. \n",
    "forresto": "Why are groups in Graph.coffee? For fbp -> json parsing?\n. Cool, is there a demo?\n. Smooth.\n. Wondering why the Layer component would need the Three.js dependency. Our Layer could just be a div with CSS3 transforms. I even got 4-corner pinning to work in Meemoo with a little crazy matrix math.\n. Meemoo.org modules have data types (int, float, string, color, image), and doesn't let you connect ports that don't make sense. A little while ago I made a hack so that numbers can go into string ports without conversion, and anything can hit \"bang\" ports.\nLately I have been thinking that something like Pure Data's message or NoFlo's array port would be nice for building objects and pulling values from objects. It would look something like: \n[pointer event module] -> [ \"pointer 1\" ] -> [ \"x\" ] \nto extract the x from an object like:\n{\n  \"pointer 1\" : {\"x\": 20, \"y\": 30},\n  \"pointer 2\" : {\"x\": 20, \"y\": 30}\n}\n(quotes are message modules that pull values from the objects sent)\nor\n[ input string \"first\"] -,\n[ input string \"last\"]   -> [obj] ->  [ template \"hello {{first}} {{last}}\" ]\nThe advantage in Pure Data is extremely compact modules, because all ports are hidden and need to be defined with message modules like this. I'd like to find a balance between showing every possible input and showing none.\n(Apologies if this is tangential.)\n. That's a really good idea. I did some very basic autotranslate in meemoo,\nand it was helpful to not always need a toString component.\nOn Aug 3, 2013 6:38 PM, \"Irakli Gozalishvili\" notifications@github.com\nwrote:\n\nElm has a very simple but powerful type system:\nhttp://elm-lang.org/learn/Records.elm\nIt's also a lot more simplistic than JSON Schema that feels little\noverkill IMO. This type system also reminds me of a structs.jshttps://github.com/dherman/structs.jsthat is a prototype implementation of the ECMAScript Binary\nData http://wiki.ecmascript.org/doku.php?id=harmony:binary_data API.\nI'd be interested in working with elm to define a JSON based format for\nstructural type vocabulary and in adding support for it in elm.\nNote that with declarative type vocabulary it would be possible to also\ngenerate port adapters that could translate from string or object to any\ndeclared type. I also think that would be extremely useful for the GUI to\nprovide some guidance in what can interact with what.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/84#issuecomment-22063049\n.\n. I feel like component.io components shouldn't need plugins or a build process. Couldn't there be a built version in the repo?\n. component-coffee didn't work on the first try. Messing with various build processes has me siding with TJ.\n. How does this affect the UI issue https://github.com/forresto/dataflow-noflo/issues/2 ?\n. The iframe element could qualify as an invisible window, but they actually run in the same thread as the parent window. Workers are the way to do heavy lifting in another thread. \n. Should this throw be taken out?\n\nhttps://github.com/noflo/noflo/blob/master/src/lib/Port.coffee#L17\nattach: (socket) ->\n    throw new Error \"#{@name}: Socket already attached #{@socket.getId()} - #{socket.getId()}\" if @isAttached()\n. I like Ken's suggestion, but we also want to define port metadata in c.inPorts.add. So \nc.inPorts.add(id, metadata, dataHandler)\n?\n. Seems to have taking care of that issue.\nI made some more performance reorganization with the edge inspector logs over here... https://github.com/meemoo/dataflow/issues/66\n. In JS, objects and arrays going through a graph are references. If they need to be cloned, that should be a specific component. \nIn the photobooth example, I'm getting DOM elements with the dom/GetElement component. It isn't possible to clone DOM element objects, and I don't think I should need the Split component to send the element to multiple nodes.\n. HTML element objects exist in one place: the DOM. When I'm passing the reference around the graph, components are doing things to them (adding a child, changing class, listening for clicks, extracting pixels from a canvas, etc.). \n\nIt doesn't add anything to the graph to require that reference to get split before going to other components.\nThis might be a special case.\n. Maybe port names will be ok with letters other than a-z?\n\"\u65e5\u672c\u8a9e\".toLowerCase()\n// \"\u65e5\u672c\u8a9e\"\n\"\u00c4\u00c4\u00c4\".toLowerCase()\n// \"\u00e4\u00e4\u00e4\"\n. Would be nice if we didn't have to .split('.') the private to parse the JSON, and separate the node and port. #140 \n. So in loadJSON\nif graph.exports instanceof Array\n  # old style\nelse \n  # it should be an object with .inports and .outports arrays\nAnd toJSON() will export that format:\nexports: {\n   inports: [\n     {\n       public: 'in',\n       process: 'nodeID',\n       port: 'portid',\n       metadata: {x:0,y:0}\n     }\n   ],\n   outports: []\n}\nLook good?\n. i18n would be cool on the library level, to replace component/port\nnames/descriptions. Scratch does something like that, and it's cool that\n8-year-olds can see the concepts in their own languages.\n. Also good for reducing if @outPorts.x.isAttached() boilerplate.\n. Seems easier for things to match between JSON structure & UI. If groups are tree-like layers, then I'd vote for a change. If groups are many-to-many tags, the current system works, but seems less useful in the UI.\nWe need a flat representation of a tree. Groups need a unique key in order to nest them inside each other. How should this work?\n{\n  \"name\": \"countdown\",\n  \"id\": \"g_countdown\",\n  \"nodes\": [\"interaction/ListenMouse_1u0rk\", \"strings/SendString_zry4n\", ...],\n  \"metadata\": {}\n},\n{\n  \"name\": \"save\",\n  \"id\": \"g_save\",\n  \"nodes\": [\"core/MakeFunction_t17n\", \"core/Split_xyb8x\", ...],\n  \"metadata\": {\n    \"description\": \"click save, run countdown, make jpg from canvas\",\n    \"parent\": \"g_countdown\"\n  }\n},\n... seems fragile. \nIf groups were an object:\n\"g_countdown\": {\n  \"name\": \"countdown\",\n  \"nodes\": [\"interaction/ListenMouse_1u0rk\", \"strings/SendString_zry4n\", ...],\n  \"metadata\": {}\n},\n\"g_save\": {\n  \"name\": \"save\",\n  \"nodes\": [\"core/MakeFunction_t17n\", \"core/Split_xyb8x\", ...],\n  \"metadata\": {\n    \"description\": \"click save, run countdown, make jpg from canvas\",\n    \"parent\": \"g_countdown\"\n  }\n},\n... we could also take nodes out of the groups and each node could have the group id in metadata.\n. For many-to-many groups, a metadata.keywords array in the process would be a better mapping.\n. That's what I'm doing... groups need an id to reference a parent group so they can be hacked to work hierarchically in the UI.\nShould I make a new layers object that works as I need?\n. Explain?\nThey are required in some form to do collapsable groups with autolayout. \nAlso for the photoshop layer style view.\n. I want to bump this up for https://github.com/automata/noflo-canvas/issues/1 (scratch own itch prioritization).\nI guess we need a Graph method to change index? Should it be a property on the edge (not metadata, since it changes how the graph works)? Should it also sort the edges, for compatibility and legibility?\n. @bergie could you prioritize this in noflo so I can make it happen in the-graph?\nAlso, is there a way that I can query noflo if a port is addressable? I guess with if edge.src.index? I could infer it, but it would be nice to get before any edges are added.\n. graph.setNodeMetadata() emits changeNode\ngraph.setEdgeMetadata() emits changeEdge\nhttps://github.com/noflo/noflo/commit/cf6bbc9004fc3d5cd7edab801bb105f1c8535333\n. @jonnor, we should connect about this and https://github.com/the-grid/the-graph/issues/71\n. I'll try to make a test then fix it.\n. Schema.org looks interesting.\nSeriously/source's input accepts HTML elements: image, video, or canvas. So we would want to specify some kind of hierarchy there: object / htmlelement / [img, video, canvas] ... \nJust hinting htmlelement will be helpful.\n. Do we have a dropdown widget in the node inspector for enum ports? I can add that as a new issue if no.\n. Wait, why is the node key in export.private toLowerCase?\n. We could make this simpler when we fix https://github.com/noflo/noflo/issues/118 ... separate process and port on the private.\n. How about this?\ntoRemove = []\nfor initializer in @initializers\n  if initializer.to.node is node.id\n    toRemove.push initializer\nfor initializer in toRemove\n  @removeInitial initializer.to.node, initializer.to.port\n. Bug when there are multiple IIPs to the same port:\n```\n  removeInitial: (node, port) ->\n    @checkTransactionStart()\nfor edge, index in @initializers\n  continue unless edge\n  if edge.to.node is node and edge.to.port is port\n    @emit 'removeInitial', edge\n    @initializers.splice index, 1\n\n@checkTransactionEnd()\n\n```\nfix:\n```\n  removeInitial: (node, port) ->\n    @checkTransactionStart()\ntoRemove = []\ntoKeep = []\nfor edge, index in @initializers\n  if edge.to.node is node and edge.to.port is port\n    toRemove.push edge\n  else\n    toKeep.push edge\n@initializers = toKeep\nfor edge in toRemove\n  @emit 'removeInitial', edge\n\n@checkTransactionEnd()\n\n```\n?\n. Do we use the underloaded form for removeEdge anywhere? If not, this would fix the bug and make things simpler:\ntoRemove = []\n    toKeep = []\n    for edge,index in @edges\n      if edge.from.node is node and edge.from.port is port and edge.to.port is node2 and edge.to.port is port2\n        toRemove.push edge\n      else\n        toKeep.push edge\n    @edges = toKeep\n    for edge in toRemove\n      @emit 'removeEdge', edge\n\nedit: found https://github.com/noflo/noflo/blob/master/src/lib/shell.coffee#L103\n. Nice. Could required default to false, and only throw if set to true?\n. Back to the original issue, thinking about it from the UI angle: we would\nlike to edit a running network without errors on every packet.\nMaybe when the network is running inside the UI, instead of throwing the\nnetwork could send a message to the UI to visually highlight the port.\n. :thumbsup: \n@jpaulm would appreciate this as well :smile: \n. @jpaulm I'm still not 100% clear on what you want to accomplish. We should get on the same page.\nWhen you say\n\nrunning http://app.flowhub.io with my own network\n\ndoes that mean that you're running noflo-ui from localhost, or that app.flowhub.io is communicating with a network running on your local machine? Or?\n\nParenthetically, it generates the following messages on the JS console, before it even starts:\n\nAll of those are just warnings that don't break anything.\n\nAlso, I would like to report that my network...\n\nWe can't see a project with a link like that. It is actually stored in a database in your local browser. You can set up app.flowhub.io to connect with github if you want to publish a project.\n\ndata-reactid=\".0.1.0.0.3.$core/Kick_ul80z.4.$...\n\nThis the SVG code that renders the graph view, generated by the JS in the-grid/the-graph ... safe to ignore.\n\nNow, for main question of compiling a client-side NoFlo app to pure JS, I've been hesitant to do much documentation there, because it is tricky and fragile. The photobooth demo is the only time I've done it. Here is what the built JS looks like for that: http://flowhub.io/demo/photobooth/build/flowhub-photobooth.js\nWhen this issue is complete, it will be easier. :rainbow: \n\nEdit: just found your request on the FBP group: https://groups.google.com/d/msg/flow-based-programming/3Y3bOQz5_Ko/RV2mfUI13RUJ ... this shouldn't be hard.\n. Try app.html \n. I think the \"gathering of different input\" would be useful for most of the noflo-canvas components as well. If, for example, MakePoint is going to get a new x and y from component Zed:\n1. Zed sends beginGroup for everything that it will send in this frame\n2. MakePoint sees x and y getting beginGroup\n3. MakePoint gets data on y, knows to wait for x\n4. MakePoint gets data on x, processes and sends result\n(As it is now, I'm not doing that flow control, so there are wasted compute() calls.)\n. Could be {name: val, name2: val2} ... Then if values is an object use those or array keep as it works now. \n. Couldn't we automate it on our own machine by changing the version in each package.json?\n. Could do it the same way as nodes are done from the UI now: the automatic id, then if you give it a name the id becomes that string, unless it isn't unique, then append _random.\nedge:\n  id:\n  src:\n  tgt:\n  metadata:\n    label:\n    route:\n. @bergie for the UI it would be needed in Graph. Also, that id won't be unique in some situations with addressable ports.\n. The way that I'm using it above will break if it becomes async some day as well. Could we have separate sync/async methods?\n. @ComFreek issue should be fixed now.\n. ~~Doesn't the return short-circuit that situation? https://github.com/noflo/noflo/blob/74a554774c1d97e08f6d98b950f9959980fe4f48/src/lib/Graph.coffee#L151~~ edit: nevermind, reread and confirmed bug in noflo-ui.\n(And hi from StackOverflow yesterday... small world :wink:)\n. ",
    "Marak": "@Bartvds - To be clear, the resource engine already has full support for JSON-Schema. \nIssue https://github.com/bigcompany/resources/issues/41 refers to the specific situation where we are creating a meta-resource to describe resources ( making resources self-hosted ) \n. ",
    "Gozala": "I kind of agree that forcing everyone to use a type system may harm (although more I think of interactions between components more I feel type system would actually help)\nAlthough completely optional type system and enforcing contracts by guards on components would not really work well either IMO. What I think would be the best of both worlds is to have base type system of values:\nstring, number, any\nAnd a way of defining structural types (think haskell) that can be enforced at the level of graphs. That way you could have strictly typed graphs / components and a very loose component graphs that kind of deal with whatever comes in. Probably set of adapter components also could be generated that'll basically take any data and attempt to match it over specific type so that untyped and typed components could be connected.\n. Elm has a very simple but powerful type system:\nhttp://elm-lang.org/learn/Records.elm\nIt's also a lot more simplistic than JSON Schema that feels little overkill IMO. This type system also reminds me of a structs.js that is a prototype implementation of the ECMAScript Binary Data API.\nI'd be interested in working with elm to define a JSON based format for structural type vocabulary and in adding support for it in elm.\nNote that with declarative type vocabulary it would be possible to also generate port adapters that could translate from string or object to any declared type. I also think that would be extremely useful for the GUI to provide some guidance in what can interact with what.\n. This is first draft of what came out of my and @evancz's collaboration on this subject:\nhttp://typed-json.org/\n. Note: noflo could recognize it's own primitive type: http://noflojs.org/#any that can be connected to anything else, although more I think about it more I feel structured types is a way to go.\n. So I have update my implementation to keep it show what happens under the hood:\nhttps://gist.github.com/Gozala/6129164\nThis implementation attempts to model components in an FRP style where function arguments are signals and result is also signal that in addition implements noflo API.\nCurrently implementation makes use of toSignal(port) and toPort(signal) APIs and does manual wiring. It could be a lot more efficient if I just implemented my custom OutputSignalPort and InputSignalPort types that would implement both signal and Port APIs. But I got lost when trying to figure out what methods are relevant for which direction (input/output) and when they're called, but hopefully with core teams help that'll be easy enough.\nMy suggestion would be to split Port implementation into three:\nInputPort\nOutputPort\nDuplexPort\nAlthough some inline comments about when this method is called and by whom would have helped a lot.\nI think I'd also would like to make another helper function like lift that would just take combiner function and do all the other wiring for you:\n``` js\nvar myComponent = lift(function(size, email) {\n  int: size\n  string: email\n  string: url:\nreturn gravatar.url(email, {s: size})\n})\n``\n. Oh there's one more thing in FRP is build around the idea of time-varying values, called signals. They can be transformed via regularmap, filter, ...APIs, merged bylift`-ing function that takes params to a function that takes signals producing those params.\nThe only thing that does not quite maps well is that signals in FRP always have value that makes combine like functions redundant and equivalent of lift since one no longer needs to wait for initial value on all signals to start combining. Usually that's achieved by a signal API that can only be created with an initial state.\nI wonder if it would make sense for noflo to have somewhat similar constraint.\n. @bergie I'm afraid this is still unclear, I really wish InputPort & OuputPort were different classes, would have being a lot more clear that way. So here's where I am at now with my use case:\n``` js\nfunction ensureConnected(signal) {\n  if (!signal.next) throw new Error(\"No connection available\")\n  signal.connect()\n}\nfunction InputSignal() {\n  this.queue = []\n}\n// Type will implements implements FRP\n// signal interface.\ninputSignal = InputSignalPort.prototype\nSignal.extend(InputSignal, function(signal, next) {\n  signal.next = next\n})\n// Type also implements noflo.Port interface so\n// that it can be exposed by noflo components.\ninputSignal = InputSignal.prototype\ninputSignal.attach = function(socket) {\n  // Do I need to implement this method for inputs ??\n  throw Error(\"Does not implemnets\")\n}\ninputSignal.connect = function(x) {\n  // On new connection send a meta packet.\n  this.next(withMeta(x, { connect: true }))\n}\ninputSignal.beginGroup = function(group) {\n  ensureConnected(this)\n  this.next(withMeta(group, { startgroup: true }))\n}\ninputSignal.send = function(data) {\n  ensureConnected(this)\n  return next(data)\n}\nsignalPort.endGroup = function(group) {\n  ensureConnected(this)\n  next(withMeta(group, { endgroup: true }))\n}\nsignalPort.disconnect = function() {\n  ensureConnected(this)\n  next(withMeta(null, { disconnect: true }))\n}\nsignalPort.detach = function() {\n  // Not sure if it is relevant\n  if (this.next) next(withMeta(null, { detach: true }))\n  this.next = null\n}\nSignal.extend(InputSignalPort, function(signal, next) {\n  signal.next = next\n})\n```\nStill not sure if I'm supposed to implement EventEmitter interface or attach and detach methods or if noflo is just going to call other port methods for me.\n. ",
    "tj": "I don't completely get the point personally, if you're doing releases with build files, why not just add ./components? then component(1) doesn't have to do anything special :D \n. IMO inheriting is still confusing (and likely unnecessary, since it could be declarative), and anti-js (speaking as a non-coffeescript user) but that's just my .02\n. ",
    "jpaulm": "Hi @bergie, we discussed this a bit during your visit, but maybe I didn't verbalize clearly why I was uncomfortable with your definition of regular ports on the output side.  Granted, my view of regular ports on the input side is the same as yours - in fact, in my FBP implementations I can also treat an element of an input array port as a \"regular\" port (in your sense) - I assume you do too!  The problem arises on the output side, as my FBP implementations allow very complex tree structures to be sent and received just like simple IPs, so doing automatic cloning could result in a very expensive \"deep\" copy (which has to be supported by the FBP infrastructure).  Besides, you can always insert a Copy process into the network, which has the advantage that it makes the designer think about whether s/he really wants to do the copy!  Of course, the other option is not to support tree structures, or not to support them passing between processes...  Banning trees would have the advantage of making input and output symmetrical, but I find trees a very useful feature (even if infrequently used)!  As always, there are trade-offs.  Just my two-cents' worth!  All the best, P.\n. Hi @bergie!  You are of course right when you are talking about \"simple\" IPs - OTOH I was talking about \"tree\" structures, where the programmer can build any type of tree using a mechanism similar to \"attach\", \"detach\".  For a description, see http://www.jpaulmorrison.com/fbp/tree.shtml (this chapter hasn't been changed in the 2nd edition).  The line you quote in your note just says \" @socket.send data\", which sort of implies to me that \"send\" takes an arbitrary data structure, encapsulates it and sends it on.  I know we both use the term Information Packet, but I am wondering if there is a slight difference in how we think about them!  Apparently there is a function called JS_malloc - do you use that?\nAlso I just wanted to pick up on @kenhkan's comment about no longer needing Merge - multiple output ports feeding one regular port or array port element happens on a \"first-come, first-serve\" basis, and avoids the possibility of deadlock.  You actually cannot do this using separate array port elements - OTOH the latter are essential for more \"interesting\" merges such as round-robin merges, Collate, etc., but network topologies using them are of course vulnerable to deadlocks, so the network designer has to use a bit more care!\n. Hi @kenhkan thanks for the welcome! I just lost a long comment, which is probably for the best, so this one will be shorter!  I will make a bunch of separate posts...\nThe big confusion in my mind seems to me to be described in your paragraph that says\n\nlet's say there are two IPs being sent on two different out-ports into an in-port, the first IP being sent actually must reach the end of the entire graph before the second IP hits the receiving in-port. JS's limit in this case nicely fits FBP's requirement.\n\nI don't understand this or see why this is necessary.  What is JS's limit?  As I understand it, Node.js is a green thread implementation, as was my first implementation (AMPS) and my C++ one (all over the floor right now!).  If you look at \n\nit's not clear to me how this would work given @kenhkan's paragraph above - but then, as I said, you guys are going to have to educate me a lot!  :-)  Sorry also to be a bit rushed! \n. Sorry, guys!  I'm a simple soul and am having a lot of trouble getting my head around this! \n@kenhkan said in his note\n\nTesting_2 calls Copy, which calls RandomDelay#1, and so on. This means that Discard has to return the call and let the stack rewind before Copy can call (i.e. send to) RandomDelay#2.\n\nThe word \"call\" puts up red flags for me!  This approach just seems way too complicated!  And, no, it rather defeats the purpose of my example to replace LoadBalance with Copy (the former has state, while the latter doesn't require any!)  \nIMHO coroutines are much simpler - and you can read the whole book using that mental model and never run into anything that is hard to visualize or implement!  Henri and I discussed JS coroutines, and he told me that they won't be available to users for a long time, so you would probably have an easier time using a native interface.  My first C++ implementation used a 7-statement Assembler exit to do stack-switching, and then they came out with fibers, so I didn't even need that!  \nJust doing a quick Google search, I found http://www.gwtproject.org/doc/latest/DevGuideCodingBasicsJSNI.html, or http://docs.oracle.com/javase/6/docs/technotes/guides/scripting/programmer_guide/#jstojava - or Rhino - have you taken a look at any of these?  And yes, I do realize that some of the existing code would have to be rewritten, but I think you would find it would go very fast!  My suspicion (and I may be wrong) is that the existing solution is getting more and more complex, and is running into (or will run into) more and more hidden beartraps... Please prove me wrong!  \nHope I don't get anyone upset at me  :-(\n. On an earlier topic, I am still concerned about \"trees\".  @kenhkan said\n\nFor one, objects/hash/dictionaries/\"trees\" are all the same thing in JS and are treated more or less the same as a number or a string (well, technically they get passed by reference, which leads to the problem of cloning that I'm describing below). That's why in noflo, @socket.send data is completely ok since JS essentially sees them all the same way.\n\nI  think that Java and C# work the same way too... but, if you allow the programmer to build trees dynamically, you still have to walk the tree if you need to make a clone of it.  In our implementations of FBP, we can receive a tree and then send it once, but any copies would have to be built using a deep copy.  If you are proposing to include cloning logic in \"send\" (not sure), then the tree structure must be visible to the infrastructure.  Or, as I said, and I think @kenhkan agreed, just build a (more or less generalized) process which can clone trees!  I guess I just feel that automatic cloning is dangerous... and unnecessary!  BTW If you send copies of an IP off in multiple directions, in our experience it is very expensive (and deadlock-prone) to try to combine them later!  We almost never did that - you are much more likely to output derived copies of the incoming IPs - which means using different ports, or different elements of an array port!\n. Hi @kenhkan , I'm almost sorry you agree with me - I hoped I was wrong! :-)  So you guys are between a rock and hard place, as the Americans say.  The question then becomes: how much useful function can be built using the current noflo approach - and, from my (selfish) POV, how much do we have to distort the basic FBP concepts to do it.  If it ever comes to a vote, given my success at migrating FBP concepts from one platform to another, without changing the mental image, I would vote to put more work into finding a mixed-language solution...  I cannot believe this is insoluble!  I don't even see why speed is a problem - if I wanted to use noflo to handle huge amounts of data, I would probably go to Java (which is pretty universal and has hardware assist on some of the big number-crunchers), or even C++, which is getting pretty close to machine language.\nIt has always been a goal of mine to be able to build a network that comprises processes written in different languages, so I think we really should try to come up with a mix of languages that can do the job - rather than trying to do everything in JS...  e.g. networks and subnets and some components in noflo, other components in other languages, and multithreading support in some language that supports red threads (as well as green).  That would also give better utilization of multiple processors, I believe...\nFinally, you said\n\nThe current roadmap of noflo is to make it portable so that it can run even in browsers. FFI dependencies would render that impossible.\n\nAssuming that FFI is not Fatal familial insomnia, I don't get that!  Surely most servers support Java, so we should be able to use that as part of the mix.  If Java is still too slow, maybe we can use C++ multithreading as an even lower level of infrastructure...\nLet's continue this discussion!\n. Hi @kenhkan and @bergie - haven't heard back from either of you yet!  I think we need to pursue this...  I have just written a program which multithreads JS running under JavaFBP - it took me _about 1/2 hour to write_, including reading the web page on calling JS from Java.  Very simple and IMHO this solution lets you leverage the advantages of JavaFBP as well as those of JS.  Here is what http://docs.oracle.com/javase/6/docs/technotes/guides/scripting/programmer_guide/#jstojava says about combining Java and JS:\n\n\nConvenience: Most scripting languages are dynamically typed. You can usually create new variables without declaring the variable type, and you can reuse variables to store objects of different types. Also, scripting languages tend to perform many type conversions automatically, for example, converting the number 10 to the text \"10\" as necessary.\nDeveloping rapid prototypes: You can avoid the edit-compile-run cycle and just use edit-run!\nApplication extension/customization: You can \"externalize\" parts of your application - like configuration scripts, business logic/rules and math expressions for financial applications.\n\n\nAnd I think this is true for this combination - in spades!  \nGranted, my first \"JS component\" is only one input and one output, so we have a lot of smart architecting to do yet, but the process of building this test was fast and painless... plus I got real multiprocessor multithreading \"for free\" - I actually used one JavaFBP component and one JS program twice!  \nOf course, if we go this route, it doesn't invalidate any of the good work on UIs that you guys have done. And yes, we may have to rewrite some components, but better to bite the bullet now than after NoFlo has spread worldwide! \nIt may be obvious to you guys why this won't work, but I can't see it!  Let's discuss!\nBest regards,\nPaul\n. Hi @kenhkan, no problem - parties are cool!  I see your comment about FFI (I did figure out what it stood for :-)  ) , but again why can't we use Java plug-ins - I know Firefox supports that - see https://support.mozilla.org/en-US/kb/how-to-enable-java-if-its-been-blocked - and I assume other browsers use something similar.  I have also used JWS to run a stand-alone Java program remotely, so I'm obviously missing something...?\nNo, actually my major concern is that in an earlier note you said\n\nTesting_2 calls Copy, which calls RandomDelay#1, and so on. This means that Discard has to return the call and let the stack rewind before Copy can call (i.e. send to) RandomDelay#2.\n\nIMHO you cannot build a robust FBP application using calls - period!  FBP processes have state - this is exactly where the power of FBP comes from, and I think you guys are trying to somehow manage without it!  I just think that is a mine-field!\nSo I need to know where this restriction come from - or maybe you guys could consider narrowing the marketplace to achieve a more robust architecture... ?\n. Aha, @kenhkan ! I can even see how you jumped from what I said to race conditions!  But no, I am not concerned about race conditions!  Something much more fundamental: co routines are not the same as sub routines - the former are cooperative, the latter hierarchical!  In your chunk of text that I quoted in my last note, you use the word \"call\" 4 times.  IMO that is not FBP (or at least not FBP concepts), and FBP cannot be built on a basis of one coroutine call ing the next.  However, maybe there is some way Node.js does handle suspension of a coroutine, so what I really need to do is play with a simple working network - perhaps the one whose diagram I put up in an earlier post...  I also need to know if Node.js is standard JS or did they add some stuff to make JS asynchronous - I can't tell from the documentation I have...?  TIA\n. Hi @kenhkan,\n\nThis turns out to be a philosophical issue that is way out of my expertise.\n\nI doubt it!  If you have read my book (or at least the first 1/3!), I suspect you have as much expertise as anyone else!  Seriously,  it is really a matter of providing the developer with an industrial model of data processing - multiple engines running in parallel, with data passing between them.  \"Coroutine\" is IMO an all-embracing term, but this can be implemented using green threads, red threads, or some hybrid.  When I heard about Node.js' event queue, I thought this might be like green threads - maybe I have to do more reading...\n\nNode.js isn't \"standard\" JS. Or I should say, Node.js isn't even a dialect of JS\n\nIf we are not using standard JS, why do you say we have to use standard JS elsewhere?!\n\n[JS] started out as more or less an event-driven scripting language as part of Netscape. \n\nin which case, we may not even need Node.js...  However I see the big problem with pure event-driven is how do you maintain \"state\" in a process?  E.g. how do you implement a counter? \n\nPerhaps we can slip an external dependency in somewhere like you've suggested. If that could be done, that would be perfect as that really solves the issue that you raised.\n\nThat sounds much better!  Java with JS seems to me to be a very exciting combination, and seems at first blush to solve a number of these problems - but maybe there are other combinations that would work OK too.  How do we get this alternative out on the table? \n. Hi guys, I just saw @kenhkan's post  from a few  days ago.  Picking up on his comment\n\nAssuming that the FIFO issue that @jpaulm raised isn't an issue (this is my understanding for now), a Port and an ArrayPort basically do the exact same thing except the programmer can address individual \"sub-port\" with an ArrayPort. If that's the case, why do we even have two different types of Port?\n\n1) What FIFO issue did I raise?!  Sorry, couldn't find it!\n2) I was looking at the JavaFBP code, and saw that Collate, for example, has to ask how many elements an array port has.  Collate originally collated two streams, but then we saw that it can be generalized very naturally to handle any number of input streams - or just one.  The size of its input array port is determined by the diagram - so the first thing Collate does when starting up is to ask how many input streams are being fed into it.  A non-array port doesn't have to ask this (even though it can be processed as an array with only one element), so array vs. non-array should really be part of the external spec of the component.\n. Hi @kenhkan, lots of points... \n1) parallel.js seems like it's specialized for doing parallel calculations on numeric data arrays - I note they mention Map/Reduce - but child_process seems promising.  Pitfalls of course, as always  - see http://stackoverflow.com/questions/13371113/how-can-i-execute-a-node-js-module-as-a-child-process-of-a-node-js-program.\n2)  Thanks for the long dissertation on JS dialects, but that wasn't my point.  In an earlier note, you say\n\n... on the browser you simply can't have dependencies that are not within the standard specification of JavaScript. \n\nI'll try to rephrase my question: if you allow Node.js on modern browsers, which you say is not part of JS proper (if I understood you correctly), and presumably requires some kind of special (non-JS) software to run it, why isn't it just as easy to include some Java code, or even Python, or in fact code in any language that supports multithreading and can communicate with JS?  I just picked Java because I already have a multithreading version of Java available.  JavaFBP is an implementation of pure FBP and you can have separate JS programs running in any number of JavaFBP processes without any distortion of FBP concepts.  \nI note we haven't heard back from @bergie on this issue - feedback would be appreciated, Henri!\n3) \"Any variable you declare that is not local to a function retains its state across events.\"\nGaaah!  That's called global storage, and is an absolute no-no!  That's really going back to the bad old days - global storage is one of the main things that makes programs hard to maintain, and that experienced programmers try to minimize.  One of the major advantages of FBP is that it makes most global storage unnecessary!\n4)  I find myself wondering at times whether you (@kenhkan) have read my book - if not, it would help a lot if you could read, say, the first 1/3 of the book, so we are not comparing apples and oranges!  There seem to be too many cases where you and I are coming from different viewpoints - FBP is a new/old paradigm, and it is quite different from conventional programming.\nThe other thing I would find useful is if you could point me at the code for a simple FBP app, such as Read -> Count -> Write .\nRegards to you both,\nPaul\n. 1. Are you saying that child_process is not part of standard JS?  Wonder why not?\n2.  Are you saying that Node.js doesn't support server side?  Then what does noflo use when running on servers?  I know that JavaFBP/JS hybrid runs on the client (coz I whipped that up a few days ago), and should be able to run on the server, perhaps using JWS...?    I should probably test that...\n3. Can noflo support a count component without using global storage?  I am afraid I didn't understand your answer...\n4. Tsk, tsk! :-)  I also would like FBP users to be able to take advantage of JS - maybe that's not the same thing as what you said...?  I think you are trying to force FBP into a JS mould, whereas for me JS is just another language, which IMO is not particularly well-adapted for the job!  Tell me again why we are bothering...?\n5. I looked at linecount - that's just the network definition, which is language-independent.  What I guess I need to see is all the code, esp. the component code!  If by DSL you mean \"domain-specific language\", FBP isn't one - in fact, if you take a look at the Google group, you will see the opinion stated recently that it isn't even a language!  See https://groups.google.com/forum/#!topic/flow-based-programming/EKWlkOGNDLI\n5.1.  Actually, maybe we should be having this discussion on the Google group - some very bright individuals hang out there! \n@bergie, it's time you stepped in!  I'd really like to get your feedback on this conversation...!\n. My last post seems to have gotten lost.  Just wanted to say that I assumed you and @bergie were collaborating on this - I now think your position is closer to mine, so we should probably let @bergie put some of these issues into perspective for us!  \nI also wondered what you meant when you said\n\nJS is what we have\n\nIts main appeal seems to be that it is an interpreter, so it's quick to write and execute - but interpreters are easy to write, and I think I'd have much more fun writing one that fits well with the FBP philosophy - instead of dragging JS kicking and screaming into the new world!   \nI will stop for now, and let @bergie try to describe his vision for us!\nRegards,\nPaul\n. Thanks, @bergie, that helps!  Just reread The Universal Runtime, and you quote Steve Yegge - http://steve-yegge.blogspot.ca/2007/02/next-big-language.html - I don't know what NBL turned out to be, but in Steve's article it sure as heck doesn't sound like JavaScript!   I still think we have to get really subversive and wean people off this messianic belief that one language will do everything!  \na) under FBP, every process can be written in the language that fits that particular need\nb) I've run into languages, e.g. SNOBOL, which look at the world in a very different but perfectly valid way - and there is no way they can be fitted into a conventional language.\nThat said, you have certainly done a super job of getting JS to be FBP-like, but I still think a combination of JS with JavaFBP or maybe one of the Python pipe languages - or any other language which does multithreading and can talk to JS -  would be a better fit!\nRegards,\nPaul\nPS Don't know why he thinks NBL has to have C[++] syntax - C[++] syntax sucks!  And C is at the wrong level for application work - unless you use it as a base for FBP, in which case it becomes much more interesting!\n. Thanks, @kenhkan,  actually that also helps!  Of course, the fact that browsers support JS \"out of the box\" explains quite well the fact that JS is such a limited language, and @bergie deserves a lot of credit for having been able to make it sit up and do tricks!  That of course doesn't mean that one should (just joking, I think!).  \nWhich reminds me of the joke about why you shouldn't spend effort on training a pig to sing - it frustrates the trainer, and irritates the pig!\nAt this point I can't really see anything much I can do to help!  However, I will be watching this space with interest!\nBest wishes to both of you!\nPaul\n. Excellent bunch of recent posts from @bergie and @kenhkan.  I agree totally with @bergie's suggestions about compatibility.  I will be starting to work shortly on a generator for .fbp in DrawFBP - just to round out that graphics tool...\nOne comment by @kenhkan  which caught my attention: \"smart IT departments disable Java\" - I assume this means that JS is somehow more hack-proof than Java.  If true, I guess this must have something to do with JS's internal architecture...  Do you have a reference?\nSecond thought: earlier we discussed the fact that more coroutine-like facilities for JS are coming down the pike - I wonder if there is any way to get these incorporated in browsers earlier?  It seems odd that ISPs cannot control what version of JS they want to install...\nThanks for the good feedback,\nBest regards,\nPaul\n. Thanks, @kenhkan, I'll do my best to keep bringing things back to the pure \"FBP spirit\"!  I learn best by doing, so I plan to read up on JS, try things, etc.  And @bergie deserves a lot of credit for having got the pig to do some very clever tricks!\nAnd yes, thanks for the analogy - that helps too!  Looking back, I see that this has been a pretty wide-ranging discussion - it has been very helpful,  and I get the impression from some of the posts above that JS (and @bergie) still has some tricks up its sleeve (excuse the mixed metaphor!). \n. PS @bergie and @kenhkan, I recently came across a remark stating that a window only has one JS thread. I don't know if the converse is true, but, if it is, could we maybe make use of invisible windows (if there is such a thing)?  Or is this a silly suggestion?! \n. I went back to @bergie's original post - was this intended as a change to the noflo infrastructure?  If so, has it been done?  The one area where I have trouble is the original comment about cloning the IP - of course, as described, it would apply equally to output ports and to output array port elements, as these behave identically, so I'm not sure what the original issue was!  Also, I have raised the single output port feeding multiple inputs as issue  #108, as it seems to me we should have it as an issue on its own.\n. Hi Forrest,\nThere is one of these cognitive dissonances going on here!  I agree we are\ndealing with references here,  but to me IPs are like solid objects or\nmemos - they can't simply appear or disappear.  I guess if you are not\ngoing to modify them, you can treat them as readonly.  Is that the hidden\nassumption?  If so, then of course you can reference them in multiple\nplaces!\nSorry to be a bit rushed!  I am in the tropics for a few weeks!\nBest regards,\nPaul\nOn 2014-02-07 7:14 AM, \"Forrest Oliphant\" notifications@github.com wrote:\n\nIn JS, objects and arrays going through a graph are references. If they\nneed to be cloned, that should be a specific component.\nIn the photobooth example, I'm getting DOM elements with the\ndom/GetElement component. It isn't possible to clone DOM element objects,\nand I don't think I should need the Split component to send the element\nto multiple nodes.\n\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/108#issuecomment-34431816\n.\n. But how do you guarantee that no component will modify an IP? It's not a\nrestriction in classical FBP!\nOn 2014-02-07 5:20 PM, \"Paul Morrison\" jpaulmorr@gmail.com wrote:\nHi Forrest,\nThere is one of these cognitive dissonances going on here!  I agree we are\ndealing with references here,  but to me IPs are like solid objects or\nmemos - they can't simply appear or disappear.  I guess if you are not\ngoing to modify them, you can treat them as readonly.  Is that the hidden\nassumption?  If so, then of course you can reference them in multiple\nplaces!\nSorry to be a bit rushed!  I am in the tropics for a few weeks!\nBest regards,\nPaul\nOn 2014-02-07 7:14 AM, \"Forrest Oliphant\" notifications@github.com\nwrote:\n\nIn JS, objects and arrays going through a graph are references. If they\nneed to be cloned, that should be a specific component.\nIn the photobooth example, I'm getting DOM elements with the\ndom/GetElement component. It isn't possible to clone DOM element\nobjects, and I don't think I should need the Split component to send the\nelement to multiple nodes.\n\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/108#issuecomment-34431816\n.\n. That's a good point, Forrest.  However, the problem from my point of view\nis that, when you do a split, whether implicit or explicit, the copies\nbecome decoupled in time.  Admittedly this is true for classical FBP,  not\nreactive, because of the single-threaded nature of reactive, but from my\nPOV this lets reactive get away with things that classical doesn't!  Call\nit FBP lite!\n\n\nRegards,\nPaul\nOn 2014-02-10 5:15 AM, \"Forrest Oliphant\" notifications@github.com wrote:\n\nHTML element objects exist in one place: the DOM. When I'm passing them\naround the graph, components are doing things to them (adding a child,\nchanging class, listening for clicks, extracting pixels from a canvas,\netc.).\n[image: photobooth split canvas]https://f.cloud.github.com/assets/395307/2124319/325634d0-923c-11e3-8039-9f40bacfda3d.png\nIt doesn't add anything to the graph to require that reference to get\nsplit before going to other components.\nThis might be a special case.\n\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/108#issuecomment-34616088\n.\n. Hi @bergie, greetings from sunny Tobago!\n\nRe the 1st para, I got that.  You can actually do the same with JavaFBP snd\nC#FBP, as Packet has a single content field which can refer to an object of\nany type.  However, after the copy, the two packets will be decoupled in\ntime, so you can't care when they run relative to each other.\nBy the way @forresto 's diagram does show a copy block - is this optional?\nParenthetically,  it would be great if the lines could be annotated with\ncontent info - even if you just allow a draggable legend, as in Draw FBP.\nAnd the lines are still very hard to see on my tablet - pale blue on black?\nI'll look at the 2nd psra when I get back home!\nRegards,\nPaul\nOn 2014-02-10 9:33 AM, \"Henri Bergius\" notifications@github.com wrote:\n\n@jpaulm https://github.com/jpaulm DOM handling, as @forrestohttps://github.com/forrestomentioned, is one of the cases where we have to deviate somewhat from the\ntraditional FBP \"single responsibility principle\", and allow the same\nelement to be sent to multiple places. However, one could argue that since\nthe DOM element is actually living inside the browser DOM tree and not in\nthe IP, we're really not duplicating the element, but instead telling\ndifferent components to perform operations on the element. A bit like a\nfile path is not really the file itself :-)\nHowever, #136 https://github.com/noflo/noflo/issues/136 gives us a way\nto parametrize ports, and this could be the way you could instruct your\noutports to make clones of IPs they send around for situations where that\nis necessary.\n\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/108#issuecomment-34637199\n.\n. I'm pretty sure I raised an issue a few months ago about why the process name in EXPORT has to be in upper case.  If this is still true it could seriously impact (natural) languages that use diacritic marks.  I am not sure where that issue is, and whether it has been resolved.\n. Sorry, I'm having trouble with email on the tablet, and I don't have my Git password! \u00a0I'll have a broader bandwidth when I get home.\n\nIt seems that the port \u00a0name case problem is an artifact of JavaScript, as, in all my implementations of FBP, port names are keywords used for communication between processes and the network. \u00a0I have raised the case issue before, without getting an answer - or maybe I didn't understand the answer! \u00a0JavaFBP and DrawFBP have no problem supporting Chinese, as port names and process names are just character strings. \u00a0Why can't JS handle them?!\nI have quite a bit of experience with natural language support, \u00a0and I find this is a bit of a blind spot on the part of English-speakers! \u00a0The moment you get into languages with diacritics you start to get problems. The Chinese example just makes the problem more obvious. \u00a0 I have no idea what lowercasing does to Chinese, but if it does anything at all it can't be good!\nYou might get away with it on statistical grounds as the number of port names to be distinguished should be small for a given component, \u00a0but don't be surprised if weird things happen!\nI know it's hard to change old architectural decisions, but think of this as red pill time!!!!\nRegards, Morpheus \u00a0: - )\nSent from Samsung tablet\n-------- Original message --------\nFrom: Henri Bergius notifications@github.com \nDate: 02-17-2014  3:49 PM  (GMT-04:00) \nTo: noflo/noflo noflo@noreply.github.com \nCc: jpaulm paul.morrison@rogers.com \nSubject: Re: [noflo] graph exports - in / out ambiguity (#118) \n@forresto I'm fine with separating private node and port, in which case only port name needs to be lowercased. Do you want to work on that?\nNote however that we need to keep backwards compatibility in a way that old FBP and JSON files still work. Easiest would probably be to check for the old . syntax at loadJSON and convert when needed.\n\u2014\nReply to this email directly or view it on GitHub.\n. Just started wondering if port names in NoFlo are being treated as variable\nnames, either in components or in networks, or both...?  Can someone point\nme at an actual example?\nOn 2014-02-18 4:12 PM, \"jpaulmorr\" jpaulmorr@gmail.com wrote:\n\nSorry, I'm having trouble with email on the tablet, and I don't have my\nGit password!  I'll have a broader bandwidth when I get home.\nIt seems that the port  name case problem is an artifact of JavaScript,\nas, in all my implementations of FBP, port names are keywords used for\ncommunication between processes and the network.  I have raised the case\nissue before, without getting an answer - or maybe I didn't understand the\nanswer!  JavaFBP and DrawFBP have no problem supporting Chinese, as port\nnames and process names are just character strings.  Why can't JS handle\nthem?!\nI have quite a bit of experience with natural language support,  and I\nfind this is a bit of a blind spot on the part of English-speakers!  The\nmoment you get into languages with diacritics you start to get problems.\nThe Chinese example just makes the problem more obvious.   I have no idea\nwhat lowercasing does to Chinese, but if it does anything at all it can't\nbe good!\nYou might get away with it on statistical grounds as the number of port\nnames to be distinguished should be small for a given component,  but don't\nbe surprised if weird things happen!\nI know it's hard to change old architectural decisions, but think of this\nas red pill time!!!!\nRegards, Morpheus  : - )\nSent from Samsung tablet\n-------- Original message --------\nFrom: Henri Bergius notifications@github.com\nDate: 02-17-2014 3:49 PM (GMT-04:00)\nTo: noflo/noflo noflo@noreply.github.com\nCc: jpaulm paul.morrison@rogers.com\nSubject: Re: [noflo] graph exports - in / out ambiguity (#118)\n@forresto https://github.com/forresto I'm fine with separating privatenode and port, in which case only port name needs to be lowercased. Do you\nwant to work on that?\nNote however that we need to keep backwards compatibility in a way that\nold FBP and JSON files still work. Easiest would probably be to check for\nthe old . syntax at loadJSON and convert when needed.\n\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/118#issuecomment-35316833\n.\n. @bergie Valid point, Henri!  But I agree with @forresto also!  Bit of a\ncatch-22!\n\nAnd I guess port names are case - insensitive also.  That is different from\nclassic FBP, but just so it is made very clear up front!\nOn 2014-02-18 4:28 PM, \"Henri Bergius\" notifications@github.com wrote:\n\n@jpaulm https://github.com/jpaulm character support isn't directly\nconnected with this issue, but anyway...\nNoFlo itself doesn't care how the nodes and ports are named, except for\nthe fact that we do normalization via toLowerCase().\nThe character limitations are mostly coming from the FBP parser where\nports are recognized with the regular expression [A-Z0-9_]+.\nThis limits ports to alphanumeric and uppercase only (on FBP language\nlevel, not in NoFlo core). This is bigger limitation than regular JavaScript\nidentifiers http://mathiasbynens.be/notes/javascript-identifiers which\nallow unicode characters.\nHowever, as we've discussed before, I'd rather have people target an\ninternational community where ASCII characters are pretty much the standard\neverybody is able to read and write. If we start allowing anything from\nUTF-8, we risk ending up in a situation where a Chinese programmer can't\ncontribute to a Finnish FBP program and vice versa. I'd rather not fragment\nthe FBP community in that way, at least yet.\n\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/118#issuecomment-35429410\n.\n. Good idea, Henri!  I don't have Git access right now - could someone raise\nit?\n\nActually, I think Henri's point is correct for port names, but  I assume\nthis reasoning only applies to port names, not process names - they should\nsimply allow all characters,  no?\nClsssic FBP does not fold port names and it may be too late to do this now.\nComments?\nI also now think I over-constrained process names in DrawFBP - to alpha,\nnumeric,  and underscore only. Unfortunately,  I don't remember why.  Could\nit be because of NoFlo?\nRegards,\nPaul\nOn 2014-02-18 6:41 PM, \"Henri Bergius\" notifications@github.com wrote:\n\n@forresto https://github.com/forresto @jpaulmhttps://github.com/jpaulmcan we get another issue for the i18n question? :-)\n\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/118#issuecomment-35432082\n.\n. \"I also now think I over-constrained process names in DrawFBP - to alpha,\nnumeric,  and underscore only.\"\n\nI now remember why I did this - it had to do with .fbp notation. The logic\ngoes like this:\nIn .fbp notation, neither process names nor port names are quoted.  This is\nnot really a problem in the case of port names, as they are normally alpha,\nwith only square brackets being syntactically significant.\nHowever, if you allow any characters in process names, you have to allow\nfor the fact that the following characters are all syntactically\nsignificant: comma, hyphen (in arrow),  round brackets, blanks, EOL and\nsemicolon (in Wayne's verson). We can't just surround the process name with\nquotes as this is the convention for IIPs.\nNote that this problem only applies to .fbp notation - not to any of the\ncompilable notatons.\nIn DrawFBP I allow the process name to include special characters, but then\nI convert them to underscores, and then of course I have to check for\nuniqueness, and make them unique if they are not!  Bit of a pain, besides\nmaking the resulting .fbp code look ugly!\nHow do you all feel about allowing special characters in process names, but\nrequiring them to be preceded by an escape character - say backslash?\nLooking forward to hearing your thoughts on this!\n. Hi guys, I don't see an answer on this one, raised 9 days ago - any comments, anyone?!  \nBasically, how about adding backslashes before any special characters in process names?\nTIA\n. Yes, please!!!\nPaul\nOn Thu, Apr 17, 2014 at 2:57 AM, Forrest Oliphant\nnotifications@github.comwrote:\n\n[image: :thumbsup:]\n@jpaulm https://github.com/jpaulm would appreciate this as well [image:\n:smile:]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/157#issuecomment-40686529\n.\n. Hi @kenhkan, nice to hear from you!\n\nI realized have been kind of riding two horses, and probably confusing the\nh*** out of myself - please ask for clarification if this doesn't make\nsense!\n1st horse:  running http://app.flowhub.io with my own network - this\nactually works, including searching, dragging, etc., but for me only in\nChrome - not Firefox.\nParenthetically, it generates the following messages on the JS console,\nbefore it even starts:\n\nplatform.js is not the first script on the page. See http://www.polymer-project.org/docs/start/platform.html#setup for details. app.js:32\n'HTMLSourceElement.media' is deprecated. This attribute doesn't do anything.\n'HTMLVideoElement.webkitDisplayingFullscreen' is deprecated. Please use the 'fullscreenchange' and 'webkitfullscreenchange' events instead.\n'HTMLVideoElement.webkitSupportsFullscreen' is deprecated. Its value is true if the video is loaded.\n\nThis is all your group's code, and it is running on your server (\napp.flowhub.io) using a network which I assume is stored on your web site\nsomewhere, so I cannot take any credit for causing these warnings!\nAlso, I would like to report that my network -\nhttp://app.flowhub.io/#project/pauls/drwes - maybe you are able to see it -\nactually talks to my webserver, which is written in JavaFBP.  I have been\nreluctant to announce this to the group, as there is a minor problem with\nthe websocket return code - when I close down my server with a 1001 code,\nit triggers a 1005.  I have reported this to Henri and Forrest, but no\nfeedback so far.  Do we have any protocol experts out there?\nNow, it is wonderful that this works, but it bothers me that I can't get it\nto run on my own machine, as it is client code.  Plus, I want my network\nto be able to talk to HTML running on my machine, and nobody seems to know\nhow to do that in Windows - at least nobody has responded to my query on\nthe Google group in 7 days - unless they are all on vacation :-)\n2nd horse:  I feel it is important that users should be able to run their\nclient networks on their own machines - and this is what I have been\nstruggling with for the last month...\nThis is probably where your suggestion would help.  DrawFBP actually\ngenerates NoFlo JSON code, so I am fairly familiar with that format -\nunless it has changed since I wrote that part of DrawFBP.    I don't think\nI care whether your pure JS looks like FBP, unless you are talking about\nthe stuff that looks like\n\ndata-reactid=\".0.1.0.0.3.$core/Kick_ul80z.4.$core/Kick_ul80z=1in=1in.3\">indataout<g class=\"node-label-bg\"\n\nas I would definitely need a format that can be edited, or at least\ngenerated.  I know of at least 2 formats: .fbp format (A OUT -> IN B OUT\n->, etc.)  and NoFlo JSON - either of these would be fine for editing.\nWhen I wrote the generator for the latter, Henri asked me if I could\ncapture the x-y coordinates, so I am doing that...   If you are indeed\nthinking of the format shown above in red, I could try to generate it from\nthe JSON format, as I have a fair amount of time these days!  And I could\nwrite it in JavaFBP :-)\nLooking forward to hearing your reactions, and hoping that our time zones\nwill make it easier for us to collaborate than the 7 hours between Europe\nand here!\nBest regards,\nPaul M.\nOn Thu, Apr 17, 2014 at 10:12 AM, Kenneth Kan notifications@github.comwrote:\n\n@jpaulm https://github.com/jpaulm Would the compiled version help in\nrunning or understanding the program? What I've been thinking is it'd be\ncompiled down to pure JavaScript. It wouldn't look anything related to FBP\nin any way at all.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/157#issuecomment-40718001\n.\n. Thanks for getting back to me!  Surely it's past your bed time! :-)\n\nIn sort of reverse order, that long JS file looks interesting - I'll start\ncrawling through it!\nI tried publishing my project so you guys can see it.  When I did the\nupload nothing happened.  Can I push from the device, or do I have to\nreproduce it on the Github side, and then push?\nAs I said, under 2nd horse:  I feel it is important that users should be\nable to run their client networks on their own machines.  The basic\nrequirement, I guess, is that my HTML should be able to talk to my network,\nas it does in photobooth, and both should be on my C drive!   However, we\nare talking about using componentry - I talk about this in my book.  On the\none hand, I want to have a good copy of a component, and I would like it if\nbugs get fixed automagically!  OTOH  I don't want my app to be impacted\nevery time someone changes a component.  OTOOH, I don't want to have a\ncontinuous stream of update requests.  So I would say that HTML and network\ndefinition should be running on my own machine - also components, but they\nshould be refreshable from a central repository.  I could register as a\nuser, and get monthly updates about what's changed.  Warning: some users\nmay have compensated for a bug in a  component, and they may not want the\nbug fixed!  That actually happened to us!\nHope that answers your question!\nBest regards,\nPaul\nOn Fri, Apr 18, 2014 at 5:31 PM, Forrest Oliphant\nnotifications@github.comwrote:\n\n@jpaulm https://github.com/jpaulm I'm still not 100% clear on what you\nwant to accomplish. We should get on the same page.\nWhen you say\nrunning http://app.flowhub.io with my own network\ndoes that mean that you're running noflo-ui from localhost, or that\napp.flowhub.io is communicating with a network running on your local\nmachine?\nParenthetically, it generates the following messages on the JS console,\nbefore it even starts:\nAll of those are just warnings that don't break anything.\nAlso, I would like to report that my network...\nWe can't see a project with a link like that. It is actually stored in a\ndatabase in your local browser. You can set up app.flowhub.io to connect\nwith github http://flowhub.io/documentation/github-integration/ if you\nwant to publish a project.\ndata-reactid=\".0.1.0.0.3.$core/Kick_ul80z.4.$...\nThis the SVG code that renders the graph, generated by the JS in\nhttps://github.com/the-grid/the-graph/ ... safe to ignore.\nNow, for main question of compiling a client-side NoFlo app, I've been\nhesitant to do much documentation there, because it is tricky and fragile.\nThe photobooth demo http://flowhub.io/demo/photobooth/ is the only time\nI've done it. Here is what the built JS looks like for that:\nhttp://flowhub.io/demo/photobooth/build/flowhub-photobooth.js\nWhen this issue is complete, it will be easier. [image: :rainbow:]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/157#issuecomment-40846290\n.\n. Hi @bergie @kenhkan !\n\nOn Mon, Apr 21, 2014 at 7:40 AM, Henri Bergius notifications@github.comwrote:\n\n@jpaulm https://github.com/jpaulm it should be noted that every\nbrowser-side NoFlo flow already runs on the user's machine -- the browser\ndownloads NoFlo and the other associated JavaScript code, parses, and\nexecutes it. When you're running the Flowhub UI you're actually executing a\nNoFlo graph on your own machine, since the UI itself is built with NoFlo.\nI had understood that - what I can't find is the actual network\ndefinition.  It also doesn't make sense to me that I have to fire up\napp.flowhub.io to run my app - in other words, the execute step should be\ndecoupled from the downloading and parsing.  You just need to save it\nsomewhere and provide a separate execute engine.\n\nThe additional benefit of the FBP protocol is that this opens the Flowhub\n\nUI to be usable with any other FBP environment that can talk the protocol.\nFor example, we already have non-JavaScript environments like MicroFlohttps://github.com/jonnor/microfloand\nImgFlo https://github.com/jonnor/imgflo that the UI can interact with\nvery similarly to how it interacts with NoFlo on Node.js. And in this case\nthere is no NoFlo in the loop.\n\nBased on your last note, I now understand your comments about protocols\nbetter - but I can also see that this will have to come quite a bit further\ndown the path!\n\n@kenhkan https://github.com/kenhkan currently deploying NoFlo graphs on\neither Node.js or browser includes several steps:\n1. Loading NoFlo and its component libraries via a CommonJS module\n   container (Node.js provides one out-of-the-box, and on browser we use\n   Component.io https://github.com/component/component)\n2. Loading a graph (and possible subgraphs) into NoFlo Graph\n   instances. This may involve first parsing the graph information from the\n   FBP syntax\n3. Passing the main graph to a NoFlo Network\n4. Instantiating NoFlo components for the Graph nodes\n5. Connecting the ports of the nodes as specified in the graph\n6. Starting the NoFlo network by sending the IIPs\nThis is standard for FBP implementations - with the exception of #6, which\nis NoFlo-specific.\n\nRegards,\nPaul\n. Some of the above ideas are interesting - am I right that they are moving NoFlo closer to classical FBP?  Now if we could provide a way to exert \"back pressure\" (suspend sender when connection is full), we could do some very neat things!\n@bergie BTW your post of 3:54 am (and 4:04 am) yesterday is showing a big black rectangle over the bottom half of the diagram (Firefox, Win7).  And what were you doing up at that time?!\n. ",
    "ghost": "I'll let you know if I find anything, but considering that I'm like new to js and esp. to noflo and coffeescript ... I just might give up again ;)\n. how do I run that console.log(process.title); ? I've no idea currently\n. cool thanks, returns this:\nAdministrator: C:\\Windows\\System32\\cmd.exe - node  a.js\n. Sure. It says true\n. I went to sleep after like 10 minutes, sorry for the delay :)\nTime is something that I have, I'll be glad to help out so don't hesitate to ask me to do things, I like it! :D\nI did:\n1. git pull\n2. grunt build\n3. npm fix\n4. noflo\nI'm still getting this for some reason:\n```\nTue 07/30/2013 10:51:03.73 s:\\workspace.js.2013\\noflo>noflo\nmodule.js:340\n    throw err;\n          ^\nError: Cannot find module 'emitter'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n    at Module.require (module.js:364:17)\n    at require (module.js:380:17)\n    at Object. (s:\\workspace.js.2013\\noflo\\lib\\Graph.js:9:20)\n    at Object. (s:\\workspace.js.2013\\noflo\\lib\\Graph.js:422:4)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n```\nBut I am not sure if I did those thing right?\n. If I just run grunt instead of grunt build I get this:\n```\nTue 07/30/2013 10:53:02.28 s:\\workspace.js.2013\\noflo>grunt\nRunning \"test\" task\nRunning \"coffeelint:libraries\" (coffeelint) task\n[warn] src/lib/ArrayPort.coffee:5 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Graph.coffee:234 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Graph.coffee:235 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Graph.coffee:238 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Graph.coffee:321 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/InternalSocket.coffee:35 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:115 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:145 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:212 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:221 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:281 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:311 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:312 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:314 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:315 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:326 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:347 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:348 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:5 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:24 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:33 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:36 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:40 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:41 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:61 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:67 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:68 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:74 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:75 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:112 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Port.coffee:18 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:95 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:99 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:102 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:109 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:166 Line exceeds maximum allowed length (max_line_length)\nRunning \"coffeelint:components\" (coffeelint) task\n\n\n2 files lint free.\n\n\nRunning \"coffee:libraries\" (coffee) task\nFile lib/ArrayPort.js created.\nFile lib/AsyncComponent.js created.\nFile lib/Component.js created.\nFile lib/ComponentLoader.js created.\nFile lib/Graph.js created.\nFile lib/InternalSocket.js created.\nFile lib/LoggingComponent.js created.\nFile lib/Network.js created.\nFile lib/NoFlo.js created.\nFile lib/Port.js created.\nFile lib/shell.js created.\nRunning \"coffee:libraries_nodejs\" (coffee) task\nFile lib/nodejs/ComponentLoader.js created.\nRunning \"coffee:bin\" (coffee) task\nFile bin/noflo.js created.\nRunning \"coffee:spec\" (coffee) task\nFile spec/ArrayPort.js created.\nFile spec/AsyncComponent.js created.\nFile spec/ComponentLoader.js created.\nFile spec/Graph.js created.\nFile spec/Network.js created.\nFile spec/NoFlo.js created.\nFile spec/Port.js created.\nFile spec/Subgraph.js created.\nRunning \"nodeunit:all\" (nodeunit) task\nFatal error: Cannot find module 'emitter'\nTue 07/30/2013 10:53:11.07 s:\\workspace.js.2013\\noflo>\n```\n. Just in case you want to see the output of: grunt build, npm link, noflo\n``` javascript\nTue 07/30/2013 13:15:54.44 S:\\workspace.js.2013\\noflo>grunt build\nRunning \"build\" task\nRunning \"coffee:libraries\" (coffee) task\nFile lib/ArrayPort.js created.\nFile lib/AsyncComponent.js created.\nFile lib/Component.js created.\nFile lib/ComponentLoader.js created.\nFile lib/Graph.js created.\nFile lib/InternalSocket.js created.\nFile lib/LoggingComponent.js created.\nFile lib/Network.js created.\nFile lib/NoFlo.js created.\nFile lib/Port.js created.\nFile lib/shell.js created.\nRunning \"coffee:libraries_nodejs\" (coffee) task\nFile lib/nodejs/ComponentLoader.js created.\nRunning \"coffee:bin\" (coffee) task\nFile bin/noflo.js created.\nRunning \"coffee:spec\" (coffee) task\nFile spec/ArrayPort.js created.\nFile spec/AsyncComponent.js created.\nFile spec/ComponentLoader.js created.\nFile spec/Graph.js created.\nFile spec/Network.js created.\nFile spec/NoFlo.js created.\nFile spec/Port.js created.\nFile spec/Subgraph.js created.\nRunning \"component:install\" (component) task\n    # S:\\workspace.js.2013\\noflo >\n    s:\\workspace.js.2013\\noflo\\node_modules\\grunt-component\\node_modules.bin\\component.cmd install\n install : component/emitter@master\n install : component/underscore@master\n install : noflo/fbp@master\n\nRunning \"component_build:noflo\" (component_build) task\nRunning \"uglify:noflo\" (uglify) task\nFile \"./browser/noflo.min.js\" created.\nOriginal: 136736 bytes.\nMinified: 54736 bytes.\nDone, without errors.\nTue 07/30/2013 13:16:28.66 S:\\workspace.js.2013\\noflo>npm link\nnpm WARN unmet dependency S:\\workspace.js.2013\\noflo\\node_modules\\grunt-component-build requires co\nffee-script@'latest' but will load\nnpm WARN unmet dependency S:\\workspace.js.2013\\noflo\\node_modules\\coffee-script,\nnpm WARN unmet dependency which is version 1.6.3\ns:\\nodist\\bin\\noflo -> s:\\nodist\\bin\\node_modules\\noflo\\bin\\noflo\ns:\\nodist\\bin\\node_modules\\noflo -> S:\\workspace.js.2013\\noflo\nTue 07/30/2013 13:16:34.17 S:\\workspace.js.2013\\noflo>noflo\nmodule.js:340\n    throw err;\n          ^\nError: Cannot find module 'emitter'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n    at Module.require (module.js:364:17)\n    at require (module.js:380:17)\n    at Object. (S:\\workspace.js.2013\\noflo\\lib\\Graph.js:9:20)\n    at Object. (S:\\workspace.js.2013\\noflo\\lib\\Graph.js:422:4)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\nTue 07/30/2013 13:16:35.48 S:\\workspace.js.2013\\noflo>\n``\n. yes I did,git log` says this is top commit: \ncommit e827c0f79a187f420f2e8d3b1cb0fae79e800ea6\nAuthor: Henri Bergius henri.bergius@iki.fi\nDate:   Tue Jul 30 03:06:41 2013 +0200\nPlatform detection in main NoFlo interface, refs #94\n. ok, grunt build in noflo folder...\n``` javascript\nTue 07/30/2013 22:14:12.85 S:\\workspace.js.2013\\noflo>grunt build\nRunning \"build\" task\nRunning \"coffee:libraries\" (coffee) task\nFile lib/ArrayPort.js created.\nFile lib/AsyncComponent.js created.\nFile lib/Component.js created.\nFile lib/ComponentLoader.js created.\nFile lib/Graph.js created.\nFile lib/InternalSocket.js created.\nFile lib/LoggingComponent.js created.\nFile lib/Network.js created.\nFile lib/NoFlo.js created.\nFile lib/Port.js created.\nFile lib/shell.js created.\nRunning \"coffee:libraries_nodejs\" (coffee) task\nFile lib/nodejs/ComponentLoader.js created.\nRunning \"coffee:bin\" (coffee) task\nFile bin/noflo.js created.\nRunning \"coffee:spec\" (coffee) task\nFile spec/ArrayPort.js created.\nFile spec/AsyncComponent.js created.\nFile spec/ComponentLoader.js created.\nFile spec/Graph.js created.\nFile spec/Network.js created.\nFile spec/NoFlo.js created.\nFile spec/Port.js created.\nFile spec/Subgraph.js created.\nRunning \"component:install\" (component) task\n    # S:\\workspace.js.2013\\noflo >\n    s:\\workspace.js.2013\\noflo\\node_modules\\grunt-component\\node_modules.bin\\component.cmd install\n install : component/emitter@master\n install : component/underscore@master\n install : noflo/fbp@master\n\nRunning \"component_build:noflo\" (component_build) task\nRunning \"uglify:noflo\" (uglify) task\nFile \"./browser/noflo.min.js\" created.\nOriginal: 136736 bytes.\nMinified: 54736 bytes.\nDone, without errors.\nTue 07/30/2013 22:19:15.27 S:\\workspace.js.2013\\noflo>\n. javascript\nTue 07/30/2013 22:21:37.43 S:\\workspace.js.2013\\noflo>noflo\nmodule.js:340\n    throw err;\n          ^\nError: Cannot find module 'emitter'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n    at Module.require (module.js:364:17)\n    at require (module.js:380:17)\n    at Object. (S:\\workspace.js.2013\\noflo\\lib\\Graph.js:9:20)\n    at Object. (S:\\workspace.js.2013\\noflo\\lib\\Graph.js:422:4)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\nTue 07/30/2013 22:22:04.26 S:\\workspace.js.2013\\noflo>\n. Tue 07/30/2013 22:22:04.26 S:\\workspace.js.2013\\noflo>which noflo\ns:\\nodist\\bin\\noflo\n. javascript\nTue 07/30/2013 22:23:03.49 S:\\workspace.js.2013\\noflo>npm link\nnpm WARN unmet dependency S:\\workspace.js.2013\\noflo\\node_modules\\grunt-component-build requires co\nffee-script@'latest' but will load\nnpm WARN unmet dependency S:\\workspace.js.2013\\noflo\\node_modules\\coffee-script,\nnpm WARN unmet dependency which is version 1.6.3\ns:\\nodist\\bin\\noflo -> s:\\nodist\\bin\\node_modules\\noflo\\bin\\noflo\ns:\\nodist\\bin\\node_modules\\noflo -> S:\\workspace.js.2013\\noflo\nTue 07/30/2013 22:23:11.11 S:\\workspace.js.2013\\noflo>which noflo\ns:\\nodist\\bin\\noflo\nTue 07/30/2013 22:23:13.89 S:\\workspace.js.2013\\noflo>noflo\nmodule.js:340\n    throw err;\n          ^\nError: Cannot find module 'emitter'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n    at Module.require (module.js:364:17)\n    at require (module.js:380:17)\n    at Object. (S:\\workspace.js.2013\\noflo\\lib\\Graph.js:9:20)\n    at Object. (S:\\workspace.js.2013\\noflo\\lib\\Graph.js:422:4)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n```\nbatch\nTue 07/30/2013 22:23:15.48 S:\\workspace.js.2013\\noflo>where noflo\ns:\\nodist\\bin\\noflo\ns:\\nodist\\bin\\noflo.cmd\n. is there some way to force a clean? if that even makes sense, but I'm guessing it recompiles everything regardless?\n. If I run just grunt it tells me too that i can't find module emitter\nAny ideas why? \n``` javascript\nTue 07/30/2013 22:26:13.59 S:\\workspace.js.2013\\noflo>grunt\nRunning \"test\" task\nRunning \"coffeelint:libraries\" (coffeelint) task\n[warn] src/lib/ArrayPort.coffee:5 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Graph.coffee:234 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Graph.coffee:235 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Graph.coffee:238 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Graph.coffee:321 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/InternalSocket.coffee:35 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:115 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:145 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:212 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:221 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:281 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:311 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:312 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:314 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:315 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:326 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:347 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Network.coffee:348 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:5 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:24 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:33 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:36 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:40 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:41 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:61 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:67 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:68 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:74 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:75 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/NoFlo.coffee:112 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/Port.coffee:18 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:95 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:99 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:102 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:109 Line exceeds maximum allowed length (max_line_length)\n[warn] src/lib/shell.coffee:166 Line exceeds maximum allowed length (max_line_length)\nRunning \"coffeelint:components\" (coffeelint) task\n\n\n2 files lint free.\n\n\nRunning \"coffee:libraries\" (coffee) task\nFile lib/ArrayPort.js created.\nFile lib/AsyncComponent.js created.\nFile lib/Component.js created.\nFile lib/ComponentLoader.js created.\nFile lib/Graph.js created.\nFile lib/InternalSocket.js created.\nFile lib/LoggingComponent.js created.\nFile lib/Network.js created.\nFile lib/NoFlo.js created.\nFile lib/Port.js created.\nFile lib/shell.js created.\nRunning \"coffee:libraries_nodejs\" (coffee) task\nFile lib/nodejs/ComponentLoader.js created.\nRunning \"coffee:bin\" (coffee) task\nFile bin/noflo.js created.\nRunning \"coffee:spec\" (coffee) task\nFile spec/ArrayPort.js created.\nFile spec/AsyncComponent.js created.\nFile spec/ComponentLoader.js created.\nFile spec/Graph.js created.\nFile spec/Network.js created.\nFile spec/NoFlo.js created.\nFile spec/Port.js created.\nFile spec/Subgraph.js created.\nRunning \"nodeunit:all\" (nodeunit) task\nFatal error: Cannot find module 'emitter'\n``\n. ok, that's odd... it seemed to work with thata.js` that I made, like so:\n``` javascript\nTue 07/30/2013 22:26:20.77 S:\\workspace.js.2013\\noflo>type a.js\nconsole.log(process.title.indexOf('node') !== -1);\nTue 07/30/2013 22:34:02.30 S:\\workspace.js.2013\\noflo>where node\ns:\\nodist\\bin\\node.exe\nTue 07/30/2013 22:34:06.84 S:\\workspace.js.2013\\noflo>node a.js\ntrue\n``\n. I just searched all files innoflofolder for thistypeof process is 'object' and process.title is 'node'and I've found only 2:\n![two old style left](https://f.cloud.github.com/assets/51895/881943/09b3dd16-f958-11e2-9d84-95e4176cdfb8.png)\n. sure, git pull, grunt build, grunt test (failed same way) andnoflo`\njavascript\nmodule.js:340\n    throw err;\n          ^\nError: Cannot find module 'emitter'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n    at Module.require (module.js:364:17)\n    at require (module.js:380:17)\n    at Object.<anonymous> (S:\\workspace.js.2013\\noflo\\lib\\Graph.js:9:20)\n    at Object.<anonymous> (S:\\workspace.js.2013\\noflo\\lib\\Graph.js:422:4)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n. ok wait... seems like I got a merge error now\n. because I changed those two files to have the new detection, the git pull wasn't completed ...\nbut works now! noflo works\nTue 07/30/2013 22:48:03.80 S:\\workspace.js.2013\\noflo>noflo\ns:\\nodist\\bin\\node_modules\\noflo\\bin\\noflo is not a NoFlo graph file, skipping\n. console.log(process.execPath); shows:\ns:\\nodist\\bin\\node.exe\nnoting that grunt (test?) does this:\n```\nRunning \"coffeelint:components\" (coffeelint) task\n[error] src/components/Graph.coffee:87 Line exceeds maximum allowed length (max_line_length)\nWarning: Task \"coffeelint:components\" failed. Use --force to continue.\nAborted due to warnings.\n``\n. Awesome! Thanks.\n. Yes, justgrunt` now fails with this (showing only last part):\n``` javascript\nRunning \"nodeunit:all\" (nodeunit) task\nTesting AsyncComponent.coffee.....OK\nTesting ComponentLoader.coffee..F....\n\n\nResolve dependency package path\nError: 'S:\\workspace.js.2013\\noflo\\node_modules\\read-installed/package.json' == 'S:\\workspa\nce.js.2013\\noflo\\node_modules\\read-installed\\package.json'\nat S:\\workspace.js.2013\\noflo\\test\\ComponentLoader.coffee:33:12\nat S:\\workspace.js.2013\\noflo\\src\\lib\\nodejs\\ComponentLoader.coffee:174:16\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:118:5\nat next (node_modules\\read-installed\\read-installed.js:172:30)\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:157:7\nat LOOP (fs.js:1343:14)\nat process._tickCallback (node.js:415:13)\n\n\nTesting Graph.coffee...OK\nTesting NoFlo.coffee.......OK\nTesting FbpParser.coffee........OK\nTesting Port.coffee..OK\nWarning: 1/91 assertions failed (5562ms) Use --force to continue.\nAborted due to warnings.\n```\nALSO npm test does this:\n``` javascript\nTue 07/30/2013 23:00:23.88 S:\\workspace.js.2013\\noflo>npm test\n\nnoflo@0.3.3 test S:\\workspace.js.2013\\noflo\n./node_modules/.bin/grunt test\n\n'.' is not recognized as an internal or external command,\noperable program or batch file.\nnpm ERR! weird error 1\nnpm ERR! not ok code 0\n``\n. by reversing the slashes in./node_modules/.bin/grunt test`  it would work (tested)\nTue 07/30/2013 23:02:43.95 S:\\workspace.js.2013\\noflo>.\\node_modules\\.bin\\grunt test\nRunning \"test\" task\n...\nEDIT: but that'd probably not work on other platforms \n. Should I use force? else it doesn't complete Aborted due to warnings.\n. no problem, I like it this way.\n``` javascript\nTesting AsyncComponent.coffee.....OK\nTesting ComponentLoader.coffeeF......\n\n\nResolve root package path\nError: 'S:\\workspace.js.2013\\noflo\\package.json' == 'S:\\workspace.js.2013\\noflo/package.jso\nn'\nat S:\\workspace.js.2013\\noflo\\test\\ComponentLoader.coffee:14:12\nat S:\\workspace.js.2013\\noflo\\src\\lib\\nodejs\\ComponentLoader.coffee:174:16\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:118:5\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:234:14\nat cb (node_modules\\read-installed\\node_modules\\slide\\lib\\async-map.js:48:11)\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:234:14\nat cb (node_modules\\read-installed\\node_modules\\slide\\lib\\async-map.js:48:11)\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:234:14\nat cb (node_modules\\read-installed\\node_modules\\slide\\lib\\async-map.js:48:11)\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:234:14\nat cb (node_modules\\read-installed\\node_modules\\slide\\lib\\async-map.js:48:11)\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:234:14\nat cb (node_modules\\read-installed\\node_modules\\slide\\lib\\async-map.js:48:11)\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:234:14\nat cb (node_modules\\read-installed\\node_modules\\slide\\lib\\async-map.js:48:11)\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:234:14\nat cb (node_modules\\read-installed\\node_modules\\slide\\lib\\async-map.js:48:11)\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:234:14\nat asyncMap (node_modules\\read-installed\\node_modules\\slide\\lib\\async-map.js:27:18)\nat next (node_modules\\read-installed\\read-installed.js:200:5)\nat S:\\workspace.js.2013\\noflo\\node_modules\\read-installed\\read-installed.js:157:7\nat LOOP (fs.js:1343:14)\nat process._tickCallback (node.js:415:13)\n\n\nTesting Graph.coffee...OK\nTesting FbpParser.coffee........OK\nTesting NoFlo.coffee.......OK\nTesting Port.coffee..OK\nWarning: 1/91 assertions failed (5200ms) Use --force to continue.\nAborted due to warnings.\n``\n.Done, without errors.`\n. Thanks for explanation.\nI asked this because I am considering using this for wiring up robotics and\ncad systems that run in the browser and on the nodejs server.\nSome benchmark comparison of a simple bit of code with and without flow\nbased graph would be a perfect way to see the impact\nI am also thinking of using the audio context as a high precision timer for\ndoing scheduling which I need for the robotic control. I know noflo has a\ntimer in it too. I wonder what clock it is using ?\nG\nOn 09/08/2013 9:48 AM, \"Kenneth Kan\" notifications@github.com wrote:\n\nThis question is kind of hard to answer. I'm not sure if it is even worth\nanswering at this stage. NoFlo is too nascent for performance hacks.\nThe value of NoFlo/FBP is so that you don't have to worry about most of\nthe code that you would otherwise have to write. Bugs from incremental\nimprovements and refactoring are also kept to the minimal. These two\nqualities alone should eliminate much need for \"high\" performance, because\nyou simply allocate what would otherwise be salary to a programmer (e.g.\nyou) having to program, to more servers to scale out.\nCurrently, design mode is run mode. Unfortunately, it is not on the\nroadmap at this point, but developers are welcomed if there is a need for\nit. :)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/99#issuecomment-22379990\n.\n. It would be nice to have the ability to compile a noflo graph with all its dependencies into either a nodejs script either a browser script with a simple command. :-)\n\nFor the node runtime:\nshell\nnoflo compile --graph graph.json --runtime node  --output main.js\nthen\nshell\n$ node main.js\nand for the browser:\nshell\nnoflo compile --graph graph.json --runtime browser --output main.js\nthen\nhtml\n<script src=\"main.js\" type=\"text/javascript\"></script>\n. Yes... I saw it, indeed, but it is noted too that it is a highly experimental work, so that sounds a bit dangerous or explosive for now.\nAlso, I'm more used to gulp than grunt, that's why I was thinking that a built-in compiler could be a very nice feature. Sometimes using dev tools one is not used to feels like going into the outer space without spacesuit. ;)\n. ",
    "totty90": "I think there is no ui yet.. http://bergie.iki.fi/blog/noflo-two-years/ :/\n. Well, you should really put that demo on the main page and kickstarter.. Would be nice to see the generated code too in javascript and in your graph format, just to compare. In this way people also trust more because can see as they can also check if it will merge well in their workflow/projects.\n. ",
    "adri": "If you want to get a preview git clone https://github.com/noflo/dataflow-noflo.git and open dataflow-noflo/demo/index.html. Play around with the result by dragging the swirl in the circle on the bottom right. \nTo make changes, for example click on the Spring X node and then select the info-icon in the toolbar (top left). If you set, lets say the stiffness, to 20 and press enter you notice a difference when dragging the circle. Also try changing the in value of the Anchor X node in oder to adjust the center (anchor) of the circle. Have fun :-)\nI think this demo was inspired by a Quartz Composer tutorial\n. ",
    "klzns": "Same here. If wasn't for this issue, I wouldn't have found this UI. I got interested in the project because of it, so maybe it would be good if you put it some light on it.\n. ",
    "jiyinyiyong": "Same here.\nAlso, I tried searching on Youtube but found no detailed video showing how people programming with Noflo.\nI haven't learnt flow-based programming before, even I got this demo I still found it hard to begin.\nWant demos please :)\n. ",
    "igorw": "FYI, the validator I tested this with is justinrainbow/json-schema.\n. ",
    "intrz": "Would be nice if the network protocol for component had a way to add and remove ports to components. This would be useful for creating components in the UI. First you would create an empty component, then add some ports, then when you click on the component to get the code editor, you don't get the entire component code by default, only the actual code. The parts dealing with ports can be scaffolding code that you as a user don't have to deal deal with. Currently the inports activate by events like \"data\". One possibility here could be that when you click on a port, you can write the function that is the event handler for that specific event. \nOne option for making a simple way to create components in the simple case where  it receives data on each inport, then when all ports have received data, it starts a funtion that processes the data, and the output is sent to the outports by that function. In such a case, an inport really just sets a property. So for example if there are inports name and email, then when there is a value on these ports, a name and email property would be set, when both the name and email property has been set, and there is an incoming value, a process() function would be called, which does something to name and email. In this case, the only thing which is needed in the UI, is the ability to add and remove ports and click editor code on the component, which will then only show the content of the process() function, which has access to the name and email property and the outports.\nEventually it would be very useful if there could be different visual DSLs for different types of components. An example is a data mapping component. In this case, you would add the empty component, maybe it would have an default inport and a default outport. Both the input and output data should be in json format, in theory, different components types could be made to map from various database formats and whatnot, but they could all use the same simple visual DSL for left/right mapping. So basically the component would be an empty box with an inport and an outport, when you connect the inport to the data source, it would detect the properties in the incoming data, and then it would be nice if the outport could somehow do the same, to get a list of expected properties from the component which will receive its data. The properties might be for example firstName and lastName on the input data, while the output data excepts only name (the full name) you would then see firstName and lastName inside the component, and simply first drag firstName to name, then lastName to name, it would then generate the required process() function inside the component, which would basically be name = firstname + \" \" + lastName. What this visual editor would be, is simply another version of the code editor. The idea here would be that by default, the code editor is just a text editor for editing say coffescript or javascript but, but you can create custom editors, which would basically just be the html for the editor and a function to transform whatever is in the editor, so that it becomes code that the runtime can understand. Basically custom editors for DSLs, which could be both visual and textual, this can help transform NoFlo into a language workbench http://martinfowler.com/articles/languageWorkbench.html especially if it was easy to create those editors with NoFlo, so you would click create editor, then you create a graph for the editor and save, then you choose create compiler and you make a graph for the compiler, or where you perhaps might need to implement some new component. Actually FBP in itself is kinda just such a DSL, for wiring together a flowgram.\nNow, if you have a custom editor for a component, which you can open by double clicking or clicking editor or whatever, it would be nice to also be able to have a custom view. The view should be for each port, so basically you would create a viewer for a specific datatype and you might have multiple of them, for example for some input data, it makes sense to have one view, where you can view a single specific value, and another view which displays a history of the incoming values on the port. Say that one inport takes sound as input, the sound in question is information packets that basically contains pieces of a wave file, each packet contains an amplitude, the viewer for single values would just display a number, the time dependent viewer would however render the waveform as it receives the amplitude packets.\n. ",
    "trustmaster": "How about Flowhub and interacting with other runtimes? Should port names be always uppercase? Or lowercase/camelCase and uppercase in FBP only? I've encountered case-sensitivity problems while using Flowhub and implementing GoFlow runtime (which is case-sensitive).\n. Seems like a subject for another FBP mailing list dispute. I personally prefer case sensitive camelCase port names as it leaves less space for accidents and supports multiWordNames if necessary.\n. This is my proposal for this issue:\n- Make port names case-sensitive in the FBP protocol (and in NoFlo-UI), use camelCase port names in NoFlo.\n- Use uppercase port names in .fbp files for historical reasons, but infer case-sensitive port names from component registry when loading a graph.\n. Good, this will at least avoid collisions in the FBP protocol, where most runtimes would expect port names to be case-sensitive.\n. Looks good to me so far. I'm talking about the Port-to-Port protocol because a Runtime protocol is a task for a more distant future in GoFlow.\nI'm not sure about supporting begingroup and endgroup because currently GoFlow makes no use of the FBP \"substreams\" or \"trees\" concepts and relies on native structs instead.\n. @offlinehacker Could you provide a few examples of what such a component would do? This issue is a bit ambiguous.\n. @hayesmg do you mean that it would be nice to attach request UUIDs to every IP travelling in the network? There are networks which have more than one source node and there are networks that maybe be processing several requests at a time asynchronously and in mixed order, so there is no single activation of the network that could be given a unique ID automatically by NoFlo. Instead, requests IDs should be introduced on application level: you can create them in the node that accepts/creates the first request IP and then pass it downstream either as a packet group, or embedded in the packet object itself.\n. @bergie Is it different from Runtime UUID defined in FBP network protocol?\n. Regarding NoFlo-UI, it could infer a Runtime UUID for an event from the websockets connection it was received from (you basically have 1 connection per runtime and the UUID is received from the first message when establishing a connection), sending Runtime UUID over the network with each message would be an overkill.\nThe question here is: how a component could get current Network UUID, sending it over as an IP or as an attribute of every IP would be quite expensive. As for Request UUID, i'm afraid it still should be coded in the application.\n. I think this deserves a pull request. :+1: \n. I would enforce using groups with \"gathering of different input\" and make it work the way @forresto described. In more detail:\n- Component.groupInputs method takes a list of input names and process callback as parameters.\n- Each of grouped inputs on beginGroup event start expecting data for specific group name.\n- Each of grouped inputs on data event records received data into the tuple for current group name.\n- On endGroup for each of the grouped inputs the component checks if the tuple for that group is complete. If it is complete, then it passes the tuple to the process callback, along with a callback which does error handling etc. Otherwise it does nothing and the inport can safely continue with next group of data.\nMaking named packet groups mandatory when using grouped inPorts enables the components to process multiple groups asynchronously without mixing the data that belongs to different requests. Think of the group names like of request UUIDs.\nIf it makes sense, I could try implementing it shortly.\n. Input gathering could also be the default behavior if you pass an array of inports to the Async component's constructor, e.g.:\n``` coffeescript\nsuper ['x', 'y'], 'out'\ndoAsync: (coords, callback, group) ->\n  console.log \"Got (#{coords.x}, #{coords.y}) from group '#{group}'\" \n``\n. \"Helpers\" always sounded ugly to me, probably because in most frameworks they contained things which break the rules of the rest of it. Let's experiment with them a bit and then come to a handy interface. I'm working on thehelpers.GroupComponent`.\n. Here we go with components gathering multiple inputs and using single output:\ncoffeescript\nc = new noflo.Component\n  inPorts:\n    x:\n      datatype: 'number'\n    y:\n      datatype: 'number'\n  outPorts:\n    radius:\n      datatype: 'number'\nnoflo.helpers.GroupComponent c, (data, groups, out) ->\n  out.send Math.sqrt(data.x**2 + data.y**2)\n, ['x', 'y'], 'radius'\nFor more detailed example see the spec.\n. I've added async handlers support to the GroupComponent helper and also made the \"gathering by group ID\" behavior optional because it conflicts with existing components using groups and forwarding either way, so you need to be sure you want to collect by group ID or it may hang the app.\nThere's another trait I'll probably submit soon which simplifies emitting multiple error messages per process call, for both sync and async processes.\nWhile testing these traits on a real app I noticed the following:\n- Traits are not compatible with the old Ports API. If you use traits, you have to use the new Ports API, otherwise trait's event handlers are ignored.\n- The new definitions (with run-time ports and traits) are harder to read and longer to write than the old class way.\n- You don't need AsyncComponent to handle async operations unless you want to play with buffering.\n. @bergie then I suspect that NoFlo 0.6.0 release won't be backwards compatible.\nAs for grouping etc., addressable ports are next. And I just realized that the current GroupComponent async code isn't safe because in the world of async processing the entire beginGroup, data, endGroup sequence has to be atomic, otherwise packet envelopes may overlap on the outport. Alternative to that is grouping by data field rather than groups, but that requires all data to be objects.\n. For those cases when merging by group packets is a bad idea, GroupComponent now supports merging objects by specified field:\n``` coffeescript\nhelpers.GroupComponent c, (data, groups, out) ->\n  out.send\n    request: data.request\n    user: data.user.name\n    text: data.message.text\n, ['user', 'message'], 'signedMessage', {field: 'request'}\nuser.send {request: 123, id: 42, name: 'John'}\nmessage.send {request: 123, id: 17, text: 'Hello world'}\nResult:\n{ request: 123, user: 'John', text: 'Hello world'}\n```\nThe field option can be combined with async option, a more complex example is in helper's spec.\nAlso async send's atomicity is now fixed, at the cost of enveloping only 1 data packet sent to the out at a time. But multiple ins are usually merged into one out packet anyways.\n. When working with GroupComponent I often forget to put options/ports on a line after function definition. So maybe putting options in front of func is better:\ncoffeescript\nhelpers.GroupComponent c,\n  in: ['x', 'y', 'z']\n  out: 'point'\n  group: true\n  , (data, groups, out) ->\n    chai.expect(data).to.deep.equal src[groups[0]]\n    out.send data\nWhat do you think?\n. GroupedInput is fine by me. The shorter the better :smile: \nOn job rejection, which event would activate it again and how does it select which jobs to retry?\n. @bergie Have a look at the updated spec and tell me whether postpone() and resume() methods can do what you want.\n@djdeath Could you please check if GroupedInput has the complete toolbox now and is capable of all the things you did with noflo-component-wires?\n. Node.js, any subgraph in the app fails with this error. Upgraded from 0.5.0 via npm update today I guess.\n. @bergie You're right, some components depend on noflo 0.4.5.\n. I'll create separate issues for them later today.\n. Refs #166 \n. @bergie I don't think it is possible because process functions cannot be attached to specific addressable port indexes only. So far it merges regardless of addressable port index.\n. @bergie Windows build failure isn't affected by Helpers, I'm afraid. I want to update CHANGES and document GroupedInput properly after it's more or less settled. I'm currently thinking over your job rejection idea and I'm probably done with it.\n. No comments from the community so far, I'm closing the issue.\n. @bergie, agreed, exposing some of these params at the network level would be useful. I actually use ordered (sync) option at graph level in GoFlow. But here comes the question: should these parameters be a part of the protocol/graph specification, or it should be a kind of IIP?\n. @bergie, regarding #130  Node.js streams API is quite different from what FBP substreams do, but I found one important thing in its docs: it could be used to emulate \"blocking\" sends @jpaulm insists on. But IMO blocking sends is not a must in a data processing system that has other facilities to deal with guaranteed delivery and overload rejection: event queue,  load ports, etc.\n. Sorry for that! Noticed it myself yesterday. Interestingly, Travis passes even if phantom tests fail.\n. A sidenote one: I found traits to be very hard to mix in together. I tried to split GroupedInput into several feature traits, but it didn't feel good (+100 LOC which don't do much but configuration of configuration). In the end one big configurable trait worked and looked better.\nA sidenote two: I believe we need a better name for GroupedInput now that it can group both inputs and outputs and has other useful patterns built in.\n. Merged helpers for #185 here because they depend on previous commits.\n. I've no idea on how to make the spec work on browser build though.\n. @bergie Graph JSON schema needs updating, please reopen this issue.\n. :+1: \n. You can actually use myComponent inside of handleGroupedData, but binding this to it shouldn't be hard, will implement it shortly.\n. I think we could reconsider WirePattern vs. noflo.Component interface and make it baked in in noflo 0.6. For 0.5 let's just stick with the way it is and make the best practices out of it.\n. @jonnor Promises are not used in the proposed API itself, it's doSomething() example function which is invoked inside of process body that returns a promise. It doesn't affect the API itself, it's just a mere example of async code which could be callback-style or synchronous as well.\nI'm a bit hesitant of using Promises in NoFlo itself, at least for sake of older browser compatibility, extra dependencies and performance/memory footprint.\n. TLDR from jpaulm/jsfbp#14 and jpaulm/jsfbp#25: blocking reads can be emulated in plain JavaScript using Promises relatively easily, but back pressure is rather complicated. It would be nice to have super-classical option, but not worth sacrificing simplicity and performance IMO.\n. I would argue that it is a graph author who decides when a component should react to its input.\nI often use components that have strong separation of processed input and controls. For example, a component that writes a post on behalf of a user into database. Inputs: post, user objects. Controls: database connection handle, and some static data like tableName. A component decides when to write what and where. If it was up to a graph, there could be a situation when it would make a meaningless write on database connection reset, for instance.\nIn IDEF0, difference between input and controls is visible on graph level (input arrows enter the box on the left, controls enter it on the top side), but input and controls can't be swapped because they are defined in the component. In Classical FBP, all the firing logic and component behavior is encapsulated in process function and the only way to tell a graph author about port specifics is by documenting it. CFBP doesn't lean towards super-reusable microcomponents, or super-configurable macrocomponents, so a graph author deducts what a component does and what input it expects either from documentation, or from code, or by a mere assumption if it's simple enough.\n. Swapping controls to inputs and vice versa in the graph would sometimes make sense, yes. But a component author should be very careful about it then, providing edge cases for every possibility. E.g. database components must always be written with data property based sharding in mind. Aren't we introducing too much complexity here?\n. All IPs are now objects which may have scope. Control IPs is not an exception.\n. @jskrzypek you're right, I've already dismissed Promises as current priority because without backpressure they have almost no benefits. But now I have something to study over the weekend, thanks for sharing this!\nDo you have any idea of what performance penalty it could be to base InternalSocket on RxJS?\n. I've settled with a Controls idea as simple as this:\n- control flag changes behavior of InPort.buffer and  InPort.receive(): when it's false (default) the buffer stores all values and receive() shifts the packet off the buffer; when it's true the buffer stores the current value and receive() doesn't remove the packet from buffer. The flag can be flippable on Graph/Flowhub level\n- triggering flag controls another aspect: when true (default) a new packet on the inport does trigger the process function, when false it doesn't\n. Bounded Queues + Observables, hmm, isn't this getting rather complicated? Time to slow down and ask a question: what problem are we trying to solve?\nMost likely it is getting 2 missing characteristics of Classical FBP in NoFlo: blocking reads and backpressure (which is blocking writes in CFBP). Let's see what these 2 are used for in CFBP:\n- Blocking reads suspend the downstream process until the data from exact inport arrives. Given the multithreaded long-running nature of CFBP, this is the way to program firing patterns within the process function itself. Given single-threaded EventLoop in JavaScript, this probably isn't the desired way to program firing patterns in JavaScript. In JS non-loopers are more simple and lightweight than loopers, so checking for a pattern match on every packet and calling the process function is what NoFlo currently leans toward: why use Promises and Observables for the job that the Event Loop does for free.\n- Blocking writes suspend the upstream process when the downstream process is busy and the connection buffer is full. This is just one of many potential solutions to rate limiting and whether it is lossless or lossy depends on the upstream process details. E.g. if the upstream reads from file, it can safely idle when paused, but if it listens to UI events, some of those events will be definitely lost when paused. As you see, the problem of rate limiting is application specific and blocking writes is not a silver bullet for it. RxJS actually provides more options for backpressure than CFBP does, but it goes far beyond the simple concept of a bounded buffer and ports on its ends. Keeping rate limiting simple and yet effective is an open question for now.\n. @gabejohnson js-csp looks interesting, definitely worth trying and considering for e.g. NoFlo 2.0.\n. This might conflict with the changes I was going to commit today. I'll try to merge it with my branch first.\n. @hayesmg The tests pass, but could you give it another try and make sure all logical branches are covered in the code? It is also not obvious from the code, where exactly the new extensibility appears.\n. So the main goal is being able to overload createComponent() part of load(), the rest is just the same code split into methods.\n. Is it worth putting one-liners createComponentWithGetComponent and createComponentFromFactory into separate methods then? Would you like to overload those as well?\n. IMO, createComponent adds a decent level of granularity there already. For sake of simplicity, could you just add that argument check and inline back those 2 methods for now? We can make them separate methods later if there's a real necessity in it.\nThen we'll be fine to merge it.\n. We need another async spec which checks if the sequence of events on an InPort is correct: default value, then IIP, then normal IPs.\nstartup() should utilize @started value to avoid accidental duplicate calls. Then we could bind it to once 'connect' or once 'attach' on all inports. Brighter ideas appreciated.\n. Let's stick with once 'connect' method for now, attach could be too early.\n@hayesmg, will you give it a try? It would also be nice to rename startup() to just start() (similar to Network) and add the isStarted() method.\n. Nice one! We also need Component.isStarted() for #212.\n@bergie Could you merge this for now please?\n. @bergie I've spent loads of time trying to implement this properly. Fixed a nasty data grouping bug in WirePattern along the way. But the summary for this issue is the following:\n- disconnect forwarding works nicely for sync components\n- it partially works for async components but is not reliable, I'd recommend forcing disconnect at the end of each async proc call for now\n- it isn't possible to implement proper flows until we switch all internalSockets from EventEmitters to Streams, because with EventEmitters it is impossible to know ahead whether a disconnect will follow a packet or not.\n. Clear as if the helpers were just applied or clear as if helpers were never applied at all?\n. OK, sounds good.\n. What if send() is never called on a parameter port which is required but has a default value?\n. Tests pass, AppVeyor fault again. This can be safely merged.\n. I'm honestly not aware of how networks are shut down in NoFlo. In most traditional FBP implementations networks are shut down with downstream propagation of connection closing:\n1. Graph inports are closed to terminate the network.\n2. When all of a process' inports have been closed it shuts down and closes its outports.\n3. This causes downstream processes to shutdown gracefully.\n4. The network is considered to be shut down when all of its outports have been closed or when all of its components have signaled it that they have shut down.\nDownstream propagation has an advantage of graceful shutdown: it can finish current requests before going down. However, there's an alternative strategy of immediate termination:\n1. When a network is started, it keeps track of all processes belonging to it.\n2. A termination signal is sent to all network nodes at the same time.\n3. Each node terminates ASAP and sends the network a signal that it has finished.\n4. When startedCount == finishedCount the network is considered to have been shut down.\nIn NoFlo, however, connect and disconnect events have a different meaning and indicate beginning and ending of a single transmission rather than wiring up and shutting down the graph. attach and detach are closer to connect and disconnect in traditional FBP, but connections are attached and detached during normal functioning because of NoFlo's run-time evolving nature.\n. As we discussed with @hayesmg on IRC, there are 2 obvious solutions of the problem:\n1. Make the Network send the list of expected IIPs to each component.\n2. Remove defaults intelligence from WirePattern and make sending defaults manual when working with individual components.\n. @hayesmg, you are right, that doesn't make much sense for standalone components.\nI'd do it this way then: disable defaults sending in WirePattern but make it expose sendDefaults() method that can be used in specs instead of calling send() manually on each port with a default value.\n. Yes, it already does that. And it creates a temporary socket if there's no socket attached to an inport and detaches it after sending the default value.\n. Hi @DQvsRA! You've done a good job giving an intro to NoFlo/FBP and making a tutorial for Flowhub! We really appreciate it and will post a link to your article in our social feeds: https://twitter.com/noflo, https://twitter.com/Flowhub_io, Google+ and Facebook.\nCould you give us a permission to translate your article into English and publish it in a blog (with a link to the original page, of course)?\n\u041e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u0440\u0435\u0441\u043f\u0435\u043a\u0442 \u0437\u0430 \"\u0422\u0435\u043a\u0443\u0447\u0435\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\". \u0423 \u043c\u0435\u043d\u044f \u043e\u0431\u044b\u0447\u043d\u043e \u043d\u0430 \u043f\u0435\u0440\u0435\u0432\u043e\u0434 \u044d\u0442\u043e\u0433\u043e \u0442\u0435\u0440\u043c\u0438\u043d\u0430 \u0443\u0445\u043e\u0434\u0438\u0442 \u0446\u0435\u043b\u044b\u0445 5 \u0441\u043b\u043e\u0432: \"\u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435, \u043e\u0441\u043d\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u043d\u0430 \u043f\u043e\u0442\u043e\u043a\u0430\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\" :grinning: \n. This change actually causes long-existing apps to hang because subgraphs are never started. Is it a requirement now that all subgraphs should be added a start port to start working again?\n. An array inPort would make sense if several components were connected to the same component and data processing would be somehow different depending on array index. It seems to me that what you are trying to do is just sending a sequence of strings to be processed independently. In this case it's just\nSender NAME -> TASKS Receiver\nwhere Sender emits one name and Receiver processes one task per invocation.\nAn addressable port makes sense here if Sender emits several names per invocation and those are combined per Receiver invocation, e.g. Receiver uses TASKS[0], [1], [2] and [3] to produce a single output packet.\nAs for WirePattern, it doesn't have any specific support for addressable ports, i.e. it deals with ports regardless of array index.\n. So, it actually looks like:\nSender0 NAME -> TASKS[0] Receiver\nSender1 NAME -> TASKS[1] Receiver\nIs it important that all 0...N names should arrive at TASKS port for Receiver to do something with the array?\n. @hayesmg PacketsToArray cannot be used here because data is coming from several senders, each sending a disconnect after a data packet.\n. @paulyoung then either an addressable port is needed here (which is not settled in WirePattern yet, see #240), or a Merge component that would merge packets arriving at inputs 0...N to a single output port as a sequence of N data packets followed by a disconnect, then PacketsToArray can be chained after such a Merge node.\n. WirePattern requires its in ports to be required implicitly because the processing function will never be called if one of the in ports isn't attached or doesn't receive data. Optional inputs here are hard to implement because WP has to know it ahead of time whether it needs to wait for data on that inport or not.\n. Agreed, this causes confusion. I'm not sure throwing an exception would be the right solution here because most components just omit the required attribute for sake of simplicity.\n. Yes, this is affects it too.\n. Now it won't set it implicitly to true, neither will it throw an exception (because sometimes non-required ports are used to wire up the graph at run-time). It's left up to a component designer: if used properly, everything is fine; if a connection on in port is never established, it will deadlock.\n. WirePattern does not use built-in port buffers, however it maintains several buffers of its own to synchronize incoming data. Marking a parameter as required makes the component wait for that parameter before processing any input. If we change it to drop all the input before all required parameters are received it would cause unexpected loss of data in many cases, or many components will likely have to set buffering: true on their ports.\nAlternatively, an option could be added to WirePattern to drop premature data instead of buffering it. Does it have to be port-specific or could it work for entire component?\n. In some cases you'd want input ports to wait for all sockets too. We might want a config option for this.\n. See implementation details below:\nIf a param port is addressable, the component waits for data on all its attached indexes to arrive before proceeding. In proc function such a parameter is accessible as an object with keys matching port indexes, e.g.:\ncofeescript\ncomponent.params.arr = {\n  0: 'foo',\n  1: 'bar',\n  2: 'baz'\n}\nIf an in port is addressable, the component activates the proc function whenever data arrives, given that data on other ports has also been received. The data on an addressable port is an object with keys matching port indexes. E.g. if just one packet was received while data on other ports arrived, it will contain just one element, e.g.:\ncoffeescript\ndata.arr = {\n  1: 'bar'\n}\nBut if several indexes were triggered while waiting for other ports, it may contain several elements:\ncoffeescript\ndata.arr = {\n  0: 'foo',\n  1: 'bar'\n}\nTherefore for components with just one in port, it is always passed one array object per invocation.\nThere are cases when a component should act the opposite way: wait for just any param index or wait for in on all indexes at once. That's why there are several \"waiting\" policies for array ports available, with the above example used by default:\ncoffeescript\nnoflo.helpers.WirePattern component,\n  in: [ 'd1', 'd2' ]\n  params: 'p'\n  out: 'out'\n  arrayPolicy: # these are defaults\n    in: 'any' # trigger on any index\n    params: 'all' # wait for all indexes\nOther combinations are also possible, e.g.:\ncoffeescript\nnoflo.helpers.WirePattern component,\n  in: [ 'd1', 'd2' ]\n  params: 'p'\n  out: 'out'\n  arrayPolicy:\n    in: 'all' # wait for all indexes\n    params: 'all' # wait for all indexes\n. This feature is not going to be used frequently, but it's safe to merge for those who need it. AppVeyor couldn't even connect to Github, so we should rely on Travis passing.\n. @jonnor :+1: \nIt's much better this way. Currently I have to implement custom ComponentLoader to separate test graphs/components from the exposed API.\n. See #198. Usually params are used to configure the component before processing the input.\n. I haven't tested it with output from a component either, so it could be a bug indeed. Theoretically there should be no difference between an IIP and a normal IP.\n. I've added a test for this in Helpers spec (see link above) but it passes. Seems like it's something with the FBP parser or addressable ports in Networks.\n. @paulyoung could you make a spec that reproduces this issue for you?\n. @paulyoung thanks! That should be sufficient!\n. Just need to make sure that randomValue is unique among other connections between these nodes and ports then.\nOn a side note: how about named edges? It's sometimes good to give edges meaningful names in the UI. I saw proposals for it somewhere but I can't remember where it was.\n. See #100\n. Yes, the obvious solution is passing params in the arguments. We have plenty of arguments in processing functions already, so maybe we could merge param values with the first input argument?\n. Great job on benchmarks @robhawkes :+1: \nLooking through the code of those emitters, all of them are based on direct function calls and therefore are synchronous. It's 2015 now and still no native EventEmitters on browser? I wonder how something like https://developer.mozilla.org/en-US/docs/Web/API/Event.Event would behave.\n. Any known side effects?\n. Confirmed, the bug affects WirePattern if there is only 1 input port. The specs use at least 2 input ports and they pass.\n. Any error output in noflo-nodejs console? Is it using the current git master of noflo?\n. I just wonder how you got the fix applied to your runtime so that it started throwing that error. Git repo urls don't always work. The quick and dirty trick to have an unreleased noflo dependency running is to clone it to a separate repo, run npm install && grunt build in there and then just copy the files over to node_modules, replacing an existing package there.\n. Ok, i'll check it later this week.\n. Sorry @ComFreek, couldn't get it working so far. Currently getting\n\nRegistration with Flowhub failed: CERT_HAS_EXPIRED\n\nerror when trying to run a noflo-nodejs runtime. Am I the only one who gets this?\n. Seems like we need some help from @bergie here.\n. @ComFreek I've checked your example. In Flowhub it was the same for me as in your 1st post because it kept using browser runtime of NoFlo no matter what i tried.\nThen I ran it in console. First with a published 0.5.11 noflo build:\n$ ./node_modules/.bin/noflo graphs/TestGraph.json\nNew data from 'WirePattern'\n{ '0': '5' }\nNew data from 'WirePattern'\n{ '1': '10' }\nThen with a patched noflo from git:\n$ ./node_modules/.bin/noflo graphs/TestGraph.json\nNew data from 'WirePattern'\n{ '0': '5', '1': '10' }\nHere is the gist: https://gist.github.com/trustmaster/b49965fcd4499964ecdf\n. Don't forget that you need noflo-core on Node.js.\n. arrayPolicy only applies do different indexes of the same addressable port (ArrayPort in FBP terms). WirePattern currently doesn't support any policy for its grouped in ports, that behavior is provided by particular port events.\n. @robhawkes We're planning to merge WirePattern into noflo.Component given all the practical observations such as this issue. We also plan to replace the current port binding in WirePattern with the concept of Firing Patterns which would allow you to set activation masks and bind different handler functions to them. That would be better than adding even more cumbersome configuration to WirePattern.\n. @robhawkes We discussed WirePattern update during a mini NoFlo meetup in April, you can find the protocol here: https://docs.google.com/document/d/1_7ExwbugP8Q8LNaaysRwWxny9sgb9FomXL0Vs8sU0cc/edit#heading=h.ggqvo151ftpf\nI started with the implementation but it is currently suspended until we roll out The Grid Beta, afterwards we plan to work on NoFlo 0.6 update.\n. @robhawkes To be clear, WirePattern doesn't forward groups arriving at Param ports. And normally group forwarding works like this:\n1. Grab all groups coming to an in port until a data packet.\n2. Flush all groups when data arrives.\n3. Process data and send results.\n4. Close as many groups as needed.\n5. Forward disconnect packet if got it from input.\nThis is called data-sensitive or data-triggered behavior and it is the most common yet not the only one supported in NoFlo. For more advanced cases like handling complex nested substream structures, there are two options available:\n- Raw ports API (without WirePattern)\n- receiveStreams option. It is not documented but there are examples in tests: https://github.com/noflo/noflo/blob/master/spec/Helpers.coffee#L475\nUnfortunately I couldn't deduce the exact packet sequence from the above screenshot (it should include group ends and disconnect packets for picture to be complete) so I can't tell for sure if it's a known issue or not. Sorry, I missed original bug report back 4 months ago too.\n. This seems to come from the early days when WirePattern could be described in one weird sentence. Do you think we could just drop it?\n. Yes, this is how I see the backwards compatibility: the old Ports API will emulate the old-style raw data and events.\nThe next question is: given 3 years of NoFlo experience by now and the IPs being switched to objects, do we still need all 7 types of events in the new API? Or can connect, disconnect, beginGroup, endGroup be safely substituted with just bracket IPs?\n. Here is where I got so far: https://github.com/trustmaster/noflo/blob/ip-objects/spec/Component.coffee#L212\nSee both test cases for new Ports API (yes, sorry for that) example.\nI had to use some new method names to keep the old API fully available.\nThe InPort maintains compatibility layer between the old raw packets with 7 event types and the new object packets with 1 event type. So the old-style components can be combined with new-style components within the same graph.\nI've added InternalSocket.post() method because connect/disconnect events are considered as optional. This is to avoid the annoying disconnect() every time you just want to send a single packet, and to avoid littering the compatibility layer with unnecessary openBracket/closeBracket packets.\n. @bergie 2 concerns:\n1. Some 3rd party packages just throw exceptions regardless of error handling convention they follow in the docs. E.g. stripe can suddenly throw an exception instead of returning err in callback in non-fatal situations such as CVC code being wrong. Would this mean a process.exit(1) from now on and try/catch everywhere \"just in case\"?\n2. How does one disable debug mode when embedding networks via ComponentLoader? Should be documented.\n. I'm the first person it would make happy if it fixes the async exceptions popping up in random places across the graphs :+1: \nJust need to make sure all possible side effects are known and the feature is documented.\n. @bergie yes, for scope should be used for any isolation/scoping purpose.\n. Added checklist in the opening post.\nI need some help identifying use cases for cloning packets vs. passing by reference.\n. @bergie yes, generators need to be ignited by a incoming packet at some point, the question is how they activate and deactivate on incoming data or requests.\nE.g. an HTTP server just starts and sets its handlers, it doesn't keep being activated all the time. In the above example we could imitate that long-running behavior by calling activate() on start packet and deactivate() on stop.\nAnother example is a component reading data from a Node.js stream or listening for DOM events. It is likely to be activated and deactivated on every chunk/event. The runtime is more probably interested in stream end event though. And for DOM events I dunno.\n. Key notes from a Slack discussion:\nThere are 2 sets of 2 events each emitted by components and their parent networks:\n- started - a node has been initialized and started accepting packets\n- activated - a node has started processing some packets\n- deactivated - a node has finished processing current packets\n- stopped - a node has no jobs queued and has stopped accepting and processing packets\nFor normal components, process function, WirePattern, or AsyncComponent doAsync handles the activated/deactivated automatically. Generators have to emit these themselves and should be provided with methods to send these events to parent network.\nIf a component sends a packet to its outport while the network isn't running or the component has earlier declared itself as deactivated, the packet should be dropped and the network should emit a process-error.\nLong-running networks can activate/deactivate for many times during a single lifecycle. Their lifecycle is normally ended by calling stop() externally.\nBatch networks (ran via noflo-nodejs --batch) should call stop() on themselves automatically after receiving deactivated event.\n. @bergie #455 makes the Network emit correct events and require callbacks. Then it's up to runtime how to use them. If you think it's beyond scope of this issue, then feel free to close it.. Thanks for comments, that makes sense and aligns with my own opinion.\nI have further questions about error handling:\n1. What does it mean for error to be aware of brackets? Does it mean automatic forwarding of all brackets received prior to activation? Wouldn't it clutter error handling?\n2. How about components like validators which can emit a list of errors rather than a single error object?\nThe the original question on buffer bounds is still open.\n. @automata all these questions are legit as I haven't bothered writing the docs yet as we haven't discussed this API before.\n- control ports are input ports which remember last received value. input.get() returns a value without moving it off the buffer for control ports. So they are the replacement for the old WirePattern param.\n- triggering: false is an orthogonal feature which was a part of WirePattern param before. Non-triggering ports don't call the process handler. They can be control or non-control.\n- return unless input.has \"foo\", \"bar\" makes sure that both foo and bar inputs have data to be received. This is the way we describe firing patterns in NoFlo 1.0. Here is a more complex example:\ncoffeescript\nprocess (input, output) ->\n  return unless input.has 'arr' or input.has 'foo', 'bar'\n  if input.has 'arr'\n    # Direct buffer access\n    found = false\n    for item, index in input.ports.arr.buffer\n      # Find something among all buffered packets\n      if item.something is 'foo'\n        # Do something\n        found = true\n      return unless found\n  else\n    [foo, bar] = input.get 'foo', 'bar\n    # ...\n- output.sendDone() is used to send activation results and deactivate the process with a single line and is recommended in most cases. output.send() is used to send intermediate results during the activation and requires calling done() to deactivate\n. @automata \n- when control receives a new value it moves the previous one off the buffer. So it has a buffer limited to 1 item\n- exactly! control: true + triggering: false == WirePattern.param\n. Error handling is now on board. Proposed ways to send errors include:\ncofeescript\nprocess: (input, output) ->\n  output.sendDone new Error 'Should be an error instance'\ncoffeescript\nprocess: (input, output) ->\n  errors = []\n  errors.push new Error 'Multiple errors per activation one'\n  errors.push new Error 'Multiple errors per activation two'\n  output.sendDone errors # Produces a substream\nSame way of passing errors is supported by output.send() and done() functions. All errors should be Error objects or inherited from Error class.\nThis PR is now fine to be merged.\n. @jonnor in that particular example it's common because a transaction gets rolled back e.g. if data validation fails. It's probably a bad design but the problem is wider than transactions in particular.\n. @jonnor via a long callback chain or promise chain that returns or throws at some point, which is not very concurrency-friendly.\n. This is something that should be handled on application architecture level, not by the underlying runtime. E.g. noflo-assembly attempts to solve this problem alongside with other things.. Reviewed and approved :+1: \n. @bergie done\n. Is there a definition for a map-style component?\n. That may be too fuzzy to infer automatically, so i'd vote for explicit yet convenient options.\n. How about\n``` coffeescript\nc.inPorts.add 'in',\n  datatype: 'string'\n  pickBrackets: true\n...\nc.process (input, output) ->\n# ...\n  output.sendWithBrackets\n    out: something\n```\n. or even\n``` coffeescript\nc.inPorts.add 'in',\n  datatype: 'string'\n  pickBrackets: true\nc.outPorts.add 'out',\n  datatype: 'string'\n  pushBrackets: true\nc.process (input, output) ->\n  # ...\n  output.sendDone\n    out: something\n``\n. I agree that we should once again be thoughtful in our apps about what brackets are used for. They should only be used for substreams, not for tagging data with ids and metadata.\n. For example, here is a quicker way to add bracket forwarding toParseYaml`: https://gist.github.com/trustmaster/c7117776d2aab3a18fecffa7f44ae5ac\n. > Example where bracket forwarding is useful:\n\nSplitArray OUT -> IN SomeOperation OUT -> IN PacketsToArray\nThis is roughly equivalent to a Promisified version:\ncoffeescript\nPromise.map someArray, someOperation\n.then (result) ->\n\nI think raw bracket forwarding is incorrect for this case, because maintaining the order of packets like <, d, d, d, > makes the whole operation act like Promise.mapSeries rather than Promise.map. If SomeOperation is supposed to be concurrent and stateless, then SplitArray and PacketsToArray should be replaced with a kind of Map and Reduce components, which would either create a dedicated scope for each collection, or tag and untag data. I'd see it like this:\n1. Map splits the array and tags each packet with two properties: collectionId, collectionLength.\n2. SomeOperation processes the data and forwards collectionId and collectionLength with the result IPs.\n3. Reduce assembles the collection back.\n. Here is another side effect of automatic bracket forwarding: it is only possible for asynchronous components that maintain output queue, or ordered: true in other words. Otherwise the order of bracket and data packets could be messed. If most elementary (or \"map type\") components are serialized in this way, this would imply a massive concurrency limitation. On the other hand, this is how both NoFlo and CFBP have been working so far: ordered by default.\nI really like the @jonnor's idea of making map-style components modify the original IP instead of creating a new one. But it requires a slightly different convention for writing such components and probably some artificial way to enforce it.\n. Here is the case that got me blocked on bracket forwarding. Given a mapping as simple as\ncoffeescript\nforwardBrackets:\n  in: [\u2018foo\u2019, \u2018bar\u2019]\n(which is from in to both foo and bar) and a fact that most components would like to send the output one way of the possible two, and they decide where to send and when inside the process function. The implementation i currently have automatically forwards brackets to both, but if the component only sends data to foo then bar gets empty brackets. There are 2 ways to fix it that i can think of:\n1. Only send brackets if a process function sends something. This sounds right, but it has two side effects:\n   - It would keep silent between output.sends, especially if sends are not on every activation\n   - Closing brackets may arrive at the input after process activation and they would be pending until next activation (which may never come)\n2. Detect and remove empty brackets from output buffers. This has the obvious side effect of not supporting empty streams.\nInput is very welcomed on this dilemma.\nAnother question that results from the same mapping is a case where the component actually wants to forward brackets to both outports at the same time.\nAnd for those who wonder how i decided to handle mappings like\ncoffeescript\nforwardBrackets:\n  foo: ['out']\n  bar: ['out']\ncurrently it would combine brackets from both foo and bar in the order they arrive. I don't know how right this approach is, but it's there.\n. Yes, this issue is mostly about specifying index when sending raw value.\n. Adding index support to send() and sendDone() would complicate already complex object logic even more. So, instead we'd want to add index to sendIP() here and tell in the docs that if you need to send data to specific port index, you should do it by calling sendIP() for each packet:\ncoffeescript\nip = new noflo.IP('data', 'fooobar')\noutput.sendIP 'out', ip, 0\noutput.sendIP 'out', ip, 3 . Yes, that's a valid option as well.. @bergie \ud83d\udc4d good to go\n. Here is what's happening there:\n1. An opening bracket arrives and is buffered\n2. Data arrives and triggers the async process function\n3. A closing bracket arrives and triggers dropEmptyBrackets handling code\n4. dropEmptyBrackets looks at the buffer but doesn't see the data between open and close bracket in the buffer, so it decides to drop them\n5. Process function sends the error but it's too late to wrap it with brackets\nThe desired behavior for it is to add a pending data item to the output queue on step 2, so that it doesn't drop the brackets on step 4. Adding that requires also dropping the pending data item together with brackets if the process function never sends data between those brackets.\n. Here is what's happening here:\n1. process function gets called and it disposes the packet before returning control\n2. legacy data event handler is called for the same object but it is already destroyed and it crashes\n. @bergie \n- Removed dropEmptyBrackets option which was conflicting with asynchronous components. This results into empty brackets being forwarded to error outport, so make sure error handling components don't make false alerts on those.\n. @bergie a solution is to check for an attached connection upon forwarding\nthe groups. Not that hard to fix.\n. @aretecode the specs are good coverage but they are not checking actual output the component sends. If you add code listening for the output and checking what comes out before calling done that would be way better.\n. @aretecode @bergie this one is good to merge. I wonder why AppVeyor keeps failing on this saying that it's \"non-mergeable\", but maybe it will be just fine when merged.\n. @bergie \u261d\ufe0f \n. I wouldn't go for inventing IPQL here (IP Query Language) and stick with callbacks which can do any sort of matching. How about these 3 methods:\n``` coffeescript\nGet a buffer (scoped or not) for a given port\nbuffer = input.buffer.get portName\nFind packets matching a callback and return them without modifying the buffer\nips = input.buffer.find portName, (ip, index) ->\n  ip.type is 'data' and ip.data isnt null\nFind packets and modify the original buffer\nbrackets = []\ninput.buffer.filter portName, (ip, index) ->\n  if ip.type isnt 'data'\n    brackets.push ip\n    return false # Remove from buffer\n  true # Keep in the buffer\n```\n. We've changed exception handling in process function so this doesn't throw anymore but rather deadlocks trying to send the error. That needs to be fixed too.\n. @bergie updated. @bergie fixed and good to go \ud83d\udc4d . @aretecode a few minor notes, as for the rest a very neat PR.\n. @aretecode great job!\n@bergie this is good to merge\n. The only way to implement this that i can think of is doing it the same way WirePattern did: maintain separate buffers for forwarded brackets (separate buffer per port/scope) and flush them at once when there is data to flush them with.\n. To give you guys some idea of the stuff i'm facing with this humble tiny issue and why it's taking so long. Got an interesting case while debugging today.\nIn this component: https://github.com/noflo/noflo/blob/master/spec/Component.coffee#L1101\nA simplified description of what's happening there. Here's the stream on the input:\n<msg>\n<delay>\none, delay: 30\ntwo, delay: 0\nthree, delay: 20\nfour, delay: 10\nfive, delay: -40\n</delay>\n</msg>\nSo, because of the delays, the results are yielded to out in sequence: two, four, three, one. And five fails immediately and sends to error. But the input/output is ordered, so it will still send it to output in sequence it arrived on input: one, two, three, four, five.\nAs the error happens first, it forwards brackets to error port, so five gets wrapped with <msg><delay> five </delay></msg>. Which is expected (?). But as this way brackets have successfully been forwarded, the results sent to out port later on don't get wrapped with brackets. Which is unexpected (?).\nI foresee comments like \"OK, just make it forward the brackets to the main port as well, because we kind of expect it\". Easy to say, because currently the framework maintains just 1 buffer for brackets, and sends them to the port that actually gets sent to, without being aware of what else may come in future.\nI have an idea how to \"fix\" this: maintain separate bracket buffer per output. Which complicates things. Another idea is to make the framework scan the output queue back and forth to decide where to send brackets, but it complicates things even more, probably a lot more.\n. Here is the current state of bracket forwarding. We now have 2 different implementations of bracket forwarding:\n1. In master branch, based on inserting brackets into certain points of the output queue\n   - Pros: works well with async components with 1 in port or multiple ports when input streams overlap in time\n   - Cons: doesn't work with async components when input streams don't overlap, e.g. fails the test in the top post of this thread\n2. In bracket_forwarding branch, based on dedicated bracket buffers which are flushed on output.send() and output.done()\n   - Pros: works with async components when input streams don't overlap, i.e. passes the test in the top post of this thread\n   - Cons: produces wrong results if the input stream is processed concurrently with output.send() and output.done() being called in an order different from the expected output, e.g. fails the test described in previous post\nThat means yet another model is needed to solve the bracket forwarding problem. Maybe something like hybrid: output + bracket queues with bracket queues sliding along the output queue as needed. I'm not sure if generic automatic bracket forwarding is at all possible with async functions and multiple inputs/outputs.\n. Note: above comment updated.\n. Already doing it in this branch: https://github.com/trustmaster/noflo/blob/network_states/src/lib/Component.coffee#L141\n. Please don't use the old socket methods in specs and post IP objects instead, because the old methods will be deprecated.\nOtherwise these specs will get broken by #468 because it doesn't turn brackets into connect/disconnect and doesn't automatically send brackets on .post() (it only sends connect and disconnect to legacy components but doesn't make brackets for them).\n. @bergie ready for review\n. Found a bug in this PR, fixing.\n. @bergie feeling brave to review this?\n. @bergie added scopes to errors and updated per other notes.\nRegarding deprecating async: false and #370, are we going to backport features to WirePattern until 2.0?\n. I vote to put this PR on hold until we finalize bracket forwarding mechanism because this feature overlaps with its implementation.\n. If we are all agreed to change input.getData() semantics so that it only works with data IPs (while it currently works with .data of brackets too which is legit), then it should consume all the brackets up to the closest data packet, e.g.:\ncoffeescript\nip = input.buffer.get(portName).shift() until ip.type is 'data'\nThen it would consume&skip all the brackets including the closing ones. Some closing brackets may be left until next data arrives, but it's ok since they would be cleared then.\n. @aretecode that line compiles to a normal while (...) { ... } loop. But of course you need one initial buffer shift before that loop.\nI mean there's no need to do a look-behind search and remove brackets as they will be dropped before next data anyways.\n. But your code is just OK.\n. @aretecode good to merge on my end. Should simplify things a lot.\n. @aretecode could you add some notes to CHANGES.md about this?\n. @bergie is it possible to set IP .type property in noflo-ui as well? Because without that neither duck typing nor brackets can work.\n. Any ideas at what stage it may be happening? I can't recall any place where .data is used to detect packet type, the actual check is https://github.com/noflo/noflo/blob/master/src/lib/IP.coffee#L13\n. @bergie thanks, got it. We can try to switch to strict typing then.\n. @jomeier is it really required to port it? NoFlo supports components in any language that compiles to JavaScript, even if the library itself is written in CofeeScript it doesn't mean user code has to.\n. @bergie will do. How does the new algo work, in a nutshell?. @jonnor connect/disconnect are added automatically by legacy translation layer when speaking to legacy components. Source is in InternalSocket.. @bergie the description aligns well with my discoveries earlier. Did you manage to make it work without enforcing the process to activate/call done() even when just checking preconditions?. I think group and field are not really esoteric. They were one of the original reasons for WirePattern to emerge.. @bergie yep, and that's one of the reasons I decided to fix&deprecate WirePattern rather than port it onto Process API back in June.. This only makes sense once all the consumers use brackets properly (i.e. for streams instead of objects), until then it's gonna mess the data flows and affect performance badly.\nThus, somewhen in post-1.0 era.. That's actually expected behaviour. In order to get all packets from the buffer you need to use input.hasStream() and input.getStream(), or a loop over items using input.has() and input.get().. There is no benefit, it's a design tradeoff. Firing patterns in FBP are not always easy. There might be a corner case like this, and components have to take it in consideration.. Mea culpa, I forgot that control ports in NoFlo don't fire. Then, indeed, it makes sense to do what @bergie suggested.. Fine by me. Note that currently packets are not cloned/dropped by default and are passed by reference instead. Cloning behavior is something that I thought should be enabled explicitly, but clonable would come useful in either case.\n. I think we need to describe some use cases for cloning. Then it will be easier to provide a practical interface for it.\n. Makes sense. I'll create a checklist for this PR.\n. Component.processOutputQueue() should not be called at all if autoOrdering is false, but I can add a check here to avoid any possible collisions.\n. Added in 2f08925\n. data got me confused here, buffer or buf is a more clear name for what it is.\n. Can't this just be\ncoffeescript\nb = @get name\nb = @find name, cb\nalso returning the modified buffer here makes sense\n. Please use .post() instead, the old socket methods will be deprecated at some point in near future.\n. This is not very nice, it's adding 1 sec to all our Travis builds. Maybe there's another way to test incomplete streams?\n. sin1.post new noflo.IP 'data', 'eh'?\n. sin1.post new noflo.IP 'openBracket', etc.\n. Changed this while debugging to put state out of the way. Can make it beforeEach => before again.\n. Good catch. Simply forgot this.\n. \u2705 \n. \u2705 \n. That will break some things. I'd like to keep backwards compatibility layer as backwards compatible as possible.\n. It would make the async test more valuable if the delays were to simulate some concurrency and test the cases when some processing finishes before the preceding one.. Is this to allow payload on disconnect packets or?. Thus it disallows empty streams like < < > >. What's the reason behind it? My guess is bracket forwarding not working correctly for empty streams. Should be documented somewhere. What's this line for if it's already checked with InPort.has()?. Typo here, should be Last close bracket. Missing (). Missing (). Missing (). Could as well just output.sendDone data. Missing (). Why is result[outport] an object instead of array here?. I thought we would keep that as low-level. But it's your call.. It was rather convenient before that you could check with input.has[Data] 'foo' that there is data on any index at all.. Does it mean that groups are not captured correctly in this test?. gc options only work in legacy mode i suppose, thus should be removed from here. Also, is group by RegExp supported?. Are postpone and resume supported at all? This should be a fatal rather than deprecation warning.. Nice one!. Yes, that would be much better.. Worth mentioning that @error is deprecated itself.. It may be reasonable to check what type of error it is to avoid regressions.. Components may have multiple ports one of which is named IN.. This behavior should be documented and/or there should be an option to return unflattened output. For those who care which ports are yielded together.. ",
    "paulyoung": "Very good point. It seems like ComponentLoader may be a better place to do this.\n. The CLI currently relies on ComponentLoader::listComponents for its output. Internally ComponentLoader::load relies on the same instance variable so perhaps loading would need to become case-insensitive (i.e. convert to lowercase on both sides when matching strings).\n. I introduced a new method since using the existing one complicated things when loading components.\nIt seems odd to me that this is part of the ComponentLoader class.\n. If anyone can offer better insight, I'm happy to go a different direction.\n. When the tests were initially failing, READDOCUMENT did look a bit weird.\n. Closing given https://github.com/noflo/noflo/commit/fd9494fece38de30ef9feb0a438df60fdcb49514 and #100.\n. FWIW - everything was green when I ran tests locally.\n. Thanks for the insight. I actually want to perform an operation on the array as a whole.\nA contrived example would be something like this:\nTake multiple NAMEs (each from different processes) and pass them all to the TASKS port as an array, where internally that component would count the number of tasks in the list.\n. > Is it important that all 0...N names should arrive at TASKS port for Receiver to do something with the array?\n@trustmaster yes, that's correct.\n. An addressable port would be preferred over an intermediate component since that provides an nicer API.\nI may be getting confused with the history of NoFlo. Is the old way to use ArrayPort and the current way to set addressable: true?\n. I understand that WirePattern depends on its in ports being required, but why alter the property and do it implicitly?\nInstead WirePattern could complain when trying to use a port that is not required.\nThis would make things clearer since the single source of truth becomes the required property of a port.\n. Do you mean pre 0.5.7 when required was default?\n. What is the consequence of using a non-required port with WirePattern now?\n. > neither will it throw an exception (because sometimes non-required ports are used to wire up the graph at run-time)\nThis was the part I was wondering about. I thought only required ports made sense.\nThanks for the explanation.\n. I didn't see this in the changelog by the way.\n. This change cause me by surprise so I've been thinking about this too.\nFollowing semver should protect against breaking changes but it gets a bit more complicated before reaching 1.0.0.\nGiven the impact of the change, perhaps it warranted a 0.6.0 release?\n. Perhaps what I really meant was something like fbp.json - a platform agnostic way of declaring components and graphs which could be used across different runtimes but still read by flowhub.\n. Thanks. I did a search in issues but think I got caught out because GitHub now keeps issues and pull requests separate.\n. Let me know if there's anything else I can do to help.\n. I wasn't sure where to start so just created a demo project that reproduces the issue for now.\n. ",
    "rhalff": "I experience the same issue using the fbp protocol.\nIf you make the lowercase decision it basically means all systems talking to the UI are forced to use/send lowercase port names.\nAlthough it is possible to work around this by looking up port names every time one receives a payload and then restore the case sensibility, it does lead to a lot of added complexity to whatever system is trying to talk to the UI.\nI think the impact of changing this seems bigger than it probably is.\nA grep using toLowerCase() will probably reveal most cases:\nbash\n$ grep toLowerCase ../noflo-ui/components -r  (Irrelevant lines remove)\n../noflo-ui/components/noflo-noflo/src/lib/Graph.coffee:    publicPort = publicPort.toLowerCase()\n../noflo-ui/components/noflo-noflo/src/lib/Graph.coffee:    publicPort = publicPort.toLowerCase()\n../noflo-ui/components/noflo-noflo/src/lib/Graph.coffee:    publicPort = publicPort.toLowerCase()\n../noflo-ui/components/noflo-noflo/src/lib/Graph.coffee:        graph.addInitialIndex conn.data, conn.tgt.process, conn.tgt.port.toLowerCase(), conn.tgt.index, metadata\n../noflo-ui/components/noflo-noflo/src/lib/Graph.coffee:      graph.addInitial conn.data, conn.tgt.process, conn.tgt.port.toLowerCase(), metadata\n../noflo-ui/components/noflo-noflo/src/lib/Graph.coffee:      graph.addEdgeIndex conn.src.process, conn.src.port.toLowerCase(), conn.src.index, conn.tgt.process, conn.tgt.port.toLowerCase(), conn.tgt.index, metadata\n../noflo-ui/components/noflo-noflo/src/lib/Graph.coffee:    graph.addEdge conn.src.process, conn.src.port.toLowerCase(), conn.tgt.process, conn.tgt.port.toLowerCase(), metadata\n../noflo-ui/components/noflo-noflo/src/components/Graph.coffee:    return (nodeName+'.'+portName).toLowerCase()\n../noflo-ui/components/noflo-noflo/src/components/Graph.coffee:    return (nodeName+'.'+portName).toLowerCase()\n../noflo-ui/components/noflo-fbp/lib/fbp.js:          result0 = (function(offset, portname) {return portname.join(\"\").toLowerCase()})(pos0, result0[0]);\n../noflo-ui/components/noflo-fbp/lib/fbp.js:          result0 = (function(offset, portname, portindex) {return { port: portname.join(\"\").toLowerCase(), index: parseInt(portindex.join('')) }})(pos0, result0[0], result0[2]);\n../noflo-ui/components/noflo-fbp/lib/fbp.js:          parser.exports.push({private:priv.toLowerCase(), public:pub.toLowerCase()})\n../noflo-ui/components/noflo-fbp/lib/fbp.js:          parser.inports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}\n../noflo-ui/components/noflo-fbp/lib/fbp.js:          parser.outports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}\nbash\n$ grep toLowerCase elements/*\nelements/noflo-context.html:            return portName.replace(/(.*)\\/(.*)(_.*)\\.(.*)/, '$2_$4').toLowerCase();\nbash\n$ grep toLowerCase preview/ -r\npreview/components/forresto-noflo-seriously/lib/SeriouslyEffect.coffee:      nofloPort = seriouslyPort.toLowerCase()\nThe latter seems to indicate all components should then also be checked, but it also shows\nhow the seriouslyEffect component has to do the same conversion.\nhttps://github.com/forresto/noflo-seriously/blob/master/lib/SeriouslyEffect.coffee#L4\n. ",
    "yanko": "any one? help?\n. @kenhkan \nhttps://github.com/noflo/noflo  is what  itried to follow...\n@bergie \nI installed grunt-cli as specified.\nI ran the grunt build:\nC:\\Users\\jpetrovic\\AppData\\Roaming\\npm\\node_modules\\noflo>grunt build\ngrunt-cli: The grunt command line interface. (v0.1.9)\nFatal error: Unable to find local grunt.\nIf you're seeing this message, either a Gruntfile wasn't found or grunt\nhasn't been installed locally to your project. For more information about\ninstalling and configuring grunt, please see the Getting Started guide:\nhttp://gruntjs.com/getting-started\nC:\\Users\\jpetrovic\\AppData\\Roaming\\npm\\node_modules\\noflo>\nno luck for now!\nThank you for helping me!\n. tired that..:\nC:>npm install\nnpm ERR! install Couldn't read dependencies\nnpm ERR! Error: ENOENT, open 'C:\\package.json'\nnpm ERR! If you need help, you may report this log at:\nnpm ERR!     http://github.com/isaacs/npm/issues\nnpm ERR! or email it to:\nnpm ERR!     npm-@googlegroups.com\nnpm ERR! System Windows_NT 6.1.7601\nnpm ERR! command \"C:\\nodejs\\node.exe\" \"C:\\nodejs\\node_modules\\npm\\bin\\n\npm-cli.js\" \"install\"\nnpm ERR! cwd C:\\\nnpm ERR! node -v v0.10.15\nnpm ERR! npm -v 1.3.5\nnpm ERR! path C:\\package.json\nnpm ERR! code ENOENT\nnpm ERR! errno 34\nnpm ERR! Error: EPERM, open 'C:\\npm-debug.log'\nnpm ERR!  { [Error: EPERM, open 'C:\\npm-debug.log'] errno: 50, code: 'EPERM', pa\nth: 'C:\\npm-debug.log' }\nnpm ERR!\nnpm ERR! Please try running this command again as root/Administrator.\nnpm ERR! System Windows_NT 6.1.7601\nnpm ERR! command \"C:\\nodejs\\node.exe\" \"C:\\nodejs\\node_modules\\npm\\bin\\n\npm-cli.js\" \"install\"\nnpm ERR! cwd C:\\\nnpm ERR! node -v v0.10.15\nnpm ERR! npm -v 1.3.5\nnpm ERR! path C:\\npm-debug.log\nnpm ERR! code EPERM\nnpm ERR! errno 50\nnpm ERR! stack Error: EPERM, open 'C:\\npm-debug.log'\nnpm ERR!\nnpm ERR! Additional logging details can be found in:\nnpm ERR!     C:\\npm-debug.log\nnpm ERR! not ok code 0\nC:>\ntx!\n. ",
    "rektide": "Running near 6 weeks now. Please give us docs!!! I'm only interested in NoFlo as far as I can do things with it, and until you have docs for remote protocols, I can not do anything.\n. ",
    "p0wl": "As stated in Google Groups (https://groups.google.com/forum/#!topic/flow-based-programming/v7Wiiyys-Ik ): I'm willing to help but unable to run the tests as https://github.com/jdcataldo/grunt-mocha-phantomjs cannot be installed on windows.\nI'm going to try to fix the paths, but I'm not as familiar as I should be with the noflo internals and coffeescript to be sure that I got it right.\nI would be very thankful if someone with more expertise could replace the the slashes as @bergie suggested. I can verify if it works on windows if someone sends a PR.\n. could you push a new version to npm?\n. Ok, I played around a lot, but didn't find a solution. It seems that it is not possible to load components from files. It seems like everything needs to be included in noflo.js...\nI've tried to create my own noflo.js with grunt-component, but I still fail when loading the components.\nI would love to register a component using require('Name', 'components/Name.coffee'), but this is not possible at the moment, right?\nThe current workflow feels really complicated and is completly not documented. The download page is not giving me any information about how to use my own components in the browser.\n. Hmm, I can't get it working.\ncan you set up an example where a component is defined in a seperate file?\nLets say I want to create a graph in index.html, which is using a component from lib/MyComponent.js\nWould be great to see an example. I think this might answer a few questions from the fbp google group as well:\nhttps://groups.google.com/forum/#!topic/flow-based-programming/v3Seqg0gM9Y\nhttps://groups.google.com/forum/#!topic/flow-based-programming/4zxQguAPqLY\nthanks in advance\n. ",
    "fb55": "Is there a mechanism for syncing IPs? Eg. for an HTTP server, it's incredibly relevant to send the response to the right request.\nAs an example: A query parameter in the URL is used to query some async data source with random response times. As a result, the order of IPs approaching the \"write response\" component isn't preserved.\nAre there any solutions?\n. My current understanding: All state is encapsulated in a single IP and passed through the entire flow - alternatively, it's possible to just carry a unique ID through the flow and resemble the parts later. Anyway, the ID has to be maintained.\nHow does the current structure of components work with that? AFAIK, eg. a math component only accepts numbers, not a group. Or does the runtime handle unpacking?\n. @bergie Thanks for the clarification!\n. ",
    "CMCDragonkai": "The real big issue is definitely that all CS developers know JS, but not all JS developers know CS. This isn't even mentioning all the other compile to JS languages like Typescript.. etc. JS is the lingua franca between these different compile to languages. (http://gaslight.co/blog/does-coffeescript-have-a-future)\nAt any case, it's fine if people want to use CS for their own applications. But if you're distributing a library for wide adoption, you want to enhance your market size.\n. ",
    "alfa256": "Example from the book:\nRead(THFILERD) OUT ->\n      IN Count(THCOUNT) OUT -> \n        IN [0] Concatenate(THMERGE) OUT ->\n          IN Print(THVIEW),\n    Count COUNT -> IN[1] Concatenate,\n   'data.fil' -> OPT Read;\nIt uses IN [0] , and OUT [0] would be the obvious choice.\n. :+1: \nA small benchmark should be in order to make improvements.\n. What are you trying to do Afshin? Having no input ports is not something\ndesirable in FBP. Also can you post your code with the explanation ?\nEl dom., 26 jul. 2015 a las 11:35, Afshin (notifications@github.com)\nescribi\u00f3:\n\nHi bergie,\nWould you mind telling me how to define a component which does not have\nany input port? After I removed the definitions of 'in' port, it says\n<< uncaughtException [Error: no inPort named 'in'] >>\nBEST\nAfshin\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/noflo/noflo/issues/292#issuecomment-124997738.\n. \n",
    "offlinehacker": "I'm wondering if such things are in plan for the future, or how have you imagined this?\n. ",
    "RangerMauve": "Awesome!\n. ",
    "djdeath": "Is the expectation that no component should ever listen to events on its ports?\n. I'm doing http requests handling and some of that processing is obviously asynchronous, like say processing uploaded files. You might have a long chain of asynchronous processes which needs to store the http request, do their actual processing and later on send a response to the http request.\nRight now I'm using the groups/SendByGroups component, which uses the groups to store the IPs and then I get the IPs out using the again the group.\nThe problem is that most of the components at the moment don't emit groups on their error ports, so I don't have a way to figure out what http request was related to a given error and as a consequence I can't even abort/close the http request (ie file descriptor leakage).\n. :+1: I definitively had the same problem with too much computation going on.\nIt's kind of tricky to get right though, because some ports could have inputs only sent once (as initials for example) that you would keep forever and other ports' data need to be discarded after compute.\n. That looks awesome :)\n. Regarding b9584c6a4d92cc0aff513adab9a212e50a753142, maybe groups could be recorded only when specified on the InPort description. That would help save a little bit of computation/memory.\nThere are limited cases where you actually want to use the groups list, in most cases you just repeat the group from input to output synchronously.\n. At some point I was event thinking you would write most of the component logic (group forwarding) in a graphical way. It's kind of wiring ports in the end ;)\n. I'm not sure if isStarted() is of any use for components.\nFor networks it's kind of important to know when initials have been sent and that the thing is actually \"alive\".\nUp to @bergie :)\n. Here is an example : https://github.com/noflo/noflo-gnome/blob/master/examples/2048/components/SquashTiles.coffee\nThe map input port being a parameter, no processing occurs until the data is received.\nOnce it arrives, all the directions received are processed. I would expect that only the last one would be processed, since it's a non buffered port.\n. ",
    "azhang": "\nWe will have to change all requires that use a .js suffix for a .coffee file (mainly in unit tests) to use .coffee\n\nNot necessarily. It depends on the plugin you use. I'm using jade in my project and I've been able to keep my .jade extensions when requireing.\n. Ahh, read it backwards. Not sure what to do in that case, sorry!\n. ",
    "KevinHoward": "You were correct @bergie, I had forgotten to update to update my .travis.yml file with the correct node.js version.\n. ",
    "cwohlman": "Thanks, could we add that to the documentation?\nAlso, my apologies for posting this to the wrong repo, I realize the\ncorrect repo would be noflo/noflo-ui.\nOn Thu, Apr 17, 2014 at 3:24 PM, Forrest Oliphant\nnotifications@github.comwrote:\n\nTry app.html\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/noflo/noflo/issues/159#issuecomment-40758478\n.\n. Thanks!\n. Closer inspection reveals that the description is already supported for json style graphs loaded from the server. I've added a pull request to support icons as well.\n. There seems to be a bug with descriptions created in noflo-ui, the description for a graph created and stored in noflo-ui isn't displayed.\n. \n",
    "automata": "Both work. The git clone git@... uses SSH and should work if you have SSH keys configured properly.\n. I have some questions after reading the proposal, example and tests:\n- First of all, I really like IP envelopes. Having groups (and scopes) in IP class is something I always wanted in Caliper: we have this case where we use groups to identify measurements for a given URL (using URL as group id) and groups keeping growing between components make it easy to mess group ordering. I can imagine that making it sure an IP belongs to a group will make it possible to decide right on the component if we should process the IP of a expected URL, for example. We can probably do that with begin/endGroups but I think this way is much more explicit.\n- I didn't get what inPorts.foo.control: true does. Does it flag that the component will send output (or call process) only when receiving IPs on foo (control) inport?\n- What's the difference between output.sendDone and output.send?\n- Are triggering: false ports like WirePattern's params? BTW it would be interesting to have a guideline doc describing how to migrate from WirePattern to Process, like some patterns like this with examples. I'd like to contribute to it.\n- What's the difference between triggering: false and required: false?\n- In which situation return unless input.has \"foo\", \"bar\" will be true? Is it only a safe check for inports or does it means process will continue only when foo and bar inports are triggered?\nSorry for the number of questions, I don't know if this is the right place to ask them, please point me to a better place if it exists :-)\n. @trustmaster thank you so much for the answers! Going throught them in order:\n- so when do control inports will get their values removed from buffer? When component disconnects?\n- got it, so if an inport is control: true and triggering: false it will act just like a WirePattern param inport, right? Because it will remember last state and will not trigger at same same\n- this is really great, I can see it as a more granular way to decide based on inports presence and data received\n. @bergie maybe we can start referring to this issue on modernization PRs we're currently working, like :point_up:? Would be also nice to have a checklist with all libs so we can track which one was modernized and which not.\n. A list of component libraries from NoFlo org, it would be interesting to check out those ones we already modernized:\n- [x] noflo/noflo-yaml\n- [ ] noflo/noflo-mq\n- [ ] noflo/noflo-basecamp\n- [x] noflo/noflo-xml\n- [x] noflo/noflo-webserver\n- [x] noflo/noflo-html\n- [ ] noflo/noflo-couchdb\n- [ ] noflo/noflo-restfulmetrics\n- [x] noflo/noflo-liquid\n- [x] noflo/noflo-markdown\n- [ ] noflo/noflo-diffbot\n- [ ] noflo/noflo-filesystem\n- [x] noflo/noflo-github\n- [x] noflo/noflo-git\n- [ ] noflo/noflo-oembed\n- [x] noflo/noflo-redis\n- [ ] noflo/noflo-graphviz\n- [x] noflo/noflo-routers\n- [x] noflo/noflo-groups\n- [x] noflo/noflo-strings\n- [x] noflo/noflo-objects\n- [x] noflo/noflo-flow\n- [x] noflo/noflo-packets\n- [x] noflo/noflo-adapters\n- [x] noflo/noflo-dom\n- [x] noflo/noflo-math\n- [x] noflo/noflo-docco\n- [x] noflo/noflo-core\n- [ ] noflo/noflo-physics\n- [x] noflo/noflo-gravatar\n- [x] noflo/noflo-css\n- [x] noflo/noflo-interaction\n- [ ] noflo/noflo-ardrone\n- [x] noflo/noflo-localstorage\n- [x] noflo/noflo-websocket\n- [x] noflo/noflo-ajax\n- [ ] noflo/noflo-gestures\n- [x] noflo/noflo-polymer\n- [ ] noflo/noflo-indexeddb\n- [x] noflo/noflo-knex\n- [ ] noflo/noflo-blockchain\n- [ ] noflo/noflo-mandrill\n- [x] noflo/noflo-graph\n- [ ] noflo/noflo-runtime\n- [ ] noflo/noflo-finitedomain\n- [ ] noflo/noflo-image\n- [x] noflo/noflo-embedly\n- [ ] noflo/noflo-tween\n- [x] noflo/noflo-facebook\n- [ ] noflo/noflo-canvas\n- [ ] noflo/noflo-gnome\n- [x] noflo/noflo-video\n- [ ] noflo/noflo-ccv\n- [ ] noflo/noflo-amd\n- [ ] noflo/noflo-react\n- [x] noflo/noflo-amqp\n- [ ] noflo/noflo-xpress\n- [ ] noflo/noflo-thegrid\n- [ ] noflo/noflo-google\n- [ ] noflo/noflo-peer\n- [x] noflo/noflo-tika\n- [x] noflo/noflo-s3\n- [ ] noflo/noflo-browser-app\n- [ ] noflo/noflo-mirobot\n- [ ] noflo/noflo-browserfile\n- [ ] noflo/noflo-color\n- [ ] noflo/noflo-webaudio\n- [ ] noflo/noflo-geometry\n- [x] noflo/noflo-mqtt\n- [ ] noflo/noflo-gpio\n- [ ] noflo/noflo-imgflo\n- [ ] noflo/noflo-svg\n- [ ] noflo/noflo-stanbol\n- [ ] noflo/noflo-sharp\n- [ ] noflo/noflo-exif\n- [x] noflo/noflo-rss\n- [x] noflo/noflo-hackrf\n- [ ] noflo/noflo-filetype\n- [x] noflo/noflo-ipfs\n- [x] noflo/noflo-jsjob\n. ",
    "waldenn": "Sure, but I was just following along with docs and there was no need to authenticate with SSH, that is just an unnecessary step here imho. A plain http clone works in both use cases (learning and developing).\n. ",
    "Anticom": "Okay, thank's for the information. Still tho it would be nice to have some visual information in the new UI, which types possibly match well. Btw, my Idea was inspired by Blenders composite editor. example (taken from here)\nKeep up the good work! I'm convinced that this could start a revolution in how we write software in the near future.\n. ",
    "hayesmg": "Sounds reasonable, thanks.\n. In regards to extensibility, a contrived example would be something similar to:\n``` js\nfunction customCreateComponent(name, component, metadata) {\n    // Call base create implementation.\n    var c = noflo.ComponentLoader.prototype.createComponent.call(this, name, component, metadata);\n    // Perform processing on each component before returning.\n    c = applyMixins(c);\n    c = addCustomMetadata(c);\n    return c;\n}\nvar cl = new noflo.ComponentLoader();\n// Utilize the custom implementation for every component to be created.\ncl.createComponent = customCreateComponent.bind(cl);\n```\nIn my particular case, I'm applying Aspect Oriented Programming to elements of my custom components.  For example, I have schema metadata for an input port and I can intercept the inPort's process method to perform validation before allowing it to be handled by the normal handler.\n. Correct.  I haven't modified the intent of the ComponentLoader, rather I have opened up the load method.\n. I believe it does add a little value in that developers can override only the piece they feel is necessary.\n. @bergie I believe I have resolved the issue, but I have reservations.  Please see my line comment in the commit regarding setTimeout.\n. I also want to point out something that still concerns me; the usage of startup() when testing components individually.  @trustmaster and I spoke briefly on this subject, and he mentioned it might be possible to send default values upon the first connect of an inPort.  Thoughts?\n. Closing due to PR #217\n. @bergie @trustmaster I believe I have found an issue with the port.isAttached check in addNode.  At the point a node is added it hasn't been attached via the addEdge function.  I am currently looking into a solution.  Stand by on merging the PR.\n. This change in defaults still requires something to fire defaults for a component, when not being executed by a network.  So the \"annoyance\" of having to write a line of code to send defaults in unit-testing is there, but it now is much closer to how all other data is sent; socket.send() versus component.start().\nWhen the component is consumed in a network, the send() call will be fired only if the following conditions are met:\n- InPort has a default value identified. hasDefault() == true\n- InPort has no other sockets attached from edges or IIP.\n. @bergie @trustmaster I don't know that there is a way in which we can confidently calculate when a network is complete.  It is possible to have a graph that takes in IIP and does nothing with it should it not meet a certain condition.  In that case the network is done after the disconnect of that IIP.  The next time the network is run it could be complete after doing some heavy processing.\nI'd like this to start a discussion of whether the 'end' or 'stop' of a network should be signaled by the graph builder and not by the network.  That would give the graph builder a way to signal when they consider their process to be complete.\nExample:\n\"Hello, World!\" -> IN Component()\nComponent() OUT -> IN AnotherComponent()\nAnotherComponent() OUT -> NetworkStop()\n. @bergie Absolutely.  I think before doing that I'd like a little better understanding as to why WirePattern is now also sending the defaults.\n. @trustmaster Regarding item 1, for clarification, is the suggestion to have Network be used when testing individual components that have defaults instead of something like socket.send() without parameters?\n. @trustmaster That seems like a reasonable approach.  Will that essentially loop through any port that hasDefault() and call the socket.send()?  If so, I like it, one method to handle all params on WP.\n. Sounds good.  Thanks!\n. I have a fix for this, but still need to create the appropriate unit test(s).\n. I have a fix for this, but still need to create the appropriate unit test(s).\n. @paulyoung This may be a starting point for that requirement: http://noflojs.org/component/noflo-adapters-PacketsToArray/\nI cannot say whether PacketsToArray is up-to-date with the latest changes, but its worth the look.\n. I see what you're saying @trustmaster.  The connect/send/disconnect of upstream ports invalidates the use of that component.\n. ",
    "jskrzypek": "@jonnor, @trustmaster, \nRegarding the idea to add InPort.read([portname]) = () => Promise<input>:\nYou may have already considered and dismissed this idea, but here goes:\nI assume you guys are familiar with Kris Kowal's GTOR (https://github.com/kriskowal/gtor) and related reactive javascript libraries, RxJS or Kefir.js? \nIf you're open to rebuilding some of the internals of noflo (I think mostly just InternalSocket, though), I think the much better upgrade would be to have OutPorts embed Observables that subscribe() attached InPorts.\nThe beautiful thing about doing something like this on top of RxJS is that you'd get a number of backpressure options out-of-the box, see their backpressure.md.\nIn terms of browser capability, RxJS is a component one of the major dataflows that people are using in Angular 2 apps, and for IoT compatability, there are a number of \"lite\" RxJS libraries you can use to limit the footprint.\n. Also, regarding your discussion of input vs control:\nI have an idea for a nice pattern that might make sense here and satisfy both sides of the discussion. It kind of depends on and follows from making the Ports/InternalSockets into Observables, but I think there are ways to implement it even if you reject that Proposal.\nAt a high level, components that want to use Control ports should implement a configureProcess() method instead of a process() method. configureProcess() would be triggered by the Control ports and set the component's process() function. Building on the scenario from @trustmaster 's gist above, here's a sketch of what it would do. The function that is returned or passed to the configDone would then get set as c.process() whenever the configureProcess() function is triggered.\n``` js\nsync configureProcess\nc.configureProcess = (controls) ->\n  doConfig controls\n  (input, output, done) -> \n    doSomething input.user.data, input.post.data, timeout: control.timeout\n    .then (result) ->\n      output.result.data result,\n        groups: input.post.groups\n      done()\n    .catch done\nasync configureProcess\nc.configureProcess = (controls, configDone) ->\n  doConfigAsync controls, ->\n    (input, output, done) -> \n      doSomething input.user.data, input.post.data, timeout: control.timeout\n      .then (result) ->\n        output.result.data result,\n          groups: input.post.groups\n        done()\n      .catch done\n```\nIf you agree with the idea of building the ports around Observables, this way of doing things becomes even cleaner, since in the reactive scenario, configureProcess() is subscribed to the Control ports' Observables, and itself returns an Observable. Then the component subscribes to the Input ports' Observables with the process() function that it sees coming from configureProcess() as the Observer to the inputs.\n. I don't know a lot about the performance implications of RxJS, but I did find some discussion about their performance available here: https://github.com/Reactive-Extensions/RxJS/blob/master/doc/mapping/bacon.js/whyrx.md\n. You can have the RxJS/Observables and still use the bounded-queues, you just use the InternalSockets as intermediaries with queues.\nHere's a pattern I found that's basically doing that (albeit from the java world).\nhttp://www.javaworld.com/article/2077526/build-ci-sdlc/java-tip-29--how-to-decouple-the-observer-observable-object-model.html\n. ",
    "gabejohnson": "@trustmaster you may want to check out\nhttps://github.com/ubolonton/js-csp\nIt's a Clojure core.async inspired library. It uses Go style channels for managing concurrency.\nhttps://en.wikipedia.org/wiki/Go_(programming_language)#Concurrency:_goroutines_and_channels\nI've used core.async in Clojure and ClojureScript and find it very useful for message buffering and sequencing.\n. ",
    "dremekie": "@jonnor \nThis is is still an issue. Take the following graph.\n{\n    \"processes\": {\n        \"WriteFile\": {\n            \"component\": \"WriteFile\",\n            \"metadata\": {}\n        },\n        \"Display\": {\n            \"component\": \"core/Output\",\n            \"metadata\": {}\n        }\n      },\n    \"connections\": [\n        {\n            \"data\": \"/Users/dwayne/Documents/test.txt\",\n            \"tgt\": {\n                \"process\": \"WriteFile\",\n                \"port\": \"filename\"\n            }\n        },\n        {\n            \"src\": {\n                \"process\": \"WriteFile\",\n                \"port\": \"out\"\n            },\n            \"tgt\": {\n                \"process\": \"Display\",\n                \"port\": \"in\"\n            }\n        },\n        {\n            \"src\": {\n                \"process\": \"WriteFile\",\n                \"port\": \"error\"\n            },\n            \"tgt\": {\n                \"process\": \"Display\",\n                \"port\": \"in\"\n            }\n        },\n        {\n            \"data\": \"Some useless text\",\n            \"tgt\": {\n                \"process\": \"WriteFile\",\n                \"port\": \"in\"\n            }\n        }\n    ]\n}\nAnd the following code snippet\nnoflo.graph.loadJSON(nofloDefinition, function(graph) {\n    noflo.createNetwork(graph, function(network) {\n      network.on('start', function() {\n        console.log('network started!');\n      });\n      network.on('end', function() {\n        console.log('network end!');\n      });\n    });\n  });\nI see this:\nnetwork started!\nnetwork started!\nnetwork started!\n/Users/dwayne/Documents/test.txt\nnetwork end!\nnetwork end!\nnetwork end!\nIs it even possible to definitely know when a network is \"complete\"?\n. I think I have this figured out...\n. ",
    "oleksandr": "@jonnor What if the library for JavaFBP is shipped compiled only? What's the purpose of having .java files in the component names?\n. From our side we used this format but it's not fixed. We'd like to consider a common approach that fits everyone. Our current component library looks like:\n{\n   \"name\": \"Local Components Registry\",\n   \"created\": \"2014-08-23T18:20:53.42258021+02:00\",\n   \"updated\": \"2014-08-24T00:06:35.00285465+02:00\"\n   \"entries\": {\n      \"core/console\": {\n         \"name\": \"core/console\",\n         \"description\": \"Simple logging component that writes everything received on the input port to standard output stream.\",\n         \"exec\": \"/Users/alex/Projects/OpenSource/cascades-io/components/core/console\",\n         \"elementary\": true,\n         \"inports\": [\n            {\n               \"name\": \"in\",\n               \"type\": \"all\",\n               \"description\": \"Input port for logging IP\",\n               \"required\": true,\n               \"addressable\": false\n            }\n         ],\n         \"outports\": []\n      },\n      ...\n}\nIn our runtime the components are shipped in a binary form. I like the format suggested by @jonnor but please make sources an optional argument.\nAlso, each component in our case can be \"introspected\". For a JavaFBP .class it's dynamic during the execution. In our case it's a binary executable - so we use a common flag \"-json\" to dump its meta data. Something like:\n$ ./components/core/console\nUsage of components/core/console:\n  -debug=false: Enable debug mode\n  -json=false: Print component documentation in JSON\n  -port.in=\"\": Component's input port endpoint\n$ ./components/core/console -json\n{\"name\":\"\",\"description\":\"Simple logging component that writes everything received on the input port to standard output stream.\",\"exec\":\"\",\"elementary\":false,\"inports\":[{\"name\":\"IN\",\"type\":\"all\",\"description\":\"Input port for logging IP\",\"required\":true,\"addressable\":false}],\"outports\":null}\n. > Similarly to component sets, we need graph sets. \n\nThey would have same properties except \"components\" would be \"graphs\"\n\nWhy not a single flag like \"elementary\": true and avoid 2 sets to traverse when looking for a component?\n. @jonnor Yep! Either .json or .fbp. I like FBP DSL... Managing JSON structure is not that comfy with hands :)\n. Could you also consider providing alternative fbp.json files upon the start of a runtime. We use this idea to have different runtimes serve different purposes (when the graphs are created bottom-up for a specific problem domain). In this case users have access to a project specific library (core + domain specific components) and don't miss-use something or get lost in the long list of components.\nAlso, we include a CLI command to manage the global library for a runtime. I don't know how it fits NoFlo's design and components integration...\n. @bergie Unfortunately can't share your excitement as we have different scenarios and type of applications to write :-(\n. ",
    "sjaakiejj": "@bergie Yeah, an error would be quite helpful in that regard, and a clear entry in the Getting Started page or the Component page of the documentation to state that port names must be lowercase. It's quite confusing for people who are just starting to get familiar with NoFlo.\n. ",
    "robhawkes": "I don't know how that benchmark should look but I'm happy to have a go if we can work out its rough structure. Right now I'm just testing it via custom components and the high-res performance.now() timing API.\n. I'd quite like to play around with the EventEmitter used in the browser version of NoFlo but on a quick glance I can't find where it's pulled in from. Can someone point it out and I'll see if there are any quick optimisations that could be done on the emit method (assuming that's where the delay is)?\nEdit: I did a quick test on WildEmitter which I use with ViziCities and that has a 0.5ms delay too. It's based on EventEmitter so if I can make improvements there then it's likely we can do the same here. The emit method seems to be doing a whole bunch of stuff so I'm confident something can be done to help. Hopefully someone can tell me where EventEmitter is set up in NoFlo so I can tweak or override it (perhaps @bergie?).\n. Edit: Updated to include tests for EventEmitter3 and bergie/emitter as well as 1,000,000 emits for fun\nI've done some benchmarking in the browser comparing EventEmitter, WlldEmitter, EventEmitter2, EventEmitter3 and NoFlo's bergie/emitter. I think the results speak for themselves\u00a0\u2013\u00a0just check out EventEmitter2!\njavascript\n// Time in milliseconds to call .emit(\"test\") once with a single listener each\nEventEmitter: 0.1829999964684248\nWildEmitter: 0.34499994944781065\nEventEmitter2: 0.0540000619366765\nEventEmitter3: 0.24399999529123306\nbergie/emitter: 0.15300000086426735\njavascript\n// Time in milliseconds to call .emit(\"test\") 100 times with a single listener each\nEventEmitter: 0.632000039331615\nWildEmitter: 0.7140000816434622\nEventEmitter2: 0.12599991168826818\nEventEmitter3: 0.3310000756755471\nbergie/emitter: 0.4160000244155526\njavascript\n// Time in milliseconds to call .emit(\"test\") 1,000 times with a single listener each\nEventEmitter: 6.219000089913607\nWildEmitter: 4.24200005363673\nEventEmitter2: 0.3120000474154949\nEventEmitter3: 0.5399999208748341\nbergie/emitter: 2.0360000198706985\njavascript\n// Time in milliseconds to call .emit(\"test\") 100,000 times with a single listener each\nEventEmitter: 255.77799999155104\nWildEmitter: 263.0449999123812\nEventEmitter2: 13.532999902963638\nEventEmitter3: 12.742999941110611\nbergie/emitter: 178.90299996361136\njavascript\n// Time in milliseconds to call .emit(\"test\") 1,000,000 times with a single listener each\nEventEmitter: 2373.087999993004\nWildEmitter: 2479.2499999748543\nEventEmitter2: 123.02199995610863\nEventEmitter3: 98.7989999121055\nbergie/emitter: 1567.4230000004172\n. // ms times for 1 .emit() call and 10 listeners\njavascript\nEventEmitter: 0.17200002912431955\nWildEmitter: 0.29200001154094934\nEventEmitter2: 0.07599999662488699\nEventEmitter3: 0.265000038780272\nbergie/emitter: 0.14700007159262896\n// ms times for 100 .emit() calls and 10 listeners\njavascript\nEventEmitter: 1.2339999666437507\nWildEmitter: 1.478999969549477\nEventEmitter2: 0.6140000186860561\nEventEmitter3: 0.7299999706447124\nbergie/emitter: 0.775999971665442\n// ms times for 1,000 .emit() calls and 10 listeners\njavascript\nEventEmitter: 11.360000004060566\nWildEmitter: 5.018000025302172\nEventEmitter2: 1.9909999100491405\nEventEmitter3: 1.2839999981224537\nbergie/emitter: 3.0610000248998404\n// ms times for 100,000 .emit() calls and 10 listeners\njavascript\nEventEmitter: 422.7909999899566\nWildEmitter: 318.76300007570535\nEventEmitter2: 126.27300003077835\nEventEmitter3: 71.41800003591925\nbergie/emitter: 229.13999995216727\n// ms times for 1,000,000 .emit() calls and 10 listeners\njavascript\nEventEmitter: 4673.170999973081\nWildEmitter: 3401.6759999794886\nEventEmitter2: 1148.3129999833182\nEventEmitter3: 641.9809999642894\nbergie/emitter: 2427.3149999789894\n. EE3 definitely seems a lot better at scale, though EE2 is far faster for requirements like mine where there are many emit calls but few listeners. I'm trying to build NoFlo using EE2 + EE3 but I can't even get it to even build, probably because I don't understand what I need to do with the Component process!\n. I managed to get a build working but it's taking me far too long to fiddle with things and I don't know enough about what I'm doing with a custom NoFlo browser build to ensure I can do a proper test with my own components.\nI'm very interested to see how someone who knows what they're doing gets on as my use-case is processing many arrays of items as realtime data comes in \u2013\u00a0speeding this up is important.\n. I see. While that me be so, the behaviour for arrayPolicy.params seems to be different, in that it allows you to wait for data on all the param ports before moving on (hence expecting this for in ports). If this isn't the intended behaviour for in ports too then I'd suggest this being separated in the WirePattern configuration as it's confusing.\nHaving the ability to wait for one of many in ports before moving on would be an incredibly useful feature, especially as the same behaviour is already provided for parameter ports. It would be a shame to have to create individual port handlers on top of the WirePattern data handler.\n. Sounds great, I can't wait to see those improvements rolled in. I love the WirePattern but I feel I'm in an either/or situation with things like this so I'm having to end up building custom components that do similar things.\n. Has there been any progress with this?\n. It's been about 4 months without reply, has anyone got a clue about this? I've stopped using NoFlo for the time-being as I need functionality like this to be able to take the plunge and implement it as a core part of the platform I'm building. Otherwise, I'll have to resort to building my own which is not something I'd like to do if possible.\n. ",
    "ensonic": "I've tested it also on a arm9 @ 300 MHz and there the improvement is 3 min -> 1 min. So far I've not seen any issues. I'll do more tests tomorrow and then make a patch as well.\n. I can't test the dynamic editing right now, as this is broken in noflo-ui right now. Trying to open a component that is on a noflo-nodejs runtime, just spins forever (can't find the bug for that right now).\n. +1 from removing. The behaviour wrt config.group is documented above.\n. ",
    "ComFreek": "Thanks, but NoFlo now throws an error (using the same component as mentioned above):\nError: No process defined for inbound node test/Test_a04e8\nThe error is apparently very serious because I can't run the graph after the error appeared. I must then completely restart the noflo-nodejs process (I am using the noflo-nodejs runtime.)\n. @trustmaster There is no output. I actually tried setting the dependencies to their respective Git URI from GitHub, but then I could not get noflo-nodejs (node node_modules/noflo-nodejs/bin/noflo-nodejs) to work because it (=Node) didn't find the noflo package. I could resolve the issue by replacing the Git URIs by normal version numbers. There must either be a serious error in NoFlo or in Node.js.\n. I've now done that with this repository and copied the files to node_modules (even needed to use 7-zip file manager since Windows cannot handle too long filenames) as you said.\nI'm still getting the No process defined ...error though.\n. @trustmaster Yes, I am getting the same error. I can't even re-login to noflo-ui. I am always being redirected to https://passport.thegrid.io/login/github_public/callback?code=xyz whose output is:\nError: Identity connected to another user\n at /app/auth.coffee:52:27\n at /app/lib.coffee:92:5\n at tryCatch1 (/app/node_modules/knex/node_modules/bluebird/js/main/util.js:45:21)\n at Promise$_callHandler [as _callHandler] (/app/node_modules/knex/node_modules/bluebird/js/main/promise.js:660:13)\n at Promise$_settlePromiseFromHandler [as _settlePromiseFromHandler] (/app/node_modules/knex/node_modules/bluebird/js/main/promise.js:675:18)\n at Promise$_settlePromiseAt [as _settlePromiseAt] (/app/node_modules/knex/node_modules/bluebird/js/main/promise.js:845:14)\n at Promise$_settlePromises [as _settlePromises] (/app/node_modules/knex/node_modules/bluebird/js/main/promise.js:988:14)\n at Async$_consumeFunctionBuffer [as _consumeFunctionBuffer] (/app/node_modules/knex/node_modules/bluebird/js/main/async.js:77:12)\n at Async$consumeFunctionBuffer (/app/node_modules/knex/node_modules/bluebird/js/main/async.js:40:14)\n at /app/node_modules/newrelic/node_modules/continuation-local-storage/node_modules/async-listener/glue.js:188:31\n at process._tickCallback (node.js:442:13)\nPS: Could this issue get reopened, please?\n. @forresto :+1:  Thanks for Fixing It works fine now (except for this issue of course).\n. @trustmaster \nWhich packages did you update?\nI have already updated noflo and noflo-nodejs to no avail. I am still getting the same error.\n. I have now updated noflo-core as well and I am still getting the same error.\nI also verified that my custom component is based on the same code as yours in the Gist.\nDo I have to update noflo-ui maybe?\n. ",
    "Gytaco": "I haven't seen any info on the component.io option? How far is the browserify version from being somwhat stable??\n. ",
    "aretecode": "https://github.com/noflo/noflo.github.io\nIt is being updated here https://github.com/aretecode/noflo.github.io/tree/gh-pages\n. If sending single IPs, or multiple IPs with mapping, IP.index is used for the port index. https://github.com/noflo/noflo/blob/master/src/lib/OutPort.coffee#L59\n. Why add another check every time you send just to support indexes when sendingIPs supports it? \n. In these functions, they will use the scopedBuffer if it is applicable, otherwise, fallback to the non-scoped buffer.\nI also think that extending input.getAll, input.filter, or add another function to have specific filters if typeof (2nd argument) is not 'function'\nFor example:\ncoffeescript\nopenBrackets = input.getWhere name: 'in', type: 'openBracket', hasData: true, getData: true\nto do...\n``` coffeescript\nfilter & map\nif ip.type is 'openBracket' and ip.data?\n  ip = ip.data\nip\n```\nAdditionally, if we have all of these functions (3+) then we might want to put them under .buffer as in\ncoffeescript\ninput.buffer.filter\n. Using this in the interim \n``` coffeescript\nbuffer =\n  get: (input, name = null) ->\n    if input.scope isnt null\n      if name?\n        return input.ports[name].scopedBuffer[input.scope]\n      return input.port.scopedBuffer[input.scope]\nif name?\n  return input.ports[name].buffer\nreturn input.port.buffer\n\nwhere: (input, name = null, args = {}) ->\n    b = buffer.get(input, name)\nif args? and Object.keys(args).length > 0\n  b = b.filter (ip) ->\n    if args.hasData\n      return false unless ip.data?\n    if args.type\n      if typeof args.type is 'array'\n        return false unless ip.type in args.type\n      return false unless ip.type is args.type\n    true\n\nif args.getData\n  return b.map (ip) -> ip.data\n\nif b.length is 1\n  return b[0]\n\nb\n\nfilter: (input, cb) ->\n    if input.scope isnt null\n      input.port.scopedBuffer[input.scope] = input.port.scopedBuffer[input.scope].filter cb\n    else\n      input.port.buffer = input.port.buffer.filter cb\n``\n. https://github.com/noflo/noflo/issues/452\n. @vladimir, it will be updated when bracket forwarding is finalized.\n. @trustmaster, wouldn't that also shift if it was only data and no brackets? Or if your preconditionreturn unless input.has 'in', (ip) -> ip.type is 'data'then it will trigger before there is acloseBracket. In my implementation here https://github.com/noflo/noflo/pull/488/files it willgetuntil there isdata(removing the brackets up to it), then it checks if there are anydata` packets after it, if there is not, it removes the following brackets.\n. @bergie @jonnor @trustmaster @automata @GabiThume \nCan someone review this so it can be merged?\n. @JamesHagerman \nParams\nIt sounds as though what you are using is a param port. \n``` coffeescript\nexports.getComponent = ->\n  c = new noflo.Component\n    inPorts:\n      url: \n        datatype: 'string'\n        required: false\n      field: \n        datatype: 'string'\n        required: true\nnoflo.helpers.WirePattern c,\n    in: ['field']\n    params: ['url']\n  , (field, groups, out, done) ->\n    console.log field \n    console.log c.params.url\n    done()\n```\nDocumentation\nThe documentation is being updated here:\nhttps://aretecode.github.io/noflo.github.io/documentation\nAnd this part is for WirePattern:\nhttps://aretecode.github.io/noflo.github.io/documentation/legacy/\nProcess API\nIn Process API this would look something similar to:\n(note this does require https://github.com/noflo/noflo/pull/488, which is available using https://github.com/aretecode/noflo-built/tree/experiment until it is merged.)\n``` coffeescript\nexports.getComponent = ->\n  c = new noflo.Component\n    inPorts:\n      url: \n        datatype: 'string'\n        required: false\n      field: \n        datatype: 'string'\n        required: true\nc.process (input, output) ->\n    return unless input.has 'field', (ip) -> ip.type is 'data'\n    [field, url] = input.getData 'field', 'url'\n    console.log field\n    console.log url \n    output.done()\n```\nOr using the current 7.8 official npm version:\n``` coffeescript\nexports.getComponent = ->\n  c = new noflo.Component\n    inPorts:\n      url: \n        datatype: 'string'\n        required: false\n      field: \n        datatype: 'string'\n        required: true\nc.process (input, output) ->\n    return unless input.has 'field', (ip) -> ip.type is 'data'\nfield = input.get 'field'\nuntil field.type is 'data'      \n  field = input.get 'field'\n\nif input.has 'url', (ip) -> ip.type is 'data'\n  url = input.get 'url'\n  until url.type is 'data'      \n    url = input.get 'url'\n\nconsole.log field\nconsole.log url\n\noutput.done()\n\n```\n. @JamesHagerman\nHappy to help! Feel free to ask if you have any more questions.\nThe updated docs will go live when they are finished being reviewed by the rest of the noflo team (some have already reviewed it), hopefully that is soon. If you spot any typos or anything that is not clear, let me know. \n. @JamesHagerman \nAre you sending url after sending field ?\nWhen all of the ports defined in the in param and the required param ports have data, WirePattern callback is triggered.\nSo if you send url before field, it will be there. If you send url after field, it is triggered before url arrives.\nSorry in my example, done is the callback for async: true on WirePattern, if it is not async, you do not need it. Most of my components are async and Process API is naturally async so I'm used to putting it in there.\nUsing the async: true would look like this:\n``` coffeescript\nexports.getComponent = ->\n  c = new noflo.Component\n    inPorts:\n      url: \n        datatype: 'string'\n        required: false\n      field: \n        datatype: 'string'\n        required: true\nnoflo.helpers.WirePattern c,\n    in: ['field']\n    params: ['url']\n    async: true\n  , (field, groups, out, done) ->\n    console.log field \n    console.log c.params.url\n    done()\n```\n. @JamesHagerman \nI will see about doing that with groups, thank you! \nDocs\nGroups are pretty much just things that you can use to group things. They are replaced by Brackets in the latest noflo\nhttps://aretecode.github.io/noflo.github.io/documentation/process-api/#brackets\nResources\nA fairly simple usage can be found here:\nhttps://github.com/aretecode/noflo-objects/blob/master/components/SplitObject.coffee\nAnd here for the documentation example project:\nhttps://github.com/aretecode/canadianness/blob/master/components/FindWords.coffee#L60\n(which is detailed more here https://aretecode.github.io/noflo.github.io/projects/)\nExample\n(there are many other uses for groups, such as database query results)\nSay you have a bunch of individual data and you want to send groups of it:\n``` coffeescript\nfruits =  ['apples', 'bananas', 'grapes', 'oranges']\nveggies = ['broccoli', 'cabbage', 'celery']\nor for Process API, output.ports.name.send new noflo.IP 'openBracket', 'fruit'\noutput.ports.name.openGroup 'fruit'\nfor fruit in fruits\n  output.ports.name.send fruit\nor for Process API, output.ports.name.send new noflo.IP 'closeBracket', 'fruit'\noutput.ports.name.closeGroup 'fruit'\nor for Process API, output.ports.name.send new noflo.IP 'openBracket', 'veggies'\noutput.ports.name.openGroup 'veggies'\nfor veggie in veggies\n  output.ports.name.send veggie\nor for Process API, output.ports.name.send new noflo.IP 'closeBracket', 'veggies'\noutput.ports.name.closeGroup 'veggies'\n```\nAvoid\nWith all that being said, I personally avoid using them (and some repositories we have do not use them at all) because they can become overly complex (especially when dealing with forwarding), and you can easily just send an object instead:\n``` coffeescript\noutput.ports.name.send \n  name: 'fruit'\n  data: fruits\noutput.ports.name.send \n  name: 'veggies'\n  data: veggies\n```\n. @JamesHagerman \nOrder & Params\nAnother thing that matters is a param ports data will stay until it is replaced.\nSo if you:\n- 1) send example.com to url\n- 2) send eh to field \n(it will trigger and have example.com as c.params.url and eh as field)\n- 3) send canada to field\n(it will trigger and have example.com as c.params.url and canada as field)\n- 4) send igloo.com to url\n- 5) send moose to field\n(it will trigger and have igloo.com as c.params.url and moose as field)\nLink\nThe reason that link is broken is because it goes to the base url, which is made for http://noflojs.org/documentation/tooling/\nSo for example \nhttps://aretecode.github.io/documentation/legacy/#async \nactually needs /noflo.github.io/ as in \nhttps://aretecode.github.io/noflo.github.io/documentation/legacy/#async\nHowever, this wont be changed because then all of the links would need to be changed for this domain, and then changed again for the live official version.\nGroups\nI've updated the docs with that stuff about groups/brackets:\nhttps://github.com/aretecode/noflo.github.io/commit/15711868abc7015e136e73e2bd5dae6135cf95dc\n. @jimmywarting I also think es6/7\n@jomeier you can use flowtypes with es6/7 with only the building step, or you can simply annotate with Native Functions as in function(fn = Function, str = String) . @justinmchase noflo does not require flowhub, flowhub is service that allows you to run noflo more easily and create graphs visually. I'm sure @bergie & @jonnor will be able to explain it better.\nthis is an example program that uses noflo without flowhub\nhttps://github.com/aretecode/canadianness\nand this is the documentation (this page in particular is for running it)\nhttps://aretecode.github.io/noflo.github.io/projects/embedding/. @justinmchase in that example project, just run coffee index.coffee. This will help save some lines!\n. ",
    "mfwei": "I try to do some actions (a subgraph) iteratively under some special conditions.\nFor example in C lang. \nfor( initialization; condition; incremental ) \n    do Action1\n    do Action2\n     ............\nWe may view a sequence of actions as a subgraph in the program.\n. Thanks for your advice, Jon.\nThese really do help me very much.\n. ",
    "schmurfy": "I found it in the connections which, I suppose, is a design choice.\nI find it a bit weird to have a disconnect between the api (set_initial) and where it ends up being stored (connections) although having it in connections make more sense to me than the set/remove_initial api.\n. I also end up checking whether a connection is a real connection or a data input now but having all the inputs in one place also help in some ways, instead of having to check two or more arrays to find if your node is connected and to what.\nThanks for the explanations :)\n. ",
    "rjsteinert": "Thanks @bergie \n. ",
    "ilanbiala": "If I have to use multiple graphs, how can I connect a graph to another in Flowhub?\n. ",
    "afshin2003": "Thank you so much!\nBEST\n. Hi bergie,\nWould you mind telling me how to define a component which does not have any input port? After I removed the definitions of 'in' port, it says \n<< uncaughtException [Error: no inPort named 'in'] >>\nBEST\nAfshin\n. Hi,\nwell, here is the thing,\nI'm developing an IVR system based on noflo which is using FreeSWITCH as telephony platform. with proper configuration, freeswitch connects a control socket to an external program to manage telephony behavior. Here is noflo graphs come to play. As a starting component I have Inbound component which listen to a configurable port and for every new call attempt builds a connection object and sends it to the next stage. It's clear that by combining the listener function and Inbound component I don't need to any input port because it gets its input via socket. So as far as I understand, I need to have my own listener process and \n1) embed noflo graph into and inject connection objects to input port of Inbound component  or\n2) inject call Ids to the external noflo process and let them connect to FreeSWITCH by themselves.\nI'll appreciate If you could provide me a simple example. If you would like to have my draft code I'll post here for sure :)\nAfshin \n. Hi Bergie,\nThanks for your support,\nHow I can do this? I have no idea :)\n. If you mean index in the graph json file, I've already done it!\n{\n  \"properties\": {\n    \"name\": \"Rightel IVR Payment\"\n  },\n  \"processes\": {\n    \"Inbound\": {\n      \"component\": \"freeswitch/inbound\",\n      \"metadata\": {}\n    },\n    \"Greeting\": {\n      \"component\": \"freeswitch/playback\",\n      \"metadata\": {\n        \"voice\": \"ivr/tvedc-greeting.wav\"\n      }\n    },\n    \"Menu1\": {\n      \"component\": \"freeswitch/autoattendant\",\n      \"metadata\": {}\n    },\n    \"Hold\": {\n      \"component\": \"freeswitch/hold\",\n      \"metadata\": {}\n    }\n  },\n  \"connections\": [\n    {\n      \"src\": {\n        \"process\": \"Inbound\",\n        \"port\": \"out\"\n      },\n      \"tgt\": {\n        \"process\": \"Greeting\",\n        \"port\": \"in\"\n      }\n    },\n    {\n      \"src\": {\n        \"process\": \"Greeting\",\n        \"port\": \"out\"\n      },\n      \"tgt\": {\n        \"process\": \"Menu1\",\n        \"port\": \"in\"\n      }\n    },\n    {\n      \"src\": {\n        \"process\": \"Menu1\",\n        \"port\": \"out\",\n        \"index\": 0\n      },\n      \"tgt\": {\n        \"process\": \"Hold\",\n        \"port\": \"in\"\n      }\n    }\n  ],\n  \"inports\" : {\n    \"inboundin\" : {\n      \"process\": \"Inbound\",\n      \"port\": \"in\",\n      \"metadata\": {}\n    }\n  }\n}\n. Hi Bergie,\nAppreciated your rapid reply. Actually I drop my reference to the used graph but I keep my reference to the loader which loaded my graph. Does not it keep a reference to the already loaded graph? I am asking this because I have memory issue!\nAfshin . I got your point. Meanwhile I'm searching to find the God damn reference, would you tell me that shutting down the graph has the same functionality compare to stopping the network? I get network object from the graph!  . @jonnor I use shutdown method of the return instance of ComponentLoader's load method. I suppose the return object is a graph object! Isn't it?. Ok, I switched to network.stop() for shutting down. So if I don't keep any reference to graph / network, do you expect that it is collected by the GC?. So so much thanks!. ",
    "coderany": "``` bash\nOlegs-iMac:publish oleg$ ./node_modules/.bin/noflo list .\nGraph (/Users/oleg/publish/node_modules/noflo/src/components/Graph.coffee)\nInports: GRAPH\nOutports: \ncore/Callback (/Users/oleg/publish/node_modules/noflo-core/components/Callback.coffee)\nThis component calls a given callback function for each IP it receives.  The Callback component is typically used to connect NoFlo with external Node.js code.\nInports: IN, CALLBACK\nOutports: ERROR\ncore/Copy (/Users/oleg/publish/node_modules/noflo-core/components/Copy.coffee)\ndeep (i.e. recursively) copy an object\nInports: IN\nOutports: OUT\ncore/DisconnectAfterPacket (/Users/oleg/publish/node_modules/noflo-core/components/DisconnectAfterPacket.coffee)\nForwards any packets, but also sends a disconnect after each of them\nInports: IN\nOutports: OUT\ncore/Drop (/Users/oleg/publish/node_modules/noflo-core/components/Drop.coffee)\nThis component drops every packet it receives with no action\nInports: IN\nOutports: \ncore/Group (/Users/oleg/publish/node_modules/noflo-core/components/Group.coffee)\nAdds a set of groups around the packets received at each connection\nInports: IN, GROUP, THRESHOLD\nOutports: OUT\ncore/Kick (/Users/oleg/publish/node_modules/noflo-core/components/Kick.coffee)\nThis component generates a single packet and sends it to the output port. Mostly usable for debugging, but can also be useful for starting up networks.\nInports: IN, DATA\nOutports: OUT\ncore/MakeFunction (/Users/oleg/publish/node_modules/noflo-core/components/MakeFunction.coffee)\nEvaluates a function each time data hits the \"in\" port and sends the return value to \"out\". Within the function \"x\" will be the variable from the in port. For example, to make a ^2 function input \"return x*x;\" to the function port.\nInports: IN, FUNCTION\nOutports: OUT, FUNCTION, ERROR\ncore/Merge (/Users/oleg/publish/node_modules/noflo-core/components/Merge.coffee)\nThis component receives data on multiple input ports and sends the same data out to the connected output port\nInports: IN\nOutports: OUT\ncore/Output (/Users/oleg/publish/node_modules/noflo-core/components/Output.coffee)\nSends the data items to console.log\nInports: IN, OPTIONS\nOutports: OUT\ncore/ReadEnv (/Users/oleg/publish/node_modules/noflo-core/components/ReadEnv.coffee)\nReads an environment variable\nInports: KEY\nOutports: OUT, ERROR\ncore/ReadGlobal (/Users/oleg/publish/node_modules/noflo-core/components/ReadGlobal.coffee)\nReturns the value of a global variable.\nInports: NAME\nOutports: VALUE, ERROR\ncore/Repeat (/Users/oleg/publish/node_modules/noflo-core/components/Repeat.coffee)\nForwards packets and metadata in the same way it receives them\nInports: IN\nOutports: OUT\ncore/RepeatAsync (/Users/oleg/publish/node_modules/noflo-core/components/RepeatAsync.coffee)\nLike 'Repeat', except repeat on next tick\nInports: IN\nOutports: OUT\ncore/RepeatDelayed (/Users/oleg/publish/node_modules/noflo-core/components/RepeatDelayed.coffee)\nForward packet after a set delay\nInports: IN, DELAY\nOutports: OUT\ncore/RunInterval (/Users/oleg/publish/node_modules/noflo-core/components/RunInterval.coffee)\nSend a packet at the given interval\nInports: INTERVAL, START, STOP\nOutports: OUT\ncore/RunTimeout (/Users/oleg/publish/node_modules/noflo-core/components/RunTimeout.coffee)\nSend a packet after the given time in ms\nInports: TIME, START, CLEAR\nOutports: OUT\ncore/SendNext (/Users/oleg/publish/node_modules/noflo-core/components/SendNext.coffee)\nSends next packet in buffer when receiving a bang\nInports: DATA, IN\nOutports: OUT, EMPTY\ncore/Split (/Users/oleg/publish/node_modules/noflo-core/components/Split.coffee)\nThis component receives data on a single input port and sends the same data out to all connected output ports\nInports: IN\nOutports: OUT\nfilesystem/BaseName (/Users/oleg/publish/node_modules/noflo-filesystem/components/BaseName.coffee)\nGet the base name of the file\nInports: IN, EXT\nOutports: OUT\nfilesystem/CopyFile (/Users/oleg/publish/node_modules/noflo-filesystem/components/CopyFile.coffee)\nInports: SOURCE, DESTINATION\nOutports: OUT, ERROR\nfilesystem/CopyTree (/Users/oleg/publish/node_modules/noflo-filesystem/components/CopyTree.coffee)\nInports: FROM, TO\nOutports: OUT, ERROR\nfilesystem/DirName (/Users/oleg/publish/node_modules/noflo-filesystem/components/DirName.coffee)\nGet the directory path of a file path\nInports: IN\nOutports: OUT\nfilesystem/DirectoryBuffer (/Users/oleg/publish/node_modules/noflo-filesystem/components/DirectoryBuffer.coffee)\nInports: COLLECT, RELEASE\nOutports: OUT\nfilesystem/DirectoryGroupBuffer (/Users/oleg/publish/node_modules/noflo-filesystem/components/DirectoryGroupBuffer.coffee)\nInports: COLLECT, RELEASE\nOutports: OUT\nfilesystem/ExtName (/Users/oleg/publish/node_modules/noflo-filesystem/components/ExtName.coffee)\nGet the file extension for a file path\nInports: IN\nOutports: OUT\nfilesystem/MakeDir (/Users/oleg/publish/node_modules/noflo-filesystem/components/MakeDir.coffee)\nCreate a directory\nInports: IN\nOutports: OUT, ERROR\nfilesystem/MimeDocumentRouter (/Users/oleg/publish/node_modules/noflo-filesystem/components/MimeDocumentRouter.coffee)\nInports: ROUTES, IN\nOutports: OUT, MISSED\nfilesystem/MimeRouter (/Users/oleg/publish/node_modules/noflo-filesystem/components/MimeRouter.coffee)\nInports: TYPES, ROUTES, IN\nOutports: OUT, MISSED\nfilesystem/Normalize (/Users/oleg/publish/node_modules/noflo-filesystem/components/Normalize.coffee)\nNormalize a path\nInports: IN\nOutports: OUT\nfilesystem/ReadDir (/Users/oleg/publish/node_modules/noflo-filesystem/components/ReadDir.coffee)\nGet a list of file paths inside a directory\nInports: SOURCE\nOutports: OUT, ERROR\nfilesystem/ReadFile (/Users/oleg/publish/node_modules/noflo-filesystem/components/ReadFile.coffee)\nRead a file and send it out as a string\nInports: IN, ENCODING\nOutports: OUT, ERROR\nfilesystem/ReadFileRaw (/Users/oleg/publish/node_modules/noflo-filesystem/components/ReadFileRaw.coffee)\nRead a file and send it out as a buffer\nInports: IN\nOutports: OUT, ERROR\nfilesystem/ReadFileSync (/Users/oleg/publish/node_modules/noflo-filesystem/components/ReadFileSync.coffee)\nJust like ReadFile, but blocks until content is read\nInports: IN, ENCODING\nOutports: OUT, ERROR\nfilesystem/Resolve (/Users/oleg/publish/node_modules/noflo-filesystem/components/Resolve.coffee)\nResolve a relative path to an absolute one\nInports: IN\nOutports: OUT\nfilesystem/Stat (/Users/oleg/publish/node_modules/noflo-filesystem/components/Stat.coffee)\nRead statistics of a file\nInports: IN\nOutports: OUT, ERROR\nfilesystem/Unlink (/Users/oleg/publish/node_modules/noflo-filesystem/components/Unlink.coffee)\nRemove a file\nInports: IN\nOutports: OUT, ERROR\nfilesystem/WriteFile (/Users/oleg/publish/node_modules/noflo-filesystem/components/WriteFile.coffee)\nWrite a string into a file\nInports: IN, FILENAME\nOutports: OUT, ERROR\nfilesystem/WriteFileRaw (/Users/oleg/publish/node_modules/noflo-filesystem/components/WriteFileRaw.coffee)\nWrite a buffer into a file\nInports: IN, FILENAME\nOutports: OUT, ERROR\npublish/Test (/Users/oleg/publish/components/Test.js)\nThis component receives data on a single input  port and sends the same data out to the output port\nInports: IN\nOutports: OUT\n```\n. Yea i see now\nchanged this\n```\nRead(filesystem/ReadFile) OUT -> IN Test()\nTest() OUT -> IN Display(core/Output)\n'package.json' -> IN Read\n```\nto this\n```\nRead(filesystem/ReadFile) OUT -> IN Test(publish/Test)\nTest(publish/Test) OUT -> IN Display(core/Output)\n'package.json' -> IN Read\n```\nnow works, thanks\n. Now i want to load this app in noflo-ui, but did not find the place where to read about how i can to it.\nAlso still did not understand can i write code in my IDE and reload it in noflo-ui instead of writing code inside flo-ui?\n. ",
    "JamesHagerman": "I looked into this more and it looks as though this has something to do with the move to fbp-manifest.\nThe issue seems to be that the code noflo-cache-preheat calls out to inside ComponentLoader and fbp-manifest don't recurse into subdirectories correctly.\nI think this is a bug with either fbp-manifest/src/list.coffee around line 26 or in noflo/src/lib/nodesjs/ComponentLoader.coffee on or around line 96\nWhat is the correct solution to this issue?\n. On it! Thanks for the help!\n. Oh, also, this seems at odds with what was done in response to #238...\n. Oh wow!!!! Thank you for the quick and detailed response!!!\nThat's way more information than I was expecting and it answers a heck of a lot of other questions to boot! Thank you!\nLooking through it in detail now!\nWhen are the updated docs going live? \n. @aretecode Cool! I know the rest of my team looks forward to updated docs!\nOne thing that has remained a little confusing to the lot of us over here are exactly how Groups work. It might be nice to make that a tad more clear in the updated docs.\n. @aretecode I just tried your example, and for some reason, using params with required set to false is also exhibiting the same issue.\nUnless I set the url inport to required: true and either set default data on it or wire up a connection to that inport, c.params.url is undefined when the WirePattern actually runs.\nAlso, that done call back is also undefined.\nAnnnnnd I just realized that there is a newer release than what we're using. We're on noflo@0.7.4.\nLet me update to 0.7.8 and see if that fixes things.\n. @aretecode Alright, that was the issue after all. Order matters!\nThank you for the help and for the notes on how Groups work!\nOne more note on the docs: The WirePattern Async link above the Wirepattern header on that legacy page is a broken link...\n. Yeah, the ordering in NoFlo has caught us off guard a few times.\nAnd that makes sense for the link as well! Thanks, yet again!\nFeel free to close this if you'd like. Not sure if discussions are to be closed or not...\n. ",
    "jomeier": "@trustmaster \nFor the components you are right. But if we want to expand noflo I think it would be good to have an alternative to coffeescript as its code base. In my opinion typescript would be a good choice. \nWould that be a fork of the original project or where could we host a typescript version?\n. @jonnor:\nI fully understand this argument. But in my opinion typescript is more common nowadays than coffeescript. It's more like C# or Java. This could attract more people for this great project.\nBut I understand the problem of two code bases.\n. Where can I put documentation for that to? Here?\n. Typescript is very similar to ES6 but supports types.\nThe result is Javascript5/6. So its not comparable to Flash or Silverlight.\n. There's another topic on that: If the UI restarts, it has no knowledge about running graphs, cause there's no fbp protocol command to get the structure of a graph out of the server.\nIt would be nice to have that.\n. My use case is that the graph will be created dynamically through the UI. I use noflo-nodejs with the fbp protocol.\nThere is no source I could load into the UI. \nA methid would be great to get the graoh from the server in JSON format.\n. OMG. That's great! That's a hidden feature :-) \nThe documentation of the fbp protocol at\nhttp://flowbased.github.io/fbp-protocol/\nshould mention that \"name\" is not only the name of a component but also the name of a graph?\nDon't know where the source of this documentation is. If I would have updated the doc myself and made a pull request.\n. My idea is that each instance of my component connects to a websocket server which sends the traffic to the User Interface. In the user interface I must create a relationship between the UI representation and the underlying processes. Without getting the identifier I can't connect the ui node symbol with my process.\nFor sure I could add an IIP to each UI node but ... seems like a workaround.\n. Ok. Cool. Thanks for your ideas. Do you know any examples in using runtime:packet or network:data? Can this be used to see the live status of the graph?\n. Thanks for the advice!\n. I created a pull request for a list command. Maybe someone can check that?\n. The idea is to define a field 'metadata' with the datatype Object which can contain anything which is needed to describe the component in an abstract way. We could for instance put describing tags inside which would help to sort/categorize/filter the components in the UI.\n. ",
    "jimmywarting": "I like the idea of a typed language. but i don't like precompiler so i don't like typescript/coffescript.\nI like to develop on the latest environment for node and chrome without it having to go through a compiling step that adds time. Only time i use a compiler is when i publish it, Then i run it through babel to make it backward compitable. The good thing is that it can be used less and less if you only target the latest engines  \nfor me javascript is javascript that can be executed without it having to go through some compile step.\nSo for me typescirpt is the new coffeescript that isn't the standard and doesn't work without a compiler therefore its something i hate.\nTechnologies that have competing spec / community driven development have a history of failing; take Flash & SilverLight for example\n\nSo i would vote for ES6/7\nPS: I'm fine .d.ts files but the code should be able to run as is. @jomeier i'm not talking about the difference in syntax or that the result is in es5/6, I'm compering it with flash/silverlight cuz i think it will eventually die out like the rest since ppl will stop maintaining it and that It's always going to be one/two step behind thos making ppl leave the typescript syntax. Who knows maybe one day we will have types in javascript but it won't look like typescript syntax. have fun updating. \nOnce we get async for loop and other new syntax feature you are going to wish you had vanilla javascript instead cuz you would always have to wait for typescript to adopt to the new standard. ",
    "ferronrsmith": "Still doesn't work. grr\n. Is there a workaround for this ? I am not really sure how to resolve this problem... n00b\n. ",
    "justinmchase": "I see so what you're saying is you just write an app with noflo package and then just run it like normal?\nThe thing throwing me off is the first step says to use \n\n1) noflo-nodejs --debug graphs/Canadianness.fbp\n\nBut then the nofolo-nodejs -h command has:\n\n--register          Register the runtime with Flowhub  [boolean] [default: true]\n\nIf I download the sample and do npm install; npm start it gives me an error about flowhub registration.\nThe default demo video on https://aretecode.github.io/noflo.github.io/documentation/ shows the speaker just running his graph via noflo graphs/Main.fbp... but when I do that it says its been deprecated and to use the other tool :(\nPerhaps I'll eventually figure out that I want it connected to flowhub and all of that but for now I just want it all to run locally, in process. I think that part of the problem is that I'm not sure what flowhub is doing, I'm not sure why its part of the equation at all frankly.. @jonnor Thanks. I'll look into it a little more.. ",
    "markopolojarvi": "Does this work out-of-the-box or is there some way to get flowtrace working right now?\nI'm currently using asCallback() to run graphs as embedded but I'm having some challenges debugging graphs and components. There was initial parameter trace suggested at https://github.com/noflo/noflo/issues/516 but at least based on the code I'm assuming this wasn't implemented in the end?. Thanks @jonnor. Too bad that my graphs are mainly composed of subgraphs ;). ",
    "enib29": "It seems while I was browsing issues I have found the solution with one of your example @bergie : \nhttps://github.com/noflo/noflo-core/blob/97c365ad7c0b1e5211d4f93a1ca792df9e6db92b/components/RunInterval.coffee\nSo now I'm using the shutdown function : \nc.shutdown = (callback) => {\n    // Do anything to stop async connection...\n    callback();\n};\nAnd everything seems to work! It was hard to find it, but should it be like that?\nPlease tell me if I'm doing wrong, I try to do my best :) \nThanks\nEDIT:\nAnd I don't understand the benefit of using WirePattern helper instead of a basic c.process function for async component? Is there one?. Thanks @bergie for the advice!\nI didn't find a way to access the current network variable. I just have access to noflo and the current component variable. Also, I browse their properties but I didn't see the current network.\nI just saw the class noflo.Network to create a new one. Any idea where can I find the network instance please?\nPS: I'm handling and processing data separately for each port of a component with : \nc.inPorts.[in/in2/...].on('data', function (data) {\nIs there a way to activate the component with that or is this way totally far away from the right noflo guidelines?\nInitially I planned to do a if statement in the process function but I noticed that if I put a parameter manually within noflo-ui (let's say port 1 value equals 5), the process can getData on it just once. I mean, if the port 2 received data, the process function will be triggered but without data on port 1 (while it's a data entered by hand).\nThe only solution found is to keep aside the value received in a persistant variable. But it seems really complicated no? I missed a better way?\n. ",
    "coveralls": "\nChanges Unknown when pulling 440fe4fb8b0275ffa27da2cfb2603b271bc143ee on coverage into  on master.\n. \n\nChanges Unknown when pulling 5525cf0db47b4adf9215b91355ab919d1cccacab on coverage into  on master.\n. ",
    "greenkeeper[bot]": "Version 4.0.1 just got published.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.0.1\n4.0.1 / 2017-10-05\n\ud83d\udc1b Fixes\n\n#3051: Upgrade Growl to v1.10.3 to fix its peer dep problems (@dpogue)\n\n\n\nCommits\nThe new version differs by 6 commits.\n\neb8bf8d Release v4.0.1\n3b485ea update CHANGELOG.md for v4.0.1 [ci skip]\n96e5c1a upgrade eslint to v4.8.0\nd7cff37 Update growl to 1.10.3\n0cdd921 remove preversion script; test on publish; closes #2999\nf49c0ce Fix changelog issues/pr URLs (#3047)\n\nSee the full diff\n\n. After pinning to 1.3.2 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 2.1.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 2.2.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\na73f66b 2.2.1 (#4885)\nba09412 Fix #4882: Range not declaring var for the \"i\" (#4883)\n794f65f Fix #4878: Compile error when using destructuring with a splat or expansion in an array (#4879)\n\nSee the full diff\n\n. After pinning to 2.2.4 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 2.3.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 12 commits.\n\nbe702d6 2.3.1 (#5069)\n68302e6 Docs headings and changelog refactor (#5067)\n0e7677a Fix #5046: Adjacent JSX (#5049)\n7cf739e Lexer, helpers and comments cleanup (#5063)\n41185ca Normalize :: syntax (#5048)\n7dbdca8 Allow implicit call with class with no body (#5053)\n8e66ae4 fix JSX expression indentation bug (#5056)\n7beb631 Create CNAME\nc2792e4 Delete CNAME\nd82272b Fix #1832: Browser compiler should run code using globally-scoped eval (#5047)\nfe75548 Fix #5034: Adjacent JSX elements must be wrapped in an enclosing tag (#5046)\n708e575 Fix README ASCII art\n\nSee the full diff\n\n. After pinning to 11.7.1 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. ## Version 11.7.3 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 2 commits.\n\n43bda0c chore(release): 11.7.3\nc20f8da security: address all vulnerabilities (#836)\n\nSee the full diff\n\n. ## Version 11.8.0 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 2 commits.\n\nbc9ffe5 chore(release): 11.8.0\n9def3eb feat: merge together multiple istanbul format reports (#840)\n\nSee the full diff\n\n. After pinning to 1.0.1 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 5.1.1 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 7.1.4 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 1.2.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 1.3.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 2 commits.\n\n352a258 v1.3.1\n89e264b cwd option should use existing base option (#122)\n\nSee the full diff\n\n. ## Version 8.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv8.0.1\n\n#662 - docs: update README.md\n#667 - docs: Remove babelrc from loader-specific options\n#668 - Add a warning if you forget to install @babel/core or install babel-core.\n\n\n\nCommits\nThe new version differs by 6 commits.\n\ndbcc2b5 8.0.1\n34d6d6e Add a warning if you forget to install @babel/core or install babel-core. (#668)\n8b6dd4b Merge pull request #662 from Sibiraj-S/patch-1\n2344855 Merge branch 'master' into patch-1\n053c9f6 Remove babelrc from loader-specific options (#667)\ne1c190d docs: update README.md\n\nSee the full diff\n\n. ## Version 8.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv8.0.2\n\n#541 - A bunch of great README fixes\n#574 - Add cacheCompression: false to disable GZip compression of the disk cache\n#670 - Handle both 'sourceMap' and 'sourceMaps' options properly\n#671 - Fix sourceMaps: 'inline' to work properly with babel-loader\n#669 - Fix sourcemaps to work with Webpack's devtoolModuleFilenameTemplate placeholders\n\n\n\nCommits\nThe new version differs by 6 commits.\n\n0e43d0a 8.0.2\n5e0565d Manually fix 'inline' sourcemaps so they work with Webpack. (#671)\nea52d05 Use 'sourceMaps' since that is what we suggest to use in our docs. (#670)\n4c32295 Use absolute filepaths in sourcemap 'sources' list. (#669)\n9621e24 Tidy up README [skip ci]\n67a5f40 Make compressing transforms cache configurable (#574)\n\nSee the full diff\n\n. - The devDependency babel-loader was updated from 7.1.5 to 8.0.3.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v8.0.3\nFeatures\n\n#687 - Add customize option\n\nBugs\n\n#685 - Also pass the caller option to loadPartialConfig\n\nDocs\n\n#681 - Update the README links to use the new options docs\n#683 - Add .mjs to the examples\n\nInternal\nSome dev dependency updates and CI tweaks.\n\n\nCommits\nThe new version differs by 12 commits.\n\n800181b 8.0.3\n7d8500c Also pass the caller option to loadPartialConfig (#685)\na507914 Expose the full loader options to all overrides hooks.\nac0c869 Tweak the customize implementation to be a bit more strict.\n9b70a02 Add overrides option\nc8d7a72 Add .mjs to the examples (#683)\n4619993 bable options link update (#681)\n8f240b4 Use node 10 on appveyor\n7e4189e Change appveyor to use babel account\neeaee46 Update devDeps to use most recent versions, and fix tests.\n3e5fb5e chore(package): update lockfile\n2b8e479 chore(package): update eslint-config-babel to version 8.0.0\n\nSee the full diff\n\n. - The devDependency babel-loader was updated from 7.1.5 to 8.0.4.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nd1a3dd5 8.0.4\n2ce62c7 Fix override check (#692)\n\nSee the full diff\n\n. - The devDependency babel-loader was updated from 7.1.5 to 8.0.5.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for 8.0.5\n\nUpdate find-cache-dir to 2.0\n\n\n\nCommits\nThe new version differs by 8 commits.\n\n20c9e0e 8.0.5\nde51b5d chore: Update ava\n66f92af Remove docs mention about sourceMap option being ignored (#750)\n6df8af1 Update dependencies and run all tests (#745)\n2c61de5 Add node 11 and 10 (#744)\n1bda840 Fix config issue in example (#708)\n364387d Merge pull request #698 from MattGurneyAMP/patch-1\n98f936d Fix license header and link\n\nSee the full diff\n\n. After pinning to 2.0.3 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 2.0.5 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 2 commits.\n\nd983b39 2.0.5\nb3fc183 Fix for async functions\n\nSee the full diff\n\n. ## Version 2.0.6 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 2 commits.\n\n4188426 2.0.6\n6406286 Various fixes and improvements\n\nSee the full diff\n\n. - The dependency get-function-params was updated from 2.0.6 to 2.0.7.\nYour tests are passing again with this update. Explicitly upgrade to this version \ud83d\ude80\n\nCommits\nThe new version differs by 2 commits.\n\n65bd858 2.0.7 fixes #6\n7a0abd9 Remove regex s flag and default params.\n\nSee the full diff\n\n. ## Version 3.2.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\n3.2.1\nA quick hotfix to address Browser builds - debug is now compiled down to IE8-compatible code via Babel upon release.\nCDNs that honor the \"browser\": key in package.json should now reflect these changes (previously, they would serve the non-bundled ES6 version).\nPatches\n\nuse babel-ified distributed source for browsers: b3f8f8e\n\n\n\nCommits\nThe new version differs by 2 commits.\n\n84e41d5 3.2.1\nb3f8f8e use babel-ified distributed source for browsers\n\nSee the full diff\n\n. After pinning to 3.1.0 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. ## Version 3.2.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 1 commits.\n\n622e579 3.2.2\n\nSee the full diff\n\n. ## Version 3.2.3 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 1 commits.\n\n700a010 re-introduce node.js (root file) (ref #603)\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n4.0.1\nThis patch restores browserify functionality as well as keeping the intended functionality with Unpkg.com.\nPatches\n\nfix browserify and supply alternative unpkg entry point (closes #606): 99c95e3\n\n\n\nCommits\nThe new version differs by 2 commits.\n\n4490cd9 4.0.1\n99c95e3 fix browserify and supply alternative unpkg entry point (closes #606)\n\nSee the full diff\n\n. After pinning to 1.6.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. - The devDependency mocha was updated from 5.2.0 to 6.0.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v6.0.1\n6.0.1 / 2019-02-21\nThe obligatory round of post-major-release bugfixes.\n\ud83d\udc1b Fixes\nThese issues were regressions.\n\n#3754 - Mocha again finds test.js when run without arguments (@plroebuck)\n#3756 - Mocha again supports third-party interfaces via --ui (@boneskull)\n#3755 - Fix broken --watch (@boneskull)\n#3759 - Fix unwelcome deprecation notice when Mocha run against languages (CoffeeScript) with implicit return statements; returning a non-undefined value from a describe callback is no longer considered deprecated (@boneskull)\n\n\ud83d\udcd6 Documentation\n\n#3738 - Upgrade to @mocha/docdash@2 (@tendonstrength)\n#3751 - Use preferred names for example config files (@Szauka)\n\n\n\nCommits\nThe new version differs by 9 commits.\n\n6d3d6b4 Release v6.0.1\n2146ece update CHANGELOG.md for v6.0.1\n7c9221d backout deprecation of value returned from suite; closes #3744\nb7cfceb fix --watch not finding any files to execute; closes #3748\nb836d73 Upgrade docdash version - issue #3663\n7926f47 fix --ui issues, closes #3746\n00f2ed9 dev dep upgrades from \"npm audit\" and \"npm upgrade\"\n34afb1a fix(cli/run.js): Revert default glob to match Mocha-5.2\n6d5a0db Bring the example congfiguration file in line with the documentation. (#3751)\n\nSee the full diff\n\n. - The devDependency mocha was updated from 5.2.0 to 6.0.2.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v6.0.2\n6.0.2 / 2019-02-25\n\ud83d\udc1b Fixes\nTwo more regressions fixed:\n\n#3768: Test file paths no longer dropped from mocha.opts (@boneskull)\n#3767: --require does not break on module names that look like certain node flags (@boneskull)\n\n\n\nCommits\nThe new version differs by 6 commits.\n\n00a895f Release v6.0.2\n1edce76 update CHANGELOG for v6.0.2 [ci skip]\n347e9db fix broken positional arguments in config; ensure positional args are unique; closes #3763\n9e31e9d fix handling of bareword args matching node flags; closes #3761\n6535965 Update \"karma-browserify\" to eliminate Karma middleware warning (#3762)\n37febb6 improve issue template. (#3411)\n\nSee the full diff\n\n. ",
    "sfescape": "Why would that be expected behavior? It only occurs in the case of control packets, and means your component has to be aware that there are control packets. What benefit does that have?. I don't see what the design tradeoff is. Having a component randomly fail to process all messages because of a race condition certainly seems like a defect to me, not a tradeoff.. I took the example from the documentation for embedding (simple graph that just repeats in to core/Display).\n`\"use strict\";\n// Load the NoFlo module\nconst noflo = require('noflo')\n// Use NoFlo's asCallback helper to prepare a JS function that wraps the graph\nconst wrappedGraph = noflo.asCallback('show_flow', {\n  // Provide the project base directory where NoFlo seeks graphs and components\n  baseDir: process.cwd()\n})\n// Call the wrapped graph. Can be done multiple times\nwrappedGraph({\n  // Provide data to be sent to inports\n  in: 'foo',\n}, (err, result) => {\n  // If component sent to its error port, then we'll have err\n  if (err) { throw err }\n  // Do something with the results\n  //console.log(result.out)\n})`\nI added a console.log to component/Graph.js just before the graph loadFile call.\nif (graph.substr(0, 1) !== \"/\" && graph.substr(1, 1) !== \":\" && process && process.cwd) {\n      graph =${process.cwd()}/${graph};\n    }\n    console.log('load graph file', graph)\n    return noflo.graph.loadFile(graph, (err, instance) => {\nExecute the graph and observe that the show_flow graph is loaded twice.\nload graph file .../graphs/show_flow.fbp\nload graph file .../graphs/show_flow.fbp\nNote: the graph itself only executes once.. ",
    "dallen66": "Thanks. ",
    "ifitzpatrick": "Yeah I like that. I'll update soon. Should name stay it's own argument to preserve backwards compatibility?\n. "
}