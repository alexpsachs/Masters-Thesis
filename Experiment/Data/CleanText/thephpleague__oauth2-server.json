{
    "alexbilbie": "Fixed. Thanks\n. FYI I've fixed all the unnecessary if/else blocks that @FrenkyNet commented on in my refactor\n. So I've cherry-picked some of what you've committed and done a ton of refactoring and now there is a new enableGrantType() method which allows you to enable various different grants which all have native support:\n- authorization_code\n- refresh_token\n- client_credentials (machine2machine auth)\n- password (user's credentials)\nOnce I've finished this work and added some more unit tests I will add some more code so that adhoc grants can be registered.\n. Sorry, can you define \"embedded user-agent\"? Which grant auth is that in the spec (or which extension spec is it) ?\n. Ah sorry you mean the password grant. Yep it does support it and if you can hold off a day or so I'll have some significantly better documentation up to show how to implement it\n. The password grant is in the develop branch https://github.com/lncd/OAuth2/blob/develop/src/Oauth2/Authentication/Server.php. However in the feature/reorg branch we've we designed the API from the ground up (hence my comment about waiting a day or so for updated docs)\n. Fixed\n. Fixed in 43d064733f28cc3be4cb20ed5fd1a102971c45e5\n. Fixed in c25be195f93142eb1a01184bac2862e9712e2336.\nThanks!\n. Fixed in develop. Thanks\n. Fixed in f5b6b43bef08a1fcc5dcefbcabf525fe5339bd92\n. Could you add a unit test for it please?\nThanks\n. All merged into dev :)\n. Base64 is a requirement in the Bearer spec http://tools.ietf.org/html/rfc6750#section-2.1\n. Haha no worries\n\nEmailing from my iPhone like a BOSS\nOn 5 Mar 2013, at 14:36, Michael Gooden notifications@github.com wrote:\n\nMy apologies, my RFC spec parser is faulty.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yep, sorry @MichaelGooden\n. Hey, I've added the users table create syntax to the README in that repository. Thanks\n. Fixed in latest commit. Thanks\n. The correct way of setting the function for the password grant is to use the  setVerifyCredentialsCallback method when you init the grant\n\nphp\n$testCredentials = function($username, $password) {\n    // return user's ID if successful, or FALSE\n};\n$pgrant = new OAuth2\\Grant\\Password();\n$pgrant->setVerifyCredentialsCallback($testCredentials);\n. Thanks. I'll merge it in in the next release\n. Now in dev branch\n. Sorry @mulama77 but as @wdJer said this isn't the right place to ask these questions. Please use the CI forums or Stackoverflow or somewhere else.\n. Thanks, I'll have a look into it and fix it in the dev branch where necessary\n. I've fixed it in dev branch\n. Interesting - we've also implemented the same functionality but it can be done without editing the library's code.\nWe've done it by having an extra column in the scopes database that limits a scope to \"autonomous only\" clients (i.e. where the user doesn't have to be involved) and then in class that implements the SessionInterface I also return this flag along with the other required parameters. Likewise the class that implements ClientInterface returns an additional flag if a client is autonomous only. Then I just do some additional checks in my own code using existing functions.\nI don't think at the moment it is worth implementing in the library, but I will write a tutorial to show how to do it.\n. Am just going to mention #21 in here as both requests are asking for similar requirements (i.e. limiting clients to certain scopes/grants)\n. Now implemented in the dev branch. See #24 comments.\nGoing to close this issue.\n. There are better ways of doing this that can be done without hacking around with the library - I'll post a tutorial on how to do it :)\nNice idea though\n. I've manually merged this in\n. Awesome, I'll include it in 1.1. Thanks\n. I've pulled this into dev branch and written a unit test to cover it. Thanks :smile:\n. This was brought up in #12 by @jfse.\nIn RFC 6750 it uses the term \"b64token\" which according to someone on the mailing list actually means that an access token can be comprised of a certain set of characters and doesn't mean base 64 encoding.\nI will include this fix in v1.1 (i.e. remove the base64 decoding)\n. Fixed in 493834fcbf4d2778533b15447da381573308f6dd\n. Unless you have separate endpoints for different grants (i.e. different instances of the auth server code) then you can already do this.\ne.g.\n/access_token has auth_code and refresh_token grants enabled with token TTL of 3600 seconds\n/access_token_normal has client_credentials grant enabled with token TTL of 86400 seconds\nIf you just have the one endpoint and have the refresh_token grant enabled then all access tokens will have whatever TTL is set\n. @lapause I agree with keeping it lightweight - in the implementation I run at work I've not edited the library and I've made it support limiting scopes to certain clients and also limiting grants to certain clients.\n@ziege why would you allow returning a refresh token but not allow a client to use it?\n. @ziege thanks, I understand what you mean now. I agree with what you're saying and I agree that option 1 is a better option\n. In the dev branch grants are now injected into getClient(), clients and grants are now injected into getScope()\n. I've implemented all of the suggestions here in v2\n. 1) This is easily fixed\n2) I think the refresh token grant is difficult to work with anyway because both the server and the client have to maintain session state, but having multiple sessions for each user/client ID for each client with different TTLs and different scopes is just asking for trouble.\nThe reason I created this library in the first place is because so many people have been implementing OAuth incorrectly and inconsistently and I think this is one example where perhaps deviating from the spec slightly is the best course of action\n. Can you run me off a MySQL dump of this new structure please\n. I've implemented all of this in v2.0 and significantly simplified the usage\n. Thanks, I've also fixed the unit tests as a result be478561b6fd3cf15bad356d51ce611d78d3b5dc\n. The client_secret isn't verified at that stage. In the authorisation grant it is verified when the client exchanges an authorisation code for an access token.\nhttps://github.com/lncd/OAuth2/blob/master/src/OAuth2/AuthServer.php#L377 - loads whichever grants have enabled, for example the authorisation code grant and it is verified in each grant's completeFlow() method https://github.com/lncd/OAuth2/blob/master/src/OAuth2/Grant/AuthCode.php#L62\n. Thanks @ziege \n. Hey,\nGood spot - I've already fixed it in the develop branch which will be pushed to master very soon. If you want to cherry pick it in then it is commit 74d9946db37591c83b0a59b8359ebc35259908fb.\nCheers\n. I've just paraphrased from the spec document\n. Closing this as now out of scope of project\n. Closing this as the method name has changed\n. I can't remember what this was for so closing for now\n. Closing for now; out of scope for V5\n. They aren't missing - you call them via the authcode grant:\n$server->getGrantType('authorization_code')->checkAuthoriseParams();\n. I don't understand what the problem is?\n. Ah I've not updated the tutorials for v2 just yet.\n. I've included this in 2.0.\nThanks\n. Hi Jesse,\nI'm sorry for the disruption over the last 24 hours or so.\nI've just tagged version 2.0 of the library so please consider this the stable and tested (100% code coverage) version.\nBest,\nAlex\n. Thanks, I've just updated it\n. ### General:\n1) I'd prefer not to move it into a separate project so it makes it this project a bit more \"get up and go\". I've no problem with linking to other DB implementations in the Composer \"suggest\" parameter.\nDatabase:\n2) Just escape the keywords\n3) That was a mistake on my part, I somehow missed endpoint_id. I will update it in the next release.\n4) I updated all of the indexes so they refer to the correct columns, what isn't correct?\n5) I've gone through and checked and I can't see an example of where a field that isn't set with \"Allow Null\" which would have an empty field. This isn't a problem.\n6) I'll update it and release a new version. As for putting it in a new table it potentially saves on N extra queries - in my implementation some access tokens have up to 20 scopes.\nSession interface:\n7) It doesn't delete the whole session, it just removes the auth code. I can't see in the spec where it says you can have multiple auth codes in one session?\n8) That was a mistake on my part. I've added it back in and released a new version.\nThank you very much for your feedback @ziege\n. 2) I can change this in the next major release, I've opened a ticket #45\n3) Fixed, and I've pushed another release\n5) I misunderstood your original point. I hadn't realised they'd slipped in when I copied the create syntax into the script. Now fixed.\n6) I've opened a ticket for this #44\n7) I'll address this in the next release as some logic needs to be refactored. I've created #46 and #47\n. Good suggestion, I'll add it in the next release\n. You're right, I'll fix in the next release\n. Agreed. I've fixed this for next update.\n. I've also changed requireStateParam() too\n. I've never used Oracle in my life so I don't know of it's limitations\n. If you could check it and provide import scripts that would be great please.\n. @ziege can you please explain again a scenario where you would have more than one authorization code associated with a session. I can't understand the use case.\nAs a client I request an (i.e. one) authorization code (with specific scopes) which I then exchange for an access token (which the scopes are associated with if the exchange is successful).\nSection 5.1.5.4 of the OAuth 2.0 Threat Model (http://tools.ietf.org/html/rfc6819#section-5.1.5.4) recommends that authorization codes should be removed after one use to prevent replay attacks. I don't then understand how you could have another authorization code associated with the same session as the client has completed it's goal of obtaining an access token.\n. So I've just spoken to Mike Jones from Microsoft who is one of the authors of the OAuth 2 spec and is here at the same conference as me and he says that it is recommended that you revoke the authorization code to prevent replay attacks.\nThe reason this isn't explicit in the spec is because in some distributed environments (e.g. an authorization endpoint which is served from many different geographical locations) there might be a delay between an authorization code being removed in all databases.\nTherefore I'm closing this issue as \"won't fix\" because developing a distributed platform is outside of the scope of this project.\n. Surely RefreshToken::useRefreshTokenRotation(true|false) would just define whether or not the old token would be deleted or kept.\nThe authorization server MAY issue a new refresh token, in which case\n   the client MUST discard the old refresh token and replace it with the\n   new refresh token.  The authorization server MAY revoke the old\n   refresh token after issuing a new refresh token to the client.  If a\n   new refresh token is issued, the refresh token scope MUST be\n   identical to that of the refresh token included by the client in the\n   request.\nSo the flow goes:\n- Check credentials and refresh token.\n- Create a new access token.\n- The scope parameter is optional and can be used to limit the prior scope. If not set, the prior scope is used. If the scope parameter is set then check that there are no new scopes being requested.\nIF TRUE:\n- Revoke the old refresh token (as the client MUST replace it anyway in this case).\n- Create a new refresh token.\n- Return the access token and the refresh token.\nIF FALSE:\n- Create a new access token.\n- The old refresh token remains valid.\n- Return the access token only.\nI don't understand why you think it should error if the scope param is set. In section 6 it says:\nscope\n         OPTIONAL.  The scope of the access request as described by\n         Section 3.3.  The requested scope MUST NOT include any scope\n         not originally granted by the resource owner, and if omitted is\n         treated as equal to the scope originally granted by the\n         resource owner.\nTherefore it should only error if the request includes additional scopes that weren't originally used in the request.\n. After some drawing this out on a piece of paper I agree.\nI'll implement it.\n. Implemented in e591fbb25c476957b4906b1073481fa0cc5ffa49\n. @inanimatt awesome, I'll take a look at it, thanks!\n. Thanks, we're trying to get it renamed to league/oauth2-server, when I requested the name change I omitted then - accidentally.\nI'll fix the zetacomponents requirement.\n. This has been fixed now.\n. Your fork seems really out of date. If it still a problem then please resubmit.\nThanks.\n. ```\nA.12.  \"access_token\" Syntax\nThe \"access_token\" element is defined in Sections 4.2.2 and 5.1:\n access-token = 1*VSCHAR\n\n```\nBefore that at the top of section A:\nVSCHAR     = %x20-7E\n. I went with this in the end:\nphp\nif (strpos($header, ',') !== false) {\n    $headerPart = explode(',', $header);\n    $accessToken = preg_replace('/^(?:\\s+)?Bearer(\\s{1})/', '', $headerPart[0]);\n} else {\n    $accessToken = preg_replace('/^(?:\\s+)?Bearer(\\s{1})/', '', $header);\n}\n$accessToken = ($accessToken === 'Bearer') ? '' : $accessToken;\nYou're right about the further optimisation of the regex, I'll update it for next release.\n. So actually we get rid of the regex and just replace the relevant lines with:\nphp\n$accessToken = trim(str_replace('Bearer', '', $headerPart[0]));\n$accessToken = trim(str_replace('Bearer', '', $header));\nWhich for the cases mentioned above:\n\"Authorization: Bearer  XXX\" ---> \"XXX\"\n\"Authorization: Bearer XXX \" ---> \"XXX\"\n\"Authorization: Bearer XXX , Bearer ABC\" ---> \"XXX\"\n\"Authorization:       Bearer XXX , Bearer ABC\" ---> \"XXX\"\n. Ah of course. The regex stays!\n. Just thought, str_replace('Bearer', '', $header, 1) would only remove the first Bearer\n. I misread the usage of the count argument in str_replace. Ignore this suggestion :+1:\n. I'm wondering if the database table names should be constants so that the PDO and Fluent drivers (#54) can use them so they're not affected when tables are renamed.\n. I'm inclined then to say let's stick with providing scripts for MySQL and Postgres. There aren't a huge number of tables so if people are using other DB types they'll just have to make them themselves.\n. They'll be in version 3 soon\n\nEmailing from my iPhone like a BOSS\nOn 3 Jun 2013, at 16:30, icep87 notifications@github.com wrote:\n\nAny idea when this will get Merged into master?\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks @zacharyblank these are great!\n\nI will merge them in and tweak them slightly as there is a proposal to tweak the table names and queries slightly in #53\n. The schema changed since Zach wrote this. Calm down. That's why I haven't merged it yet.\n\nEmailing from my iPhone like a BOSS\nOn 12 May 2013, at 16:53, Alex Bouma notifications@github.com wrote:\n\nYou are missing 3 methods in Session! associateAuthCodeScope, getAuthCodeScopes, removeRefreshToken. Do you use this code?\n\u2014\nReply to this email directly or view it on GitHub.\n. Ah crap I merged this into master by accident, I've reverted this and will manually pull it in.\n. ## This is an oversight on my part. I will update the wiki and PDO driver with how to make use of the auto-approve feature.\n\nEmailing from my iPhone like a BOSS\nOn 12 May 2013, at 15:05, Alex Bouma notifications@github.com wrote:\n\nYeah I can fix it but I think it should be fixed in the source top because im not the only one using the default PDO implementations I suppose. I can write You an pull request if wanted. If not please do fix so I can use the lib without modifying or implementing the storage models myself. :)\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing this because it has been fixed in the imminent 3.0\n. You're right it does need a default value, however in the context of the semantics of the use of the function the argument is in the right place.\n\nI'll update the develop branch.\n. Fixed in 47c24e3181b12a261ae472db0a63778255567d70\n. One is one it's way - https://github.com/php-loep/oauth1\n. I've fixed the errors in the wiki, thanks.\n. Guys, sorry I haven't helped out much, I've just started a new job, am moving house and have no Internet connection yet. Please bear with me.\n\nEmailing from my iPhone like a BOSS\nOn 3 Jun 2013, at 22:46, Jean-Nicolas Boulay notifications@github.com wrote:\n\nI am! Today I some things to do. But tonight I will be working on it. And when I am done I will give more details on how to setup this package with Laravel 4.\nRight now I am trying out OAuth2-client so that I can test it out with OAuth2-server.\nThe problem is that this package is just a framework to help you create a OAuth2-server. It does not have all the views and other things. You have to coded yourself. The reason, I think, it was to make this package as framework agnostic as possible. But trust me when I am done I will put a link to my GitHub with all the details.\n\u2014\nReply to this email directly or view it on GitHub.\n. Regarding the scope error you should delimite your scopes with a space not a comma unless you override it.\n\n\nEmailing from my iPhone like a BOSS\nOn 6 Jun 2013, at 07:59, Jean-Nicolas Boulay notifications@github.com wrote:\n\nIt seems that there is another problem with the tutorial. Again I am not sure.\nBut in section \"Create your first client\" of the wiki it says to put data in \"oauth_clients\" db table.\nI found that it did not work. So I did some digging and found that I had too add the client_id and redirect_uri to the \"oauth_client_endpoints\" db table.\nIt's weird because the way it is written in the wiki it seems it's just optional.\nI am now getting this error: \"The requested scope is invalid, unknown, or malformed. Check the \"offline_access,email,read_stream\" scope.\"\nI will try to solve it tonight but no guarantees.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm closing this because there are going to be some updated docs in the wiki.\n. Hey, I'll pull this in but can you resubmit it against the develop branch please.\n. Please can you submit this against develop branch.\n\nThanks\n. What is dynamic about the redirect uri you are using? Can the dynamic bit instead be put in the state parameter?\n\nEmailing from my iPhone like a BOSS\nOn 13 Jun 2013, at 02:48, David Mosher notifications@github.com wrote:\n\nPer the OAuth 2.0 spec section 3.2.1.3 on page 13 (emphasis added):\nWhen a redirection URI is included in an authorization request, the authorization server\nMUST compare and match the value received against at least one of the registered\nredirection URIs (or URI components) as defined in section 6...\nThe way the storage currently works is that it is checking for an exact match of the redirect_uri. This fails when say your provider is attempting to append a query string to the redirect_uri.\nI'm currently working on a fix for this internally for myself...but wanted to make sure I'm seeing this correctly and am not just overlooking something. Thoughts?\n\u2014\nReply to this email directly or view it on GitHub.\n. And what happens if you do:\n\nbash\ncurl http://authorizeserver.local/oauth2?client_id=test&grant_type=authorization_code&client_details=test&redirect_uri=http://test&response_type=code\n?\n. Please look in your frameworks documentation on how to integrate Composer packages.\nOn 28 Jul 2013, at 10:54, nasaorc notifications@github.com wrote:\n\nhow to intergrate this with ci?\nwhere should i put the League folder in?\nhow to load the oauth2 lib?\n\u2014\nReply to this email directly or view it on GitHub.\n. You need to send grant_type=XXX in your final request (where XXX is whichever grant you are using)\n. The request you're sending isn't even remotely valid.\n- The first request to /oauth sends client_id, redirect_uri, response_type and scope via GET\n- Once the user has signed in and returned to the client app with an auth code you send a POST request to /access_token with client_id, client_secret, grant_type, authorization_code and redirect_uri\n\nOn 12 Aug 2013, at 08:16, zeratool notifications@github.com wrote:\n\nThanks for the reponse, but i did send it, tried via GET and POST:\nhttp://localhost/oauth_controller/access_token?username=username&password=password&grant_type=authorization_code&client_id=test&client_details=Test+Client&redirect_uri=http://localhost/test&response_type=code&scopes=read+scopes&code=RK2DjrHgp995U1wkaUhuJYoccddOCswoYGgSrBQW\n\u2014\nReply to this email directly or view it on GitHub.\n. @vivek-1874596 You need to implement the repository interfaces - http://oauth2.thephpleague.com/installation/. Fixed. Thanks\n. Please can you resubmit this against develop branch. Thanks.\n. It's a Laravel class, at the top of the guide it says:\n\"This guide will use some Laravel framework functions however the library is framework agnostic.\"\n\n:smile:\n. Take a look in the wiki for some tutorials\n\nEmailing from my iPhone like a BOSS\nOn 6 Jul 2013, at 22:24, ashsou notifications@github.com wrote:\n\nhi,\nI downloaded the code to test the oauth over codeigniter framewrok , but I am really confused from where could I start . what I did is just importing the tables on database but then what to do with code ?!\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm really sorry but I can't help you with those problems. Please try asking on stackoverflow.com\n. You'll have to write your own method - but remember to check that if the user has approved the client before then they only approved the scopes that are requested in the current request - i.e. if the user originally approved app XYZ for scopes FOO and BAR, then if the app is now request FOO, BAR and FOOBAR the user should be asked for permission to access all the scopes again.\n. Fixed by just removing the write to disk logging in cfbb037e071d3f52c308e026f609ea6307da1b15 \n. There is an undocumented (and untested) Implicit grant in the library which you can use.\n\nCan I ask why you need the implicit grant? I strongly recommend that you avoid it\n. That's correct however please read this if you haven't already https://github.com/php-loep/oauth2-server/wiki/Which-OAuth-2.0-grant-should-I-use%3F#implicit-grant-section-42\n. 1) The ezComponents aren't required, they're used if you want them to save you having to implement all of the interfaces yourself. In the develop branch there are implementations of Laravel's Fluent and Doctrine's DBAL as well as ezComponents.\nThe tutorial does say how to use the component in the last paragraph here:\n\nTo use the PDO classes then add \"zetacomponents/database\": \"1.4.6\" to your composer.json file and run composer update.\n\n2) Fixed, thank you\n. Can you resubmit this against develop please\n. Please resubmit to develop branch\n. Please could you resubmit this against the develop branch and I'll merge it in.\n. Merged in #94\n. The owner_type parameter relates to the type of \"thing\" which owns an access token.\nSo if you're implementing the authorization code grant then the owner type will be user.\nIf you're implementing client credentials the owner type will be client.\n. The owner type can be any arbitrary value you want it to be.\nYou will be able to manipulate tokens really easily in v4 :+1: \n. The logic for dealing with errors for a missing client_id for example is this:\nphp\nif (is_null($authParams['client_id'])) {\n    throw new Exception\\ClientException(\n        sprintf($this->authServer->getExceptionMessage('invalid_request'), 'client_id'),\n    0);\n }\nAnd looking at the code for handling exceptions you can see the error message which is resolved is:\nphp\n'invalid_request' => 'The request is missing a required parameter, includes an invalid parameter value,\nincludes a parameter more than once, or is otherwise malformed. Check the \"%s\" parameter.',\nLikewise for an invalid client:\nphp\n'invalid_client' => 'Client authentication failed',\nSo I don't understand what the problem is if the client is properly interpreting the message.\n. The specification section you copied says this (emphasis mine):\n\nIf the request fails due to a missing, invalid, or mismatching redirection URI, or if the client identifier is missing or invalid, the authorization server SHOULD inform the resource owner of the error and MUST NOT automatically redirect the user-agent to the invalid redirection URI.\n\nErgo your statement is incorrect, you should inform the client of the error which can be accessed through the exception message.\n. So don't redirect the user back to the client then, just throw an error message on the auth server.\n. The only time you should redirect back with an error is if the user doesn't authorise the client.\n. This has been fixed in the develop branch.\n. Thanks for answering @suwardany.\nI've nearly finished v3.0 of the library and I'll bolster the wiki entries with some more advice/hints.\n. Not going to accept this. This pisses people off in the other grants so it was removed in #32\n. Yep, just use addGrantType to add additional grants.\nIn answer to your questions:\n1) The library will automatically perform the correct actions for each grant type based on the grant_type parameter that the client uses.\n2) If you've created all of the endpoints in the auth code example then you've created all the required endpoints for the other grants.\n3) For the moment please read the source code and/or unit tests. I'll update the wiki when I release v3\n. @jackshakes there is a unit test which compares two unix timestamps, sometimes it fails because they don't match. I've restarted the job so don't worry about it\n. Hmm I'm not sure this is something the library (because everyone will have different methods for setting headers) can solve but I can certainly make it clear in the documentation that the headers should be set\n. Why are you porting it to CodeIgniter? This library will work fine as is, you just need to import it with composer.json and set up some routes and controllers and a model for the DB\n\nEmailing from my iPhone like a BOSS\n\nOn 5 Oct 2013, at 11:51, samedney notifications@github.com wrote:\nI'm currently porting this in to CodeIgniter. Going quite well so far, so will upload something soon. I couldn't find anything out there but knowing who is on this team - has this already been done?\nAlso - from a beginners perspective - it would be good to have this available as a working project, with some sample data (users, scopes etc) and html login page.\nAgain - if this is out there, could someone point me in the right direction?\nMany thanks.\n\u2014\nReply to this email directly or view it on GitHub.\n. This has been fixed in develop already\n. The request class already normalises the headers\n. The header should be:\n\nAuthorization: Bearer <access token>\n\nEmailing from my iPhone like a BOSS\n\nOn 15 Nov 2013, at 21:35, David M notifications@github.com wrote:\nI'm using laravel as well. Things are working great.\n\u2014\nReply to this email directly or view it on GitHub.\n. Implement the methods to check access tokens and scopes as you would if they were GET/POST methods.\n\nWhen you send a request from the client (using any HTTP method) send an Authorization header like so:\nAuthorization: Bearer <access token>\nThe library will check for an access token in the authorisation header and will verify it\n. Probably because I never had a use case for passing the access token as a property when using PUT and DELETE methods when I created the library and instead just sent it as a header.\nIf you want it in there implement it, test it and send a pull request, or in your code just send a header which is far easier\n. Sorry I've just read through the whole conversation again. @jackshakes is right, if it isn't in the spec it shouldn't be allowed.\nThe reason why I built this library in the first place was so people can make spec compliant implementations and not shoot themselves in the foot like Facebook did.\nTherefore if it isn't in the spec we shouldn't deviate.\n. @jackshakes I\u2019m probably going to scrap it in v3.0 for something lighter\nOn 20 Nov 2013, at 17:02, jackshakes notifications@github.com wrote:\n\nOk, so if that's the issue, I see why you're having troubles getting PUT/DELETE to work. And in that, you're right that the ResourceServer library could be extended to fetch tokens from the body of these methods.\nFor that you could extend the League\\OAuth2\\Server\\Util\\RequestInterface library to implement the remaining crud methods.\n@alexbilbie, FWIW, I would vote this should be an extension, though, and should not be included in the base package.\n\u2014\nReply to this email directly or view it on GitHub.\n. This is already fixed in develop branch. Thanks though\n. As @jackshakes mentioned, the spec states that the redirect uri should be white listed.\n\nThe reason why I created this library was so people could implement secure solutions so I'm not going to implement this.\nFacebook have been screwed over several times because their oauth implementation only matched redirect uris at the domain level an it opened security holes.\n\nEmailing from my iPhone like a BOSS\n\nOn 14 Nov 2013, at 21:09, jackshakes notifications@github.com wrote:\nSee section 10.6: http://tools.ietf.org/html/rfc6749#section-10.6\nIn order to prevent such an attack, the authorization server MUST ensure that the redirection URI used to obtain the authorization code is identical to the redirection URI provided when exchanging the authorization code for an access token. The authorization server MUST require public clients and SHOULD require confidential clients to register their redirection URIs.  If a redirection URI is provided in the request, the authorization server MUST validate it against the registered value.\n\u2014\nReply to this email directly or view it on GitHub.\n. Rather than altering one if the existing grants why not add your own by implementing the grant interface.\n\n\nEmailing from my iPhone like a BOSS\n\nOn 14 Nov 2013, at 21:35, Robert Pitt notifications@github.com wrote:\nThanks, you are right in not implementing this. I will have to fork the library I am using and restructure it to use the state to transfer the dynamic k/v's\nThanks\n\u2014\nReply to this email directly or view it on GitHub.\n. What @jackshakes said\n. I'm working on a new set of tutorials\n. Mostly this release is about improving the underlying library so that it further implements the specification. There are some significant changes to the storage interfaces and the library now requires PHP 5.4+.\n\nI am working on some documentation which I'm hoping to have done by the end of the weekend. I'll update this issue when I've finished.\n. If you've got any questions then ask away :+1: \n. The release notes state that the built in DB storage classes have been removed \n\nEmailing from my iPhone like a BOSS\n\nOn 9 Dec 2013, at 13:15, SHELA notifications@github.com wrote:\nafter update get\nClass 'League\\OAuth2\\Server\\Storage\\PDO\\Db' not found in\n\u2014\nReply to this email directly or view it on GitHub.\n. dev-temp was deleted ages ago but I believe it pointed to this https://github.com/php-loep/oauth2-server/releases/tag/1.0.9\n. Also why would you base your code off something labelled both \"dev\" and \"temp\" ?\n. Can you resubmit against develop branch please\n. Yep stick with headers\n\n\nEmailing from my iPhone like a BOSS\n\nOn 12 Dec 2013, at 09:43, kevin mulama notifications@github.com wrote:\nSrry, Just read #111\ni'll try to implement it..............\n\u2014\nReply to this email directly or view it on GitHub.\n. Spelling - authorization_code - notice the z, you're spelling authorisation the British English way\n. No problem. It pained me everytime I had to write authorisation with a z but that's how the spec spells it\n. The SessionInterface specifies you should return a key called session_id - https://github.com/php-loep/oauth2-server/blob/develop/src/League/OAuth2/Server/Storage/SessionInterface.php#L160\n\nWhy have you made this change?\n. Ask me again tomorrow :)\n\nEmailing from my iPhone like a BOSS\n\nOn 14 Dec 2013, at 20:51, SHELA notifications@github.com wrote:\nand what you decide to do?\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah - basically I'm rewriting a lot of the backend again so it is more OO and even simpler to work with. Another day or so and it'll be done - with docs :smile: \n. You need an instance of Server\\Resource which you can then call isValid() on.\n\nSo your middleware basically calls isValid() then if it is a valid access token the route will go through as normal. You can then use other methods like hasScope() to verify the access token has a particular scope associated.\nRefresh tokens are used against the authorisation server endpoint. So POST to whatever your /access_token endpoint with\ngrant_type=refresh_token\n&refresh_token=XXX\n&client_id=XXX\n&client_secret=XXX\nAnd you will be given a new access token\n. You use the resource server for token checking, and use the authorisation server for generating them\n\nEmailing from my iPhone like a BOSS\n\nOn 15 Dec 2013, at 16:07, origal notifications@github.com wrote:\nI see.\nI have an instance of Server, but there isn't seems to be an isValid() method in it.\nOn which stage do I instantiate a Resource and how?\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing this until I can remember why I wanted to do it in the first place\n. I'm not going to put it in the library because it isn't in the core spec but if you want to do it then all you'll need to do is just duplicate the authorisation grant class and just implement the custom logic in that\n. I'm working on v4, I'll double check this when I rework the Refresh grant\n. It looks like I forgot to implement it in the Implicit grant.\n\nI'm currently working on v4 so I'll fix it in that.\nI'd highly recommend avoiding the Implicit grant in any case.\n. http://alexbilbie.com/2013/02/a-guide-to-oauth-2-grants/\nOn Wed, Dec 18, 2013 at 10:48 AM, origal notifications@github.com wrote:\n\nWhy do you recommend avoiding it?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/php-loep/oauth2-server/issues/133#issuecomment-30832274\n.\n. Pretty much what @jackshakes said. Also as I explain in this blog post http://alexbilbie.com/2013/09/securely-store-access-tokens-in-single-page-web-app/ having a single page web app is no excuse for lame security\n. If the user has their own credentials and it is an app your trust then the Client Credentials grant is designed exactly for this use case\n\n\nEmailing from my iPhone like a BOSS\n\nOn 22 Dec 2013, at 09:17, origal notifications@github.com wrote:\nThe use case is pretty simple. It's an API that serves native iOS and Android official clients. We have our own content website which the applications access via these mobile apps:\nUsing our iPhone/Android official app, a user should be allowed to login to our website either by our own service user and pass we provided him when he first signed in to our website, or by his Facebook/Google and so own.\nIn addition, The process of logging in with another Idp such as Facebook/Google/Twitter should be managed by Gigya (http://www.gigya.com) which offers this authentication as a product.\n\u2014\nReply to this email directly or view it on GitHub.\n. When a user signs in you could automatically assign appropriate scopes.\n\nYou'd need to slightly alter the grant for this so scopes are required in the request. \n\nEmailing from my iPhone like a BOSS\n\nOn 22 Dec 2013, at 09:40, origal notifications@github.com wrote:\nIs this grant suitable for users that have different permissions over the content?\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm assuming I can close this\n. @shadowhand The project README claims it is \"spec compliant\" (for the specs that are supported by this library) and has 100% code coverage.\n\nThe implicit grant support is half baked because I fundamentally think it is a mistake to implement it. I've done my best to create a library that is secure by default.\nI'm going to remove all support the implicit grant from v4 onwards\n. My pleasure :smile: \n. v4.0 is a complete rewrite and is not backwards compatible however it shouldn't take too much work to switch over. I will try and write a migration guide when I'm done from v3\n. ETA is probably by the end of the month, it's now at feature parity with v3 branch.\nI will probably only bug fix major flaws myself, if others have issues I'm happy to accept PRs, but my attention going forward is v4\n. It's been merged into develop\u2014\nSent from my iPhone\nOn Fri, Sep 12, 2014 at 12:06 AM, Gustavo Schirmer\nnotifications@github.com wrote:\n\nHi guys, where is the 4.0 branch?\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/139#issuecomment-55341634\n. Woh woh, please hold on, I've not finished the big changes I want to make, I'm just going to get confused if someone else is making big changes at the same time.\n\nRegarding the points you've made:\n- I plan on removing the grants trait to an abstract class\n- The better injection will come through the splitting up of functionality into the new classes. I don't want lots of interfaces being initiated in a constructor.\n- I don't get the point about fluid interfaces.\n- I've already started replacing with Symfony Request\n- Maybe. But it's not this librarys problem if you've already got another class called Authorization something or Resource something, we're using standard OAuth terms here.\nRegarding the entities classes, I've called them entities because I couldn't think of a better name at the time. Each of those entities has a save() method which calls a method in the storage interfaces.\nI disagree about the term \"storage\", a service implies a dependancy, whereas storage makes it obvious as to the intent.\nPlease don't submit a massive PR because we can't discuss individual changes as easily\n. But that's how the library works at the moment - developers implement the storage interfaces (which are significantly smaller than they used to be), inject them into the resource/authorisation server which in turn other classes call to ask for an instance of the storage class. So in a way the server class itself is acting like a service locator.\n. Thanks @robertpitt \n. This should be fixed with v4\n. In your test you need to set $_SERVER['HTTP_REQUEST_METHOD'] = 'get' somewhere before the resource server object is initialised so that it is picked up when the Request class is initialised\n. Thanks but I'm not going to merge, I've already dealt with this in v4\n. 4.0 is close enough that I'd hold off for a few days - I've just moved\nhouse so I've been a bit distracted these past few days but I've been\nworking on a brand new documentation site (which will be at\nhttp://oauth2.thephpleague.com/) which included upgrade notes and the\nlatest documentation.\nSorry for the delay.\nAlex\nOn 12 February 2014 12:16, Matt Robinson notifications@github.com wrote:\n\nFrom the release notes for 3.0:\nRemoved the build in DB providers - these will be put in their own repos\nto remove baggage in the main repository\nI can't find them! If they exist, could you link to them in the README\nand/or put them in the composer.json \"suggest\" property (is that\nappropriate?)\nIf they don't exist, then I'm happy enough to set up the Doctrine DBAL one\nI ported from your ezComponents original as a repository and share it, if\nthat'd help.\nOr is 4.0 close enough that it's not worth the effort?\n\nReply to this email directly or view it on GitHubhttps://github.com/thephpleague/oauth2-server/issues/147\n.\n. Please see my comment here - https://github.com/thephpleague/oauth2-server/pull/178#issuecomment-48717800.\n\nI'm finishing off the work on the v4.0.0-relational-example as I type this\n. Closing this issue so documentation development can be tracked in #193\n. You should use headers instead of the query string or body content, see #111 \n. You could do that but it'd be easier to just pass the header from the start.\nFrom v4 onwards this library will only accept access tokens over headers by default\n. Not going to merge, see #111 \n. This is fixed from v3 onwards\n. It's an oversight, I obviously missed it. I will make sure it's removed from 4.0 going forward\n. This is fixed in v4 which will be tagged today\n. Good idea. I'm not going to merge this in just yet (I want to add the feature to v4 too) but I will shortly\n. I've merged this and released 3.2 (and also merged it into v4.0). Thanks\n.  I've no idea - you should ask the Packagist guys for help.\nSorry\nOn 8 April 2014 14:47, sebasco91 notifications@github.com wrote:\n\nHi, I am trying to download this project, but when i do it by \"composer\ninstall\", it say: Authentication required (packagist.org) username:\npassword: How can i do? sorry if my cuestion is not that smarth and sorry\nfor my english.. please help me...\n\nReply to this email directly or view it on GitHubhttps://github.com/thephpleague/oauth2-server/pull/151#issuecomment-39849325\n.\n. Hey guys,\n\nI am really sorry - my personal life has been immensely busy lately. What work I have been doing has been on v4 (which was an almost complete rewrite and is now back to feature parity with v3). From here on I'm making a few more changes (see here for a list of what I've got left to do) then I will solely be working on documentation including documentation and upgrade notes.\nAlex\n. Closing this issue so documentation development can be tracked in #193\n. You're right that the spec is open to interpretation and I have made the careful decision to ignore the bit you've highlighted.\nThe reason why I created this library originally was because too many vendors and developers were implementing OAuth 2 authorisation servers which deviated from the spec and in some cases (see Facebook namely) created vulnerabilities for themselves.\nIn my opinion it is better to take a stricter approach to the specification in this case - I can't think of an instance whereby you'd want to authorise a user to do something but not authenticate the client requesting the authorisation on behalf of the user.\nWe can go forward and add a flag for that grant for authentication the client to be disabled but in the interest of allowing people to create secure, spec compliant implementations I don't think it is wise.\n. The short answer is yes it is a deal - they're private credentials, I've written a blog post about this issue and I'm going to address it in my book - http://alexbilbie.com/2013/09/securely-store-access-tokens-in-single-page-web-app/\n. This isn't an issue with the library, so I'm not going to make any changes.\nCan I recommend in your case you instead use IP firewall whitelisting instead of basic auth?\n. Right I've done some reading in the two different specs and I've made some decisions:\n1) Adding a custom OAuth header is not the right approach to go as per your suggestion\n2) I will make the authorization header matching stricter - it will only make use of the header if it starts with \"Bearer\" or any other registered token type. Therefore if you're combining basic/digest auth and query string tokens the server will ignore the auth header.\n3) Like you can with custom grants I'll add the ability to register custom token types and the ability to set the override the default bearer token output with another output - this will clean up a lot of duplicate code.\nI will make these changes going forward for v4\n. Hi Luca,\nI'll take a look into it.\n:+1: \n. It won't be imminent, I don't have the time to work on it at the moment I'm afraid.\nOut of interest why do you want to use it? I've yet to see a use case personally\n. I agree with you, I actually implemented OAuth 2.0 with my own type of signatures recently.\nI think I need to make some slight changes to the codebase in order to fully support non-bearer tokens. I also want to add support for JWT too (#209)\n. So I've had a go at implementing this and it's going to be much easier than I thought. I will post an update when I'm done :)\n\u2014\nSent from my iPhone\nOn Sat, Nov 15, 2014 at 4:51 AM, Sean notifications@github.com wrote:\n\nSimilarly, I am interested in defense in depth. An OAuth1.0 style verification would be very helpful in case TLS fails in preventing MITM attacks.\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/158#issuecomment-63160725\n. MAC token support is now in v4.1.0\n. Cheers but I'm not going to accept this only because I've got a better way of doing it.\n. Thanks Luca, I'll get on them\n. That's great. I'm actually sat just now working on a relational database example (I'll also do a no-SQL version too) which I can use for behavioural tests.\n. @lucadegasperi this response might be of interest to you https://github.com/thephpleague/oauth2-server/pull/173#issuecomment-43815646\n. Sorry for the late response; in theory this shouldn't be something to worry about because the algorithm that generates the access token uses openssl_random_pseudo_bytes which should always generate a unique token\n. :+1: cheers\n. My bad, will fix.\n\nThanks\n\nEmailing from my iPhone like a BOSS\n\nOn 6 May 2014, at 08:41, Jason Lewis notifications@github.com wrote:\nI was going to send a PR but I just wanted to clarify it first.\nThe authorization parameters are being fetched from the request body and not the query string, as per the spec. This means clients have to post a request to the authorization server instead of simply allowing a users to click a \"login with...\" link.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'll fix it in the current update I'm making\n\n\nEmailing from my iPhone like a BOSS\n\nOn 6 May 2014, at 08:48, Jason Lewis notifications@github.com wrote:\nNo worries. Just let me know and I can switch it over and send a PR. \n\u2014\nReply to this email directly or view it on GitHub.\n. Good find.\n\nMy reasoning for building v4 was because I wanted to use Redis instead of a RDBMS too. Hopefully you'll find this version much easier to work with than previous versions :)\n\nOn 6 May 2014, at 09:08, Jason Lewis notifications@github.com wrote:\nBack story is I'm implementing a Redis storage adapter so am thoroughly testing it. Here's what I've noticed so far.\nWhen using the authorization_code grant the newAuthorizeRequest method sets the redirect URI on the AuthCodeEntity, when the entity is saved this value is never sent along to the storage adapter so the redirect URI is never saved. This means the authorization_code grant will only succeed if you pass a blank redirect URI when requesting a token with the code. Fix is to add a $redirectUri parameter to the AuthCodeInterface::create method signature.\n The authorize parameters should be sent in query string not request body (#164).\nAm still in the process of testing so will update as I go. Cheers @alexbilbie.\n\u2014\nReply to this email directly or view it on GitHub.\n. 1. I was intending to associate the redirect URI with the auth code\n2. Nope, spec only allows user's credentials in the body. The getUser() + getPassword() can however be used to pick up the client's credentials\n3. I'll look at this\n. I don't suppose you fancy unit testing the methods in this class for me do you? :angel:\n. It's cool, I'll test it :)\n\nOn 6 May 2014 16:51, Luca Degasperi notifications@github.com wrote:\n\nAllright, don't know how to begin testing this. Mock everything perhaps?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/thephpleague/oauth2-server/pull/167#issuecomment-42320667\n.\n. Registering multiple client endpoint has been possible since v3.\n\nWhen ClientStorage::get is called it passes in the redirect_uri from the request when validating the client during the authoriseParams part (which results in an auth code being issued).\nYour implementation of the client storage could reference a main clients table and join a client redirect URIs table to verify the redirect uri is correct. In that second table there could be multiple URIs registered per client.\n\nEmailing from my iPhone like a BOSS\n\nOn 8 May 2014, at 05:12, Dustin Wheeler notifications@github.com wrote:\nEssentially, what I'm reasoning about is that within the context of a developer managing a set of client applications with a centralized authorization service; the client application is itself a protected resource of the developer who is authenticated to a web interface that is making requests on his/her behalf to those resources on the authorization server. [Enter chicken and egg]\nThe \"ClientApplication\" within that context is seemingly separate from the intended functionality behind \"ClientEntity\" represented by this package. ClientEntity seems to be a simple data-transfer object or \"view model\" of that more supple ClientApplication.\nI just want to make sure I'm interpreting that correctly. Because if that's so, it actually releases me to stop \"thinking I'm doing it wrong\" because I'm dealing with two TRULY separated contexts of operation. In that scenario, the package would only be used to facilitate authorization framework concerns and an anti-corruption layer would be established between my \"protected resource management\" context and this package.\n\u2014\nReply to this email directly or view it on GitHub.\n. You're right the managing of clients is outside the scope of this library.\n\nThe client entity itself won't be aware of it's own redirect URIs - the auth code will be aware the redirect URI that was validated against the client during the authorization code grant flow.\nIn terms of the future of this package, the main goals of v4 are:\n- DB independence (so you can use RDBMS, No-SQL DBs, flat files, whatever)\n- Making everything internally an object so it's easier to pass things around, and testing has become a much much easier.\n- Adding support for MAC tokens\n- Documentation (and lots of it!)\n. Does that answer your questions?\n. Can I close this or is there still an open issue?\n. My plan was to have some sort of flag in the exception to indicate that the user should be redirected and then clearly document that that is the correct behaviour and show this with examples.\nI'll leave this issue open until I've done that.\nCheers!\n. I'm loathe to merge this as it is for an old version of the library. Sorry\n. I've published 2.1.3 with this in\n. Thanks :+1: \n. The grant type that is being used in the request is injected into the interface so that if you wanted to you could limit clients/scopes to specific grants.\nThe documentation is a mess at the moment and I intend to correct that next week.\n. This is cool but I'm thinking there is a better way to generate these SQL scripts based on the work I've been doing in the relational-example branch to generate a schema using illuminate/database's schema builder.\nI'm thinking I could write a small command like utility to spit out an SQL schema script for the selected database; the relational example will always be kept up to date as they are forming part of the tests in v4\n\u2014\nSent from my iPhone\nOn Wed, May 21, 2014 at 5:58 PM, Steven Wade notifications@github.com\nwrote:\n\n\nConverted mysql.sql to Postgres using Lanyrd's MySQL to PostgreSQL\n  conversion script\n  (https://github.com/lanyrd/mysql-postgresql-converter)\nAltered the converted SQL. The default output created multiple\n  sequences to replace MySQL's autoincrement. Removed sequences and\n  replaced with bigserial column types\n  You can merge this Pull Request by running:\n  git pull https://github.com/SuiteTea/oauth2-server feature/postgresql\n  Or you can view, comment on it, or merge it online at:\n  https://github.com/thephpleague/oauth2-server/pull/173\n  -- Commit Summary --\nAdded support for PostgreSQL\n    -- File Changes --\n    A sql/postgres.sql (118)\n    -- Patch Links --\n    https://github.com/thephpleague/oauth2-server/pull/173.patch\n    https://github.com/thephpleague/oauth2-server/pull/173.diff\n    ---\n    Reply to this email directly or view it on GitHub:\n    https://github.com/thephpleague/oauth2-server/pull/173\n. Thanks anyway!\n. $scopes is defined on line 221 so I'm unsure how it is not defined for you\n. You could very easily implement this but it is out of scope of this library.\n\n\nI'm also of the opinion that one of OAuths strengths is it's upfront honesty regarding what permissions an app is requesting and I think it is a better user experience to always show all the scopes, not just new scopes.\nJust my 2c\n:)\n\u2014\nSent from my iPhone\nOn Wed, May 28, 2014 at 6:49 PM, stephenfrank notifications@github.com\nwrote:\n\n(Proviso: I may completely misunderstand certain things in the spec/implementation so bear with me)\nWhen, as a user, I connect to OAuth2 service like Google, I never have to re-approve any scopes that I've already approved in the past. It seems to remember them. This means that the 2nd or 3rd time I need to connect using Google, I never have to re-approve the same old scopes.\nHowever, I can't find anything in this implementation to store these approved scopes. I do see that they are stored in \"oauth_session_token_scopes\" but there doesn't seem to be any longer term storage which would allow my implementation to skip the \"approval\" step altogether.\nSo in 3 questions:\n- Would I be correct to implement my own table to \"save\" and \"retrieve\" the scopes which a user has approved?\n- Is it within the realm of this server implementation to provide interfaces for this storage?\n- Am I missing something else entirely?\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/175\n. Thanks Dustin.\n\nI plan on having both relational and non-relational examples inside the repo which can be used for reference and also will have functional tests as part of the testsuite.\nAlex \n. Hi,\nThere is a reason that I've held off on this - I've been working on proper documentation for v3 and v4 and it's been really helpful to spot where the holes are in the library. As soon as I've finished which will be in the next day or so I will merge this in.\nCheers,\nAlex\n. I've merged this in. Sorry for the unnecessarily long delay @shadowhand.\nAs I said on Twitter I know it seems like there isn't any activity on the codebase but I am working away on it locally, I'm not yet happy with the API and I've been trying some different approaches - I want to keep the library nimble and my concern is with v4 that quite a lot of code is required to implement the storage interfaces. I feel I may have gone a bit OTT with abstraction to the detriment of making the library easy to work with.\nIn addition I've come up with scenarios where I need to adapt sessions on the fly - e.g. auto-assigning scopes based on a user's role and permissions - and it's not currently possible to interact with the entities unless you implement customs grants which in itself requires lots of code copy and pasting.\nI do also have most of the docs written, but until I've settled on the API it's not yet worth publishing them.\nAgain I am sorry for the delay, I genuinely care for the project and want to make sure it's the best implementation out there.\n@philsturgeon @lucadegasperi @jasonlewis\n. That's my plan.\nI can easily abstract out an *sql and Redis package from the examples in the repo.\nI've all but abandoned frameworks now so others will have to create implementations for those.\n. @shadowhand have tagged 3.2.1\nv3 does a good job but it's a pain in the arse to implement a non-relational database backend, v4 addresses this as well as making hundreds more optimisations. There will be a 3.x upgrade guide.\n. @shadowhand actually I'm underselling v4 a bit - it's pretty much a complete rewrite of the codebase\n. @shadowhand #139\n. Fixed\n. Closing this issue so documentation development can be tracked in #193\n. :+1: Thanks @fahmiardi \n. Closing this issue so documentation development can be tracked in #193\n. I've removed the implicit grant in v4.\nI will consider a sibling package that adds support but I don't want it to be part of the main library because it isn't safe to use (in terms of the grant from the main spec, not just this implementation)\n. Cheers @shadowhand, I've also removed than annoying assertion that breaks when comparing seconds in v4\n. (oops, didn't mean to close before merging)\n. Sorry Github seems to be stuck on this:\n\n. On it\n. Please see #193\n. It's required in this implementation because everybody who makes it optional fucks it up and gets hacked (e.g. Facebook).\nThis project tries to be \"secure by default\" and that includes requiring redirect URIs to be required and whitelisted\n. You're quite right.\nIt's already been removed from v4 and going forward it won't be included in v3\n. @novaking yep\n. Yep, the documentation was very out of date and I'm truly sorry I've not stayed on top of it.\nIf you want to start using v4 then there is a working example in the code\n. Some initial documentation is now up at http://oauth2.thephpleague.com/\nI'll be finishing it up over today\n. I've updated this in the docs\n. I think that's a good idea. As for database columns etc there is a hint to a basic DB setup in the examples/ folder but this library is intended to be flexible enough to fit into an existing system or building a new one.\nI'm on holiday at the moment but will definitely work on this when I'm back.\nCheers!\n\u2014\nSent from my iPhone\nOn Thu, Oct 30, 2014 at 9:44 AM, Michael H\u00e4rtl notifications@github.com\nwrote:\n\nNot sure, if this should go to its own issue: Could the documentation maybe expound a little more on the storages? I.e. \n\nLeague\\OAuth2\\Server\\Storage\\SessionInterface - contains methods for retrieving and setting sessions\nWhat exactly is a \"session\" in this context? I think it therefore would be very useful to describe all required DB tables and their columns. Including, which of them are meant to be popuplated/managed by the developer, and which of them are used to keep transient data of this library (and thus should not be touched at all).\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/193#issuecomment-61093140\n. @zzal http://oauth2.thephpleague.com/authorization-server/refresh-token-grant/\n. If you have enabled the refresh token grant, when you use the auth code or resource owner password credentials grant a refresh token will be issued along with the access token.\n\n\nYou can then use the refresh token to request a new access token later on.\n. Send a POST request to your access token endpoint (the same one that you use to get the access token using password grant) but the grant type is refresh_token instead.\nThere are extensive examples that demonstrate the usage of grants in the tests/ folder e.g. https://github.com/thephpleague/oauth2-server/blob/master/tests/unit/Grant/RefreshTokenGrantTest.php#L425\n. Sorry, if you could use dev-develop now as the version (the branch is stable). I will tag v4 when #193 is done.\n. It isn't an issue because acquiring an access token is a POST request which the client makes in the background, the user doesn't leave the client.\u2014\nSent from my iPhone\nOn Thu, Aug 7, 2014 at 9:29 AM, Luca Degasperi notifications@github.com\nwrote:\n\nHey Alex,\ngreat work on the develop branch! \nAs you know I'm implementing a Laravel wrapper for the new version. One point I'm confused about is how to redirect the user back to the client when the auth_code grant type parameters check fail.\nI know there is a shouldRedirect flag but there's no way to know the redirect uri to redirect back to.\nI cannot read your mind, any clue on how to do this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/195\n. So you're referring to when you call\n\n$authParams = $server->getGrantType('authorization_code')->checkAuthorizeParams();\nand\n$redirectUri = $server->getGrantType('authorization_code')->newAuthorizeRequest('user', 1, $authParams);\n?\n. Ah I see.\nI think the easiest solution is to inject the redirect URI into the exception and then you call getHttpHeaders() method on the exception if serverShouldRedirect is true then it will return a correctly generated Location header (and nothing else)\n. Yep, I'll update the issue when I've implemented it\nOn 7 August 2014 11:53, Luca Degasperi notifications@github.com wrote:\n\nWould you mink taking care of this?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/195#issuecomment-51457143\n.\n. Yep and that's what is implemented :)\n\nThe mistake I've made is if any other parameters fail then we redirect back but I've not made a way for the server to know where to return the user too...\n. Fixed in develop. Updated docs too\n. Some initial documentation is now available for v4 at http://oauth2.thephpleague.com/\nI'm going to be finishing it over today. Tracking issue is #193 \n. What Charles said. I'm working full time on docs today\u2014\nSent from my iPhone\nOn Mon, Aug 11, 2014 at 5:00 AM, NovaKing notifications@github.com\nwrote:\n\nThose links were for v2 which no longer apply as v4 is about to come out.\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/199#issuecomment-51740156\n. Some initial documentation is available for v4 at http://oauth2.thephpleague.com/\n\nI'm going to be finishing it over today. Tracking issue is #193 \n. I've just woken up in my timezone so to answer your questions, the\nmiddleware will be a single class with no additional dependencies required\nbecause anyone implementing it will already have pulled them in themselves.\nOn Fri, 20 Mar 2015 at 07:04 Hannes Van De Vreken notifications@github.com\nwrote:\n\nI would agree with you if it would be symfony or zend specific classes,\nbut StackPHP is meant to be used in any application. So it's optional but\nalso an invitation to use good app design.\nThis will be my last response, sorry, as I don't have more time to\ndiscuss. Have a nice day.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/200#issuecomment-83941052\n.\n. What's the dev dependency you're referring to? As I said implementing the middleware won't result\nin any new dependencies being added to the project\nOn Fri, 20 Mar 2015 at 07:08 Ivan Kurnosov notifications@github.com wrote:\njust a dev dependency.\nDev dependencies are not installed by default when a library is a\ndependency itself. I cannot see how it can be a pure dev dependency :-)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/200#issuecomment-83941347\n.\n. I agree. It'll be a separate package. But as that separate package doesn't exist yet I'm just tracking it in here.\n. Closing for now; v5 will include PSR7 middleware\n. Actually you can do this, I was being thick\n. Fixed in develop\n. Which version are you running?\u2014\nSent from my iPhone\n\nOn Fri, Aug 22, 2014 at 6:55 AM, Patrik Vormittag\nnotifications@github.com wrote:\n\nIs it possible for League\\OAuth2\\Server\\Resource to support HEAD requests? Testing with curl -I returns a 500 response (In my case, from a Laravel 4 app and Apache). Error details below.\nI'm using the library to secure a RESTful API, and supporting HEAD for content negotiation / caching on resources seems necessary. Has anyone else run into this issue or am I missing something?\nphp\nERROR: exception 'Symfony\\Component\\Debug\\Exception\\FatalErrorException' with message 'Call to undefined method League\\OAuth2\\Server\\Util\\Request::HEAD()' in /vendor/league/oauth2-server/src/League/OAuth2/Server/Resource.php:271\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/203\n. You'll have to modify it yourself I'm afraid or upgrade to v4 which uses Symfony request which should support HEAD\u2014\nSent from my iPhone\n\nOn Fri, Aug 22, 2014 at 1:53 PM, Patrik Vormittag\nnotifications@github.com wrote:\n\n2.1.3\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/203#issuecomment-53056518\n. Sorry @shadowhand. I've merged this.\n. Yep https://github.com/thephpleague/oauth2-server/releases/tag/3.2.4\n. Could you merge this against develop branch please?\n. Cheers. The cache directive was meant to be available for everyone but they've kept it Travis Pro only\n. I've got a really basic implementation based on a custom grant for now.\n\nI tend to only add things to the library myself when I'm using them\n. In version 4 of the library you just need to implement a custom token type (https://github.com/thephpleague/oauth2-server/tree/develop/src/TokenType) then call setTokenType on the server instance.\n. Also, sorry I don't have my implementation to hand\n. develop branch is v4\n. @patrickheeney at the moment no. I think JWT needs a lot more thought into how to properly implement it\n. v5 of this library will have built in JWT support\n. I've added an example of how JWT support will work here - https://github.com/thephpleague/oauth2-server/blob/v5/examples/public/jwt.php\n. V5 now issues JWT out of the box\n. The authorization code grant only allows the authorize parameters to be sent in the query string hence the explicit fetch from query.\nhttp://tools.ietf.org/html/rfc6749#section-4.1.1\n. Thanks @pulkitjalan \n. This used to be possible but I somehow missed it in v4 (now in develop branch).\n211 fixes this, I will merge once I've got a moment to review it\n. #176 is now merged so I'm closing this as fixed\n. It's an oversight. I will re-add it and update this issue when it's done\n. Fixed in develop\n. This will be solved with PSR-7 but for now I'm sticking with the Symfony version\n. Version 4 is now out so please make sure your branch is up to date :)\n. Could you not just do:\n``` php\ntry {\n   ResourceServer::hasScope('scope1');\n   ResourceServer::hasScope('scope2');\n} catch (...) {\n   // kick out here\n}\n// carry on doing whatever is happening under the knowledge that the access\n// token has either one of the scopes...\n```\n. Personally I'd rather stick to strict matching rather than adding an optional variation.\n. That is only for the authorization endpoint which is only used in the authorization code grant.\nThe client credentials grant hits up the token endpoint which is POST only\n. I'll take a look @lucadegasperi \n. Yes you are @johanobergman.\nSorry about the lack of update on this issue.\n. Fixed in develop :)\n. Thanks @johanobergman \n. V2 is old and deprecated, I'm not fixing it\n. Interesting point.\nI'm thinking the ResourceServer should return an access token entity instance which you can call getOwnerId() et all on there instead.\nSemantically thanks makes more sense\n. :+1: \n. The resource server doesn't know about the resource owner (that's application specific), but it does know about the authenticated access token and who owns that.\nThe resource owner and the authenticated user (through the access token) might not be the same.\nPerhaps resource server isn't the best name?\n. I've removed all the methods you mentioned and will demonstrate with documentation how to access them\n. Thanks!\n. Thanks!\n. Thank you, sorry I was away this past week\n. Thank you, sorry I was away this past week\n. Thank you\n. :+1: \n. Good find. Thanks!\n. I agree with @bandb42.\nCan you change it to ~2.5 and I will merge.\n. Fixed it myself :)\n. Thanks Graham :)\n. I've removed develop too\n. Cheers, what did tool did you use to generate these changes?\n. Nice, thanks\n. Thanks :)\n. So am I understanding this correctly:\n1. User signs into an email provider\n2. Email is then sent to the client app via an API\nAnd you want to secure the API communication at point 2?\n. Okay so if it's your own app with your users then you should use the following grants:\n- For communicating with the API with the gmail access token or the IMAP details: client_credentials\n- For communicating with the API once you have an Xmail user signed into the app: [resource owner] password grant\n. Sorry for not replying to this. Have you solved this issue? What was your solution?\n. It deliberately isn't in there at the moment because in my opinion it's very insecure and therefore it defeats the purpose of creating a \"secure by default\" library.\nI may add support via another package.\n\u2014\nSent from my iPhone\nOn Tue, Nov 11, 2014 at 9:43 AM, Leevi Graham notifications@github.com\nwrote:\n\nI couldn't find anything in the code to support Implict Grant Flow?\nhttps://tools.ietf.org/html/rfc6749#section-1.3.2\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/249\n. I've just blogged this http://alexbilbie.com/2014/11/oauth-and-javascript/\n. Ah my bad sorry @lucadegasperi \n. I've just blogged an answer here - http://alexbilbie.com/2014/11/oauth-and-javascript\n. Thanks, I forgot to update the examples stuff\n. The intention is to use the examples to do functional testing\n. Hey, you broke the a unit test - can you fix please https://travis-ci.org/thephpleague/oauth2-server/jobs/40803398\n. Classes that implement GrantTypeInterface can extend AbstractGrant which provide the functionality that you mention. I can't think of a cleaner way of doing it without requiring developers who are making their own grants to implement a load of additional functionality?\n. I've fixed this issue now. Thanks for pointing it out :smile: \n. Thanks :+1: \n. Closing this and #259 because the EntityTrait was a dumb idea that I shouldn't have implemented in the first place\n. You might have multiple redirect URIs for testing, staging and production. If you don't then yes, you can store it directly on the client table\u00a0\n\n\u2014\nSent from my iPhone\nOn Thu, Nov 20, 2014 at 12:50 PM, Ben Bridts notifications@github.com\nwrote:\n\nFrom RFC 6749 \n\n3.1.2.  Redirection Endpoint\n[..] The authorization server redirects the user-agent to the client's redirection endpoint previously established with the authorization server during the client registration process or when making the authorization request.\n [...]\n3.1.2.2. Registration Requirements\n[...]\n The authorization server MAY allow the client to register multiple\n  redirection endpoints\n [...]\n  Lack of a redirection URI registration requirement can enable an\n   attacker to use the authorization endpoint as an open redirector as\ndescribed in Section 10.15.\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/260#issuecomment-63803062\n. @lucadegasperi any ideas?\n. OAuth spec requirement as per https://tools.ietf.org/html/rfc6749#section-4.3.2\n. The correct flow should be a single session is created which the auth code is linked to, then when the auth code is revoked the access token should be linked to the same session.\n\n\nI will have a look into the issue with the Laravel bridge (I don't use Laravel myself). I will also update the docs too.\n. Thanks @Hywan \n. I need to spend some time re-doing the examples; they're a bit out of sync\n. That was my original plan :)\n\u2014\nSent from my iPhone\nOn Tue, Dec 2, 2014 at 11:03 AM, Ivan Enderlin notifications@github.com\nwrote:\n\n@alexbilbie Use them as functional tests also. Can be useful.\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/pull/269#issuecomment-65214317\n. You're quite right, will fix.\n\nThe error should be 403 though because re-authenticating won't make a difference - the refresh token is dead\n. This is fixed in 4.0.4 release\n. Hi @maknz,\nYou've raised some really good points. I'm going to have a think and try and work out a plan of action for you as this is evidently something I've over looked.\n. Nice spot, thanks!\n. OpenID Connect would be another grant type\n. :heart:\n. The unit tests are going to cover the examples, instead the plan is to write behavioural tests\n. Yep I'd clean up every so often with a scheduled maintenance cron task.\nOut of scope of this library though - some people (including a production system I've got at work) require them to be left for auditing purposes.\n\u2014\nSent from my iPhone\nOn Wed, Dec 10, 2014 at 11:09 PM, Regan notifications@github.com wrote:\n\nI'm wondering whether it would be expected to clean up old sessions from the storage? From that I can tell, if a refresh token passes its expiry date, it would be safe to remove the refresh token, the access token and their associated session since that session is not going to be reused (whereas if just the access token was expired, but the refresh token was valid, the same session would be used for the new access token and refresh token).\nIt probably won't have much of an impact, but I can imagine over time a lot of old data piling up so it'd probably be wise to have a clean up strategy.\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/279\n. Yep\n. Thanks\n. Could you please provide a bit more information?\n\nIn this implementation a database query will look for a row that matches a plain text token (using a WHERE) then the token will be validated to see if it has expired in the library code. The only string comparison that occurs is in the database query not in this library\n. I've sat and thought about this and I'm still unsure as to what to do for this library.\nUnlike in the example given in bshaffer/oauth2-server-php#480, there isn't a string comparison made in this library's codebase, all of the assertions on whether or not an object is an instance of an interface.\nThere might be however in a developer's implementation of the storage interfaces which they need to make to use with this library.\nIs my understanding correct?\n. I need to update what is in the examples/ folder so when I do that I will take into account your advice, and I will update the documentation to warn developers to take it into account when implementing the interfaces.\nI will also ensure the MAC and JWT implementations are protected when I get round to them.\nThank you!\n. Thanks for this @maknz \n. There is documentation with examples here http://oauth2.thephpleague.com and in the example/ folder\n. This is awesome, thanks.\nIt's going to take me some time to go through it - please bear with me :+1: \n. I've finished integrating this and I've decided it's going to form the basis of v5 of the codebase (because I'm introducing some very minor backwards compatibility breaks). It can be found in the new develop branch.\nI'm removing the OpenID stuff for now so that I can implement in a different way.\nThanks for your PR :+1: \n. I don't understand your approach to this.\nWhy not just have a rotateRefreshTokens boolean flag which will return a new refresh token (and expire the old one) if true, otherwise just return the old refresh token?\n. Looks good. Would you mind adding a unit test to cover the changes please?\n. You can still use the implicit grant with this library (it looks like you've already written a working implementation based on that PR). This library is designed to be extensible and I'm not going to remove those plugin points. I just don't want to have the implicit grant it in the core library (as explained in my response to your PR).\nI will merge this when I've got 5 minutes to finish going over it.\n. Thank you for your pull request.\nI have many issues with the implicit grant as a component of the OAuth spec; my principal objection is that it is the least secure grant because the access token is exposed in a public manner to the client.\nThis means that you either accept that others will be able to make their own methods of calling your API or you have to significantly reduce the allowed permissions/scopes of access tokens created with this grant so that others implementing their own clients to your API also have reduced functionality and therefore you're intentionally crippling the functionality of the intended client.\nI appreciate this sounds very doomsday but I think that it's only responsible that API owners, regardless as to whether or not they are building a publicaly consumable API, only allow access to their APIs from whitelisted clients.\nBecause of the aforementioned exposure of the access token in public during the implicit grant flow this significantly reduces the usefulness of whitelisting as anyone can fire off commands on their own using the exposed access token and your API wouldn't be any the wiser as to whom was sending those requests.\nI want this library to be \"secure out of the box\" as much as possible and therefore I feel adding implicit grant support would go against this goal.\nThank you again though for your contribution.\n. There's an examples folder in the repo and some more examples in the docs\u00a0\n\u2014\nSent from my iPhone\nOn Tue, Dec 30, 2014 at 11:12 PM, Austin notifications@github.com wrote:\n\nIs there any downloadable example for this version of the oauth2 server? I took a look bshaffer's example and I was so lost, I couldn't figure out what  was what and how to change things. I have been trying for a week now to utilize your version of the server and I can't figure out what I still need. I've looked around and can't find any good examples that don't use some third party extensive library. I'm just looking for a lightweight, deployment system to assist in helping people learn how to use the server. Any example would be nice, and before you refer  me to the docs website. I tried following it, and I must not know enough because I couldn't get anything to work. I have a feeling I am missing an .htaccess file with special configurations.\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/289\n. Have you definitely correctly implemented all of the required storage interfaces - http://oauth2.thephpleague.com/implementing-storage-interfaces/ ?\n. Thanks for this @sarciszewski \n. To confirm, what is the composer command you're using?\n. I've just done the following and it works for me:\n\nbash\nmkdir /tmp/oauth-test\ncd /tmp/oauth-test\ncomposer require league/oauth2-server\ntouch test.php\nThe contents of test.php are:\n```\n<?php\ninclude('vendor/autoload.php');\n$server = new \\League\\OAuth2\\Server\\AuthorizationServer;\n```\nRunning php test.php I get a code 0 exit which means execution was successful.\nI also tried loading a non-existent class and I got an error message as expected.\n. Can you explain a little more sorry\n. > I'm guessing the answer is it's up to me/my framework to decide what the $request variable contains just so long as it's a ParamterBag, correct?\nYep :)\n. I implemented the events subsystem for scenarios like this.\nWhen the session.owner event is fired, your listener can get the owner type and owner ID from the session. You can then implement your own logic to look up the users role and then call associateScope on the session entity for each scope you wish to assign.\n. Closing this for now. Please follow up if you have any more questions\n. Thanks for this.\nCould you do me a favour and resubmit against the master branch please?\n. Hi Vlad,\nThank you for your comments.\nRegarding the examples, the intention was to eventually provide multiple versions (hence why the current examples are in a folder called relational - i.e. relational database).\nI used Capsule simply for it's query builder and time. The library is purposely agnostic of the backend, as some developers aren't using relational databases at all, whereas for me I use a combination of MySQL + flat file arrays depending on what I want to do.\nI'm not sure what you mean by tokens repeating themselves - they should all be unique. The fact that you've been able to implement your structure as you have shows how flexible the library is so that it can be integrated as developers see fit into existing and new applications.\nRegarding your comment about PHP 5.3 - it's irresponsible to be trying to do security related activities with an out of date version of PHP which itself doesn't have security fixes anymore.\nAlex\n. Using the client credentials grant the access token will be a client, using password grant the owner of the access token will always be a user likewise for authorization code and implicit grants\n. Not a stupid question.\nSo the session is the core component that maintains a link between a user, a client and a token type. \nFor example in the authorisation code flow this is the initial setup:\n```\n                                                          +--------+   \n                                                          |        |   \n                                                          | Scopes |   \n                                                          |        |   \n                                                          +--------+     \n                                                           ^         \n                                                           |         \n                                                           |         \n                                                           +\n\n               +------+         +---------+         +------------+   \n               |      |         |         |         |            |   \n               | User | <-----+ | Session | +-----> | Auth token |   \n               |      |         |         |         |            |   \n               +------+         +---------+         +------------+\n\n                                    +                                \n                                    |                                \n                                    v\n\n                                +--------+                           \n                                |        |                           \n                                | Client |                           \n                                |        |                           \n                                +--------+\n\n```\nWhen the auth code is converted to an access token the scopes which were associated with the auth code are copied to the session as well as associated with the access token:\n```\n                                      +--------+             +--------+    \n                                      |        |             |        |    \n                                      | Scopes |             | Scopes |    \n                                      |        |             |        |    \n                                      +--------+             +--------+      \n                                       ^                     ^           \n                                       |                     |           \n                                       |                     |           \n                                       +                     +\n\n                 +------+         +---------+         +--------------+   \n                 |      |         |         |         |              |   \n                 | User | <-----+ | Session | +-----> | Access Token |   \n                 |      |         |         |         |              |   \n                 +------+         +---------+         +--------------+\n\n                                    |                         +          \n                              +-----+                         |          \n                              |                               |          \n                              v                               v\n\n                         +--------+                   +---------------+  \n                         |        |                   |               |  \n                         | Client |                   | Refresh Token |  \n                         |        |                   |               |  \n                         +--------+                   +---------------+\n\n```\nWe copy the scopes to the session as well as the access token because if we request a new access token using the refresh token, the new access token can have the same scopes as the original token or a reduced subset of the scopes.\nDoes that make sense?\n. > I see, thank you very much for the explanation! There's something wrong with my implementation, as I don't get the scopes copied over.\nYou probably haven't correctly implemented League\\OAuth2\\Server\\Storage\\SessionInterface:: associateScope\n\nPS. Couldn't the access token keep track also of the user and client, instead of the session? It seems a bit redundant, as both the session and the access token have the same scopes.\n\nAs I said, an access token created with a refresh token might have a subset of the scopes that the original access token. But another access token created later on might require all of the scopes again. You need to store the original set of scopes somewhere.\n. The scopes are associated here along with the access token scopes - https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L239-L245\nWhen the save() method is called on the session entity the scopes are saved in this call to the storage here - https://github.com/thephpleague/oauth2-server/blob/master/src/Entity/SessionEntity.php#L291-L307\n. You're quite right @vvllaadd.\nIt looks like #282 broke this and there's now a conflict.\n. I agree, I've opened #306 to track progress of this\n. I'm closing this, please discuss further in #306\n. I was intending on dealing with these issues later - not everyone is on your timezone or has infinite free time, give me a chance.\n. Thanks @hannesvdvreken \n. Thanks\n. You're suggestion is actually implemented in the develop branch :+1: \n. It's probably fallen behind (I've not had much time over the last month to work on the library, that should change now that craziness in my life is over) but most of the changes that are in master are minor and/or examples/docblock/docs improvements so merging master on develop should work reasonably well\n. Thank you @atrauzzi :smile: \n. I am busy but I'm actually sat doing some updates as I type this.\nOnly one grant uses auth codes so it'd be a mistake to base relations on those. I've got some ideas on a more elegant way of removing sessions.\n\u2014\nSent from my iPhone\nOn Sun, Feb 22, 2015 at 4:24 PM, Alexander Trauzzi\nnotifications@github.com wrote:\n\nI think @alexbilbie is fairly busy right now so I'm taking it upon myself to refactor this package.  Part of this refactor is going to be to remove the session concept.  It's going to take a bit as I'm cleaning up the injection and coupling in the library.\nTo that end, I think the end result is going to be that authorization tokens, refresh tokens and authorization codes are all going to have a relation to auth codes.  I'm just mentioning this here in case someone notices that I've missed something! ;)\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/306#issuecomment-75443245\n. Sessions are now going in V5\n. All gone :smile:\nOn Fri, 15 Jan 2016 at 21:01, DJ Tarazona notifications@github.com wrote:\n@alexbilbie https://github.com/alexbilbie gone* in V5? \ud83d\ude07\nKeep up the awesome work!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/306#issuecomment-172091536\n.\n. I agree and in my local out-of-sync copy I've actually already done this - I will merge with dev soon :+1: \n. No trouble at all, I'm just glad I'm helping people out with my code :grinning: \n. @m4tthumphrey yep it's coming in v5. I might be able to backport to v4 too\n. This is done in V5\n. See my comment here https://github.com/thephpleague/oauth2-server/issues/153#issuecomment-37722703.\n\nMy recommendation is to copy the password grant into a new file, remove the validation you don't want and then load it into the library as a custom grant.\n. Please bear with me, I'm exceedingly busy for at least the next few days.\nI will get to this.\n\u2014\nSent from my iPhone\nOn Tue, Feb 24, 2015 at 7:24 PM, Alexander Trauzzi\nnotifications@github.com wrote:\n\nHey @alexbilbie -- As promised, I've been working on a refactor.  Having looked at both yours and bshaffer's Oauth plugins, I figured there's an opportunity to make something a little more user friendly.\nI'd love your input before I go too much further and maybe to see if your'e interested in adopting these changes as a new foundation for oauth2-server.\nBefore getting into things, here are some notes to keep in mind..\n- It's not 100% PSR-2, but I've no probelms making it such for a merge.\n- I don't oppose testing, but I was more interested in just getting the refactor done.  So they're not in here, but of course tests can be remade or retooled for the new structure.\n- All examples have been removed as the touchpoints have changed.\n- Configuration is centralized to one value object that sports fluent setters.\n- I'm still debating whether there should be domain services.  There's already one for Scopes, if I accidentally left anything behind on the cutting room floor, it probably belongs in one. :)\n- Entities are now strictly interfaces with some optional traits available for non-storage-specific entity business logic.\n- I plan on making a comprehensive Laravel integration after I know where this refactor is going to live.\n  https://github.com/atrauzzi/oauth2-server/tree/cleanup\n  Regardless of what you decide, I'd really like to thank you for your work so far on this library.  Although I do hope you like what I've done enough to use it as a new starting point.\n\nReply to this email directly or view it on GitHub:\n  https://github.com/thephpleague/oauth2-server/issues/314\n. I've got a bit of time so I'm going to take a look at this now\n. I've done my best to read through the code and here is my feedback. Please don't take any of this personally, they're just my gut reactions.\n1. New terms such as \"flows\", \"contracts\" and \"oauthable\" are confusing and unnecessary.\n2. I don't understand where all this contract stuff has come from and why it can't be called an interface?\n3. The global config object doesn't sit right because you want to tweak properties of different entities (e.g. setting different access token TTLs for different grant types).\n4. Most of the changes seem to be renaming of methods and properties and just moving things around unnecessarily.\n\nThe problem with this project is that it got a bit too \"heavy\", it can be time consuming to implement all of the \"storage interfaces\" (which I agree should actually be called repository interfaces) and the actual execution path of going from CLIENT: here are my credentials to AUTH SERVER: here's an access token is too complex.\nWith the lack of readability of your code (whats with all the extra tab spacing?), no examples or explanations as to why things have changed I don't see anything at this moment that I want to pull in.\nIn my opinion the right direction is to go down a command and event driven model with lightweight, easy to implement repository interfaces.\nI do want to say thank you though for your interest in the project.\nAlex\n. Sorry for the lack of a reply and documentation.\nCan I recommend for now you look at the Client Credentials grant source code to see how the simplest grant is implemented, then add your own domain logic into that.\n. Agreed about using EntityTraits.\nThe hydrate method needs to die.\nI will push my dev version soon with a whole bunch of these changes included.\n. So v5 will have entity traits which implement all of the required methods for this library to work. Then you can use your own Doctine/Eloquent/whatever entities.\nErgo the hydrate method won't be necessary\n. I've just pushed an early version of version 5 of this library to the v5 branch.\nIn this version I type hint against entity interfaces and use traits. Note as of this moment only the client credentials grant is implemented.\n. This is now implemented in V5\n. All of the error messages are taken from the OAuth 2.0 specification.\nIf you can find a more appropriate error from the spec please let me know and I'll change if I agree, otherwise for now it's how it is.\n\u2014\nSent from my iPhone\nOn Wed, Mar 4, 2015 at 9:12 AM, mcd-php notifications@github.com wrote:\n\nSee: AuthCodeGrant.php#L219\nphp\n        // Ensure the auth code hasn't expired\n        if ($code->isExpired() === true) {\n            throw new Exception\\InvalidRequestException('code');\n        }\nObserved: No error reason in response, no reason in log: \n\nexception 'League\\OAuth2\\Server\\Exception\\InvalidRequestException' with message 'The request is missing a required parameter, includes an invalid parameter value,includes a parameter more than once, or is otherwise malformed. Check the \"code\" parameter.'\nAbsolutely clueless and misleading, have to look into the source.\nExpected: Helpful and immediately available error messages in logs and in response, not only in code comments:\nexception '...' with message 'The code has expired'\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/321\n. I agree. I'll have a look into what can be done add support for the error_description field\n. V5 now has much much improved error messages\n. I'm afraid not.\n\n\nYou should be able to covert what is in the documentation for CI reasonably easily.\n. Thanks :+1: \n. This should be opened on https://github.com/thephpleague/oauth2-client\n. @rdohms I will do that\n. @shadowhand I've pushed a whole load of fixes that address your comments.\nRegarding the container; my intention was to use the container to bootstrap all of the built in grants to reduce the amount of bootstrapping user land code required.\nI like constructor injection because then there are guarantees that the required dependencies have been set. With setter injection you need to verify that you have all of the required dependencies set before you can proceed.\nI'm not necessarily convinced by the container myself but if I didn't try it out I wouldn't know :smile: \n. Haha I actually fixed this myself the other day in the v5 branch. Cheers!\n. Thanks\n. As @robertpitt suggested when your storage class looks for an access token simply don't validate the access token's expiry. There's no need for the library to implement any additional logic.\nBut do consider his advice about security.\n. Version 5 of the app (currently in dev) has already started to address some of these concerns and has a much better structure.\nThe next step would be to use value objects instead of working directly with Symfony's request object to allow for easier interoperability with other implementations.\nSo yes I agree with your points and they should be addressed in v5.\n. I think I've now addressed these problems in V5\n. This is a limitation of your setup I'm afraid, it's not something this project or even PHP or Apache can solve\n. I'm really sorry the late reply on this. Did you solve this?\n. Please see #111 \nBasically, use the Authorization header to pass in the access token\n. It isn't going to be changed in this library. Extend the ResourceServer\nclass if you really want it or just use Authorization headers.\nOn Fri, 4 Sep 2015 at 11:17, Andrei Kun notifications@github.com wrote:\n\nIf you want to access secured paths using access_tokens as query string\ninformations below might help you:\nCheck here:\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/ResourceServer.php#L146\nIt shouldn't be $this->getRequest()->request->get($this->tokenKey).\nInstead it should be $this->getRequest()->get($this->tokenKey).\nThat;s why it does not work. I already adjusted my code, it would be nice\nif someone from phpleague will adjust too.\nIt works now with both POST and GET having access_token in query string\nlike ?access_token= mQ77AR4vzpTdn81Sc4os7FdRYWd3UJJjQ1GBJ3Us\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/340#issuecomment-137696626\n.\n. Sorry for the late reply to this. The reason is that the resource server requires these dependences, whereas the other auth server has different dependencies depending on the grants used.\n\nAs for the event system; you're right it isn't used currently. This will be cleaned up in v5\n. Sorry for the late reply; have you solved this? Please re-open if not\n. I'm way out of touch with what's been happening in the PHP world. How have other packages implemented this?\n. V5 is PSR compliant\n. Your server should clean up old access tokens. If an access token has expired then the user should approve permission again.\n. The implementation is up to you. If you want the same functionality then you need to simply store that a user has approved a client already and then re-issue a new access token with the same permissions as before.\n. I will take a look into this\n. Merged #369 \n. Hi @developernaren, sorry for the late reply I've been away on holiday.\nBoth the resource server example and the auth server example have examples of setting additional headers on the response object.\nI'm not familiar with Lumen, but why don't these examples work for you?\n. Would changing the line to if($this->getRequest()->headers->get('Authorization', null) !== null) fix it?\n. Closing as V5 implements differently\n. @rickshawhobo I've created a 4.1.x branch - if you make the change and PR against that branch I will merge and create a new 4.1.x tag\n. @cesutherland thanks for this.\nWhy did you remove the $session->associateClient($client); line?\n. Merging this for now so that at least the more reasonable time comparison is in place.\nRegarding nonce replay validation and checking time differences in subsequent requests that can implemented later on.\n. I'm not going to merge because I've got an alternative interface implementation which I want to use instead. But thank you for the contribution\n. I'll keep this in mind for v5\n. Because the latest MAC token draft has expired and significantly changed from the implementation in this project I've removed it for now. If the MAC spec is formalised I will take another look.\n. Can you please pull and push which will fix Travis and allow me to auto-merge?\n. Thanks @michaelhogg, sorry for the delay was away for a few days\n. The OAuth spec says that you can add your own arbitrary key pairs in the response which you can hardcore your own clients to use and other clients will ignore but as @dekker-m said, latency and time sync issues make it a tricky problem to solve\n. This is something that v5 will fix (i.e. get rid of the concept of sessions).\nPlease follow #306 \n. Are you binding the Laravel request into the server using $server->setRequest($request); ?\n. On your OAuth server instance bind the Laravel request into it before the server starts its validation as shown above. \nI'm not familiar with Laravel so I can't necessarily help you on where to exactly put this in your specific code base.\n. Please see #111 \n. As I said in #340 this library isn't going to implement what you want. My recommendation is you switch to Authorization headers.\n. Seems perfectly reasonable to me. Thanks :+1: \n. The OAuth 2.0 spec doesn't provide a method to detail what scopes have been granted - you'll need to come up with your own implementation of this.\n. Have you tried adding SetEnvIf Authorization \"(.*)\" HTTP_AUTHORIZATION=$1 into your .htaccess file?\n. One session can have multiple access tokens.\nI'm removing the concept of sessions in v5.\nI'm not providing a schema on the basis that this library can be used with non-relational storage systems\n. Scopes are sent as a string in the form scope1 scope2 scope3 etc. Note the space between each scope. Yes it's dumb but it's how the spec specifies it\n. Yep - when scopes are validated the client ID is passed in (see https://github.com/thephpleague/oauth2-server/blob/master/src/Storage/ScopeInterface.php). If the client shouldn't be able to access the scope then return null and the auth server will show an error to the cleint\n. You probably need to run composer install inside examples/relational first\n. I guess it should be at the storage layer but what sort of hashing are you proposing?\n. I'd definitely hash client secrets.\nAs for tokens the issue is you need to validate them. A client will send you a plaintext token which you need to validate; if they are stored bcrypt-hashed how do you now look them up in your database to verify them?\n. That won't work. With password hashing you search by the username to get the password hash and then do a hash compare to check the password is correct.\nWith your proposal you don't have anything other than the plaintext token to go by.\n``` php\n<?php\n$token = password_hash('my token', PASSWORD_BCRYPT);\nvar_dump($token); // string(60) \"$2y$10$aPRdl7LU3CNw3z.zXIBo3eN5qPEAxEoT7E6ajrclPvIhLu0nEDx3W\"\nvar_dump(password_hash('my token', PASSWORD_BCRYPT)); // string(60) \"$2y$10$b0bj7kkGPcPREMyZTcRPUeOetI/zcaL9wWHV9qQ81P.fCN3epatFa\"\n```\nUnless you use hashing algorithm that always produces the same output then you won't be able to perform a database lookup. But then you get into the same arguments about salting and hashing yourself and it's a mess.\n. A better strategy would be to only store short lived tokens so if they did escape they're only useful for an hour or so at most\n. Thanks @m4tthumphrey \n. I don't understand why you wouldn't want confidential clients?\n. But OAuth 2 is the latest standard...\nThis library has always tried to promote a secure by default implementation\nof OAuth 2 and I think it's irresponsible to support non-confidential\nclients.\nIf you want to support them then you can create your own variation of the\npassword grant very easily that supports your specific use case.\nOn Sat, 19 Dec 2015 at 21:25, whitefoxy notifications@github.com wrote:\n\n+1 Waiting for this merge\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/pull/391#issuecomment-166027710\n.\n. @heisian what is the updated standard? RFC6749 was published in October 2012\n. I've read through https://tools.ietf.org/html/rfc6819 and I will merge this PR but after I've updated the documentation as part of V5 launch which will better describe appropriate implementations depending on requirements of the authorization server\n. V5 now supports both public and confidential clients as of 3b36ae9000328ccba408b20752021cfbc51e7a6d\n. This logic can be created in the storage interface implementations. Will update docs to demonstrate this\n. Refresh tokens solve your problem\n. I will improve the documentation to make this clearer\n. Apologies, I have pushed 4.1.4\n. Number 3\n. I will merge this in when V5 is in a slightly more advanced state (won't be much longer, promise!)\n. You can find generic PHP documentation at the doc website and in the examples directory in the code base\n. Regarding your comment about exceptions - see http://rosstuck.com/formatting-exception-messages/\nI've not finished exceptions yet; I still need to finish how translations are going to work.\n\nIn terms of passing in a response, I'm not against this. Please see the comment though about the change you made to getClientEntity\n. Closing as I believe I've addressed this\n. The password grant needs to authenticate the client that is trying to acquire an access token with a user's credentials\n. https://tools.ietf.org/html/rfc6749#section-4.3.2\n\nIf the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n. Why?\n. Preferred by Github how?\n. Why?\n. As it's such a barebones phpunit.xml file in the first place I'm not against others adding to it in a PR if they have useful improvements\n. The change was made in v4 from what is currently in v5 and I haven't\nupdated it again in v5. See discussion in #364\n\nOn Fri, 4 Dec 2015 at 01:38, Ivan Kurnosov notifications@github.com wrote:\n\nIn v4.1.x it's implemented as\nif (abs($params->get('ts') - time()) > 300) {\nand in WIP-5 it's\nif ((int) $params->get('ts') !== time()) {\nwhich looks a bit extreme and unlikely to pass ever.\nIs it a deliberate change?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/410.\n. @mikepmtl for now please follow @dav-m85's advice. Will consider this for new documentation\n. Whilst it pains me as an Englishman to use American spelling; the OAuth spec uses Z's instead of S's I will fix this :stuck_out_tongue: \n\nGood spot, thanks!\n. I've tagged and pushed 4.1.5 which should resolve this\n. You need to implement the logic for this yourself. It's outside the scope\nof this library.\nOn Tue, 5 Jan 2016 at 23:14, aluferraz notifications@github.com wrote:\n\nHi,\nIs it possible to kick out all sessions and remove all access/refresh\ntokens using your library ? I'm using the password grant type and I need to\nlogout the user if he changes his password..\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/416.\n. Implemented in v5\n. Will do. At the pace I'm going at (have found myself with a lot more time this side of Christmas) I reckon another week.\n\nIf my plan works out then implementations will only need one DB table for token storage + optional tables if you want DB driven scopes + clients :smile: \n. So the plan is to get a release candidate with new docs out in the next few\ndays. I'm then away from the 25th of March for two weeks without access to\na computer. When I'm back any outstanding issues will be resolved and V5\nwill formally be released.\nThanks for your patience everyone; it's been a long time coming but we're\non the final straight now and I really do think this is the best\nimplementation to date.\nOn Sat, 19 Mar 2016 at 12:37, Frederik Bosch notifications@github.com\nwrote:\n\n@alexbilbie https://github.com/alexbilbie Would you mind releasing a\nfirst alpha of version 5? Or do you have other plans on releasing?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/pull/420#issuecomment-198695093\n.  :tada: :tada: :tada: :tada: :tada: I've tagged and published 5.0.0-RC1 :tada: :tada: :tada: :tada: :tada:\n\nI'd like to thank everyone for supporting me this far.\nI'm away for two weeks from tomorrow which gives plenty of time for people to try it out. V5 is very stable, has a full suite of tests and working examples. \nI've completely rewritten all of the documentation too - http://oauth2.thephpleague.com/ - every page even has content, not a @todo in sight :stuck_out_tongue:\nI'm going to have limited access to emails over the next few weeks but please feel free to open issues and PRs and I will review as soon as I'm home :+1: \n. Version 5 has now been released!\nThank you to everyone for your support!\n. Thanks @juliangut\n. Thanks @juliangut, will fix the immutability issues highlighted by @andersonamuller \n. :+1: \n. Bear with me a moment, my next push is going to break some of this\n. @juliangut I've done a big push which has caused conflicts on this PR\n. It's expected to be space delimited.\nSection 3.3:\n\nThe value of the scope parameter is expressed as a list of space-\n   delimited, case-sensitive strings.  The strings are defined by the\n   authorization server.  If the value contains multiple space-delimited\n   strings, their order does not matter, and each string adds an\n   additional access range to the requested scope.\n. Are you referring to DefaultAlgorithm ?\n\nIf so, is random_bytes considered more secure than openssl_random_pseudo_bytes now?\n. :+1: I'll make the changes now\n. I've implemented the random_bytes change you suggested\n. Please send a PR to fix for V4 of this library (master), have fixed in V5 660378c7b35e03a7c0b82394fd7d333f1e9eb23d \n. fixed by #429\n. In v5 of this library access tokens will be JWTs now, and refresh tokens will be encrypted payloads so they're going to get a lot longer (~200 characters).\nWhy do you want to limit token length?\n. What's the benefit?\n. Cheers!\n. RedirectUri is also used by the authorization code grant which I've not yet pushed\n. Will bear this in mind as I work on auth code\n. :+1: awesome stuff\n. How does this work if the key has a password?\n. @juliangut if you can fix that one issue highlighted above will happily merge,  thanks :+1: \n. I agree\n. @juliangut sorry for the delay on this; when you get a chance could you make Git happy so I can merge this please?\n. This is the problem I keep hitting up against; different grants have different requirements :stuck_out_tongue_closed_eyes:. The auth code grant is such an ugly beast to try and retrofit into an otherwise nice API.\n. That implementation is very very old and out of date.\nI believe MySQL and MSSQL are reasonably compatible though so your queries should still work\n. Can you clarify your question?\n. How will the user be redirected back to the client if there isn't a\nredirect URI?\nOn Mon, 25 Jan 2016 at 14:41, David Steinsland notifications@github.com\nwrote:\n\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L119-L122\nredirect_uri is optional in spec.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/439#issuecomment-174526306\n.\n. No, the redirect_uri should be pre-registered (i.e. whitelisted) with the auth server. Facebook and others have fallen prey to attacks multiple times because they weren't requiring whitelisted redirect uris\n. Sorry when you said client storage I thought you were referring to javascript client storage and was going down completely the wrong trail of thought.\n\nI understand now. I do apologise. I will re-open this ticket and address it soon.\n. I've implemented this in v5 now\n. Did you solve this?\n. It's certainly something I want to look into. I don't have anything more to say about it at the moment though.\n. Can you point me in the direction of any large services who are providing a standards complaint implementation of OpenID Connect?\n. I had a look through the specs a few years back when they were ratified. Once I've got v5 finished I will certainly take a look again.\n. Yes; OpenID Connect will be in v5.1.0\n. Just a quick update to say that I have started working on this feature; I created https://github.com/thephpleague/openid-connect-claims last week to implement the ID token claim set.\nThere's still some more work to do yet but I will keep this ticket updated.\n. Please can you point me to the tutorial you're referring to?\n. That post is really very old. Please follow the docs here instead http://oauth2.thephpleague.com/\n. I've just pushed a big set of changes which have caused a conflict here\n. Could you please merge from HEAD and update the associated test?\n. Have never heard of it before now. Have added a .styleci.yml and got it set up. Cheers :+1: \n. @zstergios you need to clone the repository manually due to the .gitattributes file\n. I've used Slim 3 for the work-in-progress V5 branch. Otherwise no but reading through the examples and the documentation you should find it relatively easy to translate to Slim\n. By working with the request object directly the library can better follow the OAuth 2.0 specification in terms of validating each request parameter.\nReturning a response object likewise ensures that the correct headers and body are sent back to the client.\nBoth of the above also means the server can be used as a PSR7 middleware layer\n. Out of interest what would you use the \"core\" package for that the current implementation doesn't provide or doesn't fit your specific needs?\n. I understand what you are saying but OAuth is intrinsically an HTTP protocol and so this library has always handled the HTTP too. V5 uses the standardised PSR7 and versions before that Symfony HTTP Foundation.\nI don't envision this library handling OAuth in other scenarios such as XMPP or IMAP so I'm comfortable and happy with it's current approach.\nIf you can output your own request objects in a PSR7 compatible format then you can easily add a translation middleware in front of this library, likewise you could have a translation layer from a PSR7 response object to your own response type.\n. I use Zend/Diactorus for PSR7 requests and responses\nOn Sun, 29 May 2016 at 16:08, Stefano D. Mtangoo notifications@github.com\nwrote:\n\n@alexbilbie https://github.com/alexbilbie dropping Httpfoundation for\nPSR7 was good except I cannot find standalone libraries yet for PSR7. So\nwhats alternative library for those of us who want to use your library and\ndon't want to be hooked to any framework (infact I have home grown\n\"framework\").\nAm currently using http foundation but will be happy to move to any decent\nphp Request/Response PSR7 library\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/455#issuecomment-222362539,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAEwp9dMzzr5oT1RczEMNcCOfbuToJ71ks5qGZ3wgaJpZM4HgohU\n.\n. Yep the Symfony bridge is the way to go. Can't offer any advice as I've not\nused it but it's an officially supported Symfony package so they will be\nable to advise and help\nOn Mon, 30 May 2016 at 18:26, Stefano D. Mtangoo notifications@github.com\nwrote:\n@alexbilbie https://github.com/alexbilbie Am sorry for asking something\nunrelated to Oauth but confuses me.\nI use Zend/Diactorus for PSR7 requests and responses\nI have checked it out and see it implements the PSR7 fine but it is\nlacking a lot of methods compared to symfony's component. That is fine\nsince its goal isn't that. Can you advise a way to use both symfony's\nhttpfoundation and Diactorus when using your library?\nWould you recommend using something like Http Message Bridge\nhttp://symfony.com/doc/current/cookbook/psr7.html what warning if any\nwould you give someone who decided to use this one?\nThanks in advance!\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/455#issuecomment-222531171,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAEwpzPJeRReonAU_OMCLvzf-SApruEwks5qGx3LgaJpZM4HgohU\n.\n. This is awesome; thank you!\n\nI will have a good look at it shortly\n. Agreed. Have fixed\n. Thanks @juliangut \n. Cheers for the PR!\n. @juliangut can you pull from upstream which should resolve merge + test errors\n. My thinking is that the authorization server signs things with it's private key.\nThe resource server and anything else that needs to validate access tokens can use the public key to verify the integrity of the token.\n. @juliangut I've implemented this manually along with #473 but predominately used your code. Thanks again!\n. Fixed by #472 \n. I will add this information to the documentation\n. I like all of this. Thanks!\n. The library actually uses Diactoros internally currently so I will need to do some refactoring first before I can remove the dependency\n. @frederikbosch it won't take me too long to do it, thanks for the offer though\n. Hmm having had a look at this it's going to require a lot more refactoring than I expected.\nThe problem (as ever) is the auth code grant which generates HTML, JSON and redirect responses. It also uses Diactoros' Psr\\Http\\Message\\UriInterface implementation.\n. Also the OAuthServerException class uses UriInterface\n. The composer.json is specifying \"zendframework/zend-diactoros\": \"^1.1\" which will anything >= 1.1 && <2.0 so this won't lock anyone to an absolute version of the library.\nI'm thinking for the sake of getting v5 out of the door to resolve this in v5.1 if there is demand for it\n. I can solve the PSR-7 Request and Responses more easily than the UriInterface\n. This is resolved \n. Thank you so much @juliangut. I got a bit overwhelmed with stuff yesterday and didn't get a chance to fix all of the broken tests\n. Fixed via #483\n. I don't believe anything other than the authorization server should have the private key because the key holder is able to generate valid tokens\n. I'm closing this for now because I don't believe this is an issue with how the library has implemented encryption (i.e. use private key to encrypt, public key to verify)\n. I agree with your proposed changes.\nCould you please pull from HEAD so I can merge.\n. I'm not sure about this. The advantage of checking that the response is an implementation of an interface is that anything other than an implementation will result in a failure.\nAsking client implementations to throw library specific exceptions seems like more of a barrier for implementers in my opinion.\nAm open to other peoples' opinions though\n. It is correct; if you don't provide a hint it will set one for you\n. I fixed an instance I found a short while ago https://github.com/thephpleague/oauth2-server/commit/b1cf6a8436ac29e490d560987827cf63e7304556\n. The current code is incorrect :smile: \nWill fix. Thanks for finding the issue\n. Where are they persisted the first time?\n. Great spot. Thanks!\n. I've fixed the 404\nSorry about that\n. Hi,\nThanks for getting in touch. I'm away until the 8th April, but will get\nback to you as soon as I'm home.\nPlease could you flesh out this issue as much as you can so I can think\nabout it whilst I'm travelling and can better answer you when I'm back?\nThanks,\nAlex\nOn Sun, 27 Mar 2016 at 21:37, Bobselp notifications@github.com wrote:\n\nHey,\nI tried to switch to the new V5-RC1. The client credentials grant works\nfine, however I have an issue with the authentication code grant.\nIn my opinion, AuthCodeGrant->respondToAuthorizationRequest() tries to do\ntoo much in a single function, and even stuff that in my opinion don't\nbelong in the oauth-server code: Logging the user in via a web-based form.\nEvery page that has users already has a login form, maybe integrated on the\npage. The current flow forces you to create yet another login form, or to\nmake your current login form & template work with the way required by the\noauth-server code.\nI would propose that if no templateRenderer is provided to\nAuthCodeGrant::_construct, respondToAuthorizationRequest() returns at\naround line 90 of AuthCodeGrant.php. It is then up to the developer to\nmake the login & app validation functions and assemble a UserEntity.\nLines 193-226 (after the validation part in the server-code) get moved to\nan own function that can be called with the UserEntity to generate the URL\nto redirect to after the (custom) login stuff validated the user.\nThis kind of resembles the flow of V4, where you could call\ncheckAuthorizeParams(), do the validation, and then call\nnewAuthorizeRequest() with the user ID to generate the redirect URI with\nthe redirect URI.\nThis is only a rough proposal, there certainly is a better way to solve\nthis. I hope you understand the problem I have with the code that tries to\nre-do what every website already has! :)\nOther than that, congratulations to V5, besides this it really looks\nawesome so far!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/499\n. As soon as I'm home this weekend I will review all PRs and open issues :)\nOn Tue, 5 Apr 2016 at 05:48, Frederik Bosch notifications@github.com\nwrote:\n@warlock39 https://github.com/warlock39 Wonderful feedback:\nconstructive and critic. While some points were not part of the PR to\nsolve, I will take 'em into account during update. Majority is valid and\nwill be taken care of. Thanks again. Hope @alexbilbie\nhttps://github.com/alexbilbie will consider to merge.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/499#issuecomment-205489719\n. I agree; AuthCodeGrant->respondToAuthorizationRequest() does way too much and the whole templating thing adds additional bloat.\n\nI've got a work in progress solution that I've come up with in another branch; will post a link here when I'm done\n. I've added some new methods to the auth server and grants.\nPlease check out this example of the API for the auth code (I've not yet updated the implicit grant) - https://github.com/thephpleague/oauth2-server/blob/V5-authorization-request-flow/examples/public/auth_code.php#L61-L86\nIn my opinion this solves a number of problems:\n1. Removes the requirement for the library to implement any templating for user login and authorization\n2. If the user is already signed in, has already authorised the client or you want to auto-authorise the client then this new flow makes all of that possible\n3. The library is dramatically simplified which I am all for\n4. This implementation also solves #514 \nWhat do you think @warlock39 @Bobselp @frederikbosch ?\n. I've decided to merge that branch in; I really like and prefer the new implementation.\nI'm closing this issue now. Am going to cut an RC2 tag shortly\n. Hi,\nThanks for getting in touch. I'm away until the 8th April, but will get\nback to you as soon as I'm home.\nPlease could you flesh out this issue as much as you can so I can think\nabout it whilst I'm travelling and can better answer you when I'm back?\nThanks,\nAlex\nOn Mon, 28 Mar 2016 at 08:06, Tigran Gabrielyan notifications@github.com\nwrote:\n\nI am using Doctrine to persist tokens with an entity that implements\nAccessTokenEntityInterface.\nI have to create a new doctrine entity in persistNewAccessToken() and use\nsetters/getters to copy over values from AccessTokenEntity that is passed\nand my doctrine entity in order for doctrine to work.\nHow does adding the ability to configure the class that is instantiated in\nissueAccessToken, issueRefreshToken, and issueAuthCode before its passed\nto persist function sound?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/500\n. I believe this has now been resolved by #512 \n. Awesome stuff\n. Fixed by 4eee48c\n. :+1: \n\nWill merge this in once I've tagged RC2\n. Hi Adam,\nThe JWT access token can be stored either in a cookie or with JavaScript\nusing client local storage. The JWT is signed with the auth server's\nprivate API key so it can't be tampered with.\nThe refresh token as you suggest can be used to get a new access token when\nthe old one expires. You just need to enable the refresh token grant on the\nauth server alongside the password grant.\nIf you explode the JWT token on the . character, then base64 decode the\nsecond (of three) array items, then JSON decode that string you can see the\nexpiry time (unix timestamp) of the access token so you can pre-emptily\nrefresh it.\nThe site http://jwt.io is quite useful for inspecting JWT tokens.\nI hope that helps,\nAlex\nOn Thu, 31 Mar 2016 at 04:34, Adam McCann notifications@github.com wrote:\n\nHello! I'm using the version 5 RC1 of the lib and am integrating it with a\nLaravel web app. I realise there is a laravel project using this lib, but\nam doing this manually as I want control over my storage.\nI'm using the Password grant type as I have an app with users that sits on\ntop of an API. The app is a client of the API. Users login via the app\nwhich sends the request for an access token with the app client credentials\nto the APIs auth endpoint. If verified, the app gets an access token (in\nthe form of a JWT).\n2 primary questions:\n- How do you think I should maintain user sessions between page\n  requests? Looking at JWT, it contains key info, so I'm thinking maintaining\n  the state on the server side (like a traditional session-system) might not\n  be necessary (if the JWT is stored in a cookie)?\n- Despite using the Password grant i'm still given a RefreshToken on\n  successful authentication. Does this mean I don't need to implement the\n  RefreshToken grant to make use of its functionality? Or do I need to\n  initialise that grant too in order to make the RefreshToken request?\nBy the way, my understanding is that RefreshToken exists to e.g. prevent\napp users from needing to re-authenticate - is that a fair approximation?\nRather new to OAuth in general so any help would be appreciated.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/506\n. Have merged your PR; thanks!\n. Are you using v4 or v5 of the library?\n\nEither way refreshing an access token results in a new access token and\nrefresh token off the top of my head.\nOn Thu, 31 Mar 2016 at 19:45, Sajuna Fernando notifications@github.com\nwrote:\n\nHi,\nI have a question about using the refresh token grant.\nI want my refresh tokens to be long lived and without any rotation so i\nhave setup it up like below.\n$refreshTokenGrant = new League\\OAuth2\\Server\\Grant\\RefreshTokenGrant();\n$refreshTokenGrant->setRefreshTokenTTL(7776000);\n$refreshTokenGrant->setRefreshTokenRotation(false);\nI then try to obtain a new access_token using this refresh_token. It works\nand gives me back a new access_token. However, its does NOT link this new\naccess_token against the old refresh_token. The refresh_token is still\nlinked to the old access_token which is now deleted after the new\naccess_token is issued.\nHaving a look at the completeFlow() on the\nLeague\\OAuth2\\Server\\Grant\\RefreshTokenGrant i cant see any attempt to\nupdate the refresh_token when the rotation is turned off.\nIs this a bug?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/508\n. There might be a bug there.\n\nI'm afraid I'm travelling in Asia without a computer for another week so I\ncan't debug at the moment. No one else has reported a similar bug as far as\nI can recall.\nIf you find a solution please let me know back here and I will take action\nwhen I'm home.\nOn Sun, 3 Apr 2016 at 02:46, Sajuna Fernando notifications@github.com\nwrote:\n\n@alexbilbie https://github.com/alexbilbie Im using the v4 (have not\nupdated to the v5 as of yet).\nIt should not result in a new refresh token if 'shouldRotateRefreshTokens'\nis set to false i thought?\nOtherwise i do not see the point in having a long lived refresh token i'm\nafraid, if the refresh token too gets renewed every time.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/508#issuecomment-204764954\n. Thanks, will review and merge when I'm back from travels :+1:\n. Hmm there is a dependency on paragonie/random_compat which has a backwards compatible implementation of random_bytes.\n\nI'm currently travelling and don't have access to a computer to investigate; if you do solve this please let me know so I can ensure any fixes are in the final build\n. The getRedirectUri method on the client entity could return a string or an array of strings?\nIf an array is returned the auth server could call in_array?\n. This is fixed as of 8274c56\n. @frederikbosch if you haven't already could you please update the relevant examples so I can get a better idea of how the final API looks? I'm hoping to be able to review all of the open PRs and issues over the weekend\n. @frederikbosch is there any way this can be split up into smaller PRs please? This PR is changing way too much for me to try and get my head around all of it\n. Good spot. This will be an easy fix; the auth code can contain a boolean flag to determine if a redirect uri was used.\n. This has been fixed for RC2\n. Great spot!\nThanks\n. Hi @msimkunas,\nThe cookie stuff from RC1 was very much a hack and shouldn't be relied on going forward. As discussed in #499; it's better than the developer working with the library implement session stuff rather than this library try and work with it.\n. > Do you mean that using encrypted cookies for storing request details is a bad idea in general or simply that it shouldn't be part of this library?\nIt shouldn't be part of this library\n\nI\u2019m considering switching to a database-based authorization request persistence (i.e. storing the authorization request details such as the user ID in a database row and assigning a unique random ID to it which could be later stored in a cookie). What would you recommend?\n\nWhen you say storing authorisation request persistence what do you mean by this exactly? That the user has already approved a client?\n. Ah right.\nMy recommendation is that you completely disregard the implementation from RC1. The bundling into the library of the authentication and authorising HTML pages with templating tied together with the encrypted cookie was a big hack because I was trying to provide what I thought was a simple solution but ultimately it added a huge amount of technical debt to the library.\nAs a result the oauth_authorize_request cookie has gone, it means nothing to the library.\nYou're free to use any sort of session/cookie management you want to track users as they travel through the authentication and authorisation screens.\nDoes that help you out?\n. There are a few small internal fixes merged in but otherwise for the rest\nof this week I intend on improving documentation and testing.\nAt this point I'm feel fairly confident to say that there won't be anymore\ndeveloper API changes to version 5.\nOn Tue, 12 Apr 2016 at 17:20 Mantas \u0160imk\u016bnas notifications@github.com\nwrote:\n\nI was wondering whether this library would receive more major refactors\nuntil a stable v5 is released? The jump from RC1 to RC2 required me to\nperform quite a big refactoring on my project and I would be interested to\nknow about any plans regarding the schedule of the next stable release.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/541#issuecomment-208988476\n. Confirmed not vulnerable\n. The refresh token can be decrypted with the authorisation server's public key using thedecrypt method on CryptTrait \n. This has been fixed in #537 (after RC2 tag was cut).\n\nWhich example is broken?\n. This should work for you\nphp\n$grant = new \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant($refreshTokenRepository);\n$grant->setRefreshTokenTTL(new \\DateInterval('P2W')); // refresh token TTL\n$server->enableGrantType(\n    $grant,\n    new \\DateInterval('P2W') // access token TTL\n);\n. I've improved the example in 88b01b7\n. Could you give some examples please?\n. It was probably over sight many moons ago (a quick glance most were put in December 2013).\nAs I intend to release V5 imminently I'm not going to release a patch fix as they're not doing any harm.\nThanks for pointing them out though.\n. Thanks\n. Thanks!\n. You're right, you've found a bug.\nThe easiest way I can think of resolving this is introducing a 4th parameter on the getClientEntity method on the ClientRepositoryInterface. This parameter would be a boolean $mustValidateSecret.\nWhen $mustValidateSecret === true the client repository must attempt to validate the secret if the client is confidential.\nFor the authorisation and implicit grants, when validating the client as part of the authorisation request $mustValidateSecret will be false. For the other grants it will be true.\n(cc/ @assembledadam; I believe you've also found this bug)\n. I've released 5.0.1 which addresses the issue here.\n. Thanks \ud83d\ude03 \n. You can implement all of this in the finalizeScopes method of the ScopeRepositoryInterface.\nThis method is called right before an access token or authorization code is created.\nGiven a client, grant type and optional user identifier validate the set of scopes requested are valid and optionally append additional scopes or remove requested scopes.\nThis method is useful for integrating with your own app\u2019s permissions system.\nYou must return an array of ScopeEntityInterface instances; either the original scopes or an updated set.\nI hope that helps?\n. It's probably best to open a Github issue on that Laravel repo as I don't have any involvement with it.\nGoing back to your original question though overriding the grant is a valid solution\n. Thanks, I agree with this change. I'm going to merge it in for version 5.1.0\n. I've reverted this PR for now. A more backwards compatible method of needs to be found.\n. This library has been developed so that you can use any type of backend storage; relational, document, key value, columnar or even hardcoded.\nThe documentation for each of the repository interfaces describes what sort of data you might want to store not how to store it.\n. Yes, the library supports JWT tokens out of the box\n. My apologies I misunderstood.\nThe library doesn't currently support that grant but having read through the RFC it looks fairly simple to implement.\nIt looks like there are two units of work:\n1) Implement client authentication using client assertions\n2) Support the JWT Bearer Grant Type.\nI've opened ticket #556 to track client auth, and I will re-open this ticket to track the grant type\n. All of the interfaces are documented here https://oauth2.thephpleague.com (at the bottom on the left).\nThe Slim framework example is purely for demonstration, there's no requirement for you to use it\n. The ServerRequestInterface and ResponseInterface are PSR-7 implementations provided by your HTTP library. Most frameworks (Symfony, Laravel, Slim, Zend) as well as many libraries generate PSR-7 request and responses and it is these that the AuthorizationServer is expecting to be injecting in.\n. These setter methods originally existed but were removed in #490 after some discussion in another issue that really these methods weren't used by the library and were really the responsibility of implementations\n. Thanks for your contribution though\n. Which version are you using? There was an issue resolved with non-expiring\ntokens in RC1 which was resolved in RC2.\nCan you provide any example code to demonstrate?\nOn Tue, 26 Apr 2016 at 17:13, carlosmojopicon notifications@github.com\nwrote:\n\nI'm successfully doing client grants and getting access tokens back.\nTokens are generated with 10 seconds TTL for test purposes.\nThe problem comes when I use generated tokens to do authenticated calls.\nEverything works fine, but tokens are never expiring. It responds with\naccess_denied if I pass a fake token which is ok, but if I use a valid one\nit always pass the validation even if it's expired. Am I missing something?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/559\n. Sorry I realised the getNewToken method wasn't documented here https://oauth2.thephpleague.com/access-token-repository-interface/; I've corrected that now \n. Thanks @luke83. These parameters shouldn't have been sent as they're handled by the parent method\n. Thanks\n. Thanks @carlosmojopicon \n. Thanks for your PR.\n\nI'm wondering if these constants could be added to the RequestEvent class instead?\n. I think having the constants in the RequestEvent class is better; no need to introduce a brand new class into the library\n. Thank you!\n. A good question!\nA missing access token and an improperly signed token would be caught here and therefore it shouldn't be possible for the scenario you suggested to happen.\nI hope that helps :)\n. Security of the actual server is out of scope of this library. I will add\nto the docs that it's probably a good idea to rotate keys every so often\nOn Sat, 30 Apr 2016 at 13:26, Luk\u00e1\u0161 Unger notifications@github.com wrote:\n\nSuppose the attacker gets hold of a server's private key..\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/565#issuecomment-215960422\n. In direct answer to your question when the user changes their password you should just expire all of their access tokens in your database so that when an access token is used this method https://github.com/thephpleague/oauth2-server/blob/master/src/Repositories/AccessTokenRepositoryInterface.php#L40-L47 returns true.\n\nI would strongly question though whether or not this is the right thing to do in terms of user experience. If I changed my password on Twitter and I had to re-sign into every Twitter app on my computer, tablet and phone I'd be really annoyed.\nOAuth is about authorization not about authentication - i.e. the user has given their permission for a client to access data on their behalf. The fact that their password has changed should not mean that their permission to clients has changed\n. If the user has changed their password of their own free-will then just change their password. Leave their access tokens alone.\nIf the user is resetting their password because their account has been compromised then it may be a good idea to revoke their access tokens.\n. If you are persisting the tokens in a database of some sort then you can invalidate them in there, so that when a token is used the method here returns true to indicate that the token is revoked.\n. I can't recreate this.\n``` php\n$response = $response->withHeader('Access-Control-Allow-Origin', '*');\ntry {\n    return $server->respondToAccessTokenRequest($request, $response);\n} catch (OAuthServerException $exception) {\n    return $exception->generateHttpResponse($response);\n}\n```\nIf I force the server to throw an exception I see the following headers returned:\nHTTP/1.1 401 Unauthorized\nHost: localhost:4444\nConnection: close\nX-Powered-By: PHP/7.0.5\nContent-type: application/json\nAccess-Control-Allow-Origin: *\nWWW-Authenticate: Basic realm=\"OAuth\"\nContent-Length: 67\nDo you have a working example of the problem?\nThanks\n. Hi @mariopacio,\nIf you're still having issues with this please re-open this ticket.\n. Sorry for the late reply on this; how are you implementing the jsonSerialize on your ScopeEntityInterface implementation?\n. Glad to hear you've resolved it \ud83d\udc4d \n. This also needs applying to the Implicit Grant too\n. Thanks; I will review this as soon as I get a chance\n. Looks good!\n. Hi Bob,\nSo your auth server (i.e. the implementation of this library) will issue access tokens (specifically JWTs signed using the auth server's private key).\nThe API clients then use the access tokens as authorisation when calling your other APIs.\nEach of those APIs implement the resource server middleware that you linked to in your question. When the access token in the request is parsed by the middleware a few things will happen:\n1. The middleware will check the access token is signed by the Auth server's public key\n2. The middleware will then check the access token hasn't expired\n3. Finally the isAccessTokenRevoked method on AccessTokenRepositoryInterface (that was passed into the ResourceServer class when you initialised it) will be called to verify the access token hasn't been revoked since it was issued.\nIf the access token is valid the following attributes will be set on the HTTP request that was passed into the middleware:\n- oauth_access_token_id - the access token identifier\n- oauth_client_id - the client identifier\n- oauth_user_id - the user identifier represented by the access token\n- oauth_scopes - an array of string scope identifiers\nIf the authorization is invalid an instance of OAuthServerException::accessDenied will be thrown.\nDoes that answer your question?\n. > You say that API1, API2 and API3 will implement the Resource Server middleware, but that means that they need to load this library as well in the 3 API's?\nCurrently yes; but it isn't that big... \ud83d\ude04 \n\nAnd they need access to the same database as the Auth server as well?\n\nNot necessarily; you could set up a private API on your auth server that can be called in the isAccessTokenRevoked method to verify this. Alternatively you could always return false (i.e. the access token has not been revoked) if you don't anticipate needing to revoke access tokens. Or you could set up a database user that only has permission to read from the specific table where access tokens are stored.\nThere is an RFC called \"OAuth 2.0 Token Introspection\" which \"allows a resource server to query an OAuth 2.0 authorization server to determine the active state of an OAuth 2.0 token and to determine meta-information about this token\", but I've not yet had a chance to evaluate it and implement it in this library.\n. Can you open a Github issue please; it gives me something to link to if people ask similar questions\n. Have you followed the docs here https://oauth2.thephpleague.com/authorization-server/client-credentials-grant/ ?\n. Public and private keys are required.\nYou should store them outside the web root on your server\n. It is best practise to implement the interfaces as individual classes.\nYou database interaction takes place inside the methods of those classes.\n. You do this inside the relevant interface method; so for clients retrieve them from the database in this method https://oauth2.thephpleague.com/client-repository-interface/\n. > Can a normal mysql call replace this?\nyes\n. You've found a mistake in the docs; please could you change it to:\n\"If the user approves the client they will be redirected from the authorisation server to the client's redirect URI with the following parameters in the query string:\"\nThanks\n. Yes, once the user has authorised the client they are redirect back to the client with the authorisation code which is exchanged for an access token. Your PR is correct\n. Are you url_decode-ing the auth code first before sending?\n. url_decode the code parameter before sending it the authorisation server to get an access token\n. I will update the documentation to make it clearer\n. @ChrisTitos is your code definitely URL-decoding in the final API call to get an access token?\n. Which version of PHP are you running and with which versions of OpenSSL and on which platform?\n. Please see\nhttps://oauth2.thephpleague.com/resource-server/securing-your-api/\nOn Sat, 28 May 2016 at 01:20, Jos\u00e9 Quintana notifications@github.com\nwrote:\n\nI have this access_token:\nPOST\nhttp://localhost:8000/v1/user/add/?access_token=a31b28c8aa62f9b86680650d90f3b82d832e73bc\nand in backend, I would like to obtain the client data associated to this\nincoming access_token.\nIs it possible to access a client data from oauth_clients (client_id,\nclient_secret, redirect_uri, grant_types, scope, user_id) by valid\naccess_token?\nThanks in advance!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/585, or mute the\nthread\nhttps://github.com/notifications/unsubscribe/AAEwpw1NFRBg1DMxRnvRlyr9N9Z1jm7pks5qF4pSgaJpZM4Io80d\n.\n. In theory it can be used to save having to write the code for the router endpoint. It's not been documented because in all honesty I forgot to document it and I'm not actively using so it's an oversight.\n. The access token endpoint I use it literally the same one from the examples (or the AuthorizationServerMiddleware)  - no other code is necessary.\n\nAs for the authorize and login endpoint this is based on some code running in production (I've had to redact some stuff though):\n``` php\n$app->get('/authorize', function (ServerRequestInterface $request, ResponseInterface $response) use ($app) {\n    / @var \\League\\OAuth2\\Server\\AuthorizationServer $server /\n    $server = $app->getContainer()->get(AuthorizationServer::class);\n// Validate the HTTP request and return an AuthorizationRequest object.\n$authRequest = $server->validateAuthorizationRequest($request);\n\n// Serialize the the authorize request, encrypt it and store it in a cookie\n// [redacted]\n\n// Set the cookies on the response object\n// [redacted]\n\n// Redirect the user to the login page\nreturn $response->withHeader('Location', '/login');\n\n});\n$app->any('/login', function (ServerRequestInterface $request, ResponseInterface $response) use ($app) {\n    / @var \\League\\OAuth2\\Server\\AuthorizationServer $server /\n    $server = $app->getContainer()->get(AuthorizationServer::class);\n/** @var UserRepository $userRepository */\n$userRepository = $app->getContainer()->get(UserRepository::class);\n\n// Get the authorize request from the cookie, decrypt it, throw a \"session timeout error\" if the cookie is missing, and a general error if the cookie can't be decrypted\n// [redacted]\n\n// Test for login\n$error = null;\n$userId = null;\n$body = (array) $request->getParsedBody();\nif (\n    array_key_exists('username', $body)\n    && array_key_exists('password', $body)\n    && array_key_exists('_csrf', $body)\n) {\n    // Get the CSRF cookie and validate it, goto fail\n    // [redacted]\n\n    // Try to log a user in\n    $userEntity = $userRepository->getUserEntityByUserCredentials(\n        $body['username'],\n        $body['password'],\n        $authRequest->getGrantTypeId(),\n        $authRequest->getClient()\n    );\n    if ($userEntity instanceof UserEntity) {\n        $authRequest->setUser($userEntity);\n\n        // in this example the authorisation is always approved because the user\n       // is signing-into a first party app, normally you'd set this value to true or false\n       // depending on whether or not the user approved the client\n        $authRequest->setAuthorizationApproved(true);\n        // Remove the auth request cookie + CSRF\n        // [redacted]\n        return $server->completeAuthorizationRequest($authRequest, $response);\n    } else {\n        $error = 'Invalid username or password';\n    }\n}\nfail:\n\n// Create a CSRF value and write it to a cookie on the response\n// [redacted]\n\n// Render the login template with variables from the auth request and the CSRF value,\n// write HTML to response object\n// [redacted]\n\nreturn $response;\n\n});\n```\nI do intend on writing a full tutorial at some point but finding time is hard now that I'm self employed\n. You can save yourself some code by storing the validateAuthorizationRequest result in an encrypted cookie instead of validating it on every page and manually building a query string\n. I'm not using the AuthorizationServerMiddleware no.\nserialize the validateAuthorizationRequest result. Then use an encryption library to encrypt the payload, then use something like dflydev/fig-cookies package to read and write the cookies onto the PSR7 request/response objects\n. Ah I understand now. It looks like a copy and paste error on my part. I\nwill remove it when I'm next at a computer.\nSorry for the confusion.\nOn Wed, 1 Jun 2016 at 20:06, TommyBs notifications@github.com wrote:\n\nHi,\nNot really an issue with the code but I'm trying to understand the example\na bit better.\nOn\nhttps://github.com/thephpleague/oauth2-server/blob/master/examples/src/Repositories/UserRepository.php\nWhat does the 'scopes' refer to here as it doesn't seem to be used or\nstored anywhere in a member variable? Also I'm not sure why the grantType\nand $clientEntity are here and what they would be used for.\nIs this detailed more in the OAuth specs?\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/589, or mute the\nthread\nhttps://github.com/notifications/unsubscribe/AAEwp8NIfsGimr_Wp2hZ7ZblDRc4qq1aks5qHdgXgaJpZM4Ir3_9\n.\n. See the finalizeScopes method on the ScopeRepository for that\nOn Wed, 1 Jun 2016 at 20:10, TommyBs notifications@github.com wrote:\nAh, though thinking about it, I assume the Client Entity would allow me to\nsee what scopes the Client had requested and had been approved by the user,\nthen I could in theory set the scopes on a suitable object somewhere or\nfilter what data the userEntity makes available\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/589#issuecomment-223094388,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAEwp2hx09mF-Nu87UQ0DMq50w5vq_Biks5qHdkWgaJpZM4Ir3_9\n.\n. Redirect URIs are whitelisted because otherwise there is an \"open redirector\" vulnerability attack vector.\n. Because it is possible to return an array of whitelisted redirect URIs on the ClientEntity (https://github.com/thephpleague/oauth2-server/blob/master/src/Entities/ClientEntityInterface.php#L28-L35) and then in the redirect_uri parameter indicate which one you wish to the user to be returned to.\n\nSo for example you might have a production and a development URI registered and returned in that array.\n. Good question.\nWhen an access token is parsed a number of attributes are set on the PSR-7\nRequest object (see\nhttps://oauth2.thephpleague.com/resource-server/securing-your-api/#implementation\n).\nYou could add some logic to your API to determine whether or not both the\nuser and the client are allowed to access the endpoint (based on the\nrequest attributes).\nOn Sun, 5 Jun 2016 at 10:45, TommyBs notifications@github.com wrote:\n\nHi,\nCan I implement multiple grant types? If so how would token validation\nwork?\nFor instance I have an api that might have protected resources that\nrequire a user to be validated before they can access them. Now as the Api\ncan be used by first and 3rd party apps, the first party apps can obviously\nuse the password grant, whereas the 3rd party apps will use the Auth Code\ngrant.\nOn top of this any request to any non-secure (as in public available even\nover https) endpoint, should validate that it has come from a valid app,\nnow I'm toying with just having an appKey header or whether I should use\n'client credentials' scope here?\nI suppose what I'm not sure on, is how to secure a private endpoint that\nrequire a user access token and stop someone just supplying the client\naccess token to bypass this? Is there a way to validate the type of token\nto determine if it should be able to access a specific resource?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/592, or mute the\nthread\nhttps://github.com/notifications/unsubscribe/AAEwpwpNau8MNC_7G_tjvzTVD4Pkrdkfks5qIprKgaJpZM4IuUd0\n.\n. Thanks, will address in a patch later today\n. This has been fixed by #605 \n. I'm sure it can probably be used with WordPress but I've not looked at WordPress in years so I couldn't give you any advice in terms of starting I'm afraid.\n\nIf you work it out please feel free to update this ticket with a link to a blog post or some advice to others \ud83d\ude04 \n. I'm thinking it might be better to switch to v4 UUIDs for token ID long term but your suggestion of looping over is a good one\n. Hi @pmlt,\nThe state parameter is set in the RedirectResponse here https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L308-L330\nI don't suppose you could create a test case for me please?\n. Okay sorry I understand the specific issue now. I will address this in the next patch update.\nThank you for spotting this!\n. As this is handle by the underlying JWT library it can be removed\n. I switched to JWTs in v5 of the library because it solves a few implementation problems. Because JWTs are signed self-contained payloads they can be used in distributed architectures where each resource server may not have access to the underlying token persistence layer - likewise there might not even be permanent persistance and instead a revocation persistence layer instead (i.e. only store revoked tokens instead of all tokens).\nThe aim of this library is to provide a solid foundation for building an OAuth server out of the box and having built tens of OAuth servers now I think moving to JWTs as the default implementation is still a good idea.\nIf you implement the classes League\\OAuth2\\Server\\AuthorizationValidators\\AuthorizationValidatorInterface and League\\OAuth2\\Server\\ResponseTypes\\ResponseTypeInterface you'll be able to by-pass the JWT stuff and work with more traditional bearer tokens; I realise however that you'll still need to bind the public and private keys for now but as I don't believe they will actually be used outside the JWT stuff it shouldn't matter if these are dummy files. \nI do appreciate your concern though and I think I'm going to release v6 at some point this summer (and maintain it side by side with v5) to address a few small API design issues such as this to make the library even more flexible.\n. I think the loop just needs to be around $accessToken->setIdentifier($this->generateUniqueIdentifier()); and the try/catch block; no need to continuously create access token entity objects\n. Why would this not work?\n``` php\nprotected function issueAccessToken(\n    \\DateInterval $accessTokenTTL,\n    ClientEntityInterface $client,\n    $userIdentifier,\n    array $scopes = []\n) {\n    $maxGenerationAttempts = 10;\n$accessToken = $this->accessTokenRepository->getNewToken($client, $scopes, $userIdentifier);\n$accessToken->setClient($client);\n$accessToken->setUserIdentifier($userIdentifier);\n$accessToken->setExpiryDateTime((new \\DateTime())->add($accessTokenTTL));\n\nforeach ($scopes as $scope) {\n    $accessToken->addScope($scope);\n}\n\nwhile ($maxGenerationAttempts-- > 0) {\n    $accessToken->setIdentifier($this->generateUniqueIdentifier());\n    try {\n        $this->accessTokenRepository->persistNewAccessToken($accessToken);\n        return $accessToken;\n    } catch (UniqueAccessTokenIdentifierConstraintViolationException $e) {\n        if ($maxGenerationAttempts === 0) {\n            throw $e;\n        }\n    }\n}\n\n}\n```\n. I understand the concern but I think that's being overly defensive \ud83d\ude04 \n. Thanks.\nAm just thinking that this should probably extend to the issueAuthCode and and issueRefreshToken methods too?\n. Thanks so much @zerkms!\n. I've seen race conditions on Travis too.\nRegarding tests I agree they are bloated; the vast majority of the tests need converting to functional tests (i.e. spinning up a web server and sending HTTP calls to it to verify conditions). That would make adding new tests much easier (as it'd move to a one test one file model). Longer term fuzz tests can be introduced to try and trick the authorization server with garbage data.\n. Can you please paste me examples of what you are sending the authorisation sever (in terms of the JSON payload) to get an access token for both grants?\n. How strange. I will try and recreate the problem. Just to clarify you're\nusing the latest 5.0.x release?\nOn Sun, 19 Jun 2016 at 17:46, Frank Giger notifications@github.com wrote:\n\nNo problem. Now I done this situation\n$server->enableGrantType(    $authGrant,    $accessTokenExpire);$server->enableGrantType(    $clientCredentialsGrant,    $accessTokenExpire);\nI enabled the Authorization first then the Credentials. And I send this to\nthe server\n[image: Request]\nhttps://camo.githubusercontent.com/2208b96738f2f473ebc7c18d234b625cb6b97ad1/68747470733a2f2f6672616e6b2d67696765722e63682f726571756573742e706e67\nAnd I receive this response\n{\"token_type\":\"Bearer\",\"expires_in\":31535999,\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IlV4UEpRQWZLa0VOd1pJVHVsSjlldFdmSGpIZjU3ZzdNTnhYMXJ6eWIifQ.eyJhdWQiOiJFVWNEcWNRQzZBTjNVVVAzSHZEYTViaFlyQVRwWlVyd0Z0WVV3RXBzNTJrUE1ZSG1rYm1lZHY0dlVOSEx6WDc1Z1ZRQ3I1VW1XNVp6VXpLNSIsImp0aSI6IlV4UEpRQWZLa0VOd1pJVHVsSjlldFdmSGpIZjU3ZzdNTnhYMXJ6eWIiLCJpYXQiOjE0NjYzNTQyNTYsIm5iZiI6MTQ2NjM1NDI1NiwiZXhwIjoxNDk3ODkwMjU2LCJzdWIiOiIiLCJzY29wZXMiOlsidXNlcl9iYXNpYyIsImV2ZW50X2Jhc2ljIl19.aOa63M4eAo3zqo1n6nj-_ESJQfEujpajIn1GAdLRrZdeR9EG4rgbAiIb0dFt7fMjvF2zeE_LCc8HpvOu36i9ynye_ZpKO0d09lMcP_OnVhaHzpzfKasC7lwedh8lw_BzWgtN978CcayusbsDWPQSqINgOKCRSsM04XdGWP_K-hD7aKrBYWURz9QdHi0K5nEskNXdl9zl9drRzqE5bv6Tmn4FafHycrviHjJBEo2H-ZsFF5PZaY_UtOBYcuFrA6_WHVOCIpgnXS_wjCVR8WMFXMCUxVpiIDcCmfQCEGuUkcTgLLVkuCTxbuphjOLJ9Cn218thCLHwg-4DzK2pWdYtsCRcD4sBCxFALaXPp0_XeoaqghGTHkXK1uqat0f7qs4FfK58J3YTTL2aflnTmtm3lzCXobdM0JQnOco_6JpfJ2q4Fx8VDSZw9BNnCwVBIsMrDSJr9oxQw0OBevuqFYyMPnCiGiqO4c6XPiJI1Ucnaq1Q29KRBc7NqGKVY8l9tnbGDPBMRS7_ZK1b6oWJz0_zHurIUpuLvOJfdAmC1Q0rYhPDcJQVGVSKni74cxgVnI7fHvQlbPz338NqZz6mRvw34Vwu853w6aX0KWij83qFDfv9TAnhc3sayCH2JM8HWx5wxRpqjIQzKgCPZ7sAVJ8SE9LTKS0XjKVDYcFAG7Y32EU\"}\n{\"error\":\"unsupported_grant_type\",\"message\":\"The authorization grant type is not supported by the authorization server.\",\"hint\":\"Check the grant_type parameter\"}\nAnd this I receive in the header\n[image: Header]\nhttps://camo.githubusercontent.com/4efa80476aa3044814892e229942f7d3572fdc5f/68747470733a2f2f6672616e6b2d67696765722e63682f6865616465722e504e47\n- Sorry the HTTP status code is 400 and not 500. My mistake.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/602#issuecomment-227007353,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAEwp3b3_YkudbEIDDJYQKIgsrlYbGsvks5qNXI9gaJpZM4I5MNY\n.\n. I'm totally open to improving this. I need to do some tests with defuse/php-encryption to ensure that it's a backwards compatible change but otherwise \ud83d\udc4d \n. Access tokens shouldn't be affected only authorization codes and refresh tokens as they are both encrypted.\n\nAuthorization codes are short-lived and are not processed in any way by the client (other than sending it back to the authorization server within a few minutes) so I'm not concerned about BC of those. Refresh tokens are in a similar situation (although the client should know how to deal with expired refresh tokens too).\nI'm more concerned about maintaining library-API backwards compatibility but I'm sure it won't be an issue.\n. Access tokens are currently JWTs which aren't encrypted (just signed using the private key). Only refresh tokens and authorization codes are encrypted\n. Cheers!\nPR-ing against master is correct.\nI've just had a quick look and getMock has been replaced with createMock as of PHPUnit 5.4 but it's not backwards compatible\n. Is this not caught by the InvalidArgumentException catch block? https://github.com/thephpleague/oauth2-server/blob/master/src/AuthorizationValidators/BearerTokenValidator.php#L77-L80\n. Will include this in the next tag release\n. 5.1.0 has been released\n. I understand your requirement - the problem is that changing the interface will break everyones' code so in the constraints of semantic versioning I'd have to release a new major version.\nHaving said this I do think a new major version is on the horizon that addresses some small short comings of v5. As there won't be that much change I've been debating supporting both v5 and v6 side by side for 12-18 months before deprecating v5. I'll write a formal Github issue about this though.\n. I'm afraid not. V5 is a complete rewrite however the interfaces that need\nto be implemented are much simpler than V4s.\nOn Mon, 4 Jul 2016 at 07:49, Ron Rademaker notifications@github.com wrote:\n\nHi,\nI noticed in the changelogs the new 5.x releaes are a complete rewrite.\nAre there upgrade docs available for upgrading 4.x to 5.x?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/609, or mute the\nthread\nhttps://github.com/notifications/unsubscribe/AAEwp9tag-EheT27yY8YswAtQUXO2Az0ks5qSKzggaJpZM4JEF9o\n.\n. In the short term for the few Symfony/Laravel projects I've worked on I've made custom AuthorizationValidatorInterface implementations to support non-PSR7 requests and responses.\n\nThe long term solution to this is probably adopting some sort of adapter system that can support both PSR-7 and Symfony HTTP objects.\n. The best way would probably be to implement your own AuthorizationValidatorInterface based on the existing BearerTokenValidator; if the JWT cannot be parsed then assume it's a V4 token and go from there.\n. Are the mock builder changes with both PHPUnit 4.8 + 5.0 ?\n. Was this done with some automated tool? Just there are some changes in here that don't match my preferred code style - e.g. changing $foo === false to !$foo, I think !$foo is less readable when quickly scanning code\n. I've had a look through and that's the only thing I'm not comfortable with. Thanks \ud83d\ude04 \n. As you said, the object isn't re-used afterwards.\nIf you can suggest some reasons why an alternative implementation would be preferable because the information is needed later on I'm open to suggestions \ud83d\ude04 \n. Please feel free to submit a patch :)\nOn 13 July 2016 at 10:49:14, Pierre (notifications@github.com) wrote:\nHum, it's only a matter of pure brain logic, whereas your object works\nconsidering that PHP spawns and dies at the end of the request, it's OK,\nbut if you want to use it with, let's say, something like PHP-PM (using\nReactPHP) then it's not gonna work. I think that the various enabled grants\nare software configuration (in my very own case dependency injection\ncontainer configuration) - and should probably not be mutable this way, it\nshows a design flaw.\nIt was weird the first time I read the code because I didn't know if it was\na real feature to remove the grants from the authorization server or not, I\nthink that code understanding and readability should win over other\nconsiderations especially with something as complex as OAuth2.\nAnother possible implementation is a simple foreach() in the end :)\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/617#issuecomment-232309169,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAEwpziHYkbitCcP8B_aC2DcLCodk0yUks5qVLSZgaJpZM4JKiZ3\n.\n. I actually think this is an issue wih canRespondToAccessToken() method on the AbstractGrant class which uses the identifier when perhaps it should call a different abstract method to ascertain the grant_type for the POST request\n. The value of this library is in it's flexibility - I do appreciate what you're saying and previous implementations provided default implementations of entities but the V5 release was all about getting out of the way of developers.\nI don't think your implementations are useless code - this library tries to make no-assumptions and your requirements for your entities might change over time.\n. I'm not sure what you're referring to sorry?\nGithub is having problems at the moment:\n```\nJuly 12, 2016\n17:00 BSTWe're investigating delayed updates across the site.\n```\n. Thanks @digininja \n. Am very happy to review a PR for this, I think it's a good idea \ud83d\udc4d \n. This is great! Thanks @juliangut \n. Hi @alexplumb, I don't have any plans currently to support these RFCs (I've not yet had a chance to read the specs).\nIt's likely device flow support and OpenID Connect will be next but I will happily add these RFCs to the backlog.\n. What action needs to be taken here @iansltx ?\n. Sorry for my lack of response here - I'm currently on holiday.\n@alexplumb your suggestion of using events inside the repositories is a good one. Alternatively you could do this logging in finalizeScopes method of the ScopesRepository\n. Hi Grant,\nNo the state param is just used in the authorization code and implicit\ngrants. It is used as an anti-CSRF device.\nOn Wed, 27 Jul 2016 at 09:34, Daan Geurts notifications@github.com wrote:\n\nHi Alex,\nI'm using your library, which is awesome, but I don't get my mind around\nthe state param. If I check all grant types, the only one using the state\nparam upon creating an access token is the AuthCode grant. I'm using\npassword grant, is state param not needed for this?\nThanks in advance,\nDaan Geurts\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/629, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AAEwp7EGz_H_s7htB7qGHJJsuFPN_lJ9ks5qZ15RgaJpZM4JWMXv\n.\n. I switched to JWTs in v5 of the library because it solves a few implementation problems. Because JWTs are signed self-contained payloads they can be used in distributed architectures where each resource server may not have access to the underlying token persistence layer - likewise there might not even be permanent persistance and instead a revocation persistence layer instead (i.e. only store revoked tokens instead of all tokens).\n\nThe aim of this library is to provide a solid foundation for building an OAuth server out of the box and having built tens of OAuth servers now I think moving to JWTs as the default implementation is still a good idea.\nIf you implement the classes League\\OAuth2\\Server\\AuthorizationValidators\\AuthorizationValidatorInterface and League\\OAuth2\\Server\\ResponseTypes\\ResponseTypeInterface you'll be able to by-pass the JWT stuff and work with more traditional bearer tokens; I realise however that you'll still need to bind the public and private keys for now but as I don't believe they will actually be used outside the JWT stuff it shouldn't matter if these are dummy files.\nI do appreciate your concern though and I think I'm going to release v6 at some point this summer (and maintain it side by side with v5) to address a few small API design issues such as this to make the library even more flexible.\n. The openssl function requires file:// to be prepended.\nThere was a recent PR - https://github.com/thephpleague/oauth2-server/pull/625 - that allows you to inject the key directly into the first parameter - perhaps that could help in your situation?\nIn any case I do agree with you that it has got unwieldy and the upcoming version 6 release can address this.\n. @klickagent please could you clarify from the RFC where you want nonces to be used?\n. Agreed; I'm going to release it as a separate package\n. Thanks \ud83d\udc4d \n. There are two methods:\n1) Create an API endpoint that a client can send a request to (along with the access token) which will return the user details (based on the user identified by the access token).\n2) With OpenID Connect you can ask for an \"id token\" along with an access token which returns an OpenID claims set. I'm working to add OpenID support natively into this library but it's a really big specification.\nFor now, I'd go with option 1\n. You'll need to implement this manually for now, but V6 will support \"token\nintrospection\" which is an RFC that I've been working on.\nOn 18 August 2016 at 20:25:46, Nicholas Wiersma (notifications@github.com)\nwrote:\n\nHi,\nWas looking for a way to manually validate a token. It seems to only be\npossible to through a bearer token validator. There are a fair number use\ncases for this, the main one in my case is allowing consumers to validate a\ntoken and its scopes.\nAs a reference, GitHub does this, the documentation can be found here\nhttps://developer.github.com/v3/oauth_authorizations/#check-an-authorization\n.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/641, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AAEwp7xfhksLtwuixXsesPgsFjrTSkBAks5qhLG6gaJpZM4Jn1CI\n.\n. Here are two really good articles that should help you out:\n\nhttps://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage\nhttps://auth0.com/blog/ten-things-you-should-know-about-tokens-and-cookies/\n. Please can you retain the existing link and add the Passport link as\n\"Laravel Passport (Official)\"\nOn 30 August 2016 at 09:28:22, Vincent Klaiber (notifications@github.com)\nwrote:\n\nThe passport package has replaced oauth2-server-laravel for future\nversions of Laravel.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/thephpleague/oauth2-server/pull/645\nCommit Summary\n- Update Laravel link\nFile Changes\n- M framework-integrations.md\n  https://github.com/thephpleague/oauth2-server/pull/645/files#diff-0\n  (2)\nPatch Links:\n- https://github.com/thephpleague/oauth2-server/pull/645.patch\n- https://github.com/thephpleague/oauth2-server/pull/645.diff\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/pull/645, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AAEwp8cDNLTYvtVpkwr4NzdQ0SJT8NTfks5qk-mmgaJpZM4JwRSd\n.\n. I completely agree with the proposed change - it was something I should have realised before releasing v5.\n\nMy local copy of v6 (which will be a very easy upgrade and will be maintained side-by-side with v5) already has a fix for this.\n. This project doesn't implement the Open ID Connect specification yet (and won't for a while).\nThe authorization codes are distributed as embedded payloads to reduce DB hits in high request environments when a client converts to an access token.\nThe only way currently to change this would be to extend the grant and the AuthorizationCodeRepositoryInterface to support saving the value to the database\n. I'm moving v6 away from using the crypt trait (and removing the requirement for symmetric key pairs too if you don't want to use them). Going forward an auth code is likely to be a JWT which should be smaller than the current encrypted payload\n. In v6.0.0 I've updated the grants so that if you don't pass in a RefreshTokenRepository then a refresh token won't be created\n. @lookyman I've just got to finish updating the auth code and implicit grants then I'm going to release an alpha\n. It's a mistaken oversight\n. This is fixed now\n. I've just pushed 4.1.6. Sorry about the delay\n. You will need subclass the password grant to add support for these extra fields\n. In order of your questions:\n- Do you have any examples of what you'd like to see as alternatives?\n- At this point no - what the next version (alpha coming shortly) will support is JWT tokens that are signed with a HMAC key instead of RSA keys meaning you don't need to generate a public and private key\n- The library used to have support for MAC tokens but the draft specification changed quite significantly so I dropped it for the time being because noone was using it.\nThe entire library is designed to be extensible by conforming to various interfaces - if you've suggestions for new built-in functionality I'm always open to new ideas\n. Both RSA keys and HMAC will be available - if your authorization server and resource server are the same codebase use HMAC, if they're separate codebases then RSA is a better option.\nYour code change isn't necessary because the an AuthorizationValidatorInterface is already passed in which validates tokens\n. @LeonanCarvalho \"OAuth 2.0\" is the specification it isn't the library version number\n. Thanks\n. Can you describe your requirements?\n. Which HTTP library are you currently using? Symfony? Zend?\n. You need to find a Zend->PSR7 and Phalcon->PSR7 adapter\n. @er0k could you send a PR please?\n. Merged. Thanks\n. Nice spot \ud83d\udc4d \n. As of v5 the token IDs are safe to store in a database without any encryption - this is because the token ID is not the same as the access token.\nYou should make use of a good database library that automatically handles SQL escaping for you to reduce SQL injection attacks as well as any other good recommendations.\n. > That's a given \ud83d\ude09, but it won't protect from a lost database backup, an angry ex-employee, insecure legacy or vendor code, or other such scenarios where data can get in the wrong hands. We still want to limit the impact it can have.\nThese problems are outside the scope of this library\n\nSo I guess my best course of action would be to update to v5, is there an upgrade guide somewhere to go from v4 to v5? Or is it so different that it'd be easier to start from scratch?\n\nIt's easier to start from scratch however it isn't a huge upgrade path - many of the queries you've already written to implement the v4 storage interfaces can be brought over to the v5 repository interfaces.\n. I believe the finalizeScopes does what you require?\n. finalizeScopes tells you the user ID, the scopes that were requested, the client and the grant type - what additional information do you need to make a decision?\n. Okay; this will have to wait until V6 as it will require an interface change \ud83d\udc4d \n. Thanks\n. The ClientEntityInterface doesn't have a getSecret method because the library doesn't need to know the client's secret. The only time the client secret is relevant is during your implementation of ClientRepositoryInterface:: getClientEntity whereby you can validate the client secret along with the client ID at that point.\nRegarding your second question could you please explain it a little more, I'm not quite following the scenario you're looking for\n. In this instance you've highlighted - the user would actually be redirected back to the client with a 302 header - see https://github.com/thephpleague/oauth2-server/blob/master/src/Exception/OAuthServerException.php#L224-L231\n. In this case then the actual failure is much earlier on because the client ID and redirect URI are incorrect in the query string. Throwing a HTTP authorization dialog is correct behaviour.\n. Thanks; will look into it\n. I understand what you're saying about the naming convention however I don't understand this comment - \"That way it's completely up to the implementation on how to handle things\".\nWhat can't you currently do that you could do if the interface was renamed? Or is this purely a semantic change?\n. For legacy reasons. It's removed in v6\n. Please upgrade to 5.1.4 or 6.0.0 - this issue has been resolved. I'm going to get rid of the encryption all together in the next version; it's made things overly complicated\n. I will clarify my comment as I didn't have time to yesterday; the encryption mechanism is currently used for encrypting the auth code and refresh token payloads.\nIn both cases I no longer feel this is necessary and representing both of these payloads as signed JWTs (as access tokens currently are represented) solves the same underlying problem and removes the home-brew encryption mechanism.\nIn V6 you can either use RSA signing or HMAC signing - if you're implementing a distributed system you should use RSA, if your authorization and resource server are the same codebase then use HMAC signing.\nI imagine for most implementations are shared authorization and resource server codebases so I'm anticipating the implementation being much simpler for the vast majority of installations.\n. Asymmetric encryption allows for a better distributed architecture that doesn't require distributing the signing key material (private key) outside of the authorization server.. This issue has been resolved as of 5.1.4 and 6.0.0. You're best bet it to probably add logic to the front end to correctly respond to invalid token errors and back-off for a moment until the frontend has got the new access token\n. Your changes aren't correct I'm afraid.\nThe $clientSecret is the plain text that wants verifying against the hash. Where is $clientSecret a hashed value?. Why are you passing the parameters via query string and a GET request?\nOn 24 December 2016 at 21:44:57, Gabriel Angelus (notifications@github.com)\nwrote:\n\nI'm using PHP 5.6.16 with Laravel 5.3 and I received some exceptions after\ntrying to generate access tokens via GET.\nThe issue is in getRequestParameter(), where the property 'parsedBody'\ncomes defined as an empty array.\nThis little change worked for me, I expect to get your opinion.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/thephpleague/oauth2-server/pull/691\nCommit Summary\n\n[FIX] Getting parameters of request\n\nFile Changes\n\nM src/Grant/AbstractGrant.php\n   https://github.com/thephpleague/oauth2-server/pull/691/files#diff-0\n   (2)\n\nPatch Links:\n\nhttps://github.com/thephpleague/oauth2-server/pull/691.patch\nhttps://github.com/thephpleague/oauth2-server/pull/691.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/pull/691, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AAEwp3OYgmlQayQcoljVvABPFlMF8uwvks5rLZJZgaJpZM4LVTL4\n.\n. Because the OAuth specification dictates which HTTP methods each grant should use and this library does it's best to follow the specification as closely as possible.. Yep, what @jorgeGrisolle said. This issue has been resolved as of 5.1.4 and 6.0.0. You don't have to store the dates however if you do you could use the expiry date as part of a cron job to remove expired tokens. Is this a duplicate of #700?. Thanks. Please can you detail the HTTP request you are making to the authorisation server?. Yes it needs to be that strict because there is a risk of redirect hijacks which have bitten Facebook and others multiple times.\n\nIf you need to pass custom data back and forth use the state param which the auth server will pass the value of back to the client. First of all this is really irresponsible disclosure. Both this repository and the Laravel repositories have got guidance on how to report security vulnerabilities.\nSecond this isn't an issue due to the way base64 character encoding works. Depending on the encoded data you may be able to change a few characters at the end of the token without affecting modifying the encoded data.\nSo this isn't a security issue.\n. As I said before this isn't an issue.\nWhen you base64 data (for example the JWTs created via this library) the\nencoding process may add padding to the final output. Because these extra\nASCII characters are just padding you can modify them to other characters\nwithout affecting the data that has been encoded.\nThe JWT validation doesn't compare the base64 encoded data, it compares the\ndecoded data.\nOn 3 February 2017 at 16:53:29, Jeremy Kenedy (notifications@github.com)\nwrote:\n\nI removed the title and comment per your comment. You are correct, I did\nnot read the readme in full before posting this. However, you are incorrect\nabout the Passport stating a guideline and I was following one of their\ncontributor recommendations to reach out to you.\nMoving past the miss understanding, can this still be checked out?\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/702#issuecomment-277300497,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEwp45wp4C1TmzKUqOU8LCFIxYeATLbks5rY1uJgaJpZM4L2fyw\n.\n. Nope, the OAuth standard says throw a WWW-Authenticate header.\n\nThe client can use it's id and secret as the username and password.. Best to use the old 4.* branch - https://github.com/thephpleague/oauth2-server/releases/tag/4.1.5. This is documented here - http://oauth2.thephpleague.com/resource-server/securing-your-api/. The implicit grant redirects with a # not a query string in the OAuth specification. I think it'd be better to have a getter and setter method for the $payload with which you can inject additional parameters:\nphp\n$exception->setPayload(\n  array_merge(\n    $exception->getPayload(),\n    ['foo' => 'bar']\n  )\n);\nreturn $exception->generateHttpResponse($response);. Thanks. I think you're conflating two different issues.\nAs part of an authorization request the scope parameter is singular in this libraries implementation.\nThe embedded scopes array inside a JWT is of this libraries own design as I don't believe the embedding of scopes inside a JWT has ever been given an official claim.. That's correct. The OAuth 2.0 specification doesn't allow non-user grants to use refresh tokens on the basis that it's trivial for a client to reauthenticate itself - there's no user involved.. This library is purposely open ended because there are so many ways you might want to utilise this library so I don't have a sample SQL file to give you I'm afraid.\nToken IDs are 40 characters in length so you'll want to make sure that column is at least that long.\n. > For instance, a RefreshToken should be a one-to-one with the access token, right?\nYes\n\nI'm guessing AuthCode is many-many for scopes, one-one for users, many-one for clients.\n\nYes\n\nAnd AccessToken many-many for scopes, many-one for users and clients.\n\nYes\n. Sorry for the delay getting this merged. @leroy0211 please see the documentation here https://oauth2.thephpleague.com\n@danitome24 you'll need to covert the PSR http requests into Symfony requests using middleware. Sorry for the late response, I'm currently away travelling.\nThe idea here was that the getNewToken method could also add any additional grants into the request that fulfill any necessary backend logic.\nIt's going to be resolved in v6. Hello,\nThe situation you described should be mitigated on the basis that if the client directly forwarded the user on to the second route then there would not be the necessary authorisation request serialised and stored in the user's session to complete the request.\nPlease see the code comments in the implementation example here - https://oauth2.thephpleague.com/authorization-server/implicit-grant/. Sorry for the very late response to this - how can I best test it?. Please see the following two documentation pages:\nhttps://oauth2.thephpleague.com/resource-server/securing-your-api/\nhttps://oauth2.thephpleague.com/authorization-server/refresh-token-grant/. My concern is that if the refresh token isn't revoked immediately then there is a risk of replay attacks.. @xerkus could you please detail a little more the scenario you\u2019re experiencing?. @halaei so I can understand the problem better - what was the issue exactly when you say \"This was a big problem for our mobile applications\" ?. @halaei would a longer TTL for access tokens work better for you so that access tokens don't expire so frequently?. @halaei I'm not suggesting don't use refresh tokens, just increase the lifetime of access tokens so they aren't required to be refreshed as frequently\n. This issue has been resolved as of 5.1.4 and 6.0.0. Thanks for this update - please could you re-review it against the current master branch?. Am closing this to move discussion to #749 . Thanks for your pull request.\nDo you have any benchmarks to demonstrate the speed improvement?. Please remove the Yoda conditions. I'm going to release an update that doesn't hard error but just throws warnings instead. I have released 5.1.5 which replaces the hard errors with notices and deprecation warnings.\nIt is correct behaviour that the key should be owned by the server process to prevent possibility of token forgery by replacing the server\u2019s public key or leakage of the key by an attacker or rogue other process.. Thank you. Hello,\nThank you for your contribution - please could you explain the changes you've made?\nThank you. It's hard to see what's wrong here without some more information.\nPlease can you share your implementation of the RefreshTokenRepositoryInterface?. I will give a lengthier reply shortly but that audit is not the only audit\nthat took place. The other hasn't been released yet.\nOn 4 July 2017 at 21:05:32, Adam Lavin (notifications@github.com) wrote:\n\nI'm quite skeptical of the security improvements this is supposed to\nbring. In the audit report\nhttps://wiki.mozilla.org/images/7/77/Oauth2-server-report.pdf, the only\nthing raised was that was that the RSA key validation was subpar. The code\nreference, from what I've looked over, appears to only be used to check if\nyou've passed an RSA key to as string to the constructor. The auditor noted\nthat it was going to be mitigated by you dropping encryption in future\nversions, not by switching encryption methods.\nIn addition to this, The encryption change is currently implemented in a backwards\nincompatible way\nhttps://github.com/thephpleague/oauth2-server/blob/26889abdd3dc04b7b9d633991e807159f6d410f9/src/CryptTrait.php#L105,\nonce the new encryption key is provided, that's it, if the server receives\na previously valid access token / refresh token, it's no longer valid\nbecause it can't be decrypted. This would be solved by checking the old\nencryption method after the new one fails. None of this is documented on\nyour security improvements\nhttps://oauth2.thephpleague.com/v5-security-improvements/ page.\nAlso your breaking change for 6.0.0 removes\nhttps://github.com/thephpleague/oauth2-server/blob/315d079033df8f14e18860d9a56ff8f9653eeb22/src/CryptTrait.php\nall code that deals with old encryption method, but still expects a private\nkey to be given in the constructor\nhttps://github.com/thephpleague/oauth2-server/blob/315d079033df8f14e18860d9a56ff8f9653eeb22/src/AuthorizationServer.php#L87,\nwhy?\nI'm not saying this is a bad change, but it's poorly documented and anyone\nfollowing the advice given without looking into it may suddenly find\nthemselves in a situation where they have basically performed a clean reset\nof their issued tokens.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/757, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AAEwp_0o_28wGudiazhD_kJX1OIrUufcks5sKpsMgaJpZM4ONqBv\n.\n. Please feel free to submit a pull request. @andersonamuller could you copy the keys out of Kubernetes secrets mount into a temp directory when the container starts using an entrypoint script? You might need to use UID and GID to manage privileges . > I understand that this was done with best intentions, but being \"too smart\" will almost always break things for many valid use cases out there.\n\nAm coming to the same conclusion quickly. This issue has been resolved by 6.0.2. Please upgrade to laravel/passport 3.0. You probably need to use mod-rewrite with Apache. I don't use Apache so I can offer tailored advice I'm afraid.. You can't; please can you explain your use case?. When the performance of this library on a single server becomes a problem\nyou'll be pleased it's designed to scale horizontally without requiring a\ndatabase hit on the resource server.\nOn 17 July 2017 at 10:27:41, Hamid Alaei Varnosfaderani (\nnotifications@github.com) wrote:\n\nClosed #764 https://github.com/thephpleague/oauth2-server/issues/764.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/764#event-1166103330,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEwp-aMM7EpKnBz9Kcg7Jbd8wTZx2rCks5sOykMgaJpZM4OZnVd\n.\n. Are you sure BearerTokenResponse.php#L35 is the right file?\n\nDo you mean AbstractGrant.php#463?\nRegardless the identifier needs to be encoded to a UTF-8 string to be returned in the JSON payload; so even with protobuf, thrift and gzip it needs passing through bin2hex or base64_encode . Duplicate of #760.. league/oauth2-client is for social login\nThe server can store the access token if you want the ability to revoke them before they expire, otherwise yes it's the clients responsibility to store tokens.. Fixed by #770 . It's used as part of the auth code grant and implicit grant:\nhttps://oauth2.thephpleague.com/authorization-server/auth-code-grant/#implementation\nhttps://oauth2.thephpleague.com/authorization-server/implicit-grant/#implementation. I'm happy to merge this if you could please remove the disabling of the check. . Actually ignore my comment about disabling the check.\nInstead I'd be happy with an API that looks something like this:\nphp\n$privateKey = new CryptKey('file://path/to/private.key', 'passphrase');\n$privateKey->acknowledgeIncorrectKeyPermissions(); // this disables the check\nWith regards to the 600 permission I'm also happy to see 600 or 660 as a valid file permission.. Okay I will re-evaluate the acknowledgeIncorrectKeyPermissions.\nPlease can you address the comments I've made on the commit and I will merge this PR.. @yannickl88 see my comments in line here https://github.com/thephpleague/oauth2-server/pull/776/files. Apparently not.... Thanks for submitting this \ud83d\udc4d . I\u2019m going to need your help to debug this as I have no access to a Windows server system. You\u2019ve not specified any details about the version of PHP your using, which Windows you\u2019re using, etc.\nPlease open a new ticket that clearly expalins the issue for Windows users.. The check can be disabled https://github.com/thephpleague/oauth2-server/blob/master/src/CryptKey.php#L34. I think this is an issue with your setup not with the library; I'm not aware of any loops in the library that can cause memory exhaustion.. @Sephster I've still not seen any evidence this is an issue with this library and is instead a Passport issue. When a new access token is issued a new refresh token is issued.\nWhen an access token expires the corresponding refresh token won't expire (at least not immediately).\nWhen a refresh token is exchanged for an access token, the refresh token used as well as it's corresponding access token are expired, and a new access token and refresh token are issued.\nI hope that helps.. You need to modify your provider to send an Authorization code header not the access token in the query string. Please open an issue with https://github.com/thephpleague/oauth2-client for help with this.. I\u2019ve added a reference to myself back in but am \ud83d\udc4d on the change.\n@bretterer @Sephster @simonhamp please leave the copyright notices on existing files (am happy for @author blocks to change naturally over time). Let\u2019s discuss amongst ourselves how to copyright new files.. I\u2019ve thought about this for a while and I\u2019ve come to the conclusion that removing nbf and keeping iat is the best solution.\nI\u2019ve had situations whereby I\u2019ve needed to perform custom logic on tokens issued before or after a certain time so iatis useful to have.\nRemoving nbf will fix the described issues about drift.. Agreed. Have merged this because the OAuth 2 spec does allow for an alternative to the fragment hash.. Hi @juouy \nThe tokens are long because they are JWT tokens. This allows all the information needed to validate the token and determine the user who owns the token and the permissions granted without requiring a database query. This is really powerful and useful as your service grows.\nThe best thing you can do is use HTTP 2.0 which automatically compresses HTTP headers and will therefore reduce the amount of data sent between the app and the server significantly. See this blog post for more information - https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/.\nI hope that helps. As @Sephster suggested either have a shared client ID or subclass the RefreshTokenGrant class and override the problem method to suit your usecase.\nThe emitted event can be used for auditing purposes (which might result in blocking bad clients/tokens/etc). @sephster my understanding of 3.3 of the spec is that if the request contains no scopes and there are no scopes defined on the default scopes array then the request would be valid still. Access tokens are for more than just authorisation in my opinion, they can represent a verified identity too - this is the case for our JWT tokens which embed the user's ID in the sub claim.\nIMO if there are no scopes in the request, and the default scope on the auth server is no scope then this is valid as the access token still has value in terms of the entity identified.. This is due to the .gitattributes folder so that it isn't downloaded when it's pulled in via Composer.\nPlease git clone the project. Valid point \ud83d\udc4d . So the actual fail point is when the canRespondToAuthorizationRequest method is checked on the  auth code grant.\nPresently this requires both the response_type query parameter to equal code and the client_id parameter to be present.\nThis line of code was written almost two years ago and I can't remember why I added the client_id parameter check. It might be overly strict but then it might be because the OAuth spec requires the client_id property for this grant type to be valid.. @amidia take a look at https://alexbilbie.com/guide-to-oauth-2-grants/ it might help. Not all implementations of grants have clients that have either a secret or are confidential.\nThe interfaces are kept purposely small to reduce conflict with implementation entities (such as Doctrine entities).\nI hope that helps. Thanks!. Thanks!. I will look shortly\u00a0\u2014\nSent from my iPhone\nOn Tue, Jun 3, 2014 at 2:40 PM, Woody Gilk notifications@github.com\nwrote:\n\n\n@@ -0,0 +1,19 @@\n+<?php\n+/**\n- * OAuth 2.0 Missing Access Token Exception\n  whoops, just noticed this was duplicated.\n\nReply to this email directly or view it on GitHub:\n  https://github.com/thephpleague/oauth2-server/pull/178/files#r13334160\n. I've just noticed that session_id should be an integer, could you change that too please?\n. I think this method should be called setRefreshTokenRotation\n. And this method should be called shouldRefreshTokensRotate\n. Previous versions provided a fluent interface so yes I guess so\n. Nope, will fix\n. Yes\n. For the sake of readability sure\n. The SecureKey class has always been overridable using:\n\n\nphp\nSecureKey::setAlgorithm(KeyAlgorithmInterface $algorithm);\nAs to how discoverable that is due to lack of documentation is another question...\n. It isn't, you either have whitelisted clients or you don't. And this library only supports whitelisted clients for the sake of best practise out of the box.\n. Yep, handles as expected - anything listening to the event is executed, then the exception is thrown.\n. Fixed\n. I can't think of a reason why to not do this, good point\n. Yep\n. See for original intention for events here http://oauth2.thephpleague.com/authorization-server/events/\nI've not looked at these again yet. I'm still in the refactoring to the new setup phase.\n. It doesn't matter for now, it's just a quick and dirty implementation to help me out for now. Future examples will use a DB as the storage medium.\n. See https://github.com/firebase/php-jwt#200--2015-04-01\n. Only thing against https://github.com/lcobucci/jwt that I can see without playing with it is that it requires PHP 5.5\nThen again if you're thinking about security (hence installing this library) then you should be running the latest version of PHP\n. 3600 seconds is excessive. I'd change it to 300 to allow for 5 minutes instead\n. Why was this change made?\nThe grant should always be injected in so the implementation can decide if the client is permitted to use the grant type\n. $grantType will always be set though and as per PSR2 \"Method arguments with default values MUST go at the end of the argument list.\"\nV5 is still work in progress and I'm slowly updating old code so there may be out of date docblocks\n. Client secret will be null in the case of authorization part of auth code grant\n. Client credentials grant doesn't support refresh tokens so this might be confusing\n. Please change this to use === false instead of !. Please change parameter to $keyPermissionsCheck. Please use the explicit form of if ($keyPermissionsCheck === true). ",
    "spydr": "Sorry for confusing you, what I mean is getting the token without the need for redirect_uri like in this case: http://tools.ietf.org/html/rfc6749#section-4.3 where only the grant_type , username, and password are required\nI know the library supports that but I doubt if redirect_uri is optional.\n. Yes the password grant. I just test if it supports the password grant, unfortunately it requires redirect_uri which in fact in such grant there are only 4 parameters namely: grant_type, username, password, and an optional scopes.\nBasically what I'm trying to achieve is I have an app (trusted of course) with username and password input fields and when user clicks the button, the app will send a post request (curl or whatever) with ONLY username and password (aside from scopes which by default all scopes are granted) of the client to get the token.\n. Much appreciated, thanks.\n. ",
    "MichaelGooden": "This appears to be in the master branch and latest tagged versions, so this issue should be closed.\n. Added additional fix.\n. My apologies, my RFC spec parser is faulty.\n. 2) to call a public method on an already instantiated object, you should be\nable to pass array($myObject, 'methodName') as the callback.\nSent from my BlackBerry\u00ae PlayBook\u2122\nwww.blackberry.com\n\nFrom: \"jackshakes\" notifications@github.com\nTo: \"php-loep/oauth2-server\" oauth2-server@noreply.github.com\nSent: 26 September 2013 4:49 AM\nSubject: Re: [oauth2-server] Resource Owner Credentials Grant - Process\nFlow (#97)\nI was able to get the password grant working with this information. Thanks!\nTwo additional questions:\n1) @suwardany https://github.com/suwardany mentioned calling the\n\"completeFLow\" method. I didn't seem to need to do that. Can you go in to\ndetail on when this would be used? I noticed issueAccessToken() calls this\nalready.\n2) To get the callback function to work, I either had to make it a function\noutside of a class object, or make it a static function inside a class\nobject. Is there a way to reference a callback function that is a public\nmember of a class without making it static?\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/php-loep/oauth2-server/issues/97#issuecomment-25140475\n.\n. ",
    "jfse": "Are you sure about this?\nIt seems to be a common misconception that \"b64token\" implies base 64 encoding, which it does not.\nI found several mentions of this on their mailing list:\nhttp://www.ietf.org/mail-archive/web/oauth/current/msg08485.html\n. I think @jacobweber is correct here, this should be removed for all grant types.\nBasic example: you have an android application, it uses a certain client id. If a user has a mobile phone and a tablet he would be unable to login to both devices unless they use different client ids. This is a common thing I would think, even having 2 android mobile phones is not entierly unheard of.\nAs it is today, if you login to one device your tokens for the other would be removed.\nSome way to clear old sessions are necessary though, but it would need to make sure there are no valid tokens associated with them first as stated by @michaelhogg above. For myself I would write a cronjob to clear these, but it might be a good idea to have this functionality available in the repository in some way.\n. This fixes https://github.com/thephpleague/oauth2-server/issues/180, thank you!\n. ",
    "lapause": "The answer found by @jfse seems pretty straight-forward:\n\nOn casual reading of \"The OAuth 2.0 Authorization Protocol: Bearer\nTokens\"* I've encountered several people (including myself) who have\nmade the assumption that the name b64token implies that some kind of\nbase64 encoding/decoding on the access token is taking place between\nthe client and RS.\nDigging a bit deeper in to \"HTTP/1.1, part 7: Authentication\"**,\nhowever, I see that b64token is just an ABNF syntax definition\nallowing for characters typically used in base64, base64url, etc.. So\nthe b64token doesn't define any encoding or decoding but rather just\ndefines what characters can be used in the part of the Authorization\nheader that will contain the access token.\nDo I read this correctly?\n\nYes.\n. I concur with @ziege. Those usecases are quite common with OAuth, and updates described in #20 & #21 seem to me more good practice than hacking.\n\n\nIt's not about cluttering the library with a bunch of methods rarely used, just to think about possible advanced checks and extend parameters/return values in interfaces accordingly.\nIt does not complexify their implementation, and API requiring advanced permission controls could be developped without forcing the programmers to extend half the library classes.\nAs this library is one of the cleanest and most up-to-date implementation of OAuth 2 in PHP, it really should not miss an opportunity to support (not implement) out-of-the-box advanced usecases.\n. Thanks!\n. You're welcome, thanks for the quick merge.\n. I think the library should be kept light and those cases handled by developers.\nIMO, what library should do is provide to the storage interfaces methods the maximum useful information so that security limitations could be implemented there. Sample usages can be provided to developer in the interfaces inline doc.\nHere is what I would do:\n- In the Grant classes completeFlow() methods, grab the scopes early (by the way, maybe use a getScopes( array $scopes) method in the ScopeInterface rather than a getScope() one, to allow developer to grab multiple scopes in one request and eventually make cross checks (e.g forbidding the usage of a scope with another). Pass an optional grant type to this method to allow scopes/grants limitations\n- Pass the grant type used and the detail of requested scopes in the ClientInterface::getClient() method, to allow clients/grant and clients/scopes limitations\n- Pass the client details in the verifyCredentialsCallback function of the password grant type, to allow users/clients limitations\nWhen I say 'details' in the points above, it's about passing the complete array received from getClient() or getScope(), not just the ID. Without that, it would force the dev to grab complementary information again, multiplying DB requests.\n. ",
    "wdJer": "I just know, that this is not an issue of the library!\nHow you implement this in your code-base has nothing to do with the OAuth2 provider library itself.\nThis part is actually from CodeIgniter so I do not see where the issue is.\nJust to be clear.. this is not a discussion forum about concret implementations of the library.\n. ",
    "ziege": "I generally know what you mean, but how do you get the required information \"using existing functions\"?\nIf you use the Client Credentials Grant you can get the client id from the parameters, okay, but if you use the Password Grant, the user login (where you get the user id) is done directly before the scope check and there is no chance to get it - so I would not only have to check all parameters again in my scope class, but also do the login and other checks a second time. \nThis could be avoided by the extension - and the existing functionality would not be influenced as the additional parameters don't have to be used.\n. I will answer to the mentioned points later, but first want to add a fifth one:\n- [x] Access token expiration time dependent of used grant type\nas mentioned in http://tools.ietf.org/html/rfc6749#section-1.5, Refresh Tokens:\n\"access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner\"\n. @alexbilbie Yes, I thought so too, but that's not secure (at the moment). You need to add the Refresh Token Grant to the allowed grant types to get the \"refresh_token\" returned in the response. This allows the client to generate a new token using \"/access_token_normal\" and bypass the limitation in \"/access_token\".\nThis could be fixed if one could differ between \"allow creating a token using the Refresh Token Grant\" and \"return a refresh token\".\n. I see a need for all the listed features, and I think that the implementation should be as easy to use as possible, but it should also be \"secure by design\". For me this always means using a whitelist, not a blacklist.\nIn my opinion the developer is responsible for this. The library should not directly handled these extensions, it only needs to offer an easy way to implement them, e.g. see my proposal for the extension of the getScope method - all you need is some additional information. This would keep the implementation as easy as it is now, but would allow to extend it.\nThe first three points could be solved by extending the ClientInterface and the ScopeInterface by the following information (or allow another way to access it):\nScopeInterface::getScope:\n- client_id\n- owner_id (user_id, client_id,...)\n- grant_type\nClientInterface::getClient:\n- grant_type\nGenerally it would be good to give (read) access to as much relevant information as possible, to allow the implementation of other checks.\nFor point 4 I would add a column to the session table (or think about the general session table structure, regarding #25 and the problem with multiple valid tokens and the invalidation/deletion of old ones).\n. @alexbilbie I will try to explain it with an example:\nI want to use the Client Credentials Grant and I also want to use refresh tokens. I request my access token using the URI \"/access_token\". To get the access token and the refresh token, I need to activate the Client Credentials Grant - but also the Refresh Token Grant, because otherwise no refresh token will be returned. The expiration time of the access token is set to 86400 seconds.\nNow I can create a second script \"/refresh_token\" to get a new access token with the refresh token I got before. There only the Refresh Token Grant is active, and its expiration time is set to 3600 seconds.\nNow the problem:\nI can bypass the expiration time limitation by requesting a new token with the refresh token at \"/access_token\" instead of \"/refresh_token\", because the Refresh Token Grant is required to be active in both cases.\nSolutions:\n1) Bind the expiration time to the grant type (would avoid insecure implementations like the one mentioned in the example, and avoid the need of two scripts where one could do the job). The setExpiresIn() method could be moved from the AuthServer to the GrantTypeInterface.\n2) Or offer an option to add the refresh token to the response, although is not added to the allowed grant types (more difficult to understand, could lead to errors and security problems in the implementation).\n. The problem is, that point 1 depends on point 2 - you have a set of allowed scopes and can reduce them, but after that you won't have the chance to create a new access token with the original scopes. You need to keep it saved or the client will only have two options - always use full rights (insecure) or ask the user again for his credentials (bad idea).\nI tried to understand point 2 and checked the Google implementation. They do it as expected: It's possible to create multiple access tokens using the refresh token (they say that the number of tokens is limited, which is a good idea). You only get a refresh token with the main access token request and this can theoretically stay in the database forever (independent of the expiration time).\nI don't think it's too difficult:\n1) Create an \"normal\" access token and refresh token. -> One entry in the session table.\n2) Create a new access token using the refresh token. -> An additional entry in the session table, possible with the current table structure. You only have to call the \"createSession\" method and leave out the \"deleteSession\" method. The only problem is, that you create multiple sessions and - as far as I understand it - the access tokens generated with the refresh token should depend on the main access token - so they should share the same session id.\n3) Destroy all access tokens when a \"normal\" access token is generated. -> Automatically done with \"deleteSession\".\nBUT I would propose a general correction of the table structure to avoid the mentioned problem and to make it a bit clearer, easier to implement/customize and optimize the performance:\n1) Use one main session table with all basic data (without fields that are only required by special grant types you perhaps never use).\n2) Add tables for the fields used by special grant types. So you only create an entry if you have data and avoid the massive use of NULLable columns (which isn't a good idea from the performance view). You can even delete the tables, which are not required for the own implementation.\n3) For the library the changes would be minimal - as far as I can see, only the call of \"associateScope\" would have to be changed, because it's not bound to the session id, but the generated access token.\nI can work on that and provide optimized scripts for the database - MySQL, SqlServer, Oracle, and perhaps Postgres (learning at the moment) - and a Session class for your server example.\nAttached an optimized structure, as I would propose it. I'm not sure about the roles of the fields \"stage\", \"first_requested\" and \"last_updated\". Are they really required? If so, only for specific scopes?\n[Old structure replaced by new one, see next comment]\n. I optimized the structure again and created a test implementation. \n\nThe Refresh Token Grant now works as expected and theoretically it's not necessary to change the scripts - I only had to rename some parameters (because the session id is now the session token id in some cases) and this renaming should be done also in the grant scripts.\nI'm still not sure about the role of the \"stage\" field. Currently it seems to be really used with the Auth Code Grant only... \n. I just sent you the DB structure and a Session Storage example via mail.\n. I just found another problem with the current implementation:\nRFC, section 1.5:\n- \"Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens with identical or narrower scope\"\nRFC, section 6:\n- \"The authorization server MAY issue a new refresh token, in which case the client MUST discard the old refresh token and replace it with the new refresh token.\"\n- \"The authorization server MAY revoke the old refresh token after issuing a new refresh token to the client.\"\n- \"If a new refresh token is issued, the refresh token scope MUST be identical to that of the refresh token included by the client in the request.\"\nI modified the Session Storage script (sent to you via mail) to handle the creation of new refresh tokens in accordance with the RFC, but the flow of Refresh Token Grant class also needs to be modified.\nThe Refresh Token Grant must differ between two cases - issue a new refresh token when a new access token is created, or not. This defines the further steps in the flow and the possibilities on the client side. Therefore it must be possible to define the preferred behavior for this Grant:\nRefreshToken::useRefreshTokenRotation(true|false)\nIf TRUE:\n- Return error, if scope parameter set (or if it's not identical to the prior scope).\n- Check credentials and refresh token.\n- Create a new access token.\n- Revoke the old refresh token (as the client MUST replace it anyway in this case).\n- Create a new refresh token.\n- Return the access token and the refresh token.\nIf FALSE:\n- The scope parameter is optional and can be used to limit the prior scope. If not set, the prior scope is used.\n- Check credentials and refresh token.\n- Create a new access token.\n- The old refresh token remains valid.\n- Return the access token only.\n. I updated the DB structure and the Session Storage class once again, due to the following points...\nSecurity problems:\n1) \"A maximum authorization code lifetime of 10 minutes is RECOMMENDED.\" (RFC, section 4.1.2.) This is not implemented at the moment (could be perhaps handled using the current timestamps, but then it should be renamed and moved to the auth code table). I moved the timestamp and renamed it, so it's purpose is a bit clearer. And I also added the necessary checks to the Session Storage Example.\n2) \"The client MUST NOT use the authorization code more than once. If an authorization code is used more than once, the authorization server MUST deny the request and SHOULD revoke (when possible) all tokens previously issued based on that authorization code.\" (RFC, section 4.1.2.) This is not implemented at the moment. To detect multiple usages of the auth code it must not be deleted. Also the DB structure was missing an assignment of issued tokens to the auth code - to invalidate them as described. (This assignment also replaces the previous \"stage\" field, because an existing assignment means \"granted\".)\nOther problems:\n1) As a result of the Client Credentials Grant correction (no refresh token allowed), it wasn't possible anymore to create multiple valid tokens with this grant (which is required if you want to access different resource servers with only the required scope for security reasons). I modified the table structure (removed unique key in oauth_session) and the Session Storage script to allow this.\n2) There was an error in the Auth Code handling in the last version of my Session Storage class.\nMy changes in the Session Storage class:\ncreateSession\n- [x] removed stage parameter (only used for Auth Code Grant and solved more securely, see below); change of the SessionInterface required\n- [x] removed saving of timestamps (not required, can be done in customized implementations if needed)\n- [x] added expiration time for auth code (as recommended in RFC); change of the SessionInterface recommended\nupdateSession\n- [x] removed unnecessary parameters (\"authCode\", \"stage\"); change of the SessionInterface required\n- [x] removed the updates of the timestamps in the session table\n- [x] corrected the handling of the auth code entry (error in my previous script)\n- [x] added assignment of the generated token to the auth code entry (required for security reasons when validating the auth code)\nvalidateAuthCode\n- [x] check for codes added, that have been already used\n- [x] added deletion of previously issued tokens, for the case that the auth code is used multiple times (important security feature)\n- [x] check for expired auth codes added\ndeleteSession\n- [x] differ between the owner type to delete only expired sessions when the Client Credentials Grant is used.\nI sent you the updated files via mail...\n\n. How do you define \"If the server can't handle the presented token\"? \nFor security reasons, the server should respond with status 200 if the token is invalid, so what does handle mean in this case? I would define it as \"If the server can't handle the presented token type\", e.g. if the server only revokes refresh tokens but not access tokens (as mentioned in point \"2.1. Revocation Request\"). \nSo if the token type is not set, always return status 200. If the token type is set and generally supported (no matter if found or not), return status 200. Only if the token type is set and not supported, return an error (and status 400?).\nWhy is the client_id/client_secret optional? \nIf you don't check the client access, everyone could send token revoke requests and \"launch denial of service attacks on the authorization server\". In point \"6. Security Considerations\" it's mentioned as required: \"According to this specification, a client's request must contain a valid client_id, in the case of a public client, or valid client credentials, in the case of a confidential client. The token being revoked must also belong to the requesting client.\"\nSo the client must always be authorized for the token revocation.\nAlso important for the implementation:\n\"If the particular token is a refresh token and the authorization server supports the revocation of access tokens, then the authorization server SHOULD also invalidate all access tokens based on the same authorization grant.  If the token passed to the request is an access token, the server MAY decide to revoke the respective refresh token as well.\"\n. In #25 I proposed a similar change for the deleteSession method: \"differ between the owner type to delete only expired sessions when the Client Credentials Grant is used.\"\nPerhaps this needs to be done for all grant types? I couldn't find anything in the RFC that doesn't allow this behavior. This is already possible and depends on your implementation of the Session Storage, but should be default I think.\n. To 1) Okay.\nTo 2) Yes, that's possible, but not the best practice.\nTo 3) I saw you changed it, but there is another one: session_token_scope_id\nTo 4) The names were created using the table name and the used column names, and these aren't up to date. That's not important but helps to avoid naming conflicts.\nTo 5) The fields are: \"access_token\" in \"oauth_session_access_tokens\", \"auth_code\" in \"oauth_session_authcodes\", \"redirect_uri\" in \"oauth_session_redirects\", \"refresh_token\" and \"client_id\" in \"oauth_session_refresh_tokens\". All default to an empty string '', which is equal to NULL in some DBMS, but as they are also NOT NULL, this default value would not be possible. I think all fields should always be filled, so simply removing the default would fix it.\nTo 6) In Postgres this would not be a problem, because Postgres supports arrays, but MySQL and other DBMS don't. Saving the data as a string is a bit easier, right, but it has many disadvantages:\n- You are not able to use foreign keys, to protect from invalid data. If a scope is deleted or changed, foreign key constraints would update the data for the authcode - saved as a string this would probably result in an error.\n- You don't know how long the string can be - you have to use field types which allow a big amount of data (about 600.000 bytes with the current structure), and fetching theses data would be more expensive for the database. The current CHAR field is the worst variant - uses a lot of space and result in errors very soon. Saving the data in a sepparate table would save disk space in most cases and avoid errors (about the same disk space if TEXT used, but it would be more efficient).\n- You don't have the possibility to extend these data later, because they depend on your own, special format.\nAlso with 20 scopes it's only one insert, because you can insert multiple entries with one query (http://dev.mysql.com/doc/refman/5.5/en/insert.html) - as far as I know, only SqlServer < 2008 doesn't support this. And you can also get all data with one query.\nsql\nSuggestion (not tested):\nCREATE TABLE `oauth_session_authcode_scopes` (\n  `session_id` int(10) UNSIGNED NOT NULL,\n  `scope_id` smallint(5) UNSIGNED NOT NULL,\n  PRIMARY KEY (`session_id`, `scope_id`),\n  CONSTRAINT `f_oaseausc_seid` FOREIGN KEY (`session_id`) REFERENCES `oauth_sessions` (`id`) ON DELETE CASCADE ON UPDATE NO ACTION,\n  CONSTRAINT `f_oaseausc_scid` FOREIGN KEY (`scope_id`) REFERENCES `oauth_scopes` (`id`) ON DELETE CASCADE ON UPDATE NO ACTION\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\nTo 7) You can have multiple auth codes with different scopes - we discussed about this earlier I think (example where you have one client and one auth server, but several resource servers where you want to connect to using different scopes). That's why I split the session and the auth codes in the table structure. The RFC indirectly mentions this, because there it's possible \"to obtain additional access tokens with identical or narrower scope\" using refresh tokens. \nHope this helps.\n. I think the check you added for #43\nphp\nif ($this->authServer->scopeParamRequired() === true && $this->authServer->getDefaultScope() === null && count($scopes) === 0) {\nneeds to be changed, because you can also have an enpty string or empty array or better: check the value in \"setDefaultScope\" and keep the null if empty.\n. I think the change of the default value for \"requireScopeParam\" to false is not correct.\nIf I call \"requireScopeParam\" I would expect by the name of the method that it's set to true by default.\n. The automatically generated foreign key names you used in your changes exceed the maximum length for foreign keys in other DBMS (as far as I can remeber it's 30 characters in Oracle). Of course this can be changed in the Oracle script only, but I think the naming should be the same in all databases.\n. No problem. My offer to check the database structure and prepare it for other DBMS is still valid... but first the basic structure needs to be clear. At the moment I use it with Postgres (and it works great). And I have the possibility to test it with SqlServer and Oracle (which I don't use personally).\n. I had a look at it and I plan to integrate several changes into the dev version:\n- Several foreign key and index updates\n- Table renaming (to make the table structure clearer and the names shorter for better compatibility)\n- Some column renaming (belongs to the previous point)\n- Remove unnecessary column\n- Update the table script for MySQL\n- Add table script for Postgres\nOkay?\n. I just added the mentioned changes. Other SQL scripts will follow later...\n. Sorry, didn't had the chance to answer earlier. You are right, you should only have one Auth Code and delete all previous ones - I think I mixed this with multiple Access Tokens.\n. I already mentioned this and checked the RFC for the correct behaviour some time before (and this is also important for allowing multiple access tokens). Here again what I wrote:\nThe Refresh Token Grant must differ between two cases - issue a new refresh token when a new access token is created, or not. This defines the further steps in the flow and the possibilities on the client side. Therefore it must be possible to define the preferred behavior for this Grant:\nRefreshToken::useRefreshTokenRotation(true|false)\nIf TRUE:\n- Return error, if scope parameter set (or if it's not identical to the prior scope).\n- Check credentials and refresh token.\n- Create a new access token.\n- Revoke the old refresh token (as the client MUST replace it anyway in this case).\n- Create a new refresh token.\n- Return the access token and the refresh token.\nIf FALSE:\n- The scope parameter is optional and can be used to limit the prior scope. If not set, the prior scope is used.\n- Check credentials and refresh token.\n- Create a new access token.\n- The old refresh token remains valid.\n- Return the access token only.\n. That's basically right, but there is one special case, when token rotation is activated and the scope is limited at the same time - this leads to the following problem:\n1) Initial access token with scope 1, 2 and 3.\n2) New access token using the refresh token, with new scope 1 and 2.\n3) The refresh token MUST be replaced on server side and on client side.\n4) If you now want to get a third access token, you can only get one with the scopes 1 and 2 - scope 3 is lost forever. And this violated the RFC, because the \"scope originally granted\" cannot be returned anymore.\nI think this can be solved by \n- ignoring the scope completely, when token rotation is activated, \n- deactivate token rotation for requests with scopes set,\n- or returning an error\n. I also thought about it and I think this is a problem of the dtabase structure:\nThe scopes depend of the access token, which is correct, But you can hve multiple access tokens and I think it is also possible, that an old access token is deleted, while the session itselt and the refresh tokens are still valid. This could lead to a sitiuation where you cannot get the original scope anymore. \nI think we need to save the original scope for the session in an additional table, just for re-creating them (so only if we create a refresh token). This would make the scopes independent from the access token an you would be able to always rote tokens and limit scopes, also at the same time.\n. Yes, will post it again. (I tried it several times using the edit function, but Github always gave mit 404 errors... Don't know what the problem was...)\n. Where is the access token defined as a range of UTF-8 characters? The communication is done in UTF-8, but in RFC6750 the Bearer token is defined as follows:\nb64token    = 1*( ALPHA / DIGIT /\n                   \"-\" / \".\" / \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"\n credentials = \"Bearer\" 1*SP b64token\nSo the old version was okay, but you are right with only one space character after \"Bearer\".\nSome additional suggestions/questions:\n- The regular expression can be further optimized.\n- Why throw an exception when an empty access token is set. Isn't an empty access token an invalid one, which is already handled?\nThe code can be optimized again:\nphp\nif (strpos($header, ',') !== false) {\n    $headerPart = explode(',', $header);\n    $accessToken = preg_replace('/^(?:\\s+)?Bearer\\s/', '', $headerPart[0]);\n} else {\n    $accessToken = preg_replace('/^(?:\\s+)?Bearer\\s/', '', $header);\n}\nBTW: The foreach came in, because I wasn't sure which part to use - later I realized that it's always the first one in this case. And I couldn't find a reason why anyone should send multiple authorizations in other cases!? So the foreach was unnecessary, right.\n. Okay, but you use Bearer tokens, and this token type is limited to the characters mentioned before. And Bearer tokens is what's checked here... For other token types we need another check.\n. Oh, I forgot your trim change - in normal cases it's really unnecessary, but I think we have to be careful with headers, because they are send by different clients, forwarded and changed by servers,... see the cURL problem.\nSo I would add the trim again, e.g. for the following cases:\n\"Authorization: Bearer  XXX\"\n \"Authorization: Bearer XXX \"\n \"Authorization: Bearer XXX , Bearer XXX\"\nAnd this isn't a problem, as the Bearer token doesn't allow spaces (or better: space characters).\n. Oh no, that brings us back to the following bug:\nAuthorization: Bearer hDkBearerGndKSfs2as\nwould become\nhDkGndKSfs2as\n= invalid token\n. Oh, never used this parameter before... better than the regexp. :)\n. Overview of the new structure:\n\n. I cleaned up the structure, because some table name got a bit long for some DBMS (and because of inconsequent renaming). I haven't tested it yet, but as far as I know this should also work for SqlServer and Oracle now, without bigger changes.\nSome little problem I see:\n- the sequence handling, which often depends on the DBMS (e.g. in Postgres you need to set the name of the sequence to use)\n- the escaped table and column names in your script (which differs in other DBMS) - I didn't want to change that, because of the possible use of keywords as colum names.\n- in Postgres all tables are in a special schema \"oauth\", which has to be added to the table and sequence names\nI think it's difficult to support all combinations of DB layer and DBMS, because each would result in an own version, and this can be hard to keep up-to-date... Database table name constant would fix only some of the problems.\nI'm using DbWrench: http://www.dbwrench.com - In this case I used the export function, but the table structure is saved as XML and can be easily imported in PHP and used to automatically generate scripts for different databases and database versions/editions. I already wrote a tool to do this, but at the moment it's optimized for a special project and cannot be used here...\n. Yes, that's right. And most queries are basically the same.\n. ",
    "fkarlsson": "Then where is the problem in my implementation? I use the ruby gem oauth2 to test my setup and no matter which secret I input it works. Do I need to change the grant_type that I send?\nEdit: Did not see your edit! Alright, so the problem with my implementation is my getClient function which never checks for the secret. I made this mistake as it was never included in the oauth2-example-auth-server.\nThanks for the help and most of all for a great library!\n. ",
    "RealitysSuccessor": "Thanks\n. ",
    "bp1222": "I don't like the notion of the library supporting forced revocation, directly.  Revoking to different people could mean different things\nOn one hand, revoke = purge access-token with a long expire date from the DB.\nAnother, revoke = Flag access-token with long expire, to not be valid, but remain for historical purpose.\nI'm being crazy, where access tokens aren't ever purged, but are retained to the session, which is retained to the client.  In my implementation tokens are only valid once in a time of 10 seconds, but remain in the DB.  Even after refresh.  I can look to a client, and see history.\nPoint is, this is a user decision, and I'd like it kept that way.\n. Mostly because, as you have the client implementing your AuthServer can dictate how long the TTL is, why would we not let them dictate how long a Refresh Token can exist before needing a refresh itself?\nMy only thought-case here would be someone who would like to issue refresh tokens after 1 day of issuance, and another who would rather refresh after 6.  Personally, I would rather let that be up the client, rather than being an all or nothing.\n. Ok, changed it to be a boolean that you can enable/disable that will drive the re-issuing of the refresh token.\n. Done.\n. Sorry bout that, remembered reading that in the contribute file.  There we are.\n. Feel free to take this pull, or not, with rejection of implicit grant I am going to have to utilize another oauth-server which will support the basic OAuth2 grant types.\n. Neat.\nHowever, we generally have a hard time getting approval to wrap our own additions around a library when upstream rejects.  Even if you were to say, wrap the implicit with a defined('YES_I_KNOW_THIS_IS_GENERALLY_INSECURE') or something, so an implementor would have to go out of their way to enable it would be a boon.\n. @alexbilbie  hate to be \"that guy\" but, ping\n. I should note, that this change does expect the implementation of the Storage container to anticipate you might get an associate request for a scope that already exists.  For an RDBMS you could use replace rather than an insert.  For other types of storage, you would need to handle accordingly.\n. @alexbilbie hate to be \"that guy\" but, ping\n. Not sure what you mean here.\nGranted, this is just a copy-paste extension from another test.  But I'm asserting that we are returning a refresh_token, regardless of my main change.  Then the different applies with the assertNotEquals, and assertEquals,, where we see the refresh_token coming out of the issueAccessToken()\n. That's what I kind of assumed.\nI wasn't sure y'all desire to have mixed-methods.  As the $this->assertTrue(..) method is used in all your other tests.  Wasn't sure if using the $this->assertArrayHasKey(..) would have been desired.  I can change, if needed.\n. ",
    "auro1": "@bp1222 I'm sure this would be implemented as optional.\n. ",
    "ganey": "If you verify the token you can then expire it with the AccessTokenEntity class.\n\\League\\OAuth2\\Server\\ResourceServer->getAccessToken()->expire();\nExpire does the following:\n```\nnamespace League\\OAuth2\\Server\\Entity;\nclass AccessTokenEntity extends AbstractTokenEntity\n{\n  ....\npublic function expire()\n  {\n    $this->server->getAccessTokenStorage()->delete($this);\n  }\n```\nEdit: I haven't checked to see if this affects any Refresh Tokens\n. ",
    "heisian": "i'm surprised there's not a more explicit revocation interface outlined for this.\ni was attempting to use Laravel's softDeletes trait (deleted_at) column b/c I want to maintain a history of sessions and tokens, as opposed to deleting the record entirely...\nwhat about sessions?  I would like to be able to invalidate an entire session as well, cascading the results to their child tokens..\n. I think I'm onto something here...\nIn the examples included with this repo you can set a custom Storage provider:\n```\nclass CustomOAuth2ServerServiceProvider extends ServiceProvider\n{\n...\npublic function registerAuthorizer()\n{\n    $this->app->bindShared('oauth2-server.authorizer', function ($app) {\n        $config = $app['config']->get('oauth2');\n        $issuer = $app->make(AuthorizationServer::class)\n            ->setClientStorage($app->make(ClientInterface::class))\n            ->setSessionStorage(new \\App\\ExtensionsOAuth\\SessionStorage())\n            ->setAuthCodeStorage($app->make(AuthCodeInterface::class))\n            ->setAccessTokenStorage($app->make(AccessTokenInterface::class))\n            // ->setAccessTokenStorage(new \\App\\ExtensionsOAuth\\SessionStorage())\n            ->setRefreshTokenStorage($app->make(RefreshTokenInterface::class))\n            ->setScopeStorage($app->make(ScopeInterface::class))\n            ->requireScopeParam($config['scope_param'])\n            ->setDefaultScope($config['default_scope'])\n            ->requireStateParam($config['state_param'])\n            ->setScopeDelimiter($config['scope_delimiter'])\n            ->setAccessTokenTTL($config['access_token_ttl']);\n\n...\n```\nAnd it seems like alls I need to do is add another condition to filter out deleted_at columns:\n```\n<?php\nnamespace ExtensionsOAuth;\nuse Illuminate\\Database\\Capsule\\Manager as Capsule;\nuse League\\OAuth2\\Server\\Entity\\AccessTokenEntity;\nuse League\\OAuth2\\Server\\Entity\\AuthCodeEntity;\nuse League\\OAuth2\\Server\\Entity\\ScopeEntity;\nuse League\\OAuth2\\Server\\Entity\\SessionEntity;\nuse League\\OAuth2\\Server\\Storage\\AbstractStorage;\nuse League\\OAuth2\\Server\\Storage\\SessionInterface;\nclass SessionStorage extends AbstractStorage implements SessionInterface\n{\n    /*\n     * {@inheritdoc}\n     /\n    public function getByAccessToken(AccessTokenEntity $accessToken)\n    {\n        $result = Capsule::table('oauth_sessions')\n                            ->select(['oauth_sessions.id', 'oauth_sessions.owner_type', 'oauth_sessions.owner_id', 'oauth_sessions.client_id', 'oauth_sessions.client_redirect_uri'])\n                            ->join('oauth_access_tokens', 'oauth_access_tokens.session_id', '=', 'oauth_sessions.id')\n                            ->where('oauth_access_tokens.access_token', $accessToken->getId())\n                            ->where('deleted_at', NULL)\n                            ->get();\n    if (count($result) === 1) {\n        $session = new SessionEntity($this->server);\n        $session->setId($result[0]['id']);\n        $session->setOwner($result[0]['owner_type'], $result[0]['owner_id']);\n\n        return $session;\n    }\n\n...\n```\ngonna give it a shot..\n. I agree, but would actually prefer the client_secret to pass a hash check such that an HMAC-signed version of the client_secret is checked on the server.  That way client_secret needs not be passed.  I would say this is important for the client_credentials grant as well.\n@alexbilbie Yes OAuth2 is the latest standard, what these people are saying in this thread is that the standard has been updated.\n. ",
    "jacobweber": "Is there a reason not to do this in the Auth Code and Implicit grants as well?\n. Also, there doesn't seem to be anything corresponding to getGrantType('authorization_code')->checkAuthoriseParams() for implicit grants. Should we continue calling that, even though it's on the wrong class?\n. That's what I've been using -- I just didn't realize that it was untested.\nI'm using it because my client is a JavaScript app, with no server. So there's no place to store a \"client secret\". My understanding is that implicit grants are the way to go with browser-only apps.\n. Yes, I have it working. I use getGrantType('authorization_code')->checkAuthoriseParams().\n. Basically, at the point where the example generates an authorization code, I do something like this:\njavascript\nif ($params['response_type'] === 'code') {\n    // Generate an authorization code\n    [...]\n} else if ($params['response_type'] === 'token') {\n    $params[\"grant_type\"] = \"implicit\";\n    $response = $server->issueAccessToken($params);\n    return Redirect::to(\n        League\\OAuth2\\Server\\Util\\RedirectUri::make($params['redirect_uri'],\n        array(\n            \"access_token\" => $response[\"access_token\"],\n            \"token_type\" => \"bearer\",\n            \"state\" => isset($params['state']) ? $params['state'] : ''\n        ), \"#\")\n    );\n}\n. Was this already released?. No problem.\nFor now (in case anyone needs this), I did something similar to what @xiehan did. For public clients, it will always generate and return a refresh_token, but it won't persist it unless you pass scope=refresh_token in the initial auth request.\nMy ClientEntityInterface implementation has a custom isConfidential method, which returns true if the client is known to be able to store secrets. If this is the case, it will always persist the refresh token.\nclass MyRefreshTokenRepository implements RefreshTokenRepositoryInterface {\n    ...\n    public function persistNewRefreshToken(RefreshTokenEntityInterface $refreshTokenEntity) {\n        $persist = false;\n        if ($refreshTokenEntity->getAccessToken()->getClient()->isConfidential()) {\n            // For confidential clients, always persist refresh token\n            $persist = true;\n        } else {\n            // For public clients, only persist refresh token if \"refresh_token\" is in requested scopes.\n            foreach ($refreshTokenEntity->getAccessToken()->getScopes() as $scope) {\n                if ($scope->getIdentifier() === 'refresh_token') {\n                    $persist = true;\n                    break;\n                }\n            }\n        }\n        if (!$persist) return;\n        // store in database\n}. Uh oh. Does this mean that PKCE won't work at all in version 6.x (and hence PHP 5.6)? Was hoping to use it in a project.. Thanks! I'll give it a try.. I might try working on this for my own purposes. I can try to submit a PR if you want.\nI could add a respondToRevokeTokenRequest method to AuthorizationServer. It would need to duplicate some of the code in AbstractGrant->validateClient, since that's not available to AuthorizationServer.\nThen, depending on the token_type_hint, it would call either accessTokenRepository->revokeAccessToken or refreshTokenRepository->revokeRefreshToken. You'd probably need to pass the refresh token repository into the method, since it's not otherwise available to AuthorizationServer.\nI think we'd also want to pass in a flag for whether to revoke the access token, when token_type_hint=refresh_token, since this is optional.. Sure, if you don\u2019t mind me moving that out of the Grant classes, and maybe into its own class, I can take that approach.. Before I go ahead with writing tests and submitting a pull request, could I ask if this is something you're interested in at all, and if my approach in this commit is reasonable? It's based on master.\nBasically I did this:\n- Copied the client validation code from AbstractGrant into a ClientValidator class (later I can separate this into its own PR, and change the Grants to use this same class).\n- Added a RevokeTokenHandler class to handle revoke requests. It checks to see if the token is an access or refresh token, and revokes it if possible. If $canRevokeAccessTokens is true, it will allow you to revoke access tokens, and it will revoke the associated access token when you revoke a refresh token.\n- Added a enableRevokeTokenHandler method to AuthorizationServer, which can be used like this:\n$refreshTokenRepository = [...];\n$authServer = new \\League\\OAuth2\\Server\\AuthorizationServer([...]);\n$handler = new \\League\\OAuth2\\Server\\RevokeTokenHandler($refreshTokenRepository);\n$authServer->enableRevokeTokenHandler($handler);\n- Added a respondToRevokeTokenRequest method to AuthorizationServer, which can be used in the same way as respondToAccessTokenRequest.\n. @Sephster Do you have a preferred approach? I won\u2019t be offended if it\u2019s not mine \ud83d\ude0a. @chervand is using a new Grant, and I\u2019m using a non-Grant class.. No problem. I will try to work it up into a PR. I may steal some of @chervand's more mature code if he doesn't mind.. In case anyone else needs it, I'm going to try to maintain a PHP 5.6-compatible fork here. I make no promises that it will work, although the unit tests pass.. Thanks! That's very helpful. I didn't realize that it's embedding the expiration time in the token now, using JWT. I was used to the older version where I had to store the expiration time in the database and verify it myself.. With this upcoming change, will implicit-grant clients still be supported? Those are public clients, but they can't support PKCE. I'm migrating new clients to use the auth-code-grant with PKCE, but I'd like to still be able to support old implicit-grant clients.. Yes, thanks @sg3s. That makes sense.\nFor the current version, I just call enableCodeExchangeProof when setting up the server, if the client is configured as public (of course, this requires me to look up the client myself before the OAuth process starts, which I think this PR will avoid). And if it's public, my getClientEntity code skips the client-secret validation.\nSeems like it will be easy enough to transition to the new version.. Fair enough, thanks.. BTW, I couldn't figure out how to get it to pass both tests, if I have a function that sometimes returns null. The style checker wants me to change \"return null\" to \"return\", but if I do that, I get a CI error.. Sure, I refactored it to avoid returning null, and just made it revoke the token right away.. ",
    "weblance": "Followup on @jacobweber and @jfse comment.\nRe: skip deleteSession in AuthCode\n@alexbilbie I need to allow multiple access_token for all credentials in v2.1.1: as a quick patch I'm considering to remove the call to deleteSession() from the AuthCode grant (like you did for ClientCredential and Password) could you please explain the reasons why you have not done it on v2.1.1? Is there any risks/downside in doing so there (before upgrading to v3 where I see \"All grants no longer remove old sessions by default\")?\nRe: cleanup old session\n@jfse I'm also considering a cronjob to cleanup old expired session but I agree there should be a garbage collect module builtin in the library (that can be used in a cronjob). Is there anything like that?\n. ",
    "jakeasmith": "Any chance this is coming soon? I looked around for a roadmap but didn't see anything and there's a chance I may need to add support for this in my own app within the next few weeks.\n. ",
    "tonyhk": "oh thanks!\n. i'm following your blog and using v2\nhttp://alexbilbie.com/2013/02/developing-an-oauth2-authorization-server/\nto create controller \npublic function __construct()\n{\n\n// Enable the authorization code grant type\nLine 18:    $this->authserver->addGrantType(new \\OAuth2\\Grant\\AuthCode()); \nif i provide without $this->authserver it will show this Error\nArgument 1 passed to OAuth2\\Grant\\AuthCode::__construct() must be an instance of OAuth2\\AuthServer, none given, called in /app/controllers/OauthController.php on line 18 and defined \n. ",
    "joaorobertopb": "Sorry for asking in a topic already closed.\nI take much OAuth2 use with Oracle Database! \nI wonder if there is already a solution for it?\n. ",
    "mrin": "Also need to fix:\nsrc/League/OAuth2/Server/Resource.php, line: 197\n$scope['key'] to $scope['scope'];\n. ",
    "inanimatt": "Probably irrelevant unless you want to offer a bunch of alternatives, but I have a Doctrine DBAL version of this at https://github.com/inanimatt/silex-oauth2-api/tree/master/src/Inanimatt/OAuth2/Server/Storage/DBAL that you're welcome to claim for your own, no strings attached. It's convenient for using OAuth2-Server in Silex, since it ships with DBAL integration.\n. No worries, I can wait!\n. 3.x removed the storage implementations from the repository, so if you upgrade and you're using the provided ezcomponents one, for instance, then it'd stop working until you supplied those files yourself. I was using my own Doctrine DBAL storage implementation so I didn't notice. I can provide that implementation as a composer package if you like, or (I think) you can just copy the files out of the 2.x branch and tell your autoloader where to get them.\n. Here you go then! https://github.com/inanimatt/oauth2-server-dbal -- just give it the DBAL connection that your ORM's using and it should be fine. I wrote out a very quick README with some instructions in it and gave it a very quick test. YMMV!\n. Anyone with your client credentials would be able to operate on the client's behalf via the client credentials grant, so it doesn't strike me as a great idea. Google's solution to client-side-only OAuth 2.0 seems to be a variation of the implicit grant type, where you only reveal the client id, not the secret, and the authorisation server returns an access token directly rather than an auth code:  https://developers.google.com/accounts/docs/OAuth2UserAgent - this might be a better approach than the password grant. \n. Resource owners (end-users) do authenticate (to the AS) under the implicit grant type, as explained in section-4.2. The problems are that the client itself is not authenticated, and the access token is not secure. \nGoogle's implementation requires client applications to validate the token to help mitigate resource owner impersonation, but Alex's suggestion of writing a thin server-side proxy strikes me as a much better solution.\nThe spec explains the threat of unauthenticated clients in section 10.2 and section 10.16. \n. ",
    "icep87": "Any idea when this will get Merged into master? \n. ",
    "philsturgeon": "As this code will be used for v3 but not directly merged I'll close this one.\n. I don't believe this is in the spec so it seems like something you just feel like applications should do.\nMany applications allow logins from two devices at the same time, or in two browsers on the same device, etc, so should this not be an option instead of default behavior? \n@alexbilbie what do you think?\n. How about it @alexbilbie?\n. Could you sort the formatting out so that new line is one indent? Code is floating over to the right hand side in the latests commits. :)\n. These have all been ripped out for the latest versions so that we are not forced to maintain multiple systems we know nothing about. If we have fluent we need ZF2 db, Kohana's ORM, etc, etc, etc. Nope on that, make a package that bridges the two :)\n. 2 to 3 was rough, and 3 to 4 is going to be tricky. This whole thing needs more documentation, and @alexbilbie is on the case.\n. It was called temp, because it was temporary. 1.0.9 should contain all you need.\n\u2014\nSent from Mailbox for iPhone\nOn Thu, Dec 5, 2013 at 7:43 PM, Alex McRoberts notifications@github.com\nwrote:\n\nThat branch was created by @philsturgeon based on my request on May 14th to\nboth @philsturgeon and yourself. If you check your emails, you'll see one\nfrom me. It should have pointed to 1.0.9 but in fact it didn't. Once that\nbranch was created I had to point to the\ncommit b29a14ae85349aa5bc3a483e10ee5a02ae2b887d - my require file was\nessentially:\n\"require\": {\n\"league/oauth2-server\": \"dev-temp#b29a14ae85349aa5bc3a483e10ee5a02ae2b887d\",\n },\nIt looks like it was only deleted from the repo today, since we've had\ndeployments running upto this morning that worked no problem.\nReply to this email directly or view it on GitHub:\nhttps://github.com/php-loep/oauth2-server/issues/120#issuecomment-29953884\n. @reinink you got the setup instructions for the site, for @alexbilbie?\n. Thats just an issue reporting back the code coverage, because you're running it outside of our repo. Ignore it.\n. Could you provide a little more information?\n. Cheers fella.\n. At this point @alexbilbie it's probably better to merge and update docs when they eventually happen than it is to hold this up and annoy folks with waiting around. Can you give anyone an update on what is happening? \n\nThis v4 and the docs are both a long time overdue, but that is only because we mentioned it publicly. Whenever new versions are mentioned people want them nownownow and refuse to use any other version. :)\n. Thanks for the update buddy. I'm wondering if \"oauth2-server\" and \"oauth2-server-mysql\" or.... something... could be achieved to solve the problems you are having? \nFlexibility is good, but we've already seen from the lucadegasperi/oauth2-server-laravel package that if our stuff is tough to implement then people will need a wrapper to actually use it. \n. Thanks @shadowhand.\n. Done and done sir.\n. Done\n. Good move on the class name front. Can you rip out some of that added whitespace on the docblocks? I just know that some people have \"remove trailing whitespace\" enabled and adding some in while they're taking it out is just a recipe for disaster. \n. Also, if you could squash these commits down with rebase and force push back up here that would be great. It doesn't have to be one commit, but I feel like 44 commits will be a little confusing on the history. \n. Nice! I think you might have squashed in a few things that could be causing a conflict.\nCan you git pull --rebase origin master and fix conflicts there? Then we should be good and I'll leave it to Alex to merge or not.\n. Haha! I know, making clean PRs can be a massive pain in the backend. We do this for all changes at my job and while it can be annoying to do, it does save a lot of headaches later on when it comes to reverts and that sort of thing. \nThanks for playing the game! \nHopefully @alexbilbie will have some more feedback about specifics, but this looks good to me.\n. Looks good to me @alexbilbie \n. Alex raises a good point. If a refresh token already has a TTL, then we know it will eventually expire. If we set a simple flag that says \"rotate them\" then that refresh token will be replaced with a new one instead of simply turned off. \nThat would take care of your use case perfectly. \n. Could you squash your commits with git rebase -i HEAD~4 and mark the last 3  as f?\n. Bad change\n. Hello there whitespace, welcome to the party.\n. You could use assertArrayHasKey() surely? \n. Huh? I'm saying instead of $this->assertTrue(array_key_exists()) you can use $this-> assertArrayHasKey() instead.\n. I just noticed something and provided feedback. It\u2019s up to Alex either way. It could well be that assertTrue(array_has_key()) is used elsewhere, but it probably shouldn\u2019t be. :)\n. Sorry if these weren't clear. Unless I though things were self explanatory I wouldn't make comments so brief. The bad change was you adding namespace prefixes which didn't need to be there. Let's just use the shorter class name.  As for hello white space... you added white space and it doesn't need to be there. :)   \n---Sent from Boxer | http://getboxer.com\nOn 21 December 2014 11:34:40 GMT-5, Jur Balledux notifications@github.com wrote:In examples/relational/Storage/AccessTokenStorage.php:  > @@ -33,7 +34,7 @@ public function get($token) > /* > * {@inheritdoc} > / > - public function getScopes(AccessTokenEntity $token)   Dear @philsturgeon could you please provide detailed comments instead of \"Bad change\" and \"Hello whitespace\" so we can fix problems accordingly? Thanks.  \u2014Reply to this email directly or view it on GitHub.\n. \u201cShould\" seems like this might actually have an affect, more that being a question.\u201d Is\" or \u201cHas\" is what I see most commonly used for these boolean get methods.\u00a0\nI can just see people confusing these with setters.\u00a0\n--\u00a0\nPhil\nFrom:\u00a0Alex Bilbie notifications@github.com\nReply:\u00a0thephpleague/oauth2-server reply@reply.github.com>\nDate:\u00a0December 21, 2014 at 5:00:41 PM\nTo:\u00a0thephpleague/oauth2-server oauth2-server@noreply.github.com>\nCc:\u00a0Phil Sturgeon me@philsturgeon.uk>\nSubject:\u00a0 Re: [oauth2-server] Per Spec, allow Authorization Server to -maybe- issue a new Refresh Token. (#286)  \nIn src/Grant/RefreshTokenGrant.php:\n\n@@ -58,6 +65,26 @@ public function getRefreshTokenTTL()\n     }\n/**\n-     * Set the rotation boolean of the refresh token\n-     \n-     * @return int\n-     /\n-    public function setRefreshTokenRotate($refreshTokenRotate)\n-    {\n-        $this->refreshTokenRotate = $refreshTokenRotate;\n-    }\n  +\n-    /\n-     * Get rotation boolean of the refresh token\n-     \n-     * @return int\n-     /\n-    public function getRefreshTokenRotate()\n  And this method should be called shouldRefreshTokensRotate\n\n\u2014\nReply to this email directly or view it on GitHub.\n. ",
    "stayallive": "You are missing 3 methods in Session! associateAuthCodeScope, getAuthCodeScopes, removeRefreshToken.\nDo you use this code?\n. I'm sorry was just curious and trying to point out errors I saw. Not meant to be offensive!\n. I know that. But I do not wish to change it but retrieve at as in the tutorial!\n. Yeah I have seen that too :) and I also var_dumped that array... No\nauto_approve to be found! So I went digging and found out that the\nClientInterface is responsible for getting that info except it doesn't!? Or\nshould that come from somewhere else. TL;DR The auto_approve is not set on\nthe $params['client_details']\nNP I can read it fine without fancy formatting :)\nOp 12 mei 2013 om 23:52 heeft Jesse Farebrother notifications@github.com\nhet volgende geschreven:\nIf your following that tutorial you should see its retrieved from the\nassociative array called params. When the request is first made\n$params['client_details'] is populated with the information. So to access\nit you would therefore use $params['client_details']['auto_approve']. Sorry\nfor the lack of formating I'm on my phone.\nOn May 12, 2013 3:46 PM, \"Alex Bouma\" notifications@github.com wrote:\n\nI know that. But I do not wish to change it but retrieve at as in the\ntutorial!\n\u2014\nReply to this email directly or view it on GitHub<\nhttps://github.com/php-loep/oauth2-server/issues/55#issuecomment-17785984>\n.\n\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/php-loep/oauth2-server/issues/55#issuecomment-17786079\n.\n. Yeah I can fix it but I think it should be fixed in the source too because im not the only one using the default PDO implementations I suppose. I can write You an pull request if wanted. If not please do fix so I can use the lib without modifying or implementing the storage models myself. :)\n. I am really curious about the status... any progress? :)\n. This should be ->select(array('oauth_sessions.id as session_id', 'oauth_session_authcodes.id as authcode_id')).\n. Not in interface nor database!?\n. ",
    "zacharyblank": "Hey Alex - I can update all of this if you plan on merging the updates.\n. ",
    "thomaswelton": "For those interested in Laravel 4 yesterday I released an alpha version of this \nhttps://github.com/thomaswelton/laravel-oauth\nhttp://laravel-oauth.herokuapp.com/\nYou may want to take a look. It either uses Laravels Symphony Sessions for or Redis (based on your Laravel session config)\n. ",
    "JesseFarebro": "The 'auto_approve' is a field in your database in the table oauth_clients I\nbelieve so just set that to the desired value. The ClientIntetface doesn't\nprovide any way of changing this value it should be set when the client is\nfirst made.\nOn May 12, 2013 6:32 AM, \"Alex Bouma\" notifications@github.com wrote:\n\nI started implementing the OAuth2 server by your tutorial (\nhttps://github.com/php-loep/oauth2-server/wiki/Developing-an-OAuth-2.0-authorization-server)\nand found out that something is not right (or I need glasses).\nThe problem can be found here\nhttps://github.com/php-loep/oauth2-server/wiki/Developing-an-OAuth-2.0-authorization-server#create-an-oauth-controllerwhen you need to create the\nauthorise endpoint. There is spoken of a auto_approve parameter in\nclient_details however it is nowhere to be found!\nI checked the ClientInterface who is (that I believe) responsible for\nproviding that data. I looked at the docs at\nhttps://github.com/php-loep/oauth2-server/blob/master/src/League/OAuth2/Server/Storage/ClientInterface.php#L38but there is also not spoken of an\nauto_approve.\nI hope this is a valid problem and not me having a bad day =]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/php-loep/oauth2-server/issues/55\n.\n. If your following that tutorial you should see its retrieved from the\nassociative array called params. When the request is first made\n$params['client_details'] is populated with the information. So to access\nit you would therefore use $params['client_details']['auto_approve']. Sorry\nfor the lack of formating I'm on my phone.\nOn May 12, 2013 3:46 PM, \"Alex Bouma\" notifications@github.com wrote:\nI know that. But I do not wish to change it but retrieve at as in the\ntutorial!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/php-loep/oauth2-server/issues/55#issuecomment-17785984\n.\n. Well client interface just provides a interface for the storage model. Have\nyou tried looking to see what the default Client storage model does. It can\nbe located in /Leage/OAuth2/Server/Storage/PDO/Client.php I believe.\nOn May 12, 2013 3:57 PM, \"Alex Bouma\" notifications@github.com wrote:\nYeah I have seen that too :) and I also var_dumped that array... No\nauto_approve to be found! So I went digging and found out that the\nClientInterface is responsible for getting that info except it doesn't!?\nOr\nshould that come from somewhere else. TL;DR The auto_approve is not set on\nthe $params['client_details']\nNP I can read it fine without fancy formatting :)\nOp 12 mei 2013 om 23:52 heeft Jesse Farebrother notifications@github.com\nhet volgende geschreven:\nIf your following that tutorial you should see its retrieved from the\nassociative array called params. When the request is first made\n$params['client_details'] is populated with the information. So to access\nit you would therefore use $params['client_details']['auto_approve'].\nSorry\nfor the lack of formating I'm on my phone.\nOn May 12, 2013 3:46 PM, \"Alex Bouma\" notifications@github.com wrote:\n\nI know that. But I do not wish to change it but retrieve at as in the\ntutorial!\n\u2014\nReply to this email directly or view it on GitHub<\nhttps://github.com/php-loep/oauth2-server/issues/55#issuecomment-17785984>\n.\n\n\u2014\nReply to this email directly or view it on\nGitHub<\nhttps://github.com/php-loep/oauth2-server/issues/55#issuecomment-17786079>\n.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/php-loep/oauth2-server/issues/55#issuecomment-17786140\n.\n. Yeah it looks like in the default model that I said in my last post doesn't include the client_details however that would be very easy to implement just modify the SQL queries in your Client model and return an extra key in the associative array call it what ever you'd like. \n. \n",
    "akahige": "Thanks!\n. ",
    "obaid": "Similar to issue #72 which has more details and approaches, so closing this one.\n. Awesome.. can you please tell me how you get to load the library within this controller without using composer?\n. ",
    "robertpitt": "I second this, had to implement this myself as well.\n. I also agree with this, seems like the request object is not as abstract as the rest of the implementation and you are somewhat forced to use it.\nMaybe cleaning it up and creating an interface.\n. I actually figured it out, it was not the Oauth Implementation but a mistake on my part, seems I was calling incorrectly implementing the lastInsertId method of PDO in my DB Abstraction Layer.\nSorry for the inconvenience\n. Thanks, you are right in not implementing this. I will have to fork the library I am using and restructure it to use the state to transfer the dynamic k/v's\nThanks\n. I dont think that this is a grant level issue, all grants that require a\nredirect_uri should have the same logic applied to them.\nThe problem I am faced with is that some clients add custom parameters to\nthe redirect uri without taking full use of the state parameter, this is\nsomething that should be taken up with the developers of that client.\nI agree that the the OAuth framework should be kept to as strict standards\nas possible, I have contacted the developer of the client in question (WP\nKeyring), asking him to consider an update to take use of the state\nparameter.\nOn 14 November 2013 22:48, Alex Bilbie notifications@github.com wrote:\n\nRather than altering one if the existing grants why not add your own by\nimplementing the grant interface.\n\nEmailing from my iPhone like a BOSS\n\nOn 14 Nov 2013, at 21:35, Robert Pitt notifications@github.com wrote:\nThanks, you are right in not implementing this. I will have to fork the\nlibrary I am using and restructure it to use the state to transfer the\ndynamic k/v's\nThanks\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/php-loep/oauth2-server/issues/113#issuecomment-28530919\n.\n. From my experience I think that mod_fastcgi for Apache does not pass the Authorization header on to the PHP environment.\n\nWithin the fast configuration you can inform it to pass the Authorization header along, see: http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html#FastCgiConfig\n\n-pass-header header (none)\nThe name of an HTTP Request Header to be passed in the request environment. This option makes available the contents of headers which are normally not available (e.g. Authorization) to a CGI environment.\"\n\nI think this is out side of the Oauth2 Server packages scope and no action should be taken, this is down to the server administrators.\n. Hey Alex,\nIMO This should be implemented into into V3 correctly, the changes from V3 to V4 are quite substantial and for my project and many others we cannot afford to upgrade as easy as that.\nI personally think as this is a functionality bug with the library it should be patched in V3 as well.\nAny thoughts on this.\n. Access Token expiry is an integral part of a Secure Oauth infrastructure, by adding such a feature would reduce security if used.\nCan you give a good reason why this would be beneficial apart from reducing the development work need to implement a rotating access token mechanism on the client application.\n-1\n. In development, I just set your TTL to 52 * 604800, I'm sure 1 year will suffice for your need's :/\n. ",
    "solvire": "I added a pull request before I checked this. I'll have to drop mine.\nThanks for doing this. \n. ",
    "hailwood": "Whoops, did the same thing as @solvire \n. Also curious, the build failed due to composer not the code, can we please get this rerun?\n. Reopening as the existing pull request for this issue has no update to the interface documentation.\n. But the thing is that the spec states that we shouldn't be returning client_id or redirect_uri errors to the client instead we should handle those errors ourselves. So we need a way to tell the difference between the scope missing (which should be returned to the client via redirecting the resource owner) and the client_id missing which should not be returned to the client.\n. Yes inform the resource owner this is the person who has been redirected to grant authorization.\nMUST NOT automatically redirect the user-agent to the invalid redirection URI hence we are not allowed to redirect the user (resource owner) back to the client with the error.\n. That's my point. We need a way to know the difference between these errors that we should throw the error on the auth server and the errors that we should redirect the resourceOwner back with. Which presently apart from sniffing the message returned in the exception we can't tell the difference.\n. @alexbilbie also incorrect.\nThe second part of rfc6749 section 4.1.2.1 states:\n\nIf the resource owner denies the access request or if the request fails for reasons other than a missing or invalid redirection URI, the authorization server informs the client by adding the following parameters to the query component of the redirection URI using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n\nreasons other than a missing or invalid redirection URI includes many of the errors caught by checkAuthoriseParams(). View the list below which documents all errors that can happen in the function call. Notice that there are three occasions that the specs say should be handled on the authorization server (handle) and five that should be returned back to the client (redirect).\nMissing Client ID\nException Code: 0\nAction to Take: handle\nMissing Redirect Uri\nException Code: 0\nAction to Take: handle\nState Param Required && Missing State\nException Code: 0\nAction to Take: redirect\nInvalid client ID or Redirect Uri ($this->authServer->getStorage('client')->getClient() fails)\nException Code: 8\nAction to Take: handle\nMissing Response Type\nException Code: 0\nAction to Take: redirect\nUnsupported response type\nException Code: 3\nAction to Take: redirect\nScope required, no default scope, scope param missing\nException Code: 0\nAction to Take: redirect\nInvalid Scope\nException Code: 4\nAction to Take: redirect\n. Laravel uses PDO underneath fluent which is where the PDO comes into it - Check out config/database.php specifically the fetch key.\nWhen we try to use the returned scopes in Resource.php It throws\n\nCannot use object of type stdClass as array\n. Forgive all the \"changes\" there were a mix of tabs and spaces on all lines so my formatter has cleaned that up but the actual changes are:\n\nChange the Use statement to reference \\DB instead of the full path to the laravel DB facade which allows DB to be overwritten.\nChange of function getScopes to use new arrayQuery function.\nChange of function getAuthCodeScopes to use new arrayQuery function.\nAddition of arrayQuery function which wraps calls to alter the return type temporarily.\n. ",
    "rajiff": "Gr8, any idea by when it will be out or any possibility to take a early look at it\n. ",
    "jnbdz": "I ran into the same problem.\nTo debug it I just comment out the code that was causing issue. To try to get to the root of the problem.\nThen I found multiple bugs:\n1. First is the models call\n$this->authserver = new League\\OAuth2\\Server\\Authorization(\n                    new League\\OAuth2\\Server\\Storage\\PDO\\Client($db),\n                    new League\\OAuth2\\Server\\Storage\\PDO\\Session($db),\n                    new League\\OAuth2\\Server\\Storage\\PDO\\Scope($db)\n            );\nThat's the solution... This is found in the __construct method.\n1. The next bug is found on line 30.\n$this->authserver->addGrantType(new League\\OAuth2\\Server\\Grant\\AuthCode($this->authserver));\n\nI am not sure this is the solution... But it stop the error message for this.\n1. Now to debug the first problem.\nSolutions:\n'error'                 => $this->authserver->getExceptionType($e->getCode()),\nThen you will incouter another error... Here is the solution:\nheader($this->authserver->getExceptionHttpHeaders($this->authserver->getExceptionType($e->getCode())));\nI hope it helps.\nBy the way you will encounter another problem.\nNon-library specific error.\nI am trying to figure it out.\n. The next problem I got as to do with the $server variable. That is for some reason undefined.\nThe the $server var is supposed to have this value: $this->authserver.\nNow I am still incoutering some issues. I am not sure I understand them... But when I do I will add new information.\n. The problem is that I am not sure how to test out the code to see if everything is ok.\n. Busy... Who knows. But I am trying different things on my server. When I get it to work I will explain here how I did it.\n. I am! Today I some things to do. But tonight I will be working on it. And when I am done I will give more details on how to setup this package with Laravel 4.\nRight now I am trying out OAuth2-client so that I can test it out with OAuth2-server.\nThe problem is that this package is just a framework to help you create a OAuth2-server. It does not have all the views and other things. You have to coded yourself. The reason, I think, it was to make this package as framework agnostic as possible. But trust me when I am done I will put a link to my GitHub with all the details.\n. @alexbilbie should I continue figuring it out? Or will you post updates that will make what I do obsolete?\n@developernoman another thing. Your controller should extend: \"BaseController\".\n. @developernoman if you're using oauth2-client with Laravel 4, you will need to debug it to make it work. Here is how: https://github.com/php-loep/oauth2-client/issues/5\nI will continue tomorrow...\n. In the OAuth2-client Provider folder I added my own provider PHP script.\nBut every time I try to connect to my oauth-server I get an error.\nSo there seems to be a bug with the controller that I have created in the oauth-server side... Or there is something else bugging.\n. It seems that there is another problem with the tutorial. Again I am not sure.\nBut in section \"Create your first client\" of the wiki it says to put data in \"oauth_clients\" db table.\nI found that it did not work. So I did some digging and found that I had too add the client_id and redirect_uri to the \"oauth_client_endpoints\" db table.\nIt's weird because the way it is written in the wiki it seems it's just optional.\nI am now getting this error: \"The requested scope is invalid, unknown, or malformed. Check the \"offline_access,email,read_stream\" scope.\"\nI will try to solve it tonight but no guarantees.\n. It works.\n. ",
    "ghost": "Thanks fella for looking into it.\nDoes this mean that taking care of one issue raises another and you still have not been able to make it work from the wiki ?\nI am not able to atleast :( ...\n. Why is not the creator to this package helping us out ? I am sure he is the best person to sort this through :(\n. Okay, that would be great. Amazing no one has found this out before. It's the first tutorial in the wiki ...\n. Help me out with Laravel then :( ... Anyone ?\n. Thanks a lot @starJammer .\nnewls\n. adds:\nI would like to know the reason for the usage of SHOULD NOT here, but be certain I'm going to respect the spec for now, as soon as I already was, of course reusing the credentials to fetch the token.\nThanks again @starJammer !\n. Thanks a lot @starJammer ,\nI franckly admit I was asking this question hoping someone would know !\nIt is a good reason not to implement it in oauth2-server I guess !\nThanks for your reply, I asked before reading the RFC on these specific topics, lacking of time.\nThanks for providing all this information ! I will keep refreshing with the client credentials.\nnewls\n. It's available as \n$request->getAttribute( 'oauth_user_id' )\n$request->getAttribute( 'oauth_scopes' )\n$request->getAttribute( 'oauth_client_id' )\nand so on. Took me a couple of hours with Googling and testing before i figured this out :( Should be part of the documentation (Unless im completely blind).. ",
    "esolitos": "The wiki is sort of a \"pseudocode\", you need to set it up based on your Framework.\nFor example I'm modifying it to work with CodeIgniter, I still have some issues, but it seems to work.\n. Hi QuasiPerfect, right now I don't remember the steps, anyway you have to change a looooot of things.\nTake the tutorial as a pseudo-code and think what he's doing. After that you should be able to rewrite the tutorial code as you need it, imho don't try to copy-paste: Start over, it's easier.\nIf you still have issues I'll give a look to my code.\n. ",
    "quasiperfect": "@esolitos can you be so kind and tell me how you got it to work with CodeIgniter ?\n. ",
    "jasongrimes": "Will do, thanks.\n. ",
    "gstjohn": "Sorry! Resubmitting to develop now.\n. ",
    "arenowebdev": "I'm not too much in control of what I'm receiving, but I completely understand what you're saying there. What it appears to be from with who I'm working with, they need info in the query string of the redirect uri. I have a fix in place, and I'm more than willing to share if it's something you'd be interested in...  Let me know. For now, I will go ahead and close this though. :D\n. ",
    "fahmiardi": "I type in terminal:\nbash\ncurl http://authorizeserver.local/oauth2 -d 'client_id=test&grant_type=authorization_code&client_details=test&redirect_uri=http://test&response_type=code'\nand I get this:\nThe request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed. Check the \"client_id\" parameter.\n. I got this:\n[2] 19205\n[3] 19206\n[4] 19207\n[1]   Exit 127                http://authorizeserver.local/oauth2?client_id=test\n[2]   Done                    grant_type=authorization_code\n[3]   Done                    client_details=test\n[4]   Done                    redirect_uri=http://test\n. It's works!\n. [Fix] implement for Codeigniter Framework\n``` php\n<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');\n/\n\n/\nclass Oauth2 extends CI_Controller\n{\npublic function __construct()\n{\n    parent::__construct();\n\n    $this->load->library('session');\n    $this->load->helper(array('url', 'form'));\n\n    // Initiate the request handler which deals with $_GET, $_POST, etc\n    $request = new League\\OAuth2\\Server\\Util\\Request();\n\n    // Initiate a new database connection\n    $db = new League\\OAuth2\\Server\\Storage\\PDO\\Db('mysql://root:root@localhost/alex_oauth');\n\n    // Create the auth server, the three parameters passed are references\n    //  to the storage models\n    $this->authserver = new League\\OAuth2\\Server\\Authorization(\n        new League\\OAuth2\\Server\\Storage\\PDO\\Client($db),\n        new League\\OAuth2\\Server\\Storage\\PDO\\Session($db),\n        new League\\OAuth2\\Server\\Storage\\PDO\\Scope($db)\n    );\n\n    // Enable the authorization code grant type\n    $this->authserver->addGrantType(new League\\OAuth2\\Server\\Grant\\AuthCode($this->authserver));\n}\n\npublic function index()\n{\n    try {\n\n        // Tell the auth server to check the required parameters are in the\n        //  query string\n        $params = $this->authserver->getGrantType('authorization_code')->checkAuthoriseParams();\n\n        $this->session->set_userdata('client_id', $params['client_id']);\n        $this->session->set_userdata('client_details', $params['client_details']);\n        $this->session->set_userdata('redirect_uri', $params['redirect_uri']);\n        $this->session->set_userdata('response_type', $params['response_type']);\n        $this->session->set_userdata('scopes', $params['scopes']);\n\n        // Redirect the user to the sign-in route\n        redirect('/oauth2/signin');\n\n    } catch (Oauth2\\Exception\\ClientException $e) {\n        echo $e->getMessage();\n        // Throw an error here which says what the problem is with the\n        //  auth params\n\n    } catch (Exception $e) {\n        echo $e->getMessage();\n        // Throw an error here which has caught a non-library specific error\n\n    }\n}\n\npublic function signin()\n{\n    // Retrieve the auth params from the user's session\n    $params['client_id'] = $this->session->userdata('client_id');\n    $params['client_details'] = $this->session->userdata('client_details');\n    $params['redirect_uri'] = $this->session->userdata('redirect_uri');\n    $params['response_type'] = $this->session->userdata('response_type');\n    $params['scopes'] = $this->session->userdata('scopes');\n\n    // Check that the auth params are all present\n    foreach ($params as $key=>$value) {\n        if ($value == null) {\n            // Throw an error because an auth param is missing - don't\n            //  continue any further\n            // echo \"stop\";\n            // exit;\n        }\n    }\n\n    // Process the sign-in form submission\n    if ($this->input->post('signin') != null) {\n        try {\n\n            // Get username\n            $u = $this->input->post('username');\n            if ($u == null || trim($u) == '') {\n                throw new Exception('please enter your username.');\n            }\n\n            // Get password\n            $p = $this->input->post('password');\n            if ($p == null || trim($p) == '') {\n                throw new Exception('please enter your password.');\n            }\n\n            // Verify the user's username and password\n            // Set the user's ID to a session\n            if($u == 'f4hem' && $p == 'f4hem') {\n                $this->session->set_userdata('user_id', 'f4hem');\n            }\n\n        } catch (Exception $e) {\n            $params['error_message'] = $e->getMessage();\n        }\n    }\n\n    // Get the user's ID from their session\n    $params['user_id'] = $this->session->userdata('user_id');\n\n    // User is signed in\n    if ($params['user_id'] != null) {\n        // Redirect the user to /oauth/authorise route\n        redirect('/oauth2/authorize');\n    }\n\n    // User is not signed in, show the sign-in form\n    else {\n        echo form_open('/oauth2/signin');\n        echo form_label('Username', 'username');\n        echo form_input('username', '');\n        echo form_label('Password', 'password');\n        echo form_password('password', '');\n        echo form_submit('signin', 'Sign In!');\n        echo form_close();\n    }\n}\n\npublic function authorize()\n{\n    // init auto_approve for default value\n    $params['client_details']['auto_approve'] = 0;\n\n    // Retrieve the auth params from the user's session\n    $params['client_id'] = $this->session->userdata('client_id');\n    $params['client_details'] = $this->session->userdata('client_details');\n    $params['redirect_uri'] = $this->session->userdata('redirect_uri');\n    $params['response_type'] = $this->session->userdata('response_type');\n    $params['scopes'] = $this->session->userdata('scopes');\n\n    // Check that the auth params are all present\n    foreach ($params as $key=>$value) {\n        if ($value === null) {\n            // Throw an error because an auth param is missing - don't\n            //  continue any further\n            // echo \"stop\";\n            // exit;\n        }\n    }\n\n    // Get the user ID\n    $params['user_id'] = $this->session->userdata('user_id');\n\n    // User is not signed in so redirect them to the sign-in route (/oauth/signin)\n    if ($params['user_id'] == null) {\n        redirect('/oauth2/signin');\n    }\n\n    // init autoApprove if in database, value is 0\n    $params['client_details']['auto_approve'] = isset($params['client_details']['auto_approve']) ? $params['client_details']['auto_approve'] : 0;\n\n    // Check if the client should be automatically approved\n    $autoApprove = ($params['client_details']['auto_approve'] == '1') ? true : false;\n\n    // Process the authorise request if the user's has clicked 'approve' or the client\n    if ($this->input->post('approve') == 'yes' || $autoApprove === true) {\n\n        // Generate an authorization code\n        $code = $this->authserver->getGrantType('authorization_code')->newAuthoriseRequest('user',   $params['user_id'], $params);\n\n        // Redirect the user back to the client with an authorization code\n        $redirect_uri = League\\OAuth2\\Server\\Util\\RedirectUri::make(\n            $params['redirect_uri'],\n            array(\n                'code'  =>  $code,\n                'state' =>  isset($params['state']) ? $params['state'] : ''\n            )\n        );\n        redirect($redirect_uri);\n    }\n\n    // If the user has denied the client so redirect them back without an authorization code\n    if($this->input->get('deny') != null) {\n        $redirect_uri = League\\OAuth2\\Server\\Util\\RedirectUri::make(\n            $params['redirect_uri'],\n            array(\n                'error' =>  'access_denied',\n                'error_message' =>  $this->authserver->getExceptionMessage('access_denied'),\n                'state' =>  isset($params['state']) ? $params['state'] : ''\n            )\n        );\n        redirect($redirect_uri);\n    }\n\n    // The client shouldn't automatically be approved and the user hasn't yet\n    //  approved it so show them a form\n    echo form_open('/oauth2/authorize');\n    echo form_submit('approve', 'yes');\n    echo form_close();\n}\n\npublic function access_token()\n{\n    try {\n\n        // Tell the auth server to issue an access token\n        $response = $this->authserver->issueAccessToken();\n\n    } catch (League\\OAuth2\\Server\\Exception\\ClientException $e) {\n\n        // Throw an exception because there was a problem with the client's request\n        $response = array(\n            'error' =>  $this->authserver->getExceptionType($e->getCode()),\n            'error_description' => $e->getMessage()\n        );\n\n        // Set the correct header\n        header($this->authserver->getExceptionHttpHeaders($this->authserver->getExceptionType($e->getCode())));\n\n    } catch (Exception $e) {\n\n        // Throw an error when a non-library specific exception has been thrown\n        $response = array(\n            'error' =>  'undefined_error',\n            'error_description' => $e->getMessage()\n        );\n    }\n\n    header('Content-type: application/json');\n    echo json_encode($response);\n}\n\n}\n```\n. Step 1:\ntype\nbash\nhttp://authorizeserver.local/oauth2/?client_id=test&grant_type=authorization_code&client_details=test&redirect_uri=http://test.local&response_type=code\n**assuming was created client_id, redirect_uri, and client_secret in DB, exampel(client_id=test, redirect_uri=http://test.local/, client_secret=test)\nStep 2:\nwill be redirect to login form page \nbash\nhttp://authorizeserver.local/oauth2/signin\n**in this example, I use (username=f4hem, password=f4hem)\nStep 3:\nyou will be redirected to page \nbash\nhttp://authorizeserver.local/oauth2/authorize\nand click button 'yes'\nStep 4:\nyou will be redirected to redirect_uri with code and (state, if you give that while request), url like this: \nbash\nhttp://test.local/?code=WWrJy7Ww03fmZJwkvhLRPFF1ypsoOqegiKvy83AY&state=\n** code was generated randomly by League Oauth2 Library\nStep 5:\ntype in terminal:\nbash\ncurl http://authorizeserver.local/oauth2/access_token -d \"grant_type=authorization_code&client_id=test&redirect_uri=http://test.local&client_secret=test&code=WWrJy7Ww03fmZJwkvhLRPFF1ypsoOqegiKvy83AY\"\nand Taraaaa.. you will get response token (generated randomly too by Library):\nbash\n{\"access_token\":\"9P9dmgfxIAzjjMoWG8GvARita8dK1ZTN8lUtTR9i\",\"token_type\":\"bearer\",\"expires\":1372105079,\"expires_in\":3600}\nTq Alex..\n. No, I use composer too in this controller, my composer.json like this:\nbash\n{\n    \"require\": {\n        \"league/oauth2-server\": \"2.*\",\n        \"zetacomponents/database\": \"1.4.6\"\n    }\n}\nand overload the composer bootstrap autoload generated by composer in bottom of file index.php codeigniter apps. the script like this:\n``` php\n// Path to the vendor folder for Composer\ndefine('VENDORPATH', FCPATH . 'vendor/');\n/\n * --------------------------------------------------------------------\n * LOAD THE BOOTSTRAP FILE\n * --------------------------------------------------------------------\n \n * And away we go...\n \n/\n// init Composer bootstrap\nrequire_once VENDORPATH.'autoload.php';\n// init Codeigniter bootstrap\nrequire_once BASEPATH.'core/CodeIgniter.php';\n```\n. I have question alex, I have 3 controller in my authorizeserver based on CI.\n1. /oaut2/auth\n2. /oauth2/token\n3. /oauth2/revoke\nWhich GrantType should I set available in there controller, especially in /oauth2/token controller.\nThanks.\n. Sorry, I try again with additional .htaccess like above and solved, because HTTP Basic auth headers not supported by Apache FastCGI. \n. That's correct robertpitt. Tq..\n. Solved with this command:\nbash\ncurl -H \"X-HTTP-Method-Override: DELETE\" http://dev.local/myapp/delAction -d \"access_token=XXX\"\n. Cool bro.. :D\n. ",
    "ashsou": "thanks it's work :)\n. I read them so many times but still i miss the starting point what are the important files to be integrated with codeigniter folder? :( , plus terminal gives me an error message when I tried to install the composer says that i have to change some sittings in php.ini I updated it but still gives me the same thing is there any other way to download the library ?\n. ",
    "nasaorc": "how to intergrate this with ci?\nwhere should i put the League folder in?\nhow to load the oauth2 lib?\n. ",
    "zeratool": "I followed the your step-by-step tutorial and i'm now stuck on this last process, in the access_token() action :\n$response = $this->authServer->issueAccessToken();\nIs this issueAccessToken() by default no parameter?\nIf so, when i check in Authorization (League\\OAuth2\\Server\\Util\\Request) there's this line:\nif (is_null($grantType)) {\n            throw new Exception\\ClientException(sprintf(self::$exceptionMessages['invalid_request'], 'grant_type'), 0);\n        }\nAnd the error response message is :\n{\"error\":\"invalid_request\",\"error_description\":\"The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed. Check the \\\"grant_type\\\" parameter.\"}\nYour help is really much appreciated.\n. Thanks for the reponse, but i did send it, tried via GET and POST:\nhttp://localhost/oauth_controller/access_token?username=username&password=password&grant_type=authorization_code&client_id=test&client_details=Test+Client&redirect_uri=http://localhost/test&response_type=code&scopes=read+scopes&code=RK2DjrHgp995U1wkaUhuJYoccddOCswoYGgSrBQW\n. Yes, i followed those steps you mentioned, i am on the last part , the library already generated the code:\ncode=RK2DjrHgp995U1wkaUhuJYoccddOCswoYGgSrBQW\nThis code is saved in the table \" oauth_session_authcodes\" \n. For additional information, the \"client\" is mobile app.\n. It's ok now, thanks for your responses and for this cool library!\n. ",
    "FelipeCardoso89": "Thank you so much. It works. Awsome library!\n. Hi everyone.\nI'm using Codeigniter and I did follow this step-by-step guide and everything is working as expected, it means I got the Access_token.\nMy doubt at this point is: How do I make requests to my API using the access_token that I got at Step 5 of this guide? I guess that what I need to know is what's the request syntax.\nThe method that I want to reach with this request is: http://localhost/myapp/index.php/user/getUser\nThank you so much. \n[SOLVED]\nThis is what I was looking for:\ncurl -H \"Authorization: Bearer blMZK6gNQhxpjFKRUoK2gx45zQzN0Zw7WwAvjwca\" http://localhost/myapp/index.php/controller/function_in_controller\nEverything works fine now. :)\n. ",
    "kurisa12": "Hello alex?\nIm getting \"Fatal error: Call to undefined method DB::query() in F:\\Work\\xampp\\htdocs\\oauth\\application\\controllers\\model_session.php on line 79\" when i enter username and password then press the yes button. \nThis is my db.php\n<?php\nclass DB {\n```\nprivate $conn;\nprivate $statement;\nfunction __construct() {\n    $this->conn = new PDO('mysql:host=localhost;dbname=oauth2', '***', '');\n}\npublic function query($sql = '', $params = array()) {\n    $statement = $this->conn->prepare($sql);\n    $statement->setFetchMode(PDO::FETCH_OBJ);\n    $statement->execute($params);\n    return $statement;\n}\npublic function getInsertId() {\n    return (int) $this->conn->lastInsertId();\n}\n```\n} \n. ",
    "jjmpsp": "Could somebody please provide a sample project for this? Finding it hard to get my head around everything.\n. Ignore my last comment. After about 12 hours of messing around with this I've finally got a working implementation. One problem I noticed though....\nWhen requesting an access token with an invalid code, a PHP error is thrown and outputted:\n``` php\ncurl http://localhost2/oauth2/oauth2/access_token -d \"grant_type=authorization_code&client_id=test&redirect_uri=http://test.local&client_secret=test&code=LgkxoxFLXRozfJ9olQ18a2d4ybm3MTgLI5bEGEF6\"\n\nA PHP Error was encountered\nSeverity: Warning\nMessage:  header() expects parameter 1 to be string, array given\nFilename: controllers/oauth2.php\nLine Number: 220\n{\"error\":\"invalid_grant\",\"error_description\":\"The provided authorization grant is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client. Check the \\\"code\\\" parameter.\"}\n```\nI resolved this issue by removing line 220 from the controller, like so. It doesn't seem to do much anyway:\nphp\n // Set the correct header\n //header($this->authserver->getExceptionHttpHeaders($this->authserver->getExceptionType($e->getCode())));\n. Did you ever get anywhere with publishing a full code example? \nI posted in the thread for issue #72 about a year ago. I managed to get a full example running with CodeIgniter, but I have since lost this example due to data loss. Just thought I'd ask before I go ahead and spend another few days working on a new example.\n. ",
    "vivek-1874596": "I have imported library in my codeigniter project using composer in application folder\n{\n    \"require\": {\n        \"league/oauth2-server\": \"^7.0\",\n        \"zetacomponents/database\": \"1.4.6\"\n    }\n}\nAlso I have changed composer_autoload to TRUE in config file. \n$config['composer_autoload'] = TRUE;\nBut when I try to create instance of classess. It gives me error class \"ClientRepository\" not found.\n```\n$clientRepository = new ClientRepository(); // instance of ClientRepositoryInterface\n$scopeRepository = new ScopeRepository(); // instance of ScopeRepositoryInterface\n$accessTokenRepository = new AccessTokenRepository(); // instance of AccessTokenRepositoryInterface\n// Path to public and private keys\n$privateKey = APPPATH . 'third_party/vendor/private.key';\n$encryptionKey = 'lxZFUEsBCJ2Yb14IF2ygAHI5N4+ZAUXXaSeeJm6+twsUmIen';        \n// Setup the authorization server\n$server = new \\League\\OAuth2\\Server\\AuthorizationServer(\n          $clientRepository, \n          $accessTokenRepository, \n          $scopeRepository, \n          $privateKey, \n          $encryptionKey\n        );\n// Enable the client credentials grant on the server\n$server->enableGrantType(\n          new \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant(), new \\DateInterval('PT1H')\n );\n```\nPlease assist me!. @nimsothea - Try to download using composer, It will download all required classes.\nFollow steps added by @fahmiardi - https://github.com/thephpleague/oauth2-server/issues/72#issuecomment-20274701\nIt will definitely help you.. Hello, @yukunwu \nI want to implement this library in one of my codeigniter project.\nCan you please suggest me how you have implemented this library in codeigniter?\nI cannot find \"ClientRepository.php\" this file in this repository. Instead of that file, I can see \"ClientRepositoryInterface.php\" file. Did you created it yourself?\n. ",
    "nimsothea": "Hi @fahmiardi,\n\nI pulled league/oauth2-server 7.1\nI downloaded the example from this repo.\n\nI copied the \"Oauth2\" classes from this issue and there seemed to be missing some packages and classes:\n- League\\OAuth2\\Server\\Util\n- League\\OAuth2\\Server\\Storage\\PDO\n- Oauth2\\Exception\\ClientException\nPlease see in my screenshot.\n\nCan you advise where I can download the missing packages/classes?. Yep, I was using as well (composer require league/oauth2-server \"^7.1\"). ",
    "Sephster": "@nimsothea I don't think you have downloaded version 7.1.1 or you have some customisations as some of the files you are trying to get aren't provided by this package such as League\\OAuth2\\Server\\Storage\\PDO\nYou should check your version in your composer file. Hope this helps. Hi @nicolassing - I haven't yet but @alexbilbie had started on something so I'd planned on using that as a start at some point. I can't say when though as my timing predictions are usually wrong :). @darrencoutts118 I will try and get something implemented for this within the month, depending on real life etc. I think @alexbilbie had made a start on this so I will take a look and jump off from there. Cheers for your patience. Looks good to me. Minor changes to be made to keep consistency with the branch e..g use @expectedException in test but this can be resolved outside of this PR.. @alexbilbie changed the library to use the php-encryption library in this commit 1af4012df459cf8382b9d184af59161fbe62f192.\nAs such, I don't believe there is anything else that needs doing for this issue so will mark it as closed. If anyone has any objections please shout.. This looks good to me although I will do some more concrete checks later this week. I am planning on releasing v7 some time this week so will aim to get this included. \nThe 12-18 month period of support for v5 has now passed as well so I will look to retire this version at the same time. Thanks for your patience!. Merging this in although I'm going to change the mustValidateSecret back to default to true instead of false as I think it is better to be cautious about this check. Most places in the default library are specifying this anyway but I think it is good to default to the most secure option. I think you'd fixed this in your recent PHPStan PR so will close this one. Thanks for the fix regardless and apologies we took a while to pick this up. Hi @xiehan - thank you for the feedback. Apologies that this wasn't made explicitly clear in the docs. As we are on version 6 now, I feel the upgrade notes opportunity has passed. However, I think it is important we do capture this somewhere in either the readme or the docs. There are references in the docs stating that you need to pass PSR7 compatible requests and responses such as on the client credentials grant page but I agree that this could be more front and centre. I will look to add this to the README soon. Thank you. Closing this issue as added a note on PSR-7 to the readme requirements.. Thanks for the quick turn around @lookyman. I will look to get something set up for this soon. We already have a version 7 branch but it hasn't been touched in a while. I believe it has the initial workings for an Open ID implementation. I will need to consult the other maintainers but it might be the case that we remove this branch or work on it to complete the implementation depending on its state and then merge this into a version 7 branch.\nThanks again for making the changes!. @lookyman I've changed the way we are handling PKCE in this PR: https://github.com/thephpleague/oauth2-server/pull/938\nI really like the interfaces you have created for the plain and s256 verifiers though and was wondering if you'd be ok with me integrating those changes in to the aforementioned pull request?\nAlso if you have any thoughts on the approach I've proposed that would be appreciated. Thanks!. Thanks @lookyman. I will aim to get the changes integrated into the PR tomorrow. Thank you. Thanks for your efforts here @lookyman. I've added some of the changes here to my pull request as discussed. Thanks very much for your efforts. I will close this PR now as I think it is no longer required.. @jacobweber no it is listed as a release for v8. I don't have a definite schedule for that release yet. I was hoping to get it out late December/early Jan but these timescales have now slipped somewhat.. PRs are always welcome so please feel free to have a stab at this. According to the spec (and I am saying this from memory rather than checking it), I don't believe refresh tokens should have TTLs. Making the refresh tokens optional would be great though. Thanks for offering assistance.. Hi @wilsonge - RFC 6749 states the following:\n\nThe authorization server MAY fully or partially ignore the scope\n   requested by the client, based on the authorization server policy or\n   the resource owner's instructions.  If the issued access token scope\n   is different from the one requested by the client, the authorization\n   server MUST include the \"scope\" response parameter to inform the\n   client of the actual scope granted.\n\nAs such, if the server is changing the scopes that are requested, we should be returning these scopes to the client. If they don't change, it is optional as to whether we return the scopes or not.\nThere has been some discussion on how to implement this optional setting and it will likely break backwards compatibility but should be implemented in a future version.\nI don't think that we need to call finalizeScopes twice but I do think we need to adjust the implementation to adhere to this part of the RFC. \nI would welcome your thoughts on this approach. Thanks. Hi @jeremykendall, please could you provide some more context with regards to your second point so we can progress this issue? Many thanks.. Closing this as haven't heard back from @jeremykendall. If you still require assistance, please feel free to comment on this issue and we will reopen it so we can follow up. Cheers. Hi @B-Galati - sorry for not seeing your question. I think this is still possible given the current state of the package although we don't specify how to do this ourselves.\nIf someone wants to restrict a client to certain scopes, you could use a scope to client ID mapping in your database and query the client ID stored in the client entity.\nThis would require a bit of work from your end to implement but we've intentionally left the package flexible, using interfaces and abstract methods where ever possible, to give you freedom to mould it to your requirements.\nThere is no concrete implementation of finalizeScopes provided as the validation for scopes could mean different things for different devs/use cases. Some might not want to restrict by client for example, and instead do it by user ID.\nAn example of a finalize scope method is given in our examples which is just listed an an example to inspire you to roll your own:\nhttps://github.com/thephpleague/oauth2-server/blob/e091d4812789cdce69dee43d300fd3707548a4aa/examples/src/Repositories/ScopeRepository.php#L45-L59\nHope this answers your question.\n. No problem. You're welcome!. Thanks for this @everflux - I'm working on a fix at the moment to allow devs to set a default scope which I will add here shortly. If no scope is provided and no default scope is present, an exception will be thrown. Thanks for reporting this. Hi @pcambra - The change looks good to me. Please could you fix the merge conflict as there have been changes to the composer.json file since your PR was created. Once this has been changed I will be happy to merge this in. Many thanks for your help. Closing this as version 6 was released some time ago. Going to take a good hit at the outstanding PR's etc over the Christmas period and will then look to getting something put together for V7.. This looks good to me. Have checked and all appears to be working so going to merge in. I noticed that we are hashing before base64 encoding and in RFC 7636, in appendix A it shows that we should has after base64 encoding but I will make that change outside of this branch. Thanks for your contribution. Thank you for the suggestion. I think that this would likely be implemented on the client side rather than the server side as, for PKCE, it is the client device that is vulnerable for man in the middle attacks. If you have any documentation statin that this is not the case, I will be happy to revisit this. Thanks again for your PR. I think we will need to update the documentation for this to illustrate proper use cases as well but this will be separate to this PR. Hi @iansltx - thanks for this. Yeah, I realised we'd updated the PHPUnit version when I made the comment. Sorry I should have highlighted this in my initial response. Apologies for taking so long to actually pick up this PR. \nI think it would be good if we could get the docs PR and the feature to be released at the same time if at all possible but let me know if you think this won't be feasible for your timescales and we can probably just add an issue to track that this needs documenting. Thanks. Thanks @iansltx, much appreciated.. Hi @i906. Apologies for the delay in picking this up again. Did you manage to resolve your issue? Let us know if we can be of any assistance. Hi @i906 - thanks for replying. Glad you sorted your issue. I believe as Alex stated, that the www-authenticate header should be sent as stated in the OAuth2 RFC so I would advise against this.\nSince you've resolved your problem and there doesn't appear to be any immediate bug with the server where it is not conforming to the spec, I will close this issue. Thanks very much for taking the time to write back.\nIf you believe there is still an issue, please feel free to comment back and we will take a further look.. We currently have someone working on a PR to make it easier to implement alternatives to JWT should you wish.. Thanks for answering this @dimvic. I trust that answers your question @lotarbo but if you do have further questions, please don't hesitate to get back in touch and I will reopen this issue.. I assume this change was made because the initial commit was a mistake. If you look at the comment above it states:\n\n// Enable the refresh token grant on the server with a token TTL of 1 month\n\nEither the comment or the code had to change. I think having a refresh token with a TTL of 1 month is a more realistic scenario than one min so is a better illustration for our examples.. Hi @jimi985 - I'm going to try and discuss this with the other maintainers to get a second opinion on whether we need a new method or whether we can just improve our documentation.\nI'm not that familiar with CakePHP but if you have an example of your implementation conflict that would be really useful in helping decide what is the best course of action here. Thanks for your help.. Thanks for the example @jimi985 - that makes things a lot clearer. Cheers for taking the time to write that. @jimi985 I've been working on trying to get this into the library and it is not easy. What I am struggling with is the terminology here.\nA scope is just a string identifier. The scope entity interface has just one function called getIdentifier() which effectively returns the scope in question.\nThe jsonSerialize() function is converting an array of scopes into their corresponding strings. The problem I see at the moment is that getScopeIdentifiers just gets scopes according to the OAuth2 RFC. ScopeEntity is just a wrapper around this string. At the moment we have two functions:\n\ngetScopeIdentifiers\ngetScopes\n\nTechnically getScopeIdentifiers is getting the scopes as expected for transport in the OAuth spec so what does getScopes return? We could rename getScopes to getScopeEntities but this seems convoluted to me.\nThe json serializable implmentation elegantly deals with this issue in my opinion so the problem is, how do we integrate this with your Cake install?\nCan you not have a function in your model which converts the DB record into a compatible entity? This would be as @simonhamp suggested in his original post:\n\nYour problems around the jsonSerialize function stem from the fact that you're mixing an implementation of it serving one purpose, with a contract for it expecting an implementation for another purpose. From what I can tell, we can't easily solve that from the oauth2-server side without breaking backwards-compatibility and I'm not even sure that we should.\n\nYou could create a class that implements ScopeEntityInterface and doesn't extend Cake's Entity class. You could then return this class from a function inside your Cake Entity as follows:\nphp\npublic function getScopeEntity()\n{\n    return new ScopeEntity($this->scope);\n}\nThis would mean you can still get compatible entities without us needing to change/remove our implementation of jsonSerializable for use with the server.\nI think this would be the cleanest solution as I think the changes proposed here risk making the package unnecessarily complicated.\nPlease let me know your thoughts on this and if there are any reasons as to why you can't implement a solution as detailed above. \nThanks for your continued help with this.. I agree that we probably should include a concrete implementation of jsonSerialize. You are right that it can only work in one manner currently so we should add it to the library to avoid implementers having to work out how this should be defined\nIf we did this, it would still not resolve your problem without you changing the way your Cake implementation works. Assuming we move the jsonSerialize implementation to a trait, would the implementation I outlined above resolve your issue?\n. Hey @jimi985 - apologies for the length of time this has been sitting dormant. After a lot of thought, I've decided that the use case for changing the implementation here isn't strong enough so am not going to go forwards with this pull request.\nI think this issue would be much better addressed by providing a scope entity trait which provides a concrete implementation of the json serializable function. I haven't tested this out yet or looked into its feasibility but I am hoping this will be a better route forwards.\nThanks for your efforts with this PR and sorry we did not end up going forwards with your implementation. Thank you for your submission. Unfortunately this is a Duplicate of #678 so I will mark this a closed. Thanks for drawing this to our attention though.. Hi @Danack - Apologies for the delayed response. This looks like a bug to me as you are correct in that we are likely double entering scopes. This shouldn't created duplicates against the access token though as these are indexed on the scope ID:\nhttps://github.com/thephpleague/oauth2-server/blob/9fc288ce53bbd198ceb7be604ca00dc3910a7d82/src/Entities/Traits/TokenEntityTrait.php#L42-L45\nThe easiest fix would be to remove the duplicate code from the Abstract Grant but I will need to do a thorough check to make sure this won't break anything. Thanks for reporting this. This issue was originally tackled in https://github.com/thephpleague/oauth2-server/pull/553 but reverted as it introduced a breaking change. I think it should be reinstated for version 8.. Fixed with merge fea577f. This looks good to merge in. Thanks for your submission @stratoss and apologies for the delay in picking this up. Hi @devonliu02. I can't see any use case for this at the moment so I'm not seeing an immediate requirement for this change. If I have missed something, please let me know and I will take a second look but I don't think this should be merged in at this time. Thanks for your submission.. I agree with @simonhamp here. It would be negligible of us to mandate an expiry timeout for the server for everyone. The issues here seem to be largely dependent on the host server/client connection which is not the responsibility of this package.\nThe package itself does not provide implementation for the revokeRefreshToken method so it is up to you how you implement this. As this is an implementation concern, I think it is best this issue is closed.. This looks good to me. Thanks for spotting this.. Hi @jilvin - sorry for the delayed response. I've tested this and I don't believe the system is providing the same access token every time. When requesting an access token I received the following results:\n{\"token_type\":\"Bearer\",\"expires_in\":3600,\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6ImRkNDUyYmMyNjFlZWY4MzRiYjk3NTAyYWRjMmNjZDI5MGQwMjlhYjYxZTIwZGFiZTRmNzkxMGY1MzA5ZmVmZjg5NjdmNTI5NDJiM2ZhZDUyIn0.eyJhdWQiOiJteWF3ZXNvbWVhcHAiLCJqdGkiOiJkZDQ1MmJjMjYxZWVmODM0YmI5NzUwMmFkYzJjY2QyOTBkMDI5YWI2MWUyMGRhYmU0Zjc5MTBmNTMwOWZlZmY4OTY3ZjUyOTQyYjNmYWQ1MiIsImlhdCI6MTUyMjcwNDc0OCwibmJmIjoxNTIyNzA0NzQ4LCJleHAiOjE1MjI3MDgzNDgsInN1YiI6IiIsInNjb3BlcyI6WyJiYXNpYyIsImVtYWlsIl19.SAUpldSZq4ZHqqwpgrylkqJ8jwiOPZ18rLkvzro-2AQKHvHRzvr6qX-RpK5-x3uAeOVlhM4qFfg3gFtsqfk39hsX0QFH8BiOfxPWIjco4cwW4b9PlzwKWfZr4Vq__qYt1IZB5Ramk0g7MUKnLiw7jHfOWl7zj6croibfhfo3xPg33OrdN2uZGVHLsRvKbsBdRkIX3BW9sKplch1YTm2CxDLn-sHZ41JdaKiYO1PsFdLNxTdMyiCjlNAbH384ybtVdCi6wSG0D_gWu-uOeX4sqvLwxvmTzjFUpvb4mbaVl_eT3-Z02_CbzLpK8dcCU2RVGhFO3FWSHAONPDTvKBwvxA\"}\nand:\n{\"token_type\":\"Bearer\",\"expires_in\":3600,\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6ImYyNGM3OTM2MzI2OTljZGNiMTRiMWUxYjc1MTc2ZTQyMjA2NzcwNmZmNjRiZWUwMTgwZTRhMGNlOTgwYjZlZjVmMGU3YzM2MzY2NTNjNjNlIn0.eyJhdWQiOiJteWF3ZXNvbWVhcHAiLCJqdGkiOiJmMjRjNzkzNjMyNjk5Y2RjYjE0YjFlMWI3NTE3NmU0MjIwNjc3MDZmZjY0YmVlMDE4MGU0YTBjZTk4MGI2ZWY1ZjBlN2MzNjM2NjUzYzYzZSIsImlhdCI6MTUyMjcwNDgyMSwibmJmIjoxNTIyNzA0ODIxLCJleHAiOjE1MjI3MDg0MjEsInN1YiI6IiIsInNjb3BlcyI6WyJiYXNpYyIsImVtYWlsIl19.PQ9HWbhebohjGrZ_sqfUijiHqTrsBhFLA4A9S5b6FdX2rkv0sP8uqbo7kH9pbDo72qEaYVRW-TGifxQ7BOnWvLvkYEAhIAR8fAgSizCMv3kaDS5pPotWu34_0H9rsbesH2S5Jxl7Fu0TC1Dw_jmLdxvUQHqHUyjNnjEvpwZWSpCZ0xN9KVA_f26l47kfgLqTXbxcINto58A5V658Lv1p92MgbJQ8K5llWPLn9pCvz2gEdJL1iVAurEss76dtx4XTQoI9BJnBHTsa5hH5mc5Jq2YixICMwmWIIBSFz5XPBuDlOVHQIfKB0My_Jr95HbeiMwYUQWKp_CHO0GudvfI9gQ\"}\nThe access token is a JWT which is split into three sections, separated by full stops (or periods). The sections are:\n\nHeader\nPayload\nSignature\n\nThe header will typically comprise of the hashing algorithm used and other information, which in our case is always the same as can be seen in the examples above.\nThe body contains the payload of the message so this will differ for each JWT if the contents is different. For each access token generated, we generate a unique ID so that our body will be unique every time.\nThe final section of a JWT hashes the header and body together to get the signature. You can find more information about JWTs here.\nAs you can see from the examples above, it is only the header that is identical in both scenarios. I hope this clears things up but if you have any further questions, please don't hesitate to get in touch. Again, apologies for the delayed response.. No problem. I suspected that might be the case. Thanks for your patience.. Sorry all. I will pick this up closer to Christmas for review and merge in if all is ok as I realise this is a problem that needs addressing soon. Thanks for your patience. Hi @erickjth - Thanks for your commit and apologies for the delay in getting to this. I think there only needs to be the one minor change to this listed in the review and it should be good to merge in. If you could make the change I will be happy to merge this in as soon as completed. Many thanks.. @jacobweber, the main reason we have dropped 5.6 support is because we are now using PHPStan. The current vesion 7 will still work fine for PHP 5.6 but we cannot guarantee future releases will run on 5.6. We won't be backporting this fix to version 6.x at this time. I've started working on a fix for this and will hopefully close it out this evening. @benito103e is correct in that we should only be adding this header if the authorization header has been used.\nI want to do a bit more investigation beforehand though. By changing this so that the header is only issued when you have an authorization header in the request, it might not solve your specific use-case.\nWe sometimes use the redirect_uri to identify the client so an incorrect redirect_uri might still issue this behaviour but this depends on if the authorization header is present. I will double check this this evening and get back to you all.. Apologies if I am missing the gist of this discussion but I just answered a similar question so thought I would respond in kind here if it is of use. Sorry in advance to @wysisoft and @simonhamp if this is not what is being discussed.\nIf I'm understanding correctly, @wysisoft wants to know if he can tie his bearer token back to a specific user. I believe you can if you store the users ID in the sub claim of the JWT. You can then read this to restrict API access to a given user. Please see the AccessTokenTrait for more information:\nhttps://github.com/thephpleague/oauth2-server/blob/9fc288ce53bbd198ceb7be604ca00dc3910a7d82/src/Entities/Traits/AccessTokenTrait.php#L29-L41\nAs @simonhamp mentioned, it is imperative that this token is kept secure because anyone in posession of this token would have access to all permitted API end points for this users data as it is for any access token issued by the server. I hope this helps and apologies again if I've not understood correctly.. @wysisoft did this answer your question or do you still have concerns?. Hello @gbgelado - there is no native way to do this in the library at the moment, but I think it is probably a good thing to implement. I will add this as an improvement idea and speak about this with the other maintainers. Thanks for the suggestion.. Closing this PR to reopen and trigger a new Travis CI build as the Travis CI YAML file has changed upstream since originally posted. This PR is being built and failing against HHVM and PHP 5.5. Reopening to trigger a new Travis CI build. Thanks @dmelo - Change looks good. Would it be possible to change your use of Yoda conditions here and revert the comparison on the token string? to be $request->getQueryParams()['response_type'] === 'token' instead? \nConvention in the package to date has not used Yoda conditions so I think it would be good to keep consistency. Many thanks. Thanks @dmelo - cheers for removing the Yoda condition. Hi @Lctrs - Thanks for your pull request. After discussions with the other maintainers we've decided not to merge in this pull request. While using is_null() is slower than === null, this is in terms of microseconds so we feel it would have little impact on the package. Thanks again for your time and apologies we did not go forwards with your contribution this time.. Hey all, does anyone still need a response to this? I was not involved with the security upgrades so might find it difficult to find an answer to these questions. In addition, we are now on version 7 of the project so I feel that this questions is fairly out dated. Unless anyone has a strong objection, I will close this issue as I don't feel I can sufficiently answer it and even if I can, I don't believe we would make any changes now.. Thanks @webclaus for the quick response. I will close this issue as I think that this change was made so long ago it probably isn't relevant any more. @Lavoaster if you would like this to be followed up, please add a comment and I can re-open this. Thank you. Hi @Herz3h - apologies for the delay in responding to you. This page might help you to decide which grant you need to use. \nIf I am understanding correctly, you have created both the API and the mobile client. Because you are the creator of the mobile app, it is assumed that there is a higher level of trust in this app so you can use the Password Grant with a degree of confidence that the credentials will not be leaked as both the client and the server are within your control.\nThe resources @raarts has listed should help inform your decision but as per the original OAuth spec, the password grant is designed for such situations.\nI hope this is of some assistance and apologies for the delay in responding. Hi @terence1990 - apologies for the long time in getting back to you regarding this. I feel that adding a getAccessToken method to our BearerTokenValidator class wouldn't be appropriate as it doesn't align with the purpose of this class which to simply validate the bearer token.\nYou had mentioned that you would like to extend this class but are having difficulties. If you could outline the purpose of the extension, we could look at this again but I feel that adding a way to directly access the JWT in this class isn't appropriate in its current form.\nI will close this PR but if you have any further comments or would like to outline your motivations/intentions with extending this class I will be happy to revisit this. Thanks for your time. I don't believe there is an issue here as I don't think the library is forcing this permission check to occur. If a developer does not want the permissions to be checked, they can create a CryptKey instance with the third argument set to false as stated above. \nThe only scenario that I can see where this wouldn't be possible is when passing a key directly into the AuthorizationServer constructor because when the key is converted to a CryptKey instance, it defaults to checking the file permissions. However, you can get around this by passing in a CryptKey instance based on the private key you had originally passed to the AuthorizationServer\nI'm closing this issue but if I have made an oversight, please do get back in touch. Thanks. Hi @bartfeenstra - sorry it has taken so long for us to get back to you. You have likely came across the answer to your question by now but in case you haven't, documentation for this change was added here.\nI think in your case the issue can be ignored but if you are still on the 5.1x branch I would recommend setting the encryption key to improve the security of your server installation. Hope this helps and apologies again for the delayed response.\nI will mark this issue as closed but if you have further questions please don't hesitate to get back in touch. Thanks. Closing issue as bug has been fixed. @2blane and @thuethe could this not be solved by your database schema?\nWhy don't you have a pivot table between users and tokens so that these can easily be searched? I think the suggestion is probably a valid one but I want to understand your specific issue before this is progressed.\nIf this change is made, it will likely be in version 8. Thank you for your time. If you could outline why you are wanting to retrieve the user ID associated with the token as well that would be much appreciated.. i suspect this might be a Laravel Passport issue which is reported here: https://github.com/laravel/passport/issues/507\n@shaklev are you also using Passport?. Thanks @alexbilbie . Closing issue as now fixed as part of PR #923 . Hi @AndrewNovikof - Thank you for your submission. If I am understanding correctly, this change will allow the redirectURI check to pass regardless of the sub domain as long as the main domain matches.\nIf this is the case, I believe it would not comply with the OAuth2 spec as it could be a security concern. Complete URIs should be used for redirection points and the server does allow for multiple end points to be registered for a single client which should address most concerns.\nIf my assumptions are correct, I don't believe this change should be merged in but I would appreciate your thoughts on this in case I've made any mistakes. Thanks. Hi @AndrewNovikof. Thanks for replying. I think as it stands, we shouldn't merge this in as it does not comply with the OAuth spec. Thanks for suggesting this though. If you have any other improvement ideas please feel free to pop in another PR.. Hi @vlotysh - sorry for taking so long to pick this up. Before you issue your refresh token, are you calling the method setAccessToken on it and passing the access token you are issuing along with the refresh token? I suspect you might not be which is why you are seeing this error. \nMany thanks.. Hi @vlotysh  - did you manage to review my question? I'd be interested to find out why you didn't have an old access token. I suspect it is an implementation issue rather than a library issue. I'd welcome any additional information you can provide to progress this PR. Thanks. Hi @vlotysh - as I haven't heard from you, and because this PR is relatively old now, I'm going to close this. If you are still having issues please feel free to leave a comment and I will be happy to review this again. This change would force the redirect_uri to be required on the request. I don't think this has to be set as we can fall back to a client registered redirect_uri if it isn't. \nI couldn't find the section you are referring to in 5.2 about redirection. Would you be able to direct quote it here so I can find which portion of the RFC you are addressing? Many thanks for your PR.. Hi @benito103e. Thanks for the quick response. I'm sorry but I don't think redirecting to the request redirect_uri provided will always be the correct approach and I can't find a justification for this change in the RFC at the moment so I think we won't be able to merge in this request.\nIf you are able to justify the reason for this change with a clear example where we should use the request redirect_uri exclusively in the context of a scope validation error, I will be happy to re-review this. Thanks again for your efforts. Thanks for this PR. Sorry that you hit this issue. I agree, the system should probably be checking for this property (and others) before using it. I have a couple of thoughts and observations that might help:\nHave you considered using JSON Schema for this? I think it might be a good fit for validating the format of the payload and the League JSON guard package would be suitable for this purpose.\nI think using a schema to validate against would make this a cleaner and clearer implementation if it can be achieved so it would be good to explore the feasibility of this if not done already. Would you be willing to take a look at this? Thanks again for your PR\n. Hi @x0st - if you are happier using this then please submit a PR using that library. Thanks. As per the spec, the returning of scopes should be optional if there are no changes and mandatory if there have been alterations to the scopes requested.\nThis change would make the server always return the scope. I think it would be better to put this decision into the hands of the implementer instead of always returning a scope to avoid the server being opinionated on this matter. \nIs it possible to change this so the scopes will only be returned an option has been set on the server to dictate this. That would make the returning of the scopes more in line with the RFC in my opinion. Hi @chervand -  I think it would be better to have them not set by default. In most situations, if we do not return a scope, the implementer can assume they are unchanged. \nIf we have these on by default, this adds overhead for each request. While probably negligible in most situations, I think it is better we err on the side of caution and only send back the scopes if they have been requested by the implementer, leaving them off by default. \nWe should aim to ensure this change is also backwards compatible. Thanks for offering help with this!. Hi @chervand - sorry for my delayed reply. I think this is going in the right direction but I realised that we would have to set the scope policy directly on the response, where as I feel this policy should be set and controlled by the server instead. It makes sense to me that this is a server policy rather than a response type policy.\nIn the authenication server at the moment, we are setting up responses in the function getResponseTypes() by setting private keys and encryption keys on the bearer token.\nI think this function would be the best place to also set the scope return policy based on the auth servers settings. That way, the server dictates this instead of the response itself.\nOne potential problem I can see with this is that we would need to call setReturnScopes from the auth server but we can pass in response types that implement the responseTypeInterface. To prevent the risk of calling setReturnScopes on a response type that doesn't have it, we might need to update the interface to ensure all response types implement this feature but this would be a BC breaking change and would likely need to be included in a future release.\nIf you can think of an alternative approach though, I'd very much welcome your thoughts.. @raarts are you still wanting to push this PR through? Are you able to look at my initial comments and provide feedback? I would be keen to get this added to the version 8 branch if possible. Thanks. @raarts thank you for this PR. Because this is a breaking change, it probably should have been implemented on the 8.0.0 branch instead of the 7 branch. I tried to change this but it is proving to be difficult. In the interest of saving time, I'm going to close this PR and create a new one off the 8.0.0 branch with your changes included. I hope this is ok. Thank you so much for highlighting this to us!. Thanks both. I think it is probably fine to merge these two PRs together as @m-bymike suggested because they are largely addressing the same issue. I will try and take a look at this later this evening. Thanks for your contribution. Hi @raarts - Do you have time to look at my comments? Wondering what your thoughts are about the changes I've suggested? Many thanks. Hi @raarts, thanks for making the changes. This is working for me now and I can confirm that your change accepts crlf line endings. \nThe only thing left that I have noticed is that we aren't explicitly matching a line ending after the header and I believe, the header should be on its own line as per the associated rfc.\nAt the moment, the changed regular expression rule will match the following:\n\n-----BEGIN RSA PRIVATE KEY-----A-----END RSA PRIVATE KEY-----\n\nI don't believe the above is a valid key format. Would you be able to adjust the rule slightly to match specific line endings? e.g. , , or .\nAfter that I think this will be good to go. Many thanks for your efforts\n. Thanks @raarts - apologies for the delay in getting this pushed through and thanks for your patience!. I think it would be good to work towards this so would hope for it to be included in the future. Thanks for the suggestion. Hi @jacobweber - this is definitely something I would like to add to the server so please feel free to submit a PR. Thanks!. Thanks both for your offers of help with this. I think that Jacob's proposal would be more likely to be accepted. If my understanding of the RFC is correct, this change is adding an endpoint rather than a grant. Thanks both again for your offers of help here.. @pilotcurler did you manage to make progress with this? Effectively you need to put functionality in your repository implementations to call your Doctrine models which connect up to your MySQL database as stated by @simonhamp. Please do let us know how you got on with this or if there is anything else we can do to assist. Many thanks. @pilotcurler I'm going to close this issue as there has been no update on it in a while now. I aim to update the documentation to hopefully make it clearer how to implement the package which should help people in the future that have similar issues to you. \nIf you do have any more concerns please feel free to get back in touch.. Thanks for providing this @gingabeard . Awesome. Thanks guys.  I will merge this in. As per @bretterer's suggestion, I will also get documentation updated but will submit this as a separate PR. Cheers guys. In principle I can't think of an issue with what you are proposing as long as it is backwards compatible but it would be good to get more information. If you can provide any links that can back up your assertions that would be appreciated. I noted from the php-encryption lib that they note PBKDF2 is slower but I didn't find much in the way of pros and cons between password vs key other than that.\nIs the use of encryptWithPassword adversely affecting your production system? If you could provide some more context about the issue being faced and any benchmarks you have got from your tests as well that would really help us to make a decision. Thanks for your time. Closing this issue as @SunMar has produced a fix which will be added to the next release. Sorry for the delay in getting this reviewed @SunMar. I've made some minor changes but all looks good so merging in. Thanks for your patience and your contribution. This isn't something we would recommend as it could compromise the security of your server. Do all of your subdomains have the same client ID? If not, is this something you could achieve? I am assuming your subdomains don't have the same client ID at the moment so if it is possible to change this, that would be the easiest option.. Hi @marslanniaz, as this is related to Passport, it would be better to log an issue there so the Laravel Passport devs can investigate. If this does turn out to be an issue with the OAuth2 server, please feel free to link us to the issue so we can investigate further. Good luck!. Hi @danut007ro - thank you for your submission. I think that it would be clearer if we talked in terms of fallbacks rather than forced checks to more closely match the wording in RFC 7636. Some devs might get confused about what the forced check value is if they've already set enableCodeExchangeProof to true.\nI think one way to solve this issue would be to have a new PKCE option called something like pkceFallbackAllowed and for backwards compatibility, set this to false by default instead of the proposed forcedEnabledCodeExchangeProof. I'm hoping it should be fairly trivial to switch the terminology around in this PR and include an associated function to enable this feature.\nFinally we could replace the existing if statements checking $this->enableCodeExchangeProof with a call to a function that could receive the code_verifier if set, and check the pkceFallbackAllowed options and enableCodeExchangeProof values to determine if a PKCE check should be performed which should keep our if statements clean and clear to understand.\nThanks again for your suggestion. If you are able to make these adjustments I think this will be good to go. Cheers\n. I believe the issues with PKCE were fixed in the latest release, which has it disabled by default so I think it would be best to maintain this default state. Version 6.1.1 has resolved the issues around encoding I believe. Thanks. No, I've not picked this up again yet sorry @mtangoo. There has been some lengthy and indepth discussion but this needs some time to work on properly. I've been busy with personal work recently (which I'm hoping to complete this weekend) so should be able to dedicate more time to this after then. Cheers. Thanks for your efforts with this @danut007ro and apologies it has taken so long to progress. After a lot of thought I've decided we should probably take a different approach with PKCE.\nI think the initial implementation was causing some confusion. As you had stated, we shouldn't be forcing PKCE as the existing implementation does. This PR tried to modify this but I felt that overall, we needed a big change in the way PKCE was being handled so it was better to overhaul the PKCE implementation entirely instead of trying to work within the confines of the existing setup.\nI created a new PR which I'm hoping will achieve this. It does away with the forcing of PKCE compliance all together, and instead only requests that clients use PKCE if they are public (and even this can be turned off). I believe this is a more flexible implementation and closer to the PKCE specs intention.\nThank you for your efforts in trying to resolve our current implementation. If you do have any feedback on the newly created PR I would welcome your thoughts. I will close this PR now. If you do have any follow up comments please do let me know. Thank you for your efforts and sorry we didn't get to merge your changes in this time.. Thanks for your PR. Thanks for this  @SunMar - I've merged in the main changes. Would it be possible you update this branch and modify the notes I've made? Once this has been done I will get this merged in too and get a version 7.1 released. Many thanks.. I see what you mean @SunMar - I think that we should leave the string information in for now as the way we have suggested generating a password is more a recommendation than a requirement. People might not have used this method to generate their password. \nI've updated the text to say that the password might be of varying strength which I think will cover us. I will merge this in and we will get it out in the next release which should hopefully be this weekend!\nThanks for making the changes and adding this feature.. Sorry, I will merge this in when the new release is put out :) . Looks good to me. Merging this in. Thanks. Thanks. I'd been meaning to make this change. Cheers for being more on the ball than me :+1: . Hi @Kingson-de  - thanks for this PR. There is quite a lot of code to go through here so I was hoping you could assist by provinding a few more details about the PR to speed things along.\nI was wondering if you could outline what alternative you are using to JWT's so I can understand the problem better? Ultimately it doesn't matter but it would be nice to have some contect here.\nAlso which specific function are you having issues extending/overriding? I am presuming it is convertToJwt() which wouldn't be appropriate for a non-JWT bearer token. If you could expand on the specific issue you are trying to resolve and why you cannot do it given the current state of the library that would be much appreciated.\n@bauer01 if you want to outline the issues you are having as well that would be much appreciated. To clarify, is it the JWT that you are wanting to replace or the encryption mechanism? I thought that initially you wanted to replace the JWT with your own bearer format but in your last post you mentioned that:\n\nThat way you can implement your own encryption of the tokens.\n\nI am assuming you want to replace the JWT with some other format rather than alter the encryption mechanisms but just wanted to confirm this is the case.. Hi @Kingson-de - thank you for the clarity. I feel at the moment there are too many things that this PR is trying to address. We've touched on:\n\nchanging encryption mechanisms (although not implemented in this PR currently)\nAdding/removing information from JWTs\nReplacing JWTs with another bearer token format\n\n@lookyman already had a PR in for review which aims to make it easier to use different bearer token formats in #874 which I feel is a simpler solution. Have you looked at that PR to see if the changes there could resolve your problem?\nI feel #874 would better address your problem so would encourage you to take a look there. Thanks for your efforts and sorry we won't be proceeding with this PR at this time\n. @Kingson-de - if you can detail how you would change the refresh token, we can maybe look at putting a PR together. At the moment the refresh token is fairly basic, containing the following:\n client ID\n refresh token ID\n access token ID\n original scopes\n user ID\n expiry date\nThis is json_encoded and then encrypted for transport. I guess you could move some of the items (such as initial scopes into the DB but what you can in small refresh tokens, you lose in time querying the database so it would be hard to justify making such a change to the main codebase.\nThe easiest thing to do would probably be to just create your own response type that extends AbstractResponseType which is already within the scope of the current codebase.. Yep, this all sounds good to me. It would be nice to have a separate function where we can specifically target the way the refresh token is created to make  the library more flexible.. Thanks for your contribution!. Hi @Zaszczyk - I've discussed this with some of the other maintainers and they haven't raised any issues so I think this is a reasonable proposal. Would you be willing/able to submit a PR for this? . Hi @Zaszczyk, just wondering if you were willing to submit a PR? If not, I will try and pick this up but it won't be for a few months yet. Many thanks.. No pressure at all. That is fine. I don't have much time to pick it up myself but if a window comes about and you haven't picked it up yet, I will add this myself. Thanks for agreeing to help out. I don't believe there are any tests for these in our test suite.. Implemented in commit  6fd3024 . Hi @enesyurtlu. If you look in the examples readme, you can see that we are requesting the scopes of basic and email which should be set on the access token returned if everything is ok. Are you requesting scopes with your auth request?\nTo take the client credentials grant as an example, if you look at the function respondToAccessTokenRequest(), you will see that we retrieve the scopes from the auth request by calling this:\n$this->getRequestParameter('scope', $request, $this->defaultScope)\nwhich eventually calls the getParsedBody() function to retrieve the parameter of scope that was passed with the request as shown below:\n```\nprotected function getRequestParameter($parameter, ServerRequestInterface $request, $default = null)\n    {\n        $requestParameters = (array) $request->getParsedBody();\n    return isset($requestParameters[$parameter]) ? $requestParameters[$parameter] : $default;\n}\n\n```\nThe methods mentioned above should get you looking in the right places. Hope this helps you but if you have any further questions give us a shout. Cheers\n. Which grant are you working with?. Ah I see. When you send an access token to your resource server, it should be validated using the function validateAuthenticatedRequest().\nThis function checks if the access token has expired or been revoked. It it hasn't, it parses the JWT, and returns the original server request with the scopes, user ID, client ID, access token ID attached. Once you have this, you can query the server request to get the original scopes and deal with them how you want.\nSee the implementation of the BearerTokenValidator for more details.. Did this help @enesyurtlu?. Awesome. Glad you got going again! Hope everything else goes ok. Hi @dorin-niscu. Thanks for raising this. The reason this change was made is that the server wasn't  conforming to the RFC spec. If a client issues an auth request with no scope, the server should either:\n\nUse the default scope specified by the Auth end point\nIssue an invalid scope response if no default is set\n\nUsing vanilla OAuth2 server you can just call setDefaultPassword but I appreciate that Passport doesn't have an equivalent at the moment.\nI will need to think this over but will get back to you soon with a path forwards. Apologies for any inconvenience caused.. @dorin-niscu I've temporarily removed the check on empty scopes. Can you upgrade to version 6.1.1 and confirm if this has resolved your problem? Thanks. Long term we need to change the server so that if an auth token request is issued without a scope, and you have not specified a default scope, the server should be responding with an invalid token response as defined in the OAuth spec.\nThe package provided a setDefaultScope method to allow you to set a default scope for use in this instance. The problem is that there isn't an equivalent function in Passport at the moment so to save problems for people, I removed the check. I will need to discuss with other maintainers the best route forwards to get this change back in place without causing issues for Passport users. . Going to mark this issue as closed now as version 6.1.1 has resolved you problem. Thanks for reporting it to us and apologies again for any inconvenience caused.. Hi @alexbilbie. It is the last section of 3.3 that makes me believe we must have a scope present although, I admit, it could be worded more clearly:\n\nIf the client omits the scope parameter when requesting\n   authorization, the authorization server MUST either process the\n   request using a pre-defined default value or fail the request\n   indicating an invalid scope.  The authorization server SHOULD\n   document its scope requirements and default value (if defined).\n\nBecause of the word must in there, I believe we have to fall back to using a default scope in most instances. If it isn't set, we have no option but to issue a failure.  . OK I see. I had assumed a scope must always be some string and hadn't thought of the scenario where a default blank string could in itself be considered a default state. With you now!\nMain thing I am wondering now is in what scenario would we issue an invalid scope as per the rfc? I presume this would be if the default scope was set to null. Is this worth implementing? I can't see many people wanting to do this to be honest but would welcome some guidance. Merged PR in as of commit 3999c41. I believe this is working as intended. If you have registered multiple redirect uris, you must pass a redirect_uri with your auth request so that the server knows which of the multiple redirect uris to use for the given request as shown in the code below:\n$redirectUri = $this->getQueryStringParameter('redirect_uri', $request);\n        if ($redirectUri !== null) {\n            if (\n                is_string($client->getRedirectUri())\n                && (strcmp($client->getRedirectUri(), $redirectUri) !== 0)\n            ) {\n                $this->getEmitter()->emit(new RequestEvent(RequestEvent::CLIENT_AUTHENTICATION_FAILED, $request));\n                throw OAuthServerException::invalidClient();\n            } elseif (\n                is_array($client->getRedirectUri())\n                && in_array($redirectUri, $client->getRedirectUri()) === false\n            ) {\n                $this->getEmitter()->emit(new RequestEvent(RequestEvent::CLIENT_AUTHENTICATION_FAILED, $request));\n                throw OAuthServerException::invalidClient();\n            }\n        }\nIf you have only registered one redirect_uri against the client, there is no ambiguity so you can omit the redirect_uri from the auth request and the server will use the pre-registered redirect uri.\nThe count($client->getRedirectUri()) !== 1) check ensures that if you have more than one redirect_uri registered, you must specify which one you want to use for your auth request.\nI hope that I've explained this properly but if you have any further questions or comments please let me know. Cheers.. Hi @tdondich - thanks for raising this. We've had a PR submitted to fix this issue which is currently uner review. It is PR #805. I will close this issue for now as it is best to track in the raised PR. I've contacted the author of the PR to see if he has time to address the comments raised. Thanks for notifying us about this. Thanks for reporting this @Jimbolino -  I will try and look into this shortly. This issue will also affect the Implicit Grant. I think the problem here is that we are performing some of the validation inside the canRespondToAuthorizationRequest() function.\nIt would be better to just return true for the grants that can respond to authorization requests to allow the flow to continue to the validateAuthorizationRequest() function and place all actual validation inside there.\nThis will mean an interface change as we will no longer need the request object for the canRespondToAuthorizationRequest() function so will need to be done as part of a major release at some point.\nRe-opening for the timebeing as the issue will need to be rectified for the Implicit Grant as well. Long term, it would be good to implement the changes outlined above and remove validation from the canRespondToAuthorizationRequest() function completely.. Sorry, I hadn't noticed that the implicit grant and auth code grant are differentiated in their check by the response type, hence the need for the request being passed in at that point. Will require some further thought. I've had a big think about this and I actually think the initial functionality was correct. Although the error messages at first appear confusing, they are actually valid and appropriate given the circumstances.\nUnlike the request for an access token, we don't specify the grant type when requesting auth tokens. The two grants that can validate authorization requests are the implicit grant and the auth code grant.\nBoth require a response type to be specified and a client ID according to the spec. The response type is the only differentiating factor here and it is how we route to an appropriate grant e.g. code for the auth code grant and token for the implicit grant.\nIf you are omitting the client ID from a request, this is not a valid call to either the implicit grant or the auth code grant. If the library responds with an invalid client response, we are assuming you meant to call either of these grants but we cannot make that assumption as there is not enough information to go on.\nA developer might have implemented a custom grant which can also validate authorization requests but doesn't require the same set of parameters for example. \nBecause it is a requirement to provide the client ID to these grants, it is a calling issue rather than a library issue when you do not. We cannot make assumptions about what you intended in this instance.\nI think that the hint for the exception probably needs to be updated as you never pass a grant_type for an auth request but other than that I don't think there is much else to be done. I am going to revert the fix so I can release some of the unreleased features. Sorry it has taken so long to investigate this. Thanks for reporting this guys. I will aim to take a closer look at this on Tuesday evening. Apologies for any inconvenience caused.. Thanks for clarifying @tominek and glad you solved your issue. @samiboukadida, could you confirm what is being pass in $oldRefreshToken['scopes'] if it is not an array? Many thanks. As an aside @tominek - we are currently looking at alternative methods to surface Scope IDs so we don't rely on jsonSerialize as it is too easy to make mistakes with implementation. @samiboukadida, because this issue has sat idle for a few months, I'm going to close it, but if you do have further information, please get back in touch and we can look at this further. Many thanks. Thanks @simesy - I've updated the error message to recommend 600/660 but see no issue with having read only be accepted. Hi @liverbool - please can you provide some details on what bug this is fixing and how to reproduce the error as it is not clear to me from this PR. Thanks for your help. I reinstated the check on the client redirect uri to ensure we only use this is one redirect uri has been registered with the client as we don't want to always grab the first redirect uri if multiple have been registered against the client. In situations where multiple redirect uris have been listed, we should enforce that the specific redirect uri is passed along with the auth request. Hi @amidia. Thanks for taking an interest in the server. Have you had a look at the examples provided in this repository? They serve as a good starting point for seeing how an implementation might be accomplished so I would recommend have a look through them to get you going.. If you have a specific grant you are struggling to implement, please let me know and I will be happy to try and guide you through the process.. Thanks for spotting this and providing a fix. Much appreciated. This looks good to me. Thanks for your contribution @kpn13 . Apologies for this. I've been working through the old pull requests to progress them but haven't got to yours yet. I am planning on releasing version 7 this week so will try and get this included in time. Very sorry for the delay and thanks for both of your help with this. Hi @iliepandia - for your ScopeEntity implementation, how are you defining the abstract function jsonSerialize()? If you get it to return $this->getIdentifier(), does this fix your issue?\nWhen we JSON encode the ScopeEntity's, we should use jsonSerialize() to pass back the identifiers that we want to have encoded. If you could let me know if you are doing this or not and I will look into this further if not. Many thanks. Yeah I see how this could be very confusing. When implementing a scope entity, you are forced to define jsonSerialize() but I can't see anything in the docs to point you in the right direction with this.\nBecause your implementations issue has been resolved, I will close this issue but I will keep @jimi985's PR open because this probably does need to be addressed so others don't hit the same problem. At the moment I'm leaning towards improved docs but I will need to look at the code more closely.\nThanks very much for raising this and for your suggested fixes.. I've removed the temp vars and @var comments. I don't think these are needed as the variable types are already type hinted in the methods argument list. Other than that, looks great. Thanks for the submission. I will get this included in the release that is going out shortly.. Ah of course. Sorry, I didn't spot this. It probably is best to have these in then although long term it would be good to remove them. I will reinstate them and get this merged in. Thanks again. I think this is probably something we do need to overcome, especially if we are to make it easier to add custom claims to JWTs as has been mentioned in another PR. \nThis PR has exposed a slight architectural problem here. We've added a method to the bearerTokenValidator to extract the claims but I think this functionality is probably outside the scope of what a validator should be doing.\nArguably it would be nice to just have the validator verify the token but then have a separate function to determine what to do with the token once it has been validated to keep everything nice and modularised. \nThe problem I see at the moment is if we were to do this, where would this extraction code be house? No obvious answer springs to mind for me. Off the top of the head we might need a new response type for the resource server which we can use to provide such extensions but I haven't really thought this through so there might be complications with that which aren't immediately obvious. While having a new method in the validator to create the http response would be the easiest solution, I don't believe it is the correct solution as it will muddy the responsibilities of our classes. I think pursuing an alternative approach would be better for the longevity and maintainability of the code base.\nThe class is currently generating a response but I think if we are going to adjust this, we should look to improve the class when we do so, and separating the concerns to make extensibility easier would be my preferred option.. Sorry yep, I'd misread there :) . Hi @michaeldnelson. That's great to hear that you're finding the package useful. Thanks for supporting it.\nThe source files themselves don't use the getAccessToken method directly as you've stated. The reason we have access tokens at all in the refresh entity is because the server will issue a refresh token when it sends  an access token so bundling the two together in a single entity seems the logical way to go. We have a setAccessToken() method to store the access token in the entity and have a complimentary getAccessToken() method should the implementer need this for any reason.\nWe use this method in our tests for example, to easily verify that when a grant responds to an access token request, it has set the access token correctly.\nI would be hesitant to remove this function as other implementers might be relying on it for their own tests/use cases which I'm not aware of. It isn't adding any overhead to the base running of the system but does allow the code to be more extensible. I hope you understand but if you have any more questions feel free to ask about this.\nI'm not entirely sure how your scenario would work. When you issue the access token, you would need to store it in the DB so you can later validate against it, even if it is only used one time. You could set a very short lifespan for the access token as you mentioned but I can't think of a way to not store the access token within the confines of the OAuth spec. \nI would imagine you would actually increase the load on your DB slightly if you went down the route of having very short lived access tokens as you would have a lot more writes to your database whenever you need a new one. You would also need to go through the authentication process a lot more. Apologies if I've misunderstood the scenario you outlined but I hope this has been of some assistance.. Sorry, my original comment was incorrect. I should really check these things before responding so thank you both for correcting me.\nBecause the package use JWT as you noted, no DB call is required to check the validity of an access token. However, as you also noted, we do need some way of checking if a token has been revoked which cannot be achieved from the JWT alone.\nIn your scenario, even though you have short lived access tokens, I would not recommend removing the ability to revoke these tokens by not tracking them in some way. Although the period that your server could be compromised would be short lived, it would still  be a security concern to have no way of preventing the compromised access token from being used short of changing the code or turning off complete access to the server.\nIf you are concerned about the overhead of checking if the access token is revoked, I would recommend looking at differing storage solutions to arrive on one which minimises the overhead for you but still provides an adequate level of security to not be compromised. As @mtangoo noted, we do not make any assumptions about what storage you use so you are free to make this choice.. Merged in. Thanks for the efforts here @lookyman . @michaeldnelson the last link you posted is for a draft version that has not been finalised yet I believe.\nI think you might be right that the aud should be set to the authorization server endpoint. It looks like it has been incorrectly set to identify the client instead. We aren't, to my knowledge, officially implementing RFC 7523 at present but we are following the JWT RFC which confirms your assertion about the aud claim.\nAltering this would be fairly tricky though as it would break BC. I think it probably is something that needs addressing but careful thought would be needed to not immediately invalidate all active access tokens.. Hello @jacobweber - The tokenEntityInterface and refreshTokenEntityInterface both require getExpiryDateTime() methods to be implemented.\nThis function is called by the server to retrieve the expiry date for an access token to package up and send back to the client in an http response. As long as you have implemented the function, the package should use the function correctly.\nFor example, the BearerTokenResponse uses this method when generating an HTTP resonse:\nhttps://github.com/thephpleague/oauth2-server/blob/28e1418f64a114a066eda23c5846353f30399aaf/src/ResponseTypes/BearerTokenResponse.php#L25-L32\nThe Implicit Grant also uses it for its redirect response:\nhttps://github.com/thephpleague/oauth2-server/blob/28e1418f64a114a066eda23c5846353f30399aaf/src/Grant/ImplicitGrant.php#L210-L224\nAs long as you implement the function correctly in any entities that require it, you should be good to go. \nThe package provides some traits which make this a bit easier for you as they have ready made implementations of these functions should you so wish such as in the TokenEntityTrait:\nhttps://github.com/thephpleague/oauth2-server/blob/28e1418f64a114a066eda23c5846353f30399aaf/src/Entities/Traits/TokenEntityTrait.php#L57-L65\nWhen the package receives an access token, it is passed to a validator. By default, this will be the Bearer Token Validator in the form of a JWT. The JWT will be parsed, and the data within it is validated against validation data passed to the validate function. In our case, we just pass the current date time to validate against:\nhttps://github.com/thephpleague/oauth2-server/blob/28e1418f64a114a066eda23c5846353f30399aaf/src/AuthorizationValidators/BearerTokenValidator.php#L67-L78\nIf you need any further assistance the implementation in the examples is a good place to look. I hope this helps. Cheers\n. Hi @suhaboncukcu. The function getClientEntity() accepts four arguments:\n\nclientIdentifier\ngrantType\nclientSecret\nmustValidateSecret\n\nIt is up to you where you store your actual clients information. If they are stored in a DB, you must retrieve the clients from the DB and then compare their hashed client password stored in the database against the client secret you have been provided in the arguments list.\nA very simplistic example of this is shown in the examples of this library:\nhttps://github.com/thephpleague/oauth2-server/blob/b8b92e59255ffe586ddd50a3975d7219ca9a8c38/examples/src/Repositories/ClientRepository.php#L22-L42\nIn the example, we've just created an example client directly in the code but in a production system we would retrieve this from some data store.\nI hope this has helped but if you have any further questions please let me know. Cheers and good luck!. Sorry for the delayed response. It looks like you've arrived at the solution yourself which is excellent. As you'd noted, the package checks a client secret in the function validateClient which is in the AbstractGrant. This function extracts the client_secret for the request passed to it. In the auth code grant's case, we don't check this when requesting authorisation but can check it when requesting an access token.\nI wish you luck in your project!. Looks good to me as well. Thanks @Zaszczyk . This is an oversight. Thanks for reporting. Fixed in commit 99e42f6f257a7d865a04898a7591fb7f20209917. Hi @jackdpeterson. Thank you for your PR. It isn't clear to me what issue this is addressing. The grant first grabs the redirect_uri from the request and then compares it against the redirect uri stored in the authorisation code.\nThis is in line with the following section of RF6749:\n\nensure that the \"redirect_uri\" parameter is present if the \"redirect_uri\" parameter was included in the initial authorization request as described in Section 4.1.1, and if included ensure that their values are identical.\n\nThe change proposed in this PR would break this mechanism so I don't believe it is something we should be merging in. For this reason, I'm going to close this PR but if you do have further comments please feel free to respond and I will look at reopening this if necessary.\n . Hi @Zaszczyk - we are moving towards a new release soon but are awaiting some other tasks being finalised before release. I expect this will be within the week. \nIn the meantime, you can always grab dev-master which should work fine but I wouldn't recommend this as if you forget, you might upgrade later to an unstable version.. Thanks for this @lookyman. I've had a look through this and had a few thoughts. If this was to be accepted it would need to be a major release as it is changing so many interfaces. I expect version 8 would be some way off at the moment as we only released version 7 recently.\nI think it is great that we make the library as flexible as possible so any PRs to support this are appreciated. I've had a quick look through this and was wondering if you could outline your reasoning for moving the conversion from the access token to the responseType.\nMy initial thoughts are that we could just make the accessToken implement a more generic conversion function. It seems appropriate to me that the conversion is sitting within the access token because in the case of the JWT conversion, we rely on many of the internal functions within the access token itself to make the conversion e.g. getScopes, getClient etc. \nMoving the conversion to the response type means we need to pass the access token and call the access tokens functions which just seems a little messier to me although there might be good reason for this.\nIf you could outline what issues there are with keeping the conversion in the access token for you, so I can better understand the motivations for this change, that would be much appreciated. Thanks for your time. Okies I see the logic there. Thanks for clarifying. I don't see the function as that different from a _toString function or someting in Java like where you can convert a string to an int or float with inbuilt functions. The object itself both stores the information and has the ability to output itself in a different format. \nGiven that, and the fact that we are relying on many of the functions already within the access token object to make the conversion, I think it is probably best we still keep the conversion function within the access token itself.\nThe main problem I see is the naming of the function itself. If, as you've noted, you wanted to use a different mechanism for transporting the access token, the name convertToJWT doesn't lend itself well for this purpose as it is too specific.\nI think the best approach with this would be to just rename the function from convertToJWT to something more generic like getResponseString or something similar. I'm sure there are probably better names but that is the first one off the top of my head.\nThis would still be a breaking change so would have to wait until version eight but would let this classes interfaces be overridden more easily, with less change in the codebase overall.\nWRT implementing Pasteto, I think this is something that would be desirable for implementers but I'm unsure we'd bring this into the core of the package unless there were clear benefits such as reduction in size of the payload which some people have complained about with the current JWT setup. I haven't looked into this much though and this might  be something that Pasteto offers but we must ensure we are catering for the desires of most users without increasing the size of the package unnecessarily. \nBy making the access token more generic, we can then leave it up to the implementer if they want to move away from JWTs.. Great suggestion. Thanks @frankdejonge . I've removed the native type hints for now as I'd prefer these were implemented project wide instead of in sections of the code.\nI think this is pretty close to being able to be merged in but I'm unsure about the new method name now I've reviewed it again.\nIn our code we now can have implementations as follows:\n$this->accessToken->convertToAccessToken($this->privateKey);\nThis seems strange to me due to the naming we have used. Why would an access token object need to be converted to an access token? Its name implies it already is one. I'm worried that the current name of the function isn't clear enough.\nI have been racking my brain trying to think of a more appropriate name. I had thought we could possibly use __toString() but it doesn't accept an argument meaning we would need to set the private key in advance which is probably more trouble than its worth.\nThe best name I've come up with at the moment is simple build, which would align it with the JWT libraries builder class. I think that it would make more sense to call the function this so the code would then read as follows, which to me, seems  more natural/intuitive.\n$this->accessToken->build($this->privateKey);\nIf you have any thoughts on this @lookyman - or anyone else for that matter, I would very much appreciate a second set of eyes for this proposed adjustment\n. I've also changed this to merge into branch 8.0.0 which I created today. Hmmm. As far as I can tell, we set the private key for the response type but it is just passed to the access token. It might be more appropriate to set it on the access token as that is the entity that is using it. We can easily do this in the issueAccessToken function.\nWe could then use a __toString() magic method and do away with the instance on the response type if I haven't missed anything.\nDo you want to have a go at implementing this @lookyman? If not, I'm happy to make the changes tomorrow. Cheers. I've updated the code @lookyman to use __toString() and set the private key in the access token for encryption. Let me know what you think. Cheers.. Good stuff. I will merge it in now :) Cheers for all your efforts with this. Can you post what your authorize.php file looks like? If what you have provided is the full contents of your file, as @simonhamp says, this isn't an issue with this package as we don't provide a file called ClientRepository. Thanks for the fix @steverhoades . When logging in to a system, you are authenticating yourself; proving that you are who you say you are. OAuth 2 is used for authorisation which is subtly different. Authorisation just gives the posessor of an access token the right to access a protected resource. Once you've got an access token, that is all that is needed to access the resource, without needing to continually authenticate yourself.\nOAuth 2 was not intended to be a solution for authentication (although it does authenticate clients). There are extensions built on top of OAuth 2 such as OpenID that do deal with authentication, but we have yet to implement this for the OAuth 2 server. We might in the future though as it has been a fairly frequently requested feature.\nThe server uses JSON Web Tokens which have the ID of the user that provided authorisation to access their protected resources embedded in the token. This is stored under the sub claim and can be seen being set in the AccessTokenTrait:\nhttps://github.com/thephpleague/oauth2-server/blob/9fc288ce53bbd198ceb7be604ca00dc3910a7d82/src/Entities/Traits/AccessTokenTrait.php#L29-L41\nYou should use the user ID stored to restrict API calls to a specific user. You can also use scopes to further restrict the access of the client that possesses the access token.\nI hope this helps but if you have any further questions please feel free to shout.. What is the error message you are receiving?. Yeah, @simonhamp is right. You should have a user login that is not relying on OAuth 2. OAuth 2 is for protecting your API, not the login to your application itself. . @nealoke I'm going to close this issue as there hasn't been any activity in over a week. If you still have questions please feel free to comment and we will reopen it for further discussion. Hi @coloradotex. How have you implemented your encrypt and decrypt functions? Are you using the provided CryptTrait or have you implemented your own encryption mechanism?. I don't think it would be a reverting of token issue for you. The error message you are talking about can only be thrown if the server cannot decrypt the refresh token. \nIf there were issues with revoking the token, you would receive the error message Token has expired. \nWithout seeing your implementation though, it is going to be very difficult to diagnose this issue for you. There could even be something wrong with the refresh token that is being sent and your implementation of the OAuth2 server is fine.\nThe fact that this is sporadic is what is quite puzzling. Sorry I can't be of more assistance but I would still take a look to make sure you are using CryptTrait as a start.\nIf you are able to share the codebase somehow that would also be a big help but I appreciate this might not be possible.. Hi Terry. Sure, you have twitter you can DM me there (at sephster) or you can email me (andrew at noexceptions dot io). Closing this issue as I believe Terry and his team resolved this by not revoking refresh tokens immediately. @coloradotex if you still require assistance please let us know and we will be happy to re-open this ticket.. Thanks for responding and providing an update @coloradotex - much appreciated and glad you've resolved your problem.. The auth code grant is typically used by third party clients and web apps such as SPA's that cannot usually keep confidential information secret. Because of this, the server does not expect the client to transfer their client secret if they are using the auth code grant, and does not expect the client to be trusted, so will not validate their client credentials.\nInstead, we do a basic check ensuring that the registered redirect uri(s) sent, match with what was originally registered. Please check the RFC section 2.3 for more information. \nI hope this answers your question, but if not, please shout.. Hi @danisetg. This question would be better being posted in the Laravel Passport github repository as this is an implementation detail for that package. Under the OAuth2 spec, you are right in asserting that a client can be used for multiple users. \nI'm not clear from the example here how Passport uses this field. I will mark this as closed an advise you to raise this with the Passport devs. Cheers. The library itself doesn't actually implement the persistNewAccessToken so I think it will be an implementation issue.\nHave you inspected what you are passing as an $accessToken? Take a look at the implementation for persistNewAccessToken in Laravel Passport. Does this give you any clues about where the string conversion is occurring?\n. @hgs81 I'm closing this as I haven't heard back from you. This issue is probably better dealt with in Passport as it is dealing with a Passport implementation and I see you have opened an issue in that repository as well.\nAt first glance I suspect this is something to do with the conversion of the expiryDate from a DateTime object to a string but couldn't say for certain without seeing more of your implementation. I hope it is sorted for you soon and sorry I can't assist any further. If you do provide more information I will be happy to take another look at this. Cheers\n. The latest versions of both libraries should be stable. For OAuth 2 Server it is version 7.1.0 and for Passport it is version 6.0.0. I think this implementation could be simplified. Ideally what I'd like to see in the package is a language file  which will hold all of the various error messages and refactor the library to read from this language file instead of have the strings hard coded.\nBy doing this, we can then just specify the language we want to use and have the code retrieve the appropriate message so we don't need to do on-the-fly translations. The codebase should retrieve the appropriate string straight from the language file itself.\nI think it is appropriate that we can have differing messages for the same error type. For example, a run time exception can be raised for many different reasons but in general, devs just raise a run time exception with a custom message to hint at the more specific issue. Obviously this can only be done up to a point before you want to separate out your exception types but I think the current implementation doesn't require this. . Agreed. Adding as an improvement . The finalizeScope method is probably best used for this purpose. It will modify the requested scopes by the client so would be perfect for this. As @simonhamp  says, this is an implementation detail so would be unlikely to be included in the core library. Closing this PR based on review. Yep, @bitgandtter is correct. The scopes requested by the client are displayed to the user and it is up to the user to accept or decline. If you, as the owner of the auth server, want to restrict certain clients to specific scopes, you can do this using finaizeScopes but as this is something that would not be required by most users, it is you as the implementer who should implement this.\nWhen a client registers with an OAuth server, they only need to provide information on whether they are public or confidential and their redirect URIs. There is nothing in the specification that stipulates a client should also provide the scopes they intend to use.\nThe use case you are describing is not really described in the spec as as @bitgandtter explains, it is the user and not the server which will typically dictate what scopes the client has access to. I'm sorry that your use case isn't catered to out of the box in this library but I would be surprised if you find any OAuth implementation that does this as it is not a scenario outlined in the OAuth spec.. Hey. You are probably wanting to use the event emitters. Details about them can be found here. Hope that helps!. It needs further investigation. If the client is confidential or has been issued auth credentials, it must authenticate with the OAuth2 server.\nThe package first checks for Basic HTTP auth and if not present, will look for the client ID and password to try and authenticate the client. \nEven the implicit grant is not recommended now for SPAs so we will need to update the documentation to reflect this. There might be an implementation issue with the password grant here where it should allow no client auth which seems to be the case given the spec but we will need to look at this more closely in due course. Oops, I didn't mean to close this. Clicked the wrong button sorry :). Documentation has been updated to not advocate the password grant for SPAs. At the moment it states that you should use the implicit grant but I believe current best practices are actually to use an Auth Code grant without passing the client secret. This can't be achieved with the library at present so I've left it recommending the implicit grant for now. Will need to do some more investigation into this.\nAlso, the library can accept two client auth mechanisms in its current format which does not conform to the RFC.\n\nThe client MUST NOT use more than one authentication method in each request.\n\nAt the moment I believe we accept basic auth and client_secret etc but we don't enforce that only one of these should be specified. This should probably be changed to conform to the specs better but I will need to do a more thorough investigation before making any changes.\nI believe we will also need to update the diagram. @NoelDeMartin good question and apologies for any confusion I've caused. As I had stated in #881, the Auth Code Grant can be used without a secret according to the OAuth2 specs. However, I've made a mistake with my assertions in #881. \nThe initial auth code request doesn't require a secret but you are right in stating that at the moment, the access token request _does indeed require a secret because it uses the default _validateClient function which mandates that a secret must be provided.\nI'm working on a fix for this at the moment but it is taking some time to get out the door. It will be a breaking change so won't be released until version 8. The main challenge is that the client retrieval function both validates and retrieves client information which is problematic at the moment.. Yes it will. I've made some progress on this but keep hitting gotchas. The new PKCE handling should:\n\nsupport PKCE if a code challenge is sent\nForce PKCE support for public clients if this option is specified\n\nThis requires a couple of modifications to the code because the auth code grant doesn't currently support public clients. In addition, we have challenges around the way clients are authenticated because we also use this method to get client information.\nFor my changes to work, we need to know if the client is public or private in isolation. I've started to build this out but there is still a bit of work to do. You can see my progress here: https://github.com/thephpleague/oauth2-server/compare/8.0.0...Sephster:force-pkce-for-public-clients. I know this is likely an obvious question but bear with me so we can rule out everything.\n\nHave you var dumped the $payload in both instances?\nHave you confirmed that the key being used for encryption (usually set in the setEncryptionKey function in the Crypt Trait) is identical for both calls?. Hey @aluciffer - have you resolved your issue or do you still require assistance? Many thanks. Are you sure it is using two different keys? It shouldn't be so if this is the case, you just need to resolve this problem.\n\nI'm afraid I don't have any other immediate ideas. If you have a public repository of the implementation I could take a look but other than that, I'm out of ideas. \n$this->encrypty() should return the same value every time given the same payload and key. If you are getting differing results it either has to be the payload or the key that is different in both instances. \nSorry I can't offer more assistance at this time but there isn't enough information to go on.. You would have to update the key between calls, which to be honest, is unlikely if you aren't sure how this happens.\nI'd stated earlier that if the payload and key are the same, you will always get the same output which is true. However, it occurred to me that it would be unlikely you would ever provide the same payload as the expire time is typically going to be different depending when you create the payload.\nI'm finding it hard to follow this issue as there are so many instances of code being pasted.\nIf I go back to the initial post, you state that this section of code:\nphp\n$params =[\n    'code'  => $this->encrypt(\n        json_encode(\n            $payload\n         )\n    ),\n    'state' => $authorizationRequest->getState(),\n];\nis not producing the same encrypted code as this section in the AuthCodeGrant:\nphp\n$this->makeRedirectUri(\n    $finalRedirectUri,\n    $params\n) . PHP_EOL .\n.$this->makeRedirectUri(\n    $finalRedirectUri,\n    [\n        'code'  =>  $this->encrypt(\n            json_encode(\n                $payload\n            )\n         ),\n        'state' => $authorizationRequest->getState(),\n    ]\n);\nWhere is the first section of code from?\nWhat errors are you getting when running your code? What is the specific exception?\nCan you provide access to the full codebase so we can reproduce the issue? It is really hard to debug this with snippets of code so if you can provide access to the full codebase that would be ideal.. I'm closing this issue due to lack of activity/response. If you are still having problems and require assistance @aluciffer, please get back in touch here and we can reopen the issue for further investigation. $response->getBody() returns an instance of the StreamInterface. I would check this to see if it is seekable and writable using the following calls:\n$response->getBody()->isSeekable();\n$response->getBody()->isWritable();\nThat would be my first port of call to ensure there is nothing funky going on with the stream. Good luck and please let us know how you get on. Hmmm, this is really strange. Can you try the following?\n```php\n$responseParams = array_merge($this->getExtraParams($this->accessToken), $responseParams);\n// Lets find out the response params (which you have stated are present\nvar_dump($responseParams);\n// Check the response BEFORE we set the headers\nvar_dump($response);\n$response = $response\n    ->withStatus(200)\n    ->withHeader('pragma', 'no-cache')\n    ->withHeader('cache-control', 'no-store')\n    ->withHeader('content-type', 'application/json; charset=UTF-8');\n// Check the response AFTER we have set the headers\nvar_dump($response);\n$response->getBody()->write(json_encode($responseParams));\n// Check what we are writing to the body\nvar_dump(json_encode($responseParams));\n// Check the response AFTER we have set the body\nvar_dump($response);\nreturn $response;\n```\nThat's a lot of var dumping but it should give a better idea of what is happening. If this doesn't turn up anything, I think we'd need to see the full codebase to progress this. @galab-devision-bg did you try the above? How did you get on?. @galab-devision-bg I'm closing this issue as we haven't heard from you in a while. If you would like to progress this further, please get back to us and we can reopen this. Cheers. The library hasn't really been designed to use multiple encryption keys. In general, it is very unlikely that your keys will ever be compromised because, as long as you are following modern practices, it is nigh on impossible to break them.\nWe are taking the stance that if you keep your key secure, you shouldn't have a need for multiple keys. Realistically the only way that your keys could become compromised is if someone gains access to your server and if this happens, all keys on the server will be compromised anyways and need to be replaced. \nIf you have any literature indicating that it is good practice to use multiple keys for different clients then please do share it but I don't believe this is something we would cater for at this point as there isn't a clear benefit and it makes the library more complicated.. Personally I don't feel this functionality should be implemented in the server. It feels very much like a use case that would only apply to a select few. I would advocate just providing some customisation that can use this library but is not included in this library.\nScopes aren't generally used in this manner. It is assumed that once you have issued an access token with it's associated scopes, those scopes will remain available for the life time of the access token. If you no longer want those scopes to be active, you must revoke the access tokens and ask the end users to login again.\nStoring requested scopes and re-adding scopes after the access token has been issued is very much a non-standard implementation so I don't feel it should be supported here.\nI would advise you create a customisation for your own implementation @christiaangoossens as this will cater to your exact needs. It is an interesting use-case but one that I feel falls outside the remit/responsibilities of the core package.. Thanks for the clarification @christiaangoossens. As an alternative, and probably simpler solution, why can't you just grant the scopes that are potentially going to be disabled, regardless of their current state? \nBy doing this, you can use the API responses to actually dictate if the resource is currently accessible. You don't need to mess around with the scopes against the token, the server would simply say, does this client have permission to access this end point, and allow them to always call it. \nIf the endpoints data isn't currently available you could then just change the endpoint to return a 403 for unauthorized or 503 for service unavailable.\nThis does assume you'd have a fairly simplistic relationship between your scope and endpoint but if not you could always develop some middleware for the resource server to handle more nuanced relationships.. I'm afraid I can't help with regards to Doctrine as I don't use it myself. However I think the advice given by @lookyman is pretty spot on. I just wouldn't use the traits if they are causing you problems and implement the interfaces instead. \nThe traits aren't required to use the library, they are just handy implementations that you can use if applicable to your use case or for reference for your own implementations.\nEither write your own traits or put the required functionality directly into your implementation and avoid using the provided traits altogether. The errors thrown if you've missed a required function for one of the interfaces should set you right.\nPlease let us know if this helps or if you have any further questions.. I'm not aware of a WordPress integration. I was searching for one the other week but didn't find any that use this library. Hopefully someone from the community might know of a good example\nOn 6 May 2018 13:15:41 BST, jpmelnik notifications@github.com wrote:\n\nDo you have an example with Wordpress REST Api?\nThanks\n-- \nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/898\n. @jpmelnik I'm going to close this issue due to a lack of activity. I'm not aware of any WP plugin but if someone is, please feel free to comment here.. Cheers Simon, that would be good. Yeah, I want to get some tests in for this so didn't merge it in last night. Will try and add some in this evening to capture this as it was a bug we didn't catch initially so should probably be covered.\n\nI think this will resolve the laravel/passport#340 people had seen but if you are able to test this on a Passport instance that would be appreciated. . I've added in tests but this now breaks BC. I changed the invalidClient() method so we could access the ServerRequest object to check the header parameters. Previously we were just accessing $_SERVER which was not good practice anyways.\nBecause this is a BC change it will need to go into version 8. We could probably release the fix without the supporting tests in the knowledge that they will come in later so we aren't delaying the bug fix. This would be my preferred option. Thoughts welcome. If there are no objections raised, I will merge the fix into master this evening and leave the tests for version 8.. trigger_error() should be used in conjunction with an error handler which will surface the error for you. You can register an error handler using the function set_error_handler(). \nUnfortunately, I don't know enough about Drupal to advise on how error handling is used in that application. \nYou'd mentioned you don't get an error when the permission is set to 000. Does this also occur when set to 777 for example, which is similarly not allowed? I suspect you won't see an error if the permissions are set to 777, in which case, I believe this is an issue with the error handling in Drupal/simple_oauth/your setup.\nIf you could let me know about the 777 permission, we can progress from there. Thanks\n. No problem @caseylau. It looks like this is an issue with simple_oauth so I will close this issue. If this turns out to not be the case, please get back in touch and we can look into this further.. I don't think fileperms() is reliable on Windows and is only really viable on Unix systems. This is one of the reasons we only issue a notice. I must admit though, I haven't been able to find much documentation on this and don't have a Windows machine to hand at the moment to test this.\nIf it is the case that Windows servers can't be relied upon for fileperms() as I suspect, we might need to see if we can have a work around or exemption.\nThis was discussed in another issue. It was noted there that if you use an instance of  CryptKey, you shouldn't need to worry about this. \nThis information might be of use  to you @ShyZhen so I would recommend looking through the previous issue raised.\nI will try and have a look at this properly tonight but we might need to reopen this issue as multiple people have reported problems with Windows servers and this check.\nIf anyone has a reliable source for how fileperms() works on Windows it would be appreciated if you could share.\nEdit: Just remembered I have a Windows VM so can check this. Reopening this issue. I've not had chance to test this yet but suspect that @ShyZhen is right, and we need to re-evaluate this for Windows users. Hey @gingabeard and @Richard87. The way you would normally do this is as follows:\n```\nclass MyAuthorizationServer extends AuthorizationServer\n{\n    protected function getResponseType()\n    {\n        $this->responseType = new MyCustomResponseType();\n    return parent::getResponseType();\n\n}\n```\nIf you implement your custom response like this. It should resolve your issue. I will mark this as resolved but if this doesn't solve your issue, please feel free to get back and I will reopen this issue. Thanks. Hi @dzibma. Which method is causing the exception? Is it the verify() method?\nEdit: Tis ok, I've found it :). Thanks for finding this @dzibma . The server already does this by providing an auth server class and a resource server class. Please can you state your question and I will try to help as best as possible. . It is in the src folder called ResourceServer.. Closing as I believe this is resolved.. Sorry @mtangoo but I'm not following the example here. It is this bit which I'm struggling with:\n\nNow before client Y admits user, it must verify a token silently.\n\nWhich token are you talking about here? The access token? I don't think a client would have the ability to verify this as this would usually be done by the resource server. \nIf you could provide a bit more background I will try to help as best I can.. Thanks for spotting this @fizzka. Have merged in as I think it makes sense to update these comments. Thanks @Erikvv - there is a bit of repetition here with the client and userIDs as well. I think this will probably need to be tidied up and released in version 8. I will try to get this actioned before the end of the weekend. I've made a start on it in the PR here. Closing as now merged into the version 8 branch. Thanks Simon. Yeah, I'm going to need to do a bit more work on this. The client ID and user ID are suffering from the same problem. I think that although this isn't technically a BC change, the modification might cause issues for some implementers so I think this should be changed in version 8.. Closing this as I should have branched off version 8. Will open a new PR as rebasing was proving too messy. There are no official schema examples as yet. This is something that is repeatedly asked for though so we might add this in the future. There is already an open issue for a MySQL Schema.\nIn the meantime, one user of the package did provide his own schema for people to reference which might be worth taking a look at.\nSorry that there is nothing more concrete at this time. Sergey would probably be best placed to answer but I am presuming the following:\n\nGrants are for storing which grants are active on the server\n\nGrant scopes are for associating scopes with given grants (perhaps he doesn't want all scopes to be applicable to all grants)\n\n\nClient Grants must be specifying which grants are permissible/enabled to particular clients\n\n\nSimilarly I'm guessing there is some kind of permissions built in to Sergey's implementation for restricting scopes to certain clients\n\n\nUse grants must be either restricting or simply listing the grants a user is using via a client\n\nSimilar for user scopes. He is either restricting or just listing which scopes a user is using\n\nIn all honesty if I was implementing this I wouldn't bother too much with the user tables. This is all optional and specific to Sergey's implementation of course. The server is sufficiently flexible to allow many different ways to implement.\nIf you don't have use for restricting grants/scopes to clients/users, don't implement these tables.. This looks to be a sensible change to me. Thanks for submitting. Can you update the changelog as well and I will be happy to merge this in. Cheers. Hi @brentgaither - thanks for this submission. I appreciate the direction you are trying to take this in but I feel it is not sufficiently improving clarity here. We are giving a suggestion of what the problem might be rather than specifying it exactly.\nAn invalid client message can be issued for a number of reasons.\n\nThe client authentication has not been successful\nThe redirection URL provided hasn't been pre-registered\nNo redirect URI has been provided but multiple redirect URI's have been registered for the client so the server doesn't know which one to use\n\nIf we want to be more specific it would probably be better to use a hint for the exception rather than change the core exception message. The concern here might be that if it is an attacker trying to gain access, we might want to minimise the information available to them so they don't know what the issue it, although I appreciate security through obfuscation is rarely effective.\nI think given the reasons above, it would be best to keep this implementation as is for now unless a number of people raise concerns supporting the absence of specificity here.. No problem. Thank you for the suggestion and sorry we didn't decide to go forwards with implementing this this time.. It looks like the issue is here:\nhttps://github.com/thephpleague/oauth2-server/blob/3bec591393b1cc6a3fc02c94d18262e4ffad2e4f/src/ResourceServer.php#L141\nPrior to PHP 5.5, you could only put variables inside the empty() function so the function call is causing the error. I will raise a fix for this as version 4 of the package should support PHP 5.4.\nI would strongly encourage you to upgrade to a later version of the package though. Thanks for raising this.. @rmasclef I believe the issue is resolved now. I've release version 4.1.7 of the package with the bug fix. Please let me know how you get on. Thanks for reporting this.. Excellent. Please do let me know how you get on. Thanks\nOn 24 June 2018 22:16:53 BST, Romain Masclef notifications@github.com wrote:\n\n@sephter thanks a lot for your reactivity! i'll check by the end the\nweek :)\n-- \nYou are receiving this because you modified the open/close state.\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/914#issuecomment-399788289\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. @rmasclef did the fix work as expected?. Awesome. Glad it worked. Thanks for the update @rmasclef . It does look like the documentation needs updating. The code works as follows:\n\nThe Auth server uses the private key to sign payloads\nThe Resource server uses the public key to verify the signed payloads\n\nThese are typically JWTs.\nThe encryption key is either a string or a Key instance from the Defuse/Crypto library. It is used to encrypt the authorisation code or refresh code.\nI'm unclear as to the motivations for the original change but a discussion about it can be found in this issue.\nI hope that answers your question. I will modify this issue so that we can keep track and update the documentation to make it clearer. Thanks for reporting this.. Reopening as I want to track the documentation issue so we can resolve and then close.. HI @melanef. Thank you for your PR. I see the value in this but I also believe this could be solved by the library implementer through a simple change to their deletion policy. \nWhy would someone delete their access tokens if they know they are associated with refresh tokens? It isn't an impossible scenario but I was wondering if you could provide some background as to your own circumstance so I can gain a better understanding.\nIs was also wondering if this related to issue #914 that you posted? I notice this is targeting branch 4 at the moment which is not under active development any more but that isn't too much of a problem if this is indeed a bug or warrants an update to that branch. I hope with a bit more background we will be able to decide the best place for this code together. Many thanks and I look forward to hearing from you.. Thanks for the reply @melanef. Apologies for the mixup with the issue. I misread the username. Looking at later versions of the package, we have a function called validateOldRefreshToken() which handles the problem you are trying to address.\nAre you unable to upgrade to a later version of the package? What version of PHP are you running? \nThanks!. @melanef I've had a think about this and I don't think this warrants being added to the version 4 branch. It isn't actively under development at the moment. I released a bug fix for it today but that was because the bug in question breaks the entire code base if hit and the only way to resolve it is to modify the code.\nIn this instance, you could change your token policy to prevent this from happening. In addition, this issue has been resolved in later versions of the library. I would strongly recommend anyone using this version of the branch upgrades to a version that at a minimum, is compliant with PHP 7. \nThank you for raising this and I hope you understand my decision. All the best.. Thanks @Erikvv - this looks grand.. I will merge this in this evening and release a new version of the 4.x branch.. Thanks @lookyman. There are a lot of changes here so this will take some time to process. I also note that this is currently failing our build as PHPStan 0.10 doesn't support PHP 7.0. \nI don't think this change would currently warrant a version upgrade in itself so is probably better targetted for the 8.0 branch which won't be released for some time yet.. Aye, it isn't ideal to be honest. I would like to move off 7.0 pretty soon. Thinking on it though, it might not require a major bump in this package as fundamentally, nothing has changing in our API and composer should handle anyone who isn't running 7.1 or above.\nI will have  a wee think but will probably just include this in the next version on the 7 branch. Will need some time to do some testing first though. Thanks for the submission!. Thanks @Lorti . This looks good to me. I think there is a change in performance here as we are moving the finalize scopes to a later stage in the process but I don't think this is of too much concern and don't think it constitutes as a BC breaking change so happy to include it in this version. Thanks for your efforts here.. I will review this as soon as the PKCE changes have been merged in. From memory, I hadn't looked at this as it was building on some pre-existing change requests so I'd like to review them all together if possible which will likely take longer. Thanks for your patience.. @christiaangoossens I'm not sure this is the best approach. By allowing additional parameters at the authorisation code request, I think we would be deviating from the OAuth spec. I can't find anything that says additional parameters are allowed at the auth code request stage but similarly I can't find details saying this isn't allowed. I would probably err on the side of caution though.\nAccess tokens are usually consumed by the resource server and a client should normally not be aware or care what its contents are. I think this PR is flipping this assumption on its head by allowing the client to add information to the tokens. \nI will leave this PR open for further discussion in case I have made a mistake with my assertion but I feel that this approach probably isn't the right one to take at the moment. I would appreciate any thoughts you have on this though.\nThank you for your submission and apologies again for the delayed response.. @s3gs I agree that we must make it easier to add custom claims to the JWT. My assessment here is that it is happening at the wrong stage in the process but I am open to discussion on this. Ideally we would add some custom claims at the point where the access token is issued in a similar vain to the way we finalise scopes. The resource server would add these claims to help it better understand/use the access token. \nI think it would be useful if you could describe your own scenario at the moment, and perhaps how this PR solve it so we can hopefully push towards a resolution. Thanks for your offer of help with this issue. Thanks for this @StevePorter92 and apologies for not picking this up yet. I plan on setting some time aside this weekend to pick up some of the pending PRs. Thanks for your patience and thank you for your contribution. Sorry @StevePorter92 I have not yet. I have been working on numerous things for the library over the past week or so. I'm focussing on getting the PKCE changes into version 8 at the moment as there was at one time 3 separate pull requests trying to address some implemenation concerns around that. Once I've finished this (which is now fairly close to be honest), I will look at getting this reviewed. Thanks for your patience . Hi @StevePorter92. Thanks for your patience here. A couple of things spring to mind at the moment which I think are missing from this at the moment:\n\nThe token doesn't have to be a JWT. Although this server provides JWT bearer tokens out the box, implementers are free to use other formats. I don't think this is handled at the moment so will need to be addressed.\nI don't believe the introspection end point is protected. We should be protecting this with some form of authentication as it should not be available to public clients. Note that some implementations will put this end point behind a firewall internally so we have to take this into consideration as well.\nI don't see how the resource server is using this end point. Can you clarify this.\n\nThanks for your efforts to date. I hope these comments are useful. Cheers!. Hi @StevePorter92 - any updates on this PR? I'm happy to pick this up in your absence if you're snowed under.. It is awaiting review from myself. I will get to it eventually but don't have a firm timeline for this at present sorry.. Will do, thanks @StevePorter92. I should have some free time this evening. Unfortunately @dvdbot, this isn't just a case of reviewing the code. I also need to familiarise myself with the RFC to ensure it is conforming to spec which is why PRs such as this take longer than a normal bug fix. I won't be drawn on timescales as I find they are nearly always optimistic. Hope you understand and sorry I can't give a more definitive answer than that. Thanks @sg3s for responding to this. Closing this issue as seems to be resolved.. Thanks @tegaphilip . Hi @robbytaylor. I'm not sure about the change to the generateHttpResponse interface as you have pointed out in our comment. I also note that this is currently failing our PHPStan checks. Could you resolve this first and then I will take another look? Many thanks and sorry for the delayed response with this one!. Thanks @sg3s. Yeah, I'm sure we need to keep this in, I'm just not sure we should be allowing people to choose different characters from a # as the pull request I'd referenced allows us to do. I can't find support for this in the spec but I do seem to recall reading about it somewhere at some point (although I am struggling to find any evidence to support this).. It is actually used in the client trait which provides a ready made implementation for some of the functions provided by the ClientEntityTrait but I guess this isn't a real use so I see your point.\nI can't speak as to why this was added in historically. The main reason I can think for having such a function is that when a client redirects the user to the authorisation end point, the client only provides its ID. \nTypically we would want to let the user know which application is requiring access and the scopes they are requesting. The client ID wouldn't mean anything to an end user so we would need to get the client's name to display to the end user. I presume this is the main use case for the function.\nAs the function isn't used in the library directly, I think it is a fair assertion that it perhaps shouldn't have been included, and left up to the implementer whether they wanted to use this but I don't think it warrants removing as it is a minor point and all clients should have names which can be retrieved via this method if need be.\nThe name _ of the client is strictly required by the OAuth 2 spec but most implementations require it for easy identification. . Thanks @JasonTheAdams . Hi @jeremyj11 - Can you provide some more information for this? The client ID should be set from your Client Entity function _getIdentifier() which should return a string.\nPlease see https://github.com/thephpleague/oauth2-server/blob/27b956c1499f7fcfbad3a7c071cb4f48e4271e9d/src/ResponseTypes/BearerTokenResponse.php#L35-L47\nI'm interested to know if your implementation does return a string at this point or not. If you could share your implmentation of the BearerTokenResponse that would be great thanks.. @jeremyj11 are you still wanting to merge this? If you could respond to my previous comment so we can get this progressed, that would be much appreciated. Thanks for your help. Hi @jeremyj11 - I'm closing this PR as we have not heard back from you. If you'd like to have this PR progressed, please respond to my initial question and I will be happy to reopen this and take a look. Thank you.. Hi @JasonTheAdams. The client will store the access token and pass it back on future requests. The resource server validates the JWT by checking that the signature is as expected. The JWT is made up of three parts:\n\nThe header\nThe payload\nThe signature\n\nThe signature is created by the auth server, by encoding the header and payload along with a secret known only to the auth server.\nThis allows the auth server to ensure that the payload and header have not been tampered with since they were issued by the server. It doesn't matter that the JWT can be read by others as it can't be tampered with. If someone changes the payload or header, it won't match the signature and will be rejected by the resource server.\nThe main thing you have to do is ensure that the access token is not given to anyone else. Because it is a bearer token, anyone possessing it will have access to the protected resources. I hope this answers your question but if you have any follow ups please give me a shout.. Yes, this should be enough. As long as you are communicating over https, which this server and the OAuth 2 spec mandate, it should be fine. One caveat is if you are using a native app such as a desktop app. If you are, you probably need to use PKCE as well but if it is website to website, there should be no additional requirements.. Sorry, ignore my previous response. Both endpoints should be accessed over https to avoid man in the middle attacks so both your client and auth/resource server should be served via https.. The client would typically decide what scopes are required, rather than the user. The user will just provide authorisation to the client for the specified scopes. If the client does not require access to hub 2 for example, it shouldn't request access to hub 2. I hope that makes sense.. Closing this due to no response from @jacksun101.. I don't think there is a way to do this in the library. Can you provide a bit more information about the nature of the additional handling you want to do?. I think there is something not quite right about your architecture. The clients shouldn't be as coupled to your resources as they are. \nTake Twitter and the many third party applications that connect to the platform as an example. If a client requests access for a given user's account, it must know in advance which user it is requesting information for. How does this work in your implementation if you are creating resources when you are requesting access?\nIn addition, because the twitter user's account exists entirely independently of the third party application, when the third party app no longer requires its access token or doesn't renew it, it is of no concern to the Twitter account as it has no real explicit coupling with the third party app in question.\nApologies if I'm not following your example properly but my feeling is that the coupling between your clients and your resources is what is causing you problems. I would focus on trying to remove that if possible. Hope this helps. @JasonTheAdams is there anything else I can help you with in regards to this issue? Many thanks. No problem. Sounds like you ended up with a great solution! Glad to be of help. I don't think the clients were handled as confidential by default although it is true that all previous clients that used the Auth Code Grant were assumed to be confidential by default. The library largely left the details of confidential/public to the implementer to decide as the library had never had a specific requirement to find out which one the requesting client was previously.\nI went with having an isConfidential flag instead of an isPublic flag as in my mind, all clients have the features of a public client, but to be confidential, you have to have been issued some kind of credentials which you can keep secret. Because of this, it made sense to me to have to be explicit about whether the client is confidential or not. It didn't make sense to me to be explicit about being public as it didn't really give the client anything extra, and is more a common baseline most clients share if that makes sense?\nThanks very much for your feedback by the way. If you have any more it would be very welcome.. Yes, this change affects the auth code grant.. Thanks @sg3s for the very detailed response. Much appreciated.. Hi @rapgithub - the examples directory is not included as zip file download is supposed to be used as a drop in replacement for the composer install option so that you can just extract the folder and prepare it for production. In production you won't require the examples or tests folder so these haven't been included.\nIf you want to download the examples directory you can clone the repository in git which will include the files. Hope this helps!. Hi @nealoke - it depends what you are using the accountId field for but usually, scopes would be used to restrict the capabilities of an auth code and eventually issued access token. Have you looked at these as a potential solution?. To be honest, it really does depend on your implementation although typically, it will be a user who owns the resource and is granting access to a third party client. \nI still think scopes are probably the way to go here but it is hard for me to comment here as I don't have a full grasp of what you are trying to achieve. OAuth is simply a way of granting access to a user's protected resources. \nIt sounds like you have achieved the granting part but you want to restrict what level of access is provided and not allow the third party client to have complete access to the users resources. Scopes are usually used to achieve this.\nFor example, a Twitter client might have access to read tweets but not post them as per the scopes provided. In your implementation, the third party client should probably be defining which accounts it is trying to access using the user's access through scopes.\nI can't think of any other way of doing this to be honest. I'm sorry that isn't a massive help as you'd stated you don't want to use scopes but it seems appropriate for this implementation.\n. The purpose of the Auth Grant is to allow third parties to have access to a user's resources without sharing the user's credentials with the third party. Presumably your auth code grant will go something like this:\n\nThe client directs the users to the login page of your protected resource and specifies which scopes it wants access to (if applicable)\nThe user reviews the access request, and enters his/her login details if they are happy\nAn authorisation check takes place and if all is ok, we redirect back to the client with an auth code\n\nIn this scenario, it is the user who is authorising that the auth token and eventual access token be created. If that user no longer has access to the resource server, their tokens will usually be deleted although this will depend on your own policy (this is outside the scope of both this server and the OAuth spec).\n\nMy situation is not so much requesting resources of a user but more requesting / modifying resources of an account. You can compare it with a Trello powerup, are these also linked to the user or to the team?\n\nGiven the above, if you don't want to request the resources of a user, how can you use the auth grant? Who is reviewing the auth code request on behalf of the account? Which credentials will you use to login and authenticate with the resource server authentication end point? How are you going to confirm who gave access to that account?\nI am guessing that if we take OAuth out of the equation, it will be a user that will normally manipulate an accounts information in your system, so it makes sense to me that it is a user that is associated with an auth/access token as they will be giving the third party client permissions to perform many of the actions they can do. If you want to limit these actions, you do so using scopes.\nI hope that helps in some manner to explain why I think it is not right to focus on accounts but again, having not seen your application, I might be making some false assumptions.\nJust thinking of it here is a question which might help clarify matters:\nHow do you determine which account ID is associated with a given auth code at the moment?. * The access token is stored within the refresh token so as long as you have scopes associated with the access token, they will also be associated with the refresh token.\n Typically your scopes will be issued by the client as part of the initial authorisation request.  These usually aren't key value pairs, and instead are single strings. In your instance, you might have a scope called account1 or something similar.\n I'm not sure about your last point. The function getScopes() should return an array of ScopeEntityInterfaces. I would use the print_r() function to perhaps check the output to make sure this is correct.\n. Glad to be of help!. Thanks for this pull request @EricTendian. Unfortunately I think this might introduce a security concern. If you use a string password, your chosen password might be weak. To combat this, the encryption library applies key stretching to your password to make it less susceptible to brute force attacks.\nBy contrast, the key object is known to be secure by default (as you aren't setting the password used) so it can skip the password stretching making it a lot quicker to use.\nThe only way this backwards compatibility check can work is if we set the password on the Key object to one we had previously chosen, which mitigates the benefits of using the Key object.\nThank you for your efforts with this but I believe there is no BC solution to this problem.. Hi @diogodomanski. The library doesn't support PSR-15 at the moment but we will add support for this as our middleware was created prior to this standard. There isn't any guidance on how to achieve this as yet.\nWe will likely release this in version 8 of the package which is currently some way off being released.. Hi @pjdevries. Thank you for your comments. You are right in saying that the JTI is not a required claim but our server uses it to set the ID of the token. Because our server is the one issuing the access token, we should be confident that this value will be populated when checking any access tokens. \nSimilarly, we don't bother to check the claims unless the JWT has first been validated to ensure it hasn't been tampered with so there shouldn't be a scenario where we need to set a value to avoid an exception being thrown.\nI take your point on the scopes vs scope but we would be hesitant to change this as it would break backwards compatibility and as this is a custom claim and the tokens issues by our server package will only be used by our server package, I don't think it is too big a concern.\nI hope this clears up some of our decisions. If you do have any further comments please don't hesitate to get in touch. Thanks for reaching out.. A refresh token TTL should be set otherwise it will fail this check:\nif ($refreshTokenData['expire_time'] < time()) {                                                                \n    throw OAuthServerException::invalidRefreshToken('Token has expired');                                       \n}. I think it probably should be optional. There is nothing in the spec that dictates that we should specify a TTL for the refresh token. We should probably look into rectifying this (I presume we can't do this at the moment but haven't looked into it closely enough). \nThere should be no problem with setting it to P240M as there is no restrictions on absolute length to my knowledge.\n. Thank you for the further information @sg3s. I'm going to close this issue now as I believe the original question has been answered. I will open up another issue to look at the expiry time for refresh tokens. Thanks for the update and efforts with the integration. You can use any object that is PSR 7 compliant. There is no requirement to use any code from Guzzle.. Sorry I'm not sure what you mean. Can you provide references to the code base to illustrate your point? The Request objects come from an HTTP request and are disposable. I'm not sure what you mean when you say they are global.. Closing this issue as have not heard back from @docxplusgmoon. If this is still an issue, please comment on this ticket with a clarification of the problem and I will look into this further. Thank you. Thanks @DeepDiver1975 for the PR. At the moment, PHP 7.3 is still in the RC stage so we would not officially support it until it is released. I can't see the benefit in adding testing for a release candidate at this stage. Thank you for your commit though. If you want to resubmit once PHP 7.3 has been released I will be happy to accept the PR then. Thanks!. Hi @gopalvenu033 - thanks for raising an issue. I think your best route would be to check the documentation and reference the examples to get going. Failing that, I would post your question on StackOverflow to get some assistance.\nI'm happy to answer specific questions but generalised questions such as this will take too long to resolve. I hope the resources I've listed above can help but if you do have any specific questions, please feel free to reopen an issue.. This is a workflow I haven't seen before if I'm honest. OAuth isn't really used for the scenario you are suggesting. In most situations, the user credentials will already exists on the protected resource so I don't think you will find a common solution to this unfortunately. \nI would suggest that you just notify the user that their account has been created and let them login with their credentials. Use analytics to determine whether this will actually have an impact on the adoption of your service.. Actually, and apologies I didn't realise this initially, but it sounds like you want to use Dynamic Client Registration. The library doesn't support this at the moment but I think it is something we should definitely look into.\nIt has already been raised as a feature request in issue #934 so I will close this issue and track it there. Thanks!. Apologies. I thought that might be a solution for you but I guess the user part is the important bit. I'm sorry but I don't know a good solution to your problem. Nothing springs to mind as I haven't seen a similar use case in the past although that's not to say there isn't one. \nI would advise you take this to Stack Overflow as it isn't necessarily a question that is specific to this client or even PHP. There might be someone out there that has achieved what you want. Sorry I can't be of further help with this. If you do find a solution please do let me know how you get on.. I could have sworn this had previously been reported but I can find no reference to it and it hasn't been resolved for version 8. As such, I will leave this open and look to fix it for the next major release. Thank you for reporting this to us!. I knew this was ringing a bell. It is related to pull request #803. I will try and get it pushed through in the morning. Thanks. Thanks both. I will aim to look at this this evening.. Yeah you are right that we don't currently implement OIDC so this shouldn't be a concern for us and we should just adhere to the already implemented RFCs. At the moment the exceptions are static so I think it would be best if we just pass state in as an argument to the relevant method when applicable and make this argument optional.. Thanks for your pull request @mabar. I don't believe these functions you've edited will ever explicitly return null so I don't think this is the correct change to make. We won't merge in your PR this time but thank you for your submission.. I think it would be Entity or void rather than null. We don't explicitly state void in our doc blocks and I don't think this would change in the future.. Thanks @marc-mabe for spotting this and providing a fix. Tis very much appreciated. If you want a stab at the BC breaking refactor you had hinted at, we have a version 8 branch that I plan on releasing towards the end of the year. Thanks again for your PR.. It is unlikely we would make this change in the 6.x series. To upgrade to version 7 should be a fairly simple change. From memory, there is only one BC from 6 to 7.. Hi @Devristo - thanks for getting in touch and thanks for the kind words regarding the library.\nIs your code calling the validateClient() function at all? There was a change in the 8.0.0 branch where clients must now identify themselves as confidential. If they aren't confidential, then no client validation takes place as the client cannot be trusted to keep its credentials secret.. Ahh I think I see. I presume it is issuing an invalid request exception because you aren't passing a client ID in as a request parameter, correct? \nI will look at getting a fix sorted for this soon and double checking everything. Thanks for reporting this.. Closing as issue now resolved by PR #978 . We aren't supporting OpenId Connect at present but do plan to do so in the future. I don't believe including a nonce is required in any of the RFC's we currently support so don't think this will be added in until full support for OpenId Connect is.. I believe so. For JWT we use lcobucci/jwt. This vulnerability was fixed in version 3.0 and we are now using the 3.2 version.\nAs noted in the blog post, we also specify the algorithm to use when were are verifying the JWT.. Thanks @ceeram - this looks good to me. I've updated the changelog. I also wanted to add in some basic tests and where possible, remove the backslashes from \\Exception and \\LogicException where applicable but I need to head out.\nI will probably pick this up tomorrow and make the changes. If you have time to make them in the meantime, that would be much appreciated but no worries if not. Thanks so much for submitting this!. Thanks so much @ceeram. It doesn't need to be the whole project, I think we are currently a bit patchy on our approach with this. I think if you just alter the files you are editing here that would be grand thanks. Thanks for your efforts!. Thanks @ceeram . There probably are enough changes to warrant a new release now. I will do a quick once over of it this evening and aim to release tonight if everything is ok. Thanks again @ceeram . Thanks so much @ceeram. This is awesome. Merging in. Cheers for your work!. Thanks @curry684. Sorry for issues caused. I will revert the name of the function later today and release a patch to fix the problem. Sorry for any inconvenience caused. @ceeram had also reported this issue so it is clearly affecting a few people. @ceeram do you have an example of your extended class you can share so I can get a better idea of the problems at hand?. @curry684 I've reverted the interface change in release 7.3.1 which will hopefully resolve your issue. I'm leaving this issue open for now to follow up on @ceeram's issue and related PR.. @curry684 are you using a similar implementation to the one @ceeram is?\n```\nclass AuthorizationServer extends BaseAuthorizationServer\n{\n    protected function getResponseType()\n    {\n        $this->responseType = new OpenIdBearerTokenResponse();\n    return parent::getResponseType();\n}\n\n}\n```. Have you tried setting the custom bearer token response in the constructor? I've asked @ceeram this as well in his PR. Just trying to establish what the blockers are to such an approach if you have tried this already.\nThank you for your continued help!. Sorry that I haven't resolved this yet. I've been pretty busy in work. I suspect we will have to implement @ceeram's PR in the meantime and accept that the stateless implementations will have their keys reset unnecessarily. \nI will take a closer look at this this evening and aim to get a resolution in place. Long term, I think is is preferable to set the custom response via the constructor so will look at options in version 8 to formalise this as it will require a breaking change.. I've taken the decision to merge in @ceeram's fix. Although this will mean that people using Swoole will have their keys set multiple times needlessly, this to me is the lesser of two evils and will remove the BC change.\nLonger term, I think I will make the getResponseType() method private as you can set a custom response type via the constructor. Unless someone raises a good reason not to make this change, I feel that passing in a custom class via the constructor is probably a more maintainable approach long term. This will likely come in version 8.\nThank you to you both for your assistance with this and apologies for any inconvenience it has caused you. @curry684 if you could confirm the latest version has now fixed your issue, we can close this issue down. Many thanks!. Fixed in PR #969 . Thanks for confirming @curry684 . @ceeram thank you for reverting the function names. The only thing I wanted to raise for discussion here is the moving of the setting of keys. The reason this had been moved to the prototype was so that the keys weren't set over and over again, I think this change means that the keys might be set again when they are already present.\nPlease can you explain why the moving of the key setting to the constructor has caused you issues? Thanks again for helping to resolve this. It is very much appreciated.. @ceeram I went ahead and reverted the interface changes. I've then merged master into this branch so we can discuss the reverted key setting location in this PR. Hope this is ok. Many thanks. Thanks @ceeram - I see now why this is causing issues. Apologies I haven't had time to progress this yet as I was working over the weekend.\nHave you looked at changing your implementation to pass the OpenIdBearerTokenResponse() in via the constructor instead? If so, did you encounter any blockers?. Thanks for your continued efforts with this @ceeram. As noted in my comments, I haven't removed the tests, I just renamed one and removed replication from another.. There is no official way at this time. Issue #747 is tracking this but has not been worked on yet. Sorry that there isn't a resolution for you at the moment. Thanks very much @cnbailian - I've updated the documentation now. Cheers for spotting this.. Merged. Thanks for spotting. No definitive timescale on version 8. I've added a number of features I want to see added to version 8 in the version 8 milestone. We are about 50% of the way there at the moment, but more features might be added.\nYou can see this here: https://github.com/thephpleague/oauth2-server/milestones. Thanks for spotting this. Merged. Cool. Happy to include this. Good luck with your package.. This looks good to me @Devristo. Many thanks for picking this up. I like the solution you have come up with. The only point I wanted to raise is around the new getClientCredentials() function. Would it be possible to change this to be private? I can't think of many reasons to override this at present but if you can think of any please jump in. Cheers again!. If you could, that would be great cheers @Devristo . Thanks for the PR @Devristo - I deleted some of the methods from the test as they weren't needed but otherwise looks good! Thanks for your contribution and spotting this. @uiisoft I'm afraid I don't know of any out of the box installations for yii2 so I imagine you will need to roll your own. To find out more about how to do this, I would advise checking the documentation on our website and also refer to the examples which are implemented in the Slim Framework.\nThe library is designed to be flexible so it doesn't require any specific framework or even a specific database backend. We provide a set of interfaces which can effectively be seen as wrappers or contracts for the data the library requires.\nAs this isn't a specific issue about the package I am going to mark this as closed as I feel this issue is too broad to effectively deal with here. If you do require further assistance once you have reviewed the documentation feel free to reach out to me via email.\nCheers and good luck! . @delphiforphp I've taken a look and there is a composer.json file already there. Do you not mean this file? It is in the root of the examples folder. Closing due to lack of activity. If you still believe there is an issue @delphiforphp, please get back in touch and I will take another look at this. Thanks. I think this would need to be a change for version 8. There is a risk that some implementations will do nothing with the constructor and rely on the setting functions to set their clients etc.\nAlthough I would hope that most people would have set the client etc in the constructor, we cannot guarantee this. Accepting this pull request would risk introducing a breaking change for some users.\nWhen considering the wider package, we need to ensure we are implementing consistent behaviour as well. At the moment, authCodes can also have clients set against them. Like access tokens, they have a setClient() method, but the main difference is that you cannot set a client via a constructor for the authcode.\nIt looks like the change I am suggesting was originally implemented in https://github.com/thephpleague/oauth2-server/pull/553 but removed as it was a breaking change. It was never reimplemented but I think this would be the best course of action to take.\nI will flag the corresponding issue for version 8. Thanks for taking a look at this and sorry I am not merging this in at this time.. I don't think this is something we would add in as it strays away from normal conventions somewhat. It is important to remember that it is the client that has access on behalf of the user. I think linking the two so closely is probably not a good idea. If the user is suspended in an application, client access should probably be revoked.. Thanks for this @spideyfusion - merged.. That's a good point. Thanks for looking at this @crtl. I will close this issue down as your logic makes sense.\nWRT to the traits vs interfaces comment, I'm sorry if I was not clear enough on this point but I did not confuse these terms.. Hey @lordrhodos - thanks for your PR here. I've had a wee read around this and I'm not sure this would be something we would include in the package. It is a fairly big change and alters interfaces so would need to be included in the next major version.\nI am also unclear as to what benefits this has. To my knowledge, our use of random_bytes doesn't have any disadvantages to using UUIDs, and given the default length we are using is 40, it is highly improbable we will encounter a clash. I believe it is actually even less likely that UUID v4.\nIf you could detail why this change would be beneficial, I will take this on board but I think it is likely this will not be merged in. Thanks for your efforts with this regardless.. Thanks for the explanation and thanks for pointing to the previous comment. From my readings, my understanding is that unless you have a specific requirement for interoperability with UUID, random_bytes is generally a better choice as it can have a larger key range, meaning less collissions, and is quicker as it is built into PHP.\nI think the chance of someone requiring this change are slim at the moment given the reasons above. I would advise that unless you have specific need for UUID v4, you are probably best sticking with the existing implementation.\nBecause this is an edge case and would likely need to be added to a major version, I don't think I will merge this at this time. Thank you very much for your efforts with this though and your explanation.\nIf there are a number of people calling for this in the future, then I will revisit this and see about progressing it further.. Thanks for spotting and fixing! Much appreciated.. Hi @christophemassin - Sorry for the delayed response, I was on holiday. I'm sorry but I'm not familiar with the Heimdal package. I think the easiest way would be to replace the AuthorizationServerMiddleware with your own implementation but it is hard for me to comment without knowing the full workflow.\nI would recommend this question is asked on either Reddit/Laracasts/StackOverflow or raised as an issue on the Heimdal package as people more familiar with this scenario would be better placed to assist you. \nMany thanks.. Hi @ghostika - Sorry, I'm not sure what you mean. This server can only consume and issue access tokens generated by itself. From your initial comments, it looks like you are trying to do something with an access token issued by Facebook. Is this correct?. Sorry @ghostika I'm not sure I'm following still. My confusion is stemming from the need to login to Facebook and then authenticate with the OAuth 2 server. I think this question might be better served on StackOverflow as I'm unclear what you are trying to achieve and don't have much familiarity with Facebook's API offerings. Sorry I can't be of further assistance.. It is good that there is a second person asking for this as it does add weight to the request. @crtl can you provide some more information as to why you want to modify this?. Thanks @crtl for your response. Sorry, I didn't phrase my question very well first time around. I suppose I'm more interested in why you want to change this.\n@lordrhodos was looking to use UUIDs instead. Are you looking to do something along these lines? I suppose I'm just trying to establish the driving reason behind such a change. \nI'm up for giving more control/customisability to the implementer, but want to make sure I understand the driving factors for such changes. As  I said earlier, the fact two people have now requested something similar gives this proposal more weight. Thanks!. Agreed that this should be documented if it isn't already. \nCan you give a reason why the current implementation is insufficient for your use case though? It really would help prioritise this proposed change if there is a demonstrative use case why this should be changed.\nI understand that this change will give you more control but I am struggling to see why the current implementation would cause issues or be insufficient for anyone's needs.\nI'm not averse to making this modification but I'm focussing on version 8 for now so wouldn't take this forward at this time unless there was a pressing need.. Thanks for the discussion guys. I think this is something we should look to do. I'm not sure on timings yet but will flag this as an improvement and reopen the original PR for another look. Cheers both for your contributions here!. I've checked and this is correct. The resultant identifier is 80 although I see how this can be confusing passing a length of 40.. I had originally said the end of January but I didn't get as much time to work on this over the Christmas period as I would have liked. I'm hesitant to offer any further estimation as this is likely to be wrong.\nAnything that is due to go into version 8 and has been completed is in the version 8 branch. We don't have development branches as have no real need for them. Development will largely be done on a contributors fork until they are ready to submit a PR. \nCheers!. Well spotted. Thanks for finding this issue @jacobweber . Sorry @brandinchiu but I'm not familiar with Symfony 4 so wouldn't be able to assist here. I think this question would be better suited to StackOverflow/Reddit etc. Sorry I can't be of any help. Is there any alternative approach you can take? I am not a fan of blank returns and would prefer the code is more explicit.\nFor example, if token verification fails, could we use exceptions to issue an error rather than aborting the execution?. Apologies if I'm not following your question here but I will give it a go. I think you are correct in saying that you will need to have duplicates.\nThe Auth Server needs the access token repository so that it can generate and issue access tokens. The Resource Server needs the access token repository so that it can verify that the access token hasn't been revoked. Both should point to the same common store.\nI hope this helps!. It sounds like you want token introspection. The RFC hasn't been implemented yet but it is planned for a future release. This is the RFC if you are interested https://tools.ietf.org/html/rfc7662. The is_confidential flag is just an example implementation you could use to flag your clients as confidential. In the latest version of the server, we don't currently support specifying whether the client is confidential or public. This is left up to you.\nIn an upcoming version we will support the ability to flag a client as private or public. For now though, the implementer should just ensure they never let a public client use this grant. How they achieve this is outside the scope of the current version of this library.. I think it is better to be explicit so I would favour removing the StyleCI check here.. Are you using the same auth code or multiple auth codes to request the access token?. There isn't really anything that I can find in the OAuth 2 spec that says a client can't possess multiple access tokens. I also can't think of a reason why this would be a problem. I suppose the access tokens could have differing scopes and the client could use each one for different scenarios but it would be easier to just ask for the union of scopes across both tickets.\nUltimately, as this isn't in the spec, we haven't covered this scenario. If it is an issue for implementers, I would expect this to be resolved in their implementation as I don't imagine this will affect/concern most people.. Ahh I see. Ultimately it really depends on you. If you feel these extra tokens are unnecessary/a security concern, I would go with your suggested scenario of removing an identical access token before saving a new one.\nIf I were implementing the system though, I wouldn't be too concerned with this scenario. Instead, I would be asking why the client has requested an identical token when it already has a valid one. It seems more of a client issue than a server to me.. The 400 response can be left our here as the default HTTP code is set to 400 in the constructor.\nIf we are changing this to use the error code of invalid grant instead of invalid credentials, as per the spec, there are a few scenarios that can trigger this error. I think we should perhaps look at making this error more generic to account for this. For example, the function name could be changed to invalidGrant() and the error message changed to use text describing this error in the OAuth spec in a similar manner to how the invalidRequest exception has been implemented.. I think we should target the private key file here. It is unlikely we will ever have any other files ending in .crlf so would be good to be more specific here.. I don't think this test is doing what is intended. The preg_match function is always failing as we are passing in a file path rather than the actual key. To test the contents of the file against the regex pattern, we'd need to use file_get_contents() in a similar manner to the test in testKeyFileCreation() so any tests will likely sit outside of this test. If you could alter this that would be much appreciated. I'm having a bit of trouble testing this change. When pulling this branch, the crlf file created didn't contain crlf line breaks when I ran cat -e private.key.crlf. I converted the file using unix2dos to get crlf line endings and with a bit of tweaking to the tests, found that the original regex pattern still matched. It is worth noting that the new regex also matched. There might be something I am missing here though so apologies if this is the case!. I think we are safe to drop support for PHPUnit 4x now. I will merge this in and do this change separately. Thanks for your contribution. Thanks for spotting this bug. I will commit a fix up shortly. Cheers. The changes around the default scope should mean that we don't issue a refresh token without a scope whether that be default or ones specified in the original request. I don't think this will be required unless there is a scenario I'm missing. Apologies if this is the case.. Please can this be changed to match the current implementation in master so that we hash after base 64 encoding instead of before:\nhash('sha256', strtr(rtrim(base64_encode($codeVerifier), '='), '+/', '-_')). Please could you change this to extend TestCase and use PHPUnit\\Framework\\TestCase. We should replace all instances of PHPUnit_Framework_TestCase in this manner for this PR. To maintain consistency with our other tests, we should call $this->assertEquals instead of self::assertEquals. If you could change all instances to keep in line with the current tests that would be appreciated. Many thanks. Please update this to match the new implementation currently in master. It removes base64 padding, the need to url encode, and ensures that hashing occurs after we've base 64 encoded as per the RFC.. The logic is becoming a bit unwieldy here. I think it would be easier to just use $redirectUri here. There is an if statement above which checks if $redirectUri is not null. We could set the variable to the client redirect Uri in a new else block to make the code cleaner. . Same goes for this line here. We should just pass in $redirectUri and set the variable in an else block in the preceding if statement. . I don't think we need the travis_retry call here. From the Travis docs, it looks like the retry function only works in the script step. If you could check/change this that would be much appreciated. I agree with @sgomez here. I will make the change. hi @lookyman - thanks for your efforts to get PHP Stan up to level 7. It really is appreciated.\nI'm concerned about some of the changes we've made to our interfaces here specifying that it is ok to pass null into methods like setRedirectUri(). I can't think of an instance where it would be useful to make a call like this so I would have thought we would only ever want to call this with a string.\nThe same goes for some of the other calls where we had added null either as a return type or a param call. I was wondering if you could provide some more information on the needs for this change? Thank you. @SunMar I think we could use the included script /vendor/bin/generate-defuse-key here. I haven't tested it but I believe something like the following would suffice:\nvendor/bin/generate-defuse-key > \"mykey.txt\"\nIt would be good to state Mac/Linux/Windows derivations of this if possible but I think this method would be easier than the one that is currently listed.. I think this change can probably be left out. This file is for the version 5 security improvements. I also don't think the Key file is necessarily a security improvement, just a more efficient method. Thanks. I don't think we should use exceptions to control the flow of the program here. It is expected that we sometimes will fail these validation checks so I think this would be better handled with boolean checks. Can we use existing verifiers for this within the package?. We should check that the request is a POST request as per the RFC, section 2.1. Thanks for your detailed reply @lookyman. Apologies for the delay in getting back to you. I think there probably are some issues here which haven't surfaced until we've implemented PHPStan.\nWe should probably try and address these issues as I feel changing our PHPDoc to match the current behaviour, but potentially confuse end users is not something we should do.\nLooking at the state for example, this should only every consist of printable ascii characters. Setting it to null won't have any impact in this instance but it still seems somewhat misleading to me to call setState if we don't need to. As you suggested, I think this will need to be tidied up with some validation. I haven't looked at the other two instances yet but I presume they will be of a similar state.\nIf we accept this PR in its current form, it will ultimately mask the underlying issues which need to be addressed. Running PHPStan at level 7 has highlighted these issues so I think it would be appropriate to deal with them in this issue.\nIf I get time soon, I will look at rectifying these problems and putting in correct validation but feel free to address these if you also have a spare minute. As soon as these have been addressed I think this will be good to merge in.\nThanks again for your efforts with this!\nI appreciate there is no behaviour change happening here but our PHPDoc . It would be good to name this enablePkceFallback to have a similar naming style to the enableCodeExchangeProof above. We could shorten this to enablePkceFallback(). Please can you add a docblock for this function. Please remove the yoda condition. This should be $code !== null instead. Thanks. Is this function implemented as intended? This should be an effective gateway to establish whether we use PKCE or not. The initial problem was that we had no fallback method.\nIn its current form, I don't think this is actually solving the problem. If I have enableCodeExchangeProof set to true and send through a request without a code verifier/challenge, because we return true as soon as we check the enableCodeExchangeProof property, we would still enter into the main code exchange verification and hit the exception.\nI think the implementation below would satisfy the issue but apologies if I've missed something.\n```php\nprivate function shouldValidatePKCE()\n{\n    if ($this->enableCodeExchangeProof === false) {\n        return false;\n    }\nif ($code === null && $allowPkceFallback) {\n    return false;\n}\n\nreturn true;\n\n}\n``. I think it should be thecode_verifier` we are checking here. I appreciate now reading back comments that I suggested this variable name initially. Sorry about that :pray: . Thanks for changing!. Thanks for making the adjustment. Thanks for adding. Ahh I see what is happening here. I think it is the name of the function that threw me a bit to be honest.\nMy train of thought was that you can only have a fallback from something if that something is enabled in the first place e.g. enableCodeExchangeProof is set to true.\nThe way this has been implemented, it is actually allowing a PKCE exchange AND a fallback. Given that I think that the flag and corresponding function should probably be enablePkceWithFallback and enablePkce.\nThis seems a little messy to me though and I'm not sure off the top of my head what the best way is to resolve this. It could be that we have two constants for PKCE modes and just pass in one or the other which would dictate behaviour. I think the risk is at the moment that is isn't entirely clear what the differences between the flags are because of the naming if I am making myself clear.\nThe constants for PKCE modes might be the way to go but I'm open to other suggestions. If we did go for constants we could have something like PKCE and PCKE_WITH_FALLBACK` but I'm not entirely sure on that.\nWe don't want to mandate that all servers support PKCE as we want to keep the package as flexible as possible so that the implementer can ultimately decide. If you have any thoughts on the best way forward I would appreciate your input. I will try and have another think over the next couple of days but in its current state, implements could set the fallback mode to true and the enable pkce exchange proof to true, the second being pointless.. Don't worry, I might well be wrong as well. It is late so I'm bound to be making mistakes. The reason I thought this should be a code_verifier is because the client is asking for an access token here.\nAccording to the RFC protocol flow, the client sends the code challenge with the auth token request and the code verifier with the access token request. As such, I thought we would not expect to recieve a code challenge at this step from the client, only when they request an auth token.\nApologies if I've made an incorrect assumption here.. I don't think the namespace is correct here. Please can we change this to extend TestCase and add in a use PHPUnit\\Framework\\TestCase; statement?. As @frankdejonge suggested, it would be good to change this to convertToAccessToken. I updated this this morning @lookyman - hope that was ok but thought I'd save you the effort as it was a quick change.. I think this should be removed from the interface as people who don't want to use JWTs for their access token's will have no need for this. This is going to be a breaking change which is why I've flagged this change for version 8.\n. I think the naming of this interface is confusing. A scope shouldn't be able to add itself. I thought that perhaps you were trying to associate scopes with clients and that this would be a client interface but I see it is being used by the token interface. It makes sense that a scope can be added to a token I guess but we already had this functionality in the token interface, which has been deleted and moved here instead.. I would not expect a client to be an instance of a scope interface.. I would expect this to be a class for scopes associated with clients given the naming. The function suggests this is actually for a client instead as we wouldn't set a redirect URI on a scope.. Good spot. Yeah, I think we should probably err on the side of caution and set this as false by default. I hope that correct implementations will set this value in the constructor of their client entity as the client must either be public or confidential. Thanks for suggesting this.. Agreed although if we do switch, I'd prefer to do it project wide rather than in bits, to keep the coding standards consistent for the project. I'm also conscious to try and keep in step with the other League packages but to my knowledge, we haven't had much discussion on this. I've raised this with the other maintainers to see what there thoughts are on this and if they have any plans to move to type hinting/return types. We should add brackets to the class e.g. new IntrospectionResponse(). The description here doesn't match the function. Can this be updated? Thank you. Please add a full stop at the end of the description here. Apologies as I thought this would have been picked up by Travis CI. I will need to look at the rules. Need a docblock for this function. Thanks @lookyman - appreciated.. This is a replication of the test below. I just changed the name. I removed this section of the tests as it is replicated in the test below as far as I can tell.. Revoking this change as we aren't using return types at this time.. Revoking this change as we aren't using return types at this time.. Revoking as not using return types at this time.. Revoking as not using return types at this time.. Revoking as not using return types at this time.. Revoked. Revoked. Revoked. Revoked. Revoked. ",
    "mbollemeijer": "Mann... my fault, thank you for the quick replay.\n. ",
    "jakelehner": "Did you get this working @jacobweber? I have not been able to get the Implicit grant to work yet and noticed the same question you posed regarding checkAuthoriseParams(). So naturally, getGrantType('implicit')->checkAuthoriseParams() fails.\n. @jacobweber, did you have to do anything else? When I leave authorization_code in the that line I get something back, but it's not the expected format for implicit. It sends me to the redirect URL but it's sending me back with an authcode rather than a token.\nIt also appears to be creating an authcode in the DB rather than a token.\nDid you have to add logic to your authorise() function to handle the implicit requests differently?\n. Cool that's what I figured I was missing. Makes total sense.\nThanks @jacobweber !\n. I was able to get the password grant working with this information. Thanks! Two additional questions:\n1) @suwardany mentioned calling the \"completeFLow\" method. I didn't seem to need to do that. Can you go in to detail on when this would be used? I noticed issueAccessToken() calls this already.\n2) To get the callback function to work, I either had to make it a function outside of a class object, or make it a static function inside a class object. Is there a way to reference a callback function that is a public member of a class without making it static?\n. Brilliant. Passing in the object and method worked. I'll be the PHP documentation would have told me that too. Oh well.\nThanks @MichaelGooden @tolu360 !\n. Thanks, very helpful. I was able to get the authorization code flow working, and also the password flow. Though that seemed a little too easy.\nTwo more follow up questions if you could. I will post them in Issue #97 since they are more-so follow ups to that question.\n. Looking at the Travis report, the failure seems to come from the Password Grant test, which this commit didn't touch. Is there something I should to to resolve this? \nI did notice the Implicit unit test is missing, but did not have a chance to create one.\n. Did you see issue #72? It's not 100% complete but between that and the wiki I was able to get a controller working with this package pretty easily. I even skipped using the PDO storage drivers and wrote CI drivers that support limiting clients to certain scopes and grant types. It only took about a day.\nI will say both the demo code and issue 72 have some minor inconsistencies, but they were easy to spot and fix.\nI'd be glad to add my controller and drivers to the project as examples if that's what Alex and gang want.\nI'll try to remember to post my code tomorrow when I get to the office.\n. Looking through my controller again, I'm thinking I have too much project and company specific code to post and have it be meaningful. But if your code is looking like the example mentioned above, you should be headed in the right direction.\nAs for login form ... for me this is being added on to an existing user authentication system, so I just made a new login form for the existing system, and just tied my OAuth controller in to my existing user session library.\nWith your last question ... are you asking about how to make sure a user is authenticated when requesting a token? Or how to validate the token after it's been generated?\nFor validating the user's authentication during the token request process: that would all depend on your session management. For me I have a method that checks a certain session key and tells me if the user is logged in or not. if so, I bypass the login form and take them straight to the authorization form. If they are not logged in, I show the login form.\nAfter the token has been issued and the client tries to use that token: that is where the \"Resource Server\" portion of this package comes in to play. Your API end points will pass the token to the resource server, which will check for validity. There is a how-to on this in the Wiki.\nIf the server your API endpoints are on have access to the database where your tokens are stored, you can use the same session controller you used for the Authorization Server. In my case, my systems that handle the API calls are separate from the system that handles user auth and generates tokens. So I had to build a custom session storage driver that makes a back-end system level API call to validate the tokens.\n. I may be misunderstanding a little here, but it's sounding to me like you need to mentally separate your system's sessions with the OAuth tokens. Consider the following example:\nLet's say we have a fictional app called Awesome Social App. Awesome Social App uses Facebook login to get access to your profile and to post awesome social stuff to your timeline.\nThe first time you log in to Awesome Social App (client), it sends you (user) over to Facebook (auth server) where you log in (if you aren't already) and then grant access to the scopes requested by Awesome Social App. Once that is done, Awesome Social App gets an OAuth token they can use to interact with your profile.\nAt this point, you (user) can log out of Facebook and Awesome Social App can continue to use that token to interact with your profile. You being logged in to or out of Facebook has no impact on the OAuth token.\nNow when that token expires, one of two things happen. If Facebook has granted a refresh token, Awesome Social App will use that token to get a new access token from Facebook. The refresh token, in this case, acts as proof that you have already approved Awesome Social App to access your profile.\nIf Facebook did not provide a refresh token, then Awesome Social App loses access to your profile when the token expires (but not necessarily when you log out of Facebook ... they are separate). In this case, you would have to go back through the approval process to give Awesome Social App approval for another access token.\nMake sense? So how this relates to you is, you do not need to validate the user's login session every API call. But you DO need to verify the token every call. You need to verify the token has not expired, that it is for the correct user, and that it is coming from the correct client.\nYou have options here. One being you can store the tokens and OAuth sessions in your DB, which is how the default configuration and PDO storage drivers work. This can still be quick if you keep all of your OAuth tables in memory on your SQL server. It generally only gets slow when you involve reads and (more so) writes to disk.\nAnother option would be to change the storage driver to write and read OAuth sessions and tokens from something like Redis or a NOSQL variant. \n. Scopes are pretty straight forward. I did not find any recommendations for naming of scopes ... so I just made my own.\nAfter you have decided how you want the scopes split out, it's just a matter of matching them to the clients. The client has to request access to the scopes it wants when it requests the token. That token can then only be used to access the scopes previously approved for that token. If a scope wants access to a scope it doesn't have access to, it has to go through the authorization process again.\nThe Wiki article about securing your API talks about checking for scope access. Again this is handled by the session storage driver.\nThe ability to limit a particular client or grant type to specific scopes are not currently covered by this package. However, it's very easy to add. You just need to create a few more tables to map clients to scopes, then add another where clause to the storage driver to further limit the SQL query. \nPROTIP: Be sure to add column names to any query that has a default of SELECT * in the storage driver. Otherwise you will get conflicting IDs when you  join the tables together ;-)\n. So are you saying you would get an error when you would call isValid() on an incoming request? I haven't experienced that issue. I'm also not using the PDO driver, so there's that. I'll have a look to see what's different about my environment.\nSort of un-related ... this may not be the best approach, but I utilize the json encode and decode functions when i need to convert an object to an array. I often have array of objects where the objects also include sub array of objects. in which case the array walk doesn't go deep enough. So instead, i do something like this:\nphp\n// $convertToArray = array of objects needing to be converted\n$convertToArray = json_encode($convertToArray);\n$convertToArray = json_decode($convertToArray, true);\nThe 'true' in the json_decode function will force return of an associative array. I have not done any testing in regards to speed to see if this is the fastest approach or not.\n. What is the use case for using PUT and DELETE? All requests defined by the OAuth2 spec utilize GET or POST only. Using other CRUD methods would be varying from the spec.\n. I think you're confusing your API server with your OAuth server. You can support any of the CRUD methods on your API server. That has nothing to do with the OAuth process. \nThe OAuth2 RFC defines every call the OAuth Authorization server would need to make to manage the OAuth lifecycle, and all utilize GET or POST methods.\nAlso, the 'Resource' server provided in this package is not meant to be used as a full API server layer. It is only meant to obtain information and authorization data for the tokens that have been generated. So your API server may load the request library to authorize the tokens it receives, but in that case the API server is the one handling the CRUD methods, not this package.\n. Again, I think you're confusing the API request layer with the OAuth 2 layer and what this library provides. This library is not an API server.\nEvery request method involved in the OAuth 2 process is GET or POST, as described in the spec.\nSection 7 is simply stating the resource server must verify the token to ensure they are valid. It then provides room for different token types, of which Bearer is one.\nThe \"other services\" you mention are using the other HTTP verbs at their API layer. The fact that the API is secured with an Oauth token does not mean their OAuth server is utilizing those verbs. \nAgain, don't confuse the API layer with the OAuth layer. This project is not an API server.\n. @stefanfisk, I understand you're referring to the ResourceServer aspect for verifying the access token. That does not change my previous replies.\nAs @alexbilbie stated, if you are including the token in the HTTP headers, the CRUD method is irrelevant. If you are sending the token in the PUT/DELETE body, that may be different. However, I don't see a reason for doing this.\nConsider the following:\n1. Client application submits a PUT request to your API server. They include an OAuth token in the Authorization header using the Bearer format mentioned above.\n2. This request is caught by a controller in your API Server library. \n3. The API Server controller loads the ResourceServer library provided by this package in the constructor.\n4. Your API Server controller runs the isValid() method. \n   1. This can be wherever but I run it in my constructor to catch invalid tokens early.\n   2. The ResourceServer library will check the HTTP Header for the token, so the CRUD method is irrelevant.\n5. Once the token is validated, you can run other checks if you wish to limit your call to specific scopes, owner types, etc.\n   1. Again, the ResourceServer can do these checks regardless of the CRUD type.\n6. After all of these steps are complete, the request itself has been verified. The OAuth portion is over.\n7. Your API Server can now access the body contents for the PUT request. The ResourceServer is no longer involved.\nHopefully that made sense. I understand the OAuth2 spec doesn't specifically call out DELETE or PUT methods. That is because the OAuth spec is meant to define how the OAuth process works, not how the entire API flow should work.\nThe takeaway here is, your API Server is what is interpreting the PUT request, not the ResourceServer. The resource server is unaware of the CRUD method being used.\nNow, if you have a situation where the Oauth token MUST go in the PUT/DELETE body, rather than the HTTP header, that's a different story. That, however, would also fall under a different token type definition which would be an extension of this library. I would also question such an approach. OAuth is an Authorization layer. It makes sense for Authorization to stay in the HTTP header so as to not confuse it with the API request payload.\n. And just as a follow up, I ran through the steps listed above in my local test environment and was able to properly process a PUT request through my API server, secured via OAuth2 using a Bearer token in the HTTP header.\nIs the only issue here that you're trying to send the token through the PUT body rather than the HTTP header? Why would that be required?\n. Ok, so if that's the issue, I see why you're having troubles getting PUT/DELETE to work. And in that, you're right that the ResourceServer library could be extended to fetch tokens from the body of these methods. \nFor that you could extend the League\\OAuth2\\Server\\Util\\RequestInterface library to implement the remaining crud methods.\n@alexbilbie, FWIW, I would vote this should be an extension, though, and should not be included in the base package.\n. Isn't this per the Oauth spec? As I recall, it states the redirect URI for each client must be known and cannot change from request to request.\n. See section 10.6: http://tools.ietf.org/html/rfc6749#section-10.6\nIn order to prevent such an attack, the authorization server MUST\nensure that the redirection URI used to obtain the authorization code\nis identical to the redirection URI provided when exchanging the\nauthorization code for an access token.  The authorization server\nMUST require public clients and SHOULD require confidential clients\nto register their redirection URIs.  If a redirection URI is provided\nin the request, the authorization server MUST validate it against the\nregistered value.\n. A few things:\n1. The OAuth2 spec states the client_credentials request should be a POST, rather than GET. This library may still work using GET, but you should switch to POST to more closely adhere to the true OAuth2 workflow.\n2. What is client_details? I assume this is something you're using in your app?\n3. Are you setting your authorization header string correctly?\n4. The client_credentials grant request is made to the token endpoint; you don't first use the authorization endpoint as you do with auth code grant. Depending on how your controller is set up, your client credentials request should be sent to something like http://api.domain.loc/oauth2/token. It should match whatever the URL is when exchanging an auth code for a access token in the auth code grant workflow. The error you're getting is probably because you're going through the authorization endpoint, and it doesn't know what to do with the request so that's the default error. Just a guess.\n. What is the version constraint in your composer file? Could it be a result of the recent upgrade to 3.0?\nOne of the reasons I don't use composer ;-)\n. Because in 'other'grant flows, the access token is sent via POST body over SSL, and then stored in a secure location on the client's side.\nWith Implicit, the access token is often sent back in the query string (which can be seen even over SSL) and likely stored in an insecure location. For example, if the client is a Javascript app, there is nowhere the client could store the access token that would be accessible by the client but not anyone else.\n. That all depends on if you are able to transmit and store the access token in a way that it will never be accessible by an unauthorized individual (or system).\nWhat is your reason for wanting to use Implicit grant type if you aren't doing a JS app? Honestly I have yet to find a reason to use it. I'm willing to bet there is a better option for you. What's your use case?\n. I wouldn't mind helping out with a few of these if you need it. I'm still traveling a bit for the holidays, but may have some time on my off day tomorrow.\n. Does this mean 4.0 is on the horizon? I've had to go live with a fairly significant implementation using v2 of the library ... hopefully migrating to v4 won't be too bad ;-)\n. I apologize if this comment is out of place; I've yet to familiarize myself with v4. However, wouldn't the following from the spec apply to malformed requests or requests with errors referenced in this thread?\nFrom Section 4.1.2.1\n\nIf the request fails due to a missing, invalid, or mismatching\nredirection URI, or if the client identifier is missing or invalid,\nthe authorization server SHOULD inform the resource owner of the\nerror and MUST NOT automatically redirect the user-agent to the\ninvalid redirection URI.\n\nDoesn't this suggest the right thing to do in this scenario is warn the user and not send them back to the client?\n. ",
    "chadhutchins": "Wow, right in front of my face... missed that one. Thanks!\n. ",
    "nhorvath": "done. https://github.com/php-loep/oauth2-server/pull/84\n. ",
    "coveralls": "\nCoverage remained the same when pulling f612e105bd93814a8c2306e413ebd8b8d3d0d6d8 on nhorvath:develop into 56f63bb4c0e86ec35639c187c559296d73946306 on php-loep:develop.\n. \nCoverage remained the same when pulling 69710a5909edaece3bd55b2c559fe701c55086cf on daveWid:normalize-headers into 879d98abfbfdf8a8eab45faa8cd36fca7605aafc on php-loep:develop.\n. \nCoverage remained the same when pulling a2bf4e0dfb681754866670d8131c8c25f09c50e5 on daveWid:request-interface-cleanup into cfbb037e071d3f52c308e026f609ea6307da1b15 on php-loep:develop.\n. \nCoverage remained the same when pulling 23627c659e05da633619c2d846462ca55af1bcc0 on fotovio:develop into bee71c1e831c2970ed4b9e2dc770b0a354207d29 on php-loep:develop.\n. \nCoverage remained the same when pulling d3158a830b53413ffeb2b82a6bfda5e90113b3b1 on jackshakes:develop into 4a71c376b8bca9966bab25597061d14dc0c8e574 on php-loep:develop.\n. \nCoverage remained the same when pulling 343b59fbc11bf279819c0e9b99f99362582dac00 on ChupacabrasX:master into 4a71c376b8bca9966bab25597061d14dc0c8e574 on php-loep:develop.\n. \nCoverage remained the same when pulling bb1c8360812151d160302f435a3ba8af2d863a7e on hailwood:develop into 4a71c376b8bca9966bab25597061d14dc0c8e574 on php-loep:develop.\n. \nCoverage remained the same when pulling 8f69d1f3f952a89f7c64b760b12c1db349373e2b on andersonamuller:patch-1 into 302026d437e14be6b5257ee3b6dd152f6984ae23 on php-loep:master.\n. \nCoverage remained the same when pulling 9b9cf79f39849b9c09e6736f26c32258aa372986 on andersonamuller:patch-1 into 619d7550085158b794f90e984a87bf31f9cfe329 on php-loep:develop.\n. \nCoverage remained the same when pulling 8c0b13a09f5cb549140a3ed94677d3e94609f2d5 on JavierMartinz:fix-session-var into f563a59ce8363fc830f7f1b031d19b028d8c1f49 on php-loep:develop.\n. \nCoverage remained the same when pulling 8b71c95bddee41041ea03c5462e8102e40fefc2c on fahmiardi:develop into 25332be3d1a90599df06c2fac6fb31cb3df6a917 on php-loep:develop.\n. \nCoverage remained the same when pulling cc1e78e1ff9b92f2399360c1bf4e3d6809503f37 on giftcards:develop into 54ffa58e7b4553a16e889ef15b29b0c1e0323b24 on thephpleague:develop.\n. \nCoverage decreased (-0.89%) when pulling 1c74568ab82f2126f4174b4002f9b231d902a05f on nothing2lose:develop into 5ffbe6ac379322c0f9a24ac05c3753eafc25ed59 on thephpleague:develop.\n. \nCoverage remained the same when pulling cd767c07fa608c493994d25566dd84b3d52723d0 on ushahidi:notabs into 8e164f4b9928cb6250a2fca641c2d7328b6caa4d on thephpleague:develop.\n. \nCoverage remained the same when pulling 18988ede3ee4b90b1245f45cbfdd94e567227433 on ushahidi:resource-server-errors into 8e164f4b9928cb6250a2fca641c2d7328b6caa4d on thephpleague:develop.\n. \nCoverage remained the same when pulling aa903b224432e0d6f42a5521f5bddb72d3e7342f on ushahidi:resource-server-errors into 8e164f4b9928cb6250a2fca641c2d7328b6caa4d on thephpleague:develop.\n. \nCoverage remained the same when pulling c7dfc42d57d1889f9a757b5a753ab740a1b85598 on acairns:develop into 8e164f4b9928cb6250a2fca641c2d7328b6caa4d on thephpleague:develop.\n. \nCoverage remained the same when pulling 2f49789040b28585a5a72f21e4951a0809e7552f on josephspurrier:develop into 4480aa3456317c6f0a4f45cd8865c397f182f591 on thephpleague:develop.\n. \nCoverage remained the same when pulling d04c93d099d5444a89a133db4d9d3fbf31fed8bf on josephspurrier:develop into 4480aa3456317c6f0a4f45cd8865c397f182f591 on thephpleague:develop.\n. \nCoverage remained the same when pulling 2004845f610b04ba2d1de15506758c3f6ecf1a22 on ushahidi:fix-http-headers-util-request into 7771bc04ec8697cef9505bc819a47d1cb134a916 on thephpleague:develop.\n. \nCoverage remained the same when pulling 1e65f6f28ec77d3e92faec6989a196396383e989 on s-faychatelard:error-code into 13cd0cacdf1e9ae23fa073d4408a336246babb8e on thephpleague:master.\n. ",
    "dschniepp": "Sorry, missed it, it's already fixed in the development branch.\n. ",
    "daveWid": "@robertpitt There already is an interface for the Request class RequestInterface, but it has a constructor included. There is also a static buildFromGlobals function in there that should probably be removed as well.\nbuildFromGlobals is great for the included Request class, but you wouldn't need it (hopefully) if you passed in a Request object from another library or framework.\n. ",
    "henyana": "Hi, I know that this is an old post.\nBut I've one question related with this issue.\nIs there any extend owner_type rather than user and client or can stick on default specification ?\nFor example if I have an user has administrator role who can configure the oauth expires_in for each client_id\n. ",
    "suwardany": "Thanks @alexbilbie \n. Hello,\nYou are correct about the callback function, it can be set using $server->getGrantType('password')->setVerifyCredentialsCallback(\"callback_function_here\");\nThen you pass in the client_id, client_secret, username and password to the completeFlow function like this\n$server->getGrantType('password')->completeFlow($inputParams);\nThat's going to validate your user credentials using the callback and then validate the resource owner credentials and if everything is set, you get back a new access token!\n. @andreoav \nYes, you need an authorization server to issue access tokens to validate against!\nRegarding the grant type, it depends on your use case,\nA good place to get you started is https://github.com/php-loep/oauth2-server/wiki/Which-OAuth-2.0-grant-should-I-use%3F\n. ",
    "tolu360": "Thank you @suwardany for the swift response, certainly appreciated.\n. Just to elaborate on @MichaelGooden 's point, if you are using a Controller class for your oauth server, you can set your callback in your constructor function like so:\n$this->authServer->getGrantType('password')->setVerifyCredentialsCallback(array($this, 'validateUser'));\nwhere validateUser() is a public method in your class which returns a validated user_id. Hope this makes it clearer, @jackshakes ?\n. ",
    "aoxior": "Hey I am getting the Same error it is working fine on the Local server but getting problems in the live server (i am using linux VPS through godaddy), how to fix this, any help would be great help, I updated Composer to dev but still it is not working\n. ",
    "lucadegasperi": "Ok I went with a first implementation for Laravel, you can check it out here:\nhttps://github.com/lucadegasperi/oauth2-server-laravel\nThere aren't any unit tests as of now, but will work on them once the feature definition is set.\n. could you please be more specific? how does the JSON string look like? which request parameters have you used that generated the JSON string?\n. What I'm not sure is that almost any table has a relationship with the scopes table, It feels redundant.\n. Thanks Alex!\n. That angel at the end almost convinced me. Let me fix some of my issues first, then I'll see what I can do for you. I warn you I'm no unit testing guru. :smile: \n. Allright, don't know how to begin testing this. Mock everything perhaps?\n. I'm talking about the auth code flow non the access token one.\nOn Thu, Aug 7, 2014 at 11:20 AM, Alex Bilbie notifications@github.com\nwrote:\n\nIt isn't an issue because acquiring an access token is a POST request which the client makes in the background, the user doesn't leave the client.\u2014\nSent from my iPhone\nOn Thu, Aug 7, 2014 at 9:29 AM, Luca Degasperi notifications@github.com\nwrote:\n\nHey Alex,\ngreat work on the develop branch! \nAs you know I'm implementing a Laravel wrapper for the new version. One point I'm confused about is how to redirect the user back to the client when the auth_code grant type parameters check fail.\nI know there is a shouldRedirect flag but there's no way to know the redirect uri to redirect back to.\nI cannot read your mind, any clue on how to do this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/195\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/195#issuecomment-51449128\n. Yes, In some cases when the request is malformed, the user should be redirected back to the client. There's a flag on the OAuthException specifically for this. Problem is, there's no way to access the client's redirect uri when the exception is thrown, thus it's impossible to redirect to the client.\n. Would you mind taking care of this?\n. Also, there should be a way to generate a redirect uri back to the client when the user denies the client to access its resources.\n. Yes and return null if it is not present. I'm fine with it. Although this will add one more layer for the end user...\n. I would see it as a dialog...\n\n\nresource server, who is the current resource owner?\nor\nresource server, what's the current access token?\naccess token, what's your owner?\nThat's up to you i guess but i would rather go with the first one. \n. > The resource server doesn't know about the resource owner (that's application specific), but it does know about the authenticated access token and who owns that.\nTrue. But from a end user perspective you should also consider the readability and simplicity of the methods.\n\nThe resource owner and the authenticated user (through the access token) might not be the same.\n\nThat's not really the point.\n\nPerhaps resource server isn't the best name?\n\nIn my wrapper package I refer to them as se Issuer (AuthorizationServer) and Checker (ResourceServer)\nbecause to my mind a server is the whole codebase that gets deployed, not a package in it.\n. I like the new changes.\n. The reference needs to be removed by logging into packagist as well... It's the last one on the list.\n. This has to do with the way angular passes parameters back to the server. They need to be form encoded into the POST payload in order to work.\nThe request you make should look something like this in the end otherwise it won't work.\n```\nPOST /oauth/access_token HTTP/1.1\nHost: www.example.com\nAccept: /\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nclient_id=1&client_secret=1111&grant_type=client_credentials\n```\n. Agree with @juliangut those methods are a very welcome addition and would allow for some great customizations as well as better framework integrations.\n. @frederikbosch awesome!\n. There's already an adapter that works with Symfony objects and Laravel. You can check this section of the Laravel documentation on how to use it:\nhttps://www.laravel.com/docs/5.2/requests#psr7-requests\nas well as the more detailed version on the Symfony blog:\nhttp://symfony.com/blog/psr-7-support-in-symfony-is-here\n. ",
    "csavory": "Luca,\nI'm using your wrapper.  It's awesome and made oauth integration really simple! I'm getting a JSON string set in the client_id column of oauth_sessions.  Do you think that is from your wrapper or the leop code?  \n-Chris\n. I just found the problem.  The callback I was using in the password grant was wrong.  \nI was using\nphp\n                return Sentry::findUserByCredentials(array(\n                        'email'    => $username,\n                        'password' => $password,\n                ));\nLooks like I should change it to this:\nphp\n                $user = Sentry::findUserByCredentials(array(\n                        'email'    => $username,\n                        'password' => $password,\n                ));\n                if (isset($user)) {\n                    return $user->id;\n                } else {\n                    return null;\n                }\n. ",
    "samedney": "Sorry - that is really what I meant. Im using the composer.json and attempting to write all the controllers etc in CodeIgniter.\nI think I almost have things working - but thought I should check that there isn't already some code out there for this.\nIm basically using the sample code from the Wiki page and changing a few things to use CodeIgniter specific features (uri and session etc).\n. Also, not sure if it is intentional, but if you follow the demo code - should getClient() in storage/pdo/client:\nalso return oauth_clients.auto_approve in the array, or should it come from elsewhere?\n. No, I hadnt seen that - but things are looking very similar to what I have. \nIve got this all working now too. It would be good to discuss and compare.\nI kept the PDO code but made quite a few changes. I have also made a very simple username/password login page and added a couple of additional methods (for getting user_info etc). Trying to mirror the Google oAuth stuff where possible.\nI would really like some assistance with working out how to use Scopes. Is there any recommended documentation out there for that?\n. I have put my main oauth controller here: http://codepad.org/HqDCMnYe\nand here is the html sign-in view. http://codepad.org/S0RVlm2L\nand the modified Server/Storage/PDO/Client -> getClient()  here: http://codepad.org/JBhml3mC\n. Also - Im sure this is simple, but what is the best way to make sure that a user is still authenticated from apps that make use of the oauth api?\n(Maybe I will just wait to see jackshakes' code!)\n. Thanks Jackshakes,\nYou have basically answered my question. I was going to do things with CI sessions but was concerned that doing so was not the most appropriate way when using oAuth. If Im going to this much trouble I might as well do things correctly! :)\nMy real concern was speed. ie. Checking that the user is still logged in every time I make a call from the client app. Im testing this with our custom written support desk, which currently authenticates with Google. \nShould I go so far as to check that the user still has a logged-in Google (or custom oAuth) account every time I perform an action in the helpdesk?! \nIf so - what is the most suitable method? ie. Which is the correct method (URL) to call?\n. And sorry: Scopes. With google, you get to set things up to allow different apps to have access to different parts of your dataset.\nHow do I make use of these? \nLet just say that I have several sets of information tied to a user. \n- Basic (email)\n- User (real name, email, age etc)\n- Employer (company details, address)\n- Financial (salary)\nIf I want my support app to only have access to the email, what would be an appropriate way of pushing only this information out to the client?\nAgain - if there is some suitable code or wiki elsewhere - please just let me know!\n. Thanks for the above. I think it gives me more than enough to be getting on with. Again, its pretty much what I was thinking - but just wanted to make sure that I wasn't stepping out of the oAuth system unnecessarily.\nBasically, I think it would be a very useful to be able to download a complete working oAuth2 system - based on a CI project - which has the database, a login page, scopes (and potentially a form with the ability to grant them to users) - and the backend oAuth2-server - all in one working package.\nI'll try to keep things standardised and will upload anything I manage to create once its working.\n. ",
    "rahendz": "is there anyone could give my step by step to integrate this oauth libs on codeigniter 2?\n. ",
    "nsilvah": "Nope, it doesn't. You only are normalizing the headers when the getallheaders function doesn't exist. The getallheaders function doesn't normalize the headers.\n. ",
    "andreoav": "@suwardany Thank you for your quick answer.\nResource Owner Credentials is exactly what I need.\n. ",
    "sicsol": "jackshakes you are correct. \nI made adjustments in my framework to accommodate this use case from CRUD operations. This request is no longer needed.\nThanks\n. Realsurfer when doing your crud operations just add the following to your request headers. \nAuthentication: access_token_value\nThis will authenticate the user and you can use any method that your API supports. \n. I'm using laravel as well. Things are working great. \n. ",
    "realsurfer": "If I am trying to do CRUD operations to my rest api that is authenticated via an OAuth access token I also encounter these errors. I fail to see why I shouldn't be able to use PUT or DELETE if I want my api to be restful or am I missing something? Even Facebook supports DELETE.\nThanks,\nMichael\n. Thanks for your quick reply.\nYes that makes sense. Why I encountered this problem is that I am using this package https://github.com/lucadegasperi/oauth2-server-laravel for my Laravel installation and securing my API endpoints as shown in the docs. Maybe the integration in that package is not working as intended?\nYes sicsol that is how I made it work for the time being. Thanks for our feedback!\n. ",
    "stefanfisk": "I admin that I've only skimmed through the OAuth2 spec, but I cannot find anything pointing towards only GET and POST being the allowed methods for resource access. In section 7, \"Accessing Protected Resources\", it is only described how the token might be passed to the server using the Authorization header.\nAlso, other services (Instagram for example) allow using all HTTP verbs for resource access even though they use OAuth2 where you pass the token as a request parameter.\n. Yes, but what we are discussing here is the Resource Server part of PHP OAuth 2.0 Server, which in the readme are describe as \"The resource server allows you to secure your API endpoints by checking for a valid OAuth access token in the request and ensuring the token has the correct scope(s) (i.e. permissions) to access resources.\".\nThis check only works on GET and POST requests now, since RequestInterface only implements accessors for GET and POST.\nIf this is not the proper way to protect API server endpoints using this package, then how would one go about doing so?\n. I'm sorry, but I'm still not following why ResourceServer::isValid() should not support methods other than GET/POST. I've browsed through the specification again, and I can still not find any basis for this decision. Also, if they should not be supported, shouldn't the function at least throw a 405 client exception instead of triggering a PHP error?\nCertainly passing the token in a header works, but if PUT is not an allowed method then I don't see how that is any more standards conformant than supporting passing the token as a parameter.\n. I can certainly do the actual implementation of this, as long as we agree on it being allowed according to the OAuth2 specs. @jackshakes has indicated otherwise a couple of times now.\n. Yep, but I'm still not convinced that the specifications say anything regarding this use case. As I said I cannot read the specs in such a way so that ResourceServer does not represent what is described by Section 7, and in there nothing is really specified regarding what is and isn't allowed.\nIf the specs say that this should not be allowed by ResourceServer, I reckon we should be clear on where in the spec this is specified.\n. I implemented the authorization by passing the token as a parameter out of habit, as this is how essentially all OAuth2 APIs I use do it (not that I imply it making more sense for that reason). And since it is supported for GET and POST I still cannot see why it would be wrong to support it for other methods.\nI do agree however that using the header is cleaner, and I will re-spec my API server to use this method instead.\n20 nov 2013 kl. 17:46 skrev jackshakes notifications@github.com:\n\nAnd just as a follow up, I ran through the steps listed above in my local test environment and was able to properly process a PUT request through my API server, secured via OAuth2 using a Bearer token in the HTTP header.\nIs the only issue here that you're trying to send the token through the PUT body rather than the HTTP header? Why would that be required?\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "greatnonprofits-org": "I think at a minimum it makes sense to check if the method is supported or not and throw an exception if unsupported so that upstream users can catch and manage this edge case. Since calling a nonexistent method isn't something upstream can catch. \n. Is there an alternative way to validate an authorization token with out hitting the isValid method since the assumption is that under correct usage put/delete endpoints would only be authenticated with a token and wouldn't be performaing any other oauth activities like creating new tokens, deleting tokens. \n. for people using the Lucadegasperi Laravel  server: this is my workaround. \nWe use a custom filter since we also allow other api authorizaton methods, in the section of this that calls LucaDegasperi filter I add a conditional check to verify there is a valid authorization token \nwhen not submitting a get or post method. \nThis is less than ideal but will work more most cases. \n$method = $_SERVER['REQUEST_METHOD'];\n    if($method == 'GET' ||  $method == 'POST' )\n    {            \n        $oAuth = new \\LucaDegasperi\\OAuth2Server\\Filters\\OAuthFilter();\n        $oAuthFilter = $oAuth->filter();\n    } else {\n        // For other methods due to a issue with the Legaue Oauth Provider we can only proceed if a bearer token has been provided. \n        $headers = getallheaders();\n        if(isset($headers['Authorization']) && strpos($headers['Authorization'] , \"Bearer\") === 0)\n        {\n            $oAuth = new \\LucaDegasperi\\OAuth2Server\\Filters\\OAuthFilter();\n            $oAuthFilter = $oAuth->filter();            \n        }\n    }\nnot I also provide or override the getallheaders methods behind the scenes as we need to do some funny stuff on our locked down pre-release developer sandboxes to avoid basic auth from interfering with bearer auth. \n```\nfunction getHeadersExcludeBasicAuth()\n{\n    $headers = apache_request_headers(); \n    if(isset($headers['Authorization']) && strpos($headers['Authorization'], \"Basic\") === 0) {\n        unset($headers['Authorization']);\n    }\nif(isset($headers['X-Authorization']))\n{\n    $headers['Authorization'] = $headers['X-Authorization'];\n}    \nreturn $headers;\n\n}\nif (function_exists('getallheaders')) {\n    override_function('getallheaders','', \"return getHeadersExcludeBasicAuth()\" );\n} else {\n    function getallheaders() {\n        return getHeadersExcludeBasicAuth();\n    }\n}\n```\n. ",
    "andreikun": "If you want to access secured paths using access_tokens as query , string info below might help you:\nCheck here: https://github.com/thephpleague/oauth2-server/blob/master/src/ResourceServer.php#L146\nIt shouldn't be $this->getRequest()->request->get($this->tokenKey). Instead it should be $this->getRequest()->get($this->tokenKey).\nThat;s why it does not work. I already adjusted my code, it would be nice if someone from phpleague will adjust too.\nIt works now with both POST and GET having access_token in query string like ?access_token= mQ77AR4vzpTdn81Sc4os7FdRYWd3UJJjQ1GBJ3Us\n. If you want to access secured paths using access_tokens as query string informations below might help you:\nCheck here: https://github.com/thephpleague/oauth2-server/blob/master/src/ResourceServer.php#L146\nIt shouldn't be $this->getRequest()->request->get($this->tokenKey). Instead it should be $this->getRequest()->get($this->tokenKey).\nThat;s why it does not work. I already adjusted my code, it would be nice if someone from phpleague will adjust too.\nIt works now with both POST and GET having access_token in query string like ?access_token= mQ77AR4vzpTdn81Sc4os7FdRYWd3UJJjQ1GBJ3Us\n. Hello yazfield\nPlease check here my problem: https://github.com/thephpleague/oauth2-server/issues/375\nMaybe you have the same issue, and your request is just the same with the previous one where you had Authorization.\nCheck the get() method. This won't return empty string, for sure. empty array or null will return this one if no authorization is found. Better check your Auhorization header from previous requests.\nThanks.\n. It seems that Request is set via Authorizer inside the Oauth2ServerServiceProvider. This is an implementation of lucadegasperi for Laravel/Lumen.\nWhen using PHPunit, app is bootstrapped only once for each TestCase, which means that ServiceProvider is registered only once even if i make multiple requests. \nThis means that setRequest is called only once, at first call when application is boostrapped. This also can be fixed somehow from your part, by always getting the latest request.\nI will also post an issue on lucadegasperi package.\n. No, where am i supposed to do this? I am just making requests to API like $this->get(...) and $this->post(....). that's it. \n. I am using nginx, so this has nothing to do with Apache.\nIn my case i was using Lumen, and it wasn't any implementation of oauth2-server for Lumen at that time, so i used an implementation from Optimus which required lucadegasperi/oauth2-server-laravel v4.\nNow, lucadegasperi has fixed the issue on the latest version (5). They added the following line:\nhttps://github.com/lucadegasperi/oauth2-server-laravel/blob/master/src/Middleware/OAuthMiddleware.php#L70\nNow, every time you check for Authorization header, request is updated by getting $request object from the Middleware function as parameter.\nThanks.\n. Please see my comment to fix this here : https://github.com/thephpleague/oauth2-server/issues/340#issuecomment-137696626\n. ",
    "vladaverin24": "So how did you solved it?\n. ",
    "origal": "$server->addGrantType(new League\\OAuth2\\Server\\Grant\\AuthCode($server));\n. Nevermind, got it! :)\n. Uh, this is embarrassing.\nThanks!\n. I see. How is that updated documentation project going? Maybe I can help with an updated authcode grant flow example? (Slim based)\n. I see.\nI have an instance of Server, but there isn't seem to be an isValid() method in it.\nOn which stage do I instantiate a Resource and how?\n. Thanks\n. Why do you recommend avoiding it?\n. Could you clarify why should the access token be treated as public knowledge with the implicit grant, as opposed to the other grant flows?\n. I will read this blog post and try and get a better understanding. So if I implement this grant without sending the access token in the query string and my client isn't a JavaScript client, I'm all good?\n. The use case is pretty simple. It's an API that serves native iOS and Android official clients. We have our own content website which the applications access via these mobile apps:\nUsing our iPhone/Android official app, a user should be allowed to login to our website either by our own service user and pass which we provided him when he first signed in to our website, or by his Facebook/Google and so own.\nIn addition, The process of logging in with another Idp such as Facebook/Google/Twitter should be managed by Gigya (http://www.gigya.com) which offers this authentication as a product.\n. Is this grant suitable for users that have different permissions over the content?\n. Hmmm according to your guide this is done easily as different types of access tokens have different permissions..\n. Will look into that. Thanks\n. What would you recommend doing in the meanwhile?\n. 2.1.1\n. Thanks for the reply.\nI will read #111 entirely, I wasn't aware this was already discussed here.\nQuestion: If it's a given that my API requests are done with the access token as a parameter and not on request headers, can I still pass it on the header from the slim app route to the Resource server, or do I need to apply this patch in that case?\nThanks again, appreciate the rapid reply :) :+1: \n. Alright. I Have read the issue and I must say it makes sense. Will make the right adjustments for this.\n. ",
    "SHELA": "after update get\nClass 'League\\OAuth2\\Server\\Storage\\PDO\\Db' not found in\n. waiting for documentation)\n. and what you decide to do?\n. so...any idea's?\nsimple wiki to start work with 3.* version?\n. ",
    "alexmcroberts": "That branch was created by @philsturgeon based on my request on May 14th to\nboth @philsturgeon and yourself. If you check your emails, you'll see one\nfrom me. It should have pointed to 1.0.9 but in fact it didn't. Once that\nbranch was created I had to point to the\ncommit b29a14ae85349aa5bc3a483e10ee5a02ae2b887d - my require file was\nessentially:\n\"require\": {\n\"league/oauth2-server\": \"dev-temp#b29a14ae85349aa5bc3a483e10ee5a02ae2b887d\",\n },\nIt looks like it was only deleted from the repo today, since we've had\ndeployments running upto this morning that worked no problem.\n. Is it possible that you can recreate a branch with this name at the tag\nabove? \u200bWe've tried forking this branch and creating our tag which works\nlocally, but on the deploy composer is asking for a username / password and\nwe can't get this working.\nEDIT: I didn't get the comment from @philsturgeon until after I posted this. He was right, the tag 1.0.9 works. I'll close this now. Thanks guys, appreciate the help\n. ",
    "andersonamuller": "Done\n. Does anyone have a fix for this case?\n- Container PHP-FPM runs on www-data;\n- OAuth keychain are Kubernetes secrets mounted and owned by root;\nAFAIK, you cannot change that last part.\nSee also https://github.com/laravel/passport/issues/418#issuecomment-312866308. USER defined in the container is already www-data so I cannot create a script to call a chown the user does not have permissions.. You forgot the immutability: \nphp\n$response = $response->withHeader($header, $content);\n. You forgot the immutability: \nphp\n$response = $response\n              ->withStatus($this->getHttpStatusCode())\n              ->getBody()->write(json_encode($payload));\nor \nreturn $response\n          ->withStatus($this->getHttpStatusCode())\n          ->getBody()->write(json_encode($payload));\n. The write method returns the number of written bytes, not the response. You could do:\nphp\n$response->getBody()->write($exception->getMessage());\nreturn $response->withStatus(500);\n. ",
    "mulama77": "Srry, Just read https://github.com/php-loep/oauth2-server/issues/111 \ni'll try to implement it outside the spec..............\n. ",
    "JavierMartinz": "Ok, it was a issue of Laravel 4 adaptation. It is already fixed in its develop branch. Sorry for the inconveniences\n. ",
    "remithomas": "I agree but I meant to allow client to extend params into authorization URI. Of course it depends of the framework, nothing to do with this perfect oauth2-server. \n. ",
    "fx88": "THX\n. ",
    "shadowhand": "@alexbilbie how can this project claim to have 100% spec coverage when it doesn't implement part of the spec? I don't think this question has been answered at all, as the auth server doesn't properly switch backed on response_type=token request parameters.\nI wasted 4 hours of my day convinced that I was doing something wrong, when in fact, this auth server doesn't do what oauth specifies!\ncc @rjmackay.\n. > The project README claims it is \"spec compliant\"\nMy mistake, I was conflating the two.\nAfter sleeping on this, I think you're right... it is a security hazard to allow implicit grants. There's no risk through exposure through the URL, so long as the query fragment is used properly, because fragments aren't sent through the browser's HTTP request, but this does not address browsers potentially having the token in plain text in the history. (Additional reference: implicit grant security.)\nWe can adapt our code to use client credentials. Thanks for this great library!\n. @jgoux we just use a Client Credentials grant and store the credentials directly in the code, and limit the access to this specific client to only be usable via our web app. See App.oauth.js for implementation details.\n. I believe this has been fixed.\n. Okay, the documentation is one thing, but this issue shouldn't be closed without a fix in the code... right?\n. Ping @alexbilbie, any chance you will look at this today/tomorrow? We'd like to start using it.\n. Anything else I should do to help move this along?\n. Alex, how goes the documentation?\n. @alexbilbie I'm willing to help carry on the development of the current branch if you need to focus on docs and the next version... we're (@ushahidi) are getting to the point where the lack of movement on this is starting to be an issue, but we'd rather not fork.\n. @philsturgeon I don't know why Github thinks there are merge conflicts... I can merge this branch without any issues locally.\n. @philsturgeon wait wait, I see now... I was merging to master, not develop. Fixing now.\n. @alexbilbie honestly, fwiw, I think that v3 API is very good... I was able to implement the storage interfaces in about a day and have a fully operational server a couple of days later.\nI admit I have not followed v4 development very little, but can you point me at a document that explains the goals of a new version? I'm wondering if there would be some way to realize greater levels of scope injection, etc within the v3 branch.\n. @alexbilbie also, can you tag this v3 for version 3.2.1, with this included? We'd like to start using it ASAP.\n. @alexbilbie well I hope you are not developing it in isolation... the more documentation you can write before writing code, outlining how the data flows through the system, the easier it will be for others to help you. FWIW, I use nomnoml to create DFD diagrams for @ushahidi and it has been tremendously helpful in getting the team to understand the architecture.\nIf you ever want to chat about stuff, I'm often on Freenode IRC as shadowhand in the #kohana, #ushahidi, and #cleancode channels, among others.\n. @alexbilbie v3.2.1 is not appearing on packagist... can you force update it? https://packagist.org/packages/league/oauth2-server\n. Coveralls is either being laggy or lazy, here's the report: https://coveralls.io/jobs/2252699\n. @philsturgeon and a new tag too please? \n. @philsturgeon thank you sir!\n. :+1: \n. @alexbilbie can you comment a little bit more on close status? Is this integrated with v4, or simply too old  to be merged?\n. cc @philsturgeon @rjmackay \n. Travis failure is bogus, PHP 5.5 failed because the timing was off-by-one second: https://travis-ci.org/thephpleague/oauth2-server/jobs/30601056\n. I did a force push, it should be okay to merge now. :)\n. Thanks @alexbilbie! Can you also tag a new release so that we can start using this?\n. Thanks! It fixed our build! :dancers: https://travis-ci.org/ushahidi/platform/jobs/30665593 :dancers:\n. before:\n\nThe request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed. Check the \"%s\" parameter.\n\nthis happens because the original call was not adding anything for the %s replacement.\nafter:\n\nThe request is missing an access token in either the Authorization header or the access_token request parameter\n. Build failure is due to buggy test which failed to run in less than 1 second.\n. @alexbilbie @philsturgeon do I need to do anything else to get this merged? I want to keep helping with this project, but the radio silence that follows every pull request is disheartening...\n. @alexbilbie is it also tagged?\n. This method is duplicated in Authorization server, along with getExceptionType and getExceptionHttpHeaders. Should I abstract these in some why? If so, do you have a preferred class name?\n. whoops, just noticed this was duplicated.\n. noticed that all of the @package names pointed to the old repo name, but didn't change them, for consistency reasons.\n. Format of the values is different here, but it doesn't matter because of the normalizeHeaders call below.\n. uses the same code as invalid_request. i assumed it was better to ensure that missing_token had a corresponding reference in this array and the exceptionCodes, but falling back to invalid_request works the same.\n. this entire foreach block can be replaced with:\n\nphp\n$scopes = array_filter($scopes);\n. Why is the grant type added using a string, instead of a specific class?\n. Personally, I really like when setters return $this; so that setters can be chained:\n$something->setFoo(...)->setBar(...);\nWould this be an acceptable modification?\n. Any reason not to have use DateTime; at the top instead of rooting the namespace here?\n. Is there a strong reason to define the dependencies via the constructor? If not, I would suggest removing the __construct method entirely and using setters for each dependency. It makes dependency injection more flexible and is useful for testing.\n. Couldn't this for loop be replaced by an array_filter?\n. :+1: \n. This is a perfect example of why I think setters are better than constructors... knowing what order these are in the parent class requires additional cognitive load that can be avoided.\n. Wouldn't it be preferable to have the scope delimiter configured at the class level, instead of a method parameter?\n. This was confusing to read the first time around. I would prefer to see the complete DateTime constructed outside:\nphp\n$expiration = (new DateTime)->add($accessTokenTTL);\n$accessToken->setExpiryDateTime($expiration);\n. I don't feel very strongly about this, but I think it would be preferable to avoid static classes whenever possible. This kind of usage prevents the SecureKey class from being overloaded, because it is a non-injected dependency.\n. What if $clientId = ''? Is it valid?\n. What if $username = ''?\n. Is it okay to emit an event and then immediately throw an exception? I haven't used this pattern before and I'm curious how it would be handled...\n. I don't think the (default ...) is necessary here at all, and the current documentation is actually a bit misleading, because it makes it look like the default value is a string \"null\".\n. If the default interface is completely empty, why are other interfaces extending it? I don't think that's a good idea.\n. This is another good example of why setters are preferable to constructor arguments... the default values can be always be created in the constructor without having to check if a value is given:\nphp\nif (empty($this->defaultResponseType)) {\n    $this->defaultResponseType = ...;\n}\nif (empty(...)) { ... }\nOr just avoid that completely and do:\nphp\npublic function getDefaultResponseType()\n{\n    return $this->defaultResponseType ?: new BearerTokenType();\n}\n. I very strongly feel that this is not a good idea. Putting a dependency container inside of an interactor completely violates IoC.\n. Shouldn't auto-generated files be excluded from the repository?\n. That let's us change the algorithm, but what about the implementation? The simple fact is that a static class can't be overloaded.\n. My point is that using is_null is not an appropriate test here. The correct check is to use empty($clientId) or simply !$clientId.\n. Same thing here... checking for null is only one of several possible empty values, none of which are valid.\n. Right, but is the point of the event to be able to skip over the exception, or do the event and the exception have completely different purposes? What would I use the event for?\n. Is $scopes['foo'] = null; a valid definition of the foo scope? If not, then this should be using isset, right?\n. What do you think about creating a league/utils package that has common traits for this kind of thing? For instance:\nphp\ntrait ArrayKeyOrDefault\n{\n    protected function getKeyOrDefault(array $array, $key, $default = null)\n    {\n        return isset($array[$key]) ? $array[$key] : $default;\n    }\n}\nI often find myself writing these same operations over and over.\n. Considering that this package hasn't been updated in a very long time, and the recent report of vulnerabilities in JWT packages, maybe we don't want to depend on this package?\nSadly, there aren't many alternatives that do HS* validations, it might mean forking the package over to League.\n. This isn't exactly what I was suggesting, and I'm not sure it is a good idea... if a class extends Server and defines a default, this will overwrite it. I think you need the check, or you need to define a getter for it, as per my examples.\n. That's not the same thing at all. I don't want to use a static class that does way more than an isset check.\n. I'm suggesting creating a package of traits that do this and other common operations. Fetching a deep array value by string is not one of the things I would want to implement.\nThe given package doesn't link to any build status or code quality or what PSR standards it uses or even contain a license declaration. I'd like to make sure the code is high quality.\n. php\n// ArrayPath\nreturn a::get($identifier, $this->scopes, null)\n// suggested Util package\nreturn $this->getArrayKeyOrDefault($this->scopes, $identifier);\nI greatly prefer the latter for a number of reasons.\nShow me 5 packages that provide traits to implement common array operations. I'd love to know what they are, but every time I go looking I find stuff like ArrayPath that I don't want to use.\n. That's one pattern. I've also seen (and prefer) this pattern:\nphp\nfunction setCollaborator($collab) { ... }\nfunction getCollaborator()\n{\n    if (empty($this->collab)) {\n        throw new RuntimeException('Collaborator must be defined');\n    }\n    return $this->collab;\n}\nThis can even be completed with a trait:\nphp\ntrait EnsureCollaborator\n{\n    protected function getCollaboratorOrFail($collaborator, $errorMessage)\n    {\n        if (empty($collaborator)) {\n            throw new RuntimeException($errorMessage);\n        }\n        return $collaborator;\n    }\n}\nImplements as:\nphp\nreturn $this->getCollaboratorOrFail($this->collab, 'Collaborator is required');\nFollowing this pattern, you end up with much smaller units for testing, and everything becomes very consistent in the internal API.\n. > no real benefit.\nWe obviously have very different definitions of \"benefit\". Used properly, traits are reusable fragments that provide utility to a class without having to repeat the same code over and over, in a much more flexible way than statics.\n. :grinning: awesome, I was not aware they had actually updated the package.\n. Trait can be overloaded, static class cannot.\n. > an error like this would most likely be caught in production\nGood thing this package ships with a complete test suite. ;) Again, there are two parts to this:\n1. Having setters for every collaborator\n2. Choosing to use a constructor\nMy primary goal is that the first be adopted, regardless of the second.\n. > suffer from poor architecture, not the library itself\nThat sounds like an argument in favor of removing the constructor. ;) Kidding aside, I do see your point, and would iterate that there are two separate issues here and one does not preclude the second.\n. :+1: this looks great!\n. @alexbilbie I don't see a strong reason to depend on it if oauth-server is going to continue supporting 5.4, but I'll certainly be using it in my own projects.\n. I am going to contradict my previous opinion and say that setters are the wrong way to go. What we did in oauth2-client was use this signature:\nphp\npublic function __construct(array $options = [], array $collaborators = []) { ... }\nThis is simple and allows for easy customization of the collaborators with dependency injection without having to worry about argument order or setting defaults.\n. I think there is value in understanding the context in which these libraries are used too. While many applications do use auto-resolving injectors, some do not. Having array $options = [], array $collaborators = [] is very slightly less convenient for auto-resolving injectors but much better for using less sophisticated injector or no injector at all.\n. ",
    "jgoux": "Sorry to continue on this issue but I can't find a solution to my issue.\nI want to create a Restful api with Laravel (using https://github.com/dingo/api), so far, so good.\nNow, I want to create the frontend to consume my API with AngularJS, and I don't know which grant to use as a public JS application can't store any secret information. I read your post about this case @alexbilbie , and you talk about setting up a tiny script to proxy all the AJAX request. I like the idea, could you provide an example ? Which grant would you use with this proxy ? The JS app won't store any token ?\nThe JS app will be on the same server as my rest api, but I'll have to consume the rest api with a mobile app in the future.\n. ",
    "maximebeaudoin": ":+1: For no relational database support\n. Sorry for the delay guys, i'm little busy ! I'll take a look at this.. @ragboyjr Not sure if it's a good practice to return the access token as a attribute in the request. However, i think you are right, not having access to the token object after the authorization validation look like the main issue. You can't access token data other then oauth_access_token_id, oauth_client_id, oauth_user_id, oauth_scopes.\nPersonally, i ended parsing the token again with Lcobucci\\JWT\\Parser to extract the custom claim from the token.\n```php\n$token = (new \\Lcobucci\\JWT\\Parser())->parse($jwt);\n$tenantId = $token->getClaim('tenant_id');\n```. @Sephster Agree with you, i think we should find a alternative approach for this. I don't think doing a quick fix will be a good solution. For now, it's not impossible to use custom claim but you have to handle this outside of the package completely and you need to bypass the validation.. ",
    "cretz": "As someone writing a new OAuth implementation right now using this, should I be concerned about the upcoming major version change? How significantly backwards-incompatible is it and how hard will it be to port? I am using my own implementation of the storage interfaces.\n. ",
    "feedmeastraycat": "+1 on the latest comment. Im in the same situation. :)\n. Thanks. Any ETA on 4.0? Will you continue to support and bugfix the 3.x branch?\n. I updated the description because I obviously want to throw an exception (or return an error somehow) on associateAccessToken() when the access token is created/inserted. Not on validateAccessToken().\n. Ok. Thanks. :)\n. ",
    "patkruk": "Hi Alex,\nThanks for all your hard work! Are you able to estimate how soon v4 will be ready?\n. ",
    "reinink": "@philsturgeon @alexbilbie Yes, full instructions can be found here.\n. ",
    "hurrycaner": "Hi guys, where is the 4.0 branch?\n. ",
    "bakura10": "Never mind for the entity comment. I think it makes sense after all. And I can provide mapping through other ways. I'll think a bit more about that today!\n. I've changed all the \"Storage\" interfaces to Services. Actually, this is exactly what they are: services. The name \"storage\" was misleading. This way, each provider can now provide its own service. For instance, we could create a Doctrine wrapper that have service that use Doctrine object repository to do the manipulation. This is much more flexible, and the dependency to SQL is now totally removed and abstracted.\nWhat I don't like, for instance in the ClientServiceInterface, was this:\nphp\nArray\n     * (\n     *     [id]             => (string) The client ID\n     *     [secret]         => (string) The client secret\n     *     [redirect_uri]   => (string) The redirect URI used in this request\n     *     [name]           => (string) The name of the client\n     * )\n     * </code>\nYou expect the service (or storage) to return data formatted in a very specific way. I think to be cleaner we should make those methods return interface. For instance ClientServiceInterface enforce that getClient returns a ClientInterface, which in turns define getId(), getSecret(), getRedirectUri() and getName().\n. Haha sorry about that. When I start refactoring something I change everything :/.\nHaving a \"save\" method on the entities is wrong imho. A service should take the entity and save it. Entity should be completely blind about the persistence and any storage.\nRegarding the storage it's really a service. You are not only saving, but you are performing business logic on the entities, so it's a service.\nUsually, yes, a service will have a dependency to a storage. But that's the nice part of it because it makes your code completely independent. Your users just have to create their own services following the interfaces, by injecting their own persistence storage (either a Doctirne repository, a Zend Db, or anything else).\n. No problem ! I'm closing for now then and wait for you to finish. In the mean time I'll create my own repo with some of my ideas, and let's see later if we can work on unifying the ideas! :)\n. As said you don't need to review it. I created a new repository where I try new ideas :).\nEnvoy\u00e9 de mon iPhone\n\nLe 28 d\u00e9c. 2013 \u00e0 13:52, Marco Pivetta notifications@github.com a \u00e9crit :\nIn data/Client.php.dist:\n\n+namespace League\\OAuth2\\Server\\Entities;\n+\n+class Client\n+{\n-    protected $id = null;\n  +\n-    protected $secret = null;\n  +\n-    protected $name = null;\n  +\n-    protected $redirectUri = null;\n  +\n-    public function setId($id)\n-    {\n-        $this->id = $id;\n-        return $this;\n  You know what to do here, @bakura10\n\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "driesvints": "I've tried setting it at the very beginning of the PHPUnit bootstrap file but I'm still getting the same error.\n. Nvm, it got change to $_SERVER['REQUEST_METHOD'] apparently.\n. ",
    "chrisnharvey": "No probs :)\n. ",
    "derekjkeller": "Hi,\nAny update on the state of the project?  The wiki documentation was marked out of date in december and http://oauth2.thephpleague.com/ is a broken link.\n. ",
    "tpavlek": "So are there still components for v3? I'm pressed for time and need to deliver something, whether that's implementing components myself or (preferably) using the existing concrete classes.\nCan't wait for v4 right now. Any updates?\n. Thank goodness there's progress on this. Just spent an hour tearing out my hair because I thought I wasn't including an auth code, when it was just expired in fact.\nThumbs up alex :+1: \n. ",
    "novaking": "Any progress? If this is no longer a project you are working just say so. would be better than a whole bunch of people waiting for something that may not come for another couple of years.\n. Ahh ok, good to know. Thanks for the update.\n. http://oauth.thephpleague.com/ is giving server not found (Safe to assume this is one of the things you are working on now?)\n. The Wiki will eventually by the site he mentioned in this issue.\n. @M4v3R If i remember the correct the Wiki was for v2, which would not have helped you.\n. Those links were for v2 which no longer apply as v4 is about to come out.\n. ",
    "eclipse1985": "Thanks!\n. One last question, can I upgrade from 2.* to 3.* (using composer) without changes in my code and db structure?\n. I happily use Doctrine2 as ORM in all other parts of my API, so if you can provide Doctrine storage implementation (as a composer package or as you like), it will make me very glad :)\n. thanks :+1: ! Hoping have no problems\n. Sorry guys, evidently I didn't understand something... in 3.0 version changelog I see:\n\"All grants no longer remove old sessions by default\"\nbut when I make a call for a new AuthCode with AuthCode.newAuthoriseRequest() it deletes old user sessions, indeed I still see in the code: \n$this->authServer->getStorage('session')->deleteSession($authParams['client_id'], $type, $typeId);\nI check 4.0 source code, and the situation is the same...\nWhat I didn't understand? How do I handle multiple sessions?\n. Thank you, i will wait :+1: \n. ",
    "yjv": "cool! thanks!\n. @alexbilbie any news on this?\n. ",
    "ChrisZieba": "+1. Even some small examples would be cool.\n. ",
    "azngeek": "+1 I full working example would be okay as well. Is it better to stick on v3 for now?\n. ",
    "jasonlewis": "No that's absolutely fine. My only concern is that if I'm developing an EmberJS application which is a client. I'd need to store it's client credentials within the application itself meaning anyone who can view the source will see those client credentials. In this case I don't there will be any harm done because users will still need a valid username and password to authenticate.\nIs that such a big deal that the client credentials will be publicly visible?\n. True, but only if the client credentials grant was enabled.\nI'm not sure how Google's solution would benefit my situation as I want resource owners to authenticate.\n. Cheers Alex, thanks for the link, and I look forward to the book.\n. AuthCodeInterface is also missing the create method signature.\n. No worries. Just let me know and I can switch it over and send a PR. :smile:\n. Roger.\n. Just came across a few other things.\n1. It seems as those the session saves the redirect URI and then never uses it. The problem is, when you get a session from storage there's no way to set the redirect URI on the SessionEntity as it's resolved through the sessions associated client. So really it seems as though saving it in the first place is pointless?\n2. Also the username and password for the password grant have to be sent in the request body. Any chance of also allowing them to be sent as Basic authentication, you can use getUser() and getPassword() on the Symfony request instance to retrieve them.\n3. It also seems the session is saved during AuthCodeGrant::completeFlow which results in a duplicate session and the incorrect session being associated with the access token. The saving process actually creates a brand new session. The only reason for the saving is to associate the authorization code scopes with the session, this could be done during the issuing of the authorization code. At the moment it just associates the scopes with the authorization code.\nphp\n   $authCode->associateScope($scope);\nWhy not associate the scopes with the session there as well?\n. Awesome, cheers Alex. Just about finished my testing and aside from these things it all seems to be good. :smile:\n. This should actually be already possible. I'm working on a Redis adapter for 4.0 and I know that it's possible to store many different client redirection endpoints. Usually this is so clients can register a redirection endpoint for a development environment or something.\nWhen a client is authorizing with the server a redirection endpoint must be sent along (usually as redirect_uri in the query string) so that the client can be correctly validated. When authorizing with the authorization_code grant the same redirection endpoint must be sent when retrieving an authorization code and when swapping said code for an access token.\n. Yeah I can do it myself... Was just wondering if you were going to change the default behaviour of hasScope, that's all.\n. It's totally fine if you're not. :smile:\n. ",
    "rtablada": "Just a quick thought on this. Rather than to create custom grant types that mimics everything in the existing password grant, what would be the issue with making a param on the Password class requireClientSecret and then line 96 becomes if ($this->requireClientSecret && is_null($authParams['client_secret'])).\nThis allows compliant password grants where client secret is not required to output a bearer token.\nSince the default for requireClientSecret would be set to true, current functionality would remain, while the increasing number of JS app developers wouldn't have to roll their own password grant type just to get around this.\nNow it still does require client_id due to the way it looks like user and token storage is interfaced out, which will irk some front-end devs (IMO it's relatively easy to either send the client_id or inject it).\n. ",
    "Danack": "Hi Alex,\nApologies for opening this issue again, however I'm pretty sure how this library has implemented the password_grant type is not correct, and is making the easy path be to inadvertently expose the client_secret.\nI'm trying to use the library to allow a webpage app to authenticate users. Section 2.1 describes the types of client https://tools.ietf.org/html/rfc6749#section-2.1 :\n\nOAuth defines two client types, based on their ability to\n   authenticate securely with the authorization server (i.e., ability to\n   maintain the confidentiality of their client credentials):\nconfidential\n      Clients capable of maintaining the confidentiality of their\n      credentials (e.g., client implemented on a secure server with\n      restricted access to the client credentials), or capable of secure\n      client authentication using other means.\npublic\n      Clients incapable of maintaining the confidentiality of their\n      credentials (e.g., clients executing on the device used by the\n      resource owner, such as an installed native application or a web\n      browser-based application), and incapable of secure client\n      authentication via any other means.\n\nAs it is a webpage app, it is not possible for it to maintain the confidentiality of their credentials, and so should be considered a public app.\nAlso from section 2.1, although I might also want to use the Oauth library in a 'confidential' way elsewhere, those should be considered separate components.\n\nA client may be implemented as a distributed set of components, each\n   with a different client type and security context (e.g., a\n   distributed client with both a confidential server-based component\n   and a public browser-based component).  If the authorization server\n   does not provide support for such clients or does not provide\n   guidance with regard to their registration, the client SHOULD\n   register each component as a separate client.\n\nThose two pieces of information affect the meaning of  https://tools.ietf.org/html/rfc6749#section-4.3.2\n\nIf the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\nThe webpage client is not confidential (it is public) and any secure client should have registered any secure component as a separate client. \ntl:dr the password_grant type shouldn't need the client_secret to authenticate for webpage applications.\nAlthough copy+pasta+modifying the PasswordGrant type, and registering it as a custom type is trivial, that really ought to be mentioned on the password grant page\nI've opened a PR to modify the text on that page, but also I think PasswordGrantWithoutClientSecret should probably be something this library offers out of the box.\n. ",
    "noizu": "It is a flaw in that you assume any authentication header is a bearer token and not mac, or basic with out validating this is the case. There are going to be multiple people who use other authentication schemes under certain scenarios so it makes sense to verify the header is,  Authentication: Bearer \nand assume it is not the  access token if not. Which implies failing over to secondary forms of providing tokens such as the access_token x-form encoded or url provided. \n. Sweet. I'm using this library to handle oauth on greatnonprofits.org's bidirectional api and will likely use it on some of my internal projects as well so I'm happy to contribute some of my personal dev time. I need to get around to reading the entire oauth spec and glancing over the codebase though before I start making pull requests. \n. ",
    "smcjones": "Hello, my project could sorely use this token type prior to going live. Is this something imminent? I am happy to contribute to this feature if it would be helpful.\n. Similarly, I am interested in defense in depth. An OAuth1.0 style verification would be very helpful in case TLS fails in preventing MITM attacks.\n. ",
    "bajb": "We are developing a business platform to transmit a lot of sensitive data between frontends and third party systems. Personally I wouldnt feel comfortable without verifying each message, rather than just the session, although very unlikely to be compromised, still is possible.\n. Sweet, looking forward to using it :)\n. Sorry about that one.\n. You could define a new interface which covers the methods required/available in AbstractGrant, and verify that grants implement that interface within the method before using the methods.\nMethods such as $grantType->getIdentifier() I would expect to be a requirement on the grantType looking at its usage throughout the code, or failing over to use get_class($grantType).  Otherwise checking the AuthServer for that grant type, you would have no way to call hasGrantType(), and issueAccessToken would also fall over.\n. ",
    "nueko": "great to know that, have you implement that?\n. Suggest: method name following the HTTP verb..\nget(), post(), request(), password(), user(), etc\n. Sorry for that, just looking a way to use this lib with a framework that doesn't support the PSR7.\nI have problem with the psr7 Response. have you any idea to use this without PSR7 response?\n. I use Zend for Request, and Phalcon For Response\n. as i told, phalcon doesn't support psr7. but thanks\n. Phalcon\n. ",
    "samad-aghaei": "Error-\nMySQL said: \n1215 - Cannot add foreign key constraint\n. ",
    "jimekevin": "Here's the correct order for quick copy & paste: \n```\nDump of table oauth_clients\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_clients (\n  id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  secret varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  name varchar(255) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  UNIQUE KEY oauth_clients_id_secret_unique (id,secret)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_sessions\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_sessions (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  client_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  owner_type enum('client','user') COLLATE utf8_unicode_ci NOT NULL DEFAULT 'user',\n  owner_id varchar(255) COLLATE utf8_unicode_ci NOT NULL,\n  client_redirect_uri varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  KEY oauth_sessions_client_id_owner_type_owner_id_index (client_id,owner_type,owner_id),\n  CONSTRAINT oauth_sessions_client_id_foreign FOREIGN KEY (client_id) REFERENCES oauth_clients (id) ON DELETE CASCADE ON UPDATE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_access_tokens\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_access_tokens (\n  id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  session_id int(10) unsigned NOT NULL,\n  expire_time int(11) NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  UNIQUE KEY oauth_access_tokens_id_session_id_unique (id,session_id),\n  KEY oauth_access_tokens_session_id_index (session_id),\n  CONSTRAINT oauth_access_tokens_session_id_foreign FOREIGN KEY (session_id) REFERENCES oauth_sessions (id) ON DELETE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_scopes\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_scopes (\n  id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  description varchar(255) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_session_scopes\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_session_scopes (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  session_id int(10) unsigned NOT NULL,\n  scope_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  KEY oauth_session_scopes_session_id_index (session_id),\n  KEY oauth_session_scopes_scope_id_index (scope_id),\n  CONSTRAINT oauth_session_scopes_scope_id_foreign FOREIGN KEY (scope_id) REFERENCES oauth_scopes (id) ON DELETE CASCADE,\n  CONSTRAINT oauth_session_scopes_session_id_foreign FOREIGN KEY (session_id) REFERENCES oauth_sessions (id) ON DELETE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_access_token_scopes\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_access_token_scopes (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  access_token_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  scope_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  KEY oauth_access_token_scopes_access_token_id_index (access_token_id),\n  KEY oauth_access_token_scopes_scope_id_index (scope_id),\n  CONSTRAINT oauth_access_token_scopes_scope_id_foreign FOREIGN KEY (scope_id) REFERENCES oauth_scopes (id) ON DELETE CASCADE,\n  CONSTRAINT oauth_access_token_scopes_access_token_id_foreign FOREIGN KEY (access_token_id) REFERENCES oauth_access_tokens (id) ON DELETE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_auth_codes\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_auth_codes (\n  id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  session_id int(10) unsigned NOT NULL,\n  expire_time int(11) NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  KEY oauth_auth_codes_session_id_index (session_id),\n  CONSTRAINT oauth_auth_codes_session_id_foreign FOREIGN KEY (session_id) REFERENCES oauth_sessions (id) ON DELETE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_auth_code_scopes\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_auth_code_scopes (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  auth_code_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  scope_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  KEY oauth_auth_code_scopes_auth_code_id_index (auth_code_id),\n  KEY oauth_auth_code_scopes_scope_id_index (scope_id),\n  CONSTRAINT oauth_auth_code_scopes_scope_id_foreign FOREIGN KEY (scope_id) REFERENCES oauth_scopes (id) ON DELETE CASCADE,\n  CONSTRAINT oauth_auth_code_scopes_auth_code_id_foreign FOREIGN KEY (auth_code_id) REFERENCES oauth_auth_codes (id) ON DELETE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_refresh_tokens\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_refresh_tokens (\n  id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  access_token_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  expire_time int(11) NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (access_token_id),\n  UNIQUE KEY oauth_refresh_tokens_id_unique (id),\n  CONSTRAINT oauth_refresh_tokens_access_token_id_foreign FOREIGN KEY (access_token_id) REFERENCES oauth_access_tokens (id) ON DELETE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_refresh_token_scopes\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_refresh_token_scopes (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  refresh_token_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  scope_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  KEY oauth_refresh_token_scopes_refresh_token_id_index (refresh_token_id),\n  KEY oauth_refresh_token_scopes_scope_id_index (scope_id),\n  CONSTRAINT oauth_refresh_token_scopes_scope_id_foreign FOREIGN KEY (scope_id) REFERENCES oauth_scopes (id) ON DELETE CASCADE,\n  CONSTRAINT oauth_refresh_token_scopes_refresh_token_id_foreign FOREIGN KEY (refresh_token_id) REFERENCES oauth_refresh_tokens (id) ON DELETE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_client_scopes\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_client_scopes (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  client_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  scope_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  KEY oauth_client_scopes_client_id_index (client_id),\n  KEY oauth_client_scopes_scope_id_index (scope_id),\n  CONSTRAINT oauth_client_scopes_scope_id_foreign FOREIGN KEY (scope_id) REFERENCES oauth_scopes (id) ON DELETE CASCADE,\n  CONSTRAINT oauth_client_scopes_client_id_foreign FOREIGN KEY (client_id) REFERENCES oauth_clients (id) ON DELETE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_client_endpoints\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_client_endpoints (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  client_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  redirect_uri varchar(255) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  UNIQUE KEY oauth_client_endpoints_client_id_redirect_uri_unique (client_id,redirect_uri),\n  CONSTRAINT oauth_client_endpoints_client_id_foreign FOREIGN KEY (client_id) REFERENCES oauth_clients (id) ON DELETE CASCADE ON UPDATE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_grants\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_grants (\n  id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_grant_scopes\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_grant_scopes (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  grant_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  scope_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  KEY oauth_grant_scopes_grant_id_index (grant_id),\n  KEY oauth_grant_scopes_scope_id_index (scope_id),\n  CONSTRAINT oauth_grant_scopes_scope_id_foreign FOREIGN KEY (scope_id) REFERENCES oauth_scopes (id) ON DELETE CASCADE,\n  CONSTRAINT oauth_grant_scopes_grant_id_foreign FOREIGN KEY (grant_id) REFERENCES oauth_grants (id) ON DELETE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\nDump of table oauth_client_grants\n------------------------------------------------------------\nCREATE TABLE IF NOT EXISTS oauth_client_grants (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  client_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  grant_id varchar(40) COLLATE utf8_unicode_ci NOT NULL,\n  created_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  updated_at timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',\n  PRIMARY KEY (id),\n  KEY oauth_client_grants_client_id_index (client_id),\n  KEY oauth_client_grants_grant_id_index (grant_id),\n  CONSTRAINT oauth_client_grants_grant_id_foreign FOREIGN KEY (grant_id) REFERENCES oauth_grants (id) ON DELETE CASCADE ON UPDATE NO ACTION,\n  CONSTRAINT oauth_client_grants_client_id_foreign FOREIGN KEY (client_id) REFERENCES oauth_clients (id) ON DELETE CASCADE ON UPDATE NO ACTION\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n```\n. ",
    "TiMESPLiNTER": "The table users seems to be missing in this scheme to make it working for the example code under examples/relational/.\n. ",
    "mdwheele": "The ClientInterface presumes that a client already exists in a data store through some external means.  This hints to me that it is the responsibility of code outside the scope of the package to model the full representation of a client.\nIf that's the intended presumption, there is no need to make change because we're stating that a \"ClientEntity\" is a partial representation of a real-world Client Application and for the purposes of granting it an access token to protected resources, we only need the one redirect URI for retrieval.\nIt'd just help me to get clarity on that point as it has effects on the work you and I discussed the other day.\n. Essentially, what I'm reasoning about is that within the context of a developer managing a set of client applications with a centralized authorization service; the client application is itself a protected resource of the developer who is authenticated to a web interface that is making requests on his/her behalf to those resources on the authorization server.  [Enter chicken and egg]\nThe \"ClientApplication\" within the above context is seemingly separate from the intended functionality behind \"ClientEntity\" represented by this package.  ClientEntity seems to be a simple data-transfer object or \"view model\" of that more supple ClientApplication.\nI just want to make sure I'm interpreting that correctly.  Because if that's so, it actually releases me to stop \"thinking I'm doing it wrong\" because (at that point) I'm dealing with two TRULY separated contexts of operation.  In that scenario, the package would only be used to facilitate authorization framework concerns and an anti-corruption layer would be established between my \"protected resource management\" context and this package.\n. Hrm...  I'm not explaining what I'm saying clearly; I don't think.  That's my fault.  I do understand that it is possible to store multiple redirect_uris in a client redirect URIs table joined to a clients table and that the library will support it for the purposes of initiating and completing an authorization flow.  However, this relationship is not explicitly defined by the domain model (entity) of \"ClientEntity\" and that's okay assuming my expectation of \"ClientEntity\"'s responsibilities are bounded to the context of an authorization flow (meaning it would only ever need to represent a single redirect URI during the flow because only one is ever provided).  The storage implementation for Clients does not specify a contract for the creation and management of Clients (and never has).  This hints to me that Client management is outside the scope of this package and that's okay too.  I'm just trying to keep a clear boundary of what the package will ever be (or not be) responsible for.\nAn example scenario:\nAn organization hosts a central authorization service backed by a federated identity provider.  Many distributed developers are building resource services that serve as relying parties on this central auth. service.  When a developer creates a client, there are a few interested parties that would like to receive notification of that event.  For compliance reasons, every client creation, credential reset, and redirect URI registry update must be logged.  Given that there is a web interface for managing a list of clients for a specific developer, when a client is created, an event representing that creation should be dispatched to interested parties.  When a developer views a list of clients and opens one for modification, then the developer should see a list of all redirect URIs registered to that client.\nIn this scenario, a client is itself a protected resource of the authorization service.  It is a protected resource of the developer.  The current ClientEntity cannot perform this responsibility completely and it may not be meant to.  If that's the case, I can continue by treating this package as an upstream bounded context and would simply wrap it in a set of services that integrate with the rest of the application.\nWhat I'm suggesting may be too much to move on right now, but I'm really interested in hearing long-term vision for the package.  I regard 4.0 as a great step towards RDBMS independence, but it's clear that as far as the entities go, we're one step beyond putting everything into an array and passing it around.  Your explanation of that point will have effects on how much I bother trying to force the package to do something it's not meant to!\nThanks again; I hope that was clearer as to what I'm getting at.\n. To clarify another point:  this isn't 100% about whether or not the ClientEntity stores an array of redirect URIs vs a single.  This would have other implications on the whole package which is what causes me to hesitate and request clarity of responsibility and purpose.\n. My title for this issue is probably bad at this point.  I've linked a previous discussion outlining more of my thoughts. \n. Definitely!  I appreciate it.  As an aside, is there anywhere particular you'd like some extra help getting things done?\n. Fine to close! Thanks for the insight.\nOn May 13, 2014, at 5:42 AM, Alex Bilbie notifications@github.com wrote:\nCan I close this or is there still an open issue?\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/thephpleague/oauth2-server/issues/168#issuecomment-42935699\n.\n. No problem at all.  Don't feel like you have to over-commit!  I know you're busy. \n. ",
    "freezy-sk": "yes i know it's for older version of library but you made recently small fixes too ;)\nit's just a small change to support node.js lowercased headers in lucadegasperi/oauth2-server-laravel because rewrite of lucadegasperi/oauth2-server-laravel to support your oauth2-server 3.2 with outdated documentation is quite hard\n. thank you\n. ",
    "stevenwadejr": "Hey, that's cool man. I've been sitting on this script for 2 1/2 months. I needed it for a project I'm working on and just never got around to contributing. Sorry if it could have been useful 2 months ago.\nThanks for the great product anyways, maybe next time.\n. ",
    "stephenfrank": "Okay. Glad to see that I hadn't completely missed the point here.\n. ",
    "brianherbert": "Any movement on this?\n. ",
    "kamov": "Questions about that documentation:\n\n$db = new League\\OAuth2\\Server\\Storage\\PDO\\Db('mysql://user:pass@localhost/oauth');\n\nSince I have my PDO connection already setup on my application, can I just use this?\n. ",
    "M4v3R": "@alexbilbie I've just tried to access the Wiki on Github, but it doesn't seem to work (always redirects me to project page). Am I missing something?\n. @novaking That's a bummer, because I just wanted to start using v3 and can't get into the documentation.\n. ",
    "alnorth": "I went to the documentation assuming that it was for the current version. It's fine to list it when it's the dev version, but it would be useful if you could make this a little clearer. In particular the instructions for installation don't work as it should be 4.0.*@dev rather than 4.*.\n. Great, thanks.\nOn Wed, Sep 17, 2014 at 5:35 PM, Alex Bilbie notifications@github.com\nwrote:\n\nI've updated this in the docs\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/193#issuecomment-55921811\n. \n",
    "mikehaertl": "Not sure, if this should go to its own issue: Could the documentation maybe expound a little more on the storages? I.e. \n\nLeague\\OAuth2\\Server\\Storage\\SessionInterface - contains methods for retrieving and setting sessions\n\nWhat exactly is a \"session\" in this context? I think it therefore would be very useful to describe all required DB tables and their columns. Including, which of them are meant to be popuplated/managed by the developer, and which of them are used to keep transient data of this library (and thus should not be touched at all).\n. ",
    "zzal": "There's no implementation code example for \u00abAuthorization server with refresh token grant\u00bb.\nWhen the Access Token expires, how do we use the Refresh Token to require a new one?\n. > When the refresh token grant is enabled, a refresh token will automatically be created \n\nwith access tokens issued requested using the authorization code or resource owner password \ncredentials grants.\n\nSo the Access Token is re-issued automatically when Refresh Token is present?\nIf this is the case, it's no working for me\u2026 I must be missing something.\n. Yes I understand that: I have set a Password grant type along with a Refresh Token grant. I do receive a Refresh token with my Access Token.\nThe question remains: how do I use the Refresh Token to get a new Access Token? (which is sent along my Access Token in each and every request I do).\n. Ok, thanks! Now I understand\u2026\nSorry for the inconvenient and thanks for your time. :)\n. ",
    "nazan": "Yep, I hav the same problem as @zzal \nrefreshed access token does not get the same scope as original access token.\n. Care to shed some light on this issue? Anyone? In case my question is not understood.. Basically here is the problem:\n- I want to use refresh_token grant type.\n- I have already set everything up and I'm even getting a refreshed accessed token.\n- But the problem is the refreshed access token does not get the same scopes as the original access token.\nExample:\nSuppose access token A has scopes 'abc,xyz,def'. When access token A expires I'm using refresh token grant mechanism to get a refreshed access token B. However access token B does not have scope 'abc,xyz,def'. In fact access token B does not have any scope at all.\n. I get this problem in version 4.0.*\nOn Mon, Mar 2, 2015 at 9:59 PM, Norbert Fuksz notifications@github.com\nwrote:\n\nI can confirm this bug. Just ran into it myself.\nHas this been fixed? The 4.0.0 milestone seems to have come and gone.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/297#issuecomment-76751017\n.\n. \n",
    "ashleydw": "Under the relational example, it'd also be nice to have some documentation on the expected table structure.\n. I'm wondering if you have WIP for this? I'd like to remove the session concept too.\n. ",
    "peteclark3": "I ended up here following links related to more Storage implementations.  Yet I don't see it on the todo list.  Is this still a todo?\n. ",
    "barryvdh": "Or since https://github.com/thephpleague/oauth2-server/commit/7e4317cf546cb3de8fa9a5c694b6951c78fc5225 you could use 4.*@dev\n. ",
    "adamski": "ok, is there anywhere we can look at example code in the meantime? \nthanks\n. ",
    "zerkms": "Why to tie with frameworks when it's an independent library?\n. @hannesvdvreken why to tie with anything?\nI've taken it and without any problems used in symfony. If one needs integration with something - why not make it a separate project, that refers to this library as a dependency?\n. So why put everything into one repository/project?\nDoesn't splitting it into different projects each one with its own particular responsibility make it better design?\n. @hannesvdvreken the question was: why to add it to the library? Why not create a separate project that provides integration?\nComposition, you know.\n. @hannesvdvreken the question is still: why a library need to know about environment it will be used in? Why not just leave a library to be a pure library.\nAnd any integration, even as simple or as trivial as another dependency (but still biased and opinionated) to be another project?\n. It violates SRP.\nBut hey, it's your project, design it as you wish.\n. > just a dev dependency.\nDev dependencies are not installed by default (or at all) when a library is a dependency itself. I cannot see how it can be a pure dev dependency :-)\n. @alexbilbie middleware is integration. Why not have it separately?\nOAuth library provides the protocol implementation, why spoil it with information about the environment it will be hosted in?\nEspecially keeping in mind that StackPHP is not an industry standard and not everyone follows them.\n. @hannesvdvreken it will not be a dev dependency. It will be a middleware (in terms of StackPHP) implementation.\nSo a class that has nothing to do with the library (and OAuth2 protocol) directly, just a glue layer with a specific \"architecture\" \n. @alexbilbie simple example: https://github.com/thecodingmachine/silex-middleware\nSo they implemented a middleware for silex outside of silex, not as a part of it.\n. White begins and wins!\nSorry for being nasty and/or annoying, I wish the project the best design :-)\n. Oh, okay, sorry.\n. @alexbilbie and JWT library would be my next question - I understand it is probably too late, but what do you think about design that allows to optionally opt-in into using JWT?\nWe are using persistence storage for managing tokens so having extra requirement of pub/private keys to manage is just an extra work to do.\n. Good, thanks :-)\n. I see, technically the auth code storage might be a dummy without real persistence.\n. @alexbilbie well, that's what I thought initially, but there is no contract that guarantees consistency of the token between multiple setIdentifier's calls.\n. This might work and my initial implementation was identical to that, but then I thought that explicit is better.\nBy that I mean: what if some crazy implementation resets all the fields set in case when you invoke setIdentifier for the second time. Like: it is another identifier, so the identity of this entity has changed so the other fields must be reset. (and yes, I understand it is even less likely than 40 byte random value to duplicate) :-)\n. Sure, I'll change it to the proposed one, since mine is a bit paranoid and less readable.\n. Done.\nBtw, as you noticed I've put my tests into the ImplicitGrant test suite, since it has the smallest bootstrap overhead compared to others.\nIdeally every grant should be covered, since it's a detail of their behaviour, but those would be literally copy-paste.\n. I will definitely have a look slightly later, for me it's friday evening just started \ud83d\udc31\n. I've added the issue* methods modifications and will commit tests later today (and will squash all the commits together)\n. So the all code squashed and pushed. I have concerns about bloated tests, but I don't have any solution for that at the moment (apart of using dirty reflection tricks, which I personally would avoid).\n. It's funny - I could get a race condition on travis :-D The changeset id on this page and the changeset id checked against do not match.\n. @alexbilbie if there is nothing we need/can improve at the moment, may be we could merge it then? :-)\n. > that it's a backwards compatible change but otherwise\nIt depends on what you want to be BC. I believe tokens definitely will not be BC, so the support for old ones need to be kept for some time (until next major release since people may have emitted tokens with TTL of few years).\n. > Access tokens shouldn't be affected only authorization codes and refresh tokens as they are both encrypted.\nthey will be - if you switch from using openssl_* functions directly to using that library - the generated tokens will be different (the latter at least adds MAC).\nSo decrypt should be mantained for both implementations (since the decryption would definitely be incompatible), and encrypt might be simply swapped.\nAs of API - it can be implemented in a compatible way. I personally would prefer an implementation though that accepts keys either as strings or objects, but definitely not file paths.\n. Oh right. So, then it should be an easy improvement.\n. @fgambino what is the purpose of the version?\n. Oh, I did not know it's on github pages - I would have sent a PR then :-). ",
    "hannesvdvreken": "StackPHP is not a framework. It's a framework interoperability tool.\n. Yeah, but people like libraries with utility classes that they can just use to tie it in their application in no time.\n. It's better to add a stackphp middleware than to add framework specific classes for every single framework.\n. StackPHP will only be a dev dependency.\n. I would agree with you if it would be symfony or zend specific classes, but StackPHP is meant to be used in any application. So it's optional but also an invitation to use good app design.\nThis will be my last response, sorry, as I don't have more time to discuss. Have a nice day.\n. I just noticed this is a 7 month old issue. Don't worry about it, it probably will not be executed any time soon ;-)\n. As I said: just a dev dependency.\n. @kfuchs You can use AuthorizationServer::setRequest(Request $request) to inject your own (populated) version of the Symfony request.\n. Fix the indentation please.\n. ",
    "pvormittag": "2.1.3\n. Ok, I'll give updating a try first. Thanks for the quick feedback!\n. ",
    "GrahamCampbell": "Sorry, yeh.\n. Yeh.\n. Awesome. :)\n. Ok, so most of these changes were by php-cs-fixer (1.0-dev), but I went around afterwards and made a few fixes.\nConfig:\n```\n<?php\nreturn Symfony\\CS\\Config\\Config::create()\n    ->fixers(['-yoda_conditions', 'multiline_spaces_before_semicolon', 'ordered_use', 'short_array_syntax'])\n    ->finder(Symfony\\CS\\Finder\\DefaultFinder::create()->in(\"C:\\Users\\Graham\\Documents\\GitHub\\oauth2-server\"));\n```\nI actually have it setup to automatically run on the factory muffin repo:\nhttps://github.com/thephpleague/factory-muffin/blob/2c9ed6e9dcdbef1f16901ba901d80062c8faafd7/.php_cs\nhttps://github.com/thephpleague/factory-muffin/blob/2c9ed6e9dcdbef1f16901ba901d80062c8faafd7/.travis.yml\nhttps://github.com/thephpleague/factory-muffin/blob/2c9ed6e9dcdbef1f16901ba901d80062c8faafd7/composer.json\n. I can send a pull to enable it on this repo if you want?\n. :+1:\n. Awesome.\n. Would it be better to require \"2.4.*\"?\n. ",
    "otherjohn": "Would you be willing to share a Gist of it. I might be able to use that and https://github.com/bshaffer/oauth2-server-php to hack it together.\nBWT, great code!\n. I only see as high as version 3.2.4, where is version 4?\n. ",
    "patrickheeney": "Is there anything we can do to help with the JWT implementation?\n. ",
    "bernier": "+1\nI just was testing things and this actually works when updating PasswordGrant.php line 165\ntry {\n        // attempt to verify the credentials and create a token for the user\n        if(!$jwt_token = JWTAuth::attempt(array('email' => $username, 'password' => $password))) {\n            throw new Exception\\InvalidRequestException('invalid_credentials');\n        } else {\n            $this->server->getTokenType()->setParam('access_token', $jwt_token);\n        }\n    } catch (JWTException $e) {\n        // something went wrong whilst attempting to encode the token\n        throw new Exception\\InvalidRequestException('could_not_create_token');\n    }\nI'm aware there's a lot more to do.\n. ",
    "pulkitjalan": "ok, thanks\n. ",
    "lukasoppermann": "Any news on this issue?\n. Hmm, this is of course a valid reason as well. I was coming from the other side. If I create a token and the server returns it, than I save it to the database, there will be some time passing between my timestamp and the servers timestamp, so in the end, there will be a timespan where my code thinks the token is valid, but actually it is not valid.\n. Hmm, maybe that is enough. I guess this could be done. Thanks anyway.\n. ",
    "rcrowe": "Massively in-need of this for a project. Keen to understand why this was removed.\n. ",
    "ArthurGuy": "I am trying to match the facebook api for convenience and they offer this endpoint through a GET request, I guess this is another one of those situations when they do things differently.\nThanks\n. Can you tag a release for the fix in this issue?\nThanks\n. ",
    "johanobergman": "Any progress on this?\nI believe the token storage implementations should return the token even if it's expired. Then you could just have a method isExpired() in the AbstractToken and update the rest of the codebase to use that method instead of assuming null was returned for an expired token.\nAm I on the right track?\n. Great job, and thanks for the effort you put into this package!\n. ",
    "trkfabi": "Should this not have been fixed in the v2.x branch so that existing users of lucadegasperi/oauth2-server-laravel can get the solution? \nCurrently working on an API getting burned by this, and not sure how to get around it. \n[btw this is Phil S, I couldnt be arsed to log in under my own account. Hi from Uruguay!]\n. ",
    "leevigraham": "Or\u2026 I could continue to read the code and see that you're explicitly requiring a new ClientEntity which comes with the library.\n. This is already happening in ClientCredentialsGrant: https://github.com/thephpleague/oauth2-server/blob/develop/src/Grant/ClientCredentialsGrant.php#L94\n. jebus that was quick :)\nRegarding security I figured as much.\nI'm building an Angular / Ionic app with login so I guess I'll stick with Resource Owner Password Credentials\n. See #249 \n. @bandb42 Thanks for clearing that up. I did have a look at the RFC but it was 2am so I must have missed it :+1:\n. ",
    "ikben": "I would suggest using \"symfony/http-foundation\": \"~2.5\", which is equivalent to >=2.5,<3.0. Or maybe even >=2.5,<2.7 to only use 2.5 and 2.6. \nI won't throw 2.5 until 2.6 is stable.\n. From RFC 6749 \n\n3.1.2.  Redirection Endpoint\n[..] The authorization server redirects the user-agent to the client's redirection endpoint previously established with the authorization server during the client registration process or when making the authorization request.\n [...]\n3.1.2.2. Registration Requirements\n[...]\n The authorization server MAY allow the client to register multiple\n  redirection endpoints\n [...]\n  Lack of a redirection URI registration requirement can enable an\n   attacker to use the authorization endpoint as an open redirector as\n   described in Section 10.15.\n. I think this is closely related to #153 \n. \n",
    "fkooman": "The CONTRIBUTING.md file still mentions the develop branch.. I just noticed #648.... I'd also recommend using paragonie/constant-time-encoding for constant time Base64 encoding.. ",
    "deiucanta": "Let's say my app is Xmail, it will provide a single place to read all your messages from different accounts.\nFor a user to register into Xmail, I don't want to create another set of credentials for the sake of user experience. If he writes his Gmail address I will login with Gmail, but the app will not consume Gmail API directly. Xmail will only interact with Xmail API and our servers will interact with Gmail API.\nAlso, there are providers which don't support OAuth. For those, I will do a validation on the IMAP protocol and authorise them only if that successful.\nSo we have two cases\n- login > Xmail OAuth > Gmail OAuth > success\n- login > Xmail OAuth > IMAP validation > success\nIf the login is successful, we will use Xmail token to access the API. After you register (login for the first time) you will be able link other email accounts to your Xmail account.\nI think this requires and extra step from the normal OAuth flow.\n. Just a quick specification: my users will not have a Xmail username/password.\nDoes your answer include this fact? I'm not sure how to use those grants without a password.\nOn Nov 10, 2014 6:09 PM, \"Alex Bilbie\" notifications@github.com wrote:\n\nOkay so if it's your own app with your users then you should use the\nfollowing grants:\n- For communicating with the API with the gmail access token or the\n  IMAP details: client_credentials\n- For communicating with the API once you have an Xmail user signed\n  into the app: [resource owner] password grant\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/247#issuecomment-62407161\n.\n. Sorry for the delay :)\n\nWe created a custom grant which has two steps - similar to auth_code\n1. detect - you send the email address and it detects what provider it is using\n2. complete flow - you send the email address, provider type and provider details (for gmail - this will be a token, for imap - this will be a password)\nHope it makes sense.\n. ",
    "netom": "Sorry, I mistakenly thought that a GET request is needed instead of a POST.\n. ",
    "clarkeash": "Thanks for your post and reply :)\n. ",
    "maknz": "I ended up implementing a clone of the password grant but instead of user/password, it takes an OAuth2 code and a service which a closure then validates with Facebook/Google and returns the user. I've also taken the approach Alex wrote about in his OAuth and Single Page JavaScript Web-Apps blog post to proxy OAuth requests which adds the secrets server sides and forwards it on to the auth server, and store refresh tokens as encrypted cookies.\n. I'm also seeing the issue of the duplicate session for the auth code. I'm using the migrations from the Laravel package, but the storage implementations from this repo, and this repo directly rather than the Laravel bridge. I'll have a hunt through and see if I can see why it's happening, but I thought I'd note it here anyway.\n. Alright, I've found where the problem is occuring. Before the session is associated to the access token, its save() method is called at https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L263 which is creating a new session in the database and changing the ID, so when the access token's setSession() method is called, it's setting the new session, and the old one is left without anything attached to it.\nIt doesn't look like the $session->save() call https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L263 needs to happen, since the session itself hasn't changed, so simply removing that should fix the problem?\n. Nice :+1:. I've got a workaround that seems to be fine:\n``` php\n// In the first request, replace the client object with just its primitive identifier\n// so it can be serialised\n$params['client'] = $params['client']->getId();\n// When the user approves/denies the client, turn the ID back into the object\n$params['client'] = $this->authServer->getClientStorage()->get($params['client']);\n```\nA bit tidier than I was anticipating, and seems to work, but yeah maybe something that could be improved in a later version :-).\n. Awesome, and good point about auditing. Just to confirm: my assumptions are correct about an expired refresh token in a session being the flag to clear the whole session?\n. > We copy the scopes to the session as well as the access token because if we request a new access token using the refresh token, the new access token can have the same scopes as the original token or a reduced subset of the scopes.\nThis I did not realise. I thought it would use the scopes associated to the access token to determine that, but I guess it needs to keep track of the very original scopes, so they can be added and remove between refreshes irrespective of what scopes the access token currently has assigned. Sorry guys.\nWe'll need another fix for the duplicate session then? I guess in the save it needs to know whether it's already been persisted (has an ID?) and to not call create again?\n. ",
    "nfeiglin": "In your Angular request, try sending the GET params that you\ncurrently have in the url as key/values in data object rather.\nhttps://docs.angularjs.org/api/ng/service/$http#post\nOn Wed, Nov 26, 2014 at 12:02 AM, arjundas notifications@github.com wrote:\n\nI am Creating RESTful API with AngularJS and Laravel, I implement\nOAuth2-server in laravel and testing it.\ni set grant_type in config file of package :\n'grant_types' => [\n    'password' => [\n        'class' => '\\League\\OAuth2\\Server\\Grant\\PasswordGrant',\n        'callback' => function($username, $password) {\n            return Auth::validate([\n                'email'    => $username,\n                'password' => $password,\n            ]);\n        },\n        'access_token_ttl' => 604800\n    ]\n],\nthen in route.php file :\nRoute::post('oauth/access_token', function() {\n    return Response::json(Authorizer::issueAccessToken());\n});\nAnd in Angular JS :\n$http({\n    url: 'http://url/to/oauth/access_token?grant_type=password&username=johndoe&password=A3ddj3w',\n    method: \"post\",\n    headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n}).then(function(response) {\n    console.log(response);\n}, function(response) {\n    console.log(response);\n});\nwhen i run above angular code it give error : invalid_request [image:\n:+1:]\n{\n    \"error\":\"invalid_request\",\n    \"error_description\":\"The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed. Check the \\\"grant_type\\\" parameter.\"\n}\nPlease tell me where i made a mistake.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/261.\n. \n",
    "arjundas": "I tried that, but not work..\n$http.post(\n    'http://url/to/oauth/access_token',\n    {grant_type : \"password\", username : 'johndoe', password : 'A3ddj3w'}\n);\n. My request headers are like : \nHost: localhost\nAccept: application/json, text/plain, */*\nAccept-Encoding: gzip, deflate\n. Found the solution by small changes in angular js code : \n$http({\n        url: 'http://url/to/oauth/access_token',\n        method: \"post\",\n        data: $.param({client_id:\"1\",client_secret:\"12345\",grant_type : 'password', username : 'johndoe', password : 'A3ddj3w'}),\n        headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n    }).then(function(response) {\n        console.log(response);\n    }, function(response) {\n        console.log(response);\n    });\nJust added $.params in data\n. ",
    "ajaysodhi": "var promise = $http({\n                                    url: 'url/to/oauth/access_token',\n                                    method: \"post\",\n                                    async: true,\n                                    crossDomain: true,\n                                    data: $.param({username : 'UNAME', password : 'PWD', \"grant_type\": \"client_credentials\", \"scope\": \"all\"}),\n                                    headers: {\"authorization\": \"Basic Base64Encodedlogin:pwd_String\", 'Content-Type': 'application/x-www-form-urlencoded'},\n                                }).then(function(response) {\n                                    console.log(response);\n                                    alert(\"response.data.access_token: \" + response.data.access_token); \n                                    return response.data.access_token;\n                                }, function(response) {\n                                    console.log(response);\n                                    return promise;\n                                });\nThis is how I used it.\n. Thanks @arjundas. This really helped me. :100: \n. ",
    "prolio": "Awesome, thanks for the help, and for this package. It's sure made my life easier!\n. ",
    "Hywan": "@alexbilbie Welcome :-).\n. @alexbilbie Apparently yes ;-).\n. @alexbilbie Use them as functional tests also. Can be useful.\n. Mergeable?\n. \\o/\n. ",
    "nedmas": "That's cool, thanks.\nAnd cheers for the info on the status code. Still getting my head round when to use which one :-)\n. ",
    "inverse": "Overlaps with #269 - Totally overlooked this PR before :/\n. ",
    "jonnnnyw": "+1 for this. The scope entities in the auth params are also an issue.\nA workaround is to extend your entity classes and implement the Serializable interface:\n```\nuse League\\OAuth2\\Server\\Entity\\ClientEntity as BaseClient;\nclass Client extends BaseClient implements Serializable {\npublic function serialize()\n{\n    return serialize(array(\n        $this->id,\n        $this->name\n    ));\n}\n\npublic function unserialize($serialized)\n{\n    list (\n        $this->id,\n        $this->name\n    ) = unserialize($serialized);\n}\n\n}\n```\nThen return the extended entities from the client storage. This allows the objects to be serialized/unserialized in the session.\nThis could be incorporated into your entity classes.\nAnother solution would be to pass back the client and scope ids as strings in checkAuthorizeParams and handle instantiation on the entities in the grant class.\n. ",
    "alessione78": "As far I could read in the specs, OpenId Connect is built on OAuth2 but it\nuses \"authcode\" grant type.\nhttp://openid.net/connect/\nRegards\n2014-12-09 12:44 GMT+01:00 Alex Bilbie notifications@github.com:\n\nOpenID Connect would be another grant type\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/pull/274#issuecomment-66270805\n.\n. \n",
    "sarciszewski": "Sure.\nhttp://codahale.com/a-lesson-in-timing-attacks/\nhttps://cryptocoding.net/index.php/Coding_rules#Compare_secret_strings_in_constant_time\n. Forgot one: http://blog.ircmaxell.com/2014/11/its-all-about-time.html @ircmaxell explains them really well :)\n. Yeah, that's why in the first comment I wrote:\n\nI've been looking through the code (including the examples), but I cannot see anywhere where the tokens are explicitly being validated. It appears from the examples that they are being stored in a DB and relying on the RDBMS's implementations of WHERE column = value to select tokens.\n\nBased on the information you've offered, I can reasonably conclude that this library does not mitigate the timing attacks, but also does not contain the traditional offending vulnerable code snippet.\nThe most likely place that this could be exploited is:\nhttps://github.com/thephpleague/oauth2-server/blob/master/examples/relational/Storage/AuthCodeStorage.php#L19\nAs far as mitigation goes, the only efficient strategy is to have two pieces for the API: one identifier and one access token (public/private keys in reCAPTCHA lingo, or usernames/passwords). This way you can select the one acceptable API secret from the DB then compare that in constant time.\nThis might be something to consider when you implement the MAC authentication (#158). Timing attacks aren't trivial to exploit (and they require generating a lot of traffic to boot), so the question of whether it would be worth it to rewrite a significant amount of code (not to mention re-design how several classes work in a non-BC way) for a side-channel that only nation states and uber-l33t hackers would really have the resources to exploit successfully is up to you to answer.\nYou're probably fine writing it off until/unless RBDMS begin to offer a crypto_secret storage type that always compares strings in constant time during lookups. :)\n. ",
    "filerun": "The fix is good but incomplete, the save() call was used to associate the auth code scopes to the session. See: https://github.com/thephpleague/oauth2-server/issues/299#issuecomment-70008297 for the required change for fixing this.\n. Sorry, I should have been a bit more clear about the tokens repeating themselves. They are unique, it's just that the long random strings are being used directly, instead of a small integer to reference them across tables. In an environment with many users, many third-party apps, the database can get quite big.\n\nit's irresponsible to be trying to do security related activities with an out of date version of PHP which itself doesn't have security fixes anymore. <\n\nBased on this logic you should develop only for PHP 5.6 and when 5.7 is out, instantly drop any backwards compatibility.\nUnfortunately it needs to be done for business and practical reasons and it's a pity that exceptional developers fail to understand the need. This is because developers are still focused on creating code instead of creating products.\nAs a perfect analogy, 18% of all computers on this planet still run Windows XP. It is an out of date operating system which doesn't have security fixes anymore. From the development perspective, it's easy to dump support for them - it takes less work. But from a business and user perspective it is just not smart to ignore so many people and potential customers.\n. I see, thank you very much for the explanation! There's something wrong with my implementation, as I don't get the scopes copied over.\nPS. Couldn't the access token keep track also of the user and client, instead of the session? It seems a bit redundant, as both the session and the access token have the same scopes.\n. I think there's a bug in the code. Because the session scopes never get saved in the auth code grant flow. The session is saved inside newAuthorizeRequest, but when the flow is completed, the scope is assigned (only to the object) and not saved. I see the function call has been removed recently, to prevent duplicate sessions, but this also discards saving the scopes.\n. The save() method never gets called on the session entity.\n. I fixed it by replacing this line https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L240\nwith this:\njavascript\n$this->server->getSessionStorage()->associateScope($session, $authCodeScope);\n. So I am guessing by the lack of replies that nobody that is using this class is providing the end user any kind of user interface for revoking the authorizations.\n. No pressure on you Alex. I was thinking other developers might also follow the discussions here and I was hoping for another opinion on the matter.\n. After some playing with Google's \"OAuth 2.0 Playground\" I am answering the question myself :) I was mistaken, Google does not provide the same access token, but different ones, it just doesn't show them separately in the list of authorized apps. I guess that's what I will be doing as well: even though there are multiple tokens with different scopes, I will only show \"the app\" as connected and revoking the access will remove all found tokens.\n. +1 on this, an error description will help a lot\n. ",
    "JHKennedy4": "The examples shown still rely on the HttpFoundation Request objects, Slim uses a different Request object. Is the library compatible with Slim as is or do we need to wrap the Request object for compatibility? It's also unclear whether this can be implemented as shown in the examples or needs to be implemented as middleware.\nHappy to contribute back documentation on the solution, just need some pointers in the right direction. Thanks!\n. I used composer require league/oauth2-server\ncomposer.json looks like this:\n{\n    \"require-dev\": {\n        \"10up/wp_mock\": \"dev-master\",\n        \"phpunit/phpunit\": \"4.3.*\"\n    },\n    \"require\": {\n        \"league/oauth2-server\": \"~4.1\"\n    }\n}\nI've tried using composer dump-autoload a few times to regenerate the autoload files, but no luck thus far. I've got require 'vendor/autoload.php' in wordpress/index.php\n. :facepalm: the include is just in the wrong spot. Still not seeing the League in the namespaces file, but I guess that doesn't work the way I thought it did. Thanks for your help.\n. ",
    "thul": "@philsturgeon, there we go, took a bit of conflict solving. But all commits have been squashed into one commit.\n. @philsturgeon, I think it's fixed now... spent i don't know how long fixing conflicts and trying not to undo all my changes. I hope it's oke now\n. OpenID Connect is the openid scope and a few minor changes, like returning the id_token in the /token endpoint. The changes are minimal, the most changes were so we could use our own (doctrines) entities\n. How is this a \"bad change\"? Some more info might be handy, the Entity implements the Interface just fine. So people can implement their own entities.\n. ",
    "austinkregel": "Yes, I have the demo in the docs set up but when I try to actually authenticate anything it doesn't work. I get the following message \njson\n{\n   \"error\":\"access_denied\",\n   \"message\":\"The resource owner or authorization server denied the request.\"\n}\n. I double, and triple checked everything, as far as code goes, everything appears to be correct. It doesn't look like I am missing anything.\nYou can see an export of my DB here http://kbcomp.co/dump/database\nand you can traverse my code here http://kbcomp.co/dump/relational\n. ",
    "kfuchs": "Lets say I make the following request:\nPOST localhost/oauth/access_token\nContent-Type: application/json\n{\n  \"client_id\": \"client\",\n  \"client_secret\": \"secret\",\n  \"username\": \"testuser\",\n  \"password\": \"password\",\n  \"grant_type\": \"password\",\n  \"scope\": \"user\"\n}\nThe AuthorizationServer->issueAccessToken() method, as well as many other classes in the library look for information within the $request variable of Symfony\\Component\\HttpFoundation\\Request. What I'm wondering is, is there any reason why I shouldn't set the $request.\nAdditional Context:\nIt probably makes more sense if I inform you that I'm using Laravel which when sent a request with Content-Type: application/json creates a new variable in the request called $json which holds the content. I'm guessing the answer is it's up to me/my framework to decide what the $request variable contains just so long as it's a ParamterBag, correct?\n. ",
    "atrauzzi": "@bp1222 FWIW, I've introduced a major refactor to this package: https://github.com/thephpleague/oauth2-server/issues/314\nIt may help when addressing these kinds of issues by slightly tweaking the design.  As part of it, I allow multiple access tokens per refresh token and have removed the concept of \"sessions\".  Although @alexbilbie still has to review it, I'm hoping to get as much input as possible.\n. Just getting started with this library, but I'm still confused by the need for sessions as per this explanation:\n\nAs I said, an access token created with a refresh token might have a subset of the scopes that the original access token. But another access token created later on might require all of the scopes again. You need to store the original set of scopes somewhere.\n\nWhy don't you just store the scopes against the refresh token?  It would be the only basis by which this circumstance arises and would avoid introduction of a term not familiar to the Oauth2 spec.\n. :tada: \n. Quick question: Is develop up to date with things going on in master right now, or has it fallen behind a bit?  I'm just starting a new project and I'd be more than happy to switch to using it so I can make further suggestions.\n. Awesome.  I'm going to try and get familiar with the library and once you've completed some of the more major pending refactors, I'd like to help with code cleanup and any other small improvements that might occur to me.\n. I think @alexbilbie is fairly busy right now so I'm taking it upon myself to refactor this package.  Part of this refactor is going to be to remove the session concept.  It's going to take a bit as I'm cleaning up the injection and coupling in the library.\nTo that end, I think the end result is going to be that authorization tokens, refresh tokens and authorization codes are all going to have a relation to scopes.  I'm just mentioning this here in case someone notices that I've missed something! ;)\n. Oh, woops.  I meant to say \"scopes\", not \"auth codes\".  I corrected the sentence above, it should make more sense now.\nI suspect both of our changes are quite an overhaul, hopefully they're compatible in some way.  The basic gist of it is that I'm making the library able to support any ORM and as I mentioned already, reworking the dependencies.\nI've got base entity interfaces, I've converted your actual Entity classes into traits.  The idea being that any integration (Eloquent, Doctrine) can be done as a simple repository + entity package, optionally leveraging the traits for default implementation.  This should really help with your goal of having framework integrations.\nI mentioned elsewhere that I'll be working on this 9-5, so if you want to hold off in any way and preview what I've done, I should be done by the end of the week.  It won't be PSR-2 initially, but that's only on the off chance that you totally hate it and I have to keep my fork.  If you do like it, I'll do the little bit of work to make it proper PSR-2.\n. @alexbilbie Here's a preview of things: https://github.com/atrauzzi/oauth2-server/tree/cleanup/src/Entity\nI'm still tearing things apart in the rest of the repository.  But feel free to poke around to see what I'm doing with repositories, and services.  I'm just working on the grants right now.\n. @alexbilbie An example of how I'm thinking grants can look: https://github.com/atrauzzi/oauth2-server/blob/cleanup/src/GrantType/AuthorizationCode.php\nBasically flow dispatching is always handled at the service level and grants don't have to be directly called by implementers. Constants are used when grants support/require more than one flow.\nReally hoping you like this so far as I feel like it's a huge improvement to the public interface of the library.  The end result I'm hoping is dead simple to implement with and easy to document.\n. Haha, awesome.  Sorry for being such a pain! :)\nFeel free to use this issue to track/close with the commit.\n. Naturally!\nI'll take that time to double check things in the library.  I just wanted to let you know more formally that I'm ready to collaborate.\n. Just an update for tonight, I've pushed a slew of improvements to the entities and repositories that make them much more sensible for use with non-ORM back-ends.  This is all as I continue work on my Laravel package based on these changes which will use the cache drivers to store things.\n. If you are interested in seeing an implementation of the interfaces, you can watch here: https://github.com/atrauzzi/laravel-oauth2-server\nI think it'll mostly be obvious to you, but just in case it helps.  All the repositories and entities are made.\n(I'm currently getting started on the dreaded authorization code redirect flows.  Looking to get it all tied into Laravel's auth interfaces where applicable.)\n. Not a problem, part of me suspected this is what would happen and I do definitely disagree with your appraisal based on the current complexity and rigidity of the library.\nI'm going to address your points in order to keep things clear in this ticket for future readers:\n1. Oauthable is the interface anything you want to authorize by implements.  This isn't unusual in any way.  This is just how you get rid of \"sessions\" which is unusual, specifically because it does not pertain to anything in the oauth spec.  If the term bothers you, check out Authenticatable in Laravel: https://github.com/laravel/laravel/blob/master/app/User.php\n   The term \"flow\" appers in normal Oauth terminology, nothing unusual there, so I'm not sure what you're basing that assumption off of.\n2. You will also see the use of the term \"contract\" in the link above it's just a normal-language non-keyword term.  Not confusing, just programmers communicating better.\n3. Easily remedied by adding a configuration for each combination.  Certainly more desirable than having all that disparate state floating around in various classes.  You create more busywork for the implementer by having so many touchpoints.\n4. That's exactly why I selected your package as a baseline.  The one real gem was how you assembled flows and tokens.\n   What I did here was make it friendly to different types of storage layers and less rigid by loosening a lot of coupling.  I'd make a friendly wager that changing to commands and events will only add complexity with the way things are being approached right now.\nAlso, I apologize, some of the indentation is a bit messed up because I didn't hit all the files with a space-to-tab conversion - that's because I use tabs over spaces and anticipate people to use an editor that allows them to configure tab length.  I'll get the few stragglers once I spin up a new repository for the code and re-commit everything.\nIf you get proper look (and not just a gut reaction) at any point and change your mind, do get in touch.  I hate fragmentation just as much as the next guy.\n. @alexbilbie - Had cause to peek at the V5 branch just now and things are sure trending towards the refactor I did.  Not identical.  But there sure are some striking similarities.\nInterested in going over any of the possible good-bits?\n. ",
    "Fuxy22": "I can confirm this bug. Just ran into it myself.\nHas this been fixed? The 4.0.0 milestone seems to have come and gone.\n. ",
    "gtux": "I get this same problem. I'd fix like this:\n```\n    public function newAuthorizeRequest($type, $typeId, $authParams = [])\n    {\n        // Create a new session\n        $session = new SessionEntity($this->server);\n        $session->setOwner($type, $typeId);\n        $session->associateClient($authParams['client']);\n        // $session->save();  not yet\n    ...\n\n    foreach ($authParams['scopes'] as $scope) {\n        $authCode->associateScope($scope);\n        $session->associateScope($scope);   // associate the scope with session\n    }\n\n    $session->save();   // here it must save it\n    $authCode->setSession($session);\n    $authCode->save();\n\n    return $authCode->generateRedirectUri($authParams['state']);\n}\n\n```\n. ",
    "giolvani": "Hi,\nI must repeat this question, but change the field...\nFor me, the owner_type, is always 'user'. I saw it is defined manually on PasswordGrant.php\n. @alexbilbie thank you!\nI'm newbie oauth. I thought it had relationship with ACL\n. ",
    "giannicic": "Thanks for your notice. Should be ok now. \n. Done, sorry and thank you again.\n. ",
    "brutto": "@alexbilbie begin using this pretty awesome lib i really was misunderstanging what is Session about (each AccessToken issue new Session). It will be good to hear how it was planned, for what purporse? \nI'm interested in because of after some digging and implementation at my project found that maybe Session concept may used at AuthServer (not Resource) side at least with AuthCodeGrant and ImplicitGrant types to detect all tokens issued to current session and revoke all of them with this session delete.\n. Btw encoded string the same on test machines (as expected)\n. @PhilippSchaffrath Oh! You are right! urlencode helps to decrypt. Thanks for help!\nBut i still found this behaviour aliitle strange: why tokens (access/refresh) need to be urlencoded before use but not used 'as is'?\n@alexbilbie Can you point about? . Omg, exactly!! I supposed that encrypted token + signs already was spaces (dunno why i supposed that)! xDD \n*issue closed. ",
    "djtarazona": "@alexbilbie gone* in V5? \ud83d\ude07\nKeep up the awesome work!\n. ",
    "m4tthumphrey": "Could the repositories possibly introduce factories so we can extend the Entity classes? Or provide factories for each of the Entity types as standalone classes?\n. @alexbilbie amazing! Any timeline for either of those scenarios? :smile: \n. I feel there is definitely a use case for this. GitHub for example, offer Personal Access Tokens which never expire. I have looked into \"auto renewing\" tokens but this is not something you can easily implement into the resource because the exception that is thrown for an expired token is the same as when no token exists. I suppose you could create your own ResourceServer which overrides isValidRequest() though. Although I feel this logic should be stored in the database, ie storing the expiry time as 0 or -1 for example, otherwise the expiry time field becomes misleading.\nI have looked into building into the storage interfaces but there is no easy way to do this based on a specific client; you can only do it across all clients. \nWith the introduction of factories (#307) for creating entities this should be much easier to implement however.\n. ",
    "adamwathan": "Great thanks Alex! Nice that we can do custom grants, very cool.\n. ",
    "rdohms": ":+1: \nActually I believe the hydrate method should actually be static allowing you to build a new Entity without an instance of it.\n$client = ClientEntity::build($array)\nMakes for clean and expressive code.\n@alexbilbie I would be glad to PR this is you define the best direction to go with it.\n. @mcd-php static is plague is used incorrectly.\nThis case an entity is a Value Object and using a static to instantiate a VO is perfectly usable.\nIts my understanding the constructor in this case should not be changing anyway.\nClass inheritance issues can be dealt with a simple new static.\nEither way, the static is not the issue and would just make more readable code.\nThis can also be achieved in 2 steps anyway, one to make hydrate available in every object and second to have a trait for static building.\n. @alexbilbie you lost me. :P which path do you want to take?\n. @mcd-php i don't follow.\n(-100 > 0) == false // -100 is not greater then 0\nThat means isExpired returns false meaning the token is indeed not expired.\nIf time() is higher then expireTime then the result is above zero and the token ins indeed expired.\nSo this is actually not an issue.\n. Looking good, will give it a closer look alter when time becomes available.\nOne thing i think would be great is to add a Relational DB map, or at least some description of the relations between the entities, right now you have to reverse engineer it from the examples and then turn that into implementation. Having a suggested diagram would make that step a lot faster.\n. or maybe use something that already exists? https://github.com/mathiasgrimm/arraypath\n. You suggested creating yet another package that does a sub-set of this, i see no real need for all of that if this class does exactly what is needed, but can do more. What's the cost involved in using it?\n. > Fetching a deep array value by string is not one of the things I would want to implement.\nreturn (isset($this->scopes[$identifier])) ? $this->scopes[$identifier] : null;\nbecomes\nreturn a::get($identifier, $this->scopes, null)\nSolves the problem and you don't have to do anything you don't want to\n\nThe given package doesn't link to any build status or code quality or what PSR standards it uses or even contain a license declaration. I'd like to make sure the code is high quality.\n\nThat is bad attitude, all of this is solvable by PRs and contributions and keeping the spirit of OSS. \nAnyway, what i'm saying is you are trying to solve a problem that at least 5 packages already do, let's fight NIH and share more code around. That's supposed to be the spirit of the League.\n. The usual rule of thumb i have seen is: dependencies added via constructor are \"required\" and the ones added via setter injection are optional, makes it easier for whomever is providing objects to inject to know what he needs to provide. This case i think they are all required.\n. What is the advantage of using a trait here? Its adding functionality that the object does not need, making every class a little bigger at runtime with no real benefit. This is not a trait of an object, even the name does not describe a behaviour of the object, its describing a tool used to simplify an use case, hence its better as an external or even better a language construct.\n. why would you say a trait is more flexible? I would disagree, both are as flexible as the other. Also solving the same code over and over is the same purpose of this object.\nI would argue traits have the extra onus of risk of nameclashes and harder testing the testing a implementation like ArrayPath. Statics are a valid solution for this problem as it requires no context to be shared, is a clear operation with in/out and no external requirements.\n. This hardly seems like a use case for overloading.\n. This would not be caught at instantiation, only during runtime when you actually use the object. So essentially an error like this would most likely be caught in production, unless you have proper tests that stress every angle of the code and catch this execution path. \nConstructor injection will break as soon as the DIC get's put together, meaning you are more likely to catch the error before it ships out.\n. That \"test suite\" makes actually no difference, since this would be an implementation error, so its the users who will suffer from poor architecture, not the library itself.\n. ",
    "mcd-php": "Static is plague, if not otherwise proven with math rigor on case-by-case basis. For example, here it will kill partial hydration, constructor options and class inheritance (may resurrect w/ ugly functions like get_called_class(), equals to reflection and occult magick).\nJust hoist hydrate() into base class like \\League\\OAuth2\\Server\\Entity\\AbstractTokenEntity, and turn into HydratableInterface and HydrateTrait.\nHere's how I use it, so ugly:\nphp\n        $entity = new $entityClass($this->_server);\n        // https://github.com/thephpleague/oauth2-server/issues/318\n        if ( method_exists($entity,'hydrate')) {\n            $entity->hydrate($fields);\n        } else {\n            ObjectHelper::configureForeign($entity,$fields);\n        }\n. Yeah, sorry. Seemingly the real issue was value scaling/transform in my DB library.\n. I have read http://tools.ietf.org/html/rfc6749 , section 5.2 allows optional error_description. \nYes, it will take rework of exception hierarchy, but not giving human-worded description of error will impede cooperation between services using the library, and their clients.\nI have both client and server in neighbour IDE windows (splitting my project in SOA way), but what if client is foreign developer ? How can he know what failed in server, or what is his own fault ?\n. Here's the closing criteria:\nLet's https://alice.net uses this library, and https://bob.org has junior web-master Pogo who tries to establish trust with https://alice.net, but does not know what language and library does the https://alice.net use, let alone any opportunity to view it's source and debug side by side.\nThe poor Pogo can clearly and definitively find out what's bad with the connection only from network messages coming his way, no need for comments in code of library he doesn't know of existence and usage.\nIf that's true, then close.\nP.S. Sorry, don't have my offending projects handy and ready for test.\n. I have seen two places with too lengthy encodings: bin2hex without option, JSON, no compression etc, first is BearerTokenResponse.php#L35 and second is AbstractGrant.php#463.\nSince you are the primary author, I advice you to list all such places and apply pluggable codecs to them, so user-programmers can encode more efficiently, compress etc.\nI tried to find the decoding counterpart of BearerTokenResponse.php#L35 but failed to do so quickly, since the artifact being created is not wrapped to any class or interface.\n. ",
    "hoyo": "+1\n. ",
    "dav-m85": "Issue to be closed ?\n. @mcd-php awesome test case to write indeed :)\n. @mikepmtl run php examples/relational/config/init.phpand then open the oauth2.sqlite3 with the dbm of your choice... cannot think of a simpler way of doing it without crippling the repository with a useless file.\n. ",
    "demagu": "@alexbilbie having the same issue. code is always 0 in all exceptions thrown by the server. \nShould \\League\\OAuth2\\Server\\Exception\\OAuthException do:\nphp\nparent::__construct($msg, $this->httpStatusCode);\ninstead of just:\nphp\nparent::__construct($msg);\n. @alexbilbie, thanks for the hint. \nIn my specific case access_token has to be passed in as query string. \nI ended up extending ResourceServer and overwriting determineAccessToken method to for my needs. \n. ",
    "astax-t": "Any comments on this issue? I'm happy to make a pull request to fix this, but not sure if this is actually an error or was done intentionally for some reason I don't understand.\n. ",
    "filfat": "+1\n. @robertpitt It would be extremely useful in development & certain unit test, ofc I would never use it in production. :)\n. ",
    "starJammer": "Hey Irto, I created this pull request and realized it's very similar to yours. Can you look at mine as well. I added tests as well as some modifications for properly including the WWW-Authenticate headers.\nhttps://github.com/thephpleague/oauth2-server/pull/399\n. +1\n. I think I found why this ISN'T working.\nYou have to dig all the way to Symfony\\Component\\HttpFoundation\\ServerBag->getHeaders sort of. It is used by HeaderBag, which is used by Symfony\\Component\\HttpFoundation\\Request.\nAlso, refer to http://stackoverflow.com/questions/7818867/check-header-authorization-on-restler-api-framework\nEssentially, PHP under Apache ignores the Authorize header. So you have to either force apache to set the Authorize environment variable like in the stackoverflow question or you have to pass in the header under a different name.\n. Yes, it's against the OAuth2 spec. The client credentials grant uses both the client_key and client_secret directly so you can just get another access token with those.\nFor reference: https://tools.ietf.org/html/rfc6749#section-4.4.3\nSee the 3rd sentence.\n. @newls I made a mistake here and should've said \"Yes, it's not recommended by OAuth2 spec\".\nThis document defines the meaning of SHOULD NOT as being \nSHOULD NOT   This phrase, or the phrase \"NOT RECOMMENDED\" mean that\n   there may exist valid reasons in particular circumstances when the\n   particular behavior is acceptable or even useful, but the full\n   implications should be understood and the case carefully weighed\n   before implementing any behavior described with this label.\nIt specifies that the implementation can go against the recommendation if the ramifications are understood but it's up to the implementation. So it isn't strictly prohibited.\nI don't see an obvious downside to providing a refresh token other than leaking another \"credential\" onto the network. \n. I think that this was done this way because the OAuth2 spec doesn't explicitly say that refresh tokens expire.\n. @gnrcampos , the best way I found to do this was to \"fudge\" my RefreshTokenStorage implementation. Whenever the refresh token is fetched via the get method I set the expire time in the refresh token entity to one year from now. In this way the isExpired method will always return true on the entity. \nThis creates a problem because you might want to expire a refresh token for some reason. What you can do is create a Boolean column on the refresh token table is_expired. If it is true your storage implementation will set the expiration time for each token it fetches to be a year from now and if it is falsi it'll set the expiration time to some in the past.\nDoes that make sense?\n. ah, no worries. I created a tag in my forked version. \n. awww, code coverage failed. It says the external service took too long. What do I do?\n. Updated branch to latest master.\n. ",
    "mbrevda": "I actually need to implement an auth server a. What is the eta for v5? Can\nI do anything to help get it released in the near future?\nOn Mon, Apr 27, 2015, 4:30 PM Alex Bilbie notifications@github.com wrote:\n\nVersion 5 of the app (currently in dev) has already started to address\nsome of these concerns and has a much better structure.\nThe next step would be to use value objects instead of working directly\nwith Symfony's request object to allow for easier interoperability with\nother implementations.\nSo yes I agree with your points and they should be addressed in v5.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/336#issuecomment-96652802\n.\n. \n",
    "andrewpillar": "Why not just copy the files out of that folder and put them under a namespace and autoload them in that way?\n. ",
    "alnutile": "Not in a good way. Maybe we can talk. Alfrednutile@gmail.com \n. ",
    "eidng8": "Not sure if this is what you're looking for:\nhttps://github.com/lucadegasperi/oauth2-server-laravel\n. Not sure if I get it right. Should we skip an extraneous SQL query by making this change?\nphp\n$clientSecret = null;\nif ($this->shouldRequireClientSecret()) {\n    $clientSecret = $this->server->getRequest()->request->get('client_secret',\n        $this->server->getRequest()->getPassword())\n    if(is_null($clientSecret)) {\n        throw new Exception\\InvalidRequestException('client_secret');\n    }\n}\n. I would keep the constructor, because what it does seems fundamental to me. However, I would also add parameters (default to null) to the constructor to ease the pain while inject/test-ing the class. So if the constructor got null parameters, it would do as usual, and while there are something passed in, it'll use the injected stuff.\n. Just a few of my own feelings on this kind of signature.\n1. While the parameter list is short, I tend to put stuff directly to parameter list. It's easier to document, allow compile time (or sort of) checking, and let modern IDE to do their hinting works.\n2. While the parameter list is long, I tend to put stuff in arrays. However, this is harder to document, and cannot be linting, and IDE can't get a hint on it (at least not until phpdoc supports detailed array element documenting).\nSometimes (if not many), I sway. I has particular concern on coding conventions, so the above 2 may not co-exist in the same code base. But each of them has their particular temptations. Such as, for instance, the signature we are talking about.\nFor this instance, I backed @shadowhand 's opinion above. As it enables enforcement of all fundamental requirements shall be met, right at the moment of creating instance, by checking passed-in values at run time.\n. ",
    "marcteyssier": ":+1: \n. ",
    "tyuwan": "You have to handle that logic yourself.\n. ",
    "iamdriz": "@tyuwan Where would I handle it?\n. @tyuwan It would have to somehow intercept the request... Even if it's an authorization code it would need to step over the asking the user to agree and just return the code.\n. Both GitHub and Facebook don't work this way and instead just grab another access token once the current one has expired and check that the app still has permission without requiring the user to click to authorise again. In fact you can even list your authenticated apps and revoke the current token or the application itself. So they are clearly storing authenticated applications as well as access tokens.\nSent from my iPhone\n\nOn 13 Jul 2015, at 20:37, Alex Bilbie notifications@github.com wrote:\nYour server should clean up old access tokens. If an access token has expired then the user should approve permission again.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "joaopramos": "It looks like the MAC token type is not returning the issued refresh token.\nIssued pull request #369\n. ",
    "IamRobin": "Hi, I'm having the exact same issue with refresh tokens. What did you do to resolve it? (If you have)\n. ",
    "refear99": "I'm having the exact same issue\n@cboden Is this fixed?\n. @cboden Please help...\nWhich part of configuration? Auth? Grant?\n. ",
    "cboden": "@refear99 I forget exactly what was wrong but I remember it was my fault in the configuration...I think I forgot a database field and an empty row was causing it. \n. ",
    "HonzaMac": "Any progress on that? This is little bit show stopper for this oauth implementation\n. ",
    "developernaren": "I am stuck with this implementation and there is no answer to the question. Would you Alex  like me to help and make a pull request for this error? Should I see if I can help?\n. I hope you had a wonderful holiday. \nI actually created this issue . then Luca suggested that I create issue here. I had not looked into the code after I created the issue hoping that I will get reply but I remembered the issue today while looking into something else and looked around and found the solution and I suggested the same to Luca in the same thread. I think it is simpler to make the edit there.Its a coincidence that you replied the same day that I suggested the solution and it seems that your example is almost exactly as the solution that I suggested. Great Minds, I guess ;)\nI am waiting for Luca's reply now.\n. ",
    "eunion": "hi ,How did you solve the problem? I use phalcon framwork it can not save the authParams to session.\n. ",
    "raijinsetsu": "I was not. No matter what, I could not unserialize the authParams.\nSerialization worked fine.\nOn Wed, Jan 13, 2016 at 5:11 AM, eunion notifications@github.com wrote:\n\nhi ,How did you solve the problem? I use phalcon framwork it can not save\nthe authParams to session.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/361#issuecomment-171241237\n.\n. \n",
    "rickshawhobo": "hey @alexbilbie can we patch this for 4.1 with the code you suggested above? We're being forced to use 4.1 for now now due to the Luca package. Much appreciated!\n. Thanks @alexbilbie  Here is the PR https://github.com/thephpleague/oauth2-server/pull/652\n. ",
    "cesutherland": "This prevents one client from being granted an access token for an auth code issued to another client.\nThe tests on develop weren't passing, so I created this PR from master (and assigned the PR to master).  If I should assign it to develop let me know!\n. @alexbilbie @dekker-m @apollopy it should already be associated.  When the auth code is originally created, the client is associated with it.  That's how we're able to recall the client to make the check before issuing the access token :)\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L148-L165\n. @apollopy Thanks, I see!  I think it's OK, in any case.  The client was already created, associated and saved as part of the session in the authorization request.  $session->getClient() simply recalls the stored client and sets it on the session.  I think that's what we want here.\nhttps://github.com/thephpleague/oauth2-server/blob/c174b6fc65f034dd6547da6ab7bb429a20988eb0/src/Entity/SessionEntity.php#L225-L246\nIt looks like this lookup might be removable now.  We can compare the $clientId and $clientSecret to that already stored on the session.  The $redirectUri is already compared to the auth code and was validated when the auth code was issued.  And we looked at the grant id in... the server I think?\nI'm starting to agree with #306... the session abstraction \u2014 which is very neat \u2014 really muddles some things.\n. ",
    "apollopy": "I am late, I have same idea about this. but if checked, can associate $client to $session.\nphp\n// Check client ID presented matches client ID originally used in authorize request\n$session = $code->getSession();\nif ($session->getClient()->getId() !== $client->getId()) {\n    throw new Exception\\InvalidRequestException('code');\n}\n$session->associateClient($client); // It is not necessary to delete the line\n. @dekker-m \nI think check is need, but if checked, can associate $client to $session.\n. @cesutherland \nsorry, my english is bad.\nYou said associated to database; I said associated to current object. only in this way, the code is consistent.\ncan see:\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L160\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L241\n. @cesutherland \nI simply think remove the $session->associateClient($client); line don't help fix this bug. Just keep the same code style\n. if want to prevent replay attacks, can save ts+nonce to check uniqueness. but need more code. \nAnyway, ((int) $params->get('ts') !== time())  too idealistic\n. ",
    "dekker-m": "@alexbilbie I think he removed this line so the the client from the session is validated against the client making the request. This way, only the client who requested the AuthCode can request the Access Token.\nPS: I also mailed you about the same issue a few days ago ;-)\n. @apollopy If you check the client against the client who requested the authorization code, associating the $client to $session is not necessary. They will be the same if the check passes and the client should already associated to the session in the storage.\n. I'm not sure which version of the draft for MAC is implemented, but v2 of the draft has a pretty good way of checking the timestamp. On the first request the time difference is measured between server and client, this difference should be saved to the database. Subsequent requests should/can be checked against a much smaller time difference this way, possibly even a few seconds.\nChecking the timestamp should prevent replay attacks. Even a window of 5 minutes, in my opinion, is way to much to prevent replay attacks. The proposed way of checking the ts parameter in the v2 of the draft is a pretty good way to keep the window as small as possible.\n. Saving the ts + nonce is indeed another good way to prevent replay attacks. Nonetheless, I think performaning the check as proposed by @michaelhogg (as defined in the RFC) would be a good improvement over the current check. There is always the possibilty two clients do not have the correct, current timestamp. By checking the timestamp as proposed in the RFC, the difference does not mather, is should even be possible to have a time difference of 3 hours. The check will still make sure every request after the first one falls within a window of a few seconds.\n. Why do you think this is useful?\nThe reason oauth definesexpires_in instead of an expire_time is to account for servers configured with different times. It can happen my client has it's time set half an hour earlier. If you would return expire_time instead of expires_in, my client would still think the access token is valid, while it has actually expired half an hour ago. If my client would use expires_in he can adjust this time to his own local time and determine the exact time the access token will expire. If you do this, there is no point in providing the expire_time in the response.\nOr is there another reason why you want to add this response parameter?\n. I understand what you are saying, but under normal circumstances with a low network latency this should not cause too much trouble. I normally advise clients to refresh the access tokens a few seconds before it really expires to prevent this problem.\n. ",
    "michaelhogg": "+1\nIt's definitely unreasonable to expect the timestamp to be identical to time(). This is a good improvement. It would be even better if the allowable time difference could be configured, instead of being hard-coded.\nI'm not sure how closely this library is intending to follow the OAuth 2.0 Message Authentication Code (MAC) Tokens draft spec, but the Timestamp Verification section suggests calculating and storing the time delta of each client, so that clients aren't required to have accurate clocks.\nThat section of the draft spec also suggests a value of 5 minutes for the \"allowable clock skew\".\n. Note: the Travis CI build failed due to a separate bug, which I've now fixed in #371.\nMerging that fix into this branch causes the Travis CI build to pass.\n. Done :+1:\nI notice Scrutinizer is timing out \"Waiting for External Code Coverage\".\nI guess this can be fixed by increasing the timeout?\n. No worries. Many thanks for merging my PRs!\n. ",
    "arnovr": "I am not seeing any implementation of a Server Interface anywhere @ master.\nCould you enlighten me for your solution. We are having some issues on circular dependencies. This gives us more flexibility.\n. ",
    "paragonie-scott": "Scrutinizer was cancelled? o_o\n. https://github.com/thephpleague/oauth2-server/blob/V5-WIP/src/CryptTrait.php#L74 needs to use the same padding mode as decryption\n. https://github.com/juliangut/oauth2-server/blob/cryptography_trait/src/CryptTrait.php#L74\nIf you don't specify the padding mode for RSA, you end up in the same boat as ZF2015-10.\n. > As per PHP documentation openssl_private_encrypt and openssl_public_decrypt don't accept OPENSSL_PKCS1_OAEP_PADDING as padding parameter\n\nOn the other hand openssl_public_encrypt and openssl_private_decrypt do accept OPENSSL_PKCS1_OAEP_PADDING padding\n\nOh geez, I read that backwards. Sorry, that detail is really important.\nYou probably want to use openssl_sign() and openssl_verify(), but sadly there's no way to (reliably) achieve RSASSA-PSS from PHP without using e.g. PHPSeclib by @terrafrost et al.\n. ",
    "darrylkuhn": "To address it in the short term I have made the following change:\nhttps://github.com/thephpleague/oauth2-server/compare/4.1.3...darrylkuhn:4.1.4\nHappy to make the same changed against development and submit a pull request if it turns that I haven't simply misunderstood how rotation should work.\n. ",
    "corbosman": "A one way hash like bcrypt, so tokens are treated the same as one would store passwords. Same goes for client secrets, which in this specific application are stored plaintext in a database as well.  The authors claims this hashing should be done in thephpleague/oauth2-server. \n. You hash them again, and compare the hashes, just like how passwords work. \n. Ah yes, you're right, i didnt realise there is no way to identify the token. But then at least they could be encrypted with a secret right? Seems better than storing them plaintext in a database that could escape into the wild, as we often see happen. \n. ",
    "spronkey": "@alexbilbie @corbosman I just want to point out that the only purpose of a salt is to prevent the same plaintext being revealed multiple times over i.e. cracking a bunch of the same passwords. Tokens should have enough entropy in them that they are unique enough, so there's not a huge downside I can see for hashing without salting them - just use a high rounds hash and it should be fine. \n. Seconded. Magic strings are nasty, mmkay. \n. Nasty. Why not use interface name for the container, and get rid of the switch statement somehow?\n. In addition to @shadowhand 's commend above, I think this DI for the grants isn't the best design. It means we're forced to use string identification when adding grants to an authorization server.\nHow about instead of DIing in the grant constructors, adding a grant similar to the old method, $server->addGrant(new SomeGrant()), and have the server inject the storages needed into the grant itself via DI methods?\n. ",
    "mschinis": "Can we merge this?\n. Clients should never expose private keys. It's not a matter of not wanting confidential clients, but more of a \"keeping up to date with the latest standards\". Client implementations like ember-simple-auth, have stopped supporting earlier versions of the oauth2 standard, so I believe this PR would help a lot of other users.\n. @alexbilbie Most implementations of oauth2, including client oauth2 libraries follow the RFC6749.\nSharing the client_secret doesn't add any extra security, as mentioned by @whitefoxy, since the client has to expose its secret publicly at some point. Wether that is through the js console in web apps, or taking a mobile application apart and looking through the configuration files.\n. thanks!\n. ",
    "whitefoxy": "+1 Waiting for this merge\n. I don't understand why in PasswordGrant client_secret adds more security? It just adds more problems to store them. How the PasswordGrant can be used in desktop or mobile apps? The request must be proxied by the server and it is absolutely the same if the PasswordGrant not require the client_secret. In many docs, for example on IBM website, they don't use client_secret in PasswordGrant.\n. ",
    "davidsteinsland": "Can probably add that this needs to go a step further. When issuing an access token, I believe that the previous session should be used, if there is any. If not the number of sessions for the same application will quickly rise to a very high number.\nOne app = One session given that the scopes are the same.\nToday it's\nOne authorization request = One session, although it's the same app and scopes\n. https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php#L119-L122\nredirect_uri is optional in spec.\n. ClientStorage keeps track of redirect uri, no? how the uris are stored and\nfetched is implementation specific. the library should conform to the spec.\n\nMvh / Regards,\nDavid Steinsland\n. I guess you misunderstood. Redirect URI must be matched against a whitelist, yes. But the query string argument redirect_uri is optional, meaning that if it isn't set we get a default from the storage.\n. I am talking about the initial authorization grant.\nDen tirsdag 16. februar 2016 skrev Konst; notifications@github.com\nf\u00f8lgende:\n\nredirect_uri is required in Access Token Request if Authorization Request\nhad it.\nhttp://tools.ietf.org/html/rfc6749#section-4.1.3\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/439#issuecomment-184864619\n.\n\n\nMvh / Regards,\nDavid Steinsland\n. It would, in my mind, be a good addition of the OAuth library. You're then able to provide authentication and authorization in one go, and also providing a secure implicit flow grant.\n. Here's a list of certified OpenID Connect issuers:\nhttps://openid.net/certification/\nMy best tip is pointing you to the specification, though. Cumbersome reading material, but it's where it all is :)\n. ",
    "gnrcampos": "@starJammer In this case, how do I set a never expiring refresh token? I searched it in the documentation, here and even went through the code, but it seems that if I do what I think would be the most intuitive thing, setting the expiration time to zero or a negative value, this method\npublic function isExpired()\n{\n    return ((time() - $this->expireTime) > 0);\n}\nwould just return false.\n. @starJammer yes it does make sense, thank you very much. I'm gonna go over the possibilities but so far this one seems to be the best.\n. ",
    "vinkla": "Okay, good :+1: \n. :+1: \n. :+1: \n. https://github.com/lucadegasperi/oauth2-server-laravel/issues/615#issuecomment-161579547\n. Just more common name and it is preferred by GitHub.\n. This is the naming convention when creating a new repository.\n. :+1: \n. This will allow developers to keep a custom phpunit.xml for development.\n. It is just a way to let developers customize the settings in their local environment. It is common to use .dist(ribution) when pushing packages to GitHub. Nothing important really :)\n. :+1: \n. :+1: \n. Thanks for being quick on this :+1: \n. Great work @alexbilbie! Could you let us know about when this is closing its merge state? Then @lucadegasperi and I can start working on the next version of the Laravel wrapper package. We don't want to start to early with the Laravel package if there will be any major changes happening in version 5. Please let us know. Thanks.\n. Thanks. Three tables sounds really good!\n. Done.\n. ",
    "sajumani": "thanks for your reply... I have been successfully integrated\nOn Nov 21, 2015 7:23 PM, \"Alex Bilbie\" notifications@github.com wrote:\n\nYou can find generic PHP documentation at the doc website and in the\nexamples directory in the code base\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/403#issuecomment-158642616\n.\n. \n",
    "juliangut": "I really need this to be PSR7 compliant so I'll be making some PR in the next days, do you have a roadmap to V5? anyway it can be tracked so I can help?\n. Maybe this is my personal preference but I find ResponseTypes to be misleading, they are not Response objects of any type. I'd rename it to something related tokens, ResponseToken, TokenType ...\n. How is it going with V5 @alexbilbie ?\n. No prob @alexbilbie, conflicts solved\n. By the way, does oauth2 standard tells scope delimiter is limited to ' ' and thus it's now a constant or is it just because of convenience?. I find it useless to be able to change it, I've never done it\n. Yep, about the whole SecureKey::generate()\nI can't say by myself what mechanism is better but according to the guys at paragonie/random_compat discussions this is the order of preference:\n- Use libsodium if available.\n- fread() /dev/urandom if available (never on Windows)\n- mcrypt_create_iv($bytes, MCRYPT_CREATE_IV)\n- COM('CAPICOM.Utilities.1')->GetRandom()\n- openssl_random_pseudo_bytes() (absolute last resort)\nThere is a lot to read about security in that repo but in the end I'd say it is overall more secure\n. At the same time I'd change KeyCrypt encrypt and decrypt methods to use phpseclib package instead, fully compatible with openssl\n. Does RedirectUri have any other method but make? if it is not the case you can use the same strategy using Diactoros Uri implementation in AuthCodeGrant\n. You've come to a good point! This line is needed in decrypt method\nphp\nself::getAlgorithm()->setPassword($privateKeyPassword);\nIt adds an extra parameter to be handled in case RSA key has a password\nIt's added logic but I \"guess\" the benefits of being able to switch algos outruns the drawbacks of having to store and pass an extra parameter, maybe??\n. Added privateKeyPassword parameter.\nParameters on Server::__construct and AbstractResponseType::__construct needed reordering to allow default empty string for privateKeyPassword\n. I'm not very fond of this, should probably rewrite this completely. Anyway my goal is to avoid \"Helper\" classes such as KeyCrypt, IMO such functionality belong in a Trait\n. Dropping in favor of #468 \n. Fixing right now.\nAnother thing, grantType will never be null as long as this is always called from a grant which has an identifier (worst case scenario it is an empty string), the parameter should be made mandatory and moved up the list; whether the repository uses it or not is up to the developer\n. @alexbilbie have you had the time to have a look at least at this PR?\n. Done!\n. Yes, that's the only point in which it seams odd. The other way to do this is by using setRefreshTokenTTL method inside Server::enableGrantType controlled by an instanceof check\n. I can imagine, I've not tried to implement authCode grant because you were already working on it :grinning:\nAnyway I think that allowing assing of refresh token TTL instead of hardcoded to 1 month is a must\n. Just make refresh token TTL configurable on a grant basis\n. forced $request->getParsedBody() to array\n. protected_api example have been merged into middleware_use\n. merged and tested\n. Note that it must be stated on the docs that client secret must be a password_hash(ed) string\n. Thanks for the advice @paragonie-scott, updated to use OPENSSL_PKCS1_OAEP_PADDING\n. I see the problem:\nprivate_encrypt and public_decrypt only accept OPENSSL_PKCS1_PADDINGor OPENSSL_NO_PADDING as padding param, while public_encrypt and private_decrypt do accept more padding options, including OPENSSL_PKCS1_OAEP_PADDING\nNow that I write it down it seems the encryption process is upside-down, it should be encrypted with public key so only the server will be able to decrypt it with private key.\nI'll wait for your comment @alexbilbie to make the change. May we have a word from @paragonie-scott  as well?\n. I'm afraid test are failing bad\n. In the case of Client Credentials grant the 'client' is the resource owner, there is no user involved as the Application itself (client) is the one being granted access\n. Hi @tigrang, I'm facing the same issue here: composing Doctrine token entities pulling data from Legue\\Oauth2\\Server\\Entities*Entity, and I assume this is going to be a recurrent issue because of the spread of Doctrine.\nI'm thinking two options to avoid this extra step:\n- Making persistNewAccessToken, persistNewRefreshToken and persistNewAuthCode not only persist entities but create and return them by providing corresponding parameters\n- Injecting the entities' class names so the library creates them in issue* methods as you suggest, but somehow providing three class names (for access token, refresh token and auth code) seems like bloating it a bit\nWith the first option additionally the developer can be responsible of generating token identifiers instead of being restricted to what the library generates (even though using random_bytes is the correct way)\n. Please @frankdejonge add the methods to the repositories, I'll suggest though you change their signature as they don't need any parameter\nphp\npublic function getNewAccessToken();\npublic function getNewRefreshToken();\npublic function getNewAuthCode();\n. Ahhh! sorry for the missleading mention just typed @ and f and pressed enter :disappointed: \n. @alexbilbie this issue might be closed\n. Tests covered\n. I has a look at OAuth2ServerExamples\\Repositories\\ClientRepository and the phpdoc on ClientRepositoryInterface and noticed the order of the paremeters was shifted, you can see grantType is at the end of the list\n. OK then, I'm reverting that piece of code, updating the docblock and changing OAuth2ServerExamples\\Repositories\\ClientRepository\n. Somehow I keep making this mistake from time to time\n. ",
    "pekhota": "But in official docs there is no client_id and secret.\n. ok)\n. ",
    "GawainLynch": "Just a note in support of this PR. PHPUnit will check for the .xml.dist file if the .xml isn't present, so there is no negative impact on the project\u2026 but it can make short term testing changes a lot easier for a developer.\n. ",
    "gfyrag": "+1 for this features.\n. I had the same problem. Just saved the authParams fields in a flat dictionnary to restore it later.\n. ",
    "wgq91here": "i use symfony. i no problem.\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\n$session = new Session();\n$session->start();\n...\n$session->set('authParams', $authParams);\nAnd notice is , don't save function in session. like it :\n$checkUser = function ($username, $passwd) {\n  $User_model = new RelationalExample\\Model\\Users;\n  $user = $User_model->get($username);\n  if (password_verify($passwd, $user[0]['password']) === true) {\n    return $username;\n  } else\n    return false;\n};\n// error!\n$server->getGrantType('password')->setVerifyCredentialsCallback($checkUser);\n// don't out router\n$router->post('/auth', ...\nchange it :\n$router->post('/auth', function(...\n  $server->getGrantType('password')->setVerifyCredentialsCallback($checkUser);\n)\n. Examples is litter demo. Maybe can't use it directly.\nPlease visit oauth wiki, understand it.\n. ",
    "frederikbosch": "@alexbilbie Would you mind releasing a first alpha of version 5? Or do you have other plans on releasing?\n. Great, thanks for your work @alexbilbie!\n. Forgot to add how great your work is on this new version 5!\n. @alexbilbie You want me to help on this? I can update the PR by replacing Diactoros completely for PSR-7. Or would you rather focus on it yourself?\n. @alexbilbie Alright, thanks for your explanation. To be honest: I think v5 must lean on PSR-7 instead of Diactoros. It would defeat the purpose of a PSR if packages would still lean on concretions rather than interfaces. Therefore I think I am going to have a look at it. Maybe turn the Diactoros stuff into an adapter. Will update the PR when I am done.\n. Oh wow, fantastic! I am very grateful for resolving it so fast. Wonderful. Many thanks!\n. General comment: I find that the interfaces are containers, which is understandable in scope of this library package. But maybe there are situations where the name of the method could change from a getter/setter to a more operational name (tell instead of ask).\n. @alexbilbie An exception creates a better contract. When I was implementing this, I was wondering: what should I do when the login is incorrect. The doc block did not contain any hint what to do. And, alright, it's a WIP, but let's consider there would have been a docblock. See below.\nphp\n/**\n * @return UserEntityInterface|null Return the user entity when correct login, otherwise null\n */\nI believe this designs a better contract.\nphp\n/**\n * @return UserEntityInterface Return the user entity after logged in\n *\n * @throws UnknownUserException in case of an unknown user\n */\nYou even have the possibility to create more exceptions in case of other failures. More important, it eliminates a bunch of null checks. Look how many null checks this block contains.\n. I'd like to add something more here. What would you do if this library would only support PHP7? Then I am sure you would like to use return types, right? But then you cannot even use return null. See the paragraph \"Disallowing NULL on Return Types\" in the RFC for more details on this. So one has to use an exception when it is not possible to return the required type. The signature of the method for PHP would then had to look similar to this.\nphp\n    /**\n     * Get a user entity.\n     *\n     * @param string                                                          $username\n     * @param string                                                          $password\n     * @param string                                                          $grantType    The grant type used\n     * @param \\League\\OAuth2\\Server\\Entities\\Interfaces\\ClientEntityInterface $clientEntity\n     *\n     * @throws \\League\\OAuth2\\Server\\Exception\\UnknownUserException unknown user\n     * @throws \\League\\OAuth2\\Server\\Exception\\InvalidUserCredentials cannot authenticate\n     *\n     * @return \\League\\OAuth2\\Server\\Entities\\Interfaces\\UserEntityInterface\n     */\n    public function getUserEntityByUserCredentials(\n        $username,\n        $password,\n        $grantType,\n        ClientEntityInterface $clientEntity\n    ) : UserEntityInterface;\nTherefore, I would like to propose not only to change the UserRepositoryInterface but also other interfaces that can return null now.\n. It is not. This is my response body.\njson\n{\n  \"error\": \"invalid_request\",\n  \"message\": \"The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed.\",\n  \"hint\": \"`%s` parameter is missing\"\n}\n. With the change it becomes.\njson\n{\n  \"error\": \"invalid_request\",\n  \"message\": \"The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed.\",\n  \"hint\": \"Check the `password` parameter\"\n}\n. @alexbilbie Please have another look at it.\n1. No username here\n2. Passes a second argument ($hint) as string here.\n3. So $hint is not null\n4. However, $hint === null skips the sprintf call here.\n5. That leads to response body from my second message in this thread, while it should be the third.\n. Maybe my proposed solution is wrong. But the current code leads to a wrong response body.\n. Alright, thanks :+1: \n. After thinking things through, it would be best to move convertToJWT to a separate class. Then we can skip createNewToken too. I would be happy to implement either method.\n``` php\nuse Lcobucci\\JWT\\Builder;\nclass AccessTokenToJwtConverter implements AccessTokenToJwtConverterInterface {\n  private $builder;\npublic function __construct(Builder $builder) {\n    $this->builder = $builder;\n  }\npublic function convert (AccessTokenEntity $accessToken) {\n    // conversion\n   return $jwt;\n  }\n}\n```\n. @juliangut Sure. But that does not withstand the fact that a client identifier is passed to a method that expects a user identifier. Not every method is aware of the grand type that is requested, specifically the issueAccessToken method in AbstractGrant. This method is called by all grant type implementations. In turn that method calls the AccessTokenRepository which will store a user identifier while a client identifier is passed to it. Suppose you save the access token to a database with foreign keys, things will break!\nAnd if you would have had a look at ghe PR, you would have seen that I pass in null to user identifier parameter, because - as your saying correctly - there is no user with the client credentials grant type.\n. This can be solved together with PR #513, if we change the signature of newHtmlResponse inside. I am willing to help, if my help is being appreciated.\n. Then we could also remove AbstractAuthorizeGrant and by doing also reduce inheritance. I feel a grant has to too many layers: it implements, extends and uses (traits). This makes things too complex.\nThough we must not move too much responsibility into the response factory. If it becomes too fat, we can inject delegated response handlers in the factory.\n. @warlock39 Wonderful feedback: constructive and critic. While some points were not part of the PR to solve, I will take 'em into account during update. Majority is valid and will be taken care of. Thanks again. Hope @alexbilbie will consider to merge.\n. @Bobselp Thanks for the feedback. I get your points. Basically, you want this library to act as middleware in cases like AuthCodeGrant. You do not only want to inject a different renderer but you want to create a response yourself, right?\nWhile I do think my PR gives a much better separation of concerns, I do agree that your request is not honoured by it. Let me think how to improve it as such that it solves your case too.\n. Nice work @alexbilbie \n. @tigrang @juliangut PR #497 adds the feature for access tokens I think. A new method is added to the AccessTokenRepository 'createNewToken'. This will instantiate the token in the repository so you will have the opportunity to return an object that can be persisted by Doctrine. We could also add createNewToken methods to the auth code and refresh token repository. I could extend the PR, if you like what I am proposing.\n. @juliangut Will do, and will also changes the signature. Will update the PR later today or tomorrow.\np.s. @frankdejonge You were mistakenly @-mentioned by @juliangut.\n. Hehe, he is going to be super mad at you!\n. @lucadegasperi @juliangut New PR added with the requested methods.\n. Great work!\n. @rubenalliet Insert echo $e->getMessage() or var_dump($e); or dd($e) on line 56 to see the exception message and location where the exception is thrown. The exception is not coming from this oauth2 server package, but from somewhere else.\nThe error says. You are calling method $e->errorType() on class \\InvalidArgumentException but that class does not contain such method. That is correct. See the methods on the \\InvalidArgumentException.\nIt would be even better to extend the try-catch block.\nphp\ntry {\n  $response = $server->issueAccessToken();\n  return new Response(json_encode($response));\n} catch (\\InvalidArgumentException $e) {\n  dd($e); // show me what is going on here\n} catch (\\Exception $e) {\n  // handling of other exceptions\n}\n. Also added abstract repositories that return the default entities, but they can be removed if necessary.\n. Oh, and I also merged PR #501 by @juliangut because it helps solving conflicts beforehand.\n. @warlock39 The PR is updated. The things that you addressed have been taken care of.\n1. You can now append data to a JWT token by using a decorator\n2. You can now inject a NullRenderer to the ResponseFactory\n3. You can now replace the used JWT implementation with your own by creating your own implementation of ResponseFactoryInterface\nRegarding making the refresh token optional: that was not part of this PR. The idea of this PR is to give more flexibility with regard to the renderer and resulting token.\n. @warlock39 I hope you can give the same kind of feedback again. That would be appreciated since it helps getting better results!\n. @warlock39 Did some more commits. Could you have a look?\n. Maybe @juliangut can review too, since he has done quite some work too for this library. Hope he does not mind embedding him in this message.. :)\n. @alexbilbie Have been working on this PR today. To summarize what I have been doing.\n1. Only pass a ServerRequestInterface and a DateInterval to a grant type. It should a return ResponseTypeInterface, not also receive one as parameter.\n2. I extracted some code from the grant to a ResponseFactoryInterface. A response factory is injected into the grant type and could be seen as an object that shares code among the grant types that is related to the response.\n3. A default ResponseFactory is included and receives as RendererInterface and a AccessTokenConverterInterface. This encapsulates the default response behaviour as you have defined it in the library: jwt for tokens and html for auth and implicit codes. One can inject its own renderer or access token converter. JWT and the corresponding library lcobucci/jwt is abstracted this way.\n4. Someone that does not use a renderer, e.g. because only password grant is used, can inject a NullRenderer to the default ResponseFactory.\n5. Someone that does not want html but rather returns json to auth code or implicit grants, because they use a SPA, should create their own implementation of GrantTypeInterface. It took me a while to think about this. But it is logical. AuthCodeGrant is implementation of a grant type so it defines how to process a request. If you want to define other behaviour, you should change the implementation. Hence @Bobselp and @warlock39 should create their own GrantTypeInterface implementations for their json responses.\n6. There is no more CryptTrait. There is now a MessageEncryptionInterface. This allows people to their own encryption mechanism and/or own encryption library, e.g. libsodium.\n7. BearerTokenResponse and BearerRedirectResponse are now unaware of a JWT token. They receive an access token converter.\nI also changed the examples as you have requested. However, I did not test the examples. Hopefully you like what I have been doing. Of course, I am open for changes and discussion. \n. Yeah, I could, but that would mean I would change the CryptKey in an backward-incompatible manner. Would you allow that? As in a revert of a PR + better fix?\n. @alexbilbie This is weird. I do not see the commit in the commit tree of the master, but this PR says it is merged. What happened?\n. @alexbilbie Thanks for the clarification. I hope things are implemented using interfaces rather than traits. One should only use traits as implementation of an abstraction not as the abstraction itself.\n. First save access token\n. First save refresh token\n. No, I am going to change more. I had a discussion with @Bobselp already in #499. The ResponseFactoryInterface should act as middleware for those people that do not want templating.\n. @warlock39 So I am going to extract more of the AuthCodeGrant to the ResponseFactory. I am going to take your suggestion into account.\n. Good suggestion, will change.\n. Requires another interface, but will change it.\n. What do you mean? The namespace?\n. ",
    "CodeFuriate": "@alexbilbie Perfect! I have been waiting for V5 a while. I want to rewrite repository layer to use redis but there was this session concept on the way... \nbtw. you did rly good job on the package !\n. ",
    "tjboudreaux": "@alexbilbie thank you so much for this.  I started using this branch a few weeks ago to get a head start on implementing JWT support in a project I'm working on and it's worked really well for me so far.\n. I am looking at doing the exact same thing.  Thanks @pdrosos for asking this question and thanks @alexplumb for going above and beyond on the answer.\n. ",
    "Bobselp": "I didn't mean to limit the length, but to set a custom length, like 60 characters access tokens. Currently all tokens are 40 characters long.\n. I originally intended to have longer refresh tokens than access tokens, so that they have an easy distinguishable feature. But you said that refresh tokens will be way differently in V5, so I guess this can be closed.\n. Hey @frederikbosch. I looked at your PR #513, and I don't think it solves the issue I have. If I understand it correctly, your proposed way with optional/external templating is to create my own ResponseFactory class, which has custom code for newHtmlLoginResponse() and the other functions.\nHowever, the whole user authentication & app approving still happens in AuthCodeGrant->respondToAuthorizationRequest(). I want this part completly seperated (on my main website!) from the OAuth Server Library. As explained, ideally I would call a method to check that the OAuth request itself is valid. For your PR, this would be from the start of respondToAuthorizationRequest() up until around line 104. Then, I want to do all user validation & app approving by myself, on my own website. After the user is validated, I want to call another method (with a UserEntity I assembled on my own) to finalize the OAuth Request and get the URI I should redirect the user to (line 171 up until the return).\nFor the V5 code, I suggested in the first post here that you could \"toggle\" to the alternative (\"validate the user on your own\") behaviour by checking if a $templateRenderer has been provided to AuthCodeGrant->__construct or not. For your PR, this looks a bit more complicated, since ResponseFactory seems to be necessary, even if you don't want to do any HTML output by the API library.\n. > Basically, you want this library to act as middleware in cases like AuthCodeGrant. You do not only want to inject a different renderer but you want to create a response yourself, right?\nYes, exactly this. This is a better description then my \"stuff that in my opinion doesn't belong in the oauth-server code\". I get that the current way is convenient for some users, however it excludes other people that don't have their website set up the way the oauth-server code requires it, like me and @warlock39. So making it optional would be really nice.\n. Hey @alexbilbie, the new flow looks very good in my opinion, and is exactly what I wanted. Much simpler and gives the developer more options on how to handle user sign in & app auth. Thank you for the fast change!\n. I had the same issue.\nAs a temporary fix, I solved it with a small workaround: getRedirectUri() gets the requested redirect URI from the $_GET parameters, and validates it against the database backend. If it is valid, it simply returns the URI requested, if not it returns nothing. This works at least for the client credentials grant, I havn't tested it for the (two-step) auth code grant yet.\n. ",
    "mosounov": "redirect_uri is required in Access Token Request if Authorization Request had it.\nhttp://tools.ietf.org/html/rfc6749#section-4.1.3\n. ",
    "ciprogrammer": "No. I ended up building a Windows VM for development because this lib doesn't support the sqlsrv driver and the Azure server where the app has to be deployed uses sqlsrv over mssql and I didn't feel like back porting the Windows environments to use the mssql driver. Thanks anyway.\n. ",
    "bobmulder": "Any specific plans on integrating OpenID Connect? I would love to use it ;)\n. Thank you very much @alexbilbie, looking forward to the new release! Good luck!\n. Thanks @alexbilbie!\n. Hi Alex,\nThank you for taking time to answer my strugge ;)\n\nSo your auth server (i.e. the implementation of this library) will issue access tokens (specifically JWTs signed using the auth servers private key).\nThe API clients then use the access tokens as authorisation when calling your other APIs.\n\nCompletely agree, I already got that...\n\nEach of those APIs implement the resource server middleware that you linked to in your question. When the access token in the request is parsed by the middleware a few things will happen:\n- The middleware will check the access token is signed by the Auth server's public key\n- The middleware will then check the access token hasn't expired\n- Finally the isAccessTokenRevoked method on AccessTokenRepositoryInterface (that was passed into the ResourceServer class when you initialised it) will be called to verify the access token hasn't been revoked since it was issued.\n\nI don't get this completely. To be clear, the Auth server is not integrated IN my 3 API's. Lets say I have the following list:\n- auth.myapi.com\n- api1.myapi.com\n- api2.myapi.com\n- api3.myapi.com\nThe cli\u00ebnt should first get his access token via auth.myapi.com, and then could access all of the 3 API's with that access token. The 3 API's should check with scopes if he can access those endpoints, but thats my business ;)\nYou say that API1, API2 and API3 will implement the Resource Server middleware, but that means that they need to load this library as well in the 3 API's? And they need access to the samen database as the Auth server as well? \nAgain, thanks for your help!\nGreetz,\nBob\n. Thank you very much for making this clear Alex! I will try to work something out.\nIf I have any questions, is opening a new issue the right way, or can we set something up with Gitter?\n. Wow, made a mistake there ;P haha sorry!\n. Are you sure it was a mistake @alexbilbie? I am trying to implement the Authorization Code Grant right now, but I really struggle at this point...\n. Pfew :)\n. I do not @alexbilbie. How should I do that? Passing the string of the code query isn't good?\n. Ahh amazing! That did the trick ;)\nThanks @alexbilbie ;) :+1:\n. I am already doing ;)\n. Ah okay. Can you show me an example about how you implement the authorize and access_token endpoints? In my opinion the doucmented ones are too general. I would love to see an example how you implemented them...\nI guess that the Middelware I mentioned can be used for other 'protected' endpoints like login and approve?\n. Thank you Alex. I see you store the authorize request, thats new for me. I did it as follow. \nWhat do you think about this approach?\n``` php\n// Authorize method\npublic function __invoke(ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $server = $this->server;\n    try {\n        $authRequest = $server->validateAuthorizationRequest($request);\n\n        $queryParameters = $request->getQueryParams();\n\n        if(!$this->session->get('User')) {\n            $url = '/login';\n            $url .= sprintf('?response_type=%s', $queryParameters['response_type']);\n            $url .= sprintf('&client_id=%s', $queryParameters['client_id']);\n            $url .= sprintf('&grant_type=%s', $queryParameters['grant_type']);\n            $url .= sprintf('&state=%s', $queryParameters['state']);\n            $url .= sprintf('&scope=%s', $queryParameters['scope']);\n            $url .= sprintf('&redirect_uri=%s', $queryParameters['redirect_uri']);\n\n            return $response\n                ->withStatus(302)\n                ->withHeader('Location', $url);\n        }\n\n        // Once the user has logged in set the user on the AuthorizationRequest\n        $authRequest->setUser(new UserEntity());\n\n        $client = $authRequest->getClient()->getIdentifier();\n\n        if($this->isApproval($client)) {\n            if($this->approvalIsTrue($client)) {\n                $authRequest->setAuthorizationApproved(true);\n            } else {\n                $authRequest->setAuthorizationApproved(false);\n            }\n        } else {\n            $url = '/approve';\n            $url .= sprintf('?response_type=%s', $queryParameters['response_type']);\n            $url .= sprintf('&client_id=%s', $queryParameters['client_id']);\n            $url .= sprintf('&grant_type=%s', $queryParameters['grant_type']);\n            $url .= sprintf('&state=%s', $queryParameters['state']);\n            $url .= sprintf('&scope=%s', $queryParameters['scope']);\n            $url .= sprintf('&redirect_uri=%s', $queryParameters['redirect_uri']);\n\n            return $response\n                ->withStatus(302)\n                ->withHeader('Test', 'Joop')\n                ->withHeader('Location', $url);\n        }\n\n        return $server->completeAuthorizationRequest($authRequest, $response);\n\n    } catch (OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    }\n}\n\n```\n``` php\n// Login method\n public function post(ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $server = $this->server;\n    try {\n        $authRequest = $server->validateAuthorizationRequest($request);\n\n        $body = $request->getParsedBody()['data']['User'];\n        $username = $body['username'];\n        $password = $this->userResource->hashPassword($body['password']);\n        $user = $this->userResource->getForCredentials($username, $password);\n\n        $queryParameters = $request->getQueryParams();\n\n        if (is_array($user) && $user !== false) {\n            $this->session->set('User', $user);\n\n            $url = '/authorize';\n            $url .= sprintf('?response_type=%s', $queryParameters['response_type']);\n            $url .= sprintf('&client_id=%s', $queryParameters['client_id']);\n            $url .= sprintf('&grant_type=%s', $queryParameters['grant_type']);\n            $url .= sprintf('&state=%s', $queryParameters['state']);\n            $url .= sprintf('&scope=%s', $queryParameters['scope']);\n            $url .= sprintf('&redirect_uri=%s', $queryParameters['redirect_uri']);\n\n            $response = $response\n                ->withStatus(302)\n                ->withHeader('Location', $url);\n        }\n\n        return $response;\n\n    } catch (OAuthServerException $exception) {\n        return $exception->generateHttpResponse($response);\n    } catch (Exception $exception) {\n        return $response->withStatus(500)->WithJson($exception->getMessage());\n    }\n}\n\n```\n\nThe approve method has the same approach as the login method.\n. Thank you for your suggestion! Can you give an example of that piece of code? I guess you're using the Middleware in that case?\n. In that case I question myself why you should add the redirect_uri in the request if you should add it to the client...\n. Oh I get it! Didn't know that it could be an URL as well! Thank you for making this clear Alex!\n. In fact you should implement all given repository- and entity interfaces and put wordpress-like queries in it...\n. Any documentation about this? :)\n. Sorry for interrupting, but what's wrong with the fact all access tokens would become invalid on the new version? Everybody needs to authorize again to gain a new access token... Thats all... Right?\n. You're right @xiehan, Good luck!\n. \n",
    "pounard": "I am actually using the https://github.com/thephpleague/openid-connect-claims component in custom code, it's working fine considering it doesn't do much yet, nevertheless it did saved me some time, thanks.\n. Hum, it's only a matter of pure brain logic, whereas your object works considering that PHP spawns and dies at the end of the request, it's OK, but if you want to use it with, let's say, something like PHP-PM (using ReactPHP) then it's not gonna work. I think that the various enabled grants are software configuration (in my very own case dependency injection container configuration) - and should probably not be mutable this way, it shows a design flaw.\nIt was weird the first time I read the code because I didn't know if it was a real feature to remove the grants from the authorization server or not, I think that code understanding and readability should win over other considerations especially with something as complex as OAuth2.\nAnother possible implementation is a simple foreach() in the end :)\n. Done https://github.com/thephpleague/oauth2-server/pull/621\n. I did override this method actually to work-around the problem, but I can see another place where it might be a problem: the completeAuthorizationRequest() method.\n. I found another wrong behavior with that, in the AuthCodeGrant::validateAuthorizationRequest() implementation for example:\nphp\n        $client = $this->clientRepository->getClientEntity(\n            $clientId,\n            $this->getIdentifier(),\n            null,\n            false\n        );\nBecause I did overridden the component to support OAuth 2.0, I had to change the identifier to this in order to avoid conflicts:\nphp\n    public function getIdentifier()\n    {\n        // This does not exists, really, but it will work gracefully since when\n        // this parameter is used, the original AuthCodeGrant implementation\n        // can respond\n        return 'openid_authorization_code';\n    }\nThen my own client repository implementation gets openid_authorization_code as grant type instead of code and boom, it explodes.\nI am going to override the problem by temporarily convert openid_authorization_code to just code within the repository implementation, so that I don't have to patch your code, but a more pragmatic approach would be to split the getIdentifier() into two methods: getIdentifier() and getGrantType() methods.\nWould you accept a PR that does that?\n. While I do agree, they are basically only value objects, and repositories in my case are the objects where the logic is implemented into. I mean in the end, you already provided 99% of the code with traits, why not giving the user directly the working class ?\nNevertheless I do understand and respect your point of view, thanks for answering.\n. Yes, exactly what I saw a few minutes after I wrote this. Thanks for answering anyway :)\n. Yay ! That's exactly what I do need, I had to extend the BearerTokenResponse and rewrite almost everything to achieve what I needed.\n. For your information, I am susceptible to having the same problem soon, but I am not using the middlewares (I actually can't because I'm working with a Symfony application embedded into a Drupal, yuck) so I had to write my own access checks helpers, following the middlewares code flow. Maybe trying to write your own you may find a way to fetch the decrypted JWT token at some point and get the original data that was set into ?\n. Actually this might not be necessary, I am using it with Symfony, but the sensio-extra-bundle already provide automatic request/response conversion to/from PSR7, and it's working nicely without any additions. You just have to type your controllers with Psr7 interfaces instead of Symfony's Request class.\n. I guess this is OpenID Connect 1.0 actually, https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims\n. I had the same surprise as you, but hopefully for me, as opposed to your use case, Symfony does provide a transparent conversion layer using the Sensio extra bundle.\n. I don't see any valid reason to split, since the access token implementation is a the discretion of this repository and all those methods are finally tied together, splitting it does not seem to make any sense at the domain language level. This was my 2 cents, I surely might be wrong.\n. Yet, this is not OpenID specific, but the RFC doesn't opiniate about what exactly is the code, wouldn't it be useful to provide a repository interface for this, for which the default implementation would be to crypt/uncrypt ?\nI'm not that comfortable with extending the API, I'd like my future updates to go smoothly :)\nIf the idea's of adding another repository + interface + default implementation is OK for you, would you potentially accept a PR ?\n. Actually I found a way better solution, I am overriding the CryptTrait to something that instead of crypting will load and save into the database.\nThis probably would worth an injectable component using an clean interface for this instead of the actual trait, so wouldn't have to actually extend the grant implementation in order to override the trait itself.\nIt would also be cleaner and easier for unit testing, and also for integrating for such use cases.\n. Good news, thanks.\n. Beware that changing array_key_exists() for isset() also changes the behavior: array_key_exists() will return true when value is null, whereas isset() returns false if value is null.\nFor security concerns, you should ensure that it does makes the check being too loose and that the behaviour remains the same.. @dmelo Yoda conditions are good ! I do not always respect standards when it is for readability or safety :). I did do a complete Symfony 3 integration, but on a client/proprietary project, I cannot share any code. As @simonhamp stated, every bit of the implementation is tied to the client's business.\nFirst step in doing this is to provide services to your container the right way, but sadly a lot of this library's components are not stateless, and you should not share them in the end, but because PHP dies with the end of the request, just putting everything in the service container do work, even if it's not really future proof.\nYou will need a few compiler passes if you need it to be configurable.\nSecond step is implementing your own repositories. Scope and user repositories will be heavily coupled to your business so it's not easy to share or would probably be counter productive to attempt to make it generic.\nClient repository, in the other side, may be quite generic, but its implementation will vary depending on how you need clients to be registered (by users themselves ? by an admin ? hardcoded or by configuration ?).\nThird but optional step is to implement repositories for various access codes and tokens, but this is only if you wish to get rid of the JWT token. I had to for technical reasons because one of the consumers had HTTP header size limitations, JWT were way too big.\nAnd last, but the bigger and harder step, is implementing correctly the controllers, and once again, it'll depend on your business, on how you wish to build the various screens, etc...\nI'm not sure a generic implementation is really possible.. ",
    "strietzel": "@alexbilbie, first of all thanks for your great enthusiasm. Is there any progress on OpenID Connect implementation you can report?\n. ",
    "qrazi": "Also curious about this... Any progress? Any roadblocks? Any specific help needed? (just started reading up on OpenID Connect yesterday though... ). ",
    "steverhoades": "I added support for OpenID Connect on top of this server here: https://github.com/steverhoades/oauth2-openid-connect-server.  If there is any interest I would be happy to help adding this functionality to the library proper.\n. ",
    "dimvic": "@alexbilbie, thanks for a very nice OAuth2 implementation :) do you have any plans & time for OpenID Connect?. This is an implementation detail. In the authorize pages, if your server is private you might redirect back to the client's site and ask your clients to be prepared for that, but normally you would show an error to the user saying something in the lines of \"something went wrong and you should contact the client\", together with a link for them to go back where they came from. You don't want to do that in a public server implementation though as this kind of behavior would not be expected by clients and users might be shown irrelevant messages (or even nothing at all) when you send them back.. There is an example, look it up:\nhttps://github.com/thephpleague/oauth2-server/blob/master/examples/public/api.php. ",
    "wdalmut": ":+1: . ",
    "janzankowski": "+1 for this feature. ",
    "nicolassing": "Hello @Sephster, Have you started to work on this ? I'd like to start working on it :)\n. ",
    "filips123": "Is there any progress? When will OpenID Connect be implemented?. ",
    "loganto": "Currently PHP ecosystem has no thought through and maintained OIDC library. \nTo the point that I seriously have to consider using python|node for my current work task which is very sad.. @sergeyklay \nSo according to your schema:\n\nclients have scopes and grants  \nusers can also have scopes and grants  \n\nIm a bit confused why would user accounts need grants and scopes directly without clients registered? \n. @Sephster im a little confused by the schema that as provided by sergeyklay: http://vpaste.net/lQmK1   \nWhat's the use case would there be for these tables?\nclient_grants, client_scopes ?      \nuser_grants, user_scopes?\ngrants & grant_scopes ?\nLike i'm trying to think where would thee be useful in my app and I just cant... are those supposedly should be used for some ACL approach?\n. ",
    "podisto": "This is your tutorial http://alexbilbie.com/2013/02/securing-your-api-with-oauth-2/\n. @alexbilbie ok thanks finally i used http://bshaffer.github.io/ documentation to implement OAuth2 process\n. ",
    "zstergios": "There is no way to install the examples. I'm trying to download them via \"zip\" or directly from composer\ncomposer require league/oauth2-server but the \"example\" folder is not included somewhere. Can you give more information how I add the example file in my \"vendor\" folder? (I'm using Slim 3.0)\n. ",
    "jpkleemans": "@alexbilbie Thanks for your answer! Wouldn't it maybe be nice if the HTTP part of the package would be extracted into a seperate package on top of a more flexible 'core' package? So that users get the freedom to choose which Request/Response implementation they want to use (also those not implementing psr-7).\n. @alexbilbie personally I would like to use my own HTTP Request/Response classes to handle the request and then for example manually issue the access token by calling something like $passwordGrant->issueAccessToken($username, $password).\nSo your package does everything I need, but I just prefer to have a bit more 'control'. Besides that I think it's generally a good idea to separate HTTP stuff from business logic.\n. @alexbilbie ok, thanks. I'm looking forward to v5!\n. ",
    "mtangoo": "@alexbilbie dropping Httpfoundation for PSR7 was good except I cannot find standalone libraries yet for PSR7. So whats alternative library for those of us who want to use your  library and don't want to be hooked to any framework (infact I have home grown \"framework\"). \nAm currently using http foundation but will be happy to move to any decent php Request/Response PSR7 library\n. Thanks. I'll check it out \n. @alexbilbie Am sorry for asking something unrelated to Oauth but confuses me.\n\nI use Zend/Diactorus for PSR7 requests and responses\n\nI have checked it out and see it implements the PSR7 fine but it is lacking a lot of methods compared to symfony's component. That is fine since its goal isn't that. Can you advise a way to use both symfony's httpfoundation and Diactorus when using your library?\nWould you recommend using something like Http Message Bridge what warning if any would you give someone who decided to use this one?\nThanks in advance!\n. Thanks a lot \n. >passport response The resource owner or authorization server denied the request\nI would suggest you start with laravel/passport then when you confirm it is indeed this library you then open new issue with details. Refresh Token is a token that you send to get new access token if Oauth2 server supports it. For example if your access token have expired and you have refresh token that is still valid you can use that to get new and valid access token without going thru full grant process (like Auth Code or Password...)\nI don't get what you mean about encryption, hex et al so I will skip that for now!. Any news on this? I have mixed app (some using classic Auth Code and some Mobile apps using Auth Code with PKCE). Having leaisure of check for code_challenge as outlined by @sg3s would be nice one. @Sephster \nThank you for your time!. @michaeldnelson,\nNo where in the package you are required to store anything in the database, at all!\nYour implementation depends on your specific use case. Flat file, NoSQL, RDBMS, or no storage? It's up to you.\nUnless of course I have completely missed your question!. Please post the whole code snippet which contains password_verify($clientSecret, $clients[$clientIdentifier]['secret']) \nPlease make your questions help-able by including complete code as to what you are asking.. which version are you using? \nI will test when am at machine with oauth2 code. Last time I checked it was working fine.. > I hope this is a better explanation\nYeah, they are far better ;). @simonhamp \nYour concern is genuine, but I think it goes against spirit of this library of allowing flexibility in terms of \"engine and tires\". A word of warning will suffice for those who want to extends it and if someone extends it without knowing what they are doing, let them shoot their feet!\nI suggest some sort of freedom we have in other things get extended there too!. >we need to help each other improve security and an opinionated stance on the part of widely-used.....Flexibility where flexibility is safe and useful, not just for flexibility's sake.\nThanks for genuine concerns. My point was, putting ability to extend as completely optional and add even a warning that only people who know what they are doing should even venture there. If someone still feels brave to transgress that, then let them shoot their feets for sure.\nAm not against helping people to be compliant. But I really get worried when that ends up crippling flexibility.\nCheers! . :). Password grant does not require client secret \nhttps://tools.ietf.org/html/rfc6749#section-1.3.3\n. https://tools.ietf.org/html/rfc6749#section-4.3.2\nClient/Secret should be sent if the client is capable of keeping secret.\nDid you omit the id and secret and it didn't work? AFAIK it should work fine. I cannot currently verify that myself but I would expect that line since some cases require client/secret.\nThe question am asking is,  is this ennforced?  If it is then it should be logged as a bug. By the way most of the \"engine and tires\" of this library require your own implementation. I guess the same is the case with password grant . https://github.com/thephpleague/oauth2-server/blob/master/src/Repositories/ClientRepositoryInterface.php. Actually the level of trust password grant requires should warn anyone against using it anywhere. I would not recommend it even for mobile apps (Native or otherwise)\nThat being said, the question about enforcement of secret for the grant if indeed it does require it all the times should be addressed . @simonhamp \n\nThere are plenty of valid reasons to use the Password grant, but you will definitely need to send Client ID & Client Secret, so it's impractical to use this for an SPA without some kind of back-end proxy to store your secrets and make requests on behalf of the app.\n\nIs this according to RFC or an opinion of this specific library? As per RFC only grant_type, username and password are required. Scope is optional and there is no mention of client id nor of secret. Since The library tries as much as it can to stick to standard, I would expect at least the client ID/Secret to be optional.\n. @simonhamp thanks for clarification.\n\nBut it's not a requirement of this library, it's an implementation detail. As you said, \"engine and tires\" :) It all comes down to how you implement the ClientRepositoryInterface.\n\nI was under impression that the library as quoted by OP forces that and hence bypassing ClientRepositoryInterface.  Thanks for clarifying.\nI love how this library gives us power, to even shoot our own legs, especially the \"engine and the tires\";). @Sephster @simonhamp and the team, your work in this library is highly appreciated. Its such a Wondeful library!. @Sephster,\nWill v8 come with fix for https://github.com/thephpleague/oauth2-server/pull/817?. That sounds really great! When you think you are ready please open PR so that  I can help testing or if you need any input. Good work as usual!. I see you have a point. Since I can't fault your arguments, I'll close this one. \nThanks for clearing out my double . Hi @sephster,\nSorry for not being clear. \nThe flow is, app X gets access token by Auth Code for example. But app Y by same dev in same machine as X Should not require to take user thru login (given that user have previously approved X and Y for same scopes) \nSo Y needs only to verify access token  aqcuired by X and if valid it will continue using it.\nY will send the token somehow to Oauth server to verify the token and hence my question on how to do it properly with this library. \nIf am not clear let me know . Note that X and Y are two different services accessing resources from different servers. Thanks @simonhamp for great piece of advice. I think it have enough of problems to be avoided completely without much advantages. I'll think another way out that will keep Oauth intact . >I feel that the \"right thing\" to do here is not give the developer the ability to turn on some development-only insight and thereby open the door to accidentally leaving that on in production.\nAm not sure how other implements it, but my implementation which is Yii based, catches that exception, logs important stuffs and presents user with a generic message. Those detail can even be bundled as an exception hint if you still care for those who don't catch exceptions (which shouldn't be the case. It is developer responsibility to catch exceptions and do something)\nAnother way would be emitting an error Event with clear data of what happened. I see it is emiting the request, but that need one to dig the code. Emiting the actual error then the request will help a lot in logging, for those of us who care about it.\n\nHave you tried building the request in a generic HTTP client such as Postman? This usually helps me to figure out where I'm going wrong because I can more easily see what's missing from the request. \n\nWhat do you think of that?\nAs of the issue itself, I found the issue after (carefully) putting var_dump in the error and found client was sending wrong URL. Digging deeper, there was test config that was overriding the live parameters. So the problem itself is fixed, Thank you.. >Basically, the only required detail for the response is the actual error (in this case invalid_client) and that's what this package allows you to supply in your response when handling the exception.\nAre you implying that somewhere in my implementation I can get the actual error?. > If you still feel that there is more needed from the library, please feel free to open a PR.\nI still believe that adding actual error will benefit developers, with a little cost (that am not sure if matters anyway as they are only invoked in case of an error). But opening a PR at least should have a guarantee that it can be discussed. If adding that is beyond what is acceptable, then opening PR becomes waste :). Am not sure I understand your problem. But the library gives you power to do anything you want.\nDid you face a specific problem?. Great step ahead. Thank you @Sephster . I have seen many application use 0 as indefinite time. I would like to table this too for this specific use case. Set time t for specific expiry or 0 for non expiring\n. Yes, we have implemented it in our projects with no problem. You have to start with documentation of different interfaces (assuming you already know Oauth2). which grant do you want to be available?. >Is it possible to have some endpoint on the auth server which would be able to validate the tokens that way. So the middleware on the resource API would actually make a request to the auth API via an endpoint instead of directly querying the auth DB.\nI do create my endpoint and do it separately as My resources are always separate from the Oauth server. So +1 for Server inbuilt API endpoint!. Read the RFC and sounds straight forward. Follow this library norms doesn't it mean new IntrospectionRepositoryInterface and IntrospectionEntity will be needed the former having method like IntrospectionEntity validateToken(....)?\nI would be happy to write the code if I get correct guidance.. @Sephster multiple of course!. >Ultimately, as this isn't in the spec, we haven't covered this scenario. If it is an issue for implementers, I would expect this to be resolved in their implementation as I don't imagine this will affect/concern most people.\n@Sephster I understand that. My concern was that if two tokens have exact same permission and client. I wanted just to get opinions here of what others do. My default setting have been to leave them as they are, but as am refactoring different things I though I should re-visit this too.\nMy first though was check if token with equal scenario, client and user exists and zap it off before saving new one. But then I wanted to gather opinions let I shoot myself!. Sorry if I wasn't clear of what am asking. Asking is a difficult art :). >If I were implementing the system though, I wouldn't be too concerned with this scenario. Instead, I would be asking why the client has requested an identical token when it already has a valid one. It seems more of a client issue than a server to me.\nYou are correct. But sometimes its hard to control clients for such things as this. Some app (may be due to incompetent of its developers or just ignorance of Oauth2) requests new token at each user visit. They don't care of refresh token at all.\nI think I will stick to standards and let such user shoot their leg and help them heal (kidding)\nThanks for your valuable input!. ",
    "martynbiz": "OK seems I had to add the following to .htaccess\nRewriteEngine On\nRewriteCond %{HTTP:Authorization} ^(.*)\nRewriteRule .* - [e=HTTP_AUTHORIZATION:%1]\nMy bad :)\nhttp://stackoverflow.com/questions/11990388/request-headers-bag-is-missing-authorization-header-in-symfony-2\n. ",
    "isaaciss": "I had the same problem but using JWT. I've sent the Authorization Token in Request Headers but it wasn't showed when I used Symfony method $this->getRequest()->headers->get('Authorization'). I changed my apache2.conf -> Directory /var/www/ to \"AllowOverride All\" and now everything is fine.. ",
    "warlock39": "I have the same issue. I want to render oauth dialog by single page application, instead of render template on server side. \n. @frederikbosch actually, i don't know what kind of problem your PR solves. It slighlty increases readability, incapsulates some details, adds some flexibility, i like it. But:\n- if i need construct JWT with custom data, i can't\n- if i don't need template rendering, it doesn't solves it\n- if i don't want to use JWT, it is hard to replace with another implementation\n- according to oauth spec, refresh token is optional, but it is hard to disable\nSome of statements may relate to original implementation, yes. \n. I can't reproduce it anymore. I guess there were problem with composer cache or so.\nThank you for reply. \n. @frederikbosch commented PR. Not so global, but i hope it will help\n. How does it allow to append custom data to JWT? As i can see, it doesn't. Or?\n. Does it allow to use JSON representation as response? Or XML? This method forces me to render html on backend side. It would be great to use strategy here or so. API could look like:\nreturn $responseFactory->newLoginResponse(\n    LoginData($loginError, $postbackUri, $request->getQueryParams())\n);\n. To reduce number of arguments (and copy-pastes between each grant) $postbackUri can be moved to ResponseFactory and instead of passing $request->getQueryParams() we can pass just $request\n. getToken() is the method of Lcobucci\\JWT\\Builder, so it should not be exposed to client code (because Builder is internal dependency of AccessTokenConverter)\n. I am not sure, but it seems DTO is redundant \n. ",
    "tigrang": "@frederikbosch having a method on the repository class is what I had in mind.\n. ",
    "assembledadam": "Great, thanks. So I will store the JWT in a cookie over a secure connection.\n- What would be wrong with letting the refresh token do its thing rather than pre-empting and refreshing it? Or rather, what advantage does it give me to pre-empt it?\n- In order to maintain the state of the user, I also need to store their ID in the JWT.  I'm guessing the provision for this exists in the lib - as you've got a User entity with an identifier. Presumably the User ID here is the sub/aud fields in the JWT payload?\n- Assuming that's right, Unless I'm missing something, I don't need any kind of persistent server-side state tracking the app's users - which would be lovely:\n  1. Grab token from cookie and place it in the request header\n  2. Run the validateAuthenticatedRequest(), do any refresh actions deemed necessary (or not, if I just leave it for the refresh token and your lib)\n  3. Extract the User ID from the JWT token (either via one the oauth libs methods if I can find one or failing that, manually)\n  4. If the User ID > 0, they are logged in - grab their user info, and using that determine if the scopes associated with their user group have permission for this requested http method/route.\nDoes that sound doable?\nPS. Hope Tokyo is treating you well :)\n. Also on a side note, I'm playing around with the lib - i've generated a token using the password grant, and then I'm using that token to access a protected resource.\nThe thing is, the expiry time of the issued token (exp field) is in the past, but it's still letting me through.\nIsn't validateAuthenticatedRequest() within ResourceServerMiddleware supposed to pick that up and deny the user?  Or do I need to implement my own code to detect expired tokens?\nThanks!\nEdit: looking at the code for oauth2-server - BearerTokenValidator (which uses lcobucci/jwt for validation), there appears to be nothing that validates that the the current time is before the 'exp' value. Only the token is verified, checking the signature, rather than actually validating its 'claims'.  Given this is a requirements when 'exp' is specified in the RFC I must be missing something or this is a bug :)\nEdit2: It's not just my code, in all of the examples the lib doesn't respect the expiry time and allows unlimited access once a token has been generated\nEdit3: Just submitted a PR that fixes the token expiry issue. I'm guessing I'm missing something here because somebody MUST have noticed this before to get to RC1 otherwise.  3am in Tokyo right now, sweet dreams! \n. Ah, looked through issues but didn't see it. I was using RC2.  Will manually fix for now until RC3 is out.\nRefreshToken example - \nFatal error: Declaration of OAuth2ServerExamples\\Repositories\\AccessTokenRepository::persistNewAccessToken() must be compatible with League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface::persistNewAccessToken(League\\OAuth2\\Server\\Entities\\Interfaces\\AccessTokenEntityInterface $accessTokenEntity) in /Users/adam/Sites/oauth2-server/examples/src/Repositories/AccessTokenRepository.php on line 11\n. FYI it doesn't look like #537 is fixed. Just applied the fix manually and it's still giving me the wrong expiry time.\n. Excellent, thank you! \n. ",
    "sajunafernando": "@alexbilbie Im using the v4 (have not updated to the v5 as of yet).\nIt should not result in a new refresh token if 'shouldRotateRefreshTokens' is set to false i thought?\nOtherwise i do not see the point in having a long lived refresh token i'm afraid, if the refresh token too gets renewed every time.\nI would add a PR to show you what i mean but i cannot find an active branch for V4?\n. Hey @alexbilbie,\nThats all right. I think what needs to happen is as below in the completeFlow of the refresh token grant.\nCurrently:\n```\n        if ($this->shouldRotateRefreshTokens()) {\n            // Expire the old refresh token\n            $oldRefreshToken->expire();\n        // Generate a new refresh token\n        $newRefreshToken = new RefreshTokenEntity($this->server);\n        $newRefreshToken->setId(SecureKey::generate());\n        $newRefreshToken->setExpireTime($this->getRefreshTokenTTL() + time());\n        $newRefreshToken->setAccessToken($newAccessToken);\n        $newRefreshToken->save();\n\n        $this->server->getTokenType()->setParam('refresh_token', $newRefreshToken->getId());\n    } else {\n        $this->server->getTokenType()->setParam('refresh_token', $oldRefreshToken->getId());\n    }\n\n```\nShould be:\n```\n        if ($this->shouldRotateRefreshTokens()) {\n            // Expire the old refresh token\n            $oldRefreshToken->expire();\n        // Generate a new refresh token\n        $newRefreshToken = new RefreshTokenEntity($this->server);\n        $newRefreshToken->setId(SecureKey::generate());\n        $newRefreshToken->setExpireTime($this->getRefreshTokenTTL() + time());\n        $newRefreshToken->setAccessToken($newAccessToken);\n        $newRefreshToken->save();\n\n        $this->server->getTokenType()->setParam('refresh_token', $newRefreshToken->getId());\n    } else {\n\n       $oldRefreshToken->setAccessToken($newAccessToken);\n       $oldRefreshToken->save();\n\n        $this->server->getTokenType()->setParam('refresh_token', $oldRefreshToken->getId());\n    }\n\n```\n. Have you pushed a fix to the V4?\n. ",
    "msimkunas": "I suppose you\u2019re right then, authorization request persistence options are probably beyond the scope of this library.\nI\u2019ve implemented a class that uses the CryptTrait trait for encrypting cookies. It works fine, although I\u2019m considering switching to a database-based authorization request persistence (i.e. storing the authorization request details such as the user ID in a database row and assigning a unique random ID to it which could be later stored in a cookie). What would you recommend?\nUsing the database in this particular case might work, but it does mean that scheduled cleanups need to be in place to avoid cluttering the DB with intermediate request details. \n\nThe cookie stuff from RC1 was very much a hack and shouldn't be relied on going forward.\n\nDo you mean that using encrypted cookies for storing request details is a bad idea in general or simply that it shouldn't be part of this library?\n. > When you say storing authorisation request persistence what do you mean by this exactly? That the user has already approved a client?\nI am referring to the role of oauth_authorize_request cookie in 5.0.0-RC1.\n. Now when I think of it, issuing random (meaningless) session identifiers and storing the actual request data in the database may be a better solution than encrypted cookies for security reasons. This design would allow me to avoid storing sensitive data on the client.\n. I was wondering whether this library would receive more major refactors until a stable v5 is released? The jump from RC1 to RC2 required me to perform quite a big refactoring on my project and I would be interested to know about any plans regarding the schedule of the next stable release.\n. ",
    "ionux": "Sure, here are a few I found:\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/Entity/AbstractTokenEntity.php#L68\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/Entity/ClientEntity.php#L69\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/Entity/ScopeEntity.php#L55\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/Entity/SessionEntity.php#L96\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/AuthorizationServer.php#L84\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/ResourceServer.php#L69\n. ",
    "lookyman": "Thank you for a quick response!\n. Suppose the attacker gets hold of a server's private key..\n. https://github.com/thephpleague/oauth2-server/issues/550\n. ping @alexbilbie\n. Tested it for both and it works. There were mixed mock/mockbuilder tests before anyway. I just unified it to get rid of the deprecated warnings in PHPUnit 5.0.\n. ping @alexbilbie\n. Test incoming..\n. ping @alexbilbie\n. I made those changes purely to be consistent, there were more instances of !$foo than $foo === false in the code, so I changed the latter into the former. Should I reverse it? Also, let me know if you want anything else done differently.\n. Done.\n. I also don't think this is necessary. The library should be framework agnostic, and framework integrations can easily be in separate packages.\n. Sure, I'll look into it asap... @Sephster Rebased on master and modified according to your suggestions.\nAlso, if this ever gets merged, the documentation has to be updated. (just putting that here so we don't forget..). @Sephster Fixed according to https://github.com/thephpleague/oauth2-server/pull/842 and rebased on master.. Sure, go ahead and use whatever you need from this.\nI'll definitely look over your PR!. @alexbilbie Off topic, how is v6 going? Can we help somehow?\n. I have an alternative here with a little less code \ud83d\ude04 https://github.com/thephpleague/oauth2-server/pull/874. @Kingson-de Not just renaming, mainly it changes the return type from JWT's token to a simple string, so users can define their own format.\nEDIT: But you are correct that it doesn't solve the refresh token encoding.. They are needed when you use composer udate --prefer-lowest, but I can address that in a separate PR that I have ready. Thanks!. @simonhamp No problem at all.\nThere really aren't that many changes, the idea is to move the convertToJWT method from AccessToken to ResponseType. Everything else is basically fixing tests. \ud83d\ude04\nI want to create support for Paseto tokens, so the next step after this is merged would be to just write custom PasetoBearerTokenResponse and PasetoBearerTokenValidator and that's that.. Your idea of AccessToken implementing a more generic conversion function would work too, you are right. I missed that solution. However, that would mean that the interface would have to change anyway, so we are still breaking BC.\nMy reasoning for moving the conversion to ResponseType was a case of separation of concerns. The token should IMO be basically a value object holding some data, but a format in which that data appear in the response should be a concern of the response, not the token. I admit that this might be more of an academic reason than a practical one.\nIn any case, the JWT aspect is currently hardcoded in, and I'd like to change that one way or the other. What do you think?. Thank you for your comments and ideas, @Sephster. I will close this PR and prepare another one.\n(As for the Paseto thing, I was thinking of a separate package on top of this one. But we can maybe implement it at some point in the future, possibly after @paragonie-scott submits a proper RFC to IETF - I recall him mentioning somewhere that he wants to eventually do that. In the meantime, we can stick with JWT.)\nEDIT: https://github.com/paragonie/paseto/issues/16 Here it is.. We still need to call that new method from all places that currently call the old one though. Which means adding it to the access token interface, which means BC break if someone doesn't use the trait and just implements the interface.. But sure, I can do that.. I don't really care about the method's name, I am fine either way.\nI would however love to have it without the argument, and set the key in advance, to further separate it from any hardcoded implementation. But I understand if you don't want to go in that direction right now.. Thank you, I love it.. Personally, I don't use the traits at all (with the exception of AccessTokenTrait), and just implement the interfaces. It's all just getters and setters anyway, not difficult to implement yourself.. You could find some inspiration here. AccessTokenEntity, for example. Fair warning though, it's a pretty old code... Oh right, I forgot that we still support PHP 7.0. \ud83d\ude22. Also the weird thing is that I don't get those reported errors locally. I will work on it some more as soon as I have some more time.. You have tabs here instead of spaces.. Sure, no problem.. Done.. Well, PHPStan on level 7 (with the custom AbstractGrantExtension) reports these three errors:\n```\n\nLine   src\\Grant\\AuthCodeGrant.php\n\n273    Parameter #1 $state of method\n         League\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest::setState()\n         expects string, string|null given.\n  323    Parameter #4 $redirectUri of method\n         League\\OAuth2\\Server\\Grant\\AbstractGrant::issueAuthCode() expects\n         string, string|null given.\n\n\nLine   src\\Grant\\ImplicitGrant.php\n\n180    Parameter #1 $state of method\n         League\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest::setState()\n         expects string, string|null given.\n\n```\nThe first one occures here. As you can see, few lines above, we get the $stateParameter from a call to AbstractGrant::getQueryStringParameter() with a null default, which means it could technically result in a null value, because there is no validation that the server request really contains the state parameter.\nThe second one occures here. The AuthorizationRequest::getRedirectUri()'s return type is string|null, and again, we cannot be sure the null value won't be returned.\nThe third one occures here, and is identical to the first one.\nI haven't dug too deep in the code to figure out the necessary validations that would have to be implemented. The easiest fix was to allow nullability in those places, which kept the current behavior intact (since it's all only in phpdocs), and postpone the issue to a later time when it could be dealt with properly.\nIs this sufficient info? I would be happy to improve this PR according to any suggestions you might have.. I'll update it this evening.. Done.. Suggestion: Since we support PHP 7+, we really should move away from docblock typehints to proper type declarations. public function verifyCodeChallenge(string $codeVerifier, string $codeChallenge): bool; just looks so much nicer.. \ud83d\ude0a. Agreed on the project wide thing. If you decide to go for it, I would be happy to help, just send me a message on Symfony Devs Slack or something.. ",
    "MarcinOrlowski": "I am using https://github.com/lucadegasperi/oauth2-server-laravel/ which is using v4.1.5 of your server. I see in changelog Scopes were Storage before but it also looks like the interface is changed as well. Is it worth trying with v4.1.5?\n. ",
    "ismailbaskin": "Is this project follow semver? If so this change totaly break something. Interfaces are kind of promise for developers.\n. It is only convention. Do you want to do I do?\n. applied to Implicit Grant too\n. ",
    "Perni1984": "@alexbilbie: sorry to bother you, but I can't find the corresponding Grant Type for JWT Bearer, neither in the docs nor in the code.\nBasically what I would like my api client (machine) to do is to send a POST request with the following fields:\ngrant_type: urn:ietf:params:oauth:grant-type:jwt-bearer\nassertion: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL3d3dy5teS1jbGllbnQtYXBwLmNvbSIsInN1YiI6Im1haWx0bzp5b3VyZW1haWxAeW91cnNlcnZlci5jb20iLCJuYmYiOjE0NjEzODk3NzEsImV4cCI6MTQ2MTM5MzM3MSwiaWF0IjoxNDYxMzg5NzcxLCJhdWQiOiJodHRwczovL2F1dGgub2ZmaXN5LmF0In0.wg463pTnO5xlNVelnzz7MlAQ-oNkv6lunyJ3TIKWrAxRTonONuPqPk0n6lrizIqap8iqsVALvDrfaLVuPrBWy4HAAjv2mcQwcp0y4d1hFeImMaf-5CwIP_WcGHQrXKCkJtmIDFL4w8rmjbjP85KY0BpU3YiDWaRkRqs09x1G6capMFs0I7ib5FsjZ_-zBHLcXZQmnL9wbfaabxjNLCayVFEFTuqzXE3Mc-_WV2jb2gXbiFzii-DgeMlpqjtQcZb4taDcDM6Izte1DUVW_oQC0nmf8ELk_JFNV4yzNF4PtXjN5AHxsC_ryH8sEzyZwHuQRom_e6I_T3YvVzKYkgjpEQ\nwhereas assertion is the following jwt encoded payload, signed with the private key of the client-machine\njson\n{\n  \"iss\": \"https://www.my-client-app.com\",\n  \"sub\": \"mailto:youremail@yourserver.com\",\n  \"nbf\": 1461389771,\n  \"exp\": 1461393371,\n  \"iat\": 1461389771,\n  \"aud\": \"https://auth.offisy.at\"\n}\nwhat I would like to receive back from the auth server is a response as follows:\njson\n{\n  \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpZCI6IjZkNGNhYmVjODdmODVjNzU3NWU3NjFjMDFlNWU3MWEwYzdiNTliZWIiLCJqdGkiOiI2ZDRjYWJlYzg3Zjg1Yzc1NzVlNzYxYzAxZTVlNzFhMGM3YjU5YmViIiwiaXNzIjoiYXV0aC5vZmZpc3kuZGV2IiwiYXVkIjoiaHR0cHM6XC9cL3d3dy5teS1jbGllbnQtYXBwLmNvbSIsInN1YiI6Im1haWx0bzp5b3VyZW1haWxAeW91cnNlcnZlci5jb20iLCJleHAiOjE0NjEzOTU5NDksImlhdCI6MTQ2MTM5MjM0OSwidG9rZW5fdHlwZSI6ImJlYXJlciIsInNjb3BlIjpudWxsfQ.YNkz76O1cgU_8dU4dwxI-ZWZP0iGMpUaD85cTQuZjNVLQbSx1ofRCbhzzrpV25JuA-SpSPGtvOqUUcsPAafc-gfT2jqVj50absVQ4gLgcikqEE54F-3fkgYgJkcKZyaY5dmS1-I797fRAIHRXsgag5Tp1oppOoH9uxzVBwOUGUESU6_zUiHtGEmy42RM1MM7kncsE9oTh3sxO-H1S11-u7x_G2R0zhCL83KgkPYe6oLnZkw_LYPOsr22T-8OsOu8k0VoUqXWvjwuAnGUXY9BXEZAyWQFplNRE0uxWZ0o5uFXtDUOkpfg48JWS8IYfsMsyNQgtIPFqsTfDGpioFteFw\",\n  \"expires_in\": 3600,\n  \"token_type\": \"bearer\",\n  \"scope\": null\n}\ne.g. a jwt token, signed by the private key of the auth server, which can be used to authenticate against the application servers.\nBasically this is a special version of a Client Credentials Grant but with the validateClient() method rewritten. I just wanted to double check that I do not oversee something, but eventually I could provide a PR for the implementation.\nWith thanks.\n. > A new method on the client repository will be required to generate a hash using HMAC\nI guess this will all be handled by lcobucci/jwt, as HMAC is only needed when the algorithm defined in the sent JWT is HS256.\ne.g. for our specific API use case we are using RS256 as the algorithm.\n. ",
    "Xerkus": "i guess this should be moved to 7.0.0 milestone now. Revoking refresh token immediately is problematic for distributed consumers, central point must exist to request and distribute access tokens and store refresh token. Which makes single point of failure.\nImmediately revoking access token is problematic too, it will cause unnecessary failed requests before new token can be distributed.\n. It is not something i experience. Oauth server is not using this lib.\nI have microservice that receives first refresh token when user authorizes application, then keeps it current and provides to other microservices.\nMicroservices use refresh token to request access tokens independently. Access token is shared between workers and is refreshed before expiry, by single worker that acquires exclusive lock, while rest keep using existing token.\nHypothetically, if there was a chance for high load for that particular external service and if both request and access tokens were revoked on refresh we would have following:\nSome requests will fail every 30 minutes when access token is revoked/expired. Since refresh token is revoked as well, forcing central distribution of tokens, they will fail more often all across the place. That is something undesirable but i can live with. What is really problematic is that token microservice will experience regular rushes of requests for the new token (prefetching new access token is impossible, existing is revoked immediately, right?) which can overwhelm it and make whole thing unresponsive or even bring it down.\nSomething like that. ",
    "darrencoutts118": "@alexbilbie - has there been any movement on this. I am looking to use it with laravel passport.. cc/ @Sephster . ",
    "rleonr": "Not really. For instance, in the password grant implementation example\nfound on your website, you are creating\na \\League\\OAuth2\\Server\\AuthorizationServer called $server. Then you call\nthe method respondToAccessTokenRequest($request, $response);  My issue is\nthat neither the ServerRequestInterface and ResponseInterface are\ndocumented. How can I integrate the $server variable with my\nRequest/Response mechanisms if those details are unknown?\nThanks in advance,\nRicardo\n2016-04-25 5:42 GMT-04:00 Alex Bilbie notifications@github.com:\n\nAll of the interfaces are documented here https://oauth2.thephpleague.com\n(at the bottom on the left).\nThe Slim framework example is purely for demonstration, there's no\nrequirement for you to use it\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/557#issuecomment-214237035\n. \n",
    "carlosmojopicon": "I was using RC1. Updated to 5.0.2 but new problems came.\nAfter solving some namespace changes, I ended up with a Fatal error:  Call to a member function setClient() on null in /vendor/league/oauth2-server/src/Grant/AbstractGrant.php on line 304 when invoking respondToAccessTokenRequest for a client grant.\nIt seems to be due to I didn't implement new getNewToken method from AccessTokenRepositoryInterface. The question is how to do that? Do I need now to generate access tokens by myself? Do I need to implement AccessTokenEntityInterface and all TokenInterface methods to be able to generate and return a AccessTokenEntity within getNewToken method? I'm so confused now with this latest release.\n. My fault, i've implemented it as return $this;. Changed it to return $this->id; and now it works like a charm.\n. ",
    "luke83": "I thought you wanted a specific message for those parameters, parent method handling is more consistent, much better!\n. ",
    "richat": "@alexbilbie , what is your recommendation when user change password?\n. This is great idea. Thanks you very much!\nBut how to revoke their access tokens (good way)?\n. Hi sir,\nI am sorry, I don't know how to use this method in my controller.\n. ",
    "gabrielgagno": "Oh. Sorry for the oversight. I'm looking at the repository interfaces, which I thought I should implement for all classes. I'll try this one first. Thanks!\n. is it possible to make this work without public and private keys? If not, where should the public and private keys be in a client_credentials grant type?\n. Okay. Now I'm on the part where three repositories are there. so should I implement them in three classes, perhaps? then what should I do to register the mysql database I am using for usage in this library?\n. okay. now how, for example, can I set mysql to be the storage choice for both my access tokens and my clients?\n. I've seen in your example files that the client repository has one client which is hardcoded. Can a normal mysql call replace this? How would I do this?\n. Okay I got this. thanks!\n. ",
    "ChrisTitos": "Hi,\nI have the same error. I already urldecode the code. This is the debug output of my codeception test:\n```\n [Redirecting to] https://localhost/?code=ahD2esbfUDIW9EGoBfslHReMJlUvZb1R4A9pxR2g9O0u1yGC3M5HMBIPLhONqq%2BzcBMDYN0Af7l094Qrxd7Zcy6SGi6K6zPfZGMC%2BVQAevimGCs%2FZVmz2momRWvfEp254N80IBF9KPuNkiAQCxa%2B6kr9fGs8A59fE%2BKQ6gwfm5CEa9I2maelG927er%2BtA5zpuRQ5PmXyXx5V2vriISMbVXvzAqavOxYz6pTF4%2FlGeDDz9tFziYqJdeZIon1Uy9HgHavHuqYLgR0E6c2kK8Rzs0zxLhhbNlhEsOEtCn4T443ZH5ofXlxcJGgG2nQGtcRNGsKxl4gsK2AEkAapMWAZb1q4wwDpQMD7GDeKSiAX9VM%2FVrzKIOJwlTm5K3KahX2x6Url1VUO2gcC8fZMhTdNjyJWZHI76GirVFbA5bdHdzn9R7AMk9vy5hbUOBf0jO8N6LQqZWUoXcJCHAzztIrbUGozXgLX0PQQvvxWVlncw7Ybry6%2FYLfIp7o94eNIYQyt\n\nI can see in current url \"?code=\"\nI grab from current url \"/code=([-\\w\\s+%]+$)/\"\nI send post \"/oauth/access_token\",{\"grant_type\":\"authorization_code\",\"client_id\":\"431467018023914529\",\"client_secret\":\"abc123\",\"redirect_uri\":\"http://localhost\",\"code\":\"ahD2esbfUDIW9EGoBfslHReMJlUvZb1R4A9pxR2g9O0u1yGC3M5HMBIPLhONqq+zcBMDYN0Af7l094Qrxd7Zcy6SGi6K6zPfZGMC+VQAevimGCs/ZVmz2momRWvfEp254N80IBF9KPuNkiAQCxa+6kr9fGs8A59fE+KQ6gwfm5CEa9I2maelG927er+tA5zpuRQ5PmXyXx5V2vriISMbVXvzAqavOxYz6pTF4/lGeDDz9tFziYqJdeZIon1Uy9HgHavHuqYLgR0E6c2kK8Rzs0zxLhhbNlhEsOEtCn4T443ZH5ofXlxcJGgG2nQGtcRNGsKxl4gsK2AEkAapMWAZb1q4wwDpQMD7GDeKSiAX9VM/VrzKIOJwlTm5K3KahX2x6Url1VUO2gcC8fZMhTdNjyJWZHI76GirVFbA5bdHdzn9R7AMk9vy5hbUOBf0jO8N6LQqZWUoXcJCHAzztIrbUGozXgLX0PQQvvxWVlncw7Ybry6/YLfIp7o94eNIYQyt\"}\n\n[Response] {\"error\":\"invalid_request\",\"message\":\"The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed.\",\"hint\":\"Cannot decrypt the authorization code\"}\n```\n. This is the code in the test:\n$I->canSeeInCurrentUrl( '?code=' );\n$code = urldecode( $I->grabFromCurrentUrl( '/code=([-\\w\\s+%]+$)/' ) );\n$I->sendPOST( '/oauth/access_token',\n        [\n            'grant_type'    => 'authorization_code',\n            'client_id'     => $this->client->getID(),\n            'client_secret' => $this->client->getSecret(),\n            'redirect_uri'  => $this->client->getRedirectUris()[0],\n            'code'          => $code\n        ] );\nAs you can see in my previous comment, the code I get back is:\nahD2esbfUDIW9EGoBfslHReMJlUvZb1R4A9pxR2g9O0u1yGC3M5HMBIPLhONqq%2BzcBMDYN0Af7l094Qrxd7Zcy6SGi6K6zPfZGMC%2BVQAevimGCs%2FZVmz2momRWvfEp254N80IBF9KPuNkiAQCxa%2B6kr9fGs8A59fE%2BKQ6gwfm5CEa9I2maelG927er%2BtA5zpuRQ5PmXyXx5V2vriISMbVXvzAqavOxYz6pTF4%2FlGeDDz9tFziYqJdeZIon1Uy9HgHavHuqYLgR0E6c2kK8Rzs0zxLhhbNlhEsOEtCn4T443ZH5ofXlxcJGgG2nQGtcRNGsKxl4gsK2AEkAapMWAZb1q4wwDpQMD7GDeKSiAX9VM%2FVrzKIOJwlTm5K3KahX2x6Url1VUO2gcC8fZMhTdNjyJWZHI76GirVFbA5bdHdzn9R7AMk9vy5hbUOBf0jO8N6LQqZWUoXcJCHAzztIrbUGozXgLX0PQQvvxWVlncw7Ybry6%2FYLfIp7o94eNIYQyt\nAnd the code I POST is:\nahD2esbfUDIW9EGoBfslHReMJlUvZb1R4A9pxR2g9O0u1yGC3M5HMBIPLhONqq+zcBMDYN0Af7l094Qrxd7Zcy6SGi6K6zPfZGMC+VQAevimGCs/ZVmz2momRWvfEp254N80IBF9KPuNkiAQCxa+6kr9fGs8A59fE+KQ6gwfm5CEa9I2maelG927er+tA5zpuRQ5PmXyXx5V2vriISMbVXvzAqavOxYz6pTF4/lGeDDz9tFziYqJdeZIon1Uy9HgHavHuqYLgR0E6c2kK8Rzs0zxLhhbNlhEsOEtCn4T443ZH5ofXlxcJGgG2nQGtcRNGsKxl4gsK2AEkAapMWAZb1q4wwDpQMD7GDeKSiAX9VM/VrzKIOJwlTm5K3KahX2x6Url1VUO2gcC8fZMhTdNjyJWZHI76GirVFbA5bdHdzn9R7AMk9vy5hbUOBf0jO8N6LQqZWUoXcJCHAzztIrbUGozXgLX0PQQvvxWVlncw7Ybry6/YLfIp7o94eNIYQyt\nI get the same error when I manually go through the flow, urldecode the auth code (using this for example) and POST it via my REST client app.\n. I tried regenerating the public and private keys, with or without a passphrase. I also tried grabbing the auth code directly from the result of encrypt and using that for the POST request. Also updated to 5.1.\nStill no luck.  openssl_public_decrypt immediately returns false.\n. PHP 5.6\nOpenSSL version:\nOpenSSL 1.0.1e-fips 11 Feb 2013\nbuilt on: Mon May  9 07:30:30 CDT 2016\nplatform: linux-x86_64\noptions:  bn(64,64) md2(int) rc4(16x,int) des(idx,cisc,16,int) idea(int) blowfish(idx)\ncompiler: gcc -fPIC -DOPENSSL_PIC -DZLIB -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DKRB5_MIT -m64 -DL_ENDIAN -DTERMIO -Wall -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic -Wa,--noexecstack -DPURIFY -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM\nOPENSSLDIR: \"/etc/pki/tls\"\nengines:  rdrand dynamic\nOn CentOS 6.7\n. Ok, I found out what was the problem. I turns out I had mbstring function overloading enabled:\nhttp://php.net/manual/en/mbstring.overload.php\nTurning it off solved my problem. \n. ",
    "yukunwu": "finally,it sloved.By this from stackoverflow Guzzlehttp - How get the body of a response from Guzzle 6?.\nphp\n   $token = (string)$response->getBody();\nNow I get.\njson\n  {\n       \"token_type\": \"Bearer\",\n       \"expires_in\": 3600,\n       \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IjMwNDM5NTcyYzY3YjZmMThkMWE1NzQyZjFiYzVmOGI3NDY3N2MyYjg2MjRjZGRmZmFlMTc2MThkNjg1ZGRjZWI4YmYyYzgwZGZjMTJkYmRlIn0.eyJhdWQiOiJmb28iLCJqdGkiOiIzMDQzOTU3MmM2N2I2ZjE4ZDFhNTc0MmYxYmM1ZjhiNzQ2NzdjMmI4NjI0Y2RkZmZhZTE3NjE4ZDY4NWRkY2ViOGJmMmM4MGRmYzEyZGJkZSIsImlhdCI6MTQ2Mzg4NzY5MCwibmJmIjoxNDYzODg3NjkwLCJleHAiOjE0NjM4OTEyOTAsInN1YiI6IjEiLCJzY29wZXMiOltdfQ.NdrnNJYCo5SlhZJ9pepjcRJlsataaAB4YjwWOvZiGfdQ9ienrssVn9XKoV73jmg_m07O8ZEiLiKv7-2WUAedrcnLW8Ep_wZiH9TshQnLjbL5VJkpRRy6AuDDtOD-T2DWkPTODZ50ZIPqkQt2e6JT78G7cZKuxAusNpne8cpVoow\",\n       \"refresh_token\": \"JKWJZf19FwdrRb+UkRnVchkr/YJxJk3A/2h24GTgWlrYwk6i0+tZ+2zikTnABTkWcKbAkTlQPLUEYhyqwn0CUefEK7+OsgWWqxDQJKigjcl3Y9ygpxwxc0kt8eZuZt2pfsTg2i5Z7Lq8LxLhRJVKq88MlxEK35F/ZeZygGvnl+MqOBi8RytqAB862I/Qmg3tzIw7Wykp/reoVOxWuAMS2zyZ7ak9/eTAUOFSz/0ZbQ9aIR6KcmfUsAL96DHmL5VMqyfsbrR/QX8Zt2G7F5wRyAe285Uc5/dRUbVgVD1kSjuZaB1/QNrMGxbgFLnBgvXy2YqsjrW1/ZfURC+LDgnzNXAdyKoIUSqcNSfUFD2WIwYYcDbXkf+zssHe2vOJOHtYjKu+EIoOUfJKrsWDHyiUWFIjrLtk7e2XRn30Tgg1q6vi6AepqemcYMKSVSpIPiNHdG+cfGtH9OY5qSLn7kKWMF12S8maWXkM8G5MosRLJBHf5FKKCENyD/BH5imCwRwr\"\n}\nNow I can send the response to the client,and secure the APIs.\n. ",
    "anshuraj": "@yukunwu Can you share your directory structure? Where did you placed the Repositories and Entities?. ",
    "joseluisq": "Awesome :+1: \nThanks\n. ",
    "TommyBs": "Ah, though thinking about it, I assume the Client Entity would allow me to see what scopes the Client had requested and had been approved by the user, then I could in theory set the scopes on a suitable object somewhere or filter what data the userEntity makes available\n. Thanks, the example just seems to return the input though, https://github.com/thephpleague/oauth2-server/blob/master/examples/src/Repositories/ScopeRepository.php \nBut haven't looked at the docs as well (https://oauth2.thephpleague.com/scope-repository-interface/ )  I can see what I'm meant to do. Thanks for your help I'm finding my way around it all more now. I won't close this issue in case you want to track the copy & paste error you mentioned above\n. Hi sorry for the late follow up to this.\nI've been thinking about this, and there could be cases where either type is allowed to access the same endpoint. Similar to a facebook app where I could query a user endpoint with an app access token or a user access token and the response is different depending on which it is. In your response are you suggesting then that I should just check whether a oauth_user_identifier is part of the request to determine if it's a user or an app token?\nDo you think it would be a security risk to put the 'grant_type' as a parameter in the JWT? Then check this? Would this be tamper proof from outsiders bearing in mind they shouldn't be able to alter the JWT due to the signature? So something like this (Note the set('grant_type')) line\n```\npublic function convertToJWT(CryptKey $privateKey)\n    {\n        return (new Builder())\n            ->setAudience($this->getClient()->getIdentifier())\n            ->setId($this->getIdentifier(), true)\n            ->setIssuedAt(time())\n            ->setNotBefore(time())\n            ->setExpiration($this->getExpiryDateTime()->getTimestamp())\n            ->setSubject($this->getUserIdentifier())\n            ->set('scopes', $this->getScopes())\n            ->set('grant_type', $this->getAccessTokenGrantType()) // Get grant type of token\n            ->sign(new Sha256(), new Key($privateKey->getKeyPath(), $privateKey->getPassPhrase()))\n            ->getToken();\n    }\n```\nThanks\n. ",
    "pmlt": "Well it's very easy, just deny the permissions. Your highlight only runs if the authorization request is approved. If it is not approved, line 336 of the very same file creates an error response that doesn't include the state.\nIf you want, I can submit a PR to fix the issue, I think I have a pretty good idea of how to fix it.\n. ",
    "Frolki1-Dev": "No problem. Now I done this situation\nphp\n$server->enableGrantType(\n    $authGrant,\n    $accessTokenExpire\n);\n$server->enableGrantType(\n    $clientCredentialsGrant,\n    $accessTokenExpire\n);\nI enabled the Authorization first then the Credentials. And I send this to the server \n\nAnd I receive this response\njson\n{\"token_type\":\"Bearer\",\"expires_in\":31535999,\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IlV4UEpRQWZLa0VOd1pJVHVsSjlldFdmSGpIZjU3ZzdNTnhYMXJ6eWIifQ.eyJhdWQiOiJFVWNEcWNRQzZBTjNVVVAzSHZEYTViaFlyQVRwWlVyd0Z0WVV3RXBzNTJrUE1ZSG1rYm1lZHY0dlVOSEx6WDc1Z1ZRQ3I1VW1XNVp6VXpLNSIsImp0aSI6IlV4UEpRQWZLa0VOd1pJVHVsSjlldFdmSGpIZjU3ZzdNTnhYMXJ6eWIiLCJpYXQiOjE0NjYzNTQyNTYsIm5iZiI6MTQ2NjM1NDI1NiwiZXhwIjoxNDk3ODkwMjU2LCJzdWIiOiIiLCJzY29wZXMiOlsidXNlcl9iYXNpYyIsImV2ZW50X2Jhc2ljIl19.aOa63M4eAo3zqo1n6nj-_ESJQfEujpajIn1GAdLRrZdeR9EG4rgbAiIb0dFt7fMjvF2zeE_LCc8HpvOu36i9ynye_ZpKO0d09lMcP_OnVhaHzpzfKasC7lwedh8lw_BzWgtN978CcayusbsDWPQSqINgOKCRSsM04XdGWP_K-hD7aKrBYWURz9QdHi0K5nEskNXdl9zl9drRzqE5bv6Tmn4FafHycrviHjJBEo2H-ZsFF5PZaY_UtOBYcuFrA6_WHVOCIpgnXS_wjCVR8WMFXMCUxVpiIDcCmfQCEGuUkcTgLLVkuCTxbuphjOLJ9Cn218thCLHwg-4DzK2pWdYtsCRcD4sBCxFALaXPp0_XeoaqghGTHkXK1uqat0f7qs4FfK58J3YTTL2aflnTmtm3lzCXobdM0JQnOco_6JpfJ2q4Fx8VDSZw9BNnCwVBIsMrDSJr9oxQw0OBevuqFYyMPnCiGiqO4c6XPiJI1Ucnaq1Q29KRBc7NqGKVY8l9tnbGDPBMRS7_ZK1b6oWJz0_zHurIUpuLvOJfdAmC1Q0rYhPDcJQVGVSKni74cxgVnI7fHvQlbPz338NqZz6mRvw34Vwu853w6aX0KWij83qFDfv9TAnhc3sayCH2JM8HWx5wxRpqjIQzKgCPZ7sAVJ8SE9LTKS0XjKVDYcFAG7Y32EU\"}\n{\"error\":\"unsupported_grant_type\",\"message\":\"The authorization grant type is not supported by the authorization server.\",\"hint\":\"Check the `grant_type` parameter\"}\nAnd this I receive in the header\n\n- Sorry the HTTP status code is 400 and not 500. My mistake.\n. Yes I use version 5.0.3.\n. I research a bit and I found the problem. It's somthing in this method https://github.com/thephpleague/oauth2-server/blob/master/src/AuthorizationServer.php#L178-L197. I'll watch what the problem is.\n. I don't know if it's help you, but I backtrace the code and the output is:\n```\n0  League\\OAuth2\\Server\\Exception\\OAuthServerException::unsupportedGrantType() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\league\\oauth2-server\\src\\AuthorizationServer.php:196]\n1  League\\OAuth2\\Server\\AuthorizationServer->respondToAccessTokenRequest() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\app\\Controllers\\oAuthController.php:81]\n2  Behires\\Controllers\\oAuthController->postAccessToken()\n3  call_user_func() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\Handlers\\Strategies\\RequestResponse.php:41]\n4  Slim\\Handlers\\Strategies\\RequestResponse->__invoke() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\Route.php:325]\n5  Slim\\Route->__invoke() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\league\\oauth2-server\\src\\Middleware\\AuthorizationServerMiddleware.php:56]\n6  League\\OAuth2\\Server\\Middleware\\AuthorizationServerMiddleware->__invoke()\n7  call_user_func_array() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\DeferredCallable.php:37]\n8  Slim\\DeferredCallable->__invoke()\n9  call_user_func() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\MiddlewareAwareTrait.php:67]\n10 Slim\\Route->Slim{closure}() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\MiddlewareAwareTrait.php:116]\n11 Slim\\Route->callMiddlewareStack() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\Route.php:297]\n12 Slim\\Route->run() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\App.php:443]\n13 Slim\\App->__invoke() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\MiddlewareAwareTrait.php:116]\n14 Slim\\App->callMiddlewareStack() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\App.php:337]\n15 Slim\\App->process() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\vendor\\slim\\slim\\Slim\\App.php:298]\n16 Slim\\App->run() called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\bootstrap\\autoload.php:74]\n17 require_once(C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\bootstrap\\autoload.php) called at [C:\\Users\\Frank\\PhpstormProjects\\Bitbucket\\web-api-with-oauth2\\public\\index.php:3]\n```\n. I GOT IT!!!!!!!!!!\nIt's really importent that when we use the Middleware that we no more define this code\n``` php\n/ @var \\League\\OAuth2\\Server\\AuthorizationServer $server /\n$server = $this->container->get(AuthorizationServer::class);\ntry {\n    // Try to response to the request\n    return $server->respondToAccessTokenRequest($req, $res);\n} catch (OAuthServerException $e) {\n    // oAuth exception\n    return $e->generateHttpResponse($res);\n} catch (\\Exception $e) {\n    // Unknown exception\nreturn oAuth2::throwError($res, $e->getMessage(), 999,  oAuth2::ERROR_OTHERS, oAuth2::HTTP_BAD_REQUEST);\n}\n```\nThis code was the 'loop'.\nIt's enough when the Middleware works\n``` php\n// oAuth group\n$app->group('/oauth', function() use ($app) {\n    // Authorize\n    $this->get('/authorize', 'oAuthController:getAuthorize')->setName('oauth.authorize');\n// Access token\n$this->post('/access_token', 'oAuthController:postAccessToken')->setName('oauth.access_token');\n\n})->add(new AuthorizationServerMiddleware($app->getContainer()->get(AuthorizationServer::class)));\n```\nYou should write in the documentation that use only the Middleware or only the respondToAccessTokenRequest.\nYou can close this issue :smiley:.\n. ",
    "fgambino": "It may be wise to version the tokens going forward. Prepend them all with an identifier of some sort. I agree with moving away from file-based keys too. Being able to store the key in an environment variable or database would simplify the setup a lot. \n. @zerkms if the encryption scheme is ever changed again, the library will know how to handle any incoming tokens. If somebody has a long-lived refresh token that isn't versioned, it would get messy trying to figure out how to validate it. \n. ",
    "defuse": "The openssl_private_encrypt and openssl_public_decrypt are asymmetric crypto, not interchangeable with the symmetric crypto in https://github.com/defuse/php-encryption (unless what's being done currently is to use asymmetric crypto as if it were symmetric crypto).. ",
    "jfilla": "No, it is a different exception.\nhttps://github.com/lcobucci/jwt/blob/3.1/src/Parsing/Decoder.php#L36\nGreat work btw, thanks.\n. ",
    "taylorotwell": "Indeed would be nice to have so it can be installed on Laravel 5.3.\n. ",
    "RonRademaker": "Thanks for the quick reply, will look into upgrading later.\n. ",
    "mhayes14": "\nhttp://symfony.com/blog/psr-7-support-in-symfony-is-here\n\nThanks, DiactorosFactory is what I was looking for. However converting requests back and fourth seems a bit unnecessary, I'll probably go with the custom AuthorizationValidatorInterface implementation.\n\nThe long term solution to this is probably adopting some sort of adapter system that can support both PSR-7 and Symfony HTTP objects.\n\nThis sounds good.\n. I'll close this because I've had an answer from the man himself. Comments still welcome.\nAlso, thanks for an awesome library.\n. ",
    "alexplumb": "I recently had this very same problem and ended up building a custom grant type for the social network logins we support. I've attached the grant and interfaces if you want an idea of what needs to be done to make it work.\nSocialProviderEntityInterface.txt\nSocialProviderRepositoryInterface.txt\nSocialGrant.txt\nThe required request parameters are:\n1) grant_type = urn:alex:params:oauth:grant-type:social\n2) identifier = the identifier of the user returned by the social network\n3) provider = an identifier saying which social network it is\nImplementing looks like this:\n```\n    // Init our repositories\n    $clientRepository = new ClientRepository( );\n    $scopeRepository = new ScopeRepository( );\n    $accessTokenRepository = new AccessTokenRepository( );\n    $refreshTokenRepository = new RefreshTokenRepository( );\n    $userRepository = new UserRepository( );\n    $socialProviderRepository = new SocialProviderRepository( );\n// Setup the authorization server\n$this->_server = new AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $this->_private_key_path,\n    $this->_public_key_path\n);\n\n$grant = new SocialGrant( $userRepository, $socialProviderRepository, $refreshTokenRepository );\n\n$grant->setRefreshTokenTTL( new \\DateInterval( 'P1M' ) );\n\n$this->_server->enableGrantType( $grant, new \\DateInterval( 'PT1H' ) );\n\n```\n. Thanks for the quick response, @alexbilbie. Looking forward to it!\n. I was able to figure out a (relatively) simple way to do this by creating new emitter events for successful client and user authentication. Rather than modifying the built-in grants to emit events for successful authentication, I've set up the repositories to be emitter aware instead. \n. RefreshTokenGrant extends AbstractGrant, which uses the CryptTrait trait. As long as you have CryptTrait, you should be able to decrypt things just fine.. ",
    "pdrosos": "@alexplumb thank you for your answer and for the grant code! Your solution is very similar to my idea how to solve it, it's good to know that I am on the right way :)\n. ",
    "iansltx": "Cool. Working on tests now. Just realized that the responseType is a constructor param for AuthorizationServer, and updated the issue to reflect that adding params is (and will continue to be) a two-step process rather than three.\n. Same as what I did in 604: using the header directly (base64-decoding the Authorization header, checking to see whether it's Basic, etc.) rather than relying on the server var that you get for free in standard SAPIs but not necessarily elsewhere, even if elsewhere implements PSR-7.\n. Will have a PR for this later this evening. Code's done. Just need to update docs and add a test or two (everything passes post-changes).. The scenario I'm talking about is basically this:\nphp\ntry {\n    $authRequest = $this->authServer->validateAuthorizationRequest($request);\n    return $this->renderLoginPage($authRequest, $response); // returns a ResponseInterface\n} catch (OAuthServerException $e) {\n    $exceptionResponse = $e->generateHttpResponse(new Response()); // needed to not interfere with rendered response\n    return $exceptionResponse->getStatusCode() === 302 ? $exceptionResponse : $this->renderError($e, $response); // renderError() returns the decorated response\n}\nWhere adding the extra method would allow for this:\nphp\ntry {\n    $authRequest = $this->authServer->validateAuthorizationRequest($request);\n    return $this->renderLoginPage($authRequest, $response);\n} catch (OAuthServerException $e) {\n    return $e->hasRedirect() ? $e->generateHttpResponse($response) : $this->renderError($e, $response);\n}. I'll see what I can do re: test changes later tonight. I want to say the test differences here were due to the lib being on an older PHPUnit version at the time, so I have an excuse for the PR being outdated, but am more than happy to do those quick fixes.\nOnce this is merged in, I'll work on a PR into the docs branch. Sound reasonable?. Fair enough. Ended up a little more strapped for time than expected. Will try and get this...and docs changes...handled tomorrow.. ",
    "xiehan": "@alexbilbie Just want to point out that if your server is not able to handle this kind of encryption of any payloads at all (we're putting it on our backlog but for right now it's just kind of a bridge too far for us, attempting to upgrade from V4 without breaking changes for clients in a very limited amount of time), you also need to subclass AuthCodeGrant and ImplicitGrant and RefreshTokenGrant, because they encrypt/decrypt other payloads. That's quite a lot of subclassing required to avoid the encryption...\n. @bobmulder That's essentially asking us to log everybody out and force them to log in again, and that's not an option for us. We're in the middle of a huge marketing/growth campaign, so anything that might adversely affect our retention numbers is going to be deemed unacceptable. An estimated 5% of users will never log back in again if we log them out, and even for those who do, we'll get complaints as well as a slew of negative reviews in the App Store. We're never going to get management sign-off on that, ever.\nAnd that's just for our in-house apps. We have a bunch of third-party clients with whom we've got legal contracts in place that prevent us from making breaking changes to the API, at least without 3-months' notice, and I'm pretty sure logging everybody out would fall under that category. So this wouldn't fly with them, either.\n. @blacklizard That alone isn't enough -- I don't want to do that without also making sure the refresh token doesn't get saved to the database, as I don't want to fill our database with tokens that are never going to be used. Right now, I've implemented this by persistNewRefreshToken() in RefreshTokenRepository only conditionally saving to the database based on whether the client is whitelisted to receive refresh tokens or not, but that feels incredibly hacky to me. Somebody else working on this code after me is never going to think of looking there for that logic, and we're going to run into problems maintaining this down the road.\nGiven that refresh tokens aren't required by the OAuth spec, it seems to me like there should be a flag either on the AuthorizationServer or at the grant level to turn refresh tokens on/off.\n. ",
    "bpicolo": "For clarity, we did eventually rewrite a bunch of class logic to make this work. It does also require rewriting parts of the relevant grants, it is true, though we had other reasons to do that for integrating with legacy code as well. Definitely possible though.\n. ",
    "tback": "This is related to #442 . ",
    "nrwiersma": "Awesome, great to hear. Thanks.\n. ",
    "simonhamp": "@alexbilbie did Introspection make it's way into v6?. Hi @gitomato, apologies for the very late reply to this issue.\nI understand where you were coming from, but we're trying to follow the spec as closely as possible, so unfortunately there's no scope for a separate kind of error in this scenario. According to the spec, any problems with the client identification should be bundled under an invalid_client error.\nI believe this does make the specific issue of an incorrect redirect_uri trickier to detect during development, but that's actually not a bad thing in case of a bad actor trying to impersonate a client application in production.\nI'm going to close this issue off for now, but if you have any other questions or suggestions, please don't hesitate to open another ticket. Thanks. >This is meant to fix a code inconsistency where AuthCodes and AccessTokens getScopes() method is assumed to be an array of ScopeEntityInterfaces and also an array of strings.\nPlease can you indicate where it's expected to be an array of strings?\nWhile I really do like the addition of a good convenience method, I feel like this ultimately doesn't solve your jsonSerialize problem. If it's to stay, I also believe that getScopeIdentifiers could be simplified.\n\nYour problems around the jsonSerialize function stem from the fact that you're mixing an implementation of it serving one purpose, with a contract for it expecting an implementation for another purpose. From what I can tell, we can't easily solve that from the oauth2-server side without breaking backwards-compatibility and I'm not even sure that we should.\n\nI'd recommend your Scope entity class doesn't directly extend the Cake Entity class or use the Cake\\Datasource\\EntityTrait trait. Simply implement the ScopeEntityInterface and you will have no conflict over the jsonSerialize method.\nThen to connect it to your database without any issues, you can create your ActiveRecord model OAuthScope that doesn't implement ScopeEntityInterface but instantiates and manages instances of the class that does.\nI think this separation of concerns will actually help later on too.\n\nCouldn't getScopeIdentifiers more simply return array_keys($this->scopes)? Where are you planning to use this in your code? If you follow the advice from (1), do you actually need getScopeIdentifiers any more?. I appreciate your reasoning on this. Thanks for continuing to take the time. After a lot of further digging, I feel like I've got a much clearer understanding of the problem.\n\nAll things considered, I have to stand by my suggestion that you should consider separating your ScopeEntity class from your storage mechanism, but I really do appreciate your working through the problem to find a solution that could benefit everyone.\nI've tried working through some ideas, but I haven't found an alternative approach which is as elegant as your solution.\nThere are just a couple of things...\nFirst:\n\nI don't see how this creates a backwards compatibility issue\n\nYour change to TokenInterface will be a breaking change for anyone who doesn't also rely on TokenEntityTrait. This is acceptable from my point of view, but it does mean that this will be a major release, so it could still be a while before it sees daylight.\nSecondly:\n\nYou will find that if this returns more than just the identifier string, the dependent unit tests will fail.\n\nThis may be an issue with my setup, but I couldn't get any tests to fail with a different implementation of jsonSerialize in the ScopeEntity. This is possibly down to a lack of the right tests - @Sephster we should talk about this. Or maybe I'm missing something.\nBecause of this though, I've not been able to quickly replicate your scenario in a predictable way, so the caveat is that I'm still basing my understanding of this on what you've written and not on code.. Interesting issue!\nFirst off, I don't think it should be up to this library to handle the timing of refresh token revocation anywhere... and as far as I can tell it isn't.\nI'm pretty sure that revoking refresh tokens only happens in your individual implementations of RefreshTokenRepositoryInterface::revokeRefreshToken() and checking for a revoked token by your implementation of RefreshTokenRepositoryInterface::isRefreshTokenRevoked().\nIf so, then these are the places where you can implement your grace period, if you choose to. For example, in systems with a job queue, you could register a job to carry out the revocation. (But what if your job queue fails?)\nIf you don't want your revocation to happen until the new access token has been successfully used, your logic will need to be a lot more complicated. (Will you/the next person remember where and why your revocation happens at a distance?)\nI concur with @alexbilbie and wouldn't recommend either of these approaches as they could leave a big window of opportunity for an attacker to get in.\nBut if your use-case makes it impossible to approach this any other way, do what you can to make sure that the requesting client is the same as the one that has apparently previously failed.\nI'm not sure if FitBit are doing anything like this, but given that they've basically announced publicly that you can make replay attacks using their refresh tokens, I'd really hope that they take extra steps to make sure their clients don't fall foul of MitM attacks.\nFor example, consider including an extra unique header challenge with each refresh token request that you can validate server-side and possibly even decode to a specific ID that relates to a client instance. This could in theory be used to limit re-use of a refresh token more than once to a single client instance (IP address probably won't work for this, especially if network switching is the root cause of your problem).\nI think this discussion is extremely valuable and pertinent, especially around the security of consumer access to their own data whilst their mobile. However, I don't think this is an issue for OAuth2-Server to solve, as it depends largely on your own app's use-case, context and circumstances.\nI recommend we close this issue as there likely won't be any development implications off the back of this.. Thanks for sharing the extra detail @mrgrain. Also see comments on https://github.com/php/php-src/pull/2910.\n@louisfisch can you confirm the preg_last_error() code you're seeing when using the RSA_KEY_PATTERN constant? Is it a PREG_JIT_STACKLIMIT_ERROR?\nDoes anyone fancy recompiling their PHP to see if the stack limit size change fixes this issue?. @louisfisch thanks for confirming that. @wysisoft how did you get on?\nMost APIs have a specific endpoint that you can use once the user has generated a token to fetch some identifying details that you can match up with your local user record. You would typically use this association to determine which user should be logged in.\nChoosing what data to share and sharing it is kind of a separate area of concern and not really covered by this library (yet). You probably shouldn't rely solely on data stored in a token, as this may change and it's also not super flexible or private - for instance you wouldn't want to be storing any personally identifiable data in a token.\nYou should definitely check out the client-side version of this project for writing your client implementation, OAuth2 Client. Many OAuth APIs have some basic concept of retrieving user (aka Resource Owner) data after token retrieval, and oauth2-client includes some helpful tools for working with these different methods - making your server support a similar approach could make your client implementation much simpler.\nFurther, a more generalised standard for retrieving user data that is gaining popularity is OpenID Connect. It's a bit complicated at the moment, but it's worth getting to know. This is something we're currently investigating adding into this package at some point.. It's possible that it will be a constant user identifier (probably of the user on the OAuth service), but this depends on your specific implementation. Honestly, you would probably be ok using this if you're in charge of the OAuth server and can be sure that it won't change.\nBut even if you are running the OAuth server, personally I wouldn't rely on this for a couple of reasons:\n\n\nIf you don't sign or validate the signature of access tokens (you should! Google, Microsoft et al definitely are), you could expose your Joomla admin to privilege escalation, e.g. if a 'normal user' were able to modify their token at all, they might be able to replace their ID with that of an administrator giving themselves higher permissions than you'd like. Not ideal.\n\n\nIf your OAuth service changes how tokens are generated or the data stored in them for any reason, suddenly your identifying data may be different and the relationship between your OAuth users and your Joomla users might break, possibly resulting in either no one being able to login or, if they can, creating a bunch of new, empty user profiles (and much user and administrator frustration). Again, not ideal.\n\n\nIMHO, it would be better all round to have a separate and more secure channel for transmitting user data from your OAuth server to your client applications. A separate API endpoint is ideal for this as it keeps the authentication (generating and validating tokens) separate from authorisation (Who is this user? What can they do?).. @lilliesAndRoses as this issue appears to be related to Drupal's simple_oauth library (and also relatively old), I'm going to close it. If you're facing any issues specifically with this library, please feel free to open a new ticket.. @chervand That's nice. I think in most implementations, if the client requests scopes that aren't supported, the server should respond with an invalid_scope error. However, this is really useful for situations where a scope is valid, but for some other reason has been denied (e.g. authorisation).\nAnd as you rightly mention, it follows spec. In fact, I'd go so far as to say that it's worth having in the response regardless.\nDo you fancy making a pull request for this?. @alessandroraffa not yet, but thanks for the suggestion. We'll keep this issue open until we have something.. @chervand @Sephster just been looking through comments on this issue/PR and I think extending ResponseTypeInterface feels like the better option at this stage.\nHaving said that, bundling into a new major release wouldn't be that bad - the fact is there are not thousands of people calling for this at the moment, so maybe we don't need to go to the trouble of extending and checking which interface is being implemented.. I totally agree that we need to improve the documentation. It's quite an undertaking, but I'd like to give it a go.\nA library/package is likely to be overly prescriptive for some, making it kind of useless, whilst also being seen as an 'official' starting point by others, thus running the risk of being overly simplistic and causing more trouble - we wouldn't want production code running off a 'thrown together' demo implementation, but I fear that would happen all too quickly.\nWe have to remember that the main point of this library is to be agnostic to the implementation details, so we should be encouraging implementors to think in this way so that they can create the right implementation for their context and requirements.. @pilotcurler It's very tricky to put anything in the documentation that will give solid examples for specific setups as there is just so much variety from one app to another, but I can see how this is a little tricky to get going. Improving the docs is something we're working on.\nBasically, implementing the interfaces these examples identify will go some way to helping you to write the correct classes (and probably infer your database structure), but the specifics of the structure and functionality implementation is up to you.\nThe documentation for each of these interfaces is on the League site. Please look in the menu on the left under Repository Interfaces.\nIn general, your repository classes are the go-between from the oauth2-server library's functionality  to your application's persistent storage mechanism (in your case, MySQL through Doctrine), so in most cases these will be very specific to your application and not likely found generalised elsewhere.\nI'm not au fait with the particulars of Symfony, but it should be straightforward enough to create these classes. You just need to write a (repository) class for each of those repository interfaces. Then you can reliably pass instances of those classes into the new \\League\\OAuth2\\Server\\AuthorizationServer() as appropriate.\nI know it's not a Symfony implementation, but I'd encourage you to look over the Laravel Passport implementation of oauth2-server as it may guide you in the right direction. The src/Bridge/ folder contains clear and simple implementations of all of the concrete repository and entity classes required by this library.\nIf anyone is prepared to share a Symfony-/Doctrine-specific implementation, I'd be happy to look at getting it added into our examples.. Thanks for offering an answer @mtangoo.\n@raulferras Access Tokens produced by this library are JSON Web Tokens (JWT) and are meant to be able to be unpacked by a token holder so that the token details stored therein can be interpreted. They are only hashed, signed and serialised for safe transport and can be opened by anyone... anyone who knows which hashing algorithm you used. The signature of the token can be verified using the key it was created with to help prove where it came from and to check if the token has been tampered with.\nRefresh Tokens on the other hand need to be reversibly encrypted (in a way that should only be decrypt-able by the token-issuing authority) as they contain sensitive data relevant to the original request that you wouldn't want anyone to be able to forge.\nThis is because Refresh Tokens are effectively a one-time password that can be used to issue a new Access Token using some parameters of the original authentication request without having to complete a full authentication flow.\nWithout this encryption, Refresh Tokens would be useless as a security mechanism.\nGenerally, you wouldn't be decrypting these anywhere other than in the application/server that generated them.\nThe method of encryption used determines the format of the encrypted string, hence in this case the refresh tokens produced by this library (by default) are hexadecimal.\nI hope this answers your question :). I've definitely hit this before and it's definitely been trickier than it needs to be to track down. The commit above fixes this case of it, but I haven't checked for others yet.\nWould appreciate you giving this a test @Jimbolino if/when you get chance.. @Sephster I don't think it matters too much because both of these methods get called inside AuthorizationServer::validateAuthorizationRequest(), so validation is the goal one way or another.\nIf someone happens to use either of the Grant methods separately in their implementation, I feel that having the validation happen in both becomes necessary to maintain compliance with the spec.\nSo centralising the client_id parameter check - even down into the AbstractGrant - may be the best way of handling it overall.. I like the concept. My concern with this implementation is that overriding could make for some unwanted code duplication in a hurry and some unexpected behaviour if you fail to instate the default attributes.\nPerhaps appendAttributesFromToken() can sub out to another method that is used purely for custom attributes, e.g. appendCustomAttributes. The default implementation of which can just return the $request or even be empty.\nThat way you get the defaults pre-/post-appended with room for greater logic on how the custom ones get handled internally and your custom attributes method can be overridden with less danger of unintended side effects.\nThoughts?. @ragboyjr I agree in principle, but I'm keen to get feedback from more implementors on this. It strikes me that it should be one way or the other, not both, but passing only a parsed token around forces writing the logic of extracting the most commonly used claim attributes onto implementors and feels like the wrong move.\nAlso, I'm not yet sure about the implications of lugging around a parsed JWT with the request through all the middleware.\nOne approach I've been thinking of is to simplify the attribute-to-claim mapping to a couple of string arrays, something like:\n```php\nprotected $defaultClaimAttributes = [\n    'oauth_access_token_id' => 'jti',\n    'oauth_client_id' => 'aud',\n];\n// Can be added in a subclass without any function definitions\nprotected $customClaimAttributes = [\n    'custom_attribute' => 'custom_claim',\n];\nprotected function appendAttributesFromToken(ServerRequestInterface $request, Token $token)\n{\n    $claimAttributes = array_merge($this->defaultClaimAttributes, $this->customClaimAttributes);\nforeach ($claimAttributes as $attr => $claim) {\n    $request->withAttribute($attr, $token->getClaim($claim));\n}\n\nreturn $request;\n\n}\n```. >this functionality is probably outside the scope of what a validator should be doing.\nI completely agree and I understand the points you're making, but there's no need as yet to over-engineer a solution. Why not just extract a method that can be overridden in a subclass more easily?. > The class is currently generating a response\nAre you sure? I think what's happening is it's just extracting token claims and adding them to the $request object for easy access during the request pipeline via middleware.\nI do agree that it's still different concerns and definitely needs separating at some point.. I can\u2019t see anything in that spec that suggests that you can\u2019t/shouldn\u2019t use the client_id as the aud. Do you have any specific concern with this @michaeldnelson?. Thanks for your work on this @fetzi! I am not yet up to speed with RFC7662, so will need a bit more time to digest that thoroughly before I can make a full review of this PR.\nBut on first pass, this looks like a good start. I have already spotted a couple of things that I think would need to be addressed to make this solution more complete and ready for release though:\nAs you're primarily reading the data stored in the token, we're missing the opportunity to do some more interesting introspection directly from the repository, which would give us the ability to include username (or other repository-only data) in the response, for example.\nAlso, it's limited just to access tokens at the moment, but the RFC allows for introspection on all token types as well as allowing the client to hint at the token type (via the token_type_hint parameter) it is trying to inspect.\nWe should also think about documentation, as this is a useful feature that I'm sure many implementors will want to deploy and it requires some extra considerations.\nI'm also marking this for Discussion because I think that there's a really interesting twist on this that's not really explored in the RFC: why not use the Token being inspected itself as the Bearer token of the request instead of it being in the body of the request? The authorization server will then be able to tell whether or not the token is valid using already-implemented methods.\nThis also solves a potential issue I see with this RFC. The ability/desire to allow for en masse introspection of many tokens is a bit of a weak link, which the authors sort of acknowledge. If the credentials of any client that has the ability to do this introspection is compromised, it would be open season on finding active tokens, potentially even across many clients if not implemented securely - a nasty single point of failure. I think forcing clients to authenticate with the token they're attempting to inspect goes some way to deflecting this.. I would hold fire until we've had chance to discuss this a bit further.\n\nTherefore I would leave the implementation of a security mechanism (oAuth2 Access Token, HTTP Basic Auth, ...) up to the implementor.\n\nI agree. This just needs to be well covered in documentation - we'd like to help people avoid building na\u00efve implementations that are open to abuse, if possible.\n\nThe usage of the acutal token to introspect is not allowed because the RFC states in section 2.1 that the introspection request is a HTTP POST request that sends the input parameters as application/x-www-form-urlencoded data. Therefore moving the token into the Header is not a good idea IMHO.\n\nI fully appreciate this point, but the fact is this is not a ratified standard as yet, 'only' a \"Proposed Standard\" RFC (like most of the OAuth2 RFCs) and so it's an issue that is still open for discussion among all of us who will be using/implementing against this standard in the coming years, which is especially likely if it is bundled into packages such as this.\nMy point here is for us to engage critical thinking, not simply to implement any and every related RFC that pops up verbatim. Standards should tend to follow implementations and accepted best practice, not the other way around. So we are kind of in the driving seat on stuff like this.\nThis is just my opinion though, weakly held. Happy to see it implemented in whatever way suits and works and ultimately is the safest :)\nI'll pick this up with the other maintainers (in case they haven't already seen this) and hopefully we'll get some discussion going on these points.. Closing some loops:\nhttps://github.com/laravel/passport/issues/491\nhttps://github.com/thephpleague/oauth2-server/issues/579\nhttps://github.com/thephpleague/oauth2-server/issues/641. @lookyman this looks very interesting, thanks for your time and effort in preparing and sharing this with us. \ud83d\ude4f \nFeels like there's quite a lot changing here, so it may take some time to review. Please bear with us.. I agree, but a BC break for some is better than a BC break for all IMHO :)\nThanks for changing that.. Hi @nealoke. I don't think this is an issue with the package or Composer.\nWhat class is ClientRepository that you're trying to load? There's no such class in this package. There's a ClientEntityInterface...\nEven so, you would still need to reference class names absolutely or alias them, e.g.:\n```php\n<?php\nrequire_once DIR . '/../vendor/autoload.php';\nuse \\League\\OAuth2\\Server\\ClientRepositoryInterface;\nclass ClientRepository implements ClientRepositoryInterface {}\n// OR\nrequire_once DIR . '/../vendor/autoload.php';\nclass ClientRepository implements \\League\\OAuth2\\Server\\ClientRepositoryInterface {}\n```\nHope this helps.. https://github.com/thephpleague/oauth2-server/issues/72#issuecomment-374123182. As mentioned in the linked comment, you will need to write the various repository classes yourself, implementing the appropriate interface for each.\nThese repositories should contain your application's logic for storing the various OAuth2 entities (clients, scopes, tokens etc). It's kept abstract to allow for ultimate flexibility in how you choose to store these entities.\nThe examples may help you get started.\nI'm going to close this issue. Please feel free to open another issue if you're having any further trouble with your setup.. IMHO, you're better off sticking to your standard auth methods for users logging directly into your service. The extra step of giving those users an OAuth token will give you unnecessary headaches and add a redundant layer of complexity to your code.\nRemember, OAuth is ideally suited to stateless APIs, especially ones that you want to allow third-party clients to have access to your users' data on their behalf, which would otherwise require the third-party client to store and transmit your users' usernames and passwords.\nYour application is likely neither of these things. It sounds like it's a stateful web app, e.g. you have server-side user sessions that rely on a cookie on the client to identify them in your application. And it's definitely a first-party client that you control, so your trust level around credential storage and transmission should be pretty high.\nSo to get around the middleware issue, you should consider separating your stateful web routes from your stateless API routes. That way you can apply your ResourceServerMiddleware only to the API routes, whilst your web routes allow access only via an authenticated session.. @danisetg This is definitely a Passport query, but I've been using Passport extensively and I can say with confidence that this in no way limits the users that can register via that client and you do not need to create a client for each user.\nIt is simply used as a way to determine which user 'owns' the client application from your side so that you can easily present details to that user about their OAuth client account in your Laravel Passport application.. If/when this is available, implementors should be extra cautious about what they store in the JWT - especially if it's not encrypted - but even if it is, maybe things like email address aren't the best things to be putting inside a token. Use OpenID Connect instead.\nAlso, consider the extra weight that adding new claims will give to your headers - in some cases, larger JWTs could cause unexpected errors.\nPersonally, I would err on the side of keeping tokens slimmer, choosing to add an extra request to your process for less headaches.. @mtangoo I appreciate your point, but I have to disagree. I don't feel that what you suggest is the correct approach. Letting others 'shoot their feet' is one of the factors involved in why there are leaks of billions of people's personal details... we need to help each other improve security and an opinionated stance on the part of widely-used, standards-compliant libraries such as this can make a huge difference on that front.\nFlexibility where flexibility is safe and useful, not just for flexibility's sake.. Hence my original comment \ud83d\ude42 . @leroy0211 This is left up to your implementation. The logic for achieving this shouldn't be too complicated, but it is very dependent on your specific circumstances as it won't be needed/wanted in all implementations.\nHaving said that, if you do come up with an implementation that you feel is quite generic and can be integrated without adding any extra setup on behalf of other implementors, if you can share it, please feel free to submit a PR :). @leroy0211 first of all, it's worth noting that there's no silver bullet here... no one solution will safely guard all of the different areas of your application appropriately - only you are in the best position to determine what's needed, when and for whom.\nHaving simple pieces that function in predictable ways with clear APIs is much easier to get a grasp of. It's also simpler to find pieces that do/do not fit together when you are fully conversant with their interfaces and interactions. OAuth 2 Server needs to stay flexible in this regard.\nFinally, in your specific case, it sounds like something which I've also worked on in Passport which limits certain scopes to specific grant types. I've achieved this with some config and simple middleware:\n```php\n<?php\nnamespace App\\Http\\Middleware;\nuse Closure;\nuse Laravel\\Passport\\Passport;\nclass EnableAppropriateScopes\n{\n    /\n     * Dynamically enable scopes based on the grant type.\n     \n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Closure  $next\n     * @return mixed\n     /\n    public function handle($request, Closure $next)\n    {\n        $enabledScopes = config('passport.scopes.global', []);\n    // Special case for the Authorization Code Grant flow, which requires scopes in Step 1\n    if ($request->request->get('response_type') == 'code') {\n        $enabledScopes = array_merge($enabledScopes, config('passport.scopes.authorization_code', []));\n    } elseif ($grantType = $request->request->get('grant_type')) {\n        $grantSpecificScopes = config(\"passport.scopes.{$grantType}\", []);\n        $enabledScopes = array_merge($enabledScopes, $grantSpecificScopes);\n    }\n\n    Passport::tokensCan($enabledScopes);\n\n    return $next($request);\n}\n\n}\n```\nRegister and use this middleware and create the appropriate config (or hardcode your settings in the middleware itself). You will also probably need to remove any calls to Passport::tokensCan() in your AuthServiceProvider or whichever provider you've been putting your Passport bindings in.\nHope this helps!. As @alex-filat said, your SPA (if it is calling your OAuth service directly from the front-end) should be using an Implicit Grant.\nThere are plenty of valid reasons to use the Password grant, but you will definitely need to send Client ID & Client Secret, so it's impractical to use this for an SPA without some kind of back-end proxy to store your secrets and make requests on behalf of the app.. Thanks @boyd. So I've reopened this for the issue around documentation.. @mtangoo relevant part is in the docs for the section you're referencing:\n\nIf the client type is confidential or the client was issued client credentials (or assigned other authentication requirements), the client MUST authenticate with the authorization server as described in Section 3.2.1.\n\nFollowing this through the spec leads us to Section 2.3, which indicates that client_id and client_secret are required.\nBut it's not a requirement of this library, it's an implementation detail. As you said, \"engine and tires\" :) It all comes down to how you implement the ClientRepositoryInterface.. @aluciffer can you share the request parameters you're setting and the response you get when running it through Guzzle?\nEdit: Sorry, spotted request parameters above. So it looks like you're expecting JSON back from Passport without explicitly telling it to respond with JSON. Try this:\nphp\n$response = $http->post('http://passport:8090/oauth/token', [\n    'headers' => ['Accept' => 'application/json'],\n    'form_params' => [\n        'grant_type' => 'authorization_code',\n        'client_id' => '3',\n        'client_secret' => 'jOf6XcL4yv5WqSAmKwgKaKab6Drx5OJnMcMwp3rw',\n        'redirect_uri' => 'http://client:8091/callback',\n        'code' => $request->code,\n    ],\n]);. @galab-devision-bg can you isolate the json_encode($responseParams) part to see what the output of that is please?. @galab-devision-bg What is your actual code for rendering the response? $response->getBody()->getContents(); ?. I understand, but I can't see the problem being in the generateHttpResponse() method.\nIn generateHttpResponse(), please add a var_dump before the return:\n```php\n$response->getBody()->write(json_encode($responseParams));\nvar_dump($response);\nreturn $response;\n```\nPlease let us know what the var_dump result is here.. So can you change that to var_dump($response->getBody()->getContents()); and let us know what you see?. Interesting use-case... It may be that this highlights a loose adherence to the spec in this area, and this is likely something we\u2019ll address if we/you can.\nHowever, I\u2019m keen to learn more about why scopes are being used in this way in your case because it feels like this could be handled differently/more appropriately using other methods.\nPersonally as a client hoping for a token with the correct scopes (which themselves are presumably not changing as part of the data update), I\u2019d expect no warning about temporary refusal of the scope.\nTypically I\u2019d expect a temporary refusal as the response to the secondary request - the one to perform whatever action it is that\u2019s being locked by the data update.\nWhat happens if someone (who has been granted the scope from earlier before the data update) tries to call an endpoint during the data update? Won\u2019t that be problematic?. I have to say this all feels like it's happening in the wrong place... maybe it works for your use-case at the moment, but I wouldn't be surprised if you face quirkier problems down the line.\nI would definitely recommend moving things around. For example, if you know that certain parts of the data may not be available for certain groups/teams of users for a specific amount of time, give different scopes to different groups.\nStill in your scenario, from the perspective of this library, your logic that's overriding approved scopes (removing the ones that are temporarily unavailable) can't be seen as anything other than a scope being approved or not by the resource owner as there is no method of persistence internally - only via the refresh token.\nFrom that perspective, I'm not sure that this specific case is something we can actually add to OAuth2 Server.\nTo achieve this, you would need to persist the approved scopes separately (probably in a DB record) from the granted scopes (which are encrypted in the refresh token) and then apply your logic in reverse when the refresh token is used, checking to see if any of the scopes that have been approved can now be granted.. You can do that and I'm not saying that you shouldn't.... I'm saying that OAuth2 Server shouldn't - at least not yet.\nThe most solid reason for this is because I believe the majority of folks use scopes in the way they were intended (this is the first mention I've seen of scopes being used in this way): If you can request them and the resource owner granted them, then it's generally assumed that the token you use has them and the refresh token can have them too.\nAnything outside of this is pretty case-specific and should probably be wrapped in a custom grant type.. I don\u2019t feel that creating a new grant type is too onerous or insecure for your specific approach. You may find some methods could be reused and encapsulated differently. Best way is to build something out! :) Feel free to prepare a PR for review. Your input is always appreciated.\nAnd thanks for this discussion too! It\u2019s great to see different use-cases and nice to discuss things with passionate-but-reasonable people.\nI\u2019ve labelled this issue appropriately and will leave it open in case anyone wants to pick up creating an implementation of this.. I look forward to seeing what you come up with.. Thanks for taking the time to submit this PR @marekk, but I can't see the value that this adds over #851.\nIn fact, I think this is actually a slightly more dangerous implementation as it's even easier to override core validation functionality (esp. without some code duplication) and moves the really critical stuff further away from where it's being called.\nIt also causes some potential confusion, as the naming of the methods is very similar while their purpose remains distinct. This feels like a side-effect of trying to work within the bounds of the existing  contract whilst still splitting the code to make it more easily overridable. Your validateAuthorizationHeader is clearly named (if a bit more verbose than necessary), but your amended validateAuthorization is actually just adding claims to the token, not really validating anything.. Understood. From what you've said it seems like this is very specific to your use-case.\nI believe that you would be able to implement an easier fix for your needs if/when #851 does settle on improving how validation and claim extraction is done.. Will do!. Happy to see it all go in to version 8.. Forgot to mention: did some basic tests against Passport and the Basic auth prompt doesn't appear with this fix, it simply responds with the invalid_client JSON. \ud83d\udc4d . @ShyZhen I don't think this is the right approach. fileperms() should still work correctly on Windows systems and this is an important security measure to make sure that your keys aren't accessible by outside parties.\nYou should adjust your file permissions correctly. The desired permissions roughly translate to \"read & write for user and/or group\".\nI'm going to close this PR, but happy to help try and solve this with you if you can share what the value of $keyPathPerms = decoct(fileperms($keyPath) & 0777); is for you.. Hi Alex, please feel free to make a PR for this \ud83d\ude42 \nNote that there are a number of related issues currently open and some PRs too.\nSo it may be that this change makes its way into a bigger release.. You shouldn't attempt to get the user to pass their token around between apps as this is really insecure and one of the main reasons for OAuth's existence in the first place.\nIdeally the user never sees their token.\nBut there are potentially a few ways to tackle your problem:\nShared Client Credentials\nOne approach is to set the OAuth Client ID & Secret to be the same for both X and Y.\nThis is kinda naughty though as it means you've got two apps pretending to be one (from the OAuth service's perspective) and could be a pain down the line.\nAlso, this might require the OAuth service to support multiple callback URLs, so this might not even be a possibility.\nI'm guessing you're in control of the OAuth server too? Where does it fit into this whole picture?\nImplicit Token Sharing\nIf both X and Y are going to stay co-located, then there's no reason why a single token couldn't be used by both apps (as long as that makes legal and moral sense for the user, of course).\nFor example, you could store the user's current access token in $_SESSION and have both apps look at the same session store and session cookie. Or in a shared database record that is accessed via a session cookie.\nThis may be more challenging from the client side, depending on how your apps are distributed.\nFor example, if X and Y are web apps that run on completely different domain names (e.g. xapp.com and yapp.com) you would need to make sure the cookie you use to identify the user with can work across both domains.\nBut it would save a few extra round trips to the OAuth server and arguably won't require any extra validating.\n\nHonestly, I don't really like either of these methods as they're kind of insecure and they create interdependencies that could be the cause of headaches and sloppiness which may make things harder for you and/or your users later on - e.g. still logged into X, not logged into Y. Or, \"we forgot to add a logout\". Or, sessions living longer than tokens resulting in users logged in to app but unable to use that API.\nIdeally you'd use a more normalised approach: have X and Y each being a separate Client of the OAuth-protected services. This has many benefits (for users and devs), but mainly if a user logs in via App X and switches to App Y within a reasonable amount of time, they might only be presented with an auth approval when redirected to the OAuth service, not a login screen.\nThe caveats though:\n- this really only works if everything is web-based,\n- the user is using the same browser to use both X and Y, and\n- the OAuth service stores a fairly reasonable session cookie in the user's browser.. #794 working on this soon :). @mtangoo I agree that it's a bit tricky to spot mistakes in your client auth code...  during development. However, there are really only 5 cases where the invalid_client exception is thrown, so unless you're doing something extra in your implementation, there's not many paths to investigate.\nAlso, the main consideration here is how you want something to behave in production: for extra safety, you wouldn't want to give away exactly what's failing to a bad actor as this will actually help them narrow their attack vectors.\nI feel that the \"right thing\" to do here is not give the developer the ability to turn on some development-only insight and thereby open the door to accidentally leaving that on in production.\nGenerally, this issue will be caused by not passing the correct parameters or values in an auth request. If you can share the actual code that's building the request, I may be able to help further.\nHave you tried building the request in a generic HTTP client such as Postman? This usually helps me to figure out where I'm going wrong because I can more easily see what's missing from the request. Further, eventually you will build up a collection of requests that look right and work well that you can reference in future.. >Those detail can even be bundled as an exception hint if you still care for those who don't catch exceptions (which shouldn't be the case. It is developer responsibility to catch exceptions and do something)\nAgreed! But there's also a balance of what's strictly needed to comply with the spec here too.\nBasically, the only required detail for the response is the actual error (in this case invalid_client) and that's what this package allows you to supply in your response when handling the exception.\nIf you choose to dig into this to provide the optional parameters in your response (e.g. error_description), I think that should be down to the developer and not a responsibility of the library.\nI do believe that it would make things a little easier while developing if the cause of the error was surfaced, for sure. But ultimately it's not much gain for what I see two major drawbacks:\n\nPotential for reduced security (as mentioned earlier)\nUnnecessary extra processing required for cases where someone has typo'd some key detail - accuracy of all of those details should be the first thing to check on invalid_client errors\n\nAs you've stated that this is solved, I'm going to close this. If you still feel that there is more needed from the library, please feel free to open a PR.. ",
    "blacklizard": "@xiehan  why don't you just exclude refresh token from the response? \n. ",
    "filecage": "Couldn't find this in the unreleased section of the 8.0.0 branch so I assume it is not implemented yet. @Sephster do you need any help with that issue?\nMaking Refresh Tokens optional and especially setting their TTL would be a really nice feature.. Yes, that is why I've wanted to make the TTL configurable, so I can set it to forever :) I'm not spec-safe either but as far as I know, refresh tokens do not have a TTL and can only be revoked, not expire.\nHowever I think that having an optional TTL for Refresh Tokens still is a pretty good idea.\nEdit: The spec does not clearly state whether a refresh token can expire or not so I'd say it's optional. However, there is no spec-safe way to communicate an expiry timestamp for refresh tokens. As there wouldn't be a huge difference from a client's perspective (it never knows whether a refresh grant has been rejected due to expiry or revocation), I guess that supporting a TTL for the refresh tokens would be a nice feature while there definitely should be an option to make them permanent.. @Sephster The PHPStan and Style CI checks have incosistent behaviour. Declaring return null; makes Style CI remove the null and making it a void return which is then failing in Travis CI due to PHPStan.\nPlease advise.. I agree, thank you! Changed and pushed.. @Sephster please tell me whether you'd like me to remove the simplified_null_return style CI fixer to make all the checks pass. I have no experience with style CI and cannot tell whether removing it will break anything else.. ",
    "chervand": "\nI started to explore your library recently and i'm not sure whether it can break anything or not, but what about passing a Signer class to the constructor\n\nphp\n$server = new ResourceServer(\n    $accessTokenRepository,\n    $publicKey,\n    new BearerTokenValidator($accessTokenRepository, Lcobucci\\JWT\\Signer\\Hmac\\Sha256::class)\n);\n- Are you going to completely remove RSA keys or HMAC is going to be a default option? Anyway, looking forward.\n- I need it for my current project :), so i'm going to try to extend your lib somehow for that case.\nThank you your quick response.\n. @DewaldBodenstein, I believe, adding it to a League\\OAuth2\\Server\\ResponseTypes\\BearerTokenResponse $responseParams should be enough.. @simonhamp yes, sure. I'm currently working on Yii2 integration and have a DB migration for it (which is not finished though). Would like to hear you thoughts on this.. @syrm, returning null should be ok in this case. Since AuthorizationServer's constructor accepts ResponseTypeInterface instance, it is possible to add such an option to AbstractResponseType. But I think it should defaults to returning scopes, because they are conditionally required and will not cause any issues in most cases. If you agree, I'll update the PR. BTW, I think such change should be documented on how to disable returning scopes.. Please, review the updated PR. Not sure if I should add this to the ResponseTypeInterface due to BC. Maybe adding another interface for that case could be a better solution.. Hi @Sephster, sorry for the delay too. I'm still interested in this feature and I agree that this is an auth server policy rather than a response type policy.\n\nOne potential problem I can see with this is that we would need to call setReturnScopes from the auth server but we can pass in response types that implement the responseTypeInterface. To prevent the risk of calling setReturnScopes on a response type that doesn't have it, we might need to update the interface to ensure all response types implement this feature but this would be a BC breaking change and would likely need to be included in a future release.\n\nI can see 3 possible solutions now:\n1. Update ResponseTypeInterface and leave it for the next possible release.\n2. Add another interface declaring setReturnScopes which should extend ResponseTypeInterface and make default response type implementing this new interface instead of ResponseTypeInterface. Thus we could check whether response type instance implements it before calling setReturnScopes.\n3. Add another interface which wouldn't extend ResponseTypeInterface and make default response type implementing this new interface as well as ResponseTypeInterface. With this implementation we could get rid of setReturnScopes and return scopes if response type implements such interface without breaking BC. However this implementation makes impossible to control it via the auth server.\nLet me know what do you think please.. Agree, this meets the RFC better.. Hi @Sephster @jacobweber. I've already done it for the Yii2 framework integration library. In case you might want it here, I'll submit a PR. . @jacobweber I don't mind :). ",
    "LeonanCarvalho": "I realize that version is 4.1.x\nTo use it through composer is necessary use \"league/oauth2-server\": \"4.*\"\n. Yes, I'm sorry for my misunderstanding.\n\ud83d\ude33 \n. ",
    "parkershepherd": "On further inspection, the definition of isAccessTokenRevoked() is handled by Passport, making this a bug with them, not league\n. ",
    "er0k": "https://github.com/thephpleague/oauth2-server/pull/668\n. ",
    "jeremykendall": "Thanks!\n. ",
    "mrbass21": "If I were to add it, I would put it in between persist and get. \nDo you need to store the tokens? The tokens are data that are encrypted and signed by an RSA key. You don't need to store them, the library can determine a \"valid\" token based off of the oauth_user_id/oauth_client_id and an expiration date that is created when the token is created.\n. ",
    "marcaube": "\nYou should make use of a good database library that automatically handles SQL escaping for you to reduce SQL injection attacks as well as any other good recommendations.\n\nThat's a given \ud83d\ude09, but it won't protect from a lost database backup, an angry ex-employee, insecure legacy or vendor code, or other such scenarios where data can get in the wrong hands. We still want to limit the impact it can have.\nSo I guess my best course of action would be to update to v5, is there an upgrade guide somewhere to go from v4 to v5? Or is it so different that it'd be easier to start from scratch?\n. ",
    "Shkeats": "@alexbilbie as far as I can tell there's currently no way to get a reference to the authcode inside finalize scopes? \n. @alexbilbie It would be useful to have the AuthCode's id to access information persisted alongside the AuthCode when the user was present. \nIn my case, these are details about the state of the user's session at the point in time the AuthCode was made. This factors into the decision about which scopes can be requested.\nCurrently what I'm doing is using the user_id, client_id and scopes to grab the newest auth code that matches those criteria from the table, but this isn't always guaranteed to be the same one.\n. On a related note I think it would also be helpful to give the access token repository a reference to the auth code so that we can persist the relationship between the two without needing to create a custom Grant type.\n. Just a note to say I have seen this behaviour once but I can't reproduce it currently. The browser popped up a basic auth login at the auth server. As I recall it happened during some other misconfiguration of the client or client details.\n. Managed to recreate just now, it's happening in my setup if the client id is set incorrectly. The user get's sent to the auth server and you get a basic auth popup and it says: \"The site says \"OAuth\"\" both on Chrome and Firefox.\n. ",
    "B-Galati": "@alexbilbie @Sephster \nI guess that @jeremykendall meant that as of today it is not possible for a client to have scopes in their properties so it is not possible to validate that one client has the right scope access. This is specially annoying with the client credentials grant (so machine-to-machine communication) where scopes could be a sort of ACL.\nFor example my OAuth server defines scope1 and scope2. One client have access to scope1 so if he tries an auth request (or token request) with scope1 and scope2 the server would not grant access because scope2 is invalid for that client.\nI found another implementation (in Java) where this is possible -> http://projects.spring.io/spring-security-oauth/docs/oauth2.html#configuring-client-details.\nLet me know if this makes sense to or not. Perhaps I am missing something.. @Sephster Small reminder. Please let me know if I am mistaken or something.. @Sephster You're right. it's clearer now. \nThank you for this great answer :-). ",
    "phisch": "It's purely semantic, not really a bug or anything. Currently running a UserProvider that implements the UserRepositoryInterface which works, but isn't nice.\n. Experiencing the same problem, first few chunks can be decrypted, but last chunk fails.\n. Turns out it was en encoding problem for me, the Bearer token was not sent in a urlencoded form.\n. @brutto it's because the encrypted string contains characters like + which have to be url-encoded. Should be base64 encoded or something to prevent that.. ",
    "wilsonge": "Just to add here in response to\nThis makes sense if there's an expectation for the end user to decrypt these tokens, but I can't think of any reason why I would want the sensitive information contained within these tokens to be accessible to anyone with a public key.\nAt the moment the only way for a user to check the expiry time of a refresh token out is to decrypt the token. So with the way the code base in v5 is actually I think it has to be this way around. If refresh tokens change in v6 to be full JWTs then this need goes away because the information is now easily accessible (aside: as this information is accessible it does kinda defeat the purpose you mention of this information being sensitive - this information is now totally public)\n. The library requires PHP 5.5? https://github.com/thephpleague/oauth2-server/blob/master/composer.json#L7. ",
    "halaei": "It sounds that encryption/decryption with public key is 50x faster than encryption/decryption with private key. So maybe that was a performance consideration: for each encryption there can be many decryption, hence the performance of decryption is more important than the performance of encryption.\nHaving said that, I don't know why asymmetric encryption is required.. This was a big problem for our mobile applications. Here is my fix for Laravel Passport implementation:\n```php\n<?php\nnamespace App\\OAuth;\nuse Carbon\\Carbon;\nclass RefreshTokenRepository extends \\Laravel\\Passport\\Bridge\\RefreshTokenRepository\n{\n    public function revokeRefreshToken($tokenId)\n    {\n        $this->database->table('oauth_refresh_tokens')\n            ->where('id', $tokenId)\n            ->where('expires_at', '>=', Carbon::now()->addHour())\n            ->update([\n                'expires_at' => Carbon::now()->addHour(),\n            ]);\n    }\npublic function isRefreshTokenRevoked($tokenId)\n{\n    return ! $this->database->table('oauth_refresh_tokens')\n        ->where('expires_at', '>', Carbon::now())\n        ->where('id', $tokenId)\n        ->where('revoked', false)\n        ->exists();\n}\n\n}\nphp\n<?php\nnamespace App\\OAuth;\nuse Laravel\\Passport\\Passport;\nuse League\\OAuth2\\Server\\Grant\\RefreshTokenGrant;\nclass PassportServiceProvider extends \\Laravel\\Passport\\PassportServiceProvider\n{\n    protected function makeRefreshTokenGrant()\n    {\n        $repository = $this->app->make(RefreshTokenRepository::class);\n    return tap(new RefreshTokenGrant($repository), function ($grant) {\n        $grant->setRefreshTokenTTL(Passport::refreshTokensExpireIn());\n    });\n}\n\n}\n``\nThen I registerApp\\OAuth\\PassportServiceProviderinstead of the original provider.. Mobiles are held by motorcyclists to help them with routing and navigation. Due to the low network quality, it happened a lot that a refresh-token request is sent to the server but the response is lost, which makes the current refresh-token invalid without any new one provided to the driver. Now the driver is logged out of the application and has to re-enter his username & password before being able to use the application again. This is a really inconvenient situation for the driver :(. Your recommendation means not to use refresh tokens. It will certainly work, but if I choose so, what is the point of refresh tokens in OAuth after all? Don't they exist to increase security?. To me it means everyone implementingRefreshTokenRepository::revokeRefreshToken()` by actually revoking the token as the name of method suggests, introduces a bug. Implementations of this package might be unaware.. Not a specific use case really, but some performance considerations. I thought maybe the overhead does not add any specific value to my project.. ",
    "alexandrecintra": "git diff origin/master\ndiff --git a/src/Grant/RefreshTokenGrant.php b/src/Grant/RefreshTokenGrant.php\nindex 17448a9..87059d6 100644\n--- a/src/Grant/RefreshTokenGrant.php\n+++ b/src/Grant/RefreshTokenGrant.php\n@@ -63,7 +63,7 @@ class RefreshTokenGrant extends AbstractGrant\n             // The OAuth spec says that a refreshed access token can have the original scopes or fewer so ensure\n             // the request doesn't include any new scopes\n             foreach ($scopes as $scope) {\n-                if (in_array($scope->getIdentifier(), $oldRefreshToken['scopes']) === false) {\n- if (in_array($scope->jsonSerialize(), $oldRefreshToken['scopes']) === false) {\n               throw OAuthServerException::invalidScope($scope->getIdentifier());\n           }\n       }\ndiff --git a/tests/Grant/RefreshTokenGrantTest.php b/tests/Grant/RefreshTokenGrantTest.php\n  index 90a6327..c657c3f 100644\n  --- a/tests/Grant/RefreshTokenGrantTest.php\n  +++ b/tests/Grant/RefreshTokenGrantTest.php\n  @@ -124,13 +124,16 @@ class RefreshTokenGrantTest extends \\PHPUnit_Framework_TestCase\n       $grant->setPublicKey(new CryptKey('file://' . DIR . '/../Stubs/public.key'));\n       $grant->setPrivateKey(new CryptKey('file://' . DIR . '/../Stubs/private.key'));\n- $scope2 = new ScopeEntity();\n-        $scope2->setIdentifier('bar');\n  +\n       $oldRefreshToken = $this->cryptStub->doEncrypt(\n           json_encode(\n               [\n                   'client_id'        => 'foo',\n                   'refresh_token_id' => 'zyxwvu',\n                   'access_token_id'  => 'abcdef',\n-                    'scopes'           => ['foo', 'bar'],\n-                    'scopes'           => [$scope, $scope2],\n                   'user_id'          => 123,\n                   'expire_time'      => time() + 3600,\n. ",
    "ServiceTo": "Argh, okay. Thanks.\n. ",
    "georgewilde": "I'm unsure why StyleCI has failed as it's interface doesn't make that clear. It highlights changes I've not made to the file. Please message me with any changes I can make to my PR to help it get accepted.\nThanks. ",
    "chaegumi": "http://www.php.net/manual/en/function.password-verify.php\nboolean password_verify ( string $password , string $hash )\n```php\nphp\n// See the password_hash() example to see where this came from.\n$hash = '$2y$07$BCryptRequires22Chrcte/VlQH0piJtjXl.0t1XkA8pw9dMXTpOq';\n\n<pif (password_verify('rasmuslerdorf', $hash)) {\n    echo 'Password is valid!';\n} else {\n    echo 'Invalid password.';\n}\n?>\n```\nYour example now is  password_verify(hashed, hashed). Oh, It's my fault, I passed the hashed value.\n```php\n'form_params' => [\n               'grant_type' => 'authorization_code',\n               'client_id' => 'myawesomeapp',\n               'client_secret' => '$2y$10$0cnZgLgUlIBkges1dDxsYe4w9fSvrj7zpeg33Lj7QdDbG6k4tYZOW', // Here must be abc123 \n               'redirect_uri' => 'http://foo/callback',\n               'code' => $code\n           ]\n```\nThe correct use is:\n```php\n'form_params' => [\n               'grant_type' => 'authorization_code',\n               'client_id' => 'myawesomeapp',\n               'client_secret' => 'abc123', \n               'redirect_uri' => 'http://foo/callback',\n               'code' => $code\n           ]\n```\n. ",
    "gasmx": "@alexbilbie Why not use a GET request?. Got it, thanks for reply.. ",
    "jorgeGrisolle": "your grant will call issueAccessToken then this function calls accessTokenRepository->persistNewAccessToken this is the class you need to implement and use to store the token in to your DB. ",
    "Listen-WebDev": "This is what fail\n$psr = $this->server->validateAuthenticatedRequest($psr);\nin TokenGuard.php\nany ideas?\n. this is what failed\n$psr = $this->server->validateAuthenticatedRequest($psr);\nin TokenGuard.php\n. Hi Alex, here you are\n\nEndpoint: /api/v1/user\n\nBulk query headers\nAccept:application/json\nAuthorization:Bearer 034a1861ede97e32269cfdda6038c5f2fb812622ad6c5bb99badb65b7b3c17324ae402b3b0dfbfed\n. WTF !!! \ni understand... my access token was wrong, I copy and paste access token in oauth_access_token table. This is wrong! \nI feel stupid!\nThank alex for reply . ",
    "EslamIsmail93": "passport response The resource owner or authorization server denied the request . ",
    "jeremykenedy": "I removed the title and comment per your comment. You are correct, I did not read the readme in full before posting this. However, you are incorrect about the Passport stating a guideline and I was following one of their contributor recommendations to reach out to you. \nMoving past the miss understanding, can this still be checked out?. Okay, thank you for taking the time to explain. I appreciate your time.. ",
    "i906": "I did try entering the correct client id and secret into the dialog, but it does not seem to work. I encountered this dialog when I used a different redirect_uri than the one registered.. Hi @Sephster \nI thought that authentication dialog was confusing the users so I removed the WWW-Authenticate header to prevent the dialog from showing and return a 403 instead.\nphp\nif ($response instanceof Zend\\Diactoros\\Response) {\n    if (!$request->hasHeader('Authorization')) {\n        $response = $response->withoutHeader('www-authenticate');\n    }\n}. ",
    "bauer01": "Why I should use legacy version 4.* .... there souhld an option to disable built-in jwt....for example when I use some openidconnect built on top of this solution like https://github.com/steverhoades/oauth2-openid-connect-server ;-). any news pls? its critical for us... ",
    "mikefrancis": "@Sephster Hi, do you have the PR to hand? I am guessing it might have gone a bit stale and am interested to see if I can pick it up after discussion over on here https://github.com/laravel/passport/issues/543. ",
    "mabar": "I would also like to be able pick an alternative. I am currently working on oauth2-server integration for Nette and Apitte frameworks and I want choose paragonie/paseto instead of JWT. It is not required to return null, I agree. Currently it is 'anything else than entity'. But I expect that you will in future add native typehints, so it will be only entity or null.\nIf you dont like Entity|null so it should be at least Entity|mixed as current phpdoc tells repository must return entity which is definitely incorrect.. So you don't have any plans to add native typehints? Because currently is not possible to write getEntity(): Entity|void, only : ?Entity which means Entity or null.\nAlso, there are currently no plans to implement multiple return types in php.. ",
    "lkainers": "Thank you, the problem was homebrew.\nbrew install php70 (had OpenSSL problem)\nbrew install php70 --with-homebrew-curl --with-homebrew-libxml2 --with-homebrew-libxslt --without-legacy-mysql (fixed it)\n. ",
    "SoboLAN": "Question: why was this change done? Thank you.. ",
    "erickjth": "+1. Ok, I checked it out against master, the only thing missing is checking the code verifier such as code challenge check. This verifications is needed.. HI @Sephster, the change is done. Thanks for reviewing this PR.. ",
    "sgomez": "This was solved in https://github.com/thephpleague/oauth2-server/pull/777. +1 to this. This feature is useless with third-party libraries until this issue is solved. . You can configure your schema to do an 'ON DELETE CASCADE' or 'ON DELETE SET NULL'.. This is wrong, base64_encode must be done over the binary output of hash('sha256'). The process should be this:\nstrtr(rtrim(base64_encode(hash('sha256', $codeVerifier, true)), '='), '+/', '-_') \nThis can be checked with the example described in RFC7636 (Appendix B):\n```\n<?php\n$codeVerifier = 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk';\n$codeChallenge = 'E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM';\necho hash_equals(\n  strtr(rtrim(base64_encode(hash('sha256', $codeVerifier, true)), '='), '+/', '-_'),\n  $codeChallenge\n) ? 'True' : 'False';\n```\nThis returns True.\nWith the implementation of this PR:\n```\n<?php\n$codeVerifier = 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk';\n$codeChallenge = 'E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM';\necho hash_equals(\n  hash('sha256', strtr(rtrim(base64_encode($codeVerifier), '='), '+/', '-_')),\n  $codeChallenge\n) ? 'True' : 'False';\n```\nThis return False. \nhash('sha256', ..., false) returns a hexadecimal string and there are no way than match with code challenge that it is a base64 string.\nhash('sha256', ..., true) returns binary data and that is the reason to do a base64 conversion.\n. I disagree with this change. You are writing the algorithm that you must probe than works inside the tests. You have a know input and a know output, that's all you need to do unit test.. ",
    "jimi985": "Is there anything I need to do to have this pull request reviewed? This still seems to be an issue with the current master branch.. I hadn't realized at first that the ScopeEntityInterface implemented \\JsonSerializable.  This was because I was using a framework entity class (Cakephp) to implement the ScopeEntityInterface which has already implemented JsonSerializable.  I agree with @iliepandia (See issue: #846) that this library should not depend on a specific implementation of jsonSerialize, if in fact it needs to be in a very specific format.  This also restricts the flexibility of implementation of this interface.\nI think my changes in this pull request address this in a way that @iliepandia described.  By adding a method getScopeIdentifiers, that returns an array of scope identifier, this remedies this problem and also would be backwards compatible with any implementations of ScopeEntityInterface that were abiding to the specific format of jsonSerialize required by this library.. As requested, here's an example implementation of the ScopeEntityInterface in the CakePHP Framework (https://cakephp.org/)\nImplement the ScopeEntityInterface, using the base Entity class.  CakePHP uses Active Record paradigm, where the Entity class represents a record in the database.\n```\n<?php\nuse Cake\\ORM\\Entity;\n// https://github.com/thephpleague/oauth2-server\nuse League\\OAuth2\\Server\\Entities\\ScopeEntityInterface;\n/\n * OAuthScope Entity\n \n * @property string $id\n * @property string $description\n /\nclass OAuthScope extends Entity implements ScopeEntityInterface\n{\n}\n```\nThe Entity class' methods are mostly present in the EntityTrait\nclass Entity implements EntityInterface, InvalidPropertyInterface\n{\n    use EntityTrait;\nThe trait has the jsonSerialize() method implemented by default.  However, the phpleague/oauth2-server assumes that the jsonSerialize() method be implemented in a very specific way.  So this implementation of jsonSerialize() is incompatible with the oauth2-server.\n```\n/\ntrait EntityTrait {\n     * Returns an array with the requested properties\n     * stored in this entity, indexed by property name\n     \n     * @param array $properties list of properties to be returned\n     * @param bool $onlyDirty Return the requested property only if it is dirty\n     * @return array\n     /\n    public function extract(array $properties, $onlyDirty = false)\n    {\n        $result = [];\n        foreach ($properties as $property) {\n            if (!$onlyDirty || $this->isDirty($property)) {\n                $result[$property] = $this->get($property);\n            }\n        }\n    return $result;\n}\n\n/**\n * Returns the properties that will be serialized as JSON\n *\n * @return array\n */\npublic function jsonSerialize()\n{\n    return $this->extract($this->visibleProperties());\n}\n\n```\nWhile I can override the implementation of jsonSerialize, I would be forfeiting the use of the framework's implementation of jsonSerialize, when in fact the oauth2-server could take care of this independently from jsonSerialize().. The scopes that are defined in the authcode payload are expected to be an array of Scope identifiers (strings) in https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php respondToAccessTokenRequest():\n$scopes = [];\nforeach ($authCodePayload->scopes as $scopeId) {\n    $scope = $this->scopeRepository->getScopeEntityByIdentifier($scopeId);\n    if ($scope instanceof ScopeEntityInterface === false) {\n        // @codeCoverageIgnoreStart\n        throw OAuthServerException::invalidScope($scopeId);\n        // @codeCoverageIgnoreEnd\n    }\n    $scopes[] = $scope;\n}\nThis requires a very explicit implementation of jsonSerialize() for the class that implements ScopeEntityInterface.  The $authCodePayload ultimately originates from these lines in https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AuthCodeGrant.php completeAuthorizationRequest():\n$payload = [\n    'client_id'             => $authCode->getClient()->getIdentifier(),\n    'redirect_uri'          => $authCode->getRedirectUri(),\n    'auth_code_id'          => $authCode->getIdentifier(),\n    'scopes'                => $authCode->getScopes(),\n    'user_id'               => $authCode->getUserIdentifier(),\n    'expire_time'           => (new \\DateTime())->add($this->authCodeTTL)->format('U'),\n    'code_challenge'        => $authorizationRequest->getCodeChallenge(),\n    'code_challenge_method' => $authorizationRequest->getCodeChallengeMethod(),\n];\n$response = new RedirectResponse();\n$response->setRedirectUri(\n    $this->makeRedirectUri(\n        $finalRedirectUri,\n        [\n            'code'  => $this->encrypt(\n                json_encode(\n                    $payload\n                )\n            ),\n            'state' => $authorizationRequest->getState(),\n        ]\n    )\n);\nSince the payload life cycle of encrypting and decrypting this payload is handled entirely within the library, I believe the logic for defining the structure of $payload['scopes'] should be defined within the library itself.  This is the reason for creating this method.  I have forked this repository for the purposes of this change, and I know that this solves my particular issue.  Whether or not I have a class that wraps the Active Record representation of the scope, does not refute the point that the library requires that the ScopeEntityInterface be jsonSerialized in a strict manner.  This is clear if you try to alter the example implementation of the ScopeEntityInterface found here:\nhttps://github.com/thephpleague/oauth2-server/blob/master/examples/src/Entities/ScopeEntity.php\nYou will find that if this returns more than just the identifier string, the dependent unit tests will fail.\nIf, for example, I wanted to add other properties to a scope, like an added timestamp, and I wanted this property to be represented when the entity is json_encoded, I would not be able to utilize the JsonSerializable interface with this entity, because this library requires that it be serialized only as the ScopeIdentifier string.\nI don't see how this creates a backwards compatibility issue, as my suggested change for getScopeIdentifiers() utilizes an already existing method getScopeIdentifier().  Because of this, it is my understanding that any previous implementations of ScopeEntityInterface should be compatible with this.. Hi @simonhamp ,\nThank you for your feedback on this.  I remember now, since I investigated this some time ago, that the unit tests aren't adequately covering this scenario as can be seen in https://github.com/thephpleague/oauth2-server/blob/master/tests/Grant/AuthCodeGrantTest.php\n$request = new ServerRequest(\n            [],\n            [],\n            null,\n            'POST',\n            'php://input',\n            [],\n            [],\n            [],\n            [\n                'grant_type'   => 'authorization_code',\n                'client_id'    => 'foo',\n                'redirect_uri' => 'http://foo/bar',\n                'code'         => $this->cryptStub->doEncrypt(\n                    json_encode(\n                        [\n                            'auth_code_id' => uniqid(),\n                            'expire_time'  => time() + 3600,\n                            'client_id'    => 'foo',\n                            'user_id'      => 123,\n                            'scopes'       => ['foo'],\n                            'redirect_uri' => 'http://foo/bar',\n                        ]\n                    )\n                ),\n            ]\n        );\n        /** @var StubResponseType $response */\n        $response = $grant->respondToAccessTokenRequest($request, new StubResponseType(), new \\DateInterval('PT10M'));\nYou will find that the respondToAccessTokenRequest method is being tested using a faux ServerRequest object, and more specifically a synthetic $authCodePayload, where the scopes are being defined as ['foo'] instead of being derived from an actual code generated by the Grant class.  I believe it may be worth refactoring this test to adequately cover this scenario, otherwise this critical component of the library isn't adequately tested.  I'm not a fan of dependent unit tests, but this is one example where it might make sense.\nI can see why now that my proposed change might be a BC break, but I would still appreciate if this was available in a future release.  Thank you for your time you have spent investigating this.. > The json serializable implmentation elegantly deals with this issue in my opinion so the problem is, how do we integrate this with your Cake install?\nI don't think that the jsonSerializable interface elegantly deals with this as it doesn't work unless you explicitly implement this method as seen in examples/src/Entities/ScopeEntity.php:\npublic function jsonSerialize()\n    {\n        return $this->getIdentifier();\n    }\nIt forces the implementer of the OAuth2 server to implement this method in precisely this way and doesn't work otherwise.  If the implementer has no choice but to implement this method this way, why isn't it in the library itself?  That's what my code changes were attempting to solve.  After reviewing this, I'm not even sure how it breaks backwards compatibility, as the array of scopeidentifiers that is later json_encoded will be generated in an identical matter to the jsonSerialize method, assuming the jsonSerialize method is implemented as it is in the above snippet.\nUltimately, I think my changes remove unnecessary code that implementers of this library should not have to worry about, properly encapsulating the logic to package the different token payloads.. I think relying on the interaction between PHP's json_encode and jsonSerializable interface can cause problem's for future implementers, especially because the library is not providing a concrete implementation of ScopeEntityInterface.  If they happen to implement jsonSerialize in a different way than the above cited example, they will be faced with the same problems that I had to deal with.\nI also think this is more consistent with the logic that is implemented in the construction of the token payload:\njson_encode(\n    [\n        'client_id'        => $this->accessToken->getClient()->getIdentifier(),\n        'refresh_token_id' => $this->refreshToken->getIdentifier(),\n        'access_token_id'  => $this->accessToken->getIdentifier(),\n        'scopes'           => $this->accessToken->getScopes(),\n        'user_id'          => $this->accessToken->getUserIdentifier(),\n        'expire_time'      => $this->refreshToken->getExpiryDateTime()->getTimestamp(),\n]\n)\nAll of the items packaged in this payload explicitly access an identifier through a getIdentifier method except for the scopes property and none of them rely on an implementation of the jsonSerializable interface.  Using getScopeIdentifiers I think it cleans this up as it is a bit of a gotcha that it happens to be the only property relying on this interaction.. I added a pull request to address this, but it was never responded to.\nhttps://github.com/thephpleague/oauth2-server/pull/711. ",
    "lordrhodos": "I hit the same issue as well and was wondering why the AbstractGrant adds the scopes again after they had been passed to the getNewToken method of the repository. I was not using indexed entries in the scopes collection (common doctrine ArrayCollection). Changed that for now, but would love to see a fix in the future.. @sergeyklay How would you enforce that the implementer actually throws the exception? Phpdoc could be updated to document the basics of the implementation, but to me it feels not right.. > I could add a respondToRevokeTokenRequest method to AuthorizationServer. It would need to duplicate some of the code in AbstractGrant->validateClient, since that's not available to AuthorizationServer.\n@jacobweber if you are going to submit a PR try to avoid code duplication and try to decouple the validatClient feature if that is being duplicated. Maybe even submit a differnt PR if neccessary to get this right.\njust my 0.002 cents ;-). > Also, the state query parameter ist missing in error responses. The RFC states:\n\nstate\n        REQUIRED if a \"state\" parameter was present in the client\n       authorization request.  The exact value received from the\n        client.\n\njust to clarify, this seems to apply only to the following grant types:\n\nAuthorization Code Grant (https://tools.ietf.org/html/rfc6749#section-4.1.2.1)\nImplicit Grant (https://tools.ietf.org/html/rfc6749#section-4.2.2.1)\n\nThe error responses for the following grant types do not require the stateparameter:\n\nResource Owner Password Credentials Grant\nClient Credentials Grant\n\n(both link to section 5.2 in the spec for the error response). @Spomky speaking spec language is an own skill I guess \ud83d\ude09 \nFrom what I understand this library does not support OIDC (and its erlated response types), nevertheless this should be fixed. What I wonder is how the inclusion of thestate query parameter should be handled for this library?\n@Sephster do you have any opinion about it? Currently the OAuthServerException does not know about a state parameter or AuthorizationRequest. Should a PR add an optional $state parameter to \\OAuth2\\Server\\Exception\\OAuthServerException::__constructdefaulting tonull` or is there another favored approach?. > When considering the wider package, we need to ensure we are implementing consistent behaviour as well. At the moment, authCodes can also have clients set against them. Like access tokens, they have a setClient() method, but the main difference is that you cannot set a client via a constructor for the authcode.\n@Sephster \nIndeed, there are a couple of general / global issues regading DI for this library. \nIs there an agreement amongst core members / maintainers if the library should favour constructor injection over setter injection? \nI mean in the AbstractGrant there is no constructor injection, instead all depencies are injected via setter injection in\nhttps://github.com/thephpleague/oauth2-server/blob/master/src/AuthorizationServer.php#L126-L142\nso there is no real dependecy coupling for each grant type that is actually needed. What are your thoughts on this? Wouldn't it be best to just inject the services (e.g. repositories) needed into each dedicated grant type instead or am I missing something here?. Hi @Sephster, thx for having a look. To be honest I had started implementing some entities (Grant, Scope, etc.) already when I recognized that the identifiers for the tokens and the auth codes are being created by the library. I wanted to assure they all are handled the same way, so I started overriding it per grant type.\nWhile investigating the issue further I came across a comment from @alexbilbie considering changing the identifiers to use uuids:\nhttps://github.com/thephpleague/oauth2-server/issues/596#issuecomment-226700794\nBut that said, the comment is 2,5 years old and maybe not reflecting the current evaluation of the topic as you point out. My main motivation is to gain flexible control over the identifier generation and not about how the default identifier should look like. I am by no means an expert on cryptography or would argue for a certain collision percentage regarding uniqueness of either random_bytes or level4 uuids. Just wanted to decouple the generation so the implementor gets some better control avoiding code duplication. \n. @crtl I submitted a PR dealing with this code part here, but it will not be merged at the moment:\nhttps://github.com/thephpleague/oauth2-server/pull/987\nIf we can find more people in need of this we may get a chance to open up the discussion again ;-). > I for example wanted a length of 64 (for whatever reason) but I couldnt change it without extending a dozen of classes and copy/paste.\nSure someone can argue but its working like it is. Then I would state that this is a library, developed not to be a final product.\n@crtl I am backing this. I think the library should follow the current path to deliver the tools to implement an oauth2 and resource server supporting the defined (specs) oauth2 flow in a as easy as possible way, but also as flexible as possible. Flexibility for the unique identifier generation does not exist, which was the main reason for me tackling this issue. \n@Sephster the flexibility may not be needed in version 8 if that is pressing right now, but given the implementer control how to generate the unique identifiers should be added in the long term. And if it will be added it should come in a flexible way and provide a default generation without breaking exisiting installations.. ",
    "crtl": "I wanted to ask the same question.\nEither AccessTokenEntityRepository:getNewToken or AbstractGrant should setup the token.\nWhy call a factory when I do everything myself?\nIf it is to execute additional logic, why dont you use an event system?\n. Some people use object ids as their identifiers so in my opinion this behaviour is desired.\ngetIdentifier is called by the library which expects a string but due to the missing type hint the implementation can vary and we can use whatever identifier types we want to use.\nWe just have to return a string for getIdentifier.\nAlso a trait is a Trait and not an Interface.\nFrom the OAuth2 RFC:\n\nThe authorization server issues the registered client a client\n   identifier -- a unique string representing the registration\n   information provided by the client.  The client identifier is not a\n   secret; it is exposed to the resource owner and MUST NOT be used\n   alone for client authentication.  The client identifier is unique to\n   the authorization server.\n\n. Ok.\nSo the OAuth2 does not define a length for client_id and client_secret:\nFrom the OAuth2 RFC-6749, Section 2.2 Client Identifier:\n\nThe client identifier string size is left undefined by this\n   specification.  The client should avoid making assumptions about the\n   identifier size.  The authorization server SHOULD document the size\n   of any identifier it issues.\n\nSo the server should be able to specify its own length.\nViewing the source in AbstractGrant::generateUniqueIdentifier it shows us that this was intended because the method accepts a $length parameter.\nThe Problem\ngenerateUniqueIdentifier is protected and therefore can/is only called by AbstractGrant which never passes a $length and nowhere has support for configuring it.\nSo when I want my identifiers to be of a diffrent length (for example 64) I have to:\n\nExtend AbstractGrant -> MyAbstractGrant\nOverride generateUniqueIdentifier\nExtend MyAbstractGrant for all GrantTypes I want to use\n\nStep 3. will most likely result in copy/pasting the current grant implementations into the custom grants because @alexbilbie already did a geate job implementing those.\nThe Solution\n\nIntroduce an Interface IdentifierFactoryInterface\nPass an implementation of the interface to AbstractGrant\nCall the factory method inside generateUniqueIdentifier\n\nThis way the implementation is backwards compatible because it can ship with a DefaultIdentifierFactory which generates an identifier with the current length of 40.\nBut everyone wishing to control the identifier generation can implement his/her own IdentifierFactoryInterface and pass it to the grant.\nThe Pull requests from @lordrhodos is the exact same solution I see.\n. 1. The length of 40 is not documented\n2. When creating my schema I have to guess the length (maybe it changes) and I have no control over it.\n3. I cant implement my own generation algorithm\n4. It can also provide backwards compatibility for future releases.\nI for example wanted a length of 64 (for whatever reason) but I couldnt change it without extending a dozen of classes and copy/paste.\nSure someone can argue but its working like it is. Then I would state that this is a library, developed not to be a final product.\n@lordrhodos Is a good example. He wanted to use uuid, but couldn. Maybe he should/shouldnt, but should the library decide it?\n. @Sephster For example I want my identifiers to consists of alnum characters from a-zA-Z0-9.\nNow I do understand your point of view more.\nIn my opinion this is no breaking feature and the priority for me personally is not that high.\nI just saw it in the code and thought that there is room for improvement because it breaks with the Single Responsibility Principle and the Seperation of Concerns (and its so clear).\nFrom a feature/user perspective it works.\nFrom a software design perspective its wrong.. Additional it sohuld noted that the current documentation for AccessTokenRepository and RefreshTokenRepository contains the following information for getIdentifier:\n\ngetIdentifier() : string this is randomly generated unique identifier (of 80+ characters in length) for the refresh token.. \n",
    "j4m3s": "I was just looking at the code in that area yesterday, though not too deeply.  It's interesting that the whole refresh token is decoded and returned as an array by RefreshTokenGrant::validateOldRefreshToken() rather than returning a RefreshToken entity.  That may be because it's up to the user's implementation to define the entity's implementation - but a parseToken() method on the RefreshTokenRepository would be logical.  The Grant already holds a reference to it as a property.  \nIf the actual RefreshTokenEntity were returned it could then be passed into the isRevoked() and revoke() methods which would be \"nicer\" than just passing the ID.  We do have the whole token after all :)\nThat change would be backwards breaking though.\n(I suspect all of the above applies to AccessTokens as well as RefreshTokens).\nIn the meantime though, if you persist the tokens, can you not retrieve them by ID too?  It's an extra database call but otherwise is fairly straightforward.. I've just noticed that there's another potential issue with attempting to pass the whole token around rather than just the ID, and that's that the token has a getClient() method which returns a Client object rather than just the client's identifier (which is the way users are reflected on tokens).  If the framework was to try to reconstitute the whole token object and pass it into the verification methods it would need to look-up the Client object too, which would add overhead to the most common use-case, which is a simple isRevoked() check (which doesn't care about the Client).. ",
    "stratoss": "@j4m3s I'm not persisting the tokens, only the token IDs, which are revoked. My initial idea was to have  expiresAt DB field and a cronjob to clean the expired ones on a regular basis.\nPassing the whole entity will definitely work, and because the BC will be broken having this functionality in version 6 will be awesome.. I agree, what about optional $jsonOptions so we can pass JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT there for example as well?. ",
    "delboy1978uk": "Thanks very much for the fast reply Alex! :-D\nI'm creating an implementation for Bone MVC Framework. 40 characters? Great! It's mainly just the relations between the entities I'm wondering about.  \nFor instance, a RefreshToken should be a one-to-one with the access token, right?\nI'm guessing AuthCode is many-many for scopes, one-one for users, many-one for clients.\nAnd AccessToken many-many for scopes, many-one for users and clients.\nOnce I get these basic relationships I should be able to plough on ahead! Could you advise?\nI haven't set up custom repositories yet, but my entities are here:\nhttps://github.com/delboy1978uk/oauth2-api/tree/master/src/Entity/OAuth\nThanks again\nDerek\n. Ah great, guessed right first time! Thanks so much! :-D. Ah right ok, thanks for getting back! Version 6? :-D When can we expect to see that? . Ok, I've had a look again at the specs here https://www.oauth.com/oauth2-servers/definitions/ so now I understand. But again, shouldn't these be in the interface?. ",
    "shahariaazam": "So it seems that from the OAuthServerExceptiption.php file.\nIn this https://github.com/thephpleague/oauth2-server/blob/master/src/Exception/OAuthServerException.php#L224\nit always work with the first redirect uris. And that's causing trouble. Cause even we can't access the current request object from this exception. So it can be better if we can just carry over the redirect_uri as array through the whole process. . Maybe I just fix something in the flow in my implementation. I need to test it further before re-opening this issue.. ",
    "perl5punk": "Ran into a similar issue. ",
    "josiasmontag": "Can this be merged? The current implementation is inconsistent:\n\nBearerTokenResponse -> \"Bearer\"\nImplicitGrant -> \"bearer\"\n\nThanks!. ",
    "danitome24": "I don't know how to integrate it with Silex... any help?. ",
    "chenyingqiao": "i fix already\ud83d\ude02. ",
    "Ekwav": "Ok, I will store it in the session thanks for the advise :), but in my opinion it would make more sense otherwise.. ",
    "m-bymike": "btw, a \\n doesn't match CRLF line breaks, should I add that too?. The segfaults with the previous expression can still be reproduced using php 5.5 / 5.6 on the command line (make sure to replace php56 w/ the appropriate executable):\nPrevious version of regular expression:\nbash\nopenssl genrsa 2048 | php56 -r \"const RSA_KEY_PATTERN = '/^(-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----\\n)(\\n|.)+(-----END (RSA )?(PUBLIC|PRIVATE) KEY-----)$/'; echo (preg_match(RSA_KEY_PATTERN, fread(STDIN, 2048)) === 1 ? 'MATCH' : 'NO MATCH'), PHP_EOL;\"\nThis is the output I get:\nGenerating RSA private key, 2048 bit long modulus\n........................................................+++\n.................+++\ne is 65537 (0x10001)\n[1]    1914 done                openssl genrsa 2048 | \n       1915 segmentation fault  php56 -r\nNew version of regular expression:\nbash\nopenssl genrsa 2048 | php56 -r \"const RSA_KEY_PATTERN = '/^(-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----\\n).+(-----END (RSA )?(PUBLIC|PRIVATE) KEY-----)$/s'; echo (preg_match(RSA_KEY_PATTERN, fread(STDIN, 2048)) === 1 ? 'MATCH' : 'NO MATCH'), PHP_EOL;\"\nAnd the output here is:\nGenerating RSA private key, 2048 bit long modulus\n..............................+++\n...............+++\ne is 65537 (0x10001)\nMATCH\nNote: The segfault only happens w/ php 5.5/5.6 and is not reproducible w/ php7.*.\nThe expression still matches the same requirements, hence no updated tests.\n. Closing PR, changes included in #805 with commit f79d3f2.. @raarts Hi, I added a similar pull request in #731 boosting performance of the regular expression and support crlf. We should combine them somehow, because my PR doesn't come with a separate test.... @raarts I suggest you copy the expression from my PR and commit it to yours. I'll simply close my PR... . ",
    "paresy": "We encountered this problem in a real life application for Amazon Alexa. When revoking the tokens immediately there were edge cases where the Alexa service stopped working. As Xerkus pointed our there might be concurrency issues on distributed systems. Therefore our approach is to invalidate the refresh token after a timeout as halaei already pointed out.. @alexbilbie This does not fix the underlying issue. It just minimizes the probability of happening. And i would argue that a higher AccessToken TTL it is worse in terms of security than not revoking the refresh token immediately. . ",
    "jturmel": "@alexbilbie @paresy @halaei I'll jump in here although I'm not having a specific issue with your library I have been doing research for this issue on another project. I'm using an OAuth2 Python library with an API we run and some of our clients are experiencing this very issue. Increasing access token expiry time just pushes the chance of what they're describing further out, it doesn't eliminate it... conversely in our testing, we lowered the expiry time for access tokens to a very short time frame and saw the problem much more and we're not even on bad networks, it can happen when network switching (WiFi <-> cellular).\nThe main problem in our experience is client determines that an access token is expired, either by checking the expiration before making the request or from receiving a 401 response by trying to make a request with the expired token. The application then tries to refresh the access token, request is successful, but before the response can complete with the client because of network issues or any other host of issues (ie iOS only allowing so much time to complete a task in the background for example), the new access token and new refresh token are never received and stored by the application (which is also what triggers clearing out the previous tokens on the application side). When the application makes a network request again it's still using the old access token, so it tries to refresh again but this time the refresh token is invalid. The application is now forced to ask the user for authentication credentials again. For applications that perform API calls in the background often without much user interaction, a user may be logged out for some time before they ever realize it, depending on the application's importance this could be a minor inconvenience or a fairly serious issue.\nI found a post on how Fitbit started handling this very issue in their own API here: https://community.fitbit.com/t5/Web-API-Development/Refresh-token-amp-network-timeout/td-p/1102761 -- tl;dr: they built in a 2 minute grace period window where the older refresh token could still be used. Others also suggested not actually invalidating the old refresh token until the first use of the new access token... although the load around this was the reason Fitbit didn't do it, that could probably be worked around with more time/thought/resources.\nThe Python library I'm using added an option to disable rotating refresh tokens since it is an optional part of the spec.. ",
    "tylik1": "I'm having the same issue. Imagine the case where client app calls refreshToken api endpoint, to retrieve new access and refresh tokens, but then user for some reason, refreshes browser in the middle of process. The refresh token cookie is not attached, meaning, all following requests will fail, and the user will have to login again.. ",
    "e0ipso": "I am also interested on this.. ",
    "Lavoaster": "This might be because it doesn't match against those with carriage returns. I generated a key using phpseclib's RSA class, and either that, or the built in openssl_ methods, use \\r\\n line endings. So modifying my script to replace \\r\\n with \\n made it work for me. . @alexbilbie Is this supposed to be for all oauth keys, or just the ones passed via a string and saved to /tmp. ",
    "louisfisch": "Hi! I am still having this issue with version 6.1.1. The pattern does work when I test it on Regex101, as you can see in this example. However the preg_match function returns false or... nothing. Like @visual4 said, the following pattern works perfectly:\n/^(-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----\\n).*(-----END (RSA )?(PUBLIC|PRIVATE) KEY-----)$/s\nEnvironment:\n- macOS 10.13.2 (17C88)\n- PHP 7.1.12. @simonhamp I confirm the preg_last_error() returns the value 6 which I think is the value of the PREG_JIT_STACKLIMIT_ERROR constant.\n\nEssentially with PHP 7, one cannot guarantee the behaviour of a preg_match anymore.\n\n@mrgrain, agree. I also run into bad experiences with preg_match().. ",
    "mrgrain": "@louisfisch Check if your regexp returns an error. We run into the same (?) / a similar issue. For us it was caused by PHP's most stupid ever \"feature\", the implementation of PCRE JIT. See this bug for reference. You know you've hit it, when the error code is PREG_JIT_STACKLIMIT_ERROR\nEssentially with PHP 7, one cannot guarantee the behaviour of a preg_match anymore.. ",
    "jilvin": "@Sephster Thanks for taking time to resolve this. It was a mistake on my part as I checked the header section alone.. ",
    "mojojoji": "Is this ready to be merged? Challenges generated by the client (in node js) is always failing due to this.. ",
    "danut007ro": "+1 for this.\nI also made the PKCE implementation optional in https://github.com/thephpleague/oauth2-server/pull/817. Since PKCE implementation never worked, should it be enabled by default?. Second commit validates the code_verifier parameter ONLY if code_challenge was present in original authorization request. If no code_challenge was present when the authorization request was made, then the code_verifier parameter is ignored.. Hello. Since PCKE never worked actually shouldn't I enable PKCE extension by default, and make it optional like in this pull request? And maybe it can be disabled with something by a method like disableCodeExchangeProof() but by default it should be enabled since it's supported by this library. Clients that don't care about PCKE should not use it and it should be ok. I mean, I don't see any BC break here.. I think it's fixed by https://github.com/thephpleague/oauth2-server/pull/744\nWill work on my pull request after that is merged.\nThanks. Updated. Thanks. Ahh, I found the pull request for fixing this https://github.com/thephpleague/oauth2-server/pull/744. Current implementation on master is checking for $this->enableCodeExchangeProof and if this is true it will continue checking for PKCE, so for an request without code verifier/challenge it will hit the exception.\nThe fallback happens only if $this->enableCodeExchangeProof is false, and is a way of checking for PKCE without actually forcing it to be required (like $this->enableCodeExchangeProof does).\nIn my opinion, both parameters can be removed and just check for PKCE.\nAgain, I hope I made myself clear and please correct me if I'm wrong.. Hope I'm not getting this wrong. If I would check the code_verifier from request, doesn't that mean that if access token request is made without this parameter, it will bypass the previous authorization code request that was made with code_challenge parameter?\nHere I check code_challenge that was set in the authorization code request.\nPlease correct me if I'm wrong.. Hello, this fallback makes sense only if we don't want to break BC. I believe that PKCE should be enabled and not required by default (just like oauth RFC states).\nIn the RFC, there is no statement that a client MUST provide PKCE, but we can have a flag requirePkce that will check for code challenge and verifier, just like current implementation on master. But this will BC break, since enableCodeExchangeProof will be removed.. ",
    "benito103e": "I think we should verify if request contains Authorization header field : \nphp\nif (array_key_exists('HTTP_AUTHORIZATION', $_SERVER) !== false){\n   // Add \"WWW-Authenticate\" response header field\n}. @ravanscafi for my part, I removed manually this unexpected header on my authorization controller : \ncatch (OAuthServerException $exception) {\n    return  $exception->generateHttpResponse($response)->withoutHeader('WWW-Authenticate');\n}. #770 . 1\u00b0 redirect_uri : you're right, me should use redirect_uri provided or client registered redirect uris.\n2\u00b0 I don't find the reference to my quote, but on Authorizarion code grant, we can read : \nhttps://tools.ietf.org/html/rfc6749#section-4.1.2.1\n\nIf the resource owner denies the access request or if the request\n   fails for reasons other than a missing or invalid redirection URI,\n   the authorization server informs the client by adding the following\n   parameters to the query component of the redirection URI using the\n   \"application/x-www-form-urlencoded\" format, per Appendix B:\n\n. ",
    "ravanscafi": "We are suffering with this problem too.. ",
    "wysisoft": "i see in the UserEntityInterface there is a getIdentifier method, I assume this is stored in the \"Aud\" field inside the jwt token. I might be good with this.. For Wordpress and Drupal yes I think I can use the token and their API to get the user info, but for Joomla I didn't see any API like this. Am I wrong in assuming getIdentifier is stored in the token? I see Microsoft and Google storing some user identifier info in their tokens, was hoping for the same here.. i'll test it in the coming weeks and let you know, I think it will work. ",
    "gbgelado": "I made this customization:\nin resources\\lang\\pt-br\\auth.php\n'invalid_client' => 'Autentica\u00e7\u00e3o de cliente falhou',\nand in OAuthServerException.php\n```\n    public static function invalidClient()\n    {\n        $errorMessage = __('auth.invalid_client');\n    return new static($errorMessage, 4, 'invalid_client', 401);\n}\n\n```. ",
    "marcelogarbin": "any news?. ",
    "dmelo": "Hi. I've done a benchmark a while ago http://diogomelo.net/blog/15/php-array_key_exists-vs-isset . Running the code on my machine today (with php 7.1.5) i still get isset running about 3.5x faster than array_key_exists:\nSimilar behaviour: \n/home/dmelo/v.php:6:\nbool(true)\n/home/dmelo/v.php:7:\nbool(true)\nDifferences:\n1. isset works with other variables, besides arrays.\n/home/dmelo/v.php:12:\nbool(true)\n2. isset return false when value is null\n/home/dmelo/v.php:17:\nbool(false)\n3. Speed\narray_key_exists: 1.0082581043243 seconds \nisset: 0.28244996070862 seconds\nThere are other banchmarks. In general, they come to the same conclusion: unless you have a reason to use array_key_exists you should opt for isset, which is faster.\nOther posts related to the subject:\n\nhttps://ilia.ws/archives/247-Performance-Analysis-of-isset-vs-array_key_exists.html\nhttps://stackoverflow.com/questions/3210935/difference-between-isset-and-array-key-exists\nhttp://juliusbeckmann.de/blog/php-benchmark-isset-or-array_key_exists.html. @pounard, I was aware of that, when I proposed the change. In the context it was applied it is OK to have isset() returning false when the value for that key is null.\n\n@Sephster , always tought Yoda condition was a good practice, but saw that PSR-2 additions advice against it. Have just reversed the condition order on commit 203be5ca20de4a0a3520513b7507d7e2dc5fc0f8 .. @alexbilbie I did remove it on commit 203be5ca20de4a0a3520513b7507d7e2dc5fc0f8, which is also on this PR.. I also would appreciate if you could provide more details about the encryption key.\nWhat is the encryption key used for? How should the encryption key be stored? On the example https://oauth2.thephpleague.com/v5-security-improvements/ it is hard coded on the parameter, is that the recommendation? Should it be stored separated from the RSA private key?. ",
    "sergeyklay": "\ud83d\udc4e  for Yoda conditions. Yoda conditions may make code harder to read for some developers. Part of your job as a software professional is to write quality code. You want your code to be as readable as possible.\n. The MySQL schema can looks something like this, if I haven't forgotten anything. In fact, there is nothing extraordinary here. Usually each application/framework impose its own limitations.. I propose to consider such a scenario:\n\nUser should explicitly set a timezone, this is not a responsibility oauth2-server\nThe oauth2-server should use DateTime and DateTimeZone objects instead of time() function\n\n```php\ninterface DateTimeAwareInterface {\n    public function getTimestamp(): int;\npublic function getDateTime(string $format = 'Y-m-d H:i:s'): string;\n\n}\ntrait DateTimeAwareTrait {\n    protected $dateTime;\npublic function __construct(DateTimeZone $timezone = null) {\n    $this->dateTime = new DateTime('now', $timezone);\n}\n\npublic function getTimestamp(): int {\n    return $this->dateTime->getTimestamp();\n}\n\npublic function getDateTime(string $format = 'Y-m-d H:i:s'): string {\n    return $this->dateTime->format($format);\n}\n\n}\n$dc1 = new class(new DateTimeZone(\"Europe/London\")) implements DateTimeAwareInterface {\n    use DateTimeAwareTrait;\n};\n$dc2 = new class(new DateTimeZone(\"UTC\")) implements DateTimeAwareinterface {\n    use DateTimeAwareTrait;\n};\nvar_dump(\n    [\n        $dc1->getDateTime() => $dc1->getTimestamp(),\n        $dc2->getDateTime() => $dc2->getTimestamp()\n    ]\n);\n```\narray(2) {\n  '2017-10-25 09:25:59' =>\n  int(1508919959)\n  '2017-10-25 08:25:59' =>\n  int(1508919959)\n}. Got it. Do you suggest to introduce something like setExpiryComparePrecision()?. But not all auth system needs to use drift. Also 120 looks a bit magic. This is why I asked about a separated method to enable drift and disable (set to 0).. IMO Repositories should throws exception in case of unable to get Entity. Such flow allow us get rid of irrelevant conditions like $client instanceof ClientEntityInterface.. @lordrhodos It is my personal opinion. If you are always expecting to find a Client entity then throwing the exception will be right way to inform that there was a problem. In other hand if the Client entity can be missing or present and both are valid for the application logic then returning a null is acceptable. So there is a question: Is Client entity absence a normal condition, by design, or not?. Looks like a pasta code here.\n\n\nAs you may know json_decode may return NULL  if the json cannot be decoded or if the encoded data is deeper than the recursion limit. So, why do we need type hinting here?\n\n\nI think the code may be more simple and obviously faster:\n\n\n```php\n$validCodePayload = \n            isset($authCodePayload->expire_time) &\n            isset($authCodePayload->auth_code_id) &\n            isset($authCodePayload->client_id) &\n            isset($authCodePayload->redirect_uri) &\n            isset($authCodePayload->scopes) &&\n            is_array($authCodePayload->scopes) &\n            isset($authCodePayload->user_id);\nif ($validCodePayload === false) {\n    throw OAuthServerException::invalidRequest('code');\n}\n```\n\n\nI wold like to get hint - what exactly is missing\n\n\nIMO is it better to validate JSON by using JSON Schema. I think that 3 and 4 aren't mandatory, although for me they are still important.. @Sephster how about isset($oldRefreshToken['scopes'])?. @Sephster\ndiff\nif (empty($validScopes)) {\n--    throw OAuthServerException::invalidScope($redirectUri);\n++    throw OAuthServerException::invalidScope($this->defaultScope ?: 'null', $redirectUri);\n}. \n\n",
    "hugoFelippe": "I found the error, it was to be passed only the handle in the token, so I extended the class and made changes, not a problem in the class itself was an implementation error, but I want to keep it that way and just change the class . ",
    "vigneshgurusamy": "@alexbilbie In addition to that, we have to make web server user as owner for public key. Because the latest update trying to set 600 permission to public key.\n. ",
    "edwardaa": "As vigneshgurusamy said, the chmod() leads to an exception raised:\nlog\nWarning: chmod(/home/myname/example-project/certificates/public.key): Operation failed:\nOperation not permitted in League\\OAuth2\\Server\\CryptKey->__construct() (line 51 of\n/home/myname/example-project/vendor/league/oauth2-server/src/CryptKey.php). ",
    "LeandroSe": "This implemented broke a lot, example if you are testing using apache I have to change the owner to www-data, and with that I can not use php artisan passport: install.\n*sorry my english. ",
    "iget-esoares": "Also have the things broken here.\nThe file ownership breakes many laravel commands, including tinker. ",
    "gemal": "the implementation is wrong\nif ($keyPathPerms !== '600') {\nyou cant say that this is the perfect permission.\nyou might have set up the file with permission to the group\nwhich you then have\n'660'\nplease revert this. I still think is some cases even a warning is wrong\nMy folder is protect correct and is not 600 but is protected according to all security manuals.. I'm talking about this commit:\nhttps://github.com/thephpleague/oauth2-server/commit/2f8de3d2302beb490abb9475cf426148801c25c4\nhow can I help in fixing this?. I still think just check for if ($keyPathPerms !== '600') {\nis wrong\nyou could have a perfectly secure system without the permissions being 600\n. ",
    "Lctrs": "Hi,\nI replaced all the is_null() calls by null ===.\nIt's just what we can call a micro-optimization. Doing this comparison is always more efficient than calling the function for the same functionality.. ",
    "lilliesAndRoses": "This is in the context of drupal 8.3.4, simple_oauth module. . ",
    "webclaus": "Will certainly second the point that previously valid tokens are now invalid when providing an encryption key, effectively making it impossible to upgrade a production environment.\nUsing the previous decryption method as a fallback would ensure backwards compatibility and would be a trivial addition?. I can only speak for myself here, but we implemented a hybrid approach that allowed refresh tokens issued before the update to still be valid also. Painful and messy, but really nothing to do about it :)\nSo in short: No, we're rocking on 7.x and loving the package. Keep it up \ud83d\udc4d . ",
    "magnetik": "I just came across the \"v5-security-improvements\" page, and I was quite puzzled too. \nThe page should state clearly that all previously issued token will be invalid\n. ",
    "mbrodala": "@dmelo See https://github.com/thephpleague/oauth2-server/issues/915#issuecomment-399425285 for the explanation of the encryption key. I assume it needs to be stored somewhere safe and injected into your code the same way as the keypair.. ",
    "raarts": "The Resource Owner Password Credentials Grant Type is actively being discouraged by the IETF, and should not to be used for new applications. See RFC6819 Section 4.4.3. Also see this IETF draft: RFC6749 - OAuth 2.0 for Native Apps on how Oauth2 should be implemented on native apps.\nThis boils down to using a similar redirect-scheme as used by desktop browsers. Native apps have an extra vulnerability here, because there's no real control over where the redirect ends up. This is what PKCE protects against.\nI found an informative blog post here. . ..aaaaand I forgot to run phpunit, and the tests still pass. Checking to see if I can add a test for this. Can anyone recommend where and how to add a test for this?. Hi, I changed the code to only apply to resource owner password grants and added a test for it. I'm not sure if what I did was the correct approach, I'm totally unfamiliar with the code base. Please review.. Used wrong base branch closing and create a new PR.. Need to discuss with the maintainers? I propose you remove the '\\n' from the regex, and we work to get it merged, I'll remove my edits on the regex, and merge the test, and then we'll improve the tests? . Ok, will do. Thanks.. Agreed.. There's an error in the .gitattributes file, the llne I added starts with a '+'. I have fixed it in a new commit.. You're right, I misunderstood the tests. Fixed.. ",
    "libasoles": "@gemal Have you created that PR? If not, I think I will.. ",
    "JEDIBC": "An easy workaround is to use the values of the keys and not the path to the key files.. The recent commit 80fc8e654b6ab6ba66000ddd7b95f8d7203c2443 won't change the problem for symfony users as errors are turned into exception by the framework.\nPerhaps a modification of the constructor like below would allow more flexibility in the use of the keys :\n```php\n/\n * CryptKey constructor.\n \n * @param string      $keyPath\n * @param null|string $passPhrase\n * @param bool        $checkFileMode\n * @param int         $fileMode\n /\npublic function __construct($keyPath, $passPhrase = null, $checkFileMode = true, $fileMode = 0600)\n{\n    if (preg_match(self::RSA_KEY_PATTERN, $keyPath)) {\n        $keyPath = $this->saveKeyToFile($keyPath);\n    }\nif (strpos($keyPath, 'file://') !== 0) {\n    $keyPath = 'file://' . $keyPath;\n}\n\nif (!file_exists($keyPath) || !is_readable($keyPath)) {\n    throw new \\LogicException(sprintf('Key path \"%s\" does not exist or is not readable', $keyPath));\n}\n\nif ($checkFileMode) {\n    // Verify the permissions of the key\n    $keyPathPerms = decoct(fileperms($keyPath) & 0777);\n    $stringFileMode = base_convert((string) $fileMode, 10, 8);\n    if ($keyPathPerms !== $stringFileMode) {\n        // Attempt to correct the permissions\n        if (chmod($keyPath, $fileMode) === false) {\n            // @codeCoverageIgnoreStart\n            trigger_error(\n                sprintf(\n                    'Key file \"%s\" permissions are not correct, should be %s instead of %s, unable to automatically resolve the issue',\n                    $keyPath,\n                    $stringFileMode,\n                    $keyPathPerms\n                ),\n                E_USER_NOTICE\n            );\n            // @codeCoverageIgnoreEnd\n        }\n    }\n}\n\n$this->keyPath    = $keyPath;\n$this->passPhrase = $passPhrase;\n\n}\n```. Linked to #760. ",
    "klemenb": "+1 for the issue with Kubernetes deployments (and other similar environments). \nThe main issue is that secrets are mounted as \"read-only\" volumes and the \"chmod\" function itself fails with chmod: changing permissions of X: Read-only file system.\nI understand that this was done with best intentions, but being \"too smart\" will almost always break things for many valid use cases out there.. Laravel catches the E_USER_NOTICE in its exception handler.\nYou can add error_reporting(E_ALL & ~E_USER_NOTICE); to one of your service providers to prevent this.. ",
    "yannickl88": "I've made a PR #776 which proposes two things:\n- Remove the code that chmods files but trigger a USER_NOTICE when not set to 600.\n- Option to skip the check. (for dev or special cases)\nI think this is a solution for this issue.. If okay, I would like to loosen the permissions to 660 instead of 600 to support cases like ours (and that of #760). I would like to, but that might be a bit of a bigger change than possible. The check is done in the constructor. So in order for that code to work the validation of the key needs to be moved.\nThis will change the behavior quite a bit, because checking so will either be done by another class or when one of the public methods is called, changing the place where the error might be triggered (if at all).. which comments? The one about removing the disabling of the check?. I'm not seeing any comments, did you publish them?. np! should be fixed now.. There is a third constructor argument for the keys. Setting this to false will disable the check.\nThe AuthorizationServer has 2 arguments for the public and private keys which can be both a string or a CryptKey. So the easiest thing to do is use the CryptKey and make sure to set the third argument to false.\nYou do the same for the ResourceServer.\nHow to do this with Laravel passport I do not know, we use Symfony. I recommend making a PR there or try to extend it yourself to use this behavior.. ",
    "AbhijeetSomwanshi": "@alexbilbie I am getting the following error on upgrade of Passport \"laravel/passport\": \"^3.0\" Please help its on live server and urgent. Any quick fix will be greatly appreciated.\nchmod(/var/www/html/storage/oauth-private.key): Operation failed: Operation not permitted\nThanks. ",
    "vibrantBits": "Is it fixed? I just made a fresh install in homestead and got:\nKey file \"file:///home/vagrant/Development/.../storage/oauth-public.key\" permissions are not correct, should be 600 or 660 instead of 777\n. For backwards and crossplatform compatibility $keyPermissionsCheck should be false by default.. ",
    "jigarpt": "I am also getting the same error on windows 10 system.\nKey file \"file://E:/.../storage/oauth-public.key\" permissions are not correct, should be 600 or 660 instead of 666\n. ",
    "gorantosicdev": "When we can expected fix for this problem?  . ",
    "chinna-magapu": "Hi @alexbilbie  , \nI Have updated with laravel/passport 3.0 . and it is working as expected now.\nThank You for your response.. ",
    "ZoozyCN": "@alexbilbie \nRetrieve access_token from other than authorization header is commonly used, can we merge this?. ",
    "Spomky": "There is nothing wrong here. This is the expected behaviour for that grant type (see RFC6749 section 4.2.2).\n\nthe authorization server issues an access token and delivers it to the client by adding the following parameters to the fragment component of the redirection.\n\nThis grant type is designed for script applications (SPA, JS...), not for PHP applications.\nYou can read this answer to know more about that topic.\nYou should use the Autharization Code grant type instead.. @lordrhodos tha\u2019s right. Broadly speaking, the state parameter is should be part of any response (success or failure) from the authorization endpoint.\nThis is true for all response types ; not only the Authorization Code Grant and Implicit Grant but also the ones defined by other specification (e.g. OpenID Connect and its id_token or none response types). ",
    "kumy": "Thanks for the clarification. Let's close :). Unrelevant.. ",
    "valeryan": "So any information on how one would get laravel passport to use this new toggle for the permission check?  I just ran a composer update and now my whole dev environment has come crashing down.  I am using bash on windows and you cannot chmod files because it ignores it. https://github.com/Microsoft/BashOnWindows/issues/81\n. @cringer bash on windows does not support chmod of files that are stored on the ntfs file system. see https://github.com/Microsoft/BashOnWindows/issues/81. @cringer I haven't actually dug into how they are doing the permissions check, maybe it does check the OS but because you are running bash for windows the script execution is happening in a *nix environment. . ",
    "cringer": "I don't know if this is because I use the built in PHP development server, but my files in windows always report 0666, and folder report 0777.  If specific couldn't we have the package automatically disable checking/modification using a php_uname('s') check?. Yeah I get that.  My point is that the package is attempting to check and/or modify the permissions on the keys.  Since the specified values will always be reported back from a windows system the package will always crash and burn.  \nWhile a 3rd constructor has been added to disable this check I was just wondering why it doesn't do a check based on the OS anyway.   As a cross platform package, it would seem like it would be a better solution to ignore checking and modification completely on Windows.\n. @valeryan I don't really think they are checking.  If the check was done through PHP it a check to phpuname('s') would return the Operating System of the server running the php.  It doesn't matter if the development server was started using command prompt or git bash this will always be Windows.  Specifically php_uname('s') would return Windows NT. . ",
    "johannesschobel": "closed as this is related to laravel/passport. I reopened this issue, as it is - unfortunately - not related to laravel / passport. The problem arises within this library - specifically with this commit 2aca909d203e8a925da8c3a3f16a803683cecf04 .\nI realize, why the change was introduced, but i think this breaks backwards-compatibility. Especially for developers on Windows machines (yes, we exist!) or users that do not have the permission to change the file permission of the keys!\nI think, it would be good to make this behaviour (i.e., the $keyPermissionsCheck flag) customizable via a configuration file in order to not break Windows development machines or other scenarios.\nWhat do you think?. Yes, i am using laravel/passport so the problem is fixed for me.. However, other users, that are not using laravel/passport, struggle with this issue.. . ",
    "LuisMejiaF": "I know this is closed, but I have the same problem and I'm using Slim. \nI understand permissions are important, but forcing to 600 or 660 still doesn't work for me.\nIn my company, we use a sandbox in the remote server to test our software, I'm not the owner of the server, I was given a user to be able to read/write the source code in the server, but I cannot control the folders above me.  \nFor instance, if I assign the permission to be 600 or 660, I get the error private.key does not exist or is not readable. As I said, I guess this have to do with the servers setup of my company, but again, it stops me to use freely this library during development.. ",
    "fuadmuhtaz": "Just add the webserver user to the group of file. So program can read private.key\nhttps://www.cyberciti.biz/faq/howto-linux-add-user-to-group/\nAfter that, restart your webserver. You can try this,\n$privateKey = new CryptKey('file://path/to/private.key', null, false);\nThis problem has been fixed from PR #776 . Make sure you use laravel/passport version ^3.0.1\nThey already fixed it https://github.com/laravel/passport/pull/454. ",
    "vvasilev-": "Hey @johannesschobel,\nAccording to these lines, you can pass a CryptKey instance. So you can do the following: \n```php\n<?php \nuse League\\OAuth2\\Server\\CryptKey;\nuse League\\OAuth2\\Server\\AuthorizationServer;\n// rest of your code...\n$privateKey = new CryptKey($keyPath, null, false);\n$server = new AuthorizationServer(\n    $clientRepository,\n    $accessTokenRepository,\n    $scopeRepository,\n    $privateKey,\n    $encryptiongKey\n);\n```\nI tried this on my Windows machine and everything works well.. Regarding to laravel/passport, they're already doing the same thing here. Just make sure that you're using v3.0.1 of laravel/passport. . ",
    "riskis": "Thanks @fuadmuhtaz but I can't disable the check in Laravel Passport plugin.\nI changed it in my local vendor package. Thanks! Update solve my problem.\nI use \"laravel/passport\": \"~4\". ",
    "thuethe": "+1 for this.\nI've the same issue. ",
    "aleho": "Yes, I was aware of that. This is not about the possibility to disable the check though.\nThe check itself is harmful in terms of IT security. It doesn't help with securing the key pair, it actually requires the web-process to have write-rights (anything below will result in an error). By default the notice gets output in server responses, so that will lead to people setting access rights exactly as \"required\" by the notice to make it disappear. Even \"correct\" setups will lead to such a notice being shown.\nPlease don't see this as a support request about \"I can't make the notice disappear\", but consider fixing the broken warning leading to insecure setups.. ",
    "shaklev": "Same here. Hi @Sephster  , yes i'm using passport & with the update of the newest version of Passport this bug appeared . I found a workaround ( https://github.com/laravel/passport/issues/440 ) , adding\n\\League\\OAuth2\\Server\\Exception\\OAuthServerException::class, to the $dontReport array in the ExcpetionHandler. ",
    "andrewmclagan": "Yeah also experiencing this issue on Passport.. ",
    "christiaangoossens": "Related to #737. This issue still exists.. Resulted in PR #923.. +1, this would be very useful.. I agree with @michaeldnelson that we should use the cid claim for the client_id and that aud should actually be a list of the resource servers who are the recipient of the token. However, this would require the user to pass in a list of all resource servers (which may be the same server, or a very long list of servers). This would possible require adding a new Repository to keep track of resource servers.\nFor simplicity, and because aud for client_id is not strictly wrong according to the standard, although it hinders checking if the tokens are meant for that resource server (that would only be fixed if you specify the server in the request), I would not - at least soon - change the current behaviour.\nJust my 2 cents.. +1, I implemented this now (for adding a group ID to the token) by extending all the grants, which isn't the nicest for maintainability.. > Personally as a client hoping for a token with the correct scopes (which themselves are presumably not changing as part of the data update), I\u2019d expect no warning about temporary refusal of the scope.\n\nTypically I\u2019d expect a temporary refusal as the response to the secondary request - the one to perform whatever action it is that\u2019s being locked by the data update.\n\nYes, that would be the nicest, but that would require checking permissions at the data endpoint (because data might be available for one group, but not for another at the same time, so you can't just disable the endpoint). I would like to keep the authorization and data servers seperated.\n\nWhat happens if someone (who has been granted the scope from earlier before the data update) tries to call an endpoint during the data update? Won\u2019t that be problematic?\n\nFor my usecase, no. Tokens are relatively short lived, and the data update blockage can last for a week, so the first hour won't be that bad. You could imagine my usecase as a personal schedule. The schedule may not be available during holidays when a new planning is made, and thus it might be disabled for a certain group (for instance Marketing), during which period new data is inserted. After this period, they should transparently be able to get the data again.\n===\nI have currently implemented this in the following way:\n\nRefresh Tokens are adapted to include all approved scopes, not the finalized scopes\nWhen a refresh token is used, a finalizeScope() call is made, to finalize the scopes in the same way as the normal flows do.\nThe scopes field is ALWAYS returned (instead of only on changes, or never, with the spec) with the tokens to indicate which claims have actually been granted.\n\nAn example flow is indicated below:\n\nAn authorize request is made with the scope parameter specified as: test.* demo.test.\nThe normal flow is used and the system checks if all those scopes are approved by the user for this client.\nThe scopes are compared with the actual permissions of the user in the finalizeScopes method. For instance this user has the permission test.test, demo.test and demo2.test right now.\nAn access token is issued with test.test and demo.test, as requested.\n\nA refresh token is issued with all the approved scopes (test.* demo.test).\n\n\nIf the refresh token is used to obtain a new access token, the finalizeScopes method is called again. Now the user has the test.foo and demo2.test permissions instead of the previous ones.\n\nA new access token is issued with test.foo, because demo2.test wasn't in the original request, but test.* was.. I would agree that the spec doesn't specify this usecase, but as I'm using authorization code flow (with external authentication in there through SAML) in my first-party apps, it would be bad to keep asking people to login again if the scopes are not sufficient. With this system I could request all app.* permissions and approve them beforehand (as you would with first-party apps).\n\nThen, the API can dynamically insert app.schedule if it's available.. > I would definitely recommend moving things around. For example, if you know that certain parts of the data may not be available for certain groups/teams of users for a specific amount of time, give different scopes to different groups.\nSadly, I don't see how this would solve anything. Do you mean giving groups different permissions ahead of time? What if it changes?\n\nStill in your scenario, from the perspective of this library, your logic that's overriding approved scopes (removing the ones that are temporarily unavailable) can't be seen as anything other than a scope being approved or not by the resource owner as there is no method of persistence internally - only via the refresh token.\nFrom that perspective, I'm not sure that this specific case is something we can actually add to OAuth2 Server.\nTo achieve this, you would need to persist the approved scopes separately (probably in a DB record) from the granted scopes (which are encrypted in the refresh token) and then apply your logic in reverse when the refresh token is used, checking to see if any of the scopes that have been approved can now be granted.\n\nHow is this last idea different from storing all approved scopes in the refresh token directly, and removing the ones that are not being granted? Do you have a solid reasoning against using the refresh token as 'internal storage', especially in a stateless environment? It seems that you are using the DB in essentially the same way, as I am the token. The refresh token will always contain the list that the user has actually approved, in the same way as the access token would if all scopes would always be granted (but this time encrypted in the refresh token).. > You can do that and I'm not saying that you shouldn't.... I'm saying that OAuth2 Server shouldn't - at least not yet.\nI think most people are indeed still using OAuth2 for third party only, and using their own more dynamic permissions system for their own apps, and thus will never need this behaviour.\nHowever, if you want to integrate your permissions system fully with these tokens, one would expect to be able to add and remove scopes/permissions dynamically, and currently this library doesn't add originally granted scopes back in after removal and re-adding.\nI don't think this should be implemented right now, but it would be nice if some of the verification code in the grants gets moved to it's own method, and for instance validateAuthorizationRequest could be reduced to the scopes finalization and actual token issuing, which would make extending the classes without effecting security easier:\nFor instance for the Implicit Grant:\n/**\n     * {@inheritdoc}\n     */\n    public function validateAuthorizationRequest(ServerRequestInterface $request)\n    {\n        $clientId = $this->getQueryStringParameter(\n            'client_id',\n            $request,\n            $this->getServerParameter('PHP_AUTH_USER', $request)\n        );\n        if (is_null($clientId)) {\n            throw OAuthServerException::invalidRequest('client_id');\n        }\n        $client = $this->clientRepository->getClientEntity(\n            $clientId,\n            $this->getIdentifier(),\n            null,\n            false\n        );\n        if ($client instanceof ClientEntityInterface === false) {\n            $this->getEmitter()->emit(new RequestEvent(RequestEvent::CLIENT_AUTHENTICATION_FAILED, $request));\n            throw OAuthServerException::invalidClient();\n        }\n        $redirectUri = $this->getQueryStringParameter('redirect_uri', $request);\n        if ($redirectUri !== null) {\n            if (\n                is_string($client->getRedirectUri())\n                && (strcmp($client->getRedirectUri(), $redirectUri) !== 0)\n            ) {\n                $this->getEmitter()->emit(new RequestEvent(RequestEvent::CLIENT_AUTHENTICATION_FAILED, $request));\n                throw OAuthServerException::invalidClient();\n            } elseif (\n                is_array($client->getRedirectUri())\n                && in_array($redirectUri, $client->getRedirectUri(), true) === false\n            ) {\n                $this->getEmitter()->emit(new RequestEvent(RequestEvent::CLIENT_AUTHENTICATION_FAILED, $request));\n                throw OAuthServerException::invalidClient();\n            }\n        } elseif (is_array($client->getRedirectUri()) && count($client->getRedirectUri()) !== 1\n            || empty($client->getRedirectUri())) {\n            $this->getEmitter()->emit(new RequestEvent(RequestEvent::CLIENT_AUTHENTICATION_FAILED, $request));\n            throw OAuthServerException::invalidClient();\n        } else {\n            $redirectUri = is_array($client->getRedirectUri())\n                ? $client->getRedirectUri()[0]\n                : $client->getRedirectUri();\n        }\n        $scopes = $this->validateScopes(\n            $this->getQueryStringParameter('scope', $request, $this->defaultScope),\n            $redirectUri\n        );\n        // Finalize the requested scopes\n        $finalizedScopes = $this->scopeRepository->finalizeScopes(\n            $scopes,\n            $this->getIdentifier(),\n            $client\n        );\n        $stateParameter = $this->getQueryStringParameter('state', $request);\n        $authorizationRequest = new AuthorizationRequest();\n        $authorizationRequest->setGrantTypeId($this->getIdentifier());\n        $authorizationRequest->setClient($client);\n        $authorizationRequest->setRedirectUri($redirectUri);\n        if ($stateParameter !== null) {\n            $authorizationRequest->setState($stateParameter);\n        }\n        $authorizationRequest->setScopes($finalizedScopes);\n        return $authorizationRequest;\n    }\nwould be nicer if it was (or something like this):\n/**\n     * {@inheritdoc}\n     */\n    public function validateAuthorizationRequest(ServerRequestInterface $request)\n    {\n        $this->checkAuthorizationRequest($request);\n        $redirectUri = $this->getQueryStringParameter('redirect_uri', $request);\n        $scopes = $this->validateScopes(\n            $this->getQueryStringParameter('scope', $request, $this->defaultScope),\n            $redirectUri\n        );\n        // Finalize the requested scopes\n        $finalizedScopes = $this->scopeRepository->finalizeScopes(\n            $scopes,\n            $this->getIdentifier(),\n            $client\n        );\n        $stateParameter = $this->getQueryStringParameter('state', $request);\n        $authorizationRequest = new AuthorizationRequest();\n        $authorizationRequest->setGrantTypeId($this->getIdentifier());\n        $authorizationRequest->setClient($client);\n        $authorizationRequest->setRedirectUri($redirectUri);\n        if ($stateParameter !== null) {\n            $authorizationRequest->setState($stateParameter);\n        }\n        $authorizationRequest->setScopes($finalizedScopes);\n        return $authorizationRequest;\n    }. I could try to prepare a PR soon with some stuff moved around into new methods (such as in the example above), so that the core business logic (such as creating the actual tokens, or finalizing scopes) may be more easily extended, while keeping the profits of recieving the updates on those checks. I will try to make it non-breaking, so that it can be included as soon as possible.\nThings like #885 might even be possible then by just creating extended copies of every grant, instead of the current method of nearly copying the entire classes to change single lines in the long methods.\nMy use-case could than also just be implemented as a custom version of every grant, by extending the originals with minimal code changes.\nAlso, thanks to you! I do agree that although with appropriate documentation this method of granting scopes would propably work fine for most people (as if you don't change available scopes during the flow, there would be no difference), but that it may not be necessary for everyone, and making an easy extension method seems like the better option, instead of bloating the library with extra functions, that most people don't need (yet).. As said above, any PR that will follow out of this will NOT implement any functionality described above. It will only make creating extensions of grants easier.. Furthermore, any advice/tips on how this should be implemented (as apparently nobody uses scopes for permissions in first party apps) is welcome from more experienced implementers of the standard.. Thanks for the advice @Sephster. The main advantages of my current method over yours seem to be the following:\n\nThe (OAuth) authorization server can handle complex group rights and management of when endpoints are available for exactly which users. Thus the decoupled benefits of the system are preserved.\nEndpoint servers (which may also be other microservices) never need to be aware of permissions or users and thus never make a call to the authorization service\nTherefore the endpoint code also stays cleaner and less complicated, as I don't need to create a system to manage permissions in those seperate services \n\nDo you have another view on these points or a method to implement them with your method?\nI agree that it's best to use everything, including scopes, as everyone is using them, although I am not doing anything that the spec does not allow, though the way I implement this may be unexpected for developers.. It may be important that I have a lot of very complex group to permission to endpoint relationships, so I require a lot of flexibility in permission granting. I can however deal with waiting 5 or 10 min (accesstoken lifetime) for the current access token to timeout, so further access can be prevented.\nI had thought of a solution to do it your way, with having a seperate server where every endpoint would be able to check if the user has the permission right now, but this would introduce a single point of failure for all endpoints, and I would, instead of 5 token refreshes per hour, have hundreds of individual endpoint requests to check if users have the permissions, which kinda negates the point of having scopes in the first place.\nFor further insight my situation is provided below:\nFor this API I have students and teachers. I have endpoints for the students to see their schedules, grades, homework etc. For each endpoint I have a scope (such as schedule:read). Students are grouped in their class groupes. I have to deal with requests from the school to block students from seeing their schedule during the holiday, because it's populated with new data (this would apply to all students, so I could just revoke the scope temporarily), but also to prevent for instance only the first three classes from seeing their grades during a certain period, but not the last three. I also want students to login as few as possible in my first-party app which also uses the OAuth2 system from my API. I am using the OAuth2 system myself as well (and not only for third-parties) because it's linked with an external OpenID Connect provider, and thus Resource Owner Grant is not possible (no passwords locally), and I'm forced to use Authorization Code Grant or Implicit Grant. I don't want to build a seperate system for first parties if possible.. This has resulted in PR #924. I will close it, as we'll continue discussion in that PR. As said earlier, the PR does not include anything to change how scopes work, I have implemented this in a much better way which didn't require rewriting half the library :+1: . I wrote a blog post about this, for future reference: \nPart 1: https://chrg.nl/2018/07/25/modern-first-party-auth/\nPart 2: https://chrg.nl/2018/07/26/not-so-easy-oauth2-for-first-parties-part-2/. While looking at making a PR for making the addition of information to JWT's easier, I found the solution to this problem as well. Line 66 seems to be a documentation error, you should pass in the responseType (linking to your implementation of BearerTokenResponse) as the last parameter when creating the AuthorizationServer, instead of overwriting elements of that class. The documentation block should be changed to reflect that.. @Sephster This PR was intended to add an option for the server to easily add stateful information into the code granted at the end of the auth code grant, not to allow the client to do this. This would prevent having to store that data, and a separate identifier in a shared database.\nWith regards to the access tokens itself, this again goes into the contract between server and resource owner which may still indirectly depend on the client (for instance user1 + client2 => extra attr about role4) but was never intended to change as dramatically as you describe by client data.. ",
    "AndrewNovikof": "Hi @Sephster! Thank you for response! I assumed that this specific update does not suit everyone and can be a serious vulnerability for someone. . ",
    "DewaldBodenstein": "@chervand have you found a way to accomplish this?. Thanks, got it working.. ",
    "JasonTheAdams": "@loganto I believe it depends on the type of grant you're doing which drives where the scopes get stored. In the Client Credentials grant, for example, the user scope table is unnecessary as there are no \"users\" in that grant.\n\nSomething I'm confused by is id's versus identifiers. In all of the interfaces only the identifier is used, never the id. AccessTokens are where this is really odd. In the access_tokens table by @sergeyklay, there is a client_id column which is an BIGINT UNSIGNED. But the client interfaces only required the identifier. If we look at the clients table there are two columns, id and identifier \u2014 the former is a BIGINT UNSIGNED and the latter is VARCHAR(128).\nAccording to this, it would seem that the client_id is the id column. But it can't be as it's not even the right type to store it. Having both the id and identifier columns seem redundant, and the latter should so have a UNIQUE constraint.\nI may be wrong, but I believe the clients table should only have an identifier (or id, whatever you want to name it) column that is a VARCHAR(128) for storing the long identifier. The access_token table's client_id should then match this column type.\nStoring the id in that column seems nice but the interfaces suggest that it's the long identifier and not id that's being stored. I could be wrong. It's possible the mix up of the two terms just lends this whole setup to be confusing.. @simonhamp Any progress on the documentation? Would love to see this project get proper documentation.\nI'm ~70% of the way through integrating this into a vanilla PHP project, and it's been quite the undertaking. The documentation feels like it's written as a loose reference for those that made it, not for anyone new. The interfaces, especially, I find I'm just having to search through the lib code to see how methods are used to make sure I utilize them properly. Also things like the fact that the lib generates the Access Token identifier, but not the client identifier/secret. It's unclear as to which side is doing what.\nI feel like what really needs to be communicated in this docs is:\n- What's included in the lib (interfaces, traits, etc.)\n- What the lib is doing, in some detail, for each section (client, access token, etc.)\n- What's expected of the implementor (e.g., OAuth2 Server generates the tokens, you generate the client id and secret)\n- Tentative data structures for common use cases (i.e. MySQL)\nThank you for your willingness to give it a shot! The PHP League generates great libraries, I just wish they were as well documented as they are built. ;). Thanks for your thoughts, @Sephster! That makes sense. It doesn't have any \"functional\" purpose for this library, but I agree that it's a good idea to have it if it's part of the spec. The implementing developers can decide if and how to utilize the name further.\nI'm going to close this as I think it should definitely stay since it's part of the spec.. I was confused by this at first, thinking there was an integer id (such as a typical auto-incrementing primary key) as well as the long identifier. I realized, though, that there really only needs to be the identifier. So in my case it's always a string and it works fine.. Ahah! I get it now! \ud83d\ude04\nThank you for breaking down the JWT, that made me realize that I didn't fully understand the JWT standard, so I did some more homework. Now it makes sense. I also thought the JWT was validated on the client side, which it's not; it's validated on the resource server (which in my case is the same server as the authentication server).\nThis is a tangent question, but if you don't mind I'd be interested in your input. The JWT validates that the client is who they say they are and cleared to have access to the resources they're requesting. But what's a recommended way of offering some security in terms of the payload sent from the client to the resource server? In my case, the client may be passing somewhat sensitive information. The resource server is required to have an SSL certificate, but not the client. Is this enough? Should some form of end-to-end encryption be used? In which case do you per chance have a recommendation?\nThank you for any and all advice!. Got it, thank you! Should I require that the client server use https, or is it enough that the authentication and resource servers use it? There's a good chance many client sites will be on https, but I'm deciding whether it should be a requirement. Thank you for your advice!!. Got it! I have this working, now. Thank you!. In this project I'm only using client credentials, and have two resource tables \u2014 Clients & Websites. Clients is a resource (think business client) which has a one-to-one with the OAuth Client table. So each OAuth Client will be connected to one Client. In fact, in the API, when one creates the Client resource, it's also creating an OAuth Client and then connecting the two (the Client table has a oauth_client_id column).\nFrom there, each Client has many Websites, in the same way each OAuth Client has many Access Tokens. So the relationship continues such that each Access Token corresponds to a single Website.\nWhat I'd like to do in the API, then, is that when an AccessToken is requested and created, it also creates a Website and connects the two. That said, if the token expires I don't want the website to expire. So perhaps instead of using the same endpoint I should break it into two: One which returns a JWT Access Token, and another which creates the Website. The Website endpoint would require the JWT to be provided.\nI've really been trying to figure out how kosher it is to connect the OAuth tables with my resource tables. They run in parallel in a number of ways, but I know they should be distinct in most ways.\nAnyway, there's my scenario. Open to any thoughts! Thanks! :). Hi @Sephster, thanks for checking in!\nPer your feedback I decided to hire a consultant to talk over the OAuth to Resource details. I learned that I was being overly clever with the authentication and resources. There is always a contact point of some type between the OAuth and Resources, but it ought to be minimal, clear, and very secure.\nIn this case, the Website resource is now connected to the OAuth Client \u2014 since we're not using users (just client credentials) we need an alternative resource. The Access Token will give the each website access to only the resources under a specific Website resource. The Website id is included in the JWT so it can be authenticated in each request. That's the lockdown and it makes sense now.\nAll that to say this is all set. This lib is working perfectly and I'm moving forward without issue. I'll go ahead and close this. Thanks so much for your guidance!. ",
    "x0st": "@Sephster What do you think about justinrainbow/json-schema? I think it is easier to use and more understandable. . Thanks for reviewing. I will fix it ASAP. ",
    "bretterer": "@Sephster I thought we had that green light.... Left him listed as creator up in the document.\ntodo, update the email address once it is set up.. Ill start off the comments....\nI have yet been successful of getting the server running for a vanilla PHP install.   Always use it through Laravel..... I tried a little while ago, and found it very confusing and incomplete.\nA full \"zero to hero\" should be built as a sample repo or something to help get people started with this.. #794 \nLooks like we need to add what a base set of tables looks like, possibly look into having either a \"migrations\" package for this, or just leave it to the samples.. ",
    "soundsgoodsofar": "That would be fine but it doesn't address the issue at hand.  Those DateTime objects are still reliant on system time.  System time can, and in real world does, drift between servers.\nSo the problem with this approach is:\n1. User requests token from Server A.\n2. Server A returns a token with iat timestamp 100000\n3. 200ms later, user tries to use token in API call which gets sent to Server B\n4. Server B's system time is 2 seconds behind Server A\n5. Server B thinks that oauth token is from the future and rejects it\nThere's really very little use case for having oauth tokens with precise-to-the-second verification.  If anything, there should be a tolerance on verification for 60 seconds or so to make sure that some drift is tolerated.  At a minimum, this definitely shouldn't be precise to the exact second.. My suggestion would be to modify AccessTokenTrait::convertToJWT and change these two lines:\n->setIssuedAt(time())\n            ->setNotBefore(time())\nto:\n->setIssuedAt(time() - 120)\n            ->setNotBefore(time() - 120)\nThat would make these tokens issued timestamps 2 minutes in the past, which should be plenty to deal with normal drift, and not have any likely impact on usage.  If you wanted to make that a configurable property in case someone wants to modify that time that would make sense.  But I think the default case should definitely be to add a reasonable amount of buffer time.. Well drift isn't something anyone wants.  But it's something that will affect any product that scales to the point of needing more than one server.  You really don't want your default configuration to be something that works in a single-server environment, but breaks when you move to multi-server.\nI would also say that portability is really the point of oauth.  So a library that is not tolerant of normal issues with distributed networks seems problematic.\nTo your point, yes 120 is magic, but it's normal magic.  Your browser has a magic number of seconds after which it will timeout a network connection.  Magic timing thresholds exist throughout asynchronous systems, and if you want to enforce a timing constraint on an oauth token, you have to pick some amount of acceptable drift in time between systems.  Currently the acceptable drift amount chosen is zero (which is also a magic number) and I'm just pointing out that that is a bad magic number.\nMy personal opinion would be to just remove this check entirely, which is what I've done in my own fork.  It really doesn't add anything in terms of security.  But if you really want to keep it, the only option is to add some amount of timing tolerance that seems reasonable.  I can submit a patch for the former case if the repo owners like.. I don't actually believe that would help.  NBF and IAT are being set and checked the exact same way right now.  If you want to keep one or both of them it should be fine, but you still need to add a bit of tolerance to the validation method.\nIMO just leave them both set as they are now and add at least 5 seconds up to 120 seconds of tolerance on the check.\nAnother option would be to just expose the ValidationData object as configurable and let people decide.  I would still argue that the sensible default should be something tolerant of distributed timing drift, but at least making it fixable without forking the project would be great.. This bit us again in production today and I just want to bump this again as extremely important in real-world scenarios.\nThere's an open issue on the upstream lcobucci package for this problem as well.  Seeing it addressed in either place would be great.\nhttps://github.com/lcobucci/jwt/issues/191\nI added the composer post-install patch I'm using to the issue above.. ",
    "syrm": "No for two reasons : \n- the interface doesn't allow it\n- null instanceof ClientEntityInterface  and you get an error. ",
    "Oxmoze": "Hi @lucasantarella \nAre you aware of the OpenID Conenct specification and the response_mode parameter?\nI think it would be better to support this authentication request parameter instead that solution as it may confuse developers and may not be supported by clients.. ",
    "lucasantarella": "HI @Oxmoze \nThanks for the quick response. I'm not sure how the response_mode parameter translates to modifying the way the auth responses are given back to the client. This is probably due to my ignorance on the subject \ud83d\ude04 . \nCan you show me how to utilize this functionality to achieve a response that gives the access_token as a query parameter in the callback uri?. ",
    "gingabeard": "@pilotcurler I know this has been a while, but for others' benefit who Google their way here..\nSymfony 3+ DI  wants the services type-hinted in the controller endpoints and entity constructors.\nMy bundle services.yml looks a bit like this:\nLeague\\OAuth2\\Server\\AuthorizationServer:\n    class:       League\\OAuth2\\Server\\AuthorizationServer\n    arguments:\n        - '@MyAuthBundle\\Repository\\ClientRepository'\n        - '@MyAuthBundle\\Repository\\AccessTokenRepository'\n        - '@MyAuthBundle\\Repository\\ScopeRepository'\n        - \"%oauth2_private_key%\"\n        - \"%oauth2_encryption_key%\"\n\nLeague\\OAuth2\\Server\\Grant\\PasswordGrant:\n    class:    League\\OAuth2\\Server\\Grant\\PasswordGrant\n    arguments:\n        - '@MyAuthBundle\\Repository\\UserRepository'\n        - '@MyAuthBundle\\Repository\\RefreshTokenRepository'\n\nLeague\\OAuth2\\Server\\Grant\\RefreshTokenGrant:\n    class:    League\\OAuth2\\Server\\Grant\\RefreshTokenGrant\n    arguments:\n        - '@MyAuthBundle\\Repository\\RefreshTokenRepository'`\n\n..Then you grab them in the various constructors & controllers, ie:\n```\nMyAuthBundle/Controller/TokenController.php\npublic function tokenAction(AuthorizationServer $server, PasswordGrant $passwordGrant, RefreshTokenGrant $refreshTokenGrant, RequestInterface $request ): Response\n    {\n        $passwordGrant->setRefreshTokenTTL(new \\DateInterval('P1M'));\n//etc\n```\nYou'll need some PSR7 jiggery-pokery too:\nuse Psr\\Http\\Message\\RequestInterface;\nuse Zend\\Diactoros\\Response; //implements Psr\\Http\\Message\\ResponseInterface\n(edit:)\nAlso worth mentioning that I had an issue using the vendor repositories, in that I got tied up in knots trying to implement League\\OAuth2\\Server\\Repositories(whatever)RepositoryInterface and extend Doctrine\\ORM\\EntityRepository with the same class, so eventually gave up and split them into separate classes, passing the Doctrine Manager for each entity to the Repository:\n```\nuse League\\OAuth2\\Server\\Repositories\\AccessTokenRepositoryInterface;\nuse MyAuthBundle\\Doctrine\\ORM\\AccessTokenManager;\nuse League\\OAuth2\\Server\\Entities\\ClientEntityInterface;\nuse League\\OAuth2\\Server\\Entities\\AccessTokenEntityInterface;\n/*\n * Class AccessTokenRepo\n * @package MyAuthBundle\\Service\\OAuthRepository\n * @author ...\n /\nclass AccessTokenRepo implements AccessTokenRepositoryInterface {\n/**\n * @var AccessTokenManager\n */\nprivate $accessTokenManager;\n\n/**\n * AccessTokenRepo constructor.\n * @param AccessTokenManager $accessTokenManager\n */\npublic function __construct(AccessTokenManager $accessTokenManager)\n{\n    $this->accessTokenManager = $accessTokenManager;\n}\n\n```\nNot an even slightly elegant solution, but it works.\nHTH ppl. Yea that makes sense - traits more of a clue than a final implementation, thanks guys.\nI'll just override the props for now to keep Doctrine happy (new to me too, but really easy to use once I had an example to copy,) and ditch the rest of the traits when/if we veer away from them.\nCheers. Handy, thank you. Implementing that scope finalizer was giving me a headache, so it was nice to lift yours :). ",
    "raulferras": "Much clearer now, thanks!. ",
    "SunMar": "See defuse/php-encryption#359 for information about PBKDF2 being slow vs using a Key. Unfortunately I can't give any benchmarks but our performance tests showed that the PBKDF2 hashing algorithm was forming a big bottleneck, taking up to 50% of a request's total processing time. Once we put some hacks in place to use a Key instead, the bottleneck disappeared. The HKDF hashing did not take significantly more time than any other code being run during the request.. Also see defuse/php-encryption#161 which is the original use case for implementing the PBKDF2 algorithm. From what I understand it's for cases where you don't store the key on the server, but have it supplied by the user in the form of a password. PBKDF2 is then used to turn the password into an encryption key and it's meant to be slow to protect against attacks like brute force. However if you are storing the encryption key on the server, and it's a strong encryption key then PBKDF2 is not necessary, only HKDF should be secure enough. The Key object by default generates strong keys that are 32 bytes long and because it uses random_bytes() it's not limited to human readable characters like a password is. The Key object even forces you to use its createNewRandomKey() function by not allowing the class to be changed through final and only accepting its own custom format for import/export of keys. So I think it might even be better practice anyways to use a Key instead of a password for the encryption key via AuthorizationServer. The only con I can think of is that you need to store the Key somewhere, you can't use a key you already have because you can't import just anything as a Key object, but that is an issue I guess that would need to be addressed by the person implementing thephpleague/oauth2-server and doesn't need to be a concern of this package itself.. Perhaps when this is merged and in a release, the following documentation should be updated too to reflect the ability to use a Key:\nV5 Security Improvements#6.0.0\nInstallation#Generating encryption keys\nFrom skimming through he documentation I couldn't find other places referencing encryption keys.. Ok, I found the gh-pages branch and also created a PR #820 for that branch to reflect the changes in the documentation, if they are accepted.. Sorry, I made a bad bush and deleted the fork but now I can't update this PR anymore. Closing this and creating a new one.. @Sephster Ah yes, sorry, forgot about those interfaces. Phpdoc updated for the interfaces too.. I also updated the PR to remove some code duplication in the CryptTraitTest.. @simonhamp setEncryptionKey() is called by AuthorizationServer and is basically a pass-through for whatever encryption key is passed when doing a new AuthorizationServer, which is done by whoever is implementing this package and is not done by the package itself.\nSo I'm not really sure how to get rid of the if, because the library doesn't have control over whether the encryption is a string or a Key. This way it stays backwards compatible, if you pass a string it does the current implementation of encryptWithPassword() and only if you pass a Key it uses encrypt().\nNote that in the tests doEncrypt() and doDecrypt() are just pass-throughs in the stub to encrypt() and decrypt() because they are protected and can't be called directly. See CryptTraitStub.. @Sephster Is the PR ok for you too? I updated the change you requested.. @Sephster I've updated the branch. What I'm not sure however about is the text for generating a string password, from the previous documentation I've left this command:\nphp -r 'echo base64_encode(random_bytes(32)), PHP_EOL;'\nHowever the funny thing is, because random_bytes(32) is used this actually already is a secure key, it's not a potentially unsafe password. If you generate a \"password\" like that, it's much better to use the Key object and eliminate the performance hit. But I don't really know what to write there or what kind of use case you'd have with an \"unknown\" password.\nWhat I guess my suggestion would be is to completely remove the string part from the documentation and just tell people use generate a secure Key instead. That the code also accepts a string for backwards compatibility can then be added as minor note instead.\nWhat do you think?. ",
    "sg3s": "Hi,\nI just wanted to note that I encountered this exact issue too, when I was implementing the (php-encryption) library directly in my own project for different purposes (after having found it in this project).\nIn my case when decrypting just one item while using decryptWithPassword the PBKDF2 overhead accounted for almost 200ms of the process time for a request that took ~260ms total, which was ~60ms without decrypting the value (profiled with xdebug / qcachegrind).\nAfter switching to the methods described in the defuse/php-encryption documentation this slowdown essentially disappeared.\nCheckout the neat bin script the lib provides to generate a key, might want to include that in the docs maybe?\nThe performance hit is significant, I came here to see if it was a known problem. Good to see someone already beat me to it. Would be good to see this updated upstream :). Just wanted to chime in, as this currently seems the most correct location to place this.\nAs stated, by default PKCE is optional, not required by default, and the fallback should be implicit.\nBut PKCE was made to better secure authorization codes for public clients that cannot keep a secret, so it makes sense that some clients ARE required to use it. And in fact, this is stipulated in the RFC \"OAuth 2.0 for Native Apps Section 6\" so some clients should be forced to use it.\nThis should be on a per-client basis (especially important for multi-client setups that mix public and private clients) just as the use of a client secret should be. I don't have a good idea how to solve this (but ideas are welcome, I need it, so I might make it) but I think it does warrant further scrutiny.\nTo recap, as far as my interpretation of the RFCs goes.\n1. If code_challenge is present in the authorization request it enables PKCE checks (if the server supports it) and code_verifier is required in the token request. \nhttps://tools.ietf.org/html/rfc7636#section-5\n\n\nIf we are dealing with a public client the client_secret can be optional and in fact might be construed as a violation of the spec if it is not a deployment specific registration\nhttps://tools.ietf.org/html/rfc6819#section-3.7\nhttps://tools.ietf.org/html/rfc6819#section-4.1.1\n\n\nIf we are dealing with a native client (by definition also public) the code_verifier should be required in the authorization request, thereby enabling PKCE \nhttps://tools.ietf.org/html/rfc8252#section-6\n\n\nAgain, I don't have a good idea on how to solve the latter 2 points (but suggestions are welcome), but I think those are separate from making PKCE optional, when enabled, which seems the goal of this PR.\n(also; PKCE functionality is not documented currently, but obviously there are also quite a few kinks to sort out, just saying). I have not been able to do an implementation myself as of yet, but since last time I did give implementation (witin league/oauth2-server) some thought.\n\n\nThe current issues stem from a functional misalignement with the spec. I think oauth2-server should follow the RFC as close as possible. \n\n\nThis means PKCE should be enabled when the code_challenge is present in the Authorization Request. Without having to explicitly enable it on the server, as the server can and thus should support it.\n\n\nThis means that the enableCodeExchangeProof() function and enableCodeExchangeProof property on the grant must be deprecated, and only used to replicate past behaviour to ensure backwards compatibility.\n\n\nThe above options / feature should be removed for the next major version of the plugin - or stubbed so that calling enableCodeExchangeProof() doesn't break anything but does nothing. PKCE is enabled automatically if the code_challenge is present.\n\n\nIn a separate feature the ClientEntityInterface and / or ClientTrait should be modified somehow to enable/allow the option of forcing PKCE per individual client when Authorization Requests come from said client. \n\n\nMaybe the last feature should be in tandem with the grant changes described in point 3 so moving over the forcing PKCE from grant level to client level is easier / retains essentially the same functionality.\nIf you take this route, keep the existing option only to keep backwards compatibility, then the changes are fairly minimal for point 1-4. \nCheck the included diff as example (changes based on current master / 7.2.0). Note; I intentionally kept some indentation unchanged to keep the diff to the minimal code necessary only. This should work but is untested (and phpunit still passes).\npkce-changes.txt\n. While the RFC is in draft it should not be used, it explicitly says so in the draft.\nWhile eventually something will be standardised, oauth2-server should refrain from adding uncertain/uncomplete features. I've checked what the larger vendors use in their JWTs, as far as I could find nobody uses cid for the suggested purpose (yet). \nIf they use something it is usually referring to claims in an ID token. Which is OpenID spec, which is not supported (yet?) through the oauth2-server. For ID tokens the aud claim MUST be the client_id of the client requesting the token, but they also should not be used by resource servers to authenticate requests.\nhttp://openid.net/specs/openid-connect-core-1_0.html#rfc.section.2 \nI'm guessing that this ambiguity resulted from the original specs being less specific and because those tokens were typically used by resource servers that traditionally fairly tightly coupled to the same vendor that distributed the tokens, it didn't really matter. What is clear though, is that no large vendors are using the aud claim in access tokens to store the client_id, but you can always add your own claim to remedy that.\nMaybe an option to correct this behaviour / allow people to add their own claims would be an option until this can be fixed in the default setting?. Today while trying to get this discrepancy documented I reviewed the information in several specs and I think it is useful to clarify a few things.\nThe specification referenced by @michaeldnelson is something else\nThe final version of the spec can be found here, and basically describes how to retrieve access tokens using JWTs from an authorisation server. It is used for 2 legged authentication scenarios (like the client credentials grant), usually where some kind of impersonation of specific users by a client without direct user input is used.\nIt is unrelated to the JWT contents in context of an access token used to communicate with a resource server.\nThe actual implemented specs neither explicitly define the JWT claim contents\nThe two RFCs that this library does explicitly implement are \"JSON Web Token\" describing the generics of a JWT and the OAuth2 specific \"Bearer Token Usage\". \nThe first defines the generic usage of a small list of claims, the latter doesn't even mention JWT and predates it by years. \nI've tried to find specifications that do touch upon this but could not find anything. Even OIDC does not go into this, probably because they consider it a problem of the resource server implementation. When you look at how explicitly id tokens are defined, it is a world of difference. If the wide range of implementations between authorisation servers is anything to go by, this might be a good candidate to make a specification for though.\nJSON Web Token (RFC7519)\nJSON Web Token (JWT) is a compact claims representation format\nintended for space constrained environments such as HTTP\nAuthorization headers and URI query parameters.\nWhat it does say about audience: \nThe \"aud\" (audience) claim identifies the recipients that the JWT is\nintended for.  Each principal intended to process the JWT MUST\nidentify itself with a value in the audience claim.\nThe interpretation of audience values is generally application specific.\nSo, this can be an array, with values that are of type string or uri. It also states that all principals intended to process the JWT MUST be in this property. From the OAuth2 core spec we know that access tokens are usually opaque to clients, so they themselves should not need to process the token. The client could still also be an audience, but that probably means you actually want an (OIDC) id token which is explicitly meant for use by clients. \nIt is ultimately left to specific implementation to define exactly what the audience actually is.\nBearer Token Usage (RFC6750)\nThis specification describes how to use bearer tokens in HTTP \nrequests to access OAuth 2.0 protected resources.\nThis document does not specify the encoding or the contents of the\ntoken; hence, detailed recommendations about the means of\nguaranteeing token integrity protection are outside the scope of this\ndocument.\nWhat it does say about audience (threat mitigation, summary):\nTo deal with token redirect, it is important for the authorization\nserver to include the identity of the intended recipients (the\naudience), typically a single resource server (or a list of resource\nservers), in the token.\nIssue scoped bearer tokens:  Token servers SHOULD issue bearer tokens\n      that contain an audience restriction, scoping their use to the\n      intended relying party or set of relying parties.\nThis quite clearly defines the resource servers as the audience, within the scope of OAuth2 access tokens. So believe this to be the most usable information to base the library implementation upon. But the bearer token usage spec does predate the JWT spec by years.\nThough, if a future specification would actually elaborate what is what in at least the generic claims that can be present in a JWT that should be leading (anyone have time for that?). \nConclusion\nThe OAuth2 server should and does make a stance here as specifics in this area are left to implementations. Having the client id in the audience is not wrong per-se, but resource servers should be added (config array / resource server repository interface?) as audiences too. \nThat way resource servers can verify the tokens are intended for their usage, which is something they MUST do according to the combined specifications, when the aud claim is present.. We've been patching this in our fork and this looks to be doing what we need to. Any chance this can get reviewed/merged?. @Sephster As you said the access tokens are consumed by the resource server, and you think we might be violating the spec with these changes. I can see how you can misuse the methods in this PR to do that. So maybe this isn't the right approach, but I do think the library should facilitate options to change/add to what is in the access token. \nThere is no single specification we can rely upon to define an access token, and thus in our case, the authorisation code (because we put most access token information in there). But the resource server can, and at least in our case does, care about which client is being used and from where. We add additional information in the access token to give our resource server a verifiable context which is more secure.\nWould it be an idea to maybe collect scenarios from users (open an issue, define a simple template for responses so you get a minimum set of variables) and then look at possible options for extensibility? This could allow you/the maintainers to get some insight on how the access tokens are (mis)used, then you can steer towards more appropriate solutions with features and documentation on what not to do.\nI like how the library takes a very strict stance on the specifications in how to fill in the different flows/interactions, that is why we selected this library, makes it less error prone, but we would like some more flexibility short of overwriting 5-8 classes to add a claim in a somewhat clean way, that increases security.\nI'm very much interested to help with any of that if it is appreciated.. Scenario 1\nWhat \nWe add the resource owner (but really the client retrieving the access token) IP to the token, and verify this matches with the client IP on the resource server.\nWhy \nWe have a client / resource server which we limited to specific networks. This can be done with webserver rules, but letting the application do it with an IP in the token allows us to control the error message and format much better, and keep the logic for determining the allowed networks centralised on the authorisation server.\nHow oauth2-server support would help\nCurrently we trust that the client receiving and using the authorisation code and using it to retrieve an access token is on the same network/ip. It is a javascript client after all. However this does not have to be true if someone managed to intercept the authorisation code. PKCE mitigates issues with that, but allowing the determine the authoriser IP when the authorisation code is created is cleaner & more reliable (as we control the authorisation server much more than the clients). \nThe same goes for functionality where the access token is locked to user-agent signatures or special device enrollment headers etc.\nScenario 2\nWhat\nWe allow impersonation of users for support purposes for certain clients (this is limited to certain employees who need at least explicit consent from a user on a phone call). The impersonator details are encoded in the access tokens used by clients. Our resource servers are semi aware of it for audit/activity log purposes and protecting various sensitive functions. Clients don't know the difference.\nWhy\nIt allows our service department to inspect systems/functionality as a user with very few real limits or differences when RDP support is not an option.\nHow oauth2-server support would help\nWe link the details to the relevant session in the database when authorising the client. Currently we retrieve and validate that data again when finalizing the access token. Being able to pass the necessary details when the authorisation code is created allows us to remove that overhead, it is again also cleaner as this is the stage where most of the access token is already determined.\n(In this scenario we also wanted to turn off refresh tokens for clients that can get them normally and maybe limit the lifetime of access tokens in that situation as well. It is a different issue but we pre-process requests and bootstrap the oauth2-server library with shorter/effectively useless TTLs on the refresh tokens to do this now... because it is not like the library makes this easy)\nThere are plenty of other scenarios where a certain degree of extensibility simply improves lives. We don't keep an active record of cases where we envision/brainstorm functionality and dismiss options simply because the oauth2-server does not allow for it, even if it is about crafting more secure systems, but it happens regularly.. I do not see an example curl command for for auth_code.php which should typically be approached with a webbrowser where you might have to log in as a user. But this seems like an error in the curl command you tried to use.\nIf you want to use this endpoint with curl you will need to tell curl to convert all --data arguments to query params with -G. The auth code requests also returns a redirect back to the client, which must also match with the registered redirect_uri, because of that you probably want to add the -i flag too.\nWhich would look like this for the example data:\ncurl -i -G \"http://localhost:4444/auth_code.php/authorize\" \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -H \"Accept: 1.0\" \\\n  --data-urlencode \"response_type=code\" \\\n  --data-urlencode \"client_id=myawesomeapp\" \\\n  --data-urlencode \"redirect_uri=http://foo/bar\" \\\n  --data-urlencode \"scope=basic email\" \\\n  --data-urlencode \"state=123123123asae\"\nWhich gives you a result like the following:\nHTTP/1.1 302 Found\nHost: localhost:4444\nDate: Thu, 26 Jul 2018 15:44:20 +0000\nConnection: close\nX-Powered-By: PHP/7.2.7\nContent-Type: text/html; charset=UTF-8\nLocation: http://foo/bar?code=<code_here>&state=123123123asae\nContent-Length: 0\nThen, using the code from the previous example, you can retrieve the access token (on the client side) with the following command:\ncurl -X \"POST\" \"http://localhost:4444/auth_code.php/access_token\" \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -H \"Accept: 1.0\" \\\n  --data-urlencode \"grant_type=authorization_code\" \\\n  --data-urlencode \"client_id=myawesomeapp\" \\\n  --data-urlencode \"client_secret=abc123\" \\\n  --data-urlencode \"redirect_uri=http://foo/bar\" \\\n  --data-urlencode \"scope=basic email\" \\\n  --data-urlencode \"code=<code_here>\"\nWhich should yield something like this:\n{\"token_type\":\"Bearer\",\"expires_in\":3600,\"access_token\":\"<jwt_access_token>\",\"refresh_token\":\"<encrypted_refresh_token>\"}\nThe example server itself looks to be working just fine ;)\n. I've had this exact question when I began devoting time to understanding all the different specs. \nFragment encoding in fact a part of OpenID specs. Definitely something you want if you want to work towards a fully OpenID Connect compliance. \nThe question is if that is something you/the maintainers want. The specs are backwards compatible with plain oAuth2 as far as I know, but might require significant changes to implement properly. For a large part OpenID specifies additions, so it could possibly be enabled by adding interfaces, traits for the extra entities and some extra configuration. \nThe specification describing (among other things) the fragment response type is I think one of the more divergent from plain oAuth2 but well understandable knowing the context of the original specs.\nhttp://openid.net/specs/oauth-v2-multiple-response-types-1_0.html\nPersonally I find these specs to be pretty hard to read, even compared to IETF RFCs, so for me this documentation of a OpenID Connect compliant server really helped me by framing the different features from an implementation standpoint.\nhttps://connect2id.com/products/server/docs/api\nOpenID Connect is something I've been personally been looking into as it solves some additional problems we've been having trying to use oAuth2 for our 1st party clients. But it is not something you just do, and I am pretty time constrained. I see the questions for OpenID Connect features pop up pretty often here too, so maybe it should be something to invest in.. To be complete; These are features that are in OpenID Connect that are pretty desirable to me:\n\nFragment responses for authorisation requests\nToken introspection (using RFC7662)\nToken revocation (using RFC7009)\nUserinfo\nLogin / session status through iframe\nLogout flows\n\nAnd to complete/manage that it also includes:\n\nServer discovery (see it as feature detection for clients)\nServer JWK set (publish keys needed to validate tokens)\nClient registration (for dynamic clients, like apps)\n\nI am not sure what a minimum implementation would be, but server discovery is definitely needed, and some features can be optionally exposed through server discovery.\nUnder \"Specification Organisation\" they list exactly what is optional and what is not.\nhttp://openid.net/connect/. It seems that the fragment is supposed to be used when using Implicit Grant in the core oAuth 2.0 spec.\nThough, I do think OpenID Connect does a much better job of defining how that actually works then.. Ah, missed that the PR made it an arbitrary character... \nNo that is definitely not right. The reason the fragment is used for the implicit grant is ofcourse to protect the token which stays local and is not sent to servers in requests by user-agents and thus does not show up in logs.\nThe spec that does expand this and does allow for another way is OpenID Connect - in the same document that I linked earlier response_mode is defined, and it is stated that the use of the option is not recommended. But if that spec is followed then the change should be based on the presence of the response_mode query param in the authorisation request.\nIt is not even mentioned in the original spec that you should be able to use a query string, even suggesting that for user-agents that do not support it in a Location header you should employ a different type of redirection. It does not mention switching over to using a query string, probably because this is inherently insecure for Implicit Grant responses.. The dilemma is that sometimes you want users to be able to grant clients access to specific entity IDs in a resource server which are not known to the client beforehand. A selection step is presented to the user when reviewing the client authorisation request. \nSort of how some central Git repositories (dunno if Github can do this) can let you share specific git repositories with 3rd party services, instead of blanket access to all repositories in an account.\n@jacksun101 I believe this is already possible by utilizing the ScopeRepository->finalizeScopes() function which you must implement as part of the ScopeRepositoryInterface.\nhttps://oauth2.thephpleague.com/scope-repository-interface/\n\nLet the client request the scopes as you defined. \nFeed the interface the selectable data for the user using the wildcard scopes. \nDo a (pre-oauth2-server) check for the input given by the user. \nUse the input given by the user during the ->finalizeScopes() to replace the wildcard scopes with the appropriate scopes and actual IDs embedded in them.. Loving the approach, looks good.\n\nI understand that the PR breaks backward compatibility, but seeing as previously clients were handled as confidential by default (and probably should be as the spec prefers confidential clients) shouldn't the trait/new default also be that clients are confidential by default?\nOr putting it in another way, wouldn't it maybe be preferred/clearer to make this $isPublic with a ->isPublic() function (and flipping the boolean values), so it relates more directly to the official specification context with the additional PKCE requirement and secret omission for public clients?\nMaybe I'm missing something, let me know, this is obviously weeks of deliberation and work, I just reviewed in ~10 minutes ;). I've mostly been been working with the Authorisation Code Grant and the puzzle to get that right for the different scenarios, so I guess that created my bias. \nYou're right, and thinking about it like that does make sense.\nThat leaves me with no further questions about the code itself.\nSo maybe a few points to update in documentation? One of the things I had difficulty with when starting out was determining in which scenario which grant should be used. Definitely because different revisions of different RCFs and information online conflict which each other. \nI tried to capture what I think are the current recommended best practices in my own 'Which Grant?' flowchart. Compared to the current chart in the docs I changed the basic questions and crammed more info in the chart itself. \n\nIt is mostly centered around the question if your client can keep a secret and that Authorisation Code Grant is usually preferred, even if you cannot use a secret, which is now more natural to do with the changes in this PR. The question whether a client is first- or third-party has little bearing on which grant you should use, so I removed most references to that. The Password Grant should also be usable with or without secret, but should obviously be avoided if possible.\nI tried to keep OIDC out of it, but I did end up referencing Dynamic Client Registration, and I wonder if additional explanation about the Multiple Response Types is useful. Maybe a definition of what is NOT in scope or currently planned for oauth2-server (explicitly mentioning OIDC features) could make that more obvious.\nIf you're wondering why Implicit Grant should be avoided, basically Authorisation Code Grant is a safer flow, especially with PKCE, and can be used for SPAs, so why not.. I should add that avoiding Implicit Grant is only applicable in a vanilla oauth2-server setup (without OIDC elements). \nIf you add functionality like session checks through an iframe (to replace refresh tokens) it becomes more interesting again, but this is standardised in the OIDC spec, and not in core OAuth2.. @jacobweber \nYour ImplicitGrant clients should continue to work without changes needed.\nFor clients using the AuthCodeGrant you may need to make some changes.\n- Let the oauth2-server know if clients are confidential (implement/make use of isConfidential).\n- Make sure you validate the secret with the new function (implement/make use of validateClient).\n- The getClientEntity can no longer receive a secret and thus should not validate it.\nIf your clients can keep a secret (i.e. they are not native/web clients) they should return true when isConfidential is called. If you use the supplied ClientTrait it will return false by default, so override if necessary/for your confidential clients. Returning true causes validateClient to also be called with the given secret in the token request, which is where you should validate the secret you stored for the client.\nWith this PR the PKCE checks are done if the code_challenge parameter is present in an authentication request, as per RFC specification. It is thus effectively determined by client if PKCE should be used. You should not need to change client configurations/code, unless you want/need to enable PKCE from the client side.\nThe requireCodeChallengeForPublicClients flag can then be used to force PKCE use for public clients from the server side, if wanted. . A TTL is optional according to the spec. But using one is highly recommended. It is one of the more controversial issues with the OAuth2 spec (indefinite refresh tokens).\nSystems that do allow for 'indefinite' expiration dates usually just set the expires at to something silly large like the year 2100. I think this is mostly so that one verification step can always be checking the expires at and you can count on the attributes existing in other steps.\n@nealoke I was curious if I could make the expiration a fixed date (used (new DateTime)->diff(new DateTime('2100-01-01')) to create a DateInterval that spans to the year 2100) and experienced no issues with the ~81 years refresh token token age. What could however be an issue is that if you change the refresh token TTL from the default, you will need to do so for all the grants you use that can grant one (so, the authorisation code grant) and the refresh token grant itself. Or the different grants will give you new refresh tokens with different TTL.. @nealoke That might indeed indicate that you are indeed storing it incorrectly.\nThe storage solution is left up to the implementer of the library, but it sounds like you might not be storing the time portion of the expiry datetime or the way you are converting the datetime from the database to a datetime (or equivalent) in php might not work correctly. It is weird how you describe that DateTime->format returns part of the format, as far as I know it should not do that.\nI would suggest simplifying the problem to its core constituents and maybe posting a question on StackOverflow if you don't discover the problem yourself during that process. This is likely not a problem in the library, but if it is we'll need a much more detailed description on how to reproduce this.. With the given configuration\n- Your refresh tokens created by the refresh grant should be valid for 20 years\n- Your access tokens created by the refresh grant should be valid for 1 hour\nWhen your initial refresh tokens are created with the AuthCodeGrant you will need to set the TTL for those refresh tokens separately.\ni.e.\n$authCodeTTL = new \\DateInterval('PT10M'); // 10 minutes\n$refreshTTL = new \\DateInterval(\"P240M\");  // 20 years\n$tokenTTL = new \\DateInterval(\"PT1H\");     // 1 hour; library default\n\n$authCodeGrant = new AuthCodeGrant($authCodeRepository, $refreshTokenRepository, authCodeTTL);\n$authCodeGrant->setRefreshTokenTTL($refreshTTL);\n\n$refreshTokenGrant = new RefreshTokenGrant($refreshTokenRepository);\n$refreshTokenGrant->setRefreshTokenTTL($refreshTTL);\n\n$server->enableGrantType($refreshTokenGrant, $tokenTTL);\n$server->enableGrantType($authCodeGrant, $tokenTTL);\n\nIf you do not use the $authCodeGrant->setRefreshTokenTTL($refreshTTL); the refresh tokens created during an AuthCodeGrant will have the default expiry time. \nI agree that this is a confusing implementation detail. I tried explaining this in my response 20 days ago too ;). Not in favor, setting a far future expires date is effectively just as good and makes you think about what you're actually doing. \nWhat would be good is somehow being able to set an expiration time for refresh tokens (or access tokens really) per client. So you can control / write logic to determine which clients are actually allowed to receive long lifetime tokens and which are not, instead of always using the defaults configured on the server/grant.. Shouldn't the ClientTrait at least define the default as false? It seems implied by the default being null here. That would also ensure the ->isConfidential() trait function always actually returns a boolean in its default state. Or am I missing something here?. ",
    "alterphp": "Ok, I understand I have to share the same client across subdomains (as I want to share authentication between them). For now, my trusted apps (subdomains) have their single own client ID so that I have to split those two layers.\nThanks for advice.\nOne last question, what kind of action do you expect to be achieved on REFRESH_TOKEN_CLIENT_FAILED event (in order to explain why this case emit an event and not other cases) ?. ",
    "Kingson-de": "Hey @Sephster,\nthe main problem right now is that you can't easily override the encryption of the tokens.\nSo my approach is that you only rely on the AccessTokenEntityInterface and RefreshTokenEntityInterface.\nThat way you can implement your own encryption of the tokens.\nCurrently if you have look on e.g. BearerTokenResponse there it is impossible to change the encryption.\nAlso if you compare the size of the Access/Refresh Tokens with Facebook or Google, they are more than double the size.\nIf you need more explanation, I am more than happy to help :). @Sephster For us we want to implement our own bearer format. But with this implementation you can also adjust the information you put into the JWT. Maybe you need more or less data in the JWT, which can't be changed right now.\nTo be fair with the PR I provided you could not really replace the encryption mechanism, there would be a lot more changes involved.\nThat is why I proposed to discuss a solution which is beneficial for this package in my first comment :). Hey @Sephster,\nthanks for taking the time to review.\nSadly #874 is just renaming convertToJWT to convertToAccessToken in AccessTokenEntityInterface which is a BC nonetheless.\nSo if you go for a BC then I would take the more flexible solution.\nStill the hardcoded generating of the refresh token in BearerTokenResponse is not fixed there.\nMaybe I will take another approach when I got time.\nBut thanks anyway for responding and providing this OAuth solution for PHP!. @lookyman Yes true, but this applies only to the access token. Refresh token can't be changed. So this fixes it only partly.. @Sephster In my opinion it would be nice if the refresh/access token entity implements how it is converted for transport and which data it contains. Similar to the JsonSerializable interface.\nFor simple tokens this should be enough.\nIf the transport format is more complex like JWT, an exchangeable/optional serializer could do the final transformation.\nSo in the JWT case the token entity will produce an assoc array and the JWT serializer will encode the array to JSON and encrypt it afterwards.\nWe could have a token manager that is able to convert the token to the transport format using token and serializer.\nIn the special case of refresh tokens they actually could be short because when the client wants to exchange it for a new access token, the client needs to send it to the Auth Server which should validate the refresh token. So the Auth Server needs to have a storage for the refresh tokens to validate them. If you only rely on decrypting the JWT then you have a security issue because your refresh tokens can't be revoked.\nAnd if your storage is for example Redis with twemproxy the querying is very fast, maybe faster than decrypting the JWT \ud83d\ude09 . ",
    "Zaszczyk": "Hi @Sephster, I'm sorry for the lack of response, I had not resources and time to code it. However it is interesting challenge and I will try to pick this up until end of March ok?. @Sephster are there tests of emitting events or already implemented events? Because I want to inspire, but can't find any.. ",
    "enesyurtlu": "I read examples and docs so many times. But I couldn't understand how I can pass scopes to my controller or routes section to make role based auth. I want to make scope check in the backend, not while sending authorization requests. And I wanted to store my admin users in another table. But I couldn't. \nI have 2 different routes. One for Admins and one for normal users. I want to secure both of them.. I added something extra.\n\nI have 2 different routes. One for Admins and one for normal users. I want to secure both of them. but don't want users to access admins area.\n\nI am using password grant for my admin panel that is made with angular 5. And I don't know which grant to use for website (users section).\nAdmin can edit anything add, edit, delete.\nUsers can add playlists, edit them and delete them. And change their profile settings, infos.. Want to add something I can send scopes with auth req, and server checks. But I am trying to check scopes while user trying to access a route.. Yes, I am sorry for being late to write. But I tried just now. Thank you so much. . My mistake was trying to get \"getAttribute('auth_scope')\". Now it works with \"getAttribute('auth_scopes')\" :). ",
    "dorin-niscu": "@Sephster Seems to be fine. Thanks.. ",
    "samiboukadida": "i have to add this line (before line 50)\n$oldRefreshTokenScopes = explode(' ', $oldRefreshToken['scopes']);\nperhaps i do make a mistake in using this package, could you confirm me. Thanks.. ",
    "tominek": "Hello can you please describe the issue more? Maybe include whole method. I am currently struggling on the same part of the code: \nRefreshTokenGrant:55\nif (in_array($scope->getIdentifier(), $oldRefreshToken['scopes']) === false) {\n    throw OAuthServerException::invalidScope($scope->getIdentifier());\n}\nMy issue is that scope identifier 'basic' is being searched in array of arrays\narray(2) {\n  [0]=>\n  array(2) {\n    [\"id\"]=>\n    string(5) \"basic\"\n    [\"description\"]=>\n    string(23) \"Basic details about you\"\n  }\n  [1]=>\n  array(2) {\n    [\"id\"]=>\n    string(5) \"email\"\n    [\"description\"]=>\n    string(18) \"Your email address\"\n  }\n}\nMaybe we are dealing with the same issue.. So looks like WE ARE dealing with the same issue. I just tried your code, but I am not sure that it is the best solution, as I am getting PHP Warnings:\nWarning: explode() expects parameter 2 to be string, array given in /var/www/vendor/league/oauth2-server/src/Grant/RefreshTokenGrant.php on line 51\nWarning: in_array() expects parameter 2 to be array, null given in /var/www/vendor/league/oauth2-server/src/Grant/RefreshTokenGrant.php on line 58\nWarning: in_array() expects parameter 2 to be array, null given in /var/www/vendor/league/oauth2-server/src/Grant/RefreshTokenGrant.php on line 58\nI think we can try to fix this and do PR.. Hello @Sephster , so I have investigated more and found the issue. I implemented jsonSerialize() method in Scope entity like this:\npublic function jsonSerialize()\n    {\n        return [\n            'id' => $this->id,\n            'description' => $this->description\n        ];\n    }\nas I wanted to also use description for the scope, but I have not realized that it would not work within the scope comparison in RefreshTokenGrant class.\nSo leaving the method like in the example code works, kinda my bad, but it is not very intuitive. Adding abstract class implementing this method with some additional informaiton about the required format would probably help.\npublic function jsonSerialize()\n    {\n        return $this->id;\n    }\nSo my issue is solved, lets wait for @samiboukadida :-). ",
    "liverbool": "@Sephster, When redirect back to client site (on error) it not use redirect_uri from query string but from database config instead. This's wrong behavior if i have added multiple redirect Uris in my database config (client config).\n. ",
    "amidia": "hi @Sephster yes i have. not all the grants thou. i successfully tried client_credentials and password grants. but still can't make a head or tail of it. maybe i'll try with another frameworks to learn and hopely with the time i can absorbs the idea behind it.\nthanks anyway.. ",
    "iliepandia": "Hi @Sephster , \nEventually after looking at your example in closer detail, because I could not understand how your tests are passing, I realized that jsonSeralize() was how you made it work. In my case jsonSeralize was returning much more than the identifier. \nSo yes, implemented jsonSerialize, as you suggest, does fix my issue, but in my opinion it hides the problem, not really fix it.\nI would suggest that here:\nhttps://github.com/thephpleague/oauth2-server/blob/8bbd21885635e132aaeca900e8221d8ca87cb6b9/src/Grant/AuthCodeGrant.php#L323\n$authCode->getScopes() be replaced with an array where for each scope you specifically call getIdentifier(). Maybe something like\nphp\n<?php\n$scopes = array_map( $authCode->getScopes(), function(scope){return $scope->getIdentifier() });\nThis way scopes will always have an array of identifiers regardless of how people implement the jsonSerialize().\nAnother solution could be to make it clear in the docs that jsonSerialize() needs a very specific implementation and will not work otherwise. . ",
    "ragboyjr": "Why don't we just pass the entire token instance into the request? Then if you'd like to attach more request attributes, you can do it in a middleware down stream.. @maximebeaudoin interesting. I feel like a request attribute is most appropriate for things like a parsed representation of the JWT. I could be wrong. \nGiving the entire token in the request would allow for a lot of customizations that wouldn't require updates to the library, but just a simple middleware downstream.. ",
    "michaeldnelson": "I'm not entirely sure how your scenario would work. When you issue the\naccess token, you would need to store it in the DB so you can later\nvalidate against it, even if it is only used one time. You could set a very\nshort lifespan for the access token as you mentioned but I can't think of a\nway to not store the access token within the confines of the OAuth spec.\nIt is my understanding that a signed jwt is self contained and its validity\nfor use can be determined by verifying that you are the signer, it does not\nrequire the verification of a database lookup.\nOn Sun, Feb 18, 2018 at 2:58 PM Andrew Millington notifications@github.com\nwrote:\n\nHi @michaeldnelson https://github.com/michaeldnelson. That's great to\nhear that you're finding the package useful. Thanks for supporting it.\nThe source files themselves don't use the getAccessToken method directly\nas you've stated. The reason we have access tokens at all in the refresh\nentity is because the server will issue a refresh token when it sends an\naccess token so bundling the two together in a single entity seems the\nlogical way to go. We have a setAccessToken() method to store the access\ntoken in the entity and have a complimentary getAccessToken() method\nshould the implementer need this for any reason.\nWe use this method in our tests for example, to easily verify that when a\ngrant responds to an access token request, it has set the access token\ncorrectly.\nI would be hesitant to remove this function as other implementers might be\nrelying on it for their own tests/use cases which I'm not aware of. It\nisn't adding any overhead to the base running of the system but does allow\nthe code to be more extensible. I hope you understand but if you have any\nmore questions feel free to ask about this.\nI'm not entirely sure how your scenario would work. When you issue the\naccess token, you would need to store it in the DB so you can later\nvalidate against it, even if it is only used one time. You could set a very\nshort lifespan for the access token as you mentioned but I can't think of a\nway to not store the access token within the confines of the OAuth spec.\nI would imagine you would actually increase the load on your DB slightly\nif you went down the route of having very short lived access tokens as you\nwould have a lot more writes to your database whenever you need a new one.\nYou would also need to go through the authentication process a lot more.\nApologies if I've misunderstood the scenario you outlined but I hope this\nhas been of some assistance.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/issues/855#issuecomment-366542741,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAyoMRDQZgC1hHS79GNrEMPj8R-B7zJOks5tWIDcgaJpZM4SJyZx\n.\n. Hi @Sephster \n\nHere is an article detailing the use of JWS to sign access tokens to reduce db lookups.\nhttps://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/\nHere is a relevant except:\nWhether tokens are opaque or not is usually defined by the implementation. Common implementations allow for direct authorization checks against an access token. That is, when an access token is passed to a server managing a resource, the server can read the information contained in the token and decide itself whether the user is authorized or not (no checks against an authorization server are needed). This is one of the reasons tokens must be signed (using JWS, for instance). On the other hand, refresh tokens usually require a check against the authorization server.\n. Thank you for your responses. I have some thoughts about possible scenarios but it seems like a lot of this is still very fuzzy especially around securing single page apps :) Regardless, as I said, I appreciate this library.  It provides a lot of functionality while not forcing an implementation.  . I think you are right that this is not explicitly prohibited.  Closer reading of the spec leaves this open for interpretation.  I've just never seen it used this way.  Personally my issue with this is that I validate the audience claim against $request->getHost(), this is a simple added layer of validation that doesn't require a database lookup.  This is particularly useful if a token should be locked to a specific subdomain.  Again this can all be validated with client id, it's just a little weird to me because I would consider that who is using the token, not the audience of the token.  Additionally validation using the client id requires a db lookup, where host alone does not. But, as I said, I was wrong to assume this was \"incorrect\" it just was just cognitive dissonance for me and a challenge for my use case.. There is a cid claim for this purpose it looks like.\nhttps://tools.ietf.org/html/draft-ietf-oauth-token-exchange-12#section-4.3\n4.3.  \"cid\" (Client Identifier) Claim\nThe \"cid\" claim carries the client identifier of the OAuth 2.0\n   [RFC6749] client that requested the token.\nThe following example illustrates the \"cid\" claim within a JWT Claims\n   Set indicating an OAuth 2.0 client with \"s6BhdRkqt3\" as its\n   identifier.\n{\n  \"aud\":\"https://consumer.example.com\",\n  \"iss\":\"https://issuer.example.com\",\n  \"exp\":1443904177,\n  \"sub\":\"user@example.com\",\n  \"cid\":\"s6BhdRkqt3\"\n}. Thank you for taking the time to consider this issue :) I'll look forward to seeing how the project progresses. .\n",
    "suhaboncukcu": "@Sephster Thank you for your kind response. But it got me confused. \nI've already implemented my client repository implementing the interface as below: \n```\npublic function getClientEntity($clientIdentifier, $grantType, $clientSecret = null, $mustValidateSecret = true)\n{\n    $className = Configure::read('Oauth2Server.classes.clientValidator');\n    $clientValidator = new $className();\n    $clientValidator->validate($clientIdentifier, $grantType, $clientSecret);\nreturn new ClientEntity();\n\n}\n```\nI plan to handle non-authorized request within the validate function. I have my client stored safely on my database and I can get its id and secret without a problem.  However, whenever I try to get $clientSecret from this function; I get null. \nSo for me; \npassword_verify($clientSecret, $clients[$clientIdentifier]['secret']) gives false each time because $clientSecret param is always null. \nShould I overwrite the AuthCodeGrant.php to retrieve $clientSecret ?\nhttps://github.com/thephpleague/oauth2-server/blob/b8b92e59255ffe586ddd50a3975d7219ca9a8c38/src/Grant/AuthCodeGrant.php#L216-L221\n. Hi @Sephster, could you take a look at my explanation? I know it is not good to comment again but I couldn't find any other example for my case. I can fork the repo but I really don't want that since you are amazing and I don't want to miss an update. \nIs there any other platform that I can get an answer about this you can suggest? Stackoverflow has zero responses as well. \nMany thanks. @mtangoo but I am doing that. (I think)\nI am using Postman's Oauth 2.0 Authorization screen and sending the client secret. (When I sniff the request I can see it is correctly sent via header)\n```\nclass ClientRepository implements ClientRepositoryInterface\n{\npublic function getClientEntity($clientIdentifier, $grantType, $clientSecret = null, $mustValidateSecret = true)\n    {\n    var_dump($clientSecret); die(); // <<<< this is null\n\n\n    return new ClientEntity();\n}\n\n}\n```\nBut even though I've implemented the ClientRepositoryInterface,   getClientEntity function doesn't get the client secret. I understand that this function should be called with four parameters including $clientSecret and $mustValidateSecret . However, I'm not the one calling this function. AuthCodeGrant.php already calls this function and sends parameters as \nhttps://github.com/thephpleague/oauth2-server/blob/b8b92e59255ffe586ddd50a3975d7219ca9a8c38/src/Grant/AuthCodeGrant.php#L216-L221\nSince AuthGrant sends $clientSecret parameter as null, how can I validate the client? \nI hope this is a better explanation\n. @mtangoo no need. I checked the source code again and days after I now realized that this function is called twice. Once sending the clientSecret as null. Then with the proper clientSecret So the example @Sephster shared actually includes the line below:\nhttps://github.com/thephpleague/oauth2-server/blob/b8b92e59255ffe586ddd50a3975d7219ca9a8c38/examples/src/Repositories/ClientRepository.php#L36-L37\nIt looks like only when $mustValidateSecret is true; I should check for the $clientSecretand validate. Otherwise I shouldn't even check for the $clientSecret and just return void or false. I was trying to validate client for all the requests. \nMany thanks to you all. Now I can proceed with my mini project which I hope will help some others.\n. ",
    "fetzi": "Thanks for your feedback @simonhamp.\nI tried to avoid breaking changes in the introspection implementation (for a timely release \ud83d\ude09). But yes additional data like the username would be great to be included. What else are you thinking of?\nThe usage of the token_type_hint parameter is a good idea, I will try to implement this functionality as soon as possible.\nAccording to your security concerns: the RFC says that you should protect your introspection endpoint in some way except if its only an internal resource. Therefore I would leave the implementation of a security mechanism (oAuth2 Access Token, HTTP Basic Auth, ...) up to the implementor. This is a very important and sensible point that should be highlighted in the introspection documentation as well.\nThe usage of the acutal token to introspect is not allowed because the RFC states in section 2.1 that the introspection request is a HTTP POST request that sends the input parameters as application/x-www-form-urlencoded data. Therefore moving the token into the Header is not a good idea IMHO.\nAnd yes when the feature is completed I will send an additional PR for a detailed documentation update.\nWhat do you think about the points mentioned? Maybe we should split the points up and define them in detail what should be included in the auth server and how?. @simonhamp any update on this PR?. Closing this for now, implementation done by @steveporter92 in #925.. ",
    "jackdpeterson": "The above commit takes the approach that the client's configured redirect_uri is what we care about when validating the request. \nThe other key assumption being made is that the redirect_uri inside of the authorization_code is that it is used for redirecting and not validation of any kind. As such, the enforcement of the redirect_uri happens prior to abstractGrant::validateClient() is called.\nThis also means that the authCode.redirect_uri is used purely for storage as a debugging artifact to see where we sent a user after they completed step #1 on the authCode flow.\nSample action (not intended for production use) can be seen at https://gist.github.com/jackdpeterson/fb82d178e5d64e258fbf9b4150811c63\n. Closing because $_GET['state'] is a thing. Thanks @iansltx  :-).\nhumbled lol..",
    "frankdejonge": "My two cents on the matter. The getResponseString is a very technical description. It might be better to name it something along the lines of convertToAccessToken with a string return type. This is a better description than \"get string response\". The current convertToJwt could be seen as an implementation detail of that function.. The else could be removed.\n. If you check for the negative first you can throw the exception instead of doing it in the if and throwing the exception in the else.\n. The else is not needed.\n. Here too.\n. This exception can also be moved up to eliminate the nesting.\n. Also here.\n. And here.\n. and here\n. ",
    "nealoke": "@simonhamp indeed, that was where the issue is... I must say the documentation is not as handy to start with. I might do a PR to change that :) Thanks for helping!. Thanks for the quick follow up :+1: \nBut I'm afraid I don't fully understand what I should do now. The thing is currently my oauth clients can have access to my resource server (aka my api). But because I'm using the ResourceServerMiddleware it errors when my front-end application tries to access the api on behalf of the user that is logged in due to the missing JWT token. \nI guess my question is how to create the JWT token for people who want to login to my SPA. I don't know how to create this token with this library and is this possible without specifying an oauth client. I would love a simplified example how to do this :sob: . I receive the following error message:\nFatal error:  Call to a member function getIdentifier() on null in C:\\xampp\\htdocs\\wizer\\packages\\auth\\vendor\\league\\oauth2-server\\src\\Entities\\Traits\\AccessTokenTrait.php on line 31\nWhen trying:\n$generator = new AccessTokenEntity();\n$token = $generator->convertToJWT(new League\\OAuth2\\Server\\CryptKey($privateKeyPath, null, false))\nA small recap on the situation\nSo out of your answer and my stackoverflow question it becomes clear that the OAuth flow is not for typical user logins. I would like to create an endpoint on my auth server for logins such as myauth.com/login. This endpoint will accept a HTTP POST request containing the credentials of the user. For this to work I would need to validate the user (ok) and then create a JWT token for the user. \nMy question, how can I create this token on my myauth.com/login endpoint with the oauth-server package? I'm guessing something like new AccessTokenRepository()->getNewToken() but I'm not sure how.. @christiaangoossens do you mind sharing how you did the adding of (in your case) the group ID to the JWT token? I am needing this as well because users have access to multiple accounts. You mentioned extending the Grant types but I'm unsure how.. +1 for merging this, maybe also some documentation on how to do this?. @Sephster Thanks for the quick reply. As a matter of fact I thought about it but because the auth codes are used for integrations that are for a specific accountId it seems a bit weird to use the actual user as resource owner and block the access with a scope. \nDo you think it is appropriate to use the accountId as the resource owner in stead of the user? Or is this not a good practice for Oauth? . @Sephster the problem is that my knowledge on how to setup integrations with oauth is very limited and I'm sure you have a better understanding and knowledge about this. \nBut what if the user who setup the integration get's deleted? The integration (because the accessToken and refreshToken are scoped on the user) also becomes invalid then I guess?\nSo for example user \"John\" is created in the account. He wants to setup an integration the company's application and a third party one and thus starts the auth grand flow. After successfully granting the scopes etc. the integration is working. Now user \"John\" gets fired and his account is deleted. The integration which is still using the scoped accessToken(s) and refreshToken is now invalid and thus the integration is not working anymore. Doens't this seems like highly odd?\nMy situation is not so much requesting resources of a user but more requesting / modifying resources of an account. You can compare it with a Trello powerup, are these also linked to the user or to the team?. @Sephster This cleared up quite a bit \ud83d\udc4d . I'm gonna try now to implement it with the scope based approach and see if I run in any issues when I do this. Thanks for the time and effort to put forth such an explanation!\nTrying to do the scope based approach I have a few questions namely\nWhy is the scope not stored at the refresh token level as well?\nHow do you actually add a scope like accountId = 1?\nHow come the outcome is not a json format for the code below?\n```\n    public function finalizeScopes(\n        array $scopes,\n        $grantType,\n        ClientEntityInterface $clientEntity,\n        $userIdentifier = null\n    ) {\n        // Example of programatically modifying the final scope of the access token\n        $scope = new ScopeEntity();\n        $scope->setIdentifier('email');\n        $scopes[] = $scope;\n    return $scopes;\n}\n\n```\nOutcome $accessTokenEntity->getScopes() is a:1:{i:0;O:26:\"Entities\\ScopeEntity\":1:{s:13:\"*identifier\";s:5:\"email\";}}?. @Sephster thanks, I just implemented it with your comments from above and it works like a charm. I can't thank you enough \ud83e\udd47 !. @Sephster I understand, but shouldn't it be optional? Also I if I use $refreshTokenGrant->setRefreshTokenTTL(new \\DateInterval(\"P240M\")); it always throws the error you mentioned above. Is that normal or is it not allowed to set such a long interval?. Great, thanks again for the help. I'll try to debug why the P240M is not working as expected.. @sg3s Thanks for giving me an example for the fixed date. When I try to persist this information using the $refreshTokenEntityInterface->getExpiryDateTime()->format(\"Y-m-d H:i:s\") it only gives me the first period though. Am I storing this incorrectly?\nExample\n$TTL = new DateInterval(\"P200M\")\n$refreshTokenEntityInterface->getExpiryDateTime()->format(\"Y-m-d H:i:s\") ==> 2018/11/09 H:i:s. @sg3s Thanks for the fast answer, the DateTime->format also returns the H:i:s elements, I just typed these as placeholders.\nI checked the example and tried multiple things but I am getting quite sure that the library is not setting the TTL for refresh tokens correctly.\nSetting the grant\n```\n$refreshTokenGrant = new RefreshTokenGrant($refreshTokenRepository);\n$refreshTokenGrant->setRefreshTokenTTL(new \\DateInterval(\"P240M\"));\n$server->enableGrantType(\n    $refreshTokenGrant,\n    new \\DateInterval(\"PT1H\")\n);\n```\nRefreshTokenRepository implements RefreshTokenRepositoryInterface\n```\npublic function persistNewRefreshToken(RefreshTokenEntityInterface $refreshTokenEntityInterface) {\n    global $db;\n$db->insert(\"oauth_refresh_tokens\", [\n    \"id\" => $refreshTokenEntityInterface->getIdentifier(),\n    \"accessToken\" => $refreshTokenEntityInterface->getAccessToken()->getIdentifier(),\n    \"expiresAt\" => $refreshTokenEntityInterface->getExpiryDateTime()->format(\"Y-m-d H:i:s\")\n]);\n\n}\n```\nEventhough I set the TTL with $refreshTokenGrant->setRefreshTokenTTL(...) it still chooses the default which is set in the __construct() of the RefreshTokenGrant. Normally it should overide this with the method supplied by the parent AbstractGrant but for some reason it is not the case.\n. @sg3s omg, didn't understand that at all \ud83d\ude04. Thanks for the effort and speed of answering my question! \nTHANK YOU . ",
    "coloradotex": "Thanks for the response, Sephster.  As far as I know, we did not implement our own encrypt / decrypt functions.   I'll try to check that, but if there is a different encrypt/decrypt function involved, it was developed by a third party that we hired as consultants to do the oauth server implementation.  This third party has become unresponsive to us, so we're trying to delve into this and figure it out on our own.  But, I highly doubt they implemented a a different encryption mechanism.  That was never mentioned.   \nWhat\u2019s interesting is that it works almost all of the time.  Just every so often we get a failure and this error message is generated.  But, it\u2019s happening enough that it\u2019s annoying for our users.  \nWe just found a post where this statement was made:\n\"We encountered this problem in a real life application for Amazon Alexa. When revoking the tokens immediately there were edge cases where the Alexa service stopped working. As Xerkus pointed out there might be concurrency issues on distributed systems. Therefore our approach is to invalidate the refresh token after a timeout as halaei already pointed out.\"  (issue 735)\nWe\u2019re going to take a look at this possibility more closely.  However, do you have any insight you can share with us?  \nThanks so much.\n. Good afternoon, Andrew, and thanks so much for the reply.  A quick\nquestion \u2013 will this reply get posted on the public forum ?  Is there\nany way we can take this offline so we can figure out a way for you to\nsee the codebase?\nAnd, we're pretty confident we're just using the default CryptTrait.\nThanks.\nTerry\nQuoting Andrew Millington notifications@github.com:\n\nI don't think it would be a reverting of token issue for you. The\nerror message you are talking about can only be thrown if the server\ncannot decrypt the refresh token.\nIf there were issues with revoking the token, you would receive the\nerror message Token has expired.\nWithout seeing your implementation though, it is going to be very\ndifficult to diagnose this issue for you. There could even be\nsomething wrong with the refresh token that is being sent and your\nimplementation of the OAuth2 server is fine.\nThe fact that this is sporadic is what is quite puzzling. Sorry I\ncan't be of more assistance but I would still take a look to make\nsure you are using CryptTrait as a start.\nIf you are able to share the codebase somehow that would also be a\nbig help but I appreciate this might not be possible.\n--\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub:\nhttps://github.com/thephpleague/oauth2-server/issues/880#issuecomment-378579686\n\n. Obviously, replying to the email posted to the forum.  Is there some way we can go offline so I can give you access to the codebase?\nthanks so much.. I wanted to respond back to this.  Right now, we do believe the issue has been resolved, as Sephster mentioned above, by not revoking refresh tokens immediately, as reported in issue 735.  We're still reserving judgement, wanting to let our testing run its course, but it very much looks like it is resolved.  I do want to take this opportunity to thank Sephster so much for his assistance and attention to our issue.  It was greatly appreciated!. ",
    "starx": "@Sephster Makes sense. Thanks. ",
    "hgs81": "Thanks, @Sephster.\nI also don't think this is not an issue about this repository.\nBut I cannot find implementation of persistNewAccessToken() method in laravel/passport.\nAlso I tested with raw php when this error occurs.\nThis code raised same error:\nphp\necho (new DateTime());\n$accessToken var dump contains DateTime type variable 'expiryDate'.\nPerhaps is this version problem? I want to know if old version of AccessToken implementation has string type 'expiryDate'.\nPS: \nThere is live backend online that works with same code.\nI wanted to test it locally so I cloned all source code, compose install, and launch.\nBut I met this error.\nBackend is maintained by another ops engineer.\nJust yesterday, he said he updated backend with latest push.\nAnd after that, live backend also occur same error.\nIf you can tell me most stable version of oauth2-server and laravel/passport version, I would be thank you.. ",
    "tpaksu": "Will also fix #747.. Hi @Sephster ,\nTL;DR oauth2-server package doesn't give the user the ability to customize the messages, still it would be hardcoded localized strings for the user. but packages with laravel service providers have this option. By adding this to oauth2-server package, we would destroy this package's portability. \n\nWhen thinking in the Laravel scope, the user would do something like this (if I understood you correctly):\nphp\n    \"invalid_key\" => \"Your key seems to be expired, please send an email to foo@bar.com with the key \"abcdefg\" to request a new one\",\nIf I put this message inside oauth2-server package, it will overwrite the message every time the package gets updated, right? \nInstead of this, I would prefer to export the laravel/passport package's language file to the application resource folder (within the service provider's boot method - oauth2-server doesn't have one because it fits not only in laravel, but also in every framework which supports composer).\nAnd for doing this, I would need the dynamic error messages, less dynamic, or expose more information to it's parent package which then could handle the message translations. It'll be better that laravel/passport handles the translation feature and phpleague/oauth2-server to be more open for translation.\nOr maybe, just a thought, we can use a separate class which builds these error messages with sprintf and variable arrays, and then use something like dependency injection in the base class to inject the custom message builder to the oauth2-server package, to enable overriding the stock message builder class. \n. Until I realized that some messages are dynamically generated, this was my implementation:\nin laravel/passport package I've added a new method to src/Http/Controllers/HandlesOAuthErrors.php:\n```php\n /\n     * Translates the response content\n     \n     * @return \\Illuminate\\Http\\Response\n     /\n    protected function translateResponse(Response $httpResponse)\n    {\n        // get response content as object\n        $content = json_decode($httpResponse->content(), false);\n    // backup the old message and hint properties\n    $message_backup = property_exists($content->message) ? $content->message : false;\n    $message_hint_backup = property_exists($content,\"hint\") ? $content->hint : false;\n\n    // translate strings\n    $content->message = trans(\"passport::messages.\".$content->error);\n    $content->hint = trans(\"passport::messages.\".$content->error.\"_hint\");\n\n    // if the translation file doesn't contain the key, restore from backup, and if property didn't exist before, delete the keys from the message\n    if($content->message == \"passport:messages.\".$content->error) $content->message = $message_backup;\n    if($content->message == false) unset($content->message);\n    if($content->hint == \"passport:messages.\".$content->error.\"_hint\") $content->hint = $message_hint_backup;\n    if($content->hint == false) unset($content->hint);\n\n    return $httpResponse->setContent(json_encode($content));\n}\n\n```\nwhich modifies this part:\n```php\ncatch (OAuthServerException $e) {\n            $this->exceptionHandler()->report($e);\n        return $this->translateResponse($this->convertResponse(\n            $e->generateHttpResponse(new Psr7Response)\n        ));\n    }\n\n```\nand it gets the translations from resources/translations/en/messages.php which can be published into app/resources/lang/vendor/passport/en/messages.php in the main framework layer. Still keeping the portability of oauth2-server package.. ",
    "rakeev": "@nealoke all you need to do is reimplement AccessTokenEntity::convertToJWT()\nCopy it from AccessTokenTrait and adjust as needed\nNo grant extension needed\n. ",
    "leroy0211": "Sad to hear, but based on your previous suggestion I also created a PR in Passport, because it's also achievable with finalizeScopes(). They however also declined the PR, so I'm forced to use some other library for Oauth2 in our Microservice Architecture. \nBut I'm still a bit confused about the use of scopes in thephpleague/oauth2-server (and Passport). Scopes are there to protect access to resources. But there is nothing that restricts a client to request access to all available scopes, and therefor could have access to all your API's. So why would anyone implement scopes if every client can request access to all of them?\nBased on the Oauth2 spec, there is actually nothing that suggests a Client must first be assigned to one or more scopes. So I totally understand why thephpleague won't add it to the core.. But what you describe only applies on the Auth code grant (with user interaction), and maybe on the password grant. \nSo what's implied is, that in case of the client credentials grant none of the scopes matter, because it's without interaction of the user and without any user-id. But there is no way to access any user-resource with the client credentials grant since there is no user. So in what kind of use-case would you use the client credentials grant?\nMaybe I am misusing Oauth2 (and scopes) to limit complete access to specific API's, and maybe I need to implement another layer of security, something like ACL's for clients. \n. @simonhamp Thanks, I didn't thought of altering the tokensCan in a middleware. My use-case however does not work completely like that.\nI currently kind of fixed my use-case with a new Layer of ACL (on the client) just like the $user->can([role], [object]) of the laravel Auth. \nInstead I created a middleware which does something like $client->can('product:write'), and limited the client's access like that. All configuration is stored in another database table, so it can be maintained by other teams.\nBut thanks everybody for this discussion, I really learned a bit more about Oauth2.. @Sephster No I don't mean Dynamic Client Registration, because that's an RFC to register a new Client. I really ment Register a new User over the API and automatically log them in. \nThe main reason is that our complete software is based on API's. So even our own web application is using API's. So to register a new User in the web application there must be an API for that, which will result in a new token which logs in the newly created user.. ",
    "bitgandtter": "Scopes are intended for human users, so they can allow/disallow access to api on their behalf, not on behalf of a client AFAIK. @boyd91 has a point, the current implementation requires client_secret as part of password grant. Not sure if this is completely under the specs or we are missing something. At leas on my side its enforced, i workaround using implicit grant for my SPA but as far as password grant client_secret its mandatory. ",
    "boyd91": "The Password grant referred to in the docs does require to pass the client_secret. See http://oauth2.thephpleague.com/authorization-server/resource-owner-password-credentials-grant/. The password grant in this implementation indeed requires the client_secret to be passed. https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/PasswordGrant.php#L51. By reading the contents of validateClient it certainly seems like it's unconditionally enforced. https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AbstractGrant.php#L172. @simonhamp Thanks for your clarification.\nIn that case I would suggest the doc needs an update. It now states\n\nIf the client is a web application that has runs entirely on the front end (e.g. a single page web application) you should implement the password grant for a first party clients and the implicit grant for a third party clients.\n\nhttp://oauth2.thephpleague.com/authorization-server/which-grant/\nSince the client_secret is always required, the password grant can never be a viable option for a frontend only SPA (regardless wether it is first or third party) because such clients can never really keep the client_secret a secret.. ",
    "alex-filat": "It is wrong to use Password Grant for SPA. The only right solution (if you really need oauth 2.0 authorisation) is Implicit Grant flow. Otherwise you misunderstand at the basic level the purpose of oauth 2.0.. ",
    "NoelDeMartin": "@Sephster \n\nI believe current best practices are actually to use an Auth Code grant without passing the client secret. This can't be achieved with the library at present\n\nIn this other issue https://github.com/thephpleague/oauth2-server/issues/881 you confirm that client secret is actually not being used for the Auth Code grant, so which of the two statements is correct?\nLooking at the code seems like the secret is required at the moment: https://github.com/thephpleague/oauth2-server/blob/master/src/Grant/AbstractGrant.php#L181..L189\nWhat's the current status to support this? I could do a PR if you want, but I'm not familiar with the library so I'm not sure of the actual side-effects of changing the code.. ",
    "yuloh": "If anyone else reads this thread wondering about the status of the original issue, the client_secret was no longer required for the password grant in 5.0.0-RC1.\n\nPassword grant updated\n   Allow support for public clients\n\nhttps://github.com/thephpleague/oauth2-server/blob/0227f14b7bbeaa2ec1fec378ba0c1afd927e95b0/src/Grant/AbstractGrant.php#L187. ",
    "aluciffer": "Hi Sephster, no worries, i will bear with anything, because i've spent days on this topic and i'm completely puzzled.\nI keep obtaining the two different outputs running literally the code above, how can $payload be different?, if i dump it out, where exactly should i dump it to see if it's different?\nIf i have the two lines one below the other in the code, how can the result be different?\nTo follow your suggestion, i have changed crypttrait as follows:\n```php\n/\n * Decrypt data with a public key.\n \n * @param string $encryptedData\n \n * @throws \\LogicException\n \n * @return string\n /\nprotected function decrypt($encryptedData)\n{\n    $fp = fopen('decrypt.trait.txt', 'a');\n    fwrite($fp, 'call of '.$_SERVER['SERVER_NAME'] . ' ' . print_R($_REQUEST,1). PHP_EOL. ' with encKey='.print_r($this->encryptionKey,1).PHP_EOL.PHP_EOL);\n    fclose($fp);\ntry {\n    return Crypto::decryptWithPassword($encryptedData, $this->encryptionKey);\n} catch (\\Exception $e) {\n    throw new \\LogicException($e->getMessage());\n}\n\n}\n/\n * Set the encryption key\n \n * @param string $key\n /\npublic function setEncryptionKey($key = null)\n{\n    $fp = fopen('crypt.trait.txt', 'a');\n    fwrite($fp, 'call of '.$_SERVER['SERVER_NAME'] . ' ' . print_R($_REQUEST,1). PHP_EOL. ' with key='.print_r($key,1).PHP_EOL.PHP_EOL);\n    fclose($fp);\n    $this->encryptionKey = $key;\n}\n```\nAnd in AuthCodeGrant.php, the function completeAuthorizationRequest as follows:\n```php\n/*\n * {@inheritdoc}\n /\npublic function completeAuthorizationRequest(AuthorizationRequest $authorizationRequest)\n{\n    if ($authorizationRequest->getUser() instanceof UserEntityInterface === false) {\n        throw new \\LogicException('An instance of UserEntityInterface should be set on the AuthorizationRequest');\n    }\n$finalRedirectUri = ($authorizationRequest->getRedirectUri() === null)\n    ? is_array($authorizationRequest->getClient()->getRedirectUri())\n        ? $authorizationRequest->getClient()->getRedirectUri()[0]\n        : $authorizationRequest->getClient()->getRedirectUri()\n    : $authorizationRequest->getRedirectUri();\n\n// The user approved the client, redirect them back with an auth code\nif ($authorizationRequest->isAuthorizationApproved() === true) {\n    $authCode = $this->issueAuthCode(\n        $this->authCodeTTL,\n        $authorizationRequest->getClient(),\n        $authorizationRequest->getUser()->getIdentifier(),\n        $authorizationRequest->getRedirectUri(),\n        $authorizationRequest->getScopes()\n    );\n\n    $payload = [\n        'client_id'             => $authCode->getClient()->getIdentifier(),\n        'redirect_uri'          => $authCode->getRedirectUri(),\n        'auth_code_id'          => $authCode->getIdentifier(),\n        'scopes'                => $authCode->getScopes(),\n        'user_id'               => $authCode->getUserIdentifier(),\n        'expire_time'           => (new \\DateTime())->add($this->authCodeTTL)->format('U'),\n        'code_challenge'        => $authorizationRequest->getCodeChallenge(),\n        'code_challenge_method' => $authorizationRequest->getCodeChallengeMethod(),\n    ];\n\n    $response = new RedirectResponse();\n\n    $params =[\n                'code'  => $this->encrypt(\n                    json_encode(\n                        $payload\n                    )\n                ),\n                'state' => $authorizationRequest->getState(),\n            ];\n\n    $fp = fopen('AuthCodeGrantDebug.txt', 'a');\n    fwrite($fp, date('H:i:s').':' .$this->makeRedirectUri(\n            $finalRedirectUri,\n            $params\n        ) . PHP_EOL . \n        $this->makeRedirectUri(\n            $finalRedirectUri,\n            [\n                'code'  => $this->encrypt(\n                    json_encode(\n                        $payload\n                    )\n                ),\n                'state' => $authorizationRequest->getState(),\n            ]\n        ). PHP_EOL. PHP_EOL);\n    fclose($fp);\n\n    $response->setRedirectUri(\n        $this->makeRedirectUri(\n            $finalRedirectUri,\n            [\n                'code'  => $this->encrypt(\n                    json_encode(\n                        $payload\n                    )\n                ),\n                'state' => $authorizationRequest->getState(),\n            ]\n        )\n    );\n\n    return $response;\n}\n\n// The user denied the client, redirect them back with an error\nthrow OAuthServerException::accessDenied(\n    'The user denied the request',\n    $this->makeRedirectUri(\n        $finalRedirectUri,\n        [\n            'state' => $authorizationRequest->getState(),\n        ]\n    )\n);\n\n}\n```\nI get the following three files, where i've added a couple of manual markups (before pressing login and after pressing the login button):\nAuthCodeGrantDebug.txt\ncrypt.trait.txt\ndecrypt.trait.txt\nI thought i got to the bottom of the problem because i always keep getting on the client side:\n{\"error\":\"invalid_request\",\"message\":\"The request is missing a required parameter, includes an invalid parameter value, (truncated...),\nThe problem is i don't understand why i cannot do a complete, successful authorization.. In the client, i have the following code, which surprizingly, gets a successful bearer_token when i uncomment and submit manually the form : \n```php\nRoute::get('/callback', function (Request $request) {\n/\n     return '\n\n    \n    \n    \n    \n    \n';\n/\n$http = new GuzzleHttp\\Client;\n\n$response = $http->post('http://passport:8090/oauth/token', [\n    'form_params' => [\n        'grant_type' => 'authorization_code',\n        'client_id' => '3',\n        'client_secret' => 'jOf6XcL4yv5WqSAmKwgKaKab6Drx5OJnMcMwp3rw',\n        'redirect_uri' => 'http://client:8091/callback',\n        'code' => $request->code,\n    ],\n]);\n\nreturn json_decode((string) $response->getBody(), true);\n\n});\n```\nI fail to understand, can you please help if there is a problem in the encryption here or is is something else?. Ok, about the var_dump, i've done it in crypttrait->encrypt and yes it shows the same output.\ncompleteAuthorizationRequest:\n```php\n$GLOBALS['tz'] = 1;\n$params = [\n    'code'  => $this->encrypt(\n        json_encode(\n            $payload\n        )\n    ),\n    'state' => $authorizationRequest->getState(),\n];\n// print_R($payload);\n$uri = $this->makeRedirectUri(\n    $finalRedirectUri,\n    [\n        'code'  => $this->encrypt(\n            json_encode(\n                $payload\n            )\n        ),\n        'state' => $authorizationRequest->getState(),\n    ]\n);\n$uri2 = $this->makeRedirectUri(\n    $finalRedirectUri,\n    $params\n);\n$fp = fopen('AuthCodeGrantDebug.txt', 'a');\nfwrite($fp, date('H:i:s').':' . $uri. PHP_EOL.$uri2. PHP_EOL. PHP_EOL);\nfclose($fp);\nexit;\n**CryptTrait->encrypt:**php\nif (@$GLOBALS['tz'] === 1) {\n    var_dump($unencryptedData);\n}\n```\noutputs:\n| string(265) \"{\"client_id\":\"3\",\"redirect_uri\":\"http:\\/\\/client:8091\\/callback\",\"auth_code_id\":\"e921196006aacb0e114dda4dc593ee2a9d6c8d88fc13e831fd3bc07085be568e61e3ec693d55cd20\",\"scopes\":[],\"user_id\":1,\"expire_time\":\"1524475669\",\"code_challenge\":null,\"code_challenge_method\":null}\"\n-- | --\n\u00a0 | string(265) \"{\"client_id\":\"3\",\"redirect_uri\":\"http:\\/\\/client:8091\\/callback\",\"auth_code_id\":\"e921196006aacb0e114dda4dc593ee2a9d6c8d88fc13e831fd3bc07085be568e61e3ec693d55cd20\",\"scopes\":[],\"user_id\":1,\"expire_time\":\"1524475669\",\"code_challenge\":null,\"code_challenge_method\":null}\"\n\u00a0 |\nand the last two entries in AuthCodeGrantDebug.txt:\n09:17:49:http://client:8091/callback?code=def502007da70049d112d07ab8261860f759dc429079b9fd156d578a1aca8c1877ded127e92914d211f7a5a6269be07cfd4b476960851e102779a3372f9cecec91163cd2f483114056858fabc78fbb4bc02917d3115d4b7a02e4d4f83e5ed87164d4363c4b653ff87f6e4741bd2e365c3f097e6df32c738ef8607624ccfc71da72cb1c48572e34263f25afedcec6e1af3305a3aad6874e5749697ed91cc78225a8886c421faff4cdc5110d1f5a944f5f3ef1f13a0aaf4bf16e94bba1baa461a880232ad9a3bca355dbf141a501cfa23c0e5419d405327b91d00302d2c5aeeeb72be521e224cf286e066143f7922f9d9637f5543202baa252b0c4fd787da85fe81874c2c93f9cc2b75e4ca5fe24d471fc7e9f2e576c3a0db4db4c4c3932ce2b99c50c3dddd1ce872b621804c5bc5c79d126c01a2e2dedbd0685dd1e8c18728607dc16c4dbdb4d6083da89af3cd8e1a330bba1a7d7104ca0024819ced5ab\nhttp://client:8091/callback?code=def502005b2f6d93fe61d9abeb6c1fd23362cfa8ed781a2872b2260e47d3672f24bc8d995f26279696267b1fadb2ef7e4b786d681df57cdd4b6668ec7336df8035cd0f59c08596ec5bd0ee9c4d40b3371e1a12d030f27eaa2da6e1084cd1a947143068817f69026e2b11c01904ac940505fb3e5a620d020933c3d157c1ff8cc702a30307e79eedb344470cebc2d3a8ff176020a6790bb6285468adf61855b23287a3d11c8499d8fdbda892e26718c4741f7b039ef8bceddc88b6ade2db9295b7770080e8ab564926f66d5af9df6af8fd549a0b8929ee05189bc76e2c5dcba50dfe52d4a32c6075cfd1ed685fd9639b3d00fc0df693c2b7693d4f6cde61e1b2009627d95b52affcd1d33d75a854a15df0f6ed688676299d8736d2d577f57ef4bd3fc87f6a64e5e9babe3bb18dfd878d80073f82d2ea9366209dcd4da228720b44fc06cfc4e6e312adf5bc6986f912724f9e4917f40fbed68d33116eda94. Ok, so then sorry for the flooding, i now think that it's normal that the output is different, the crypto->encrypt outputs a different string at every call .\nBut then what is going on, why does the guzzlehttp call fail ?. @simonhamp Thanks, but no, that didn't help.\nActually i now find @Sephster 's suggestion that my client receives a code encrypted with a different encryption key than the one used when the code received back from the client is decrypted.. @Sephster no, i have not, i am not sure anymore that this is a real issue with oauth2-server or laravel, perhaps a misconfiguration, but no, i  did not find any solution. The access code is being encrypted with a different key than when it's being decrypted in the exchange for the access token. do you have any ideas?. In my AuthCodeGrant.php,\nthese two calls cause different outputs:\n`\n$params =[\n'code' => $this->encrypt(\njson_encode(\n$payload\n)\n),\n'state' => $authorizationRequest->getState(),\n];\n$fp = fopen('AuthCodeGrantDebug.txt', 'a');\nfwrite($fp, date('H:i:s').':' .$this->makeRedirectUri(\n        $finalRedirectUri,\n        $params\n    ) . PHP_EOL . \n    $this->makeRedirectUri(\n        $finalRedirectUri,\n        [\n            'code'  => $this->encrypt(\n                json_encode(\n                    $payload\n                )\n            ),\n            'state' => $authorizationRequest->getState(),\n        ]\n    ). PHP_EOL. PHP_EOL);\nfclose($fp);\n\n`\nas seen in the attached. how can the key be different?\nwell, if it's using two different keys, Why? how do you explain this? how can i identify where the key comes from ( i could only figure that it is different)?. ",
    "galab-devision-bg": "@Sephster Sorry for the delayed answer I was not able to test that earilier. Both isSeekable and isWritable return true. . @simonhamp Yes :) It returns the correctly generated data. \n\"{\"token_type\":\"Bearer\",\"expires_in\":2592000,\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6ImM3MTYxYmFiYTVlODczMjYxNTVkNmI3ODg3MWNmN2I3NDI1YmY3ZTVlMTYzYTgyOWIzZTAzMDQ2YWU4MzE1YTI4YTNkZTNjMDU2NGQyOTRjIn0.eyJhdWQiOiIxIiwianRpIjoiYzcxNjFiYWJhNWU4NzMyNjE1NWQ2Yjc4ODcxY2Y3Yjc0MjViZjdlNWUxNjNhODI5YjNlMDMwNDZhZTgzMTVhMjhhM2RlM2MwNTY0ZDI5NGMiLCJpYXQiOjE1MjQ0NzExNzIsIm5iZiI6MTUyNDQ3MTE3MiwiZXhwIjoxNTI3MDYzMTcyLCJzdWIiOiIxIiwic2NvcGVzIjpbe30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se30se31dfQ.F1QUhYImb_pNiBwpSyh1Z002vFRKO9krPkIhnlJYeCtT_GFHSplZxV3o7jgl8UIQxsLCAcnDBMWPuk5xIxcFMw7ca0om_miuYK0qhHp-7_RGYHMlYJN1ln77xzCSH3l241FitctyVl-7Up9peUCYOmth2GVR8EIaGj70sD4B3boYjTAmYV1KNpzlxtMqVurSwf1_uAIVb-0Uid8LJlklzKU4n4WVmPtcdp8ZKxX3WmoEMGQgFRuRCO1pZKkcaLwBGqg-KU8zU90YptMsVhDvIMS_fdDHcKleqeECMx7CKocycjoVwtvazZxK6InblunEEoSrbmkvJe5bIgdUzmXzaw\",\"refresh_token\":\"def502006be9916a5d6a0ca17b84a156a367f5afe1aaa89f93a6048fee8819256a17d06d2e8114004bc20b57bc516da076228cbcd0d2b61bc614867bc4dcfa7c0bd571b487e8708855890e2f23f3ddb9b2899aece167707cafed8ebf9a021fdb2140ac086038d9b3de6ed9f14ddfa710d7423c23a0d58561c5566cb60dda1f338f89165cf2bd724dc1a3cdeaf5267410909e414a179ed64159e9c18ba2d714525659baac112e2aaca3b9bbac887161ea503d021b4639aed2d2bf063263e19dd5fbb8d88d8fd0ec4a0134009a8c3ae7cfdc1a134e7bf98c5f16197fbfa930ba8b8a36090f7fea585e12c51890eef6ed35f37aa45993acc10c87ed376014c1020ddefb4c18911b5e4745484b1b3245cbd426e47166e3d7f0f30e9b0dee6738d4889c23f07b6e4af106382b456f5818da1aeafcf1ac52bd332dd31f0049fb01a8832eff7e4ff9ded4f2ae88ba78d9e296f23240d7c3a805fc66483cab8bef6b3b9485614d2d2ce76b97ae512d3d5b2362e6fb9f7cb4873bc716c8d2bc15c0b69e32d398b9a81f7bd23c9b48d1788dab07ec349fefbf1db07cfa781f1a5f07414c21c253306b648a781d043745b366b7a94ae85bd6429144fb714fad09942a3ae197f00853c71b8b4754ecf2bae569347052c4fa0bb80472b0eb9f2edc3cacff5cdeae21532fba7b207233b3db84023e57bdf8a28966e82bc9a0c1e1643771c9dd6a61281bf9a8df2abd6970c98574cfae276f8117b9a91c6c815c5b00e15950561edd46ece8e327498bfb45c8acf94aa25db84d0bd92e3d82c31742092585ac08df73f88db2847aa9b5dc4c3363918433afbe28824ca713d252e8197365e4376312f00a0c5fb183cbabe2dbbc6c0601abb3455effa6bca402b3ff959df362f5588e83f72c020e799f8fc61313d61714c521cbc4d27c7aa361e3b400ba2736f2a8fd39289587cac515a9690055118f68d9d4ba10b1ba1bc787a094c7225389301e97cbf5f40b7eaf9736f620013db96224f90324afb2f1a3f09372397b\"}\"\nPS > Maybe it is worth mentioning that I am using php7.1-fpm with nginx 1.10 \nI did not find any necessary configuration but again, any bit of information is valuable. no I expect psr7 response as per the oauth2 itself but I cannot manage to get it so I don't even get to the step for rendering my response.. The result of it is in the first post that is the GuzzleHttp\\Psr7\\Response object.. It returns null. ",
    "marekk": "My problem is that I need to remove that validation because we don't use the registered claim names here, and they are all optional.\nvalidateAuthorization  is not amended but the original kept for backward compatibility.. ",
    "kaysenlau": "@Sephster Very thanks for the info.\nIf I set it to 777, I will get the error message in every drupal page.\n\nIf I set it to 000, I won't got the error.\nWrong user/group don't have tips too, can this be fixed in this repo?. I debug it just now.\nif (!file_exists($keyPath) || !is_readable($keyPath)) {\n            throw new \\LogicException(sprintf('Key path \"%s\" does not exist or is not readable', $keyPath));\n        }\nWhen permission is 000 or wrong user/group will trigger above error, but this error don't display in drupal page, Maybe we should fix it in simple_oauth. I have created an issue on https://www.drupal.org/project/simple_oauth/issues/2972726 and upload a patch on it.Thanks for the advice @Sephster. ",
    "ShyZhen": "Hi, \u8c22\u8c22\u60a8\u7684\u7b54\u590d\uff0c\u6211\u8ba4\u4e3a\u7528Windows\u8fdb\u884c\u6743\u9650\u7ba1\u7406\u5176\u5b9e\u662f\u5f88\u96be\u7684\u4e00\u4ef6\u4e8b\uff0c\u6211\u4e00\u822c\u90fd\u4f7f\u7528Windows\u8fdb\u884c\u5f00\u53d1\uff0c\u6700\u7ec8\u7a0b\u5e8f\u8dd1\u5728Linux\uff1b\u6211\u4e00\u76f4\u5728\u5c1d\u8bd5\uff0c\u600e\u6837\u628a\u6211\u7684\u6587\u4ef6\u6743\u9650\u6539\u6210600\uff0c\u4f46\u662f\uff0c\u6211\u8bd5\u8fc7\u4e86\u5f88\u591a\u65b9\u6cd5\uff0c\u627e\u4e86\u5f88\u591a\u8d44\u6599\uff0c\u5979\u4f9d\u7136\u662f666\uff0c\u5728\u6211\u773c\u91ccWindows\u5e76\u4e0d\u9002\u5408\u505a\u6743\u9650\u7ba1\u7406\u3002\u4e0d\u8fc7\u8fd9\u53ea\u662f\u6211\u7684\u4e00\u9762\u4e4b\u8bcd\uff0c\u56e0\u4e3a\u6211\u4e5f\u5f88\u65e0\u77e5\uff0c\u6211\u4e5f\u5728\u8ffd\u6c42\u771f\u7406\u3002\u8c22\u8c22\u9605\u8bfb\u3002\n\nHi, thanks for your reply, I think it's very difficult to use Windows to manage permission, I usually use Windows for development, and the final program runs in Linux; I've been trying to change my file rights to 600, but I tried a lot of methods and found a lot of information, she was still 666, In my opinion\n Windows is not suitable for permission management. It's statement of only one of the parties, because I am also ignorant, and I am also seeking truth. Thank you for reading.. ",
    "Richard87": "Hi!\nI think I have the same problem when trying to use oauth2-openid-server (https://github.com/steverhoades/oauth2-openid-connect-server/issues/21), the Implicit Grant completley disregards the responseType, so I don't know how to add the id_token response required in OpenID except creating a new OidcImplicitGrant, wich feels wrong..... ",
    "acodercat": "Where is the resource class?thx. thanks. ",
    "fizzka": "logic changed, but comments are obsolete (not relevant). reopen to fix frozen build. good luck =)\n2018-06-15 16:42 GMT+03:00 Andrew Millington notifications@github.com:\n\nMerged #912 https://github.com/thephpleague/oauth2-server/pull/912.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/thephpleague/oauth2-server/pull/912#event-1683409680,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACRjYMi25RZqg1kDX2MI_jqUkCwFekM9ks5t87mzgaJpZM4UoqPr\n.\n. \n",
    "brentgaither": "Thanks for the feedback. I thought that might be giving away too much information, but I was not sure and figured I would give the suggestion. . ",
    "rmasclef": "@sephter thanks a lot for your reactivity! i'll check by the end the week :). @Sephster sorry for the huge delay, I just upgraded the app deps and the problem seems to be fixed, thanks a lot :+1: \nFYI: we are going to upgrade that old app to php 5.6 in order to reduce the risk to encounter that types of errors :) . ",
    "melanef": "Hi Andrew, thanks for taking the time to analyze and reply to my PR.\nNo, I'm not the one who opened issue #914, and it's totally not what I have been experiencing. \nI agree with you that it can (maybe should) be fixed on my side (and I believe it will as soon as my partners review it) as it is somewhat of an inconsistency, but at the same time I also think the oAuth server should fail gracefully throwing an exception instead of issuing a \"Call to member function on null\" error.\nMy issue was caught on Sentry (a tool to monitor and track errors and events) and I did some analysis on the whole flow to understand where would be the problem. I even considered adding the exception throw on my Access Token Storage method get, where we check that the access token we are looking for does not exist, but it wouldn't be the best approach.\nOn my platform we do have an area where our users can check which API clients are authorized and, if he wishes, delete the authorization, where is the only part of the system where an access token can be removed. The only way to reproduce this error is to get a new access token (by the authorization flow) and then removing the access token.\nMy pull request was issued against branch 4.1.x because it's the one we use (4.1.6) on our platform and to be honest, I don't know if the problem exists on the other branches.\nOnce again, thank you very much for your attention.. ",
    "francislavoie": "If you're asking for specific scenarios, I was hoping this would be merged specifically for the first point in @christiaangoossens PR comment, i.e. adding claims into the JWT without needing to store state on the server, by transferring that state in the authorization code.. ",
    "StevePorter92": "Hey @Sephster, don't suppose you have had a chance to cast your eye of this?. Hey @Sephster, no worries at all! \ud83d\ude04 . Hey @Sephster! Really appreciate the feedback, will get to your comments as soon as possible. Hey @Sephster. Sorry for the delay. Little snowed under recently yes. I've got a few updates I'll check-in hopefully this evening to address your comments. Thanks for the support! . Added some changes to address your comments @Sephster.\nThe Introspector now validates through a IntrospectionValidator interface. I've moved all of the token logic to a BearerTokenValidator class. This should give implementers the freedom to validate introspection requests for other formats.\nI'm a little unsure as to the best way to get the resource server to use our new endpoint so could do with being pointed in the right direction. My current line of thought is to create a AuthorizationValidators\\IntrospectionValidator class. I think this will just need the URL of the introspection endpoint as well as any information required for authentication?\nAlso a little unsure on the best way to protect this new endpoint. What are your thoughts on this?\nThanks again.. As @sephster said, there isn't currently a timeline for this feature @dvdbot.\nIntrospection can be achieved with laravel through passport and https://github.com/designmynight/laravel-oauth-introspect-middleware.\nCurrently what's outstanding is finding a sensible way for the resource server to use introspection. We also need to consider authentication. \n@sephster, when you come to review this, let me know if there's anything I can pick up. \n. ",
    "dvdbot": "So, I'm currently sort of in the need of introspection because I want to use Express Gateways OAuth 2.0 Introspection functionality with my Lumen 5.8 + Passport based Microservice - any eta on the implementation of Introspection?. Sorry for the pings but, anything @StevePorter92 or @Sephster ?. Ah okay, currently got it half working by using a separate package - only running into one problem which is that the Authorization header seems to be required to have to validation in the BearerTokenValidator succeed, even though it is in the request body...\nApparently it seems Express Gateway doesn't put it into the Header so I'm a bit stuck and I don't know if this is a Bug in the BearerTokenValidator or not because Express Gateway talks about using a combination of Client_Id:Client_secret as Token Validation Value or something. So when can we expect this to be implemented @Sephster - cause currently it's a big stopper when you want to use the Microservices Architecture with Laravel or Lumen\nOr do you have an alternative/workaround?\nI tried overriding the ResourceServer so I can return a custom validator (actually just a modified version of the BearerTokenValidator so it looks in the body instead of the header - where it should actually check when using introspection - but... a few needed class members are private...\nauthorizationValidator and accessTokenRepository. So when can we expect this to be implemented @Sephster - cause currently it's a big stopper when you want to use the Microservices Architecture with Laravel or Lumen\nOr do you have an alternative/workaround?\nI tried overriding the ResourceServer so I can return a custom validator (actually just a modified version of the BearerTokenValidator so it looks in the body instead of the header - where it should actually check when using introspection - but... a few needed class members are private...\nauthorizationValidator and accessTokenRepository. @StevePorter92 and @Sephster - I've got it working for the moment as follows:\nI copied the controller from the Laravel Introspection package, then I copied the token validation part from the BearerTokenValidator into the controller, added a public key variable which gets instantiated as follows\nPHP\n$this->publicKey = new CryptKey('file://'.Passport::keyPath('oauth-'. 'public' .'.key'), null, null);\nAbove I stole from somewhere inside the Passport package :joy:\nNow I can at least introspect. ",
    "conquer66666": "thanks. ",
    "tegaphilip": "@Sephster \ud83d\udc4d . ",
    "robbytaylor": "I added the request object as an argument to ResponseTypeInterface:: generateHttpResponse() because it seemed like a preferable (i.e. more generic) approach than adding a $requestedScopes parameter.\nI allowed the request parameter to be null, partly because there's places where a redirect response is generated which don't have the request instance available. It didn't seem sensible to update unrelated methods to pass the request object only so it can be passed to the redirect response, which doesn't even need it. I also thought it might help backwards compatibility for libraries which depend on this one. But let me know if you can see a better way of approaching it.. Hi @Sephster, thanks for getting back to me on this. Will do.. ",
    "JurRutten": "Never mind, there was an issue creating the jwt token. ",
    "xgin": "I use the following factory for AuthorizationServerMiddleware with Zend Expressive 3:\n```php\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse League\\OAuth2\\Server\\Middleware\\AuthorizationServerMiddleware;\nuse League\\OAuth2\\Server\\AuthorizationServer;\nclass AuthorizationServerMiddlewareFactory\n{\n   public function __invoke(ContainerInterface $container) {\n        $middleware = new AuthorizationServerMiddleware($container->get(AuthorizationServer::class));\n    return new class ($middleware) implements MiddlewareInterface {\n        private $middleware;\n\n        public function __construct(callable $middleware)\n        {\n            $this->middleware = $middleware;\n        }\n\n        public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface\n        {\n            return ($this->middleware)(\n                $request,\n                new \\Zend\\Diactoros\\Response(),\n                function ($request, $response) {\n                    return $response;\n                }\n            );\n        }\n    };\n}\n\n}\n```\nFor ResourceServerMiddleware is enough to wrap it with Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator.. ",
    "docxplusgmoon": "Example code:\n`\n$accessTokenRepository = new AccessTokenRepository();\n    $bearerTokenValidator  = new BearerTokenValidator($accessTokenRepository);\n\n    $publicKeyPath = $this->config->public_key_path;\n\n    $bearerTokenValidator->setPublicKey(new CryptKey($publicKeyPath, null, false));\n\n    $request = $bearerTokenValidator->validateAuthorization(ServerRequest::fromGlobals());\n\n    print_r($request->getAttributes());\n\n. @faravinicius ServerRequest must be instance of GuzzleHttp\\Psr7\\ServerRequest. Adduse GuzzleHttp\\Psr7\\ServerRequest` on head your class. ",
    "faravinicius": "Thanks, @docxplusgmoon!. Today I was able to finalize an implementation and it is giving an error. Call to undefined method Zend\\Diactoros\\ServerRequest::fromGlobals().\nHelp me ?. I found the documentation, I'm sorry!. ",
    "DeepDiver1975": "\nIf you want to resubmit once PHP 7.3 has been released I will be happy to accept the PR then. Thanks!\n\nFeel free to re-open this PR by then ... or I resubmit - depending on the travis php 7.3 support by then.\nGenerally speaking I think RC is a pretty good stage to start testing if a lib is properly running on a new php version. Potential issues can then be addressed in the remaining weeks until the final release is there.\nBut as you command - I'll return soon .... ;-). ",
    "dennisrojaspereira": "Sorry guys, my bad !. ",
    "temp": "Also, the state query parameter ist missing in error responses. The RFC states:\nstate\n         REQUIRED if a \"state\" parameter was present in the client\n         authorization request.  The exact value received from the\n         client.. ",
    "ceeram": "So it was not without breaking BC: https://github.com/thephpleague/oauth2-server/issues/968. You want use import statements added throughout the whole project? i can do that, although unrelated to this PR. I can make a new PR for that if you like. I can also add some tests for testing that previous exceptions are passed to exceptions to the current PR. Test added.. Thanks for the quick merge. Any plans for a new tagged release?. And thanks again for the quickly created tagged release.. This issue is not just about changing the method name, as i renamed it in our extended class as well. Also setting the privateKey and encryptionKey was moved to the constructor, which is why it still was broken after renaming the extended method.. https://github.com/thephpleague/oauth2-server/pull/969 i have a fixed the BC without breaking the newly added tests. I think this will make both sides happy. This is also related to moving the setting of the keys. I have a PR up to move them back to where they were #969 . Alternatively, you could add the code to set the keys in your extended method to get around this with current implementation. See https://github.com/thephpleague/oauth2-server/pull/969#issuecomment-439898961. Still, this is unwanted behavior from a minor release. i moved it to ensure privateKey was set to the instance created in getResponseType, since it was only being set in constructor now. People need to set those themselves when creating a new instance in this method when overriding, while this wasnt needed when just calling parent. As said, we have solved it differently now. So if your solution works as well, im fine with it. Just fyi, only reverting the methodname change as you did now will still not be 100% BC with original code.. You removed the tests that were added in the PR #960 . If you would add them back and they still pass they wont at leats totally break the changes for stateless, just that privatekey might not be set in responseTypes created in overridden methods.. Re-added tests from #960 in https://github.com/thephpleague/oauth2-server/pull/971\nThe move of setting keys is up to you if you move that back or not.. Added a test to prove the BC break concerning the move of key setting. \nPS sorry for the super long line, but styleCi forced me doing this instead of what i had\n\n. This was our original code that was broken, and would still be broken by current master:\n```\nclass AuthorizationServer extends BaseAuthorizationServer\n{\n    protected function getResponseType()\n    {\n        $this->responseType = new OpenIdBearerTokenResponse();\n    return parent::getResponseType();\n}\n\n}\n```\nresulting in an error that privateKey was null. Indeed thats the way we worked around it now, passing the object as contructor argument. Still the move of the key setting is a breaking change. People can update their code to set them themselves ofcourse, but that would not be desired in a minor version upgrade.\nExample fix for users:\n```\nclass AuthorizationServer extends BaseAuthorizationServer\n{\n    protected function getResponseType()\n    {\n        $this->responseType = new OpenIdBearerTokenResponse();\n        $this->responseType->setPrivateKey($this->privateKey);\n        $this->responseType->setEncryptionKey($this->encryptionKey);\n    return parent::getResponseType();\n}\n\n}\n```\nAbove fix would in userland code is not needed when merging in this PR. That will make the stateless server change backwards compatible with implementations that extend AuthorizationServer and create new responseType objects in their overrided method. Added back the tests from #960 to ensure this behavior is unchanged after the method name revert in #970 . In this pr some asserts were removed, https://github.com/thephpleague/oauth2-server/pull/970/files#diff-257ce39e10ed4b9dcbbf1a46a2b4dab6L110\nindeed not all of it, but some.. ",
    "sunspikes": "Would it also be possible to make a release for 6.x series with this fix because the zendframework/zend-expressive-authentication-oauth2 uses that.. ",
    "Devristo": "In this case I am not using the PKCE flow but a confidential client. However the 8.0.0 branch changed the way the AuthCodeGrant is implemented.\nsrc/Grant/AuthCodeGrant.php\n\nPreviously the validateClient call would check the request params AND the headers using getBasicAuthCredentials. However now the respondToAccessTokenRequest only checks the request params and will fail if the client is using HTTP Basic authentication.\nIf you want I could create an  test that would succeed on 7.x and fail on 8.x to illustrate the issue?. Exactly! Thanks for picking this up. I cannot think about a reason either. I was just using protected because other methods were using protected as well. Shall I change it to private ?. Hmm it cannot be private because it is being called from its subclass AuthCodeGrant.\n1) LeagueTests\\Grant\\AuthCodeGrantTest::testRespondToAccessTokenRequest\nError: Call to private method League\\OAuth2\\Server\\Grant\\AbstractGrant::getClientCredentials() from context 'League\\OAuth2\\Server\\Grant\\AuthCodeGrant'\nMy suggestion is to leave it protected.. ",
    "MichaelKubovic": "Hi @m0ark, how did you deal with the missing nonce?. ",
    "curry684": "Yikes, https://github.com/thephpleague/oauth2-server/commit/d288a2ad8a574d9a1b641d529a79cbc617e03305 is the obvious cause... that commit should've never made it into a minor release, that's fundamentally breaking all extension points.. It should be noted that we're not so much doing unexpected stuff, we're actually using a documented extension point:\n/**\n     * Add custom fields to your Bearer Token response here, then override\n     * AuthorizationServer::getResponseType() to pull in your version of\n     * this class rather than the default.\n     *\n     * @param AccessTokenEntityInterface $accessToken\n     *\n     * @return array\n     */\n    protected function getExtraParams(AccessTokenEntityInterface $accessToken)\n    {\n        return [];\n    }\nI've just upgraded to 7.3.1 but still getting breakage elsewhere:\n\nArgument 1 passed to [redacted]\\OAuth2\\Entity\\AccessToken::convertToJWT() must be an instance of League\\OAuth2\\Server\\CryptKey, null given, called in [redacted]/vendor/league/oauth2-server/src/ResponseTypes/BearerTokenResponse.php on line 28\n\nThis could be just an implementation detail on my end, will investigate whether this concerns this library's public API.. My new error is still BC breakage. The old getResponseType implementation would set the keys on the fly: https://github.com/thephpleague/oauth2-server/blob/7.2.0/src/AuthorizationServer.php#L211-L214\nAs the new implementation does that in the constructor and clones it afterwards any custom ResponseType override \"old style\" will be missing the keys. https://github.com/thephpleague/oauth2-server/blob/7.3.0/src/AuthorizationServer.php#L117-L121\nImho this whole change is fundamentally wrong, as this breaks the whole point of deciding what ResponseType is needed at runtime, instead forcing us to decide during service initialization. This makes the library much less powerful.\nFor the time being I'm reverting to 7.2.0 again, this is not something a simple PR can fix.\nedit saying the same as @ceeram 44 seconds before me   \ud83d\ude09 . Pretty much identical yes, like I said it's documented to do it like this: https://github.com/thephpleague/oauth2-server/blob/master/src/ResponseTypes/BearerTokenResponse.php#L67-L69 . Yeah I'd recommend just yanking the 7.3.x releases and adding this to the 8.x breaking changes pile. I know there are fixes and workarounds but I shouldn't be having to use them   \ud83d\ude09 . Well practically yanking isn't really possible anymore after a week. Perhaps best to just ensure the old behavior still works in 7.x branch, if need be with some monkeypatch methods around the old extension points.\nRight now it's a dangerous wait until applications being less actively developed hit the composer update button, we can't be the only 2 using this.. No problem really, just sticking to 7.2.0 is an acceptable workaround for the time being as long as it doesn't take months to get 8.0 out or fix it well in a 7.3.x edition. Rather do it well than rush now that the dragon is already out. And given the lack of other outcry it would seem the broken extension point isn't used all that often.. Yep, I can confirm 7.3.2 is working fine again, cheers!. ",
    "alukaa": "so owners of this project consider to add this feature or not, i think it's important. for us we can understand what happened, but if we notice these response message to user, they may can not understand what happened. hope your guys to think a little about this, thx. ",
    "itay-moav": "AuthCodeGrant \n. going through the code I figured this . ",
    "ghostika": "Yes, i'm aware that the resource server can authorize only tokens, that was issued by the OAuth server.\nUsing Authorization Code grant with PKCE is clear to me, on the phone in a browser I present a login form and a FB login link for the user and after they logged in, they can authorize the mobile app.\nBut for UX porpuses I'd like to offer the opportunity, that the user authenticates himself with the native Facebook app first, and then goes the request to the OAuth2 server. \nI'm not sure what's the right flow here. Apart from the normal request parameters for the Authorization Code grant, should I just simply send the token, what the mobile app receives from the Facebook native app?. ",
    "brandinchiu": "No problem! I appreciate the reply either way. I'll move the question to somewhere more appropriate.. ",
    "eselskas": "Thanks for the quick reply, that makes sense now.\nHave a great day!. Hi @Sephster, I wanted to follow up on the above and clarify something.\nSince we have 2 separate APIs (resource & auth), we want to keep their logic completely separate and have them communicating to different databases. I have added the AccessTokenRepository to the resource API for the moment, but the concern is that if we need to modify this repository at some point and roll out the change, we will be facing some downtime since they're duplicates on both auth & resource APIs. Also, our resource API is currently aware of and querying the auth database, which is not ideal either.\nIs it possible to have some endpoint on the auth server which would be able to validate the tokens that way. So the middleware on the resource API would actually make a request to the auth API via an endpoint instead of directly querying the auth DB.\nDo you have any thoughts/suggestions in this case?. ",
    "crayner": "Sorry,  wrong package.... ",
    "dhrrgn": "@FrenkyNet I am aware.  I was just doing it for consistency in the class.  Not how I would normally do it, but want to be consistent.\n. ",
    "Ocramius": "@bakura10 please don't tell me that you're using symfony's http request object...\n. Argh, you ARE using it :\\ \n. null is implicit\n. string|null\n. Same as above\n. Same as above\n. Same as above\n. Should probably be injected\n. Storage should have an interface\n. I'd avoid getStorage - also, why does the token contain the storage?\n. Argh - active-recordish?\n. Also probably unsuggested \n. You know what to do here, @bakura10 \n. ",
    "JurJean": "Dear @philsturgeon could you please provide detailed comments instead of \"Bad change\" and \"Hello whitespace\" so we can fix problems accordingly? Thanks.\n. I see. Thanks.\n. ",
    "lcobucci": "You can look http://github.com/lcobucci/jwt too. \n. "
}