{
    "FooBarWidget": "Fixed in commit b60712e.\n. Looks good, excellent work! Thanks for contributing.  The only thing that I don't understand is the priority thing in Currency. It'd be great if you can document that in more detail. Other than that, feel free to release.\n. Looks good. I see a typo though:\n\"+  # Alternativly you can use the convinience methods like\"\nShould be \"Alternatively you can use the convenience methods like\"\nI'm not so happy with the ActiveRecord breakage. API breakages should result in a major version bump (e.g. 3.0.0) but the issue has been discovered after the release so no use in crying over spilled milk.\nThe ActiveRecord instructions should definitely be updated. You've written a new \"Money 2.3 and ActiveRecord\" section, but why isn't it part of the \"Ruby on Rails\" section? The \"Ruby on Rails\" section still contains incorrect code.\n. Yes agreed with the major version bump.\n@weppos: looks good. You should document that a breakage occurred in 2.3.0 though, and that previous versions used #currency and didn't need the patch.\n. I just noticed that the Github link in README.rdoc doesn't work very well. It links to this issue but the browser doesn't scroll to the correct comment. Can you document the issue directly in the README so that readers don't have to wade through all of our comments in search for the right one?\n. Looks good.\n. Fixed in 7147201909a3.\n. Fixed in commit b60712e.\n. Looks good, excellent work! Thanks for contributing.  The only thing that I don't understand is the priority thing in Currency. It'd be great if you can document that in more detail. Other than that, feel free to release.\n. Looks good. I see a typo though:\n\"+  # Alternativly you can use the convinience methods like\"\nShould be \"Alternatively you can use the convenience methods like\"\nI'm not so happy with the ActiveRecord breakage. API breakages should result in a major version bump (e.g. 3.0.0) but the issue has been discovered after the release so no use in crying over spilled milk.\nThe ActiveRecord instructions should definitely be updated. You've written a new \"Money 2.3 and ActiveRecord\" section, but why isn't it part of the \"Ruby on Rails\" section? The \"Ruby on Rails\" section still contains incorrect code.\n. Yes agreed with the major version bump.\n@weppos: looks good. You should document that a breakage occurred in 2.3.0 though, and that previous versions used #currency and didn't need the patch.\n. I just noticed that the Github link in README.rdoc doesn't work very well. It links to this issue but the browser doesn't scroll to the correct comment. Can you document the issue directly in the README so that readers don't have to wade through all of our comments in search for the right one?\n. Looks good.\n. Fixed in 7147201909a3.\n. ",
    "semmons99": "We don't want to add rails dependencies to the gem. Accounting for i18n should be done in your app.\n. This should be easier now that we've added the :delimiter and :separator options to format.\n. Allow 'nil' cents doesn't when creating a Money object doesn't make sense overall. But as cimm points out, you can use :allow_nil. Alternately you could use :constructor or :converter to manipulate the nil prior to calling to Money#new\n. Thanks for the patch. I'll take a look at it and see about incorporating it into trunk.\n. I have no problem merging this if you make one change. The Brazilian Real should always have a space between the symbol and the amount. You can see we had to patch this with the following commit 898d46265f3d0299507a4f74f39c762d51b00a96. Once that is updated, I will merge your changes into trunk.\n. I've merged your changes into trunk. I've sent a message to Hong Lai, and as long as he doesn't object, I will release a new version of the gem.\n. The updated gem has been released!\n. can you submit a patch to the documentation with you methods?\n. I'm having a hard time deciding what to do here. I don't want to put ActiveRecord specific code into the library, and I don't see the use of currency_as_string, and especially currency_as_string=, outside of this.\nI'm not very familiar with ActiveRecord, but is there anyway to use the :converter option in composed_of to make this work? Perhaps cents and currency should be stored in separate columns in the db?\n. Go ahead and write up the documentation and I'll merge it into trunk and release it.\n. I was thinking perhaps we should bump the major version once we get everything sorted out.\n. I merged weppos' changes into trunk and bumped the version. Take a look at the documentation and make sure we don't need anymore changes, then I'll release the gem.\n. I also created two pages on the wiki to detail information about this issue.\n. The gem has been released and the documentation has been updated.\n. #currency_as_string and #currency_as_string= have been added to Money as of version 3.0.3\n. Can you create a test case where this fails? I cannot recreate the issue.\n. did you follow the steps in the wiki for using Money 2.3.* and greater with rails? Here's a link to the wiki: http://wiki.github.com/FooBarWidget/money/ruby-on-rails-moneygem-23-an-later\nWhen we changed currency from a String to and Class there were some changes that are needed to your model.\n. The first spec will fail because there are no #cents= or #currency= methods. The second spec doesn't actually call rate = nil, it looks like composed_of (through some meta-magic) calls rate = Money.new(nil). I'd be interested to see if the error would go away if it was changed to rate = 0 in the spec.\n. I've added #currency_as_string and #currency_as_string= to Money it should make it easier to use #composed_of now, by doing the following:\ncomposed_of :price,\n  :class => 'Money',\n  :mapping => [%w(cents cents), %w(currency currency_as_string)]\nLet me know if this helps you.\n. What about this for your :constructor?\n:constructor => Proc.new { |cents, currency| cents ||= 0; currency ||= Money.default_currency; Money.new(cents, currency) }\n. also, do you need to add the following option to #composed_of?\n:allow_nil => true\n. I reopened this as a bug until we come to a good solution. I'm not keen on accepting nil for cents in the constructor, but if we cannot find another way, I may have to do it.\n. :contructor could also be written as follows:\n:constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) }\n. It's hard to say. When someone passes nil it might be an error. If we just convert it to 0, it will never be caught. I'm hard pressed to think of a constructor that accepts nil in place of a value and uses the default. Most libraries would expect you to pass a valid object (one that responds to #round) or not pass anything and accept the default. Looking at BigDecimal if you pass nil to #new you get an error in a similar vein to when you pass nil to Money#new. Essentially, we're looking for a duck (or anything that quacks) but you're passing a zebra.\n. when using the :constructor from http://github.com/FooBarWidget/money/issues#issue/5/comment/282826 I haven't received the error anymore. I'm closing this issue unless I hear differently.\n. These are both good suggestions. I'll work on them today.\n. as of a9a16d93dcab0abcc0517b88457531abef6421b4 #to_s, #to_f and #format use :subunit_to_unit\n. as of 513ca047e2c9a9459f4f2a671d6da43a827d9691 moved Separators and Delimiters to Currency\n. as of e7afe97f6fbe93de8b0444ca6244962d333c6713 the MIGHTY Chilean Peso is updated!\n. I'll work on this today.\n. Here's the spec I've created.\ncontext 'TND to USD using a rate of 0.67138' do\n  it 'returns the correct amount' do\n    @bank.add_rate('TND', 'USD', 0.67138)\n    @bank.exchange(1000, 'TND', 'USD').should == 67\n  end\nend\n. valodzka, would you be willing to write more specs to make sure everything is working as expected?\n. Doesn't work in reverse at the moment. Below is the failing spec.\ncontext 'USD to TND using a rate of 1.32862' do\n  it 'returns the correct amount' do\n    @bank.add_rate('USD', 'TND', 1.32862)\n    @bank.exchange(1000, 'USD', 'TND').should == 13286\n  end\nend\n. As of 627da58f07b60aaa5e9c3aaa2249067267871d46 both specs pass.\n. I'll work on this today.\n. in commit ddeda9e801d7d137026d1e2660cf148d913571d4 I added the following specs:\n```\ncontext 'using custom rounding methods' do\n  describe 'passing a rounding method to #new' do\n    before :each do\n      mth   = Proc.new{|ex| ex.ceil }\n      @bank = Money::VariableExchangeBank.new(&mth)\n    end\nit 'should use @rounding_method' do\n  @bank.add_rate('USD', 'EUR', 0.86)\n  @bank.exchange(10, 'USD', 'EUR').should == 9\nend\n\nend\ndescribe 'passing a rounding method to #exchange' do\n    it 'should use &block' do\n      @bank.add_rate('USD', 'EUR', 0.86)\n      @bank.exchange(10, 'USD', 'EUR').should == 8\n  mth = Proc.new{|ex| ex.ceil }\n  @bank.exchange(10, 'USD', 'EUR', &mth).should == 9\n\n  @bank.exchange(10, 'USD', 'EUR'){|ex| ex.ceil }.should == 9\nend\n\nend\nend\n``\n. commit b93de1a81577927dd373504f999a9c8150e2cc59 implements these changes. Is this what you were looking for?\n. yeah, the documentation is wrong on that. I'll fix it today too.\n. fixed in f1c4b60b7c9899e36e608774ab3a45ff0ab63ffa\n. I've never heard of this. I'll research it today.\n. failing spec added in commit 4951ac7d278ad1e1bfe1b81399928fb63cd2ad94\n. fixed in commit c4a20ad06b38ac029a2b860edc2b05b42def57b8\n. This is only used when we don't know the symbol of the currency being represented. The only way for this to happen is for the developer to insert a new entry into theMoney::Currency::TABLEconstant at runtime without :symbol specified. I'd wager this is a rare occurrence, and one a developer would realize they're doing, since warnings will be thrown for trying to update a constant. If you know of a missing currency, by all means, please fork and submit a patch. I could also fathom a patch that allows you to change the default currency symbol (just like you can change the default bank and default currency). If that is something you would find useful, please create a new issue and we'll mark it as an enhancement.\n. commit bad6f51412590854f392a307a86d917dff45776c adds support for optional currency argument in Numeric#to_money\n. commit 04fcbd29ee4c6d41a40af064575d70ec6d93b2c3 adds support for optional currency argument in String#to_money\n. failing spec added in commit 106b6b1d3262e20a851eba96d89611d9cf728668\n. fixed with commit fe5cb0302c00eff465d3d5940d5b56bb3e9f52dd\n. I'm working on a gem for the Bank of Canada and Federal Reserve exchanges rates, and can foresee the same issue coming up. What we'll need to do though, is create a backwards compatible method to do this. Perhaps a constant defined on theBankobject that if nil or false, requires cents in the exchange function, otherwise pass aMoneyobject. Thoughts?\n. I agree with you on both counts. I'll create a ticket forBank::Baseand start working on that one first. I'm also going to do one more release before we make this major change. I know of one user createdBankgem at the moment. I'll submit a patch to them when we're ready to release our updated class.\n.Bank::Baseissue create here http://github.com/FooBarWidget/money/issues#issue/14\n. I've decided I don't want to break anyone's current implementations, so I will be depreciating the#exchangemethod and adding a new#exchange_withmethod.\n. I believe I have everything implemented as of commit 2fd9b41ae19a4916c0d12e8debefd4a2c4a660c4\n. I'm closing this, feel free to create a new issue or comment on this one if you find anything wrong with the recent commits.\n. implemented in 4d688e7f2115d5e89e4c0bc9e28865d81dfb854b\n. Good idea, I like it. If you have time to implement it this weekend, feel free, otherwise I'll work on it Monday morning.\n. The only thing I'm thinking is that we need to moveget_rate,set_rateandrate_key_forintoMoney::Bank::Base. They're going to be needed quite often as helper methods in otherBankimplementations.\n. What you're saying makes sense. Let's leave them where they are in VariableExchange. \n. changes have been merged into trunk.\n. fixed in commit dfae9cfb2c066d1db3c11fe0a0990c0eae138703\n. Looks good, I've merged your changes into trunk.\n. added in 9ccc593fad1f7fa3cf635ba8eac214cdef277b69\n. added in 125302dde11a7e1bb17f02c4feed095677b26913\n. fixed with commit e211a70f63ac8cf748155c15206bf8f6e3b1f6fc\n. I will be adding these methods on Monday 08/30 and then releasing v3.1.0.pre3.\n. added in commit c471834c5acc91247679b125ddbf3826d244b62a\n. fixed with commit 5f70d6314c65ddb04262c8cf0fc362981d7f9c35\n. fixed with commit b51bd9d2e69577048c302bab6b66759c48200cd5\n. yeah, that makes more sense. fixed.\n. I think we should do three things. First addjsonas a development dependency. Second, usegemspec#requirementsto signal to the user they will need to installjsonif they want to use it to export/import rates. Finally, useautoloadinstead ofrequireforjsonandyaml. I'll make these changes today.\n. fixed in commits ba7f7c3cea69da374ebe5738594bb1f5198455a6 and a17fdb89c5b921458ff78b6c1cb552abb5d22779\n. do you havejsonor ruby 1.9? You'll have to have one to run the specs. Right now the specs run in 1.8.6, 1.8.7, 1.9.1, 1.9.2 and JRuby 1.5.2 on my machine.\n. ahh, it works for me because I haveRUBYOPTset to-rubygemsin my environment variables.\n. You should be able to use#to_fto do this already.\n. What about just enhancing#initializeto accept anyObjectand attempting to create a newMoneyobject based on theClass`? Something like the code below.\nclass Money\n  def initialize(obj,\n                 currency = Money.default_currency,\n                 bank     = Money.default_bank)\n    case obj\n    when Fixnum\n      # do what we do now\n    when String\n      # use String#to_money\n    when Numeric\n      # use Numeric#to_money\n    else\n      # raise an error\n    end\n  end\nend\n. Okay, I can agree with that. How about something like this then?\n```\nMoney#from_string\ndef self.from_string(s,\n                     currency = Money.default_currency,\n                     bank = Money.default_bank\n  #...\nend\nMoney#from_float\ndef self.from_float(n,\n                    currency = Money.default_currency,\n                    bank = Money.default_bank\n  #...\nend\n```\nThey're unambiguous, and we can easily add more methods in the future. In this case I wouldn't use String#to_money and use #to_f on the provided string, not have to jump through all the hoops String#to_money attempts.\n. I'd avoid #parse and just use #from_* that way there's a consistent way to do things when you're not passing cents to #new.\n. do you want to write these methods weppos?\n. We could add a #from_bigdecimal method as well.\n. I can implement these if you don't have time, weppos.\n. sounds good :)\n. You have to be a contributor to add labels, close issues, etc.\n. I like the ideas, but the word amount is confusing. Since we're already using cents I would suggest using the word dollars as it is more universally understandable, and corresponds well to cents.\nI'd also like to see a separate ticket (and set of patches) submitted for the core extensions cleanup.\n. Looks good, one minor thing, in the specs, can you use #new instead of .new in the descriptions?\n. Units is ambiguous, it can refer to either dollars and cents. I understands that dollars is specific to a handful of countries (approximately 36 countries use the dollar to refer to their whole unit of money), but so is cents (approximately 42 countries). I'd rather use a term that a majority of people understand and can reason about, than something more ambiguous that everyone would be forced to look at documentation for.\n. If dollars/cents is an issue, we could always add two new keys to the Currency table for :whole_units and :fractional_units and then use #method_missing so that users could call their natural language currency units (which will just call #dollars and #cents. It's not something I think is necessary, but could be added if you think it's needed.\n. If we go this direction, I would actually add :subunit and :unit to Currency::TABLE and the use #method_missing to call #dollars and #cents.\n. sounds good\n. sure, I'll do that right now.\n. fixed in commit ace4f67ce4a8af01f8c2f94fbd15fea718cd90fe\n. I'm going to try an introduce BigDecimal anywhere we're doing floating point math, since you really don't want to lose precision when dealing with money.\n. fixed with commit d0a97becfbdc0c3aa0376f5a1d715569a60c7f07\n. Yes, I prefer the describe and it style.\n. No. Just and oversite.\n. See if you can find any documentation on multiplying two dollar amounts together. I've been looking and can't find anything. I'm having a hard time making sense of when you'd multiply two dollar amounts together as well.\n. Looking around, when you multiple two numbers with the same unit the result is that unit squared. For example, 12 cm * 12 cm = 12 cm^2. Perhaps we should return a Money object, but through a warning saying something along the effects of, \"multiplying two Money objects results in Money^2 \"\n. good catch\n. update Money#parse to use :subunit_to_unit (closed by b0fd8a923c91c7c98d04d96ffef006b1b595ef70)\n. closed with commit b0fd8a923c91c7c98d04d96ffef006b1b595ef70\n. That would be great. I really like to get to a point by 3.5.0 where we don't have those types of hacks around anymore.\n. Lets back those changes out and leave them in a v3.2.0 branch for now. I'd like to release at least one more 3.1.* version before 3.2.0 to give everyone a little more time to remove their deprecated code.\n. I'm thinking a 3.1.5 bump for BigDecimal and #dollars\n. I like the idea of separate methods for handling simple strings versus complex ones. We'll probably need to think about a way of deprecating the old String#to_money so that it works more inline with Money#from_string and a new method to String that is a synonym for Money#parse.\n. so, something like a regex that detects anything other than digits, commas and periods?\n. We represent cents as an Integer so that we don't have to work with Float unless the user uses one in a calculation. It is common practice to #floor currency based transactions because in everyday use, you don't deal with fractions of a cent. If you need to keep those fractions of a cent, I suggest using #divmod which will return an Array containing the floor'd amount and the amount left over. For example:\n    Money.new(101).divmod(2) #=> [#, #]\nIf you want 50.5, call #to_f first.\n. Thanks for the patch, I've merge it into trunk.\n. Thanks for answering this weppos. Could you elaborate with an example, perhaps on the wiki?\n. Thank you very much! I didn't know if this was ever going to be done.\n. #to_money uses an older heuristic that was implemented prior to the library recognizing anything but 100 based currencies. Now that you've pointed this out, hopefully we can implement a fix for it.\n. fixed with commit f9d4383042b6129b8ed07d122274eb010e980882\n. I think we can handle this by using Math.log10(currency.subunit_to_unit) for all subunits that are multiples of 10. I'll try and write this up tomorrow morning.\n. This is fixed as of commit 5c5494edfd0e704fe6fc3639137e9f624a43e3d1\n. fixed with commit 82799a3bd8de726e655a3ea4b47127875a4c2d09\n. Can you submit your branch where cents is ensured to be an integer as a pull request? I'll merge it in as soon as you do.\n. Thanks, I've merged your patch.\n. I'm not quite sure why we'd add #decimal_mark. #separator has been functioning fine, and I'd rather keep to one definition. Also, all the whitespace changes really bother me, since I can't see what really changed in those lines. I assume it's adding #decimal_mark everywhere.\n. Okay, I agree. Separator and Delimiter are hold overs that could definitely be aliased and deprecated in a future version.\n. I did a benchmark test with your removal of using the ATTRIBUTES constant. #inspect increases the execution time of the method by 164%. I'd suggest removing that change. Better yet, by just changing it to the code below, we can decrease execution time of #inspect by 216%.\n    def inspect\n      \"<#{self.class.name} id: #{id}, priority: #{priority}, iso_code: #{iso_code}, name: #{name}, symbol: #{symbol}, subunit: #{subunit}, subunit_to_unit: #{subunit_to_unit}, separator: #{separator}, delimiter: #{delimiter}\"\n    end\n. Another good point. Of course now that it exists, it's hard to change. I'll have to come up with a deprecation strategy, just in case someone is using it.\n. I don't have time today, but I'll work on merging your patch tomorrow.\n. merged!\n. This must have to do with the Mutex on Bank. I'll look into it more next week.\n. fixed with commit 42950621dd89bac2157e54a4317c63c74b17ad87\n. wow, thanks for pointing this out. It seems we lost the commit at some point.\n. reimplemented in commit 0ed513e99b6a4b6031b4b477231d1afcc34da5ea I have no idea how it disappeared. Releases this morning in money 3.6.1.\n. Thanks for the initial code and the patch. Everything looks good and has been merged.\n. thanks, patch has been merged\n. It's due to the period after ea; it resets the heuristic. I'm thinking we could add something to the heuristic to remove / ea\\./ from any passed string. Before I do that and potentially introduce new bugs, could you do the same prior to calling Money.parse?\n. There's actually cases where multiple decimals are valid, specifically there are currencies/locales that swap the meaning of the decimal and comma. So our parser is incorrectly identifying your second decimal as an indicator that you're in one of these locales. I'm still thinking about removing / ea\\./ but I haven't thought through all of the ramifications yet.\n. I believe it's a bit of inconsistency stemming from before the library had a true Currency Class. Please, submit a patch and I'll be more than happy to merge it!\n. I think it's correct, in that you could be in the US, thus working with numbers which use , as a thousands separator and not the decimal. The only time I would treat it as you described, would be in VND was inside the string that was being parsed.\n. I'm closing this. Feel free to submit a pull request if you implement it.\n. strange, it must be an issue specific to ree, since testing on jruby 1.4.1-1.5.6, and matz 1.8.6-1.9.2 works. I'll double check the patch works with all versions we test with and apply it.\n. merged.\n. merged\n. can you try and clone the repo and install using rake install? I believe this issue is fixed with some of the recent commits that have not yet been released.\n. Great! I plan on rolling a new official release today.\n. thanks for the patch, I went ahead and merged it\n. thanks for the patch, it's been merged\n. Money#format already has :no_cents option you can set to true to omit cents, but it will not do rounding.\nAnother option would be to update :subunit_to_unit to 1 for JPY, but we should only do this if the Sen is never used.\nThe final option could be to add :always_suppress_cents => true to the Currency::TABLE, but I'm not sure this is desirable either.\nIs the Money#format option workable for you? The biggest issue I foresee, is we'll need to do some type of rounding with everything but setting :subunit_to_unit to 1, and that has it's own issues with losing precision.\n. You could probably monkey patch #format to always set :no_cents to true when working with JPY.\n. I'll keep this as an idea. I have to figure out how it would effect anyone using JPY right now that expects cents. I'd have to force them to always use :no_cents => false or create a new :show_cents on #format which is really just flipping the situation. I'll wait to get more feedback from others and go from there.\n. sorry, Money::Currency::TABLE was created as a constant and was not meant to be used outside of Money::Currency itself. To access information about a Currency object, you should be using the public methods which still include #separator and #delimiter. We'd be more than happy to accept any patches you need to make to Money::Currency::TABLE if it is incorrect, out of date, or missing something you need.\n. I'd be more than happy to add the new fields to currency for you. I'd love to have the correct name of the currency in their native languages. Correcting the symbols would be a great patch too. If you have information on older currencies, that too would be helpful. Any other information you need, that may be useful to others is more than welcome to be added.\n. Just do the ones you have. Hopefully others will find it useful and contribute to any you miss.\n. I agree with weppos. Without separate commits for each feature, and tests for those features. We can't really do much with this.\nRegarding the change of adding date to the list of arguments of #exchange_with; this should probably only be implemented by a new Bank gem. We can't expect anyone whose already created a Bank gem to accept this new parameter.\n. Perhaps changing it to def exchange_with(from, to_currency, options => {}, &block) would make more sense. Easier to expand in the future. I wouldn't feel bad doing this to everyone whose already written a Bank module.\n. If you're still planning on working on this please continue and submit another pull request when it's ready.\n. If I understand right, this \n:cny => { :priority => 100, :iso_code => \"CNY\", :name => \"Chinese Renminbi Yuan\",                     :symbol => \"\u00a5\",             :subunit => \"Jiao\",          :subunit_to_unit => 10,   :symbol_first => true, :html_entity => \"&#x5713;\", :decimal_mark => \".\", :thousands_separator => \",\"},\nshould be changed to this \n:cny => { :priority => 100, :iso_code => \"CNY\", :name => \"Chinese Renminbi Yuan\",                     :symbol => \"\u00a5\",             :subunit => \"Fen\",          :subunit_to_unit => 100,   :symbol_first => true, :html_entity => \"&#x5713;\", :decimal_mark => \".\", :thousands_separator => \",\"},\nIs that correct?\n. updated in commit 1a1cb22ebc3d017ed187774aee2c0e728e1fd5fc\n. thanks, your patch has been merged.\n. :no_cents is meant to remove cents when displaying a Money object. It is not meant to round the value before removing the cents.\n. We have nearly 61,000 downloads, so I'm not sure any uses it like this, though I'd wager a few do. I'd be willing to accept a patch that adds a new option to #format such as :round_cents which does what you wish it to. Just write the code/tests and submit a pull request.\n. - Money#neg looks good, I'll accept it. I'm also going to add an alias of #negate\n- #exchange_with and #exchange_to look good, I'll accept them.\n- adding an i18n switch would be great as would Rails key\n- I'm hesitant about the two deprecations. We don't know who is relying on them, and they're not getting in the way right now.\nI like the idea of Money#to_h and Hash#to_money, but I think it would be better if it was something like this https://gist.github.com/842113.\nFinally, how are you modifying the Currency::TABLE? Adding new keys, or changing values? If you're changing values, one commit per currency would be preferred. If you're adding new keys, then one commit per key would be preferred.\n. - I think having all the attributes returned by #to_h is a good idea so people can use whatever they need.\n- I may add your deprecation suggestions, I need to think about it more.\n- Wow, that's a lot of changes. Can you give me an overview of the changes, if they all sound good, I'll accept them in a single commit.\n. I think others could find former currencies helpful. I think it's fine adding them to Currency::TABLE, perhaps with another attribute that indicates their no longer used.\n. I'm going to close this until we get your currency updates straightened out. Then you can resubmit this pull request.\n. I plan on pulling both of the pull requests tomorrow morning. Just an FYI, I usually don't accept any pull requests with failing tests. I might make an exception here. But I not sure I will, it's a rule I want to stick to.\n. I'm sorry, but I cannot merge this. There are too many incompatibilities, with Ruby 1.9+ etc. I willing to work through this with you. I've create a gist here with the current currencies in yaml format. Please update this with your new attributes and currencies. Please do not reorder anything. I want to be able to easily compare the two files to ensure the differences are valid.\n. I'm willing to work on this, I just need a valid yaml file. If you can't give it to me in the same order, can you at least give it to me sorted alphabetically?\n. I believe there are some errors with your yaml conversion process. For instance :ghs has somehow become an attribute of :ghc instead of it's own entry. I think it would be better if we started with one commit that extracts Money::Currency::TABLE into it's own file currency_table.rb. Then another that creates a rake task to extract that Hash into a yaml file. And finally a third commit that adds a rake task to convert the yaml file to the Hash. If you can does this, then we can proceed to adding your currencies changes. Otherwise, I suggest you fork the gem and maintain your own branch as right now, these changes are not working correctly.\n. @elmatou I'm not sure if this will help you, but we recently removed the TABLE hash and started storing the currencies as JSON.\n. Putting an index on a CHAR(3) field in the database on iso code should make it perform just as well. Since ISO doesn't provide a universally recognized number for each currency, I really wouldn't want to try and maintain one myself.\n. There's no reason it couldn't be. Feel free to write a patch and I'll merge it if everything looks okay.\n. It's pretty easy. You'll create a fork of the project, write your new method plus tests, then submit a pull request. I'll check out everything to make sure it works and merge it in.\n. I'm closing this for now. Feel free to reopen when you have a pull request ready.\n. You have these backwards. decimal_mark is separator and thousands_separator is delimiter. Also, it should be number.currency.format.separator and number.currency.format.delimiter and these are optional and not always given, which is why the original implementer used number:format but incorrectly used the wrong names. I've commented on the diff on what I think they should be. Before I can merge these, I'll need to see some tests. You can do this by writing a spec that requires ActionPack.\n. I had make quite a few changes. You still had separator/delimiter backwards. I also cleanup up and implemented correct tests.\n. @pconnor thanks for the updated documentation!\n. @weppos: Can you take a look at this? I'm not as familiar with Rails as you are.\n. I believe you should write this as:\nruby\nCompany.new(:balance => Money.new(100, \"EUR\"))\n. @jell Was anything changed regarding the specs aside from splitting them up? My biggest concern with chopping up the specs at the same time a massive change like this is done, is that something might have broken backwards compatibility that we won't be aware of.\nWhat I'd really like to see is this request rebased into two commits.\n1. The refactoring of code in the lib directory\n2. The refactoring of code in the spec directory\nThis way I can test each commit individually. Overall, I like the idea, I'd just like to have it cleaned up and tested.\n. @Jell thanks for your work on this. We really appreciate it.\n. @Jell everything looks great! Thanks for the patches.\n. @nurey, you could also use :symbol => false and not worry about it. Your choice.\n. @nurey, please see commit 684f60dccf5e7b47baa330ee690fdd65eabee849 for how I enhanced your specs after I merged your changes. This is more what we're looking for when it comes to tests.\n. updated in commit 05841763f8e1e35cf19ead529b86b523435995cb\n. If you create a patch for this I'll be happy to merge it.\n. I guess I don't understand the issue with creating a negative object. If you subtract $1 from $2, you need a -$1 money object.\n. Two things. First, before I can accept this patch there needs to be tests added for the new functionality. Second, I'm not sure that we want to auto-convert everything sent to arithmetic methods. How can be ensure that they get the correct Currency, etc? Maybe we need a global option that you can enable to auto-convert everything where possible and let users set it themselves.\n. I agree with @weppos. The only way I can see enabling this would be to have multiple global options for the user to configure. Seems like it would just be easier to force users to always add two Money objects, calling #to_money or Money#new first.\n. Looks great. Merged!\n. I think rails-money would be the best fit. If you created it, and would like to have it be part of the RubyMoney family, I'd have no problem adding it to the organization and making you a member. In fact, if you're interested, I can setup the repo and give you full admin rights to it, just let me know.\n. We have to pass the Float to preserve backwards compatibility. I actually have written a new gem cashrb. That forgoes backwards compatibility to make things easier and clearer.\n. updated in commit ea323af1bf70c523ce332ac917b7c3b3067857a4\n. updated in commit 236a0b3c5fff5c360b4b968783a3e8eac9ddba9d\n. Thanks for the patch. Once you make that change, I'll merge your code.\n. Thanks for the patch. It's been merged.\n. Proposed change here 82f5fef3d52019c571c0\n@hakanensari, this should do what you're looking for and still keep the i18n bug fix that other users requested. Try it out and let me know if it works for you.\n. Here's where I'm still having a problem with raising the version to 4.0. i18n was implemented as an enhancement in 3.5.0, it gave you the ability to use i18n to look up separators/delimiters if you were using i18n in your application.  Since this was an enhancement to the public API (and was backwards compatible) we increased the minor version. Now, in 3.6.2, we made a bug fix that used the currency entry in rails_i18n if it was available. This was a bug fix, so that patch version was added. Nothing broke backwards compatibility. What I don't understand is why your app started using i18n in 3.6.2, when it should have back in 3.5.0 already. We probably should have had this switch available since 3.5.0, but we didn't, but I don't think this makes it a backwards incompatible update requiring a major version bump.\n. I agree, it's an edge case. I'll be pushing this out as 3.7.0 today.\n. Pushed out a new version just now.\n. I'm going to leave this to users to define. The only reason that banks have #to_json methods is to easily unload and load rates.\n. Thanks for creating the gem. If you're interested in joining the RubyMoney team, just let me know.\n. I understand what you're requesting, but how is this different than the i18n support that is baked in already?\n. If I were you, I would just add an entry to the Money::Currency::TABLE hash. If bitcoins ever become a internationally recognized Currency, we would then add it to the Gem for everyone.\n. what about passing the money amount to the other page like this n.format(:decimal_mark => \".\", :thousands_separator => nil)?\n. Having not heard anything in 2 weeks, I am closing this issue.\n. what about just using #to_f\n. @weppos can you take a look at this?\n@defconomicron & @asadfarooq We take all issues whether report by 1 person or 100 with the same importance. Looking at your profiles you appear to either be the same person, or at least know each other. There's no need to say you both have the issue if either is the case.\n. I'm sorry, our rails expert @weppos isn't available right now. Have you tried posting this question to the rails mailing list, or on IRC?\n. @weppos @defconomicron any advancement on this issue? Is it a non-money issue?\n. Just curious, have you tried using cashrb\n. Looks good, thanks for the fix!\n. I would suggest using BigDecimal until you need to output the actual dollars/cents value. That's what I've done in the past. \n. Instead of storing the second object as a Money object, you could just store the raw cents value. But I don't really think you're violating DRY by storing the currency in both models.\n. Why wouldn't it be the same? It seems like it would be a good idea to check that and make sure there isn't a mismatch. If you always assume they're the same, and they're actually not, you could get some potential big miscalculations I'd imagine.\n. It should work for other currencies already...\n. Awesome, Thanks!\n. According to ISO, 1/100 of a Yen is a Sen, which is used by ISO as the cents notation for Yen. If you didn't want to use Sen, you could just call #format with :no_cents.\n. If that's the case, I have no problem removing Sen. Please update the currency file appropriately and send a pull request. I'll merge it right away.\n. Decimal will lose precision. We'd have to use a BigDecimal. You might look at using my cashrb gem instead. It let's you use custom currencies and uses BigDecimal by default.\n. We need a patch to store cents as a BigDecimal. I have no problem accepting a patch to do just that, but I purposefully started work on cashrb to get rid of all of these issues.\n. bigint\n. It should, I don't see why it wouldn't, but I haven't tested it.\n. Thanks for the patch!\n. Thanks for the patch!\n. He's right there, you're storing the currency for both objects in the same field.\n. Thanks for the patch!\n. Thanks for the update!\n. I'm thinking we should leave this in for historical calculations. We have a number of requests for those before.\n. That would be fine with me if someone would like to submit a patch.\n. It's to signify that the currency isn't valid anymore, but it still needs to be there for legacy reasons.\n. Take a look at #exchange_with my guess is has something to do with the rounding here. https://github.com/RubyMoney/money/blob/master/lib/money/bank/variable_exchange.rb#L87\n. @johnrees anything further on this?\n. Excellent! Feel free to submit a patch to the readme with a link.\n. Awesome, thanks!\n. @alovak this looks great. Thanks for the patch. Merged!\n. Fixed! Just pushed 4.0.1\n. Excellent! I've merged the patch and given you commit permission. Could you add some tests?\n. I'll let @weppos handle this, he's our resident rails integration expert.\n. Closing this issue. Please reopen if there is more that needs to be done in the future.\n. Hmm. With subunit_to_unit => 4400, 0.5 is invalid. That's implying 5000 \u0447\u0430\u0442\u043b. Does this actually mean 5 \u0447\u0430\u0442\u043b? If so does \"0.0005\".to_money(:kzm) work? If no, could you write up some failing tests for us? I'm guessing we'll still have a problem because this isn't 1,5,10,100,1000, etc. But if you commit to writing some tests, I will work on getting this fixed.\n. Closing this. Please open a pull request with your tests when they're ready.\n. @weppos, what do you think about this? I've never been a fan that we even have the method Money#to_money. It seems to me if you want to change the Currency of your object, you'd just call #exchange_to yourself anyway? @pelle, can you give me an example where you'd want to use this instead of #exchange_to\n. Fair enough. Merged.\n. Thanks!\n. Instead of making #initialize do two different things, I'd rather stick to the single responsibility principal and create a new class method #add_currency which does this.\n. Ahh. I understand. You might take a look at my other gem cashrb which lets you define arbitrary currencies. For now I'm going to close this pull request.\n. @weppos this is great. I think we're on our way to actually cleaning up this library.\n. Excellent. I ran it through all the Rubies I could think of and everything works accept we're failing on some encoding issues with jruby-1.6.5 when running in 1.9 mode. Can you try and see if it's just my machine that has the issue?\n. Alright sounds good to me. I'm betting it has something to do with currency.json being utf-8 but there being no indication it is.\n. Thanks for pointing this out. I'll update the README. We have to have UTF-8 since there are so many currencies other than USD that use non-ASCII characters.\n. Check out my other gem https://github.com/semmons99/cashrb I think that's what you're looking for.\n. Thanks for the patch. You now have commit access to the repo.\n. Excellent. Thank you. You now have commit access as well.\n. thanks @dom1nga you now have commit access!\n. I think this would be good as a separate gem that could be loaded at runtime if desired.\n. I'm going to close this issue. However, @etagwerker if you decide you would like to build the gem, we can make it a RubyMoney project and add it as a official repo. If you need any help implementing it, just let us know.\n. Perhaps we leave this open and keep taps on the issue. I would imagine this is a JRuby bug if all other implementations work right.\n. I'm going to go ahead and close this. We can point anyone to this who opens a new issue.\n. For this to affect someone, wouldn't they have to issue 16 million unique symbols? The only issue I could see is if you're throwing heaps of invalid currencies to Money::Currency#new.\nWouldn't this fix the problem?\n``` ruby\nID_STRINGS = TABLE.keys.map{|k| k.to_s.downcase}\ndef initialize(id)\n  id = id.to_s.downcase\nunless ID_STRINGS.include? id\n    raise UnknownCurrency, \"Unknown currency '#{id}'\"\n  end\n@id = id.to_sym\n  data = TABLE[@id]\n  data.each_pair do |key, value|\n    instance_variable_set(:\"@#{key}\", value)\n  end\nend\n```\n. Since no response has been given in a week, I'm closing this issue.\n. @kenn if you have some time to make the pull request and add a test or two, that'd be great.\n. @nubs Could you please add some tests for this?\n@dom1nga what would you expect Money.parse('-5.95-') to do?\nThe problem I have with #parse in general is that we try and throw too much at it and hope it converts properly. If I was doing this over, there wouldn't be a parse method. I'd expect the user to know their input format and get it into some form of Numeric ahead of time.\n. @dom1nga I don't really have an opinion one way or another; but could you elaborate more on why you think this should throw an ArgumentError?\n. @dom1nga sounds reasonable. I assume you would argue the - in front and behind the number part is ambiguous and could either be a negative or some type of separator from data fields, much like a comma in a standard CSV?\nI wonder if we need to raise a new ParsingError for anything Money#parse can't handle. Does such a thing exist?\n. @nubs, awesome the patch is starting to come together. Now if you can just raise a ParsingError we'll be all set.\n. @nubs nevermind about the ParsingError we'll address that issue in a future release.\n. Thanks for your patch @nubs. You now have commit rights to the repo.\n. @WhiteFire-Sondergaard Feel free to submit a patch for each of these issues and we'll merge it. Make sure that they are separate pull requests please.\n. I think this underscores the issue that we need to finally address string parsing. I've opened a new pull request to get opinions before we make anymore changes.\n. @weppos @alovak @dom1nga @jacobat @jduff @mreinsch  @nubs @pelle @semaperepelitsa\nLooking for more opinions on this? Anyone have some other ideas?\n. @alovak Currently our string parsing is a mishmash of heuristics to try and detect and parse a money-like object. The problem is we're always getting new request for how parse string and just like everything else having to do with money, they're region specific. What I'd like to do is come up with a solution that puts some (or all) of the burden back onto consumer of the gem for parsing their own strings.\n. I'm going to close this. We can revisit this if we start having more pain.\n. I you can find all the information for those and make a patch that would be\ngreat.\nOn Thursday, December 29, 2011, Mateo Murphy \nreply@reply.github.com\nwrote:\n\nI've just started using Money with money-historical-bank, and notice that\nthe data that open-exchange-rates provides includes some currencies that\nare not supported by Money. Namely; zwl, iep, xdr, tmt, and clf. I could\nadd support for these if anyone is interested?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/136\n\n\n\nshane\n. Thanks for the patch @kenn. You now have commit rights to the repo.\n. @weppos could you field this one?\n. I could see making #=== match an object that can be coerced into a Currency object. But I believe #== should stick strictly to Currency-like objects.\n. Feel free to open a pull request and add this method. So long as there's test and it doesn't break anything I'll merge it right away.\n. @weppos I think your message was cut-off.\n. thanks @enebo. You now have commit access to the repo. Use it wisely :smile:\n. @barmstrong The issue is that adding a new currency is harder than appending a new record to the TABLE constant. Since it's a constant, it really shouldn't be modified. That being said, we need to provide a way to allow users to add new currencies safely. I'll work on something today.\n. > IMHO currency should be added though pull request :) What do you think?\n\n@alovak for a legit, iso recognized currency I agree. However it is nice to support non-standard currencies with #143 should address.\n. After some testing, we will be releasing 5.0.0 since this change breaks compatibility.\n. @alovak @weppos @barmstrong How's this look to everyone?\n. @alup once I hear from the original issue creator that it covers their request I'll merge it :smile:\n. @mattv thanks for the bug report\n. NOTE: #147 will handle this.\n. Please add a spec as a sanity check. Then we'll merge.\n. @enebo can you rebase master on your code. Right now I can't do an automatic merge and it doesn't make sense to me.\n. @enebo please close those issues and mention your fix.\n. @enebo One more thing, if you haven't already, please update CHANGELOG.md with a description of this change and references to the issues and pull requests that it addressed.\n. This is mostly due to the US centric beginnings of this library where are :subunit_to_unit calculations were 1:100. I could see renaming #cents to #subunit, but seeing as it hasn't been a source of confusion (at least one that's been reported) I'd rather just leave it alone.\n. Thanks for the pull request @scomma. Anyone who submits a patch, and has it accepted, is given commit right to the main repo, even you. Thanks again.\n. @scomma I just noticed that you didn't run any of the tests after you made this change. Please ensure in the future all patches you make have been tested first.\n. Thanks @matma. You now have commit rights to the repo.\n. Thanks for the patch @the-architect! You now have commit rights to the repo.\n. @banjerluke this introduces a failing spec. Could you please fix it and let me know when you've pushed a revision?\n. Thanks for the patch @banjerluke. You now have commit rights to the repo.\n. @neilmiddleton an assumption of the default currency just as if they hadn't opted-in.\n. Thanks for the patch @neilmiddleton. You now have commit rights to the repo.\n. Thanks for the patch @alup. Before I merge it, please update the CHANGELOG and add your name to the AUTHORS file.\n. Thanks @alup! You now have commit rights to the repo as well.\n. Thanks for the patch @ohthatjames.  Before I merge it, please update the CHANGELOG and add your name to the AUTHORS file.\n. Excellent. Thanks @ohthatjames. You now have commit rights to the repo.\n. @alup in the future, feel free to just create a pull request and describe the issue there. Should hopefully save you an extra step. :smile:\n. Other than the issue I noted above, this looks fine. Feel free to add your email to the travis-ci config to be notified of any problems that arise during CI after this patch is merged.\n. @weppos I'm going to rely on you and @alup to discuss and refine this feature. I still have limited Rails knowledge and can't really speak on this with authority.\n. I'd be in favor of a new gem myself. I have no problem creating a new money-rails repo and giving whomever wants to lead and develop the project full admin control of it.\n. @alup I've created the money-rails repo and given you and @weppos admin rights to it. Go nuts!\n. This looks great @MatmaRex! Please follow the Contribution section of the README by updating the changelog and authors section. Once you have, let me know and I'll merge.\n. > Fine, although I have no idea why would that be needed. (Or why should I do it in particular.)\nThe CHANGELOG needs to be updated so that others know what you changed without reading the Git history. AUTHORS is nice to see who worked on a project and give them some recognition.\n\nAlso, I don't need the commit access, thank you. (And I don't see why would you give it out to everyone.)\n\nYou don't have to use it then. If a developer is willing to take their time to fix a bug in software I maintain, I'm willing to offer them my respect by giving them the same access I have to this project. Some of our greatest core members have come from this practice. We believe in Free and Open Source Software which is why we offer everyone who's willing to help commit access. Anarchy in software is the reason FOSS keeps moving forward.\n. A pre-release of 5.0 will be done today, followed by a full release next Monday if not issues are reported.\n. I just released 5.0.0.rc1\n. Having AUTHORS around keeps us independent from that particular Github feature and doesn't force user to clone the repo and run git who to see who has contributed. Really, it's just a nice, small file to make sure everyone who works on the project is recognized in an easily viewable manner.\n. @MrGando You can start looking in this file. You'll probably need to put some special logic in for currencies that map subunit_to_unit as 1.\n. @MrGando what version of the library are you using. I just wrote the following test and it works.\nruby\nit \"handles CLP correctly\" do\n  clp = Money.new(1000, \"CLP\")\n  clp.format.should == \"$1.000\"\nend\nI'm going to close the issue under the assumption it's an old bug that was fixed in the 5.0.0 release. Please reopen if that's not the case.\n. Thanks for the patch @exviva. You've been added as an author of the gem and give commit rights to the main repository.\n. If we were to do something like this I'd create a new instance variable on Money (something like raise_exception_on_invalid_conversion) that defaults to false. Users could change this setting if needed. Then we could modify #to_money to check this flag and act accordingly. Adding a ! to methods to raise exceptions is a Rails convention (not a general Ruby convention). I'd like to avoid explicitly writing anything that is specific to Rails, etc.\n. What if we had the library wide boolean and an option parameter that you could pass to #to_money? Has anyone found other libraries outside rails that optionally raise exceptions, is there a common pattern?\n. I'm going to agree with @weppos. Let's close this issue until more requests come in with a similar issue. He's also right that #parse is probably the place we would really want to look at modifying.\n. @kirillian could you actually just create USD5 yourself and create all new money objects you need using that currency?\n. I'm good with adding a precision attribute to each money object. However, instead of having the user specify the precision, should we just allow either the default based on the currency or infinite and then have the rounding be done by the user user for the #format method.\nQuite honestly, I'd really like to make a Money2 library that gets rid of a lot of the technical debt we've acquired over the last 5 years.\n. I'm thinking we stop using Integer and start using BigDecimal. It's what I did with cashrb, my first attempt at rewriting this library.\n. Yes, it would be helpful if they were separated. We should really start with internal precision and once that is solidly in place go about getting formatting precision working. @kirillian do you feel up for trying this?\n. Couldn't we just store the current cents as the whole number of the BigDecimal and the extra precision as the fractional cents? Then we can just modify the #cents method to return round(0, BigDecimal::ROUND_HALF_EVEN) unless a variable is set. This should preserve backwards compatibility.\n. Awesome, thanks @kirillian!\n. Please open a pull request. Even if the code isn't ready to merge, it will give us a place to discuss it.\n. So, I was thinking this could be simpler. Perhaps something like this.\nlib/money/money.rb\n``` ruby\nclass Money\n  class << self\n    attr_accessor :infinite_precision\n  end\nself.infinite_precision = false\ndef initialize(cents, currency = Money.default_currency, bank = Money.default_bank)\n    @cents    = BigDecimal(cents)\n    @currency = Currency.wrap(currency)\n    @bank     = bank\n  end\ndef cents\n    if self.class.infinite_precision\n      @cents.round(0, BigDecimal::ROUND_HALF_EVEN)\n    else\n      @cents\n    end\n  end\n```\nNote, we definitely do not want to define #cents=. Users should only be creating new money objects, not mutating existing ones.\nWe'd need to audit our internal code to make sure we only use #cents and don't directly access @cents, but it should work.\n. @kirillian let me know if you need any help finishing this patch up.\n. @kirillian I wrote up my own pull request this morning (https://github.com/RubyMoney/money/pull/174). What do you think of it?\n. :smile: I felt like coding this morning.\n. Adding the rounding mode is a great idea. I'll do that right now.\n. @davekaro any way we can write some tests for this?\n. I'd be fine with a patch that has us use multi-json instead.\n. Aside from removing the requirement line above, this looks good to me. Just shot me a message when it's updated and I'll merge.\n. Thanks for the patch @davekaro! You now have commit rights to the repo.\n. This pull request addresses that very issue https://github.com/RubyMoney/money/pull/169 :smile:\n. Historically cents was used because Floating Point math was bad and would lose cents in calculations. We're now trying to retrofit the library to use BigDecimal, but not change the interface on users. You can still use your decimal structure and just call the \"#to_money\" on your decimal data. It should be handled properly for you.\n. there is a money-rails gem that might help you.\n. just rebased to sync with master\n. @kirillian I started using #to_d for conversion where appropriate. Had to add a new conversion_precision option since 1.9 requires you to provide one.\n. Hmm, you're probably right that it does use sprintf at some point. Any ideas on how we can coerce the fractional cents out other than that?\nOnce we get this merged, I'll let you got about implementing the new #format option. I'm also going to go ahead and give you commit rights now since this is really your patch written by me.\n. git rebase master\n. excellent. Do you see anything missing from this pull request?\n@RubyMoney/money-devs and @RubyMoney/money-admins do you see anything missing from this pull request as far as tests go?\n. @semaperepelitsa traditionally, we've returned cents as an integer. If we don't continue to do it we'll break backwards compatibility.\n. If no one speaks up against this patch, I'll be merging it on Monday 6/4.\n. @kirillian: The patch has been merged. Please add your missing tests and create a new pull request for your change(s) to #format.\n. Thanks for the heads up. Updated in commit 577020a7ef12723493d058758b7f2067d08d650d\n. According to CHANGELOG.md, JPY was updated in 4.0.0 to correctly use :subunit_to_unit = 1 since the Sen has been out of circulation since 1953. I believe that's why you're seeing the difference. Essentially JPY 500 no correctly implies 500 Yen instead of the defunct 500 Sen.\n. This is a tough call. If I were representing the amount as a float, it should probably be 1.9, but if I was displaying it, it would probably be 1.4. Honestly thought, I have no idea.\n. @kirillian: I've added an unresolved tag to this issue and am closing it. Please reopen if you stumble across any more information.\n. JRuby and Travis-CI aren't getting along lately. I'm going to close this until I see things stabalize.\n. Awesome. Merged!\n. @hakanensari would you update the wiki with this information too?\n. Please submit a pull request with the required updates.\n. I'm fine with this, though we'll need to be vigilante that no one accidentally commits files that were caught by the projects .gitignore previously.\n. @weppos I say merge it and see where the cards fall. Worse case, we eventually revert the commit. More likely we help educate the public (and ourselves) from time to time on the need for a global .gitignore for our editors, etc.\n. It would probably be worthwhile to put the existing ZWD into currency_bc.json at least. As for the other three, if someone can dig up their information and put it into currency_bc.json as well that'd be nice, but not necessary right now.\n. Closed via #186\n. Please investigate and submit pull requests for any problems like this you find. \n. Thanks for the patch @Exoth! You now have commits rights to the project.\n. > But seriously, what's \"bc\"?\n@hakanensari: It stands for \"Backwards Compatibility\". We're very hesitant to break backwards compatibility for purities sake. Therefore we move defunct currencies into currency_bc.json to signal to us they're bad, but someone might be using them.\n. > The library depends on multi_json to load the config and export rates in multiple \"formats,\" including JSON.\nmulti_json is required due to problems with certain versions of JRuby. Originally we used the builtin JSON parser until the problem was discovered.\n. > 1) VariableExchange#export_rates should have a single responsibility, which is to dump the rates Hash. Let the user then worry about formatting that Hash, which is trivial.\nVariableExchange is more of an example implementation of a Bank than something that should actually be used. If you come up with a better example implementation that follows SRP better, I'd be happy to deprecate this implementation in favor of it.\n. > 2) Convert the config to YAML. Standard library FTW.\nJSON is a standard library, and if it wasn't for the JRuby bug, we wouldn't need multi_json. That being said, I'm not opposed to using YAML or even Ruby.\n. @hakanensari: I just looked through all the bank implementations we have listed in the README and all but one subclass VariableExchangeBank. I think we're stuck with that one until we come up with a better implementation. When we do we will need to deprecate VariableExchangeBank and work with the authors to update their gems if possible.\n. I have no problem depreciating and then removing #to_currency. Please investigate and submit a pull request to start the ball rolling on that.\nAs for #to_money I agree with @weppos that this is more extending a class than monkey patching it. That being said, it wouldn't be a horrible idea to make people explicitly request the #to_money feature by doing something like require \"money/core_ext. That being said, I don't want to pull the rug out from users by suddenly making them do this. And I can't think of a good way to notify them we're going to change this. With a library this mature, I tend to error on the side of least surprise and just carry around the baggage. That being said, if someone comes up with an good idea, I'd be willing to take a look at the resulting pull request and discuss it.\n. Pull Request #191 removes the need for multi_json while keeping everything in the current JSON format. Please pop over there and let me know if there are issues.\n. @hakanensari: I can't see any good reason not to move everything into a plan old ruby object. What to give it a whirl?\n. :smile: I'm good with it!\n. @davekaro Ahh yes. Thank you for reminding me. So, if we want to keep JSON, we need to continue with mutli_json.\n. @hakanensari: At one point the currency data was in a CONSTANT that was a Ruby Hash. I'd need to dig back thorough time to see what the rational was for stopping that. Unless somewhat else remembers. I believe it was last year around this time.\n. @hakanensari It should now only be necessary via a development dependency for testing the VariableExchange bank. And honestly I say we remove the dependency and assume anyone developing the gem is using 1.9.3+.\n. go ahead and remove the badge and LoadError while you're at it.\n. @weppos and anyone else, I'd like to hear your thoughts on this pull request. I think it brings us forward, but I want to make sure I'm not missing anything.\n@hakanensari: Mind updating the CHANGELOG for these changes?\n. The json dependency is for VariableExchangeBank importing and exporting rates. I still torn. I wonder if we should extract the currencies into their own gem and have money add the new gem as a dependency.\n. I think you're right @weppos. The first option makes the most sense to me as well. If someone else wants to tackle just getting the standard JSON library to work, I say go for it. Otherwise I'll tackle it on Monday.\nAny thoughts on leaving 1.8.7 behind?\n. Thanks @mdi \n. This really doesn't make sense to me. It only works when one of the currencies is ZERO. But just because a currency is zero doesn't mean you can do arithmetic on the two. You can't subtract 2 meters from 0 seconds, it doesn't make sense. Likewise you can't subtract 2 EUR from 0 USD. You need to first normalize to a single currency.\nAlso, for future reference, please include applicable unit tests.\n. Here's where I'm worried.\nruby\n[100 USD, -100 USD, 1 EUR].inject(&:+) # ==> 1 EUR\n[1 EUR, 100 USD, -100 USD].inject(&:+) # ==> Exception\nI'd rather we work consistently everywhere. Also, the 1.9 syntax takes care of peeking at the first item. I do see your point of have a special type of Money object though represents some abstract ZERO amount.\n. @ioquatix: Would you please open a new issue to discuss the creation and role of a Money.zero object. Being pragmatic, it's a rather complicated topic that I'd like to hear others discuss and share their pain before we attempt to tackle it.\n. @ioquatix: I really like this proposal. Unfortunately I don't have the time to implement this single-handedly right now. Any chance you could start a pull request and we could work together to create a solution?\n. @llazzaro: I'm still working through the scenarios to decide if polymorphic zero is good. Right now I think it is. And yes, Money::Zero would solve this issue.\n. @RubyMoney/money-devs: Anyone interested in implementing this Money::Zero functionality. It would be really handy.\n. @llazzaro: Awesome, please give it a try. I'm sure other devs will help pitch in if you need help.\n. @ioquatix: Thanks for the input. At this time I think you're right. We'll leave it up to the client to decide how they'd like to work with disparate currencies.\n. @ioquatix: Thanks for the info. I'm now wrestling with making a Money::Collection inside the money gem itself, or as a new gem.\n. Have you looked at the money-rails gem?\n. Thanks for the update @hisyam!\n. This commit added support for infinite precision amounts. You'll need to set Money.infinite_precision = true to enable this feature.\n. I'd put it in an initializer file.\n. No, it'll be part of v5.1\n. @ioquatix: feel free to submit a patch. You don't want to just remove cents though, it would need to be deprecated and eventually removed after many month's of depreciation notices.\n. What version of Ruby and the money gem are you using? Using ruby 1.9.3 and money 5.0.0 I have both return 50 cents.\n. @dasil003: Sounds to me like you need special regional formatting, which is something we can't really support (there's just too many special cases depending on where you are in the world). I'd suggest you write a method that wraps a call to #format that takes into account any special formatting you have to do for local idiosyncracies.\n. @dasil003: feel free to submit to patch for vetting, but this initial request was a \"how should I do this\" which we label support. We get lot's of suggestions without patches, so our default reaction you can write a custom method to fix that or submit a patch. Sorry if this comes off harsh.\n. I believe we're missing a flag in the documentation. You must set Money.assume_from_symbol = true to get symbol parsing.\n. strike that, the README already mentions the need for the switch.\n. I'm confused why this is needed. Can this not be accomplished already using the decimal_mark and thousands_separator of #format?\n. Oh, is it because it's not always grouped into sets of 3? What are the rules?\n. okay, so after the first grouping of three, it groups twos.\n. @sankaranarayanan: Could you do a little leg work for me and find out if any other locales do this formatting. I want to ensure that indian_formatting is the appropriate description.\n. Looking at this wikipedia article would it be more apt to name it something like south_asian_number_formatting.\n. I'm thinking this should only be an option for the #format method as it's specific to a locale and affects all displayed monetary units. Is that a correct statement?\n. > 2) Yes, It should only be an option for #format, but shouldn't we allow it to be set on Currency as the currency is also specific to a locale? I mean, you speak of millions of dollars and lakhs of rupees; and interchanging the format and currency is very rare.\nIn an English Number Format area they would be referred to as a million rupees and formatted in the English variant, if we had it specified on the currency itself, it would mean in countries that use their standard formatting for all currencies would have a problem. So I'd like to leave it the #format method for now. Though if enough people chime in and tell me that's wrong, I can be swayed.\n\n3) Ideally we should also look up in I18n like what you are doing for decimal_mark. And that is lacking from this pull request. Is this what you are asking?\n\nNope, you can skip i18n for now.\nIn the end, I'd just like this pull request to add the option to #format for now.\n. @TMaYaD: right, I want that part removed by @sankaranarayanan \n. thanks for the patch @sankaranarayanan!\n. jruby-1.9mode fails on Travis because 1.6.7.2 doesn't come packaged with json, but 1.7.0 does. In my opinion users who want to use JSON not packaged with ruby can add json to their Gemfile. It's in stdlib, we shouldn't need to jump through hoops.\n. Thanks @hakanensari. Still debating if I want to do that.\n. so that change helps testing, but still requires JRuby users to add json to their own Gemfile when using money prior to 1.7.0. Should I just put something in the README about that?\n. It's been a week, and I haven't heard any objections. Forward we go!\n. We've struggled with this question throughout the lifetime of Money. Right now issue #195 proposes the creation of a Money::Zero object that would take care of this situation. But that hasn't been moving recently. Personally when I work with types like Money I try and make sure to only work with other Money objects. Therefore, I'd change your example to this:\n``` ruby\nm = Money.new(50, :CAD)\nif m > Money.new(0, m.currency)\n  puts \"it worked!\"\nend\n```\nIt's not the most ideal solution, but it's all we've really got to work with right now. If you feel strongly about this issue, I'd encourage your to work on #195 with @ioquatix. I'll give you guys all the help I can to get the proposal off the ground and working.\n. @weppos: can you respond to this one?\n. @m4n: I know it's been months and you haven't heard anything. Have you looked at the money-rails gem it should solve this for you.\n. Sorry I missed this before. We have a policy to not try an accomodate external gems like this. It leads to a lot of potential headaches; which you can see if you go back in the issues/pull-requests and see us try to support different JSON libraries. My suggestion would be to monkey-patch money if needed in your own codebase.\n. @cblock let me know if that last comment makes sense to you.\n. I think #export_rates could be written more clearly like so:\n``` ruby\ndef export_rates(format, file=nil)\n  formatter = FORMAT_MAP[format] || format\nraise Money::Bank::UnknownRateFormat unless\n    formatter.respond_to(:dump)\n@mutex.synchronize {\n    data = formatter.dump(@rates)\nFile.open(file, \"w\"){|f| f.write(data)} unless file.nil?\n\n}\ndata\nend\n```\nInstead of waiting for a formatter to be passed that doesn't respond to #dump, we proactively check that it does, controlling the exception.\n. I'd also prefer in the documentation for the method it be shown that both :json, JSON or a custom formatter can be used.\nWe'd also need test added in for formatters being passed that don't respond to #dump.\n. > Not sure if we want to keep RATE_FORMATS constant and any references to format-style argument in documentation.\nThis could just be a private method instead, something like def formatter_for(format)\n. If we give them our own error, with a better message, it will be more understandable than having to dig into the money source and see why the method #dump is needed. Sure, Ruby gives you an error message, but we should try and be more helpful to the developers than that.\nVariableExchange::FORMAT_MAP[:yaml] = Syck will give a warning. But if we changed it to use attr_accessor and it would provide the same functionality without giving unnecessary warnings.\nI think we should leave the documentation for :json for two reasons, backwards compatibility as well as it should be the most common way to dump rates for most users.\n. @semaperepelitsa: If you're interested on continuing this work, please reopen the pull request.\n. @skwp: You're right, this would be a handy (and potentially easy) feature to implement. Please do so and let us know if you need any help.\n. @jacobat & @skwp: Yes, we should assume there is the possibility that currencies could trade between each other at different rates. To handle that, I'd only create the mirror rate if one does not already exist.\n. ruby\nn = Money.new(12000)\nputs n * 0.5\n. @alup & @mikaelwikman: This looks good to me, but do you happen to have anything we could alias #cents to?\n. Actually, money handles none base 100 currency. So, fractional sounds good to me. Anyone else?\n. Excellent. Thanks @mikaelwikman. \n. Awesome work @mikaelwikman! Thanks for your work. This is something we've know needed to be done, but have been hesitant to take the plunge. I'm really glad you were able to keeps this 100% backwards compatible. Once Travis okays the patch I'll merge this in and give you commit rights to the project. Thanks again!\n. Standard workflow is to do some work, create a pull request and reach a consensus on the changes. Once you feel a consensus is reached, merge the pull request or have some else if you're more comfortable with that. Also, feel free to make little changes to documentation, etc without creating pull requests (I've made at least four already today).\nI know one of the test that is slowing things down is actually testing rounding or something over a huge swath of values. That might be overkill.\n. @xaph: Thanks for the info. Any chance you could submit a patch?\n. @xaph: Since this currently isn't part of unicode, we can't add it. But as soon as it is, please reopen this issue and we'll get it updated.\n. :+1: Ship It! :shipit:\n. You could try and run the 22000 and find all the errors that it actually fixed. However, since we converted to BigDecimal awhile ago, this should no longer be an issue. At least I hope it isn't.\nThe other option is split it out this massive run into an acceptance test and have it run with a separate rake spec:acceptance command.\n. Can you create a new issue and reference this pull-request there? I will attempt to code spelunk tomorrow or Friday. \n. @kenn & @mikaelwikman: See my comments on #216, but it appears we have squashed all internal usage of Floats.\n. @zackxu1: A new issue would fit better. That being said, we're working through a handful of issues right now. I'd suggest adding gem \"money\", :git => \"git://github.com/RubyMoney/money.git\" to your Gemfile. If that won't work, let me know and I can roll a beta that you can point to.\n. I've you vendor your gems and commit the to you repo, then it wouldn't be the latest code :smile:. But, I'll roll a beta today.\n. @zackxu1: You can now install 5.1.0.beta1 by running gem install money --pre or adding gem \"money\", \"~> 5.1.0.beta1\" to your Gemfile.\n. @mikaelwikman: back on topic. I would imagine just testing the having a 0.01 amount added to anything works.\n. @mikaelwikman: I've gone through the codebase and can't find anywhere in the code where we're still using Float internally. I say, just add the 0.01 test for completeness and we're all set.\n. @palexvs: What method are you using to create the JSON? Whatever is doing that conversion will need to be updated to enhance your JSON. I am unaware of any method we provide that would generate this.\n. I'm guessing that ActiveSupport/ActiveRecord is doing some magic via a #inspect call to automatically convert to JSON. I'd rather not dictate how anyone want's to format their JSON, so I leave this as an exercise for the consumer.\n. I welcome a patch with a reasonable proposal.\n. Looks good. Merging.\n. Thanks for the patch @clee704!\n. @itspanzi: checking it out right now\n. I like it. Wait a day or two to get others opinions, and if there's not big issues, ship it! :shipit:\n. @mikaelwikman: I'd say go ahead and rebase, merge and ship it! :shipit:\n. shell\ngit remote add upsteam git://github.com/RubyMoney/money.git\ngit fetch upsteam\ngit pull --rebase . upstream/master\ngit push\nThen let me know and I'll check the pull request and merge it.\n. @mikaelwikman did you add the remote and fetch? The message looks like you missed one of those steps.\n. That sounds right\n. Looks like it's Travis being flaky. Merging.\n. :heart:\n. @itspanzi: looks like you didn't run the specs. There are some that need to be updated. Please push another commit that fixes them. Also, please add you name to the authors and update the changelog per the contributing guidelines\n. Awesome work, thanks @itspanzi!\n. Hi @muxcmux: Please updated the CHANGELOG (and optionally add your name to AUTHORS) as detailed in the contribution guidelines. Then I'll merge and give you a commit bit.\n. Sorry @muxcmux, didn't know you updated the pull request. Merged!\n. @adiel: Could you rebase and push again, I can't automatically merge right now. Please let me know when you do.\n. thanks @adiel!\n. Yeah, it's old code that's been around a long time. That being said, #parse is meant to extract the amount from stuff like \"$100.00\" or \"100 USD\", not \"foo\". Others that have looked for similar things in the past have gone with scrubbing their own data. Perhaps something like this:\n``` ruby\ndef scrub_money_string(str, currency = Money.default_currency)\n  n = Integer(str)\n  Money.new(n, currency)\nrescue\n  return nil # or you could raise your own exception here\nend\n``\n. If you work for money long enough, you'll know that keeping values in their fractional form is much better than float. So, that is whyMoney.newaccepts the fractional unit (commonly called cents). If you want to pass in \"100.20\" and have us assume it's one hundred dollars and twenty cents instead of 100.2 cents, useMoney.from_numeric(100.20, :usd)or100.20.to_money(:usd). You can find this and much more in [our documentation](http://rubydoc.info/gems/money/5.0.0/frames).\n. Actually, that's common only for non-financial rounding. Since we're working with financial calculations, we use [Bankers Rounding](https://en.wikipedia.org/wiki/Rounding#Round_half_to_even). If you want to change your system, look atMoney.rounding_modewhich accepts any mode thatBigDecimalsupports.\n. @vanboom: no problem! :smile: \n. I'm going to assume you mean default totrueas it's alreadyfalse`. No, you cannot do this globally via the gem. But you could write a helper method\nruby\ndef no_cents(n)\n  n.format(no_cents_if_whole: true)\nend\n. @acesuares: you probably want to open a issue on money-rails then.\n. Is it implied that the \".\" in \"10.000\" is a thousands separator?\n. So the problem is in the #extract_cents method. Feel like taking a crack at it?\n. No problem. Anyone else fell free to pick this up.\n. Hey @muxcmux,\nThe problem we're trying to fix here is that when parsing a string, it should respect the given currencies rules for decimal markers and thousands separators and not try to second guess it.\n. I always have a hard time deciding what to do here.\nAnyone @RubyMoney/money-devs @RubyMoney/money-admins care to weigh in?\n. Please figure out why this is failing with ruby-1.9.2-p320 and fix. Thanks for the patch!\n. Thanks for the patch @klevo, sorry I didn't merge it sooner. You now have a commit bit on the repo.\n. @mastooo: This has been talked about a lot, but we've never come away with a good solution. If you have one, please let us know.\n. That's about the best idea I've had so far too.\n. Feel free to submit a patch to correct this.\n. Does this look right to you? https://github.com/RubyMoney/money/blob/master/config/currency_iso.json#L2302\n. Thanks @mzahir.\n. This is working fine for me with a fresh rails project. Can you link your Gemfile here so we can see if there's a conflict somewhere? It appears that you're not able to load the currencies JSON file that is part of the project. I wonder if this has something to do with RVM gemsets.\n. @quasor: I believe the problem is money needs a json gem, so if you don't have one loaded already it uses the default json builtin (or gem for 1.8.7). But if you then try and load an alternate json implementation things get wonky. So best way to fix this is load your alternate json first.\n. Thanks for the pull request @cathper. You should now have commit rights to the repo.\n. @cathper: Could you update the currency section in the README to include exponent? No need for a PR, you can edit it directly.\n. @cathper: danke\n. I don't have a problem with adding Money#to_i (which would be an alias of Money#cents). I wonder though, is there a better way? Have you looked at using our money-rails gem? Does it have the same issue?\n. @bcobb: Yes. That would be great. I want to thank you in advance for doing all the hard work of tracking this problem down and looking for a solution. It's just great!\n. @kirillian: No problem. Thanks for looping back into this. Please add documentation to the #format method describing the new :precision. Also please add a brief note to the CHANGELOG. Then we'll be all set to merge!\n. Please reopen when you've updated this PR.\n. If you rewrite/rename the method as I showed on the comment, this should be reasonably performant. You'll also need to add some tests to verify it's functionality.\n. oh, and thanks for working on this @cathper!\n. Thanks for merging @cathper!\n. Please update the changelog and add documentation to the #format method. Thanks!\n. When you do let me know and I'll merge this.\n. @dougdroper: Thanks! Look like you need to do a git pull --rebase upstream/master (or however you like) to sync yourself with master, then I'll be able to merge.\n. Thanks @dougdroper and @seddy. You now both have commit rights to the repo.\n. We have automated ways to output these correctly already. However, trying to guess which way input is meant to understood is a huge pain. You're more than welcome to try, but most users (including myself) have found it easier to just write our own input adapters depending on what weird data vendors send to us.\n. We don't want to break existing implementations, so it's probably best to add the Rate class and mix it in yourself. However, I would be more than happy to include this if you can come up with a way to mix it in with a configuration option so it doesn't break old apps.\n. @alup could you shed any light on this?\n. Hi @Exoth, @alup has fixed the problem and I've merged it into master.\n. @alup: Sure. Have I given you rights yet to cut a release?\n. @alup: You should now have the ability to cut a release. Tag the code, bump version, etc. Let me know if you need anything.\n. Thanks for the fix @alup!\n. You'd need to add a new formatting option or keep doing it as you are :smile: \n. You should now have commit rights to the repo too @groe! Thanks for your help.\n. Excellent! Thanks for your contribution.\n. @driv3r: somehow I missed this earlier, sorry. The problem with the way Ruby coerces objects is that in this example, Money.new(5) would attempt to be coerced to an Integer. It is much safer to be explicit and only add Money objects to each other.\n. Thanks for responding to this @alup. Had I gotten to it first it would have been immediately closed.\n@ollym We work on this in our free time and don't have the time to answer questions addressed to us in this manner. Next time take a look at the authors of the projects you use before writing in like this. Well over half of the contributors to this gem are not American. The original maintainers were not. We have always struggled to make this an international gem and comments like this are not taken lightly.\n. Our prior suggestions is to write a helper method like def formatted_money(money) that calls money.format(...) for you. You other option is to monkey-patch Money#to_s for your own code, but that isn't the safest way of going things. We can't change the way #to_s currently works for backwards compatibility (nor do I think we want to). I'd be willing to entertain other ideas though.\n. > Unfortunately I'm not willing to leave object oriented programming behind and go back to functional programming. There is no incentive to use the money gem if I can reprogram it in helpers (because in that case Integers would be an as-good replacement for the gem ;).\nWe could always use a presenter instead. Composition FTW. :smile: \nRegardless, I think you have a valid point on moving some code from money-rails into money to handle this rather common case. @halo will you take the lead on that?\n. @halo that looks reasonable to me, what do you think @alup?\nIt's high time Money got a proper configuration setup.\n. @ollym: We actively choose not to accept anything other than Integer in #new because Float can lose it's precision when being converted. If you must use Float, you can do: 12.0.to_money(:EUR) #=> #<Money fractional:1200 currency:EUR>\n. thanks @frankmt \n. Any chance you could write me a script (or failing test) that has this same error? It's hard to follow without knowing exactly what everything is and being able to inspect it myself.\n. Excellent! Showers work miracles!\n. Thanks!\n. thanks!\n. @geehsien this sounds great. If you create the PR I'll merge it an give you commit rights. Remember to follow the Contribution Guidelines to help me out. :smile: \n. Thanks again @geehsien! You now have commit rights! :smile: \n. Thanks!\n. @dnl: I can merge this once it's passing on rbx.\n. @dnl you should now have commit rights. Thanks!\n. please submit a pull request (see the contribution guidelines) and I'll merge right away.\n. By dividing by 12 and not 12.0 you're implying integer division which truncates instead of rounds. Use 12.0 and you'll get what you're looking for: Money.new(980) / 12.0 => #<Money fractional:82 currency:USD>\n. Thanks @radar. You now have commit access to the project.\n. @ddrscott: thanks for the patch. You now have your commit bit.\n. @Exoth: My bad for not looking into each of those. Please remove them with a PR.\n. Right, and we shouldn't maintain any currencies that were never valid.\n- shane\n  On May 21, 2013 at 1:42:32 AM, Exoth (notifications@github.com) wrote:\n  So what rule should be used? \u0441urrency.json should contain only actively used at the moment ISO currencies and currency_bc.json should contain not actively used ISO currencies?\n  \u2014\u2028Reply to this email directly or view it on GitHub.\ufffc\n. > If some one can exchange it, the Gem should be able to display it.\nI can exchange my miners chips at the company store, does that mean the Gem should display them? I think saying someone can exchange the currency somewhere is too broad a definition. We've always followed that currencies must have an ISO code to be maintained.\nThat being said, I'm fine supporting non-ISO currencies either in an optionally loaded config/currency_additional or in a separate extension gem. As someone who doesn't work with the alternative currencies, I'll give everyone a chance to voice their opinion.\nCome Friday I will act to change these one way or the other.\n. I can get down with that.\n. done with d7dfc1005719a8716dd95316405bebb3c67595e8\n. Nah, they're actually defunct and only kept for backwards compatibility. I might even remove them when 6.0 releases.\n. closing since there's been no movement on this issue.\n. Yeah, this is one where we can't break people's code, and I'm sure someone somewhere is using this and will break. It seems dirty, but we should probably add a new option.\n. That's the best I've got. We really need a more customizable Decorator for this type of thing.\n. Closing due to inactivity.\n. @bhoggard: Double checking, but isn't the Euro format of using decimal for thousands separator vs decimal mark dependent on region?\n. @RubyMoney/money-devs could anyone else over in the Euro zone review  this? I'm ready to merge unless I hear there's a problem.\n. Hey guys, how about trying what @semaperepelitsa suggested and adding an optional locale argument to help parsing?\n. I'm up for anything. @RubyMoney/money-devs give me your :+1: or :-1: on each plan.\n. The only problem I see with this approach is we'll break backwards compatibility if we suddenly treat 6.000 as 6000 and not 6.\n. That sounds reasonable. Thoughts?\n- shane\nOn Tuesday, April 23, 2013 at 6:07 PM, Daniel Sherson wrote:\n\nPerhaps there needs to be a way to force the parser to assume various things.  \n\u2014\nReply to this email directly or view it on GitHub (https://github.com/RubyMoney/money/pull/276#issuecomment-16889806).\n. I'd love to see Money v6 do something like this. \n- shane\n\nOn Tuesday, April 23, 2013 at 11:13 PM, Tim Evans wrote:\n\nIMO, this should use ISO locales like Carmen does. The MSDN link I posted covers a few corner cases and illustrates that formatting should not be composed with the currency- in fact, they seem to be orthogonal problems. That means the correct solution is to supply a currency + locale to Money when formatting. And possibly having a top level configuration parameter so this doesn't cause any backwards compatibility issues.\nAn example of how users might use this might be the following:\nMoney.locale = \"en_US\" cash_money = Money.new(50_000_00, \"USD\") cash_money.format # => $50,000.00 cash_money.format(locale: \"fr_FR\") # => 50.000,00$ Money.parse(\"$50.000,00\") # =>  Money.parse(\"$50.000,00\", \"USD\", \"fr_FR\") # =>  \n\u2014\nReply to this email directly or view it on GitHub (https://github.com/RubyMoney/money/pull/276#issuecomment-16905911).\n. Anyone willing to setup and implement something like this? Also, in 6.x we can break things. So if there are rough edges that need to be removed, speak up now.\n. Closing due to inactivity.\n. I was an intentional bug fix. Since it was a bug fix we did not increment the major version, as this wasn't a breaking change (in our view) but a minor change to patch a bug.\n. @aripollak: Just added it.\n. Thanks!\n. Thanks @cbrunsdon!\n. @SergXIIIth I think you want to open this on http://github.com/RubyMoney/money-rails\n. what ruby version?\n. @nambrot what is the correct currency for this?\n. @nambrot those unicode codes appear to be for http://codepoints.net/U+FFE2 and http://codepoints.net/U+FFAC, neither of which are the EURO symbol (which is \\U+20AC). My guess is that's your problem.\n. I'm not sure, I'm using iterm2 connecting to a ubuntu vm via vmware and vagrant and I can paste \"\u20ac\" with no issue...\n. We've talked multiple times about having a generic representation of 0 that doesn't have a currency, but every time someone proposes it, they never follow through with the work. If you're willing to write the patch, I'll review and merge.\n. Yes. It's not ideal, but we keep it around for backwards comparability. I personally avoid #parse and write my own parsing methods as needed. \n- shane\n\nOn Tuesday, June 18, 2013 at 8:24 PM, EddyKang wrote:\n\nUsing the latest version (5.1.1), I came across a bug with Money.parse where it was returning me an incorrect value. I was more expecting an error.\n[3] pry(main)> prices = \"Adv $17, DoS $19, Door $21, Mezz $27\" => \"Adv $17, DoS $19, Door $21, Mezz $27\" [4] pry(main)> Money.parse(prices) => # [5] pry(main)> Money.parse(prices).format => \"$17,192,127.00\"  \nIs this behavior expected?\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/RubyMoney/money/issues/283).\n. Agreed\n- shane\n\nOn Tuesday, June 18, 2013 at 10:19 PM, Ryan Bigg wrote:\n\nI really don't think Money.parse should be responsible for parsing strings like that. What you should be doing is splitting out the amounts and parsing them through Money.parse instead.\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/RubyMoney/money/issues/283#issuecomment-19658400).\n. I'd love to see this in a Pull Request.\u00a0\n- shane\n\nOn Thu, Jun 27, 2013 at 2:22 PM, Exoth notifications@github.com wrote:\n\nIn my application I need to output translated currency names. So I extended the Currency model to return other than English names from I18n yml files by ISO code in case use_i18n is enabled, and filled the yml file by the parsed data from Wikipedia.\nSo I think that it would be great if this functionality is in the Money gem itself. Like we can extract currency names from the currency.json file and put them in en.yml and then fill some other locales.\nDo you think it's going to be helpful? If so, I'll make a pull request for this functionality. Otherwise, I'll put it in a separate gem, which is going to extend the Currency model.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/287\n. Quite honestly, Money.parse just isn't that good. You could try and tweak it with a PR, but most user roll their own parsing.\n. Money#new takes an amount of cents. #to_money assumes you're passing a dollar/cents value.\n. @NARKOZ could you write a patch to check for nil symbols? If not, I can probably get to it this weekend.\n. thanks @bjones \n. Money.parse is not a reliable method for figuring out currencies. It's much better to roll your own parse method. We're toying with the idea of depreciating and then removing the .parse method.\n. @jan it's also the source of 95% of all bugs and support requests in money. It only works randomly at best. It's much easier to write your own parsing method, knowing exactly what kind of input you're dealing with.\n\nAs much as I don't like removing features, this had to be done to protect everyone from potentially unseen miscalculations.\n. Hi @gustavolobo. Looks like you're not correctly composing your money object. Here's our old documentation for doing it that way in the 2.3 days.\nruby\ncomposed_of :price,\n  :class_name => \"Money\",\n  :mapping => [%w(cents cents), %w(currency currency_as_string)],\n  :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) }\nIn 3.0.3+ it's expected you compose your money object as seen here: https://github.com/RubyMoney/money/wiki/Ruby-on-Rails-%28Money.gem-3.0.3-and-later%29\nThat being said, the true way to work with money and rails together is to use the money-rails gem.\n. I try to avoid mentioning .new_with_amount in the README because I'd much prefer users to use .new which is a much more safe and understandable way to create the money object. That being said, if the API docs aren't clear enough yet, please submit a pull request that updates the docs here.\n. Since it's not a commonly used feature it's only in the API docs. We link to those right near the top of the readme. Outside of putting that documentation in the readme, could we have done anything else to direct you to the API docs?\n- shane\nOn Tue, Jul 30, 2013 at 11:03 AM, S\u00e9bastien Grosjean\nnotifications@github.com wrote:\n\nThanks for the quick reply. My biggest issue was actually due to a bug in money-rails: https://github.com/RubyMoney/money-rails/pull/120\nI think a note in the ReadMe would have saved me 1-2 hours but it's only my 2 cents feedback ;-) Once looking into the API doc, it's clear what new_with_amount does so do not think it need any change on this side.\nThanks again for the quick reply.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/295#issuecomment-21796744\n. thanks @bjones \n. If you could just do me one quick favor and edit the CHANGELOG for fix I'll merge this right in. Thanks!\n. Thanks @asellitt and @orien!\n. Thanks!\n. I agree with @marcoow that his solution would be preferred. This should be an extension most definitely. I'd have not problem rolling it under the RubyMoney org though to make sure it gets love from the community.\n. @yinquanteo yeah.\n. Thanks for the patch @alex-ross. And thanks to @asellitt and @mdi for chiming in and merging!\n. @rmustafin thanks! If you would like it transferred underneath the RubyMoney org too, let us know.\n. :-1: Money has always been immutable by design. I'm not too keen on breaking that to avoid writing x =.\n\nThat being said, if there's a strong desire in the community to break that tradition please speak up.\n. This was probably acceptable duplication for the sake of clarity. We try not to condense if/else/end just to try and trick Code Climate. Usually, when you want to remove duplication from Code Climate, you should be extracting methods, not changing structure. What to try again?\n. Hey Tien. I think you're right this still needs to be refactored. I have an idea and will toss it up here tomorrow when I have my laptop to discuss with you.\u00a0\n- shane\nOn Sat, Aug 17, 2013 at 9:28 AM, Tien Nguyen notifications@github.com\nwrote:\n\nTotally agreed with you that refactoring is not just for tricking Code Climate. I mentioned codeclimate is just an example. Isn't the new structure clear, I personally prefer *short ? cc/ @semmons99\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/304#issuecomment-22811855\n. @viettienn I'm going to take the discussion over on @ohthatjames PR\n. This makes sense, but the prior if/else/end was much easier to read. Please change that back from the enormus ... unless ....\n. Thanks. Just need to do a couple things per the contribution guidelines.\n- Add yourself to the AUTHORS file\n- Update the CHANGELOG\n. merged!\n. @ohthatjames @viettienn :point_up:\n. That's up to you. It's a little easier to develop on RubyMoney/money than a fork.\u00a0\n\n- shane\nOn Wed, Aug 21, 2013 at 11:17 PM, Tien Nguyen notifications@github.com\nwrote:\n\n+1 for creating a new PR for these refactoring. BTW, in the future should I create new branch in my forked repo or I can create new branch from RubyMoney/money ? @semmons99\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/306#issuecomment-23065997\n. That is how infinite precision should be working. Could you write a failing test so we can track it down?\n. @JoeStanton did this fix your situation?\n. awesome :+1:\n. as_d is just shorthand for us the create a big decimal, it shouldn't be a public interface.\n. My biggest worry here is backwards compatibility. What happens to users expecting floats?\n. I'd welcome a patch that included post install messaging and an update to the readme.\u00a0\n\n```\nI'll blog about it too\n\nshane\n```\n\nOn Mon, Sep 2, 2013 at 3:01 PM, Orien Madgwick notifications@github.com\nwrote:\n\nThat's a valid concern @semmons99. This changes the post conditions of the methods in question and shouldn't be taken lightly. The money gem is used by vast community and this change may cause some applications to behave unexpectedly. Given this, we have a duty of care to provide, so we should take every opportunity to warn clients of this change. Potential methods to achieve this are:\n- a migration guide on the site and/or readme document\n- a post deploy message\n  This is a lot of effort to go through but I believe it will be worth it. This change has the possibility to fix subtle defects in existing client applications. While for new applications using the Money gem, it promotes the more healthy behaviour of using BigDecimals for monetary values. Thus, avoiding a whole class of errors and the associated pain for developers. Developing in Ruby will be even more awesome!\n\nReply to this email directly or view it on GitHub:\n  https://github.com/RubyMoney/money/pull/311#issuecomment-23674557\n. We should probably put a fancy red alert message at the top to check out the migration notes too. Other than that, it looks great.\n. Looks good. Merging.\n. @orien I've released 6.0.0.pre3 this morning. Please help me to remember to release 6.0.0 proper next week.\n. Thanks!\n. @lucasrenan sorry, but .parse is scheduled for removal just for reasons like this. We won't be patching it.\n\nI personally have stopped using .parse a couple years ago due to all the potential edge cases.\n. excellent!\n. Good catch, thanks. Could you please check that you've done everything listed here: https://github.com/RubyMoney/money/blob/master/CONTRIBUTING.md\nOnce you have, I'll merge the PR.\n. merged!\n. You'll need to document the new option in the method documentation. You'll also need to rebase on master since I merged your other commit.\n. Good point. Perhaps we should allow user to format their own objects if they want rounded infinite precision.\n. @fklingler let me know when you have the error fixed\n. Thanks!\n. You're welcome to patch that. In all our years, we've never had anyone try to create a money object for another money object :smile: \n. @keithpitt right. If you pass a value that's already a Money object, it should just return that same object.\n. Yeah, for now it can be a copy.\u00a0\n- shane\nOn Thu, Sep 19, 2013 at 9:44 AM, Brian Jones notifications@github.com\nwrote:\n\nNot sure about same object, shouldn't it behave as a copy constructor if\nyou do this?\nOn Wed, Sep 18, 2013 at 8:32 PM, Shane Emmons notifications@github.comwrote:\n\n@keithpitt https://github.com/keithpitt right. If you pass a value\nthat's already a Money object, it should just return that same object.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/issues/318#issuecomment-24710006\n.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/318#issuecomment-24739388\n. Please follow the contribution guidelines. Then I can merge.\n\n\nhttps://github.com/RubyMoney/money/blob/master/CONTRIBUTING.md\n. I'd welcome a patch. If you don't have an exchange rate defined, it will error right now.\n. Please update the CHANGELOG too.\n. Feel free to patch.\u00a0\n- shane\nOn Wed, Sep 25, 2013 at 5:56 AM, Andreas Neuhaus notifications@github.com\nwrote:\n\nAccordingly to https://en.bitcoin.it/wiki/Satoshi and http://en.wikipedia.org/wiki/Bitcoin, 1 BTC equals 100_000_000 Satoshi, but RubyMoney currently uses 10_000_000 for subunit_to_unit.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/322\n. Thanks @ticean \n. Ruby's builtin coercion is changing the right hand side to a money object, and #to_money is depreciated.\n\nAny chance you could work on creating a better error for this?\n. Awesome! You rock! :metal: \n. @joshhepworth could you check contributing and make sure you've covered all your bases?\n. just pushed 6.0.0.pre5 with your commit\n. very cool. merged!\n. @asok your build failed because you used 1.9 hash syntax, but we still support 1.8.7. Please use the good old hashrocket syntax. Also, when you do patch the change, please make sure you still end up with a single commit :smile: \n. @asok still failing on 1.8.7. You may want to make RATE_FORMATS a proper object.\n. @asok not a fan of Monkey Patching Hash just so we can avoid an if statement.\n. and so it shall be. I still consider you a contributor though :smile: \n. @jegz there is not. There are some defaults you can set, but not all. A number of users have created a proxy method that they always call that has their formatting defaults.\nI'd definitely entertain a patch that setup a way to do default formatting.\n. Sorry, we now only support arithmetic between money objects. $100 + 0 monkeys is undefined.\n. @chatgris minor suggestion. Also, please check out the contribution guidelines in the root of the repo.\nCurious, what kind of objects are you creating that inherit from Money?\n. Interesting. I would have used composition for that work, but inheritance does the job too.\n. @Silex have you tried any of the 6.0.0 pre releases?\n. We're close (as in later today or tomorrow) or releasing 6.0.0\n. Is there something I'm missing in this Gem? I'm pretty sure you just need to upgrade to google_currency 3.0.0\n. Forking google_currency and trying to give it a lower version of money is probably your only option since money does not support 1.8.7 any longer.\n. @zubin I take that back. I'm about to release money 6.0.0 which support 1.8.7. I'll then release 3.1.0 which will support money 6.0.0 and you should be all set.\n. @zubin money 6.0.0 is now released along with google_currency 3.1.0\nPlease create a new issue if you have any problems with either.\n. Thanks!\n- shane\nOn Thu, Nov 7, 2013 at 4:46 PM, Orien Madgwick notifications@github.com\nwrote:\n\nCongratulations on the releases @semmons99!\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/332#issuecomment-28009660\n. Great catch, could you submit a patch?\n. Instead of a global variable, I'd set a class instance variable on Money. Then we don't need to be moving the file around.\n. Please reopen when you've addressed the issue(s).\n. This may be specific to Spain, but most likely not all Spanish speaking countries.\u00a0\n- shane\n\nOn Mon, Nov 11, 2013 at 2:24 AM, Exoth notifications@github.com wrote:\n\nMy site was sent to a translator for check, and he says, that in Spanish instead of \u20ac534 we should write 534 \u20ac\nSo I guess that this is a global rule for the Spanish language that the currency sign should go after the number delimited with a space. As I see, there's a custom Japanese rule defined in localize_formatting_rules, so the Spanish rule could be defined there in the same way. Can anyone Spanish speaking confirm that this rule is right and global?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/336\n. I'll play with this later today. I still don't find it ideal. It's a good start though and a valid issue.\n. Sorry, this fell off of my radar. I will pick it up in the morning.\n. I haven't found anything I'm happy with quite yet. I will try again this week though.\n. @brianphillips fixed in master\n. pretty much your exact patch. Thanks for the initial work\n. sorry it took so long\n. try gem \"money\", :github => \"RubyMoney/money\"\n\nalso, please post the actual deprecation you're getting.\n. Hi @jescalante. Try the latest master. I believe I've fixed your issue. If not, please reopen.\n. You are right, I hadn't pushed it yet.\n. gem \"money\", :github => \"RubyMoney/money\" should do the trick\n. :clap: horray! :clap: Thanks for reporting the issue.\n. @imton any chance you could give us an example where you're getting this with the money library?\n. @imton okay, this looks like you actually have an issue with RubyMoney/money-rails, not the money gem. You should open an issue there.\n. Okay. I finally understand what you're asking. Just use .to_f\nBTC is unique for having the giant subunit. Other currencies always display the full subunit so as to not be ambiguous. \n. You shouldn't if you're not doing any calculations after the fact. But I just remembered we now report the BigDecimal value back to you when you call #dollars.\nSo, how about this?\nruby\nn = Money.new(100, \"BTC\") #=> #<Money fractional:100 currency:BTC>\nn.format #=> \"B\u20e60.00000100\"\nn.dollars.to_s(\"F\") #=> \"0.000001\"\n. Feel free to submit a patch that adds the option to #format. Provided it doesn't harm any other methods or options I have no objection.\n. It shouldn't be too bad.\n. Sorry @shawndeprey we actually recently pulled this type of parsing out. It was unwieldy and always ended up being specific to a single developers codebase than generally useful.\n. Please make that one tweak then read CONTRIBUTING.md and make sure everything is square there.\n. @jlecour awesome work. Please tweak this to work for Ruby 1.8.7 (see TravisCI failure) and make sure you've done everything on the Contributing Guidelines.\nOnce that's taken care of, I'll happily merge.\n. Please reread the notes section of the contributing guidelines.\n. @jlecour no worries. Thanks for the patch! :smile: \n. I have no problem if someone wants to take this on and submit a patch.\n. Closing, please reopen if you're actively working on this.\n. @ohthatjames do you have more suggestions?\n. @hadees reopened\n. I believe you're looking for @yard, @yardparam and @yardreturn http://rubydoc.info/gems/yard/file/docs/Tags.md#yield\n. looks good\n. @ohthatjames it would be nice to have the nested blocks issue fixed, but I don't think it's something that's high priority.\n. You're converting between money's internal BigDecimal and Floats, this will not yield the same results.\n. Ah, sorry. I didn't understand your question. If you look at the implementation of VariableExchangeBank it contains it's own rounding method. You can either specify one, or write another bank. VariableExchangeBank is really just a sample. Most users don't use it in production and instead use more robust banks.\nI'd gladly take patches to fix anything you see wrong with it.\n. > Alternatively, should I be instantiating another Money object every time I want to use the comparison operators?\nYes. String#to_money will be removed, unlike the other deprecation warnings which warn that you'll just have to require the extensions manually.\n. @Robsteranium ah, now I think I understand what you're saying. In money 6.1, this will be broken unless core extensions are required, or in the case of String.to_money won't work at all. What suggestions do you have?\n. We have a branch labelled 6.1.0 that removes all the warnings. I'll be releasing the first beta on Monday.\n. /cc @RubyMoney/money-devs \n. @RubyMoney just an FYI to everyone. I've released the monetize gem and patched the money gem to use it. In the 6.1.x series, we will have removed all the parsing code from money into monetize.\n. @lassebunk mind submitting a patch for that?\n. Could you check why the build is failing for 1.8.7 too please?\n. don't worry about 1.8.7, I've stopped testing on it.\n. Thanks for the patch!\n. @saurabhnanda what if we update all the methods that use a mutex to taken an optional parameter, :without_mutex? Then, when another higher-level function needs to wrap a number of these calls in a mutex, it can do so.\n. here's my proposed change: https://github.com/RubyMoney/money/pull/351\n. perhaps we only need a mutex around the updating of rates?\n. I don't know if ruby has these capabilities.\u00a0- shane\nOn Wed, Jan 8, 2014 at 1:11 AM, Saurabh Nanda notifications@github.com\nwrote:\n\nBut how can we implement the following: all reads are non-blocking, except when some thread is updating the rates. This might mean using some underlying MVCC features, which Ruby doesn't provide out of the box. IIRC this is exactly how Postgres handles concurrency without unnecessarily blocking.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/350#issuecomment-31808310\n. closing since nothing has been done in 1 month.\n. That's excellent. Please let us know if you'd like it hosted under the RubyMoney org (you'd still be the owner, etc). Also, feel free to submit a PR to the README.md to add it.\n. So, we can easily make the mutex public. But, is there something would could add to the API to make thread-safety less of a developer chore?\n. /cc @RubyMoney/money-devs \n. I'm wondering if Ruby has the concurrency mechanisms we're looking for. Do banks require us to pull in another dependency to get better threading support?\n. would someone like to implement this idea as a pull request?\n. I'm going to merge this to get us some more primitives, but please, let's continue exploring this topic.\n. Yes.\u00a0- shane\n\nOn Mon, Jan 6, 2014 at 1:35 AM, Saurabh Nanda notifications@github.com\nwrote:\n\nIs this the final API, then? Can I submit a PR for eu_central_bank based on this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/351#issuecomment-31630119\n. I just released 6.0.1.beta3 that contains this change.\n. discussing in #350 \n. Are you using GitHub master, or at least 6.0.1.beta3?\n. please try a beta\n. Have you tried the 6.1.0 beta at all?- shane\n\nOn Fri, Jan 31, 2014 at 12:11 PM, Chris notifications@github.com wrote:\n\nI think the issue is that requires money requires monetize/core_extensions before requiring the money/core_extensions/... which overwrite the monetize definitions.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/354#issuecomment-33821552\n. FYI, 6.1.0 is on master now.\n. There's quite a few deprecations that use monetize. Could you update them all?\n. We added the silencer option because people were complaining about the noise. Perhaps though, the silencer should be set in the monetize gem? Regardless, this currently can't be merged due to conflicts.\n. Excellent. :+1:\n. @ct-clearhaus looks like you have some failing specs.\n. #363 has been merged.\n. I've also merged 6.1.0 into master which may help clear everything up\n. Yes. I like this approach. \n. Passing a string is not a supported argument to new. It was deprecated in 6.0.x series. \n. Sorry, I misread the example. Sounds like a bug in format. Can you dig in and fix it?\n. Thanks @Zemanux \n. It probably doesn't hurt to set it to false.\u00a0- shane\n\nOn Thu, Feb 6, 2014 at 3:37 AM, Hakan Ensari notifications@github.com\nwrote:\n\nOne of my gems has a dependency on Money. Its tests have been emitting an I18n deprecation notice for a while. I have not looked into this in depth, but I know that setting the attribute to true, which apparently will be the default at some unspecified point in the future, results in the tests failing.\n[deprecated] I18n.enforce_available_locales will default to true in the future. If you really want to skip validation of your locale you can set I18n.enforce_available_locales = false to avoid this message.\nAny pointers on how to resolve this? Does this mean some work is required in the Money gem (hence, me posting here)?\nPS: Kudos on slimming the gem (format, etc.). You guys were so against such changes last year.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/366\n. Sounds like a gem pating problem to me, not something related to the gem. What OS, version of Ruby and Ruby version manager (if any) are you using?\n. I just successfully was able to install money and require it on a fresh Ruby 2.1 install w/ Ubuntu.\n. @cyzanfar unfortunately, this is an RVM issue and not something we can help you with. My suggestion, ditch RVM and try using ruby-install with chruby, or just using ruby-install and running a single version of Ruby. Sorry we can't help more.\n. Thanks!\n. You are correct. Could you please submit a pull request fixing this?\n. Thanks!\n. Thanks!\n. feel free to patch :smile: \n. Sounds like you've probably uncovered a MRI bug. Do you have a test we can run that always produces this?\n. @jgwmaxwell ping\n. closed due to no activity\n. thanks!\n. Send a PR and I'll merge\n. @tenoriocesar could you squash this into a single commit?\n. How would you compare without converting the currencies?\n. @clowder please let me know when this can be merged. Right now it has conflicts.\n. still can't merge automatically. Try rebasing against master. Also, please squash into a single commit.\n. :+1: \n. :+1: \n. Should be fixed now with 6.1.1.\n\nYou have a beta run for 2 months and no one finds the problem. Yes, you now must manually require Monetize.\n. In 6.0.0 we deprecated using Monetize directly in Money, stating that you must \"require 'monetize'\" in 6.1.x. I believe this is proper versioning.\n. That'd be awesome. Let us know how we can help. Is it simply adding a link in the README, or is there some integration points you need?\n. I'd like to avoid adding extra dependencies into Money (we've been aggressively removing even our own). However, I have no problem adding the API for you to hook into Money#format if maguire is required. Would you be willing to write that integration?\n. any progress?\n. closing, no progress in the last month.\n. Perhaps you could write a failing spec to show this?\n. Sorry, I meant submit a PR with a new failing test, not modifying an existing one. Any chance you could work on a fix?\n. closing as there's been no movement in 10 days\n. We already have Money.zero (an alias for Money.empty) if you want to create a money 0 value money object. It takes an optional currency too.\nhttp://rubydoc.info/gems/money/Money#empty-class_method\n. Nope. We'd expect you to extract the appropriate values from the hash and create a new Money object using our existing instantiation methods.\n. @optimator999 the money gem, by default, uses a round method known as banker's rounding (or round half even). Sounds like you're looking for a different rounding method. You can change it using the rounding_mode option. Check out the docs: http://rubydoc.info/gems/money/Money.rounding_mode\n. What about losing precision, should this first be rounded using the rounding_mode specified by the object? I'd expect the code to use that instead of to_d\n. Okay. Then instead of .to_i I'd create a whole_unit method that just returns the unit, dropping any subunits.\u00a0- shane\nOn Thu, Apr 24, 2014 at 5:33 PM, Pedro Nascimento\nnotifications@github.com wrote:\n\nShouldn't to_i ignore rounding? BigDecimal#to_i doesn't look like it uses the rounding mode when converting it to Integer.\nMy understanding is that I want the \"non-cents\" part. If I wanted to round it first, I'd to Money.new(100).round.to_i.\nI could add this to the documentation if you think it can be misleading.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/388#issuecomment-41335351\n. I really hate the #to_f method (even though I originally came to the project by implementing it). It let's you do bad things. That being said, if there's enough outcry for #to_i to be implemented, I'll allow it.\n. Alright, let's merge it!\n. I merged it, but would you mind adding information about it to the changelog?\n. Good catch. Could you try patching it?\n. Okay. So, if you're using i18n, the thought is you want everything output according to your definitions, not our guesses. Seems a fair default to me. Do you disagree, if so, is it worth breaking 1000's of apps to change?\n. Thanks for your thought behind this. It helps the project a lot to have people thinking about stuff like this.\n. :+1: \n. :metal: \n. If you check out the documentation for Money.new, it takes two optional arguments:\n\nruby\ndef initialize(obj, currency = Money.default_currency, bank = Money.default_bank)\nSo, you could pass an alternate bank which can be used by that instance of a Money object, while leaving the default bank for other instances. Make sense?\n. No problem!\n. You'll actually want to move this up into a # Master section as 6.1.0 (and 6.1.1) have already been released.\nIt would be really awesome if you could go back and figure out what was released in 6.1.1 and anything that's been committed since then.\n. awesome. Thank you!\n. :+1: \n. thanks @brixen \n. excellent. Thank you. If you could squash the commits I'll merge.\n. Awesome. Thank you!\n. @paulodiniz if you could please squash this into a single commit I'll merge it!\n. Those names are currency names. The problem is there isn't just one country associated with a given currency. You need to create a one-to-many relation with your code that maps currencies to countries.\nThis is out of the scope of the Gem, though we could fold anything you make into the RubyMoney project to be maintained, etc.\n. Yes. If you can make it more robust I have no problem including it.\u00a0- shane\nOn Wed, May 28, 2014 at 5:17 PM, Cyle Hunter notifications@github.com\nwrote:\n\nHmm, well I made a fork with an updated JSON file that includes an additional field containing the main ISO 3166 Code associated for any given currency. I now see what you mean now with some countries using more than one currency - this wiki article nicely summarizes this. I don't think it would be difficult to extend what I have currently to accommodate this. For me, what I have is sufficient for my needs, but I don't mind putting in some extra work in to make something a little more robust if you think it adds value to your project.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/399#issuecomment-44465717\n. Not sure what your use case for invalidating all the settings are (all exchanges will break or produce invalid results); but why not use map?\n\nruby\nMoney::Currency.table = Money::Currency.table\n  .map { |code, currency| [code, currency.merge({:subunit_to_unit => 10000})] }\n  .to_h\n. Why not use the infinite precision option that money provides instead of changing the ratio of cents to dollars?\n. Currencies should be static. They shouldn't be changing while your app is running.\n. I guess I'm still just confused on what currency changes so often to not warrant a new release. Exchange rates make sense, but the underlying format of a currency?\n. wow, can't believe it took that long to catch this. Thanks!\n. thanks!\n. @fotos I'm not going to be able to get on this quickly. Could you even start a PR with your failing tests so we can move ahead from there?\n. I'm more of the opinion it's an error and you should convert before performing operations.\u00a0- shane\nOn Wed, Jun 18, 2014 at 8:26 PM, Pedro Nascimento\nnotifications@github.com wrote:\n\nI'd take a grip on this, but IMHO working with numbers and money objects is weird if you don't convert it. I would always expect 4 / Money.new(400) to return 1 but I believe we expect 0.01.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/404#issuecomment-46511161\n. What's everyone think of this solution: https://github.com/RubyMoney/money/pull/405\n\n@fotos does it pass all your specs?\n. What's everyone think about the additional specs added to #405, are we missing any? What about the addition of #<=> raising a TypeError?\n. /cc @RubyMoney/money-devs \n. bueller, anyone?\n. closing, no activity in 2+ months.\n. @calebthompson @lunks made some description changes, thoughts?\n. @fotos 2 * Money.new(2, 'USD') is allowed by this patch. Division is not commutative, 2/5 != 5/2.\nI'm going to take @ct-clearhaus and make sure our operations all pass those tests.\n. Yes, please. Let's start seeing some code and their resulting specs.\n. anyone?\n. Just call Money.new(1000).cents\n. Sorry, I misunderstood the initial issue. If you want to create a money object via whole units and not subunits, require the monetize library and do 1000.to_money\nshell\nirb(main):004:0> 1000.to_money(:INR)\n=> #<Money fractional:100000 currency:INR>\n. Why are you passing the decimal mark when it works by default?\nshell\nirb(main):001:0> require \"money\"\n=> true\nirb(main):002:0> Money.euro(12345678).format\n=> \"\u20ac123.456,78\"\n. Ah, so you format the currency based on the currencies signature and not the locale. Could you verify this isn't fixed in master? I feel like this has been addressed recently for some reason.\n. Could you submit a patch?\n. closing due to inactivity\n. Agreed. I think you're trying to twist the meaning of attributes which could lead to some gnarly code.\u00a0- shane\nOn Fri, Jul 18, 2014 at 9:05 AM, RKushnir notifications@github.com\nwrote:\n\nIt seems to me, you're mixing different concerns. You use currency: INR to identify that it belongs to India, as well as an indicator of the currency. There's a commercial exchange rate for USD to INR, but you also have some ratio that plays the role of exchange rate, and also acts as a discount value. \nWhy don't you just store all prices in single currency(e.g. USD) and have a country_id column and a discount column(which is default to 0)?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/409#issuecomment-49428135\n. It's not a bad idea. I'd expect it to be done inside the Money initializer. I have no problem protecting users, though they should sanitize their data :smile: \n. thanks!\n. So, someone is editing the internals of a money object? Would this affect any value if you're abusing the code in such a way? Should not every Money instance be frozen to avoid bad actors then?\n\nI'm not really against this, I'm more just wtf?! is someone doing to make this necessary?\n. I'd be okay with doing a >= 0.6.4 <= 0.7.whatever_it_is_now\n. feel free to submit a pr\n. This change is breaking tests. Please fix.\n. Please rebase against master and see if it's still failing\n. closed, no activity in over 10 days\n. CI is failing\n. Just fixed on master, can you rebase and verify it works?\n. please provide a log of an IRB session. I cannot follow this description right now.\n. closed, no activity in over 10 days\n. Feel free to submit a PR to fix this along with a reference article. Don't forget to follow the contribution guides when you submit the PR.\n. Please read the Contribution Guidelines, rebase and ping me. I'll merge.\n. perfecto!\n. sure thing!\n. closing, no activity in 2+ weeks\n. After two weeks I close any issue that hasn't been followed up on by the requester. I believe this one was completed in another PR though.\n. if someone would go through and replace should with expect I'd give them an internet hug or 5 shrute bucks\n. :metal:\n. If you look at the code, yen is in the legacy section. It's invalid but we had to leave it for apps who were/are using it.\u00a0- shane\nOn Fri, Aug 22, 2014 at 12:14 AM, ahpri notifications@github.com wrote:\n\nI'm confused on why there exist two currencies to represent Japanese Yen when there should be only one. They are :yen and :jpy when it really should be just :jpy.\n     class Price < ActiveRecord::Base\n        def self.all_currencies(hash)\n          hash.keys\n        end\n     end\nrails console --s  \nPrice.all_currencies(Money::Currency.table)\n=> [:aed, :afn, :all,................:jpy,.........:yen]\nI see they print differently though:\nyen = \u00a51,000\njpy = \u00a5100,000\nIs that just how the currency is over there?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/426\n. Have you gone through the docs? Looked at the infinite precision options...\n. We can't really just change the feature, too many libraries rely on it. You should instead make it an optional toggle. FYI, you need to rebase. This can't be merged.\n. \n\nChanging this has repercussions throughout all the existing exchange libraries. Simply adding a feature toggle that allows users to use round (perhaps a specific version of it like the actual Money object does) vs dumb to_i is a much more stable approach. Then, if we have an outcry of \"make the round toggle the default, we can do that in a major release\". With 2.5 million downloads, we can't break stuff without some serious thought and community buy in.\n. I'm totally not following this. What's the usage of this?\n. This sounds like something that should be implemented in a exchange extension, much like these: https://github.com/RubyMoney/money#implementations\n. 6.2.0 released\n. Is there a reason you can't specify something other than 0.7.0.beta1 in your own Gemfile?\n. I guess I don't see how if a user sets their rounding method to be BigDecimal::ROUND_DOWN 1.85 would be wrong. Are you saying everyone ever using this gem will always want to use one type of rounding when using your feature?\n. I'd be okay with the rounding method being defined by the currency.\u00a0- shane\nOn Wed, Sep 10, 2014 at 10:17 AM, tweymuth notifications@github.com\nwrote:\n\nI just had a look at the Wikipedia article on Swedish rounding. It appears that in Argentina, prices are always rounded down. That means we indeed have to use different rounding methods for different currencies. However, I still think that for this very feature, the rounding method is coupled to the currency and therefore does not have to be set by the user. What do you think about this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/433#issuecomment-55118243\n. :+1: thanks for taking the time to work with me and get this right!\n. just released 6.3.0 for you\n. thanks!\n. please follow the contribution guidelines and I'll be happy to merge\n. > When contributing, please make sure to update the CHANGELOG and AUTHORS files when you submit your pull request. Upon merging of your first pull request, you will be given commit access to the repository.\n. You'd have to examine the source to see how it actually works. Why not covert everything in the array to the same type first?\n. My guess, max/min is doing operations in a different order. I'll investigate tonight.\u00a0- shane\n\nOn Thu, Sep 18, 2014 at 4:17 PM, Jonathan Chambers\nnotifications@github.com wrote:\n\nYeah, unfortunately #max and #min are implemented in C code. Here's #max for instance:\nc\n/*\n *  call-seq:\n *     enum.max                   -> obj\n *     enum.max { |a, b| block }  -> obj\n *     enum.max(n)                -> obj\n *     enum.max(n) {|a,b| block } -> obj\n *\n *  Returns the object in _enum_ with the maximum value. The\n *  first form assumes all objects implement <code>Comparable</code>;\n *  the second uses the block to return <em>a <=> b</em>.\n *\n *     a = %w(albatross dog horse)\n *     a.max                                   #=> \"horse\"\n *     a.max { |a, b| a.length <=> b.length }  #=> \"albatross\"\n *\n *  If the +n+ argument is given, maximum +n+ elements are returned\n *  as an array.\n *\n *     a = %w[albatross dog horse]\n *     a.max(2)                                  #=> [\"dog\", \"horse\"]\n *     a.max(2) {|a, b| a.length <=> b.length }  #=> [\"horse\", \"albatross\"]\n */\nstatic VALUE\nenum_max(int argc, VALUE *argv, VALUE obj)\n{\n    NODE *memo = NEW_MEMO(Qundef, 0, 0);\n    VALUE result;\n    VALUE num;\n    rb_scan_args(argc, argv, \"01\", &num);\n    if (!NIL_P(num))\n       return nmin_run(obj, num, 0, 1);\n    if (rb_block_given_p()) {\n  rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)memo);\n    }\n    else {\n  rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)memo);\n    }\n    result = memo->u1.value;\n    if (result == Qundef) return Qnil;\n    return result;\n}\nfrom: https://github.com/ruby/ruby/blob/9b94249f39bff401465340639bed1f2a93b62ebf/enum.c\nI'm not familiar enough with Ruby's C code to really grasp what's going wrong. I do know this code is ultimately calling Money#<=> though, and that this method is working as expected.\nI agree it's no biggy, just to ensure the array is all Money objects before hand (that's how I'm working around it), it's just that this really caught me off guard because all the other comparison methods (>, ==, etc.) work fine with a mixture of Money objects and plain numbers. \nThe fact that #max and #min don't work as expected, definitely breaks the \"rule of least surprise\", which probably isn't a good thing when working with financial transactions!\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/436#issuecomment-56095842\n. I just checked Money.new(100) <=> 0 == 1 and 0 <=> Money.new(100) == 1 which makes it obvious that min/max runs the second version, and also that we need to get consensus on https://github.com/RubyMoney/money/pull/405\n. I'd be cool with a disambiguate option on format.\n. Seems like adding another column to the currency is the more flexible solution.\n. Please follow the guidelines in CONTRIUTING.md and squash into a single commit. Then I'll merge.\n. thanks!\n. The answer you're getting is correct. You're starting with $0.01USD and converting that using 0.01 * 10600 = 106 which is exactly what you're getting.\n. thanks!\n. thanks!\n. thanks!\n. https://github.com/RubyMoney/money/blob/master/money.gemspec#L28\n\nFeel free to submit a patch\n. :metal: \n. :metal: \n. Yes. Please do submit a PR. I'll close this and wait for the PR.\n. #453 will be merged, adding the synonym that is clearer would also be accepted\n. np\n. The legacy version of JPY in https://github.com/RubyMoney/money/blob/master/config/currency_backwards_compatible.json supports the older 1/100 conversion rate\n. Unfortunately I don't have personal experience in this particular scenario. I\u2019ll ask around though. Please do the same and let me know any results.\nOn Wed, Oct 22, 2014 at 1:34 AM, shpupti notifications@github.com wrote:\n\nHi Gabriel and Shane,\nin answer to Gabriel's question - the Google Play API returns a price in micro-cents along with an ISO4217 currency code.\nI think the issue I've been experiencing comes from a difference between \"banking currencies\" and \"real-world currencies\", where some local currencies no longer use their subunit in day to day life they are still considered a valid value in banking and foreign exchange systems.\nFor example the following data I got from the Google Play API: \"price\"=>\"\uffe5162\", \"price_amount_micros\"=>162000000, \"currency_code\"=>\"JPY\".\nHowever, my understanding of the all-around usage of the RubyMoney project is quite limited so I'd appreciate some advice regarding the best way to handle this conflict of definitions.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/450#issuecomment-60046765\n. I believe for now we should leave as is and allow the user to load the legacy currency as their situation demands.\n. They're just available to use, nothing fancy. Look at their label and use that to access then. For example the legacy jpy is yen.\n. squash into a single commit and I'll merge this right away\n. Currently CI is failing. I'd like to see the specs remain unchanged (or just add additional) too.\n. It's how I operate. I prefer to be explicit and do my conversions to a common currency before running comparisons.\n. You've got more than meets the eye here. The money gem by itself doesn't support converting Fixnums to Money objects. Formatting is also dependent on your locale. Finally, if you believe the - should precede the symbol, find supporting documentation and submit a PR changing the value for USD here: https://github.com/RubyMoney/money/blob/master/config/currency_iso.json#L2242\n. just released 6.4.0\n. please fix your build errors and ping me when you've pushed your branch back up\n. try that, should fix you\n. @newstler we'd just merged other patches that conflicted between the time you opened the PR and I got a chance to look at it.\n. Please squash into a single commit. I'll also wait to hear from @shpupti \n. I think you've hit the nail on the head. We need a digital_sub_unit added for these discrepancies.\n. two weeks, no activity. :-(\n\nclosing...\n. Thanks!\n. I'd love to see you open a PR that updates the README.md with a proposed policy. We can then discuss it.\n. Please submit a pull request. :-)\n. :metal: thank you!\n. discussion in PR\n. Couple problems.\n1. No Tests. Can't merge a new feature without tests.\n2. This breaks how the code works. It should be optional. Look at creating some type of global param that defaults to false to allow this. We can revisit with Money 7.0.0 if it begins to default to true.\n. I don't disagree with your code, but you can't break everyone who uses this libraries code without fair warning, which means we need a global param with a false default that can be swapped in 7.0.0\n. warning, after 10 days of inactivity this PR will be closed\n. 6.5.0 released\n. Feel free to submit a patch. \n. I don't see a PR for it. Was one ever submitted?\n. This is correct. The default rounding mode indicates how this is dealt with: https://github.com/RubyMoney/money/blob/master/lib/money/bank/variable_exchange.rb#L110\nYou can specify it as you see fit via params as you see in the code above.\n. Did you try master. Isn't it fixed?\n. If not, fix it.\n. yes, please update that as well\n. then let me know when you have\n. closing, two week no activity\n. I think the best place to start is better error messages. Will you tackle this?\n. @georgemillo it's been 3 weeks. Can we close this?\n. Great point! Could you create a wiki page with a \u201croad to 7.0.0\u201d wishlist? Even if it\u2019s only this change.\nOn Tue, Feb 3, 2015 at 9:58 AM, George Millo notifications@github.com\nwrote:\n\nFixed the Currency#all problem in #491.\nFor the others, I don't think a MissingAttributeError message is the right solution. When is anyone ever going to deliberately define a currency with no subunit_to_unit, for example? (Looking in currency_iso.json, I see that there are only two \"real-world\" currencies (the Mauritanian Ouguiya and the Malagasy Ariary) that have a subunit_to_unit value that isn't either 1 or 100).\nIt makes more sense to me if we make subunit_to_unit compulsory, although this would be a breaking change and require a major version number bump. And it's not exactly a big issue, so it's probably worth waiting until we have a bunch more breaking changes that we want to push, and putting them all in the same major version upgrade.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/479#issuecomment-72664317\n. For some reason CodeClimate won't integrate with GitHub right now.\n. Do we need the subunits for historical purposes? Do the major money exchanges ignore it now? Just need to double check stuff like xi and Google Exchange first please. \n. Sounds good.\u00a0\n- shane\n\nOn Wed, Jan 21, 2015 at 4:57 PM, Jason Hooper notifications@github.com\nwrote:\n\nNot sure about money exchanges practices. Where can I check or find out more? We have users in Iceland who have complained that we are showing minor units. They do not use them as per the link. The updated ISO data at http://www.currency-iso.org/dam/downloads/table_a1.xml reflects this.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/483#issuecomment-70930059\n. According to wikipedia there are no 1\u00a2 coins being circulated by banks for CAD. The subunit_to_unit is correct that it's split to 100, but the column you're referring to is for physical coins in circulation.\n. see answer in #484 \n. Thanks!\n. remember you can always have your Gemfile point to github\n. released to Rubygems\n. :rocket: \n. Why can't you use the Monetize gem which is intended for this purpose?\n. We purposely extracted this code out of money because it can be error prone and non-obvious. Perhaps you should look at how complicated it is to parse user input for currencies outside of usd. If you don't want to include a new gem, write your own \"3 line method.\"\n\nSpeaking to the entire group of contributors to this project like this is the reason projects are abandoned and maintainers leave. We work and share our time and talents and then get complaints from someone who hasn't even bothered to understand the full breadth of the issue; only focusing on their own personal single minded use case. We are not your personal unpaid workers. Next time you contact a project make sure you understand everything. Don't write to them like they're jackasses that owe you anything.\u00a0\nLet it be known, future posts from anyone in this tone will be autoclosed with a \ud83d\udc02 \ud83d\udca9 emoji only.\n. Sorry. These projects can really take it out of you. Monetize exists for this purpose and I don\u2019t see us pulling the functionality back into Money itself. Monetize is an extraction from Money, so you wouldn\u2019t be adding anymore code then was in your project pre-6.0.0\nOn Thu, Feb 5, 2015 at 8:56 AM, seongreen notifications@github.com\nwrote:\n\nGem Money should work with minimal unit and only with integer (BigDec) (no string float and other) to avoid collision and wrong work because people use this gem in real 'money' project. \nAlso old version < '5.0.0'  has not oblivious syntax.\n'100'.to_money     => return 100$\n Money.new(100)  => return 1$\nAll extensions of native classes with \"to_money\" and other methods moved to Monetize gem.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/493#issuecomment-73049324\n. Awesome thanks. \n. :rocket: \n. unfortunately this is part of money-rails. I see you have a question that no one has answered there. Have you tried stack overflow?\n. Thanks!\n. seems like a good candidate for a toggle if you're not using the feature.\n. Sorry, I thought I had.\n. yep\n. I believe you can pass an actual symbol vs a boolean, which is why it's using double negation. I believe it's why the CI run failed too.\n. See this PR. https://github.com/RubyMoney/money/pull/435\n. fixed\n. :metal:\n. Thanks!\n. I'd love for someone to take the mantle back up. I tried to fix this and couldn't get anyone to talk to me.\n. #405 was meant to address this but got no traction. I'd love someone to take up the mantle again.\n. Just an fyi. Monetize is code directly ripped out of money and put in it's own gem as an optional subset. If you need that functionality back, just include the gem, it will be no larger than it was before, and you'll continue to receive bug fixes.\n. Please add suggested test\n- shane\n\nOn Wed, May 6, 2015 at 3:52 PM, printercu notifications@github.com\nwrote:\n\nAlso .from_amount now respects rounding_mode\nYou can view, comment on, or merge this pull request online at:\n  https://github.com/RubyMoney/money/pull/510\n-- Commit Summary --\n- Less objects allocations in .from_amount\n  -- File Changes --\n  M lib/money/money.rb (4)\n  -- Patch Links --\n  https://github.com/RubyMoney/money/pull/510.patch\n  https://github.com/RubyMoney/money/pull/510.diff\n\nReply to this email directly or view it on GitHub:\n  https://github.com/RubyMoney/money/pull/510\n. Please update changelog before merging in the future. @mikerodrigues will you submit another PR with a changelog update?\n. Please update changelog, then I'll merge.\n. Can't merge, looks like you need to rebase first.\n. Great! Thank you for the hard work and thought put behind this. I only ask a couple things, please update the changelog and authors file and ensure the readme is up to date with these changes. Then I'll merge away.\n. I think you're right. We should just always be threadsafe (the option is from early Rails 2.x days). Everything you propose looks great too. I'll probably release this as 7.0.0 just in case there's some different behavior, but let's try and avoid it where we can.\n. This is great. I'm ready to merge if you are.\n. need a rebase before I can merge\n. Thanks for fixing this up!\n. Please update the changelog including links to the two issues then I'll merge. \n. The problem appears to be financial institutions still use the centavo in\ntheir calculations.\n- shane\n\nOn Sun, May 31, 2015 at 7:46 AM, Filipe Goncalves notifications@github.com\nwrote:\n\nIn CLP there are no centavos since 1984, check the tables from ISO 4217\nCLP Minor Unit: 0\nhttp://www.currency-iso.org/dam/downloads/table_a1.xls\nCLP. Decimal Operator: 0\nhttp://en.wikipedia.org/wiki/ISO_4217\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/RubyMoney/money/pull/519#issuecomment-107161315.\n. Should the Google currency gem override it then you think? Since Google pretends it still exists?\n- shane\n\nOn Sun, May 31, 2015 at 1:02 PM, Filipe Goncalves\nnotifications@github.com wrote:\n\nProbably there are many companies that simply put all currencies with 2 decimals, but I think we should keep with backward compatibility since this gem had CLP without cents for most of the time and to follow the ISO 4217 standard.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/519#issuecomment-107223575\n. @zkarpinski could you make a PR for google_currency that monkey patches the subunit for CLP? That way we don't affect others incorrectly.\n. As long as the process runs.\n. thanks, once the pr is updated I'll merge it\n. merginated\n. thanks!\n. Waiting for all my green lights, then I'll merge.\n. Yeah. Please provide more info as we're not able to reproduce locally or on CI.\n. Can you open another ticket and ping all collabs? Also, feel free to submit a PR that just does what you think it should :smile: \n. does this still need to remain open?\n. #to_money is not part of this gem. It is part of the https://github.com/RubyMoney/monetize\n\nYou're welcome to submit a PR to that project that respects the rounding mode. However, I'd suggest not using #to_money where possible, it's a crutch.\n. status?\n. Are you running the same version as Travis?\n. PR merged\n. thanks!\n. BAM!\n. Have you checked to make sure both support IDR? Some places do not.\n. This is not a money issue, It's an issue with the other gems which I've left open. Feel free to submit patches.\n. Please submit a patch and I'll merge it.\n. thanks!\n. I believe you can us i18n\u2019s irregular inflections config to update the plural.\nOn Mon, Jul 27, 2015 at 2:58 AM, Alex Popov notifications@github.com\nwrote:\n\nI would like to submit a PR for amending two things in currency_iso.json:\n- the symbol for BGN (Bulgarian Lev) must have a dot at the end: \u043b\u0432.;\n- the plural name of the subunit is stotinki, not stotinkas\n  While I can change the first directly in the file, where can I change the latter? Should I submit a direct PR to Rails? Thank you.\n\nReply to this email directly or view it on GitHub:\n  https://github.com/RubyMoney/money/issues/543\n. So that's specific to rails, you'd need to submit a patch here for just vanilla i18n. You could also submit a patch directly to Rails.\n. nice!\n. 6.6.1 released\n. I'm good with this. Let's merge and face wrath after you've updated the changelog.\n. Please make two pull requests. I won't merge the attr_accessor change without more info. I only use private attr_accessor, no instance variables. \n. @createdbypete just need to update the CHANGELOG.md file with what this change does.\n. Thanks!\n. thanks!\n. Excellent. I'd gladly fold this into the RubyMoney org if you like or you can submit a PR to update the README with a link to it.\n. Submit a PR to add those two currencies to the Money gem. You'll need to go to your settings of the project to transfer your repo the the RubyMoney org.\n. Things have been very active lately, so probably a couple weeks. Need to have people test master for a while.\n\nOn Wed, Sep 2, 2015 at 3:49 AM, Phlegx Systems OG\nnotifications@github.com wrote:\n\n@semmons99 when will a new release made?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/557#issuecomment-136966713\n. Thanks for catching this!\n. Thanks.\n. Thanks!\n. Seems like you could either use allocate to do this, or at least use allocate to do the work.\n. Thanks!\n. Thanks!\n. Hard Ruby problems with coercion. Please make your life easier and don't mix Money with other numerics. They're not equivalent and will give you a headache.\n. I think it's due to the subunit_to_unit value for bitcoin. It would be like displaying seventy cents as 0.7 for US dollars. It's not quite right. That being said. I'd accept a PR that included a new option to format to drop trailing zeros.\n. Thanks!\n. Yes. Let's split each issue into it's own PR. I agree we could merge the .zero? change right away.\n\nI'm pretty sure there are changes to protected methods in 2.3. I don't remember reading anything about private though.\n. thanks!\n. I'm okay with this PR. Should we wait for 2.3.0 to be released fully?\n. If you have two banks, why not just do\n``` ruby\nmoney = Money.new(...)\nmoney1 = bank1.exchange_with(money, :EUR)\nmoney2 = bank2.exchange_with(money, :EUR)\n```\n. thanks!\n. so, backwards compatible, but requires a major version bump since we changed an interface. Got it.\n. Would you mind submitting another PR (you can even merge it) that updates the changelog to mention the potentially breaking change?\n. I don't see a reason to stop supporting it unless new development is being hindered. \n- shane\n\nOn Dec 16, 2015, at 7:40 PM, takiy33 notifications@github.com wrote:\nRuby 1.9.3 has not been supported since 23 Feb 2015.\nSo, I think money gem finishes to support Ruby 1.9.3.\n@semmons99 What do you think about it?\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/RubyMoney/money/pull/586\nCommit Summary\nDrop support for Ruby 1.9.3\nFile Changes\nM .travis.yml (1)\nM CHANGELOG.md (1)\nPatch Links:\nhttps://github.com/RubyMoney/money/pull/586.patch\nhttps://github.com/RubyMoney/money/pull/586.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. thanks!\n. thanks again!\n. Thanks \n. No need\n- shane\nOn Dec 24, 2015, at 11:43 AM, Yura Tolstik notifications@github.com wrote:\nif you want I can write some tests for this case, but not sure if I should\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks \n. The plan is Jan 4\n. Please do. \n- shane\nOn Jan 3, 2016, at 7:50 AM, Tom Hale notifications@github.com wrote:\nI get I18n::InvalidLocale: :en is not a valid locale when trying to:\nMoneynew(1, :usd)format\nI found that setting:\nI18nenforce_available_locales = false\nremoved the error\nShould I update the README?\nFull error output:\nirb(main):003:0> Moneynew(1,:usd)format\nI18n::InvalidLocale: :en is not a valid locale\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/i18n-070/lib/i18nrb:284:in enforce_available_locales!'\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/i18n-070/lib/i18nrb:151:intranslate'\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/money-661/lib/money/money/formattingrb:17:in block in define_i18n_method'\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/money-661/lib/money/moneyrb:362:into_s'\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/money-661/lib/money/money/formattingrb:239:in format'\n    from (irb):3\n    from /home/ravi/rbenv/versions/223/bin/irb:11:in'\nirb(main):004:0> \n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks\n. Thanks!\n. You don't want format in that case. It's meant to truncate. \n- shane\nOn Jan 6, 2016, at 8:03 AM, Tom Hale notifications@github.com wrote:\nFor currency trading, having lots of decimal places is a Good Thing\nHow do I use format to get an amount with an arbitrary number of decimal places?\nIt seems like it should be easy, but I couldn't find an example anywhere, or work it out from the code\n\u2014\nReply to this email directly or view it on GitHub.\n. Sounds like a new method or an enhancement to format. \n- shane\nOn Jan 6, 2016, at 8:05 AM, Tom Hale notifications@github.com wrote:\nAccording to wikipedia, in the EU, an amount should be printed in English as GBP 123:\nAccording however to the European Union's Publication Office,[5] in English, Irish, Latvian and Maltese texts, the ISO 4217 code is to be followed by a fixed space and the amount: a sum of EUR 30\nIs there a cleaner way to do this than:\nm = Moneynew('123', :gbp) # => #\nmformat( symbol: mcurrencyto_s + ' ') # => \"GBP 123\"\n\u2014\nReply to this email directly or view it on GitHub.\n. Why does the spec change. Seems like incorrect behavior. \n. Sounds like a JRuby issue or a float is being used somewhere it shouldn't. \n- shane\nOn Jan 16, 2016, at 12:30 PM, Laurent Arnoud notifications@github.com wrote:\nOn jruby the result is 2.9999999999999996 for this spec\n\u2014\nReply to this email directly or view it on GitHub.\n. That seems the more reasonable answer.\n- shane\nOn Jan 19, 2016, at 1:09 AM, printercu notifications@github.com wrote:\nSo should we better round exponent in #exponent method?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/RubyMoney/money/pull/601#issuecomment-172750814.\n. Looks good. Thanks for following through with this.\n. Thanks!\n. Thanks \n. worth a try\n. I've always personally be an advocate for any calculations and comparisons against a non-Money object throwing an error unless they're sensible like multiplication and division.\n- shane\nOn Jan 27, 2016, at 1:19 PM, Demian Ferreiro notifications@github.com wrote:\nHmm. I think i prefer the current behaviour of Money instances not being directly comparable with Numeric values. Although some_money > 0 seems reasonable to define, i think it's not very intuitive for Money instances to be comparable to some numeric values but not others.\nThe case when comparing with a literal 0 seems obvious, but if instead we were comparing against some other expression like make_discount if order_price >= min_order_price_to_make_discount i would like for that comparison to always raise an exception if min_order_price_to_make_discount has a bug and returns a number instead of a Money, not to silently pass because, for some reason, most of the time it returns 0.\nMoney already provides methods like zero?, nonzero?, positive? and negative?, which i think are clearer and more intuitive than asking a money instance how it compares against a bare number 0 \n\u2014\nReply to this email directly or view it on GitHub https://github.com/RubyMoney/money/issues/604#issuecomment-175780129.\n. This has always been very controversial. Please make sure you open a dialog around this.\n. We've had discussion before (and never resolution) if Money + something, regardless if it's zero or not should raise an exception. I'm okay merging #605 if everyone is happy w/ it. Just would like to get feedback. If we have no arguments, let's merge on Monday. Just ping me to remind me.\n. I like this. It makes the most sense to me. Merging. We'll probably need a major bump due to the changes, but I'm okay with that. @RubyMoney/money-devs could people give master a try? Maybe try this with money-rails too?\n. Seems to me money-rails should just provide a better validation helper then. \n- shane\nOn Jan 31, 2016, at 9:50 PM, printercu notifications@github.com wrote:\nThe only place i see where it'll be useful is\nvalidates_numericality_of :money_field, greater_than: 0, less_than: 100\nIn any other place it'll be comparison either with 0 or with magic numbers, which should better be replaced with money-object constants. And hope there will be no scenario when single non-zero numeric will be compared to multi-currency money. (do_something if money > 53 and money can be usd, cad or eur).\n\u2014\nReply to this email directly or view it on GitHub.\n. Awesome. Thank you!\n. no worries, thanks!\n. We don't want to add rails dependencies to the gem. Accounting for i18n should be done in your app.\n. This should be easier now that we've added the :delimiter and :separator options to format.\n. Allow 'nil' cents doesn't when creating a Money object doesn't make sense overall. But as cimm points out, you can use :allow_nil. Alternately you could use :constructor or :converter to manipulate the nil prior to calling to Money#new\n. Thanks for the patch. I'll take a look at it and see about incorporating it into trunk.\n. I have no problem merging this if you make one change. The Brazilian Real should always have a space between the symbol and the amount. You can see we had to patch this with the following commit 898d46265f3d0299507a4f74f39c762d51b00a96. Once that is updated, I will merge your changes into trunk.\n. I've merged your changes into trunk. I've sent a message to Hong Lai, and as long as he doesn't object, I will release a new version of the gem.\n. The updated gem has been released!\n. can you submit a patch to the documentation with you methods?\n. I'm having a hard time deciding what to do here. I don't want to put ActiveRecord specific code into the library, and I don't see the use of currency_as_string, and especially currency_as_string=, outside of this.\n\nI'm not very familiar with ActiveRecord, but is there anyway to use the :converter option in composed_of to make this work? Perhaps cents and currency should be stored in separate columns in the db?\n. Go ahead and write up the documentation and I'll merge it into trunk and release it.\n. I was thinking perhaps we should bump the major version once we get everything sorted out.\n. I merged weppos' changes into trunk and bumped the version. Take a look at the documentation and make sure we don't need anymore changes, then I'll release the gem.\n. I also created two pages on the wiki to detail information about this issue.\n. The gem has been released and the documentation has been updated.\n. #currency_as_string and #currency_as_string= have been added to Money as of version 3.0.3\n. Can you create a test case where this fails? I cannot recreate the issue.\n. did you follow the steps in the wiki for using Money 2.3.* and greater with rails? Here's a link to the wiki: http://wiki.github.com/FooBarWidget/money/ruby-on-rails-moneygem-23-an-later\nWhen we changed currency from a String to and Class there were some changes that are needed to your model.\n. The first spec will fail because there are no #cents= or #currency= methods. The second spec doesn't actually call rate = nil, it looks like composed_of (through some meta-magic) calls rate = Money.new(nil). I'd be interested to see if the error would go away if it was changed to rate = 0 in the spec.\n. I've added #currency_as_string and #currency_as_string= to Money it should make it easier to use #composed_of now, by doing the following:\ncomposed_of :price,\n  :class => 'Money',\n  :mapping => [%w(cents cents), %w(currency currency_as_string)]\nLet me know if this helps you.\n. What about this for your :constructor?\n:constructor => Proc.new { |cents, currency| cents ||= 0; currency ||= Money.default_currency; Money.new(cents, currency) }\n. also, do you need to add the following option to #composed_of?\n:allow_nil => true\n. I reopened this as a bug until we come to a good solution. I'm not keen on accepting nil for cents in the constructor, but if we cannot find another way, I may have to do it.\n. :contructor could also be written as follows:\n:constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) }\n. It's hard to say. When someone passes nil it might be an error. If we just convert it to 0, it will never be caught. I'm hard pressed to think of a constructor that accepts nil in place of a value and uses the default. Most libraries would expect you to pass a valid object (one that responds to #round) or not pass anything and accept the default. Looking at BigDecimal if you pass nil to #new you get an error in a similar vein to when you pass nil to Money#new. Essentially, we're looking for a duck (or anything that quacks) but you're passing a zebra.\n. when using the :constructor from http://github.com/FooBarWidget/money/issues#issue/5/comment/282826 I haven't received the error anymore. I'm closing this issue unless I hear differently.\n. These are both good suggestions. I'll work on them today.\n. as of a9a16d93dcab0abcc0517b88457531abef6421b4 #to_s, #to_f and #format use :subunit_to_unit\n. as of 513ca047e2c9a9459f4f2a671d6da43a827d9691 moved Separators and Delimiters to Currency\n. as of e7afe97f6fbe93de8b0444ca6244962d333c6713 the MIGHTY Chilean Peso is updated!\n. I'll work on this today.\n. Here's the spec I've created.\ncontext 'TND to USD using a rate of 0.67138' do\n  it 'returns the correct amount' do\n    @bank.add_rate('TND', 'USD', 0.67138)\n    @bank.exchange(1000, 'TND', 'USD').should == 67\n  end\nend\n. valodzka, would you be willing to write more specs to make sure everything is working as expected?\n. Doesn't work in reverse at the moment. Below is the failing spec.\ncontext 'USD to TND using a rate of 1.32862' do\n  it 'returns the correct amount' do\n    @bank.add_rate('USD', 'TND', 1.32862)\n    @bank.exchange(1000, 'USD', 'TND').should == 13286\n  end\nend\n. As of 627da58f07b60aaa5e9c3aaa2249067267871d46 both specs pass.\n. I'll work on this today.\n. in commit ddeda9e801d7d137026d1e2660cf148d913571d4 I added the following specs:\n```\ncontext 'using custom rounding methods' do\n  describe 'passing a rounding method to #new' do\n    before :each do\n      mth   = Proc.new{|ex| ex.ceil }\n      @bank = Money::VariableExchangeBank.new(&mth)\n    end\nit 'should use @rounding_method' do\n  @bank.add_rate('USD', 'EUR', 0.86)\n  @bank.exchange(10, 'USD', 'EUR').should == 9\nend\n\nend\ndescribe 'passing a rounding method to #exchange' do\n    it 'should use &block' do\n      @bank.add_rate('USD', 'EUR', 0.86)\n      @bank.exchange(10, 'USD', 'EUR').should == 8\n  mth = Proc.new{|ex| ex.ceil }\n  @bank.exchange(10, 'USD', 'EUR', &mth).should == 9\n\n  @bank.exchange(10, 'USD', 'EUR'){|ex| ex.ceil }.should == 9\nend\n\nend\nend\n``\n. commit b93de1a81577927dd373504f999a9c8150e2cc59 implements these changes. Is this what you were looking for?\n. yeah, the documentation is wrong on that. I'll fix it today too.\n. fixed in f1c4b60b7c9899e36e608774ab3a45ff0ab63ffa\n. I've never heard of this. I'll research it today.\n. failing spec added in commit 4951ac7d278ad1e1bfe1b81399928fb63cd2ad94\n. fixed in commit c4a20ad06b38ac029a2b860edc2b05b42def57b8\n. This is only used when we don't know the symbol of the currency being represented. The only way for this to happen is for the developer to insert a new entry into theMoney::Currency::TABLEconstant at runtime without :symbol specified. I'd wager this is a rare occurrence, and one a developer would realize they're doing, since warnings will be thrown for trying to update a constant. If you know of a missing currency, by all means, please fork and submit a patch. I could also fathom a patch that allows you to change the default currency symbol (just like you can change the default bank and default currency). If that is something you would find useful, please create a new issue and we'll mark it as an enhancement.\n. commit bad6f51412590854f392a307a86d917dff45776c adds support for optional currency argument in Numeric#to_money\n. commit 04fcbd29ee4c6d41a40af064575d70ec6d93b2c3 adds support for optional currency argument in String#to_money\n. failing spec added in commit 106b6b1d3262e20a851eba96d89611d9cf728668\n. fixed with commit fe5cb0302c00eff465d3d5940d5b56bb3e9f52dd\n. I'm working on a gem for the Bank of Canada and Federal Reserve exchanges rates, and can foresee the same issue coming up. What we'll need to do though, is create a backwards compatible method to do this. Perhaps a constant defined on theBankobject that if nil or false, requires cents in the exchange function, otherwise pass aMoneyobject. Thoughts?\n. I agree with you on both counts. I'll create a ticket forBank::Baseand start working on that one first. I'm also going to do one more release before we make this major change. I know of one user createdBankgem at the moment. I'll submit a patch to them when we're ready to release our updated class.\n.Bank::Baseissue create here http://github.com/FooBarWidget/money/issues#issue/14\n. I've decided I don't want to break anyone's current implementations, so I will be depreciating the#exchangemethod and adding a new#exchange_withmethod.\n. I believe I have everything implemented as of commit 2fd9b41ae19a4916c0d12e8debefd4a2c4a660c4\n. I'm closing this, feel free to create a new issue or comment on this one if you find anything wrong with the recent commits.\n. implemented in 4d688e7f2115d5e89e4c0bc9e28865d81dfb854b\n. Good idea, I like it. If you have time to implement it this weekend, feel free, otherwise I'll work on it Monday morning.\n. The only thing I'm thinking is that we need to moveget_rate,set_rateandrate_key_forintoMoney::Bank::Base. They're going to be needed quite often as helper methods in otherBankimplementations.\n. What you're saying makes sense. Let's leave them where they are in VariableExchange. \n. changes have been merged into trunk.\n. fixed in commit dfae9cfb2c066d1db3c11fe0a0990c0eae138703\n. Looks good, I've merged your changes into trunk.\n. added in 9ccc593fad1f7fa3cf635ba8eac214cdef277b69\n. added in 125302dde11a7e1bb17f02c4feed095677b26913\n. fixed with commit e211a70f63ac8cf748155c15206bf8f6e3b1f6fc\n. I will be adding these methods on Monday 08/30 and then releasing v3.1.0.pre3.\n. added in commit c471834c5acc91247679b125ddbf3826d244b62a\n. fixed with commit 5f70d6314c65ddb04262c8cf0fc362981d7f9c35\n. fixed with commit b51bd9d2e69577048c302bab6b66759c48200cd5\n. yeah, that makes more sense. fixed.\n. I think we should do three things. First addjsonas a development dependency. Second, usegemspec#requirementsto signal to the user they will need to installjsonif they want to use it to export/import rates. Finally, useautoloadinstead ofrequireforjsonandyaml. I'll make these changes today.\n. fixed in commits ba7f7c3cea69da374ebe5738594bb1f5198455a6 and a17fdb89c5b921458ff78b6c1cb552abb5d22779\n. do you havejsonor ruby 1.9? You'll have to have one to run the specs. Right now the specs run in 1.8.6, 1.8.7, 1.9.1, 1.9.2 and JRuby 1.5.2 on my machine.\n. ahh, it works for me because I haveRUBYOPTset to-rubygemsin my environment variables.\n. You should be able to use#to_fto do this already.\n. What about just enhancing#initializeto accept anyObjectand attempting to create a newMoneyobject based on theClass`? Something like the code below.\nclass Money\n  def initialize(obj,\n                 currency = Money.default_currency,\n                 bank     = Money.default_bank)\n    case obj\n    when Fixnum\n      # do what we do now\n    when String\n      # use String#to_money\n    when Numeric\n      # use Numeric#to_money\n    else\n      # raise an error\n    end\n  end\nend\n. Okay, I can agree with that. How about something like this then?\n```\nMoney#from_string\ndef self.from_string(s,\n                     currency = Money.default_currency,\n                     bank = Money.default_bank\n  #...\nend\nMoney#from_float\ndef self.from_float(n,\n                    currency = Money.default_currency,\n                    bank = Money.default_bank\n  #...\nend\n```\nThey're unambiguous, and we can easily add more methods in the future. In this case I wouldn't use String#to_money and use #to_f on the provided string, not have to jump through all the hoops String#to_money attempts.\n. I'd avoid #parse and just use #from_* that way there's a consistent way to do things when you're not passing cents to #new.\n. do you want to write these methods weppos?\n. We could add a #from_bigdecimal method as well.\n. I can implement these if you don't have time, weppos.\n. sounds good :)\n. You have to be a contributor to add labels, close issues, etc.\n. I like the ideas, but the word amount is confusing. Since we're already using cents I would suggest using the word dollars as it is more universally understandable, and corresponds well to cents.\nI'd also like to see a separate ticket (and set of patches) submitted for the core extensions cleanup.\n. Looks good, one minor thing, in the specs, can you use #new instead of .new in the descriptions?\n. Units is ambiguous, it can refer to either dollars and cents. I understands that dollars is specific to a handful of countries (approximately 36 countries use the dollar to refer to their whole unit of money), but so is cents (approximately 42 countries). I'd rather use a term that a majority of people understand and can reason about, than something more ambiguous that everyone would be forced to look at documentation for.\n. If dollars/cents is an issue, we could always add two new keys to the Currency table for :whole_units and :fractional_units and then use #method_missing so that users could call their natural language currency units (which will just call #dollars and #cents. It's not something I think is necessary, but could be added if you think it's needed.\n. If we go this direction, I would actually add :subunit and :unit to Currency::TABLE and the use #method_missing to call #dollars and #cents.\n. sounds good\n. sure, I'll do that right now.\n. fixed in commit ace4f67ce4a8af01f8c2f94fbd15fea718cd90fe\n. I'm going to try an introduce BigDecimal anywhere we're doing floating point math, since you really don't want to lose precision when dealing with money.\n. fixed with commit d0a97becfbdc0c3aa0376f5a1d715569a60c7f07\n. Yes, I prefer the describe and it style.\n. No. Just and oversite.\n. See if you can find any documentation on multiplying two dollar amounts together. I've been looking and can't find anything. I'm having a hard time making sense of when you'd multiply two dollar amounts together as well.\n. Looking around, when you multiple two numbers with the same unit the result is that unit squared. For example, 12 cm * 12 cm = 12 cm^2. Perhaps we should return a Money object, but through a warning saying something along the effects of, \"multiplying two Money objects results in Money^2 \"\n. good catch\n. update Money#parse to use :subunit_to_unit (closed by b0fd8a923c91c7c98d04d96ffef006b1b595ef70)\n. closed with commit b0fd8a923c91c7c98d04d96ffef006b1b595ef70\n. That would be great. I really like to get to a point by 3.5.0 where we don't have those types of hacks around anymore.\n. Lets back those changes out and leave them in a v3.2.0 branch for now. I'd like to release at least one more 3.1.* version before 3.2.0 to give everyone a little more time to remove their deprecated code.\n. I'm thinking a 3.1.5 bump for BigDecimal and #dollars\n. I like the idea of separate methods for handling simple strings versus complex ones. We'll probably need to think about a way of deprecating the old String#to_money so that it works more inline with Money#from_string and a new method to String that is a synonym for Money#parse.\n. so, something like a regex that detects anything other than digits, commas and periods?\n. We represent cents as an Integer so that we don't have to work with Float unless the user uses one in a calculation. It is common practice to #floor currency based transactions because in everyday use, you don't deal with fractions of a cent. If you need to keep those fractions of a cent, I suggest using #divmod which will return an Array containing the floor'd amount and the amount left over. For example:\n    Money.new(101).divmod(2) #=> [#, #]\nIf you want 50.5, call #to_f first.\n. Thanks for the patch, I've merge it into trunk.\n. Thanks for answering this weppos. Could you elaborate with an example, perhaps on the wiki?\n. Thank you very much! I didn't know if this was ever going to be done.\n. #to_money uses an older heuristic that was implemented prior to the library recognizing anything but 100 based currencies. Now that you've pointed this out, hopefully we can implement a fix for it.\n. fixed with commit f9d4383042b6129b8ed07d122274eb010e980882\n. I think we can handle this by using Math.log10(currency.subunit_to_unit) for all subunits that are multiples of 10. I'll try and write this up tomorrow morning.\n. This is fixed as of commit 5c5494edfd0e704fe6fc3639137e9f624a43e3d1\n. fixed with commit 82799a3bd8de726e655a3ea4b47127875a4c2d09\n. Can you submit your branch where cents is ensured to be an integer as a pull request? I'll merge it in as soon as you do.\n. Thanks, I've merged your patch.\n. I'm not quite sure why we'd add #decimal_mark. #separator has been functioning fine, and I'd rather keep to one definition. Also, all the whitespace changes really bother me, since I can't see what really changed in those lines. I assume it's adding #decimal_mark everywhere.\n. Okay, I agree. Separator and Delimiter are hold overs that could definitely be aliased and deprecated in a future version.\n. I did a benchmark test with your removal of using the ATTRIBUTES constant. #inspect increases the execution time of the method by 164%. I'd suggest removing that change. Better yet, by just changing it to the code below, we can decrease execution time of #inspect by 216%.\n    def inspect\n      \"<#{self.class.name} id: #{id}, priority: #{priority}, iso_code: #{iso_code}, name: #{name}, symbol: #{symbol}, subunit: #{subunit}, subunit_to_unit: #{subunit_to_unit}, separator: #{separator}, delimiter: #{delimiter}\"\n    end\n. Another good point. Of course now that it exists, it's hard to change. I'll have to come up with a deprecation strategy, just in case someone is using it.\n. I don't have time today, but I'll work on merging your patch tomorrow.\n. merged!\n. This must have to do with the Mutex on Bank. I'll look into it more next week.\n. fixed with commit 42950621dd89bac2157e54a4317c63c74b17ad87\n. wow, thanks for pointing this out. It seems we lost the commit at some point.\n. reimplemented in commit 0ed513e99b6a4b6031b4b477231d1afcc34da5ea I have no idea how it disappeared. Releases this morning in money 3.6.1.\n. Thanks for the initial code and the patch. Everything looks good and has been merged.\n. thanks, patch has been merged\n. It's due to the period after ea; it resets the heuristic. I'm thinking we could add something to the heuristic to remove / ea\\./ from any passed string. Before I do that and potentially introduce new bugs, could you do the same prior to calling Money.parse?\n. There's actually cases where multiple decimals are valid, specifically there are currencies/locales that swap the meaning of the decimal and comma. So our parser is incorrectly identifying your second decimal as an indicator that you're in one of these locales. I'm still thinking about removing / ea\\./ but I haven't thought through all of the ramifications yet.\n. I believe it's a bit of inconsistency stemming from before the library had a true Currency Class. Please, submit a patch and I'll be more than happy to merge it!\n. I think it's correct, in that you could be in the US, thus working with numbers which use , as a thousands separator and not the decimal. The only time I would treat it as you described, would be in VND was inside the string that was being parsed.\n. I'm closing this. Feel free to submit a pull request if you implement it.\n. strange, it must be an issue specific to ree, since testing on jruby 1.4.1-1.5.6, and matz 1.8.6-1.9.2 works. I'll double check the patch works with all versions we test with and apply it.\n. merged.\n. merged\n. can you try and clone the repo and install using rake install? I believe this issue is fixed with some of the recent commits that have not yet been released.\n. Great! I plan on rolling a new official release today.\n. thanks for the patch, I went ahead and merged it\n. thanks for the patch, it's been merged\n. Money#format already has :no_cents option you can set to true to omit cents, but it will not do rounding.\nAnother option would be to update :subunit_to_unit to 1 for JPY, but we should only do this if the Sen is never used.\nThe final option could be to add :always_suppress_cents => true to the Currency::TABLE, but I'm not sure this is desirable either.\nIs the Money#format option workable for you? The biggest issue I foresee, is we'll need to do some type of rounding with everything but setting :subunit_to_unit to 1, and that has it's own issues with losing precision.\n. You could probably monkey patch #format to always set :no_cents to true when working with JPY.\n. I'll keep this as an idea. I have to figure out how it would effect anyone using JPY right now that expects cents. I'd have to force them to always use :no_cents => false or create a new :show_cents on #format which is really just flipping the situation. I'll wait to get more feedback from others and go from there.\n. sorry, Money::Currency::TABLE was created as a constant and was not meant to be used outside of Money::Currency itself. To access information about a Currency object, you should be using the public methods which still include #separator and #delimiter. We'd be more than happy to accept any patches you need to make to Money::Currency::TABLE if it is incorrect, out of date, or missing something you need.\n. I'd be more than happy to add the new fields to currency for you. I'd love to have the correct name of the currency in their native languages. Correcting the symbols would be a great patch too. If you have information on older currencies, that too would be helpful. Any other information you need, that may be useful to others is more than welcome to be added.\n. Just do the ones you have. Hopefully others will find it useful and contribute to any you miss.\n. I agree with weppos. Without separate commits for each feature, and tests for those features. We can't really do much with this.\nRegarding the change of adding date to the list of arguments of #exchange_with; this should probably only be implemented by a new Bank gem. We can't expect anyone whose already created a Bank gem to accept this new parameter.\n. Perhaps changing it to def exchange_with(from, to_currency, options => {}, &block) would make more sense. Easier to expand in the future. I wouldn't feel bad doing this to everyone whose already written a Bank module.\n. If you're still planning on working on this please continue and submit another pull request when it's ready.\n. If I understand right, this \n:cny => { :priority => 100, :iso_code => \"CNY\", :name => \"Chinese Renminbi Yuan\",                     :symbol => \"\u00a5\",             :subunit => \"Jiao\",          :subunit_to_unit => 10,   :symbol_first => true, :html_entity => \"&#x5713;\", :decimal_mark => \".\", :thousands_separator => \",\"},\nshould be changed to this \n:cny => { :priority => 100, :iso_code => \"CNY\", :name => \"Chinese Renminbi Yuan\",                     :symbol => \"\u00a5\",             :subunit => \"Fen\",          :subunit_to_unit => 100,   :symbol_first => true, :html_entity => \"&#x5713;\", :decimal_mark => \".\", :thousands_separator => \",\"},\nIs that correct?\n. updated in commit 1a1cb22ebc3d017ed187774aee2c0e728e1fd5fc\n. thanks, your patch has been merged.\n. :no_cents is meant to remove cents when displaying a Money object. It is not meant to round the value before removing the cents.\n. We have nearly 61,000 downloads, so I'm not sure any uses it like this, though I'd wager a few do. I'd be willing to accept a patch that adds a new option to #format such as :round_cents which does what you wish it to. Just write the code/tests and submit a pull request.\n. - Money#neg looks good, I'll accept it. I'm also going to add an alias of #negate\n- #exchange_with and #exchange_to look good, I'll accept them.\n- adding an i18n switch would be great as would Rails key\n- I'm hesitant about the two deprecations. We don't know who is relying on them, and they're not getting in the way right now.\nI like the idea of Money#to_h and Hash#to_money, but I think it would be better if it was something like this https://gist.github.com/842113.\nFinally, how are you modifying the Currency::TABLE? Adding new keys, or changing values? If you're changing values, one commit per currency would be preferred. If you're adding new keys, then one commit per key would be preferred.\n. - I think having all the attributes returned by #to_h is a good idea so people can use whatever they need.\n- I may add your deprecation suggestions, I need to think about it more.\n- Wow, that's a lot of changes. Can you give me an overview of the changes, if they all sound good, I'll accept them in a single commit.\n. I think others could find former currencies helpful. I think it's fine adding them to Currency::TABLE, perhaps with another attribute that indicates their no longer used.\n. I'm going to close this until we get your currency updates straightened out. Then you can resubmit this pull request.\n. I plan on pulling both of the pull requests tomorrow morning. Just an FYI, I usually don't accept any pull requests with failing tests. I might make an exception here. But I not sure I will, it's a rule I want to stick to.\n. I'm sorry, but I cannot merge this. There are too many incompatibilities, with Ruby 1.9+ etc. I willing to work through this with you. I've create a gist here with the current currencies in yaml format. Please update this with your new attributes and currencies. Please do not reorder anything. I want to be able to easily compare the two files to ensure the differences are valid.\n. I'm willing to work on this, I just need a valid yaml file. If you can't give it to me in the same order, can you at least give it to me sorted alphabetically?\n. I believe there are some errors with your yaml conversion process. For instance :ghs has somehow become an attribute of :ghc instead of it's own entry. I think it would be better if we started with one commit that extracts Money::Currency::TABLE into it's own file currency_table.rb. Then another that creates a rake task to extract that Hash into a yaml file. And finally a third commit that adds a rake task to convert the yaml file to the Hash. If you can does this, then we can proceed to adding your currencies changes. Otherwise, I suggest you fork the gem and maintain your own branch as right now, these changes are not working correctly.\n. @elmatou I'm not sure if this will help you, but we recently removed the TABLE hash and started storing the currencies as JSON.\n. Putting an index on a CHAR(3) field in the database on iso code should make it perform just as well. Since ISO doesn't provide a universally recognized number for each currency, I really wouldn't want to try and maintain one myself.\n. There's no reason it couldn't be. Feel free to write a patch and I'll merge it if everything looks okay.\n. It's pretty easy. You'll create a fork of the project, write your new method plus tests, then submit a pull request. I'll check out everything to make sure it works and merge it in.\n. I'm closing this for now. Feel free to reopen when you have a pull request ready.\n. You have these backwards. decimal_mark is separator and thousands_separator is delimiter. Also, it should be number.currency.format.separator and number.currency.format.delimiter and these are optional and not always given, which is why the original implementer used number:format but incorrectly used the wrong names. I've commented on the diff on what I think they should be. Before I can merge these, I'll need to see some tests. You can do this by writing a spec that requires ActionPack.\n. I had make quite a few changes. You still had separator/delimiter backwards. I also cleanup up and implemented correct tests.\n. @pconnor thanks for the updated documentation!\n. @weppos: Can you take a look at this? I'm not as familiar with Rails as you are.\n. I believe you should write this as:\nruby\nCompany.new(:balance => Money.new(100, \"EUR\"))\n. @jell Was anything changed regarding the specs aside from splitting them up? My biggest concern with chopping up the specs at the same time a massive change like this is done, is that something might have broken backwards compatibility that we won't be aware of.\nWhat I'd really like to see is this request rebased into two commits.\n1. The refactoring of code in the lib directory\n2. The refactoring of code in the spec directory\nThis way I can test each commit individually. Overall, I like the idea, I'd just like to have it cleaned up and tested.\n. @Jell thanks for your work on this. We really appreciate it.\n. @Jell everything looks great! Thanks for the patches.\n. @nurey, you could also use :symbol => false and not worry about it. Your choice.\n. @nurey, please see commit 684f60dccf5e7b47baa330ee690fdd65eabee849 for how I enhanced your specs after I merged your changes. This is more what we're looking for when it comes to tests.\n. updated in commit 05841763f8e1e35cf19ead529b86b523435995cb\n. If you create a patch for this I'll be happy to merge it.\n. I guess I don't understand the issue with creating a negative object. If you subtract $1 from $2, you need a -$1 money object.\n. Two things. First, before I can accept this patch there needs to be tests added for the new functionality. Second, I'm not sure that we want to auto-convert everything sent to arithmetic methods. How can be ensure that they get the correct Currency, etc? Maybe we need a global option that you can enable to auto-convert everything where possible and let users set it themselves.\n. I agree with @weppos. The only way I can see enabling this would be to have multiple global options for the user to configure. Seems like it would just be easier to force users to always add two Money objects, calling #to_money or Money#new first.\n. Looks great. Merged!\n. I think rails-money would be the best fit. If you created it, and would like to have it be part of the RubyMoney family, I'd have no problem adding it to the organization and making you a member. In fact, if you're interested, I can setup the repo and give you full admin rights to it, just let me know.\n. We have to pass the Float to preserve backwards compatibility. I actually have written a new gem cashrb. That forgoes backwards compatibility to make things easier and clearer.\n. updated in commit ea323af1bf70c523ce332ac917b7c3b3067857a4\n. updated in commit 236a0b3c5fff5c360b4b968783a3e8eac9ddba9d\n. Thanks for the patch. Once you make that change, I'll merge your code.\n. Thanks for the patch. It's been merged.\n. Proposed change here 82f5fef3d52019c571c0\n@hakanensari, this should do what you're looking for and still keep the i18n bug fix that other users requested. Try it out and let me know if it works for you.\n. Here's where I'm still having a problem with raising the version to 4.0. i18n was implemented as an enhancement in 3.5.0, it gave you the ability to use i18n to look up separators/delimiters if you were using i18n in your application.  Since this was an enhancement to the public API (and was backwards compatible) we increased the minor version. Now, in 3.6.2, we made a bug fix that used the currency entry in rails_i18n if it was available. This was a bug fix, so that patch version was added. Nothing broke backwards compatibility. What I don't understand is why your app started using i18n in 3.6.2, when it should have back in 3.5.0 already. We probably should have had this switch available since 3.5.0, but we didn't, but I don't think this makes it a backwards incompatible update requiring a major version bump.\n. I agree, it's an edge case. I'll be pushing this out as 3.7.0 today.\n. Pushed out a new version just now.\n. I'm going to leave this to users to define. The only reason that banks have #to_json methods is to easily unload and load rates.\n. Thanks for creating the gem. If you're interested in joining the RubyMoney team, just let me know.\n. I understand what you're requesting, but how is this different than the i18n support that is baked in already?\n. If I were you, I would just add an entry to the Money::Currency::TABLE hash. If bitcoins ever become a internationally recognized Currency, we would then add it to the Gem for everyone.\n. what about passing the money amount to the other page like this n.format(:decimal_mark => \".\", :thousands_separator => nil)?\n. Having not heard anything in 2 weeks, I am closing this issue.\n. what about just using #to_f\n. @weppos can you take a look at this?\n@defconomicron & @asadfarooq We take all issues whether report by 1 person or 100 with the same importance. Looking at your profiles you appear to either be the same person, or at least know each other. There's no need to say you both have the issue if either is the case.\n. I'm sorry, our rails expert @weppos isn't available right now. Have you tried posting this question to the rails mailing list, or on IRC?\n. @weppos @defconomicron any advancement on this issue? Is it a non-money issue?\n. Just curious, have you tried using cashrb\n. Looks good, thanks for the fix!\n. I would suggest using BigDecimal until you need to output the actual dollars/cents value. That's what I've done in the past. \n. Instead of storing the second object as a Money object, you could just store the raw cents value. But I don't really think you're violating DRY by storing the currency in both models.\n. Why wouldn't it be the same? It seems like it would be a good idea to check that and make sure there isn't a mismatch. If you always assume they're the same, and they're actually not, you could get some potential big miscalculations I'd imagine.\n. It should work for other currencies already...\n. Awesome, Thanks!\n. According to ISO, 1/100 of a Yen is a Sen, which is used by ISO as the cents notation for Yen. If you didn't want to use Sen, you could just call #format with :no_cents.\n. If that's the case, I have no problem removing Sen. Please update the currency file appropriately and send a pull request. I'll merge it right away.\n. Decimal will lose precision. We'd have to use a BigDecimal. You might look at using my cashrb gem instead. It let's you use custom currencies and uses BigDecimal by default.\n. We need a patch to store cents as a BigDecimal. I have no problem accepting a patch to do just that, but I purposefully started work on cashrb to get rid of all of these issues.\n. bigint\n. It should, I don't see why it wouldn't, but I haven't tested it.\n. Thanks for the patch!\n. Thanks for the patch!\n. He's right there, you're storing the currency for both objects in the same field.\n. Thanks for the patch!\n. Thanks for the update!\n. I'm thinking we should leave this in for historical calculations. We have a number of requests for those before.\n. That would be fine with me if someone would like to submit a patch.\n. It's to signify that the currency isn't valid anymore, but it still needs to be there for legacy reasons.\n. Take a look at #exchange_with my guess is has something to do with the rounding here. https://github.com/RubyMoney/money/blob/master/lib/money/bank/variable_exchange.rb#L87\n. @johnrees anything further on this?\n. Excellent! Feel free to submit a patch to the readme with a link.\n. Awesome, thanks!\n. @alovak this looks great. Thanks for the patch. Merged!\n. Fixed! Just pushed 4.0.1\n. Excellent! I've merged the patch and given you commit permission. Could you add some tests?\n. I'll let @weppos handle this, he's our resident rails integration expert.\n. Closing this issue. Please reopen if there is more that needs to be done in the future.\n. Hmm. With subunit_to_unit => 4400, 0.5 is invalid. That's implying 5000 \u0447\u0430\u0442\u043b. Does this actually mean 5 \u0447\u0430\u0442\u043b? If so does \"0.0005\".to_money(:kzm) work? If no, could you write up some failing tests for us? I'm guessing we'll still have a problem because this isn't 1,5,10,100,1000, etc. But if you commit to writing some tests, I will work on getting this fixed.\n. Closing this. Please open a pull request with your tests when they're ready.\n. @weppos, what do you think about this? I've never been a fan that we even have the method Money#to_money. It seems to me if you want to change the Currency of your object, you'd just call #exchange_to yourself anyway? @pelle, can you give me an example where you'd want to use this instead of #exchange_to\n. Fair enough. Merged.\n. Thanks!\n. Instead of making #initialize do two different things, I'd rather stick to the single responsibility principal and create a new class method #add_currency which does this.\n. Ahh. I understand. You might take a look at my other gem cashrb which lets you define arbitrary currencies. For now I'm going to close this pull request.\n. @weppos this is great. I think we're on our way to actually cleaning up this library.\n. Excellent. I ran it through all the Rubies I could think of and everything works accept we're failing on some encoding issues with jruby-1.6.5 when running in 1.9 mode. Can you try and see if it's just my machine that has the issue?\n. Alright sounds good to me. I'm betting it has something to do with currency.json being utf-8 but there being no indication it is.\n. Thanks for pointing this out. I'll update the README. We have to have UTF-8 since there are so many currencies other than USD that use non-ASCII characters.\n. Check out my other gem https://github.com/semmons99/cashrb I think that's what you're looking for.\n. Thanks for the patch. You now have commit access to the repo.\n. Excellent. Thank you. You now have commit access as well.\n. thanks @dom1nga you now have commit access!\n. I think this would be good as a separate gem that could be loaded at runtime if desired.\n. I'm going to close this issue. However, @etagwerker if you decide you would like to build the gem, we can make it a RubyMoney project and add it as a official repo. If you need any help implementing it, just let us know.\n. Perhaps we leave this open and keep taps on the issue. I would imagine this is a JRuby bug if all other implementations work right.\n. I'm going to go ahead and close this. We can point anyone to this who opens a new issue.\n. For this to affect someone, wouldn't they have to issue 16 million unique symbols? The only issue I could see is if you're throwing heaps of invalid currencies to Money::Currency#new.\nWouldn't this fix the problem?\n``` ruby\nID_STRINGS = TABLE.keys.map{|k| k.to_s.downcase}\ndef initialize(id)\n  id = id.to_s.downcase\nunless ID_STRINGS.include? id\n    raise UnknownCurrency, \"Unknown currency '#{id}'\"\n  end\n@id = id.to_sym\n  data = TABLE[@id]\n  data.each_pair do |key, value|\n    instance_variable_set(:\"@#{key}\", value)\n  end\nend\n```\n. Since no response has been given in a week, I'm closing this issue.\n. @kenn if you have some time to make the pull request and add a test or two, that'd be great.\n. @nubs Could you please add some tests for this?\n@dom1nga what would you expect Money.parse('-5.95-') to do?\nThe problem I have with #parse in general is that we try and throw too much at it and hope it converts properly. If I was doing this over, there wouldn't be a parse method. I'd expect the user to know their input format and get it into some form of Numeric ahead of time.\n. @dom1nga I don't really have an opinion one way or another; but could you elaborate more on why you think this should throw an ArgumentError?\n. @dom1nga sounds reasonable. I assume you would argue the - in front and behind the number part is ambiguous and could either be a negative or some type of separator from data fields, much like a comma in a standard CSV?\nI wonder if we need to raise a new ParsingError for anything Money#parse can't handle. Does such a thing exist?\n. @nubs, awesome the patch is starting to come together. Now if you can just raise a ParsingError we'll be all set.\n. @nubs nevermind about the ParsingError we'll address that issue in a future release.\n. Thanks for your patch @nubs. You now have commit rights to the repo.\n. @WhiteFire-Sondergaard Feel free to submit a patch for each of these issues and we'll merge it. Make sure that they are separate pull requests please.\n. I think this underscores the issue that we need to finally address string parsing. I've opened a new pull request to get opinions before we make anymore changes.\n. @weppos @alovak @dom1nga @jacobat @jduff @mreinsch  @nubs @pelle @semaperepelitsa\nLooking for more opinions on this? Anyone have some other ideas?\n. @alovak Currently our string parsing is a mishmash of heuristics to try and detect and parse a money-like object. The problem is we're always getting new request for how parse string and just like everything else having to do with money, they're region specific. What I'd like to do is come up with a solution that puts some (or all) of the burden back onto consumer of the gem for parsing their own strings.\n. I'm going to close this. We can revisit this if we start having more pain.\n. I you can find all the information for those and make a patch that would be\ngreat.\nOn Thursday, December 29, 2011, Mateo Murphy \nreply@reply.github.com\nwrote:\n\nI've just started using Money with money-historical-bank, and notice that\nthe data that open-exchange-rates provides includes some currencies that\nare not supported by Money. Namely; zwl, iep, xdr, tmt, and clf. I could\nadd support for these if anyone is interested?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/136\n\n\n\nshane\n. Thanks for the patch @kenn. You now have commit rights to the repo.\n. @weppos could you field this one?\n. I could see making #=== match an object that can be coerced into a Currency object. But I believe #== should stick strictly to Currency-like objects.\n. Feel free to open a pull request and add this method. So long as there's test and it doesn't break anything I'll merge it right away.\n. @weppos I think your message was cut-off.\n. thanks @enebo. You now have commit access to the repo. Use it wisely :smile:\n. @barmstrong The issue is that adding a new currency is harder than appending a new record to the TABLE constant. Since it's a constant, it really shouldn't be modified. That being said, we need to provide a way to allow users to add new currencies safely. I'll work on something today.\n. > IMHO currency should be added though pull request :) What do you think?\n\n@alovak for a legit, iso recognized currency I agree. However it is nice to support non-standard currencies with #143 should address.\n. After some testing, we will be releasing 5.0.0 since this change breaks compatibility.\n. @alovak @weppos @barmstrong How's this look to everyone?\n. @alup once I hear from the original issue creator that it covers their request I'll merge it :smile:\n. @mattv thanks for the bug report\n. NOTE: #147 will handle this.\n. Please add a spec as a sanity check. Then we'll merge.\n. @enebo can you rebase master on your code. Right now I can't do an automatic merge and it doesn't make sense to me.\n. @enebo please close those issues and mention your fix.\n. @enebo One more thing, if you haven't already, please update CHANGELOG.md with a description of this change and references to the issues and pull requests that it addressed.\n. This is mostly due to the US centric beginnings of this library where are :subunit_to_unit calculations were 1:100. I could see renaming #cents to #subunit, but seeing as it hasn't been a source of confusion (at least one that's been reported) I'd rather just leave it alone.\n. Thanks for the pull request @scomma. Anyone who submits a patch, and has it accepted, is given commit right to the main repo, even you. Thanks again.\n. @scomma I just noticed that you didn't run any of the tests after you made this change. Please ensure in the future all patches you make have been tested first.\n. Thanks @matma. You now have commit rights to the repo.\n. Thanks for the patch @the-architect! You now have commit rights to the repo.\n. @banjerluke this introduces a failing spec. Could you please fix it and let me know when you've pushed a revision?\n. Thanks for the patch @banjerluke. You now have commit rights to the repo.\n. @neilmiddleton an assumption of the default currency just as if they hadn't opted-in.\n. Thanks for the patch @neilmiddleton. You now have commit rights to the repo.\n. Thanks for the patch @alup. Before I merge it, please update the CHANGELOG and add your name to the AUTHORS file.\n. Thanks @alup! You now have commit rights to the repo as well.\n. Thanks for the patch @ohthatjames.  Before I merge it, please update the CHANGELOG and add your name to the AUTHORS file.\n. Excellent. Thanks @ohthatjames. You now have commit rights to the repo.\n. @alup in the future, feel free to just create a pull request and describe the issue there. Should hopefully save you an extra step. :smile:\n. Other than the issue I noted above, this looks fine. Feel free to add your email to the travis-ci config to be notified of any problems that arise during CI after this patch is merged.\n. @weppos I'm going to rely on you and @alup to discuss and refine this feature. I still have limited Rails knowledge and can't really speak on this with authority.\n. I'd be in favor of a new gem myself. I have no problem creating a new money-rails repo and giving whomever wants to lead and develop the project full admin control of it.\n. @alup I've created the money-rails repo and given you and @weppos admin rights to it. Go nuts!\n. This looks great @MatmaRex! Please follow the Contribution section of the README by updating the changelog and authors section. Once you have, let me know and I'll merge.\n. > Fine, although I have no idea why would that be needed. (Or why should I do it in particular.)\nThe CHANGELOG needs to be updated so that others know what you changed without reading the Git history. AUTHORS is nice to see who worked on a project and give them some recognition.\n\nAlso, I don't need the commit access, thank you. (And I don't see why would you give it out to everyone.)\n\nYou don't have to use it then. If a developer is willing to take their time to fix a bug in software I maintain, I'm willing to offer them my respect by giving them the same access I have to this project. Some of our greatest core members have come from this practice. We believe in Free and Open Source Software which is why we offer everyone who's willing to help commit access. Anarchy in software is the reason FOSS keeps moving forward.\n. A pre-release of 5.0 will be done today, followed by a full release next Monday if not issues are reported.\n. I just released 5.0.0.rc1\n. Having AUTHORS around keeps us independent from that particular Github feature and doesn't force user to clone the repo and run git who to see who has contributed. Really, it's just a nice, small file to make sure everyone who works on the project is recognized in an easily viewable manner.\n. @MrGando You can start looking in this file. You'll probably need to put some special logic in for currencies that map subunit_to_unit as 1.\n. @MrGando what version of the library are you using. I just wrote the following test and it works.\nruby\nit \"handles CLP correctly\" do\n  clp = Money.new(1000, \"CLP\")\n  clp.format.should == \"$1.000\"\nend\nI'm going to close the issue under the assumption it's an old bug that was fixed in the 5.0.0 release. Please reopen if that's not the case.\n. Thanks for the patch @exviva. You've been added as an author of the gem and give commit rights to the main repository.\n. If we were to do something like this I'd create a new instance variable on Money (something like raise_exception_on_invalid_conversion) that defaults to false. Users could change this setting if needed. Then we could modify #to_money to check this flag and act accordingly. Adding a ! to methods to raise exceptions is a Rails convention (not a general Ruby convention). I'd like to avoid explicitly writing anything that is specific to Rails, etc.\n. What if we had the library wide boolean and an option parameter that you could pass to #to_money? Has anyone found other libraries outside rails that optionally raise exceptions, is there a common pattern?\n. I'm going to agree with @weppos. Let's close this issue until more requests come in with a similar issue. He's also right that #parse is probably the place we would really want to look at modifying.\n. @kirillian could you actually just create USD5 yourself and create all new money objects you need using that currency?\n. I'm good with adding a precision attribute to each money object. However, instead of having the user specify the precision, should we just allow either the default based on the currency or infinite and then have the rounding be done by the user user for the #format method.\nQuite honestly, I'd really like to make a Money2 library that gets rid of a lot of the technical debt we've acquired over the last 5 years.\n. I'm thinking we stop using Integer and start using BigDecimal. It's what I did with cashrb, my first attempt at rewriting this library.\n. Yes, it would be helpful if they were separated. We should really start with internal precision and once that is solidly in place go about getting formatting precision working. @kirillian do you feel up for trying this?\n. Couldn't we just store the current cents as the whole number of the BigDecimal and the extra precision as the fractional cents? Then we can just modify the #cents method to return round(0, BigDecimal::ROUND_HALF_EVEN) unless a variable is set. This should preserve backwards compatibility.\n. Awesome, thanks @kirillian!\n. Please open a pull request. Even if the code isn't ready to merge, it will give us a place to discuss it.\n. So, I was thinking this could be simpler. Perhaps something like this.\nlib/money/money.rb\n``` ruby\nclass Money\n  class << self\n    attr_accessor :infinite_precision\n  end\nself.infinite_precision = false\ndef initialize(cents, currency = Money.default_currency, bank = Money.default_bank)\n    @cents    = BigDecimal(cents)\n    @currency = Currency.wrap(currency)\n    @bank     = bank\n  end\ndef cents\n    if self.class.infinite_precision\n      @cents.round(0, BigDecimal::ROUND_HALF_EVEN)\n    else\n      @cents\n    end\n  end\n```\nNote, we definitely do not want to define #cents=. Users should only be creating new money objects, not mutating existing ones.\nWe'd need to audit our internal code to make sure we only use #cents and don't directly access @cents, but it should work.\n. @kirillian let me know if you need any help finishing this patch up.\n. @kirillian I wrote up my own pull request this morning (https://github.com/RubyMoney/money/pull/174). What do you think of it?\n. :smile: I felt like coding this morning.\n. Adding the rounding mode is a great idea. I'll do that right now.\n. @davekaro any way we can write some tests for this?\n. I'd be fine with a patch that has us use multi-json instead.\n. Aside from removing the requirement line above, this looks good to me. Just shot me a message when it's updated and I'll merge.\n. Thanks for the patch @davekaro! You now have commit rights to the repo.\n. This pull request addresses that very issue https://github.com/RubyMoney/money/pull/169 :smile:\n. Historically cents was used because Floating Point math was bad and would lose cents in calculations. We're now trying to retrofit the library to use BigDecimal, but not change the interface on users. You can still use your decimal structure and just call the \"#to_money\" on your decimal data. It should be handled properly for you.\n. there is a money-rails gem that might help you.\n. just rebased to sync with master\n. @kirillian I started using #to_d for conversion where appropriate. Had to add a new conversion_precision option since 1.9 requires you to provide one.\n. Hmm, you're probably right that it does use sprintf at some point. Any ideas on how we can coerce the fractional cents out other than that?\nOnce we get this merged, I'll let you got about implementing the new #format option. I'm also going to go ahead and give you commit rights now since this is really your patch written by me.\n. git rebase master\n. excellent. Do you see anything missing from this pull request?\n@RubyMoney/money-devs and @RubyMoney/money-admins do you see anything missing from this pull request as far as tests go?\n. @semaperepelitsa traditionally, we've returned cents as an integer. If we don't continue to do it we'll break backwards compatibility.\n. If no one speaks up against this patch, I'll be merging it on Monday 6/4.\n. @kirillian: The patch has been merged. Please add your missing tests and create a new pull request for your change(s) to #format.\n. Thanks for the heads up. Updated in commit 577020a7ef12723493d058758b7f2067d08d650d\n. According to CHANGELOG.md, JPY was updated in 4.0.0 to correctly use :subunit_to_unit = 1 since the Sen has been out of circulation since 1953. I believe that's why you're seeing the difference. Essentially JPY 500 no correctly implies 500 Yen instead of the defunct 500 Sen.\n. This is a tough call. If I were representing the amount as a float, it should probably be 1.9, but if I was displaying it, it would probably be 1.4. Honestly thought, I have no idea.\n. @kirillian: I've added an unresolved tag to this issue and am closing it. Please reopen if you stumble across any more information.\n. JRuby and Travis-CI aren't getting along lately. I'm going to close this until I see things stabalize.\n. Awesome. Merged!\n. @hakanensari would you update the wiki with this information too?\n. Please submit a pull request with the required updates.\n. I'm fine with this, though we'll need to be vigilante that no one accidentally commits files that were caught by the projects .gitignore previously.\n. @weppos I say merge it and see where the cards fall. Worse case, we eventually revert the commit. More likely we help educate the public (and ourselves) from time to time on the need for a global .gitignore for our editors, etc.\n. It would probably be worthwhile to put the existing ZWD into currency_bc.json at least. As for the other three, if someone can dig up their information and put it into currency_bc.json as well that'd be nice, but not necessary right now.\n. Closed via #186\n. Please investigate and submit pull requests for any problems like this you find. \n. Thanks for the patch @Exoth! You now have commits rights to the project.\n. > But seriously, what's \"bc\"?\n@hakanensari: It stands for \"Backwards Compatibility\". We're very hesitant to break backwards compatibility for purities sake. Therefore we move defunct currencies into currency_bc.json to signal to us they're bad, but someone might be using them.\n. > The library depends on multi_json to load the config and export rates in multiple \"formats,\" including JSON.\nmulti_json is required due to problems with certain versions of JRuby. Originally we used the builtin JSON parser until the problem was discovered.\n. > 1) VariableExchange#export_rates should have a single responsibility, which is to dump the rates Hash. Let the user then worry about formatting that Hash, which is trivial.\nVariableExchange is more of an example implementation of a Bank than something that should actually be used. If you come up with a better example implementation that follows SRP better, I'd be happy to deprecate this implementation in favor of it.\n. > 2) Convert the config to YAML. Standard library FTW.\nJSON is a standard library, and if it wasn't for the JRuby bug, we wouldn't need multi_json. That being said, I'm not opposed to using YAML or even Ruby.\n. @hakanensari: I just looked through all the bank implementations we have listed in the README and all but one subclass VariableExchangeBank. I think we're stuck with that one until we come up with a better implementation. When we do we will need to deprecate VariableExchangeBank and work with the authors to update their gems if possible.\n. I have no problem depreciating and then removing #to_currency. Please investigate and submit a pull request to start the ball rolling on that.\nAs for #to_money I agree with @weppos that this is more extending a class than monkey patching it. That being said, it wouldn't be a horrible idea to make people explicitly request the #to_money feature by doing something like require \"money/core_ext. That being said, I don't want to pull the rug out from users by suddenly making them do this. And I can't think of a good way to notify them we're going to change this. With a library this mature, I tend to error on the side of least surprise and just carry around the baggage. That being said, if someone comes up with an good idea, I'd be willing to take a look at the resulting pull request and discuss it.\n. Pull Request #191 removes the need for multi_json while keeping everything in the current JSON format. Please pop over there and let me know if there are issues.\n. @hakanensari: I can't see any good reason not to move everything into a plan old ruby object. What to give it a whirl?\n. :smile: I'm good with it!\n. @davekaro Ahh yes. Thank you for reminding me. So, if we want to keep JSON, we need to continue with mutli_json.\n. @hakanensari: At one point the currency data was in a CONSTANT that was a Ruby Hash. I'd need to dig back thorough time to see what the rational was for stopping that. Unless somewhat else remembers. I believe it was last year around this time.\n. @hakanensari It should now only be necessary via a development dependency for testing the VariableExchange bank. And honestly I say we remove the dependency and assume anyone developing the gem is using 1.9.3+.\n. go ahead and remove the badge and LoadError while you're at it.\n. @weppos and anyone else, I'd like to hear your thoughts on this pull request. I think it brings us forward, but I want to make sure I'm not missing anything.\n@hakanensari: Mind updating the CHANGELOG for these changes?\n. The json dependency is for VariableExchangeBank importing and exporting rates. I still torn. I wonder if we should extract the currencies into their own gem and have money add the new gem as a dependency.\n. I think you're right @weppos. The first option makes the most sense to me as well. If someone else wants to tackle just getting the standard JSON library to work, I say go for it. Otherwise I'll tackle it on Monday.\nAny thoughts on leaving 1.8.7 behind?\n. Thanks @mdi \n. This really doesn't make sense to me. It only works when one of the currencies is ZERO. But just because a currency is zero doesn't mean you can do arithmetic on the two. You can't subtract 2 meters from 0 seconds, it doesn't make sense. Likewise you can't subtract 2 EUR from 0 USD. You need to first normalize to a single currency.\nAlso, for future reference, please include applicable unit tests.\n. Here's where I'm worried.\nruby\n[100 USD, -100 USD, 1 EUR].inject(&:+) # ==> 1 EUR\n[1 EUR, 100 USD, -100 USD].inject(&:+) # ==> Exception\nI'd rather we work consistently everywhere. Also, the 1.9 syntax takes care of peeking at the first item. I do see your point of have a special type of Money object though represents some abstract ZERO amount.\n. @ioquatix: Would you please open a new issue to discuss the creation and role of a Money.zero object. Being pragmatic, it's a rather complicated topic that I'd like to hear others discuss and share their pain before we attempt to tackle it.\n. @ioquatix: I really like this proposal. Unfortunately I don't have the time to implement this single-handedly right now. Any chance you could start a pull request and we could work together to create a solution?\n. @llazzaro: I'm still working through the scenarios to decide if polymorphic zero is good. Right now I think it is. And yes, Money::Zero would solve this issue.\n. @RubyMoney/money-devs: Anyone interested in implementing this Money::Zero functionality. It would be really handy.\n. @llazzaro: Awesome, please give it a try. I'm sure other devs will help pitch in if you need help.\n. @ioquatix: Thanks for the input. At this time I think you're right. We'll leave it up to the client to decide how they'd like to work with disparate currencies.\n. @ioquatix: Thanks for the info. I'm now wrestling with making a Money::Collection inside the money gem itself, or as a new gem.\n. Have you looked at the money-rails gem?\n. Thanks for the update @hisyam!\n. This commit added support for infinite precision amounts. You'll need to set Money.infinite_precision = true to enable this feature.\n. I'd put it in an initializer file.\n. No, it'll be part of v5.1\n. @ioquatix: feel free to submit a patch. You don't want to just remove cents though, it would need to be deprecated and eventually removed after many month's of depreciation notices.\n. What version of Ruby and the money gem are you using? Using ruby 1.9.3 and money 5.0.0 I have both return 50 cents.\n. @dasil003: Sounds to me like you need special regional formatting, which is something we can't really support (there's just too many special cases depending on where you are in the world). I'd suggest you write a method that wraps a call to #format that takes into account any special formatting you have to do for local idiosyncracies.\n. @dasil003: feel free to submit to patch for vetting, but this initial request was a \"how should I do this\" which we label support. We get lot's of suggestions without patches, so our default reaction you can write a custom method to fix that or submit a patch. Sorry if this comes off harsh.\n. I believe we're missing a flag in the documentation. You must set Money.assume_from_symbol = true to get symbol parsing.\n. strike that, the README already mentions the need for the switch.\n. I'm confused why this is needed. Can this not be accomplished already using the decimal_mark and thousands_separator of #format?\n. Oh, is it because it's not always grouped into sets of 3? What are the rules?\n. okay, so after the first grouping of three, it groups twos.\n. @sankaranarayanan: Could you do a little leg work for me and find out if any other locales do this formatting. I want to ensure that indian_formatting is the appropriate description.\n. Looking at this wikipedia article would it be more apt to name it something like south_asian_number_formatting.\n. I'm thinking this should only be an option for the #format method as it's specific to a locale and affects all displayed monetary units. Is that a correct statement?\n. > 2) Yes, It should only be an option for #format, but shouldn't we allow it to be set on Currency as the currency is also specific to a locale? I mean, you speak of millions of dollars and lakhs of rupees; and interchanging the format and currency is very rare.\nIn an English Number Format area they would be referred to as a million rupees and formatted in the English variant, if we had it specified on the currency itself, it would mean in countries that use their standard formatting for all currencies would have a problem. So I'd like to leave it the #format method for now. Though if enough people chime in and tell me that's wrong, I can be swayed.\n\n3) Ideally we should also look up in I18n like what you are doing for decimal_mark. And that is lacking from this pull request. Is this what you are asking?\n\nNope, you can skip i18n for now.\nIn the end, I'd just like this pull request to add the option to #format for now.\n. @TMaYaD: right, I want that part removed by @sankaranarayanan \n. thanks for the patch @sankaranarayanan!\n. jruby-1.9mode fails on Travis because 1.6.7.2 doesn't come packaged with json, but 1.7.0 does. In my opinion users who want to use JSON not packaged with ruby can add json to their Gemfile. It's in stdlib, we shouldn't need to jump through hoops.\n. Thanks @hakanensari. Still debating if I want to do that.\n. so that change helps testing, but still requires JRuby users to add json to their own Gemfile when using money prior to 1.7.0. Should I just put something in the README about that?\n. It's been a week, and I haven't heard any objections. Forward we go!\n. We've struggled with this question throughout the lifetime of Money. Right now issue #195 proposes the creation of a Money::Zero object that would take care of this situation. But that hasn't been moving recently. Personally when I work with types like Money I try and make sure to only work with other Money objects. Therefore, I'd change your example to this:\n``` ruby\nm = Money.new(50, :CAD)\nif m > Money.new(0, m.currency)\n  puts \"it worked!\"\nend\n```\nIt's not the most ideal solution, but it's all we've really got to work with right now. If you feel strongly about this issue, I'd encourage your to work on #195 with @ioquatix. I'll give you guys all the help I can to get the proposal off the ground and working.\n. @weppos: can you respond to this one?\n. @m4n: I know it's been months and you haven't heard anything. Have you looked at the money-rails gem it should solve this for you.\n. Sorry I missed this before. We have a policy to not try an accomodate external gems like this. It leads to a lot of potential headaches; which you can see if you go back in the issues/pull-requests and see us try to support different JSON libraries. My suggestion would be to monkey-patch money if needed in your own codebase.\n. @cblock let me know if that last comment makes sense to you.\n. I think #export_rates could be written more clearly like so:\n``` ruby\ndef export_rates(format, file=nil)\n  formatter = FORMAT_MAP[format] || format\nraise Money::Bank::UnknownRateFormat unless\n    formatter.respond_to(:dump)\n@mutex.synchronize {\n    data = formatter.dump(@rates)\nFile.open(file, \"w\"){|f| f.write(data)} unless file.nil?\n\n}\ndata\nend\n```\nInstead of waiting for a formatter to be passed that doesn't respond to #dump, we proactively check that it does, controlling the exception.\n. I'd also prefer in the documentation for the method it be shown that both :json, JSON or a custom formatter can be used.\nWe'd also need test added in for formatters being passed that don't respond to #dump.\n. > Not sure if we want to keep RATE_FORMATS constant and any references to format-style argument in documentation.\nThis could just be a private method instead, something like def formatter_for(format)\n. If we give them our own error, with a better message, it will be more understandable than having to dig into the money source and see why the method #dump is needed. Sure, Ruby gives you an error message, but we should try and be more helpful to the developers than that.\nVariableExchange::FORMAT_MAP[:yaml] = Syck will give a warning. But if we changed it to use attr_accessor and it would provide the same functionality without giving unnecessary warnings.\nI think we should leave the documentation for :json for two reasons, backwards compatibility as well as it should be the most common way to dump rates for most users.\n. @semaperepelitsa: If you're interested on continuing this work, please reopen the pull request.\n. @skwp: You're right, this would be a handy (and potentially easy) feature to implement. Please do so and let us know if you need any help.\n. @jacobat & @skwp: Yes, we should assume there is the possibility that currencies could trade between each other at different rates. To handle that, I'd only create the mirror rate if one does not already exist.\n. ruby\nn = Money.new(12000)\nputs n * 0.5\n. @alup & @mikaelwikman: This looks good to me, but do you happen to have anything we could alias #cents to?\n. Actually, money handles none base 100 currency. So, fractional sounds good to me. Anyone else?\n. Excellent. Thanks @mikaelwikman. \n. Awesome work @mikaelwikman! Thanks for your work. This is something we've know needed to be done, but have been hesitant to take the plunge. I'm really glad you were able to keeps this 100% backwards compatible. Once Travis okays the patch I'll merge this in and give you commit rights to the project. Thanks again!\n. Standard workflow is to do some work, create a pull request and reach a consensus on the changes. Once you feel a consensus is reached, merge the pull request or have some else if you're more comfortable with that. Also, feel free to make little changes to documentation, etc without creating pull requests (I've made at least four already today).\nI know one of the test that is slowing things down is actually testing rounding or something over a huge swath of values. That might be overkill.\n. @xaph: Thanks for the info. Any chance you could submit a patch?\n. @xaph: Since this currently isn't part of unicode, we can't add it. But as soon as it is, please reopen this issue and we'll get it updated.\n. :+1: Ship It! :shipit:\n. You could try and run the 22000 and find all the errors that it actually fixed. However, since we converted to BigDecimal awhile ago, this should no longer be an issue. At least I hope it isn't.\nThe other option is split it out this massive run into an acceptance test and have it run with a separate rake spec:acceptance command.\n. Can you create a new issue and reference this pull-request there? I will attempt to code spelunk tomorrow or Friday. \n. @kenn & @mikaelwikman: See my comments on #216, but it appears we have squashed all internal usage of Floats.\n. @zackxu1: A new issue would fit better. That being said, we're working through a handful of issues right now. I'd suggest adding gem \"money\", :git => \"git://github.com/RubyMoney/money.git\" to your Gemfile. If that won't work, let me know and I can roll a beta that you can point to.\n. I've you vendor your gems and commit the to you repo, then it wouldn't be the latest code :smile:. But, I'll roll a beta today.\n. @zackxu1: You can now install 5.1.0.beta1 by running gem install money --pre or adding gem \"money\", \"~> 5.1.0.beta1\" to your Gemfile.\n. @mikaelwikman: back on topic. I would imagine just testing the having a 0.01 amount added to anything works.\n. @mikaelwikman: I've gone through the codebase and can't find anywhere in the code where we're still using Float internally. I say, just add the 0.01 test for completeness and we're all set.\n. @palexvs: What method are you using to create the JSON? Whatever is doing that conversion will need to be updated to enhance your JSON. I am unaware of any method we provide that would generate this.\n. I'm guessing that ActiveSupport/ActiveRecord is doing some magic via a #inspect call to automatically convert to JSON. I'd rather not dictate how anyone want's to format their JSON, so I leave this as an exercise for the consumer.\n. I welcome a patch with a reasonable proposal.\n. Looks good. Merging.\n. Thanks for the patch @clee704!\n. @itspanzi: checking it out right now\n. I like it. Wait a day or two to get others opinions, and if there's not big issues, ship it! :shipit:\n. @mikaelwikman: I'd say go ahead and rebase, merge and ship it! :shipit:\n. shell\ngit remote add upsteam git://github.com/RubyMoney/money.git\ngit fetch upsteam\ngit pull --rebase . upstream/master\ngit push\nThen let me know and I'll check the pull request and merge it.\n. @mikaelwikman did you add the remote and fetch? The message looks like you missed one of those steps.\n. That sounds right\n. Looks like it's Travis being flaky. Merging.\n. :heart:\n. @itspanzi: looks like you didn't run the specs. There are some that need to be updated. Please push another commit that fixes them. Also, please add you name to the authors and update the changelog per the contributing guidelines\n. Awesome work, thanks @itspanzi!\n. Hi @muxcmux: Please updated the CHANGELOG (and optionally add your name to AUTHORS) as detailed in the contribution guidelines. Then I'll merge and give you a commit bit.\n. Sorry @muxcmux, didn't know you updated the pull request. Merged!\n. @adiel: Could you rebase and push again, I can't automatically merge right now. Please let me know when you do.\n. thanks @adiel!\n. Yeah, it's old code that's been around a long time. That being said, #parse is meant to extract the amount from stuff like \"$100.00\" or \"100 USD\", not \"foo\". Others that have looked for similar things in the past have gone with scrubbing their own data. Perhaps something like this:\n``` ruby\ndef scrub_money_string(str, currency = Money.default_currency)\n  n = Integer(str)\n  Money.new(n, currency)\nrescue\n  return nil # or you could raise your own exception here\nend\n``\n. If you work for money long enough, you'll know that keeping values in their fractional form is much better than float. So, that is whyMoney.newaccepts the fractional unit (commonly called cents). If you want to pass in \"100.20\" and have us assume it's one hundred dollars and twenty cents instead of 100.2 cents, useMoney.from_numeric(100.20, :usd)or100.20.to_money(:usd). You can find this and much more in [our documentation](http://rubydoc.info/gems/money/5.0.0/frames).\n. Actually, that's common only for non-financial rounding. Since we're working with financial calculations, we use [Bankers Rounding](https://en.wikipedia.org/wiki/Rounding#Round_half_to_even). If you want to change your system, look atMoney.rounding_modewhich accepts any mode thatBigDecimalsupports.\n. @vanboom: no problem! :smile: \n. I'm going to assume you mean default totrueas it's alreadyfalse`. No, you cannot do this globally via the gem. But you could write a helper method\nruby\ndef no_cents(n)\n  n.format(no_cents_if_whole: true)\nend\n. @acesuares: you probably want to open a issue on money-rails then.\n. Is it implied that the \".\" in \"10.000\" is a thousands separator?\n. So the problem is in the #extract_cents method. Feel like taking a crack at it?\n. No problem. Anyone else fell free to pick this up.\n. Hey @muxcmux,\nThe problem we're trying to fix here is that when parsing a string, it should respect the given currencies rules for decimal markers and thousands separators and not try to second guess it.\n. I always have a hard time deciding what to do here.\nAnyone @RubyMoney/money-devs @RubyMoney/money-admins care to weigh in?\n. Please figure out why this is failing with ruby-1.9.2-p320 and fix. Thanks for the patch!\n. Thanks for the patch @klevo, sorry I didn't merge it sooner. You now have a commit bit on the repo.\n. @mastooo: This has been talked about a lot, but we've never come away with a good solution. If you have one, please let us know.\n. That's about the best idea I've had so far too.\n. Feel free to submit a patch to correct this.\n. Does this look right to you? https://github.com/RubyMoney/money/blob/master/config/currency_iso.json#L2302\n. Thanks @mzahir.\n. This is working fine for me with a fresh rails project. Can you link your Gemfile here so we can see if there's a conflict somewhere? It appears that you're not able to load the currencies JSON file that is part of the project. I wonder if this has something to do with RVM gemsets.\n. @quasor: I believe the problem is money needs a json gem, so if you don't have one loaded already it uses the default json builtin (or gem for 1.8.7). But if you then try and load an alternate json implementation things get wonky. So best way to fix this is load your alternate json first.\n. Thanks for the pull request @cathper. You should now have commit rights to the repo.\n. @cathper: Could you update the currency section in the README to include exponent? No need for a PR, you can edit it directly.\n. @cathper: danke\n. I don't have a problem with adding Money#to_i (which would be an alias of Money#cents). I wonder though, is there a better way? Have you looked at using our money-rails gem? Does it have the same issue?\n. @bcobb: Yes. That would be great. I want to thank you in advance for doing all the hard work of tracking this problem down and looking for a solution. It's just great!\n. @kirillian: No problem. Thanks for looping back into this. Please add documentation to the #format method describing the new :precision. Also please add a brief note to the CHANGELOG. Then we'll be all set to merge!\n. Please reopen when you've updated this PR.\n. If you rewrite/rename the method as I showed on the comment, this should be reasonably performant. You'll also need to add some tests to verify it's functionality.\n. oh, and thanks for working on this @cathper!\n. Thanks for merging @cathper!\n. Please update the changelog and add documentation to the #format method. Thanks!\n. When you do let me know and I'll merge this.\n. @dougdroper: Thanks! Look like you need to do a git pull --rebase upstream/master (or however you like) to sync yourself with master, then I'll be able to merge.\n. Thanks @dougdroper and @seddy. You now both have commit rights to the repo.\n. We have automated ways to output these correctly already. However, trying to guess which way input is meant to understood is a huge pain. You're more than welcome to try, but most users (including myself) have found it easier to just write our own input adapters depending on what weird data vendors send to us.\n. We don't want to break existing implementations, so it's probably best to add the Rate class and mix it in yourself. However, I would be more than happy to include this if you can come up with a way to mix it in with a configuration option so it doesn't break old apps.\n. @alup could you shed any light on this?\n. Hi @Exoth, @alup has fixed the problem and I've merged it into master.\n. @alup: Sure. Have I given you rights yet to cut a release?\n. @alup: You should now have the ability to cut a release. Tag the code, bump version, etc. Let me know if you need anything.\n. Thanks for the fix @alup!\n. You'd need to add a new formatting option or keep doing it as you are :smile: \n. You should now have commit rights to the repo too @groe! Thanks for your help.\n. Excellent! Thanks for your contribution.\n. @driv3r: somehow I missed this earlier, sorry. The problem with the way Ruby coerces objects is that in this example, Money.new(5) would attempt to be coerced to an Integer. It is much safer to be explicit and only add Money objects to each other.\n. Thanks for responding to this @alup. Had I gotten to it first it would have been immediately closed.\n@ollym We work on this in our free time and don't have the time to answer questions addressed to us in this manner. Next time take a look at the authors of the projects you use before writing in like this. Well over half of the contributors to this gem are not American. The original maintainers were not. We have always struggled to make this an international gem and comments like this are not taken lightly.\n. Our prior suggestions is to write a helper method like def formatted_money(money) that calls money.format(...) for you. You other option is to monkey-patch Money#to_s for your own code, but that isn't the safest way of going things. We can't change the way #to_s currently works for backwards compatibility (nor do I think we want to). I'd be willing to entertain other ideas though.\n. > Unfortunately I'm not willing to leave object oriented programming behind and go back to functional programming. There is no incentive to use the money gem if I can reprogram it in helpers (because in that case Integers would be an as-good replacement for the gem ;).\nWe could always use a presenter instead. Composition FTW. :smile: \nRegardless, I think you have a valid point on moving some code from money-rails into money to handle this rather common case. @halo will you take the lead on that?\n. @halo that looks reasonable to me, what do you think @alup?\nIt's high time Money got a proper configuration setup.\n. @ollym: We actively choose not to accept anything other than Integer in #new because Float can lose it's precision when being converted. If you must use Float, you can do: 12.0.to_money(:EUR) #=> #<Money fractional:1200 currency:EUR>\n. thanks @frankmt \n. Any chance you could write me a script (or failing test) that has this same error? It's hard to follow without knowing exactly what everything is and being able to inspect it myself.\n. Excellent! Showers work miracles!\n. Thanks!\n. thanks!\n. @geehsien this sounds great. If you create the PR I'll merge it an give you commit rights. Remember to follow the Contribution Guidelines to help me out. :smile: \n. Thanks again @geehsien! You now have commit rights! :smile: \n. Thanks!\n. @dnl: I can merge this once it's passing on rbx.\n. @dnl you should now have commit rights. Thanks!\n. please submit a pull request (see the contribution guidelines) and I'll merge right away.\n. By dividing by 12 and not 12.0 you're implying integer division which truncates instead of rounds. Use 12.0 and you'll get what you're looking for: Money.new(980) / 12.0 => #<Money fractional:82 currency:USD>\n. Thanks @radar. You now have commit access to the project.\n. @ddrscott: thanks for the patch. You now have your commit bit.\n. @Exoth: My bad for not looking into each of those. Please remove them with a PR.\n. Right, and we shouldn't maintain any currencies that were never valid.\n- shane\n  On May 21, 2013 at 1:42:32 AM, Exoth (notifications@github.com) wrote:\n  So what rule should be used? \u0441urrency.json should contain only actively used at the moment ISO currencies and currency_bc.json should contain not actively used ISO currencies?\n  \u2014\u2028Reply to this email directly or view it on GitHub.\ufffc\n. > If some one can exchange it, the Gem should be able to display it.\nI can exchange my miners chips at the company store, does that mean the Gem should display them? I think saying someone can exchange the currency somewhere is too broad a definition. We've always followed that currencies must have an ISO code to be maintained.\nThat being said, I'm fine supporting non-ISO currencies either in an optionally loaded config/currency_additional or in a separate extension gem. As someone who doesn't work with the alternative currencies, I'll give everyone a chance to voice their opinion.\nCome Friday I will act to change these one way or the other.\n. I can get down with that.\n. done with d7dfc1005719a8716dd95316405bebb3c67595e8\n. Nah, they're actually defunct and only kept for backwards compatibility. I might even remove them when 6.0 releases.\n. closing since there's been no movement on this issue.\n. Yeah, this is one where we can't break people's code, and I'm sure someone somewhere is using this and will break. It seems dirty, but we should probably add a new option.\n. That's the best I've got. We really need a more customizable Decorator for this type of thing.\n. Closing due to inactivity.\n. @bhoggard: Double checking, but isn't the Euro format of using decimal for thousands separator vs decimal mark dependent on region?\n. @RubyMoney/money-devs could anyone else over in the Euro zone review  this? I'm ready to merge unless I hear there's a problem.\n. Hey guys, how about trying what @semaperepelitsa suggested and adding an optional locale argument to help parsing?\n. I'm up for anything. @RubyMoney/money-devs give me your :+1: or :-1: on each plan.\n. The only problem I see with this approach is we'll break backwards compatibility if we suddenly treat 6.000 as 6000 and not 6.\n. That sounds reasonable. Thoughts?\n- shane\nOn Tuesday, April 23, 2013 at 6:07 PM, Daniel Sherson wrote:\n\nPerhaps there needs to be a way to force the parser to assume various things.  \n\u2014\nReply to this email directly or view it on GitHub (https://github.com/RubyMoney/money/pull/276#issuecomment-16889806).\n. I'd love to see Money v6 do something like this. \n- shane\n\nOn Tuesday, April 23, 2013 at 11:13 PM, Tim Evans wrote:\n\nIMO, this should use ISO locales like Carmen does. The MSDN link I posted covers a few corner cases and illustrates that formatting should not be composed with the currency- in fact, they seem to be orthogonal problems. That means the correct solution is to supply a currency + locale to Money when formatting. And possibly having a top level configuration parameter so this doesn't cause any backwards compatibility issues.\nAn example of how users might use this might be the following:\nMoney.locale = \"en_US\" cash_money = Money.new(50_000_00, \"USD\") cash_money.format # => $50,000.00 cash_money.format(locale: \"fr_FR\") # => 50.000,00$ Money.parse(\"$50.000,00\") # =>  Money.parse(\"$50.000,00\", \"USD\", \"fr_FR\") # =>  \n\u2014\nReply to this email directly or view it on GitHub (https://github.com/RubyMoney/money/pull/276#issuecomment-16905911).\n. Anyone willing to setup and implement something like this? Also, in 6.x we can break things. So if there are rough edges that need to be removed, speak up now.\n. Closing due to inactivity.\n. I was an intentional bug fix. Since it was a bug fix we did not increment the major version, as this wasn't a breaking change (in our view) but a minor change to patch a bug.\n. @aripollak: Just added it.\n. Thanks!\n. Thanks @cbrunsdon!\n. @SergXIIIth I think you want to open this on http://github.com/RubyMoney/money-rails\n. what ruby version?\n. @nambrot what is the correct currency for this?\n. @nambrot those unicode codes appear to be for http://codepoints.net/U+FFE2 and http://codepoints.net/U+FFAC, neither of which are the EURO symbol (which is \\U+20AC). My guess is that's your problem.\n. I'm not sure, I'm using iterm2 connecting to a ubuntu vm via vmware and vagrant and I can paste \"\u20ac\" with no issue...\n. We've talked multiple times about having a generic representation of 0 that doesn't have a currency, but every time someone proposes it, they never follow through with the work. If you're willing to write the patch, I'll review and merge.\n. Yes. It's not ideal, but we keep it around for backwards comparability. I personally avoid #parse and write my own parsing methods as needed. \n- shane\n\nOn Tuesday, June 18, 2013 at 8:24 PM, EddyKang wrote:\n\nUsing the latest version (5.1.1), I came across a bug with Money.parse where it was returning me an incorrect value. I was more expecting an error.\n[3] pry(main)> prices = \"Adv $17, DoS $19, Door $21, Mezz $27\" => \"Adv $17, DoS $19, Door $21, Mezz $27\" [4] pry(main)> Money.parse(prices) => # [5] pry(main)> Money.parse(prices).format => \"$17,192,127.00\"  \nIs this behavior expected?\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/RubyMoney/money/issues/283).\n. Agreed\n- shane\n\nOn Tuesday, June 18, 2013 at 10:19 PM, Ryan Bigg wrote:\n\nI really don't think Money.parse should be responsible for parsing strings like that. What you should be doing is splitting out the amounts and parsing them through Money.parse instead.\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/RubyMoney/money/issues/283#issuecomment-19658400).\n. I'd love to see this in a Pull Request.\u00a0\n- shane\n\nOn Thu, Jun 27, 2013 at 2:22 PM, Exoth notifications@github.com wrote:\n\nIn my application I need to output translated currency names. So I extended the Currency model to return other than English names from I18n yml files by ISO code in case use_i18n is enabled, and filled the yml file by the parsed data from Wikipedia.\nSo I think that it would be great if this functionality is in the Money gem itself. Like we can extract currency names from the currency.json file and put them in en.yml and then fill some other locales.\nDo you think it's going to be helpful? If so, I'll make a pull request for this functionality. Otherwise, I'll put it in a separate gem, which is going to extend the Currency model.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/287\n. Quite honestly, Money.parse just isn't that good. You could try and tweak it with a PR, but most user roll their own parsing.\n. Money#new takes an amount of cents. #to_money assumes you're passing a dollar/cents value.\n. @NARKOZ could you write a patch to check for nil symbols? If not, I can probably get to it this weekend.\n. thanks @bjones \n. Money.parse is not a reliable method for figuring out currencies. It's much better to roll your own parse method. We're toying with the idea of depreciating and then removing the .parse method.\n. @jan it's also the source of 95% of all bugs and support requests in money. It only works randomly at best. It's much easier to write your own parsing method, knowing exactly what kind of input you're dealing with.\n\nAs much as I don't like removing features, this had to be done to protect everyone from potentially unseen miscalculations.\n. Hi @gustavolobo. Looks like you're not correctly composing your money object. Here's our old documentation for doing it that way in the 2.3 days.\nruby\ncomposed_of :price,\n  :class_name => \"Money\",\n  :mapping => [%w(cents cents), %w(currency currency_as_string)],\n  :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) }\nIn 3.0.3+ it's expected you compose your money object as seen here: https://github.com/RubyMoney/money/wiki/Ruby-on-Rails-%28Money.gem-3.0.3-and-later%29\nThat being said, the true way to work with money and rails together is to use the money-rails gem.\n. I try to avoid mentioning .new_with_amount in the README because I'd much prefer users to use .new which is a much more safe and understandable way to create the money object. That being said, if the API docs aren't clear enough yet, please submit a pull request that updates the docs here.\n. Since it's not a commonly used feature it's only in the API docs. We link to those right near the top of the readme. Outside of putting that documentation in the readme, could we have done anything else to direct you to the API docs?\n- shane\nOn Tue, Jul 30, 2013 at 11:03 AM, S\u00e9bastien Grosjean\nnotifications@github.com wrote:\n\nThanks for the quick reply. My biggest issue was actually due to a bug in money-rails: https://github.com/RubyMoney/money-rails/pull/120\nI think a note in the ReadMe would have saved me 1-2 hours but it's only my 2 cents feedback ;-) Once looking into the API doc, it's clear what new_with_amount does so do not think it need any change on this side.\nThanks again for the quick reply.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/295#issuecomment-21796744\n. thanks @bjones \n. If you could just do me one quick favor and edit the CHANGELOG for fix I'll merge this right in. Thanks!\n. Thanks @asellitt and @orien!\n. Thanks!\n. I agree with @marcoow that his solution would be preferred. This should be an extension most definitely. I'd have not problem rolling it under the RubyMoney org though to make sure it gets love from the community.\n. @yinquanteo yeah.\n. Thanks for the patch @alex-ross. And thanks to @asellitt and @mdi for chiming in and merging!\n. @rmustafin thanks! If you would like it transferred underneath the RubyMoney org too, let us know.\n. :-1: Money has always been immutable by design. I'm not too keen on breaking that to avoid writing x =.\n\nThat being said, if there's a strong desire in the community to break that tradition please speak up.\n. This was probably acceptable duplication for the sake of clarity. We try not to condense if/else/end just to try and trick Code Climate. Usually, when you want to remove duplication from Code Climate, you should be extracting methods, not changing structure. What to try again?\n. Hey Tien. I think you're right this still needs to be refactored. I have an idea and will toss it up here tomorrow when I have my laptop to discuss with you.\u00a0\n- shane\nOn Sat, Aug 17, 2013 at 9:28 AM, Tien Nguyen notifications@github.com\nwrote:\n\nTotally agreed with you that refactoring is not just for tricking Code Climate. I mentioned codeclimate is just an example. Isn't the new structure clear, I personally prefer *short ? cc/ @semmons99\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/304#issuecomment-22811855\n. @viettienn I'm going to take the discussion over on @ohthatjames PR\n. This makes sense, but the prior if/else/end was much easier to read. Please change that back from the enormus ... unless ....\n. Thanks. Just need to do a couple things per the contribution guidelines.\n- Add yourself to the AUTHORS file\n- Update the CHANGELOG\n. merged!\n. @ohthatjames @viettienn :point_up:\n. That's up to you. It's a little easier to develop on RubyMoney/money than a fork.\u00a0\n\n- shane\nOn Wed, Aug 21, 2013 at 11:17 PM, Tien Nguyen notifications@github.com\nwrote:\n\n+1 for creating a new PR for these refactoring. BTW, in the future should I create new branch in my forked repo or I can create new branch from RubyMoney/money ? @semmons99\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/306#issuecomment-23065997\n. That is how infinite precision should be working. Could you write a failing test so we can track it down?\n. @JoeStanton did this fix your situation?\n. awesome :+1:\n. as_d is just shorthand for us the create a big decimal, it shouldn't be a public interface.\n. My biggest worry here is backwards compatibility. What happens to users expecting floats?\n. I'd welcome a patch that included post install messaging and an update to the readme.\u00a0\n\n```\nI'll blog about it too\n\nshane\n```\n\nOn Mon, Sep 2, 2013 at 3:01 PM, Orien Madgwick notifications@github.com\nwrote:\n\nThat's a valid concern @semmons99. This changes the post conditions of the methods in question and shouldn't be taken lightly. The money gem is used by vast community and this change may cause some applications to behave unexpectedly. Given this, we have a duty of care to provide, so we should take every opportunity to warn clients of this change. Potential methods to achieve this are:\n- a migration guide on the site and/or readme document\n- a post deploy message\n  This is a lot of effort to go through but I believe it will be worth it. This change has the possibility to fix subtle defects in existing client applications. While for new applications using the Money gem, it promotes the more healthy behaviour of using BigDecimals for monetary values. Thus, avoiding a whole class of errors and the associated pain for developers. Developing in Ruby will be even more awesome!\n\nReply to this email directly or view it on GitHub:\n  https://github.com/RubyMoney/money/pull/311#issuecomment-23674557\n. We should probably put a fancy red alert message at the top to check out the migration notes too. Other than that, it looks great.\n. Looks good. Merging.\n. @orien I've released 6.0.0.pre3 this morning. Please help me to remember to release 6.0.0 proper next week.\n. Thanks!\n. @lucasrenan sorry, but .parse is scheduled for removal just for reasons like this. We won't be patching it.\n\nI personally have stopped using .parse a couple years ago due to all the potential edge cases.\n. excellent!\n. Good catch, thanks. Could you please check that you've done everything listed here: https://github.com/RubyMoney/money/blob/master/CONTRIBUTING.md\nOnce you have, I'll merge the PR.\n. merged!\n. You'll need to document the new option in the method documentation. You'll also need to rebase on master since I merged your other commit.\n. Good point. Perhaps we should allow user to format their own objects if they want rounded infinite precision.\n. @fklingler let me know when you have the error fixed\n. Thanks!\n. You're welcome to patch that. In all our years, we've never had anyone try to create a money object for another money object :smile: \n. @keithpitt right. If you pass a value that's already a Money object, it should just return that same object.\n. Yeah, for now it can be a copy.\u00a0\n- shane\nOn Thu, Sep 19, 2013 at 9:44 AM, Brian Jones notifications@github.com\nwrote:\n\nNot sure about same object, shouldn't it behave as a copy constructor if\nyou do this?\nOn Wed, Sep 18, 2013 at 8:32 PM, Shane Emmons notifications@github.comwrote:\n\n@keithpitt https://github.com/keithpitt right. If you pass a value\nthat's already a Money object, it should just return that same object.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/issues/318#issuecomment-24710006\n.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/318#issuecomment-24739388\n. Please follow the contribution guidelines. Then I can merge.\n\n\nhttps://github.com/RubyMoney/money/blob/master/CONTRIBUTING.md\n. I'd welcome a patch. If you don't have an exchange rate defined, it will error right now.\n. Please update the CHANGELOG too.\n. Feel free to patch.\u00a0\n- shane\nOn Wed, Sep 25, 2013 at 5:56 AM, Andreas Neuhaus notifications@github.com\nwrote:\n\nAccordingly to https://en.bitcoin.it/wiki/Satoshi and http://en.wikipedia.org/wiki/Bitcoin, 1 BTC equals 100_000_000 Satoshi, but RubyMoney currently uses 10_000_000 for subunit_to_unit.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/322\n. Thanks @ticean \n. Ruby's builtin coercion is changing the right hand side to a money object, and #to_money is depreciated.\n\nAny chance you could work on creating a better error for this?\n. Awesome! You rock! :metal: \n. @joshhepworth could you check contributing and make sure you've covered all your bases?\n. just pushed 6.0.0.pre5 with your commit\n. very cool. merged!\n. @asok your build failed because you used 1.9 hash syntax, but we still support 1.8.7. Please use the good old hashrocket syntax. Also, when you do patch the change, please make sure you still end up with a single commit :smile: \n. @asok still failing on 1.8.7. You may want to make RATE_FORMATS a proper object.\n. @asok not a fan of Monkey Patching Hash just so we can avoid an if statement.\n. and so it shall be. I still consider you a contributor though :smile: \n. @jegz there is not. There are some defaults you can set, but not all. A number of users have created a proxy method that they always call that has their formatting defaults.\nI'd definitely entertain a patch that setup a way to do default formatting.\n. Sorry, we now only support arithmetic between money objects. $100 + 0 monkeys is undefined.\n. @chatgris minor suggestion. Also, please check out the contribution guidelines in the root of the repo.\nCurious, what kind of objects are you creating that inherit from Money?\n. Interesting. I would have used composition for that work, but inheritance does the job too.\n. @Silex have you tried any of the 6.0.0 pre releases?\n. We're close (as in later today or tomorrow) or releasing 6.0.0\n. Is there something I'm missing in this Gem? I'm pretty sure you just need to upgrade to google_currency 3.0.0\n. Forking google_currency and trying to give it a lower version of money is probably your only option since money does not support 1.8.7 any longer.\n. @zubin I take that back. I'm about to release money 6.0.0 which support 1.8.7. I'll then release 3.1.0 which will support money 6.0.0 and you should be all set.\n. @zubin money 6.0.0 is now released along with google_currency 3.1.0\nPlease create a new issue if you have any problems with either.\n. Thanks!\n- shane\nOn Thu, Nov 7, 2013 at 4:46 PM, Orien Madgwick notifications@github.com\nwrote:\n\nCongratulations on the releases @semmons99!\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/332#issuecomment-28009660\n. Great catch, could you submit a patch?\n. Instead of a global variable, I'd set a class instance variable on Money. Then we don't need to be moving the file around.\n. Please reopen when you've addressed the issue(s).\n. This may be specific to Spain, but most likely not all Spanish speaking countries.\u00a0\n- shane\n\nOn Mon, Nov 11, 2013 at 2:24 AM, Exoth notifications@github.com wrote:\n\nMy site was sent to a translator for check, and he says, that in Spanish instead of \u20ac534 we should write 534 \u20ac\nSo I guess that this is a global rule for the Spanish language that the currency sign should go after the number delimited with a space. As I see, there's a custom Japanese rule defined in localize_formatting_rules, so the Spanish rule could be defined there in the same way. Can anyone Spanish speaking confirm that this rule is right and global?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/336\n. I'll play with this later today. I still don't find it ideal. It's a good start though and a valid issue.\n. Sorry, this fell off of my radar. I will pick it up in the morning.\n. I haven't found anything I'm happy with quite yet. I will try again this week though.\n. @brianphillips fixed in master\n. pretty much your exact patch. Thanks for the initial work\n. sorry it took so long\n. try gem \"money\", :github => \"RubyMoney/money\"\n\nalso, please post the actual deprecation you're getting.\n. Hi @jescalante. Try the latest master. I believe I've fixed your issue. If not, please reopen.\n. You are right, I hadn't pushed it yet.\n. gem \"money\", :github => \"RubyMoney/money\" should do the trick\n. :clap: horray! :clap: Thanks for reporting the issue.\n. @imton any chance you could give us an example where you're getting this with the money library?\n. @imton okay, this looks like you actually have an issue with RubyMoney/money-rails, not the money gem. You should open an issue there.\n. Okay. I finally understand what you're asking. Just use .to_f\nBTC is unique for having the giant subunit. Other currencies always display the full subunit so as to not be ambiguous. \n. You shouldn't if you're not doing any calculations after the fact. But I just remembered we now report the BigDecimal value back to you when you call #dollars.\nSo, how about this?\nruby\nn = Money.new(100, \"BTC\") #=> #<Money fractional:100 currency:BTC>\nn.format #=> \"B\u20e60.00000100\"\nn.dollars.to_s(\"F\") #=> \"0.000001\"\n. Feel free to submit a patch that adds the option to #format. Provided it doesn't harm any other methods or options I have no objection.\n. It shouldn't be too bad.\n. Sorry @shawndeprey we actually recently pulled this type of parsing out. It was unwieldy and always ended up being specific to a single developers codebase than generally useful.\n. Please make that one tweak then read CONTRIBUTING.md and make sure everything is square there.\n. @jlecour awesome work. Please tweak this to work for Ruby 1.8.7 (see TravisCI failure) and make sure you've done everything on the Contributing Guidelines.\nOnce that's taken care of, I'll happily merge.\n. Please reread the notes section of the contributing guidelines.\n. @jlecour no worries. Thanks for the patch! :smile: \n. I have no problem if someone wants to take this on and submit a patch.\n. Closing, please reopen if you're actively working on this.\n. @ohthatjames do you have more suggestions?\n. @hadees reopened\n. I believe you're looking for @yard, @yardparam and @yardreturn http://rubydoc.info/gems/yard/file/docs/Tags.md#yield\n. looks good\n. @ohthatjames it would be nice to have the nested blocks issue fixed, but I don't think it's something that's high priority.\n. You're converting between money's internal BigDecimal and Floats, this will not yield the same results.\n. Ah, sorry. I didn't understand your question. If you look at the implementation of VariableExchangeBank it contains it's own rounding method. You can either specify one, or write another bank. VariableExchangeBank is really just a sample. Most users don't use it in production and instead use more robust banks.\nI'd gladly take patches to fix anything you see wrong with it.\n. > Alternatively, should I be instantiating another Money object every time I want to use the comparison operators?\nYes. String#to_money will be removed, unlike the other deprecation warnings which warn that you'll just have to require the extensions manually.\n. @Robsteranium ah, now I think I understand what you're saying. In money 6.1, this will be broken unless core extensions are required, or in the case of String.to_money won't work at all. What suggestions do you have?\n. We have a branch labelled 6.1.0 that removes all the warnings. I'll be releasing the first beta on Monday.\n. /cc @RubyMoney/money-devs \n. @RubyMoney just an FYI to everyone. I've released the monetize gem and patched the money gem to use it. In the 6.1.x series, we will have removed all the parsing code from money into monetize.\n. @lassebunk mind submitting a patch for that?\n. Could you check why the build is failing for 1.8.7 too please?\n. don't worry about 1.8.7, I've stopped testing on it.\n. Thanks for the patch!\n. @saurabhnanda what if we update all the methods that use a mutex to taken an optional parameter, :without_mutex? Then, when another higher-level function needs to wrap a number of these calls in a mutex, it can do so.\n. here's my proposed change: https://github.com/RubyMoney/money/pull/351\n. perhaps we only need a mutex around the updating of rates?\n. I don't know if ruby has these capabilities.\u00a0- shane\nOn Wed, Jan 8, 2014 at 1:11 AM, Saurabh Nanda notifications@github.com\nwrote:\n\nBut how can we implement the following: all reads are non-blocking, except when some thread is updating the rates. This might mean using some underlying MVCC features, which Ruby doesn't provide out of the box. IIRC this is exactly how Postgres handles concurrency without unnecessarily blocking.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/350#issuecomment-31808310\n. closing since nothing has been done in 1 month.\n. That's excellent. Please let us know if you'd like it hosted under the RubyMoney org (you'd still be the owner, etc). Also, feel free to submit a PR to the README.md to add it.\n. So, we can easily make the mutex public. But, is there something would could add to the API to make thread-safety less of a developer chore?\n. /cc @RubyMoney/money-devs \n. I'm wondering if Ruby has the concurrency mechanisms we're looking for. Do banks require us to pull in another dependency to get better threading support?\n. would someone like to implement this idea as a pull request?\n. I'm going to merge this to get us some more primitives, but please, let's continue exploring this topic.\n. Yes.\u00a0- shane\n\nOn Mon, Jan 6, 2014 at 1:35 AM, Saurabh Nanda notifications@github.com\nwrote:\n\nIs this the final API, then? Can I submit a PR for eu_central_bank based on this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/351#issuecomment-31630119\n. I just released 6.0.1.beta3 that contains this change.\n. discussing in #350 \n. Are you using GitHub master, or at least 6.0.1.beta3?\n. please try a beta\n. Have you tried the 6.1.0 beta at all?- shane\n\nOn Fri, Jan 31, 2014 at 12:11 PM, Chris notifications@github.com wrote:\n\nI think the issue is that requires money requires monetize/core_extensions before requiring the money/core_extensions/... which overwrite the monetize definitions.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/354#issuecomment-33821552\n. FYI, 6.1.0 is on master now.\n. There's quite a few deprecations that use monetize. Could you update them all?\n. We added the silencer option because people were complaining about the noise. Perhaps though, the silencer should be set in the monetize gem? Regardless, this currently can't be merged due to conflicts.\n. Excellent. :+1:\n. @ct-clearhaus looks like you have some failing specs.\n. #363 has been merged.\n. I've also merged 6.1.0 into master which may help clear everything up\n. Yes. I like this approach. \n. Passing a string is not a supported argument to new. It was deprecated in 6.0.x series. \n. Sorry, I misread the example. Sounds like a bug in format. Can you dig in and fix it?\n. Thanks @Zemanux \n. It probably doesn't hurt to set it to false.\u00a0- shane\n\nOn Thu, Feb 6, 2014 at 3:37 AM, Hakan Ensari notifications@github.com\nwrote:\n\nOne of my gems has a dependency on Money. Its tests have been emitting an I18n deprecation notice for a while. I have not looked into this in depth, but I know that setting the attribute to true, which apparently will be the default at some unspecified point in the future, results in the tests failing.\n[deprecated] I18n.enforce_available_locales will default to true in the future. If you really want to skip validation of your locale you can set I18n.enforce_available_locales = false to avoid this message.\nAny pointers on how to resolve this? Does this mean some work is required in the Money gem (hence, me posting here)?\nPS: Kudos on slimming the gem (format, etc.). You guys were so against such changes last year.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/366\n. Sounds like a gem pating problem to me, not something related to the gem. What OS, version of Ruby and Ruby version manager (if any) are you using?\n. I just successfully was able to install money and require it on a fresh Ruby 2.1 install w/ Ubuntu.\n. @cyzanfar unfortunately, this is an RVM issue and not something we can help you with. My suggestion, ditch RVM and try using ruby-install with chruby, or just using ruby-install and running a single version of Ruby. Sorry we can't help more.\n. Thanks!\n. You are correct. Could you please submit a pull request fixing this?\n. Thanks!\n. Thanks!\n. feel free to patch :smile: \n. Sounds like you've probably uncovered a MRI bug. Do you have a test we can run that always produces this?\n. @jgwmaxwell ping\n. closed due to no activity\n. thanks!\n. Send a PR and I'll merge\n. @tenoriocesar could you squash this into a single commit?\n. How would you compare without converting the currencies?\n. @clowder please let me know when this can be merged. Right now it has conflicts.\n. still can't merge automatically. Try rebasing against master. Also, please squash into a single commit.\n. :+1: \n. :+1: \n. Should be fixed now with 6.1.1.\n\nYou have a beta run for 2 months and no one finds the problem. Yes, you now must manually require Monetize.\n. In 6.0.0 we deprecated using Monetize directly in Money, stating that you must \"require 'monetize'\" in 6.1.x. I believe this is proper versioning.\n. That'd be awesome. Let us know how we can help. Is it simply adding a link in the README, or is there some integration points you need?\n. I'd like to avoid adding extra dependencies into Money (we've been aggressively removing even our own). However, I have no problem adding the API for you to hook into Money#format if maguire is required. Would you be willing to write that integration?\n. any progress?\n. closing, no progress in the last month.\n. Perhaps you could write a failing spec to show this?\n. Sorry, I meant submit a PR with a new failing test, not modifying an existing one. Any chance you could work on a fix?\n. closing as there's been no movement in 10 days\n. We already have Money.zero (an alias for Money.empty) if you want to create a money 0 value money object. It takes an optional currency too.\nhttp://rubydoc.info/gems/money/Money#empty-class_method\n. Nope. We'd expect you to extract the appropriate values from the hash and create a new Money object using our existing instantiation methods.\n. @optimator999 the money gem, by default, uses a round method known as banker's rounding (or round half even). Sounds like you're looking for a different rounding method. You can change it using the rounding_mode option. Check out the docs: http://rubydoc.info/gems/money/Money.rounding_mode\n. What about losing precision, should this first be rounded using the rounding_mode specified by the object? I'd expect the code to use that instead of to_d\n. Okay. Then instead of .to_i I'd create a whole_unit method that just returns the unit, dropping any subunits.\u00a0- shane\nOn Thu, Apr 24, 2014 at 5:33 PM, Pedro Nascimento\nnotifications@github.com wrote:\n\nShouldn't to_i ignore rounding? BigDecimal#to_i doesn't look like it uses the rounding mode when converting it to Integer.\nMy understanding is that I want the \"non-cents\" part. If I wanted to round it first, I'd to Money.new(100).round.to_i.\nI could add this to the documentation if you think it can be misleading.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/388#issuecomment-41335351\n. I really hate the #to_f method (even though I originally came to the project by implementing it). It let's you do bad things. That being said, if there's enough outcry for #to_i to be implemented, I'll allow it.\n. Alright, let's merge it!\n. I merged it, but would you mind adding information about it to the changelog?\n. Good catch. Could you try patching it?\n. Okay. So, if you're using i18n, the thought is you want everything output according to your definitions, not our guesses. Seems a fair default to me. Do you disagree, if so, is it worth breaking 1000's of apps to change?\n. Thanks for your thought behind this. It helps the project a lot to have people thinking about stuff like this.\n. :+1: \n. :metal: \n. If you check out the documentation for Money.new, it takes two optional arguments:\n\nruby\ndef initialize(obj, currency = Money.default_currency, bank = Money.default_bank)\nSo, you could pass an alternate bank which can be used by that instance of a Money object, while leaving the default bank for other instances. Make sense?\n. No problem!\n. You'll actually want to move this up into a # Master section as 6.1.0 (and 6.1.1) have already been released.\nIt would be really awesome if you could go back and figure out what was released in 6.1.1 and anything that's been committed since then.\n. awesome. Thank you!\n. :+1: \n. thanks @brixen \n. excellent. Thank you. If you could squash the commits I'll merge.\n. Awesome. Thank you!\n. @paulodiniz if you could please squash this into a single commit I'll merge it!\n. Those names are currency names. The problem is there isn't just one country associated with a given currency. You need to create a one-to-many relation with your code that maps currencies to countries.\nThis is out of the scope of the Gem, though we could fold anything you make into the RubyMoney project to be maintained, etc.\n. Yes. If you can make it more robust I have no problem including it.\u00a0- shane\nOn Wed, May 28, 2014 at 5:17 PM, Cyle Hunter notifications@github.com\nwrote:\n\nHmm, well I made a fork with an updated JSON file that includes an additional field containing the main ISO 3166 Code associated for any given currency. I now see what you mean now with some countries using more than one currency - this wiki article nicely summarizes this. I don't think it would be difficult to extend what I have currently to accommodate this. For me, what I have is sufficient for my needs, but I don't mind putting in some extra work in to make something a little more robust if you think it adds value to your project.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/399#issuecomment-44465717\n. Not sure what your use case for invalidating all the settings are (all exchanges will break or produce invalid results); but why not use map?\n\nruby\nMoney::Currency.table = Money::Currency.table\n  .map { |code, currency| [code, currency.merge({:subunit_to_unit => 10000})] }\n  .to_h\n. Why not use the infinite precision option that money provides instead of changing the ratio of cents to dollars?\n. Currencies should be static. They shouldn't be changing while your app is running.\n. I guess I'm still just confused on what currency changes so often to not warrant a new release. Exchange rates make sense, but the underlying format of a currency?\n. wow, can't believe it took that long to catch this. Thanks!\n. thanks!\n. @fotos I'm not going to be able to get on this quickly. Could you even start a PR with your failing tests so we can move ahead from there?\n. I'm more of the opinion it's an error and you should convert before performing operations.\u00a0- shane\nOn Wed, Jun 18, 2014 at 8:26 PM, Pedro Nascimento\nnotifications@github.com wrote:\n\nI'd take a grip on this, but IMHO working with numbers and money objects is weird if you don't convert it. I would always expect 4 / Money.new(400) to return 1 but I believe we expect 0.01.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/404#issuecomment-46511161\n. What's everyone think of this solution: https://github.com/RubyMoney/money/pull/405\n\n@fotos does it pass all your specs?\n. What's everyone think about the additional specs added to #405, are we missing any? What about the addition of #<=> raising a TypeError?\n. /cc @RubyMoney/money-devs \n. bueller, anyone?\n. closing, no activity in 2+ months.\n. @calebthompson @lunks made some description changes, thoughts?\n. @fotos 2 * Money.new(2, 'USD') is allowed by this patch. Division is not commutative, 2/5 != 5/2.\nI'm going to take @ct-clearhaus and make sure our operations all pass those tests.\n. Yes, please. Let's start seeing some code and their resulting specs.\n. anyone?\n. Just call Money.new(1000).cents\n. Sorry, I misunderstood the initial issue. If you want to create a money object via whole units and not subunits, require the monetize library and do 1000.to_money\nshell\nirb(main):004:0> 1000.to_money(:INR)\n=> #<Money fractional:100000 currency:INR>\n. Why are you passing the decimal mark when it works by default?\nshell\nirb(main):001:0> require \"money\"\n=> true\nirb(main):002:0> Money.euro(12345678).format\n=> \"\u20ac123.456,78\"\n. Ah, so you format the currency based on the currencies signature and not the locale. Could you verify this isn't fixed in master? I feel like this has been addressed recently for some reason.\n. Could you submit a patch?\n. closing due to inactivity\n. Agreed. I think you're trying to twist the meaning of attributes which could lead to some gnarly code.\u00a0- shane\nOn Fri, Jul 18, 2014 at 9:05 AM, RKushnir notifications@github.com\nwrote:\n\nIt seems to me, you're mixing different concerns. You use currency: INR to identify that it belongs to India, as well as an indicator of the currency. There's a commercial exchange rate for USD to INR, but you also have some ratio that plays the role of exchange rate, and also acts as a discount value. \nWhy don't you just store all prices in single currency(e.g. USD) and have a country_id column and a discount column(which is default to 0)?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/409#issuecomment-49428135\n. It's not a bad idea. I'd expect it to be done inside the Money initializer. I have no problem protecting users, though they should sanitize their data :smile: \n. thanks!\n. So, someone is editing the internals of a money object? Would this affect any value if you're abusing the code in such a way? Should not every Money instance be frozen to avoid bad actors then?\n\nI'm not really against this, I'm more just wtf?! is someone doing to make this necessary?\n. I'd be okay with doing a >= 0.6.4 <= 0.7.whatever_it_is_now\n. feel free to submit a pr\n. This change is breaking tests. Please fix.\n. Please rebase against master and see if it's still failing\n. closed, no activity in over 10 days\n. CI is failing\n. Just fixed on master, can you rebase and verify it works?\n. please provide a log of an IRB session. I cannot follow this description right now.\n. closed, no activity in over 10 days\n. Feel free to submit a PR to fix this along with a reference article. Don't forget to follow the contribution guides when you submit the PR.\n. Please read the Contribution Guidelines, rebase and ping me. I'll merge.\n. perfecto!\n. sure thing!\n. closing, no activity in 2+ weeks\n. After two weeks I close any issue that hasn't been followed up on by the requester. I believe this one was completed in another PR though.\n. if someone would go through and replace should with expect I'd give them an internet hug or 5 shrute bucks\n. :metal:\n. If you look at the code, yen is in the legacy section. It's invalid but we had to leave it for apps who were/are using it.\u00a0- shane\nOn Fri, Aug 22, 2014 at 12:14 AM, ahpri notifications@github.com wrote:\n\nI'm confused on why there exist two currencies to represent Japanese Yen when there should be only one. They are :yen and :jpy when it really should be just :jpy.\n     class Price < ActiveRecord::Base\n        def self.all_currencies(hash)\n          hash.keys\n        end\n     end\nrails console --s  \nPrice.all_currencies(Money::Currency.table)\n=> [:aed, :afn, :all,................:jpy,.........:yen]\nI see they print differently though:\nyen = \u00a51,000\njpy = \u00a5100,000\nIs that just how the currency is over there?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/426\n. Have you gone through the docs? Looked at the infinite precision options...\n. We can't really just change the feature, too many libraries rely on it. You should instead make it an optional toggle. FYI, you need to rebase. This can't be merged.\n. \n\nChanging this has repercussions throughout all the existing exchange libraries. Simply adding a feature toggle that allows users to use round (perhaps a specific version of it like the actual Money object does) vs dumb to_i is a much more stable approach. Then, if we have an outcry of \"make the round toggle the default, we can do that in a major release\". With 2.5 million downloads, we can't break stuff without some serious thought and community buy in.\n. I'm totally not following this. What's the usage of this?\n. This sounds like something that should be implemented in a exchange extension, much like these: https://github.com/RubyMoney/money#implementations\n. 6.2.0 released\n. Is there a reason you can't specify something other than 0.7.0.beta1 in your own Gemfile?\n. I guess I don't see how if a user sets their rounding method to be BigDecimal::ROUND_DOWN 1.85 would be wrong. Are you saying everyone ever using this gem will always want to use one type of rounding when using your feature?\n. I'd be okay with the rounding method being defined by the currency.\u00a0- shane\nOn Wed, Sep 10, 2014 at 10:17 AM, tweymuth notifications@github.com\nwrote:\n\nI just had a look at the Wikipedia article on Swedish rounding. It appears that in Argentina, prices are always rounded down. That means we indeed have to use different rounding methods for different currencies. However, I still think that for this very feature, the rounding method is coupled to the currency and therefore does not have to be set by the user. What do you think about this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/433#issuecomment-55118243\n. :+1: thanks for taking the time to work with me and get this right!\n. just released 6.3.0 for you\n. thanks!\n. please follow the contribution guidelines and I'll be happy to merge\n. > When contributing, please make sure to update the CHANGELOG and AUTHORS files when you submit your pull request. Upon merging of your first pull request, you will be given commit access to the repository.\n. You'd have to examine the source to see how it actually works. Why not covert everything in the array to the same type first?\n. My guess, max/min is doing operations in a different order. I'll investigate tonight.\u00a0- shane\n\nOn Thu, Sep 18, 2014 at 4:17 PM, Jonathan Chambers\nnotifications@github.com wrote:\n\nYeah, unfortunately #max and #min are implemented in C code. Here's #max for instance:\nc\n/*\n *  call-seq:\n *     enum.max                   -> obj\n *     enum.max { |a, b| block }  -> obj\n *     enum.max(n)                -> obj\n *     enum.max(n) {|a,b| block } -> obj\n *\n *  Returns the object in _enum_ with the maximum value. The\n *  first form assumes all objects implement <code>Comparable</code>;\n *  the second uses the block to return <em>a <=> b</em>.\n *\n *     a = %w(albatross dog horse)\n *     a.max                                   #=> \"horse\"\n *     a.max { |a, b| a.length <=> b.length }  #=> \"albatross\"\n *\n *  If the +n+ argument is given, maximum +n+ elements are returned\n *  as an array.\n *\n *     a = %w[albatross dog horse]\n *     a.max(2)                                  #=> [\"dog\", \"horse\"]\n *     a.max(2) {|a, b| a.length <=> b.length }  #=> [\"horse\", \"albatross\"]\n */\nstatic VALUE\nenum_max(int argc, VALUE *argv, VALUE obj)\n{\n    NODE *memo = NEW_MEMO(Qundef, 0, 0);\n    VALUE result;\n    VALUE num;\n    rb_scan_args(argc, argv, \"01\", &num);\n    if (!NIL_P(num))\n       return nmin_run(obj, num, 0, 1);\n    if (rb_block_given_p()) {\n  rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)memo);\n    }\n    else {\n  rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)memo);\n    }\n    result = memo->u1.value;\n    if (result == Qundef) return Qnil;\n    return result;\n}\nfrom: https://github.com/ruby/ruby/blob/9b94249f39bff401465340639bed1f2a93b62ebf/enum.c\nI'm not familiar enough with Ruby's C code to really grasp what's going wrong. I do know this code is ultimately calling Money#<=> though, and that this method is working as expected.\nI agree it's no biggy, just to ensure the array is all Money objects before hand (that's how I'm working around it), it's just that this really caught me off guard because all the other comparison methods (>, ==, etc.) work fine with a mixture of Money objects and plain numbers. \nThe fact that #max and #min don't work as expected, definitely breaks the \"rule of least surprise\", which probably isn't a good thing when working with financial transactions!\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/436#issuecomment-56095842\n. I just checked Money.new(100) <=> 0 == 1 and 0 <=> Money.new(100) == 1 which makes it obvious that min/max runs the second version, and also that we need to get consensus on https://github.com/RubyMoney/money/pull/405\n. I'd be cool with a disambiguate option on format.\n. Seems like adding another column to the currency is the more flexible solution.\n. Please follow the guidelines in CONTRIUTING.md and squash into a single commit. Then I'll merge.\n. thanks!\n. The answer you're getting is correct. You're starting with $0.01USD and converting that using 0.01 * 10600 = 106 which is exactly what you're getting.\n. thanks!\n. thanks!\n. thanks!\n. https://github.com/RubyMoney/money/blob/master/money.gemspec#L28\n\nFeel free to submit a patch\n. :metal: \n. :metal: \n. Yes. Please do submit a PR. I'll close this and wait for the PR.\n. #453 will be merged, adding the synonym that is clearer would also be accepted\n. np\n. The legacy version of JPY in https://github.com/RubyMoney/money/blob/master/config/currency_backwards_compatible.json supports the older 1/100 conversion rate\n. Unfortunately I don't have personal experience in this particular scenario. I\u2019ll ask around though. Please do the same and let me know any results.\nOn Wed, Oct 22, 2014 at 1:34 AM, shpupti notifications@github.com wrote:\n\nHi Gabriel and Shane,\nin answer to Gabriel's question - the Google Play API returns a price in micro-cents along with an ISO4217 currency code.\nI think the issue I've been experiencing comes from a difference between \"banking currencies\" and \"real-world currencies\", where some local currencies no longer use their subunit in day to day life they are still considered a valid value in banking and foreign exchange systems.\nFor example the following data I got from the Google Play API: \"price\"=>\"\uffe5162\", \"price_amount_micros\"=>162000000, \"currency_code\"=>\"JPY\".\nHowever, my understanding of the all-around usage of the RubyMoney project is quite limited so I'd appreciate some advice regarding the best way to handle this conflict of definitions.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/450#issuecomment-60046765\n. I believe for now we should leave as is and allow the user to load the legacy currency as their situation demands.\n. They're just available to use, nothing fancy. Look at their label and use that to access then. For example the legacy jpy is yen.\n. squash into a single commit and I'll merge this right away\n. Currently CI is failing. I'd like to see the specs remain unchanged (or just add additional) too.\n. It's how I operate. I prefer to be explicit and do my conversions to a common currency before running comparisons.\n. You've got more than meets the eye here. The money gem by itself doesn't support converting Fixnums to Money objects. Formatting is also dependent on your locale. Finally, if you believe the - should precede the symbol, find supporting documentation and submit a PR changing the value for USD here: https://github.com/RubyMoney/money/blob/master/config/currency_iso.json#L2242\n. just released 6.4.0\n. please fix your build errors and ping me when you've pushed your branch back up\n. try that, should fix you\n. @newstler we'd just merged other patches that conflicted between the time you opened the PR and I got a chance to look at it.\n. Please squash into a single commit. I'll also wait to hear from @shpupti \n. I think you've hit the nail on the head. We need a digital_sub_unit added for these discrepancies.\n. two weeks, no activity. :-(\n\nclosing...\n. Thanks!\n. I'd love to see you open a PR that updates the README.md with a proposed policy. We can then discuss it.\n. Please submit a pull request. :-)\n. :metal: thank you!\n. discussion in PR\n. Couple problems.\n1. No Tests. Can't merge a new feature without tests.\n2. This breaks how the code works. It should be optional. Look at creating some type of global param that defaults to false to allow this. We can revisit with Money 7.0.0 if it begins to default to true.\n. I don't disagree with your code, but you can't break everyone who uses this libraries code without fair warning, which means we need a global param with a false default that can be swapped in 7.0.0\n. warning, after 10 days of inactivity this PR will be closed\n. 6.5.0 released\n. Feel free to submit a patch. \n. I don't see a PR for it. Was one ever submitted?\n. This is correct. The default rounding mode indicates how this is dealt with: https://github.com/RubyMoney/money/blob/master/lib/money/bank/variable_exchange.rb#L110\nYou can specify it as you see fit via params as you see in the code above.\n. Did you try master. Isn't it fixed?\n. If not, fix it.\n. yes, please update that as well\n. then let me know when you have\n. closing, two week no activity\n. I think the best place to start is better error messages. Will you tackle this?\n. @georgemillo it's been 3 weeks. Can we close this?\n. Great point! Could you create a wiki page with a \u201croad to 7.0.0\u201d wishlist? Even if it\u2019s only this change.\nOn Tue, Feb 3, 2015 at 9:58 AM, George Millo notifications@github.com\nwrote:\n\nFixed the Currency#all problem in #491.\nFor the others, I don't think a MissingAttributeError message is the right solution. When is anyone ever going to deliberately define a currency with no subunit_to_unit, for example? (Looking in currency_iso.json, I see that there are only two \"real-world\" currencies (the Mauritanian Ouguiya and the Malagasy Ariary) that have a subunit_to_unit value that isn't either 1 or 100).\nIt makes more sense to me if we make subunit_to_unit compulsory, although this would be a breaking change and require a major version number bump. And it's not exactly a big issue, so it's probably worth waiting until we have a bunch more breaking changes that we want to push, and putting them all in the same major version upgrade.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/479#issuecomment-72664317\n. For some reason CodeClimate won't integrate with GitHub right now.\n. Do we need the subunits for historical purposes? Do the major money exchanges ignore it now? Just need to double check stuff like xi and Google Exchange first please. \n. Sounds good.\u00a0\n- shane\n\nOn Wed, Jan 21, 2015 at 4:57 PM, Jason Hooper notifications@github.com\nwrote:\n\nNot sure about money exchanges practices. Where can I check or find out more? We have users in Iceland who have complained that we are showing minor units. They do not use them as per the link. The updated ISO data at http://www.currency-iso.org/dam/downloads/table_a1.xml reflects this.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/483#issuecomment-70930059\n. According to wikipedia there are no 1\u00a2 coins being circulated by banks for CAD. The subunit_to_unit is correct that it's split to 100, but the column you're referring to is for physical coins in circulation.\n. see answer in #484 \n. Thanks!\n. remember you can always have your Gemfile point to github\n. released to Rubygems\n. :rocket: \n. Why can't you use the Monetize gem which is intended for this purpose?\n. We purposely extracted this code out of money because it can be error prone and non-obvious. Perhaps you should look at how complicated it is to parse user input for currencies outside of usd. If you don't want to include a new gem, write your own \"3 line method.\"\n\nSpeaking to the entire group of contributors to this project like this is the reason projects are abandoned and maintainers leave. We work and share our time and talents and then get complaints from someone who hasn't even bothered to understand the full breadth of the issue; only focusing on their own personal single minded use case. We are not your personal unpaid workers. Next time you contact a project make sure you understand everything. Don't write to them like they're jackasses that owe you anything.\u00a0\nLet it be known, future posts from anyone in this tone will be autoclosed with a \ud83d\udc02 \ud83d\udca9 emoji only.\n. Sorry. These projects can really take it out of you. Monetize exists for this purpose and I don\u2019t see us pulling the functionality back into Money itself. Monetize is an extraction from Money, so you wouldn\u2019t be adding anymore code then was in your project pre-6.0.0\nOn Thu, Feb 5, 2015 at 8:56 AM, seongreen notifications@github.com\nwrote:\n\nGem Money should work with minimal unit and only with integer (BigDec) (no string float and other) to avoid collision and wrong work because people use this gem in real 'money' project. \nAlso old version < '5.0.0'  has not oblivious syntax.\n'100'.to_money     => return 100$\n Money.new(100)  => return 1$\nAll extensions of native classes with \"to_money\" and other methods moved to Monetize gem.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/493#issuecomment-73049324\n. Awesome thanks. \n. :rocket: \n. unfortunately this is part of money-rails. I see you have a question that no one has answered there. Have you tried stack overflow?\n. Thanks!\n. seems like a good candidate for a toggle if you're not using the feature.\n. Sorry, I thought I had.\n. yep\n. I believe you can pass an actual symbol vs a boolean, which is why it's using double negation. I believe it's why the CI run failed too.\n. See this PR. https://github.com/RubyMoney/money/pull/435\n. fixed\n. :metal:\n. Thanks!\n. I'd love for someone to take the mantle back up. I tried to fix this and couldn't get anyone to talk to me.\n. #405 was meant to address this but got no traction. I'd love someone to take up the mantle again.\n. Just an fyi. Monetize is code directly ripped out of money and put in it's own gem as an optional subset. If you need that functionality back, just include the gem, it will be no larger than it was before, and you'll continue to receive bug fixes.\n. Please add suggested test\n- shane\n\nOn Wed, May 6, 2015 at 3:52 PM, printercu notifications@github.com\nwrote:\n\nAlso .from_amount now respects rounding_mode\nYou can view, comment on, or merge this pull request online at:\n  https://github.com/RubyMoney/money/pull/510\n-- Commit Summary --\n- Less objects allocations in .from_amount\n  -- File Changes --\n  M lib/money/money.rb (4)\n  -- Patch Links --\n  https://github.com/RubyMoney/money/pull/510.patch\n  https://github.com/RubyMoney/money/pull/510.diff\n\nReply to this email directly or view it on GitHub:\n  https://github.com/RubyMoney/money/pull/510\n. Please update changelog before merging in the future. @mikerodrigues will you submit another PR with a changelog update?\n. Please update changelog, then I'll merge.\n. Can't merge, looks like you need to rebase first.\n. Great! Thank you for the hard work and thought put behind this. I only ask a couple things, please update the changelog and authors file and ensure the readme is up to date with these changes. Then I'll merge away.\n. I think you're right. We should just always be threadsafe (the option is from early Rails 2.x days). Everything you propose looks great too. I'll probably release this as 7.0.0 just in case there's some different behavior, but let's try and avoid it where we can.\n. This is great. I'm ready to merge if you are.\n. need a rebase before I can merge\n. Thanks for fixing this up!\n. Please update the changelog including links to the two issues then I'll merge. \n. The problem appears to be financial institutions still use the centavo in\ntheir calculations.\n- shane\n\nOn Sun, May 31, 2015 at 7:46 AM, Filipe Goncalves notifications@github.com\nwrote:\n\nIn CLP there are no centavos since 1984, check the tables from ISO 4217\nCLP Minor Unit: 0\nhttp://www.currency-iso.org/dam/downloads/table_a1.xls\nCLP. Decimal Operator: 0\nhttp://en.wikipedia.org/wiki/ISO_4217\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/RubyMoney/money/pull/519#issuecomment-107161315.\n. Should the Google currency gem override it then you think? Since Google pretends it still exists?\n- shane\n\nOn Sun, May 31, 2015 at 1:02 PM, Filipe Goncalves\nnotifications@github.com wrote:\n\nProbably there are many companies that simply put all currencies with 2 decimals, but I think we should keep with backward compatibility since this gem had CLP without cents for most of the time and to follow the ISO 4217 standard.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/519#issuecomment-107223575\n. @zkarpinski could you make a PR for google_currency that monkey patches the subunit for CLP? That way we don't affect others incorrectly.\n. As long as the process runs.\n. thanks, once the pr is updated I'll merge it\n. merginated\n. thanks!\n. Waiting for all my green lights, then I'll merge.\n. Yeah. Please provide more info as we're not able to reproduce locally or on CI.\n. Can you open another ticket and ping all collabs? Also, feel free to submit a PR that just does what you think it should :smile: \n. does this still need to remain open?\n. #to_money is not part of this gem. It is part of the https://github.com/RubyMoney/monetize\n\nYou're welcome to submit a PR to that project that respects the rounding mode. However, I'd suggest not using #to_money where possible, it's a crutch.\n. status?\n. Are you running the same version as Travis?\n. PR merged\n. thanks!\n. BAM!\n. Have you checked to make sure both support IDR? Some places do not.\n. This is not a money issue, It's an issue with the other gems which I've left open. Feel free to submit patches.\n. Please submit a patch and I'll merge it.\n. thanks!\n. I believe you can us i18n\u2019s irregular inflections config to update the plural.\nOn Mon, Jul 27, 2015 at 2:58 AM, Alex Popov notifications@github.com\nwrote:\n\nI would like to submit a PR for amending two things in currency_iso.json:\n- the symbol for BGN (Bulgarian Lev) must have a dot at the end: \u043b\u0432.;\n- the plural name of the subunit is stotinki, not stotinkas\n  While I can change the first directly in the file, where can I change the latter? Should I submit a direct PR to Rails? Thank you.\n\nReply to this email directly or view it on GitHub:\n  https://github.com/RubyMoney/money/issues/543\n. So that's specific to rails, you'd need to submit a patch here for just vanilla i18n. You could also submit a patch directly to Rails.\n. nice!\n. 6.6.1 released\n. I'm good with this. Let's merge and face wrath after you've updated the changelog.\n. Please make two pull requests. I won't merge the attr_accessor change without more info. I only use private attr_accessor, no instance variables. \n. @createdbypete just need to update the CHANGELOG.md file with what this change does.\n. Thanks!\n. thanks!\n. Excellent. I'd gladly fold this into the RubyMoney org if you like or you can submit a PR to update the README with a link to it.\n. Submit a PR to add those two currencies to the Money gem. You'll need to go to your settings of the project to transfer your repo the the RubyMoney org.\n. Things have been very active lately, so probably a couple weeks. Need to have people test master for a while.\n\nOn Wed, Sep 2, 2015 at 3:49 AM, Phlegx Systems OG\nnotifications@github.com wrote:\n\n@semmons99 when will a new release made?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/557#issuecomment-136966713\n. Thanks for catching this!\n. Thanks.\n. Thanks!\n. Seems like you could either use allocate to do this, or at least use allocate to do the work.\n. Thanks!\n. Thanks!\n. Hard Ruby problems with coercion. Please make your life easier and don't mix Money with other numerics. They're not equivalent and will give you a headache.\n. I think it's due to the subunit_to_unit value for bitcoin. It would be like displaying seventy cents as 0.7 for US dollars. It's not quite right. That being said. I'd accept a PR that included a new option to format to drop trailing zeros.\n. Thanks!\n. Yes. Let's split each issue into it's own PR. I agree we could merge the .zero? change right away.\n\nI'm pretty sure there are changes to protected methods in 2.3. I don't remember reading anything about private though.\n. thanks!\n. I'm okay with this PR. Should we wait for 2.3.0 to be released fully?\n. If you have two banks, why not just do\n``` ruby\nmoney = Money.new(...)\nmoney1 = bank1.exchange_with(money, :EUR)\nmoney2 = bank2.exchange_with(money, :EUR)\n```\n. thanks!\n. so, backwards compatible, but requires a major version bump since we changed an interface. Got it.\n. Would you mind submitting another PR (you can even merge it) that updates the changelog to mention the potentially breaking change?\n. I don't see a reason to stop supporting it unless new development is being hindered. \n- shane\n\nOn Dec 16, 2015, at 7:40 PM, takiy33 notifications@github.com wrote:\nRuby 1.9.3 has not been supported since 23 Feb 2015.\nSo, I think money gem finishes to support Ruby 1.9.3.\n@semmons99 What do you think about it?\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/RubyMoney/money/pull/586\nCommit Summary\nDrop support for Ruby 1.9.3\nFile Changes\nM .travis.yml (1)\nM CHANGELOG.md (1)\nPatch Links:\nhttps://github.com/RubyMoney/money/pull/586.patch\nhttps://github.com/RubyMoney/money/pull/586.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. thanks!\n. thanks again!\n. Thanks \n. No need\n- shane\nOn Dec 24, 2015, at 11:43 AM, Yura Tolstik notifications@github.com wrote:\nif you want I can write some tests for this case, but not sure if I should\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks \n. The plan is Jan 4\n. Please do. \n- shane\nOn Jan 3, 2016, at 7:50 AM, Tom Hale notifications@github.com wrote:\nI get I18n::InvalidLocale: :en is not a valid locale when trying to:\nMoneynew(1, :usd)format\nI found that setting:\nI18nenforce_available_locales = false\nremoved the error\nShould I update the README?\nFull error output:\nirb(main):003:0> Moneynew(1,:usd)format\nI18n::InvalidLocale: :en is not a valid locale\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/i18n-070/lib/i18nrb:284:in enforce_available_locales!'\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/i18n-070/lib/i18nrb:151:intranslate'\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/money-661/lib/money/money/formattingrb:17:in block in define_i18n_method'\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/money-661/lib/money/moneyrb:362:into_s'\n    from /home/ravi/rbenv/versions/223/lib/ruby/gems/220/gems/money-661/lib/money/money/formattingrb:239:in format'\n    from (irb):3\n    from /home/ravi/rbenv/versions/223/bin/irb:11:in'\nirb(main):004:0> \n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks\n. Thanks!\n. You don't want format in that case. It's meant to truncate. \n- shane\nOn Jan 6, 2016, at 8:03 AM, Tom Hale notifications@github.com wrote:\nFor currency trading, having lots of decimal places is a Good Thing\nHow do I use format to get an amount with an arbitrary number of decimal places?\nIt seems like it should be easy, but I couldn't find an example anywhere, or work it out from the code\n\u2014\nReply to this email directly or view it on GitHub.\n. Sounds like a new method or an enhancement to format. \n- shane\nOn Jan 6, 2016, at 8:05 AM, Tom Hale notifications@github.com wrote:\nAccording to wikipedia, in the EU, an amount should be printed in English as GBP 123:\nAccording however to the European Union's Publication Office,[5] in English, Irish, Latvian and Maltese texts, the ISO 4217 code is to be followed by a fixed space and the amount: a sum of EUR 30\nIs there a cleaner way to do this than:\nm = Moneynew('123', :gbp) # => #\nmformat( symbol: mcurrencyto_s + ' ') # => \"GBP 123\"\n\u2014\nReply to this email directly or view it on GitHub.\n. Why does the spec change. Seems like incorrect behavior. \n. Sounds like a JRuby issue or a float is being used somewhere it shouldn't. \n- shane\nOn Jan 16, 2016, at 12:30 PM, Laurent Arnoud notifications@github.com wrote:\nOn jruby the result is 2.9999999999999996 for this spec\n\u2014\nReply to this email directly or view it on GitHub.\n. That seems the more reasonable answer.\n- shane\nOn Jan 19, 2016, at 1:09 AM, printercu notifications@github.com wrote:\nSo should we better round exponent in #exponent method?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/RubyMoney/money/pull/601#issuecomment-172750814.\n. Looks good. Thanks for following through with this.\n. Thanks!\n. Thanks \n. worth a try\n. I've always personally be an advocate for any calculations and comparisons against a non-Money object throwing an error unless they're sensible like multiplication and division.\n- shane\nOn Jan 27, 2016, at 1:19 PM, Demian Ferreiro notifications@github.com wrote:\nHmm. I think i prefer the current behaviour of Money instances not being directly comparable with Numeric values. Although some_money > 0 seems reasonable to define, i think it's not very intuitive for Money instances to be comparable to some numeric values but not others.\nThe case when comparing with a literal 0 seems obvious, but if instead we were comparing against some other expression like make_discount if order_price >= min_order_price_to_make_discount i would like for that comparison to always raise an exception if min_order_price_to_make_discount has a bug and returns a number instead of a Money, not to silently pass because, for some reason, most of the time it returns 0.\nMoney already provides methods like zero?, nonzero?, positive? and negative?, which i think are clearer and more intuitive than asking a money instance how it compares against a bare number 0 \n\u2014\nReply to this email directly or view it on GitHub https://github.com/RubyMoney/money/issues/604#issuecomment-175780129.\n. This has always been very controversial. Please make sure you open a dialog around this.\n. We've had discussion before (and never resolution) if Money + something, regardless if it's zero or not should raise an exception. I'm okay merging #605 if everyone is happy w/ it. Just would like to get feedback. If we have no arguments, let's merge on Monday. Just ping me to remind me.\n. I like this. It makes the most sense to me. Merging. We'll probably need a major bump due to the changes, but I'm okay with that. @RubyMoney/money-devs could people give master a try? Maybe try this with money-rails too?\n. Seems to me money-rails should just provide a better validation helper then. \n- shane\nOn Jan 31, 2016, at 9:50 PM, printercu notifications@github.com wrote:\nThe only place i see where it'll be useful is\nvalidates_numericality_of :money_field, greater_than: 0, less_than: 100\nIn any other place it'll be comparison either with 0 or with magic numbers, which should better be replaced with money-object constants. And hope there will be no scenario when single non-zero numeric will be compared to multi-currency money. (do_something if money > 53 and money can be usd, cad or eur).\n\u2014\nReply to this email directly or view it on GitHub.\n. Awesome. Thank you!\n. no worries, thanks!\n. \n",
    "cimm": "I have the same problem but it seems to work if you add :allow_nil in your model.\ncomposed_of :price, :class_name => \"Money\", :mapping => [%w(cents cents), %w(currency currency)], :allow_nil => true\n. I have the same problem but it seems to work if you add :allow_nil in your model.\ncomposed_of :price, :class_name => \"Money\", :mapping => [%w(cents cents), %w(currency currency)], :allow_nil => true\n. ",
    "weppos": "Great!\nI updated the repository. Make sure to destroy/recreate the remote source if you already fetched it because I used a rebase strategy to clean the commit history.\nThanks for your quick feedback!\n. Excellent!\nI wish that all projects have this reactivity.\nLooking forward to upgrading the Gem dependency list in my app. ;)\nThank you!\n-- Simone\n. No problem.\nI added a few more documentation in the following 2 changesets in my fork.\nhttp://github.com/weppos/money/compare/cce64fa...07d18b2\nThe changes should apply cleanly in your fork queue. If not, let me know, I'll rebase them on your repos.\n. In my Rails app I extended the Money class with two additional methods\n```\ndef currency_as_string\n  currency.to_s\nend\ndef currency_as_string=(value)\n  currency = Currency.wrap(value)\nend\n```\nAnd here's my model definition\ncomposed_of :order_price,\n            :class_name   => \"Money\",\n            :mapping      => [%w( order_price_cents cents ), %w( order_price_currency currency_as_string )]\n. I have a doubt about the usefulness of my patch. The two methods above are strictly focused on ActiveRecord composite feature.\nWhilst the first might be partially useful for the Money library itself, the second one is technically wrong. In fact, it allows you to change the internal value for currency causing an inconsistent object status.\nIdeally, if we want to implement both methods, currency_as_string= should probably be a wrapper for the existing exchange_to method.\nWhat do you think?\n. :converter and :constructor have a different goal. When you create a composite column called my_column, ActiveRecord creates a virtual my_column attribute with its own getter and setter methods.\nYou use :converter and :constructor to instruct how to cast an external object to fit the composite rule.\nFor example\n```\ncomposed_of :order_price,\n            :class_name   => \"Money\",\n            :mapping      => [%w( order_price_cents cents ), %w( order_price_currency currency_as_string )],\n            :constructor  => Proc.new { |cents, currency| (cents.blank? || currency.blank?) ? nil : Money.new(cents, currency) },\n            :converter    => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\nrecord = Record.new\nrecord.order_price = \"$40\"\nhere the converter is called, equal to\nrecord.order_price = \"$40\".to_money\nrecord.order_price = Object.new\nhere the converter is called again\nraise ArgumentError, \"Can't convert Object to Money\"\n```\nActiveRecord expects the values in the mapping hash to be compatible. If you set\n:mapping      => [%w( order_price_cents cents ), %w( order_price_currency currency )],\nIt won't work because it tries to serialize the currency object instead of calling the  #to_s method on it (I still have to understand the reason behind this choice. AFAIK, it may be an ActiveRecord bug). At least this is the issue I experiences so far.\nI agree, I wouldn't change the Money Gem to fit an ActiveRecord use case. This is exactly the reason why I haven't included the patch before.\nAt least, we can extend the documentation to include references to this ticket and a quick solution.\n. http://github.com/weppos/money/compare/3d48d49a94950dcb297d...0dd2f8e78032d0054ee1\nI also committed 3 other changes. Feel free to review and merge them if you agree with the changes.\n. @ FooBarWidget\nFixed the typo, and reorganized the Rails section\nhttp://github.com/weppos/money/compare/3d48d49a94950dcb297d...e0c7273\n. http://github.com/weppos/money/commit/16a6fa582e0c0a60117e1b531c56924dbdacb26e\n. I agree that we should care about BC. The problem here is that we only have control over out own Money implementation. Thus, I can see two alternatives:\n1. Create a completely different exchange method which would pass a Money instance instead of cents. At the same time, we can deprecate the existing exchange method which will be removed in a future release. In this way we give users the time to change their bank implementations.\n2. Change the API of the exchange method passing a Money object, update our existing Bank implementation and make clear in the documentation and changelog that users needs to change their Bank classes.\nI personally prefer the second one, whilst the first one follows a more soft BC approach. In both cases, we should immediately update our default_bank implementation.\nTalking about bank classes, there's also an other small improvement I'd like to suggest. The documentation says we can replace the default_bank with any custom implementation, but doesn't list the required methods nor it provides a shared interface. It also doesn't document very well the requirements of a Bank object.\nMy idea was to extract a base Bank::Base class from the current VariableExchangeBank which should provide a basic interface and make Bank::VariableExchangeBank (or Bank::VariableExchange) a subclass of Bank::Base. But I guess this is an other ticket... \n. I'm working on a currency converter webservice based on Money and Sinatra right now. Let me know if you want to delegate me some task.\n. I was looking at your implementation. It looks great, however I've one additional suggestion.\nThe code in master can be simplified as follows\nclass Money\n  class BaseBank\n  end\n  class VariableExchangeBank < BaseBank\n  end\nend\nI like the idea to define an intermediate Bank namespace\nclass Money\n  module Bank\n    class Base\n    end\n    class VariableExchange < Base\n    end\n  end\nend\nThis would allow the Bank module to contain all the bank-focused classes/objects/code not strictly tied to base or a bank implementation.\nFor instance Money::Bank::Base (or any subclass) could raise a Money::Bank::UnknownRate error instead of Money::BaseBank::UnknownRate.\nThe usage of a Base class as synonymous for simple interface is a really common pattern in the Ruby world, as you might probably know. Think about Sinatra, Rails, ...\nWhat do you think?\n. I'm working on it. Could you reopen the task?\n. Done. All the changes are available in the bank branch on my repo.\nhttp://github.com/weppos/money/compare/weppos:master...weppos:bank\nHere's the comparison with master on FooBarWidget repo.\nhttp://github.com/weppos/money/compare/bank\nNote that the bank branch includes also the changes suggested in #16.\n. As I wrote in\nhttp://github.com/weppos/money/commit/83bc6ca2c5f035fc132e7d1805886ced5a405e51\nI can agree with moving get_rate and set_rate in the base class, but I don't know whether it is a good idea to actually implement them.\nFor instance, I might want my SuperCool bank to store rates in Redis or MongoDb instead of in memory. get_rate and set_rate might want to contact Redis instead of Mutex.\nAlso, I might need to create a custom key generation algorithm.\nWhile I was working on the refactoring, I realized that VariableExchange bank can also be considered a more feature-rich base class.\nI mean, if your code need a prepackaged solution to store and retrieve rates, you can extend VariableExchange instead of Base.\nIMHO, the only reason to add get_rate and set_rate to Base, would be to encourage a consistent naming convention. In this case, both methods should raise NotImplementedError in Base.\nLet me show you two concretes examples. In my code I have a Test bank I use while running the application in test mode.\n```\nmodule Converters\n  class Test < Money::Bank::Base\ndef exchange_with(from, to_currency)\n  Money.new(from.cents * 2)\nend\n\nend\nend\n```\nI've also a more powerful converter which works which interacts with a custom backend.\n```\nrequire \"uri\"\nrequire \"net/http\"\nmodule Converters\n  class Service < Money::Bank::Base\ndef initialize(key)\n  @key = key\nend\n\ndef exchange_with(from, to_currency)\n  return from if same_currency?(from.currency, to_currency)\n\n  Timeout::timeout(5) do\n    # contact service and deal with the request\n  end\nend\n\nend\nend\n```\nAs you can see, they both requires a super-small set of features and I found Base to be the perfect solution. For a variety of reasons, they don't offer a rate get/set mechanism.\nI've also an other internal backed which, instead, gives the ability to manually configure rates. In this case, I extend Money::Bank::VariableExchange and override the exchange_with method with my custom logic.\nThat said, if you really want to move get_rate and set_rate to Base, the world won't end now. ;)\nJust le me know, I will make the changes and prepare the branch for the merge.\n. OK, I pushed all the changes. You can find them in my master branch.\nI suggest you to merge the changes via Git to preserve the merge history. Otherwise, the GitHub Fork Queue feature will flatten the commits.\n$ cd money\n$ git checkout master\n$ git remote add weppos git://github.com/weppos/money.git\n$ git fetch weppos\n$ git merge weppos/master\n. Here's the patch (along with 2 other commits).\nhttp://github.com/weppos/money/compare/18caf7ad26...fea72b08\n. +1\n. I found two additional sources that confirm your request:\n- http://en.wikipedia.org/wiki/Hong_Kong_dollar\n- http://www.worldtravelguide.net/country/115/money/Far-East-Asia/Hong-Kong.html\nI think we can proceed.\n. Hi rabbashanks,\nthanks for your report. I investigated your request and I agree with it. We would probably keep the old currency as well because the new ISO code is valid only since 2007 and we would support payments made before 2007 as well.\nHonestly, I don't think changing the constant into a variable would be a good idea.\nI prefer this kind of issues to be reported as a bug rather than have users rely on monkey patching.\n. Ooops... it seems semmons99 already fixed it! :D\n. Could you please move it outside the begin/rescue block? In this way, if the rspec library is not available, the test task will be defined and will display the \"no rspec\" error message.\n. Excellent! I love the idea of #requirements and json as developer dependency.\n. I required rubygems in fb2de08c9b7513ab80d19fe56a6461897031a113 for tests. Tests was still failing on my mac.\n. Yes, I have json installed. With Ruby 1.9, it worked fine, with 1.8.7 it didn't because rubygems is not bundled and autoloaded in Ruby < 1.8.7\n. I agree with gamov.\nNo longer than yesterday I had to implement a new routine in one Rails app to deal with money. Indeed, users can't play with cents. I can't ask to an user \"Enter here your order price in cents\".\nWhile I was working on the feature, I realized that Money could probably be improved on this side. I'd like to propose a few additional methods:\nMoney.parse([String])\nEquivalent to String.to_s.to_money or viceversa.\nInput is always handled as string.\nIdeally, I would be able to call\nMoney.parse(\"10\")\nMoney.parse(\"10 USD\")\nMoney.new_from_decimal([Fixnum/Float], ...) (or ala Objective-C new_with_decimal)\nEquivalent to Money.new, but accepts a decimal value instead of cents.\nAccepts a currency and a bank, as Money.new does.\nIt automatically converts the input value to cents, \naccording to the value of subunit for given currency.\nMoney#decimal\nMoney#decimal=\nGets/Sets the value in Fixnum/Float.\nI'm sure these methods will significantly improve the library.\nI can work on them once we agree on the implementation. :)\n. Honestly, I would consider to keep them separate.\nI don't really like superclever methods because it's really easy to introduce additional and hard-to-debug bugs.\nFor instance, it would be hard to understand if Money.new(10) should be 10 cents or 10 dollars.\nI believe using separate method provides additional security and readability, in this case.\n. I agree.\nWould this implementation also include Money.parse?\n. Sure, I can work on them. I'll try to get the patch within tomorrow.\n. We always try to avoid coupling the Money library with Rails. Once these methods will be in place, you'll be able to accomplish the task defining your own composed_of configuration.\n. I'm quite busy right now, but I'd like to work on it to break from my current daily activity.\nGive me a few hours. :)\n. Now that I have a few minutes to stop and relax, I'm reviewing all the comments to this issue to organize the changes.\nI'd like to summarize all the activities for a final feedback. Honestly, there's also a small piece of these changes that doesn't please me very much. I'm going to explain why.\nFirst, the goal of this ticket: add support for getting/setting/creating Money objects from a decimal value. We can define decimal value the \"human readable\" amount of money, which Money internally manages as cents.\n```\nCurrent Money implementation\nYou can't supply $10 but you need to convert the amount to cents\nMoney.new(1000, \"USD\") # 1000 cents == 10 $\n```\nThe idea is to have something like\n```\nMoney.METHOD(10, \"USD\")\n$10 are converted into 1000\nthen Money.new(1000) is called.\n```\nHere's my first question. I'm not a native English/American speaker so forgive me if this is a stupid question. We initially agreed on using decimal but, to me, the word decimal doesn't really sound correct. It is too tied to a data tipe, even if no Decimal class exists in Ruby. I would use a more abstract word, something like amount or value.\nMoney.new(1000, \"USD\")\nMoney.from_amount(10, \"USD\")\nThis word will be consistently use across the entire library, so that we can implement\n```\nm = Money.new(1000, \"USD\")\nm.amount # => 10\nm.amount = 12\nm.cents  # => 1200\n```\nNeedless to say, the amount <=> cents conversion will be aware of the Currenty#subunit property.\nSecond question is: do we really need a list of\nMoney.from_bigdecimal\nMoney.from_integer\nMoney.from_string\nMoney.from_whatever\nIn my opinion, we should abstract the money implementation from a specific data type and the ticket #27 is an excellent demonstration.\nI believe Money should provide methods to create money from \"concepts\", rather than from \"types\".\nWhat does it means in practice?\nFirst, we can provide a reasonable set of allowed types when defining a method API. For instance, Money.new accepts cents and we can intelligently try to guess whether cents is a Float/Bigdecimal/Fixnum and coherce it. On this side, I would recommend to avoid super-clever methods. In fact, a Money.new which accepts also Strings will probably cause much more headache in debugging apps than help.\nThen, we can add more \"meaningful\" methods to extend Money usage always trying to work with concepts rather than types (Ruby is not really a strongly typed language).\n\nThere's an small exception to my feedback. We can think about adding more .from_type methods with the purpose to simplify the core extensions provided in the core_extensions.rb file. In this case, we can create\n```\nfor the purpose of this example I separate Numeric\ninto smaller classes\nMoney.from_fixnum(value, ...)\nMoney.from_float(value, ...)\nMoney.from_bigdecimal(value, ...)\nclass Fixnum\n  def to_money(...)\n    Money.from_fixnum(self, ...)\n  end\nend\nclass Float\n  def to_money(...)\n    Money.from_float(self, ...)\n  end\nend\nclass BigDecimal\n  def to_money(...)\n    Money.from_bigdecimal(self, ...)\n  end\nend\n```\nString deserves a special mention here because a String is a very data-reach money format. In fact, there are two types of string representations:\n```\nwith currency\n\"10 $\"\n\"10 USD\"\nwithout currency\n\"10\"\n```\nThis is the reason why we can try to provide two methods:\n```\nA type-focused method, as for BigDecimal, Fixnum...\nwhich accepts only digit representations\n\"1.0\", \"1000\" and handle them as cents\nMoney.from_string\nA concept-focused method which implements a more advanced\n(and slow) detection mechanism\nMoney.parse(...)\n```\nThe idea behind this change is to clean up the core_extensions by moving all the logic into the Money class.\n\nTo summarize:\n1. Do you agree with the idea of using a less type-coupled term? Which one? Assuming to use amount, I would add\n```\n   # I would use the new_from prefix to prevent confusion with\n   # type-focused methods such as from_numeric which always\n   # works with cents as expected.\n   Money.new_from_amount(numeric, ...)\nMoney#amount\n   Money#amount=(numeric)\n   ```\n2. Do you agree with the idea to cleanup core extensions and add type-coupled initialization methods? I would add\nMoney.from_bigdecimal\n   Money.from_numeric  # (or from_fixnum, from_float)\n   Money.from_string\n   Money.parse\nand update the core extensions accordingly.\nWe can also decide to move the section 2 to an other ticket.\n\nSorry for the very long comment.\n. I don't like very much the word dollars because it reminds the Dollar currency name, however at the moment I don't have a better name so I used it as suggested.\nSee http://github.com/RubyMoney/money/compare/master...issue_25\nAny feedback before the merge?\nThere are a couple of FIXME. I'm planning to remove them once the core extension refactoring is completed and we addressed a couple of other related issues I posted today.\n. Sure!\nI used # to identify instance methods (such as #dollars) and . to identify class methods (such as .new_from_dollars).\n. Add support for creating objects with the main monetary unit instead of cents (closed by 1172245ea201386d5cec7e347728e3ed2979568b)\n. It please me more than #dollars. Let's see semmons99's feedback.\n. Ok, let's leave #dollars in place.\n. At this point, I suggest to go ahead with the current implementation (cents and dollars) and keep things as simple as possible. We can always try to implement different solutions in the future, based to real-world usages and feedback.\n. Honestly, I don't have much experience with BigDecimal. Is the public API compatible with Float? I'm going to read some docs about it so that I can speak with a better knowledge of the issue.\n. I think we can close this now.\n. I'm working on this.\n. Should\nMoney.new(100) * Money.new(2)\nreturns Money.new(200) or 200?\nIt doesn't really make sense to me to return 200. Does it?\n. I implemented the method following the same direction of #/. Feel free to add your feedback here if something should be changed.\n. Can now multiply one Money object by one another using #* (closed by 626c6f4c38a83073dddeb88f8a8ad90e6e915cbe)\n. As discussed, trying to multiply a Money by an other Money now results in an ArgumentError.\n. Deprecated Money#format with separate params instead of Hash.\nDeprecated Money#new(0, :currency => \"EUR\") in favor of Money#new(0, \"EUR\").\nDeprecation target set to Money 3.5.0. (closed by 31214fe8374f8ae26f93ab8de5c5243a6b4d6f2d)\n. In d579d110d987e50ac579fc9af7806b440378d3f9 I also removed all the deprecations with target v3.2.0. I made it in a branch then merged the branch so we can easily revert the merge if we don't agree with it. \n. Just to know, are you going to include the BigDecimal, #dollars and core extension changes in a 3.1.x release?\nIMHO, they all deserve a minor bump ;)\nBy the way, I reverted the commit. I'm going to push the changes tomorrow.\n. For future reference, here's a tutorial to revert the revert of a merge.\nhttp://www.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.txt\nRequired to re-include the branch in to master when we are ready to merge the changes.\n. Pushed the revert commit. Do you want to package a release now or are you waiting for #32?\n. My idea, was to implement a simple guessing mechanism.\nIf the string contains something different than digits, use #parse. Otherwise, use #from_string.\n. Exactly.\n. I'm working on this.\n. Done. All tests passes.\nI also took the time to cleanup the tests according to #28, increase documentation and test coverage.\nhttp://github.com/RubyMoney/money/compare/issue_32\nI didn't include the fix for #30 because I prefer to work on one ticket at time.\n. Cleanup core extensions (closed by 15460e9139acfb02fe19ba4b704b6fb2e1e29176)\n. As of Money 3.1.5 you can use the Money#parse and Money#new_with_dollar methods to work with dollars as opposite of cents.\nTalking about Rails, I haven't been using composed_of for a while because I found it to be too less flexible. Instead, I'm now using a virtual attribute to get/set the Money value to a model.\n. Indeed, but I need to extract it from my project to make it more understandable, and unfortunately I'm quite busy in these days. I'll try to do it asap.\n. Hey Matthew,\nthank you very much for your contributions!\nI posted a few comments on your commits.\nCould you please review them?\nThanks!\n. mbasset, which is your Ruby version?\nWith Ruby 1.8.7-p302 it works\nruby-1.8.7-p302 :004 > Marshal.dump(Money.new(100))\n => \"\\004\\bo:\\nMoney\\b:\\v@centsii:\\n@banko:\\\"Money::Bank::VariableExchange\\b:\\025@rounding_method0:\\v@mutexU:\\nMutex\\\"\\000:\\v@rates{\\000:\\016@currencyo:\\024Money::Currency\\016:\\b@id:\\busd:\\017@separator\\\"\\006.:\\016@iso_code\\\"\\bUSD:\\025@subunit_to_unitii:\\n@name\\\"\\031United States Dollar:\\016@priorityi\\006:\\r@subunit\\\"\\tCent:\\017@delimiter\\\"\\006,:\\f@symbol\\\"\\006$\"\n. Your commit contains severals changes and no tests.\nI strongly encourage you to:\n- split the commit into multiple commits, one for each feature\n- add corresponding tests for each feature\n. elmatou already provided the answer. I just want to say that is perfectly fine to have only one currency attribute, as long as all prices must have the same currency (that makes sense in your example).\nYou might also want to customize the default_currency with an initializer, if different than USD.\nMoney.default_currency = Money::Currency.new('EUR')\n. For me it's ok but I leave the final decision to @semmons99.\nI'm just concerned about the use of extend here compared to all the other includes.\ninclude Comparable\ninclude Arithmetic\ninclude Formatting\nextend Parsing\nWhat about using include and refactoring the Parsing module with\n```\nclass Money\n  module Parsing\n    def self.included(base)\n      base.extend ClassMethods\n    end\nmodule ClassMethods\n  def parse\n  end\n\n  ...\nend\n\nend\nend\n```\nIt's a little bit more complex but it follows the normal Ruby practices.\nWell, perhaps we can leave the code as it is and remember this approach in case we need to include instance methods in the Parsing module (since this will force the use of include instead of extend.\n. Also, Financial software often treat positive amount as debit and negative amounts as credit.\n+1 to keep the ability to manage negative/positive money amounts.\n. Also, the question is: should the second parameter be a cent or a dollar?\nYou usually initialize the object with cents, but when you do 1.to_money you actually assume 1 to mean 1 dollar.\nThus, basically Money.new(100) + 1 means Money.new(100) + Money.new(100).\nThat sounds quite confusing to me. I'm not very sure it makes sense to allow this shortcut, we might probably end up generating some hard-to-debug side effect.\n. That's strange. Actually, the #price object is mapped as a Money instance and the cents/currency mapping should have worked.\n. By default, the result of #format returns exactly the format you are requesting.\n```\nMoney.new(102400, \"USD\").format\n=> \"$1,024.00\"\n```\n. You might want to give a look at Money documentation.\nhttp://money.rubyforge.org/Money.html#format-instance_method\n. It is a method call. It goes where you need it.\nPerhaps you need to study some tutorial about learning programming in Ruby before going ahead with your project. :)\n. This is not the point. I can give you all the explanations you want, but if you don't know how to implement them because you are lacking basic knowledge of how Ruby works, then all the explanations won't never help you.\nYou asked about formatting a money instance. I told you you can use the #format method. I don't know anything about your business, thus I cannot provide you a more accurate answer.\n. Do we really need a to_json, to_xml, to_yaml, ... feature?\nI'm not really sure they makes sense because users might want to use a different to_json logic depending on your application.\nAlso, it is worth to mention that, by default, the JSON library adds a to_json method at Object level. It means, every object is \"jsonificable\". The way it works by default, is to export all the internal object attributes.\nLast but not least, a Money#to_json might probably require a Money.from_json counterpart.\nFrom my very personal point of view, I would delegate the responsibility to create a to_json method to the final user.\n. Also, it's important to keep in mind that the JSON library is actually a gem and is not part of the Ruby Standard Library, at least in Ruby 1.8.7. What if I want to use Yajl instead of JSON? Or any other library? I would have to re-implement this method in any case.\n. I'm very sorry, I'm on vacation with limited connectivity. I'll be back on August 1.\n. Hi @defconomicron, thanks for providing a test application. That's by far one of the most perfect bug report I ever received.\nI'm debugging the issue right now.\nI honestly believe this isn't a Money issue but I'm still working on it.\nI would try to find the cause in some hard-to-debug use of Money cents initializer in place of a dollar initializer, or viceversa.\nI'll get back to you as soon as I have more details.\n. Hello guys, I'm extremely sorry, this is a very busy period for me.\nBTW, I debugged the issue and I found the problem.\nThis is not an ActiveRecord bug, nor a Money bug. The bug is in the way you use composed_of.\nThe composed field is a virtual attribute. You must make sure the composed field doesn't match the name of an existing, real, table column, otherwise you'll get an unexpected behavior.\nIn your case, the behavior is that the Money gem stores the price in cents internally. Each time you were calling composed_of, you were creating a kind of recursive call where ActiveRecord loaded the value of price and set it as new price.\nBut because when you set the price to 1, you actually save 100, then the second time you were passing 100 that were saved as 10000 and so on.\nNeedless to say, if you had chosen a currency where dollars are equal to 10 cents, then you would have experienced the same issue but prices would have been increased by 10.\nI forked the invoices repository and pushed a fix. See weppos/invoices@5339785ff2139948d82d81212a9a2c7a445eadc3\n. This is one of these cases where overriding a default method doesn't make any sense to me.\nWhy don't you simply define your own formatting method delegating to Money#format method passing a default set of options? Here's an example using a Formatter module.\n``` ruby\nmodule Formatter\n  def self.money(money, options = {})\n    # set default options\n    options = options.dup\n    options.key?(:symbol) || option[:symbol] = false\n    options.key?(:with_currency) || option[:with_currency] = true\nmoney.format(options)\n\nend\nend\nm = Money.us_dollar(100)\nFormatter.money(m)\n=> \"$1.00\"\nFormatter.money(m, :symbol => false)\n=> \"1.00\"\n```\nNo need to redefine Money#format behavior.\n. If you don't like Formatter.money(Money.new(...), ...), define an additional method in the Money class.\n``` ruby\nclass Money\n  # Note. The name mimic the Rails conventions\n  # for dates and times.\n  # Feel free to rename it.\n  def to_formatted_s(options = {})\n    # set default options\n    options = options.dup\n    options.key?(:symbol) || option[:symbol] = false\n    options.key?(:with_currency) || option[:with_currency] = true\nformat(options)\n\nend\nend\nMoney.to_formatted_s\n```\nRedefining the default formatter is not a good idea, other libraries you include in your project might actually rely on the default Money behavior.\n. This is a responsibility of your view. It depends on how you create your view.\nYou might want to add a condition to display an empty field if the money value is 0, or you can optionally set the attribute to nil. Last but not least, you might want to use JavaScript to cleanup the field.\n. You're welcome. Feel free to post here if you need further assistance.\n. It's already there, it's called :symbol_first.\nhttps://github.com/RubyMoney/money/blob/v3.7.1/lib/money/currency.rb#L25\n. What about moving it to the currency_bc.json file?\n. > That would be fine with me if someone would like to submit a patch.\nI'll do.\n. Does the validates_presence_of :total_cost line works (apart from the tests)?\nI don't know whether the shoulda matcher is compatible with composed attributes. You can write a custom test instead of using the matcher.\n. In my experience, the composed_of attribute seems to be the cause of several headache. People use it most of the time, but I prefer to skip it.\nIn my applications, I actually handle the composition of my money objects separately because sometimes I want the view to display only the dollar value, other times the full object, rarely the cents value.\nBecause you use value.to_money in the constructor, your Rails application is able to convert\n100 USD\ninto the corresponding Money.new(10000, \"USD\") instance, as long as your input displays both dollar and currency. If you only display the dollar value, you need to pass the currency as hidden object or in some other way.\n. I'm not a real fan of this patch. Let me explain why.\nThe Currency table is a class-wide object. When you define a new instance, you actually work at instance level.\nIn this specific case, It doesn't make sense for me that the initializer of a new instance is allowed to modify the class-level list of currencies. It's counter intuitive. You wouldn't expect it to modify the global list of currencies.\nIt's also pretty hard to debug in a large application and it can be the cause of some unexpected side effects.\nNothing prevents you to add the currency before actually creating the  Money instance. In this case, it's more explicit that the new currency will be available across the entire application.\nTwo other things prevents this pull request to be merged:\n1. Please do not add new dependencies to the gem, unless strictly required or previously discussed (9a33efdd8823f1729c3a261b0cd498bc2100bece)\n2. Please one pull request one feature. Open a separate pull request for 2943953540f407f003fdd1aab09bb2332695d781\n. Honestly, exchange_to would be enough for me but @pelle's comment makes sense.\nJust a couple of notes:\ngiven_currency = Currency.wrap(given_currency) if given_currency\ncan be simplified to \ngiven_currency = Currency.wrap(given_currency)\nAlso, the method is missing the @param signature.\n. Merged, thank you.\n. Finished to cleanup all the specs.\nIf feedback is ok, I'll merge the branch and I was thinking about preparing a 4.0.2 release.\n. You're right. Here's the error log.\n```\nweppos-macair:money weppos$ export JRUBY_OPTS=--1.9\nweppos-macair:money weppos$ jruby -v\njruby 1.6.5 (ruby-1.9.2-p136) (2011-10-25 9dcd388) (Java HotSpot(TM) 64-Bit Server VM 1.6.0_29) [darwin-x86_64-java]\nweppos-macair:money weppos$ rake\n/Users/weppos/.rvm/rubies/jruby-1.6.5/bin/jruby -S rspec ./spec/core_extensions_spec.rb ./spec/currency_spec.rb ./spec/money_spec.rb ./spec/bank/base_spec.rb ./spec/bank/variable_exchange_spec.rb ./spec/money/arithmetic_spec.rb ./spec/money/formatting_spec.rb ./spec/money/parsing_spec.rb\n..............................................................................................................................................................................F.F.F........F...F.F.F.........F............................\nFailures:\n1) Money formatting#format respects :subunit_to_unit currency property\n     Failure/Error: Money.new(10_00, \"BHD\").format.should == \"\u0628.\u062f1.000\"\n       expected: \"\u0628.\u062f1.000\"\n            got: \"\\xD8\\xA8.\\xD8\\xAF1.000\" (using ==)\n     # ./spec/money/formatting_spec.rb:93:in `(root)'\n2) Money formatting#format respects the thousands_separator and decimal_mark defaults\n     Failure/Error: one_thousand[\"GBP\"].should == \"\u00a31,000.00\"\n       expected: \"\u00a31,000.00\"\n            got: \"\\xC2\\xA31,000.00\" (using ==)\n     # ./spec/money/formatting_spec.rb:106:in `(root)'\n3) Money formatting#format inserts thousands separator into the result if the amount is sufficiently large and the currency symbol is at the end\n     Failure/Error: Money.euro(1_234_567_12).format.should == \"1.234.567,12 \u20ac\"\n       expected: \"1.234.567,12 \u20ac\"\n            got: \"1.234.567,12 \\xE2\\x82\\xAC\" (using ==)\n     # ./spec/money/formatting_spec.rb:142:in `(root)'\n4) Money formatting Money formatting#format :no_cents option respects :subunit_to_unit currency property\n     Failure/Error: Money.new(10_00, \"BHD\").format(:no_cents => true).should == \"\u0628.\u062f1\"\n       expected: \"\u0628.\u062f1\"\n            got: \"\\xD8\\xA8.\\xD8\\xAF1\" (using ==)\n     # ./spec/money/formatting_spec.rb:162:in `(root)'\n5) Money formatting Money formatting#format :symbol option (:symbol => true) returns symbol based on the given currency code\n     Failure/Error: one[\"GBP\"].should == \"\u00a31.00\"\n       expected: \"\u00a31.00\"\n            got: \"\\xC2\\xA31.00\" (using ==)\n     # ./spec/money/formatting_spec.rb:205:in `(root)'\n6) Money formatting Money formatting#format :symbol option (:symbol => some non-Boolean value that evaluates to true) returns symbol based on the given currency code\n     Failure/Error: Money.new(100, \"GBP\").format(:symbol => true).should == \"\u00a31.00\"\n       expected: \"\u00a31.00\"\n            got: \"\\xC2\\xA31.00\" (using ==)\n     # ./spec/money/formatting_spec.rb:242:in `(root)'\n7) Money formatting Money formatting#format :symbol option defaults :symbol to true\n     Failure/Error: money.format.should == \"\u00a31.00\"\n       expected: \"\u00a31.00\"\n            got: \"\\xC2\\xA31.00\" (using ==)\n     # ./spec/money/formatting_spec.rb:259:in `(root)'\n8) Money formatting Money formatting#format :symbol_position option inserts currency symbol before the amount when set to :before\n     Failure/Error: Money.euro(1_234_567_12).format(:symbol_position => :before).should == \"\u20ac1.234.567,12\"\n       expected: \"\u20ac1.234.567,12\"\n            got: \"\\xE2\\x82\\xAC1.234.567,12\" (using ==)\n     # ./spec/money/formatting_spec.rb:317:in `(root)'\nFinished in 17.18 seconds\n234 examples, 8 failures\nFailed examples:\nrspec ./spec/money/formatting_spec.rb:92 # Money formatting#format respects :subunit_to_unit currency property\nrspec ./spec/money/formatting_spec.rb:100 # Money formatting#format respects the thousands_separator and decimal_mark defaults\nrspec ./spec/money/formatting_spec.rb:141 # Money formatting#format inserts thousands separator into the result if the amount is sufficiently large and the currency symbol is at the end\nrspec ./spec/money/formatting_spec.rb:161 # Money formatting Money formatting#format :no_cents option respects :subunit_to_unit currency property\nrspec ./spec/money/formatting_spec.rb:199 # Money formatting Money formatting#format :symbol option (:symbol => true) returns symbol based on the given currency code\nrspec ./spec/money/formatting_spec.rb:241 # Money formatting Money formatting#format :symbol option (:symbol => some non-Boolean value that evaluates to true) returns symbol based on the given currency code\nrspec ./spec/money/formatting_spec.rb:254 # Money formatting Money formatting#format :symbol option defaults :symbol to true\nrspec ./spec/money/formatting_spec.rb:316 # Money formatting Money formatting#format :symbol_position option inserts currency symbol before the amount when set to :before\norg.jruby.exceptions.RaiseException: (SystemExit) exit\nrake aborted!\nruby /Users/weppos/.rvm/rubies/jruby-1.6.5/bin/jruby -S rspec ./spec/core_extensions_spec.rb ./spec/currency_spec.rb ./spec/money_spec.rb ./spec/bank/base_spec.rb ./spec/bank/variable_exchange_spec.rb ./spec/money/arithmetic_spec.rb ./spec/money/formatting_spec.rb ./spec/money/parsing_spec.rb failed\nTasks: TOP => default => spec\n(See full trace by running task with --trace)\nweppos-macair:money weppos$ \n```\nInvestigating...\n. The issue exists on master, it doesn't belong to this branch.\nI run the tests against master and they fails.\nIf you agree, I'll merge this branch and file a separate issue. I'll try to get it working for today.\n. I'm not sure this method is a good fit for this Gem. After all, this gem is about Money, not \"everything somehow related to moneys and currencies\".\nAlso, the feature would open several questions. For example, what EUR should return?\n. The issue seems to be caused by the JSON.parse line.\nReading the JSON file in jRuby works perfectly. But as soon as the JSON string is parsed, the symbol is converted.\njruby-1.6.5 :005 > j = JSON.parse(s)\njruby-1.6.5 :006 > j[\"eur\"]\n => {\"priority\"=>2, \"iso_code\"=>\"EUR\", \"name\"=>\"Euro\", \"symbol\"=>\"\\xE2\\x82\\xAC\", \"subunit\"=>\"Cent\", \"subunit_to_unit\"=>100, \"symbol_first\"=>false, \"html_entity\"=>\"&#x20AC;\", \"decimal_mark\"=>\",\", \"thousands_separator\"=>\".\", \"iso_numeric\"=>\"978\"}\n. I believe it's the same issue reported at intridea/multi_json#25\n. Tests pass if I use require 'json/pure' as commented in the multi_json issue.\n```\nweppos-macair:money weppos$ rspec spec/money/formatting_spec.rb \n.............................................\nFinished in 16.9 seconds\n45 examples, 0 failures\n```\nAt this point I'm quite sure it's a JSON (or interpreter) issue, not something we can easily fix on Money side.\n. We can leave it open for now. Actually, this is not Money's fault, hence we\ncan eventually close it and redirect to the issue in case someone will\ncomplain about it.\nThe issue itself includes a possible workaround, though it must be\nimplemented application-wide.\nOn Wednesday, December 14, 2011, Shane Emmons \nreply@reply.github.com\nwrote:\n\nPerhaps we leave this open and keep taps on the issue. I would imagine\nthis is a JRuby bug if all other implementations work right.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/131#issuecomment-3141130\n. Thank you @plentz. I subscribed the issue, I'll wait for it to be merged and I'll restore the travis config for JRuby in 1.9 mode.\n. I never faced this issue, but it's a very interesting topic to keep in mind. Thank you very much for point it out.\n\nI think we need to find a solution. Handling the currency key as String might be the solution. However, changing the way we store currencies would break applications that access TABLE directly, though this is not recommended.\nI'm +1 for changing keys to Strings. I'm thinking about a solution to minimize the impact.\n. +1 for ParseError. The ArgumentError is quite generic and can't be handled very well at higher levels.\n. What would you expect exactly?\nIt's also important to underline that String parsing is always a guessing and it's likely to not cover all possible (and infinite) ways you can use to format a Money object.\n. I confess my ignorance, I just noticed that in bookkeeping negative amounts are sometimes represented with a number in a number in parentheses.\nhttp://en.wikipedia.org/wiki/Negative_number\nHonestly, I always believed that String#to_money should be able to parse a restricted set of formats, to avoid dealing with complex exceptions and cases. We already have to deal with different conventions originated from having currencies from all over the world.\nI believe we already crossed the line with #133. The more cases we accepts, the more we increase the possibility that you will encounter side effects trying to parse existing outputs. If we investigate all fields where money are involved, from booking to accountants, etc... there are tons of possibilities and sometimes the same output in a field has a different meaning in another field. Or to put it in another way, I'm quite sure (1000\u20ac) doesn't have the same meaning here in Italy.\nIMHO, String parsing should just provide basic capabilities. You can always write your own custom parser based on String#to_money. It's like the difference we have in Ruby between Date.parse and Date.strptime.\nI'm curious to know what other Money contributors think about this topic.\nIn any case, thank you @WhiteFire-Sondergaard for opening this issue, we always appreciate feedback from users! :)\n. > Seeing a little mixed feedback here?\nIn my previous comment I just expressed my POV. In fact, I also said I was curious to understand other contributors' POV.\n\nOtherwise someone that is feeding a form field into string.money is going to have a user pasting from a ledger or excel getting the nasty surprise of negative becoming positive.\n\nI could reverse the sentence and say: if someone in Europe pastes a content from an Excel where the value has parenthesis, it woud probably be surprised to see the money amount converted to a negative value.\nPersonally, I believe the ignore a not globally and uniquely identified standard is better than assuming a standard for the US market can be applied to all other markets. I could be wrong, but it's always easier to build your parser on top of String#to_money to make it more intelligent, rather than trying to force the library to not be too intelligent.\nAgain, I can be wrong. But I see these kind of changes very complex to handle without generating side effects. Just my 2 cents.\n@WhiteFire-Sondergaard, do you know if this kind of convention only exists for US or also for other countries?\n. Sorry guys, I'm in san francisco on vacation. I have a few ideas in mind,\nI'll post them when I'll be back in Italy\nOn Jan 1, 2012 3:22 PM, \"Shane Emmons\" \nreply@reply.github.com\nwrote:\n\nI'm going to close this. We can revisit this if we start having more pain.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/135#issuecomment-3326451\n. If you want to initialize a Money object from a string use Money.from_string(\"100\"). \n. Yep. I'm considering to write some sort of blog post/wiki page to definitely document the procedure, since it's a very recurring topic. Give me a couple of days.\n. The current Money version is 4.0.2. Please update to the latest version and let us know if the issue is fixed.\n. I just noticed you are using a ISO4217::Currency::ExchangeBank:0x104f9b820 object. I'm sorry, but this object doesn't belong to Money.\n\nIt seems you are using a Bank object provided by a different gem. Please check the documentation for that gem.\n. The default is Money::Bank::VariableExchange\nhttps://github.com/RubyMoney/money/blob/master/lib/money/money.rb#L53\n. The default exchange bank object requires you to manually specify the exchange rate.\nPlease check the Money README file to learn about adding rates or using alternative bank implementations (section Currency Exchange).\nhttps://github.com/RubyMoney/money/blob/master/README.md\n. From http://ruby-doc.org/core-1.9.3/Object.html#method-i-eql-3F\n\nEquality\u2014At the Object level, == returns true only if obj and other are the same object. Typically, this method is overridden in descendant classes to provide class-specific meaning.\nUnlike ==, the equal? method should never be overridden by subclasses: it is used to determine object identity (that is, a.equal?(b) iff a is the same object as b).\nThe eql? method returns true if obj and anObject have the same value. Used by Hash to test members for equality. For objects of class Object, eql? is synonymous with ==. Subclasses normally continue this tradition, but there are exceptions. Numeric types, for example, perform type conversion across ==, but not across eql?, so:\n\nAbout #===\n\nCase Equality\u2014For class Object, effectively the same as calling #==, but typically overridden by descendants to provide meaningful semantics in case statements.\n. Ops, fixed.\n. +1 for me. The time has come to avoid altering the TABLE hash directly.\n. Before going into the details of the patch, I'm just wondering what is the overall opinion about supporting Rails directly into the gem.\n. I agree with @ohthatjames. In fact, I have the same concern about testing.\n. Could you explain why you need a nil amount? Isn't a nil amount different than assigning a nil value to the variable?\n. The Money library isn't designed to store nil values. Honestly, it's hard to keep track of all side effects that your change would cause. For example, the library uses BigDecimal.\n\nIt seems you can initialize a BigDecimal object passing an empty string with Ruby 1.9.3\n1.9.2p318 :002 > BigDecimal.new(\"\")\n => #<BigDecimal:7fd97b17d9d0,'0.0',9(9)>\nbut if this behavior will change in the future, your implementation will fail. This is just one example.\nI would suggest you to follow a different approach and keeping the empty value to 0. For example, you can add a new flag to each money instance.\nclass Money\n  attr_accessor :inherited\nend\nand instruct your application to check for this attribute, instead of the internal value. If the attribute is true, then the behavior would be the same of a nil amount.\n. > Just wondering: is that something we should add maybe on the readme?\nThis is a very specific need I would not worry about mentioning it in the README. Chances are similar needs might have different solutions, depending on the project where the solution applies.\n. A money instance with a nil amount doesn't make sense from an implementation point of view. Money is a framework agnostic library, we don't really tie to a specific ORM.\nI'm a Rails and ActiveRecord user as well and I honestly never faced this issue. A nil value for a money object is equal to say the value is nil. Think it for a second: when an Integer value is nil in ActiveRecord you get a nil, you don't get an Integer that returns nil. This is the same here.\nThere's no validation issue in ActiveRecord. Depending on how you implemented the integration, you should be able to check whether the specific column in the database is nil.\nTo summarize, you can have 3 cases:\n1. the field has a value different than 0 and the returned object is a Money with amount different than 0\n2. the field has a value equal to 0 and the returned object is a Money with amount 0\n3. the field has no value and the returned object is nil\n. You don't need 3 columns. You need just one, may be two in case you also want to save the currency.\nLet's say you want to save an order price. You need one (or two) columns:\n- Order#price_cents - Integer, null allowed\n- Order#price_currency - String, limit 3\nIf price_cents != nil then you can return a Money instance, if price_cents == nil then return nil.\n. Here's an example using two fields.\n``` ruby\nclass Order < ActiveRecord::Base\n  def price\n    if price_cents?\n      Money.new(price_cents, price_currency)\n    end\n  end\ndef price=(value)\n    if value.nil?\n      price_cents, price_currency = nil, nil\n    else\n      money = value.to_money\n      price_cents, price_currency = money.cents, money.currency.to_s\n    end\n  end\ndef price?\n    !price.nil?\n  end\nend\n``\n. Sorry @thbar, when I replied your post I probably didn't notice you were referencing an ActiveRecord object. For some reason, I thought you were re-opening the Money class. I probably read the implementation without paying attention to the class definition. My fault.\n. Because this is a Rails information, I believe it belongs to the new [RubyMoney/money-rails](https://github.com/RubyMoney/money-rails) project.\n. @thbar feel free to propose a README update. At this time, I'm not sure whether it would be better here or in the money-rails repo. :)\n. I honestly don't see the need of a new special method just to accomodate ActiveRecord needs. Moreover, the checkinput =~ /[0-9]/` is very opinionable, other users might need a different validation match and we will end up trying to match everyone's needs.\nWhat's wrong with the following custom validation?\nruby\ncomposed_of :price,\n  :class_name => \"Money\",\n  :mapping => [%w(price_cents cents), %w(currency currency_as_string)],\n  :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n  :converter => Proc.new { |value| \n    if value.respond_to?(:to_money)\n      if input =~ /[0-9]/\n        value.to_money\n      else\n        raise ArgumentError, \"`input' should contain a numeric character\"\n      end\n    else\n      raise ArgumentError, \"Can't convert #{value.class} to Money\"\n    end\n  }\nPS. In case the patch will pass the approval, please note that tests are requires in order to merge the pull request.\nBTW, thanks for taking the time to contribute!\n. It's a common Ruby pattern to use the bang version (foo vs foo!) to denote a method that changes the receiver and/or a method that raises compared to a one that silently returns. This is a very common approach in ORMs, but you can find it in other libraries.\nI'm not sure it makes 100% sense here because #135 is still unsolved and unless we standardize the way we want to parse inputs, the regular expression pattern will be very opinionable.\nSo far, this is the first time this request comes. Let's see if someone else has the same need, in case we will collect all the feedback and start working on it. Users are free to re-open the Money library and add the to_money! method if requires.\nJust to clarify my point of view, there are two additional aspects that prevents me to vote in favor of this feature:\n- I honestly haven't find a real case where to_money! would make sense. The example above isn't probably the best one.\n- We should remember that to_money is provided to several Ruby classes, not only to String. We have Fixnum and many others. I can't find a reasonable implementation of Fixnum#to_money! May be we want to talk about Money#parse and Money#parse!, rather than String#to_money!\n. Hi @kirillian. Thanks for the patch. It's not clear to me why you need to change the initialization method. Wouldn't be sufficient to pass the precision to the format method?\n. I agree this might be an interesting feature, but I honestly don't like the idea to create tons of currency instances. If we really want to add this feature, I would vote for an internal refactoring. The precision can be an attribute of the money object and methods will have to be updated accordingly.\nJust my 2 cents.\nPS. As a side note, the format method is becoming pretty complex.\n. I had one week off. Checking the code...\n. Integrated in 89ba651\n. Good point.\n. Merged!\n. The order is defined as part of the Currency in the :symbol_first property.\nIf you have specific needs that go beyond the default formatting, keep in mind you can always use #to_s and #symbol to prepare your own helper.\n``` ruby\nc = Money.new(100)\n=> #\nputs \"#{c} #{c.symbol}\"\n=> \"1.00 $\"\n```\nI would avoid haking the #format method because it's already very complex and it's really that simple to format the object the way you want using the methods above.\n. What is the official currency for Zimbabwe at the time being?\n. Feel free to go ahead and create one pull request for each request. We'll review them and see if it makes sense to merge them into the code base.\nThe changes you requested seems trivial but they aren't. For every change, documentation should be written in order to make sure users won't be confused.\nPS. This ticket breaks the single responsibility principle as well. You started a discussion for at least 3 different changes in the same issue. ;)\n. Since the beginning, Money#parse has been dealing with data parsing as opposite of Fixnum|Integer#to_money where you don't need to parse anything but just create the necessary Money object calculating the correct amount.\nMoney#parse is a quite complex method and there were attempts in the past to simplify it. Removing the core extensions and moving the logic into Money.parse seems a step backward to me. In fact, you should also be aware that Numeric#to_money relies on Money.from_numeric while String#to_money relies on Money.parse.\nWhether these extensions provide or not a real value, this is a different topic. In Ruby is perfectly fine to reopen classes. Despite this approach leads to money-patches in many cases, it doesn't mean you should avoid reopening classes at all. I don't believe the use we did of this feature in the Money library can be classified as monkey patching. We're re-opening classes in order to add extensions. After all, we're not redefining String core methods or patching them.\nThat said, we can discuss about the benefit of providing core extensions or not. I personally don't use them in this case, but they don't hurt me. I would vote +1 for removing the #to_currency extensions (it's very unlikely that someone needs to play with currencies directly), but I have no preference for keeping or removing #to_money.\n. -1 for me\nHere's the reason:\nYAML had several issues in the past. Unless you are using Ruby 1.9.3 where Psyck is enabled by default, all the other Ruby versions use Syck which is an outdated and buggy implementation. Not to mention, Syck is incredibly slow compared to other parsers, including the JSON parser.\nGiven that JSON is part of Ruby library (I honestly don't remember since which revision), I would prefer to use JSON.\nThis also avoid issues with other users/tools that are currently using our JSON data to power their libraries.\nI honestly don't remember the issue we had with JRuby. Maybe it's time to check if the issue was solved and use the default JSON library.\n. There's something that I can't understand. We are going back storing again the definitions in a Ruby Hash and we keep the dependency to JSON?\nAnyway, I'm -1 to go back to a Ruby Hash. I personally prefer to keep definitions outside the Ruby library, ideally as JSON. I'm currently working in this way for the whois library as well. The idea is to move definitions to a general format so that other libraries and other languages can benefit from it.\n. I believe we're falling into the trap of over-optimization.\nWhy are we doing all this stuff? To remove the dependency to multi_json. What's wrong with multi_json? So, to remove dependency with multi_json we want to extract currencies into a new gem, which will became a dependency, and have the extra-effort of maintaining a new gem?\nI really don't see the reason for all of this. I actually don't see any good reason why we should remove the dependency to multi_json at any cost if the new solutions will require the equal amount of effort to be maintainer (or in the worst case more effort).\nI will vote +1 only if the solution to remove multi_json is by using the JSON library that comes with the standard Ruby implementation (whatever it is). If this is not possible for whatever reason and multi_json is currently the only solution... let's go ahead with it.\nAgain, what's wrong with multi_json. So far, we had no complaints about it. multi_json has no dependencies on other libraries, thus I believe our current money -> multi_json dependency chain is skinny enough to let me sleep very well at night.\n. More on this topic. I didn't have the time to check the reason why we can't use JSON.load. It seems the issue with JRuby is fixed and, so far, the only reason is the one described in #170.\nIf that's the case, the issue is really simple to be solved. We have two options:\n1. don't use any symbolize key. Load keys as strings and symbolize them later on the same method. Here's a symbolize_key implementation.\n2. Create a very simple adapter inside Money that simply checks whether yajl-ruby is used and pass the right option.\nI personally prefer the first choice.\n. -1 for me. Liquid is a good library, but if we follone this path we should\nadd (and maintain) tons of code to support interaction between various ruby\nlibraries.\nI think It's fair enough to delegate the end user to add the alias in this\ncase to its own codebase.\nOn Monday, August 27, 2012, Carsten Block wrote:\n\nbump\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/207#issuecomment-8067206.\n\n\nSimone Carletti\nApplication Developer\nSite & Blog: http://www.simonecarletti.com/\nLinkedIn: http://linkedin.com/in/weppos\nSkype: weppos\n. Great!\nI updated the repository. Make sure to destroy/recreate the remote source if you already fetched it because I used a rebase strategy to clean the commit history.\nThanks for your quick feedback!\n. Excellent!\nI wish that all projects have this reactivity.\nLooking forward to upgrading the Gem dependency list in my app. ;)\nThank you!\n-- Simone\n. No problem.\nI added a few more documentation in the following 2 changesets in my fork.\nhttp://github.com/weppos/money/compare/cce64fa...07d18b2\nThe changes should apply cleanly in your fork queue. If not, let me know, I'll rebase them on your repos.\n. In my Rails app I extended the Money class with two additional methods\n```\ndef currency_as_string\n  currency.to_s\nend\ndef currency_as_string=(value)\n  currency = Currency.wrap(value)\nend\n```\nAnd here's my model definition\ncomposed_of :order_price,\n            :class_name   => \"Money\",\n            :mapping      => [%w( order_price_cents cents ), %w( order_price_currency currency_as_string )]\n. I have a doubt about the usefulness of my patch. The two methods above are strictly focused on ActiveRecord composite feature.\nWhilst the first might be partially useful for the Money library itself, the second one is technically wrong. In fact, it allows you to change the internal value for currency causing an inconsistent object status.\nIdeally, if we want to implement both methods, currency_as_string= should probably be a wrapper for the existing exchange_to method.\nWhat do you think?\n. :converter and :constructor have a different goal. When you create a composite column called my_column, ActiveRecord creates a virtual my_column attribute with its own getter and setter methods.\nYou use :converter and :constructor to instruct how to cast an external object to fit the composite rule.\nFor example\n```\ncomposed_of :order_price,\n            :class_name   => \"Money\",\n            :mapping      => [%w( order_price_cents cents ), %w( order_price_currency currency_as_string )],\n            :constructor  => Proc.new { |cents, currency| (cents.blank? || currency.blank?) ? nil : Money.new(cents, currency) },\n            :converter    => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\nrecord = Record.new\nrecord.order_price = \"$40\"\nhere the converter is called, equal to\nrecord.order_price = \"$40\".to_money\nrecord.order_price = Object.new\nhere the converter is called again\nraise ArgumentError, \"Can't convert Object to Money\"\n```\nActiveRecord expects the values in the mapping hash to be compatible. If you set\n:mapping      => [%w( order_price_cents cents ), %w( order_price_currency currency )],\nIt won't work because it tries to serialize the currency object instead of calling the  #to_s method on it (I still have to understand the reason behind this choice. AFAIK, it may be an ActiveRecord bug). At least this is the issue I experiences so far.\nI agree, I wouldn't change the Money Gem to fit an ActiveRecord use case. This is exactly the reason why I haven't included the patch before.\nAt least, we can extend the documentation to include references to this ticket and a quick solution.\n. http://github.com/weppos/money/compare/3d48d49a94950dcb297d...0dd2f8e78032d0054ee1\nI also committed 3 other changes. Feel free to review and merge them if you agree with the changes.\n. @ FooBarWidget\nFixed the typo, and reorganized the Rails section\nhttp://github.com/weppos/money/compare/3d48d49a94950dcb297d...e0c7273\n. http://github.com/weppos/money/commit/16a6fa582e0c0a60117e1b531c56924dbdacb26e\n. I agree that we should care about BC. The problem here is that we only have control over out own Money implementation. Thus, I can see two alternatives:\n1. Create a completely different exchange method which would pass a Money instance instead of cents. At the same time, we can deprecate the existing exchange method which will be removed in a future release. In this way we give users the time to change their bank implementations.\n2. Change the API of the exchange method passing a Money object, update our existing Bank implementation and make clear in the documentation and changelog that users needs to change their Bank classes.\nI personally prefer the second one, whilst the first one follows a more soft BC approach. In both cases, we should immediately update our default_bank implementation.\nTalking about bank classes, there's also an other small improvement I'd like to suggest. The documentation says we can replace the default_bank with any custom implementation, but doesn't list the required methods nor it provides a shared interface. It also doesn't document very well the requirements of a Bank object.\nMy idea was to extract a base Bank::Base class from the current VariableExchangeBank which should provide a basic interface and make Bank::VariableExchangeBank (or Bank::VariableExchange) a subclass of Bank::Base. But I guess this is an other ticket... \n. I'm working on a currency converter webservice based on Money and Sinatra right now. Let me know if you want to delegate me some task.\n. I was looking at your implementation. It looks great, however I've one additional suggestion.\nThe code in master can be simplified as follows\nclass Money\n  class BaseBank\n  end\n  class VariableExchangeBank < BaseBank\n  end\nend\nI like the idea to define an intermediate Bank namespace\nclass Money\n  module Bank\n    class Base\n    end\n    class VariableExchange < Base\n    end\n  end\nend\nThis would allow the Bank module to contain all the bank-focused classes/objects/code not strictly tied to base or a bank implementation.\nFor instance Money::Bank::Base (or any subclass) could raise a Money::Bank::UnknownRate error instead of Money::BaseBank::UnknownRate.\nThe usage of a Base class as synonymous for simple interface is a really common pattern in the Ruby world, as you might probably know. Think about Sinatra, Rails, ...\nWhat do you think?\n. I'm working on it. Could you reopen the task?\n. Done. All the changes are available in the bank branch on my repo.\nhttp://github.com/weppos/money/compare/weppos:master...weppos:bank\nHere's the comparison with master on FooBarWidget repo.\nhttp://github.com/weppos/money/compare/bank\nNote that the bank branch includes also the changes suggested in #16.\n. As I wrote in\nhttp://github.com/weppos/money/commit/83bc6ca2c5f035fc132e7d1805886ced5a405e51\nI can agree with moving get_rate and set_rate in the base class, but I don't know whether it is a good idea to actually implement them.\nFor instance, I might want my SuperCool bank to store rates in Redis or MongoDb instead of in memory. get_rate and set_rate might want to contact Redis instead of Mutex.\nAlso, I might need to create a custom key generation algorithm.\nWhile I was working on the refactoring, I realized that VariableExchange bank can also be considered a more feature-rich base class.\nI mean, if your code need a prepackaged solution to store and retrieve rates, you can extend VariableExchange instead of Base.\nIMHO, the only reason to add get_rate and set_rate to Base, would be to encourage a consistent naming convention. In this case, both methods should raise NotImplementedError in Base.\nLet me show you two concretes examples. In my code I have a Test bank I use while running the application in test mode.\n```\nmodule Converters\n  class Test < Money::Bank::Base\ndef exchange_with(from, to_currency)\n  Money.new(from.cents * 2)\nend\n\nend\nend\n```\nI've also a more powerful converter which works which interacts with a custom backend.\n```\nrequire \"uri\"\nrequire \"net/http\"\nmodule Converters\n  class Service < Money::Bank::Base\ndef initialize(key)\n  @key = key\nend\n\ndef exchange_with(from, to_currency)\n  return from if same_currency?(from.currency, to_currency)\n\n  Timeout::timeout(5) do\n    # contact service and deal with the request\n  end\nend\n\nend\nend\n```\nAs you can see, they both requires a super-small set of features and I found Base to be the perfect solution. For a variety of reasons, they don't offer a rate get/set mechanism.\nI've also an other internal backed which, instead, gives the ability to manually configure rates. In this case, I extend Money::Bank::VariableExchange and override the exchange_with method with my custom logic.\nThat said, if you really want to move get_rate and set_rate to Base, the world won't end now. ;)\nJust le me know, I will make the changes and prepare the branch for the merge.\n. OK, I pushed all the changes. You can find them in my master branch.\nI suggest you to merge the changes via Git to preserve the merge history. Otherwise, the GitHub Fork Queue feature will flatten the commits.\n$ cd money\n$ git checkout master\n$ git remote add weppos git://github.com/weppos/money.git\n$ git fetch weppos\n$ git merge weppos/master\n. Here's the patch (along with 2 other commits).\nhttp://github.com/weppos/money/compare/18caf7ad26...fea72b08\n. +1\n. I found two additional sources that confirm your request:\n- http://en.wikipedia.org/wiki/Hong_Kong_dollar\n- http://www.worldtravelguide.net/country/115/money/Far-East-Asia/Hong-Kong.html\nI think we can proceed.\n. Hi rabbashanks,\nthanks for your report. I investigated your request and I agree with it. We would probably keep the old currency as well because the new ISO code is valid only since 2007 and we would support payments made before 2007 as well.\nHonestly, I don't think changing the constant into a variable would be a good idea.\nI prefer this kind of issues to be reported as a bug rather than have users rely on monkey patching.\n. Ooops... it seems semmons99 already fixed it! :D\n. Could you please move it outside the begin/rescue block? In this way, if the rspec library is not available, the test task will be defined and will display the \"no rspec\" error message.\n. Excellent! I love the idea of #requirements and json as developer dependency.\n. I required rubygems in fb2de08c9b7513ab80d19fe56a6461897031a113 for tests. Tests was still failing on my mac.\n. Yes, I have json installed. With Ruby 1.9, it worked fine, with 1.8.7 it didn't because rubygems is not bundled and autoloaded in Ruby < 1.8.7\n. I agree with gamov.\nNo longer than yesterday I had to implement a new routine in one Rails app to deal with money. Indeed, users can't play with cents. I can't ask to an user \"Enter here your order price in cents\".\nWhile I was working on the feature, I realized that Money could probably be improved on this side. I'd like to propose a few additional methods:\nMoney.parse([String])\nEquivalent to String.to_s.to_money or viceversa.\nInput is always handled as string.\nIdeally, I would be able to call\nMoney.parse(\"10\")\nMoney.parse(\"10 USD\")\nMoney.new_from_decimal([Fixnum/Float], ...) (or ala Objective-C new_with_decimal)\nEquivalent to Money.new, but accepts a decimal value instead of cents.\nAccepts a currency and a bank, as Money.new does.\nIt automatically converts the input value to cents, \naccording to the value of subunit for given currency.\nMoney#decimal\nMoney#decimal=\nGets/Sets the value in Fixnum/Float.\nI'm sure these methods will significantly improve the library.\nI can work on them once we agree on the implementation. :)\n. Honestly, I would consider to keep them separate.\nI don't really like superclever methods because it's really easy to introduce additional and hard-to-debug bugs.\nFor instance, it would be hard to understand if Money.new(10) should be 10 cents or 10 dollars.\nI believe using separate method provides additional security and readability, in this case.\n. I agree.\nWould this implementation also include Money.parse?\n. Sure, I can work on them. I'll try to get the patch within tomorrow.\n. We always try to avoid coupling the Money library with Rails. Once these methods will be in place, you'll be able to accomplish the task defining your own composed_of configuration.\n. I'm quite busy right now, but I'd like to work on it to break from my current daily activity.\nGive me a few hours. :)\n. Now that I have a few minutes to stop and relax, I'm reviewing all the comments to this issue to organize the changes.\nI'd like to summarize all the activities for a final feedback. Honestly, there's also a small piece of these changes that doesn't please me very much. I'm going to explain why.\nFirst, the goal of this ticket: add support for getting/setting/creating Money objects from a decimal value. We can define decimal value the \"human readable\" amount of money, which Money internally manages as cents.\n```\nCurrent Money implementation\nYou can't supply $10 but you need to convert the amount to cents\nMoney.new(1000, \"USD\") # 1000 cents == 10 $\n```\nThe idea is to have something like\n```\nMoney.METHOD(10, \"USD\")\n$10 are converted into 1000\nthen Money.new(1000) is called.\n```\nHere's my first question. I'm not a native English/American speaker so forgive me if this is a stupid question. We initially agreed on using decimal but, to me, the word decimal doesn't really sound correct. It is too tied to a data tipe, even if no Decimal class exists in Ruby. I would use a more abstract word, something like amount or value.\nMoney.new(1000, \"USD\")\nMoney.from_amount(10, \"USD\")\nThis word will be consistently use across the entire library, so that we can implement\n```\nm = Money.new(1000, \"USD\")\nm.amount # => 10\nm.amount = 12\nm.cents  # => 1200\n```\nNeedless to say, the amount <=> cents conversion will be aware of the Currenty#subunit property.\nSecond question is: do we really need a list of\nMoney.from_bigdecimal\nMoney.from_integer\nMoney.from_string\nMoney.from_whatever\nIn my opinion, we should abstract the money implementation from a specific data type and the ticket #27 is an excellent demonstration.\nI believe Money should provide methods to create money from \"concepts\", rather than from \"types\".\nWhat does it means in practice?\nFirst, we can provide a reasonable set of allowed types when defining a method API. For instance, Money.new accepts cents and we can intelligently try to guess whether cents is a Float/Bigdecimal/Fixnum and coherce it. On this side, I would recommend to avoid super-clever methods. In fact, a Money.new which accepts also Strings will probably cause much more headache in debugging apps than help.\nThen, we can add more \"meaningful\" methods to extend Money usage always trying to work with concepts rather than types (Ruby is not really a strongly typed language).\n\nThere's an small exception to my feedback. We can think about adding more .from_type methods with the purpose to simplify the core extensions provided in the core_extensions.rb file. In this case, we can create\n```\nfor the purpose of this example I separate Numeric\ninto smaller classes\nMoney.from_fixnum(value, ...)\nMoney.from_float(value, ...)\nMoney.from_bigdecimal(value, ...)\nclass Fixnum\n  def to_money(...)\n    Money.from_fixnum(self, ...)\n  end\nend\nclass Float\n  def to_money(...)\n    Money.from_float(self, ...)\n  end\nend\nclass BigDecimal\n  def to_money(...)\n    Money.from_bigdecimal(self, ...)\n  end\nend\n```\nString deserves a special mention here because a String is a very data-reach money format. In fact, there are two types of string representations:\n```\nwith currency\n\"10 $\"\n\"10 USD\"\nwithout currency\n\"10\"\n```\nThis is the reason why we can try to provide two methods:\n```\nA type-focused method, as for BigDecimal, Fixnum...\nwhich accepts only digit representations\n\"1.0\", \"1000\" and handle them as cents\nMoney.from_string\nA concept-focused method which implements a more advanced\n(and slow) detection mechanism\nMoney.parse(...)\n```\nThe idea behind this change is to clean up the core_extensions by moving all the logic into the Money class.\n\nTo summarize:\n1. Do you agree with the idea of using a less type-coupled term? Which one? Assuming to use amount, I would add\n```\n   # I would use the new_from prefix to prevent confusion with\n   # type-focused methods such as from_numeric which always\n   # works with cents as expected.\n   Money.new_from_amount(numeric, ...)\nMoney#amount\n   Money#amount=(numeric)\n   ```\n2. Do you agree with the idea to cleanup core extensions and add type-coupled initialization methods? I would add\nMoney.from_bigdecimal\n   Money.from_numeric  # (or from_fixnum, from_float)\n   Money.from_string\n   Money.parse\nand update the core extensions accordingly.\nWe can also decide to move the section 2 to an other ticket.\n\nSorry for the very long comment.\n. I don't like very much the word dollars because it reminds the Dollar currency name, however at the moment I don't have a better name so I used it as suggested.\nSee http://github.com/RubyMoney/money/compare/master...issue_25\nAny feedback before the merge?\nThere are a couple of FIXME. I'm planning to remove them once the core extension refactoring is completed and we addressed a couple of other related issues I posted today.\n. Sure!\nI used # to identify instance methods (such as #dollars) and . to identify class methods (such as .new_from_dollars).\n. Add support for creating objects with the main monetary unit instead of cents (closed by 1172245ea201386d5cec7e347728e3ed2979568b)\n. It please me more than #dollars. Let's see semmons99's feedback.\n. Ok, let's leave #dollars in place.\n. At this point, I suggest to go ahead with the current implementation (cents and dollars) and keep things as simple as possible. We can always try to implement different solutions in the future, based to real-world usages and feedback.\n. Honestly, I don't have much experience with BigDecimal. Is the public API compatible with Float? I'm going to read some docs about it so that I can speak with a better knowledge of the issue.\n. I think we can close this now.\n. I'm working on this.\n. Should\nMoney.new(100) * Money.new(2)\nreturns Money.new(200) or 200?\nIt doesn't really make sense to me to return 200. Does it?\n. I implemented the method following the same direction of #/. Feel free to add your feedback here if something should be changed.\n. Can now multiply one Money object by one another using #* (closed by 626c6f4c38a83073dddeb88f8a8ad90e6e915cbe)\n. As discussed, trying to multiply a Money by an other Money now results in an ArgumentError.\n. Deprecated Money#format with separate params instead of Hash.\nDeprecated Money#new(0, :currency => \"EUR\") in favor of Money#new(0, \"EUR\").\nDeprecation target set to Money 3.5.0. (closed by 31214fe8374f8ae26f93ab8de5c5243a6b4d6f2d)\n. In d579d110d987e50ac579fc9af7806b440378d3f9 I also removed all the deprecations with target v3.2.0. I made it in a branch then merged the branch so we can easily revert the merge if we don't agree with it. \n. Just to know, are you going to include the BigDecimal, #dollars and core extension changes in a 3.1.x release?\nIMHO, they all deserve a minor bump ;)\nBy the way, I reverted the commit. I'm going to push the changes tomorrow.\n. For future reference, here's a tutorial to revert the revert of a merge.\nhttp://www.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.txt\nRequired to re-include the branch in to master when we are ready to merge the changes.\n. Pushed the revert commit. Do you want to package a release now or are you waiting for #32?\n. My idea, was to implement a simple guessing mechanism.\nIf the string contains something different than digits, use #parse. Otherwise, use #from_string.\n. Exactly.\n. I'm working on this.\n. Done. All tests passes.\nI also took the time to cleanup the tests according to #28, increase documentation and test coverage.\nhttp://github.com/RubyMoney/money/compare/issue_32\nI didn't include the fix for #30 because I prefer to work on one ticket at time.\n. Cleanup core extensions (closed by 15460e9139acfb02fe19ba4b704b6fb2e1e29176)\n. As of Money 3.1.5 you can use the Money#parse and Money#new_with_dollar methods to work with dollars as opposite of cents.\nTalking about Rails, I haven't been using composed_of for a while because I found it to be too less flexible. Instead, I'm now using a virtual attribute to get/set the Money value to a model.\n. Indeed, but I need to extract it from my project to make it more understandable, and unfortunately I'm quite busy in these days. I'll try to do it asap.\n. Hey Matthew,\nthank you very much for your contributions!\nI posted a few comments on your commits.\nCould you please review them?\nThanks!\n. mbasset, which is your Ruby version?\nWith Ruby 1.8.7-p302 it works\nruby-1.8.7-p302 :004 > Marshal.dump(Money.new(100))\n => \"\\004\\bo:\\nMoney\\b:\\v@centsii:\\n@banko:\\\"Money::Bank::VariableExchange\\b:\\025@rounding_method0:\\v@mutexU:\\nMutex\\\"\\000:\\v@rates{\\000:\\016@currencyo:\\024Money::Currency\\016:\\b@id:\\busd:\\017@separator\\\"\\006.:\\016@iso_code\\\"\\bUSD:\\025@subunit_to_unitii:\\n@name\\\"\\031United States Dollar:\\016@priorityi\\006:\\r@subunit\\\"\\tCent:\\017@delimiter\\\"\\006,:\\f@symbol\\\"\\006$\"\n. Your commit contains severals changes and no tests.\nI strongly encourage you to:\n- split the commit into multiple commits, one for each feature\n- add corresponding tests for each feature\n. elmatou already provided the answer. I just want to say that is perfectly fine to have only one currency attribute, as long as all prices must have the same currency (that makes sense in your example).\nYou might also want to customize the default_currency with an initializer, if different than USD.\nMoney.default_currency = Money::Currency.new('EUR')\n. For me it's ok but I leave the final decision to @semmons99.\nI'm just concerned about the use of extend here compared to all the other includes.\ninclude Comparable\ninclude Arithmetic\ninclude Formatting\nextend Parsing\nWhat about using include and refactoring the Parsing module with\n```\nclass Money\n  module Parsing\n    def self.included(base)\n      base.extend ClassMethods\n    end\nmodule ClassMethods\n  def parse\n  end\n\n  ...\nend\n\nend\nend\n```\nIt's a little bit more complex but it follows the normal Ruby practices.\nWell, perhaps we can leave the code as it is and remember this approach in case we need to include instance methods in the Parsing module (since this will force the use of include instead of extend.\n. Also, Financial software often treat positive amount as debit and negative amounts as credit.\n+1 to keep the ability to manage negative/positive money amounts.\n. Also, the question is: should the second parameter be a cent or a dollar?\nYou usually initialize the object with cents, but when you do 1.to_money you actually assume 1 to mean 1 dollar.\nThus, basically Money.new(100) + 1 means Money.new(100) + Money.new(100).\nThat sounds quite confusing to me. I'm not very sure it makes sense to allow this shortcut, we might probably end up generating some hard-to-debug side effect.\n. That's strange. Actually, the #price object is mapped as a Money instance and the cents/currency mapping should have worked.\n. By default, the result of #format returns exactly the format you are requesting.\n```\nMoney.new(102400, \"USD\").format\n=> \"$1,024.00\"\n```\n. You might want to give a look at Money documentation.\nhttp://money.rubyforge.org/Money.html#format-instance_method\n. It is a method call. It goes where you need it.\nPerhaps you need to study some tutorial about learning programming in Ruby before going ahead with your project. :)\n. This is not the point. I can give you all the explanations you want, but if you don't know how to implement them because you are lacking basic knowledge of how Ruby works, then all the explanations won't never help you.\nYou asked about formatting a money instance. I told you you can use the #format method. I don't know anything about your business, thus I cannot provide you a more accurate answer.\n. Do we really need a to_json, to_xml, to_yaml, ... feature?\nI'm not really sure they makes sense because users might want to use a different to_json logic depending on your application.\nAlso, it is worth to mention that, by default, the JSON library adds a to_json method at Object level. It means, every object is \"jsonificable\". The way it works by default, is to export all the internal object attributes.\nLast but not least, a Money#to_json might probably require a Money.from_json counterpart.\nFrom my very personal point of view, I would delegate the responsibility to create a to_json method to the final user.\n. Also, it's important to keep in mind that the JSON library is actually a gem and is not part of the Ruby Standard Library, at least in Ruby 1.8.7. What if I want to use Yajl instead of JSON? Or any other library? I would have to re-implement this method in any case.\n. I'm very sorry, I'm on vacation with limited connectivity. I'll be back on August 1.\n. Hi @defconomicron, thanks for providing a test application. That's by far one of the most perfect bug report I ever received.\nI'm debugging the issue right now.\nI honestly believe this isn't a Money issue but I'm still working on it.\nI would try to find the cause in some hard-to-debug use of Money cents initializer in place of a dollar initializer, or viceversa.\nI'll get back to you as soon as I have more details.\n. Hello guys, I'm extremely sorry, this is a very busy period for me.\nBTW, I debugged the issue and I found the problem.\nThis is not an ActiveRecord bug, nor a Money bug. The bug is in the way you use composed_of.\nThe composed field is a virtual attribute. You must make sure the composed field doesn't match the name of an existing, real, table column, otherwise you'll get an unexpected behavior.\nIn your case, the behavior is that the Money gem stores the price in cents internally. Each time you were calling composed_of, you were creating a kind of recursive call where ActiveRecord loaded the value of price and set it as new price.\nBut because when you set the price to 1, you actually save 100, then the second time you were passing 100 that were saved as 10000 and so on.\nNeedless to say, if you had chosen a currency where dollars are equal to 10 cents, then you would have experienced the same issue but prices would have been increased by 10.\nI forked the invoices repository and pushed a fix. See weppos/invoices@5339785ff2139948d82d81212a9a2c7a445eadc3\n. This is one of these cases where overriding a default method doesn't make any sense to me.\nWhy don't you simply define your own formatting method delegating to Money#format method passing a default set of options? Here's an example using a Formatter module.\n``` ruby\nmodule Formatter\n  def self.money(money, options = {})\n    # set default options\n    options = options.dup\n    options.key?(:symbol) || option[:symbol] = false\n    options.key?(:with_currency) || option[:with_currency] = true\nmoney.format(options)\n\nend\nend\nm = Money.us_dollar(100)\nFormatter.money(m)\n=> \"$1.00\"\nFormatter.money(m, :symbol => false)\n=> \"1.00\"\n```\nNo need to redefine Money#format behavior.\n. If you don't like Formatter.money(Money.new(...), ...), define an additional method in the Money class.\n``` ruby\nclass Money\n  # Note. The name mimic the Rails conventions\n  # for dates and times.\n  # Feel free to rename it.\n  def to_formatted_s(options = {})\n    # set default options\n    options = options.dup\n    options.key?(:symbol) || option[:symbol] = false\n    options.key?(:with_currency) || option[:with_currency] = true\nformat(options)\n\nend\nend\nMoney.to_formatted_s\n```\nRedefining the default formatter is not a good idea, other libraries you include in your project might actually rely on the default Money behavior.\n. This is a responsibility of your view. It depends on how you create your view.\nYou might want to add a condition to display an empty field if the money value is 0, or you can optionally set the attribute to nil. Last but not least, you might want to use JavaScript to cleanup the field.\n. You're welcome. Feel free to post here if you need further assistance.\n. It's already there, it's called :symbol_first.\nhttps://github.com/RubyMoney/money/blob/v3.7.1/lib/money/currency.rb#L25\n. What about moving it to the currency_bc.json file?\n. > That would be fine with me if someone would like to submit a patch.\nI'll do.\n. Does the validates_presence_of :total_cost line works (apart from the tests)?\nI don't know whether the shoulda matcher is compatible with composed attributes. You can write a custom test instead of using the matcher.\n. In my experience, the composed_of attribute seems to be the cause of several headache. People use it most of the time, but I prefer to skip it.\nIn my applications, I actually handle the composition of my money objects separately because sometimes I want the view to display only the dollar value, other times the full object, rarely the cents value.\nBecause you use value.to_money in the constructor, your Rails application is able to convert\n100 USD\ninto the corresponding Money.new(10000, \"USD\") instance, as long as your input displays both dollar and currency. If you only display the dollar value, you need to pass the currency as hidden object or in some other way.\n. I'm not a real fan of this patch. Let me explain why.\nThe Currency table is a class-wide object. When you define a new instance, you actually work at instance level.\nIn this specific case, It doesn't make sense for me that the initializer of a new instance is allowed to modify the class-level list of currencies. It's counter intuitive. You wouldn't expect it to modify the global list of currencies.\nIt's also pretty hard to debug in a large application and it can be the cause of some unexpected side effects.\nNothing prevents you to add the currency before actually creating the  Money instance. In this case, it's more explicit that the new currency will be available across the entire application.\nTwo other things prevents this pull request to be merged:\n1. Please do not add new dependencies to the gem, unless strictly required or previously discussed (9a33efdd8823f1729c3a261b0cd498bc2100bece)\n2. Please one pull request one feature. Open a separate pull request for 2943953540f407f003fdd1aab09bb2332695d781\n. Honestly, exchange_to would be enough for me but @pelle's comment makes sense.\nJust a couple of notes:\ngiven_currency = Currency.wrap(given_currency) if given_currency\ncan be simplified to \ngiven_currency = Currency.wrap(given_currency)\nAlso, the method is missing the @param signature.\n. Merged, thank you.\n. Finished to cleanup all the specs.\nIf feedback is ok, I'll merge the branch and I was thinking about preparing a 4.0.2 release.\n. You're right. Here's the error log.\n```\nweppos-macair:money weppos$ export JRUBY_OPTS=--1.9\nweppos-macair:money weppos$ jruby -v\njruby 1.6.5 (ruby-1.9.2-p136) (2011-10-25 9dcd388) (Java HotSpot(TM) 64-Bit Server VM 1.6.0_29) [darwin-x86_64-java]\nweppos-macair:money weppos$ rake\n/Users/weppos/.rvm/rubies/jruby-1.6.5/bin/jruby -S rspec ./spec/core_extensions_spec.rb ./spec/currency_spec.rb ./spec/money_spec.rb ./spec/bank/base_spec.rb ./spec/bank/variable_exchange_spec.rb ./spec/money/arithmetic_spec.rb ./spec/money/formatting_spec.rb ./spec/money/parsing_spec.rb\n..............................................................................................................................................................................F.F.F........F...F.F.F.........F............................\nFailures:\n1) Money formatting#format respects :subunit_to_unit currency property\n     Failure/Error: Money.new(10_00, \"BHD\").format.should == \"\u0628.\u062f1.000\"\n       expected: \"\u0628.\u062f1.000\"\n            got: \"\\xD8\\xA8.\\xD8\\xAF1.000\" (using ==)\n     # ./spec/money/formatting_spec.rb:93:in `(root)'\n2) Money formatting#format respects the thousands_separator and decimal_mark defaults\n     Failure/Error: one_thousand[\"GBP\"].should == \"\u00a31,000.00\"\n       expected: \"\u00a31,000.00\"\n            got: \"\\xC2\\xA31,000.00\" (using ==)\n     # ./spec/money/formatting_spec.rb:106:in `(root)'\n3) Money formatting#format inserts thousands separator into the result if the amount is sufficiently large and the currency symbol is at the end\n     Failure/Error: Money.euro(1_234_567_12).format.should == \"1.234.567,12 \u20ac\"\n       expected: \"1.234.567,12 \u20ac\"\n            got: \"1.234.567,12 \\xE2\\x82\\xAC\" (using ==)\n     # ./spec/money/formatting_spec.rb:142:in `(root)'\n4) Money formatting Money formatting#format :no_cents option respects :subunit_to_unit currency property\n     Failure/Error: Money.new(10_00, \"BHD\").format(:no_cents => true).should == \"\u0628.\u062f1\"\n       expected: \"\u0628.\u062f1\"\n            got: \"\\xD8\\xA8.\\xD8\\xAF1\" (using ==)\n     # ./spec/money/formatting_spec.rb:162:in `(root)'\n5) Money formatting Money formatting#format :symbol option (:symbol => true) returns symbol based on the given currency code\n     Failure/Error: one[\"GBP\"].should == \"\u00a31.00\"\n       expected: \"\u00a31.00\"\n            got: \"\\xC2\\xA31.00\" (using ==)\n     # ./spec/money/formatting_spec.rb:205:in `(root)'\n6) Money formatting Money formatting#format :symbol option (:symbol => some non-Boolean value that evaluates to true) returns symbol based on the given currency code\n     Failure/Error: Money.new(100, \"GBP\").format(:symbol => true).should == \"\u00a31.00\"\n       expected: \"\u00a31.00\"\n            got: \"\\xC2\\xA31.00\" (using ==)\n     # ./spec/money/formatting_spec.rb:242:in `(root)'\n7) Money formatting Money formatting#format :symbol option defaults :symbol to true\n     Failure/Error: money.format.should == \"\u00a31.00\"\n       expected: \"\u00a31.00\"\n            got: \"\\xC2\\xA31.00\" (using ==)\n     # ./spec/money/formatting_spec.rb:259:in `(root)'\n8) Money formatting Money formatting#format :symbol_position option inserts currency symbol before the amount when set to :before\n     Failure/Error: Money.euro(1_234_567_12).format(:symbol_position => :before).should == \"\u20ac1.234.567,12\"\n       expected: \"\u20ac1.234.567,12\"\n            got: \"\\xE2\\x82\\xAC1.234.567,12\" (using ==)\n     # ./spec/money/formatting_spec.rb:317:in `(root)'\nFinished in 17.18 seconds\n234 examples, 8 failures\nFailed examples:\nrspec ./spec/money/formatting_spec.rb:92 # Money formatting#format respects :subunit_to_unit currency property\nrspec ./spec/money/formatting_spec.rb:100 # Money formatting#format respects the thousands_separator and decimal_mark defaults\nrspec ./spec/money/formatting_spec.rb:141 # Money formatting#format inserts thousands separator into the result if the amount is sufficiently large and the currency symbol is at the end\nrspec ./spec/money/formatting_spec.rb:161 # Money formatting Money formatting#format :no_cents option respects :subunit_to_unit currency property\nrspec ./spec/money/formatting_spec.rb:199 # Money formatting Money formatting#format :symbol option (:symbol => true) returns symbol based on the given currency code\nrspec ./spec/money/formatting_spec.rb:241 # Money formatting Money formatting#format :symbol option (:symbol => some non-Boolean value that evaluates to true) returns symbol based on the given currency code\nrspec ./spec/money/formatting_spec.rb:254 # Money formatting Money formatting#format :symbol option defaults :symbol to true\nrspec ./spec/money/formatting_spec.rb:316 # Money formatting Money formatting#format :symbol_position option inserts currency symbol before the amount when set to :before\norg.jruby.exceptions.RaiseException: (SystemExit) exit\nrake aborted!\nruby /Users/weppos/.rvm/rubies/jruby-1.6.5/bin/jruby -S rspec ./spec/core_extensions_spec.rb ./spec/currency_spec.rb ./spec/money_spec.rb ./spec/bank/base_spec.rb ./spec/bank/variable_exchange_spec.rb ./spec/money/arithmetic_spec.rb ./spec/money/formatting_spec.rb ./spec/money/parsing_spec.rb failed\nTasks: TOP => default => spec\n(See full trace by running task with --trace)\nweppos-macair:money weppos$ \n```\nInvestigating...\n. The issue exists on master, it doesn't belong to this branch.\nI run the tests against master and they fails.\nIf you agree, I'll merge this branch and file a separate issue. I'll try to get it working for today.\n. I'm not sure this method is a good fit for this Gem. After all, this gem is about Money, not \"everything somehow related to moneys and currencies\".\nAlso, the feature would open several questions. For example, what EUR should return?\n. The issue seems to be caused by the JSON.parse line.\nReading the JSON file in jRuby works perfectly. But as soon as the JSON string is parsed, the symbol is converted.\njruby-1.6.5 :005 > j = JSON.parse(s)\njruby-1.6.5 :006 > j[\"eur\"]\n => {\"priority\"=>2, \"iso_code\"=>\"EUR\", \"name\"=>\"Euro\", \"symbol\"=>\"\\xE2\\x82\\xAC\", \"subunit\"=>\"Cent\", \"subunit_to_unit\"=>100, \"symbol_first\"=>false, \"html_entity\"=>\"&#x20AC;\", \"decimal_mark\"=>\",\", \"thousands_separator\"=>\".\", \"iso_numeric\"=>\"978\"}\n. I believe it's the same issue reported at intridea/multi_json#25\n. Tests pass if I use require 'json/pure' as commented in the multi_json issue.\n```\nweppos-macair:money weppos$ rspec spec/money/formatting_spec.rb \n.............................................\nFinished in 16.9 seconds\n45 examples, 0 failures\n```\nAt this point I'm quite sure it's a JSON (or interpreter) issue, not something we can easily fix on Money side.\n. We can leave it open for now. Actually, this is not Money's fault, hence we\ncan eventually close it and redirect to the issue in case someone will\ncomplain about it.\nThe issue itself includes a possible workaround, though it must be\nimplemented application-wide.\nOn Wednesday, December 14, 2011, Shane Emmons \nreply@reply.github.com\nwrote:\n\nPerhaps we leave this open and keep taps on the issue. I would imagine\nthis is a JRuby bug if all other implementations work right.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/131#issuecomment-3141130\n. Thank you @plentz. I subscribed the issue, I'll wait for it to be merged and I'll restore the travis config for JRuby in 1.9 mode.\n. I never faced this issue, but it's a very interesting topic to keep in mind. Thank you very much for point it out.\n\nI think we need to find a solution. Handling the currency key as String might be the solution. However, changing the way we store currencies would break applications that access TABLE directly, though this is not recommended.\nI'm +1 for changing keys to Strings. I'm thinking about a solution to minimize the impact.\n. +1 for ParseError. The ArgumentError is quite generic and can't be handled very well at higher levels.\n. What would you expect exactly?\nIt's also important to underline that String parsing is always a guessing and it's likely to not cover all possible (and infinite) ways you can use to format a Money object.\n. I confess my ignorance, I just noticed that in bookkeeping negative amounts are sometimes represented with a number in a number in parentheses.\nhttp://en.wikipedia.org/wiki/Negative_number\nHonestly, I always believed that String#to_money should be able to parse a restricted set of formats, to avoid dealing with complex exceptions and cases. We already have to deal with different conventions originated from having currencies from all over the world.\nI believe we already crossed the line with #133. The more cases we accepts, the more we increase the possibility that you will encounter side effects trying to parse existing outputs. If we investigate all fields where money are involved, from booking to accountants, etc... there are tons of possibilities and sometimes the same output in a field has a different meaning in another field. Or to put it in another way, I'm quite sure (1000\u20ac) doesn't have the same meaning here in Italy.\nIMHO, String parsing should just provide basic capabilities. You can always write your own custom parser based on String#to_money. It's like the difference we have in Ruby between Date.parse and Date.strptime.\nI'm curious to know what other Money contributors think about this topic.\nIn any case, thank you @WhiteFire-Sondergaard for opening this issue, we always appreciate feedback from users! :)\n. > Seeing a little mixed feedback here?\nIn my previous comment I just expressed my POV. In fact, I also said I was curious to understand other contributors' POV.\n\nOtherwise someone that is feeding a form field into string.money is going to have a user pasting from a ledger or excel getting the nasty surprise of negative becoming positive.\n\nI could reverse the sentence and say: if someone in Europe pastes a content from an Excel where the value has parenthesis, it woud probably be surprised to see the money amount converted to a negative value.\nPersonally, I believe the ignore a not globally and uniquely identified standard is better than assuming a standard for the US market can be applied to all other markets. I could be wrong, but it's always easier to build your parser on top of String#to_money to make it more intelligent, rather than trying to force the library to not be too intelligent.\nAgain, I can be wrong. But I see these kind of changes very complex to handle without generating side effects. Just my 2 cents.\n@WhiteFire-Sondergaard, do you know if this kind of convention only exists for US or also for other countries?\n. Sorry guys, I'm in san francisco on vacation. I have a few ideas in mind,\nI'll post them when I'll be back in Italy\nOn Jan 1, 2012 3:22 PM, \"Shane Emmons\" \nreply@reply.github.com\nwrote:\n\nI'm going to close this. We can revisit this if we start having more pain.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/135#issuecomment-3326451\n. If you want to initialize a Money object from a string use Money.from_string(\"100\"). \n. Yep. I'm considering to write some sort of blog post/wiki page to definitely document the procedure, since it's a very recurring topic. Give me a couple of days.\n. The current Money version is 4.0.2. Please update to the latest version and let us know if the issue is fixed.\n. I just noticed you are using a ISO4217::Currency::ExchangeBank:0x104f9b820 object. I'm sorry, but this object doesn't belong to Money.\n\nIt seems you are using a Bank object provided by a different gem. Please check the documentation for that gem.\n. The default is Money::Bank::VariableExchange\nhttps://github.com/RubyMoney/money/blob/master/lib/money/money.rb#L53\n. The default exchange bank object requires you to manually specify the exchange rate.\nPlease check the Money README file to learn about adding rates or using alternative bank implementations (section Currency Exchange).\nhttps://github.com/RubyMoney/money/blob/master/README.md\n. From http://ruby-doc.org/core-1.9.3/Object.html#method-i-eql-3F\n\nEquality\u2014At the Object level, == returns true only if obj and other are the same object. Typically, this method is overridden in descendant classes to provide class-specific meaning.\nUnlike ==, the equal? method should never be overridden by subclasses: it is used to determine object identity (that is, a.equal?(b) iff a is the same object as b).\nThe eql? method returns true if obj and anObject have the same value. Used by Hash to test members for equality. For objects of class Object, eql? is synonymous with ==. Subclasses normally continue this tradition, but there are exceptions. Numeric types, for example, perform type conversion across ==, but not across eql?, so:\n\nAbout #===\n\nCase Equality\u2014For class Object, effectively the same as calling #==, but typically overridden by descendants to provide meaningful semantics in case statements.\n. Ops, fixed.\n. +1 for me. The time has come to avoid altering the TABLE hash directly.\n. Before going into the details of the patch, I'm just wondering what is the overall opinion about supporting Rails directly into the gem.\n. I agree with @ohthatjames. In fact, I have the same concern about testing.\n. Could you explain why you need a nil amount? Isn't a nil amount different than assigning a nil value to the variable?\n. The Money library isn't designed to store nil values. Honestly, it's hard to keep track of all side effects that your change would cause. For example, the library uses BigDecimal.\n\nIt seems you can initialize a BigDecimal object passing an empty string with Ruby 1.9.3\n1.9.2p318 :002 > BigDecimal.new(\"\")\n => #<BigDecimal:7fd97b17d9d0,'0.0',9(9)>\nbut if this behavior will change in the future, your implementation will fail. This is just one example.\nI would suggest you to follow a different approach and keeping the empty value to 0. For example, you can add a new flag to each money instance.\nclass Money\n  attr_accessor :inherited\nend\nand instruct your application to check for this attribute, instead of the internal value. If the attribute is true, then the behavior would be the same of a nil amount.\n. > Just wondering: is that something we should add maybe on the readme?\nThis is a very specific need I would not worry about mentioning it in the README. Chances are similar needs might have different solutions, depending on the project where the solution applies.\n. A money instance with a nil amount doesn't make sense from an implementation point of view. Money is a framework agnostic library, we don't really tie to a specific ORM.\nI'm a Rails and ActiveRecord user as well and I honestly never faced this issue. A nil value for a money object is equal to say the value is nil. Think it for a second: when an Integer value is nil in ActiveRecord you get a nil, you don't get an Integer that returns nil. This is the same here.\nThere's no validation issue in ActiveRecord. Depending on how you implemented the integration, you should be able to check whether the specific column in the database is nil.\nTo summarize, you can have 3 cases:\n1. the field has a value different than 0 and the returned object is a Money with amount different than 0\n2. the field has a value equal to 0 and the returned object is a Money with amount 0\n3. the field has no value and the returned object is nil\n. You don't need 3 columns. You need just one, may be two in case you also want to save the currency.\nLet's say you want to save an order price. You need one (or two) columns:\n- Order#price_cents - Integer, null allowed\n- Order#price_currency - String, limit 3\nIf price_cents != nil then you can return a Money instance, if price_cents == nil then return nil.\n. Here's an example using two fields.\n``` ruby\nclass Order < ActiveRecord::Base\n  def price\n    if price_cents?\n      Money.new(price_cents, price_currency)\n    end\n  end\ndef price=(value)\n    if value.nil?\n      price_cents, price_currency = nil, nil\n    else\n      money = value.to_money\n      price_cents, price_currency = money.cents, money.currency.to_s\n    end\n  end\ndef price?\n    !price.nil?\n  end\nend\n``\n. Sorry @thbar, when I replied your post I probably didn't notice you were referencing an ActiveRecord object. For some reason, I thought you were re-opening the Money class. I probably read the implementation without paying attention to the class definition. My fault.\n. Because this is a Rails information, I believe it belongs to the new [RubyMoney/money-rails](https://github.com/RubyMoney/money-rails) project.\n. @thbar feel free to propose a README update. At this time, I'm not sure whether it would be better here or in the money-rails repo. :)\n. I honestly don't see the need of a new special method just to accomodate ActiveRecord needs. Moreover, the checkinput =~ /[0-9]/` is very opinionable, other users might need a different validation match and we will end up trying to match everyone's needs.\nWhat's wrong with the following custom validation?\nruby\ncomposed_of :price,\n  :class_name => \"Money\",\n  :mapping => [%w(price_cents cents), %w(currency currency_as_string)],\n  :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n  :converter => Proc.new { |value| \n    if value.respond_to?(:to_money)\n      if input =~ /[0-9]/\n        value.to_money\n      else\n        raise ArgumentError, \"`input' should contain a numeric character\"\n      end\n    else\n      raise ArgumentError, \"Can't convert #{value.class} to Money\"\n    end\n  }\nPS. In case the patch will pass the approval, please note that tests are requires in order to merge the pull request.\nBTW, thanks for taking the time to contribute!\n. It's a common Ruby pattern to use the bang version (foo vs foo!) to denote a method that changes the receiver and/or a method that raises compared to a one that silently returns. This is a very common approach in ORMs, but you can find it in other libraries.\nI'm not sure it makes 100% sense here because #135 is still unsolved and unless we standardize the way we want to parse inputs, the regular expression pattern will be very opinionable.\nSo far, this is the first time this request comes. Let's see if someone else has the same need, in case we will collect all the feedback and start working on it. Users are free to re-open the Money library and add the to_money! method if requires.\nJust to clarify my point of view, there are two additional aspects that prevents me to vote in favor of this feature:\n- I honestly haven't find a real case where to_money! would make sense. The example above isn't probably the best one.\n- We should remember that to_money is provided to several Ruby classes, not only to String. We have Fixnum and many others. I can't find a reasonable implementation of Fixnum#to_money! May be we want to talk about Money#parse and Money#parse!, rather than String#to_money!\n. Hi @kirillian. Thanks for the patch. It's not clear to me why you need to change the initialization method. Wouldn't be sufficient to pass the precision to the format method?\n. I agree this might be an interesting feature, but I honestly don't like the idea to create tons of currency instances. If we really want to add this feature, I would vote for an internal refactoring. The precision can be an attribute of the money object and methods will have to be updated accordingly.\nJust my 2 cents.\nPS. As a side note, the format method is becoming pretty complex.\n. I had one week off. Checking the code...\n. Integrated in 89ba651\n. Good point.\n. Merged!\n. The order is defined as part of the Currency in the :symbol_first property.\nIf you have specific needs that go beyond the default formatting, keep in mind you can always use #to_s and #symbol to prepare your own helper.\n``` ruby\nc = Money.new(100)\n=> #\nputs \"#{c} #{c.symbol}\"\n=> \"1.00 $\"\n```\nI would avoid haking the #format method because it's already very complex and it's really that simple to format the object the way you want using the methods above.\n. What is the official currency for Zimbabwe at the time being?\n. Feel free to go ahead and create one pull request for each request. We'll review them and see if it makes sense to merge them into the code base.\nThe changes you requested seems trivial but they aren't. For every change, documentation should be written in order to make sure users won't be confused.\nPS. This ticket breaks the single responsibility principle as well. You started a discussion for at least 3 different changes in the same issue. ;)\n. Since the beginning, Money#parse has been dealing with data parsing as opposite of Fixnum|Integer#to_money where you don't need to parse anything but just create the necessary Money object calculating the correct amount.\nMoney#parse is a quite complex method and there were attempts in the past to simplify it. Removing the core extensions and moving the logic into Money.parse seems a step backward to me. In fact, you should also be aware that Numeric#to_money relies on Money.from_numeric while String#to_money relies on Money.parse.\nWhether these extensions provide or not a real value, this is a different topic. In Ruby is perfectly fine to reopen classes. Despite this approach leads to money-patches in many cases, it doesn't mean you should avoid reopening classes at all. I don't believe the use we did of this feature in the Money library can be classified as monkey patching. We're re-opening classes in order to add extensions. After all, we're not redefining String core methods or patching them.\nThat said, we can discuss about the benefit of providing core extensions or not. I personally don't use them in this case, but they don't hurt me. I would vote +1 for removing the #to_currency extensions (it's very unlikely that someone needs to play with currencies directly), but I have no preference for keeping or removing #to_money.\n. -1 for me\nHere's the reason:\nYAML had several issues in the past. Unless you are using Ruby 1.9.3 where Psyck is enabled by default, all the other Ruby versions use Syck which is an outdated and buggy implementation. Not to mention, Syck is incredibly slow compared to other parsers, including the JSON parser.\nGiven that JSON is part of Ruby library (I honestly don't remember since which revision), I would prefer to use JSON.\nThis also avoid issues with other users/tools that are currently using our JSON data to power their libraries.\nI honestly don't remember the issue we had with JRuby. Maybe it's time to check if the issue was solved and use the default JSON library.\n. There's something that I can't understand. We are going back storing again the definitions in a Ruby Hash and we keep the dependency to JSON?\nAnyway, I'm -1 to go back to a Ruby Hash. I personally prefer to keep definitions outside the Ruby library, ideally as JSON. I'm currently working in this way for the whois library as well. The idea is to move definitions to a general format so that other libraries and other languages can benefit from it.\n. I believe we're falling into the trap of over-optimization.\nWhy are we doing all this stuff? To remove the dependency to multi_json. What's wrong with multi_json? So, to remove dependency with multi_json we want to extract currencies into a new gem, which will became a dependency, and have the extra-effort of maintaining a new gem?\nI really don't see the reason for all of this. I actually don't see any good reason why we should remove the dependency to multi_json at any cost if the new solutions will require the equal amount of effort to be maintainer (or in the worst case more effort).\nI will vote +1 only if the solution to remove multi_json is by using the JSON library that comes with the standard Ruby implementation (whatever it is). If this is not possible for whatever reason and multi_json is currently the only solution... let's go ahead with it.\nAgain, what's wrong with multi_json. So far, we had no complaints about it. multi_json has no dependencies on other libraries, thus I believe our current money -> multi_json dependency chain is skinny enough to let me sleep very well at night.\n. More on this topic. I didn't have the time to check the reason why we can't use JSON.load. It seems the issue with JRuby is fixed and, so far, the only reason is the one described in #170.\nIf that's the case, the issue is really simple to be solved. We have two options:\n1. don't use any symbolize key. Load keys as strings and symbolize them later on the same method. Here's a symbolize_key implementation.\n2. Create a very simple adapter inside Money that simply checks whether yajl-ruby is used and pass the right option.\nI personally prefer the first choice.\n. -1 for me. Liquid is a good library, but if we follone this path we should\nadd (and maintain) tons of code to support interaction between various ruby\nlibraries.\nI think It's fair enough to delegate the end user to add the alias in this\ncase to its own codebase.\nOn Monday, August 27, 2012, Carsten Block wrote:\n\nbump\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/207#issuecomment-8067206.\n\n\nSimone Carletti\nApplication Developer\nSite & Blog: http://www.simonecarletti.com/\nLinkedIn: http://linkedin.com/in/weppos\nSkype: weppos\n. ",
    "spatrik": "I think patch broke the composed_of example for using the money gem with rails.\nIn my model I have:\ncomposed_of :price,\n  :class_name => \"Money\",\n  :mapping => [%w(cents cents), %w(currency currency)]\nSaving a variant object works, but when I load it back from the database, I get a YAML string instead:\nv2.currency # => \"--- !ruby/object:Money::Currency \\nid: :sek\\niso_code: SEK\\nname: Swedish Krona\\npriority: 100\\nsubunit: !binary |\\n  w5ZyZQ==\\n\\nsubunit_to_unit: \\\"100\\\"\\nsymbol: kr\\n\"\nI have found two solutions to this, the first is to add serialize :currency to my model. The other way is to add a currency_iso_code method to the Money class and use that as a mapping instead. \n. The :converter option is only used when the assigned object is of another class than specified (Money in this case). It can be used to make variant.price = 100 be converted to Money.new(10000, 'SEK') for example, but if I send a Money object the converter is not run. \nIn my example above I have cents and currency in separate columns, what happens is that AR runs something like write_attribute(:currency, money_object.send(:currency)). In 2.2, currency would have been a string, which gets saved properly, but since it's an object in 2.3, AR magically serializes it to YAML before saving it. \n. I think patch broke the composed_of example for using the money gem with rails.\nIn my model I have:\ncomposed_of :price,\n  :class_name => \"Money\",\n  :mapping => [%w(cents cents), %w(currency currency)]\nSaving a variant object works, but when I load it back from the database, I get a YAML string instead:\nv2.currency # => \"--- !ruby/object:Money::Currency \\nid: :sek\\niso_code: SEK\\nname: Swedish Krona\\npriority: 100\\nsubunit: !binary |\\n  w5ZyZQ==\\n\\nsubunit_to_unit: \\\"100\\\"\\nsymbol: kr\\n\"\nI have found two solutions to this, the first is to add serialize :currency to my model. The other way is to add a currency_iso_code method to the Money class and use that as a mapping instead. \n. The :converter option is only used when the assigned object is of another class than specified (Money in this case). It can be used to make variant.price = 100 be converted to Money.new(10000, 'SEK') for example, but if I send a Money object the converter is not run. \nIn my example above I have cents and currency in separate columns, what happens is that AR runs something like write_attribute(:currency, money_object.send(:currency)). In 2.2, currency would have been a string, which gets saved properly, but since it's an object in 2.3, AR magically serializes it to YAML before saving it. \n. ",
    "grimen": "Minimal spec that fails:\nMigration:\n\nclass CreateShippingMethods < ActiveRecord::Migration\n  def self.up\n    create_table :shipping_methods do |t|\n      t.integer     :rate_cents\n      t.string      :rate_currency\n    end\n  end\n\n  def self.down\n    drop_table :shipping_methods\n  end\nend\n\nModel:\n\nclass ShippingMethod < ActiveRecord::Base\n  composed_of(:rate,\n        :class_name => 'Money',\n        :mapping => [\n          ['rate_cents', 'cents'],\n          ['rate_currency', 'currency']\n        ])\nend\n\nFailing specs, either:\n\ndescribe ShippingMethod do\n  before do\n    @shipping_method = ShippingMethod.new\n  end\n\n  it \"it should be possible to set rate to nil\" do\n    @shipping_method.rate_cents = nil\n    @shipping_method.rate_currency = nil\n    @shipping_method.rate.should_not raise_error(NoMethodError)\n  end\n\n  it \"it should be possible to set rate to nil\" do\n    @shipping_method.rate = nil\n    @shipping_method.rate.should_not raise_error(NoMethodError)\n  end\nend\n\nUsing gem money-3.0.2\n. Yes I use such, but didn't include it here - don't seem to be the issue.\n. The problem is that \"something\" is calling #round on nil - should not, or at least fall back from nil to 0. I guess I'll run the debugger if there's no obvious reason, consider it a bug then.\n. 1) There are rate_cents and rate_currency fields in DB, therefore there is #rate_cents= and #rate_currency so the first spec should not fail. It fails with:\n\nMethodError in 'ShippingMethod rate it should be possible to set rate_cents and rate_currency to nil'\nundefined method `round' for nil:NilClass\n\n2) Yes, that is probably what is happening, but that should not fail - ensuring no nil values in DB is kind of waste. Nil should fall back to 0 (in the case of expected integer constructor argument), right? if I haven't missed something that would make more sense thant throwing such errors all over the place. I get them in many places. Otherwise a wonderfult gem, but this is really annoying. =|\n. This looks promising though (from an old issue). Will get back with the result on this:\n\n:constructor  => Proc.new { |cents, currency| (cents.blank? || currency.blank?) ? nil : Money.new(cents, currency) },\n\nfound here: http://github.com/FooBarWidget/money/issues/4#issue/4/comment/224930\n. That did not solve this problem, neither the constructor thingy. I'm still rolling with these errors when value contains nil before or after construction.\n. A solution would be to parse a nil value as 0 in the constructor by default - it totally makes sense too in compare to throwing an error.\n. ...or at least check if the receiving value is a Numeric, and/or responds to #round.\n. I'll experiment with the different suggestions, but if you consider using Money with other than ActiveRecord (or maybe ActiveModel) then the problem will be there still. I think that \"no money\" (nil, 0) is equivalent to \"zero funds\", or what's the opposite argument? Either way, calling #round on anything feels a bit too much assumption in a dynamic language, don't you agree?\n. OK, thanks - will get back if I get in trouble. :)\n. Minimal spec that fails:\nMigration:\n\nclass CreateShippingMethods < ActiveRecord::Migration\n  def self.up\n    create_table :shipping_methods do |t|\n      t.integer     :rate_cents\n      t.string      :rate_currency\n    end\n  end\n\n  def self.down\n    drop_table :shipping_methods\n  end\nend\n\nModel:\n\nclass ShippingMethod < ActiveRecord::Base\n  composed_of(:rate,\n        :class_name => 'Money',\n        :mapping => [\n          ['rate_cents', 'cents'],\n          ['rate_currency', 'currency']\n        ])\nend\n\nFailing specs, either:\n\ndescribe ShippingMethod do\n  before do\n    @shipping_method = ShippingMethod.new\n  end\n\n  it \"it should be possible to set rate to nil\" do\n    @shipping_method.rate_cents = nil\n    @shipping_method.rate_currency = nil\n    @shipping_method.rate.should_not raise_error(NoMethodError)\n  end\n\n  it \"it should be possible to set rate to nil\" do\n    @shipping_method.rate = nil\n    @shipping_method.rate.should_not raise_error(NoMethodError)\n  end\nend\n\nUsing gem money-3.0.2\n. Yes I use such, but didn't include it here - don't seem to be the issue.\n. The problem is that \"something\" is calling #round on nil - should not, or at least fall back from nil to 0. I guess I'll run the debugger if there's no obvious reason, consider it a bug then.\n. 1) There are rate_cents and rate_currency fields in DB, therefore there is #rate_cents= and #rate_currency so the first spec should not fail. It fails with:\n\nMethodError in 'ShippingMethod rate it should be possible to set rate_cents and rate_currency to nil'\nundefined method `round' for nil:NilClass\n\n2) Yes, that is probably what is happening, but that should not fail - ensuring no nil values in DB is kind of waste. Nil should fall back to 0 (in the case of expected integer constructor argument), right? if I haven't missed something that would make more sense thant throwing such errors all over the place. I get them in many places. Otherwise a wonderfult gem, but this is really annoying. =|\n. This looks promising though (from an old issue). Will get back with the result on this:\n\n:constructor  => Proc.new { |cents, currency| (cents.blank? || currency.blank?) ? nil : Money.new(cents, currency) },\n\nfound here: http://github.com/FooBarWidget/money/issues/4#issue/4/comment/224930\n. That did not solve this problem, neither the constructor thingy. I'm still rolling with these errors when value contains nil before or after construction.\n. A solution would be to parse a nil value as 0 in the constructor by default - it totally makes sense too in compare to throwing an error.\n. ...or at least check if the receiving value is a Numeric, and/or responds to #round.\n. I'll experiment with the different suggestions, but if you consider using Money with other than ActiveRecord (or maybe ActiveModel) then the problem will be there still. I think that \"no money\" (nil, 0) is equivalent to \"zero funds\", or what's the opposite argument? Either way, calling #round on anything feels a bit too much assumption in a dynamic language, don't you agree?\n. OK, thanks - will get back if I get in trouble. :)\n. ",
    "ismasan": "Ah crap I had just fixed it. http://github.com/ismasan/money\nThanks though!\n. Still, I updated subunit_to_unit and delimiters for the MIGHTY Chilean Peso, which were wrong.\n. Excellent, thanks!\nI think I'd like to add a few improvements to this PR before merging, actually. Particularly around importing/exporting data. It'd be nice to have a better, more generic API that allowed us to do this with other store implementations and not just the in-memory one.\nSo I've got a question for you: the current code uses an optional Mutex (the default is true) for thread-safe access to the main exchange rates data structure.\nruby\nif opts[:without_mutex]\n  block.call self\nelse\n  @mutex.synchronize(&block)\nend\nThis means that all store methods need to take an options hash so users are able to enable/disable the mutex on a per-method basis.\nThe question is: is this necessary? When is using a mutex not a good idea? Could it not be always enabled and not be optional?\nIf the answer is no, would it make sense that the mutex option is enabled once on store initialization?\nruby\ndef initialize(opts = {})\n  @without_mutex = opts[:without_mutex]\nend\nThis would simplify the #add_rate, '#get_rate` interface and also mean that the bank instance wouldn't need to know anything about store thread-safety (allowing for more generic import/export).\nI'm not sure whether the current mutex functionality is used at all and whether the proposed changes would affect users significantly.\n. To complement this: the basic Store API that I've got in mind is the following\nInitialize:\n``` ruby\ninitialize(opts_hash)\n```\nAdd rate:\n``` ruby\nadd_rate(iso_from, iso_to, float_rate)\n```\nGet rate:\n``` ruby\nget_rate(iso_from, iso_to)\n```\nIterate and yield rates in tuples iso_from, iso_to, float_rate. Returns an Enumerator:\n``` ruby\neach_rate(&block)\n```\nRun a thread-safe transaction (or an IO or database transaction, depending on the store backend):\n``` ruby\ntransaction(&block)\n```\nWith this, banks can implement import and export methods while being completely agnostic of the store implementation.\nImporting:\n``` ruby\ndata = parse_data_from(some_raw_data)\nstore.transaction do\n  data.each do |iso_from, iso_to, rate|\n    store.add_rate iso_from, iso_to, rate\n  end\nend\n```\nExporting:\n``` ruby\ndata = store.transaction do\n  store.each_rate.each_with_object({}) do |(from,to,rate),hash|\n    hash[\"#{from}_#{to}\"] = rate\n  end\nend\nJSON.generate(data) # or YAML, etc.\n```\nFor this to work, all the knowledge about thread safety needs to be encapsulated in the stores, and banks should not need to know anything about it.\nHope this makes sense.\n. Excellent, so I'll make it thread-safe by default, but keep the option to disable it at the Store#initialize level instead on each method call.\n. Ok, I've pushed the latest changes, See Readme for details.\nNotes:\nRatesStore::Memory and Bank::variableExchange both use \"_TO_\" as a separator to serialize/deserialize exchange rates, but I've added a bit of duplication because they should be separate concerns:\n- RatesStore::Memory only uses that for internal indexing of rates. Banks should not know about internal data structures.\n- Bank::VariableExchange uses the same separator just to keep backwards compatibility with the data formats uses on Bank#export_data and Bank::import_data.\nIn the future we could separate data parsing and mapping from banks. But that's a different pull request.\nLet me know what you think.\n. Yeah someone beat me to the merge:)\nI'll do it in a few hours.\nIsmael Celis\n\nOn 21 May 2015, at 19:06, Shane Emmons notifications@github.com wrote:\nneed a rebase before I can merge\n\u2014\nReply to this email directly or view it on GitHub.\n. Rebased.\n. Ah crap I had just fixed it. http://github.com/ismasan/money\n\nThanks though!\n. Still, I updated subunit_to_unit and delimiters for the MIGHTY Chilean Peso, which were wrong.\n. Excellent, thanks!\nI think I'd like to add a few improvements to this PR before merging, actually. Particularly around importing/exporting data. It'd be nice to have a better, more generic API that allowed us to do this with other store implementations and not just the in-memory one.\nSo I've got a question for you: the current code uses an optional Mutex (the default is true) for thread-safe access to the main exchange rates data structure.\nruby\nif opts[:without_mutex]\n  block.call self\nelse\n  @mutex.synchronize(&block)\nend\nThis means that all store methods need to take an options hash so users are able to enable/disable the mutex on a per-method basis.\nThe question is: is this necessary? When is using a mutex not a good idea? Could it not be always enabled and not be optional?\nIf the answer is no, would it make sense that the mutex option is enabled once on store initialization?\nruby\ndef initialize(opts = {})\n  @without_mutex = opts[:without_mutex]\nend\nThis would simplify the #add_rate, '#get_rate` interface and also mean that the bank instance wouldn't need to know anything about store thread-safety (allowing for more generic import/export).\nI'm not sure whether the current mutex functionality is used at all and whether the proposed changes would affect users significantly.\n. To complement this: the basic Store API that I've got in mind is the following\nInitialize:\n``` ruby\ninitialize(opts_hash)\n```\nAdd rate:\n``` ruby\nadd_rate(iso_from, iso_to, float_rate)\n```\nGet rate:\n``` ruby\nget_rate(iso_from, iso_to)\n```\nIterate and yield rates in tuples iso_from, iso_to, float_rate. Returns an Enumerator:\n``` ruby\neach_rate(&block)\n```\nRun a thread-safe transaction (or an IO or database transaction, depending on the store backend):\n``` ruby\ntransaction(&block)\n```\nWith this, banks can implement import and export methods while being completely agnostic of the store implementation.\nImporting:\n``` ruby\ndata = parse_data_from(some_raw_data)\nstore.transaction do\n  data.each do |iso_from, iso_to, rate|\n    store.add_rate iso_from, iso_to, rate\n  end\nend\n```\nExporting:\n``` ruby\ndata = store.transaction do\n  store.each_rate.each_with_object({}) do |(from,to,rate),hash|\n    hash[\"#{from}_#{to}\"] = rate\n  end\nend\nJSON.generate(data) # or YAML, etc.\n```\nFor this to work, all the knowledge about thread safety needs to be encapsulated in the stores, and banks should not need to know anything about it.\nHope this makes sense.\n. Excellent, so I'll make it thread-safe by default, but keep the option to disable it at the Store#initialize level instead on each method call.\n. Ok, I've pushed the latest changes, See Readme for details.\nNotes:\nRatesStore::Memory and Bank::variableExchange both use \"_TO_\" as a separator to serialize/deserialize exchange rates, but I've added a bit of duplication because they should be separate concerns:\n- RatesStore::Memory only uses that for internal indexing of rates. Banks should not know about internal data structures.\n- Bank::VariableExchange uses the same separator just to keep backwards compatibility with the data formats uses on Bank#export_data and Bank::import_data.\nIn the future we could separate data parsing and mapping from banks. But that's a different pull request.\nLet me know what you think.\n. Yeah someone beat me to the merge:)\nI'll do it in a few hours.\nIsmael Celis\n\nOn 21 May 2015, at 19:06, Shane Emmons notifications@github.com wrote:\nneed a rebase before I can merge\n\u2014\nReply to this email directly or view it on GitHub.\n. Rebased.\n. \n",
    "valodzka": "I thought about constants like BigDecimal provides (ROUND_UP, ROUND_DOWN and other), but your solution is even more flexible. May be even too flexible, but it, of course, ok for me.\n. This issue doesn't have nothings with money gem.\nRuby (and library with it) handles numbers with such precision perfectly, normal databases give you information about error (e.g. \"PGError: ERROR:  integer out of range\").\nProblem only with your database. I recomend to change it to something more robust :).\n. I thought about constants like BigDecimal provides (ROUND_UP, ROUND_DOWN and other), but your solution is even more flexible. May be even too flexible, but it, of course, ok for me.\n. This issue doesn't have nothings with money gem.\nRuby (and library with it) handles numbers with such precision perfectly, normal databases give you information about error (e.g. \"PGError: ERROR:  integer out of range\").\nProblem only with your database. I recomend to change it to something more robust :).\n. ",
    "elmatou": "Guy's I'm bit late on this but.\nI think it's not a very good idea.\nAs it is said in the wikipedia article you link to us, this symbol is context dependent.\nIt has been the cause of very uncomfortable mistakes in past. That's why it isn't very used this 1972...\nIf you keep this commit I'm gonna override it right now ;-)\nAnd why I didn't blame $ ? because everybody knows that it could be any kind of dollars or pesos, or ....\n. I just added the instruction for the converter method in the wiki.\n:converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\n. I semmons,\nJust installed Edge Money : \nMoney.new(1212.45.to_d*100).to_s => \"1212.45\"\nseems to work fine, thank you for response.\n. to speek freely,\nThere is a lot of things I dislike in this list....\nI'am currently working in doing one better, more suitable for my needs. But I am not sure it will be useful for anybody. Anyway I stick to the original model to be reused or patched.\nMy points are :\nCurrency names in english. It is a bit too ethnocentric to me !?\nSymbols are not accurate enough (about 20 times $, same with F and \u00a3)\nI need some missing currencies (eg : all Euro Zone previous euro)\nbegin and end dates for former currencies\nI am also working on an exchange rates module, so I need some other infos...\nA dump of my work is readable at :\nhttps://spreadsheets.google.com/ccc?key=0AkxTvAzcUacHdGVKeUdwZ3ZTbFJCNGtwdVl5MkE4UFE&hl=en&authkey=CN2vqe8H\nAsk for a edit access if anyone wants to help me on the matter.\nSee you.\n. Then I will send you a pull request when I am done.\nBut it's kind hard to find a list with currencies in their native languages, I think I will have to do it by my self....\n. Hi,\nI am totaly aware of the lack of tests, that is the point of the introduction sentence.\nI will write & submit them if the features have any chances to be merged.\nAnyway, the big point to me is the exchange_with thing, as you can see I set the date as an optional argument : def exchange_with(from, to_currency, *date, &block)\nIf somebody use a Bank without the date parameter, he just have to ignore the optional parameter.\nThis argument has to be handled from the Money object to the Bank object (and even to the Rate object in my case). And it need to be implemented in the exchange_to method and then in the exchange_with method.\nThe only alternative I see, is to affect a dedicated Bank for each \"date\" or a dynamic bank...  not very enthousiast !\n. You're right,\nI was working on another topic on these past days, but I will submit my work on Money, in few days.\nbest regards, \n. I'm quite sure that negative Money Object are usefull.\nFirst af all, If you consider a money transfert the amount has to be considered has additive for the reciever and negative for the sender (check on accounting standarts, for more examples).\nOf course you could say : I have only positive coins (or bills if you are more lucky) in my pocket and when I pay something, I substract the amount.\nYes but, if you look at the basic algebra, you'll see there is only two computing operations : addition & multiplication.\nsubstraction have to be considered as the addition of the negative element.\ndivision has to be considered as the multiplication of the inverse element.\nSo what ?\nSo the presence of negative amount and negative modifier are conceptualy corrects.\nBut You'are right, semanticly, it is possible to mess everythings up, if you combine, negative assignation, #.neg modification and substrations computing ; think about, how it could be ambigious:\nMoney.new(0) - Money.new(-100).neg\nI think, you have to choose your point of view for your accounting process (as dealing with money is always a kind of accounting), any operation can be considered as a positive stream of money, or equaly a negative stream.\nOnce you've choosen your pov, you can set your code, in a way, and a positive input in your process will exactly have the oposite meaning of a negative input.\nBy the way, As we couldn't find an understanding on some points (and I do think it is sad) this pull request (and others I have did) wasn't merged in the gem.\n. Does anybody use it this way ?\nI find very strange to have all the .99\u00a4 prices who will be print almost 1\u00a4 lower..\n. I'ill transform my fork to a :precision option wich will do it.\n. - Ok I'will add the alias it is a good idea.\n- Nice !\n- The deprecations are not essentials matter, but would be a good practice, and a good message for the community.\n- #to_hash and an alias in #to_h. IMHO all the attributes aren't very useful and even a bit too much, but if anybody find it useful I will add your code to my commit.\n- Currency::TABLE is another matter. If I do what you propose It will be around 50 commits I'll  have to do.\n  First of all I dumped the Hash into a YAML file (and add a task to build a Ruby source code back), in these way the amendments will be very easy to check with my YAML file, and then we commit only the accepted changes.\n  What do you think about ?! I 'll show you what I mean with a gist in the afternoon (Paris Time)\n. Sure ! Since I work with Google docs it is quite easy, just check the URL below\nhttps://spreadsheets0.google.com/ccc?authkey=CN2vqe8H&hl=en&key=teJyGpgvSlRB4kpuYy2A8PQ&hl=en&authkey=CN2vqe8H#gid=0\nFor CVS tab is the final output , Currencies tab show the changes\n. It was a bit easier than I thought.\nI put in a gist a YAML currencies list https://gist.github.com/842254\nfirst commit is actually a dump of the list in the current version of the gem\nSecond commit is the final version of my work (and needs).\n- Add original_name attribute filled for 80% of the currencies\n- Amendments for 52 symbols, I aimed to have as few $, \u00a3, Fr as possible for better acknowledgment of currencies.\n- Add 23 former currencies (Euro Zone)\nI am quite sure that very few are interested in former currencies, that's why I think the Currency::TABLE should be customizable, or Currency::TABLE stay what it is but the gem should use (Currency#find or #wrap, ...) a customized array of Currencies object. I could push a bit of code of what I did for my usage if you want.\n. I just see that I didn't told that I lost all :symbol_first attributes in my YAML file. I did'nt want to change this attribute.\n. I agree with you, it make more sense...\nWhat about the previous pull request ?!\n. BTW I saw that some of tests used old currencies infos, they will have to be updated if the changes are accepted.\n. And your right ! I am gonna push updated tests tomorrow morning. Anyway everybody need these tests.\n. Hi Shane,\nHere are the updated tests.\nI am quite ashamed but I found some inconsistencies in my YAML file, some decimal_mark and thousand_separator where wrong (but where right in previous file), I set them back is this commit.\nI'll push my I18n branch once the first tow pull request are accepted (I forked from my master and not from upstream/master :-( )\n. True, I'am still working with ruby 1.8.7\nmaybe if you send me the backtraces I'll be able to find a fix.\nBut sorry, I wont fill your yaml gist, it's too many work, and that is precisely why I sent two commits in the pull requests.\nI plan to upgrade (and migrate some apps) to Ruby 1.9.2 by the end of the month, I'll check at this time\n. checkout HEAD of my currencies-yml branch. All currencies are sorted AtoZ and attributes too.\nhttps://github.com/elmatou/money/blob/currencies-yml/lib/fixtures/currencies.yml\nI think this is what you need.\n. Your right Indeed, extraction from Money::Currency::TABLE, gave a strange result for this duplicate keys, probably my mistake. I can do what you ask, but not right now, as my fork work fine for my needs (except that mistake which will be corrected asap), I could bring a even more split commits to the community later.\n. Thx for the heads up !\nThis is a good news, I'm using the gem for any new project right now, but I'm quite sure it is a good move.\n. Hi,\nAs I understand, the issue append on the Money#format call.\nCan you post your composed_of statements please.\nAnd try to log an inspect call on your attributes, maybe your currency attributes is not correctly binded with your prices_xxx attributes.\nPut Rails.logger.debug price_low.inspect  in your #update_changelog method, run your code, and watch your developement.log\nYou should see someting like   \nIf XXX is different from your currency attribute that do mean your composed_of is not correctly set.\nI wrote a little rails helper for this kind of issue. \nyou can grab it here : https://gist.github.com/924331\n. The money object is instanciated with USD because it is yout default currency (which is the default, default currency).\nIt mean that the constructor find your currency attribute is nil (currency || Money.default_currency).\nYour composed_of statements seem to be correct, I guess yout attribute is not correctly set (check for currency.nil?)\nIf you want to use the helpers, copy the file in your lib folder, in your environment.rb call require 'money_helpers' then you will be able to use the helper in your model.\nYou can have only one currency attribute, even if it could be a consitency issue (if you change your price_low currency, it will change your price_high currency as a side effect.).\nHope it helps, tell us your progress.\n. Hi pconnor,\nI had a similar issue few weeks ago.\nLike you, in a specific point in my app, my Money instance was in USD (default currency), but I expected EUR.\nthe point was, I did set the money object directly trough an html form, as I would do it for any other attributes.\nExpense.amount = params[:amount]\nbut params[:amount] is a string (html, http params, ...  know only about strings). And quite normaly the :converter Proc did trigger, this proc use the parser included in the gem... String.to_money exists and works well, but....\n\"102.45\".to_money or \"-123,45\".to_money, create a Money object with the default currency, this is quite normal, because there is no currency information in \"102.45\"...\nIf you get my point, you will understand, that we should rewrite the :converter proc in order to save the old currency, if there was one... but we don't have any knowledge of previous value in this point of the proc, so I recommend to rewritte a proper setter (and the getter to) method, which could be : note tested\n\ndef amount=(thing)\n  if thing.respond_to?(:to_money)\n    if currency.nil?\n      thing.to_money\n    else\n      thing.to_money.currency = currency # is that possible ?\n  else\n    raise(ArgumentError, \"Can't convert #{thing.class} to Money\")\n  end\nend\n\ndef amount\n  Money.new(cents, currency)\nend\n\nI'm not sure all these things concerns you, but for the record, it could be usefull to others.\n. Guy's I'm bit late on this but.\nI think it's not a very good idea.\nAs it is said in the wikipedia article you link to us, this symbol is context dependent.\nIt has been the cause of very uncomfortable mistakes in past. That's why it isn't very used this 1972...\nIf you keep this commit I'm gonna override it right now ;-)\nAnd why I didn't blame $ ? because everybody knows that it could be any kind of dollars or pesos, or ....\n. I just added the instruction for the converter method in the wiki.\n:converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\n. I semmons,\nJust installed Edge Money : \nMoney.new(1212.45.to_d*100).to_s => \"1212.45\"\nseems to work fine, thank you for response.\n. to speek freely,\nThere is a lot of things I dislike in this list....\nI'am currently working in doing one better, more suitable for my needs. But I am not sure it will be useful for anybody. Anyway I stick to the original model to be reused or patched.\nMy points are :\nCurrency names in english. It is a bit too ethnocentric to me !?\nSymbols are not accurate enough (about 20 times $, same with F and \u00a3)\nI need some missing currencies (eg : all Euro Zone previous euro)\nbegin and end dates for former currencies\nI am also working on an exchange rates module, so I need some other infos...\nA dump of my work is readable at :\nhttps://spreadsheets.google.com/ccc?key=0AkxTvAzcUacHdGVKeUdwZ3ZTbFJCNGtwdVl5MkE4UFE&hl=en&authkey=CN2vqe8H\nAsk for a edit access if anyone wants to help me on the matter.\nSee you.\n. Then I will send you a pull request when I am done.\nBut it's kind hard to find a list with currencies in their native languages, I think I will have to do it by my self....\n. Hi,\nI am totaly aware of the lack of tests, that is the point of the introduction sentence.\nI will write & submit them if the features have any chances to be merged.\nAnyway, the big point to me is the exchange_with thing, as you can see I set the date as an optional argument : def exchange_with(from, to_currency, *date, &block)\nIf somebody use a Bank without the date parameter, he just have to ignore the optional parameter.\nThis argument has to be handled from the Money object to the Bank object (and even to the Rate object in my case). And it need to be implemented in the exchange_to method and then in the exchange_with method.\nThe only alternative I see, is to affect a dedicated Bank for each \"date\" or a dynamic bank...  not very enthousiast !\n. You're right,\nI was working on another topic on these past days, but I will submit my work on Money, in few days.\nbest regards, \n. I'm quite sure that negative Money Object are usefull.\nFirst af all, If you consider a money transfert the amount has to be considered has additive for the reciever and negative for the sender (check on accounting standarts, for more examples).\nOf course you could say : I have only positive coins (or bills if you are more lucky) in my pocket and when I pay something, I substract the amount.\nYes but, if you look at the basic algebra, you'll see there is only two computing operations : addition & multiplication.\nsubstraction have to be considered as the addition of the negative element.\ndivision has to be considered as the multiplication of the inverse element.\nSo what ?\nSo the presence of negative amount and negative modifier are conceptualy corrects.\nBut You'are right, semanticly, it is possible to mess everythings up, if you combine, negative assignation, #.neg modification and substrations computing ; think about, how it could be ambigious:\nMoney.new(0) - Money.new(-100).neg\nI think, you have to choose your point of view for your accounting process (as dealing with money is always a kind of accounting), any operation can be considered as a positive stream of money, or equaly a negative stream.\nOnce you've choosen your pov, you can set your code, in a way, and a positive input in your process will exactly have the oposite meaning of a negative input.\nBy the way, As we couldn't find an understanding on some points (and I do think it is sad) this pull request (and others I have did) wasn't merged in the gem.\n. Does anybody use it this way ?\nI find very strange to have all the .99\u00a4 prices who will be print almost 1\u00a4 lower..\n. I'ill transform my fork to a :precision option wich will do it.\n. - Ok I'will add the alias it is a good idea.\n- Nice !\n- The deprecations are not essentials matter, but would be a good practice, and a good message for the community.\n- #to_hash and an alias in #to_h. IMHO all the attributes aren't very useful and even a bit too much, but if anybody find it useful I will add your code to my commit.\n- Currency::TABLE is another matter. If I do what you propose It will be around 50 commits I'll  have to do.\n  First of all I dumped the Hash into a YAML file (and add a task to build a Ruby source code back), in these way the amendments will be very easy to check with my YAML file, and then we commit only the accepted changes.\n  What do you think about ?! I 'll show you what I mean with a gist in the afternoon (Paris Time)\n. Sure ! Since I work with Google docs it is quite easy, just check the URL below\nhttps://spreadsheets0.google.com/ccc?authkey=CN2vqe8H&hl=en&key=teJyGpgvSlRB4kpuYy2A8PQ&hl=en&authkey=CN2vqe8H#gid=0\nFor CVS tab is the final output , Currencies tab show the changes\n. It was a bit easier than I thought.\nI put in a gist a YAML currencies list https://gist.github.com/842254\nfirst commit is actually a dump of the list in the current version of the gem\nSecond commit is the final version of my work (and needs).\n- Add original_name attribute filled for 80% of the currencies\n- Amendments for 52 symbols, I aimed to have as few $, \u00a3, Fr as possible for better acknowledgment of currencies.\n- Add 23 former currencies (Euro Zone)\nI am quite sure that very few are interested in former currencies, that's why I think the Currency::TABLE should be customizable, or Currency::TABLE stay what it is but the gem should use (Currency#find or #wrap, ...) a customized array of Currencies object. I could push a bit of code of what I did for my usage if you want.\n. I just see that I didn't told that I lost all :symbol_first attributes in my YAML file. I did'nt want to change this attribute.\n. I agree with you, it make more sense...\nWhat about the previous pull request ?!\n. BTW I saw that some of tests used old currencies infos, they will have to be updated if the changes are accepted.\n. And your right ! I am gonna push updated tests tomorrow morning. Anyway everybody need these tests.\n. Hi Shane,\nHere are the updated tests.\nI am quite ashamed but I found some inconsistencies in my YAML file, some decimal_mark and thousand_separator where wrong (but where right in previous file), I set them back is this commit.\nI'll push my I18n branch once the first tow pull request are accepted (I forked from my master and not from upstream/master :-( )\n. True, I'am still working with ruby 1.8.7\nmaybe if you send me the backtraces I'll be able to find a fix.\nBut sorry, I wont fill your yaml gist, it's too many work, and that is precisely why I sent two commits in the pull requests.\nI plan to upgrade (and migrate some apps) to Ruby 1.9.2 by the end of the month, I'll check at this time\n. checkout HEAD of my currencies-yml branch. All currencies are sorted AtoZ and attributes too.\nhttps://github.com/elmatou/money/blob/currencies-yml/lib/fixtures/currencies.yml\nI think this is what you need.\n. Your right Indeed, extraction from Money::Currency::TABLE, gave a strange result for this duplicate keys, probably my mistake. I can do what you ask, but not right now, as my fork work fine for my needs (except that mistake which will be corrected asap), I could bring a even more split commits to the community later.\n. Thx for the heads up !\nThis is a good news, I'm using the gem for any new project right now, but I'm quite sure it is a good move.\n. Hi,\nAs I understand, the issue append on the Money#format call.\nCan you post your composed_of statements please.\nAnd try to log an inspect call on your attributes, maybe your currency attributes is not correctly binded with your prices_xxx attributes.\nPut Rails.logger.debug price_low.inspect  in your #update_changelog method, run your code, and watch your developement.log\nYou should see someting like   \nIf XXX is different from your currency attribute that do mean your composed_of is not correctly set.\nI wrote a little rails helper for this kind of issue. \nyou can grab it here : https://gist.github.com/924331\n. The money object is instanciated with USD because it is yout default currency (which is the default, default currency).\nIt mean that the constructor find your currency attribute is nil (currency || Money.default_currency).\nYour composed_of statements seem to be correct, I guess yout attribute is not correctly set (check for currency.nil?)\nIf you want to use the helpers, copy the file in your lib folder, in your environment.rb call require 'money_helpers' then you will be able to use the helper in your model.\nYou can have only one currency attribute, even if it could be a consitency issue (if you change your price_low currency, it will change your price_high currency as a side effect.).\nHope it helps, tell us your progress.\n. Hi pconnor,\nI had a similar issue few weeks ago.\nLike you, in a specific point in my app, my Money instance was in USD (default currency), but I expected EUR.\nthe point was, I did set the money object directly trough an html form, as I would do it for any other attributes.\nExpense.amount = params[:amount]\nbut params[:amount] is a string (html, http params, ...  know only about strings). And quite normaly the :converter Proc did trigger, this proc use the parser included in the gem... String.to_money exists and works well, but....\n\"102.45\".to_money or \"-123,45\".to_money, create a Money object with the default currency, this is quite normal, because there is no currency information in \"102.45\"...\nIf you get my point, you will understand, that we should rewrite the :converter proc in order to save the old currency, if there was one... but we don't have any knowledge of previous value in this point of the proc, so I recommend to rewritte a proper setter (and the getter to) method, which could be : note tested\n\ndef amount=(thing)\n  if thing.respond_to?(:to_money)\n    if currency.nil?\n      thing.to_money\n    else\n      thing.to_money.currency = currency # is that possible ?\n  else\n    raise(ArgumentError, \"Can't convert #{thing.class} to Money\")\n  end\nend\n\ndef amount\n  Money.new(cents, currency)\nend\n\nI'm not sure all these things concerns you, but for the record, it could be usefull to others.\n. ",
    "rob-anderson": "That was quick... you guys rock\n. That was quick... you guys rock\n. ",
    "gamov": "I agree with weppos that it must be clear when Money will deal with :decimal instead of cents.\nHowever, I think it would be great if the new version of Money support the composed_of method of Rails and transparently detects if data from the AR backend is in :decimal/integer (checking if it's a BigDecimal type).\n[I'm new to Ruby and Rails... please bare with me if I don't make much sense :o)]\nIf I understand correctly, we can play around with :constructor/:converter parameters to 'interface' between the DB data and the Money class and make the dec->cents conversion there. Am I right?\nWhy not #from_dec? It seems you consider the evil float equal to the righteous Bigdecimal.\n. hey guys, one more newbie question: I wanted to had the blue 'enhancement' label to this issue, I couldn't figure how. Do you need some kind of admin rights?\n. Cool. thanks for your help!\n. - since we already have #cents, what about #units (instead of dollars/amount)?\n. Yes, I think it's nicer to have those two additional methods (whole_units/fract_units) semmons99.\nNote that when I evaluated other money gems, I also saw the use of dollars/cents method names even for other currencies.\n. I have never submitted a patch, not sure how it works but that's a good opportunity to learn.\n. I agree with weppos that it must be clear when Money will deal with :decimal instead of cents.\nHowever, I think it would be great if the new version of Money support the composed_of method of Rails and transparently detects if data from the AR backend is in :decimal/integer (checking if it's a BigDecimal type).\n[I'm new to Ruby and Rails... please bare with me if I don't make much sense :o)]\nIf I understand correctly, we can play around with :constructor/:converter parameters to 'interface' between the DB data and the Money class and make the dec->cents conversion there. Am I right?\nWhy not #from_dec? It seems you consider the evil float equal to the righteous Bigdecimal.\n. hey guys, one more newbie question: I wanted to had the blue 'enhancement' label to this issue, I couldn't figure how. Do you need some kind of admin rights?\n. Cool. thanks for your help!\n. - since we already have #cents, what about #units (instead of dollars/amount)?\n. Yes, I think it's nicer to have those two additional methods (whole_units/fract_units) semmons99.\nNote that when I evaluated other money gems, I also saw the use of dollars/cents method names even for other currencies.\n. I have never submitted a patch, not sure how it works but that's a good opportunity to learn.\n. ",
    "mavenlink": "Sure thing, sounds good.  We've basically limited our to_money usage to monefying 0 at this point.\n. That's absolutely the right way to go and much more elegant.  You beat me to the punch.\nWe implemented some similar JS after I posted this:\nMath.ceil(Math.log($('#rollup').data('subunit'))/Math.LN10);\nUnfortunately, JS doesn't have log10!\n. Sure thing, sounds good.  We've basically limited our to_money usage to monefying 0 at this point.\n. That's absolutely the right way to go and much more elegant.  You beat me to the punch.\nWe implemented some similar JS after I posted this:\nMath.ceil(Math.log($('#rollup').data('subunit'))/Math.LN10);\nUnfortunately, JS doesn't have log10!\n. ",
    "abhay": "another option is to always store as an integer. this is reasonable as it's something that is listed in the README file but not actually ensured. Here's a branch that ensures it.\n. another option is to always store as an integer. this is reasonable as it's something that is listed in the README file but not actually ensured. Here's a branch that ensures it.\n. ",
    "mceachen": "To be honest, I'd delete the inspect altogether -- I've never seen someone override it, and the only user should be an engineer. The only code consumer is the test, afaik, and it's not a particularly defensible test in the first place. I'd replace the test with something that actually verified the exterior state of the object was copacetic, not that the developer's to_s is OK.\n. To be honest, I'd delete the inspect altogether -- I've never seen someone override it, and the only user should be an engineer. The only code consumer is the test, afaik, and it's not a particularly defensible test in the first place. I'd replace the test with something that actually verified the exterior state of the object was copacetic, not that the developer's to_s is OK.\n. ",
    "mbasset": "Using version 1.9.2-94\n. Using version 1.9.2-94\n. ",
    "mguinada": "Was this ever released on gem? \nI'm using money 3.6.0 with rails 3.0.5 and ruby 1.9.2p180 and I'm running into this issue.\n. cool, thanks for your quick intervention.\n. Was this ever released on gem? \nI'm using money 3.6.0 with rails 3.0.5 and ruby 1.9.2p180 and I'm running into this issue.\n. cool, thanks for your quick intervention.\n. ",
    "tobi": "By the way, thanks guys for overtaking my money project. It has been in great hands I see. \n. By the way, thanks guys for overtaking my money project. It has been in great hands I see. \n. ",
    "tlianza": "Yes, actually I was thinking of putting my code after Money.parse, where if it identified a price in dollars, but the input string had two decimals, it would thrown an error (in my case, return nil).  \nSo, that's what I was thinking might make for a reasonable bit of logic in the Money.parse library itself... a price in dollars should never have more than one decimal, or else it's un-parsable.  What do you think?\n. I'd be happy to submit a patch for this and a bunch of test cases.  I have had a price-scraping engine running for a few years now and have encountered a lot of interesting ways different sites format money, so I'd love to contribute those test cases to this project. \nQuestion though: In the Money.extract_cents method there is this comment, which is very similar to your comment above:\n\"we can't determine if the comma or period is supposed to be a decimal_mark or a thousands_separator\"\nSince that method takes currency as an argument, why doesn't that method trust the currency to define the behavior of decimals and thousand's separators?  It appears that it will always try to \"figure out\" the rules, in lieu of trusting the currency's rules.  Is there a reason for that?  Currency is used later in the method to convert to cents.\n. Working on a patch, and noticed this test:\nhttps://github.com/RubyMoney/money/blob/master/spec/money_spec.rb#L533\n(\"0.0\"..\"9.9\").each do |amt|\n    amt.to_money(\"VND\").format(:symbol => false).should == amt.to_s.gsub(/\\./, \",\")\n end\nThis seems to say that when you take an input string of \"0.1\" Vietnamese \u0110\u1ed3ng's, which use \".\" to indicate thousands, the expected output is \"0,1\". \nIf I were to change the behavior to respect the currency being passed in, \"0.1\" would not treat the \".\" as a decimal.  It would treat it as a thousands separator, and thus would throw it out - returning a value of 1.\nDo you think this behavior is relied upon?  It doesn't seem correct to me, but since there's a test for it I'm guessing it is by design.\n. Gotcha - so since that method doesn't take an argument that indicates the viewer's region, it appears that relies on guessing the formatting based on what's passed in.  Ok, I'll have to think on this a bit more.... maybe Money.parse needs to use a different codepath than .format.\n. Yes, actually I was thinking of putting my code after Money.parse, where if it identified a price in dollars, but the input string had two decimals, it would thrown an error (in my case, return nil).  \nSo, that's what I was thinking might make for a reasonable bit of logic in the Money.parse library itself... a price in dollars should never have more than one decimal, or else it's un-parsable.  What do you think?\n. I'd be happy to submit a patch for this and a bunch of test cases.  I have had a price-scraping engine running for a few years now and have encountered a lot of interesting ways different sites format money, so I'd love to contribute those test cases to this project. \nQuestion though: In the Money.extract_cents method there is this comment, which is very similar to your comment above:\n\"we can't determine if the comma or period is supposed to be a decimal_mark or a thousands_separator\"\nSince that method takes currency as an argument, why doesn't that method trust the currency to define the behavior of decimals and thousand's separators?  It appears that it will always try to \"figure out\" the rules, in lieu of trusting the currency's rules.  Is there a reason for that?  Currency is used later in the method to convert to cents.\n. Working on a patch, and noticed this test:\nhttps://github.com/RubyMoney/money/blob/master/spec/money_spec.rb#L533\n(\"0.0\"..\"9.9\").each do |amt|\n    amt.to_money(\"VND\").format(:symbol => false).should == amt.to_s.gsub(/\\./, \",\")\n end\nThis seems to say that when you take an input string of \"0.1\" Vietnamese \u0110\u1ed3ng's, which use \".\" to indicate thousands, the expected output is \"0,1\". \nIf I were to change the behavior to respect the currency being passed in, \"0.1\" would not treat the \".\" as a decimal.  It would treat it as a thousands separator, and thus would throw it out - returning a value of 1.\nDo you think this behavior is relied upon?  It doesn't seem correct to me, but since there's a test for it I'm guessing it is by design.\n. Gotcha - so since that method doesn't take an argument that indicates the viewer's region, it appears that relies on guessing the formatting based on what's passed in.  Ok, I'll have to think on this a bit more.... maybe Money.parse needs to use a different codepath than .format.\n. ",
    "hakanensari": "My bad. I missed the :no_cents option.\nYes, that's workable, although ideally I would have wanted Money#format to know existing formatting conventions so I can avoid conditional spaghetti, as in: \"if JPY, format without cents, otherwise format with cents.\"\nI somewhat like the idea of a :suppress_cents option in Currency::TABLE and hooking that into Money#to_s. Of course, the question is whether that messes with anyone's existing implementation.\nDoing away with the JPY subunit altogether takes the issue beyond the scope of formatting and is probably a no-go unless financial institutions etc. already round off to the nearest \u00a51 in common scenarios.\n. Done. Would personally prefer :suppress_cents in Currency::TABLE though in the long run.\nThanks for responding so quickly :)\n```\nclass Money\n  alias :old_normalize_formatting_rules :normalize_formatting_rules\ndef normalize_formatting_rules(rules)\n    rules = old_normalize_formatting_rules(rules)\nif currency.iso_code == \"JPY\" && !rules.has_key?(:no_cents)\n  rules.merge!(:no_cents => true)\nend\n\nrules\n\nend\nend\n```\n. For reference, Amazon.co.jp, for instance, stores its prices like this:\n\"Price\"=> {\n  \"Amount\" => \"1166\",\n  \"CurrencyCode\" => \"JPY\",\n  \"FormattedPrice\" => \"\uffe5 1,166\"\n}\n. Yes, that's fine.\nPracticing semver would also require to yank 3.6.2 and release 4.0, but since our app perhaps was the only one in the universe to be affected by this change, I suppose we can keep it silent and move on.\n. This is a bit of a semver edge case: a bug fix of a non-working (?) feature that breaks an app that has not made use of that feature.\nIn any case, I will be content to relax our Gemfile again once you push out the above change.\nHappy Mondays.\n. @semmons99 no worries, I've done that already\n. > PS. This ticket breaks the single responsibility principle as well. You started a discussion for at least 3 different changes in the same issue. ;)\nHaha, I know.\nBut seriously, what's \"bc\"?\n. > VariableExchange is more of an example implementation of a Bank than something that should actually be used. If you come up with a better example implementation that follows SRP better, I'd be happy to deprecate this implementation in favor of it.\nI was wondering what the purposes of it was.\nI'd deprecate or remove VariableExchange#export_rates and VariableExchange#import_rates and simply add VariableExchange#rates= so you can set rates with a Hash. Bonus: VariableExchange#rates is already there.\nIf someone is using this, let her worry about converting whatever format to a Hash. It's not like XE or ECB offers JSON or XML that you can directly plug in here.\nAnd if it's really merely an example implementation, it probably doesn't even belong under lib?\nYou'd have one less thing to worry about (e.g. \"JRuby bug\") if you don't depend on JSON at all.\n. I won't touch VariableExchange unless I know we're on the same page.\n. Sure.\n. Is the json dependency necessary in the gemspec? It seems it didn't used to be.\n. Travis will complain, though.\nThis is purely cosmetic, but it could either remain as a dev dependency in the gemspec or be conditionally required in the Gemfile if RUBY_VERSION is < 1.9.\n. Also, again purely cosmetic, but I'd either relax or eliminate the dev dependency versions and get rid of the annoying Gemnasium badge in the README.\n. Also, while I'm at this, is this an obsolete artefact, or is the intention that Money should work when i18n is not available?\nruby\nrequire \"i18n\" rescue LoadError\nIf so, this needs to go into a begin/end block and the dependency on i18n in the gemspec has to be removed. Some tests will require refactoring as well.\nOtherwise, the rescue LoadError can be deleted.\n. That's enough plumbing for the day. :clap:\n. It seems I opened a can of worms unintentionally.\n@weppos, I wasn't trying to optimise\u2014or to annoy.\nI'm not a big fan of these adapter libraries. They may have a use in certain cases, but IMO they're more a symptom of a larger problem than a solution. There really should be a single \"canonical\" implementation of JSON, XML, HTTP, and what have you that just does the job.\nBut this is besides the point here.\nYour point is that it's good to keep the data in a separate place. Two years ago, they lived in defaults.rb. You prefer to have them under config. You also prefer JSON over other formats for various reasons.\nThat's fine.\nYour first suggestion on how to symbolise the keys without resorting to multi_json is also fine. (I would not go the second route, as you would be partially reimplementing multi_json within Money, which would be madness redux.)\nA third possibility is that you could simply store the hash part of the data in a separate file and eval it into a hash (eval is a parser, after all) if you are really into that kind of separation where you don't want to see code pollute the data.\nJSON is fine as long as it doesn't create overhead. There's no inherent value in using it as this data doesn't talk to the Internet.\n@semmons99, moving the currency data to a separate gem sounds like a bad idea. But I would suggest ditching the defunct currencies altogether. If there's someone using one, let her require money and then add it to the table by hand. It's not so difficult.\nI would +1 dropping 1.8 support. Then you could use the shorter Hash syntax, for instance, which looks even sexier than JSON.\nI would also +1 identifying, deprecating, and eventually dropping other cruft in the code: monkey-patches to basic classes (I'm glad there's no \"1\".to_usd, although I'm sure that it occurred to the original author at some point), VariableExchange exporting its rates to this and that format, making I18n optional (as it clearly was the intention of someone at some point), and so on. \nNow, back to :beer:\n. @ioquatix,\nruby\namounts.inject(&:+)\n. @semmons99, a stop-gap solution is to add to Gemfile:\nruby\ngem 'json', platform: :jruby\n. Gemfile has no meaning outside of the context of running tests, so the gem itself would be clean.\nMoney is a basic library. JRuby is a major Ruby implementation. It's good practice to communicate to others you are testing against it.\n. My bad. I missed the :no_cents option.\nYes, that's workable, although ideally I would have wanted Money#format to know existing formatting conventions so I can avoid conditional spaghetti, as in: \"if JPY, format without cents, otherwise format with cents.\"\nI somewhat like the idea of a :suppress_cents option in Currency::TABLE and hooking that into Money#to_s. Of course, the question is whether that messes with anyone's existing implementation.\nDoing away with the JPY subunit altogether takes the issue beyond the scope of formatting and is probably a no-go unless financial institutions etc. already round off to the nearest \u00a51 in common scenarios.\n. Done. Would personally prefer :suppress_cents in Currency::TABLE though in the long run.\nThanks for responding so quickly :)\n```\nclass Money\n  alias :old_normalize_formatting_rules :normalize_formatting_rules\ndef normalize_formatting_rules(rules)\n    rules = old_normalize_formatting_rules(rules)\nif currency.iso_code == \"JPY\" && !rules.has_key?(:no_cents)\n  rules.merge!(:no_cents => true)\nend\n\nrules\n\nend\nend\n```\n. For reference, Amazon.co.jp, for instance, stores its prices like this:\n\"Price\"=> {\n  \"Amount\" => \"1166\",\n  \"CurrencyCode\" => \"JPY\",\n  \"FormattedPrice\" => \"\uffe5 1,166\"\n}\n. Yes, that's fine.\nPracticing semver would also require to yank 3.6.2 and release 4.0, but since our app perhaps was the only one in the universe to be affected by this change, I suppose we can keep it silent and move on.\n. This is a bit of a semver edge case: a bug fix of a non-working (?) feature that breaks an app that has not made use of that feature.\nIn any case, I will be content to relax our Gemfile again once you push out the above change.\nHappy Mondays.\n. @semmons99 no worries, I've done that already\n. > PS. This ticket breaks the single responsibility principle as well. You started a discussion for at least 3 different changes in the same issue. ;)\nHaha, I know.\nBut seriously, what's \"bc\"?\n. > VariableExchange is more of an example implementation of a Bank than something that should actually be used. If you come up with a better example implementation that follows SRP better, I'd be happy to deprecate this implementation in favor of it.\nI was wondering what the purposes of it was.\nI'd deprecate or remove VariableExchange#export_rates and VariableExchange#import_rates and simply add VariableExchange#rates= so you can set rates with a Hash. Bonus: VariableExchange#rates is already there.\nIf someone is using this, let her worry about converting whatever format to a Hash. It's not like XE or ECB offers JSON or XML that you can directly plug in here.\nAnd if it's really merely an example implementation, it probably doesn't even belong under lib?\nYou'd have one less thing to worry about (e.g. \"JRuby bug\") if you don't depend on JSON at all.\n. I won't touch VariableExchange unless I know we're on the same page.\n. Sure.\n. Is the json dependency necessary in the gemspec? It seems it didn't used to be.\n. Travis will complain, though.\nThis is purely cosmetic, but it could either remain as a dev dependency in the gemspec or be conditionally required in the Gemfile if RUBY_VERSION is < 1.9.\n. Also, again purely cosmetic, but I'd either relax or eliminate the dev dependency versions and get rid of the annoying Gemnasium badge in the README.\n. Also, while I'm at this, is this an obsolete artefact, or is the intention that Money should work when i18n is not available?\nruby\nrequire \"i18n\" rescue LoadError\nIf so, this needs to go into a begin/end block and the dependency on i18n in the gemspec has to be removed. Some tests will require refactoring as well.\nOtherwise, the rescue LoadError can be deleted.\n. That's enough plumbing for the day. :clap:\n. It seems I opened a can of worms unintentionally.\n@weppos, I wasn't trying to optimise\u2014or to annoy.\nI'm not a big fan of these adapter libraries. They may have a use in certain cases, but IMO they're more a symptom of a larger problem than a solution. There really should be a single \"canonical\" implementation of JSON, XML, HTTP, and what have you that just does the job.\nBut this is besides the point here.\nYour point is that it's good to keep the data in a separate place. Two years ago, they lived in defaults.rb. You prefer to have them under config. You also prefer JSON over other formats for various reasons.\nThat's fine.\nYour first suggestion on how to symbolise the keys without resorting to multi_json is also fine. (I would not go the second route, as you would be partially reimplementing multi_json within Money, which would be madness redux.)\nA third possibility is that you could simply store the hash part of the data in a separate file and eval it into a hash (eval is a parser, after all) if you are really into that kind of separation where you don't want to see code pollute the data.\nJSON is fine as long as it doesn't create overhead. There's no inherent value in using it as this data doesn't talk to the Internet.\n@semmons99, moving the currency data to a separate gem sounds like a bad idea. But I would suggest ditching the defunct currencies altogether. If there's someone using one, let her require money and then add it to the table by hand. It's not so difficult.\nI would +1 dropping 1.8 support. Then you could use the shorter Hash syntax, for instance, which looks even sexier than JSON.\nI would also +1 identifying, deprecating, and eventually dropping other cruft in the code: monkey-patches to basic classes (I'm glad there's no \"1\".to_usd, although I'm sure that it occurred to the original author at some point), VariableExchange exporting its rates to this and that format, making I18n optional (as it clearly was the intention of someone at some point), and so on. \nNow, back to :beer:\n. @ioquatix,\nruby\namounts.inject(&:+)\n. @semmons99, a stop-gap solution is to add to Gemfile:\nruby\ngem 'json', platform: :jruby\n. Gemfile has no meaning outside of the context of running tests, so the gem itself would be clean.\nMoney is a basic library. JRuby is a major Ruby implementation. It's good practice to communicate to others you are testing against it.\n. ",
    "kaos12": "Does it makes sense to create a Money object with negative values?\nI'm currently using the money gem for handling a simple expense system and while getting acquainted with the gem I realize I can create a Money object with negative value, such as Money.new(-1000). As a result, if I add this object to another Money it will be used as negative value.\nWhat I'm trying to understand is if this behavior is good thing, because I think it can cause some semantic problems (for instance filtering using input before creating my Money object).\nI'd like to hear your comments about this. Thank you very much and nice job on this gem, really helpful! \n. Oh, that of treating the amounts as debit or credit is news to me. I agree on that. Gonna close it. Thanks!\n. Does it makes sense to create a Money object with negative values?\nI'm currently using the money gem for handling a simple expense system and while getting acquainted with the gem I realize I can create a Money object with negative value, such as Money.new(-1000). As a result, if I add this object to another Money it will be used as negative value.\nWhat I'm trying to understand is if this behavior is good thing, because I think it can cause some semantic problems (for instance filtering using input before creating my Money object).\nI'd like to hear your comments about this. Thank you very much and nice job on this gem, really helpful! \n. Oh, that of treating the amounts as debit or credit is news to me. I agree on that. Gonna close it. Thanks!\n. ",
    "idler921": "Yes, it should be!\n. Yes, it should be!\n. ",
    "eloyesp": "I'd realy like to learn how to do those specs.\n. I like the idea, but I cannot do it right now, I will tell you when I can. Thanks.\n. Then I think that it should be implemented in version 4.0.\nAnd can be added the option to assign a integer to @rounding_method (like BigDecimal::ROUND_HALF_EVEN)\n. I'd realy like to learn how to do those specs.\n. I like the idea, but I cannot do it right now, I will tell you when I can. Thanks.\n. Then I think that it should be implemented in version 4.0.\nAnd can be added the option to assign a integer to @rounding_method (like BigDecimal::ROUND_HALF_EVEN)\n. ",
    "pconnor": "Here is my price.rb\n```\nclass Price < ActiveRecord::Base\nbelongs_to :priceable, :polymorphic => true\n  attr_accessor :retail, :price, :user\ncomposed_of :price_low,\n    :class_name => \"Money\",\n    :mapping => [%w(price_low_cents cents), %w(currency currency_as_string)],\n    :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n    :converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\ncomposed_of :price_high,\n    :class_name => \"Money\",\n    :mapping => [%w(price_high_cents cents), %w(currency currency_as_string)],\n    :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n    :converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\ncomposed_of :retail_low,\n    :class_name => \"Money\",\n    :mapping => [%w(retail_low_cents cents), %w(currency currency_as_string)],\n    :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n    :converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\ncomposed_of :retail_high,\n    :class_name => \"Money\",\n    :mapping => [%w(retail_high_cents cents), %w(currency currency_as_string)],\n    :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n    :converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\nafter_validation :update_changelog\ndef update_changelog\n    Rails.logger.debug price_low.inspect\n    if self.changed?\n      change = \"Price: Low = #{self.price_low.format(:with_currency => true)}, High = #{self.price_high.format(:with_currency => true)} | Retail Value: Low = #{self.retail_low.format(:with_currency => true)}, High = #{self.retail_high.format(:with_currency => true)} | Set: #{Time.now.to_s(:long)} | #{self.currency}\"\n      if !self.changelog.blank?\n        self.changelog = self.changelog + \"\\r\\n\" + change\n      else\n        self.changelog = change\n      end\n    end\n  end\nend\n```\nYou are correct that the inspect shows:#<Money cents:11002 currency:USD>\nDo I need a different currency attribute for each \"price type\" that I have, and is that causing my problem here?\nI looked at the helper.  It is a bit over my head how to use it, but I will start working on it now. \nThank you!\n. @elmatou and @weppos,\nThanks to both of you for your help!  I spent a ton (too much) of time on this last night.  Below is the ugly fix that I came up with.  It works, but I am positive there is a better way.  Ultimately, however, I could never get Money to see my self.currency value (either the 'old' one stored in the db or the 'new' one in the params).\ndef update_changelog\n    if self.changed?\n      price_low = Money.new(self.price_low_cents, self.currency).format(:with_currency => true)\n      price_high = Money.new(self.price_high_cents, self.currency).format(:with_currency => true)\n      retail_low = Money.new(self.retail_low_cents, self.currency).format(:with_currency => true)\n      retail_high = Money.new(self.retail_high_cents, self.currency).format(:with_currency => true)\n      change = \"Price: Low = #{price_low}, High = #{price_high} | Retail Value: Low = #{retail_low}, High = #{retail_high} | Set: #{Time.now.to_s(:long)}\"\n      if !self.changelog.blank?\n        self.changelog = self.changelog + \"\\r\\n\" + change\n      else\n        self.changelog = change\n      end\n    end\n  end\n. elmatou,\nGood point.  This is all a bit above my \"pay grade\", but I agree and will spend some time this weekend looking into what you have suggested.\n. Here is my price.rb\n```\nclass Price < ActiveRecord::Base\nbelongs_to :priceable, :polymorphic => true\n  attr_accessor :retail, :price, :user\ncomposed_of :price_low,\n    :class_name => \"Money\",\n    :mapping => [%w(price_low_cents cents), %w(currency currency_as_string)],\n    :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n    :converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\ncomposed_of :price_high,\n    :class_name => \"Money\",\n    :mapping => [%w(price_high_cents cents), %w(currency currency_as_string)],\n    :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n    :converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\ncomposed_of :retail_low,\n    :class_name => \"Money\",\n    :mapping => [%w(retail_low_cents cents), %w(currency currency_as_string)],\n    :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n    :converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\ncomposed_of :retail_high,\n    :class_name => \"Money\",\n    :mapping => [%w(retail_high_cents cents), %w(currency currency_as_string)],\n    :constructor => Proc.new { |cents, currency| Money.new(cents || 0, currency || Money.default_currency) },\n    :converter => Proc.new { |value| value.respond_to?(:to_money) ? value.to_money : raise(ArgumentError, \"Can't convert #{value.class} to Money\") }\nafter_validation :update_changelog\ndef update_changelog\n    Rails.logger.debug price_low.inspect\n    if self.changed?\n      change = \"Price: Low = #{self.price_low.format(:with_currency => true)}, High = #{self.price_high.format(:with_currency => true)} | Retail Value: Low = #{self.retail_low.format(:with_currency => true)}, High = #{self.retail_high.format(:with_currency => true)} | Set: #{Time.now.to_s(:long)} | #{self.currency}\"\n      if !self.changelog.blank?\n        self.changelog = self.changelog + \"\\r\\n\" + change\n      else\n        self.changelog = change\n      end\n    end\n  end\nend\n```\nYou are correct that the inspect shows:#<Money cents:11002 currency:USD>\nDo I need a different currency attribute for each \"price type\" that I have, and is that causing my problem here?\nI looked at the helper.  It is a bit over my head how to use it, but I will start working on it now. \nThank you!\n. @elmatou and @weppos,\nThanks to both of you for your help!  I spent a ton (too much) of time on this last night.  Below is the ugly fix that I came up with.  It works, but I am positive there is a better way.  Ultimately, however, I could never get Money to see my self.currency value (either the 'old' one stored in the db or the 'new' one in the params).\ndef update_changelog\n    if self.changed?\n      price_low = Money.new(self.price_low_cents, self.currency).format(:with_currency => true)\n      price_high = Money.new(self.price_high_cents, self.currency).format(:with_currency => true)\n      retail_low = Money.new(self.retail_low_cents, self.currency).format(:with_currency => true)\n      retail_high = Money.new(self.retail_high_cents, self.currency).format(:with_currency => true)\n      change = \"Price: Low = #{price_low}, High = #{price_high} | Retail Value: Low = #{retail_low}, High = #{retail_high} | Set: #{Time.now.to_s(:long)}\"\n      if !self.changelog.blank?\n        self.changelog = self.changelog + \"\\r\\n\" + change\n      else\n        self.changelog = change\n      end\n    end\n  end\n. elmatou,\nGood point.  This is all a bit above my \"pay grade\", but I agree and will spend some time this weekend looking into what you have suggested.\n. ",
    "Jell": "I can fix that. It would be more consistent that way.\n. No I just split the specs without any change. I will do the rebase on a separate branch and send a new pull request.\n. you're welcome!\n. I can fix that. It would be more consistent that way.\n. No I just split the specs without any change. I will do the rebase on a separate branch and send a new pull request.\n. you're welcome!\n. ",
    "nurey": "here's how i figured out how to paste in unicode on Mac OS X:\n- gem install clipboard\n- irb\n  ruby-1.9.2-p180 :001 > $LOAD_PATH << './lib'\n  ruby-1.9.2-p180 :001 > require 'clipboard'\n  => true \n  ruby-1.9.2-p180 :002 > require 'money.rb'\n  => true \n  ruby-1.9.2-p180 :003 > Clipboard.copy Money.new(10_50, \"BHD\").format(:no_cents_if_whole => true)\n  => \"\u0628.\u062f1.050\" \n- open TextEdit.app\n- Preferences/Open and Save/\n  - set Opening Files to Unicode UTF8\n  - set Saving Files to Unicode UTF8\n- paste as needed\n. here's how i figured out how to paste in unicode on Mac OS X:\n- gem install clipboard\n- irb\n  ruby-1.9.2-p180 :001 > $LOAD_PATH << './lib'\n  ruby-1.9.2-p180 :001 > require 'clipboard'\n  => true \n  ruby-1.9.2-p180 :002 > require 'money.rb'\n  => true \n  ruby-1.9.2-p180 :003 > Clipboard.copy Money.new(10_50, \"BHD\").format(:no_cents_if_whole => true)\n  => \"\u0628.\u062f1.050\" \n- open TextEdit.app\n- Preferences/Open and Save/\n  - set Opening Files to Unicode UTF8\n  - set Saving Files to Unicode UTF8\n- paste as needed\n. ",
    "alovak": "@DarkFox iso4217 numeric codes were added in 4.0.0.\nNow you can use them :)\n. Thanks! :)\n. Great idea! It will be nice to have such function :) \nBut I can agree with @semmons99 that it can be implemented as separate gem because it will introduce new dependency from ISO 3166 (Country Codes).\nP.S. There is a gem for Countries: https://github.com/jim/carmen\n. I would like to participate in discussion but I don't understand the problem :)\nWhy you decided to talk about string parsing?\n. IMHO currency should be added though pull request :) What do you think?\n. @exviva, thanks a lot!\n. @DarkFox iso4217 numeric codes were added in 4.0.0.\nNow you can use them :)\n. Thanks! :)\n. Great idea! It will be nice to have such function :) \nBut I can agree with @semmons99 that it can be implemented as separate gem because it will introduce new dependency from ISO 3166 (Country Codes).\nP.S. There is a gem for Countries: https://github.com/jim/carmen\n. I would like to participate in discussion but I don't understand the problem :)\nWhy you decided to talk about string parsing?\n. IMHO currency should be added though pull request :) What do you think?\n. @exviva, thanks a lot!\n. ",
    "basex": "Two links that might work as an example:\nhttp://www.bortarsasag.hu/hu/delicat/\nhttp://www.anonymuscatering.hu/itallap.php\n. Yes this is wrong for most EU countries (e.g.  France, Germany, Italy, Spain, Portugal etc).\nAs per wikipedia, the currency symbol preceding the number is mostly an English convention.\nhttps://en.wikipedia.org/wiki/Euro_sign#Use\n. Tiago is correct, CLP does not use centavos since 1984 and in ISO 4217 is expressed without decimal units.\nISO 4217 Table A.1. CLP Minor Unit: 0\nhttp://www.currency-iso.org/dam/downloads/table_a1.xls\nCLP. Decimal Operator: 0\nhttp://en.wikipedia.org/wiki/ISO_4217 \n. In CLP there are no centavos check the tables from ISO 4217\nCLP Minor Unit: 0\nhttp://www.currency-iso.org/dam/downloads/table_a1.xls\nCLP. Decimal Operator: 0\nhttp://en.wikipedia.org/wiki/ISO_4217\nAlso in stripe page: https://support.stripe.com/questions/which-zero-decimal-currencies-does-stripe-support\nRelated Issue #504 \nCan this merge be reverted?\n. Stripe is a financial institution and doesn't use cents for CLP.\nProbably there are many companies that simply put all currencies with 2 decimals, but I think we should keep with backward compatibility since this gem had CLP without cents for most of the time and to follow the ISO 4217 standard.\n. Yes I think that should be the case, if Google handles the units differently than the standard it should be the google_currency gem handling the special case.\n. Two links that might work as an example:\nhttp://www.bortarsasag.hu/hu/delicat/\nhttp://www.anonymuscatering.hu/itallap.php\n. Yes this is wrong for most EU countries (e.g.  France, Germany, Italy, Spain, Portugal etc).\nAs per wikipedia, the currency symbol preceding the number is mostly an English convention.\nhttps://en.wikipedia.org/wiki/Euro_sign#Use\n. Tiago is correct, CLP does not use centavos since 1984 and in ISO 4217 is expressed without decimal units.\nISO 4217 Table A.1. CLP Minor Unit: 0\nhttp://www.currency-iso.org/dam/downloads/table_a1.xls\nCLP. Decimal Operator: 0\nhttp://en.wikipedia.org/wiki/ISO_4217 \n. In CLP there are no centavos check the tables from ISO 4217\nCLP Minor Unit: 0\nhttp://www.currency-iso.org/dam/downloads/table_a1.xls\nCLP. Decimal Operator: 0\nhttp://en.wikipedia.org/wiki/ISO_4217\nAlso in stripe page: https://support.stripe.com/questions/which-zero-decimal-currencies-does-stripe-support\nRelated Issue #504 \nCan this merge be reverted?\n. Stripe is a financial institution and doesn't use cents for CLP.\nProbably there are many companies that simply put all currencies with 2 decimals, but I think we should keep with backward compatibility since this gem had CLP without cents for most of the time and to follow the ISO 4217 standard.\n. Yes I think that should be the case, if Google handles the units differently than the standard it should be the google_currency gem handling the special case.\n. ",
    "Justinwceo": "Never mind i got it working. \ni did the following: \nchanged composed_of =\ncomposed_of :price,\n    :class_name  => \"Money\",\n    :mapping     => [%w(price cents)\ninstead of t.integer :cents i did t.integer :price in my database.\nI believe the mapping needed to be the same as the composed of :price, that was all and now everything is working perfectly, no errors.\n. Where is this #format at? Are you basically saying that if i just follow the tutorial in the Wiki it should come out as follows?\n. Wow, that comment seemed as if you are annoyed. I agree, i do need to study Ruby.It would help if you answered all of the areas of my questions but if your that busy, its OK, i am making a multibillion dollar business too, good luck and thanks for the help you gave me!\n. Never mind i got it working. \ni did the following: \nchanged composed_of =\ncomposed_of :price,\n    :class_name  => \"Money\",\n    :mapping     => [%w(price cents)\ninstead of t.integer :cents i did t.integer :price in my database.\nI believe the mapping needed to be the same as the composed of :price, that was all and now everything is working perfectly, no errors.\n. Where is this #format at? Are you basically saying that if i just follow the tutorial in the Wiki it should come out as follows?\n. Wow, that comment seemed as if you are annoyed. I agree, i do need to study Ruby.It would help if you answered all of the areas of my questions but if your that busy, its OK, i am making a multibillion dollar business too, good luck and thanks for the help you gave me!\n. ",
    "rwz": "Well, i saw JSON.dump in other parts of the code, for example in VariableExchange#export_rates. so i concluded it's safe to use it . Anyway, it can be easy implemented with only string interpolation.\nI only implemented it because Object#to_json is way too verbose for Money object. It looks something like:\njavascript\n{\"cents\"=>1000,\n \"currency\"=>\n  {\"id\"=>\"usd\",\n   \"priority\"=>1,\n   \"iso_code\"=>\"USD\",\n   \"name\"=>\"United States Dollar\",\n   \"symbol\"=>\"$\",\n   \"subunit\"=>\"Cent\",\n   \"subunit_to_unit\"=>100,\n   \"symbol_first\"=>true,\n   \"html_entity\"=>\"$\",\n   \"decimal_mark\"=>\".\",\n   \"thousands_separator\"=>\",\"},\n \"bank\"=>{\"rounding_method\"=>nil, \"rates\"=>{}, \"mutex\"=>{}}}\n. Well, i saw JSON.dump in other parts of the code, for example in VariableExchange#export_rates. so i concluded it's safe to use it . Anyway, it can be easy implemented with only string interpolation.\nI only implemented it because Object#to_json is way too verbose for Money object. It looks something like:\njavascript\n{\"cents\"=>1000,\n \"currency\"=>\n  {\"id\"=>\"usd\",\n   \"priority\"=>1,\n   \"iso_code\"=>\"USD\",\n   \"name\"=>\"United States Dollar\",\n   \"symbol\"=>\"$\",\n   \"subunit\"=>\"Cent\",\n   \"subunit_to_unit\"=>100,\n   \"symbol_first\"=>true,\n   \"html_entity\"=>\"$\",\n   \"decimal_mark\"=>\".\",\n   \"thousands_separator\"=>\",\"},\n \"bank\"=>{\"rounding_method\"=>nil, \"rates\"=>{}, \"mutex\"=>{}}}\n. ",
    "h0jeZvgoxFepBQ2C": "I think i can change the translations easier as monkey patching your\nsource code...  Or did i miss something?\nf.e. i want to implement the new bitcoin currency... it would be nicer to integrate it to some yaml files, than to monkeypatch your currencies table.\n. Sorry, closed it accidentialy\n. Yeah but then I have to check if the currency is correct -> tradelimits currency must be the same as the markets currency, and thats what i dont want to if thats possible. \n. Hmm... yes thats true, that its more secure if something acciententially happens (f.e. market currency was changed  acciententially). Maybe i will try it now with two seperate currency fields for market / tradelimit.\nWhat I meaned before, was that i want to include the market.currency into the deciaml-convertion of the tradelimit.price -> so i won't have to check if the currencies are the same, because the currency is fully inherited from market.\nBut all in all, you are right and it's more secure to store more data... Thanks for your thoughts...!\n. I know that this behaviour doesnt really belong to this gem, but it would had helped me a lot, if i had known it... And i think other users may have the same problem at some time... \nBeside that.. I use mysql 5.1... And it doesn't throw an error.. Even if i insert data with the mysql command line tool...\n. So there is absolutely no solution if I want to store 30 Mio. dollars in the database with this money gem? :O\n. Hmm... i see.. I would submit a patch, but im not really good in ruby :/ But thanks for your help and work!\nOne last question: what column type would you prefer for storing big values (f.e. 30 Mio. dollars) with cashrb?\n. thx!\n. Ok one last last question :P\nMoney gem with bigint column doesnt work?\n. Ok thx!\n. Yeah, please add support for longer codes..! Aurora and several other altcoins use longer codes - and this gem doesn't let me :(. I think i can change the translations easier as monkey patching your\nsource code...  Or did i miss something?\nf.e. i want to implement the new bitcoin currency... it would be nicer to integrate it to some yaml files, than to monkeypatch your currencies table.\n. Sorry, closed it accidentialy\n. Yeah but then I have to check if the currency is correct -> tradelimits currency must be the same as the markets currency, and thats what i dont want to if thats possible. \n. Hmm... yes thats true, that its more secure if something acciententially happens (f.e. market currency was changed  acciententially). Maybe i will try it now with two seperate currency fields for market / tradelimit.\nWhat I meaned before, was that i want to include the market.currency into the deciaml-convertion of the tradelimit.price -> so i won't have to check if the currencies are the same, because the currency is fully inherited from market.\nBut all in all, you are right and it's more secure to store more data... Thanks for your thoughts...!\n. I know that this behaviour doesnt really belong to this gem, but it would had helped me a lot, if i had known it... And i think other users may have the same problem at some time... \nBeside that.. I use mysql 5.1... And it doesn't throw an error.. Even if i insert data with the mysql command line tool...\n. So there is absolutely no solution if I want to store 30 Mio. dollars in the database with this money gem? :O\n. Hmm... i see.. I would submit a patch, but im not really good in ruby :/ But thanks for your help and work!\nOne last question: what column type would you prefer for storing big values (f.e. 30 Mio. dollars) with cashrb?\n. thx!\n. Ok one last last question :P\nMoney gem with bigint column doesnt work?\n. Ok thx!\n. Yeah, please add support for longer codes..! Aurora and several other altcoins use longer codes - and this gem doesn't let me :(. ",
    "solars": "Hi,\nSorry, somehow google marked your email as spam, I'm not sure why... I just saw it by accident here that you replied.\nThanks for the above suggestions, I will use that for now - however, I still think that this is too complicated and that there should be a method .raw or whatever, returning the number in the 'common' format that all programming languages use, separated by a dot\nThanks and greetings,\nChristoph\n. ah that would be an option, if it always works\nthanks a lot\n. I don't need the monetize gem - how should I replace this call with the money gem?\nDo I need to include the monetize gem now?\n. Alright, thank you\n. one more thing, sorry: what was the last version including the old stuff, so I can use this until everything is changed?\nThanks\n. Hi,\nSorry, somehow google marked your email as spam, I'm not sure why... I just saw it by accident here that you replied.\nThanks for the above suggestions, I will use that for now - however, I still think that this is too complicated and that there should be a method .raw or whatever, returning the number in the 'common' format that all programming languages use, separated by a dot\nThanks and greetings,\nChristoph\n. ah that would be an option, if it always works\nthanks a lot\n. I don't need the monetize gem - how should I replace this call with the money gem?\nDo I need to include the monetize gem now?\n. Alright, thank you\n. one more thing, sorry: what was the last version including the old stuff, so I can use this until everything is changed?\nThanks\n. ",
    "asadfarooq": "I have the same issue\n. I have the same issue\n. ",
    "defconomicron": "Yes, we work together.  Sorry.\n. Perhaps this issue does not relate to the Money gem itself but rather to the way rails handles nested attributes.\nHere is a rough fix to my issue:\n```\n    def invoice_items_attributes=(invoice_items_attributes)\n      invoice_items_attributes.keys.each do |key|\n        attributes = invoice_items_attributes[key]\n        invoice_item = self.invoice_items.detect {|invoice_item| invoice_item.id.to_s == attributes[\"id\"]} || InvoiceItem.new(:invoice_id => self.id)\n    if attributes[\"_destroy\"] == \"1\"\n      invoice_item.destroy\n      next\n    end\n\n    invoice_item.attributes = attributes\n    puts invoice_item.errors.full_messages unless invoice_item.save\n  end\nend\n\n```\n. If anyone is still having issues with this strange bug, here is a monkey patch that I wrote to fix this issue once and for all (works on Rails 3.0.9; not sure about other versions)\n```\n  module ActiveRecord::NestedAttributes::ClassMethods\n    # MONKEY PATCH: THIS METHOD WAS MODIFIED TO CORRECTLY HANDLE THE MONEY/CURRENCY VALUES WITHIN NESTED ATTRIBUTES UPON EVERY SUBSEQUENT SAVE\n    def accepts_nested_attributes_for(*attr_names)\n      options = { :allow_destroy => false, :update_only => false }\n      options.update(attr_names.extract_options!)\n      options.assert_valid_keys(:allow_destroy, :reject_if, :limit, :update_only)\n      options[:reject_if] = REJECT_ALL_BLANK_PROC if options[:reject_if] == :all_blank\n  attr_names.each do |association_name|\n    if reflection = reflect_on_association(association_name)\n      reflection.options[:autosave] = true\n      add_autosave_association_callbacks(reflection)\n      nested_attributes_options[association_name.to_sym] = options\n      type = (reflection.collection? ? :collection : :one_to_one)\n      class_eval <<-eoruby, __FILE__, __LINE__ + 1\n        if method_defined?(:#{association_name}_attributes=)\n          remove_method(:#{association_name}_attributes=)\n        end\n\n        def #{association_name}_attributes=(attributes)\n          if :#{type} == :collection\n            self.#{association_name}[0]\n          else\n            self.#{association_name}\n          end\n          assign_nested_attributes_for_#{type}_association(:#{association_name}, attributes)\n        end\n      eoruby\n    else\n      raise ArgumentError, \"No association found for name `#{association_name}'. Has it been defined yet?\"\n    end\n  end\nend\n\nend\n```\n. Here is a simple test case that you can use without using the UI I've provided:\n```\n  params = {\"invoice\"=>{\"invoice_items_attributes\"=>{\"0\"=>{\"price\"=>\"1\"}}}}\n  invoice = Invoice.new\n  invoice.attributes = params[\"invoice\"]\n  invoice.save\na = invoice.invoice_items.last.price\ninvoice = Invoice.last\n  params = {\"invoice\"=>{\"invoice_items_attributes\"=>{\"0\"=>{\"price\"=>\"1.00\", \"id\"=>invoice.invoice_item_ids.last}}}}\n  invoice.attributes = params[\"invoice\"]\n  invoice.save\nb = invoice.invoice_items.last.price\nputs a == b ? \"Bug Fixed\" : \"#{a} != #{b}\"\n```\n. I've not made any new advances on this issue.  We suspect that it is an Active Record issue.\nThe currency gem located at: https://github.com/kstephens/currency/issues/1 has the same issue as well.\n. Yes, we work together.  Sorry.\n. Perhaps this issue does not relate to the Money gem itself but rather to the way rails handles nested attributes.\nHere is a rough fix to my issue:\n```\n    def invoice_items_attributes=(invoice_items_attributes)\n      invoice_items_attributes.keys.each do |key|\n        attributes = invoice_items_attributes[key]\n        invoice_item = self.invoice_items.detect {|invoice_item| invoice_item.id.to_s == attributes[\"id\"]} || InvoiceItem.new(:invoice_id => self.id)\n    if attributes[\"_destroy\"] == \"1\"\n      invoice_item.destroy\n      next\n    end\n\n    invoice_item.attributes = attributes\n    puts invoice_item.errors.full_messages unless invoice_item.save\n  end\nend\n\n```\n. If anyone is still having issues with this strange bug, here is a monkey patch that I wrote to fix this issue once and for all (works on Rails 3.0.9; not sure about other versions)\n```\n  module ActiveRecord::NestedAttributes::ClassMethods\n    # MONKEY PATCH: THIS METHOD WAS MODIFIED TO CORRECTLY HANDLE THE MONEY/CURRENCY VALUES WITHIN NESTED ATTRIBUTES UPON EVERY SUBSEQUENT SAVE\n    def accepts_nested_attributes_for(*attr_names)\n      options = { :allow_destroy => false, :update_only => false }\n      options.update(attr_names.extract_options!)\n      options.assert_valid_keys(:allow_destroy, :reject_if, :limit, :update_only)\n      options[:reject_if] = REJECT_ALL_BLANK_PROC if options[:reject_if] == :all_blank\n  attr_names.each do |association_name|\n    if reflection = reflect_on_association(association_name)\n      reflection.options[:autosave] = true\n      add_autosave_association_callbacks(reflection)\n      nested_attributes_options[association_name.to_sym] = options\n      type = (reflection.collection? ? :collection : :one_to_one)\n      class_eval <<-eoruby, __FILE__, __LINE__ + 1\n        if method_defined?(:#{association_name}_attributes=)\n          remove_method(:#{association_name}_attributes=)\n        end\n\n        def #{association_name}_attributes=(attributes)\n          if :#{type} == :collection\n            self.#{association_name}[0]\n          else\n            self.#{association_name}\n          end\n          assign_nested_attributes_for_#{type}_association(:#{association_name}, attributes)\n        end\n      eoruby\n    else\n      raise ArgumentError, \"No association found for name `#{association_name}'. Has it been defined yet?\"\n    end\n  end\nend\n\nend\n```\n. Here is a simple test case that you can use without using the UI I've provided:\n```\n  params = {\"invoice\"=>{\"invoice_items_attributes\"=>{\"0\"=>{\"price\"=>\"1\"}}}}\n  invoice = Invoice.new\n  invoice.attributes = params[\"invoice\"]\n  invoice.save\na = invoice.invoice_items.last.price\ninvoice = Invoice.last\n  params = {\"invoice\"=>{\"invoice_items_attributes\"=>{\"0\"=>{\"price\"=>\"1.00\", \"id\"=>invoice.invoice_item_ids.last}}}}\n  invoice.attributes = params[\"invoice\"]\n  invoice.save\nb = invoice.invoice_items.last.price\nputs a == b ? \"Bug Fixed\" : \"#{a} != #{b}\"\n```\n. I've not made any new advances on this issue.  We suspect that it is an Active Record issue.\nThe currency gem located at: https://github.com/kstephens/currency/issues/1 has the same issue as well.\n. ",
    "pwim": "But there is no such thing as sen, as it was taken out of circulation in 1953. As I am living in Japan, I can assure you no one uses decimal units when using Yen. \nI want to display currency how it would normally be displayed. For instance, with US Dollars, I want to display $100.00 and with yen \u00a51,000. If I need to use :no_cents, then as far as I understand, I would need to inspect which currency I am displaying, defeating the point of using a library like this.\n. @thijsc The spec is assuming the currency has 100 subunits to a unit (like 100 cents in a dollar), whereas the yen has no subunit, \n. But there is no such thing as sen, as it was taken out of circulation in 1953. As I am living in Japan, I can assure you no one uses decimal units when using Yen. \nI want to display currency how it would normally be displayed. For instance, with US Dollars, I want to display $100.00 and with yen \u00a51,000. If I need to use :no_cents, then as far as I understand, I would need to inspect which currency I am displaying, defeating the point of using a library like this.\n. @thijsc The spec is assuming the currency has 100 subunits to a unit (like 100 cents in a dollar), whereas the yen has no subunit, \n. ",
    "thijsc": "Thanks for the info. This is a bit of a confusing subject.\n. Thanks for the info. This is a bit of a confusing subject.\n. ",
    "mjankowski": "No problem - figure I can save someone else the hour I lost today - thanks for merging!\n. I'm not sure if this is actually your issue, but shouldn't you use separate columns to store the currency for each attribute?\nSo, if you want \"fee\" and \"service_fee\" to both be composed_of/Money attributes in your model, I would use the following db columns:\n- fee_cents + fee_currency -- to store amount and currency values for the fee attribute\n- service_fee_cents + service_fee_currency -- to store amount and currency values for the service fee attribute\nThe way you have it now, I think the \"currency\" column will be used for both values - which might cause the gem to replace the value for whichever column you are not setting?\n. No problem - figure I can save someone else the hour I lost today - thanks for merging!\n. I'm not sure if this is actually your issue, but shouldn't you use separate columns to store the currency for each attribute?\nSo, if you want \"fee\" and \"service_fee\" to both be composed_of/Money attributes in your model, I would use the following db columns:\n- fee_cents + fee_currency -- to store amount and currency values for the fee attribute\n- service_fee_cents + service_fee_currency -- to store amount and currency values for the service fee attribute\nThe way you have it now, I think the \"currency\" column will be used for both values - which might cause the gem to replace the value for whichever column you are not setting?\n. ",
    "mmzoo": "Hi, thank you for your answer.\nI agree that this would be a more maintainable solution when the Money gem is updated in the future. Yet, our app is so large, that it would be full of\nFormatter.money(Money.new(...), ...)\nand it felt so nice just being able to call Money.format without intermediator (I mean, that's what the format function is all about, right?). Actually, our huge legacy system uses that type of intermediator and we're trying to get rid of it :)\nYour solution doesn't fix the hardcoded space in Money#format, though ;)\n. Hm. I think we found a compromise here :) Thank you!\n. Hi, thank you for your answer.\nI agree that this would be a more maintainable solution when the Money gem is updated in the future. Yet, our app is so large, that it would be full of\nFormatter.money(Money.new(...), ...)\nand it felt so nice just being able to call Money.format without intermediator (I mean, that's what the format function is all about, right?). Actually, our huge legacy system uses that type of intermediator and we're trying to get rid of it :)\nYour solution doesn't fix the hardcoded space in Money#format, though ;)\n. Hm. I think we found a compromise here :) Thank you!\n. ",
    "johnrees": "Thought that might be the route to take. Thanks for the speedy response.\n. It's a shoulda problem, when I get to the bottom of it I'll post an update on here for anyone who might stumble on this thread. I realise you like to keep your issues clean on this gem so I'll close it for now! Thanks.\n. Thought that might be the route to take. Thanks for the speedy response.\n. It's a shoulda problem, when I get to the bottom of it I'll post an update on here for anyone who might stumble on this thread. I realise you like to keep your issues clean on this gem so I'll close it for now! Thanks.\n. ",
    "f3r": "Upps, somehow I skipped that. Thanks!!!\n. Upps, somehow I skipped that. Thanks!!!\n. ",
    "ghost": "What this file is used for? Could someone explain more about it?\n. I could do it...\n. weppos: OK\n. I've tried the money-rails gem. Unfortunately I've got the same bug as noted here when saving the currency with the price_cents column. Using it without the currency part works okay though.\n. ```\nform\n<%= f.select(:price_currency, all_currencies(Money::Currency.table)) %>\n<%= f.text_field :price_cents %>\nviews\n<%= @dress.price_currency %> <%= @dress.price_cents %>\n```\nThis fixed saving the currency part but it saves the price in the database without converting it to cents. For example, if I input the price as \"1957\" it saves directly as \"1957\".\nI'm gonna try the second one right now.\n. ruby\n  def create\n    @dress.name = params[:dress][:name]\n    @dress.image = params[:dress][:image]\n    @dress.description = params[:dress][:description]\n    @dress.category_id = params[:dress][:category_id]\n    @dress.image = params[:dress][:type_id]\n    @dress.price = Money.parse(params[:dress][:price_cents], params[:dress][:price_currency])\n  ...\nThis doesn't work. It says undefined methodname=' for nil:NilClass`.\nruby\n  def create\n    @dress = current_user.shop.dresses.build(params[:dress])\n    @dress.price = Money.parse(params[:dress][:price_cents], params[:dress][:price_currency])\n  ...\nThis one gives the error Can't mass-assign protected attributes: price_currency, price.\n. This one gives me the error Can't mass-assign protected attributes: price_currency, price:\nruby\ndef create\n    price_cents = params[:dress].delete([:price_cents])\n    price_currency = params[:dress].delete([:price_currency])\n    @dress = current_user.shop.dresses.build(params[:dress])\n    @dress.price = Money.parse(price_cents, price_currency)\nTried this and it just saves using the default currency and set the price to 0.00 :\n``` ruby\ndef create\n  @dress = current_user.shop.dresses.build(post_params)\n  @dress.price = Money.parse(params[:dress][:price_cents], params[:dress][:price_currency])\n...\nprivate\ndef post_params\n  params[:dress].slice(:name, :image, :description, :category_id, :type_id)\nend\n```\nI'll just close the issue as \"a gap in my knowledge\" rather than a bug. Thanks for trying to help though.\np/s: I think that I'm approaching this problem in the wrong way. If the user has to input the currency every single time they want to add a new dress, they would be annoyed. A better approach is to ask the user to set a default currency for their shop.\n. ##### Update\n@semmons99 \u2014 The latest version of money-rails gem which was released 8 days ago solved this issue.\n. By the law https://es.wikipedia.org/wiki/Peso_Ley_18.188. Sorry but I do not have much time and should learn how to pull request. For the next one.. What this file is used for? Could someone explain more about it?\n. I could do it...\n. weppos: OK\n. I've tried the money-rails gem. Unfortunately I've got the same bug as noted here when saving the currency with the price_cents column. Using it without the currency part works okay though.\n. ```\nform\n<%= f.select(:price_currency, all_currencies(Money::Currency.table)) %>\n<%= f.text_field :price_cents %>\nviews\n<%= @dress.price_currency %> <%= @dress.price_cents %>\n```\nThis fixed saving the currency part but it saves the price in the database without converting it to cents. For example, if I input the price as \"1957\" it saves directly as \"1957\".\nI'm gonna try the second one right now.\n. ruby\n  def create\n    @dress.name = params[:dress][:name]\n    @dress.image = params[:dress][:image]\n    @dress.description = params[:dress][:description]\n    @dress.category_id = params[:dress][:category_id]\n    @dress.image = params[:dress][:type_id]\n    @dress.price = Money.parse(params[:dress][:price_cents], params[:dress][:price_currency])\n  ...\nThis doesn't work. It says undefined methodname=' for nil:NilClass`.\nruby\n  def create\n    @dress = current_user.shop.dresses.build(params[:dress])\n    @dress.price = Money.parse(params[:dress][:price_cents], params[:dress][:price_currency])\n  ...\nThis one gives the error Can't mass-assign protected attributes: price_currency, price.\n. This one gives me the error Can't mass-assign protected attributes: price_currency, price:\nruby\ndef create\n    price_cents = params[:dress].delete([:price_cents])\n    price_currency = params[:dress].delete([:price_currency])\n    @dress = current_user.shop.dresses.build(params[:dress])\n    @dress.price = Money.parse(price_cents, price_currency)\nTried this and it just saves using the default currency and set the price to 0.00 :\n``` ruby\ndef create\n  @dress = current_user.shop.dresses.build(post_params)\n  @dress.price = Money.parse(params[:dress][:price_cents], params[:dress][:price_currency])\n...\nprivate\ndef post_params\n  params[:dress].slice(:name, :image, :description, :category_id, :type_id)\nend\n```\nI'll just close the issue as \"a gap in my knowledge\" rather than a bug. Thanks for trying to help though.\np/s: I think that I'm approaching this problem in the wrong way. If the user has to input the currency every single time they want to add a new dress, they would be annoyed. A better approach is to ask the user to set a default currency for their shop.\n. ##### Update\n@semmons99 \u2014 The latest version of money-rails gem which was released 8 days ago solved this issue.\n. By the law https://es.wikipedia.org/wiki/Peso_Ley_18.188. Sorry but I do not have much time and should learn how to pull request. For the next one.. ",
    "mdi": "Yep. It's fixed now. Thanks!\n. :+1:\n. Yep. It's fixed now. Thanks!\n. :+1:\n. ",
    "chezka": "Thanks for the quick response.\n\nIf so does \"0.0005\".to_money(:kzm)\n\nalso broken\nruby-1.8.7-p352 :001 > '0.0005'.to_money(:kzm)\n => #<Money cents:1 currency:KZM>\n\nBut if you commit to writing some tests, I will work on getting this fixed.\n\nThat would be great. I will write tests in next few days.\nBTW integer version works correct:\nruby-1.8.7-p352 :003 > 0.5.to_money(:kzm)\n => #<Money cents:2200 currency:KZM>\n. Thanks for the quick response.\n\nIf so does \"0.0005\".to_money(:kzm)\n\nalso broken\nruby-1.8.7-p352 :001 > '0.0005'.to_money(:kzm)\n => #<Money cents:1 currency:KZM>\n\nBut if you commit to writing some tests, I will work on getting this fixed.\n\nThat would be great. I will write tests in next few days.\nBTW integer version works correct:\nruby-1.8.7-p352 :003 > 0.5.to_money(:kzm)\n => #<Money cents:2200 currency:KZM>\n. ",
    "pelle": "I forgot I also added the -@ arithmetic method to make change the polarity of a money object as well as guard. \nAll commits can be cherry-picked.\n. closing this and resubmitting 3 separate pull requests.\nOne comment though is that it doesn't modify the global list of currencies. I had a version that did and agree that is not a good idea. This just creates a new instance to be used separately.\n. The main reason I needed it is that I want to be able to accept both money objects and numbers, using to_money to normalize them. You know for the same reason String implements to_s. Money had to_money but not with the same signature as the core extensions. This just brings them in line with core extensions.\n. I'm not sure you can do that with the current initialize method.\nThe problem is that the integration with the currency table makes it very difficult to work around. Essentially the initializer acts like a finder and not a regular constructor.\nIn our application we have potentially 1000s of currencies, whose properties update all the time. We don't want them in the national currency table, but would like to be able to interact with them in the same way. I realize we are quite unusual with this problem, so I'm quite happy to just leave it in my fork.\n. I forgot I also added the -@ arithmetic method to make change the polarity of a money object as well as guard. \nAll commits can be cherry-picked.\n. closing this and resubmitting 3 separate pull requests.\nOne comment though is that it doesn't modify the global list of currencies. I had a version that did and agree that is not a good idea. This just creates a new instance to be used separately.\n. The main reason I needed it is that I want to be able to accept both money objects and numbers, using to_money to normalize them. You know for the same reason String implements to_s. Money had to_money but not with the same signature as the core extensions. This just brings them in line with core extensions.\n. I'm not sure you can do that with the current initialize method.\nThe problem is that the integration with the currency table makes it very difficult to work around. Essentially the initializer acts like a finder and not a regular constructor.\nIn our application we have potentially 1000s of currencies, whose properties update all the time. We don't want them in the national currency table, but would like to be able to interact with them in the same way. I realize we are quite unusual with this problem, so I'm quite happy to just leave it in my fork.\n. ",
    "masonhale": "Follow-up: \nIt appears my Heroku app did not have an encoding specified, and defaulted to US-ASCII. Updating that to UTF-8 by adding a LANG=en_US.UTF-8 config variable also resolved the issue.\nThe core issue then appears to be that the money gem requires a UTF-8 encoding setting to work properly. Any app with a US-ASCII encoding will cause a crash when the gem is loaded.\nSuggestion: either remove the dependency on UTF-8 encoding, or clearly document that dependency.\n. Thanks. It may be worth pointing out that some users (many) of the Money gem (myself included) are primarily interested in it to provide a way to store money values without floating point errors, and don't need or use the multi-currency features at all. \nMaybe it would make sense to break up the parts so that those users who don't need/want multi-currency support aren't forced to use UTF-8? \n. Thanks for pointing that out -- I'll check it out.\n. Follow-up: \nIt appears my Heroku app did not have an encoding specified, and defaulted to US-ASCII. Updating that to UTF-8 by adding a LANG=en_US.UTF-8 config variable also resolved the issue.\nThe core issue then appears to be that the money gem requires a UTF-8 encoding setting to work properly. Any app with a US-ASCII encoding will cause a crash when the gem is loaded.\nSuggestion: either remove the dependency on UTF-8 encoding, or clearly document that dependency.\n. Thanks. It may be worth pointing out that some users (many) of the Money gem (myself included) are primarily interested in it to provide a way to store money values without floating point errors, and don't need or use the multi-currency features at all. \nMaybe it would make sense to break up the parts so that those users who don't need/want multi-currency support aren't forced to use UTF-8? \n. Thanks for pointing that out -- I'll check it out.\n. ",
    "semaperepelitsa": "Cool, thanks!\n. Is there any benefit in having this disabled and therefore keeping two implementations? If so, this could be extracted into a module to avoid if statements all over the code.\n. Why do you think we need to explicitly check that it responds to dump? Ruby will check that itself and display a clear error:\n```\n\n\nMoney::Bank::VariableExchange.new.export_rates PStore\nNoMethodError: undefined method `dump' for PStore:Class\n```\n\n\nAlso, it is not stored anywhere, so the problem can be easily tracked down.\nI agree, this can be a private method (with a case statement) instead of a hash. Generally, I like using hashes for this more because they can be easily modified in other places like `VariableExchange::FORMAT_MAP[:yaml] = Syck\". But it does not matter here much.\nDo you think it is worth showing :json in documentation? I don't see any benefits in this (except for backwards compatibility) so I'm not sure what to write. Don't want to leave that question to a reader.\n. The formatting rules do not depend on currency, they depend on locale. In US English you write \"\u20ac10,370.55\" and in Russian - \"10 370,55 \u20ac\".\nThis doesn't matter when you are dealing with a local currency only. But it is not uncommon to have an additional one.\n. The money format isn't defined by the currency but by the locale. For example, in USA you would write $10,000.23 and \u20ac10,000.23. In Russia that would be 10 000,23 $ and 10 000,23 \u20ac.\nMaybe, the parser should handle ambiguous inputs based on optional \"locale\" argument.\n. Cool, thanks!\n. Is there any benefit in having this disabled and therefore keeping two implementations? If so, this could be extracted into a module to avoid if statements all over the code.\n. Why do you think we need to explicitly check that it responds to dump? Ruby will check that itself and display a clear error:\n```\n\n\nMoney::Bank::VariableExchange.new.export_rates PStore\nNoMethodError: undefined method `dump' for PStore:Class\n```\n\n\nAlso, it is not stored anywhere, so the problem can be easily tracked down.\nI agree, this can be a private method (with a case statement) instead of a hash. Generally, I like using hashes for this more because they can be easily modified in other places like `VariableExchange::FORMAT_MAP[:yaml] = Syck\". But it does not matter here much.\nDo you think it is worth showing :json in documentation? I don't see any benefits in this (except for backwards compatibility) so I'm not sure what to write. Don't want to leave that question to a reader.\n. The formatting rules do not depend on currency, they depend on locale. In US English you write \"\u20ac10,370.55\" and in Russian - \"10 370,55 \u20ac\".\nThis doesn't matter when you are dealing with a local currency only. But it is not uncommon to have an additional one.\n. The money format isn't defined by the currency but by the locale. For example, in USA you would write $10,000.23 and \u20ac10,000.23. In Russia that would be 10 000,23 $ and 10 000,23 \u20ac.\nMaybe, the parser should handle ambiguous inputs based on optional \"locale\" argument.\n. ",
    "etagwerker": "Hey, thanks for your feedback. \nI'll look into starting a new gem for this particular need. \n. Hey, thanks for your feedback. \nI'll look into starting a new gem for this particular need. \n. ",
    "triemstr": "Hi @etagwerker, I'd like to see a few of these country gems working more closely together.  For example, there are country lists growing at spree and at carmen: https://github.com/jim/carmen as @alovak has mentioned.\nSee some discussion on a more recent attempt to develop country tables here: https://github.com/jim/carmen/issues/43\nI definitely also need currencies with each country.\nAnyway, you can contact me as you setup your gem...I'm sure I'll have a few ideas and don't want to add any more comments here.\nKevin\n. Hi @etagwerker, I'd like to see a few of these country gems working more closely together.  For example, there are country lists growing at spree and at carmen: https://github.com/jim/carmen as @alovak has mentioned.\nSee some discussion on a more recent attempt to develop country tables here: https://github.com/jim/carmen/issues/43\nI definitely also need currencies with each country.\nAnyway, you can contact me as you setup your gem...I'm sure I'll have a few ideas and don't want to add any more comments here.\nKevin\n. ",
    "dom1nga": "Works right on:\n-ruby-1.8.7-p352 \n-ruby-1.9.2-p290\n-ruby-1.9.3-preview1\n. why not normal for ruby using something like this var = 8-?\n. with this pull request Money.parse('-5.95-') # => #<Money cents:-595 currency:USD>\ni think this is not normal behavior.\n. @semmons99 lambda { Money.parse('-5.95-') }.should raise_error ArgumentError or Money.new(0, 'USD')\n. when you take number as part of string argument, you  can expect as a result of non-zero value. better to raise argument error, than to mislead with zero value as a result.\n. it would be nice.\nbut in this case we have to override result of something like this Money.parse ('hellothere'), and this can create problems for current users. with accepting this issue we'll have these problems. I am against minus sign after the amount because of the mathematical perception of numbers. -8 is negative 8.\n8- or 8 - is mathematical operation, which expects the second argument.\n. Works right on:\n-ruby-1.8.7-p352 \n-ruby-1.9.2-p290\n-ruby-1.9.3-preview1\n. why not normal for ruby using something like this var = 8-?\n. with this pull request Money.parse('-5.95-') # => #<Money cents:-595 currency:USD>\ni think this is not normal behavior.\n. @semmons99 lambda { Money.parse('-5.95-') }.should raise_error ArgumentError or Money.new(0, 'USD')\n. when you take number as part of string argument, you  can expect as a result of non-zero value. better to raise argument error, than to mislead with zero value as a result.\n. it would be nice.\nbut in this case we have to override result of something like this Money.parse ('hellothere'), and this can create problems for current users. with accepting this issue we'll have these problems. I am against minus sign after the amount because of the mathematical perception of numbers. -8 is negative 8.\n8- or 8 - is mathematical operation, which expects the second argument.\n. ",
    "plentz": "this one should do the trick https://github.com/flori/json/pull/119\n. this one should do the trick https://github.com/flori/json/pull/119\n. ",
    "kenn": "@semmons99 sorry for my late reply - your fix does seem good, plus backward compatible. Can you apply the fix, or should I cook up a pull request? Thanks!\n. I thought the underlaid purpose of the full coverage was to test Float presicion at every corner case in decimal places.\nruby\nirb> 0.1 + 0.7\n => 0.7999999999999999\nhttp://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/\nAre you sure it's a good idea? At least we should be clear how we chose those specific test cases and, at least, change the test titles - it's no longer brute force. :)\n. @semmons99 sorry for my late reply - your fix does seem good, plus backward compatible. Can you apply the fix, or should I cook up a pull request? Thanks!\n. I thought the underlaid purpose of the full coverage was to test Float presicion at every corner case in decimal places.\nruby\nirb> 0.1 + 0.7\n => 0.7999999999999999\nhttp://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/\nAre you sure it's a good idea? At least we should be clear how we chose those specific test cases and, at least, change the test titles - it's no longer brute force. :)\n. ",
    "nubs": "Updated pull request with tests for negative amounts in general.  Changed code to throw an argument error for \"-$5.95-\"\n. Updated pull request with tests for negative amounts in general.  Changed code to throw an argument error for \"-$5.95-\"\n. ",
    "WhiteFire-Sondergaard": "Expect? cents:-10000. The ($nnnnn) format is the default for negative currency values for the finance industry for USD.\nThanks for the quick response by the way. :)\n. Seeing a little mixed feedback here? Too accepting vs submit a pull request? :)\nAnyway, if it's not something you want to do to the class, which I can understand the rational for, at least it should not ignore the ()s. If it's not going to parse them, it should at least throw an error.\nOtherwise someone that is feeding a form field into string.money is going to have a user pasting from a ledger or excel getting the nasty surprise of negative becoming positive.\n. Actually I have been searching for more information on that myself. So far I can find references to it being standard in accounting within the United States, which matches what my users tell me, but only vague references to other currency's negative representation. For example, some countries use nnn- rather than -nnn.\nEven more disturbing is that some countries invert the meaning of comma and period, leading to figures like 1.000.000,00\nThe more I learn about the finance industry, the more I wonder how we are not living in caves. \n. The more I have looked into this, the more I expect that to parse values correctly you are going to need to know what currency you are dealing with first. It's more than just the whole negative number issue. That could easily be solved by searching for a - or some for of ()s. Things like 1,000,000.00 and 1.000.000,00 being valid depending on the currency involved (US vs. Denmark in that case) means you can't just ignore commas.\n. Expect? cents:-10000. The ($nnnnn) format is the default for negative currency values for the finance industry for USD.\nThanks for the quick response by the way. :)\n. Seeing a little mixed feedback here? Too accepting vs submit a pull request? :)\nAnyway, if it's not something you want to do to the class, which I can understand the rational for, at least it should not ignore the ()s. If it's not going to parse them, it should at least throw an error.\nOtherwise someone that is feeding a form field into string.money is going to have a user pasting from a ledger or excel getting the nasty surprise of negative becoming positive.\n. Actually I have been searching for more information on that myself. So far I can find references to it being standard in accounting within the United States, which matches what my users tell me, but only vague references to other currency's negative representation. For example, some countries use nnn- rather than -nnn.\nEven more disturbing is that some countries invert the meaning of comma and period, leading to figures like 1.000.000,00\nThe more I learn about the finance industry, the more I wonder how we are not living in caves. \n. The more I have looked into this, the more I expect that to parse values correctly you are going to need to know what currency you are dealing with first. It's more than just the whole negative number issue. That could easily be solved by searching for a - or some for of ()s. Things like 1,000,000.00 and 1.000.000,00 being valid depending on the currency involved (US vs. Denmark in that case) means you can't just ignore commas.\n. ",
    "gerwinov": "For sure. Thanks a lot!\n. For sure. Thanks a lot!\n. ",
    "mrmanishs": "Ah ok - let me check that, I think there's some conflict where a Countries gem I am using is installing it's own Money object.\nWhat's the default Exchange service to use, does one come with your Money?\nOn Feb 5, 2012, at 12:43 PM, Simone Carletti wrote:\n\nI just noticed you are using a ISO4217::Currency::ExchangeBank:0x104f9b820 object. I'm sorry, but this object doesn't belong to Money.\nIt seems you are using a Bank object provided by a different gem. Please check the documentation for that gem.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/140#issuecomment-3819202\n. OK -I got more details - I'm using a countries gem which says I can use your Money gem.\n\nThe countries gem (https://github.com/hexorx/countries) has this example:\n\n\nMoney.default_bank = Currency::ExchangeBank.new\n=> #>\n?> Money.us_dollar(100).exchange_to(\"CAD\")  # => Money.new(124, \"CAD\")\nNoMethodError: undefined method exchange_with' for #<ISO4217::Currency::ExchangeBank:0x109af9448>\n        from /Library/Ruby/Gems/1.8/gems/money-4.0.2/lib/money/money.rb:320:inexchange_to'\n        from (irb):7\n\n\nAny idea if the example is wrong or if I'm missing something? \nOn Feb 5, 2012, at 12:43 PM, Simone Carletti wrote:\n\nI just noticed you are using a ISO4217::Currency::ExchangeBank:0x104f9b820 object. I'm sorry, but this object doesn't belong to Money.\nIt seems you are using a Bank object provided by a different gem. Please check the documentation for that gem.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/140#issuecomment-3819202\n. Looks like that's helping. Now, it's not noticing CAD currency for conversion: \n\nMoney.default_bank = Money::Bank::VariableExchange.new\n=> #>\nMoney.us_dollar(100).exchange_to(\"USD\")\n=> #\nMoney.us_dollar(100).exchange_to(\"CAD\")\nMoney::Bank::UnknownRate: No conversion rate known for 'USD' -> 'CAD'\n        from /Library/Ruby/Gems/1.8/gems/money-4.0.2/lib/money/bank/variable_exchange.rb:93:in exchange_with'\n        from /Library/Ruby/Gems/1.8/gems/money-4.0.2/lib/money/money.rb:320:inexchange_to'\n        from (irb):15\n\n\nIs there something that needs to be done to pull the exchange rates for default bank?\nOn Feb 5, 2012, at 12:43 PM, Simone Carletti wrote:\n\nI just noticed you are using a ISO4217::Currency::ExchangeBank:0x104f9b820 object. I'm sorry, but this object doesn't belong to Money.\nIt seems you are using a Bank object provided by a different gem. Please check the documentation for that gem.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/140#issuecomment-3819202\n. Will do - thanks Simone.\n\nOn Feb 5, 2012, at 12:58 PM, Simone Carletti wrote:\n\nThe default exchange bank object requires you to manually specify the exchange rate.\nRead the Money README file to learn about adding rates or using alternative bank implementations (section Currency Exchange).\nhttps://github.com/RubyMoney/money\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/140#issuecomment-3819306\n. Ah ok - let me check that, I think there's some conflict where a Countries gem I am using is installing it's own Money object.\n\nWhat's the default Exchange service to use, does one come with your Money?\nOn Feb 5, 2012, at 12:43 PM, Simone Carletti wrote:\n\nI just noticed you are using a ISO4217::Currency::ExchangeBank:0x104f9b820 object. I'm sorry, but this object doesn't belong to Money.\nIt seems you are using a Bank object provided by a different gem. Please check the documentation for that gem.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/140#issuecomment-3819202\n. OK -I got more details - I'm using a countries gem which says I can use your Money gem.\n\nThe countries gem (https://github.com/hexorx/countries) has this example:\n\n\nMoney.default_bank = Currency::ExchangeBank.new\n=> #>\n?> Money.us_dollar(100).exchange_to(\"CAD\")  # => Money.new(124, \"CAD\")\nNoMethodError: undefined method exchange_with' for #<ISO4217::Currency::ExchangeBank:0x109af9448>\n        from /Library/Ruby/Gems/1.8/gems/money-4.0.2/lib/money/money.rb:320:inexchange_to'\n        from (irb):7\n\n\nAny idea if the example is wrong or if I'm missing something? \nOn Feb 5, 2012, at 12:43 PM, Simone Carletti wrote:\n\nI just noticed you are using a ISO4217::Currency::ExchangeBank:0x104f9b820 object. I'm sorry, but this object doesn't belong to Money.\nIt seems you are using a Bank object provided by a different gem. Please check the documentation for that gem.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/140#issuecomment-3819202\n. Looks like that's helping. Now, it's not noticing CAD currency for conversion: \n\nMoney.default_bank = Money::Bank::VariableExchange.new\n=> #>\nMoney.us_dollar(100).exchange_to(\"USD\")\n=> #\nMoney.us_dollar(100).exchange_to(\"CAD\")\nMoney::Bank::UnknownRate: No conversion rate known for 'USD' -> 'CAD'\n        from /Library/Ruby/Gems/1.8/gems/money-4.0.2/lib/money/bank/variable_exchange.rb:93:in exchange_with'\n        from /Library/Ruby/Gems/1.8/gems/money-4.0.2/lib/money/money.rb:320:inexchange_to'\n        from (irb):15\n\n\nIs there something that needs to be done to pull the exchange rates for default bank?\nOn Feb 5, 2012, at 12:43 PM, Simone Carletti wrote:\n\nI just noticed you are using a ISO4217::Currency::ExchangeBank:0x104f9b820 object. I'm sorry, but this object doesn't belong to Money.\nIt seems you are using a Bank object provided by a different gem. Please check the documentation for that gem.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/140#issuecomment-3819202\n. Will do - thanks Simone.\n\nOn Feb 5, 2012, at 12:58 PM, Simone Carletti wrote:\n\nThe default exchange bank object requires you to manually specify the exchange rate.\nRead the Money README file to learn about adding rates or using alternative bank implementations (section Currency Exchange).\nhttps://github.com/RubyMoney/money\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/140#issuecomment-3819306\n. \n",
    "glebm": "Hmm, I guess this does make more sense\n. Hmm, I guess this does make more sense\n. ",
    "enebo": "Ok thanks.  I will likely only address incompatbilities with JRuby when they pop up.\n. ub.com/RubyMoney/money/pull/148 fixed this issue by adding repeated integer division if the map does not have the value in it yet. Things should be working on master for you now.\n. https://github.com/RubyMoney/money/pull/148 fixed this issue by adding repeated integer division if the map does not have the value in it yet.   Things should be working on master for you now.\n. Added class instance var change we talked about.\n. Your landed table changes conflicted with the specs I wrote.  I will update those and commit.\n. Landed...One thing I noticed which may or may not be an issue moving forward.  I do not see FOO currency get unregistered anywhere in the specs, like the previous method used to restore currency table after.  Is this an issue?  semmons, 146 and 147 should be closable now....not sure if I should do that or not...\n. ah ok...will do.\n. Ok thanks.  I will likely only address incompatbilities with JRuby when they pop up.\n. ub.com/RubyMoney/money/pull/148 fixed this issue by adding repeated integer division if the map does not have the value in it yet. Things should be working on master for you now.\n. https://github.com/RubyMoney/money/pull/148 fixed this issue by adding repeated integer division if the map does not have the value in it yet.   Things should be working on master for you now.\n. Added class instance var change we talked about.\n. Your landed table changes conflicted with the specs I wrote.  I will update those and commit.\n. Landed...One thing I noticed which may or may not be an issue moving forward.  I do not see FOO currency get unregistered anywhere in the specs, like the previous method used to restore currency table after.  Is this an issue?  semmons, 146 and 147 should be closable now....not sure if I should do that or not...\n. ah ok...will do.\n. ",
    "barmstrong": "I just tried downgrading to version 4.0.1 and it works now.  Maybe some change in 4.0.2 broke it?  In any event, thanks for the awesome gem!\n. Yeah I was confused how modifying the constant was working - but it seemed to work in 4.0.1?  Not sure why.\nAnyway, the new .register solution looks great.  Should this inc the version number or will it go out in a later 4.0.3?\nThanks!\n. 1.9.3 and money gem 4.0.1\nSweet, sounds like an upgrade will fix it.  Should have thought to check that first.\nThanks semmons99!\n. I just tried downgrading to version 4.0.1 and it works now.  Maybe some change in 4.0.2 broke it?  In any event, thanks for the awesome gem!\n. Yeah I was confused how modifying the constant was working - but it seemed to work in 4.0.1?  Not sure why.\nAnyway, the new .register solution looks great.  Should this inc the version number or will it go out in a later 4.0.3?\nThanks!\n. 1.9.3 and money gem 4.0.1\nSweet, sounds like an upgrade will fix it.  Should have thought to check that first.\nThanks semmons99!\n. ",
    "alup": "Thnx!!! what I was looking for ...\nWhen is this going to be merged to master?\n. Thnx for the fix\n. Finally, I found some extra problems with formatting. I'll try to fix them the next days, depending on my free time. \nE.g. to reproduce a wrong formatting issue:\nEU2 = '{ \"priority\": 2, \"iso_code\": \"EU2\", \"iso_numeric\": \"978\", \"name\": \"Euro\", \"symbol\": \"\u20ac\", \"subunit\": \"Subcent\", \"subunit_to_unit\": 10000, \"symbol_first\": false, \"decimal_mark\": \",\", \"thousands_separator\": \".\" }'\nMoney::Currency.register(JSON.parse(EU2, :symbolize_names => true))\n\"91,1023\".to_money(\"EU2\").format\n. @semmons99 Done :)! I also rebased!\n. Thanks @semmons99 :)\n. Fixed in GH-159\n. This is a valid concern, but I think that the majority of people which come to use this library (like me :) ), want a quick (and mature) solution to bring currency conversions and money handling in their application. If we also admit that the majority of applications are based on the web and the dominant solution out there is Rails, then we have WHP an answer.\n. Yes the testing will bring heavy deps into play, but this is going to affect only the development part. \nI also like the proposal of a new gem to handle the integration separately.\n. +1 @semmons99\nI would like to help and I could also lead the effort if you want.\n. @semmons99 thnx dude, we will rock :)\n. It seems fine and all tests are passing.\n. It is a bug! CLP are 1 to 1 mapped with their subunit and this seems to  break format method\n. I agree with @weppos, the example I suggested is not the best to demonstrate the need. But I think, there should be a way to denote a failing String parsing by raising an exception. This implies a delegation of the handling to a higher level and it is compatible with the common approach.\nAn instance variable would only handle the problem in a library-wide, boolean manner. I believe there should also be a separate method.\n. Ok, I agree ... \n. :+1:\n. I agree with @hakanensari\n. @semmons99 I think just writing it to the README would be enough.\n. Seems good to me. \n/cc @semmons99\n. @mdi Please squash your commits to remove the reverted ones. You can just git push -f <your_remote_name> <your_branch_name> to update this pull request :)\n. @mikaelwikman @semmons99 Keep in mind that we also want backwards compatibility, so except for fixing the wrong usage of cents, we need to maintain the presence of #cents (meaning 100 fractions of a currency) in order to avoid breaking people's code :)!\nAfterwards we may deprecate its usage.\n. @semmons99 Should we release 5.1.1 to address this?\n. @semmons99 not yet :p\n. @semmons99 thanks mate :)\n. You're welcome :)!\n. I cannot reproduce the issue in master :s\nirb(main):001:0> Money.new(100023, \"RUB\").format(no_cents: true, thousands_separator: \".\")\n=> \"1.000 \u0440.\"\nirb(main):002:0> Money.new(100023, \"RUB\").format(thousands_separator: \".\")\n=> \"1.000,23 \u0440.\"\nCan you try to use the master branch as dependency in your Gemfile?\ngem \"money\", git: <repository_url>\n. @blackbumer any progress on this?\n. closing this till we have a response :)\n. Ok, the issue has to do with the way Money gem integrates with I18n in Rails. Take a look at this.\nIf I18n is defined, which is true in Rails, then Money tries to use the I18n defined stuff. Thousands separator is picked by \"number.currency.format.delimiter\" or \"number.format.delimiter\" and decimal mark by \"number.currency.format.separator\" or \"number.format.separator\" in config/locales/*.\nSo, in order to solve this, you should put the appropriate values in the config/locales/<whatever>.yml.\nP.s. I am not an American :P \nUpdate: I silently supposed that you are using Money with Rails :)\n. @semmons99 @halo agree on this. @halo Would you like to provide a patch for it?\n. Yes, I like the approach. @halo keep in mind that we also need to provide backwards compatibility for the moment. Later, we could deprecate the old stuff that doesn't fit to the new strategy.\n. LGTM, ty John\n. Credits to @fotos :)\n. thnx for this :)\n. Can you please squash your commits in order to be ready for merging?\n. One commit is preferrable\n. Thank you again!\n. thnx :)\n. Thnx for the patch\n. This will break some people's code as it is not backwards compatible. Maybe we should provide some extra options to handle these cases. @semmons99 what do you think?\n. Can you provide us with an example code snippet? :)\n. Thnx!!! what I was looking for ...\nWhen is this going to be merged to master?\n. Thnx for the fix\n. Finally, I found some extra problems with formatting. I'll try to fix them the next days, depending on my free time. \nE.g. to reproduce a wrong formatting issue:\nEU2 = '{ \"priority\": 2, \"iso_code\": \"EU2\", \"iso_numeric\": \"978\", \"name\": \"Euro\", \"symbol\": \"\u20ac\", \"subunit\": \"Subcent\", \"subunit_to_unit\": 10000, \"symbol_first\": false, \"decimal_mark\": \",\", \"thousands_separator\": \".\" }'\nMoney::Currency.register(JSON.parse(EU2, :symbolize_names => true))\n\"91,1023\".to_money(\"EU2\").format\n. @semmons99 Done :)! I also rebased!\n. Thanks @semmons99 :)\n. Fixed in GH-159\n. This is a valid concern, but I think that the majority of people which come to use this library (like me :) ), want a quick (and mature) solution to bring currency conversions and money handling in their application. If we also admit that the majority of applications are based on the web and the dominant solution out there is Rails, then we have WHP an answer.\n. Yes the testing will bring heavy deps into play, but this is going to affect only the development part. \nI also like the proposal of a new gem to handle the integration separately.\n. +1 @semmons99\nI would like to help and I could also lead the effort if you want.\n. @semmons99 thnx dude, we will rock :)\n. It seems fine and all tests are passing.\n. It is a bug! CLP are 1 to 1 mapped with their subunit and this seems to  break format method\n. I agree with @weppos, the example I suggested is not the best to demonstrate the need. But I think, there should be a way to denote a failing String parsing by raising an exception. This implies a delegation of the handling to a higher level and it is compatible with the common approach.\nAn instance variable would only handle the problem in a library-wide, boolean manner. I believe there should also be a separate method.\n. Ok, I agree ... \n. :+1:\n. I agree with @hakanensari\n. @semmons99 I think just writing it to the README would be enough.\n. Seems good to me. \n/cc @semmons99\n. @mdi Please squash your commits to remove the reverted ones. You can just git push -f <your_remote_name> <your_branch_name> to update this pull request :)\n. @mikaelwikman @semmons99 Keep in mind that we also want backwards compatibility, so except for fixing the wrong usage of cents, we need to maintain the presence of #cents (meaning 100 fractions of a currency) in order to avoid breaking people's code :)!\nAfterwards we may deprecate its usage.\n. @semmons99 Should we release 5.1.1 to address this?\n. @semmons99 not yet :p\n. @semmons99 thanks mate :)\n. You're welcome :)!\n. I cannot reproduce the issue in master :s\nirb(main):001:0> Money.new(100023, \"RUB\").format(no_cents: true, thousands_separator: \".\")\n=> \"1.000 \u0440.\"\nirb(main):002:0> Money.new(100023, \"RUB\").format(thousands_separator: \".\")\n=> \"1.000,23 \u0440.\"\nCan you try to use the master branch as dependency in your Gemfile?\ngem \"money\", git: <repository_url>\n. @blackbumer any progress on this?\n. closing this till we have a response :)\n. Ok, the issue has to do with the way Money gem integrates with I18n in Rails. Take a look at this.\nIf I18n is defined, which is true in Rails, then Money tries to use the I18n defined stuff. Thousands separator is picked by \"number.currency.format.delimiter\" or \"number.format.delimiter\" and decimal mark by \"number.currency.format.separator\" or \"number.format.separator\" in config/locales/*.\nSo, in order to solve this, you should put the appropriate values in the config/locales/<whatever>.yml.\nP.s. I am not an American :P \nUpdate: I silently supposed that you are using Money with Rails :)\n. @semmons99 @halo agree on this. @halo Would you like to provide a patch for it?\n. Yes, I like the approach. @halo keep in mind that we also need to provide backwards compatibility for the moment. Later, we could deprecate the old stuff that doesn't fit to the new strategy.\n. LGTM, ty John\n. Credits to @fotos :)\n. thnx for this :)\n. Can you please squash your commits in order to be ready for merging?\n. One commit is preferrable\n. Thank you again!\n. thnx :)\n. Thnx for the patch\n. This will break some people's code as it is not backwards compatible. Maybe we should provide some extra options to handle these cases. @semmons99 what do you think?\n. Can you provide us with an example code snippet? :)\n. ",
    "scomma": "Ouch! Sorry it slipped my mind.\n. Ouch! Sorry it slipped my mind.\n. ",
    "yagooar": "There is no official way of writing the Euro symbol. Please be careful about the fonts you provide, as I can't find there anything related to the topic.\nRead this article in order to learn more about it: http://en.wikipedia.org/wiki/Linguistic_issues_concerning_the_euro\n. There is no official way of writing the Euro symbol. Please be careful about the fonts you provide, as I can't find there anything related to the topic.\nRead this article in order to learn more about it: http://en.wikipedia.org/wiki/Linguistic_issues_concerning_the_euro\n. ",
    "mezis": "Placement of the symbol relative to the amount is actually locale-dependent, and is in no way specified by the EU. The correct link for standards regarding the symbol is http://ec.europa.eu/economy_finance/euro/cash/symbol/index_en.htm (the link in the commit concerns the coins, not the symbols).\nNote that Rails correctly specifies this on a per-locale basis, eg. for French.\n. Placement of the symbol relative to the amount is actually locale-dependent, and is in no way specified by the EU. The correct link for standards regarding the symbol is http://ec.europa.eu/economy_finance/euro/cash/symbol/index_en.htm (the link in the commit concerns the coins, not the symbols).\nNote that Rails correctly specifies this on a per-locale basis, eg. for French.\n. ",
    "the-architect": "Thank you. :)\n. Thank you. :)\n. ",
    "banjerluke": "D'oh. Bad programmer! No treat!\nFixed now. :-)\n. D'oh. Bad programmer! No treat!\nFixed now. :-)\n. ",
    "neilmiddleton": "I've added a setting Money.assume_from_symbol which enables this behavior if it's wanted.\n. I can, but what would you expect the result to be?  An error, or an assumption of the default currency?\n. Thanks!\nNeil\nOn Friday, 9 March 2012 at 14:51, Shane Emmons wrote:\n\nThanks for the patch @neilmiddleton. You now have commit rights to the repo.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/155#issuecomment-4417450\n. +1\n. I've added a setting Money.assume_from_symbol which enables this behavior if it's wanted.\n. I can, but what would you expect the result to be?  An error, or an assumption of the default currency?\n. Thanks!\n\nNeil\nOn Friday, 9 March 2012 at 14:51, Shane Emmons wrote:\n\nThanks for the patch @neilmiddleton. You now have commit rights to the repo.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/155#issuecomment-4417450\n. +1\n. \n",
    "matma": "+1\n. My opinion is similar to @marcoow's - if you are using this gem in production in real world (everything which is fiscal), the historical rates are often required. So making this as an extension is perfect compromise. For me big :+1: \n. +1\n. My opinion is similar to @marcoow's - if you are using this gem in production in real world (everything which is fiscal), the historical rates are often required. So making this as an extension is perfect compromise. For me big :+1: \n. ",
    "ohthatjames": "Thanks, done!\n. I would be opposed, but not militantly so. It seems like a lot of work for little value: it's not hard to use the snippet in the wiki to create your own abstraction. The wiki provides a handy default, but I don't necessarily think it's the use-case that's always appropriate. For instance, it may be useful in a project to allow/disallow nils, or to maybe have the constructor only take Money objects rather than calling to_money on another object. Once you start customising it like that, you're effectively back to composed_of anyway.\nHow were you planning on testing this? Would it involve making ActiveRecord a development dependency to check integration?\nI would be tempted to suggest that this form part of a money-rails gem to avoid too many dependencies in this one.\n. I'm going to assume that you use some kind of mass assignment in your controller. When you call @dress.update_attributes(params[:dress]) or similar, if :price_currency is set first then when :price is set it will overwrite the price_currency you've set.\nThere are two ways I can think to fix this:\n1) Make price_cents attr_accessible and set it in the form:\n```\nform\n<%= f.select(:price_currency, all_currencies(Money::Currency.table)) %>\n<%= f.text_field :price_cents %>\n```\n2) Make neither price_cents or price_currency attr_accessible, and instead set it in the controller:\n@dress.attributes = params[:dress]\n@dress.price = Money.parse(params[:dress][:price_cents], params[:dress][:price_currency])\nThis second version will parse the value with the currency that you've specified, and most importantly will do it consistently.\n. In the first example, you'll have to define @dress = Dress.new\nFor the second one, is it a warning or an error? You could try:\ndef create\n    price_cents = params[:dress].delete([:price_cents])\n    price_currency = params[:dress].delete([:price_currency])\n    @dress = current_user.shop.dresses.build(params[:dress])\n    @dress.price = Money.parse(price_cents, price_currency)\nOr have a look at https://gist.github.com/1975644 for how to only allow the correct mass assignments to occur.\n. In the case where you want to see greater or less than zero, there's m.positive? and m.negative?. There's also m.zero? and m.nonzero?.\n. Hi @semmons99 and @viettienn - I came up with a slightly different approach (#306) that removed the duplication, but maybe in a way that expresses the intention a bit more clearly. What do you guys think?\n. @semmons99 yup, your way is much better - avoiding the extra conditionals altogether! Probably best to close this PR - none of it's going to be kept.\n@viettienn: do you want to knock up a new PR with those changes or do you want me to?\n. I think for this to work you have to have a decimal column instead of an integer column in your database, so $10.23456 would be stored in the decimal column as 1023.456. Your precision would then be based on what you chose in the db - not quite infinite, but probably close enough!\n. I handle this by defining my own default bank: \n```\nclass NullBank < Money::Bank::Base\n  class ExchangeException < Exception; end\ndef exchange_with(from, to_currency, &block)\n    raise ExchangeException\n  end\nend\n```\nMake this your default bank and you should be good to go.\n. Fixed by #323 \n. Really sorry, I've been away and I missed the notifications on this one. Two observations: \n1) this doesn't allow for nested blocks (the following example fails):\n```\nit \"allows nested blocks\" do\n  Money.rounding_mode(BigDecimal::ROUND_UP) do\n    Money.rounding_mode(BigDecimal::ROUND_DOWN) do\n      Money.new(1.9).fractional\n    end.should == 1\nMoney.new(1.1).fractional\n\nend.should == 2\nend\n```\nThis is caused by https://github.com/RubyMoney/money/commit/32929d80e361c648a8b85567f429de1f2ca00214#diff-a6d34f32282d8d431a585cdaf0aaf730R174 - we may have to make it an array and push and pop rounding modes.\n2) I've been thinking about this, and I can't really see the use-case for doing this on a global level. Would it be safer to allow the rounding mode to be overridden on each method that uses it? It adds a certain amount of complexity and finding bugs due to changing the rounding may be a bit annoying (action at a distance). Do you have any example code of how you intend to use this? \n. BTW, happy to look into the nested blocks issue if others think it's worth closing off.\n. This isn't a multi-threading problem - modifiying a collection under iteration is dangerous even with a single thread: http://jdfrens.blogspot.co.uk/2013/04/cant-add-new-key-into-hash-during.html. There is no \"fix\" for this, because it's a dangerous use by a client.\nA slight adaptation to an example above, if you want to modify the currencies (and I'm still not clear on when that would be necessary, as pointed out they are static data), you could do:\nMoney::Currency.table.each { |code, currency| [code, currency.merge!({:subunit_to_unit => 10000})] }\n. Thanks, done!\n. I would be opposed, but not militantly so. It seems like a lot of work for little value: it's not hard to use the snippet in the wiki to create your own abstraction. The wiki provides a handy default, but I don't necessarily think it's the use-case that's always appropriate. For instance, it may be useful in a project to allow/disallow nils, or to maybe have the constructor only take Money objects rather than calling to_money on another object. Once you start customising it like that, you're effectively back to composed_of anyway.\nHow were you planning on testing this? Would it involve making ActiveRecord a development dependency to check integration?\nI would be tempted to suggest that this form part of a money-rails gem to avoid too many dependencies in this one.\n. I'm going to assume that you use some kind of mass assignment in your controller. When you call @dress.update_attributes(params[:dress]) or similar, if :price_currency is set first then when :price is set it will overwrite the price_currency you've set.\nThere are two ways I can think to fix this:\n1) Make price_cents attr_accessible and set it in the form:\n```\nform\n<%= f.select(:price_currency, all_currencies(Money::Currency.table)) %>\n<%= f.text_field :price_cents %>\n```\n2) Make neither price_cents or price_currency attr_accessible, and instead set it in the controller:\n@dress.attributes = params[:dress]\n@dress.price = Money.parse(params[:dress][:price_cents], params[:dress][:price_currency])\nThis second version will parse the value with the currency that you've specified, and most importantly will do it consistently.\n. In the first example, you'll have to define @dress = Dress.new\nFor the second one, is it a warning or an error? You could try:\ndef create\n    price_cents = params[:dress].delete([:price_cents])\n    price_currency = params[:dress].delete([:price_currency])\n    @dress = current_user.shop.dresses.build(params[:dress])\n    @dress.price = Money.parse(price_cents, price_currency)\nOr have a look at https://gist.github.com/1975644 for how to only allow the correct mass assignments to occur.\n. In the case where you want to see greater or less than zero, there's m.positive? and m.negative?. There's also m.zero? and m.nonzero?.\n. Hi @semmons99 and @viettienn - I came up with a slightly different approach (#306) that removed the duplication, but maybe in a way that expresses the intention a bit more clearly. What do you guys think?\n. @semmons99 yup, your way is much better - avoiding the extra conditionals altogether! Probably best to close this PR - none of it's going to be kept.\n@viettienn: do you want to knock up a new PR with those changes or do you want me to?\n. I think for this to work you have to have a decimal column instead of an integer column in your database, so $10.23456 would be stored in the decimal column as 1023.456. Your precision would then be based on what you chose in the db - not quite infinite, but probably close enough!\n. I handle this by defining my own default bank: \n```\nclass NullBank < Money::Bank::Base\n  class ExchangeException < Exception; end\ndef exchange_with(from, to_currency, &block)\n    raise ExchangeException\n  end\nend\n```\nMake this your default bank and you should be good to go.\n. Fixed by #323 \n. Really sorry, I've been away and I missed the notifications on this one. Two observations: \n1) this doesn't allow for nested blocks (the following example fails):\n```\nit \"allows nested blocks\" do\n  Money.rounding_mode(BigDecimal::ROUND_UP) do\n    Money.rounding_mode(BigDecimal::ROUND_DOWN) do\n      Money.new(1.9).fractional\n    end.should == 1\nMoney.new(1.1).fractional\n\nend.should == 2\nend\n```\nThis is caused by https://github.com/RubyMoney/money/commit/32929d80e361c648a8b85567f429de1f2ca00214#diff-a6d34f32282d8d431a585cdaf0aaf730R174 - we may have to make it an array and push and pop rounding modes.\n2) I've been thinking about this, and I can't really see the use-case for doing this on a global level. Would it be safer to allow the rounding mode to be overridden on each method that uses it? It adds a certain amount of complexity and finding bugs due to changing the rounding may be a bit annoying (action at a distance). Do you have any example code of how you intend to use this? \n. BTW, happy to look into the nested blocks issue if others think it's worth closing off.\n. This isn't a multi-threading problem - modifiying a collection under iteration is dangerous even with a single thread: http://jdfrens.blogspot.co.uk/2013/04/cant-add-new-key-into-hash-during.html. There is no \"fix\" for this, because it's a dangerous use by a client.\nA slight adaptation to an example above, if you want to modify the currencies (and I'm still not clear on when that would be necessary, as pointed out they are static data), you could do:\nMoney::Currency.table.each { |code, currency| [code, currency.merge!({:subunit_to_unit => 10000})] }\n. ",
    "thbar": "I don't understand your second question (yet!).\nMy need is: inherited and overridable amounts.\nI need a nil amount to state that this entry doesn't override the default value provided by a parent Schedule record (I deal with recurring amounts).\nWhen the amount is nil, the app will retrieve the default amount via the parent record instead.\nIs the code I provided good enough to achieve that or are there any know caveats?\n. That's the kind of thing I was wondering about, thanks!\nI think I will keep a boolean flag amount_provided on the Entry to indicate whether the amount must be ignored or not, and will revert to a default \"0\" value with composed_of etc.\nJust wondering: is that something we should add maybe on the readme?\n. Thanks for your support.\n. So by 3 you mean it's possible to store and retrieve a nil money attribute in the database?\nDoes that mean we should have three columns maybe:\n- one with the cents, defaulting to 0 and never null\n- one with the currency\n- and one with something like money_provided (true/false)\nwhich we would compose together to build nil/not nil money instance?\nMaybe there is just some misunderstanding here and we can find some clean way to allow the user to not specify a given money field (which makes sense as a functionality).\nLet me know what you both think!\n. Thanks for the example - this makes me wonder: how is it different from what I submitted initially?\n``` ruby\nclass Entry < ActiveRecord::Base\n  def amount\n    cents ? Money.new(cents) : nil\n  end\ndef amount=(value)\n    self.cents = value ? value.to_money.cents : nil\n  end\nend\n```\nHonest question really - I'm trying to ensure I don't mess up with what I'm storing.\nWas that wrong because of the name amount?\n. No worries really - I just wanted to make sure I didn't miss anything\nnon obvious!\nThanks for taking the time to clarify this,  much appreciated.\nWould you welcome a readme patch about this case if I write something?\nLe 1 mai 2012 \u00e0 13:58, Simone Carletti\nreply@reply.github.com\na \u00e9crit :\n\nSorry @thbar, when I replied your post I probably didn't notice you were referencing an ActiveRecord object. For some reason, I thought you were re-opening the Money class. I probably read the implementation without paying attention to the class definition. My fault.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/161#issuecomment-5437363\n. I wasn't aware of that gem. After a careful look it looks complicated yet not flexible enough to allow nil for instance, so I won't depend on that :)\n\nI was referring to this section of the money gem readme, which suggest to either use money-rails, or follow the instructions below.\nI propose to append more information to the latter - but then I don't want to push if you are opposed to that; I can as well write a blog post :)\nLet me know what you prefer, I'm ok both ways, just trying to help people in similar situations (like @larrysalibra).\n. Ok, will do! Thanks.\n. I don't understand your second question (yet!).\nMy need is: inherited and overridable amounts.\nI need a nil amount to state that this entry doesn't override the default value provided by a parent Schedule record (I deal with recurring amounts).\nWhen the amount is nil, the app will retrieve the default amount via the parent record instead.\nIs the code I provided good enough to achieve that or are there any know caveats?\n. That's the kind of thing I was wondering about, thanks!\nI think I will keep a boolean flag amount_provided on the Entry to indicate whether the amount must be ignored or not, and will revert to a default \"0\" value with composed_of etc.\nJust wondering: is that something we should add maybe on the readme?\n. Thanks for your support.\n. So by 3 you mean it's possible to store and retrieve a nil money attribute in the database?\nDoes that mean we should have three columns maybe:\n- one with the cents, defaulting to 0 and never null\n- one with the currency\n- and one with something like money_provided (true/false)\nwhich we would compose together to build nil/not nil money instance?\nMaybe there is just some misunderstanding here and we can find some clean way to allow the user to not specify a given money field (which makes sense as a functionality).\nLet me know what you both think!\n. Thanks for the example - this makes me wonder: how is it different from what I submitted initially?\n``` ruby\nclass Entry < ActiveRecord::Base\n  def amount\n    cents ? Money.new(cents) : nil\n  end\ndef amount=(value)\n    self.cents = value ? value.to_money.cents : nil\n  end\nend\n```\nHonest question really - I'm trying to ensure I don't mess up with what I'm storing.\nWas that wrong because of the name amount?\n. No worries really - I just wanted to make sure I didn't miss anything\nnon obvious!\nThanks for taking the time to clarify this,  much appreciated.\nWould you welcome a readme patch about this case if I write something?\nLe 1 mai 2012 \u00e0 13:58, Simone Carletti\nreply@reply.github.com\na \u00e9crit :\n\nSorry @thbar, when I replied your post I probably didn't notice you were referencing an ActiveRecord object. For some reason, I thought you were re-opening the Money class. I probably read the implementation without paying attention to the class definition. My fault.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/161#issuecomment-5437363\n. I wasn't aware of that gem. After a careful look it looks complicated yet not flexible enough to allow nil for instance, so I won't depend on that :)\n\nI was referring to this section of the money gem readme, which suggest to either use money-rails, or follow the instructions below.\nI propose to append more information to the latter - but then I don't want to push if you are opposed to that; I can as well write a blog post :)\nLet me know what you prefer, I'm ok both ways, just trying to help people in similar situations (like @larrysalibra).\n. Ok, will do! Thanks.\n. ",
    "larrysalibra": "I'm having the same problem...no support for nil Money values.  When you present a form to enter values that include new Money objects, it is often (one could argue typical) to want the user to enter a value and not provide them with a 0.00 default value.  This is how every other ActiveRecord type behaves.\nCurrent behavior deviates from conventional ActiveRecord behavior and makes it impossible to validate whether or not a user has provided a Money value.  A NULL in the database should result in a nil value for the Money object and not a value of 0.00. nil != 0.00\n. I'm having the same problem...no support for nil Money values.  When you present a form to enter values that include new Money objects, it is often (one could argue typical) to want the user to enter a value and not provide them with a 0.00 default value.  This is how every other ActiveRecord type behaves.\nCurrent behavior deviates from conventional ActiveRecord behavior and makes it impossible to validate whether or not a user has provided a Money value.  A NULL in the database should result in a nil value for the Money object and not a value of 0.00. nil != 0.00\n. ",
    "MatmaRex": "Fine, although I have no idea why would that be needed. (Or why should I do it in particular.)\nAlso, I don't need the commit access, thank you. (And I don't see why would you give it out to everyone.)\n. Fine, although I have no idea why would that be needed. (Or why should I do it in particular.)\nAlso, I don't need the commit access, thank you. (And I don't see why would you give it out to everyone.)\n. ",
    "Goles": "Maybe I can fix it if you guys tell me where to look at ? \nIt's the first time that I use this gem so I don't really know the codebase very well... anyway let me know.\n. I'm a bit out of time now, but I'll try to look at it after work. \n. Maybe I can fix it if you guys tell me where to look at ? \nIt's the first time that I use this gem so I don't really know the codebase very well... anyway let me know.\n. I'm a bit out of time now, but I'll try to look at it after work. \n. ",
    "exviva": "Thanks, how generous of you :).\n. Thanks, how generous of you :).\n. ",
    "kirillian": "I thought that at first. Then I ran through some tests of my formatting method and ran across a couple issues. Let me show by example what I'm trying to explain.\nSay I have $ 12.1234 USD...I can only store $ 12.12 of this in a Money object, meaning the $.0034 is not even stored. And I certainly can't display it if it isn't stored.\nHopefully that made some sense. I tried changing the initialization method because I needed to make sure the code was backwards compatible and I realized that hooking into the subunit_to_unit ratio on a new currency definition would allow me to do what I needed without messing around with innards (cheap way to make it backwards compatible and avoid the \"scary\" internal structural change.\nI would be more than happy to help do some refactoring if yall have some more ideas\n. Hmm...I actually probably could do so for my particular case...along with using the precision option when formatting...\nI sense that the initialization changes seem to be a bit disconcerting...is it something that I could address potentially in order to make things a bit cleaner, etc? The only concern I've actually had with the Money gem has been the lack of support for partial cents...what kind of guidelines would you suggest for offering such? If I could provide a patch that offered support in a cleaner way (or perhaps abstracted some of the code into another method), would that be something to consider? I had done some thinking before and couldn't think of a way at the time to create the support without changing some method signatures until I thought of this particular solution...this provides the benefit of adding in the features without requiring changes to code that is already written.\nI could create those new money objects for my own needs without a problem, but it seems to me a little unintuitive for others' use...\n. How were you thinking of handling an infinite precision on an object? The concept of storing values as integers gets in the way there...\n. I think that my pull request really encompasses two features that could perhaps be discussed separately, a precision option for formatting and internal precision.\nSo I guess my questions would be the following:\n- Are these features desirable?\n- Do my code changes address either of these features in an agreeable manner?\n- Should I split off the formatting changes perhaps and deal with internal precision separately?\n. I can certainly take a look at it. I'll respond a little later with something one way or another.\n. I've done a little thinking and brainstorming concerning the internal storage/handling of precision. I just wanted to lay out some thoughts/concerns I had about the various alternatives.\nUsing BigDecimal to store cents. This may end up being the easiest, cleanest, and best long-term solution, but it causes backwards compatibility issues. It would likely require some database migration generators (since each column changed in the database will require different parameters...) or something similar to handle the compatibility changes.\nLeaving cents as an integer and defining precision on the money object. This has the benefit of being slightly more backwards compatible as it is basically just a higher abstraction of the solution I originally submitted. However, it ties the money object to a defined precision rather than infinite precision, and it means that the units that are passed in as parameters on creation of the money object might not represent cents any longer (they could be partial cents or multiple cents), meaning semantic value is lost there or at least obfuscated.\nI guess I actually am liking the BigDecimal representation a bit more with the realization that this might be a rather rough change.\n. That is probably for the best, #cents= could prolly be modified to check for integers, BigDecimal, float, and other types and handle appropriately...I will have something I think sometime tommorrow, even if it is not completed. I will make a separate branch and a separate pull request I think. I will close this one.\n. I've done a bit of work on this today. Did not have the time that I expected, but eh, it happens. I believe that I have a rough draft of a solution that will provide the internal support we need. It just so happens that formatting grows naturally out of this extension. However, A few of the tests are failing currently and I have to do some more looking into that. I have to put this aside for the day, so I wanted to make sure that what I've worked on so far is available for anyone interested. You are more than welcome to download the branch that I'm working on and make suggestions or comments. I don't want to open a pull request just yet because, well...it's not ready, but if that's more appropriate, I can do that instead.\nIn the meantime, the branch that I am working on is here:\nhttps://github.com/kirillian/money-1/tree/internal_precision_support\n. Done\n. After a bit of work and rework (BigDecimals are kindof a pain to work with it seems, at least insofar as extracting the value as a string is concerned), I think I have something closer to the goal. I think my next couple of steps include options for rounding type and adding more tests. However, what we should have here is a working implementation. Woot!\n- Didn't submit comment yesterday. Submitting now.\n. Nice call. That's a leftover from my testing that I didn't remove immediately because I don't think we can expect #split and #allocate to properly work when we are tracking partial cents as both methods assume whole cents need to be preserved. They may also need a rework to deal with such. I'm currently fixing up a few more tests and finishing the rounding options. \nI also discovered that Rational => BigDecimal seems to not be working properly in 1.9.2 (I believe that it won't work pre1.9.3) because there is no Rational#to_d method available, so e.g. Rational(2/3).to_s => \"2/3\" and BigDecimal(\"2/3\") => 0.2E1 as BigDecimal stops parsing on the first invalid character.\nSo that might require special consideration too.\n. I have added rounding options and done a bunch of cleanup with methods that had extraneous #to_i's and fixed tests as well as adding new appropriate tests. I was mistaken about the Rational => BigDecimal conversion. After some more looking, I just realized that I didn't have the needed library included (derp), so I added that.\nI think the only thing I have left currently is to make sure that #split and #allocate are refactored for partial cents considerations if need be.\n. No problem. I think I got this, I just had to do a couple other things for a couple days in there.\n. Geez...you're going to town this morning. I just started pulling your commits down and you're already taking off on the #allocate and #split. I'm doing some triage. I didn't like having so many components to the number in the #to_s method at first, but I like what you did with it. It's much cleaner. Maybe the rounding mode can be added to your pull as well...I'll be taking a look here shortly\n. Closing this pull request since a more complete one is already ready to be merged:\nhttps://github.com/RubyMoney/money/pull/174\n. So, one thing that I ran across while working on my alternate pull request. Converting a number type to BigDecimal has some problems with a couple types...Rational has this problem, and Float theoretically could it seems. I had solved this problem by adding:\nrequire 'bigdecimal/util'\nto the lib/money.rb file so that we could do Rational#to_d and Float#to_d\nI did something like:\ndef initialize(cents, currency = Money.default_currency, bank = Money.default_bank)\n    @currency = Currency.wrap(currency)\n    @bank = bank\n    if cents.respond_to?(:to_d)\n      @cents = cents.to_d\n    else\n      @cents = BigDecimal(cents.to_s)\n    end\n  end\nto handle the conversion. Then you should have native BigDecimal support for everything.\n. I saw that...I'll do one more check, but it seems that everything that I have done so far is already included in your pull except for changes to Money#format, but that can be separated out as well...\nI do have a concern though in the #to_s method:\nfractional = fractional.to_s(\"F\")[2..-1]\nI shied away from this in my code because I ran across something that suggested to me that the BigDecimal might be converted to floating point in the #sprintf method that this eventually calls. However, looking at this again and trying to find confirmation one way or another is not working out so well. I can't even really find where I found something, but it was a concern that I just wanted to make sure you had thought about at least or knew one way or another.\n. I'm working on something to not use #sprintf...think I have something that will work. I didn't realize that I had used it in my own pull...wow its so hard to avoid that crap.\n. Ok...after finding a bit of a mess involved, I kept looking for some confirmation one way or another. I think I found something that appears to be consistent with what I've seen before.\nhttp://stackoverflow.com/questions/1950541/consistent-rounding-of-floating-points-in-ruby\nThis person seems to suggest that performing rounding before passing to sprintf should take care of the issues. This actually seems to fit with my own testing as I took a few well known floating point error examples and used BigDecimals to do all the math involved and printed with the BigDecimal#to_s method successfully. So, my concern may really have already been addressed in the end. At least I have confidence in it at this point.\n. I added a fix for a very specific case that I noticed while dealing with adding a :precision option to formatting. The tests don't cover this case currently. I will create a pull request for the :precision option once this branch has actually been accepted.\n. Sorry about taking so long on this. I kinda moved on to a different project at work and took me a while to get back to this there and I didn't work on it much at home for a while. This should give the ability to format a money object with a precision parameter (think I store a value of $1.23456 but I want to only display it as $1.23 - an accounting thing when dealing with really small amounts of money).\nI am actually finally getting back to working on moving our main project from an old money gem to this one. It will take some time, but if I run into something else, I'll make a pull request for it also.\n. I left on vacation right after committing this and put off answering the email when I got back into chaos. I'll work on that this evening.\n. I thought that at first. Then I ran through some tests of my formatting method and ran across a couple issues. Let me show by example what I'm trying to explain.\nSay I have $ 12.1234 USD...I can only store $ 12.12 of this in a Money object, meaning the $.0034 is not even stored. And I certainly can't display it if it isn't stored.\nHopefully that made some sense. I tried changing the initialization method because I needed to make sure the code was backwards compatible and I realized that hooking into the subunit_to_unit ratio on a new currency definition would allow me to do what I needed without messing around with innards (cheap way to make it backwards compatible and avoid the \"scary\" internal structural change.\nI would be more than happy to help do some refactoring if yall have some more ideas\n. Hmm...I actually probably could do so for my particular case...along with using the precision option when formatting...\nI sense that the initialization changes seem to be a bit disconcerting...is it something that I could address potentially in order to make things a bit cleaner, etc? The only concern I've actually had with the Money gem has been the lack of support for partial cents...what kind of guidelines would you suggest for offering such? If I could provide a patch that offered support in a cleaner way (or perhaps abstracted some of the code into another method), would that be something to consider? I had done some thinking before and couldn't think of a way at the time to create the support without changing some method signatures until I thought of this particular solution...this provides the benefit of adding in the features without requiring changes to code that is already written.\nI could create those new money objects for my own needs without a problem, but it seems to me a little unintuitive for others' use...\n. How were you thinking of handling an infinite precision on an object? The concept of storing values as integers gets in the way there...\n. I think that my pull request really encompasses two features that could perhaps be discussed separately, a precision option for formatting and internal precision.\nSo I guess my questions would be the following:\n- Are these features desirable?\n- Do my code changes address either of these features in an agreeable manner?\n- Should I split off the formatting changes perhaps and deal with internal precision separately?\n. I can certainly take a look at it. I'll respond a little later with something one way or another.\n. I've done a little thinking and brainstorming concerning the internal storage/handling of precision. I just wanted to lay out some thoughts/concerns I had about the various alternatives.\nUsing BigDecimal to store cents. This may end up being the easiest, cleanest, and best long-term solution, but it causes backwards compatibility issues. It would likely require some database migration generators (since each column changed in the database will require different parameters...) or something similar to handle the compatibility changes.\nLeaving cents as an integer and defining precision on the money object. This has the benefit of being slightly more backwards compatible as it is basically just a higher abstraction of the solution I originally submitted. However, it ties the money object to a defined precision rather than infinite precision, and it means that the units that are passed in as parameters on creation of the money object might not represent cents any longer (they could be partial cents or multiple cents), meaning semantic value is lost there or at least obfuscated.\nI guess I actually am liking the BigDecimal representation a bit more with the realization that this might be a rather rough change.\n. That is probably for the best, #cents= could prolly be modified to check for integers, BigDecimal, float, and other types and handle appropriately...I will have something I think sometime tommorrow, even if it is not completed. I will make a separate branch and a separate pull request I think. I will close this one.\n. I've done a bit of work on this today. Did not have the time that I expected, but eh, it happens. I believe that I have a rough draft of a solution that will provide the internal support we need. It just so happens that formatting grows naturally out of this extension. However, A few of the tests are failing currently and I have to do some more looking into that. I have to put this aside for the day, so I wanted to make sure that what I've worked on so far is available for anyone interested. You are more than welcome to download the branch that I'm working on and make suggestions or comments. I don't want to open a pull request just yet because, well...it's not ready, but if that's more appropriate, I can do that instead.\nIn the meantime, the branch that I am working on is here:\nhttps://github.com/kirillian/money-1/tree/internal_precision_support\n. Done\n. After a bit of work and rework (BigDecimals are kindof a pain to work with it seems, at least insofar as extracting the value as a string is concerned), I think I have something closer to the goal. I think my next couple of steps include options for rounding type and adding more tests. However, what we should have here is a working implementation. Woot!\n- Didn't submit comment yesterday. Submitting now.\n. Nice call. That's a leftover from my testing that I didn't remove immediately because I don't think we can expect #split and #allocate to properly work when we are tracking partial cents as both methods assume whole cents need to be preserved. They may also need a rework to deal with such. I'm currently fixing up a few more tests and finishing the rounding options. \nI also discovered that Rational => BigDecimal seems to not be working properly in 1.9.2 (I believe that it won't work pre1.9.3) because there is no Rational#to_d method available, so e.g. Rational(2/3).to_s => \"2/3\" and BigDecimal(\"2/3\") => 0.2E1 as BigDecimal stops parsing on the first invalid character.\nSo that might require special consideration too.\n. I have added rounding options and done a bunch of cleanup with methods that had extraneous #to_i's and fixed tests as well as adding new appropriate tests. I was mistaken about the Rational => BigDecimal conversion. After some more looking, I just realized that I didn't have the needed library included (derp), so I added that.\nI think the only thing I have left currently is to make sure that #split and #allocate are refactored for partial cents considerations if need be.\n. No problem. I think I got this, I just had to do a couple other things for a couple days in there.\n. Geez...you're going to town this morning. I just started pulling your commits down and you're already taking off on the #allocate and #split. I'm doing some triage. I didn't like having so many components to the number in the #to_s method at first, but I like what you did with it. It's much cleaner. Maybe the rounding mode can be added to your pull as well...I'll be taking a look here shortly\n. Closing this pull request since a more complete one is already ready to be merged:\nhttps://github.com/RubyMoney/money/pull/174\n. So, one thing that I ran across while working on my alternate pull request. Converting a number type to BigDecimal has some problems with a couple types...Rational has this problem, and Float theoretically could it seems. I had solved this problem by adding:\nrequire 'bigdecimal/util'\nto the lib/money.rb file so that we could do Rational#to_d and Float#to_d\nI did something like:\ndef initialize(cents, currency = Money.default_currency, bank = Money.default_bank)\n    @currency = Currency.wrap(currency)\n    @bank = bank\n    if cents.respond_to?(:to_d)\n      @cents = cents.to_d\n    else\n      @cents = BigDecimal(cents.to_s)\n    end\n  end\nto handle the conversion. Then you should have native BigDecimal support for everything.\n. I saw that...I'll do one more check, but it seems that everything that I have done so far is already included in your pull except for changes to Money#format, but that can be separated out as well...\nI do have a concern though in the #to_s method:\nfractional = fractional.to_s(\"F\")[2..-1]\nI shied away from this in my code because I ran across something that suggested to me that the BigDecimal might be converted to floating point in the #sprintf method that this eventually calls. However, looking at this again and trying to find confirmation one way or another is not working out so well. I can't even really find where I found something, but it was a concern that I just wanted to make sure you had thought about at least or knew one way or another.\n. I'm working on something to not use #sprintf...think I have something that will work. I didn't realize that I had used it in my own pull...wow its so hard to avoid that crap.\n. Ok...after finding a bit of a mess involved, I kept looking for some confirmation one way or another. I think I found something that appears to be consistent with what I've seen before.\nhttp://stackoverflow.com/questions/1950541/consistent-rounding-of-floating-points-in-ruby\nThis person seems to suggest that performing rounding before passing to sprintf should take care of the issues. This actually seems to fit with my own testing as I took a few well known floating point error examples and used BigDecimals to do all the math involved and printed with the BigDecimal#to_s method successfully. So, my concern may really have already been addressed in the end. At least I have confidence in it at this point.\n. I added a fix for a very specific case that I noticed while dealing with adding a :precision option to formatting. The tests don't cover this case currently. I will create a pull request for the :precision option once this branch has actually been accepted.\n. Sorry about taking so long on this. I kinda moved on to a different project at work and took me a while to get back to this there and I didn't work on it much at home for a while. This should give the ability to format a money object with a precision parameter (think I store a value of $1.23456 but I want to only display it as $1.23 - an accounting thing when dealing with really small amounts of money).\nI am actually finally getting back to working on moving our main project from an old money gem to this one. It will take some time, but if I run into something else, I'll make a pull request for it also.\n. I left on vacation right after committing this and put off answering the email when I got back into chaos. I'll work on that this evening.\n. ",
    "davekaro": "Ok, I started writing tests and realized that using multi_json is probably better anyways. Thoughts?\n. It's part of this pull request already. The second commit. Is there something different I should do?\n. All set. I also added a specific version for multi_json since it did change some stuff in 1.3.\n. The problem with this was when a project loads the yajl-ruby gem. See https://github.com/RubyMoney/money/pull/170 for details.\n. Ok, I started writing tests and realized that using multi_json is probably better anyways. Thoughts?\n. It's part of this pull request already. The second commit. Is there something different I should do?\n. All set. I also added a specific version for multi_json since it did change some stuff in 1.3.\n. The problem with this was when a project loads the yajl-ruby gem. See https://github.com/RubyMoney/money/pull/170 for details.\n. ",
    "travisbot": "This pull request passes (merged d49053c2 into ff573e63).\n. This pull request passes (merged f69b857d into 7349b8c7).\n. This pull request passes (merged 6cd78695 into 356cce72).\n. This pull request fails (merged 41e29bee into 356cce72).\n. This pull request fails (merged 9949ee60 into 356cce72).\n. This pull request passes (merged f4c150d8 into 356cce72).\n. This pull request passes (merged 89638c32 into 356cce72).\n. This pull request passes (merged d98727e7 into 577020a7).\n. This pull request passes (merged cdf21326 into 577020a7).\n. This pull request fails (merged 5c680c53 into 577020a7).\n. This pull request passes (merged 21dbf202 into 577020a7).\n. This pull request passes (merged 94e3b7c4 into ccf4ebc6).\n. This pull request passes (merged fd153501 into ccf4ebc6).\n. This pull request passes (merged 09e768ce into 4facf60c).\n. This pull request passes (merged 01d48c8d into 4facf60c).\n. This pull request passes (merged a66ddfac into 4facf60c).\n. This pull request fails (merged 315a86a2 into 0113e212).\n. This pull request passes (merged bedac7ab into 0113e212).\n. This pull request passes (merged 5d874d27 into 7f9acdad).\n. This pull request passes (merged 14888879 into 7f9acdad).\n. This pull request passes (merged 586cc504 into 7f9acdad).\n. This pull request passes (merged 23fd586e into f17aac9d).\n. This pull request passes (merged 67061849 into f17aac9d).\n. This pull request fails (merged 583cb55f into f17aac9d).\n. This pull request passes (merged cf1903f2 into f17aac9d).\n. This pull request fails (merged 758cf89a into f17aac9d).\n. This pull request fails (merged 4a5b0002 into f17aac9d).\n. This pull request passes (merged 52b29f37 into f17aac9d).\n. This pull request fails (merged 479119e2 into 001f6902).\n. This pull request fails (merged 51d67441 into 001f6902).\n. This pull request fails (merged 346d49ec into 001f6902).\n. This pull request fails (merged 4eb11165 into 001f6902).\n. This pull request fails (merged 1528218a into 001f6902).\n. This pull request fails (merged c0213bdd into 001f6902).\n. This pull request passes (merged dc2f89fd into 001f6902).\n. This pull request passes (merged f58155bc into 001f6902).\n. This pull request passes (merged 67b7f38d into 8cdec127).\n. This pull request passes (merged d49053c2 into ff573e63).\n. This pull request passes (merged f69b857d into 7349b8c7).\n. This pull request passes (merged 6cd78695 into 356cce72).\n. This pull request fails (merged 41e29bee into 356cce72).\n. This pull request fails (merged 9949ee60 into 356cce72).\n. This pull request passes (merged f4c150d8 into 356cce72).\n. This pull request passes (merged 89638c32 into 356cce72).\n. This pull request passes (merged d98727e7 into 577020a7).\n. This pull request passes (merged cdf21326 into 577020a7).\n. This pull request fails (merged 5c680c53 into 577020a7).\n. This pull request passes (merged 21dbf202 into 577020a7).\n. This pull request passes (merged 94e3b7c4 into ccf4ebc6).\n. This pull request passes (merged fd153501 into ccf4ebc6).\n. This pull request passes (merged 09e768ce into 4facf60c).\n. This pull request passes (merged 01d48c8d into 4facf60c).\n. This pull request passes (merged a66ddfac into 4facf60c).\n. This pull request fails (merged 315a86a2 into 0113e212).\n. This pull request passes (merged bedac7ab into 0113e212).\n. This pull request passes (merged 5d874d27 into 7f9acdad).\n. This pull request passes (merged 14888879 into 7f9acdad).\n. This pull request passes (merged 586cc504 into 7f9acdad).\n. This pull request passes (merged 23fd586e into f17aac9d).\n. This pull request passes (merged 67061849 into f17aac9d).\n. This pull request fails (merged 583cb55f into f17aac9d).\n. This pull request passes (merged cf1903f2 into f17aac9d).\n. This pull request fails (merged 758cf89a into f17aac9d).\n. This pull request fails (merged 4a5b0002 into f17aac9d).\n. This pull request passes (merged 52b29f37 into f17aac9d).\n. This pull request fails (merged 479119e2 into 001f6902).\n. This pull request fails (merged 51d67441 into 001f6902).\n. This pull request fails (merged 346d49ec into 001f6902).\n. This pull request fails (merged 4eb11165 into 001f6902).\n. This pull request fails (merged 1528218a into 001f6902).\n. This pull request fails (merged c0213bdd into 001f6902).\n. This pull request passes (merged dc2f89fd into 001f6902).\n. This pull request passes (merged f58155bc into 001f6902).\n. This pull request passes (merged 67b7f38d into 8cdec127).\n. ",
    "brutuscat": "@semmons99 thanks I will keep an eye on it.\nWhat would be your advice if you had to migrate an app that is currently using \"decimal\" data structure to store money values in the simpler way (eg. not using cents as unit)?\nThere is any way can indicate what \"unit\" to use?\nI'm sorry but I don't understand why you use cents as units... What am I missing here?\n. So in Rails,  using composed_of and its :converter I would be able to have a Money object \"transparently\" just calling the #to_money method?\n. Reply to myself, it looks that it's true. http://rubydoc.info/gems/money/Numeric#to_money-instance_method\n@semmons99  That's great! Thanks!\nAnything else I should be aware of?\n. @semmons99 thanks I will keep an eye on it.\nWhat would be your advice if you had to migrate an app that is currently using \"decimal\" data structure to store money values in the simpler way (eg. not using cents as unit)?\nThere is any way can indicate what \"unit\" to use?\nI'm sorry but I don't understand why you use cents as units... What am I missing here?\n. So in Rails,  using composed_of and its :converter I would be able to have a Money object \"transparently\" just calling the #to_money method?\n. Reply to myself, it looks that it's true. http://rubydoc.info/gems/money/Numeric#to_money-instance_method\n@semmons99  That's great! Thanks!\nAnything else I should be aware of?\n. ",
    "Exoth": "Thanks\n. The last official Zimbabwe currency is ZWL, but it's not used anymore. That's what Wikipedia says:\n\"Despite attempts to control inflation by legislation, and three redenominations (in 2006, 2008 and 2009), use of the Zimbabwean dollar as an official currency was effectively abandoned on 12 April 2009. This was a result of the Reserve Bank of Zimbabwe legalising use of foreign currencies for transactions in January 2009.\"\n. Thanks.\n. Actually EEK and ZWL currencies are already in currency_bc.json. So now these currencies are doubled. Also they are really not used anymore. It's quite strange, that OpenExchange has rates for them, so I would not rely on it as the source of currently used currencies. Anyway, even if to take these currencies as active, they at least have to be removed from currency_bc.json.\n. \"On 1 January 2011 the euro replaced the kroon as the official currency of Estonia. The kroon circulated alongside the euro until 15 January 2011 at which point it ceased to be legal tender. However, the Eesti Pank will indefinitely exchange kroon banknotes and coins in any amount into euro.\"\nWell, I don't know if this currency should be located in currency.json or currency_bc.json. What do you think?\n. \"On 12 April 2009, media outlets reported that economic planning minister Elton Mangoma had announced the suspension of the local currency \"for at least a year\", effectively terminating the fourth dollar.\nSince February 2009, following a period of hyperinflation and widespread rejection of the devalued currency, companies and individuals are permitted to transact domestic business in other currencies, such as the US$ or the South African rand. In consequence, the Zimbabwean economy has undergone dollarisation and the Zimbabwean dollar has fallen out of everyday use.\"\n. Also:\nBTC: ISO 4217 code  Not designated. Not recognized as a currency by SIX Interbank Clearing.\n. JEP is not ISO too. MTL was replaced by Euro.\n. So what rule should be used? \u0441urrency.json should contain only actively used at the moment ISO currencies and currency_bc.json should contain not actively used ISO currencies?\n. Thanks\n. The last official Zimbabwe currency is ZWL, but it's not used anymore. That's what Wikipedia says:\n\"Despite attempts to control inflation by legislation, and three redenominations (in 2006, 2008 and 2009), use of the Zimbabwean dollar as an official currency was effectively abandoned on 12 April 2009. This was a result of the Reserve Bank of Zimbabwe legalising use of foreign currencies for transactions in January 2009.\"\n. Thanks.\n. Actually EEK and ZWL currencies are already in currency_bc.json. So now these currencies are doubled. Also they are really not used anymore. It's quite strange, that OpenExchange has rates for them, so I would not rely on it as the source of currently used currencies. Anyway, even if to take these currencies as active, they at least have to be removed from currency_bc.json.\n. \"On 1 January 2011 the euro replaced the kroon as the official currency of Estonia. The kroon circulated alongside the euro until 15 January 2011 at which point it ceased to be legal tender. However, the Eesti Pank will indefinitely exchange kroon banknotes and coins in any amount into euro.\"\nWell, I don't know if this currency should be located in currency.json or currency_bc.json. What do you think?\n. \"On 12 April 2009, media outlets reported that economic planning minister Elton Mangoma had announced the suspension of the local currency \"for at least a year\", effectively terminating the fourth dollar.\nSince February 2009, following a period of hyperinflation and widespread rejection of the devalued currency, companies and individuals are permitted to transact domestic business in other currencies, such as the US$ or the South African rand. In consequence, the Zimbabwean economy has undergone dollarisation and the Zimbabwean dollar has fallen out of everyday use.\"\n. Also:\nBTC: ISO 4217 code  Not designated. Not recognized as a currency by SIX Interbank Clearing.\n. JEP is not ISO too. MTL was replaced by Euro.\n. So what rule should be used? \u0441urrency.json should contain only actively used at the moment ISO currencies and currency_bc.json should contain not actively used ISO currencies?\n. ",
    "ksol": "Thanks a lot. I went with \"#{c} #{c.symbol}\", it indeed is clear & simple enough :)\n. Thanks a lot. I went with \"#{c} #{c.symbol}\", it indeed is clear & simple enough :)\n. ",
    "ioquatix": "Hi Semmons, I thought we'd need to discuss it so I wanted to make a proposal without spending a lot of time on it (e.g. writing tests - in other news, all the existing tests passed so that is a good sign).\nGenerally, it makes sense in any numerical system to have additive and multiplicative identities. In this case, the additive identity is 0. 0 cents in any currency is 0. It doesn't matter what exchange rate you apply it to, it won't make any difference.\nIn this case, the typical use case would be something along the lines \namounts.inject(Money.zero) {|sum, amount| sum + amount}\nWithout having some additive identity (i.e. a zero figure that exists regardless of currency) we have to resort to hacks such as taking the first element of the array and using that as the identity:\nfirst = amounts.pop\namounts.inject(first) {|sum, amount| sum + amount}\nThis also assumes that we have an item in the array. To deal with this exception we'd need to write\nfirst = amounts.pop || Money.empty\nresult = amounts.inject(first) {|sum, amount| sum + amount}\nHowever, now we are imbuing the calculation with a default currency in the case that there were no amounts. This is a leaky abstraction.\nIn any type of mathematical system where addition and subtraction of amounts is an important process it would be good practice to include the additive identity whereby (a + i) = a and (a - i) = a. Without these the system is fundamentally limited.\n\u001bFinally, you might find that you get a slight performance improvement due to avoiding unnecessary object creation.\nThanks.\n. semmons: that is a good point. To resolve this and to improve the original patch you could have a theoretical \"nil\" currency where the only valid amount is zero. So, 0 USD + 1 EUR is invalid without some exchange rate, but 0 nil + 1 EUR = 1 EUR. You'd have to explicitly specify the additive identity Money.zero, it wouldn't form from adding two existing currencies together - but in the case where you compare 0 USD and 0 nil you'd get true, so you'd have to figure out the finer details of how that interaction takes place. But ultimately it would be a token value that represents no amount of money in no specific currency (e.g. an empty bag).\nTo provide finer control, you could allow the bank to do currency conversions for 0-dollar amounts as this will always be zero in all currencies.\nIn the above case specifically, what is also undefined is the final currency. By injecting a specific currency you control the outcome. The order of evaluation will change the resulting currency.\nAnyway, I still think having an additive identity would be useful in many cases. It might take some effort to flesh out the finer details, but it gives greater depth to the kinds of arithmetic operations possible.\n. What is also perhaps interesting is that summing up an arbitrary set of currencies should be done by grouping together currencies, summing those individual parts, and then having the option to either stop at that point or exchange currencies to a single common currency and then sum together those results. Simply summing up an array seems a bit unpredictable.\n. More food for thought: If we consider 0 USD, actually this is an absurd amount, one can't \"have\" 0 USD. A bank can exchange 0 USD for 0 EUR or 0 NZD. In fact, if you went into a real bank and asked them to exchange 0 USD with 0 NZD they'd probably call security.\nOne way to implement this then, is to simply allow the bank object to translate 0 amounts in any currency to any other currency. This seems pretty logical to me and should be easy to implement as a simple optional feature.\n. Hi,\nIn the end I decided to write something from scratch since I needed something urgently.\nhttps://github.com/ioquatix/latinum\nIt should support all of the use-cases mentioned so far. Perhaps some of the concepts in latinum can be adapted to the money gem.\n. @odigity Different boats for different folks, as some might say =) I hope that both gems can improve in the end, but this is my stick in the mud, so to speak.\n. llazzaro: good point =)\nStrangely enough Latinum implements some of those ideas too, including the idea of a \"Bag\" of different units (Latinum::Collection).\n. @llazzaro If you want something right now that works please check out my gem Latinum\n. After developing Latinum I decided that Money::Zero is fundamentally bad, actually, adding money together of different currencies is fundamentally bad idea. I'd actually recommend looking at how I implemented Latinum::Collection which allows you to avoid the issue entirely and control explicitly how you deal with adding together multiple currencies deterministically.\n. @semmons99 To follow up with this, I actually throw an error if you try to add Latinum::Resource with different face names. Latinum::Collection will aggregate Latinum::Resources based on face name (e.g. 'USD') and at the end if you want to reduce to a single currency you can use a Latinum::Bank which can exchange everything for a common currency (essentially Latinum::Collection is the same as @odigity's original suggestion for a compound money object that represents multiple resource types/currency names, etc). It works very very well and I used it in a web-based accounting system I made called Financier (https://github.com/ioquatix/financier).\n. I thought I'd suggest that not all currency is measured in cents. I would humbly suggest that 'cents' should be renamed 'amount', which would also make more sense in light of this bug report.\n. Okay, right, thanks =)\n. https://github.com/ioquatix/latinum supports arbitrary precision bitcoins, internally using Ruby's awesome BigDecimal. It should be serialised to the database as a string.\nThe specific metadata for the currency is here:\nhttps://github.com/ioquatix/latinum/blob/2ca2e9ead6651c9a66c92e7b8893d5cccd958d97/lib/latinum/currencies/global.rb#L79-L85. Hi Semmons, I thought we'd need to discuss it so I wanted to make a proposal without spending a lot of time on it (e.g. writing tests - in other news, all the existing tests passed so that is a good sign).\nGenerally, it makes sense in any numerical system to have additive and multiplicative identities. In this case, the additive identity is 0. 0 cents in any currency is 0. It doesn't matter what exchange rate you apply it to, it won't make any difference.\nIn this case, the typical use case would be something along the lines \namounts.inject(Money.zero) {|sum, amount| sum + amount}\nWithout having some additive identity (i.e. a zero figure that exists regardless of currency) we have to resort to hacks such as taking the first element of the array and using that as the identity:\nfirst = amounts.pop\namounts.inject(first) {|sum, amount| sum + amount}\nThis also assumes that we have an item in the array. To deal with this exception we'd need to write\nfirst = amounts.pop || Money.empty\nresult = amounts.inject(first) {|sum, amount| sum + amount}\nHowever, now we are imbuing the calculation with a default currency in the case that there were no amounts. This is a leaky abstraction.\nIn any type of mathematical system where addition and subtraction of amounts is an important process it would be good practice to include the additive identity whereby (a + i) = a and (a - i) = a. Without these the system is fundamentally limited.\n\u001bFinally, you might find that you get a slight performance improvement due to avoiding unnecessary object creation.\nThanks.\n. semmons: that is a good point. To resolve this and to improve the original patch you could have a theoretical \"nil\" currency where the only valid amount is zero. So, 0 USD + 1 EUR is invalid without some exchange rate, but 0 nil + 1 EUR = 1 EUR. You'd have to explicitly specify the additive identity Money.zero, it wouldn't form from adding two existing currencies together - but in the case where you compare 0 USD and 0 nil you'd get true, so you'd have to figure out the finer details of how that interaction takes place. But ultimately it would be a token value that represents no amount of money in no specific currency (e.g. an empty bag).\nTo provide finer control, you could allow the bank to do currency conversions for 0-dollar amounts as this will always be zero in all currencies.\nIn the above case specifically, what is also undefined is the final currency. By injecting a specific currency you control the outcome. The order of evaluation will change the resulting currency.\nAnyway, I still think having an additive identity would be useful in many cases. It might take some effort to flesh out the finer details, but it gives greater depth to the kinds of arithmetic operations possible.\n. What is also perhaps interesting is that summing up an arbitrary set of currencies should be done by grouping together currencies, summing those individual parts, and then having the option to either stop at that point or exchange currencies to a single common currency and then sum together those results. Simply summing up an array seems a bit unpredictable.\n. More food for thought: If we consider 0 USD, actually this is an absurd amount, one can't \"have\" 0 USD. A bank can exchange 0 USD for 0 EUR or 0 NZD. In fact, if you went into a real bank and asked them to exchange 0 USD with 0 NZD they'd probably call security.\nOne way to implement this then, is to simply allow the bank object to translate 0 amounts in any currency to any other currency. This seems pretty logical to me and should be easy to implement as a simple optional feature.\n. Hi,\nIn the end I decided to write something from scratch since I needed something urgently.\nhttps://github.com/ioquatix/latinum\nIt should support all of the use-cases mentioned so far. Perhaps some of the concepts in latinum can be adapted to the money gem.\n. @odigity Different boats for different folks, as some might say =) I hope that both gems can improve in the end, but this is my stick in the mud, so to speak.\n. llazzaro: good point =)\nStrangely enough Latinum implements some of those ideas too, including the idea of a \"Bag\" of different units (Latinum::Collection).\n. @llazzaro If you want something right now that works please check out my gem Latinum\n. After developing Latinum I decided that Money::Zero is fundamentally bad, actually, adding money together of different currencies is fundamentally bad idea. I'd actually recommend looking at how I implemented Latinum::Collection which allows you to avoid the issue entirely and control explicitly how you deal with adding together multiple currencies deterministically.\n. @semmons99 To follow up with this, I actually throw an error if you try to add Latinum::Resource with different face names. Latinum::Collection will aggregate Latinum::Resources based on face name (e.g. 'USD') and at the end if you want to reduce to a single currency you can use a Latinum::Bank which can exchange everything for a common currency (essentially Latinum::Collection is the same as @odigity's original suggestion for a compound money object that represents multiple resource types/currency names, etc). It works very very well and I used it in a web-based accounting system I made called Financier (https://github.com/ioquatix/financier).\n. I thought I'd suggest that not all currency is measured in cents. I would humbly suggest that 'cents' should be renamed 'amount', which would also make more sense in light of this bug report.\n. Okay, right, thanks =)\n. https://github.com/ioquatix/latinum supports arbitrary precision bitcoins, internally using Ruby's awesome BigDecimal. It should be serialised to the database as a string.\nThe specific metadata for the currency is here:\nhttps://github.com/ioquatix/latinum/blob/2ca2e9ead6651c9a66c92e7b8893d5cccd958d97/lib/latinum/currencies/global.rb#L79-L85. ",
    "odigity": "This is on my list of things to deal with soon, since I'm building a precision multi-currency double-entry accounting system, and I need to disable implicit currency conversion (currently happens whenever you use math or comparison operators), and replace it with some kind of compound money object.  That way, when I do this:\nx = Money.new(50, :USD) + Money.new(50, :CAD)\nx will store both values independently within it.  Then if you subtract 50 CAD later, it will be back to equally just 50 USD.  That way you maintain perfect precision, and only do currency exchanges when that's explicitly what you want.\nI'm taking my time to think it through, though, since this is a pretty significant change in behavior, and I'm new to the domain of currency and accounting, and still working through my app's needs.\n(TANGENT)\nI've already kind of tweaked Money to the breaking point to get it to do what I want in my app with regards to the unit/subunit concept.  I am storing values in the database as integers, with a fixed multiplier configured for each currency to ensure an adequate level of precision is maintained when rounding.  The easiest way to do that was to treat the unit as the casual unit (dollar, gram, bitcoin), and the subunit as the minimum precision unit.  For example, I'm storing USD values with a precision of 1/100th of a cent, so I redefined the unit-to-subunit ratio for USD to 10000.\nOf course, this probably breaks some of the other parts of Money, such as formatting helpers, so I'm avoiding using any of it for now until I more fully know the impact of my changes.\nI've also aliased four new methods, because using .to_d and .cents were confusing in my code:\nclass Money\n  class << self\n    alias :from_unit :new_with_dollars\n    alias :from_subunit :new\n  end\n  alias :to_unit :to_d\n  alias :to_subunit :cents\nend\nThat way my code becomes more understandable.  If I'm serializing/deserializing values to/from the database:\nMoney.from_subunit(val)  # $0.0001\nval = m.to_subunit  # $0.0001\nIf I'm inputting from or outputting to a user:\nMoney.from_unit(val)  # $1.00\nval = m.to_unit  # $1.00\n(CLOSING THOUGHTS)\nSo, it'd be nice to see a different version of money that:\n1) got rid of names like cents/dollars in core methods\n2) added a precision_unit concept separate from subunit, which represents minimum precision for storing as an integer, and the multiplier used to inflate/deflate  (then subunit would purely be for pretty formatting)\n3) turned off implicit currency conversion, and allowed the enabling of compound multi-currency balances within a single money value for perfect precision across numeric operations\nPS-To understand why that least features is necessary, read up on multi-currency accounting:\nhttp://www.mscs.dal.ca/~selinger/accounting/\n. PPS-To be fair, I'm still not 100% certain a compound money object is what I actually need to implement my accounting system.  I hope to think more on that soon.\n. Competition!  How very un-Star Trek.  :)\nThis is great, ioquatix.  I'm excited to see evolution in the business domain of ruby libraries, it will benefit everyone.\n. That's awesome!  Big commit, too.  Should I add that line to application.rb, or an an initializer/ file?\n. Doesn't work:\nundefined method `infinite_precision=' for Money:Class (NoMethodError)\nI looked into my local copy of the gem, and it doesn't have the infinite precision commit, even though it is v5.0.  I thought I saw a comment saying this was part of v5.0?\n. In the meantime, I'm going to explicitly compare the 'cents' value instead of the whole money object:\nputs \"it worked!\" if m.cents > 0\n. This is on my list of things to deal with soon, since I'm building a precision multi-currency double-entry accounting system, and I need to disable implicit currency conversion (currently happens whenever you use math or comparison operators), and replace it with some kind of compound money object.  That way, when I do this:\nx = Money.new(50, :USD) + Money.new(50, :CAD)\nx will store both values independently within it.  Then if you subtract 50 CAD later, it will be back to equally just 50 USD.  That way you maintain perfect precision, and only do currency exchanges when that's explicitly what you want.\nI'm taking my time to think it through, though, since this is a pretty significant change in behavior, and I'm new to the domain of currency and accounting, and still working through my app's needs.\n(TANGENT)\nI've already kind of tweaked Money to the breaking point to get it to do what I want in my app with regards to the unit/subunit concept.  I am storing values in the database as integers, with a fixed multiplier configured for each currency to ensure an adequate level of precision is maintained when rounding.  The easiest way to do that was to treat the unit as the casual unit (dollar, gram, bitcoin), and the subunit as the minimum precision unit.  For example, I'm storing USD values with a precision of 1/100th of a cent, so I redefined the unit-to-subunit ratio for USD to 10000.\nOf course, this probably breaks some of the other parts of Money, such as formatting helpers, so I'm avoiding using any of it for now until I more fully know the impact of my changes.\nI've also aliased four new methods, because using .to_d and .cents were confusing in my code:\nclass Money\n  class << self\n    alias :from_unit :new_with_dollars\n    alias :from_subunit :new\n  end\n  alias :to_unit :to_d\n  alias :to_subunit :cents\nend\nThat way my code becomes more understandable.  If I'm serializing/deserializing values to/from the database:\nMoney.from_subunit(val)  # $0.0001\nval = m.to_subunit  # $0.0001\nIf I'm inputting from or outputting to a user:\nMoney.from_unit(val)  # $1.00\nval = m.to_unit  # $1.00\n(CLOSING THOUGHTS)\nSo, it'd be nice to see a different version of money that:\n1) got rid of names like cents/dollars in core methods\n2) added a precision_unit concept separate from subunit, which represents minimum precision for storing as an integer, and the multiplier used to inflate/deflate  (then subunit would purely be for pretty formatting)\n3) turned off implicit currency conversion, and allowed the enabling of compound multi-currency balances within a single money value for perfect precision across numeric operations\nPS-To understand why that least features is necessary, read up on multi-currency accounting:\nhttp://www.mscs.dal.ca/~selinger/accounting/\n. PPS-To be fair, I'm still not 100% certain a compound money object is what I actually need to implement my accounting system.  I hope to think more on that soon.\n. Competition!  How very un-Star Trek.  :)\nThis is great, ioquatix.  I'm excited to see evolution in the business domain of ruby libraries, it will benefit everyone.\n. That's awesome!  Big commit, too.  Should I add that line to application.rb, or an an initializer/ file?\n. Doesn't work:\nundefined method `infinite_precision=' for Money:Class (NoMethodError)\nI looked into my local copy of the gem, and it doesn't have the infinite precision commit, even though it is v5.0.  I thought I saw a comment saying this was part of v5.0?\n. In the meantime, I'm going to explicitly compare the 'cents' value instead of the whole money object:\nputs \"it worked!\" if m.cents > 0\n. ",
    "llazzaro": "I think this could be a usefull paper http://stephane.ducasse.free.fr/Teaching/CoursAnnecy/0506-M1-COO/aconcagua-p292-wilkinson.pdf especially 3.7 talks about Zero Problem\n. Also I will point that :\n Money.parse(0, \"ARS\") == Money.parse(0, \"USD\")  => false\nDo you think is a good idea to have polymorphic zero? Do you think Money.Zero will solve this issue?\n. I am not member of money-dev , not familiar with the Money code and very new to ruby. but I can give a try\n. I think this could be a usefull paper http://stephane.ducasse.free.fr/Teaching/CoursAnnecy/0506-M1-COO/aconcagua-p292-wilkinson.pdf especially 3.7 talks about Zero Problem\n. Also I will point that :\n Money.parse(0, \"ARS\") == Money.parse(0, \"USD\")  => false\nDo you think is a good idea to have polymorphic zero? Do you think Money.Zero will solve this issue?\n. I am not member of money-dev , not familiar with the Money code and very new to ruby. but I can give a try\n. ",
    "lulalala": "I happen to have implemented https://github.com/lulalala/money-collection, because I want more precision when summing multiple Money objects together. This maybe of help to you.\n. Just to clarify, before my commit, the master branch already has some specs that fails sporadically.\nBy the way, maybe a simpler way is just to compare calculated decimal amounts, but I am not sure if it goes against the philosophy of integer operation. Feel free to comment.\n. @ct-clearhaus I think you have a point.\nThe bug I have is illustrated in this spec https://github.com/lulalala/money/blob/compare_different_currency_precision/spec/money/arithmetic_spec.rb#L105\nSo 1 USD equals to 2 FOO. However 3 FOO is considered to be equal to 1 USD, due to it being rounded down.\nI think it is better to then compare the floating point converted results. It will be simpler than my branch right now. What do you think? If you think it is okay I'll amend my pull-request.\n. Cool, I think you want to convey that comparison between amounts that requires currency conversion is asymmetric in nature. The semantic of  <=> here is defined as converting other to subject first. So of course I shouldn't make it go the other way.\nThat said, I think whether we compare before or after rounding it down to an integer, is open to debate. It's easy to think that 0.01 USD is less than 0.03 FOO, because it has less purchasing power. That is, I believe <=> should compare \"purchasing power\". When I compare coins from two currencies, I wouldn't always want to physically exchange one to another first, because I just want to compare their purchasing powers. However if I do care about finding the largest offering in a bidding, I have the option to convert it manually then compare.\nthoughts? :dancer: \n. Sorry it took this long to reply.\nI have to apologize for one thing. The spec failure was indeed caused by me. I think it is to do with adding custom FOO currency.\nI dig a bit and now understand that currently, if I am to comparison before rounding, it would be hacky because it goes against the current implementation.\nI still think it is a good idea, but it would require changing Bank, Money and Arithmatic. For example the infinite_precision setting has to go to the exchange part of the code. It also need to be a per-instance setting to avoid concurrency issues. All these requires a lot of change which I don't have time right now. \nBut thanks a ton for all of you who took time looking into this pull-request.\n. @printercu because my infinite_precision is false, round would always return self. So this would not work. Maybe we should allow rounding when infinite_precision is false?\n. Hi @orien, I see you in 3ba5e1c81d9e763742ae1d39d01c3dec64fae3b6 first wrote the round method. At that time you explicitly stated that round would do nothing if infinite_precision is false. Would there be bad implication if we are to allow rounding when infinite_precision is false? Cheers!\n. I happen to have implemented https://github.com/lulalala/money-collection, because I want more precision when summing multiple Money objects together. This maybe of help to you.\n. Just to clarify, before my commit, the master branch already has some specs that fails sporadically.\nBy the way, maybe a simpler way is just to compare calculated decimal amounts, but I am not sure if it goes against the philosophy of integer operation. Feel free to comment.\n. @ct-clearhaus I think you have a point.\nThe bug I have is illustrated in this spec https://github.com/lulalala/money/blob/compare_different_currency_precision/spec/money/arithmetic_spec.rb#L105\nSo 1 USD equals to 2 FOO. However 3 FOO is considered to be equal to 1 USD, due to it being rounded down.\nI think it is better to then compare the floating point converted results. It will be simpler than my branch right now. What do you think? If you think it is okay I'll amend my pull-request.\n. Cool, I think you want to convey that comparison between amounts that requires currency conversion is asymmetric in nature. The semantic of  <=> here is defined as converting other to subject first. So of course I shouldn't make it go the other way.\nThat said, I think whether we compare before or after rounding it down to an integer, is open to debate. It's easy to think that 0.01 USD is less than 0.03 FOO, because it has less purchasing power. That is, I believe <=> should compare \"purchasing power\". When I compare coins from two currencies, I wouldn't always want to physically exchange one to another first, because I just want to compare their purchasing powers. However if I do care about finding the largest offering in a bidding, I have the option to convert it manually then compare.\nthoughts? :dancer: \n. Sorry it took this long to reply.\nI have to apologize for one thing. The spec failure was indeed caused by me. I think it is to do with adding custom FOO currency.\nI dig a bit and now understand that currently, if I am to comparison before rounding, it would be hacky because it goes against the current implementation.\nI still think it is a good idea, but it would require changing Bank, Money and Arithmatic. For example the infinite_precision setting has to go to the exchange part of the code. It also need to be a per-instance setting to avoid concurrency issues. All these requires a lot of change which I don't have time right now. \nBut thanks a ton for all of you who took time looking into this pull-request.\n. @printercu because my infinite_precision is false, round would always return self. So this would not work. Maybe we should allow rounding when infinite_precision is false?\n. Hi @orien, I see you in 3ba5e1c81d9e763742ae1d39d01c3dec64fae3b6 first wrote the round method. At that time you explicitly stated that round would do nothing if infinite_precision is false. Would there be bad implication if we are to allow rounding when infinite_precision is false? Cheers!\n. ",
    "gtd": "The space issue is not without precedent.  See Brazilian Real.\nI am not sure about other Kroner like Danish or Swedish, but it's worth investigating.\nAlso, I have a patch that implements the dash fix with a single setting, so it's kind of a slap in the face to get labeled \"support\" :)\n. It is time.\n. The space issue is not without precedent.  See Brazilian Real.\nI am not sure about other Kroner like Danish or Swedish, but it's worth investigating.\nAlso, I have a patch that implements the dash fix with a single setting, so it's kind of a slap in the face to get labeled \"support\" :)\n. It is time.\n. ",
    "sankaranarayanan": "In Indian format \n1 crore is 1,00,00,000\n1 thousand is 1,000\n. ok, I'll change the flag name.\nThanks & Regards\nSankaranarayanan .E\nOn Wed, Jul 18, 2012 at 7:46 PM, Shane Emmons <\nreply@reply.github.com\n\nwrote:\nLooking at this wikipedia article would it be more\napt to name it something like south_asian_number_formatting.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/202#issuecomment-7070071\n. I've removed that attributes in currency\nThanks & Regards\nSankaranarayanan .E\n\nOn Wed, Jul 18, 2012 at 11:27 PM, Shane Emmons <\nreply@reply.github.com\n\nwrote:\n@TMaYaD: right, I want that part removed by @sankaranarayanan\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/202#issuecomment-7076655\n. In Indian format \n1 crore is 1,00,00,000\n1 thousand is 1,000\n. ok, I'll change the flag name.\n\nThanks & Regards\nSankaranarayanan .E\nOn Wed, Jul 18, 2012 at 7:46 PM, Shane Emmons <\nreply@reply.github.com\n\nwrote:\nLooking at this wikipedia article would it be more\napt to name it something like south_asian_number_formatting.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/202#issuecomment-7070071\n. I've removed that attributes in currency\nThanks & Regards\nSankaranarayanan .E\n\nOn Wed, Jul 18, 2012 at 11:27 PM, Shane Emmons <\nreply@reply.github.com\n\nwrote:\n@TMaYaD: right, I want that part removed by @sankaranarayanan\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/202#issuecomment-7076655\n. \n",
    "TMaYaD": "Sorry, I did not get that. How ever, let me try to break it down.\n1) Yes, this is specific to a locale.\n2) Yes, It should only be an option for #format, but shouldn't we allow it to be set on Currency as the currency is also specific to a locale? I mean, you speak of millions of dollars and lakhs of rupees; and interchanging the format and currency is very rare.\n3) Ideally we should also look up in I18n like what you are doing for decimal_mark. And that is lacking from this pull request. Is this what you are asking?\n. okay, i reviewed the code and now im even more confused. even though the option is made available on currency, its neither being used nor does it have any specs covering it. \n. Sorry, I did not get that. How ever, let me try to break it down.\n1) Yes, this is specific to a locale.\n2) Yes, It should only be an option for #format, but shouldn't we allow it to be set on Currency as the currency is also specific to a locale? I mean, you speak of millions of dollars and lakhs of rupees; and interchanging the format and currency is very rare.\n3) Ideally we should also look up in I18n like what you are doing for decimal_mark. And that is lacking from this pull request. Is this what you are asking?\n. okay, i reviewed the code and now im even more confused. even though the option is made available on currency, its neither being used nor does it have any specs covering it. \n. ",
    "cblock": "bump\n. Hi and thanks for your responses. I understand your concerns and I'll follow your advice.\n. bump\n. Hi and thanks for your responses. I understand your concerns and I'll follow your advice.\n. ",
    "konung": "I switched to https://github.com/RubyMoney/money-rails gem instead which solved the issue\n. I switched to https://github.com/RubyMoney/money-rails gem instead which solved the issue\n. ",
    "seddy": "Apologies, sent pull request to wrong repository, so have closed!\n. Thanks @semmons99 - very much appreciated, also to @dougdroper for finishing this off :)!\n. Apologies, sent pull request to wrong repository, so have closed!\n. Thanks @semmons99 - very much appreciated, also to @dougdroper for finishing this off :)!\n. ",
    "jacobat": "I assume it should still be possible to have different rates going back and forth? One use case would be an exchange that features different rates when buying and selling a currency.\n. I assume it should still be possible to have different rates going back and forth? One use case would be an exchange that features different rates when buying and selling a currency.\n. ",
    "benkant": "Is it always the case that EURUSD == 1/USDEUR though? That might be the case for the mid rate, but certainly won't be if you're specifying buy and sell rates.\nIf I add a rate for EUR, USD I might not necessarily want an automatic inverse to occur. I am \"buying USD\" and \"selling EUR\", and specifying the rate that happens at.\nI think by default the VariableExchange should not automatically do the inverse. If your exchange \"supports\" that, you should subclass. My 0.02c.\n. Is it always the case that EURUSD == 1/USDEUR though? That might be the case for the mid rate, but certainly won't be if you're specifying buy and sell rates.\nIf I add a rate for EUR, USD I might not necessarily want an automatic inverse to occur. I am \"buying USD\" and \"selling EUR\", and specifying the rate that happens at.\nI think by default the VariableExchange should not automatically do the inverse. If your exchange \"supports\" that, you should subclass. My 0.02c.\n. ",
    "skwp": "After thinking about this and realizing also that there are sources of automatic exchange data, I move to close this issue. Since I opened it, I am closing it. If someone wants to reopen, please do :)\n. For those who are curious, I was using this to implement currency conversions for my project http://rewear.me - check it out!\n. After thinking about this and realizing also that there are sources of automatic exchange data, I move to close this issue. Since I opened it, I am closing it. If someone wants to reopen, please do :)\n. For those who are curious, I was using this to implement currency conversions for my project http://rewear.me - check it out!\n. ",
    "therocketforever": "Ha! Obviously.\nI think I was making this about 1000 times harder then it needed to be.\nThank you so much. \n. Ha! Obviously.\nI think I was making this about 1000 times harder then it needed to be.\nThank you so much. \n. ",
    "mikabytes": "Nice trick with the -f flag, happy to learn something new today :) Thanks\n. I believe the technical word is \"fractional part\", however, we face another challenge in implementing it. Keeping in mind that the significance of the fractional part is 1/100 in most countries, but in some it is 1/1000 or even 1/5. The Money gem (please correct me if I'm wrong) has based it all on the 1/100 system. This makes for inconsistent use.. How would you instantiate it? Money.new(100.5, 'BHD')?\nKeeping the notion of cents is not incorrect, although not proper. \"Cent\", Latin \"centrum\", meaning hundred, can still be used and understood even if the native fractional part is different.\nMaybe we're seeing a major rewrite ahead? ;)\n. Although we can handle currencies that have non-100 fractions, my concern is that we get some behaviour that is not correct:\nThis is still correct, since cents are \"out of a hundred\":\nMoney.new(100, 'BHD')\n => #<Money cents:100 currency:BHD>\nHowever, if you rename \"cents\" to \"fractions\", it is no longer correct.\nMoney.new(100, 'BHD')\n => #<Money fractions:100 currency:BHD>  # expects fractions to be 1000 !\n100 fractions of a currency that makes a whole out of 1000 (natively) equal 0.1 BHD.\n. Oh, I just realised I was wrong. It would work correctly as you said @semmons99 . Not sure where you're at, but in Sweden it's in the middle of the night. I guess I'm getting tired..\nMoney.new(100, 'BHD').dollars => 0.1 BHD\nHowever, this means that Money is currently wrong, as the \"cents\" are showing incorrect numbers (assuming cent means \"out of a hundred\"). When we rename this to \"fractions\" or \"fractional\" it will be correct.\nNow going to bed. I'll work on the cent renaming tomorrow if all agree!\n. As you see, I've added another two commits. The first one makes the API change with modified tests, and the second only adjusts the internals to use #fractional as well as modified the comments. \ncents remain as a synonym and no behaviour has changed. I recommend to deprecate it sometime in the future, perhaps in the next major release.\n. I'm happy to help, and would like to improve a few other things too as I'll be needing. First off there is a test slowing down the suite, I'm on it right now. After that I'll be heading for supporting all countries currency symbols for the Money.parse (it currently only supports dollar, euro and pounds).\nI would be most grateful if people review my work. Direct commit access feels kind of risky. What is the workflow?\n. Thanks for the info, you'll be seeing me again :)\n. Hi @kenn, that's a good point! Do you have an idea of how we could identify a few cases where float point would have been an issue if it wasn't solved as it is today? I would really like to have focused tests for these, rather than going napalm on the whole issue :)\n. If we can confirm that BigDecimal is used everywhere regarding this issue, then we can trust it and settle for a single integration test. Since I'm new to this code it would be best if someone with good experience can make the decision. Up for a vote?\nAlso, is it possible to re-open this thread somehow since the issue is not resolved?\n. @clee704 thanks for the contribution. I have confirmed this.\nCould I ask you to make an entry in the CHANGELOG.md and update this pull request? Then we'll be ready for a merge.\n. Hello Pavan,\nUnfortunately it is not possible to add symbols that are not include in unicode. The new symbol as shown in Wikipedia is a SVG image file, which we can't use in text documents. \nUnless anyone have suggestions, I believe we will just have to wait until it is included. This is a common problem with several other symbols.\n. Ah - my bad. Yes, we can add this. Would you like to make the change?\n. Great! I'm in need of some help though - I have already merged this branch with master on my fork and I'm not quite sure how I would go about rebasing it for merging with upstream (here). Any pointers?\n. Sorry to bother with this, but I'm still unable to rebase:\ngit pull --rebase . upstream/master\nfatal: Couldn't find remote ref upstream/master\nfatal: The remote end hung up unexpectedly\nI'm used to merge, rebase is a new concept for me (which I'm currently reading up on)\n. I did all the steps, and git fetch upstream was also successful as I can see 6 new commits in the git status. Still it would seem some tag is missing. Perhaps I can clear this mess by doing a hard reset on a very old commit, fetch and apply upstream, then rebase on the currency_extensions branch on my master. That should give us clean git history. Let me know what you think, and thanks again for the help!\n. Rebase is now successful, but seems we got an error in the CI scripts for jruby as can be seen here.\n. Cool, and thanks again for the help :)\n. Hello Anthony :)\nLooks good. :shipit:\n. Yes, I would agree with @semaperepelitsa. The thousands and decimal separators are entirely decided by locale. For example, in Swedish you would always write \",\" before the fractional part. I.e Swedish 10,37 is written \"10.37\" in Ruby. This is, of course, a major pain in the ass since the numpad period button won't work unless the keyboard layout is changed to \"en/us\".\n. Indeed. We might need to rethink all current functionality that involves the thousands separator and fractal sign. We could probably do some automatic mapping from the current settings by using Country gem to figure out the locale, and use this by default. This way we'd still be backwards compatible. After that the logical course of action would be to add locale to the interfaces and let it fall-back to the one defined in the configuration.\nI'm currently swamped with work, all scheduled up to end of January. So someone else would need to take a crack at it :)\n. Nice trick with the -f flag, happy to learn something new today :) Thanks\n. I believe the technical word is \"fractional part\", however, we face another challenge in implementing it. Keeping in mind that the significance of the fractional part is 1/100 in most countries, but in some it is 1/1000 or even 1/5. The Money gem (please correct me if I'm wrong) has based it all on the 1/100 system. This makes for inconsistent use.. How would you instantiate it? Money.new(100.5, 'BHD')?\nKeeping the notion of cents is not incorrect, although not proper. \"Cent\", Latin \"centrum\", meaning hundred, can still be used and understood even if the native fractional part is different.\nMaybe we're seeing a major rewrite ahead? ;)\n. Although we can handle currencies that have non-100 fractions, my concern is that we get some behaviour that is not correct:\nThis is still correct, since cents are \"out of a hundred\":\nMoney.new(100, 'BHD')\n => #<Money cents:100 currency:BHD>\nHowever, if you rename \"cents\" to \"fractions\", it is no longer correct.\nMoney.new(100, 'BHD')\n => #<Money fractions:100 currency:BHD>  # expects fractions to be 1000 !\n100 fractions of a currency that makes a whole out of 1000 (natively) equal 0.1 BHD.\n. Oh, I just realised I was wrong. It would work correctly as you said @semmons99 . Not sure where you're at, but in Sweden it's in the middle of the night. I guess I'm getting tired..\nMoney.new(100, 'BHD').dollars => 0.1 BHD\nHowever, this means that Money is currently wrong, as the \"cents\" are showing incorrect numbers (assuming cent means \"out of a hundred\"). When we rename this to \"fractions\" or \"fractional\" it will be correct.\nNow going to bed. I'll work on the cent renaming tomorrow if all agree!\n. As you see, I've added another two commits. The first one makes the API change with modified tests, and the second only adjusts the internals to use #fractional as well as modified the comments. \ncents remain as a synonym and no behaviour has changed. I recommend to deprecate it sometime in the future, perhaps in the next major release.\n. I'm happy to help, and would like to improve a few other things too as I'll be needing. First off there is a test slowing down the suite, I'm on it right now. After that I'll be heading for supporting all countries currency symbols for the Money.parse (it currently only supports dollar, euro and pounds).\nI would be most grateful if people review my work. Direct commit access feels kind of risky. What is the workflow?\n. Thanks for the info, you'll be seeing me again :)\n. Hi @kenn, that's a good point! Do you have an idea of how we could identify a few cases where float point would have been an issue if it wasn't solved as it is today? I would really like to have focused tests for these, rather than going napalm on the whole issue :)\n. If we can confirm that BigDecimal is used everywhere regarding this issue, then we can trust it and settle for a single integration test. Since I'm new to this code it would be best if someone with good experience can make the decision. Up for a vote?\nAlso, is it possible to re-open this thread somehow since the issue is not resolved?\n. @clee704 thanks for the contribution. I have confirmed this.\nCould I ask you to make an entry in the CHANGELOG.md and update this pull request? Then we'll be ready for a merge.\n. Hello Pavan,\nUnfortunately it is not possible to add symbols that are not include in unicode. The new symbol as shown in Wikipedia is a SVG image file, which we can't use in text documents. \nUnless anyone have suggestions, I believe we will just have to wait until it is included. This is a common problem with several other symbols.\n. Ah - my bad. Yes, we can add this. Would you like to make the change?\n. Great! I'm in need of some help though - I have already merged this branch with master on my fork and I'm not quite sure how I would go about rebasing it for merging with upstream (here). Any pointers?\n. Sorry to bother with this, but I'm still unable to rebase:\ngit pull --rebase . upstream/master\nfatal: Couldn't find remote ref upstream/master\nfatal: The remote end hung up unexpectedly\nI'm used to merge, rebase is a new concept for me (which I'm currently reading up on)\n. I did all the steps, and git fetch upstream was also successful as I can see 6 new commits in the git status. Still it would seem some tag is missing. Perhaps I can clear this mess by doing a hard reset on a very old commit, fetch and apply upstream, then rebase on the currency_extensions branch on my master. That should give us clean git history. Let me know what you think, and thanks again for the help!\n. Rebase is now successful, but seems we got an error in the CI scripts for jruby as can be seen here.\n. Cool, and thanks again for the help :)\n. Hello Anthony :)\nLooks good. :shipit:\n. Yes, I would agree with @semaperepelitsa. The thousands and decimal separators are entirely decided by locale. For example, in Swedish you would always write \",\" before the fractional part. I.e Swedish 10,37 is written \"10.37\" in Ruby. This is, of course, a major pain in the ass since the numpad period button won't work unless the keyboard layout is changed to \"en/us\".\n. Indeed. We might need to rethink all current functionality that involves the thousands separator and fractal sign. We could probably do some automatic mapping from the current settings by using Country gem to figure out the locale, and use this by default. This way we'd still be backwards compatible. After that the logical course of action would be to add locale to the interfaces and let it fall-back to the one defined in the configuration.\nI'm currently swamped with work, all scheduled up to end of January. So someone else would need to take a crack at it :)\n. ",
    "zackxu1": "Hi.\nWe're using the Money gem and we would like the support of fractional cent, eg\n100.837 cents\nI believe this is supported by the latest mods here.\nThis gem hasn't been tagged in 6 months, can someone bump up its version number?\nSorry if this is the wrong place to make such request\nThanks\n. @semmons99 Thanks, that worked, but that means always pulling the latest code? Let me know how soon you think you'll be able to create a few version.  Thanks alot\n. @semmons99 Thanks!\n. Hi.\nWe're using the Money gem and we would like the support of fractional cent, eg\n100.837 cents\nI believe this is supported by the latest mods here.\nThis gem hasn't been tagged in 6 months, can someone bump up its version number?\nSorry if this is the wrong place to make such request\nThanks\n. @semmons99 Thanks, that worked, but that means always pulling the latest code? Let me know how soon you think you'll be able to create a few version.  Thanks alot\n. @semmons99 Thanks!\n. ",
    "palexvs": "Hmm, so Money does not have any methods to conver it to JSON, i am right?\nThen it do gem ActiveSupport in Rails. \nOk. Then i will write some workaround.\nOr maybe do you want add serialization to JSON in Money gem?\nThank you\n. Hmm, so Money does not have any methods to conver it to JSON, i am right?\nThen it do gem ActiveSupport in Rails. \nOk. Then i will write some workaround.\nOr maybe do you want add serialization to JSON in Money gem?\nThank you\n. ",
    "bbozo": "I would maybe just suggest to make #to_h to return something sensible that the constructor can chew through, this way you could serialize and deserialize the Money object, for example in a Postgres JSON datastore\nAt the moment the procedure is something like:\n``` ruby\n  def new_plan_attributes_for_jsonizing attributes\n    Hash[\n      attributes.map do |k,v|\n        unless v.is_a? Money\n          [k, v]\n        else\n          [k, { :type => 'Money', :cents => v.cents, :currency => v.currency.iso_code }]\n        end\n      end\n    ]\n  end\ndef attributes_from_jsonizing attributes\n    Hash[\n      attributes.map do |k,v|\n        if v.is_a?(Hash) and v['type'] == 'Money'\n          [ k, Money.new(v['cents'], v['currency']) ]\n        else\n          [k,v]\n        end\n      end\n    ]\n  end\n```\n. :+1: \n. @printercu, good point! :) thank you\n. Nice, this was fixed in 60b2f60b28952da2427b6c15e922c6811d9e216a\n. :) that was quick :) :+1:\n. Hmm, aparently using Satoshis is not future-proof + what about the other plethora of emerging, theoretically infinitely divisible, currencies?\nI posted a question on Code Review, it seems to me we (The Programmers Of THe WorLd) will have to move away from integers when presenting amounts and start to be super-careful in the way we handle tiny denominations, precision calculations etc. @krtschmr consider this, one day a 100 USD buys you 1234 units, for example satoshis, of some currency. The price hops in the next year or couple of years by 10 times - this is reasonable because the supply in many cryptocurrencies is hard-limited so with the increased supply.. - so the same 100 USD buys you now 123.4 units - and if you can't store this decimal - you have a problem,\nif you can't store this decimal and you still store the int part (because of a to_i you have somewhere - a very reasonable thing to do in the nil-averse world we live in) - you have a VERY big problem.\nAlso consider APIs, how could this migration possibly work one day if we stick to the integer/cents/satoshis + number of decimals scheme?. I would maybe just suggest to make #to_h to return something sensible that the constructor can chew through, this way you could serialize and deserialize the Money object, for example in a Postgres JSON datastore\nAt the moment the procedure is something like:\n``` ruby\n  def new_plan_attributes_for_jsonizing attributes\n    Hash[\n      attributes.map do |k,v|\n        unless v.is_a? Money\n          [k, v]\n        else\n          [k, { :type => 'Money', :cents => v.cents, :currency => v.currency.iso_code }]\n        end\n      end\n    ]\n  end\ndef attributes_from_jsonizing attributes\n    Hash[\n      attributes.map do |k,v|\n        if v.is_a?(Hash) and v['type'] == 'Money'\n          [ k, Money.new(v['cents'], v['currency']) ]\n        else\n          [k,v]\n        end\n      end\n    ]\n  end\n```\n. :+1: \n. @printercu, good point! :) thank you\n. Nice, this was fixed in 60b2f60b28952da2427b6c15e922c6811d9e216a\n. :) that was quick :) :+1:\n. Hmm, aparently using Satoshis is not future-proof + what about the other plethora of emerging, theoretically infinitely divisible, currencies?\nI posted a question on Code Review, it seems to me we (The Programmers Of THe WorLd) will have to move away from integers when presenting amounts and start to be super-careful in the way we handle tiny denominations, precision calculations etc. @krtschmr consider this, one day a 100 USD buys you 1234 units, for example satoshis, of some currency. The price hops in the next year or couple of years by 10 times - this is reasonable because the supply in many cryptocurrencies is hard-limited so with the increased supply.. - so the same 100 USD buys you now 123.4 units - and if you can't store this decimal - you have a problem,\nif you can't store this decimal and you still store the int part (because of a to_i you have somewhere - a very reasonable thing to do in the nil-averse world we live in) - you have a VERY big problem.\nAlso consider APIs, how could this migration possibly work one day if we stick to the integer/cents/satoshis + number of decimals scheme?. ",
    "printercu": "@bbozo please consider storing amount or ~~fractional~~ instead of cents. With Money.infinite_precision = true cents will also be fractional and will be stored in json as string. But amount will be more human-readable. There is now .from_amount to construct Money with dollars.\n. Ready.\n. :+1: \n. TLDR; Money::Currency.table[:rub][:symbol] = 'rub'\nHere is full pry listing, how you can get it https://gist.github.com/printercu/022b0ee5bc3db99cd5bc\n. done\n. @jimpo @semmons99 there are warning after this pr was merged:\n~/.rvm/gems/ruby-2.2.1/gems/rspec-expectations-3.2.1/lib/rspec/matchers/built_in/eq.rb:35: warning: Return nil in #<=> if the comparison is inappropriate or avoid such comparison.\n. i've run rspec in gem\n. :+1: \n. I think it's ok to raise UnknownRate. Error will indicate that code is working not as it supposed to. Suppressing such errors (silently or with warnings) is kind of JS/PHP way which is hard to debug.\n. Warnings are still there: https://travis-ci.org/RubyMoney/money/jobs/70629750\n. Hi! Have you tried Money.rounding_mode=?\n. :+1: \n. nice! i just wonder it can be useful to have method to access @@instances for debugging/development.\nIt's not really necessary for me, 'cause of pry. But it's not available sometimes. wdyt?\n. good! everything is fine, but i think we can get extra performance. my comment https://github.com/RubyMoney/money/pull/538#discussion_r34447779 is hidden now, 'cause code've changed. it's about instances[id] || @@mutex.synchronize\n\nCan you please provide example of concurrency? I think while there is ||= inside .synchronize everything should be ok. It would just improve performance by avoiding synchronisation when it's not needed, and synchronising otherwise.\n. Is it a problem? \n\nI'm really feeling uncomfortable to argue about this, because 3x speed up in mri is maybe not so significant in this case. I just wanted to give some advice, how to improve code to be more perfect, while not taking much effort. I think that actions must not be performed, when they are unnecessary, and that's all. \nEverything else is perfect in PR, i think somebody will merge it soon as it is. I just want someone else to look through the code.\n. yeah, i'll merge it\n. :+1: \n@phlegx can you please add spec for it, so somebody wouldn't remove it accidentally later.\n. Hi! It was added in 6.6\n. @poc7667 https://github.com/RubyMoney/money/blob/master/lib/money/money.rb#L228 is it what you want? There is also https://github.com/RubyMoney/monetize gem with more conversions.\n. https://github.com/RubyMoney/money/issues?q=is%3Aissue+from_amount+is%3Aclosed\n. It may depend on bank. What bank do you use? Try to set rates manually, will it give same result?\n. Please try with Money.infinite_precision = true.\n. Seems like it was fixed in 6.6.1.\nruby\n2.2.1 (main):0[2] > Money.new(1, :HKD).exchange_to(:VND)\n=> #<Money fractional:28.844994 currency:VND>\nNote that you need to update google_currency to 3.2.1. But it's not published, you can install it from github.\n@semmons99 can you publish google_currency@3.2.1 ?\n. Exchange rate is not 100 time smaller. When you create with Money.new you should pass amount in cents. Use Money.from_amount to instantiate with amount in dollars.\nThere was a problem with exchange, and i can reproduce same situation with HKD/VND in 6.5.1 now (but not in 6.6.1). If you want prevent cents from truncation, you need to ensure you have right version. You can check #exchange method with pry:\n```\n\nshow-method Money::Bank::VariableExchange#exchange\nFrom: gems/money-6.6.1/lib/money/bank/variable_exchange.rb @ line 127:\nOwner: Money::Bank::VariableExchange\n...\n  else\n    ex.to_s.to_d <<< this must be .to_d, old version has .to_i\n  end\nend\n``\n. Can you please checkMoney.from_amount(100, :HKD).to_d,Money.from_amount(100, :VND).to_d,Money.from_amount(100, :USD).to_d? You can find out what.to_d` returns.\n\nP.S. .to_d is better than .to_f when you work with money, 'cause with .to_f sometimes you can get wrong result while working with fractional part.\n. Why is it wrong? Try .dollars, .cents for Money.from_amount(100, :VND). Seems like VND does not have subunits. Yeah, different methods return same result :). I don't like this design and just use #to_d and .from_amount without all the .dollars, .cents, etc. This methods works with main currency units.\n. you're welcome!\n. :+1:  Maybe this will be helpful https://github.com/rails/rails/blob/master/activesupport/lib/active_support/number_helper/number_to_rounded_converter.rb#L72-L79, you can take regex right from there.\n. Can you please add tests for the define_method stuff? Don't really understand what does it solve. Why do we need to add methods directly into the base? Seems like following works fine (no failed tests)\n``` diff\n-    def self.included(base)\n-      [\n-        [:thousands_separator, :delimiter, \",\"],\n-        [:decimal_mark, :separator, \".\"]\n-      ].each do |method, name, character|\n-        define_i18n_method(method, name, character)\n-      end\n-    end\n-\n     def self.define_i18n_method(method, name, character)\n       define_method(method) do\n         if self.class.use_i18n\n@@ -25,6 +16,14 @@ class Money\n       alias_method name, method\n     end\n\n[\n[:thousands_separator, :delimiter, \",\"],\n[:decimal_mark, :separator, \".\"]\n].each do |method, name, character|\ndefine_i18n_method(method, name, character)\nend\n```\n\nUPD Even simplier\ndiff\n+    define_i18n_method :thousands_separator, :delimiter, ','\n+    define_i18n_method :decimal_mark, :separator, '.'\n. Please don't merge #578 in. This is a quick and dirty but not a good solution. Maybe there is even bug in ruby. There is no 2.3 image in rvm for now, so i'm not able to test it myself.\nHave you tried my solution?\n. Yeah this'll be better :+1: \nSeems like there is really bug in a mri preview version, I'll install and check it.\n. I've opened an issue in ruby tracker https://bugs.ruby-lang.org/issues/11754\nLets first wait for the result.\n. @semmons99 why did you merge it?\nRuby 2.3 is still preview, there may be a bug. Please read conversation in #576. Please consider to revert it.\n. cool :+1: \n. Why is it better to make it private? I think i was using it in some project.\n. I cant find statement you are talking about. Is it this one https://github.com/RubyMoney/money/blob/master/lib/money/currency.rb#L201 ?\n. It's not supposed to hide stringified_keys, its for stringify_keys. And this one is private, 'cause it's inside class << self. Everything seems to be ok. Closing?\n. We can change this only in major release, 'cause it'll break backward compatibility. It's seems to be logical to separate code from iso_code. I think it's even better to replace .iso_code with just .code, but there will be a lot of incompatibility.\nFor now, while there is no decision on this, seems like you can use \nruby\ndef is_iso?\n  !iso_numeric.empty?\nend\n. There is already #code method, and it's a little bit more complex. Somebody may be using it now.\n. My #iso? is hacky. I think iso_numeric should be better int|null, but it's string now. And my solution relies on it. So instead of it i would prefer to change iso_numeric in definitions, and check for !iso_numeric.nil? in #iso?.\n@RubyMoney/money-devs is it ok to change iso_numeric's type (string => [int|null]) in json files?\n. Failure could take place, if exponent is Float (https://github.com/RubyMoney/money#currency-exponent). It's better to use .be_within(0.01).of(3) in spec rather then .round.\n. So should we better round exponent in #exponent method?\n. #607 #606 #605 are related. lets continue conversation in #606 maybe?\n. fixed in #607 \n. Why do we need CoercedNumber? Can we just make all operations commutative with \nruby\n    def coerce(other)\n      [self, other]\n    end\n? Seems like there are all the checks in #<=>, #- and other methods.\nThere is already commit to fix Money#<=>(Numeric) to return nil (https://github.com/RubyMoney/money/commit/377e48f4a09e93a5ef6e861d43cd1abc3bde80b4) but Numeric#<=>(Money) is missing there.\nUPD. Ah, seems like error is just with division. I'll try to get a solution.\n. Take a look at #607 please. wdyt?\n. I've also added support for commutative comparison with 0 to #607.\n. Thanks for testing!\nI think this should be expected behaviour.  Indeed, it's very odd that == doesn't raise error, 'cause it is expected to use the result of <=> same way as >=. I'll check ruby docs and report later.\nUPD. http://ruby-doc.org/core-2.2.2/Comparable.html#method-i-3C-3D\n\nEven if obj <=> other raised an exception, the exception is ignored and [==] returns false.\n\nIt'll be really confusing to have 1.to_money == 1 returning false. I'll fix it.\n. I've thought about the issue and understood why == is different from all other comparison methods and doesn't rise error. The point is that == is expected to work with any other value:\n``` ruby\nmoney = Money.usd(1)\nmoney == [] # false\nmoney == User.first # false\n...\n```\nSo it would be inconsistent if it would rise error just for non-zero numerics.\nI think current behaviour is ok, we just need to add a note to readme. wdyt?\nPS. I was always against implicit typecasting in the case of Money's comparison operators. It supports only 0 for now, and I think #zero?, #positive? & #negative? are just enough (or even single #to_d). Maybe one day we'll be able to deprecate comparison with non-money values.\n. @bryanrite i've pushed fixes in #616 . Let someone take a look on it, and we'll merge.\n. @semmons99 take a look please.\n. What about return fractional <=> 0 if other_money.zero? ? There will be less allocations. \nThere are some issues with commutative operations (#605 #606 #607) and i was fixing them in #607 . I'll add commit to provide commutative comparison (Money > 0, 0 < Money).\n. Got it. Don't really think it's safe enough to allow comparison with numbers, but may be it'll be useful. I hope we can wait someone else's review.\nHowever seems like this way code can be even simpler: return fractional <=> other_money if other_money.is_a?(Numeric)\n. The only place i see where it'll be useful is \nruby\nvalidates_numericality_of :money_field, \n  greater_than: 0, \n  less_than: ->(x) { maximum_in_currency(x) }\nIn any other place it'll be comparison either with 0 or with magic numbers, which should better be replaced with money-object constants. And hope there will be no scenario when single non-zero numeric will be compared to multi-currency money (do_something if money > 53 and money can be usd, cad or eur).\n. In previous git versions push.default was default to matching. So you could overwrite master in main repo when pushed amended commit with --force. If nobody had a copy of recent commits it would be a little tricky to restore master. Though this is not a critical problem, this will never happen if you use your own repo :)\n. Seems like it was a fix: https://github.com/RubyMoney/money/commit/bfa7108e1d085f7518ff979db4b8c9cb1b1b1e3f\nHere is pr #506 \n. @xxswingxx I also don't like the idea to initiate Money with cents. You can use .from_amount instead of .new: Money.from_amount(1.2345, :clf) == Money.new(12345, :clf).\n. Is it supposed to be like this?\n``` ruby\nI18n.locale = 'fr-CA'\nMoney.new(100, :usd) == '$1.00'\nMoney.new(100, :cad) == '1.00$'\n```\nDoes not all other currencies need to be displayed with symbol after value for fr-CA?\n. I'm not sure if this should be done this way. However :decimal_mark and :thousands_separator should be better set from locale file. Maybe :symbol_position can be changed in the same way.\nping @RubyMoney/money-devs in a short: fr-CA locale need to print symbols for all currencies in the end. Is it right place to change it in the localize_formatting_rules? Can this be done other way?\n. There are a lot of locales and many of them may have specific formatting rules. It'll be huge case block if we would be adding every such rule into the code. There also should work the principle of separation code and data. Messing them together isn't good idea.\nIf this is really the case, we should better introduce default locale files with formatting settings for this locales.\n. I've extracted formatting logic to separate class. So it's easy to define custom formatters and switch between them dynamically: https://github.com/printercu/money/blob/v7/lib/money/formatter.rb\nhttps://github.com/printercu/money/blob/v7/lib/money.rb#L369-383\n. @HaleTom yep! I've forgotten about this first. Added commit. I've also changed Currency to use #code.downcase.to_sym as id. So it's not repeated in currency files. However after this YEN & GHC fallbacks are not supported (JPY & GHS should be used instead).\nI'll add #is_iso? later after changing iso_numeric to Int.\n. I thought, nobody was interested in this pr. I can rebase and fix conflicts if you really intend to merge this one :). I've just rebased on master, and added some small commits.\nI've decided to release it as money2 gem for now, as I've been using it for a while in several projects.\nHere is a note I've made to share with others: https://github.com/printercu/money/wiki\nI'll be glad to receive suggestions, PRs or any other feedback.. @antstorm I just want to make it easier to try to move to new version and to give early-adopter's feedback and understand overall reaction. As I said, there are just too much incompatibility, so I really don't have time now to add deprecation warnings all over the code first, and then rebase everything again, while I've already have working v7 code.\nAs I mentioned, there is V6Compatibility module. I think It should be released as separate gem, which can be modified to raise warnings. However I don't even know how can this be done for some deprecations (ex. changing Money.from_amount -> Money.new). So best for me is just to release new major version and provide robust migration guide, which can be prepared with early-adopters.\n@dmitry I don't think it would be right enough to become an owner just to push own changes without community support. Main repo is improved continuously and I hope this PR or something else similar will be merged soon.. @bdewater I'm not sure if this would be merged soon. For now I have money2 gem, and merging money's master in sometimes. Please see https://github.com/RubyMoney/money/pull/619#issuecomment-269368526 for more info.. I'll try soon. @RubyMoney/money-devs does somebody use it and can prove that it should work this way?\n. For the first time I just used keyword arguments to avoid extra code similar to .extract_options!. Later I've added module for v6 compatibility: https://github.com/printercu/money/blob/v7/lib/money/v6_compatibility.rb\nIt uses Module#prepend. However I used this module to change logic & specs in separate commits. We can remove it and add support for 1.9.\n. We can keep support for 1.9 now (removing modules for v6 compatibility: arithmetics, currency symbol's case). But if we would want to drop it later, we'll need to change major version one more time.\n. Notice about ruby 1.9?\nAbout all other incompatibilities. As I said, I've made module for compatibility mode. We can add deprecation warnings there and release it as 6.7.99 (same way as rspec2) so everybody are able to catch deprecations in development.\n. @antstorm wdyt about this pr? Is it interesting to continue dealing with it?\nIf it's hard to review the whole commit, please take a look at separate commits. They just move code around.\n. 1. What do you mean? Split this PR into smaller ones?\n2. This is not full ActiveSupport's class_attribute, It doesn't provide instance accessors. This config methods are used a lot in tests, so it's already tested.\n3. https://github.com/RubyMoney/money/pull/622#issuecomment-203916702\n. 1. Why is it required? I don't think it's necessary.\n2. class attribute's inheritance differs from cattr's. In v6 config methods are using class_attribute-like method, but made with ivars, so it requires .setup_default. class_attribute provides same features without .setup_default. I'll add tests, if everything else is ok.\n3. All deprecations are in this module. We can add deprecations to all of the in a row with instance_methods.each. Indeed there is too much breaking changes, so I'll think about releasing it as a new gem.\n. 1. They inherited, but overwriting in child does not affect parent. Don't think why separate module would be better. Formatter is configured separately from Money now, I think it's better not to mix their options into single configuration.\n2. I'm not planning to continue support backward compatibility. I used it to make old test pass with new code in compatibility mode in first commit, and rewrite tests to pass it without compatibility in next commit to not get errors. We can release it either in separate gem, or as the last version of v6 with deprecation warnings. Or just remove before release. But i don't want to mess with deprecations in other way, because Money.new will just work different at all, and it'll require to update all this calls. So it would be completely different version. If it's not the way the gem supposed to develop in, it'll be really better to continue in a fork.\n. 1. What inheritance problems? What if I want my custom Money class, inherited from Money. Ok, it's uncommon, but custom Formatter is more real. It'll have it's own configuration, with gem's default. class_attribute is much flexible: if value is not overwritten, it'll be inherited from parent even if it was changed in parent. MoneyRails uses class vars, it's ok because MoneyRails is a module, but with classes it can lead to unwanted behaviour: http://stackoverflow.com/a/15773671/1135874\n2. It's related to #619 . Sorry, I thought you remember about it. The main point i want to change is the weirdness of storing cents as a main value, instead of using bigdecimals. It simplifies everything and provides more expectable API.\n. In the first example you get EUR. In the second you will get GBP. What amount do you expect, if you don't have rates for this?\n. I think nobody want that in some cases it'll return different currencies. It's not what is expected: it's looks fine in your example, but what about custom code:\nruby\nmoney_sum = money_eur + money_gbp\nIt's expected that money_sum's currency is EUR. But it'll be GBP sometimes, when money_eur is zero.\n. @textgoeshere i've got no errors:\n2.2.1 (main):0[2] > Money::VERSION\n=> \"6.7.0\"\n2.2.1 (main):0[3] > Money.default_bank\n=> #<Money::Bank::GoogleCurrency:0x007fabc46f3188 @store=#<Money::RatesStore::Memory:0x007fabc46f2f08 @index={}, @options={}, @mutex=#<Mutex:0x007fabc46f2df0>, @in_transaction=false>, @rounding_method=nil>\n2.2.1 (main):0[4] > Money.eur(1) + Money.gbp(0)\n=> #<Money fractional:1.0 currency:EUR>\n2.2.1 (main):0[5] > Money.eur(1) + Money.gbp(1)\n=> #<Money fractional:2.2431 currency:EUR>\n2.2.1 (main):0[6] > Money.gbp(0) + Money.eur(1)\n=> #<Money fractional:0.8045 currency:GBP>\n2.2.1 (main):0[7] > Money.gbp(1) + Money.eur(1)\n=> #<Money fractional:1.8045 currency:GBP>\n. You had an error, because you didn't have rates set. And there is return self if other.zero? in the #+, so you hadn't error when added 0 pounds. I don't think we must raise conversion error in this case, because there is no need in conversion.\nHowever if a lot of people want to prevent such operations maybe the team will add this feature.\nAnyway you can implement this yourself and prepend the module to money:\n``` ruby\nsmth like this\nclass Money\n  module PreventConversion\n    %w(+ - * /).each do |op|\n      define_method(op) do |other|\n        raise 'Nope!' if other.is_a?(Money) && other.currency != currency\n        super\n      end\n    end\n  end\nprepend PreventConversion\nend\n```\n. This seems to be rational. Created pr.\n. Nice catch @antstorm \nready\n. check https://www.google.com/finance/converter?a=1&from=vnd&to=usd I took url from https://github.com/RubyMoney/google_currency/blob/master/lib/money/bank/google_currency.rb#L147\ngoogle can not convert it, so gem too. I think, its because of small amount.\nIt can be fixed in gem, by changing input amount. I'll try it later in few days.\n. @antstorm I thought that we could just increase the amount, but google doesnt return the rate anyway: https://www.google.com/finance/converter?a=1000000&from=vnd&to=usd\nWe need to get info about the api, or find other endpoint.\n. https://developers.google.com/finance/?csw=1 google finance api is deprecated.\nI thought about yahoo, as it is advised here http://stackoverflow.com/a/8391430/1135874 but it also has problem with vnd/usd: http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20yahoo.finance.xchange%20where%20pair%20in%20(%22VNDUSD%22)&env=store://datatables.org/alltableswithkeys\n. google_currency already does it. it caches rates for a specific time. But the problem is that apis doesn't provide vnd/usd rate (google and yahoo too). Maybe we can add option that will enable calculation of inverse rate when specific rate can not be loaded. People will be able to convert, while this is \"unofficial\" rate.\n. There are already a lot of providers: https://github.com/RubyMoney/money#implementations\nI don't know if any of them provides vnd/usd rate. I was picking one for use some time ago, and found that google_currency gives more rates than most of others. As i wrote, i was googling for any other free provider and found yahoo. But it also doesn't return vdn/usd rate.\n. or try to register your own currency https://github.com/RubyMoney/money#currency\n. Yes\n. try\nruby\nMoney.rounding_mode(BigDecimal::ROUND_UP) do\n  (Money.new(219) / 0.9515).round\nend\n. I think it's reasonable. Just to remove this check in #round.\n. I've also found this pr: https://github.com/halostatue/diff-lcs/pull/36 \nThere are warnings in rspec when something is failing.. Yep. rspec-mocks & rspec-expectations.. Seems like it's related to #666.. Can you please explain, what is \"data store\"? Is it money gem related or app specific?. @antstorm I don't think this update is good idea. Imagine following:\nruby\ncurrency = Money::Currency.analyze('some string without currency').first\nMoney.new(100, currency)\nInstead of error, it will return object with default currency. And there can be much more cases when it will lead to bugs. I think @karthikmuralidharan solving his app specific problem. Which can be simply solved by \nruby\ncurrency_code = returned_by_data_store || Money.default_currency. Uh. I see that .new works just like .from_amount in this pr. So it's just inconsistent. I take my words back.. Can you please provide few more backtrace lines? I think 10 more will be enough. There is wtf!! command in pry for this.. You can give a try for my fork: https://github.com/printercu/money , it doesn't depend on that gem.\nIt's released as money2 for now. . Hi! Why don't you want just use money.to_d <=> 0?. There should be also #negative? and #positive? helpers.. I'm not really arguing for anything, but want to share this answer from SO and ruby docs about equality in ruby: https://stackoverflow.com/a/7157051/1135874 , https://ruby-doc.org/core-2.4.1/Object.html#method-i-eql-3F :\n\nThe eql? method returns true if obj and other refer to the same hash key. This is used by Hash to test members for equality. (from docs)\n\nAccording to this I think #eql? should not perform any conversion and assumptions and return true only  if all instance variables are the same.. It was in i18n gem from 0.7.0 https://github.com/svenfuchs/i18n/blob/master/CHANGELOG.md#070\nThe only way money gem can address it is not to use i18n by default. I think it's a better way, as most of projects don't need it, but it'll be breaking change.. I think we should prefer '< 1.0', as 1.0 may bring breaking changes.. This works slightly different. Here is explanation with examples http://guides.rubygems.org/patterns/ in \"Pessimistic version constraint\" section. In a short, it doesn't matter how stable lib is, but if it ever changes major version this may break dependent code.\nP.S. seems like it would be the case some day: money uses raise: true, but here https://github.com/svenfuchs/i18n/blob/efc97ba659c12a5ef1d34b970fb69e9f693e727c/lib/i18n.rb#L157 comment says that this option is going to be deprecated. Of course, this may never happen :). -1\nIt pollutes history/git blame.. @bbozo please consider storing amount or ~~fractional~~ instead of cents. With Money.infinite_precision = true cents will also be fractional and will be stored in json as string. But amount will be more human-readable. There is now .from_amount to construct Money with dollars.\n. Ready.\n. :+1: \n. TLDR; Money::Currency.table[:rub][:symbol] = 'rub'\nHere is full pry listing, how you can get it https://gist.github.com/printercu/022b0ee5bc3db99cd5bc\n. done\n. @jimpo @semmons99 there are warning after this pr was merged:\n~/.rvm/gems/ruby-2.2.1/gems/rspec-expectations-3.2.1/lib/rspec/matchers/built_in/eq.rb:35: warning: Return nil in #<=> if the comparison is inappropriate or avoid such comparison.\n. i've run rspec in gem\n. :+1: \n. I think it's ok to raise UnknownRate. Error will indicate that code is working not as it supposed to. Suppressing such errors (silently or with warnings) is kind of JS/PHP way which is hard to debug.\n. Warnings are still there: https://travis-ci.org/RubyMoney/money/jobs/70629750\n. Hi! Have you tried Money.rounding_mode=?\n. :+1: \n. nice! i just wonder it can be useful to have method to access @@instances for debugging/development.\nIt's not really necessary for me, 'cause of pry. But it's not available sometimes. wdyt?\n. good! everything is fine, but i think we can get extra performance. my comment https://github.com/RubyMoney/money/pull/538#discussion_r34447779 is hidden now, 'cause code've changed. it's about instances[id] || @@mutex.synchronize\n\nCan you please provide example of concurrency? I think while there is ||= inside .synchronize everything should be ok. It would just improve performance by avoiding synchronisation when it's not needed, and synchronising otherwise.\n. Is it a problem? \n\nI'm really feeling uncomfortable to argue about this, because 3x speed up in mri is maybe not so significant in this case. I just wanted to give some advice, how to improve code to be more perfect, while not taking much effort. I think that actions must not be performed, when they are unnecessary, and that's all. \nEverything else is perfect in PR, i think somebody will merge it soon as it is. I just want someone else to look through the code.\n. yeah, i'll merge it\n. :+1: \n@phlegx can you please add spec for it, so somebody wouldn't remove it accidentally later.\n. Hi! It was added in 6.6\n. @poc7667 https://github.com/RubyMoney/money/blob/master/lib/money/money.rb#L228 is it what you want? There is also https://github.com/RubyMoney/monetize gem with more conversions.\n. https://github.com/RubyMoney/money/issues?q=is%3Aissue+from_amount+is%3Aclosed\n. It may depend on bank. What bank do you use? Try to set rates manually, will it give same result?\n. Please try with Money.infinite_precision = true.\n. Seems like it was fixed in 6.6.1.\nruby\n2.2.1 (main):0[2] > Money.new(1, :HKD).exchange_to(:VND)\n=> #<Money fractional:28.844994 currency:VND>\nNote that you need to update google_currency to 3.2.1. But it's not published, you can install it from github.\n@semmons99 can you publish google_currency@3.2.1 ?\n. Exchange rate is not 100 time smaller. When you create with Money.new you should pass amount in cents. Use Money.from_amount to instantiate with amount in dollars.\nThere was a problem with exchange, and i can reproduce same situation with HKD/VND in 6.5.1 now (but not in 6.6.1). If you want prevent cents from truncation, you need to ensure you have right version. You can check #exchange method with pry:\n```\n\nshow-method Money::Bank::VariableExchange#exchange\nFrom: gems/money-6.6.1/lib/money/bank/variable_exchange.rb @ line 127:\nOwner: Money::Bank::VariableExchange\n...\n  else\n    ex.to_s.to_d <<< this must be .to_d, old version has .to_i\n  end\nend\n``\n. Can you please checkMoney.from_amount(100, :HKD).to_d,Money.from_amount(100, :VND).to_d,Money.from_amount(100, :USD).to_d? You can find out what.to_d` returns.\n\nP.S. .to_d is better than .to_f when you work with money, 'cause with .to_f sometimes you can get wrong result while working with fractional part.\n. Why is it wrong? Try .dollars, .cents for Money.from_amount(100, :VND). Seems like VND does not have subunits. Yeah, different methods return same result :). I don't like this design and just use #to_d and .from_amount without all the .dollars, .cents, etc. This methods works with main currency units.\n. you're welcome!\n. :+1:  Maybe this will be helpful https://github.com/rails/rails/blob/master/activesupport/lib/active_support/number_helper/number_to_rounded_converter.rb#L72-L79, you can take regex right from there.\n. Can you please add tests for the define_method stuff? Don't really understand what does it solve. Why do we need to add methods directly into the base? Seems like following works fine (no failed tests)\n``` diff\n-    def self.included(base)\n-      [\n-        [:thousands_separator, :delimiter, \",\"],\n-        [:decimal_mark, :separator, \".\"]\n-      ].each do |method, name, character|\n-        define_i18n_method(method, name, character)\n-      end\n-    end\n-\n     def self.define_i18n_method(method, name, character)\n       define_method(method) do\n         if self.class.use_i18n\n@@ -25,6 +16,14 @@ class Money\n       alias_method name, method\n     end\n\n[\n[:thousands_separator, :delimiter, \",\"],\n[:decimal_mark, :separator, \".\"]\n].each do |method, name, character|\ndefine_i18n_method(method, name, character)\nend\n```\n\nUPD Even simplier\ndiff\n+    define_i18n_method :thousands_separator, :delimiter, ','\n+    define_i18n_method :decimal_mark, :separator, '.'\n. Please don't merge #578 in. This is a quick and dirty but not a good solution. Maybe there is even bug in ruby. There is no 2.3 image in rvm for now, so i'm not able to test it myself.\nHave you tried my solution?\n. Yeah this'll be better :+1: \nSeems like there is really bug in a mri preview version, I'll install and check it.\n. I've opened an issue in ruby tracker https://bugs.ruby-lang.org/issues/11754\nLets first wait for the result.\n. @semmons99 why did you merge it?\nRuby 2.3 is still preview, there may be a bug. Please read conversation in #576. Please consider to revert it.\n. cool :+1: \n. Why is it better to make it private? I think i was using it in some project.\n. I cant find statement you are talking about. Is it this one https://github.com/RubyMoney/money/blob/master/lib/money/currency.rb#L201 ?\n. It's not supposed to hide stringified_keys, its for stringify_keys. And this one is private, 'cause it's inside class << self. Everything seems to be ok. Closing?\n. We can change this only in major release, 'cause it'll break backward compatibility. It's seems to be logical to separate code from iso_code. I think it's even better to replace .iso_code with just .code, but there will be a lot of incompatibility.\nFor now, while there is no decision on this, seems like you can use \nruby\ndef is_iso?\n  !iso_numeric.empty?\nend\n. There is already #code method, and it's a little bit more complex. Somebody may be using it now.\n. My #iso? is hacky. I think iso_numeric should be better int|null, but it's string now. And my solution relies on it. So instead of it i would prefer to change iso_numeric in definitions, and check for !iso_numeric.nil? in #iso?.\n@RubyMoney/money-devs is it ok to change iso_numeric's type (string => [int|null]) in json files?\n. Failure could take place, if exponent is Float (https://github.com/RubyMoney/money#currency-exponent). It's better to use .be_within(0.01).of(3) in spec rather then .round.\n. So should we better round exponent in #exponent method?\n. #607 #606 #605 are related. lets continue conversation in #606 maybe?\n. fixed in #607 \n. Why do we need CoercedNumber? Can we just make all operations commutative with \nruby\n    def coerce(other)\n      [self, other]\n    end\n? Seems like there are all the checks in #<=>, #- and other methods.\nThere is already commit to fix Money#<=>(Numeric) to return nil (https://github.com/RubyMoney/money/commit/377e48f4a09e93a5ef6e861d43cd1abc3bde80b4) but Numeric#<=>(Money) is missing there.\nUPD. Ah, seems like error is just with division. I'll try to get a solution.\n. Take a look at #607 please. wdyt?\n. I've also added support for commutative comparison with 0 to #607.\n. Thanks for testing!\nI think this should be expected behaviour.  Indeed, it's very odd that == doesn't raise error, 'cause it is expected to use the result of <=> same way as >=. I'll check ruby docs and report later.\nUPD. http://ruby-doc.org/core-2.2.2/Comparable.html#method-i-3C-3D\n\nEven if obj <=> other raised an exception, the exception is ignored and [==] returns false.\n\nIt'll be really confusing to have 1.to_money == 1 returning false. I'll fix it.\n. I've thought about the issue and understood why == is different from all other comparison methods and doesn't rise error. The point is that == is expected to work with any other value:\n``` ruby\nmoney = Money.usd(1)\nmoney == [] # false\nmoney == User.first # false\n...\n```\nSo it would be inconsistent if it would rise error just for non-zero numerics.\nI think current behaviour is ok, we just need to add a note to readme. wdyt?\nPS. I was always against implicit typecasting in the case of Money's comparison operators. It supports only 0 for now, and I think #zero?, #positive? & #negative? are just enough (or even single #to_d). Maybe one day we'll be able to deprecate comparison with non-money values.\n. @bryanrite i've pushed fixes in #616 . Let someone take a look on it, and we'll merge.\n. @semmons99 take a look please.\n. What about return fractional <=> 0 if other_money.zero? ? There will be less allocations. \nThere are some issues with commutative operations (#605 #606 #607) and i was fixing them in #607 . I'll add commit to provide commutative comparison (Money > 0, 0 < Money).\n. Got it. Don't really think it's safe enough to allow comparison with numbers, but may be it'll be useful. I hope we can wait someone else's review.\nHowever seems like this way code can be even simpler: return fractional <=> other_money if other_money.is_a?(Numeric)\n. The only place i see where it'll be useful is \nruby\nvalidates_numericality_of :money_field, \n  greater_than: 0, \n  less_than: ->(x) { maximum_in_currency(x) }\nIn any other place it'll be comparison either with 0 or with magic numbers, which should better be replaced with money-object constants. And hope there will be no scenario when single non-zero numeric will be compared to multi-currency money (do_something if money > 53 and money can be usd, cad or eur).\n. In previous git versions push.default was default to matching. So you could overwrite master in main repo when pushed amended commit with --force. If nobody had a copy of recent commits it would be a little tricky to restore master. Though this is not a critical problem, this will never happen if you use your own repo :)\n. Seems like it was a fix: https://github.com/RubyMoney/money/commit/bfa7108e1d085f7518ff979db4b8c9cb1b1b1e3f\nHere is pr #506 \n. @xxswingxx I also don't like the idea to initiate Money with cents. You can use .from_amount instead of .new: Money.from_amount(1.2345, :clf) == Money.new(12345, :clf).\n. Is it supposed to be like this?\n``` ruby\nI18n.locale = 'fr-CA'\nMoney.new(100, :usd) == '$1.00'\nMoney.new(100, :cad) == '1.00$'\n```\nDoes not all other currencies need to be displayed with symbol after value for fr-CA?\n. I'm not sure if this should be done this way. However :decimal_mark and :thousands_separator should be better set from locale file. Maybe :symbol_position can be changed in the same way.\nping @RubyMoney/money-devs in a short: fr-CA locale need to print symbols for all currencies in the end. Is it right place to change it in the localize_formatting_rules? Can this be done other way?\n. There are a lot of locales and many of them may have specific formatting rules. It'll be huge case block if we would be adding every such rule into the code. There also should work the principle of separation code and data. Messing them together isn't good idea.\nIf this is really the case, we should better introduce default locale files with formatting settings for this locales.\n. I've extracted formatting logic to separate class. So it's easy to define custom formatters and switch between them dynamically: https://github.com/printercu/money/blob/v7/lib/money/formatter.rb\nhttps://github.com/printercu/money/blob/v7/lib/money.rb#L369-383\n. @HaleTom yep! I've forgotten about this first. Added commit. I've also changed Currency to use #code.downcase.to_sym as id. So it's not repeated in currency files. However after this YEN & GHC fallbacks are not supported (JPY & GHS should be used instead).\nI'll add #is_iso? later after changing iso_numeric to Int.\n. I thought, nobody was interested in this pr. I can rebase and fix conflicts if you really intend to merge this one :). I've just rebased on master, and added some small commits.\nI've decided to release it as money2 gem for now, as I've been using it for a while in several projects.\nHere is a note I've made to share with others: https://github.com/printercu/money/wiki\nI'll be glad to receive suggestions, PRs or any other feedback.. @antstorm I just want to make it easier to try to move to new version and to give early-adopter's feedback and understand overall reaction. As I said, there are just too much incompatibility, so I really don't have time now to add deprecation warnings all over the code first, and then rebase everything again, while I've already have working v7 code.\nAs I mentioned, there is V6Compatibility module. I think It should be released as separate gem, which can be modified to raise warnings. However I don't even know how can this be done for some deprecations (ex. changing Money.from_amount -> Money.new). So best for me is just to release new major version and provide robust migration guide, which can be prepared with early-adopters.\n@dmitry I don't think it would be right enough to become an owner just to push own changes without community support. Main repo is improved continuously and I hope this PR or something else similar will be merged soon.. @bdewater I'm not sure if this would be merged soon. For now I have money2 gem, and merging money's master in sometimes. Please see https://github.com/RubyMoney/money/pull/619#issuecomment-269368526 for more info.. I'll try soon. @RubyMoney/money-devs does somebody use it and can prove that it should work this way?\n. For the first time I just used keyword arguments to avoid extra code similar to .extract_options!. Later I've added module for v6 compatibility: https://github.com/printercu/money/blob/v7/lib/money/v6_compatibility.rb\nIt uses Module#prepend. However I used this module to change logic & specs in separate commits. We can remove it and add support for 1.9.\n. We can keep support for 1.9 now (removing modules for v6 compatibility: arithmetics, currency symbol's case). But if we would want to drop it later, we'll need to change major version one more time.\n. Notice about ruby 1.9?\nAbout all other incompatibilities. As I said, I've made module for compatibility mode. We can add deprecation warnings there and release it as 6.7.99 (same way as rspec2) so everybody are able to catch deprecations in development.\n. @antstorm wdyt about this pr? Is it interesting to continue dealing with it?\nIf it's hard to review the whole commit, please take a look at separate commits. They just move code around.\n. 1. What do you mean? Split this PR into smaller ones?\n2. This is not full ActiveSupport's class_attribute, It doesn't provide instance accessors. This config methods are used a lot in tests, so it's already tested.\n3. https://github.com/RubyMoney/money/pull/622#issuecomment-203916702\n. 1. Why is it required? I don't think it's necessary.\n2. class attribute's inheritance differs from cattr's. In v6 config methods are using class_attribute-like method, but made with ivars, so it requires .setup_default. class_attribute provides same features without .setup_default. I'll add tests, if everything else is ok.\n3. All deprecations are in this module. We can add deprecations to all of the in a row with instance_methods.each. Indeed there is too much breaking changes, so I'll think about releasing it as a new gem.\n. 1. They inherited, but overwriting in child does not affect parent. Don't think why separate module would be better. Formatter is configured separately from Money now, I think it's better not to mix their options into single configuration.\n2. I'm not planning to continue support backward compatibility. I used it to make old test pass with new code in compatibility mode in first commit, and rewrite tests to pass it without compatibility in next commit to not get errors. We can release it either in separate gem, or as the last version of v6 with deprecation warnings. Or just remove before release. But i don't want to mess with deprecations in other way, because Money.new will just work different at all, and it'll require to update all this calls. So it would be completely different version. If it's not the way the gem supposed to develop in, it'll be really better to continue in a fork.\n. 1. What inheritance problems? What if I want my custom Money class, inherited from Money. Ok, it's uncommon, but custom Formatter is more real. It'll have it's own configuration, with gem's default. class_attribute is much flexible: if value is not overwritten, it'll be inherited from parent even if it was changed in parent. MoneyRails uses class vars, it's ok because MoneyRails is a module, but with classes it can lead to unwanted behaviour: http://stackoverflow.com/a/15773671/1135874\n2. It's related to #619 . Sorry, I thought you remember about it. The main point i want to change is the weirdness of storing cents as a main value, instead of using bigdecimals. It simplifies everything and provides more expectable API.\n. In the first example you get EUR. In the second you will get GBP. What amount do you expect, if you don't have rates for this?\n. I think nobody want that in some cases it'll return different currencies. It's not what is expected: it's looks fine in your example, but what about custom code:\nruby\nmoney_sum = money_eur + money_gbp\nIt's expected that money_sum's currency is EUR. But it'll be GBP sometimes, when money_eur is zero.\n. @textgoeshere i've got no errors:\n2.2.1 (main):0[2] > Money::VERSION\n=> \"6.7.0\"\n2.2.1 (main):0[3] > Money.default_bank\n=> #<Money::Bank::GoogleCurrency:0x007fabc46f3188 @store=#<Money::RatesStore::Memory:0x007fabc46f2f08 @index={}, @options={}, @mutex=#<Mutex:0x007fabc46f2df0>, @in_transaction=false>, @rounding_method=nil>\n2.2.1 (main):0[4] > Money.eur(1) + Money.gbp(0)\n=> #<Money fractional:1.0 currency:EUR>\n2.2.1 (main):0[5] > Money.eur(1) + Money.gbp(1)\n=> #<Money fractional:2.2431 currency:EUR>\n2.2.1 (main):0[6] > Money.gbp(0) + Money.eur(1)\n=> #<Money fractional:0.8045 currency:GBP>\n2.2.1 (main):0[7] > Money.gbp(1) + Money.eur(1)\n=> #<Money fractional:1.8045 currency:GBP>\n. You had an error, because you didn't have rates set. And there is return self if other.zero? in the #+, so you hadn't error when added 0 pounds. I don't think we must raise conversion error in this case, because there is no need in conversion.\nHowever if a lot of people want to prevent such operations maybe the team will add this feature.\nAnyway you can implement this yourself and prepend the module to money:\n``` ruby\nsmth like this\nclass Money\n  module PreventConversion\n    %w(+ - * /).each do |op|\n      define_method(op) do |other|\n        raise 'Nope!' if other.is_a?(Money) && other.currency != currency\n        super\n      end\n    end\n  end\nprepend PreventConversion\nend\n```\n. This seems to be rational. Created pr.\n. Nice catch @antstorm \nready\n. check https://www.google.com/finance/converter?a=1&from=vnd&to=usd I took url from https://github.com/RubyMoney/google_currency/blob/master/lib/money/bank/google_currency.rb#L147\ngoogle can not convert it, so gem too. I think, its because of small amount.\nIt can be fixed in gem, by changing input amount. I'll try it later in few days.\n. @antstorm I thought that we could just increase the amount, but google doesnt return the rate anyway: https://www.google.com/finance/converter?a=1000000&from=vnd&to=usd\nWe need to get info about the api, or find other endpoint.\n. https://developers.google.com/finance/?csw=1 google finance api is deprecated.\nI thought about yahoo, as it is advised here http://stackoverflow.com/a/8391430/1135874 but it also has problem with vnd/usd: http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20yahoo.finance.xchange%20where%20pair%20in%20(%22VNDUSD%22)&env=store://datatables.org/alltableswithkeys\n. google_currency already does it. it caches rates for a specific time. But the problem is that apis doesn't provide vnd/usd rate (google and yahoo too). Maybe we can add option that will enable calculation of inverse rate when specific rate can not be loaded. People will be able to convert, while this is \"unofficial\" rate.\n. There are already a lot of providers: https://github.com/RubyMoney/money#implementations\nI don't know if any of them provides vnd/usd rate. I was picking one for use some time ago, and found that google_currency gives more rates than most of others. As i wrote, i was googling for any other free provider and found yahoo. But it also doesn't return vdn/usd rate.\n. or try to register your own currency https://github.com/RubyMoney/money#currency\n. Yes\n. try\nruby\nMoney.rounding_mode(BigDecimal::ROUND_UP) do\n  (Money.new(219) / 0.9515).round\nend\n. I think it's reasonable. Just to remove this check in #round.\n. I've also found this pr: https://github.com/halostatue/diff-lcs/pull/36 \nThere are warnings in rspec when something is failing.. Yep. rspec-mocks & rspec-expectations.. Seems like it's related to #666.. Can you please explain, what is \"data store\"? Is it money gem related or app specific?. @antstorm I don't think this update is good idea. Imagine following:\nruby\ncurrency = Money::Currency.analyze('some string without currency').first\nMoney.new(100, currency)\nInstead of error, it will return object with default currency. And there can be much more cases when it will lead to bugs. I think @karthikmuralidharan solving his app specific problem. Which can be simply solved by \nruby\ncurrency_code = returned_by_data_store || Money.default_currency. Uh. I see that .new works just like .from_amount in this pr. So it's just inconsistent. I take my words back.. Can you please provide few more backtrace lines? I think 10 more will be enough. There is wtf!! command in pry for this.. You can give a try for my fork: https://github.com/printercu/money , it doesn't depend on that gem.\nIt's released as money2 for now. . Hi! Why don't you want just use money.to_d <=> 0?. There should be also #negative? and #positive? helpers.. I'm not really arguing for anything, but want to share this answer from SO and ruby docs about equality in ruby: https://stackoverflow.com/a/7157051/1135874 , https://ruby-doc.org/core-2.4.1/Object.html#method-i-eql-3F :\n\nThe eql? method returns true if obj and other refer to the same hash key. This is used by Hash to test members for equality. (from docs)\n\nAccording to this I think #eql? should not perform any conversion and assumptions and return true only  if all instance variables are the same.. It was in i18n gem from 0.7.0 https://github.com/svenfuchs/i18n/blob/master/CHANGELOG.md#070\nThe only way money gem can address it is not to use i18n by default. I think it's a better way, as most of projects don't need it, but it'll be breaking change.. I think we should prefer '< 1.0', as 1.0 may bring breaking changes.. This works slightly different. Here is explanation with examples http://guides.rubygems.org/patterns/ in \"Pessimistic version constraint\" section. In a short, it doesn't matter how stable lib is, but if it ever changes major version this may break dependent code.\nP.S. seems like it would be the case some day: money uses raise: true, but here https://github.com/svenfuchs/i18n/blob/efc97ba659c12a5ef1d34b970fb69e9f693e727c/lib/i18n.rb#L157 comment says that this option is going to be deprecated. Of course, this may never happen :). -1\nIt pollutes history/git blame.. ",
    "itspanzi": "Hello Mike,\nThanks for the quick response.\nCan you please check the Unicode section in the Wikipedia page? It seems to have both the Unicode character and the HTML entity. Is that not the right one?\n. Sure. Will send a pull request soon :) Thanks!\n. I have just sent you a pull request. Can you please review it and accept it.\n. Oops! Sorry, I was sloppy.\n. Hello Mike,\nThanks for the quick response.\nCan you please check the Unicode section in the Wikipedia page? It seems to have both the Unicode character and the HTML entity. Is that not the right one?\n. Sure. Will send a pull request soon :) Thanks!\n. I have just sent you a pull request. Can you please review it and accept it.\n. Oops! Sorry, I was sloppy.\n. ",
    "adiel": "@semmons99 Rebased, you should be good to go.\n. @semmons99 Rebased, you should be good to go.\n. ",
    "9mm": "@semmons99 It's actually not in the main docs, it took me forever to find how to do this. This is a really common issue so I think it should be featured prominently in the main readme (how to convert from a dollar amount vs a cents amount). A lot of payment API's for instance require floats, so its common to convert that back to cents in the internal DB.. Bugger... I see it now (it's hidden in the from_amount section, the key part being the comparison operator showing how its converting a dollar amount and not a cents amount).. @semmons99 It's actually not in the main docs, it took me forever to find how to do this. This is a really common issue so I think it should be featured prominently in the main readme (how to convert from a dollar amount vs a cents amount). A lot of payment API's for instance require floats, so its common to convert that back to cents in the internal DB.. Bugger... I see it now (it's hidden in the from_amount section, the key part being the comparison operator showing how its converting a dollar amount and not a cents amount).. ",
    "antstorm": "@9mm it's a very common misconception, I feel like it deserves it's own short section in the README. Happy to accept your PR if you're up for it.. @timpalander sure is planned! I'll have a look, btw you are also very welcome to submit a PR :). @RubyMoney/money-rails-devs any thoughts on this one?\n. @ct-clearhaus yeah, didn't notice that. Will read through that PR and see what needs to be changed to merge it.\n. @takiy33 I've also encountered the same problem. Here's a PR that should fix the issue  \u2014 #537.\n. @printercu I've updated the PR, can you please take another look. I went for the pure class variable, because Ruby doesn't have cattr_accessor.\n. @printercu I've added a method for easier debugging/development access to instances. Also added a test to make sure @@instances are used.\n. @printercu If you request the same uninitialized currency from 2 different threads you might end with one thread initializing a new currency inside the synchronize, while other thread will result in checking the instances variable twice. Since MRI has GIL that won't even make a difference. In jruby & rbx if there's a mutex lock, you'll end up checking instances twice.\n. @printercu I did some benchmarking and you're right, this gives us like 15% performance boost, which is really good. I've updated the commit.\n. @ggilder, @printercu is this good to go?\n. Well first of all, you shouldn't be doing that. It's a view helper for a reason.\nBut if you still feel adventurous, try ActionView::Base.money_without_cents\n. Good spot, thanks!\n. Judging by the output only 2 float exponents are MGA and MRO, but Wiki says:\n\nSo I guess it's safe to .round the result of that method (inside the method, not test, we want consistency across different interpreters) as it should be int.\nAlso the description of exponent method looks completely off.\n. #606 was resolved and Money.new(1) > 0 works fine in the latest release. I'm closing this issue.\n. Just reviewed and merged #616, we should push the new version out\n. @kayzee sorry for a late reminder, but the new version (6.7.1) is released.\n. Looks like with 2 PRs above merged this issues should be fixed. Feel free to open a new one in case something is still not right.\n. @kernow I'll put together a release this week, there are no major changes in there, so probably gonna be 6.7.1\n. @kernow 6.7.1 is now available on RubyGems\n. Nice one, thanks, @tonyta!\n. That looks really good, couple of comments:\n1. I'd suggest splitting each test into 2 separate ones, because they kinda handle different cases\n2. That might be an intended behaviour, but still \u2014 why the decimal mark isn't used in ISK example? Shouldn't that be 300.000,00?\n. @cade got it, my mistake, wasn't familiar with th \"ISK\" currency. Can you please squash your commits into one and I'll me happy to merge it.\n. Also thumbs up for a very well described PR! :+1:\n. Nice one!\nBtw, can you please use your own fork in the future, thanks!\n. I'd say it's just a good practice, plus that way all the contributors are equal and everybody goes through the same reviewing process. And commit access is for being able to merge other people's commits once you're happy with them, thus speeding up the PR's life cycle.\nBut that's just my understanding of how things are around here plus, like I said, it's a good practice. Maybe @semmons99 can elaborate on that a bit more.\n. Well, here are some of the reasons why fork model is better:\n- As @printercu mentioned, it prevents accidents like overriding master, force pushing to co-owned branches and affecting someone else's branches\n- It's clear that these are your branches and should be managed only by you\n- It keeps the main repo clean \u2014 no abandoned or work-in-progress branches, that aren't meant for others to use\nI guess it's not as black and white as one might wish :) Another slightly more vague argument is that main repo might use branches (and some very often do) to support and manage different gem's versions and mixing that with bugfix/feature branches makes it harder for others to explore.\n. @adrianov yes, I don't see a reason (apart from people simply not using them) why these should not be included. I'm happy to accept a PR with these.\n. Thank you for the PR, closing this one.\n. Judging by the article on wiki, CLF has an exponent of 4, making the Money 6.6 example legit. I guess because of such a high exponent these are not being used in day-to-day trade.\n. From the same article it also seems that Chile has 2 different currencies \u2014 CLF and CLP, which is quite odd.\n. @r11runner thanks!\n. @printercu that's looking good, merging!\n. @deepredsky yeah, that's absolutely right, it should be easily customisable only using default as a fallback\n. @otagi while it makes sense, it's important to remember that number_to_currency is part of ActionView, which is of course part of Rails. And money gem does not depend on it\u2026 although this can definitely be added to money-rails which bridges that gap.\n. @printercu great work! My suggestion is to create another branch and opening separate PRs (which can be reviewed individually) against that branch. Otherwise this is now becoming pretty much unreviewable\n. @printercu still not sure why you decided to release it separately, I though that you didn't have time or something. We were really close to merging #622.. @printercu let's actually make this happen. I've created a new branch v7_new, can you please split your changes into smaller PRs and open them against that branch? I'll review everything and we'll merge it.. @printercu thanks, ping me if you need any help with that. That definitely looks wrong and should be [-4, -3]\n. @printercu any particular reason for dropping 1.9 support?\n. I just thought that some sort of a deprecation notice might be good before actually dropping support. At least it's a good practise.\n. @printercu yes, absolutely, money.rb became bloated with features and splitting it out into different modules is a really good refactoring. I'll take a closer look at each of the commits later today.\n. Sorry for a delay, here are a few comments:\n1. It's worth breaking this PR down to smaller parts related in logic, like \u2014 extracting things into their own classes, refactoring few parts and then removing bits\n2. Newly introduced class_attribute method needs tests around it. Also it seems to be allowing changing config per Money instance and I'm not sure about this. Feels like it should be cattr_accessor-based. Would like to hear your thoughts on this.\n3. Removing currency_as_string requires deprecation first\n. 1. Yes, there's a lot of stuff going on in this PR apart from just moving things around\n2. In case there's no instance access, how's it different from ruby's cattr_accessor? I'm also in favour of unit-testing everything.\n3. Yes, but we need a PR with that deprecation, otherwise it's going to be hard to keep track of things to be deprecated\n. 1. It's not required, but it is the reason why we are having 3 separate threads in this conversation :)\n2. So they don't get inherited? Is that something we need to worry about? If yes, then maybe configuration should live in it's own module/class that people won't need to inherit from?\n3. If we're dropping these features then there should be no backwards compatibility, otherwise we are burdening ourselves with maintaining legacy support.\n. 1. My argument for separate module is separation of concerns, plus it's not uncommon to do that. money-rails uses a MoneyRails::Configuration module, for example, so there's no inheritance issues and all settings along with their default live in a separate place.\n2. I'm afraid I'm not sure what you're talking about here. I guess you are referring to the code outside of this PR, because I don't see how this PR changes Money.new behaviour. Do you think it would be more productive to get on a hangout and make sure we're on the same page?\n. 1. Because it's uncommon introducing functionality that doesn't have a use-case for it feel wrong. Although if you insist \u2014 let's go with that, but please add unit tests for those methods.\n2. Right, got it\u2026 let's have another discussion on that topic. Meanwhile can you exclude #currency_as_string removal from this PR and include it in another with the backwards compatibility/deprecation warning.\n. I'd suggest combining + and - methods together, because they're really similar. Maybe generate them dynamically\n. Nice one, @printercu, thank you!\n. Nice one! Coveralls report seems inappropriate in this case, merging it\n. @invidian the link works for me. I guess there was something wrong with it when you checked.\n. No worries, mate!\n. @netmask looking good, thanks!\n. @seongreen looks legit! Can you please put it before the BYR in order to keep alphabetical order?\n. @seongreen Can you also squash these 2 commits into one?\n. Hmm\u2026 that looks really odd, are you in sync with master?\n. @seongreen it kinda looks like GitHub's acting up, can you try reopening your PR?\n. @seongreen have you given up on this one? :)\n. @seongreen oh, right, I see that. I wonder why GitHub still showed a proper diff\u2026\n. @naps62 thank you, good spot!\n. @printercu do you think we should handle that error better on our side?\n. @victormartinezsimon yeah, that actually looks like a problem with Google's converter, because simply googling \"1 VND in USD\" gives the right result\n. @printercu yeah, something definitely wrong with their API, I get errors when trying to convert VND to most popular currencies, some other work though.\nSeems like finding other endpoint might be a good solution. But as far as I understand google_currency is not a dependency.\n. Right\u2026 should we write something that just gets all the rates caches them for a couple of hours and does conversion on it's own? At least that way we can always swap the rates provider easily, not relying on specifics of a 3rd party API.\n. In case it's just caching rates \u2014 should we swap the provider? I mean reverse rates might be quite a bit off, rendering them pretty much useless.\n. Here are my finding on this \u2014 https://github.com/RubyMoney/google_currency/pull/48\nAlso this issue is not related to money gem, please add your comments to the PR above.\n. @ajahongir thanks for the fix! Please note that AUTHORS and CHANGELOG.md will be updated by maintainers before the next release. Can you please remove these changes from your commit? I will merge it right after that.\n. @ajahongir great! Just a quick question \u2014 shouldn't it be \u0441\u045e\u043c (with that thingie above y, according to wiki) in Cyrillic?\n. @ajahongir nice one, thank you!\n. Money.rounding_mode = BigDecimal::ROUND_DOWN\n. Oh, you've already found it, great!\n. @ajahongir I don't think there is, alternate_symbols is not really used apart from currencies_by_symbol lookup.\n. Is there a case when symbol doesn't exist?\n. @yenshirak great, thank you! Merging\n. @rubemz thanks for the PR, but it should already be doing that. .find calls .new which does _instances[id] || @@mutex.synchronize { _instances[id] ||= super }.\n. @rubemz sure thing, no worries!\n. @bsylvain I don't think there is, so you might wanna create your own helper that formats it the way you want\n. @printercu very good point! Btw, I wonder if alternate_symbols are only for lookups?\n. @lulalala got a good look at what's happening here and I've got a couple of concerns:\n1. Using .round is not obvious for some people, especially since Money will mask actual @fractional value when calling .fractional. So removing the check for infinite_precision from round method would definitely work it feels like patching rather then solving a problem.\n2. How about storing the rounding_mode in an instance of Money in case it was overriden? It kinda makes sense since it's only used for output. That way we've both got precise BigDecimal and can generate rounded value.\n. @chessbyte it's properly hidden, but it is MIT, like @ct-clearhaus pointed out ^\n. @sergio-ocon but the LICENSE file contains valid copy of MIT license\n. Works for me! Thank you, @epidemian!\n. @epidemian btw, next time you open a PR, try doing that from your own fork & branch ;)\n. Oh wow, didn't know that. No worries, mate, all good! :)\n. Looking good! Might be worth adding network error handling to your gem, but it works.\n. @n0rmanc these settings should be based on your locale, not the currency, but it should still work. Please make sure that you don't have this redefined in i18n.\n. @mcnelson what about the I18n section? Although it uses a delimiter keyword it has the same meaning.\n. Yes, exactly, because it should really be determined by locale rather than a currency.\n. We've got some discussions going on this topic and it seems like the logical approach is to use I18n locale here. Hence the inconsistency with the documentation.\nHere's an example \u2014 in Spain official currency is EUR with , is used as decimal separator and . as thousands separator. But that doesn't mean that all the EUR using countries are following the same formatting rules. Moreover Spanish would use the same formatting rules for other currencies.\n. @mcnelson don't think there's one, but it was touched upon here and there, so I'm happy to keep this one or maybe start a new one on that particular issue\n. @prokopsimek do you have use_i18n enabled?. @prokopsimek it should be on by default, maybe something overrides that. Great work, @we138. Can you please remove that extra indent and I'll merge this.\n. @we138 nice one, thanks!\n. @jdatti thanks, looks legit! I've restarted the failed CI build. Once it's green I'll merge it.\n. @jdatti it seems like there's something wrong with bundling the gems. I'll check what's wrong with it and then merge your PR. Thanks again!\n. Agree with @epidemian's comment, otherwise looks good.\n. @Funfun great! I'd also like to suggest a better name for FORMAT_IMPORTERS since they do both importing and exporting. How about FORMAT_SERIALIZERS? Should make it a bit more clear. Otherwise happy to merge it.\n. @Funfun any ideas why jruby tests are failing? Seems like something to do with thread safety\u2026\n. @Funfun perfect, thanks!\n. @MiguelBel thanks for the PR, looking good. Can you please squash it into a single commit while I fix the issues with ruby 1.9.3?\n. \ud83d\udc4d \n. @yukihariguchi thanks for the PR, looks legit from what I can tell. Do you have any examples of this? Wiki or any other resource?\nAlso, CHANGELOG and AUTHORS is updated when releasing a new version, so can you please drop that last commit?\n. @alexdunae that's a really good catch, thanks. I've implemented a fix for this scenario ^\n. @alexdunae thanks, mate! I've merged the PR, so if you could point your Gemfile to the master you should get that behaviour. I'll release it later together with other fixes.\n. I think this one's resolved, closing. Feel free to reopen or open a new one if you have any further questions.\n. @phlegx good point, it does look like a bug. Seems like you're loosing precision when performing the multiplication operation. I think it's because you're hitting some kind of limit, probably there's a non-BigDecimal value used somewhere in the chain of operations. I'll take a look into it.\nBtw, Is that a real use case? :)\n. @phlegx yeah, that .to_f is the likely candidate, although calculate_fractional method looks dodgy as well\n. @phlegx the issue with it is that Money#fractional already uses a BigDecimal underneath. And I'm not sure why is BigDecimal used for subunit_to_unit, because these are FixNums\u2026\n. @phlegx yeah, thanks for the tip. I've opened a PR ^ Will merge once tests are all green\n. As for the converting everything to BigDecimal \u2014 @fractional is already a BigDecimal even if you don't use infinite_precision it's just a matter of exposing access to it and using it for all operations in order to not loose precision along the way.\n. @jororusev good spot. Can you please open a PR for this change?\n. @jororusev this should now be fixed\n. @rodolfospalenza sorry for a delay, just got back from a holiday.\nThis is a very good looking PR, but one immediate concern is that this resembles the Money#allocate method with difference being that you are always splitting into equal parts rather than providing the custom splits. While I think there's a place for both approaches \u2014 they by all means should use the same API underneath.\n. @kaspernj yeah, that's definitely a good addition. Do all the exchanges provide this information?\n. @kaspernj yeah, so it has to be optional and warn user whenever trying to get that data from unsupported exchange.\nfixer.io definitely looks like a good addition to the list of exchanges.\n. @kaspernj since it's up to the developer to decide whether to use it or not I think we should be loud and clear that their exchange doesn't support it. That shouldn't be a problem.\nIn terms of backwards compatibility \u2014 that also should be ok, because args hash is optional is shouldn't change the footprint of the method. It also might be a good idea to have another method that gets rates at a specified date, which defaults to now.\nI'm fine with it being a [WIP], will squash it before merging.\n. Looking good! The failing test seems unrelated. I'll fix that for master and merge this one\n. @spk thanks! I'll merge this, but we need to keep an eye on RVM/Travis resolving that issue.\n. @project-eutopia It's ready to be merged now, thank you for contributing!\nAs for the CONTRIBUTING \u2014 I will update it, otherwise it's a bit confusing. I usually run something like git shortlog -s | awk '{ print $2 \" \" $3 }' > AUTHORS before releasing a new version, so that everyone's mentioned.\n. @guilleiguaran Looks good, thanks!\n. @Fryie that's really worth speeding up, thanks for pointing this out. I'm not sure if there's an alternative, but I will dig around a bit to see if there are any quick wins here.. @Fryie after a quick round of profiling \u2014 disabling i18n does bring the performance to a factor of about 10. Here's an example:\nMoney.use_i18n = false\nres = Benchmark.measure do\n  100_000.times do\n    Money.euro(250).format\n  end\nend\nputs res\n=>  4.430000   0.060000   4.490000 (  4.487014). In my experience it's always better to do all the calculations in BigDecimal (which is what fractional is stored in) and convert to Float or any other type only when you have to. That way you don't have to round things along the way, keeping value with max precision.. @kernow so you are handling rounding as you go, right?. @kernow it is much easier, no doubts. It's just really important to avoid intermediary rounding, which can accumulate error in your result. @danielricecodes yeah, absolutely, a really good answer, thanks!\nOne thing I'd like to add is that you can use infinite_precision to achieve a similar result, but you'll have to handle rounding on your own.. Looks good, thanks!. @catalin88 it seems like something's is overriding the default formatting rules, most likely your locale. Following exactly the same steps I get:\n```ruby\n\n\nMoney.default_formatting_rules\n=> {:sign_before_symbol=>true, :symbol_position=>:after}\nm = Money.new(1234, \"RON\")\n=> #\nm.format\n=> \"12,34 Lei\"\n``. Sure, no problem!. @pda good catch, thanks!. @printercudiff-lcsbeing a dependency ofrspec?. @printercu got it, will bump these up as soon as that PR is merged. @Nerian good work, can you please rebase it againstruby-2-4-0branch and re-open (or edit) your PR against that branch?. @Nerian thanks!. @orien good catch, a quick solution here is to avoid freezing of the object. I'll think of the better solution for this.. Here's a fix \u2014 #676 . @orien yeah, don't think it will since it's a pretty standard practise and this method is well tested.. @orien you're right, good spot. That's probably why I used instance variable in the first place\u2026 I guess the wholeFormatting` part needs a proper refactoring, possibly being processed in a separate class, instantiated whenever needed.. @Azdaroth judging by the ISO 4217 (https://en.wikipedia.org/wiki/ISO_4217), HUF still has an exponent of 2. It might as well be out of date and probably needs updating, which I'm happy to accept in form of a PR.\n\n\nAs for the rounding, and the fact that 1 Ft can still potentially be used \u2014 there's a smallest_denomination option, which is already set to 5 for HUF. Meaning that you can do:\nruby\nirb(main):003:0> Money.new 9_99, 'HUF'\n=> #<Money fractional:999 currency:HUF>\nirb(main):004:0> _.round_to_nearest_cash_value\n=> 1000\nSo I guess it's just the exponent part that needs fixing.. @hiepph you are probably right, most of the currencies weren't added by people who are using them and there's very little info online on how the currency format, so I'm happy to accept a PR with this change.. @Azdaroth thanks!. @karthikmuralidharan the change looks good to me, but could you please add a test case for it?. @printercu yep, that's exactly why this is ok \u2014 consistency.\nYour earlier comment also makes perfect sense. Would be great to be able to distinguish between currency not provided and nil currency cases.. @karthikmuralidharan yeah, makes sense to me, thank you!. Good shout @varg90, you wanna open a PR for this?. The fix is merged now. Looking good, thank you @komba !. @ricardopacheco any chance of getting the stacktrace? Or have you solved the issue?. @ricardopacheco glad you've solved it!. @stereobooster that's a really good point, I'll extract it out into it's own gem. @tobypinder thanks for pointing that out, I'll have the new version released today. New version (6.8.2) should now be available \u2014 https://rubygems.org/gems/money. @stereobooster thanks for helping out with this. Looking good. Hopefully it's not a massive breaking change, so we can squeeze it in before v2.\nAlso we need a gem in place to merge this and a entry in README.\nI wonder if it's worth deprecating this functionality before throwing it away\u2026. @stereobooster can you please push the code for heuristics gem to https://github.com/RubyMoney/money-heuristics?. @stereobooster sorry, I've pushed a README so you can fork it now.\n. @stereobooster thanks for doing this!. Yes, but we need to make sure money-heuristics is ready in order to do that. @livedo thanks for the PR! So the only thing that's holding me from merging this is the fact that GBX is not listed in ISO 4217, although I see how it can be useful in certain scenarios.\nBut I guess there's no harm in having it. @dilumn we can speed up the release if that's important for you, no problem.\nAs for the issue \u2014 can you copy an example that you're using and output for it?. version 6.8.3 is now released with this change \u2014 https://rubygems.org/gems/money. No problem, @dilumn !. @archana-juvo thank you for contributing!. This is a really interesting idea! I would say it is outside of scope, but I can definitely think of a couple of changes to this project allowing for an easier implementation of this feature. Things like a pluggable Formatter and maybe money-i18n with a database of translations.. Yes, that's pretty much what I was thinking! Maybe include helper methods within the context of a proc allowing for easier formatting. As far as I understand most of the formatting consist of re-arranging static parts.. @maltoe you're right, but these things change much more often since the original list unfortunately wasn't created according to the ISO-4217. Releasing a major version every time it happens will get us to version 100 sooner than you think :)\nThere needs to be a better way of handling this. Maybe by specifying version in which that particular currency has changed and providing means to migrate data easier.\nAs for the fix itself I'd suggest going through your dataset and diving your cents by 100 for all affected currencies. Another solution is registering a new currency with old settings using Money::Currency.register.. That's a great catch! I'm quite surprised that it works that way though. @orien yes, the snippet you've posted was exactly what I had in mind. The question I'm trying to answer here is whether these two method were intended to have differences or was it a side effect of a code duplication. In case its the former \u2014 I'd suggest renaming one of the implementations to something more intention revealing (probably the version with currncy conversion).. Sorry for a delay, just got back after taking some time off.\nEverything that you've said makes perfect sense, I didn't know there's Object#eql? method. So as per your last example \u2014 should eql? be treated as Object equality without any additions? That leaves us with the set of rules:\n\neql? returns true only if both fraction and currency are equal\n== first checks eql? then returns true if both objects are zero? or can be exchange to the same currency and then compared\u2026\n\nWDYT? Trying to figure out what's right here\u2026 somehow extracting comparison with exchange into a separate method feels right, otherwise innocent == might result in a network call depending on your Rates backend\u2026. @orien while I agree that breaking things for others is bad and should be avoided if possible \u2014 I don't think that should stop us from doing what's right and this is what we're trying to figure out here. \n@printercu has a really good point here and I think it aligns best with what docs say about eql?.. @orien yes and it feels to me that altering the behaviour of eql? (by removing special treatment for zeros on both sides) is the way to go here. While altering hash is also a solution, it might cause some really unexpected results like both Money.new(0, 'USD') and Money.new(0, 'AUD') referencing the same entry in a Hash. Here's an example:\n```ruby\n\n\nm1 = Money.new(0, 'USD')\nm2 = Money.new(0, 'AUD')\na = {}\na[m1] = 1\na[m2] = 2\na #=> {#=>2}\n```\n\n\nThis happens when using fractional.hash as a result for Money#hash when fractional is zero. Hope that makes sense.. @orien great. I believe we're in an agreement now and can work to merge this PR :). @orien yes, that's exactly right. I assume the fix for eql? can be part of a different PR.. Thank you, @orien!. @RomainGoncalves sorry for a delay. In case you still haven't figured it out:\nirb(main):003:0> Money.rounding_mode = BigDecimal::ROUND_HALF_UP\n=> 3\nirb(main):004:0> Money.from_amount 1019.125\n=> #<Money fractional:101913 currency:USD>\nThe default rounding mode is BigDecimal::ROUND_HALF_EVEN, which rounds towards the nearest neighbor, unless both neighbors are equidistant, in which case round towards the even neighbor (Banker\u2019s rounding).. @dipaktc looks like your error originates in money-currencylayer-bank (which is not part of RubyMoney org), so I'd suggest raising this question in that repo instead.. @emmanuelmillionaer money already comes with decimal_mark defined for each currency. In case you need to customise it further you can write your own method which figures out the right decimal_mark for the given currency and calls money.format with decimal_mark: your_calculated_decimal_mark.\nBtw, what are your requirements for this? I'm looking into switching away from decimal_mark based on currency and base it on locale instead, which I think makes much more sense.. Currently Satoshi is recorded as a subunit of Bitcoin, which is part of the non-ISO currencies. Have a look here:\n\"btc\": {\n    \"priority\": 100,\n    \"iso_code\": \"BTC\",\n    \"name\": \"Bitcoin\",\n    \"symbol\": \"B\u20e6\",\n    \"alternate_symbols\": [],\n    \"subunit\": \"Satoshi\",\n    \"subunit_to_unit\": 100000000,\n    \"symbol_first\": true,\n    \"html_entity\": \"\",\n    \"decimal_mark\": \".\",\n    \"thousands_separator\": \",\",\n    \"iso_numeric\": \"\",\n    \"smallest_denomination\": 1\n  }. @Titinux you're absolutely right, this thought has been circulating around for some time now. I think it's time to drop this and delegate to number_to_currency with the correct currency symbol.. @kschutt thank you for spotting this!. @rajdeep26 great spot. It's an issue with Monetize which was using the wrong rounding mode. Here's a PR that fixes it \u2014 https://github.com/RubyMoney/monetize/pull/101. You might need to rebase that against the master first\u2026. @samnissen I'm not exactly sure how's that gonna impact existing users. It seems like newer Rails versions default to true as well. We might wanna just update the example to include this line if that's what you are worried about.. @printercu I think you're right and we can align this change with removing currency-based formatting in favor of I18n locale-based formatting, which I think it already does a great job of.. @Liy0 good spot! Do you want to open a PR for this change? I'm happy to review and merge it. @stanley90 sure, do you want to open a PR?. Thank you for finding and fixing it!. @ct-clearhaus thanks for additional info! I think it makes sense to leave it as it is then. What about the name of the subunit?. @ianmurrays @ct-clearhaus thanks a lot for your input guys!. @Nerian thanks!. I agree with both @ct-clearhaus and @printercu here. This PR has very little value on it's own.. @alexdunae so the error message is definitely odd and can be improved.\nAs for the comparing to zero money \u2014 what is the use case for doing this comparison? There's a .positive? method for checking whether the amount is positive. Normally you'd be comparing 2 Money objects with values coming from external source (like a DB or API) and in this case it's be weird if in some cases (when one of them is 0) you get a result and other times the error is raised.. Yeah, I hear you. It's just that you can either make it strict and have developers implement all these things themselves or you can go super flexible but that means it's going to be unsafe in same cases. So we're kinda trying to stay in the middle providing some flexibility but not pushing it all the way.\nBasically Money.zero('USD') is the same as Money.new(0, 'USD'). When comparing two Money instances we want to make sure these are of the same currency or at least make sure developers are aware of a potential conversion which can lead to unwanted results.\nSo when doing Money.new(amount_in_usd, 'USD') <=> Money.new(amount_in_cad, 'CAD') it is possible to optimise for a case when one of these is .zero?, but might be a lead to an unpleasant surprise that it works in some cases, but not others.. @9mm it's a very common misconception, I feel like it deserves it's own short section in the README. Happy to accept your PR if you're up for it.. @timpalander sure is planned! I'll have a look, btw you are also very welcome to submit a PR :). @RubyMoney/money-rails-devs any thoughts on this one?\n. @ct-clearhaus yeah, didn't notice that. Will read through that PR and see what needs to be changed to merge it.\n. @takiy33 I've also encountered the same problem. Here's a PR that should fix the issue  \u2014 #537.\n. @printercu I've updated the PR, can you please take another look. I went for the pure class variable, because Ruby doesn't have cattr_accessor.\n. @printercu I've added a method for easier debugging/development access to instances. Also added a test to make sure @@instances are used.\n. @printercu If you request the same uninitialized currency from 2 different threads you might end with one thread initializing a new currency inside the synchronize, while other thread will result in checking the instances variable twice. Since MRI has GIL that won't even make a difference. In jruby & rbx if there's a mutex lock, you'll end up checking instances twice.\n. @printercu I did some benchmarking and you're right, this gives us like 15% performance boost, which is really good. I've updated the commit.\n. @ggilder, @printercu is this good to go?\n. Well first of all, you shouldn't be doing that. It's a view helper for a reason.\nBut if you still feel adventurous, try ActionView::Base.money_without_cents\n. Good spot, thanks!\n. Judging by the output only 2 float exponents are MGA and MRO, but Wiki says:\n\nSo I guess it's safe to .round the result of that method (inside the method, not test, we want consistency across different interpreters) as it should be int.\nAlso the description of exponent method looks completely off.\n. #606 was resolved and Money.new(1) > 0 works fine in the latest release. I'm closing this issue.\n. Just reviewed and merged #616, we should push the new version out\n. @kayzee sorry for a late reminder, but the new version (6.7.1) is released.\n. Looks like with 2 PRs above merged this issues should be fixed. Feel free to open a new one in case something is still not right.\n. @kernow I'll put together a release this week, there are no major changes in there, so probably gonna be 6.7.1\n. @kernow 6.7.1 is now available on RubyGems\n. Nice one, thanks, @tonyta!\n. That looks really good, couple of comments:\n1. I'd suggest splitting each test into 2 separate ones, because they kinda handle different cases\n2. That might be an intended behaviour, but still \u2014 why the decimal mark isn't used in ISK example? Shouldn't that be 300.000,00?\n. @cade got it, my mistake, wasn't familiar with th \"ISK\" currency. Can you please squash your commits into one and I'll me happy to merge it.\n. Also thumbs up for a very well described PR! :+1:\n. Nice one!\nBtw, can you please use your own fork in the future, thanks!\n. I'd say it's just a good practice, plus that way all the contributors are equal and everybody goes through the same reviewing process. And commit access is for being able to merge other people's commits once you're happy with them, thus speeding up the PR's life cycle.\nBut that's just my understanding of how things are around here plus, like I said, it's a good practice. Maybe @semmons99 can elaborate on that a bit more.\n. Well, here are some of the reasons why fork model is better:\n- As @printercu mentioned, it prevents accidents like overriding master, force pushing to co-owned branches and affecting someone else's branches\n- It's clear that these are your branches and should be managed only by you\n- It keeps the main repo clean \u2014 no abandoned or work-in-progress branches, that aren't meant for others to use\nI guess it's not as black and white as one might wish :) Another slightly more vague argument is that main repo might use branches (and some very often do) to support and manage different gem's versions and mixing that with bugfix/feature branches makes it harder for others to explore.\n. @adrianov yes, I don't see a reason (apart from people simply not using them) why these should not be included. I'm happy to accept a PR with these.\n. Thank you for the PR, closing this one.\n. Judging by the article on wiki, CLF has an exponent of 4, making the Money 6.6 example legit. I guess because of such a high exponent these are not being used in day-to-day trade.\n. From the same article it also seems that Chile has 2 different currencies \u2014 CLF and CLP, which is quite odd.\n. @r11runner thanks!\n. @printercu that's looking good, merging!\n. @deepredsky yeah, that's absolutely right, it should be easily customisable only using default as a fallback\n. @otagi while it makes sense, it's important to remember that number_to_currency is part of ActionView, which is of course part of Rails. And money gem does not depend on it\u2026 although this can definitely be added to money-rails which bridges that gap.\n. @printercu great work! My suggestion is to create another branch and opening separate PRs (which can be reviewed individually) against that branch. Otherwise this is now becoming pretty much unreviewable\n. @printercu still not sure why you decided to release it separately, I though that you didn't have time or something. We were really close to merging #622.. @printercu let's actually make this happen. I've created a new branch v7_new, can you please split your changes into smaller PRs and open them against that branch? I'll review everything and we'll merge it.. @printercu thanks, ping me if you need any help with that. That definitely looks wrong and should be [-4, -3]\n. @printercu any particular reason for dropping 1.9 support?\n. I just thought that some sort of a deprecation notice might be good before actually dropping support. At least it's a good practise.\n. @printercu yes, absolutely, money.rb became bloated with features and splitting it out into different modules is a really good refactoring. I'll take a closer look at each of the commits later today.\n. Sorry for a delay, here are a few comments:\n1. It's worth breaking this PR down to smaller parts related in logic, like \u2014 extracting things into their own classes, refactoring few parts and then removing bits\n2. Newly introduced class_attribute method needs tests around it. Also it seems to be allowing changing config per Money instance and I'm not sure about this. Feels like it should be cattr_accessor-based. Would like to hear your thoughts on this.\n3. Removing currency_as_string requires deprecation first\n. 1. Yes, there's a lot of stuff going on in this PR apart from just moving things around\n2. In case there's no instance access, how's it different from ruby's cattr_accessor? I'm also in favour of unit-testing everything.\n3. Yes, but we need a PR with that deprecation, otherwise it's going to be hard to keep track of things to be deprecated\n. 1. It's not required, but it is the reason why we are having 3 separate threads in this conversation :)\n2. So they don't get inherited? Is that something we need to worry about? If yes, then maybe configuration should live in it's own module/class that people won't need to inherit from?\n3. If we're dropping these features then there should be no backwards compatibility, otherwise we are burdening ourselves with maintaining legacy support.\n. 1. My argument for separate module is separation of concerns, plus it's not uncommon to do that. money-rails uses a MoneyRails::Configuration module, for example, so there's no inheritance issues and all settings along with their default live in a separate place.\n2. I'm afraid I'm not sure what you're talking about here. I guess you are referring to the code outside of this PR, because I don't see how this PR changes Money.new behaviour. Do you think it would be more productive to get on a hangout and make sure we're on the same page?\n. 1. Because it's uncommon introducing functionality that doesn't have a use-case for it feel wrong. Although if you insist \u2014 let's go with that, but please add unit tests for those methods.\n2. Right, got it\u2026 let's have another discussion on that topic. Meanwhile can you exclude #currency_as_string removal from this PR and include it in another with the backwards compatibility/deprecation warning.\n. I'd suggest combining + and - methods together, because they're really similar. Maybe generate them dynamically\n. Nice one, @printercu, thank you!\n. Nice one! Coveralls report seems inappropriate in this case, merging it\n. @invidian the link works for me. I guess there was something wrong with it when you checked.\n. No worries, mate!\n. @netmask looking good, thanks!\n. @seongreen looks legit! Can you please put it before the BYR in order to keep alphabetical order?\n. @seongreen Can you also squash these 2 commits into one?\n. Hmm\u2026 that looks really odd, are you in sync with master?\n. @seongreen it kinda looks like GitHub's acting up, can you try reopening your PR?\n. @seongreen have you given up on this one? :)\n. @seongreen oh, right, I see that. I wonder why GitHub still showed a proper diff\u2026\n. @naps62 thank you, good spot!\n. @printercu do you think we should handle that error better on our side?\n. @victormartinezsimon yeah, that actually looks like a problem with Google's converter, because simply googling \"1 VND in USD\" gives the right result\n. @printercu yeah, something definitely wrong with their API, I get errors when trying to convert VND to most popular currencies, some other work though.\nSeems like finding other endpoint might be a good solution. But as far as I understand google_currency is not a dependency.\n. Right\u2026 should we write something that just gets all the rates caches them for a couple of hours and does conversion on it's own? At least that way we can always swap the rates provider easily, not relying on specifics of a 3rd party API.\n. In case it's just caching rates \u2014 should we swap the provider? I mean reverse rates might be quite a bit off, rendering them pretty much useless.\n. Here are my finding on this \u2014 https://github.com/RubyMoney/google_currency/pull/48\nAlso this issue is not related to money gem, please add your comments to the PR above.\n. @ajahongir thanks for the fix! Please note that AUTHORS and CHANGELOG.md will be updated by maintainers before the next release. Can you please remove these changes from your commit? I will merge it right after that.\n. @ajahongir great! Just a quick question \u2014 shouldn't it be \u0441\u045e\u043c (with that thingie above y, according to wiki) in Cyrillic?\n. @ajahongir nice one, thank you!\n. Money.rounding_mode = BigDecimal::ROUND_DOWN\n. Oh, you've already found it, great!\n. @ajahongir I don't think there is, alternate_symbols is not really used apart from currencies_by_symbol lookup.\n. Is there a case when symbol doesn't exist?\n. @yenshirak great, thank you! Merging\n. @rubemz thanks for the PR, but it should already be doing that. .find calls .new which does _instances[id] || @@mutex.synchronize { _instances[id] ||= super }.\n. @rubemz sure thing, no worries!\n. @bsylvain I don't think there is, so you might wanna create your own helper that formats it the way you want\n. @printercu very good point! Btw, I wonder if alternate_symbols are only for lookups?\n. @lulalala got a good look at what's happening here and I've got a couple of concerns:\n1. Using .round is not obvious for some people, especially since Money will mask actual @fractional value when calling .fractional. So removing the check for infinite_precision from round method would definitely work it feels like patching rather then solving a problem.\n2. How about storing the rounding_mode in an instance of Money in case it was overriden? It kinda makes sense since it's only used for output. That way we've both got precise BigDecimal and can generate rounded value.\n. @chessbyte it's properly hidden, but it is MIT, like @ct-clearhaus pointed out ^\n. @sergio-ocon but the LICENSE file contains valid copy of MIT license\n. Works for me! Thank you, @epidemian!\n. @epidemian btw, next time you open a PR, try doing that from your own fork & branch ;)\n. Oh wow, didn't know that. No worries, mate, all good! :)\n. Looking good! Might be worth adding network error handling to your gem, but it works.\n. @n0rmanc these settings should be based on your locale, not the currency, but it should still work. Please make sure that you don't have this redefined in i18n.\n. @mcnelson what about the I18n section? Although it uses a delimiter keyword it has the same meaning.\n. Yes, exactly, because it should really be determined by locale rather than a currency.\n. We've got some discussions going on this topic and it seems like the logical approach is to use I18n locale here. Hence the inconsistency with the documentation.\nHere's an example \u2014 in Spain official currency is EUR with , is used as decimal separator and . as thousands separator. But that doesn't mean that all the EUR using countries are following the same formatting rules. Moreover Spanish would use the same formatting rules for other currencies.\n. @mcnelson don't think there's one, but it was touched upon here and there, so I'm happy to keep this one or maybe start a new one on that particular issue\n. @prokopsimek do you have use_i18n enabled?. @prokopsimek it should be on by default, maybe something overrides that. Great work, @we138. Can you please remove that extra indent and I'll merge this.\n. @we138 nice one, thanks!\n. @jdatti thanks, looks legit! I've restarted the failed CI build. Once it's green I'll merge it.\n. @jdatti it seems like there's something wrong with bundling the gems. I'll check what's wrong with it and then merge your PR. Thanks again!\n. Agree with @epidemian's comment, otherwise looks good.\n. @Funfun great! I'd also like to suggest a better name for FORMAT_IMPORTERS since they do both importing and exporting. How about FORMAT_SERIALIZERS? Should make it a bit more clear. Otherwise happy to merge it.\n. @Funfun any ideas why jruby tests are failing? Seems like something to do with thread safety\u2026\n. @Funfun perfect, thanks!\n. @MiguelBel thanks for the PR, looking good. Can you please squash it into a single commit while I fix the issues with ruby 1.9.3?\n. \ud83d\udc4d \n. @yukihariguchi thanks for the PR, looks legit from what I can tell. Do you have any examples of this? Wiki or any other resource?\nAlso, CHANGELOG and AUTHORS is updated when releasing a new version, so can you please drop that last commit?\n. @alexdunae that's a really good catch, thanks. I've implemented a fix for this scenario ^\n. @alexdunae thanks, mate! I've merged the PR, so if you could point your Gemfile to the master you should get that behaviour. I'll release it later together with other fixes.\n. I think this one's resolved, closing. Feel free to reopen or open a new one if you have any further questions.\n. @phlegx good point, it does look like a bug. Seems like you're loosing precision when performing the multiplication operation. I think it's because you're hitting some kind of limit, probably there's a non-BigDecimal value used somewhere in the chain of operations. I'll take a look into it.\nBtw, Is that a real use case? :)\n. @phlegx yeah, that .to_f is the likely candidate, although calculate_fractional method looks dodgy as well\n. @phlegx the issue with it is that Money#fractional already uses a BigDecimal underneath. And I'm not sure why is BigDecimal used for subunit_to_unit, because these are FixNums\u2026\n. @phlegx yeah, thanks for the tip. I've opened a PR ^ Will merge once tests are all green\n. As for the converting everything to BigDecimal \u2014 @fractional is already a BigDecimal even if you don't use infinite_precision it's just a matter of exposing access to it and using it for all operations in order to not loose precision along the way.\n. @jororusev good spot. Can you please open a PR for this change?\n. @jororusev this should now be fixed\n. @rodolfospalenza sorry for a delay, just got back from a holiday.\nThis is a very good looking PR, but one immediate concern is that this resembles the Money#allocate method with difference being that you are always splitting into equal parts rather than providing the custom splits. While I think there's a place for both approaches \u2014 they by all means should use the same API underneath.\n. @kaspernj yeah, that's definitely a good addition. Do all the exchanges provide this information?\n. @kaspernj yeah, so it has to be optional and warn user whenever trying to get that data from unsupported exchange.\nfixer.io definitely looks like a good addition to the list of exchanges.\n. @kaspernj since it's up to the developer to decide whether to use it or not I think we should be loud and clear that their exchange doesn't support it. That shouldn't be a problem.\nIn terms of backwards compatibility \u2014 that also should be ok, because args hash is optional is shouldn't change the footprint of the method. It also might be a good idea to have another method that gets rates at a specified date, which defaults to now.\nI'm fine with it being a [WIP], will squash it before merging.\n. Looking good! The failing test seems unrelated. I'll fix that for master and merge this one\n. @spk thanks! I'll merge this, but we need to keep an eye on RVM/Travis resolving that issue.\n. @project-eutopia It's ready to be merged now, thank you for contributing!\nAs for the CONTRIBUTING \u2014 I will update it, otherwise it's a bit confusing. I usually run something like git shortlog -s | awk '{ print $2 \" \" $3 }' > AUTHORS before releasing a new version, so that everyone's mentioned.\n. @guilleiguaran Looks good, thanks!\n. @Fryie that's really worth speeding up, thanks for pointing this out. I'm not sure if there's an alternative, but I will dig around a bit to see if there are any quick wins here.. @Fryie after a quick round of profiling \u2014 disabling i18n does bring the performance to a factor of about 10. Here's an example:\nMoney.use_i18n = false\nres = Benchmark.measure do\n  100_000.times do\n    Money.euro(250).format\n  end\nend\nputs res\n=>  4.430000   0.060000   4.490000 (  4.487014). In my experience it's always better to do all the calculations in BigDecimal (which is what fractional is stored in) and convert to Float or any other type only when you have to. That way you don't have to round things along the way, keeping value with max precision.. @kernow so you are handling rounding as you go, right?. @kernow it is much easier, no doubts. It's just really important to avoid intermediary rounding, which can accumulate error in your result. @danielricecodes yeah, absolutely, a really good answer, thanks!\nOne thing I'd like to add is that you can use infinite_precision to achieve a similar result, but you'll have to handle rounding on your own.. Looks good, thanks!. @catalin88 it seems like something's is overriding the default formatting rules, most likely your locale. Following exactly the same steps I get:\n```ruby\n\n\nMoney.default_formatting_rules\n=> {:sign_before_symbol=>true, :symbol_position=>:after}\nm = Money.new(1234, \"RON\")\n=> #\nm.format\n=> \"12,34 Lei\"\n``. Sure, no problem!. @pda good catch, thanks!. @printercudiff-lcsbeing a dependency ofrspec?. @printercu got it, will bump these up as soon as that PR is merged. @Nerian good work, can you please rebase it againstruby-2-4-0branch and re-open (or edit) your PR against that branch?. @Nerian thanks!. @orien good catch, a quick solution here is to avoid freezing of the object. I'll think of the better solution for this.. Here's a fix \u2014 #676 . @orien yeah, don't think it will since it's a pretty standard practise and this method is well tested.. @orien you're right, good spot. That's probably why I used instance variable in the first place\u2026 I guess the wholeFormatting` part needs a proper refactoring, possibly being processed in a separate class, instantiated whenever needed.. @Azdaroth judging by the ISO 4217 (https://en.wikipedia.org/wiki/ISO_4217), HUF still has an exponent of 2. It might as well be out of date and probably needs updating, which I'm happy to accept in form of a PR.\n\n\nAs for the rounding, and the fact that 1 Ft can still potentially be used \u2014 there's a smallest_denomination option, which is already set to 5 for HUF. Meaning that you can do:\nruby\nirb(main):003:0> Money.new 9_99, 'HUF'\n=> #<Money fractional:999 currency:HUF>\nirb(main):004:0> _.round_to_nearest_cash_value\n=> 1000\nSo I guess it's just the exponent part that needs fixing.. @hiepph you are probably right, most of the currencies weren't added by people who are using them and there's very little info online on how the currency format, so I'm happy to accept a PR with this change.. @Azdaroth thanks!. @karthikmuralidharan the change looks good to me, but could you please add a test case for it?. @printercu yep, that's exactly why this is ok \u2014 consistency.\nYour earlier comment also makes perfect sense. Would be great to be able to distinguish between currency not provided and nil currency cases.. @karthikmuralidharan yeah, makes sense to me, thank you!. Good shout @varg90, you wanna open a PR for this?. The fix is merged now. Looking good, thank you @komba !. @ricardopacheco any chance of getting the stacktrace? Or have you solved the issue?. @ricardopacheco glad you've solved it!. @stereobooster that's a really good point, I'll extract it out into it's own gem. @tobypinder thanks for pointing that out, I'll have the new version released today. New version (6.8.2) should now be available \u2014 https://rubygems.org/gems/money. @stereobooster thanks for helping out with this. Looking good. Hopefully it's not a massive breaking change, so we can squeeze it in before v2.\nAlso we need a gem in place to merge this and a entry in README.\nI wonder if it's worth deprecating this functionality before throwing it away\u2026. @stereobooster can you please push the code for heuristics gem to https://github.com/RubyMoney/money-heuristics?. @stereobooster sorry, I've pushed a README so you can fork it now.\n. @stereobooster thanks for doing this!. Yes, but we need to make sure money-heuristics is ready in order to do that. @livedo thanks for the PR! So the only thing that's holding me from merging this is the fact that GBX is not listed in ISO 4217, although I see how it can be useful in certain scenarios.\nBut I guess there's no harm in having it. @dilumn we can speed up the release if that's important for you, no problem.\nAs for the issue \u2014 can you copy an example that you're using and output for it?. version 6.8.3 is now released with this change \u2014 https://rubygems.org/gems/money. No problem, @dilumn !. @archana-juvo thank you for contributing!. This is a really interesting idea! I would say it is outside of scope, but I can definitely think of a couple of changes to this project allowing for an easier implementation of this feature. Things like a pluggable Formatter and maybe money-i18n with a database of translations.. Yes, that's pretty much what I was thinking! Maybe include helper methods within the context of a proc allowing for easier formatting. As far as I understand most of the formatting consist of re-arranging static parts.. @maltoe you're right, but these things change much more often since the original list unfortunately wasn't created according to the ISO-4217. Releasing a major version every time it happens will get us to version 100 sooner than you think :)\nThere needs to be a better way of handling this. Maybe by specifying version in which that particular currency has changed and providing means to migrate data easier.\nAs for the fix itself I'd suggest going through your dataset and diving your cents by 100 for all affected currencies. Another solution is registering a new currency with old settings using Money::Currency.register.. That's a great catch! I'm quite surprised that it works that way though. @orien yes, the snippet you've posted was exactly what I had in mind. The question I'm trying to answer here is whether these two method were intended to have differences or was it a side effect of a code duplication. In case its the former \u2014 I'd suggest renaming one of the implementations to something more intention revealing (probably the version with currncy conversion).. Sorry for a delay, just got back after taking some time off.\nEverything that you've said makes perfect sense, I didn't know there's Object#eql? method. So as per your last example \u2014 should eql? be treated as Object equality without any additions? That leaves us with the set of rules:\n\neql? returns true only if both fraction and currency are equal\n== first checks eql? then returns true if both objects are zero? or can be exchange to the same currency and then compared\u2026\n\nWDYT? Trying to figure out what's right here\u2026 somehow extracting comparison with exchange into a separate method feels right, otherwise innocent == might result in a network call depending on your Rates backend\u2026. @orien while I agree that breaking things for others is bad and should be avoided if possible \u2014 I don't think that should stop us from doing what's right and this is what we're trying to figure out here. \n@printercu has a really good point here and I think it aligns best with what docs say about eql?.. @orien yes and it feels to me that altering the behaviour of eql? (by removing special treatment for zeros on both sides) is the way to go here. While altering hash is also a solution, it might cause some really unexpected results like both Money.new(0, 'USD') and Money.new(0, 'AUD') referencing the same entry in a Hash. Here's an example:\n```ruby\n\n\nm1 = Money.new(0, 'USD')\nm2 = Money.new(0, 'AUD')\na = {}\na[m1] = 1\na[m2] = 2\na #=> {#=>2}\n```\n\n\nThis happens when using fractional.hash as a result for Money#hash when fractional is zero. Hope that makes sense.. @orien great. I believe we're in an agreement now and can work to merge this PR :). @orien yes, that's exactly right. I assume the fix for eql? can be part of a different PR.. Thank you, @orien!. @RomainGoncalves sorry for a delay. In case you still haven't figured it out:\nirb(main):003:0> Money.rounding_mode = BigDecimal::ROUND_HALF_UP\n=> 3\nirb(main):004:0> Money.from_amount 1019.125\n=> #<Money fractional:101913 currency:USD>\nThe default rounding mode is BigDecimal::ROUND_HALF_EVEN, which rounds towards the nearest neighbor, unless both neighbors are equidistant, in which case round towards the even neighbor (Banker\u2019s rounding).. @dipaktc looks like your error originates in money-currencylayer-bank (which is not part of RubyMoney org), so I'd suggest raising this question in that repo instead.. @emmanuelmillionaer money already comes with decimal_mark defined for each currency. In case you need to customise it further you can write your own method which figures out the right decimal_mark for the given currency and calls money.format with decimal_mark: your_calculated_decimal_mark.\nBtw, what are your requirements for this? I'm looking into switching away from decimal_mark based on currency and base it on locale instead, which I think makes much more sense.. Currently Satoshi is recorded as a subunit of Bitcoin, which is part of the non-ISO currencies. Have a look here:\n\"btc\": {\n    \"priority\": 100,\n    \"iso_code\": \"BTC\",\n    \"name\": \"Bitcoin\",\n    \"symbol\": \"B\u20e6\",\n    \"alternate_symbols\": [],\n    \"subunit\": \"Satoshi\",\n    \"subunit_to_unit\": 100000000,\n    \"symbol_first\": true,\n    \"html_entity\": \"\",\n    \"decimal_mark\": \".\",\n    \"thousands_separator\": \",\",\n    \"iso_numeric\": \"\",\n    \"smallest_denomination\": 1\n  }. @Titinux you're absolutely right, this thought has been circulating around for some time now. I think it's time to drop this and delegate to number_to_currency with the correct currency symbol.. @kschutt thank you for spotting this!. @rajdeep26 great spot. It's an issue with Monetize which was using the wrong rounding mode. Here's a PR that fixes it \u2014 https://github.com/RubyMoney/monetize/pull/101. You might need to rebase that against the master first\u2026. @samnissen I'm not exactly sure how's that gonna impact existing users. It seems like newer Rails versions default to true as well. We might wanna just update the example to include this line if that's what you are worried about.. @printercu I think you're right and we can align this change with removing currency-based formatting in favor of I18n locale-based formatting, which I think it already does a great job of.. @Liy0 good spot! Do you want to open a PR for this change? I'm happy to review and merge it. @stanley90 sure, do you want to open a PR?. Thank you for finding and fixing it!. @ct-clearhaus thanks for additional info! I think it makes sense to leave it as it is then. What about the name of the subunit?. @ianmurrays @ct-clearhaus thanks a lot for your input guys!. @Nerian thanks!. I agree with both @ct-clearhaus and @printercu here. This PR has very little value on it's own.. @alexdunae so the error message is definitely odd and can be improved.\nAs for the comparing to zero money \u2014 what is the use case for doing this comparison? There's a .positive? method for checking whether the amount is positive. Normally you'd be comparing 2 Money objects with values coming from external source (like a DB or API) and in this case it's be weird if in some cases (when one of them is 0) you get a result and other times the error is raised.. Yeah, I hear you. It's just that you can either make it strict and have developers implement all these things themselves or you can go super flexible but that means it's going to be unsafe in same cases. So we're kinda trying to stay in the middle providing some flexibility but not pushing it all the way.\nBasically Money.zero('USD') is the same as Money.new(0, 'USD'). When comparing two Money instances we want to make sure these are of the same currency or at least make sure developers are aware of a potential conversion which can lead to unwanted results.\nSo when doing Money.new(amount_in_usd, 'USD') <=> Money.new(amount_in_cad, 'CAD') it is possible to optimise for a case when one of these is .zero?, but might be a lead to an unpleasant surprise that it works in some cases, but not others.. ",
    "vanboom": "Thanks.  This gem is more sophisticated than I expected.  I apologize for creating this issue prematurely.  Thanks for sharing your gem, it is outstanding!\n. Thanks.  This gem is more sophisticated than I expected.  I apologize for creating this issue prematurely.  Thanks for sharing your gem, it is outstanding!\n. ",
    "acesuares": "I installed money-rails and it installed money, which I really need, but the default is true. I even looked at the code. True all the way down.\nAm I missing something here?\nBTW great job. Love you. 4ever. For making my life that much easier.\nPS maybe it's called rails-money.\n. You are right!\n. https://github.com/RubyMoney/money-rails/issues/52\n. I installed money-rails and it installed money, which I really need, but the default is true. I even looked at the code. True all the way down.\nAm I missing something here?\nBTW great job. Love you. 4ever. For making my life that much easier.\nPS maybe it's called rails-money.\n. You are right!\n. https://github.com/RubyMoney/money-rails/issues/52\n. ",
    "danbeaulieu": "@semmons99 Yes, according to the library it is\n1.9.3p194 :064 > Money::Currency.find(:eur).thousands_separator\n => \".\"\n. @semmons99 I would, but I've got the usual excuses. Also, it doesn't seem like it's just local to #extract_cents method.\nfor instance the #to_money method doesn't seem to use parse or extract_cents, so there'd need to be some refactoring to ensure that works as well. \nI'll poke at it, but I'd be surprised if I had anything before xmas.\n. @semmons99 Yes, according to the library it is\n1.9.3p194 :064 > Money::Currency.find(:eur).thousands_separator\n => \".\"\n. @semmons99 I would, but I've got the usual excuses. Also, it doesn't seem like it's just local to #extract_cents method.\nfor instance the #to_money method doesn't seem to use parse or extract_cents, so there'd need to be some refactoring to ensure that works as well. \nI'll poke at it, but I'd be surprised if I had anything before xmas.\n. ",
    "muxcmux": "I have a question. Why does the spec pass with no errors if I add this to the core_extension_spec (String#to_money)?\n\"10,370 EUR\".to_money.should == Money.new(1_037, \"EUR\")\n\"10.370 EUR\".to_money.should == Money.new(1_037_000, \"EUR\")\n. Nevermind, swapped thousands_separator with decimal_mark :(\n. Wouldn't that introduce backward incompatibilities? For example, this:\n\"100.37 EUR\"      => Money.new(100_37, \"EUR\")     ,\nwould no longer be valid\n. @mikaelwikman I couldn't agree more, but that seems to raise more questions than it answers. In such case, why do we need to keep information on thousands separator and the decimal sign? This should be locale-specific, like @semaperepelitsa suggested. \n. This is probably one of the things that comes most often in the issues (eg. e3ef333) and it looks to me like most people agree the parser should take locale into account. :thumbsup: for this in money v.6\n. I have a question. Why does the spec pass with no errors if I add this to the core_extension_spec (String#to_money)?\n\"10,370 EUR\".to_money.should == Money.new(1_037, \"EUR\")\n\"10.370 EUR\".to_money.should == Money.new(1_037_000, \"EUR\")\n. Nevermind, swapped thousands_separator with decimal_mark :(\n. Wouldn't that introduce backward incompatibilities? For example, this:\n\"100.37 EUR\"      => Money.new(100_37, \"EUR\")     ,\nwould no longer be valid\n. @mikaelwikman I couldn't agree more, but that seems to raise more questions than it answers. In such case, why do we need to keep information on thousands separator and the decimal sign? This should be locale-specific, like @semaperepelitsa suggested. \n. This is probably one of the things that comes most often in the issues (eg. e3ef333) and it looks to me like most people agree the parser should take locale into account. :thumbsup: for this in money v.6\n. ",
    "klevo": "awesome, thanks!\nOn Dec 5, 2012, at 5:21 AM, Shane Emmons notifications@github.com wrote:\n\nThanks for the patch @klevo, sorry I didn't merge it sooner. You now have a commit bit on the repo.\n\u2014\nReply to this email directly or view it on GitHub.\n. awesome, thanks!\n\nOn Dec 5, 2012, at 5:21 AM, Shane Emmons notifications@github.com wrote:\n\nThanks for the patch @klevo, sorry I didn't merge it sooner. You now have a commit bit on the repo.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "lacco": "+1 for fixing this. I am now working for the third (German) client who insists on \"1,00 \u20ac\". \nWe might need to consider the user's locale when rendering the symbol. A dirty hack would be to set this information manually (e.g. when using Rails in a before_filter):\ndef determine_locale\n  I18n.locale = ...\n  Money::Currency.table[:eur][:symbol_first] = ![:de, :es, :fr].include?(I18n.locale)\nend\nBetter ideas?\n. +1 for fixing this. I am now working for the third (German) client who insists on \"1,00 \u20ac\". \nWe might need to consider the user's locale when rendering the symbol. A dirty hack would be to set this information manually (e.g. when using Rails in a before_filter):\ndef determine_locale\n  I18n.locale = ...\n  Money::Currency.table[:eur][:symbol_first] = ![:de, :es, :fr].include?(I18n.locale)\nend\nBetter ideas?\n. ",
    "kriskhaira": "Hi. Sorry to bring this back, but is there a patch for this yet? If not, I'm going to submit a PR.\n. Looks like it was already fixed in 6.4.0. I was using 6.1.1. Thanks, @semmons99.\n. Hi. Sorry to bring this back, but is there a patch for this yet? If not, I'm going to submit a PR.\n. Looks like it was already fixed in 6.4.0. I was using 6.1.1. Thanks, @semmons99.\n. ",
    "mzahir": "Sorry - I have rolled back the requested changes. This commit should be good to go.\n. Sorry - I have rolled back the requested changes. This commit should be good to go.\n. ",
    "coveralls": "\nChanges Unknown when pulling 3abeb410fcadeac1f4230d68e34077aff97443a0 on mzahir:master into * on RubyMoney:master*.\n. \nChanges Unknown when pulling 4edd4dd43704a30aa6b68edd4efc9f51348ab3bc on radar:issue-272 into * on RubyMoney:master*.\n. \nCoverage increased (+0.0%) when pulling ed37f7544e2e8702ecf801afa1c29ca6ba0a276d on krishicks:master into 43caa0e5936110df3d57b03b66f3c32c807e7c1e on RubyMoney:master.\n. \nCoverage remained the same when pulling c76e4b23c4ddd8c14ab915fc3f1b6a4a6b848218 on Martin91:error-html-entity-for-CNY into af54c223b844c94ba2792fe4bb1ee52b73bab1a9 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 0c0329e9e9fc32e15c970289a4a958b398c88f53 on optional-mutex into 7186f2767908b417877cae8b7178d71ec287710f on master.\n. \nCoverage increased (+0.01%) when pulling 581a4bca25efe07da4899e01efc8eeb7489be9a0 on optional-mutex into 7186f2767908b417877cae8b7178d71ec287710f on master.\n. \nCoverage decreased (-0.0%) when pulling 68ca3116e935ca61ace1ee55c5bb72760f190ff3 on currency-refactor into e85303ac6222870b99c5affee5870aa7642c0c3e on master.\n. \nCoverage decreased (-0.0%) when pulling 02db9e0466c423b28a61c16b497f37723b6a0b9a on currency-refactor into e85303ac6222870b99c5affee5870aa7642c0c3e on master.\n. \nCoverage decreased (-0.04%) when pulling 2e410ee47659da12d3805b441d8e63a9acd62423 on refactor-format into 655f557dfc38250dba4ae752c5074c827dde4649 on master.\n. \nCoverage remained the same when pulling 7358b48befdfa33d326502c8ec2f8afe7da8772f on saurabhnanda:patch-1 into 655f557dfc38250dba4ae752c5074c827dde4649 on RubyMoney:master.\n. \nCoverage remained the same when pulling 709506a4dab60dc75b87db8a523b7ab1a8d9b5ab on saurabhnanda:master into 655f557dfc38250dba4ae752c5074c827dde4649 on RubyMoney:master.\n. \nCoverage decreased (-0.0%) when pulling 04a219ea3ee1f668f4d2afeba0e7dffd7b8b842c on saurabhnanda:master into 655f557dfc38250dba4ae752c5074c827dde4649 on RubyMoney:master.\n. \nCoverage remained the same when pulling ee57b37f377708fd6d93041eba0ac047bb39a94c on calebthompson:ct-nr-dont-warn-for-string-to_money into 581da4d188930078fbf3113bda857d1bfeab1d09 on RubyMoney:master.\n. \nCoverage increased (+0.04%) when pulling 63fb7a751854cfc9cfaf21d0395ed0b58650aae9 on 6.1.0 into 46e2a5768ea8f9ec1f94a473531f7b3cc1f848b3 on master.\n. \nCoverage remained the same when pulling 9c960a670d79356ab6f9320c370af1a718a5620e on ginter:fix-deprecation-warnings into 658b4b89b1824eb612e16baccf572ca110d4f01a on RubyMoney:master.\n. \nCoverage remained the same when pulling dc25cd0876f78d0521171a009aafe084fc20acca on JonathonMA:fix/money-rounding_mode into c668a16af88c3550edddef3582ced836def74f2c on RubyMoney:master.\n. \nCoverage remained the same when pulling e5bc6d7c9f95dd76701339bcc9c54c60b563f8c8 on nashbridges:new-manat into f777d3b602c60e24002fb08beb95d58bf0bfd874 on RubyMoney:master.\n. \nCoverage decreased (-0.12%) when pulling b395e53bff3fa92ee95a700e0b22279b1ae8739a on brixen:master into 36cd8a8eb37dee8572cfc6c57249c94c3f54590e on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 132c143f1a3cb1832402544adfe483441a8fa144 on CentroNet-Marketing:performance-improvements into 36cd8a8eb37dee8572cfc6c57249c94c3f54590e on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling bf832035878c249b96a4563b2f1f534a99ffb71e on CentroNet-Marketing:performance-improvements into 36cd8a8eb37dee8572cfc6c57249c94c3f54590e on RubyMoney:master.\n. \nCoverage decreased (-0.17%) when pulling 8a6075dc55bb7cf581e192ee0e8a167bc6712ac3 on CentroNet-Marketing:performance-improvements into 36cd8a8eb37dee8572cfc6c57249c94c3f54590e on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling ea6c2c9131da9e90df56c4e1a6e6718c19413b28 on CentroNet-Marketing:performance-improvements into 05f985f35442b512422803551177a161cc4531eb on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling ea6c2c9131da9e90df56c4e1a6e6718c19413b28 on CentroNet-Marketing:performance-improvements into 05f985f35442b512422803551177a161cc4531eb on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling ea6c2c9131da9e90df56c4e1a6e6718c19413b28 on CentroNet-Marketing:performance-improvements into 05f985f35442b512422803551177a161cc4531eb on RubyMoney:master.\n. \nChanges Unknown when pulling 0f1d72a3d17f19207833c553ab9a1dbc67a98cc0 on paulodiniz:master into * on RubyMoney:master*.\n. \nChanges Unknown when pulling 167c1d80348fe68b91c7787a5bd8f844b0e5c7ce on paulodiniz:master into * on RubyMoney:master*.\n. \nCoverage remained the same when pulling 2fb0f4a7e671af7328b8b585db89368e3ad63dfd on Matsarello:master into b2557bbd4c7f9891e8e85d4d1d3284f1aab27e72 on RubyMoney:master.\n. \nCoverage remained the same when pulling 708783fd3cf80c4235697c058e6450ce3250445a on padi:patch-1 into cfc788e92c7290fc7da1fa37ad090ff3bbf18fa6 on RubyMoney:master.\n. \nChanges Unknown when pulling 9fd01931ebfd279c433b4df291d933e83dc0ede6 on RKushnir:patch-1 into * on RubyMoney:master*.\n. \nChanges Unknown when pulling 9fd01931ebfd279c433b4df291d933e83dc0ede6 on RKushnir:patch-1 into * on RubyMoney:master*.\n. \nCoverage increased (+0.0%) when pulling 29d14c1840c8471aef15eb41e3df7021afe41f01 on fix-coerce into 3c1f74fb48c907f029b6dcb04b19c2422bfe82f2 on master.\n. \nCoverage increased (+0.01%) when pulling 21d90fe300311c4ddcca744e04163c56ddfbd7ba on fix-coerce into 3c1f74fb48c907f029b6dcb04b19c2422bfe82f2 on master.\n. \nCoverage increased (+0.01%) when pulling 6fe5c7fbf942e8ddff79a5193976659346d01af6 on fix-coerce into 3c1f74fb48c907f029b6dcb04b19c2422bfe82f2 on master.\n. \nCoverage increased (+0.01%) when pulling f808668509b5ebaf0511118e0fb33c629744e1c3 on fix-coerce into 3c1f74fb48c907f029b6dcb04b19c2422bfe82f2 on master.\n. \nCoverage decreased (-0.12%) when pulling 7358d492c76840bebbfcb13a5b6f9f07eccfbb6c on gballester:master into c433569fc30ba6d62901fdd6d6f0faf9256d6f56 on RubyMoney:master.\n. \nCoverage remained the same when pulling 1bf90cc4c956ad930c514a92a12bd1f607bfb5e6 on fliptheweb:patch-2 into c0557444b21f09338b672a270b2d9c913a441a95 on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling e34b19244464433c947f994890372fbbc616de4c on troelskn:fix-formatting-sek-and-nok into c0557444b21f09338b672a270b2d9c913a441a95 on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling 043ee8ed8d6ee4aa34b4c9fe351883e229fd2f7b on troelskn:fix-formatting-sek-and-nok into c0557444b21f09338b672a270b2d9c913a441a95 on RubyMoney:master.\n. \nCoverage remained the same when pulling ea3dbfd558b63dfec47162eca116b72743c068ca on troelskn:fix-formatting-sek-and-nok into c0557444b21f09338b672a270b2d9c913a441a95 on RubyMoney:master.\n. \nCoverage remained the same when pulling 93ae57606bbb6497c07a1e5e5adee56a00f0f592 on troelskn:fix-formatting-sek-and-nok into 393b67850bbca1a29dd0f6d3c0f61028aaf742d1 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 8abda3dc1fbc0ff36c85d81c90d1fa86f0bcf722 on tjhart:fix-rounded_infinite_precision-with-use_i18n-as-false into e0a1f2c9f91a694d1773fbb1b34be9e30c364382 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 56178f82796ea6f71992b8b520109bda2821d5a0 on tjhart:fix-rounded_infinite_precision-with-use_i18n-as-false into e0a1f2c9f91a694d1773fbb1b34be9e30c364382 on RubyMoney:master.\n. \nCoverage remained the same when pulling 615befd862e69886bd67d9deb1657f2c671903bc on jerhinesmith:master into e0a1f2c9f91a694d1773fbb1b34be9e30c364382 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 615befd862e69886bd67d9deb1657f2c671903bc on jerhinesmith:master into e0a1f2c9f91a694d1773fbb1b34be9e30c364382 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 15d7b1dc28f3ba060e04ca9f3a8b77e321a943d2 on jerhinesmith:master into c1ee53f0dc82569bef621b7e7a56a74577b14087 on RubyMoney:master.\n. \nCoverage decreased (-0.23%) when pulling b1a30668a9419ac5b89a7912343038d0e360a6a3 on tweymuth:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 718bbc853bc0f9602c71926db3a19b1a6b5b80b6 on tweymuth:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling a89091a481a778d742819fa5784d7ee61e27db60 on tweymuth:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 2d7d4a70790ecde8b34c7d921499ce40447bd811 on tweymuth:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage remained the same when pulling 7bcda1445f0436ccbf04eaa8ead579821e390235 on georgemillo:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage remained the same when pulling 7e5d0da727b5c2bbc9862f5185556f8501b48e0c on shpupti:master into fae74d08f67f617f5dff1c71498d8169fafe2f7a on RubyMoney:master.\n. \nCoverage remained the same when pulling c01e4f905535518954f566c2fdbf572ee3ab67b8 on shpupti:master into fae74d08f67f617f5dff1c71498d8169fafe2f7a on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling b7bc13b721174b82740967646ed04fee5a6fe7cd on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling c0f1e73bf81c71982ae4e919461fe3b106bd4ccb on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 0403d2f67e56e18a4fd55bb9c8107a3291a1d3e3 on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 41ae26d6d696f998229be57cadc4feffd731180a on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 7bb542e6121a119f91f5512db4bb800dbde2276f on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage remained the same when pulling b5a471931b653b1cfef09390873796a600545bc7 on arthurtalkgoal:master into 3d2b34a879fc30291b9c330062d24799e65f4fad on RubyMoney:master.\n. \nCoverage decreased (-0.45%) when pulling 52d66ef3e1ba3a7ab489382884d9a688914b9f7b on ggilder:fix-vnd-subunit into ff0bf0b895ca93e125a017900b7fb68d6666b702 on RubyMoney:master.\n. \nCoverage remained the same when pulling 0152bcf899a257f1a081582c397ed04c0d2c4a03 on ggilder:fix-vnd-subunit into ff0bf0b895ca93e125a017900b7fb68d6666b702 on RubyMoney:master.\n. \nCoverage remained the same when pulling 3c83b0fcfaf803646314a6668128cc93e81dc291 on tweymuth:master into 11491ce48c32561bccfaf1d3bb57d74d6e8c1514 on RubyMoney:master.\n. \nCoverage remained the same when pulling d9ee5f3d00971bc6235818c89d78daffc096422e on BRMatt:patch-1 into 7df3e6d3c2d31a2eda8ebd5b56eaf046612cecbb on RubyMoney:master.\n. \nCoverage remained the same when pulling d1acabe7b64ce558de16a79902075b725306b1c4 on ggilder:fix-rub-symbol into 105036b1f059f3593b1d7af97d96dec70d8f83f5 on RubyMoney:master.\n. \nCoverage remained the same when pulling 048ab7df1b43ba32787b20ecf7d4664dc334bdaa on ggilder:fix-try-symbol into 105036b1f059f3593b1d7af97d96dec70d8f83f5 on RubyMoney:master.\n. \nCoverage remained the same when pulling 9c1a0fbbc6c847fd386f8bde6b260e27c02a0de6 on ggilder:ignore-coverage into a42e2b140f6fed9fa5104c2c0fc66c07a22e9e7a on RubyMoney:master.\n. \nCoverage remained the same when pulling 632bdec51802721d320fced24dc4f72bef31d33c on shpupti:master into c9696907ab798db170f4ea899cfa09084454f395 on RubyMoney:master.\n. \nCoverage remained the same when pulling 9f54d7f8917784dd9a565eccd9db85fc8dbeed69 on zacksiri:master into c9696907ab798db170f4ea899cfa09084454f395 on RubyMoney:master.\n. \nCoverage remained the same when pulling 25a0e449ea429d797be434af5e299b6e80040784 on sigra:master into 0f7e1565670e5bf345c16eac7c79cc44c4445264 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling fd8f29fd77956e05eae0c84dbef347b2a70daaab on mateusg:master into e42371c3ccb671740b0942e8a390d6ec43454d63 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling d2384d84e2c50071c03d1bd707d680ce6d3cb278 on mateusg:master into e42371c3ccb671740b0942e8a390d6ec43454d63 on RubyMoney:master.\n. \nCoverage decreased (-0.09%) when pulling 80447c5bc8fae1b3b2c286b3104aed3087afb081 on lulalala:compare_different_currency_precision into c9f547e8c20a377446fcc9506e53e3b91cab69b4 on RubyMoney:master.\n. \nCoverage decreased (-0.11%) when pulling 38e224895ac8cce48fc503f147f8c6e5f0205dcf on vandrijevik:patch-1 into 7c82f6c71c1f0957b97f7aaa31b27c6d453764eb on RubyMoney:master.\n. \nCoverage remained the same when pulling 3abbcfae86f5e9a0e88b375918613183687e5225 on TinkerDev:master into b07481a6c330dc0cc1c88b05f78f97c7761b9402 on RubyMoney:master.\n. \nCoverage remained the same when pulling 9580358603fcf10501578cbe90aeff11ddac6456 on raphaelcosta:master into b07481a6c330dc0cc1c88b05f78f97c7761b9402 on RubyMoney:master.\n. \nCoverage remained the same when pulling deca5e8f42148b968f8d86fdbe07144ec752526c on geetfun:master into b07481a6c330dc0cc1c88b05f78f97c7761b9402 on RubyMoney:master.\n. \nCoverage increased (+0.18%) when pulling ae293095cd461e3396523016f0c6a5bf937f7339 on aripollak:ruby-2.2.0-deprecation-fix into 82e3f5cf97bd31384ba8b5ccf3c14f6da23f2ddc on RubyMoney:master.\n. \nCoverage increased (+0.18%) when pulling 83313a40b5540a01b5e81366357429e7df002745 on aripollak:ruby-2.2.0-deprecation-fix into 82e3f5cf97bd31384ba8b5ccf3c14f6da23f2ddc on RubyMoney:master.\n. \nCoverage remained the same when pulling c0668e44eaafc3f34039f9d4747f6a1c518c4ad9 on safakgur:fix-try into 917369d51870fd76510aa1fa8ac73b9e9846562b on RubyMoney:master.\n. \nCoverage remained the same when pulling ce46d036ac02f1657f9d9178508e050c8225cd06 on levady:update-idr-currency-iso into becb6cd64d7722fdd81bac9c70b5889c4d69fcae on RubyMoney:master.\n. \nCoverage remained the same when pulling abc279fcbd3b0970c8152261cbbf605b9d21c98b on parentheses into becb6cd64d7722fdd81bac9c70b5889c4d69fcae on master.\n. \nCoverage increased (+0.0%) when pulling ba1cca03b20dc49e38378ff60ca99116b488f23b on constructors into becb6cd64d7722fdd81bac9c70b5889c4d69fcae on master.\n. \nCoverage increased (+0.0%) when pulling 11f838af4213962fb6e401a038c497bc0d04941a on constructors into 6a3398933d81f6c676835abd3fc9dd17248adb9b on master.\n. \nCoverage increased (+0.0%) when pulling aea6a9ee86147bcdda660bd6f1fdee26b51eeed5 on register into 6a3398933d81f6c676835abd3fc9dd17248adb9b on master.\n. \nCoverage increased (+0.0%) when pulling bd17234c91d105b60a5011620e2c80c0770771bb on initialize into 31ad320677fd1a4c3167cce53cc1763a00889100 on master.\n. \nCoverage increased (+0.0%) when pulling 2bf937e7bfcb91055281e75d06a43e08048a389a on symbol_position into 379671b2a1e8a418698427b31848539bb843c211 on master.\n. \nCoverage remained the same at 99.78% when pulling 161d36d81811ab3bb54037a996ce3a0e90eed459 on jasonahooper:master into 6aa9633493f0a1fd1f0033e9146034fdffa755fa on RubyMoney:master.\n. \nCoverage remained the same at 99.78% when pulling 55255ca702f23d23cb31bba94a674488323ae88b on abatko:patch-1 into f643921cbf7cd4c19677c3b7a76831fa88705226 on RubyMoney:master.\n. \nCoverage remained the same at 99.78% when pulling 28d22c414b49b4b40b63a91d27c07d87e6cd52b0 on jkingdon:swaziland-symbol into f643921cbf7cd4c19677c3b7a76831fa88705226 on RubyMoney:master.\n. \nCoverage remained the same at 99.78% when pulling 7810d3f8f0562987235c2ae8c04c53a16d9f74e8 on seongreen:improve-byr-format into 33c19117d20d1b70893ad4a93bfb581ada7a5e90 on RubyMoney:master.\n. \nCoverage decreased (-0.12%) to 99.79% when pulling 0659f2bc4383373f550ab8e8ac5da84fba7c66a4 on currency_enumerable into 5d5cef6bb2df58220fc00af44126cf01a8648140 on master.\n. \nCoverage remained the same at 99.79% when pulling 8a30f522728c1951fde0eccab95f0095f3ccab2d on cade:master into 6d97813511f884fd543c3ebfaa6c6b262eff03d2 on RubyMoney:master.\n. \nCoverage decreased (-0.08%) to 99.71% when pulling d36f9f95c7c6e423fa1d44bfdde773d295ca1048 on douglasmiller:master into d9e0bd88562f48a4666c02b04acf9ba8e64a454b on RubyMoney:master.\n. \nCoverage decreased (-0.04%) to 99.75% when pulling 30f085a1f53a7c03bd45ae993b367fe3374a66d4 on arthurkarganyan:patch-1 into d9e0bd88562f48a4666c02b04acf9ba8e64a454b on RubyMoney:master.\n. \nCoverage remained the same at 99.79% when pulling bfa7108e1d085f7518ff979db4b8c9cb1b1b1e3f on cade:fix-clf-exponent into e0eb7a5f8296a8c0761d2dfadbc763fca102bdbb on RubyMoney:master.\n. \nCoverage decreased (-0.0%) to 99.71% when pulling e3af22ff83950518481ed52682f934bea29cc076 on mikerodrigues:master into ed04ecf88b967be7a2e24917f1e506288b7b12c6 on RubyMoney:master.\n. \nCoverage decreased (-0.0%) to 99.71% when pulling e3af22ff83950518481ed52682f934bea29cc076 on mikerodrigues:master into ed04ecf88b967be7a2e24917f1e506288b7b12c6 on RubyMoney:master.\n. \nCoverage increased (+0.01%) to 99.71% when pulling e9583be9215c9e75b4ddc90851df9563d88c0b0d on ismasan:decouple_rate_store into ae9f9291685aa746067778008e4756c6c2bce766 on RubyMoney:master.\n. \nCoverage increased (+0.01%) to 99.71% when pulling 8cf70ab8f885a88d8a87ffb83b916c1000881aee on ismasan:decouple_rate_store into ae9f9291685aa746067778008e4756c6c2bce766 on RubyMoney:master.\n. \nCoverage increased (+0.0%) to 99.71% when pulling 668c0e0320cfae5e016a271c993d0ff40505307f on thread_safe_memory_store_transaction into b04d8a7e881e0c51ed9d8af0f3b3351595cbc625 on master.\n. \nCoverage increased (+0.0%) to 99.72% when pulling 3285c01ab7ffb1e5c1c4a322255765b25e987be8 on printercu:patch-1 into 03c2034e7674097d536f084f40c57770411550a9 on RubyMoney:master.\n. \nCoverage remained the same at 99.338% when pulling 28890983e36992b2de1092163a8b938615bd9b84 on r11runner:readme-typo into 39b617cca8f02c885cc8246e0aab3e9dc5f90e15 on RubyMoney:master.\n. \nCoverage increased (+0.004%) to 99.342% when pulling 6c9b7274b63b3543e487a0b4f15daf0edefffb49 on printercu:master into fea316e85510c8d6d7748af94c80f37deebafc71 on RubyMoney:master.\n. \nCoverage remained the same at 99.338% when pulling 2afea67900324e01145d4caa22dd34cfe0050d3e on insphire:aed-symbol into fea316e85510c8d6d7748af94c80f37deebafc71 on RubyMoney:master.\n. \nCoverage increased (+0.002%) to 99.344% when pulling 8f2b7254198855b5fc5bcbe955e7cfc7b950460f on hoverlover:feature/fr-CA into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.002%) to 99.344% when pulling 44d294bbd484f3d103cf403b812726bfdb613c63 on hoverlover:feature/fr-CA into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.003%) to 99.345% when pulling 2d5cc69041901f379b0990638aef76d277ae998c on hoverlover:feature/fr-CA into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-55.4%) to 43.936% when pulling 83924f9b9031fb91ccf602dab913a999dc58d269 on printercu:v7 into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-0.8%) to 98.507% when pulling 91dc5ed6bc5a75ec8b72f34789a40e70657264af on printercu:v7 into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-0.8%) to 98.507% when pulling dad5733917f97ce0372af948829e32d842522215 on printercu:v7 into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-1.0%) to 98.362% when pulling 843707025a802e8047767918d9f4d1c7674b5a9c on printercu:v7 into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.07%) to 99.41% when pulling a1dffe1baca6b9506d1c6584e82ce0088ec5c902 on printercu:v7_part0 into 6c9b7274b63b3543e487a0b4f15daf0edefffb49 on RubyMoney:v7.\n. \nCoverage increased (+0.07%) to 99.41% when pulling 7d37cb74421776d308a35ad1b5167baaf58ab99b on printercu:v7_part0 into 6c9b7274b63b3543e487a0b4f15daf0edefffb49 on RubyMoney:v7.\n. \nCoverage increased (+0.07%) to 99.41% when pulling 7d37cb74421776d308a35ad1b5167baaf58ab99b on printercu:v7_part0 into 643d27edbb87ce7a317cb3140f8bfb34aa2d9ec7 on RubyMoney:v7.\n. \nCoverage increased (+0.4%) to 99.781% when pulling bf76588605e586ea86f49e1211bc7d634e31d615 on printercu:conversion_errors into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.04%) to 99.383% when pulling 9814398630741ceaa512ac1c523e848fc1111926 on printercu:conversion_errors into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.04%) to 99.382% when pulling fa5096486ac841eb570217752b8b88c779bc9f79 on printercu:conversion_errors into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.226% when pulling 1b004edd5dbc7e69316eba8a68307d34f84b3a3b on printercu:divmod into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.195% when pulling 7b47115c393b3baf7a7d186a287459d40f30abfb on netmask:master into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling eb19812141c96dba18e76004bf20f7dcdee660e9 on netmask:master into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 9be8ba29ab905e3772b1db6d31b9b5427ffc853f on seongreen:add_byn_currency into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 9d376021f0ca1d7a186134b28dae1135b408fbd2 on seongreen:add_byn_currency into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 02e15601e6a5951959d1ea230f12cd76c3a9d095 on naps62:mp-readme into d20bfea68ac14d744cdf8e79c756eed4f81af981 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 65e85eaf1287b74d9530919f3f5c326161fa5e0e on ajahongir:fix/uzs-syntax into 8b97ebc8ff252e4d534193eac209531e90097d4b on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 4786041cb33cbae1cf81456ba86353ea42473220 on ajahongir:fix/uzs-syntax into 8b97ebc8ff252e4d534193eac209531e90097d4b on RubyMoney:master.\n. \nCoverage decreased (-68.0%) to 31.38% when pulling 9427ce0f2994169d23de7f55f430e7f2e2df581e on ajahongir:fix/uzs-syntax into 8b97ebc8ff252e4d534193eac209531e90097d4b on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling b25896381618abfc3843f197feb5639949b77504 on ajahongir:fix/uzs-syntax into 8b97ebc8ff252e4d534193eac209531e90097d4b on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 18b17f9225a67ecfb6131ddfd01bac40780054d6 on yenshirak:fix-huf into bc1781d2f76484af84d58d334719f170a6c6de0f on RubyMoney:master.\n. \nCoverage increased (+0.0007%) to 99.382% when pulling 535769a2c7287e6d12761701d8fcb5220fb64e3f on rubemz:refactor/currency-find into 90dfbda64ba6f88bcd836464c606624d2141b8e3 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 42fc721805b62228cf9ec5b78dfac8123163596e on mention-mit-in-license into 90dfbda64ba6f88bcd836464c606624d2141b8e3 on master.\n. \nCoverage remained the same at 99.382% when pulling 4e96ceb6a6fcbd8f4a93fdb9473e93c95928c9a5 on naps62:mp-uphold into 35b71b92c817a92499d87ecd8c05b09e84fbef91 on RubyMoney:master.\n. \nCoverage decreased (-0.03%) to 99.35% when pulling 9e8f923cdeaec1221f60f03ea175c565caf389f3 on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 137f35017f9e7915b2bb7c18464c38f48088e996 on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 20733f54606afc17a108eb68327e66816971cebc on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 20733f54606afc17a108eb68327e66816971cebc on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage increased (+0.4%) to 99.781% when pulling 20733f54606afc17a108eb68327e66816971cebc on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 810d1e7555f6c32a6b3ab8785c570de979cee9a4 on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 1d720c8a0c36ab6f7aa7d50ea3bd3929cd3b456a on jdatti:master into aa20a622a35ee21dccfa647b74fc665e5a70ae3a on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 844bbbb4e96c619f478356a8a72bea1ddf5aaefa on antstorm:fix-ruby-1-9-json-issue into aa20a622a35ee21dccfa647b74fc665e5a70ae3a on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling c2f914d0951e95b77d809d81510104e0c792f9be on antstorm:update-rubies into a529382b91dd1c4ec0a29e07d9f0e42e21ffd828 on RubyMoney:master.\n. \nCoverage decreased (-0.002%) to 99.379% when pulling fef4439b6d335b67b8f30192dd5dc96722542d44 on to_refactoring_case_statement into 1d17a813462d5d16b8d3fbc6ad11075bb2a6ceb6 on master.\n. \nCoverage decreased (-0.002%) to 99.379% when pulling a82e2ccb561a2ce5123fb34dab24e081e131f1ff on to_refactoring_case_statement into 1d17a813462d5d16b8d3fbc6ad11075bb2a6ceb6 on master.\n. \nCoverage decreased (-0.002%) to 99.379% when pulling dc6186fc73b516fd10093eaa711bc577521dab79 on to_refactoring_case_statement into 1d17a813462d5d16b8d3fbc6ad11075bb2a6ceb6 on master.\n. \nCoverage decreased (-0.002%) to 99.379% when pulling 703e93f43ec6d897ddf58ad77a6de64c78b304ac on to_refactoring_case_statement into 1d17a813462d5d16b8d3fbc6ad11075bb2a6ceb6 on master.\n. \nCoverage increased (+0.4%) to 99.78% when pulling 421359b0a3f4aa09fc2c01f799bd26f07de0691f on MiguelBel:update-to-iso-4217 into c67bf62a92d0984a5b3266293957686743578a3c on RubyMoney:master.\n. \nCoverage remained the same at 99.379% when pulling 3101baf619ef0064d67c7cd93f75d8dd790e1037 on MiguelBel:update-to-iso-4217 into c67bf62a92d0984a5b3266293957686743578a3c on RubyMoney:master.\n. \nCoverage remained the same at 99.379% when pulling c3ab1bc86b0e69f3501f58baaab45c57cb25a68b on antstorm:fix-ruby-193 into c67bf62a92d0984a5b3266293957686743578a3c on RubyMoney:master.\n. \nCoverage decreased (-0.003%) to 99.376% when pulling c20176cd180538aee124babac83eeee0ce48d9de on yukihariguchi:remove_localize_formatting_rules into 5630a70ed7f533c25a8c62b74116579c63d4aae0 on RubyMoney:master.\n. \nCoverage increased (+0.0005%) to 99.38% when pulling 6b288935c20bbf87f5452d8cf8866a94fba463b2 on antstorm:add_test_for_currency_as_string into 5630a70ed7f533c25a8c62b74116579c63d4aae0 on RubyMoney:master.\n. \nCoverage increased (+0.002%) to 99.382% when pulling 37e76ea5410d9503589d3dbe730f971f40b68768 on antstorm:fix-for-negative-amount-allocation into 0887443cd8bc74466560d638bb7bf00ff0d4613d on RubyMoney:master.\n. \nCoverage increased (+0.0004%) to 99.382% when pulling 1df2f31188d585394fea7426a646ff37897eefe9 on antstorm:fix-exchange-issues-with-bigger-numbers into 47ca1202651d032c85d036cb0aeadd8b8b8618bf on RubyMoney:master.\n. \nCoverage increased (+0.008%) to 99.39% when pulling 1bd9b5f1e6659bdf277a79ba27c20315bc8d3929 on rodolfospalenza:master into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.3%) to 99.122% when pulling 548369522e2a94ea6f75121233dbdba7ccf3e041 on kaspernj:exchanged_at_support into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.3%) to 99.122% when pulling 548369522e2a94ea6f75121233dbdba7ccf3e041 on kaspernj:exchanged_at_support into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.24% when pulling e7634fa9b1380c32c948a8f8e973b366c941f5f7 on kaspernj:exchanged_at_support into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.233% when pulling dcbe43b6250ad28d68d9d828cdaa275b72e2c087 on xssc:patch-1 into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.273% when pulling c85432ebaf5e0c0178a2ae75fe8ce592daf36aaa on antstorm:fix-ruby-1-9-3 into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.04%) to 99.233% when pulling 76100eaf6484927417bd67272226c02763fd5b44 on spk:allow-fail-rbx into 9b2421dc3149454af5d4027b2ffe65d184d5793b on RubyMoney:master.\n. \nCoverage increased (+0.004%) to 99.277% when pulling 13f646b68a27736d6687423c03577b19ee638d8e on project-eutopia:disambiguate_and_symbol_options_work_together into aa35ebdd50fae6f4a31d47ab596974b74a2f6e19 on RubyMoney:master.\n. \nCoverage increased (+0.004%) to 99.277% when pulling f401e30d9144bba1ff4ca607bb0b3ff85f8b31af on project-eutopia:disambiguate_and_symbol_options_work_together into aa35ebdd50fae6f4a31d47ab596974b74a2f6e19 on RubyMoney:master.\n. \nCoverage increased (+0.004%) to 99.277% when pulling f401e30d9144bba1ff4ca607bb0b3ff85f8b31af on project-eutopia:disambiguate_and_symbol_options_work_together into aa35ebdd50fae6f4a31d47ab596974b74a2f6e19 on RubyMoney:master.\n. \n\nCoverage increased (+0.7%) to 99.961% when pulling 355dc94535b916e7dae8ca863dbf2b1efaa15b22 on guilleiguaran:patch-1 into 5a9b970ca4c13d2721217acbd63327a328882105 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.277% when pulling d192cad71932c60b6d301a49a93e81b756ea7352 on antstorm:precache-i18n-calls into b07a9d994f26768fcb746c9936d4bb664b629d0d on RubyMoney:master.\n. \n\nCoverage decreased (-0.002%) to 99.275% when pulling 05fec49e765bc6f1ef39724e6703daec1d7e5d8f on antstorm:precache-i18n-calls into b07a9d994f26768fcb746c9936d4bb664b629d0d on RubyMoney:master.\n. \n\nCoverage remained the same at 99.277% when pulling bcd133b51319f3945fff4db2811790421181ad89 on prokopsimek:patch-1 into b07a9d994f26768fcb746c9936d4bb664b629d0d on RubyMoney:master.\n. \n\nCoverage remained the same at 99.277% when pulling fb6402307a652edc4f60911a7ecb4e282999baed on pda:remove-post-install-message into 7ba1c8e468e722a246c7bad6594ee55adec57ed4 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.275% when pulling e31a705b067fe848b4b9021323c1b9b7582c3e41 on antstorm:add-2-4-0-build-target into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:ruby-2-4-0.\n. \n\nCoverage remained the same at 99.275% when pulling 22cf221d632456aadfbb42ec0dcd06a5746b10f2 on antstorm:fix-ruby-2-4-0-deprecation-warnings into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:ruby-2-4-0.\n. \n\nCoverage remained the same at 99.275% when pulling 8a9a7a115fd4bba1f901e950c0be7fd4b51ecd3e on ruby-2-4-0 into ddf506aa289042379212ecc1715a33cee88687d0 on master.\n. \n\nCoverage remained the same at 99.275% when pulling 8a9a7a115fd4bba1f901e950c0be7fd4b51ecd3e on ruby-2-4-0 into ddf506aa289042379212ecc1715a33cee88687d0 on master.\n. \n\nCoverage remained the same at 99.275% when pulling ada9b9b8f280452f8552c5f440b0138b20b7a0cb on ruby-2-4-0 into ddf506aa289042379212ecc1715a33cee88687d0 on master.\n. \n\nCoverage remained the same at 99.275% when pulling ad7794c8294a726793405d08976c2e45789da851 on ruby-2-4-0 into ddf506aa289042379212ecc1715a33cee88687d0 on master.\n. \n\nCoverage remained the same at 99.275% when pulling 05431c5c3164e77f2451bf8e37322ac6b78a4683 on Nerian:ruby-2.4 into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.275% when pulling 05431c5c3164e77f2451bf8e37322ac6b78a4683 on Nerian:ruby-2.4 into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.275% when pulling f27c7b01c84327d88ffbed9b9e89b7069a9239e8 on Nerian:ruby-2.4 into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.277% when pulling 3450314cbcfc675df63dec757a63c92cacb61c3b on antstorm:fix-frozen-money-issue into ac882088513b3a77008b7db6d1c2e68caf2e3ef0 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.277% when pulling 4ceb81384aef6724914b9fd52e5c20d952270eaa on Azdaroth:eliminate-subunits-for-forints into c7999bd74cb710389082c2fc7ad4ea3ee82536e7 on RubyMoney:master.\n. \n\nCoverage increased (+0.04%) to 99.277% when pulling 0323a986c6581c9c57c9fdd71ed0d68099117459 on karthikmuralidharan:patch-2 into 7552ed68d563c169093676476142f36b6607ff47 on RubyMoney:master.\n. \n\nCoverage increased (+0.04%) to 99.279% when pulling fd919017575f3c588929b7b69e9de5599f8665d9 on karthikmuralidharan:patch-2 into 7552ed68d563c169093676476142f36b6607ff47 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.279% when pulling 7d2a065f6b7e6212fc11a09a84e7494800b880bf on antstorm:bump-i18n-version into 557561ef7259b8d2ab6a3603d0a5335e90842644 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.279% when pulling 536059a5598720789c872e79b1aff513f43c3346 on antstorm:fix-uzs into c7fd57690952ff0ac3fea782242110cb349ad5c5 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.279% when pulling 1e39abc35803737bc0d966eb462c7b22e143a4ad on komba:master into 26465abedc629a96196b5570b03d123c1ab64845 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.279% when pulling d1fb3d53297c115451108511c5d156b2d8d8eeb8 on lautis:i18n-version-relax into 190683e7b84b66d11b83b7be32d019cf3c2fc114 on RubyMoney:master.\n. \n\nChanges Unknown when pulling 1e5c5fd4a3c6c601bc1921fe9303bd59b31f639b on guilhermesimoes:master into  on RubyMoney:master.\n. \n\nCoverage decreased (-0.02%) to 99.259% when pulling faaeb1583959fb2157ba649f254291c7d0e98a36 on stereobooster:remove-heuristics-module into 0a56365295176fa845601133ddc3e6850514704c on RubyMoney:master.\n. \n\nCoverage decreased (-0.02%) to 99.262% when pulling 44e4e0d40a37cc28bbfc050257c3b39c006d384f on stereobooster:remove-heuristics-module into 0a56365295176fa845601133ddc3e6850514704c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 4f3dd2e9a1fa5b9b44f2332034791aba405c032c on livedo:patch-1 into 57480dae379ddb41875073e2af0ff9e34227fb15 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 49be6770627ccdb5d00883c3f20dce1433da97f1 on dilumn:master into 641e094de13136be8a22fe5d4f954e9d569ecd39 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 49be6770627ccdb5d00883c3f20dce1433da97f1 on dilumn:master into 641e094de13136be8a22fe5d4f954e9d569ecd39 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling e111bf5a4da3c95b5ffdada7f05522ded6c371ee on dilumn:master into 641e094de13136be8a22fe5d4f954e9d569ecd39 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 9be80a6ca57e5944022934045180ea354e92c20d on v6_8_3 into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on master.\n. \n\nCoverage remained the same at 99.262% when pulling 8bf3cee40367da2d904c7a258bd58d00202a8ce3 on jacksonh:bbd_symbol_first into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 8bf3cee40367da2d904c7a258bd58d00202a8ce3 on jacksonh:bbd_symbol_first into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 8bf3cee40367da2d904c7a258bd58d00202a8ce3 on jacksonh:bbd_symbol_first into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 42abad09a3751bb801350f96ad4be5d5f226e335 on archanasingh:nio-pab-symbol into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 1f450f017ddbb81ca1f8fd01f0786fa72128af1b on archanasingh:nio-ambiguity into ec1c46b7f188a4fc82d530bd2e03a814ed4c6da5 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 4d7bbfe5eb87208ec015114759b7756b04a81fde on v6_8_4 into 50a302f648af65ccbfd22ffd21a2ecc928bf6723 on master.\n. \n\nCoverage remained the same at 99.262% when pulling 61e6ef6225605e2dfa4508b98f9e19c8bab467cb on thilonel:huf-config-update into 88775214e5b80e409840b06dae03275597151fee on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.264% when pulling fc15a032f90a02f2b43855709b8ffbafa3192228 on orien:compare_zero into 3a126f4011e6abc420e07b40674cc27de854c9ae on RubyMoney:master.\n. \n\nCoverage increased (+0.004%) to 99.268% when pulling d2819ce91f3cf04858fe6e0ee93789fd8136f20b on orien:compare_zero into 3a126f4011e6abc420e07b40674cc27de854c9ae on RubyMoney:master.\n. \n\nCoverage increased (+0.005%) to 99.27% when pulling 516db28a9a93fb3f6dd1116373151f2d773d5353 on orien:compare_zero into 24682ba23c610ac2a1d9f9369fc67380d8e2a575 on RubyMoney:master.\n. \n\nCoverage increased (+0.004%) to 99.269% when pulling 8d7efc23cc37d02062721b6cb18e98881a677895 on orien:compare_zero into 24682ba23c610ac2a1d9f9369fc67380d8e2a575 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.264% when pulling 5bc31496e8439bcb535f1a79b7423b572ba9a477 on orien:build_rubies into 3a126f4011e6abc420e07b40674cc27de854c9ae on RubyMoney:master.\n. \n\nCoverage decreased (-25.5%) to 73.805% when pulling 5814bee2d087716dbd2f4100f2bc1e7009e19c3c on orien:eql into 6a1de2719c87113f2f062b4418ccd46988d1a3ac on RubyMoney:v7_new.\n. \n\nCoverage remained the same at 99.27% when pulling 4e17f22f3fdd280cf3367533e813d05218fa30de on kschutt:xts_iso_4217 into 6a1de2719c87113f2f062b4418ccd46988d1a3ac on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling 88b4848cf6dbfe55185746eea13fcc88b20a9bf6 on isaacsouza:readme_text_adjustment into 27b8b141e023b0a688cb562caee800808051e48c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling eacd877f63aa6693f98b807cd62c9745f1c07ee2 on isaacsouza:readme_text_adjustment into 27b8b141e023b0a688cb562caee800808051e48c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling 180156006092dc76975db654c05084dd735d81b7 on isaacsouza:readme_text_adjustment into 27b8b141e023b0a688cb562caee800808051e48c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling 0e3a5cd043211d14e49ad7ce733bdfe9ae7c5a53 on adisos:patch-1 into 17cf0b82325ec186c36198091311411085e1ede7 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling 3b2e5d6bff2cc64e455655d2c03c4dd4020cdedc on antstorm:colorize-rspec-output into 42cbc3628cd1d47c945fb27515d669a1d20dcf5b on RubyMoney:master.\n. \n\nCoverage increased (+0.08%) to 99.351% when pulling 9d1427c7ec61172af38283448a666f0d7374172c on antstorm:fix-ars-html-entity into a19366501d38a80f8d43a4ba58e57fd66aa1400a on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling 88acbc990e2ffe0ab15001c74ead3ca12d1be391 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling eab27b80478e6743abc7d1116c6f0a4688c21675 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling eab27b80478e6743abc7d1116c6f0a4688c21675 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling 0f858f6525fdd03775f6d757a982337024755c14 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling 0f858f6525fdd03775f6d757a982337024755c14 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage remained the same at 99.351% when pulling e928b546ad9d3797b25499c74da33a861f0b59ae on antstorm:force-update-bundler into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage increased (+0.003%) to 99.354% when pulling 3efdff7b8a93fee7c379a39a371726ecb4d1b7ec on alexdunae:allocate-rationals into c57c081ad244cf2469608cceaa51d21427108773 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.354% when pulling 1afe899fd6c73f5f9f4678c2c8c611e9311bcdb7 on jesuiswk:master into bbd5d98eb86af1a9db3f36b70efd7b3c54a5807a on RubyMoney:master.\n. \n\nCoverage remained the same at 99.354% when pulling 18be7d88fc5a7a3c5887d46f96e3f3fc38b97ad1 on Nerian:patch-1 into bbd5d98eb86af1a9db3f36b70efd7b3c54a5807a on RubyMoney:master.\n. \n\nCoverage remained the same at 99.354% when pulling a0c5598cc4f1f240a70b85c23e927eb60522e830 on Nerian:patch-2 into bbd5d98eb86af1a9db3f36b70efd7b3c54a5807a on RubyMoney:master.\n. \n\nCoverage decreased (-0.0003%) to 99.353% when pulling 6312f85180843af58eb08a8573e52770a6bf7aae on ltvragr:patch-1 into 3017883bebd0e2355d97b00865351dc5cac20eeb on RubyMoney:master.\n. \nChanges Unknown when pulling 3abeb410fcadeac1f4230d68e34077aff97443a0 on mzahir:master into * on RubyMoney:master*.\n. \nChanges Unknown when pulling 4edd4dd43704a30aa6b68edd4efc9f51348ab3bc on radar:issue-272 into * on RubyMoney:master*.\n. \nCoverage increased (+0.0%) when pulling ed37f7544e2e8702ecf801afa1c29ca6ba0a276d on krishicks:master into 43caa0e5936110df3d57b03b66f3c32c807e7c1e on RubyMoney:master.\n. \nCoverage remained the same when pulling c76e4b23c4ddd8c14ab915fc3f1b6a4a6b848218 on Martin91:error-html-entity-for-CNY into af54c223b844c94ba2792fe4bb1ee52b73bab1a9 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 0c0329e9e9fc32e15c970289a4a958b398c88f53 on optional-mutex into 7186f2767908b417877cae8b7178d71ec287710f on master.\n. \nCoverage increased (+0.01%) when pulling 581a4bca25efe07da4899e01efc8eeb7489be9a0 on optional-mutex into 7186f2767908b417877cae8b7178d71ec287710f on master.\n. \nCoverage decreased (-0.0%) when pulling 68ca3116e935ca61ace1ee55c5bb72760f190ff3 on currency-refactor into e85303ac6222870b99c5affee5870aa7642c0c3e on master.\n. \nCoverage decreased (-0.0%) when pulling 02db9e0466c423b28a61c16b497f37723b6a0b9a on currency-refactor into e85303ac6222870b99c5affee5870aa7642c0c3e on master.\n. \nCoverage decreased (-0.04%) when pulling 2e410ee47659da12d3805b441d8e63a9acd62423 on refactor-format into 655f557dfc38250dba4ae752c5074c827dde4649 on master.\n. \nCoverage remained the same when pulling 7358b48befdfa33d326502c8ec2f8afe7da8772f on saurabhnanda:patch-1 into 655f557dfc38250dba4ae752c5074c827dde4649 on RubyMoney:master.\n. \nCoverage remained the same when pulling 709506a4dab60dc75b87db8a523b7ab1a8d9b5ab on saurabhnanda:master into 655f557dfc38250dba4ae752c5074c827dde4649 on RubyMoney:master.\n. \nCoverage decreased (-0.0%) when pulling 04a219ea3ee1f668f4d2afeba0e7dffd7b8b842c on saurabhnanda:master into 655f557dfc38250dba4ae752c5074c827dde4649 on RubyMoney:master.\n. \nCoverage remained the same when pulling ee57b37f377708fd6d93041eba0ac047bb39a94c on calebthompson:ct-nr-dont-warn-for-string-to_money into 581da4d188930078fbf3113bda857d1bfeab1d09 on RubyMoney:master.\n. \nCoverage increased (+0.04%) when pulling 63fb7a751854cfc9cfaf21d0395ed0b58650aae9 on 6.1.0 into 46e2a5768ea8f9ec1f94a473531f7b3cc1f848b3 on master.\n. \nCoverage remained the same when pulling 9c960a670d79356ab6f9320c370af1a718a5620e on ginter:fix-deprecation-warnings into 658b4b89b1824eb612e16baccf572ca110d4f01a on RubyMoney:master.\n. \nCoverage remained the same when pulling dc25cd0876f78d0521171a009aafe084fc20acca on JonathonMA:fix/money-rounding_mode into c668a16af88c3550edddef3582ced836def74f2c on RubyMoney:master.\n. \nCoverage remained the same when pulling e5bc6d7c9f95dd76701339bcc9c54c60b563f8c8 on nashbridges:new-manat into f777d3b602c60e24002fb08beb95d58bf0bfd874 on RubyMoney:master.\n. \nCoverage decreased (-0.12%) when pulling b395e53bff3fa92ee95a700e0b22279b1ae8739a on brixen:master into 36cd8a8eb37dee8572cfc6c57249c94c3f54590e on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 132c143f1a3cb1832402544adfe483441a8fa144 on CentroNet-Marketing:performance-improvements into 36cd8a8eb37dee8572cfc6c57249c94c3f54590e on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling bf832035878c249b96a4563b2f1f534a99ffb71e on CentroNet-Marketing:performance-improvements into 36cd8a8eb37dee8572cfc6c57249c94c3f54590e on RubyMoney:master.\n. \nCoverage decreased (-0.17%) when pulling 8a6075dc55bb7cf581e192ee0e8a167bc6712ac3 on CentroNet-Marketing:performance-improvements into 36cd8a8eb37dee8572cfc6c57249c94c3f54590e on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling ea6c2c9131da9e90df56c4e1a6e6718c19413b28 on CentroNet-Marketing:performance-improvements into 05f985f35442b512422803551177a161cc4531eb on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling ea6c2c9131da9e90df56c4e1a6e6718c19413b28 on CentroNet-Marketing:performance-improvements into 05f985f35442b512422803551177a161cc4531eb on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling ea6c2c9131da9e90df56c4e1a6e6718c19413b28 on CentroNet-Marketing:performance-improvements into 05f985f35442b512422803551177a161cc4531eb on RubyMoney:master.\n. \nChanges Unknown when pulling 0f1d72a3d17f19207833c553ab9a1dbc67a98cc0 on paulodiniz:master into * on RubyMoney:master*.\n. \nChanges Unknown when pulling 167c1d80348fe68b91c7787a5bd8f844b0e5c7ce on paulodiniz:master into * on RubyMoney:master*.\n. \nCoverage remained the same when pulling 2fb0f4a7e671af7328b8b585db89368e3ad63dfd on Matsarello:master into b2557bbd4c7f9891e8e85d4d1d3284f1aab27e72 on RubyMoney:master.\n. \nCoverage remained the same when pulling 708783fd3cf80c4235697c058e6450ce3250445a on padi:patch-1 into cfc788e92c7290fc7da1fa37ad090ff3bbf18fa6 on RubyMoney:master.\n. \nChanges Unknown when pulling 9fd01931ebfd279c433b4df291d933e83dc0ede6 on RKushnir:patch-1 into * on RubyMoney:master*.\n. \nChanges Unknown when pulling 9fd01931ebfd279c433b4df291d933e83dc0ede6 on RKushnir:patch-1 into * on RubyMoney:master*.\n. \nCoverage increased (+0.0%) when pulling 29d14c1840c8471aef15eb41e3df7021afe41f01 on fix-coerce into 3c1f74fb48c907f029b6dcb04b19c2422bfe82f2 on master.\n. \nCoverage increased (+0.01%) when pulling 21d90fe300311c4ddcca744e04163c56ddfbd7ba on fix-coerce into 3c1f74fb48c907f029b6dcb04b19c2422bfe82f2 on master.\n. \nCoverage increased (+0.01%) when pulling 6fe5c7fbf942e8ddff79a5193976659346d01af6 on fix-coerce into 3c1f74fb48c907f029b6dcb04b19c2422bfe82f2 on master.\n. \nCoverage increased (+0.01%) when pulling f808668509b5ebaf0511118e0fb33c629744e1c3 on fix-coerce into 3c1f74fb48c907f029b6dcb04b19c2422bfe82f2 on master.\n. \nCoverage decreased (-0.12%) when pulling 7358d492c76840bebbfcb13a5b6f9f07eccfbb6c on gballester:master into c433569fc30ba6d62901fdd6d6f0faf9256d6f56 on RubyMoney:master.\n. \nCoverage remained the same when pulling 1bf90cc4c956ad930c514a92a12bd1f607bfb5e6 on fliptheweb:patch-2 into c0557444b21f09338b672a270b2d9c913a441a95 on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling e34b19244464433c947f994890372fbbc616de4c on troelskn:fix-formatting-sek-and-nok into c0557444b21f09338b672a270b2d9c913a441a95 on RubyMoney:master.\n. \nCoverage decreased (-0.05%) when pulling 043ee8ed8d6ee4aa34b4c9fe351883e229fd2f7b on troelskn:fix-formatting-sek-and-nok into c0557444b21f09338b672a270b2d9c913a441a95 on RubyMoney:master.\n. \nCoverage remained the same when pulling ea3dbfd558b63dfec47162eca116b72743c068ca on troelskn:fix-formatting-sek-and-nok into c0557444b21f09338b672a270b2d9c913a441a95 on RubyMoney:master.\n. \nCoverage remained the same when pulling 93ae57606bbb6497c07a1e5e5adee56a00f0f592 on troelskn:fix-formatting-sek-and-nok into 393b67850bbca1a29dd0f6d3c0f61028aaf742d1 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 8abda3dc1fbc0ff36c85d81c90d1fa86f0bcf722 on tjhart:fix-rounded_infinite_precision-with-use_i18n-as-false into e0a1f2c9f91a694d1773fbb1b34be9e30c364382 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 56178f82796ea6f71992b8b520109bda2821d5a0 on tjhart:fix-rounded_infinite_precision-with-use_i18n-as-false into e0a1f2c9f91a694d1773fbb1b34be9e30c364382 on RubyMoney:master.\n. \nCoverage remained the same when pulling 615befd862e69886bd67d9deb1657f2c671903bc on jerhinesmith:master into e0a1f2c9f91a694d1773fbb1b34be9e30c364382 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 615befd862e69886bd67d9deb1657f2c671903bc on jerhinesmith:master into e0a1f2c9f91a694d1773fbb1b34be9e30c364382 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling 15d7b1dc28f3ba060e04ca9f3a8b77e321a943d2 on jerhinesmith:master into c1ee53f0dc82569bef621b7e7a56a74577b14087 on RubyMoney:master.\n. \nCoverage decreased (-0.23%) when pulling b1a30668a9419ac5b89a7912343038d0e360a6a3 on tweymuth:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 718bbc853bc0f9602c71926db3a19b1a6b5b80b6 on tweymuth:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling a89091a481a778d742819fa5784d7ee61e27db60 on tweymuth:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 2d7d4a70790ecde8b34c7d921499ce40447bd811 on tweymuth:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage remained the same when pulling 7bcda1445f0436ccbf04eaa8ead579821e390235 on georgemillo:master into 8016360fd4d2ad2fe8fd043c095bb1b9e49a7b13 on RubyMoney:master.\n. \nCoverage remained the same when pulling 7e5d0da727b5c2bbc9862f5185556f8501b48e0c on shpupti:master into fae74d08f67f617f5dff1c71498d8169fafe2f7a on RubyMoney:master.\n. \nCoverage remained the same when pulling c01e4f905535518954f566c2fdbf572ee3ab67b8 on shpupti:master into fae74d08f67f617f5dff1c71498d8169fafe2f7a on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling b7bc13b721174b82740967646ed04fee5a6fe7cd on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling c0f1e73bf81c71982ae4e919461fe3b106bd4ccb on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 0403d2f67e56e18a4fd55bb9c8107a3291a1d3e3 on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 41ae26d6d696f998229be57cadc4feffd731180a on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage increased (+0.01%) when pulling 7bb542e6121a119f91f5512db4bb800dbde2276f on edwinv:master into 6838873f0582f6e9e0b2055705e956d035761929 on RubyMoney:master.\n. \nCoverage remained the same when pulling b5a471931b653b1cfef09390873796a600545bc7 on arthurtalkgoal:master into 3d2b34a879fc30291b9c330062d24799e65f4fad on RubyMoney:master.\n. \nCoverage decreased (-0.45%) when pulling 52d66ef3e1ba3a7ab489382884d9a688914b9f7b on ggilder:fix-vnd-subunit into ff0bf0b895ca93e125a017900b7fb68d6666b702 on RubyMoney:master.\n. \nCoverage remained the same when pulling 0152bcf899a257f1a081582c397ed04c0d2c4a03 on ggilder:fix-vnd-subunit into ff0bf0b895ca93e125a017900b7fb68d6666b702 on RubyMoney:master.\n. \nCoverage remained the same when pulling 3c83b0fcfaf803646314a6668128cc93e81dc291 on tweymuth:master into 11491ce48c32561bccfaf1d3bb57d74d6e8c1514 on RubyMoney:master.\n. \nCoverage remained the same when pulling d9ee5f3d00971bc6235818c89d78daffc096422e on BRMatt:patch-1 into 7df3e6d3c2d31a2eda8ebd5b56eaf046612cecbb on RubyMoney:master.\n. \nCoverage remained the same when pulling d1acabe7b64ce558de16a79902075b725306b1c4 on ggilder:fix-rub-symbol into 105036b1f059f3593b1d7af97d96dec70d8f83f5 on RubyMoney:master.\n. \nCoverage remained the same when pulling 048ab7df1b43ba32787b20ecf7d4664dc334bdaa on ggilder:fix-try-symbol into 105036b1f059f3593b1d7af97d96dec70d8f83f5 on RubyMoney:master.\n. \nCoverage remained the same when pulling 9c1a0fbbc6c847fd386f8bde6b260e27c02a0de6 on ggilder:ignore-coverage into a42e2b140f6fed9fa5104c2c0fc66c07a22e9e7a on RubyMoney:master.\n. \nCoverage remained the same when pulling 632bdec51802721d320fced24dc4f72bef31d33c on shpupti:master into c9696907ab798db170f4ea899cfa09084454f395 on RubyMoney:master.\n. \nCoverage remained the same when pulling 9f54d7f8917784dd9a565eccd9db85fc8dbeed69 on zacksiri:master into c9696907ab798db170f4ea899cfa09084454f395 on RubyMoney:master.\n. \nCoverage remained the same when pulling 25a0e449ea429d797be434af5e299b6e80040784 on sigra:master into 0f7e1565670e5bf345c16eac7c79cc44c4445264 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling fd8f29fd77956e05eae0c84dbef347b2a70daaab on mateusg:master into e42371c3ccb671740b0942e8a390d6ec43454d63 on RubyMoney:master.\n. \nCoverage increased (+0.0%) when pulling d2384d84e2c50071c03d1bd707d680ce6d3cb278 on mateusg:master into e42371c3ccb671740b0942e8a390d6ec43454d63 on RubyMoney:master.\n. \nCoverage decreased (-0.09%) when pulling 80447c5bc8fae1b3b2c286b3104aed3087afb081 on lulalala:compare_different_currency_precision into c9f547e8c20a377446fcc9506e53e3b91cab69b4 on RubyMoney:master.\n. \nCoverage decreased (-0.11%) when pulling 38e224895ac8cce48fc503f147f8c6e5f0205dcf on vandrijevik:patch-1 into 7c82f6c71c1f0957b97f7aaa31b27c6d453764eb on RubyMoney:master.\n. \nCoverage remained the same when pulling 3abbcfae86f5e9a0e88b375918613183687e5225 on TinkerDev:master into b07481a6c330dc0cc1c88b05f78f97c7761b9402 on RubyMoney:master.\n. \nCoverage remained the same when pulling 9580358603fcf10501578cbe90aeff11ddac6456 on raphaelcosta:master into b07481a6c330dc0cc1c88b05f78f97c7761b9402 on RubyMoney:master.\n. \nCoverage remained the same when pulling deca5e8f42148b968f8d86fdbe07144ec752526c on geetfun:master into b07481a6c330dc0cc1c88b05f78f97c7761b9402 on RubyMoney:master.\n. \nCoverage increased (+0.18%) when pulling ae293095cd461e3396523016f0c6a5bf937f7339 on aripollak:ruby-2.2.0-deprecation-fix into 82e3f5cf97bd31384ba8b5ccf3c14f6da23f2ddc on RubyMoney:master.\n. \nCoverage increased (+0.18%) when pulling 83313a40b5540a01b5e81366357429e7df002745 on aripollak:ruby-2.2.0-deprecation-fix into 82e3f5cf97bd31384ba8b5ccf3c14f6da23f2ddc on RubyMoney:master.\n. \nCoverage remained the same when pulling c0668e44eaafc3f34039f9d4747f6a1c518c4ad9 on safakgur:fix-try into 917369d51870fd76510aa1fa8ac73b9e9846562b on RubyMoney:master.\n. \nCoverage remained the same when pulling ce46d036ac02f1657f9d9178508e050c8225cd06 on levady:update-idr-currency-iso into becb6cd64d7722fdd81bac9c70b5889c4d69fcae on RubyMoney:master.\n. \nCoverage remained the same when pulling abc279fcbd3b0970c8152261cbbf605b9d21c98b on parentheses into becb6cd64d7722fdd81bac9c70b5889c4d69fcae on master.\n. \nCoverage increased (+0.0%) when pulling ba1cca03b20dc49e38378ff60ca99116b488f23b on constructors into becb6cd64d7722fdd81bac9c70b5889c4d69fcae on master.\n. \nCoverage increased (+0.0%) when pulling 11f838af4213962fb6e401a038c497bc0d04941a on constructors into 6a3398933d81f6c676835abd3fc9dd17248adb9b on master.\n. \nCoverage increased (+0.0%) when pulling aea6a9ee86147bcdda660bd6f1fdee26b51eeed5 on register into 6a3398933d81f6c676835abd3fc9dd17248adb9b on master.\n. \nCoverage increased (+0.0%) when pulling bd17234c91d105b60a5011620e2c80c0770771bb on initialize into 31ad320677fd1a4c3167cce53cc1763a00889100 on master.\n. \nCoverage increased (+0.0%) when pulling 2bf937e7bfcb91055281e75d06a43e08048a389a on symbol_position into 379671b2a1e8a418698427b31848539bb843c211 on master.\n. \nCoverage remained the same at 99.78% when pulling 161d36d81811ab3bb54037a996ce3a0e90eed459 on jasonahooper:master into 6aa9633493f0a1fd1f0033e9146034fdffa755fa on RubyMoney:master.\n. \nCoverage remained the same at 99.78% when pulling 55255ca702f23d23cb31bba94a674488323ae88b on abatko:patch-1 into f643921cbf7cd4c19677c3b7a76831fa88705226 on RubyMoney:master.\n. \nCoverage remained the same at 99.78% when pulling 28d22c414b49b4b40b63a91d27c07d87e6cd52b0 on jkingdon:swaziland-symbol into f643921cbf7cd4c19677c3b7a76831fa88705226 on RubyMoney:master.\n. \nCoverage remained the same at 99.78% when pulling 7810d3f8f0562987235c2ae8c04c53a16d9f74e8 on seongreen:improve-byr-format into 33c19117d20d1b70893ad4a93bfb581ada7a5e90 on RubyMoney:master.\n. \nCoverage decreased (-0.12%) to 99.79% when pulling 0659f2bc4383373f550ab8e8ac5da84fba7c66a4 on currency_enumerable into 5d5cef6bb2df58220fc00af44126cf01a8648140 on master.\n. \nCoverage remained the same at 99.79% when pulling 8a30f522728c1951fde0eccab95f0095f3ccab2d on cade:master into 6d97813511f884fd543c3ebfaa6c6b262eff03d2 on RubyMoney:master.\n. \nCoverage decreased (-0.08%) to 99.71% when pulling d36f9f95c7c6e423fa1d44bfdde773d295ca1048 on douglasmiller:master into d9e0bd88562f48a4666c02b04acf9ba8e64a454b on RubyMoney:master.\n. \nCoverage decreased (-0.04%) to 99.75% when pulling 30f085a1f53a7c03bd45ae993b367fe3374a66d4 on arthurkarganyan:patch-1 into d9e0bd88562f48a4666c02b04acf9ba8e64a454b on RubyMoney:master.\n. \nCoverage remained the same at 99.79% when pulling bfa7108e1d085f7518ff979db4b8c9cb1b1b1e3f on cade:fix-clf-exponent into e0eb7a5f8296a8c0761d2dfadbc763fca102bdbb on RubyMoney:master.\n. \nCoverage decreased (-0.0%) to 99.71% when pulling e3af22ff83950518481ed52682f934bea29cc076 on mikerodrigues:master into ed04ecf88b967be7a2e24917f1e506288b7b12c6 on RubyMoney:master.\n. \nCoverage decreased (-0.0%) to 99.71% when pulling e3af22ff83950518481ed52682f934bea29cc076 on mikerodrigues:master into ed04ecf88b967be7a2e24917f1e506288b7b12c6 on RubyMoney:master.\n. \nCoverage increased (+0.01%) to 99.71% when pulling e9583be9215c9e75b4ddc90851df9563d88c0b0d on ismasan:decouple_rate_store into ae9f9291685aa746067778008e4756c6c2bce766 on RubyMoney:master.\n. \nCoverage increased (+0.01%) to 99.71% when pulling 8cf70ab8f885a88d8a87ffb83b916c1000881aee on ismasan:decouple_rate_store into ae9f9291685aa746067778008e4756c6c2bce766 on RubyMoney:master.\n. \nCoverage increased (+0.0%) to 99.71% when pulling 668c0e0320cfae5e016a271c993d0ff40505307f on thread_safe_memory_store_transaction into b04d8a7e881e0c51ed9d8af0f3b3351595cbc625 on master.\n. \nCoverage increased (+0.0%) to 99.72% when pulling 3285c01ab7ffb1e5c1c4a322255765b25e987be8 on printercu:patch-1 into 03c2034e7674097d536f084f40c57770411550a9 on RubyMoney:master.\n. \nCoverage remained the same at 99.338% when pulling 28890983e36992b2de1092163a8b938615bd9b84 on r11runner:readme-typo into 39b617cca8f02c885cc8246e0aab3e9dc5f90e15 on RubyMoney:master.\n. \nCoverage increased (+0.004%) to 99.342% when pulling 6c9b7274b63b3543e487a0b4f15daf0edefffb49 on printercu:master into fea316e85510c8d6d7748af94c80f37deebafc71 on RubyMoney:master.\n. \nCoverage remained the same at 99.338% when pulling 2afea67900324e01145d4caa22dd34cfe0050d3e on insphire:aed-symbol into fea316e85510c8d6d7748af94c80f37deebafc71 on RubyMoney:master.\n. \nCoverage increased (+0.002%) to 99.344% when pulling 8f2b7254198855b5fc5bcbe955e7cfc7b950460f on hoverlover:feature/fr-CA into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.002%) to 99.344% when pulling 44d294bbd484f3d103cf403b812726bfdb613c63 on hoverlover:feature/fr-CA into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.003%) to 99.345% when pulling 2d5cc69041901f379b0990638aef76d277ae998c on hoverlover:feature/fr-CA into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-55.4%) to 43.936% when pulling 83924f9b9031fb91ccf602dab913a999dc58d269 on printercu:v7 into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-0.8%) to 98.507% when pulling 91dc5ed6bc5a75ec8b72f34789a40e70657264af on printercu:v7 into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-0.8%) to 98.507% when pulling dad5733917f97ce0372af948829e32d842522215 on printercu:v7 into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-1.0%) to 98.362% when pulling 843707025a802e8047767918d9f4d1c7674b5a9c on printercu:v7 into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.07%) to 99.41% when pulling a1dffe1baca6b9506d1c6584e82ce0088ec5c902 on printercu:v7_part0 into 6c9b7274b63b3543e487a0b4f15daf0edefffb49 on RubyMoney:v7.\n. \nCoverage increased (+0.07%) to 99.41% when pulling 7d37cb74421776d308a35ad1b5167baaf58ab99b on printercu:v7_part0 into 6c9b7274b63b3543e487a0b4f15daf0edefffb49 on RubyMoney:v7.\n. \nCoverage increased (+0.07%) to 99.41% when pulling 7d37cb74421776d308a35ad1b5167baaf58ab99b on printercu:v7_part0 into 643d27edbb87ce7a317cb3140f8bfb34aa2d9ec7 on RubyMoney:v7.\n. \nCoverage increased (+0.4%) to 99.781% when pulling bf76588605e586ea86f49e1211bc7d634e31d615 on printercu:conversion_errors into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.04%) to 99.383% when pulling 9814398630741ceaa512ac1c523e848fc1111926 on printercu:conversion_errors into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage increased (+0.04%) to 99.382% when pulling fa5096486ac841eb570217752b8b88c779bc9f79 on printercu:conversion_errors into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.226% when pulling 1b004edd5dbc7e69316eba8a68307d34f84b3a3b on printercu:divmod into e5716501d02d3b6e2f99b5dd619da2152e043378 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.195% when pulling 7b47115c393b3baf7a7d186a287459d40f30abfb on netmask:master into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling eb19812141c96dba18e76004bf20f7dcdee660e9 on netmask:master into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 9be8ba29ab905e3772b1db6d31b9b5427ffc853f on seongreen:add_byn_currency into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 9d376021f0ca1d7a186134b28dae1135b408fbd2 on seongreen:add_byn_currency into d090daa09620125b11218405e45ef2356601d579 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 02e15601e6a5951959d1ea230f12cd76c3a9d095 on naps62:mp-readme into d20bfea68ac14d744cdf8e79c756eed4f81af981 on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 65e85eaf1287b74d9530919f3f5c326161fa5e0e on ajahongir:fix/uzs-syntax into 8b97ebc8ff252e4d534193eac209531e90097d4b on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling 4786041cb33cbae1cf81456ba86353ea42473220 on ajahongir:fix/uzs-syntax into 8b97ebc8ff252e4d534193eac209531e90097d4b on RubyMoney:master.\n. \nCoverage decreased (-68.0%) to 31.38% when pulling 9427ce0f2994169d23de7f55f430e7f2e2df581e on ajahongir:fix/uzs-syntax into 8b97ebc8ff252e4d534193eac209531e90097d4b on RubyMoney:master.\n. \nCoverage remained the same at 99.341% when pulling b25896381618abfc3843f197feb5639949b77504 on ajahongir:fix/uzs-syntax into 8b97ebc8ff252e4d534193eac209531e90097d4b on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 18b17f9225a67ecfb6131ddfd01bac40780054d6 on yenshirak:fix-huf into bc1781d2f76484af84d58d334719f170a6c6de0f on RubyMoney:master.\n. \nCoverage increased (+0.0007%) to 99.382% when pulling 535769a2c7287e6d12761701d8fcb5220fb64e3f on rubemz:refactor/currency-find into 90dfbda64ba6f88bcd836464c606624d2141b8e3 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 42fc721805b62228cf9ec5b78dfac8123163596e on mention-mit-in-license into 90dfbda64ba6f88bcd836464c606624d2141b8e3 on master.\n. \nCoverage remained the same at 99.382% when pulling 4e96ceb6a6fcbd8f4a93fdb9473e93c95928c9a5 on naps62:mp-uphold into 35b71b92c817a92499d87ecd8c05b09e84fbef91 on RubyMoney:master.\n. \nCoverage decreased (-0.03%) to 99.35% when pulling 9e8f923cdeaec1221f60f03ea175c565caf389f3 on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 137f35017f9e7915b2bb7c18464c38f48088e996 on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 20733f54606afc17a108eb68327e66816971cebc on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 20733f54606afc17a108eb68327e66816971cebc on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage increased (+0.4%) to 99.781% when pulling 20733f54606afc17a108eb68327e66816971cebc on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 810d1e7555f6c32a6b3ab8785c570de979cee9a4 on we138:add-currencies into e86aa7e91b15c6222dbde8997d459445974b7bb6 on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 1d720c8a0c36ab6f7aa7d50ea3bd3929cd3b456a on jdatti:master into aa20a622a35ee21dccfa647b74fc665e5a70ae3a on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling 844bbbb4e96c619f478356a8a72bea1ddf5aaefa on antstorm:fix-ruby-1-9-json-issue into aa20a622a35ee21dccfa647b74fc665e5a70ae3a on RubyMoney:master.\n. \nCoverage remained the same at 99.382% when pulling c2f914d0951e95b77d809d81510104e0c792f9be on antstorm:update-rubies into a529382b91dd1c4ec0a29e07d9f0e42e21ffd828 on RubyMoney:master.\n. \nCoverage decreased (-0.002%) to 99.379% when pulling fef4439b6d335b67b8f30192dd5dc96722542d44 on to_refactoring_case_statement into 1d17a813462d5d16b8d3fbc6ad11075bb2a6ceb6 on master.\n. \nCoverage decreased (-0.002%) to 99.379% when pulling a82e2ccb561a2ce5123fb34dab24e081e131f1ff on to_refactoring_case_statement into 1d17a813462d5d16b8d3fbc6ad11075bb2a6ceb6 on master.\n. \nCoverage decreased (-0.002%) to 99.379% when pulling dc6186fc73b516fd10093eaa711bc577521dab79 on to_refactoring_case_statement into 1d17a813462d5d16b8d3fbc6ad11075bb2a6ceb6 on master.\n. \nCoverage decreased (-0.002%) to 99.379% when pulling 703e93f43ec6d897ddf58ad77a6de64c78b304ac on to_refactoring_case_statement into 1d17a813462d5d16b8d3fbc6ad11075bb2a6ceb6 on master.\n. \nCoverage increased (+0.4%) to 99.78% when pulling 421359b0a3f4aa09fc2c01f799bd26f07de0691f on MiguelBel:update-to-iso-4217 into c67bf62a92d0984a5b3266293957686743578a3c on RubyMoney:master.\n. \nCoverage remained the same at 99.379% when pulling 3101baf619ef0064d67c7cd93f75d8dd790e1037 on MiguelBel:update-to-iso-4217 into c67bf62a92d0984a5b3266293957686743578a3c on RubyMoney:master.\n. \nCoverage remained the same at 99.379% when pulling c3ab1bc86b0e69f3501f58baaab45c57cb25a68b on antstorm:fix-ruby-193 into c67bf62a92d0984a5b3266293957686743578a3c on RubyMoney:master.\n. \nCoverage decreased (-0.003%) to 99.376% when pulling c20176cd180538aee124babac83eeee0ce48d9de on yukihariguchi:remove_localize_formatting_rules into 5630a70ed7f533c25a8c62b74116579c63d4aae0 on RubyMoney:master.\n. \nCoverage increased (+0.0005%) to 99.38% when pulling 6b288935c20bbf87f5452d8cf8866a94fba463b2 on antstorm:add_test_for_currency_as_string into 5630a70ed7f533c25a8c62b74116579c63d4aae0 on RubyMoney:master.\n. \nCoverage increased (+0.002%) to 99.382% when pulling 37e76ea5410d9503589d3dbe730f971f40b68768 on antstorm:fix-for-negative-amount-allocation into 0887443cd8bc74466560d638bb7bf00ff0d4613d on RubyMoney:master.\n. \nCoverage increased (+0.0004%) to 99.382% when pulling 1df2f31188d585394fea7426a646ff37897eefe9 on antstorm:fix-exchange-issues-with-bigger-numbers into 47ca1202651d032c85d036cb0aeadd8b8b8618bf on RubyMoney:master.\n. \nCoverage increased (+0.008%) to 99.39% when pulling 1bd9b5f1e6659bdf277a79ba27c20315bc8d3929 on rodolfospalenza:master into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.3%) to 99.122% when pulling 548369522e2a94ea6f75121233dbdba7ccf3e041 on kaspernj:exchanged_at_support into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.3%) to 99.122% when pulling 548369522e2a94ea6f75121233dbdba7ccf3e041 on kaspernj:exchanged_at_support into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.24% when pulling e7634fa9b1380c32c948a8f8e973b366c941f5f7 on kaspernj:exchanged_at_support into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.233% when pulling dcbe43b6250ad28d68d9d828cdaa275b72e2c087 on xssc:patch-1 into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.1%) to 99.273% when pulling c85432ebaf5e0c0178a2ae75fe8ce592daf36aaa on antstorm:fix-ruby-1-9-3 into e2773f7859b268965fa003e2630ed58e7e96ac58 on RubyMoney:master.\n. \nCoverage decreased (-0.04%) to 99.233% when pulling 76100eaf6484927417bd67272226c02763fd5b44 on spk:allow-fail-rbx into 9b2421dc3149454af5d4027b2ffe65d184d5793b on RubyMoney:master.\n. \nCoverage increased (+0.004%) to 99.277% when pulling 13f646b68a27736d6687423c03577b19ee638d8e on project-eutopia:disambiguate_and_symbol_options_work_together into aa35ebdd50fae6f4a31d47ab596974b74a2f6e19 on RubyMoney:master.\n. \nCoverage increased (+0.004%) to 99.277% when pulling f401e30d9144bba1ff4ca607bb0b3ff85f8b31af on project-eutopia:disambiguate_and_symbol_options_work_together into aa35ebdd50fae6f4a31d47ab596974b74a2f6e19 on RubyMoney:master.\n. \nCoverage increased (+0.004%) to 99.277% when pulling f401e30d9144bba1ff4ca607bb0b3ff85f8b31af on project-eutopia:disambiguate_and_symbol_options_work_together into aa35ebdd50fae6f4a31d47ab596974b74a2f6e19 on RubyMoney:master.\n. \n\nCoverage increased (+0.7%) to 99.961% when pulling 355dc94535b916e7dae8ca863dbf2b1efaa15b22 on guilleiguaran:patch-1 into 5a9b970ca4c13d2721217acbd63327a328882105 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.277% when pulling d192cad71932c60b6d301a49a93e81b756ea7352 on antstorm:precache-i18n-calls into b07a9d994f26768fcb746c9936d4bb664b629d0d on RubyMoney:master.\n. \n\nCoverage decreased (-0.002%) to 99.275% when pulling 05fec49e765bc6f1ef39724e6703daec1d7e5d8f on antstorm:precache-i18n-calls into b07a9d994f26768fcb746c9936d4bb664b629d0d on RubyMoney:master.\n. \n\nCoverage remained the same at 99.277% when pulling bcd133b51319f3945fff4db2811790421181ad89 on prokopsimek:patch-1 into b07a9d994f26768fcb746c9936d4bb664b629d0d on RubyMoney:master.\n. \n\nCoverage remained the same at 99.277% when pulling fb6402307a652edc4f60911a7ecb4e282999baed on pda:remove-post-install-message into 7ba1c8e468e722a246c7bad6594ee55adec57ed4 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.275% when pulling e31a705b067fe848b4b9021323c1b9b7582c3e41 on antstorm:add-2-4-0-build-target into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:ruby-2-4-0.\n. \n\nCoverage remained the same at 99.275% when pulling 22cf221d632456aadfbb42ec0dcd06a5746b10f2 on antstorm:fix-ruby-2-4-0-deprecation-warnings into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:ruby-2-4-0.\n. \n\nCoverage remained the same at 99.275% when pulling 8a9a7a115fd4bba1f901e950c0be7fd4b51ecd3e on ruby-2-4-0 into ddf506aa289042379212ecc1715a33cee88687d0 on master.\n. \n\nCoverage remained the same at 99.275% when pulling 8a9a7a115fd4bba1f901e950c0be7fd4b51ecd3e on ruby-2-4-0 into ddf506aa289042379212ecc1715a33cee88687d0 on master.\n. \n\nCoverage remained the same at 99.275% when pulling ada9b9b8f280452f8552c5f440b0138b20b7a0cb on ruby-2-4-0 into ddf506aa289042379212ecc1715a33cee88687d0 on master.\n. \n\nCoverage remained the same at 99.275% when pulling ad7794c8294a726793405d08976c2e45789da851 on ruby-2-4-0 into ddf506aa289042379212ecc1715a33cee88687d0 on master.\n. \n\nCoverage remained the same at 99.275% when pulling 05431c5c3164e77f2451bf8e37322ac6b78a4683 on Nerian:ruby-2.4 into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.275% when pulling 05431c5c3164e77f2451bf8e37322ac6b78a4683 on Nerian:ruby-2.4 into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.275% when pulling f27c7b01c84327d88ffbed9b9e89b7069a9239e8 on Nerian:ruby-2.4 into ddf506aa289042379212ecc1715a33cee88687d0 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.277% when pulling 3450314cbcfc675df63dec757a63c92cacb61c3b on antstorm:fix-frozen-money-issue into ac882088513b3a77008b7db6d1c2e68caf2e3ef0 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.277% when pulling 4ceb81384aef6724914b9fd52e5c20d952270eaa on Azdaroth:eliminate-subunits-for-forints into c7999bd74cb710389082c2fc7ad4ea3ee82536e7 on RubyMoney:master.\n. \n\nCoverage increased (+0.04%) to 99.277% when pulling 0323a986c6581c9c57c9fdd71ed0d68099117459 on karthikmuralidharan:patch-2 into 7552ed68d563c169093676476142f36b6607ff47 on RubyMoney:master.\n. \n\nCoverage increased (+0.04%) to 99.279% when pulling fd919017575f3c588929b7b69e9de5599f8665d9 on karthikmuralidharan:patch-2 into 7552ed68d563c169093676476142f36b6607ff47 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.279% when pulling 7d2a065f6b7e6212fc11a09a84e7494800b880bf on antstorm:bump-i18n-version into 557561ef7259b8d2ab6a3603d0a5335e90842644 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.279% when pulling 536059a5598720789c872e79b1aff513f43c3346 on antstorm:fix-uzs into c7fd57690952ff0ac3fea782242110cb349ad5c5 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.279% when pulling 1e39abc35803737bc0d966eb462c7b22e143a4ad on komba:master into 26465abedc629a96196b5570b03d123c1ab64845 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.279% when pulling d1fb3d53297c115451108511c5d156b2d8d8eeb8 on lautis:i18n-version-relax into 190683e7b84b66d11b83b7be32d019cf3c2fc114 on RubyMoney:master.\n. \n\nChanges Unknown when pulling 1e5c5fd4a3c6c601bc1921fe9303bd59b31f639b on guilhermesimoes:master into  on RubyMoney:master.\n. \n\nCoverage decreased (-0.02%) to 99.259% when pulling faaeb1583959fb2157ba649f254291c7d0e98a36 on stereobooster:remove-heuristics-module into 0a56365295176fa845601133ddc3e6850514704c on RubyMoney:master.\n. \n\nCoverage decreased (-0.02%) to 99.262% when pulling 44e4e0d40a37cc28bbfc050257c3b39c006d384f on stereobooster:remove-heuristics-module into 0a56365295176fa845601133ddc3e6850514704c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 4f3dd2e9a1fa5b9b44f2332034791aba405c032c on livedo:patch-1 into 57480dae379ddb41875073e2af0ff9e34227fb15 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 49be6770627ccdb5d00883c3f20dce1433da97f1 on dilumn:master into 641e094de13136be8a22fe5d4f954e9d569ecd39 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 49be6770627ccdb5d00883c3f20dce1433da97f1 on dilumn:master into 641e094de13136be8a22fe5d4f954e9d569ecd39 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling e111bf5a4da3c95b5ffdada7f05522ded6c371ee on dilumn:master into 641e094de13136be8a22fe5d4f954e9d569ecd39 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 9be80a6ca57e5944022934045180ea354e92c20d on v6_8_3 into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on master.\n. \n\nCoverage remained the same at 99.262% when pulling 8bf3cee40367da2d904c7a258bd58d00202a8ce3 on jacksonh:bbd_symbol_first into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 8bf3cee40367da2d904c7a258bd58d00202a8ce3 on jacksonh:bbd_symbol_first into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 8bf3cee40367da2d904c7a258bd58d00202a8ce3 on jacksonh:bbd_symbol_first into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 42abad09a3751bb801350f96ad4be5d5f226e335 on archanasingh:nio-pab-symbol into 1622ed1ac3e0688416c3e3cc96609a79fdb5444c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 1f450f017ddbb81ca1f8fd01f0786fa72128af1b on archanasingh:nio-ambiguity into ec1c46b7f188a4fc82d530bd2e03a814ed4c6da5 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.262% when pulling 4d7bbfe5eb87208ec015114759b7756b04a81fde on v6_8_4 into 50a302f648af65ccbfd22ffd21a2ecc928bf6723 on master.\n. \n\nCoverage remained the same at 99.262% when pulling 61e6ef6225605e2dfa4508b98f9e19c8bab467cb on thilonel:huf-config-update into 88775214e5b80e409840b06dae03275597151fee on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage increased (+0.002%) to 99.264% when pulling e641a12720b623b9f7097b82bdcff4aa68073c2b on danschultzer:memory-store-marshal-dump into 5ecaa8da1508090fed7e7d30eb5f967689d93cc6 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.264% when pulling fc15a032f90a02f2b43855709b8ffbafa3192228 on orien:compare_zero into 3a126f4011e6abc420e07b40674cc27de854c9ae on RubyMoney:master.\n. \n\nCoverage increased (+0.004%) to 99.268% when pulling d2819ce91f3cf04858fe6e0ee93789fd8136f20b on orien:compare_zero into 3a126f4011e6abc420e07b40674cc27de854c9ae on RubyMoney:master.\n. \n\nCoverage increased (+0.005%) to 99.27% when pulling 516db28a9a93fb3f6dd1116373151f2d773d5353 on orien:compare_zero into 24682ba23c610ac2a1d9f9369fc67380d8e2a575 on RubyMoney:master.\n. \n\nCoverage increased (+0.004%) to 99.269% when pulling 8d7efc23cc37d02062721b6cb18e98881a677895 on orien:compare_zero into 24682ba23c610ac2a1d9f9369fc67380d8e2a575 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.264% when pulling 5bc31496e8439bcb535f1a79b7423b572ba9a477 on orien:build_rubies into 3a126f4011e6abc420e07b40674cc27de854c9ae on RubyMoney:master.\n. \n\nCoverage decreased (-25.5%) to 73.805% when pulling 5814bee2d087716dbd2f4100f2bc1e7009e19c3c on orien:eql into 6a1de2719c87113f2f062b4418ccd46988d1a3ac on RubyMoney:v7_new.\n. \n\nCoverage remained the same at 99.27% when pulling 4e17f22f3fdd280cf3367533e813d05218fa30de on kschutt:xts_iso_4217 into 6a1de2719c87113f2f062b4418ccd46988d1a3ac on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling 88b4848cf6dbfe55185746eea13fcc88b20a9bf6 on isaacsouza:readme_text_adjustment into 27b8b141e023b0a688cb562caee800808051e48c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling eacd877f63aa6693f98b807cd62c9745f1c07ee2 on isaacsouza:readme_text_adjustment into 27b8b141e023b0a688cb562caee800808051e48c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling 180156006092dc76975db654c05084dd735d81b7 on isaacsouza:readme_text_adjustment into 27b8b141e023b0a688cb562caee800808051e48c on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling 0e3a5cd043211d14e49ad7ce733bdfe9ae7c5a53 on adisos:patch-1 into 17cf0b82325ec186c36198091311411085e1ede7 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.27% when pulling 3b2e5d6bff2cc64e455655d2c03c4dd4020cdedc on antstorm:colorize-rspec-output into 42cbc3628cd1d47c945fb27515d669a1d20dcf5b on RubyMoney:master.\n. \n\nCoverage increased (+0.08%) to 99.351% when pulling 9d1427c7ec61172af38283448a666f0d7374172c on antstorm:fix-ars-html-entity into a19366501d38a80f8d43a4ba58e57fd66aa1400a on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling 88acbc990e2ffe0ab15001c74ead3ca12d1be391 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling eab27b80478e6743abc7d1116c6f0a4688c21675 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling eab27b80478e6743abc7d1116c6f0a4688c21675 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling 0f858f6525fdd03775f6d757a982337024755c14 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage decreased (-0.04%) to 99.309% when pulling 0f858f6525fdd03775f6d757a982337024755c14 on stanley90:add-cnh into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage remained the same at 99.351% when pulling e928b546ad9d3797b25499c74da33a861f0b59ae on antstorm:force-update-bundler into 9f3a02887f555b6377d4896dcbb57292712143cd on RubyMoney:master.\n. \n\nCoverage increased (+0.003%) to 99.354% when pulling 3efdff7b8a93fee7c379a39a371726ecb4d1b7ec on alexdunae:allocate-rationals into c57c081ad244cf2469608cceaa51d21427108773 on RubyMoney:master.\n. \n\nCoverage remained the same at 99.354% when pulling 1afe899fd6c73f5f9f4678c2c8c611e9311bcdb7 on jesuiswk:master into bbd5d98eb86af1a9db3f36b70efd7b3c54a5807a on RubyMoney:master.\n. \n\nCoverage remained the same at 99.354% when pulling 18be7d88fc5a7a3c5887d46f96e3f3fc38b97ad1 on Nerian:patch-1 into bbd5d98eb86af1a9db3f36b70efd7b3c54a5807a on RubyMoney:master.\n. \n\nCoverage remained the same at 99.354% when pulling a0c5598cc4f1f240a70b85c23e927eb60522e830 on Nerian:patch-2 into bbd5d98eb86af1a9db3f36b70efd7b3c54a5807a on RubyMoney:master.\n. \n\nCoverage decreased (-0.0003%) to 99.353% when pulling 6312f85180843af58eb08a8573e52770a6bf7aae on ltvragr:patch-1 into 3017883bebd0e2355d97b00865351dc5cac20eeb on RubyMoney:master.\n. ",
    "SergXIIIth": "Yep, problem can be solve by reorder Gemfile. I found sequence which cause issue.\n```\nsource 'https://rubygems.org'\nruby '1.9.3' \ngem 'rails', '~> 3.2'\ngem 'carrierwave-mongoid', :require => 'carrierwave/mongoid'\ngem 'yajl-ruby', :require => 'yajl/json_gem'\ngem 'money'\n```\n. Not really. I fix it by loading alternate json implementation AFTER gem money. So to solve use Gemfile like\n``` ruby\nsource 'https://rubygems.org'\nruby '1.9.3' \ngem 'rails', '~> 3.2'\ngem 'money' # should be before alternate json\ngem 'carrierwave-mongoid', :require => 'carrierwave/mongoid'\ngem 'yajl-ruby', :require => 'yajl/json_gem'\n```\n. Yep, problem can be solve by reorder Gemfile. I found sequence which cause issue.\n```\nsource 'https://rubygems.org'\nruby '1.9.3' \ngem 'rails', '~> 3.2'\ngem 'carrierwave-mongoid', :require => 'carrierwave/mongoid'\ngem 'yajl-ruby', :require => 'yajl/json_gem'\ngem 'money'\n```\n. Not really. I fix it by loading alternate json implementation AFTER gem money. So to solve use Gemfile like\n``` ruby\nsource 'https://rubygems.org'\nruby '1.9.3' \ngem 'rails', '~> 3.2'\ngem 'money' # should be before alternate json\ngem 'carrierwave-mongoid', :require => 'carrierwave/mongoid'\ngem 'yajl-ruby', :require => 'yajl/json_gem'\n```\n. ",
    "quasor": "Can you expand on this? What was the error?\n. Can you expand on this? What was the error?\n. ",
    "cathper": "@semmons99 README updated.\n. Merging ... just poke me if something is wrong :-)\n. An automagic matching could be along the lines of ([1-9][0-9]{0,2})+[,.\\s_]{0,1}[0-9]{1,2} and then the \u00a4 before or after? Isn't that good enough, or is it necessary to complicate it with a locale?\n. All currencies from currency.json has decimal_mark and thousands_separator so the first \"if\" will catch most use cases I guess. But I'm not sure if people actually use \".\" or \",\" consistently. I guess not. Therefore, I think that the intelligence that is in the \"else\" is what should happen by default (which is what I suggested, admittedly before I read the diff / file@e08e0e4). Just because someone chooses a currency, it doesn't mean that they will only parse numbers that uses the correct decimal_mark and thousands_separator \u2014 correct according to the currency (not a locale).\nI would consider both 6.000 and 6,000 equal to 6000 rather than 6. Especially since the parser doesn't know what locale the number was input via.\n. @semmons99 README updated.\n. Merging ... just poke me if something is wrong :-)\n. An automagic matching could be along the lines of ([1-9][0-9]{0,2})+[,.\\s_]{0,1}[0-9]{1,2} and then the \u00a4 before or after? Isn't that good enough, or is it necessary to complicate it with a locale?\n. All currencies from currency.json has decimal_mark and thousands_separator so the first \"if\" will catch most use cases I guess. But I'm not sure if people actually use \".\" or \",\" consistently. I guess not. Therefore, I think that the intelligence that is in the \"else\" is what should happen by default (which is what I suggested, admittedly before I read the diff / file@e08e0e4). Just because someone chooses a currency, it doesn't mean that they will only parse numbers that uses the correct decimal_mark and thousands_separator \u2014 correct according to the currency (not a locale).\nI would consider both 6.000 and 6,000 equal to 6000 rather than 6. Especially since the parser doesn't know what locale the number was input via.\n. ",
    "bcobb": "We did look at money-rails, and found that for our relatively simple needs (side-stepping Fixnum/BigDecimal Obsession, mostly), it was as easy to write and test our own serializer. We didn't realize, though, that an inline rescue caused us to succeed in spite of ourselves.\nThat pull request above has been modified and merged, and now Rails master will silently swallow this error.\nDo you think it would be worth clarifying this typecasting behavior with the Rails core team? That is: should value objects respond to coercion methods (e.g. to_i) if they are intended to be persisted as such?\n. We did look at money-rails, and found that for our relatively simple needs (side-stepping Fixnum/BigDecimal Obsession, mostly), it was as easy to write and test our own serializer. We didn't realize, though, that an inline rescue caused us to succeed in spite of ourselves.\nThat pull request above has been modified and merged, and now Rails master will silently swallow this error.\nDo you think it would be worth clarifying this typecasting behavior with the Rails core team? That is: should value objects respond to coercion methods (e.g. to_i) if they are intended to be persisted as such?\n. ",
    "dougdroper": "@semmons99 I have updated the changelog and added documentation.. Thanks\n. Sorry, can you close this pull request one in favour of https://github.com/RubyMoney/money/pull/242 \n. Thanks @semmons99 \n. Is there not already a split method that does this? \nhttps://github.com/RubyMoney/money/blob/master/lib/money/money.rb#L511\n. @semmons99 I have updated the changelog and added documentation.. Thanks\n. Sorry, can you close this pull request one in favour of https://github.com/RubyMoney/money/pull/242 \n. Thanks @semmons99 \n. Is there not already a split method that does this? \nhttps://github.com/RubyMoney/money/blob/master/lib/money/money.rb#L511\n. ",
    "scrooloose": "FYI, including this module is my current solution (https://gist.github.com/4609796). Its hacks, but I need to get something up and running for work.\nId say that there should be a Rate object - which would be a value object. Money::Bank::VariableExchange  would still have the same API except that it would return Rate objects instead of straight BigDecimals.\nRate would look something like\n```\nclass Rate\n    attr_reader :from, :to: :rate, :expiry_time\n ...\n\nend\n```\nExpiry time would be optional.\nThoughts?\n. FYI, including this module is my current solution (https://gist.github.com/4609796). Its hacks, but I need to get something up and running for work.\nId say that there should be a Rate object - which would be a value object. Money::Bank::VariableExchange  would still have the same API except that it would return Rate objects instead of straight BigDecimals.\nRate would look something like\n```\nclass Rate\n    attr_reader :from, :to: :rate, :expiry_time\n ...\n\nend\n```\nExpiry time would be optional.\nThoughts?\n. ",
    "danil-z": "i've tryed with any EUR value. it works fine but any RUB value it doesn't.\nformat(no_cents: true, thousands_separator: \".\")\n. i've tryed with any EUR value. it works fine but any RUB value it doesn't.\nformat(no_cents: true, thousands_separator: \".\")\n. ",
    "groe": "Taking you at your word ;-) #249 \n. I'm not sure if I understand exactly what your question is, but have you seen the options you can provide to the format method?\n. Taking you at your word ;-) #249 \n. I'm not sure if I understand exactly what your question is, but have you seen the options you can provide to the format method?\n. ",
    "halo": "Actually, my question was not primarily concerned with overwriting #to_s, but rather with being able to use #format without having to specify parameters each and every single time. I'd be fine using money.format in all my views, as long as I don't have to pass in the same arguments over and over again.\n\nOur prior suggestions is to write a helper method like def formatted_money(money)\n\nUnfortunately I'm not willing to leave object oriented programming behind and go back to functional programming. There is no incentive to use the money gem if I can reprogram it in helpers (because in that case Integers would be an as-good replacement for the gem ;). \n\nYou other option is to monkey-patch [...] but that isn't the safest way of going things\n\nI don't mean to be rude, but I interpret what you say as \"you could use money-rails, but you shouldn't, because it's monkey-patching the money gem\". (And only because it's the same maintainer, I wouldn't trust that it's always kept in sync). What if I would like to publish my formatting settings as a separate gem? I couldn't maintain synchronization with the money gem manually for the rest of my life.\nBut let me try to be more constructive than that! :) Why not simply move the code in money-rails that handles formatting over into the money gem itself? It doesn't introduce any backwards-compability problems (at least if you remove the alias_method_chain call) and does the job just fine. The money-rails gem would also become much less fragile. The #format method could simply precede the rules found in the global Money::Configuration module if any are present.\nWhat do you think?\n. I was thinking something along these lines. Would that be the right direction?\n. Actually, my question was not primarily concerned with overwriting #to_s, but rather with being able to use #format without having to specify parameters each and every single time. I'd be fine using money.format in all my views, as long as I don't have to pass in the same arguments over and over again.\n\nOur prior suggestions is to write a helper method like def formatted_money(money)\n\nUnfortunately I'm not willing to leave object oriented programming behind and go back to functional programming. There is no incentive to use the money gem if I can reprogram it in helpers (because in that case Integers would be an as-good replacement for the gem ;). \n\nYou other option is to monkey-patch [...] but that isn't the safest way of going things\n\nI don't mean to be rude, but I interpret what you say as \"you could use money-rails, but you shouldn't, because it's monkey-patching the money gem\". (And only because it's the same maintainer, I wouldn't trust that it's always kept in sync). What if I would like to publish my formatting settings as a separate gem? I couldn't maintain synchronization with the money gem manually for the rest of my life.\nBut let me try to be more constructive than that! :) Why not simply move the code in money-rails that handles formatting over into the money gem itself? It doesn't introduce any backwards-compability problems (at least if you remove the alias_method_chain call) and does the job just fine. The money-rails gem would also become much less fragile. The #format method could simply precede the rules found in the global Money::Configuration module if any are present.\nWhat do you think?\n. I was thinking something along these lines. Would that be the right direction?\n. ",
    "MarkPochert": "Thanks for you Replay. I found the solutions after a shower :-). The limit was created before i added the bank class for the exchange\n. Thanks for you Replay. I found the solutions after a shower :-). The limit was created before i added the bank class for the exchange\n. ",
    "jc00ke": "That was a quick merge, thank you!\n. Could we use transpec to automate some of the upgrade?\n. That was a quick merge, thank you!\n. Could we use transpec to automate some of the upgrade?\n. ",
    "geehsien": "Thanks!\n. Thanks!\n. ",
    "kachick": "Thanks to merge :)\n. OK.\nWhich is better?\n- All commits -> 1 commit\n- All commits -> 4 commits(divide by Class/Module)\n. I have just finished to squash them.\n. Thank you for your advice and merging ! :)\n. Thank you :)\n. Thanks to merge :)\n. OK.\nWhich is better?\n- All commits -> 1 commit\n- All commits -> 4 commits(divide by Class/Module)\n. I have just finished to squash them.\n. Thank you for your advice and merging ! :)\n. Thank you :)\n. ",
    "Eventect": "Terrific, thanks a lot.\n. Terrific, thanks a lot.\n. ",
    "radar": "My mistake, I hadn't realised 5.1.1 was released. It fixes this issue.\n. I spent some time today and tried to work out why it wasn't working, but couldn't. Some kind of regular expression voodoo magic is needed within regexp_format.\n. By moving the thousands separator code up within the formatting, I was able to fix this issue. All specs are passing on my machine and by the looks of it, Travis is greenlighting it too.\nPlease to be of the merging? :)\n. Thanks @semmons99 :)\n. Sounds like the best option. :+1:\nOn Tue, May 21, 2013 at 3:19 PM, Shane Emmons notifications@github.com\nwrote:\n\nI can get down with that.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/273#issuecomment-18232343\n. I really don't think Money.parse should be responsible for parsing strings like that. What you should be doing is splitting out the amounts and parsing them through Money.parse instead.\n\nMoney.parse can take a number of strings and checking to make sure that a string complies with the format that is expected should be the responsibility of the developer passing in the string, not the library itself. If it was also the responsibility of the library, then it would also slow down Money.parse.\n. Where are you seeing these zeroes displayed? Do you have some code which shows this issue?\n\u2014\nSent from Mailbox for iPad\nOn Mon, Nov 18, 2013 at 1:58 PM, Gaston M notifications@github.com\nwrote:\n\nHi,\nIt would be awesome if we had an option in format that strips insignificant zeros.\nHere is the regexp that RoR uses and works awesome over strings.\nsparator_escaped = Regexp.escape(separator)\nmoney_value_string.sub(/(separator)(\\d*[1-9])?0+\\z/, '\\1\\2').sub(/separator\\z/, '')\nThanks!\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/338\n. I like long stories :) Please share.\n. >= dependencies are bad because they allow for major breaking API changes. I would recommend that if you want this support, to fork this gem and apply a change such as ~> 0.7 instead.\n. My mistake, I hadn't realised 5.1.1 was released. It fixes this issue.\n. I spent some time today and tried to work out why it wasn't working, but couldn't. Some kind of regular expression voodoo magic is needed within regexp_format.\n. By moving the thousands separator code up within the formatting, I was able to fix this issue. All specs are passing on my machine and by the looks of it, Travis is greenlighting it too.\n\nPlease to be of the merging? :)\n. Thanks @semmons99 :)\n. Sounds like the best option. :+1:\nOn Tue, May 21, 2013 at 3:19 PM, Shane Emmons notifications@github.com\nwrote:\n\nI can get down with that.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/273#issuecomment-18232343\n. I really don't think Money.parse should be responsible for parsing strings like that. What you should be doing is splitting out the amounts and parsing them through Money.parse instead.\n\nMoney.parse can take a number of strings and checking to make sure that a string complies with the format that is expected should be the responsibility of the developer passing in the string, not the library itself. If it was also the responsibility of the library, then it would also slow down Money.parse.\n. Where are you seeing these zeroes displayed? Do you have some code which shows this issue?\n\u2014\nSent from Mailbox for iPad\nOn Mon, Nov 18, 2013 at 1:58 PM, Gaston M notifications@github.com\nwrote:\n\nHi,\nIt would be awesome if we had an option in format that strips insignificant zeros.\nHere is the regexp that RoR uses and works awesome over strings.\nsparator_escaped = Regexp.escape(separator)\nmoney_value_string.sub(/(separator)(\\d*[1-9])?0+\\z/, '\\1\\2').sub(/separator\\z/, '')\nThanks!\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/338\n. I like long stories :) Please share.\n. >= dependencies are bad because they allow for major breaking API changes. I would recommend that if you want this support, to fork this gem and apply a change such as ~> 0.7 instead.\n. \n",
    "ddrscott": "Thanks commit privs. Maybe some one can write a thing to scrape the ISO website and them make a Spec to make sure currency.json doesn't have any holes. I'll post it as a feature request...\n. I don't understand the philosophy of old currency and soon to be currencies. I'd think if there is an exchange rate OR an ISO code there should be some support for it. What is the utility of the Gem if the developer needs to make a decision to handle a case of a currency their holding in their hand or looking up in an rate table, but the Money gem says it's not valid?\nI believe the authority should be exchange rates. If some one can exchange it, the Gem should be able to display it. Put in another way, who should maintain the concept of a \"valid\" currency?\n. I agree the definition of \"someone\" is a bit broad and that we don't want to exchange goats or anything like that. I can live with the additional currency file if we name it config/currency_non_iso.json so there's no ambiguity about what's in there. I'd also recommend renaming the original config/currency_iso.json to be even more clear.\n. Now I know what \"bc\" meant, but wouldn't it be better just to put those entries into non_iso? That way as more currencies are needed, the developer doesn't need to decide between those two files?\n. Using locale is also consistent with iOS NSNumberFormatter class.\nhttps://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNumberFormatter_Class/Reference/Reference.html\nOn Apr 23, 2013 10:13 PM, \"Tim Evans\" notifications@github.com wrote:\n\nIMO, this should use ISO locales like Carmen does. The MSDN link I posted\ncovers a few corner cases and illustrates that formatting should not be\ncomposed with the currency- in fact, they seem to be orthogonal problems.\nThat means the correct solution is to supply a currency + locale to Money\nwhen formatting. And possibly having a top level configuration parameter so\nthis doesn't cause any backwards compatibility issues.\nAn example of how users might use this might be the following:\nMoney.locale = \"en_US\"cash_money = Money.new(50_000_00, \"USD\")cash_money.format# => $50,000.00cash_money.format(locale: \"fr_FR\")# => 50.000,00$\nMoney.parse(\"$50.000,00\")# => Money.parse(\"$50.000,00\", \"USD\", \"fr_FR\")# => \n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/276#issuecomment-16905911\n.\n. Thanks commit privs. Maybe some one can write a thing to scrape the ISO website and them make a Spec to make sure currency.json doesn't have any holes. I'll post it as a feature request...\n. I don't understand the philosophy of old currency and soon to be currencies. I'd think if there is an exchange rate OR an ISO code there should be some support for it. What is the utility of the Gem if the developer needs to make a decision to handle a case of a currency their holding in their hand or looking up in an rate table, but the Money gem says it's not valid?\n\nI believe the authority should be exchange rates. If some one can exchange it, the Gem should be able to display it. Put in another way, who should maintain the concept of a \"valid\" currency?\n. I agree the definition of \"someone\" is a bit broad and that we don't want to exchange goats or anything like that. I can live with the additional currency file if we name it config/currency_non_iso.json so there's no ambiguity about what's in there. I'd also recommend renaming the original config/currency_iso.json to be even more clear.\n. Now I know what \"bc\" meant, but wouldn't it be better just to put those entries into non_iso? That way as more currencies are needed, the developer doesn't need to decide between those two files?\n. Using locale is also consistent with iOS NSNumberFormatter class.\nhttps://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNumberFormatter_Class/Reference/Reference.html\nOn Apr 23, 2013 10:13 PM, \"Tim Evans\" notifications@github.com wrote:\n\nIMO, this should use ISO locales like Carmen does. The MSDN link I posted\ncovers a few corner cases and illustrates that formatting should not be\ncomposed with the currency- in fact, they seem to be orthogonal problems.\nThat means the correct solution is to supply a currency + locale to Money\nwhen formatting. And possibly having a top level configuration parameter so\nthis doesn't cause any backwards compatibility issues.\nAn example of how users might use this might be the following:\nMoney.locale = \"en_US\"cash_money = Money.new(50_000_00, \"USD\")cash_money.format# => $50,000.00cash_money.format(locale: \"fr_FR\")# => 50.000,00$\nMoney.parse(\"$50.000,00\")# => Money.parse(\"$50.000,00\", \"USD\", \"fr_FR\")# => \n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/276#issuecomment-16905911\n.\n. \n",
    "cbrunsdon": "Fair game, if I have to, I have to. Should I call it :html_wrap_symbol? \n. Fair game, if I have to, I have to. Should I call it :html_wrap_symbol? \n. ",
    "tim-evans": "I think it might be dependent on region, but that should be handled by how you define the what the currency specification is.\nHere's some notes on more complex cases where commas and full-stops aren't so simply interchanged:\nhttp://msdn.microsoft.com/en-us/goglobal/bb688126.aspx\nhttp://ux.stackexchange.com/questions/9105/international-currency-formatting-guidelines-currency-codes\n(FYI- I worked on this with @bhoggard, just so you know why I'm chiming in)\n. I think using Rails compatible locales would be a friendly way to do this. ~~IMO, this should use ISO locales like Carmen does.~~ The MSDN link I posted covers a few corner cases and illustrates that formatting should not be composed with the currency- in fact, they seem to be orthogonal problems. That means the correct solution is to supply a currency + locale to Money when formatting. And possibly having a top level configuration parameter so this doesn't cause any backwards compatibility issues.\nAn example of how users might use this might be the following:\n``` ruby\nMoney.locale = \"en_US\"\ncash_money = Money.new(50_000_00, \"USD\")\ncash_money.format\n=> $50,000.00\ncash_money.format(locale: \"fr_FR\")\n=> 50.000,00$\nMoney.parse(\"$50.000,00\")\n=> \nMoney.parse(\"$50.000,00\", \"USD\", \"fr_FR\")\n=> \n``\n. There's a few avenues that could be taken:\n- simply reference the gem from the README\n- use maguire as a backend for money'sformatmethod\n- provide hooks for maguire to hook into money'sformat` method nicely\nMy preference is deep integration, just because I think it would benefit both gems in terms of having a great data set for both currencies and formatting.\n. I totally hear you on that, and I can provide some help in doing so.\nAlso, there's another unmentioned option, which is to pull in the code into money itself (since there's already some data redundancy between the two in terms of symbols and currencies)\n. I think it might be dependent on region, but that should be handled by how you define the what the currency specification is.\nHere's some notes on more complex cases where commas and full-stops aren't so simply interchanged:\nhttp://msdn.microsoft.com/en-us/goglobal/bb688126.aspx\nhttp://ux.stackexchange.com/questions/9105/international-currency-formatting-guidelines-currency-codes\n(FYI- I worked on this with @bhoggard, just so you know why I'm chiming in)\n. I think using Rails compatible locales would be a friendly way to do this. ~~IMO, this should use ISO locales like Carmen does.~~ The MSDN link I posted covers a few corner cases and illustrates that formatting should not be composed with the currency- in fact, they seem to be orthogonal problems. That means the correct solution is to supply a currency + locale to Money when formatting. And possibly having a top level configuration parameter so this doesn't cause any backwards compatibility issues.\nAn example of how users might use this might be the following:\n``` ruby\nMoney.locale = \"en_US\"\ncash_money = Money.new(50_000_00, \"USD\")\ncash_money.format\n=> $50,000.00\ncash_money.format(locale: \"fr_FR\")\n=> 50.000,00$\nMoney.parse(\"$50.000,00\")\n=> \nMoney.parse(\"$50.000,00\", \"USD\", \"fr_FR\")\n=> \n``\n. There's a few avenues that could be taken:\n- simply reference the gem from the README\n- use maguire as a backend for money'sformatmethod\n- provide hooks for maguire to hook into money'sformat` method nicely\nMy preference is deep integration, just because I think it would benefit both gems in terms of having a great data set for both currencies and formatting.\n. I totally hear you on that, and I can provide some help in doing so.\nAlso, there's another unmentioned option, which is to pull in the code into money itself (since there's already some data redundancy between the two in terms of symbols and currencies)\n. ",
    "robotdana": "Something along the lines of :assume_fractional_format => indicator)\nIndicator could be a punctuation (',' or '.')\nCould be a locale ('us', 'en-us', 'eu') etc (useful when passing in a user's locale preference)\nCould be :from_currency (as we're currently doing)\nIf it's not there then do what we've always done...\n. It would be good to have a list of cases, including the ambiguous ones, then we can decide which ambiguous case should win, and when we need to raise parse errors rather than just assume things.\nI also think we should be considering correctness over backwards compatibility.\n. Something along the lines of :assume_fractional_format => indicator)\nIndicator could be a punctuation (',' or '.')\nCould be a locale ('us', 'en-us', 'eu') etc (useful when passing in a user's locale preference)\nCould be :from_currency (as we're currently doing)\nIf it's not there then do what we've always done...\n. It would be good to have a list of cases, including the ambiguous ones, then we can decide which ambiguous case should win, and when we need to raise parse errors rather than just assume things.\nI also think we should be considering correctness over backwards compatibility.\n. ",
    "aripollak": "Could you add something in the changelog to that effect? Something like \"Fixed bug that resulted in standard rounding of cents instead of banker's rounding\"\n. Could you add something in the changelog to that effect? Something like \"Fixed bug that resulted in standard rounding of cents instead of banker's rounding\"\n. ",
    "nambrot": "Hey guys, thanks for replying so quickly, I hope this helps\n```\n  money git:(master) rspec spec\n...................................................................................................................................................................................................................................................................................................................\nFinished in 0.27046 seconds\n307 examples, 0 failures\nRandomized with seed 35949\n\u279c  money git:(master) ruby -v\nruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-darwin12.0.0]\n\u279c  money git:(master) irb\n1.9.3p194 :001 > require 'money'\n => true \n1.9.3p194 :002 > Money.parse(\"\\U+FFE2\\U+FFAC100\")\n => # \n1.9.3p194 :003 > \n```\nIt seems like my setup is not working well with UTF-8, but I dont really know how to debug\n1.9.3p194 :003 > \"\\U+FFE2\\U+FFAC100\"\n => \"U+FFE2U+FFAC100\" \n1.9.3p194 :004 > \"\\U+FFE2\\U+FFAC100\".encoding\n => #<Encoding:UTF-8> \n1.9.3p194 :005 > __ENCODING__\n => #<Encoding:UTF-8> \n1.9.3p194 :006 >\n. It should be Euros. The parser works with \"5 EUR\", but it must be a Unicode issue if it can't detect the symbol, right?\n. Thanks for that. I didn't know that. Do you know what would cause that\nweird behavior when I paste it into the console?\nOn Mon, Jun 10, 2013 at 10:34 PM, Shane Emmons notifications@github.comwrote:\n\n@nambrot https://github.com/nambrot those unicode codes appear to be\nfor http://codepoints.net/U+FFE2 and http://codepoints.net/U+FFAC,\nneither of which are the EURO symbol (which is \\U+20AC). My guess is that's\nyour problem.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/issues/281#issuecomment-19224501\n.\n. For everyone who will find it in the future, apparently its a readline issue on MacOSX\n. Hey guys, thanks for replying so quickly, I hope this helps\n\n```\n  money git:(master) rspec spec\n...................................................................................................................................................................................................................................................................................................................\nFinished in 0.27046 seconds\n307 examples, 0 failures\nRandomized with seed 35949\n\u279c  money git:(master) ruby -v\nruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-darwin12.0.0]\n\u279c  money git:(master) irb\n1.9.3p194 :001 > require 'money'\n => true \n1.9.3p194 :002 > Money.parse(\"\\U+FFE2\\U+FFAC100\")\n => # \n1.9.3p194 :003 > \n```\nIt seems like my setup is not working well with UTF-8, but I dont really know how to debug\n1.9.3p194 :003 > \"\\U+FFE2\\U+FFAC100\"\n => \"U+FFE2U+FFAC100\" \n1.9.3p194 :004 > \"\\U+FFE2\\U+FFAC100\".encoding\n => #<Encoding:UTF-8> \n1.9.3p194 :005 > __ENCODING__\n => #<Encoding:UTF-8> \n1.9.3p194 :006 >\n. It should be Euros. The parser works with \"5 EUR\", but it must be a Unicode issue if it can't detect the symbol, right?\n. Thanks for that. I didn't know that. Do you know what would cause that\nweird behavior when I paste it into the console?\nOn Mon, Jun 10, 2013 at 10:34 PM, Shane Emmons notifications@github.comwrote:\n\n@nambrot https://github.com/nambrot those unicode codes appear to be\nfor http://codepoints.net/U+FFE2 and http://codepoints.net/U+FFAC,\nneither of which are the EURO symbol (which is \\U+20AC). My guess is that's\nyour problem.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/issues/281#issuecomment-19224501\n.\n. For everyone who will find it in the future, apparently its a readline issue on MacOSX\n. \n",
    "thrillcall": "If that is the case, shouldn't there be a spec that covers that scenario (concatenating multiple numbers into a new mythical number)?  I could not find one.\nThis feels like completely unexpected behavior.\nThere is a spec that covers throwing an argument error if there is a range (determined by checking for the presence of a '-' in the string.  This scenario also should potentially throw an argument error (multiple numbers found within a single string, separated by non-numeric chars).\nWould you accept a pull request that implemented that?\n. If that is the case, shouldn't there be a spec that covers that scenario (concatenating multiple numbers into a new mythical number)?  I could not find one.\nThis feels like completely unexpected behavior.\nThere is a spec that covers throwing an argument error if there is a range (determined by checking for the presence of a '-' in the string.  This scenario also should potentially throw an argument error (multiple numbers found within a single string, separated by non-numeric chars).\nWould you accept a pull request that implemented that?\n. ",
    "marcoow": "Hehe, thanks to @github for the one-click-merge-in-the-browser-button :+1: \n. Sounds cool but in my opinion as it's not really fundamental money functionality and probably only relevant for few projects, I'd say it sounds like sth. to go into a to-be-created money-ext gem or so.\n. Sorry, I somehow misread your original post - thought the proposal was to add the #exchange_with method to the money gem. I think adding an additional parameter to the + operator is not such a great idea actually as it's kind of a surprising syntax and not really necessary as it only saves a few lines...\nI'd say it would be much better syntax if you e.g. had sth. like this (also with this solution there would be no duplication in a hypothetical money-ext gem):\nruby\na = \"1 USD\".to_money\nb = \"1 GBP\".to_money\na + b.at(Date.yesterday, 'USD')\n. :+1:\n. Hehe, thanks to @github for the one-click-merge-in-the-browser-button :+1: \n. Sounds cool but in my opinion as it's not really fundamental money functionality and probably only relevant for few projects, I'd say it sounds like sth. to go into a to-be-created money-ext gem or so.\n. Sorry, I somehow misread your original post - thought the proposal was to add the #exchange_with method to the money gem. I think adding an additional parameter to the + operator is not such a great idea actually as it's kind of a surprising syntax and not really necessary as it only saves a few lines...\nI'd say it would be much better syntax if you e.g. had sth. like this (also with this solution there would be no duplication in a hypothetical money-ext gem):\nruby\na = \"1 USD\".to_money\nb = \"1 GBP\".to_money\na + b.at(Date.yesterday, 'USD')\n. :+1:\n. ",
    "ajoulie": "Thanks for the reply. \nI read the doc just after sending the issue. Sorry for that. \n. Thanks for the reply. \nI read the doc just after sending the issue. Sorry for that. \n. ",
    "jan": "Money..parse is one of my favorite features or Money. Please don't deprecate it.\n. Money..parse is one of my favorite features or Money. Please don't deprecate it.\n. ",
    "gustavolobo": "Thanks for your help mate :smile:\n. :astonished: \n. Thanks for your help mate :smile:\n. :astonished: \n. ",
    "ZenCocoon": "Thanks for the quick reply. My biggest issue was actually due to a bug in money-rails: https://github.com/RubyMoney/money-rails/pull/120\nI think a note in the ReadMe would have saved me 1-2 hours but it's only my 2 cents feedback ;-) Once looking into the API doc, it's clear what new_with_amount does so do not think it need any change on this side.\nThanks again for the quick reply.\n. Hi Shane, the API doc is well indicated and clearly nothing is missing here. You obviously know way better the proper use of the Money gem and the best practices that need to be in the ReadMe so let's keep it this way.\nThanks a lot for your time and work,\nS\u00e9b\n. Thanks for the quick reply. My biggest issue was actually due to a bug in money-rails: https://github.com/RubyMoney/money-rails/pull/120\nI think a note in the ReadMe would have saved me 1-2 hours but it's only my 2 cents feedback ;-) Once looking into the API doc, it's clear what new_with_amount does so do not think it need any change on this side.\nThanks again for the quick reply.\n. Hi Shane, the API doc is well indicated and clearly nothing is missing here. You obviously know way better the proper use of the Money gem and the best practices that need to be in the ReadMe so let's keep it this way.\nThanks a lot for your time and work,\nS\u00e9b\n. ",
    "asellitt": "@semmons99 we branched off of the 5.1.1 tag and made changes to that, so editing CHANGELOG creates (a minor) merge conflict. I'm happy to close this PR and re-open one with the changes on envato/money's master branch so that merging this in will be simple.\n. see: https://github.com/RubyMoney/money/pull/298\n. @semmons99 this should make the merge easier (see: https://github.com/RubyMoney/money/pull/297)\n. Good idea. :+1:\n. :+1:\n. @semmons99 we branched off of the 5.1.1 tag and made changes to that, so editing CHANGELOG creates (a minor) merge conflict. I'm happy to close this PR and re-open one with the changes on envato/money's master branch so that merging this in will be simple.\n. see: https://github.com/RubyMoney/money/pull/298\n. @semmons99 this should make the merge easier (see: https://github.com/RubyMoney/money/pull/297)\n. Good idea. :+1:\n. :+1:\n. ",
    "yinquanteo": "Since historical rates are often required, wouldn't it make sense to include it in the core infrastructure of the money gem?\nThe problem with creating a money extension gem is that a lot of the methods (such as in arithmetic) will have to be re-written with a lot of repetition. They'll have to be constantly re-synced whenever there is a new money gem release.\n. @marcoow that's way better syntax! \n@semmons99 thanks. It'll probably make sense to patch the historical bank gem? I'll look into it.\n. Since historical rates are often required, wouldn't it make sense to include it in the core infrastructure of the money gem?\nThe problem with creating a money extension gem is that a lot of the methods (such as in arithmetic) will have to be re-written with a lot of repetition. They'll have to be constantly re-synced whenever there is a new money gem release.\n. @marcoow that's way better syntax! \n@semmons99 thanks. It'll probably make sense to patch the historical bank gem? I'll look into it.\n. ",
    "viettienn": "Thanks @semmons99 for that. Keeping money object immutable also good for me. Will close this if no one actually need this. \n. Anyway this is according to codeclimate https://codeclimate.com/github/RubyMoney/money/Money::Arithmetic#duplication\n.  Totally agreed with you that refactoring is not just for tricking Code Climate. I mentioned codeclimate is just an example. Isn't the new structure clear, I personally prefer *short ? cc/ @semmons99 \n. @ohthatjames, I think that's a good idea though. Make me coming up with an idea that we should have some helper methods like yours to ensure a another money object is in same currency as the current one.\n@semmons99, let's discuss about that.\n. Thanks @semmons99. That's why I am seeing a lot of this if else end in your code LOL.\n. Ah ok thanks. I have done it. Love to contribute more in the future.\n. @semmons99  @ohthatjames \n. +1 for creating a new PR for these refactoring. BTW, in the future should I create new branch in my forked repo or I can create new branch from RubyMoney/money ? @semmons99 \n. +1\n. @semmons99, @ohthatjames \n. Just a note: .parse is depreciated and will be remove in 6.1.0. Please write your own parsing methods.\n. :+1: \n. Thanks @semmons99 for that. Keeping money object immutable also good for me. Will close this if no one actually need this. \n. Anyway this is according to codeclimate https://codeclimate.com/github/RubyMoney/money/Money::Arithmetic#duplication\n.  Totally agreed with you that refactoring is not just for tricking Code Climate. I mentioned codeclimate is just an example. Isn't the new structure clear, I personally prefer *short ? cc/ @semmons99 \n. @ohthatjames, I think that's a good idea though. Make me coming up with an idea that we should have some helper methods like yours to ensure a another money object is in same currency as the current one.\n@semmons99, let's discuss about that.\n. Thanks @semmons99. That's why I am seeing a lot of this if else end in your code LOL.\n. Ah ok thanks. I have done it. Love to contribute more in the future.\n. @semmons99  @ohthatjames \n. +1 for creating a new PR for these refactoring. BTW, in the future should I create new branch in my forked repo or I can create new branch from RubyMoney/money ? @semmons99 \n. +1\n. @semmons99, @ohthatjames \n. Just a note: .parse is depreciated and will be remove in 6.1.0. Please write your own parsing methods.\n. :+1: \n. ",
    "JoeStanton": "Hi - thanks for the help! Money.infinite_precision was working, I was just using money-rails which used an integer to back the value and was therefore losing precision. I ended up defining a custom currency with more significant digits and it's working well.\n. Hi - thanks for the help! Money.infinite_precision was working, I was just using money-rails which used an integer to back the value and was therefore losing precision. I ended up defining a custom currency with more significant digits and it's working well.\n. ",
    "bjones": "Isn't to_d more standard?\nOn Sep 1, 2013, at 9:13 AM, Orien Madgwick notifications@github.com wrote:\nLet's use the as_d method.\nYou can merge this Pull Request by running\ngit pull https://github.com/orien/money master\nOr view, comment on, or merge it at:\nhttps://github.com/RubyMoney/money/pull/310\nCommit Summary\n- DRY out the creation of big decimals\nFile Changes\n- M lib/money/money.rbhttps://github.com/RubyMoney/money/pull/310/files#diff-0(25)\n- M lib/money/money/arithmetic.rbhttps://github.com/RubyMoney/money/pull/310/files#diff-1(6)\nPatch Links:\n- https://github.com/RubyMoney/money/pull/310.patch\n- https://github.com/RubyMoney/money/pull/310.diff\n. Not sure about same object, shouldn't it behave as a copy constructor if\nyou do this?\nOn Wed, Sep 18, 2013 at 8:32 PM, Shane Emmons notifications@github.comwrote:\n\n@keithpitt https://github.com/keithpitt right. If you pass a value\nthat's already a Money object, it should just return that same object.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/issues/318#issuecomment-24710006\n.\n. You need to use gem from github, not rubygems.org...\n\nGemfile\ngem 'money', :git => \"https://github.com/RubyMoney/money.git\", :ref =>\n\"...some.commit.hash...\"\nOn Wed, Dec 18, 2013 at 2:59 PM, jescalante notifications@github.comwrote:\n\nI've looked for your last commit in master but I'm only seeing the one\nfrom 22 days ago... Maybe you forgot to push?\nHowever, I gave it a try, I've reinstalled the gem and the problem\npersists, and BTW I'm unable to reopen the issue.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/337#issuecomment-30875063\n.\n. Maybe the developer just needs an immutable bank to use in this scenario. Looks like there is an experimental change to Mutex in 2.0 to let you determine if the thread already has the mutex lock too.\n. On Sun, Jan 5, 2014 at 9:23 AM, Saurabh Nanda notifications@github.comwrote:\nDiscussing the \"immutable bank\" option further, how will it work in the\nfollowing scenarios:\n1. Multiple threads in the same process hold a reference to the\n   immutable bank. One thread is responsible for periodically updating the\n   rates.\n2. Multiple processes/run-times on the same machine (typical Rails\n   deployment) create an immutable bank object at startup. Before/after every\n   process they check some cache for rate updates. If the rates have been\n   changed they update the bank object.\nIt is immutable, so no one is periodically updating it.\n\nIdea is something like\nmutable_bank.copy do |immutable_bank|\n # long critical section using an immutable bank with rates that don't\nchange\nend\nHere the copy() creates the immutable bank obj from the mutable bank obj in\nthe usual threadsafe mutex'd way.\n\nI guess the 2nd one is fairly simple to get right with an immutable bank.\nHowever, we need to be careful that the export_rates writes out to\natomically to file at\nhttps://github.com/RubyMoney/money/blob/0c0329e9e9fc32e15c970289a4a958b398c88f53/lib/money/bank/variable_exchange.rb#L223\nI'm not sure how the 1st one will work with immutable bank objects.\nThoughts?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/351#issuecomment-31605311\n.\n. Support for 1.8 was ditched somewhere in the most recent release candidate\ncycle I believe.  It looks like rvm is complaining because you are sort of\ntrying to use ruby 1.9 but it is broken in some way.\n\nOn Mon, Feb 17, 2014 at 3:46 PM, cyzanfar notifications@github.com wrote:\n\nam using ruby 1.8.7 and im using am using rvm 1.25.18.\nIt is working now require 'money' returns true.\nI ran rvm -v gave me:\n```Warning! PATH is not properly set up,\n'/Users/cyrusghazanfar/.rvm/gems/ruby-1.9.3-p484/bin' is not available,\nusually this is caused by shell initialization files - check them for\n'PATH=...' entries,\nit might also help to re-add RVM to your dotfiles: 'rvm get stable\n--auto-dotfiles',\nto fix temporarily in this shell session run: 'rvm use ruby-1.9.3-p484'.\nrvm 1.25.18 (stable) by Wayne E. Seguin wayneeseguin@gmail.com, Michal\nPapis mpapis@gmail.com [https://rvm.io/]```\nso then i entered rvm get stable --auto-dotfiles which gave me\n```Warning! PATH is not properly set up,\n'/Users/cyrusghazanfar/.rvm/gems/ruby-1.9.3-p484/bin' is not available,\nusually this is caused by shell initialization files - check them for\n'PATH=...' entries,\nit might also help to re-add RVM to your dotfiles: 'rvm get stable\n--auto-dotfiles',\nto fix temporarily in this shell session run: 'rvm use ruby-1.9.3-p484'.\nDownloading https://get.rvm.io\nTurning on auto dotfiles mode.\nDownloading https://github.com/wayneeseguin/rvm/archive/stable.tar.gz\nUpgrading the RVM installation in /Users/cyrusghazanfar/.rvm/\nRemoving rvm PATH line from /Users/cyrusghazanfar/.profile\n/Users/cyrusghazanfar/.bashrc /Users/cyrusghazanfar/.zshrc.\nAdding rvm PATH line to /Users/cyrusghazanfar/.profile\n/Users/cyrusghazanfar/.bashrc /Users/cyrusghazanfar/.zshrc.\nRemoving rvm loading line from /Users/cyrusghazanfar/.bash_profile\n/Users/cyrusghazanfar/.zlogin.\nAdding rvm loading line to /Users/cyrusghazanfar/.bash_profile\n/Users/cyrusghazanfar/.zlogin.\nUpgrade of RVM in /Users/cyrusghazanfar/.rvm/ is complete.\ncyrusghazanfar,\n\nThank you for using RVM! We sincerely hope that RVM helps to make your\nlife easier and more enjoyable!!!\n\n~Wayne, Michal & team.\nIn case of problems: http://rvm.io/help and https://twitter.com/rvm_io\nUpgrade Notes:\n/Users/cyrusghazanfar/.bash_profile:4:export\nPATH=/usr/local/bin:/usr/local/bin:/usr/local/sbin:~/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin:/Users/cyrusghazanfar/.rvm/bin\n-\nWARNING: Above files contains PATH= with no $PATH inside, this can\n   break RVM,\n   for details check wayneeseguin/rvm#1351 (comment)https://github.com/wayneeseguin/rvm/issues/1351#issuecomment-10939525\n   to avoid this warning append #PATH.\n   -\nNo new notes to display.\nRVM reloaded!```\nAnd now when i switch back to irb and run require 'money' it gave me true.\nHow's so?\n\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/issues/367#issuecomment-35321297\n.\n. Being a Euro currency does not determine thousands separator or decimal\nseparator. I don't think this is a bug.\n\nOn Jun 26, 2014, at 8:07 PM, Jim Zhan notifications@github.com wrote:\n407 https://github.com/RubyMoney/money/issues/407\nCurrently, if my default locale is \"en_US\" and I do something like:\npry(main)> Money.new(123456789, \"EUR\").format\n=> \"\u20ac1,234,567.89\"\nIt is supposed to be \"\u20ac1.234.567,89\".\nYou can merge this Pull Request by running\ngit pull https://github.com/cjzhan2000/money master\nOr view, comment on, or merge it at:\nhttps://github.com/RubyMoney/money/pull/408\nCommit Summary\n- minor fix for formatting to display the correct thousands separator\n  and decimal mark\nFile Changes\n- M lib/money/money/formatting.rb\n  https://github.com/RubyMoney/money/pull/408/files#diff-0 (4)\nPatch Links:\n- https://github.com/RubyMoney/money/pull/408.patch\n- https://github.com/RubyMoney/money/pull/408.diff\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/RubyMoney/money/pull/408.\n. Isn't to_d more standard?\nOn Sep 1, 2013, at 9:13 AM, Orien Madgwick notifications@github.com wrote:\nLet's use the as_d method.\nYou can merge this Pull Request by running\ngit pull https://github.com/orien/money master\nOr view, comment on, or merge it at:\nhttps://github.com/RubyMoney/money/pull/310\nCommit Summary\n- DRY out the creation of big decimals\nFile Changes\n- M lib/money/money.rbhttps://github.com/RubyMoney/money/pull/310/files#diff-0(25)\n- M lib/money/money/arithmetic.rbhttps://github.com/RubyMoney/money/pull/310/files#diff-1(6)\nPatch Links:\n- https://github.com/RubyMoney/money/pull/310.patch\n- https://github.com/RubyMoney/money/pull/310.diff\n. Not sure about same object, shouldn't it behave as a copy constructor if\nyou do this?\nOn Wed, Sep 18, 2013 at 8:32 PM, Shane Emmons notifications@github.comwrote:\n\n@keithpitt https://github.com/keithpitt right. If you pass a value\nthat's already a Money object, it should just return that same object.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/issues/318#issuecomment-24710006\n.\n. You need to use gem from github, not rubygems.org...\n\nGemfile\ngem 'money', :git => \"https://github.com/RubyMoney/money.git\", :ref =>\n\"...some.commit.hash...\"\nOn Wed, Dec 18, 2013 at 2:59 PM, jescalante notifications@github.comwrote:\n\nI've looked for your last commit in master but I'm only seeing the one\nfrom 22 days ago... Maybe you forgot to push?\nHowever, I gave it a try, I've reinstalled the gem and the problem\npersists, and BTW I'm unable to reopen the issue.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/337#issuecomment-30875063\n.\n. Maybe the developer just needs an immutable bank to use in this scenario. Looks like there is an experimental change to Mutex in 2.0 to let you determine if the thread already has the mutex lock too.\n. On Sun, Jan 5, 2014 at 9:23 AM, Saurabh Nanda notifications@github.comwrote:\nDiscussing the \"immutable bank\" option further, how will it work in the\nfollowing scenarios:\n1. Multiple threads in the same process hold a reference to the\n   immutable bank. One thread is responsible for periodically updating the\n   rates.\n2. Multiple processes/run-times on the same machine (typical Rails\n   deployment) create an immutable bank object at startup. Before/after every\n   process they check some cache for rate updates. If the rates have been\n   changed they update the bank object.\nIt is immutable, so no one is periodically updating it.\n\nIdea is something like\nmutable_bank.copy do |immutable_bank|\n # long critical section using an immutable bank with rates that don't\nchange\nend\nHere the copy() creates the immutable bank obj from the mutable bank obj in\nthe usual threadsafe mutex'd way.\n\nI guess the 2nd one is fairly simple to get right with an immutable bank.\nHowever, we need to be careful that the export_rates writes out to\natomically to file at\nhttps://github.com/RubyMoney/money/blob/0c0329e9e9fc32e15c970289a4a958b398c88f53/lib/money/bank/variable_exchange.rb#L223\nI'm not sure how the 1st one will work with immutable bank objects.\nThoughts?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/351#issuecomment-31605311\n.\n. Support for 1.8 was ditched somewhere in the most recent release candidate\ncycle I believe.  It looks like rvm is complaining because you are sort of\ntrying to use ruby 1.9 but it is broken in some way.\n\nOn Mon, Feb 17, 2014 at 3:46 PM, cyzanfar notifications@github.com wrote:\n\nam using ruby 1.8.7 and im using am using rvm 1.25.18.\nIt is working now require 'money' returns true.\nI ran rvm -v gave me:\n```Warning! PATH is not properly set up,\n'/Users/cyrusghazanfar/.rvm/gems/ruby-1.9.3-p484/bin' is not available,\nusually this is caused by shell initialization files - check them for\n'PATH=...' entries,\nit might also help to re-add RVM to your dotfiles: 'rvm get stable\n--auto-dotfiles',\nto fix temporarily in this shell session run: 'rvm use ruby-1.9.3-p484'.\nrvm 1.25.18 (stable) by Wayne E. Seguin wayneeseguin@gmail.com, Michal\nPapis mpapis@gmail.com [https://rvm.io/]```\nso then i entered rvm get stable --auto-dotfiles which gave me\n```Warning! PATH is not properly set up,\n'/Users/cyrusghazanfar/.rvm/gems/ruby-1.9.3-p484/bin' is not available,\nusually this is caused by shell initialization files - check them for\n'PATH=...' entries,\nit might also help to re-add RVM to your dotfiles: 'rvm get stable\n--auto-dotfiles',\nto fix temporarily in this shell session run: 'rvm use ruby-1.9.3-p484'.\nDownloading https://get.rvm.io\nTurning on auto dotfiles mode.\nDownloading https://github.com/wayneeseguin/rvm/archive/stable.tar.gz\nUpgrading the RVM installation in /Users/cyrusghazanfar/.rvm/\nRemoving rvm PATH line from /Users/cyrusghazanfar/.profile\n/Users/cyrusghazanfar/.bashrc /Users/cyrusghazanfar/.zshrc.\nAdding rvm PATH line to /Users/cyrusghazanfar/.profile\n/Users/cyrusghazanfar/.bashrc /Users/cyrusghazanfar/.zshrc.\nRemoving rvm loading line from /Users/cyrusghazanfar/.bash_profile\n/Users/cyrusghazanfar/.zlogin.\nAdding rvm loading line to /Users/cyrusghazanfar/.bash_profile\n/Users/cyrusghazanfar/.zlogin.\nUpgrade of RVM in /Users/cyrusghazanfar/.rvm/ is complete.\ncyrusghazanfar,\n\nThank you for using RVM! We sincerely hope that RVM helps to make your\nlife easier and more enjoyable!!!\n\n~Wayne, Michal & team.\nIn case of problems: http://rvm.io/help and https://twitter.com/rvm_io\nUpgrade Notes:\n/Users/cyrusghazanfar/.bash_profile:4:export\nPATH=/usr/local/bin:/usr/local/bin:/usr/local/sbin:~/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin:/Users/cyrusghazanfar/.rvm/bin\n-\nWARNING: Above files contains PATH= with no $PATH inside, this can\n   break RVM,\n   for details check wayneeseguin/rvm#1351 (comment)https://github.com/wayneeseguin/rvm/issues/1351#issuecomment-10939525\n   to avoid this warning append #PATH.\n   -\nNo new notes to display.\nRVM reloaded!```\nAnd now when i switch back to irb and run require 'money' it gave me true.\nHow's so?\n\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/issues/367#issuecomment-35321297\n.\n. Being a Euro currency does not determine thousands separator or decimal\nseparator. I don't think this is a bug.\n\nOn Jun 26, 2014, at 8:07 PM, Jim Zhan notifications@github.com wrote:\n407 https://github.com/RubyMoney/money/issues/407\nCurrently, if my default locale is \"en_US\" and I do something like:\npry(main)> Money.new(123456789, \"EUR\").format\n=> \"\u20ac1,234,567.89\"\nIt is supposed to be \"\u20ac1.234.567,89\".\nYou can merge this Pull Request by running\ngit pull https://github.com/cjzhan2000/money master\nOr view, comment on, or merge it at:\nhttps://github.com/RubyMoney/money/pull/408\nCommit Summary\n- minor fix for formatting to display the correct thousands separator\n  and decimal mark\nFile Changes\n- M lib/money/money/formatting.rb\n  https://github.com/RubyMoney/money/pull/408/files#diff-0 (4)\nPatch Links:\n- https://github.com/RubyMoney/money/pull/408.patch\n- https://github.com/RubyMoney/money/pull/408.diff\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/RubyMoney/money/pull/408.\n. ",
    "orien": "That's a valid concern @semmons99. This changes the post conditions of the methods in question and shouldn't be taken lightly. The money gem is used by vast community and this change may cause some applications to behave unexpectedly. Given this, we have a duty of care to provide, so we should take every opportunity to warn clients of this change. Potential methods to achieve this are:\n- a migration guide on the site and/or readme document\n- a post deploy message\nThis is a lot of effort to go through but I believe it will be worth it. This change has the possibility to fix subtle defects in existing client applications. While for new applications using the Money gem, it promotes the more healthy behaviour of using BigDecimals for monetary values. Thus, avoiding a whole class of errors and the associated pain for developers. Developing in Ruby will be even more awesome!\n. Cheers @semmons99, I'll work on that.\n. How's this @semmons99?\n. I don't think markdown supports red text, so here's a warning message.\n. Cheers @semmons99 \n. Oops, forgot about that @semmons99. Added it in now.\n. Congratulations on the releases @semmons99!\n. Thank you!. Thanks.\nHopefully the variable shadowing won't cause problems. :crossed_fingers:. It looks like there're a few calls to decimal_mark in the private apply_decimal_mark_from_rules method.\nThis means the decimal mark will be re-computed a few times while processing a format call.\nPerhaps we could pass in the computed value to this method.. Thanks @antstorm. I've updated the specs to use it.\nI'm unclear what you'd like me to change regarding your second point. Are you referring to the specs? I'll point out that #eql? and #== have differing implementations on Money: #eql? has an explicit definition. Whereas #== is implicitly defined via the inclusion of the Comparision module and our implementation of #<=>. They both behave slightly different.\nIn any case I've added a spec exposing the existing behaviour of the #eql? method comparing zero amounts with differing currencies.. Is the suggestion to alter #eql? to delegate to #==? This implementation doesn't break any tests:\nruby\ndef eql?(other)\n  other.is_a?(Money) && self == other\nend\nIt would behave slightly different though, as it would perform currency conversions before comparison. Currency conversion presents the possibility of raising conversion errors for missing rates, or the disallow_currency_conversion configuration setting.. @antstorm These methods are overriding methods on Object. This prevents us from altering the name to reveal intent.\nFrom the docs:\n\nThe eql? method returns true if obj and other refer to the same hash key. This is used by Hash to test members for equality. For objects of class Object, eql? is synonymous with ==. Subclasses normally continue this tradition by aliasing eql? to their overridden == method, but there are exceptions. Numeric types, for example, perform type conversion across ==, but not across eql?, so:\nruby\n1 == 1.0     #=> true\n1.eql? 1.0   #=> false\nIt seems Money follows the example of numeric types. == is lenient: it compares across subclasses, and currencies. Whereas eql? is strict: it doesn't consider differing subclasses or currencies to be eql?.\n\nIf we consider that eql? is stricter than ==, it is unsurprising where eql? to return false when == would return true. But surprising if eql? were to return true when == would return false. This is the correction this PR makes. Consider the current implementation:\nruby\nMoney.new(0, 'USD').eql? Money.new(0, 'AUD') # => true\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => false\neql? in this scenario is more lenient than ==.\nThe proposed change makes this:\nruby\nMoney.new(0, 'USD').eql? Money.new(0, 'AUD') # => true\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => true. > 1. eql? returns true only if both fraction and currency are equal\n\n\n== first checks eql? then returns true if both objects are zero? or can be exchange to the same currency and then compared\u2026\n\n\n@antstorm: That'd conform to the constraint of == being more lenient than eql?. However, I'd prefer both methods consider amounts of zero to be equal, no matter the currency. When one has no money, currency has no bearing. This is a documented behaviour of Money#eql? and relied upon by many.\n\nWDYT? Trying to figure out what's right here\u2026 somehow extracting comparison with exchange into a separate method feels right, otherwise innocent == might result in a network call depending on your Rates backend\u2026\n\nWhile it's a little concerning that == may result in a network call, it is the current behaviour and I'd expect many applications rely on this currency conversion behaviour. Changing it now would be  non-trivial. Luckily there is a way to disable the conversion: Money.disallow_currency_conversion! However this also breaks == in relation to zero values. Hence this PR. \ud83d\ude05 . Yes, that is a good point. Inspecting the current behaviour in the zero amount case we see we flout this rule:\nruby\nm1 = Money.new(0, 'USD')\nm2 = Money.new(0, 'AUD')\nm1.eql?(m2) #=> true\nm1.hash == m2.hash #=> false\nThere are two options to rectify this, aligning Money with the constraint. We can:\n\nalter the behaviour of the eql? method; or\nalter the behaviour of the hash method.\n\n. Yes, I think this is a good argument leave the #hash implementation as is.. @antstorm So coming back to this PR. It makes a change to the == method.\nCurrent behaviour:\n```ruby\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => false (due to no rate being set)\nMoney.disallow_currency_conversion!\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => Money::Bank::DifferentCurrencyError: No exchanging of currencies allowed: 0.00 AUD to USD\n```\nProposed behaviour:\n```ruby\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => true (even though no rate is set)\nMoney.disallow_currency_conversion!\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => true (even though we aren't allowed to convert currency)\n```\nWith our new found understanding is this change desired?. That's a valid concern @semmons99. This changes the post conditions of the methods in question and shouldn't be taken lightly. The money gem is used by vast community and this change may cause some applications to behave unexpectedly. Given this, we have a duty of care to provide, so we should take every opportunity to warn clients of this change. Potential methods to achieve this are:\n- a migration guide on the site and/or readme document\n- a post deploy message\nThis is a lot of effort to go through but I believe it will be worth it. This change has the possibility to fix subtle defects in existing client applications. While for new applications using the Money gem, it promotes the more healthy behaviour of using BigDecimals for monetary values. Thus, avoiding a whole class of errors and the associated pain for developers. Developing in Ruby will be even more awesome!\n. Cheers @semmons99, I'll work on that.\n. How's this @semmons99?\n. I don't think markdown supports red text, so here's a warning message.\n. Cheers @semmons99 \n. Oops, forgot about that @semmons99. Added it in now.\n. Congratulations on the releases @semmons99!\n. Thank you!. Thanks.\nHopefully the variable shadowing won't cause problems. :crossed_fingers:. It looks like there're a few calls to decimal_mark in the private apply_decimal_mark_from_rules method.\nThis means the decimal mark will be re-computed a few times while processing a format call.\nPerhaps we could pass in the computed value to this method.. Thanks @antstorm. I've updated the specs to use it.\nI'm unclear what you'd like me to change regarding your second point. Are you referring to the specs? I'll point out that #eql? and #== have differing implementations on Money: #eql? has an explicit definition. Whereas #== is implicitly defined via the inclusion of the Comparision module and our implementation of #<=>. They both behave slightly different.\nIn any case I've added a spec exposing the existing behaviour of the #eql? method comparing zero amounts with differing currencies.. Is the suggestion to alter #eql? to delegate to #==? This implementation doesn't break any tests:\nruby\ndef eql?(other)\n  other.is_a?(Money) && self == other\nend\nIt would behave slightly different though, as it would perform currency conversions before comparison. Currency conversion presents the possibility of raising conversion errors for missing rates, or the disallow_currency_conversion configuration setting.. @antstorm These methods are overriding methods on Object. This prevents us from altering the name to reveal intent.\nFrom the docs:\n\nThe eql? method returns true if obj and other refer to the same hash key. This is used by Hash to test members for equality. For objects of class Object, eql? is synonymous with ==. Subclasses normally continue this tradition by aliasing eql? to their overridden == method, but there are exceptions. Numeric types, for example, perform type conversion across ==, but not across eql?, so:\nruby\n1 == 1.0     #=> true\n1.eql? 1.0   #=> false\nIt seems Money follows the example of numeric types. == is lenient: it compares across subclasses, and currencies. Whereas eql? is strict: it doesn't consider differing subclasses or currencies to be eql?.\n\nIf we consider that eql? is stricter than ==, it is unsurprising where eql? to return false when == would return true. But surprising if eql? were to return true when == would return false. This is the correction this PR makes. Consider the current implementation:\nruby\nMoney.new(0, 'USD').eql? Money.new(0, 'AUD') # => true\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => false\neql? in this scenario is more lenient than ==.\nThe proposed change makes this:\nruby\nMoney.new(0, 'USD').eql? Money.new(0, 'AUD') # => true\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => true. > 1. eql? returns true only if both fraction and currency are equal\n\n\n== first checks eql? then returns true if both objects are zero? or can be exchange to the same currency and then compared\u2026\n\n\n@antstorm: That'd conform to the constraint of == being more lenient than eql?. However, I'd prefer both methods consider amounts of zero to be equal, no matter the currency. When one has no money, currency has no bearing. This is a documented behaviour of Money#eql? and relied upon by many.\n\nWDYT? Trying to figure out what's right here\u2026 somehow extracting comparison with exchange into a separate method feels right, otherwise innocent == might result in a network call depending on your Rates backend\u2026\n\nWhile it's a little concerning that == may result in a network call, it is the current behaviour and I'd expect many applications rely on this currency conversion behaviour. Changing it now would be  non-trivial. Luckily there is a way to disable the conversion: Money.disallow_currency_conversion! However this also breaks == in relation to zero values. Hence this PR. \ud83d\ude05 . Yes, that is a good point. Inspecting the current behaviour in the zero amount case we see we flout this rule:\nruby\nm1 = Money.new(0, 'USD')\nm2 = Money.new(0, 'AUD')\nm1.eql?(m2) #=> true\nm1.hash == m2.hash #=> false\nThere are two options to rectify this, aligning Money with the constraint. We can:\n\nalter the behaviour of the eql? method; or\nalter the behaviour of the hash method.\n\n. Yes, I think this is a good argument leave the #hash implementation as is.. @antstorm So coming back to this PR. It makes a change to the == method.\nCurrent behaviour:\n```ruby\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => false (due to no rate being set)\nMoney.disallow_currency_conversion!\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => Money::Bank::DifferentCurrencyError: No exchanging of currencies allowed: 0.00 AUD to USD\n```\nProposed behaviour:\n```ruby\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => true (even though no rate is set)\nMoney.disallow_currency_conversion!\nMoney.new(0, 'USD') == Money.new(0, 'AUD')   # => true (even though we aren't allowed to convert currency)\n```\nWith our new found understanding is this change desired?. ",
    "lucasrenan": ":+1: \n. :+1: \n. ",
    "fklingler": "I did not read the notes, sorry about that. Here you go :)\n. Not sure about the name of the option, but I think it's good enough. If you have a better idea, I can obviously modify it! ;)\n. Will do that right now, I just spotted a bug in my implementation though, I'll add a test and correct it.\n. I think this is ok now.\n. I just saw Money::Currency.new(\"MGA\").exponent  # => 0.6989700043360189 in the README.\nHow the formatting should go with this currency (and the others with a non multiple of 10 as the subunit_to_unit property)?\nI'm not sure if my implementation breaks these currency rules (if the option is used), but it's quite possible.\n. This last commit does the trick. It now rounds to closest 1/subunit_to_unit.\n. It's ok now, thanks Travis :dancer:\n. I have no change to do on the changelog since this fixes a new feature, present in the master section of the changelog :\nAdd :rounded_infinite_precision option to .format\n. I did not read the notes, sorry about that. Here you go :)\n. Not sure about the name of the option, but I think it's good enough. If you have a better idea, I can obviously modify it! ;)\n. Will do that right now, I just spotted a bug in my implementation though, I'll add a test and correct it.\n. I think this is ok now.\n. I just saw Money::Currency.new(\"MGA\").exponent  # => 0.6989700043360189 in the README.\nHow the formatting should go with this currency (and the others with a non multiple of 10 as the subunit_to_unit property)?\nI'm not sure if my implementation breaks these currency rules (if the option is used), but it's quite possible.\n. This last commit does the trick. It now rounds to closest 1/subunit_to_unit.\n. It's ok now, thanks Travis :dancer:\n. I have no change to do on the changelog since this fixes a new feature, present in the master section of the changelog :\nAdd :rounded_infinite_precision option to .format\n. ",
    "keithpitt": "Sure! I can do this. The expected behaviour would be that it still just works, but doesn't change the value?\n. Sure! I can do this. The expected behaviour would be that it still just works, but doesn't change the value?\n. ",
    "joshhepworth": "Sure. I just wanted to check-in before going at it. Thanks!\n. @semmons99 Yup. Sorry about that. I swear I looked for the contributing section in the README and just missed it the first time.\n. Sure. I just wanted to check-in before going at it. Thanks!\n. @semmons99 Yup. Sorry about that. I swear I looked for the contributing section in the README and just missed it the first time.\n. ",
    "asok": "Right, didn't think about it :) It's now fixed.\n. @semmons99 what do you think about this monkey patch https://github.com/erebor/nbayes/commit/ca93eae656563b37abf5685e44c2df23ccae0c30 ?\n. So I've created a new object. But to tell you the truth, my commit makes the code a bit drier but at the same time introduces more complexity. I would reject my PR if I were you :)\n. Right, didn't think about it :) It's now fixed.\n. @semmons99 what do you think about this monkey patch https://github.com/erebor/nbayes/commit/ca93eae656563b37abf5685e44c2df23ccae0c30 ?\n. So I've created a new object. But to tell you the truth, my commit makes the code a bit drier but at the same time introduces more complexity. I would reject my PR if I were you :)\n. ",
    "chatgris": "The idea is to have one object to give us access to all amount of a complex domain object.\nThis is pseudo code:\n``` ruby\nclass OrderAmount < Money\n  attr_reader :order\ndef initialize(order)\n    @order = order\n    super(order.amount.cents, order.amount.currency)\n  end\ndef shipping\n    # returns a Money object\n  end\ndef discounts\n    # returns a Money object\n  end\ndef tax\n    # returns a Money object\n  end\nend\n```\nSo, we can do:\nruby\nOrder.last.amounts.tap |amounts|\n  amounts # default amount\n  amounts.shipping\n  amounts.tax\nend\nInstead of :\nruby\nOrder.last.tap |order|\n  order.amount # default amount\n  order.shipping.amount\n  order.tax.amount\nend\n. Thanks for the fast response and the work on Money. :+1: \nYeah, normally, I would have used composition, but I need to have a context to compute for instance the discounts amount, so I choose inheritance, and I am quite satisfied with this choice.\n. The idea is to have one object to give us access to all amount of a complex domain object.\nThis is pseudo code:\n``` ruby\nclass OrderAmount < Money\n  attr_reader :order\ndef initialize(order)\n    @order = order\n    super(order.amount.cents, order.amount.currency)\n  end\ndef shipping\n    # returns a Money object\n  end\ndef discounts\n    # returns a Money object\n  end\ndef tax\n    # returns a Money object\n  end\nend\n```\nSo, we can do:\nruby\nOrder.last.amounts.tap |amounts|\n  amounts # default amount\n  amounts.shipping\n  amounts.tax\nend\nInstead of :\nruby\nOrder.last.tap |order|\n  order.amount # default amount\n  order.shipping.amount\n  order.tax.amount\nend\n. Thanks for the fast response and the work on Money. :+1: \nYeah, normally, I would have used composition, but I need to have a context to compute for instance the discounts amount, so I choose inheritance, and I am quite satisfied with this choice.\n. ",
    "Silex": "@semmons99: I'm pretty sure it is fixed in the 6.x pre release. I'm just saying it's annoying that gem install money suffers from this problem.\n. Good news, thanks\n. @semmons99: I'm pretty sure it is fixed in the 6.x pre release. I'm just saying it's annoying that gem install money suffers from this problem.\n. Good news, thanks\n. ",
    "jaros1": "HI eyaleizenberg. New version 3.0.0 of Google_currency available. https://github.com/RubyMoney/google_currency/releases/tag/v3.0.0\n. HI eyaleizenberg. New version 3.0.0 of Google_currency available. https://github.com/RubyMoney/google_currency/releases/tag/v3.0.0\n. ",
    "zubin": "Anyone know of a patch for ruby187?\n$ gem install google_currency -v3.0.0\nERROR:  Error installing google_currency:\n    money requires Ruby version >= 1.9.2.\n. Thanks @semmons99, that worked just fine!\n. Done, see https://github.com/RubyMoney/money/pull/334.\n. Anyone know of a patch for ruby187?\n$ gem install google_currency -v3.0.0\nERROR:  Error installing google_currency:\n    money requires Ruby version >= 1.9.2.\n. Thanks @semmons99, that worked just fine!\n. Done, see https://github.com/RubyMoney/money/pull/334.\n. ",
    "brianphillips": "A couple notes:\n- I'm not sure if there's a better way than a global variable to control whether those specific deprecation errors are issued\n- In version 6.1.0, once the implicit loading is removed, the real core extensions code can be moved back to where it was and the global variable nonsense can be removed\n. This pull request (like it's predecessor) still moves the core_extensions.rb file because this was the only way I could devise that allows the user to silence the deprecation warning by following the provided instructions (by explicitly requiring \"money/core_extensions\").  I think asking them to put Money.Money.silence_core_extensions_deprecation_message = true in their code isn't ideal.\nI'm open to trying another approach if you have a suggestion.\n. @semmons99 - have you had a chance to take a look at this yet?\n. @semmons99 - no worries, thanks for all the hard work :+1: \n. A couple notes:\n- I'm not sure if there's a better way than a global variable to control whether those specific deprecation errors are issued\n- In version 6.1.0, once the implicit loading is removed, the real core extensions code can be moved back to where it was and the global variable nonsense can be removed\n. This pull request (like it's predecessor) still moves the core_extensions.rb file because this was the only way I could devise that allows the user to silence the deprecation warning by following the provided instructions (by explicitly requiring \"money/core_extensions\").  I think asking them to put Money.Money.silence_core_extensions_deprecation_message = true in their code isn't ideal.\nI'm open to trying another approach if you have a suggestion.\n. @semmons99 - have you had a chance to take a look at this yet?\n. @semmons99 - no worries, thanks for all the hard work :+1: \n. ",
    "jescalante": "Hi guys, I have the same warning problem, and since this has recently merged in master I made my Gemfile  to point to the last commit:\nruby\ngem 'money', :git => \"https://github.com/RubyMoney/money.git\", :ref => \"ea4093116d2a529d479acfec428626c6f2cdf642\"\nAnd in the initializer I added:\nruby\nrequire 'money'\nrequire 'money/core_extensions'\nHowever I'm still getting the same warning message. Am I missing something?\nThanks!\n. Sorry for the late reply. I did as you told, but I'm still getting the same message:\nbash\nDEPRECATION WARNING: as of Money 6.1.0 you must `require 'money/core_extensions'` to compare Money to core classes. (called from: /home/joe/overol/lib/monetizable.rb:113)\nMonetizable is a class who controls the price assignment of products. In the line 113 there is comparisson between a Integer and a Money, this used to work flawlessly before the update, and we use it a lot.\n. I've looked for your last commit in master but I'm only seeing the one from 22 days ago... Maybe you forgot to push?\nHowever, I gave it a try, I've reinstalled the gem and the problem persists, and BTW I'm unable to reopen the issue.\n. It works! Thank you very much :smiley: \n. Hi guys, I have the same warning problem, and since this has recently merged in master I made my Gemfile  to point to the last commit:\nruby\ngem 'money', :git => \"https://github.com/RubyMoney/money.git\", :ref => \"ea4093116d2a529d479acfec428626c6f2cdf642\"\nAnd in the initializer I added:\nruby\nrequire 'money'\nrequire 'money/core_extensions'\nHowever I'm still getting the same warning message. Am I missing something?\nThanks!\n. Sorry for the late reply. I did as you told, but I'm still getting the same message:\nbash\nDEPRECATION WARNING: as of Money 6.1.0 you must `require 'money/core_extensions'` to compare Money to core classes. (called from: /home/joe/overol/lib/monetizable.rb:113)\nMonetizable is a class who controls the price assignment of products. In the line 113 there is comparisson between a Integer and a Money, this used to work flawlessly before the update, and we use it a lot.\n. I've looked for your last commit in master but I'm only seeing the one from 22 days ago... Maybe you forgot to push?\nHowever, I gave it a try, I've reinstalled the gem and the problem persists, and BTW I'm unable to reopen the issue.\n. It works! Thank you very much :smiley: \n. ",
    "joshuapinter": "@bjones, you mean like @jescalante and @semmons99 have already suggested?\n. @bjones, you mean like @jescalante and @semmons99 have already suggested?\n. ",
    "gastonmorixe": "I always get them. The currency I am using, bitcoin, has a subunit_tounit of 100000000. \n``` ruby\nNote:\npayment.available is 3.5 BTC\npayment.amount is 3 BTC\npayment.available.format + \" / \" + payment.amount.format\n3.50000000 BTC / 3 BTC\n```\n. @semmons99 I am sorry, please tell me more clearly what is needed to reproduce this.\n``` ruby\nMoneyRails.configure do |config|\nconfig.register_currency = {\n     :priority            => 1,\n     :iso_code            => \"btc\",\n     :name                => \"BTC with subunit of 8 digits\",\n     :symbol              => \"BTC\",\n     :symbol_first        => false,\n     :subunit             => \"Satoshi\",\n     :subunit_to_unit     => 100000000,\n     :thousands_separator => \",\",\n     :decimal_mark        => \".\",\n  }\nconfig.default_currency = :btc\nend\n```\n. Ok, I already submitted an issue there. But I still think this is a feature request, not a bug.\nruby\nMoney.new(50).format\noutputs\n\"$0.50\"\nwhat setting does strip that rightmost zero?\nThanks\n. I don't think using .to_f is right. I want to avoid any float overflow or rounding mistake.\n. That would not take into account the symbol position. \nI still thinking this should be a new feature using the regexp I posted in the first post, and handled by strings. Included in the \"format\" method with a \"strip_insignificant_zeros\" option.\nWhat do you think?\n. I will. Do you think the performance could be an issue here working with strings? \nThanks.\n. I always get them. The currency I am using, bitcoin, has a subunit_tounit of 100000000. \n``` ruby\nNote:\npayment.available is 3.5 BTC\npayment.amount is 3 BTC\npayment.available.format + \" / \" + payment.amount.format\n3.50000000 BTC / 3 BTC\n```\n. @semmons99 I am sorry, please tell me more clearly what is needed to reproduce this.\n``` ruby\nMoneyRails.configure do |config|\nconfig.register_currency = {\n     :priority            => 1,\n     :iso_code            => \"btc\",\n     :name                => \"BTC with subunit of 8 digits\",\n     :symbol              => \"BTC\",\n     :symbol_first        => false,\n     :subunit             => \"Satoshi\",\n     :subunit_to_unit     => 100000000,\n     :thousands_separator => \",\",\n     :decimal_mark        => \".\",\n  }\nconfig.default_currency = :btc\nend\n```\n. Ok, I already submitted an issue there. But I still think this is a feature request, not a bug.\nruby\nMoney.new(50).format\noutputs\n\"$0.50\"\nwhat setting does strip that rightmost zero?\nThanks\n. I don't think using .to_f is right. I want to avoid any float overflow or rounding mistake.\n. That would not take into account the symbol position. \nI still thinking this should be a new feature using the regexp I posted in the first post, and handled by strings. Included in the \"format\" method with a \"strip_insignificant_zeros\" option.\nWhat do you think?\n. I will. Do you think the performance could be an issue here working with strings? \nThanks.\n. ",
    "shawndeprey": "Roger that. Good to know.\n. Roger that. Good to know.\n. ",
    "tommeier": "@semmons99  thanks, done, I overlooked the notes section but all other parts completed.:)\n. @semmons99  thanks, done, I overlooked the notes section but all other parts completed.:)\n. ",
    "jlecour": "I guess the contributing guidelines are respected, and the Travis CI status is green.\n. @semmons99 Sorry, I did not read carefully enough. It's done.\n. Ok, so I make mistake after mistake. Not a good day. Sorry\n. It seems that the master branch is OK because I get i18n v0.7.0.beta1 when executing bundle install.\nBut nothing happens when I execute the test suite ; no output, no error.\n. Hi @semmons99 \nYou've been closing a few issues in the same way recently.\nIs there a policy I'm not aware of about closing issues on a per idle-time basis?\nIs this issue resolved?\nThanks for your clarification.\n. I guess the contributing guidelines are respected, and the Travis CI status is green.\n. @semmons99 Sorry, I did not read carefully enough. It's done.\n. Ok, so I make mistake after mistake. Not a good day. Sorry\n. It seems that the master branch is OK because I get i18n v0.7.0.beta1 when executing bundle install.\nBut nothing happens when I execute the test suite ; no output, no error.\n. Hi @semmons99 \nYou've been closing a few issues in the same way recently.\nIs there a policy I'm not aware of about closing issues on a per idle-time basis?\nIs this issue resolved?\nThanks for your clarification.\n. ",
    "hadees": "I'd like to work on it but I didn't get any other feedback about how best to make it thread safe.\n. @semmons99 I've gone ahead and made changes in my branch that I think will make it thread safe.  I can't seem to reopen the pull request though.\n. Should I just create a new pull request?\n. I also want to update the YARD docs before this gets merged in but I'm not sure the right syntax to show it returns [BigDecimal::ROUND_MODE] or the results of the block.\n. That was my last update to the branch unless anyone has more suggestions.\n. I'd like to work on it but I didn't get any other feedback about how best to make it thread safe.\n. @semmons99 I've gone ahead and made changes in my branch that I think will make it thread safe.  I can't seem to reopen the pull request though.\n. Should I just create a new pull request?\n. I also want to update the YARD docs before this gets merged in but I'm not sure the right syntax to show it returns [BigDecimal::ROUND_MODE] or the results of the block.\n. That was my last update to the branch unless anyone has more suggestions.\n. ",
    "soylent": "Seems like Money::Bank::VariableExchange#exchange_with ignores infinite_precision option and always rounds up values that are less than 1 subunit. My test above illustrates this case. So my question remains.\n. Seems like Money::Bank::VariableExchange#exchange_with ignores infinite_precision option and always rounds up values that are less than 1 subunit. My test above illustrates this case. So my question remains.\n. ",
    "Robsteranium": "Sorry, I still don't understand. It seems to me that there are two distinct deprecations here:\n- String#to_money is being removed (as Money.parse is being removed), and \n- Numeric#to_money is being separated out into money/core_extensions which will remain, but must be required explicitly.\nThe deprecation warning in Money::Arithmetic currently masks this, when (it looks to me like) it could just allow the relevant error to bubble up.\nIf Money::Arithmetic will now require two Money objects for comparison, perhaps the deprecation notice should explain this as it doesn't seem clear (to me at least). Perhaps the other_money.respond_to?(:to_money) condition should also be replaced with something like other_money.is_a?(Money)?\n. I suggest the warning in Money::Arithmetic be removed. The warnings in String and Numeric will still appear. If the comparison is only using Numeric#to_money then requiring money/core_extensions will silence this too. It's only a minor point but I think it would be clearer.\nI've just noticed Monetize provides a new home for the extensions to String and Numeric. Will Money::Arithmetic depend upon Monetize or will it ultimately raise an error unless it receives two money objects?\n. Sorry, I still don't understand. It seems to me that there are two distinct deprecations here:\n- String#to_money is being removed (as Money.parse is being removed), and \n- Numeric#to_money is being separated out into money/core_extensions which will remain, but must be required explicitly.\nThe deprecation warning in Money::Arithmetic currently masks this, when (it looks to me like) it could just allow the relevant error to bubble up.\nIf Money::Arithmetic will now require two Money objects for comparison, perhaps the deprecation notice should explain this as it doesn't seem clear (to me at least). Perhaps the other_money.respond_to?(:to_money) condition should also be replaced with something like other_money.is_a?(Money)?\n. I suggest the warning in Money::Arithmetic be removed. The warnings in String and Numeric will still appear. If the comparison is only using Numeric#to_money then requiring money/core_extensions will silence this too. It's only a minor point but I think it would be clearer.\nI've just noticed Monetize provides a new home for the extensions to String and Numeric. Will Money::Arithmetic depend upon Monetize or will it ultimately raise an error unless it receives two money objects?\n. ",
    "lassebunk": "Will look into that.\nThanks.\n. Will look into that.\nThanks.\n. ",
    "krishicks": "Updated.\n. Updated.\n. ",
    "saurabhnanda": "@semmons99  -- I've made a new PR on rubymoney/eu_central_bank based on the new API, but somehow this doesn't feel right. I feel there is too much mutex synchronization going on right now. If multiple threads are simply reading rates, they don't need to block each other. Blocking should only happen when some thread is updating the threads, in which scenario, all reads should be blocked till the write finishes.\nDo we have something in Ruby to support this? \n. But how can we implement the following: all reads are non-blocking, except when some thread is updating the rates. This might mean using some underlying MVCC features, which Ruby doesn't provide out of the box. IIRC this is exactly how Postgres handles concurrency without unnecessarily blocking.\n. My thoughts on this approach:\n- Philosophically, it doesn't make sense to push the mutex synchronization out from the core library. It's basically making the calling programs responsible for thread-safety, which, in all probability, will get missed by a lot of developers.\n- Practically, if there are two separate sub-systems (or gems) in an app using the Money gem, where one sub-system is using an external mutex and the other sub-system is depending upon the internal mutex, we're back to the same non-thread-safe situation.\n. The second point that I raised above can be handled if we make @mutex readable to the outside world. That way a calling program will have the ability to do the following:\nbank.mutex.syhronize {\n  bank.get_rate('EUR', 'INR', :without_mutex => true)\n  bank.get_rate('EUR', 'USD', :without_mutex => true)\nend\n. However, this will still not solve the philosophical question of burdening every developer with the responsibility of making their calls thread-sage.\n. Discussing the \"immutable bank\" option further, how will it work in the following scenarios:\n1. Multiple threads in the same process hold a reference to the immutable bank. One thread is responsible for periodically updating the rates.\n2. Multiple processes/run-times on the same machine (typical Rails deployment) create an immutable bank object at startup. Before/after every process they check some cache for rate updates. If the rates have been changed they update the bank object.\nI guess the 2nd one is fairly simple to get right with an immutable bank. However, we need to be careful that the export_rates writes out to atomically to file at https://github.com/RubyMoney/money/blob/0c0329e9e9fc32e15c970289a4a958b398c88f53/lib/money/bank/variable_exchange.rb#L223\nI'm not sure how the 1st one will work with immutable bank objects. Thoughts?\n. Is this the final API, then? Can I submit a PR for eu_central_bank based on this?\n. @semmons99 -- I've made a new PR on rubymoney/eu_central_bank based on the new API, but somehow this doesn't feel right. I feel there is too much mutex synchronization going on right now. If multiple threads are simply reading rates, they don't need to block each other. Blocking should only happen when some thread is updating the threads, in which scenario, all reads should be blocked till the write finishes.\nDo we have something in Ruby to support this?\n. Done.\n. @semmons99  -- I've made a new PR on rubymoney/eu_central_bank based on the new API, but somehow this doesn't feel right. I feel there is too much mutex synchronization going on right now. If multiple threads are simply reading rates, they don't need to block each other. Blocking should only happen when some thread is updating the threads, in which scenario, all reads should be blocked till the write finishes.\nDo we have something in Ruby to support this? \n. But how can we implement the following: all reads are non-blocking, except when some thread is updating the rates. This might mean using some underlying MVCC features, which Ruby doesn't provide out of the box. IIRC this is exactly how Postgres handles concurrency without unnecessarily blocking.\n. My thoughts on this approach:\n- Philosophically, it doesn't make sense to push the mutex synchronization out from the core library. It's basically making the calling programs responsible for thread-safety, which, in all probability, will get missed by a lot of developers.\n- Practically, if there are two separate sub-systems (or gems) in an app using the Money gem, where one sub-system is using an external mutex and the other sub-system is depending upon the internal mutex, we're back to the same non-thread-safe situation.\n. The second point that I raised above can be handled if we make @mutex readable to the outside world. That way a calling program will have the ability to do the following:\nbank.mutex.syhronize {\n  bank.get_rate('EUR', 'INR', :without_mutex => true)\n  bank.get_rate('EUR', 'USD', :without_mutex => true)\nend\n. However, this will still not solve the philosophical question of burdening every developer with the responsibility of making their calls thread-sage.\n. Discussing the \"immutable bank\" option further, how will it work in the following scenarios:\n1. Multiple threads in the same process hold a reference to the immutable bank. One thread is responsible for periodically updating the rates.\n2. Multiple processes/run-times on the same machine (typical Rails deployment) create an immutable bank object at startup. Before/after every process they check some cache for rate updates. If the rates have been changed they update the bank object.\nI guess the 2nd one is fairly simple to get right with an immutable bank. However, we need to be careful that the export_rates writes out to atomically to file at https://github.com/RubyMoney/money/blob/0c0329e9e9fc32e15c970289a4a958b398c88f53/lib/money/bank/variable_exchange.rb#L223\nI'm not sure how the 1st one will work with immutable bank objects. Thoughts?\n. Is this the final API, then? Can I submit a PR for eu_central_bank based on this?\n. @semmons99 -- I've made a new PR on rubymoney/eu_central_bank based on the new API, but somehow this doesn't feel right. I feel there is too much mutex synchronization going on right now. If multiple threads are simply reading rates, they don't need to block each other. Blocking should only happen when some thread is updating the threads, in which scenario, all reads should be blocked till the write finishes.\nDo we have something in Ruby to support this?\n. Done.\n. ",
    "ct-clearhaus": "@saurabhnanda \nI've made an alternative to EuCentralBank, https://github.com/ct-clearhaus/money-ecb, which won't have this issue since all combinations of currencies are being set_rate'ed (with the mutex).\nmoney-ecb is not quite production ready yet, but have a try, give it a review if you care :-)\n. I hoped that it'd be hosted under RubyMoney at some point, but I expect to have it ready for production before so it won't confuse users. It needs a few fixes and a review to be there. I'll make a PR when it is ready.\n. Oh, I see: https://travis-ci.org/RubyMoney/money/jobs/18103137#L379\nThat one does not fail locally on my machine. Any idea why modifying Money#exchange_to has consequences on Money.parse?\n. @semmons99 I have a hard time reproducing the error and figuring out why the test fails. Maybe it's related to 84a552d6 combined with the spec helper? Can you reproduce the error?\nBtw., https://github.com/ct-clearhaus/money/compare/RubyMoney:master...ct-clearhaus:update_contribute as a consequence of https://github.com/RubyMoney/money/commit/42f237a75c340cf6b08329fa87b45f306ae24c1a#diff-52c976fc38ed2b4e3b1192f8a8e24cffL14\n. Master is also failing so hunting goes on: https://gist.github.com/anonymous/8781856\n. https://github.com/ct-clearhaus/money/commit/7669177baa9d1a206ae6ee427c43dc38756c90cf should probably be cherry-picked into an earlier point. Do you have the overview where?\nThis is why master was also failing ...\n. https://github.com/RubyMoney/money/pull/363\n. I like the green colour :-)\nAnother thing is if you think this is the way rounding should be done; I see that some work is going on wrt. to rounding elsewhere ...\n. Sorry, I already did. Had to have an excuse to test my docker image :-)\nhttps://github.com/RubyMoney/money/pull/370\n. It would require a bank to support the relevant currencies before the comparison makes sense. Maybe it should even support selection of which bank to use?\n. I think the following should be the result of mixing Money and numbers:\n```\nfour = Money.new(400, 'EUR')\nfour + 1 # raises error\nfour - 1 # raises error\nfour * 2 # equals Money.new(800, 'EUR')\nfour / 2 # equals Money.new(200, 'EUR')\n1 + four # raises error\n1 - four # raises error\n2 * four # equals Money.new(800, 'EUR')\n2 / four # raises error\nfour  2 # raises error\n2  four # raises error\nfour % 3 # equals Money.new(100, 'EUR')\n5 % four # raises error\nMath.sqrt(four) # raises error\netc.\n```\nThis is the exactly what would happen if you multiply some physical unit (like meters for length) by numbers when the outcome must be in the same unit; 2 * 3 meters is 6 meters whereas 2 meters * 3 meters is 6 square meters. Also, you cannot add something without a unit to something with a unit, so I think an explicit #to_money would be appropriate to expect from the user.\n. ``` sh\n\n$ irb\n2.0.0-p353 :001 > require 'money'\n => true\n2.0.0-p353 :002 > Money.new(1000, 'INR').exchange_to('INR')\n => #\n2.0.0-p353 :003 > Money.new(1000, 'INR').currency\n => #\n```\n\nMaybe you want to use Money#amount, Money#fractional or Money#to_f?\n. > i think this library considers the amount entered in cents not in dollars.\nThat's intended. https://github.com/RubyMoney/money#usage\n. It does matter which way it is converted; one may have a rate r for e.g. EUR -> USD and not 1/r for USD -> EUR. This is very common in banks where they benefit from the margin (along with maybe a conversion fee).\nTherefore I am not very fond of the way the rounding issue is solved. Moreover, @lulalala can you more explicitly examplify the rounding issue? I might be a bit tired, but I do not fully understand.\n. I think the comment should be\n\n0.03 FOO == 0.015 USD but gets rounded down to 0.01 USD\n\nwhich then doesn't call for a fix IMHO.\nAm I misunderstanding something?\n. Someone with overview who will decide, @semmons99 ?\n. > I can fork and make a pull request if needed...\n:+1: \n. Duplicate of #399?\n. For reference: \nhttp://www.currency-iso.org/dam/isocy/downloads/dl_currency_iso_amendment_92.pdf (dl_currency_iso_amendment_92.pdf.zip)\n. Related to https://github.com/RubyMoney/money/pull/405?\n. https://github.com/RubyMoney/money/blob/master/lib/money/bank/base.rb#L52?\n. https://github.com/RubyMoney/money/blame/master/README.md#L9 :smiley: \n. See https://github.com/RubyMoney/money#usage for instance\nMoney.from_amount(5, \"USD\") == Money.new(500, \"USD\")  # 5 USD\nAlso, see https://github.com/RubyMoney/money#features.\n. The division Money.new(20487)/100 gives you integer division in minor unit, thus, #<Money fractional:205 currency:USD> rather than the non-integer value 2.0487.. I don't understand the issue.\nirb(main):002:0> Money.new(20487)/100 == Money.new(20487.0)/100 and Money.new(20487)/100 == Money.new(20487)/100.0\n=> true\nirb(main):003:0> Money.new(20487).to_f/100.0 == Money.new(20487)/100.0\n=> false\nBy using Money.new(20487) you get integer division because Moneys are rounded (by a configurable method) to fit within the precision of 1 minor unit.. Please notice that ISO 4217 lists CLP to have exponent 0, thus subunit_to_unit == 1.\nBonus information: On Oct. 14th, 12:00 St Louis, even Visa and Mastercard will adjust CLP (and UGX) to be aligned with ISO \ud83d\ude42\nEdit: Mastercard updates CLP on Oct. 14th 12:00 St Louis time; Visa updates CLP on Oct. 13th 10:00 GMT \ud83e\udd26\u200d\u2642\ufe0f. https://www.currency-iso.org/dam/downloads/lists/list_one.xls \ud83d\ude42. I like the code and I notice that it agrees with https://github.com/bbatsov/ruby-style-guide#no-nested-conditionals. However, I'd probably only fix this if the code style was fixed (in this regard) all over.. @saurabhnanda \nI've made an alternative to EuCentralBank, https://github.com/ct-clearhaus/money-ecb, which won't have this issue since all combinations of currencies are being set_rate'ed (with the mutex).\nmoney-ecb is not quite production ready yet, but have a try, give it a review if you care :-)\n. I hoped that it'd be hosted under RubyMoney at some point, but I expect to have it ready for production before so it won't confuse users. It needs a few fixes and a review to be there. I'll make a PR when it is ready.\n. Oh, I see: https://travis-ci.org/RubyMoney/money/jobs/18103137#L379\nThat one does not fail locally on my machine. Any idea why modifying Money#exchange_to has consequences on Money.parse?\n. @semmons99 I have a hard time reproducing the error and figuring out why the test fails. Maybe it's related to 84a552d6 combined with the spec helper? Can you reproduce the error?\nBtw., https://github.com/ct-clearhaus/money/compare/RubyMoney:master...ct-clearhaus:update_contribute as a consequence of https://github.com/RubyMoney/money/commit/42f237a75c340cf6b08329fa87b45f306ae24c1a#diff-52c976fc38ed2b4e3b1192f8a8e24cffL14\n. Master is also failing so hunting goes on: https://gist.github.com/anonymous/8781856\n. https://github.com/ct-clearhaus/money/commit/7669177baa9d1a206ae6ee427c43dc38756c90cf should probably be cherry-picked into an earlier point. Do you have the overview where?\nThis is why master was also failing ...\n. https://github.com/RubyMoney/money/pull/363\n. I like the green colour :-)\nAnother thing is if you think this is the way rounding should be done; I see that some work is going on wrt. to rounding elsewhere ...\n. Sorry, I already did. Had to have an excuse to test my docker image :-)\nhttps://github.com/RubyMoney/money/pull/370\n. It would require a bank to support the relevant currencies before the comparison makes sense. Maybe it should even support selection of which bank to use?\n. I think the following should be the result of mixing Money and numbers:\n```\nfour = Money.new(400, 'EUR')\nfour + 1 # raises error\nfour - 1 # raises error\nfour * 2 # equals Money.new(800, 'EUR')\nfour / 2 # equals Money.new(200, 'EUR')\n1 + four # raises error\n1 - four # raises error\n2 * four # equals Money.new(800, 'EUR')\n2 / four # raises error\nfour  2 # raises error\n2  four # raises error\nfour % 3 # equals Money.new(100, 'EUR')\n5 % four # raises error\nMath.sqrt(four) # raises error\netc.\n```\nThis is the exactly what would happen if you multiply some physical unit (like meters for length) by numbers when the outcome must be in the same unit; 2 * 3 meters is 6 meters whereas 2 meters * 3 meters is 6 square meters. Also, you cannot add something without a unit to something with a unit, so I think an explicit #to_money would be appropriate to expect from the user.\n. ``` sh\n\n$ irb\n2.0.0-p353 :001 > require 'money'\n => true\n2.0.0-p353 :002 > Money.new(1000, 'INR').exchange_to('INR')\n => #\n2.0.0-p353 :003 > Money.new(1000, 'INR').currency\n => #\n```\n\nMaybe you want to use Money#amount, Money#fractional or Money#to_f?\n. > i think this library considers the amount entered in cents not in dollars.\nThat's intended. https://github.com/RubyMoney/money#usage\n. It does matter which way it is converted; one may have a rate r for e.g. EUR -> USD and not 1/r for USD -> EUR. This is very common in banks where they benefit from the margin (along with maybe a conversion fee).\nTherefore I am not very fond of the way the rounding issue is solved. Moreover, @lulalala can you more explicitly examplify the rounding issue? I might be a bit tired, but I do not fully understand.\n. I think the comment should be\n\n0.03 FOO == 0.015 USD but gets rounded down to 0.01 USD\n\nwhich then doesn't call for a fix IMHO.\nAm I misunderstanding something?\n. Someone with overview who will decide, @semmons99 ?\n. > I can fork and make a pull request if needed...\n:+1: \n. Duplicate of #399?\n. For reference: \nhttp://www.currency-iso.org/dam/isocy/downloads/dl_currency_iso_amendment_92.pdf (dl_currency_iso_amendment_92.pdf.zip)\n. Related to https://github.com/RubyMoney/money/pull/405?\n. https://github.com/RubyMoney/money/blob/master/lib/money/bank/base.rb#L52?\n. https://github.com/RubyMoney/money/blame/master/README.md#L9 :smiley: \n. See https://github.com/RubyMoney/money#usage for instance\nMoney.from_amount(5, \"USD\") == Money.new(500, \"USD\")  # 5 USD\nAlso, see https://github.com/RubyMoney/money#features.\n. The division Money.new(20487)/100 gives you integer division in minor unit, thus, #<Money fractional:205 currency:USD> rather than the non-integer value 2.0487.. I don't understand the issue.\nirb(main):002:0> Money.new(20487)/100 == Money.new(20487.0)/100 and Money.new(20487)/100 == Money.new(20487)/100.0\n=> true\nirb(main):003:0> Money.new(20487).to_f/100.0 == Money.new(20487)/100.0\n=> false\nBy using Money.new(20487) you get integer division because Moneys are rounded (by a configurable method) to fit within the precision of 1 minor unit.. Please notice that ISO 4217 lists CLP to have exponent 0, thus subunit_to_unit == 1.\nBonus information: On Oct. 14th, 12:00 St Louis, even Visa and Mastercard will adjust CLP (and UGX) to be aligned with ISO \ud83d\ude42\nEdit: Mastercard updates CLP on Oct. 14th 12:00 St Louis time; Visa updates CLP on Oct. 13th 10:00 GMT \ud83e\udd26\u200d\u2642\ufe0f. https://www.currency-iso.org/dam/downloads/lists/list_one.xls \ud83d\ude42. I like the code and I notice that it agrees with https://github.com/bbatsov/ruby-style-guide#no-nested-conditionals. However, I'd probably only fix this if the code style was fixed (in this regard) all over.. ",
    "nickhoffman": "This happens for me, too.\nrequire 'money/core_extension' raises an error.\nrequire 'money/core_extensions' doesn't cause the warnings to stop.\nI'm using money-rails 0.9.0 and money 6.0.0, which are the newest gem versions.\nruby\nDataSet.new.cad_to_usd_rate = 1\nDEPRECATION WARNING: as of Money 6.1.0 you must `require 'money/core_extension'` to use Numeric#to_money.\n=> 1\n. This happens for me, too.\nrequire 'money/core_extension' raises an error.\nrequire 'money/core_extensions' doesn't cause the warnings to stop.\nI'm using money-rails 0.9.0 and money 6.0.0, which are the newest gem versions.\nruby\nDataSet.new.cad_to_usd_rate = 1\nDEPRECATION WARNING: as of Money 6.1.0 you must `require 'money/core_extension'` to use Numeric#to_money.\n=> 1\n. ",
    "jgwmaxwell": "This is still happening on 6.0.1 - requiring monetize/core_extensions doesn't stop the errors and it spams the logs a ridiculous amount. The deprecation warning is obviously needed, but it shouldn't still be spamming once the require has been made!\n. This is still happening on 6.0.1 - requiring monetize/core_extensions doesn't stop the errors and it spams the logs a ridiculous amount. The deprecation warning is obviously needed, but it shouldn't still be spamming once the require has been made!\n. ",
    "ginter": "Didn't see your comment, sorry about that\n. https://github.com/RubyMoney/money/issues/354\n. Ran into more issues when I started looking further into the Money::Money class. \nAll of the Parsing methods also issue the deprecated warnings and there's no easy way that I can see to get the Monetize class methods as instance variables in Money::Money without changing the monetize gem.\nEasy fix would seemingly be to just remove the deprecation warnings and delegate to Monetize as they already do.\nIt just seems strange to me to issue deprecation warnings to use monetize when it's already being required/used internally.\n. Didn't see your comment, sorry about that\n. https://github.com/RubyMoney/money/issues/354\n. Ran into more issues when I started looking further into the Money::Money class. \nAll of the Parsing methods also issue the deprecated warnings and there's no easy way that I can see to get the Monetize class methods as instance variables in Money::Money without changing the monetize gem.\nEasy fix would seemingly be to just remove the deprecation warnings and delegate to Monetize as they already do.\nIt just seems strange to me to issue deprecation warnings to use monetize when it's already being required/used internally.\n. ",
    "calebthompson": "I think I was running into the same error as @derekprior in https://github.com/RubyMoney/money/issues/354.\n. This isn't removing the silencer, it's just:\n1. Adding the silencer's effect to String#to_money so that it won't always complain, and\n2. Moving the logic to silence deprecations into Money::deprecate so that it isn't as noisy in the codebase.\nI wouldn't be against having this in monetize, but I assumed you wanted it here.\nAs for merge conflicts, I have just rebased onto master, so they should be taken care of.\n. lgtm\n. Sorry. transpec worked pretty well on another of my projects. I recommend that approach.\n. I think I was running into the same error as @derekprior in https://github.com/RubyMoney/money/issues/354.\n. This isn't removing the silencer, it's just:\n1. Adding the silencer's effect to String#to_money so that it won't always complain, and\n2. Moving the logic to silence deprecations into Money::deprecate so that it isn't as noisy in the codebase.\nI wouldn't be against having this in monetize, but I assumed you wanted it here.\nAs for merge conflicts, I have just rebased onto master, so they should be taken care of.\n. lgtm\n. Sorry. transpec worked pretty well on another of my projects. I recommend that approach.\n. ",
    "seuros": ":+1: \n. @semmons99 , updated.\n. :+1: \n. @semmons99 , updated.\n. ",
    "raphaelcm": "It was an unrelated error. Nevermind.\n. It was an unrelated error. Nevermind.\n. ",
    "zemanux": "Hi semmons99, with a signed integer or BigDecimal it's the same problem !\n. I submitted pull request #365 \n. I've tested this : \nYAML.load(50000.to_money.to_yaml)                                                                                       \n =>  #<Money fractional:27 currency:USD>\n. Yes indeed. Well done ! How can I fix this ?\n. OK, I'll have a look and keep you in touch. ;-)\n. Hi semmons99, with a signed integer or BigDecimal it's the same problem !\n. I submitted pull request #365 \n. I've tested this : \nYAML.load(50000.to_money.to_yaml)                                                                                       \n =>  #<Money fractional:27 currency:USD>\n. Yes indeed. Well done ! How can I fix this ?\n. OK, I'll have a look and keep you in touch. ;-)\n. ",
    "cyzanfar": "am using ruby 1.8.7 and im using  am using rvm 1.25.18. \nIt is working now require 'money' returns true. \nI ran rvm -v gave me: \nWarning! PATH is not properly set up, '/Users/cyrusghazanfar/.rvm/gems/ruby-1.9.3-p484/bin' is not available,\n         usually this is caused by shell initialization files - check them for 'PATH=...' entries,\n         it might also help to re-add RVM to your dotfiles: 'rvm get stable --auto-dotfiles',\n         to fix temporarily in this shell session run: 'rvm use ruby-1.9.3-p484'.\nrvm 1.25.18 (stable) by Wayne E. Seguin <wayneeseguin@gmail.com>, Michal Papis <mpapis@gmail.com> [https://rvm.io/]\nso then i entered rvm get stable --auto-dotfiles which gave me\nWarning! PATH is not properly set up, '/Users/cyrusghazanfar/.rvm/gems/ruby-1.9.3-p484/bin' is not available,\nusually this is caused by shell initialization files - check them for 'PATH=...' entries,\n         it might also help to re-add RVM to your dotfiles: 'rvm get stable --auto-dotfiles',\n         to fix temporarily in this shell session run: 'rvm use ruby-1.9.3-p484'.Downloading https://get.rvm.io\nTurning on auto dotfiles mode.\nDownloading https://github.com/wayneeseguin/rvm/archive/stable.tar.gz\nUpgrading the RVM installation in /Users/cyrusghazanfar/.rvm/\n    Removing rvm PATH line from /Users/cyrusghazanfar/.profile /Users/cyrusghazanfar/.bashrc /Users/cyrusghazanfar/.zshrc.\n    Adding rvm PATH line to /Users/cyrusghazanfar/.profile /Users/cyrusghazanfar/.bashrc /Users/cyrusghazanfar/.zshrc.\n    Removing rvm loading line from /Users/cyrusghazanfar/.bash_profile /Users/cyrusghazanfar/.zlogin.\n    Adding rvm loading line to /Users/cyrusghazanfar/.bash_profile /Users/cyrusghazanfar/.zlogin.\nUpgrade of RVM in /Users/cyrusghazanfar/.rvm/ is complete.```\n`````` cyrusghazanfar,\nThank you for using RVM!\n   We sincerely hope that RVM helps to make your life easier and more enjoyable!!!\n ~Wayne, Michal & team.```\nIn case of problems: http://rvm.io/help and https://twitter.com/rvm_io\nUpgrade Notes:\n/Users/cyrusghazanfar/.bash_profile:4:export PATH=/usr/local/bin:/usr/local/bin:/usr/local/sbin:~/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin:/Users/cyrusghazanfar/.rvm/bin\n* WARNING: Above files contains `PATH=` with no `$PATH` inside, this can break RVM,\n    for details check https://github.com/wayneeseguin/rvm/issues/1351#issuecomment-10939525\n    to avoid this warning append #PATH.\n* No new notes to display.\nRVM reloaded!\nAnd now when i switch back to irb and run require 'money' it gave me true.\nHow's so?\n`````\n.  am using ruby 1.8.7 and im using  am using rvm 1.25.18. \nIt is working nowrequire 'money'returnstrue. \nI ranrvm -vgave me:Warning! PATH is not properly set up, '/Users/cyrusghazanfar/.rvm/gems/ruby-1.9.3-p484/bin' is not available,\n         usually this is caused by shell initialization files - check them for 'PATH=...' entries,\n         it might also help to re-add RVM to your dotfiles: 'rvm get stable --auto-dotfiles',\n         to fix temporarily in this shell session run: 'rvm use ruby-1.9.3-p484'.`\nrvm 1.25.18 (stable) by Wayne E. Seguin <wayneeseguin@gmail.com>, Michal Papis <mpapis@gmail.com> [https://rvm.io/]\nso then i entered rvm get stable --auto-dotfiles which gave me\nWarning! PATH is not properly set up, '/Users/cyrusghazanfar/.rvm/gems/ruby-1.9.3-p484/bin' is not available,\nusually this is caused by shell initialization files - check them for 'PATH=...' entries,\n         it might also help to re-add RVM to your dotfiles: 'rvm get stable --auto-dotfiles',\n         to fix temporarily in this shell session run: 'rvm use ruby-1.9.3-p484'.Downloading https://get.rvm.io\nTurning on auto dotfiles mode.\nDownloading https://github.com/wayneeseguin/rvm/archive/stable.tar.gz\nUpgrading the RVM installation in /Users/cyrusghazanfar/.rvm/\n    Removing rvm PATH line from /Users/cyrusghazanfar/.profile /Users/cyrusghazanfar/.bashrc /Users/cyrusghazanfar/.zshrc.\n    Adding rvm PATH line to /Users/cyrusghazanfar/.profile /Users/cyrusghazanfar/.bashrc /Users/cyrusghazanfar/.zshrc.\n    Removing rvm loading line from /Users/cyrusghazanfar/.bash_profile /Users/cyrusghazanfar/.zlogin.\n    Adding rvm loading line to /Users/cyrusghazanfar/.bash_profile /Users/cyrusghazanfar/.zlogin.\nUpgrade of RVM in /Users/cyrusghazanfar/.rvm/ is complete.```\n`````` cyrusghazanfar,\nThank you for using RVM!\n   We sincerely hope that RVM helps to make your life easier and more enjoyable!!!\n ~Wayne, Michal & team.```\nIn case of problems: http://rvm.io/help and https://twitter.com/rvm_io\nUpgrade Notes:\n/Users/cyrusghazanfar/.bash_profile:4:export PATH=/usr/local/bin:/usr/local/bin:/usr/local/sbin:~/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin:/Users/cyrusghazanfar/.rvm/bin\n* WARNING: Above files contains `PATH=` with no `$PATH` inside, this can break RVM,\n    for details check https://github.com/wayneeseguin/rvm/issues/1351#issuecomment-10939525\n    to avoid this warning append #PATH.\n* No new notes to display.\nRVM reloaded!\nAnd now when i switch back to irb and run require 'money' it gave me true.\nHow's so?\n``````\n. ",
    "andrewhavens": "This is still an issue, however, it appears that this is a bug in Ruby 2.1.1. I am using Money 5.1.1 and am also experiencing the same segfault.\nThere is an open issue on the Ruby issue tracker which suggests a monkey patch to get around the issue. I can't vouch for it's effectiveness as I have yet to try it.\n. This is still an issue, however, it appears that this is a bug in Ruby 2.1.1. I am using Money 5.1.1 and am also experiencing the same segfault.\nThere is an open issue on the Ruby issue tracker which suggests a monkey patch to get around the issue. I can't vouch for it's effectiveness as I have yet to try it.\n. ",
    "igajard1": "I'm a chilean developer and realized that our currency symbol html_entity is wrong.\nIs there a way to hack these value until its released?\n. Don`t worry registering a corrected CLP, solves the issue. Although the pull request is valid.\n``` ruby\nRegister a corrected CLP\ncurr = {\n    priority: 1,\n    iso_code: \"CLP\",\n    name: \"Chilean Peso\",\n    symbol: \"$\",\n    alternate_symbols: [],\n    subunit: \"Peso\",\n    subunit_to_unit: 1,\n    symbol_first: true,\n    html_entity: \"$\",\n    decimal_mark: \",\",\n    thousands_separator: \".\",\n    iso_numeric: \"152\"\n}\nMoney::Currency.register(curr)\n``\n. I'm a chilean developer and realized that our currency symbol html_entity is wrong.\nIs there a way to hack these value until its released?\n. Dont worry registering a corrected CLP, solves the issue. Although the pull request is valid.\n``` ruby\nRegister a corrected CLP\ncurr = {\n    priority: 1,\n    iso_code: \"CLP\",\n    name: \"Chilean Peso\",\n    symbol: \"$\",\n    alternate_symbols: [],\n    subunit: \"Peso\",\n    subunit_to_unit: 1,\n    symbol_first: true,\n    html_entity: \"$\",\n    decimal_mark: \",\",\n    thousands_separator: \".\",\n    iso_numeric: \"152\"\n}\nMoney::Currency.register(curr)\n```\n. ",
    "tenoriocesar": "@semmons99 requested change is done!\n. @semmons99 requested change is done!\n. ",
    "rubenrails": "Oops! I just noticed the last example of the Currency Exchange block.\nruby\nMoney.new(1000, \"EUR\") + Money.new(1000, \"USD\") == Money.new(1500, \"EUR\")\nSeems like it's already possible to do what I was asking for, it didn't work for me last time I tried, maybe it was just something wrong with my code. I'll check again and re-open if I find a bug.\n@semmons99 I was talking about actually converting but behind the scenes by checking the exchange rate on the default bank (which seems like it's already been implemented)\n. Oops! I just noticed the last example of the Currency Exchange block.\nruby\nMoney.new(1000, \"EUR\") + Money.new(1000, \"USD\") == Money.new(1500, \"EUR\")\nSeems like it's already possible to do what I was asking for, it didn't work for me last time I tried, maybe it was just something wrong with my code. I'll check again and re-open if I find a bug.\n@semmons99 I was talking about actually converting but behind the scenes by checking the exchange rate on the default bank (which seems like it's already been implemented)\n. ",
    "clowder": "@semmons99 Apologies, I moved the check from the [SingleCurrency] bank into [Money#exchange_to] and did a rebase. Hopefully it's all kosher now\u203d\n. Sorry @semmons99 there is no way for me to see the merge status from my end. I've submitted a rebased version over at #379; we're actively using appearhere:v6.0.1-stable.\n. @semmons99 Apologies, I moved the check from the [SingleCurrency] bank into [Money#exchange_to] and did a rebase. Hopefully it's all kosher now\u203d\n. Sorry @semmons99 there is no way for me to see the merge status from my end. I've submitted a rebased version over at #379; we're actively using appearhere:v6.0.1-stable.\n. ",
    "JDutil": "I hadn't noticed any deprecation warnings from Spree using Monetize that was recently removed in the new version.  Should we just begin to require Monetize on it's own?\n. Thanks.\n. I hadn't noticed any deprecation warnings from Spree using Monetize that was recently removed in the new version.  Should we just begin to require Monetize on it's own?\n. Thanks.\n. ",
    "juriglx": "I thought i did with: https://github.com/aklamio/money/commit/a71c477c7a47fe5e50e70b57feee195de1eb19aa\nDoes it not fail for you?\n. At the moment i have no idea how to fix this without breaking stuff. So, no promises..\n. I thought i did with: https://github.com/aklamio/money/commit/a71c477c7a47fe5e50e70b57feee195de1eb19aa\nDoes it not fail for you?\n. At the moment i have no idea how to fix this without breaking stuff. So, no promises..\n. ",
    "optimator999": "I thought the same, but the mode didn't seem to make a difference.I've expanded the test to show that the rounding_mode fails to make a difference\n```\nclass TestMoneyGem < Test::Unit::TestCase\n    #This works\n    def test_round_up\n        Money.rounding_mode(BigDecimal::ROUND_UP) do\n          assert_equal(Money.new(35), Money.new(1200) * BigDecimal.new('0.029'))\n        end\n    end\n#This works\ndef test_round_down\n    Money.rounding_mode(BigDecimal::ROUND_DOWN) do\n        assert_equal(Money.new(34),Money.new(1200) * BigDecimal.new('0.029'))\n    end\nend\n\n#This fails\ndef test_conversion_1\n    Money.rounding_mode(BigDecimal::ROUND_UP) do\n        btc = Money.new(\"4084841687\", 'BTC')\n        Money.add_rate(\"BTC\", \"USD\", \"538.65\")\n        assert_equal btc.exchange_to(\"USD\"), Money.new(\"2200300\", \"USD\")\n    end\nend\n\n#This fails\ndef test_conversion_2\n    Money.rounding_mode(BigDecimal::ROUND_CEILING) do\n        btc = Money.new(\"4084841687\", 'BTC')\n        Money.add_rate(\"BTC\", \"USD\", \"538.65\")\n        assert_equal btc.exchange_to(\"USD\"), Money.new(\"2200300\", \"USD\")\n    end\nend\n\nend\n```\nThe the last two assert tests fail.\n. The code:\nassert_equal Money.new(\"2200300\", \"USD\"), btc.exchange_to(\"USD\") {|x|x.round}\nis the correct way to accomplish what I need. The issue should remain closed.\n. I thought the same, but the mode didn't seem to make a difference.I've expanded the test to show that the rounding_mode fails to make a difference\n```\nclass TestMoneyGem < Test::Unit::TestCase\n    #This works\n    def test_round_up\n        Money.rounding_mode(BigDecimal::ROUND_UP) do\n          assert_equal(Money.new(35), Money.new(1200) * BigDecimal.new('0.029'))\n        end\n    end\n#This works\ndef test_round_down\n    Money.rounding_mode(BigDecimal::ROUND_DOWN) do\n        assert_equal(Money.new(34),Money.new(1200) * BigDecimal.new('0.029'))\n    end\nend\n\n#This fails\ndef test_conversion_1\n    Money.rounding_mode(BigDecimal::ROUND_UP) do\n        btc = Money.new(\"4084841687\", 'BTC')\n        Money.add_rate(\"BTC\", \"USD\", \"538.65\")\n        assert_equal btc.exchange_to(\"USD\"), Money.new(\"2200300\", \"USD\")\n    end\nend\n\n#This fails\ndef test_conversion_2\n    Money.rounding_mode(BigDecimal::ROUND_CEILING) do\n        btc = Money.new(\"4084841687\", 'BTC')\n        Money.add_rate(\"BTC\", \"USD\", \"538.65\")\n        assert_equal btc.exchange_to(\"USD\"), Money.new(\"2200300\", \"USD\")\n    end\nend\n\nend\n```\nThe the last two assert tests fail.\n. The code:\nassert_equal Money.new(\"2200300\", \"USD\"), btc.exchange_to(\"USD\") {|x|x.round}\nis the correct way to accomplish what I need. The issue should remain closed.\n. ",
    "lunks": "Shouldn't to_i ignore rounding? BigDecimal#to_i doesn't use the rounding mode when converting itself to Integer.\nMy understanding is that I want the \"non-cents\" part. If I wanted to round it first, I'd to Money.new(100).round.to_i.\nI could add this to the documentation if you think it can be misleading.\n. I have no strong opinion on any of the options as my usage is on an app that doesn't care about cents, so either would work for me. My concern is that with .to_i I assume people would not expect rounding, just the integer part, given its name.\n. Sure!\n. Oh, sorry about that. I'll do that later today.\nOn Thu, May 15, 2014 at 5:28 PM, Shane Emmons notifications@github.comwrote:\n\nYou'll actually want to move this up into a # Master section as 6.1.0\n(and 6.1.1) have already been released.\nIt would be really awesome if you could go back and figure out what was\nreleased in 6.1.1 and anything that's been committed since then.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/394#issuecomment-43260718\n.\n. Updated, take a look at it.\n. :+1: Looks fine to me. @semmons99 ?\n. Weird coverage reduce, couldn't find where it was introduced, and specs are still there. I'm merging this.\n. Thanks, @mjc \n. :-1: from me as well, no apparent reason to change how some specific (or all) currency works. Your use case seems to be a misunderstanding of a feature we have -- infinite precision. I'm okay with having an issue where an user might not understand how can we use infinite precision on something like i.e. gas price, but it seems that allowing you to exactly that so solves your problem.\n\nAnything I'm missing where we might need to change currency on the fly? They seem to be pretty much static on the real world, and we should keep it this way in our gem. If we happen to have any discrepancies on how real life currency works and how we implement it, I'm more than happy to hear about it. Otherwise, you should treat it according to your personal needs.\n. Thanks!\n. I'd take a grip on this, but IMHO working with numbers and money objects is weird if you don't convert it. I would always expect 4 / Money.new(400) to return 1 but I believe we expect 0.01.\n. :+1: \n. We should have tests for the possible operations. *, /, +, -, <=>\n. Can we upgrade directly to RSpec 3.0 instead of 2.99? 2.99 is meant only so you can transition to 3.0.\n. Looks good to me!\n. .to_i shouldn't care about round. You can round in several different ways. Rounding is one of them.\nPedro Nascimento\n\nOn Sep 5, 2014, at 01:20, Eaden notifications@github.com wrote:\nIf you look at the spec, I believe this is fixing a bug? i.e. the spec fails without this.\nIs an increase in accuracy such a bad thing? can this be a breaking change for the next major release?\n\u2014\nReply to this email directly or view it on GitHub.\n. I agree.\n\nPedro Nascimento\n\nOn Sep 5, 2014, at 02:12, Shane Emmons notifications@github.com wrote:\nChanging this has repercussions throughout all the existing exchange libraries. Simply adding a feature toggle that allows users to use round (perhaps a specific version of it like the actual Money object does) vs dumb to_i is a much more stable approach. Then, if we have an outcry of \"make the round toggle the default, we can do that in a major release\". With 2.5 million downloads, we can't break stuff without some serious thought and community buy in.\n\u2014\nReply to this email directly or view it on GitHub.\n. This looks awesome. :clap:\n. IMHO you should move everything as the first part of the branch (no need for a PR if it's just moving) then it should be easier to review all the other changes.\n. I'm in favor of dropping support for 1.9 if we need to. Do you think this makes the code better enough for us to drop support for 1.9.3? If not, it's better for us to keep it compatible.\n. Shouldn't to_i ignore rounding? BigDecimal#to_i doesn't use the rounding mode when converting itself to Integer.\n\nMy understanding is that I want the \"non-cents\" part. If I wanted to round it first, I'd to Money.new(100).round.to_i.\nI could add this to the documentation if you think it can be misleading.\n. I have no strong opinion on any of the options as my usage is on an app that doesn't care about cents, so either would work for me. My concern is that with .to_i I assume people would not expect rounding, just the integer part, given its name.\n. Sure!\n. Oh, sorry about that. I'll do that later today.\nOn Thu, May 15, 2014 at 5:28 PM, Shane Emmons notifications@github.comwrote:\n\nYou'll actually want to move this up into a # Master section as 6.1.0\n(and 6.1.1) have already been released.\nIt would be really awesome if you could go back and figure out what was\nreleased in 6.1.1 and anything that's been committed since then.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/RubyMoney/money/pull/394#issuecomment-43260718\n.\n. Updated, take a look at it.\n. :+1: Looks fine to me. @semmons99 ?\n. Weird coverage reduce, couldn't find where it was introduced, and specs are still there. I'm merging this.\n. Thanks, @mjc \n. :-1: from me as well, no apparent reason to change how some specific (or all) currency works. Your use case seems to be a misunderstanding of a feature we have -- infinite precision. I'm okay with having an issue where an user might not understand how can we use infinite precision on something like i.e. gas price, but it seems that allowing you to exactly that so solves your problem.\n\nAnything I'm missing where we might need to change currency on the fly? They seem to be pretty much static on the real world, and we should keep it this way in our gem. If we happen to have any discrepancies on how real life currency works and how we implement it, I'm more than happy to hear about it. Otherwise, you should treat it according to your personal needs.\n. Thanks!\n. I'd take a grip on this, but IMHO working with numbers and money objects is weird if you don't convert it. I would always expect 4 / Money.new(400) to return 1 but I believe we expect 0.01.\n. :+1: \n. We should have tests for the possible operations. *, /, +, -, <=>\n. Can we upgrade directly to RSpec 3.0 instead of 2.99? 2.99 is meant only so you can transition to 3.0.\n. Looks good to me!\n. .to_i shouldn't care about round. You can round in several different ways. Rounding is one of them.\nPedro Nascimento\n\nOn Sep 5, 2014, at 01:20, Eaden notifications@github.com wrote:\nIf you look at the spec, I believe this is fixing a bug? i.e. the spec fails without this.\nIs an increase in accuracy such a bad thing? can this be a breaking change for the next major release?\n\u2014\nReply to this email directly or view it on GitHub.\n. I agree.\n\nPedro Nascimento\n\nOn Sep 5, 2014, at 02:12, Shane Emmons notifications@github.com wrote:\nChanging this has repercussions throughout all the existing exchange libraries. Simply adding a feature toggle that allows users to use round (perhaps a specific version of it like the actual Money object does) vs dumb to_i is a much more stable approach. Then, if we have an outcry of \"make the round toggle the default, we can do that in a major release\". With 2.5 million downloads, we can't break stuff without some serious thought and community buy in.\n\u2014\nReply to this email directly or view it on GitHub.\n. This looks awesome. :clap:\n. IMHO you should move everything as the first part of the branch (no need for a PR if it's just moving) then it should be easier to review all the other changes.\n. I'm in favor of dropping support for 1.9 if we need to. Do you think this makes the code better enough for us to drop support for 1.9.3? If not, it's better for us to keep it compatible.\n. \n",
    "momer": "@semmons99 @lunks consider the following:\nPer the API, I can reasonably assume that my_money = Money.new(3009, \"USD\") returns a Money object representing $30.09. And, as such, Money#to_f returns that $30.09 representation as a Float 30.09. So it would also be reasonable to expect that Money#to_i returns the integer part of the Money object, just as Float#to_i and BigDecimal#to_i do, without any rounding.\nAs a related aside: Money#new takes 3 parameters [0] the first of which is a representation of the fractional value of the money. Now, whether or not Money should be coercing to anything other than a Fractional representation of the money, as a BigDecimal is another discussion :smile: \n. @semmons99 @lunks consider the following:\nPer the API, I can reasonably assume that my_money = Money.new(3009, \"USD\") returns a Money object representing $30.09. And, as such, Money#to_f returns that $30.09 representation as a Float 30.09. So it would also be reasonable to expect that Money#to_i returns the integer part of the Money object, just as Float#to_i and BigDecimal#to_i do, without any rounding.\nAs a related aside: Money#new takes 3 parameters [0] the first of which is a representation of the fractional value of the money. Now, whether or not Money should be coercing to anything other than a Fractional representation of the money, as a BigDecimal is another discussion :smile: \n. ",
    "alex-ross": "Guess it has something to do with I18n. Looks like all currencies gets same thousand separator and decimal mark if you define an format in your locale files.\nCheck out this method:\nlib/money/money/formatting.rb#L13-L27\nSo if I set Money.use_i18n to false it will work as i expect. So why is it true by default and why should we want I18n to override all currencies as it is now?\n. No after some thougths i actully agree. Displaying currencies between each other with different decimalpointers and so on may be confusing.\u2014\nAlexander Ross\nOn Sun, May 11, 2014 at 5:38 AM, Shane Emmons notifications@github.com\nwrote:\n\nOkay. So, if you're using i18n, the thought is you want everything output according to your definitions, not our guesses. Seems a fair default to me. Do you disagree, if so, is it worth breaking 1000's of apps to change?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/390#issuecomment-42761077\n. @saizai Guess everything in CHANGELOG's \"future release\" should be for 6.6.0. No changes in the changelog since the version bump.\n. You should use https://github.com/RubyMoney/money-rails instead. That Gem do includes helpers  for Rails. This Gem does not.\n\nIf it still doesn't work, feel free to resubmit the issue there.\n. Guess it has something to do with I18n. Looks like all currencies gets same thousand separator and decimal mark if you define an format in your locale files.\nCheck out this method:\nlib/money/money/formatting.rb#L13-L27\nSo if I set Money.use_i18n to false it will work as i expect. So why is it true by default and why should we want I18n to override all currencies as it is now?\n. No after some thougths i actully agree. Displaying currencies between each other with different decimalpointers and so on may be confusing.\u2014\nAlexander Ross\nOn Sun, May 11, 2014 at 5:38 AM, Shane Emmons notifications@github.com\nwrote:\n\nOkay. So, if you're using i18n, the thought is you want everything output according to your definitions, not our guesses. Seems a fair default to me. Do you disagree, if so, is it worth breaking 1000's of apps to change?\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/390#issuecomment-42761077\n. @saizai Guess everything in CHANGELOG's \"future release\" should be for 6.6.0. No changes in the changelog since the version bump.\n. You should use https://github.com/RubyMoney/money-rails instead. That Gem do includes helpers  for Rails. This Gem does not.\n\nIf it still doesn't work, feel free to resubmit the issue there.\n. ",
    "apneadiving": "it fully does, thank you and sorry I didnt catch that.\n. it fully does, thank you and sorry I didnt catch that.\n. ",
    "brixen": "Thank you!\n. Thank you!\n. ",
    "mjc": "Whoop, I missed another rescue NoMethodError.\n. Freshly squashed. :)\n. Sorry, apparently I can't click straight, time to go home. :+1: \n. It seems like a reasonable use case might be for updating currency information on the fly in a web form or something.  This is probably worth fixing.   At first glance it seems like we could just use ThreadSafe::Cache and just be done with it, but I would have to take some time and try it out just to be sure.\n. Agreed, offering more precision would fix the original.  There's no reason doing this in a thread-safe way would even be difficult, though. Why not just fix the thread safety anyway? I'll happily do the work.\n. Whoop, I missed another rescue NoMethodError.\n. Freshly squashed. :)\n. Sorry, apparently I can't click straight, time to go home. :+1: \n. It seems like a reasonable use case might be for updating currency information on the fly in a web form or something.  This is probably worth fixing.   At first glance it seems like we could just use ThreadSafe::Cache and just be done with it, but I would have to take some time and try it out just to be sure.\n. Agreed, offering more precision would fix the original.  There's no reason doing this in a thread-safe way would even be difficult, though. Why not just fix the thread safety anyway? I'll happily do the work.\n. ",
    "paulodiniz": "@semmons99 Squashed :+1: \n. @mikerodrigues I agree with you that the we should coerce the other operand in the coerce method. But if we do this:\n2 * Money.new(3)\nIt will try to coerce the Numeric 2 to a Money class, and will throw an error on the multiplication method, because it will try to multiply two instances of Money.\n. :+1: \n. The Money::RatesStore::Memory is only available from 6.6.0 versions. Looking on the 6.5.1 tag 6.5.1 that class does not exist yet. \nOn the 6.6.0 tag 6.6.0 you can see it's there.\nJust update your gem and it will work :smile: \n. The other approach would it be to check if the other_money parameter is a Numeric ,coerce the self class to Numeric if true, and then compare them\n. This PR also handles with comparison on other numbers`\nruby\nMoney.new(2) < 3\n=> true\nI mean, this all can be addressed on the Coercion issues, but I think it's an honest way to achieve something logical without the coercion discussion\n. You are right :) Updated the PR\n. @epidemian You are right, those issues would be solved using a better coercion method, which I think it's being discussed on Issue 606\n. I was unable to reproduce with those same versions.\nruby\nirb(main):002:0* Rails.application.eager_load!\n/Users/paulodiniz/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activejob-5.0.1/lib/active_job/arguments.rb:38: warning: constant ::Fixnum is deprecated\n/Users/paulodiniz/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activejob-5.0.1/lib/active_job/arguments.rb:38: warning: constant ::Bignum is deprecated\n=> [\"/Users/paulodiniz/rails/money-test/app/assets\", \"/Users/paulodiniz/rails/money-test/app/channels\", \"/Users/paulodiniz/rails/money-test/app/controllers\", \"/Users/paulodiniz/rails/money-test/app/controllers/concerns\", \"/Users/paulodiniz/rails/money-test/app/helpers\", \"/Users/paulodiniz/rails/money-test/app/jobs\", \"/Users/paulodiniz/rails/money-test/app/mailers\", \"/Users/paulodiniz/rails/money-test/app/models\", \"/Users/paulodiniz/rails/money-test/app/models/concerns\"]\nCan you please provide us the full stacktrace as @printercu mentioned please?. @semmons99 Squashed :+1: \n. @mikerodrigues I agree with you that the we should coerce the other operand in the coerce method. But if we do this:\n2 * Money.new(3)\nIt will try to coerce the Numeric 2 to a Money class, and will throw an error on the multiplication method, because it will try to multiply two instances of Money.\n. :+1: \n. The Money::RatesStore::Memory is only available from 6.6.0 versions. Looking on the 6.5.1 tag 6.5.1 that class does not exist yet. \nOn the 6.6.0 tag 6.6.0 you can see it's there.\nJust update your gem and it will work :smile: \n. The other approach would it be to check if the other_money parameter is a Numeric ,coerce the self class to Numeric if true, and then compare them\n. This PR also handles with comparison on other numbers`\nruby\nMoney.new(2) < 3\n=> true\nI mean, this all can be addressed on the Coercion issues, but I think it's an honest way to achieve something logical without the coercion discussion\n. You are right :) Updated the PR\n. @epidemian You are right, those issues would be solved using a better coercion method, which I think it's being discussed on Issue 606\n. I was unable to reproduce with those same versions.\nruby\nirb(main):002:0* Rails.application.eager_load!\n/Users/paulodiniz/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activejob-5.0.1/lib/active_job/arguments.rb:38: warning: constant ::Fixnum is deprecated\n/Users/paulodiniz/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activejob-5.0.1/lib/active_job/arguments.rb:38: warning: constant ::Bignum is deprecated\n=> [\"/Users/paulodiniz/rails/money-test/app/assets\", \"/Users/paulodiniz/rails/money-test/app/channels\", \"/Users/paulodiniz/rails/money-test/app/controllers\", \"/Users/paulodiniz/rails/money-test/app/controllers/concerns\", \"/Users/paulodiniz/rails/money-test/app/helpers\", \"/Users/paulodiniz/rails/money-test/app/jobs\", \"/Users/paulodiniz/rails/money-test/app/mailers\", \"/Users/paulodiniz/rails/money-test/app/models\", \"/Users/paulodiniz/rails/money-test/app/models/concerns\"]\nCan you please provide us the full stacktrace as @printercu mentioned please?. ",
    "nozpheratu": "Hmm, well I made a fork with an updated JSON file that includes an additional field containing the main ISO 3166 country code associated for any given currency, but I now see what you meant with some currencies being used by more than one country. This wiki article nicely summarizes all the currencies that are shared between multiple territories.\nI don't think it would be difficult to extend what I have currently to accommodate this. For me, what I have is sufficient for my needs, but I don't mind putting in some extra work in to make something a little more robust if you think it adds value to your project.\n. Hmm, well I made a fork with an updated JSON file that includes an additional field containing the main ISO 3166 country code associated for any given currency, but I now see what you meant with some currencies being used by more than one country. This wiki article nicely summarizes all the currencies that are shared between multiple territories.\nI don't think it would be difficult to extend what I have currently to accommodate this. For me, what I have is sufficient for my needs, but I don't mind putting in some extra work in to make something a little more robust if you think it adds value to your project.\n. ",
    "lmmendes": "Hello i'm going to be talking in place of @passworks (i used the wrong account to open the ticket).\nI'm doing that invalidation because in my use case i need more precision in the subunit for my calculations, in this case a precision of four (0000) digits and the gem by default only has two (00) digit precision for each currency.\nSo one ideia was cloning all currencies, removing them from the gem and re-adding them with the adjusted precision.\nThe supplied alternative does not work because Money::Currency.tabledoes not allow assignment (not implemented), it gives the following error:\n`undefined method 'table=' for Money::Currency:Class (NoMethodError)``\nIs there a easy way to change the currencies precision without having to fork the gem and changing the supplied \".json\" files provided or without resorting to the hack mentioned in the first comment by @passworks ?\n. @semmons99 that works fine for my case.\nAlthough first problem persists if you ever need to change currencies in a highly threaded environment.\nAlso should't Currency class have a method to change all currencies precision or one at a time at least?\n. Hello i'm going to be talking in place of @passworks (i used the wrong account to open the ticket).\nI'm doing that invalidation because in my use case i need more precision in the subunit for my calculations, in this case a precision of four (0000) digits and the gem by default only has two (00) digit precision for each currency.\nSo one ideia was cloning all currencies, removing them from the gem and re-adding them with the adjusted precision.\nThe supplied alternative does not work because Money::Currency.tabledoes not allow assignment (not implemented), it gives the following error:\n`undefined method 'table=' for Money::Currency:Class (NoMethodError)``\nIs there a easy way to change the currencies precision without having to fork the gem and changing the supplied \".json\" files provided or without resorting to the hack mentioned in the first comment by @passworks ?\n. @semmons99 that works fine for my case.\nAlthough first problem persists if you ever need to change currencies in a highly threaded environment.\nAlso should't Currency class have a method to change all currencies precision or one at a time at least?\n. ",
    "AlexeyKrasnoperov": "Added little more changes: I found that in your example in README with locale yml files wrong symbols are used for separator and delimeter and won't lead to \"1,234,567.89 kr\" result. Changed the same symbols in Money::Formatting controller.\n. Added little more changes: I found that in your example in README with locale yml files wrong symbols are used for separator and delimeter and won't lead to \"1,234,567.89 kr\" result. Changed the same symbols in Money::Formatting controller.\n. ",
    "fotos": "@semmons99 I added some comments on the #405. This PR is a start but can be improved.\n. Personally I see some mistakes that promote an inconsistent API.\nFor example while\nRuby\nMoney.new(2, 'USD') * 2\nis allowed, the commutative operation\nRuby\n2 * Money.new(2, 'USD')\nis not! Same goes for division (/). That makes the usage of money inconsistent.\nAlso addition (+) is commutative and should be allowed (the PR raises a TypeError). This PR is a start and fixes the calculation problems but (IMHO) it's incomplete and a bit too restrictive. I like the approach but I think we should try to coerce values (at least Numeric and ideally String).\n. @semmons99 yeah, I tried the multiplication again and it works. Perhaps, last night, I was in the wrong branch or something.\nMy comment still holds true for the division. I know division is not commutative but supporting it one way (Money / Numeric) and not the other (Numeric / Money) feels unintuitive. That's the whole point of coercion. You try to coerce the operand without changing the operation order (which was the mistake in the original code).\n. @semmons99 I added some comments on the #405. This PR is a start but can be improved.\n. Personally I see some mistakes that promote an inconsistent API.\nFor example while\nRuby\nMoney.new(2, 'USD') * 2\nis allowed, the commutative operation\nRuby\n2 * Money.new(2, 'USD')\nis not! Same goes for division (/). That makes the usage of money inconsistent.\nAlso addition (+) is commutative and should be allowed (the PR raises a TypeError). This PR is a start and fixes the calculation problems but (IMHO) it's incomplete and a bit too restrictive. I like the approach but I think we should try to coerce values (at least Numeric and ideally String).\n. @semmons99 yeah, I tried the multiplication again and it works. Perhaps, last night, I was in the wrong branch or something.\nMy comment still holds true for the division. I know division is not commutative but supporting it one way (Money / Numeric) and not the other (Numeric / Money) feels unintuitive. That's the whole point of coercion. You try to coerce the operand without changing the operation order (which was the mistake in the original code).\n. ",
    "sachin87": "@ct-clearhaus \n1 Dollar = 100 Cents\nwhen i write\nMoney.new(1000, :usd).exchange_to(:usd).to_f\nit returns me 10.0\nbut i want it be 1000, i think this library considers the amount entered in cents  not in dollars.\ni know that this is the default behavior, but i don't think its a better idea to put two extra zeros to achieve what i want.\n. @ct-clearhaus \nthere should be a configuration to change this default behavior.\n. thanks i will try it.\n. @semmons99 you was very quick in closing  this issue, by the way opposite conversion from GBP to IDR is successfully done. \n. @ct-clearhaus \n1 Dollar = 100 Cents\nwhen i write\nMoney.new(1000, :usd).exchange_to(:usd).to_f\nit returns me 10.0\nbut i want it be 1000, i think this library considers the amount entered in cents  not in dollars.\ni know that this is the default behavior, but i don't think its a better idea to put two extra zeros to achieve what i want.\n. @ct-clearhaus \nthere should be a configuration to change this default behavior.\n. thanks i will try it.\n. @semmons99 you was very quick in closing  this issue, by the way opposite conversion from GBP to IDR is successfully done. \n. ",
    "RKushnir": "The value is stored in subunits to allow for fractional amount like 12.34. (If I'm not mistaken, in your case that's in paise). Just multiply the amount by 100.\n. ruby\nMoney.new(1000).cents\n => 1000\n@semmons99 What's the point?\n. It seems to me, you're mixing different concerns. You use currency: INR to identify that it belongs to India, as well as an indicator of the currency. There's a commercial exchange rate for USD to INR, but you also have some ratio that plays the role of exchange rate, and also acts as a discount value. \nWhy don't you just store all prices in single currency(e.g. USD) and have a country_id column. And in countries table have a discount column(which is default to 0)?\n. Are you sure?\n``` ruby\nYAML.load(300.to_money.to_yaml)\n=> #\nYAML.load(\"!ruby/object:BigDecimal 27:0.3E5\").to_f\n=> 30000.0\n. Maybe collectiveidea/delayed_job#588 has to do with this. Are you by chance using DJ?\n. If the problem is in DJ, you better ask there :)\n. The value is stored in subunits to allow for fractional amount like 12.34. (If I'm not mistaken, in your case that's in paise). Just multiply the amount by 100.\n. ruby\nMoney.new(1000).cents\n => 1000\n```\n@semmons99 What's the point?\n. It seems to me, you're mixing different concerns. You use currency: INR to identify that it belongs to India, as well as an indicator of the currency. There's a commercial exchange rate for USD to INR, but you also have some ratio that plays the role of exchange rate, and also acts as a discount value. \nWhy don't you just store all prices in single currency(e.g. USD) and have a country_id column. And in countries table have a discount column(which is default to 0)?\n. Are you sure?\n``` ruby\nYAML.load(300.to_money.to_yaml)\n=> #\nYAML.load(\"!ruby/object:BigDecimal 27:0.3E5\").to_f\n=> 30000.0\n```\n. Maybe collectiveidea/delayed_job#588 has to do with this. Are you by chance using DJ?\n. If the problem is in DJ, you better ask there :)\n. ",
    "chengjunzhan": "For some reason, the same Money.euro(12345678).format returns something like this:\npry(main)> Money.new(123456789, \"EUR\").format\n=> \"\u20ac1,234,567.89\"\nI guess maybe because my default locale is \"en_US\"? In that case, because there are many other things in my repo that depend on the default locale, so I have to pass in the separator and mark explicitly.\n. Thanks. I double check and it looks like the master branch had the same issue.\n. Sure. I will submit one later today or tomorrow. Thanks!\n. For some reason, the same Money.euro(12345678).format returns something like this:\npry(main)> Money.new(123456789, \"EUR\").format\n=> \"\u20ac1,234,567.89\"\nI guess maybe because my default locale is \"en_US\"? In that case, because there are many other things in my repo that depend on the default locale, so I have to pass in the separator and mark explicitly.\n. Thanks. I double check and it looks like the master branch had the same issue.\n. Sure. I will submit one later today or tomorrow. Thanks!\n. ",
    "ollie": "Hm, yeah, the more I think about it the more horrible it seems. Discount should definitely handled in a different way.\n. Hm, yeah, the more I think about it the more horrible it seems. Discount should definitely handled in a different way.\n. ",
    "hoverlover": "Totally agree with you about sanitization.  But I figured since there was a default currency, we could use it :smile: \nI'll work on a PR.  Thanks for the quick reply!\n. Forgot to update my fork before creating the fix.  I'll send another PR.\n. Hmm, that's actually a good question.  I'll ask my resident translator and find out.\n. OK, I just found out that you are correct.  I will make that change.\n. I have verified with the translator that this is now correct.\n. Since these are finite things that are constant, I think putting them in the library is the right thing to do, instead of having people set them in a locale file. Forcing everyone to include the same rules in their own locale files doesn't feel right to me.\u00a0\n. Totally agree with you about sanitization.  But I figured since there was a default currency, we could use it :smile: \nI'll work on a PR.  Thanks for the quick reply!\n. Forgot to update my fork before creating the fix.  I'll send another PR.\n. Hmm, that's actually a good question.  I'll ask my resident translator and find out.\n. OK, I just found out that you are correct.  I will make that change.\n. I have verified with the translator that this is now correct.\n. Since these are finite things that are constant, I think putting them in the library is the right thing to do, instead of having people set them in a locale file. Forcing everyone to include the same rules in their own locale files doesn't feel right to me.\u00a0\n. ",
    "timpalander": "Is support for I18n 0.8.0 planned?. Is support for I18n 0.8.0 planned?. ",
    "troelskn": "Upon further investigation, it seems that I am wrong about SEK. I have removed that change from the PR. I'm certain about the correctness of the NOK change though.\n. CI is failing on AZN, but I made no changes to that, so not sure why?\n. Sure - Hang on\n. Upon further investigation, it seems that I am wrong about SEK. I have removed that change from the PR. I'm certain about the correctness of the NOK change though.\n. CI is failing on AZN, but I made no changes to that, so not sure why?\n. Sure - Hang on\n. ",
    "tjhart": "Shane,\nI believe the only thing I missed was updating the CHANGELOG and AUTHORS files. Let me know if there was something else you wanted.\nTim\nOn Aug 19, 2014, at 4:58 PM, Shane Emmons notifications@github.com wrote:\n\nPlease read the Contribution Guidelines, rebase and ping me. I'll merge.\n\u2014\nReply to this email directly or view it on GitHub.\n. Shane,\n\nI believe the only thing I missed was updating the CHANGELOG and AUTHORS files. Let me know if there was something else you wanted.\nTim\nOn Aug 19, 2014, at 4:58 PM, Shane Emmons notifications@github.com wrote:\n\nPlease read the Contribution Guidelines, rebase and ping me. I'll merge.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "jerhinesmith": "I forked, updated to rspec 2.99, added rspec-its, updated some specs to fix deprecation warnings, and am getting all tests to pass (using i18n 0.7.0.beta1).  I'll create a pull request, but this is my first time contributing (to anything, really), so please let me know if I screw it up.\n. I believe the main hurdle was that activesupport 4.2.0.beta1 relies on i18n >= 0.7.0.beta1.  6.2.1 of this gem also allows for 0.7.0.beta1, so the issue is technically resolved (though money-rails still needs to be updated to allow for money ~> 0.6.1).\n. Worth a shot. :smile: \n. So, rspec 3 is a much bigger deal largely due to the deprecation of \"should\" in favor of \"expect\".  I counted >500 lines using should.\n. Updated to use rspec 3 and fixed all deprecation warnings.\n. I forked, updated to rspec 2.99, added rspec-its, updated some specs to fix deprecation warnings, and am getting all tests to pass (using i18n 0.7.0.beta1).  I'll create a pull request, but this is my first time contributing (to anything, really), so please let me know if I screw it up.\n. I believe the main hurdle was that activesupport 4.2.0.beta1 relies on i18n >= 0.7.0.beta1.  6.2.1 of this gem also allows for 0.7.0.beta1, so the issue is technically resolved (though money-rails still needs to be updated to allow for money ~> 0.6.1).\n. Worth a shot. :smile: \n. So, rspec 3 is a much bigger deal largely due to the deprecation of \"should\" in favor of \"expect\".  I counted >500 lines using should.\n. Updated to use rspec 3 and fixed all deprecation warnings.\n. ",
    "shoshinsimba": "OK, just what I expected. Thanks, just wanted to make sure.\n. OK, just what I expected. Thanks, just wanted to make sure.\n. ",
    "ChandramouliGollapalli": "For this i am storing in DB as integer like 31234, in the screen i want to display like this $3.1234 using money gem... help me how to do this??\n. For this i am storing in DB as integer like 31234, in the screen i want to display like this $3.1234 using money gem... help me how to do this??\n. ",
    "eadz": "If you look at the spec, I believe this is fixing a bug? i.e. the spec fails without this. \nIs an increase in accuracy such a bad thing? can this be a breaking change for the next major release? \n. @semmons99 yes it's related, I'll put this PR on hold for now until I have time to demonstrate its usage fully.\n. If you look at the spec, I believe this is fixing a bug? i.e. the spec fails without this. \nIs an increase in accuracy such a bad thing? can this be a breaking change for the next major release? \n. @semmons99 yes it's related, I'll put this PR on hold for now until I have time to demonstrate its usage fully.\n. ",
    "ryanzhou": "@semmons99 Currency Pairs are used widely in the FX world (http://en.wikipedia.org/wiki/Currency_pair). It will be great if Money gem can handle foreign exchange by accepting a CurrencyPair object.\n. Before this commit, <=> was used for comparison. However, <=> and == in Arithmetic class are defined differently.\nThis gives us some subtle differences across versions (which may cause some specs to break).\nBefore:\nMoney.zero == Money.zero(:aud)\n=> true\nAfter:\nMoney.zero == Money.zero(:aud)\n=> false\n. @semmons99 Currency Pairs are used widely in the FX world (http://en.wikipedia.org/wiki/Currency_pair). It will be great if Money gem can handle foreign exchange by accepting a CurrencyPair object.\n. Before this commit, <=> was used for comparison. However, <=> and == in Arithmetic class are defined differently.\nThis gives us some subtle differences across versions (which may cause some specs to break).\nBefore:\nMoney.zero == Money.zero(:aud)\n=> true\nAfter:\nMoney.zero == Money.zero(:aud)\n=> false\n. ",
    "andyw8": "That's what I've done to fix it for myself. I'm highlighting the problem to hopefully prevent other people from running into the same issue.\nI can understand having a dev/beta dependency in the master branch, or in a preview release, but not as part of an official release.\n. That's what I've done to fix it for myself. I'm highlighting the problem to hopefully prevent other people from running into the same issue.\nI can understand having a dev/beta dependency in the master branch, or in a preview release, but not as part of an official release.\n. ",
    "tweymuth": "Thanks for your comments, and sorry for forgetting about the tests in the first place!\n. I added the tests for negative cash amounts.\nAs for the rounding method, we should not use the one #return_value does, as this would lead to wrong results. For example, with the rounding method BigDecimal::ROUND_DOWN, CHF 1.89 would be rounded down to CHF 1.85, while the correct result would be CHF 1.90.\n. Indeed, this was my intention. The sole purpose of this method is to round some arbitrary amount of money to the nearest possible value that is payable with hard cash. I think this is always done with the same rounding method, isn't it?\n. I just had a look at the Wikipedia article on Swedish rounding. It appears that in Argentina, prices are always rounded down. That means we indeed have to use different rounding methods for different currencies. However, I still think that for this very feature, the rounding method is coupled to the currency and therefore does not have to be set by the user. What do you think about this?\n. I found out that in New Zealand, shops can decide on their own if they want to round up or down to the nereast cash value. I guess that we have to make the rounding mode configurable for the user, then. For simplicity, I just take the rounding mode already defined in the Money class. I don't think that someone would want to use different rounding modes for rounding to the smallest available coinage and for rounding to the nearest payable amount.\n. If you change (or remove) the subunit, you also have to adapt the value of smallest_denomination. In this case, the smallest denomination is no longer 5000 sen, but 50 rupiah.\n. Thanks for your comments, and sorry for forgetting about the tests in the first place!\n. I added the tests for negative cash amounts.\nAs for the rounding method, we should not use the one #return_value does, as this would lead to wrong results. For example, with the rounding method BigDecimal::ROUND_DOWN, CHF 1.89 would be rounded down to CHF 1.85, while the correct result would be CHF 1.90.\n. Indeed, this was my intention. The sole purpose of this method is to round some arbitrary amount of money to the nearest possible value that is payable with hard cash. I think this is always done with the same rounding method, isn't it?\n. I just had a look at the Wikipedia article on Swedish rounding. It appears that in Argentina, prices are always rounded down. That means we indeed have to use different rounding methods for different currencies. However, I still think that for this very feature, the rounding method is coupled to the currency and therefore does not have to be set by the user. What do you think about this?\n. I found out that in New Zealand, shops can decide on their own if they want to round up or down to the nereast cash value. I guess that we have to make the rounding mode configurable for the user, then. For simplicity, I just take the rounding mode already defined in the Money class. I don't think that someone would want to use different rounding modes for rounding to the smallest available coinage and for rounding to the nearest payable amount.\n. If you change (or remove) the subunit, you also have to adapt the value of smallest_denomination. In this case, the smallest denomination is no longer 5000 sen, but 50 rupiah.\n. ",
    "remofritzsche": "Thank you guys for this feature. Is there any ETA for the next release?\n. Brilliant, thank you!\n. Thank you guys for this feature. Is there any ETA for the next release?\n. Brilliant, thank you!\n. ",
    "ugacode": "Hi Shane,\nsorry but I'm new to Gem development and was sure that I've followed to contribution guidelines correctly.\nMind telling me what is missing?\n. Done. Sorry about the misunderstanding.\n. Hi Gabriel and Shane,\nin answer to Gabriel's question - the Google Play API returns a price in micro-cents along with an ISO4217 currency code.\nI think the issue I've been experiencing comes from a difference between \"banking currencies\" and \"real-world currencies\", where some local currencies no longer use their subunit in day to day life they are still considered a valid value in banking and foreign exchange systems.\nFor example the following data I got from the Google Play API: \"price\"=>\"\uffe5162\", \"price_amount_micros\"=>162000000, \"currency_code\"=>\"JPY\".\nHowever, my understanding of the all-around usage of the RubyMoney project is quite limited so I'd appreciate some advice regarding the best way to handle this conflict of definitions.\n. Couldn't find any documentation or code that uses the \"currency_backwards_comptaible.json\" file aside from it being loaded by the loader.\nMind pointing me in the right direction?\nThanks!\n. Great, thank you very much.\n. Hi, I guess this goes back to a discussion I was having with @semmons99 on a different pull request regarding the difference between the way sub-units are referred to in digital financial systems as opposed to everyday transactions.\nFor example - this quote regarding KRW - \"The jeon is no longer used for everyday transactions, and appears only in foreign exchange rates\".\nThe issue I've had with sub-units that reduced from 100 to 1 was that cent to dollar conversion immediately becomes broken and it seems the standard for currency representation in digital systems is either cents or micro-cents. (My reference to this is mainly the Google Play Store APIs)\nPerhaps the best idea would be to add an extra sub-unit field to the currencies?\n. Hi Shane,\nsorry but I'm new to Gem development and was sure that I've followed to contribution guidelines correctly.\nMind telling me what is missing?\n. Done. Sorry about the misunderstanding.\n. Hi Gabriel and Shane,\nin answer to Gabriel's question - the Google Play API returns a price in micro-cents along with an ISO4217 currency code.\nI think the issue I've been experiencing comes from a difference between \"banking currencies\" and \"real-world currencies\", where some local currencies no longer use their subunit in day to day life they are still considered a valid value in banking and foreign exchange systems.\nFor example the following data I got from the Google Play API: \"price\"=>\"\uffe5162\", \"price_amount_micros\"=>162000000, \"currency_code\"=>\"JPY\".\nHowever, my understanding of the all-around usage of the RubyMoney project is quite limited so I'd appreciate some advice regarding the best way to handle this conflict of definitions.\n. Couldn't find any documentation or code that uses the \"currency_backwards_comptaible.json\" file aside from it being loaded by the loader.\nMind pointing me in the right direction?\nThanks!\n. Great, thank you very much.\n. Hi, I guess this goes back to a discussion I was having with @semmons99 on a different pull request regarding the difference between the way sub-units are referred to in digital financial systems as opposed to everyday transactions.\nFor example - this quote regarding KRW - \"The jeon is no longer used for everyday transactions, and appears only in foreign exchange rates\".\nThe issue I've had with sub-units that reduced from 100 to 1 was that cent to dollar conversion immediately becomes broken and it seems the standard for currency representation in digital systems is either cents or micro-cents. (My reference to this is mainly the Google Play Store APIs)\nPerhaps the best idea would be to add an extra sub-unit field to the currencies?\n. ",
    "jmchambers": "Yeah, unfortunately #max and #min are implemented in C code. Here's #max for instance:\n``` c\n/\n *  call-seq:\n *     enum.max                   -> obj\n *     enum.max { |a, b| block }  -> obj\n *     enum.max(n)                -> obj\n *     enum.max(n) {|a,b| block } -> obj\n *\n *  Returns the object in enum with the maximum value. The\n *  first form assumes all objects implement Comparable;\n *  the second uses the block to return a <=> b.\n *\n *     a = %w(albatross dog horse)\n *     a.max                                   #=> \"horse\"\n *     a.max { |a, b| a.length <=> b.length }  #=> \"albatross\"\n *\n *  If the +n+ argument is given, maximum +n+ elements are returned\n *  as an array.\n *\n *     a = %w[albatross dog horse]\n *     a.max(2)                                  #=> [\"dog\", \"horse\"]\n *     a.max(2) {|a, b| a.length <=> b.length }  #=> [\"horse\", \"albatross\"]\n /\nstatic VALUE\nenum_max(int argc, VALUE argv, VALUE obj)\n{\n    NODE memo = NEW_MEMO(Qundef, 0, 0);\n    VALUE result;\n    VALUE num;\nrb_scan_args(argc, argv, \"01\", &num);\n\nif (!NIL_P(num))\n   return nmin_run(obj, num, 0, 1);\n\nif (rb_block_given_p()) {\nrb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)memo);\n}\nelse {\nrb_block_call(obj, id_each, 0, 0, max_i, (VALUE)memo);\n}\nresult = memo->u1.value;\nif (result == Qundef) return Qnil;\nreturn result;\n\n}\n```\nfrom: https://github.com/ruby/ruby/blob/9b94249f39bff401465340639bed1f2a93b62ebf/enum.c\nI'm not familiar enough with Ruby's C code to really grasp what's going wrong. I do know this code is ultimately calling Money#<=> though, and that this method is working as expected.\nI agree it's no biggy, just to ensure the array is all Money objects before hand (that's how I'm working around it), it's just that this really caught me off guard because all the other comparison methods (>, ==, etc.) work fine with a mixture of Money objects and plain numbers. \nThe fact that #max and #min don't work as expected, definitely breaks the \"rule of least surprise\", which probably isn't a good thing when working with financial transactions!\n. Yeah, unfortunately #max and #min are implemented in C code. Here's #max for instance:\n``` c\n/\n *  call-seq:\n *     enum.max                   -> obj\n *     enum.max { |a, b| block }  -> obj\n *     enum.max(n)                -> obj\n *     enum.max(n) {|a,b| block } -> obj\n *\n *  Returns the object in enum with the maximum value. The\n *  first form assumes all objects implement Comparable;\n *  the second uses the block to return a <=> b.\n *\n *     a = %w(albatross dog horse)\n *     a.max                                   #=> \"horse\"\n *     a.max { |a, b| a.length <=> b.length }  #=> \"albatross\"\n *\n *  If the +n+ argument is given, maximum +n+ elements are returned\n *  as an array.\n *\n *     a = %w[albatross dog horse]\n *     a.max(2)                                  #=> [\"dog\", \"horse\"]\n *     a.max(2) {|a, b| a.length <=> b.length }  #=> [\"horse\", \"albatross\"]\n /\nstatic VALUE\nenum_max(int argc, VALUE argv, VALUE obj)\n{\n    NODE memo = NEW_MEMO(Qundef, 0, 0);\n    VALUE result;\n    VALUE num;\nrb_scan_args(argc, argv, \"01\", &num);\n\nif (!NIL_P(num))\n   return nmin_run(obj, num, 0, 1);\n\nif (rb_block_given_p()) {\nrb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)memo);\n}\nelse {\nrb_block_call(obj, id_each, 0, 0, max_i, (VALUE)memo);\n}\nresult = memo->u1.value;\nif (result == Qundef) return Qnil;\nreturn result;\n\n}\n```\nfrom: https://github.com/ruby/ruby/blob/9b94249f39bff401465340639bed1f2a93b62ebf/enum.c\nI'm not familiar enough with Ruby's C code to really grasp what's going wrong. I do know this code is ultimately calling Money#<=> though, and that this method is working as expected.\nI agree it's no biggy, just to ensure the array is all Money objects before hand (that's how I'm working around it), it's just that this really caught me off guard because all the other comparison methods (>, ==, etc.) work fine with a mixture of Money objects and plain numbers. \nThe fact that #max and #min don't work as expected, definitely breaks the \"rule of least surprise\", which probably isn't a good thing when working with financial transactions!\n. ",
    "edwinv": "Ok! One last thing we need to consider, is how we find the disambiguate symbol for a currency. Two options:\n1. We include an alternative_symbol in the data JSON files for each currency, which should be used when disambiguate=true. When no alternative symbol is provided for the currency, a fallback to the default symbol is used.\n2. We use the already present alternate_symbols array and pick the first alternative symbol from this array. This will work for most ambiguate currencies, for some we need to add the right symbol to the front of the array. The NOK currency for example, would probably used \"NOK\" as an alternative symbol, but ,- is provided in the JSON: https://github.com/RubyMoney/money/blob/master/config/currency_iso.json#L1550\nSo, the main question is if we are willing to maintain an extra field in the JSON of exploit the already present alternate_symbols with some minor additions?\n. Fix was made and merged with PR https://github.com/RubyMoney/money/pull/438\n. Commits are squashed, AUTHORS and CHANGELOG are updated.\n. Ok! One last thing we need to consider, is how we find the disambiguate symbol for a currency. Two options:\n1. We include an alternative_symbol in the data JSON files for each currency, which should be used when disambiguate=true. When no alternative symbol is provided for the currency, a fallback to the default symbol is used.\n2. We use the already present alternate_symbols array and pick the first alternative symbol from this array. This will work for most ambiguate currencies, for some we need to add the right symbol to the front of the array. The NOK currency for example, would probably used \"NOK\" as an alternative symbol, but ,- is provided in the JSON: https://github.com/RubyMoney/money/blob/master/config/currency_iso.json#L1550\nSo, the main question is if we are willing to maintain an extra field in the JSON of exploit the already present alternate_symbols with some minor additions?\n. Fix was made and merged with PR https://github.com/RubyMoney/money/pull/438\n. Commits are squashed, AUTHORS and CHANGELOG are updated.\n. ",
    "Vorob-Astronaut": "Thnx)\n. Thnx)\n. ",
    "BRMatt": "Thanks for the quick merge :heart: \n. Thanks for the quick merge :heart: \n. ",
    "ggilder": ":+1: to this! I've encountered the same issue and had to work around it by using Rails number_to_currency, but then you have to override the symbol if it's not the default currency for the locale.\n. I'll try to put together a PR for this in the next week or two.\n. According to Wikipedia: \"The sen and the rin were eventually taken out of circulation at the end of 1953.\"\nCan you describe what you're seeing in the Google Play API? I'm a little worried that other systems might have the opposite assumption...\n. Speaking as someone who doesn't use the currency conversion functions of this gem, I can't see how any of the suggested behaviors (including the existing behavior) are predictable given assumptions about how #<=> works. Perhaps the best thing would be to simply not allow comparisons between different currencies?\n. Thank you!\n. This note from Wikipedia is a little worrying:\n\nIn August 2014, Microsoft issued updates for all of its mainstream versions of Microsoft Windows that enabled support for the new ruble sign, but the updates were later found to have bugs that result in system crashes.\n\nI wonder how widespread support for the new symbol is...\n. Looks good to me, not sure on the spelling of \"kopeck/kopek\" but either is probably fine. Users who need to support old Windows systems can always use the alternate symbol, so this should be safe. \nYou might squash these commits into one since they are all related. And don't forget to update the CHANGELOG and AUTHORS files so you are credited!\n. Travis seems to be having unrelated problems on rbx, ugh :(\n. Hmm, looks like it's a little off. You can try these steps to fix it:\n```\nCheck if you have an \"upstream\" remote\ngit remote -v | grep upstream\nIf nothing showed up, then run:\ngit remote add upstream https://github.com/RubyMoney/money.git\nNow update the remote\ngit fetch upstream\nAnd rebase your branch off it\ngit rebase -i upstream/master\nIn the editor that appears, delete the lines for any commits that aren't yours.\nComplete the rebase and force push your branch up again.\n``\n. @newstler yeah git rebase can seem like magic sometimes. :wink: The [git book](http://git-scm.com/book/en/v2/Git-Branching-Rebasing) has a pretty exhaustive guide if you're interested in more details.\n. I wonder if the previous values could be represented as historical currencies incurrency_backwards_compatible.json` ? I'm not sure what the conventions are for adding currencies there, naming, etc.\n. Yeah, I've ended up overriding these values in a wrapper for my applications. :(\nNot sure what the best long-term solution for this is, but it could at least be easier to incorporate custom overrides. I'll try to put together a PR for that next week.\n. By the way, just wanted to say a big thank you to everyone who's contributed to this project! The gem is awesome and made my work much easier: http://www.reuters.com/article/2014/11/20/us-square-payments-global-idUSKCN0J423720141120\n. Closed in favor of https://github.com/RubyMoney/money/pull/467\n. :+1: \n. :+1: :ox: :hankey: \n. LGTM!\n. :+1: \n. :+1: \n. Would be good to add a test to cover rounding mode.\n. LGTM!\n. Sorry about that, I thought about mentioning but wasn't sure if minor refactors warranted changelog entries.\n. LGTM; please add yourself to AUTHORS if you're not there already and add an entry to CHANGELOG.\n. :+1: to this! I've encountered the same issue and had to work around it by using Rails number_to_currency, but then you have to override the symbol if it's not the default currency for the locale.\n. I'll try to put together a PR for this in the next week or two.\n. According to Wikipedia: \"The sen and the rin were eventually taken out of circulation at the end of 1953.\"\nCan you describe what you're seeing in the Google Play API? I'm a little worried that other systems might have the opposite assumption...\n. Speaking as someone who doesn't use the currency conversion functions of this gem, I can't see how any of the suggested behaviors (including the existing behavior) are predictable given assumptions about how #<=> works. Perhaps the best thing would be to simply not allow comparisons between different currencies?\n. Thank you!\n. This note from Wikipedia is a little worrying:\n\nIn August 2014, Microsoft issued updates for all of its mainstream versions of Microsoft Windows that enabled support for the new ruble sign, but the updates were later found to have bugs that result in system crashes.\n\nI wonder how widespread support for the new symbol is...\n. Looks good to me, not sure on the spelling of \"kopeck/kopek\" but either is probably fine. Users who need to support old Windows systems can always use the alternate symbol, so this should be safe. \nYou might squash these commits into one since they are all related. And don't forget to update the CHANGELOG and AUTHORS files so you are credited!\n. Travis seems to be having unrelated problems on rbx, ugh :(\n. Hmm, looks like it's a little off. You can try these steps to fix it:\n```\nCheck if you have an \"upstream\" remote\ngit remote -v | grep upstream\nIf nothing showed up, then run:\ngit remote add upstream https://github.com/RubyMoney/money.git\nNow update the remote\ngit fetch upstream\nAnd rebase your branch off it\ngit rebase -i upstream/master\nIn the editor that appears, delete the lines for any commits that aren't yours.\nComplete the rebase and force push your branch up again.\n``\n. @newstler yeah git rebase can seem like magic sometimes. :wink: The [git book](http://git-scm.com/book/en/v2/Git-Branching-Rebasing) has a pretty exhaustive guide if you're interested in more details.\n. I wonder if the previous values could be represented as historical currencies incurrency_backwards_compatible.json` ? I'm not sure what the conventions are for adding currencies there, naming, etc.\n. Yeah, I've ended up overriding these values in a wrapper for my applications. :(\nNot sure what the best long-term solution for this is, but it could at least be easier to incorporate custom overrides. I'll try to put together a PR for that next week.\n. By the way, just wanted to say a big thank you to everyone who's contributed to this project! The gem is awesome and made my work much easier: http://www.reuters.com/article/2014/11/20/us-square-payments-global-idUSKCN0J423720141120\n. Closed in favor of https://github.com/RubyMoney/money/pull/467\n. :+1: \n. :+1: :ox: :hankey: \n. LGTM!\n. :+1: \n. :+1: \n. Would be good to add a test to cover rounding mode.\n. LGTM!\n. Sorry about that, I thought about mentioning but wasn't sure if minor refactors warranted changelog entries.\n. LGTM; please add yourself to AUTHORS if you're not there already and add an entry to CHANGELOG.\n. ",
    "mateusg": ":+1:\nI used symbol_before_without_space: false, but I don't think it looks very understanding and I don't want to worry about this everytime Money#format is called. I'll see if I can submit a PR this week. ;)\n. Considering this gem has a module for formatting currency, I think providing a way to set default rules for everytime Money#format is called is a pretty straightforward answer to this issue.\nIf PR #453 is accepted, this is how it would be solved:\n```\nMoney.default_formatting_rules = { symbol_before_without_space: false }\nMoney.new(0).format\n=> \"$ 0.00\"\n```\nI still think symbol_before_without_space could be renamed to space_after_symbol, space_before_number or something more \"afirmative\".\n. @bradfeehan default_formatting_rules was just a workaround for the problem of always having to send formatting options to Money#format (code duplication). You set it only once, and it is considered by default for every Money#format call. As you can imagine, my situation was simpler, I didn't have many currency formats.\nI still believe the format should be fetched from I18n if Money.use_i18n is true. At the time I came across this issue, I reviewed the code and realised making such change would be way harder/dangerous because of how the formatting rules are coupled.\nhttps://github.com/RubyMoney/money/blob/b04d8a7e881e0c51ed9d8af0f3b3351595cbc625/lib/money/money/formatting.rb\nI'll try to refactor this method maybe next week and see if I can introduce the format from I18n without breaking anything. Meanwhile, I think you should implement your own helper to handle this.\n. :+1:\nI used symbol_before_without_space: false, but I don't think it looks very understanding and I don't want to worry about this everytime Money#format is called. I'll see if I can submit a PR this week. ;)\n. Considering this gem has a module for formatting currency, I think providing a way to set default rules for everytime Money#format is called is a pretty straightforward answer to this issue.\nIf PR #453 is accepted, this is how it would be solved:\n```\nMoney.default_formatting_rules = { symbol_before_without_space: false }\nMoney.new(0).format\n=> \"$ 0.00\"\n```\nI still think symbol_before_without_space could be renamed to space_after_symbol, space_before_number or something more \"afirmative\".\n. @bradfeehan default_formatting_rules was just a workaround for the problem of always having to send formatting options to Money#format (code duplication). You set it only once, and it is considered by default for every Money#format call. As you can imagine, my situation was simpler, I didn't have many currency formats.\nI still believe the format should be fetched from I18n if Money.use_i18n is true. At the time I came across this issue, I reviewed the code and realised making such change would be way harder/dangerous because of how the formatting rules are coupled.\nhttps://github.com/RubyMoney/money/blob/b04d8a7e881e0c51ed9d8af0f3b3351595cbc625/lib/money/money/formatting.rb\nI'll try to refactor this method maybe next week and see if I can introduce the format from I18n without breaking anything. Meanwhile, I think you should implement your own helper to handle this.\n. ",
    "bradfeehan": "@mateusg: How does the default_formatting_rules option help you in this situation? I'm finding myself in the same situation as your initial message in this thread but don't see how you fixed it.\nFor example, if you have 10 currencies that need to be shown in 20 locales, the default_formatting_rules should change depending on the locale, right? Like USD in en_US the currency symbol is before the amount. But USD in en_FR should have the currency symbol after the amount. Not sure how to achieve this.\n. That makes a lot of sense! It'd be great if the number formatting would be done external to Money, maybe https://github.com/twitter/twitter-cldr-rb could help?\n. I have a use for this, it'd be great to see it merged. Otherwise, is there a way to show \"US$\" for USD only when the locale isn't en or en_US? It doesn't have a disambiguation column.\n. @mateusg: How does the default_formatting_rules option help you in this situation? I'm finding myself in the same situation as your initial message in this thread but don't see how you fixed it.\nFor example, if you have 10 currencies that need to be shown in 20 locales, the default_formatting_rules should change depending on the locale, right? Like USD in en_US the currency symbol is before the amount. But USD in en_FR should have the currency symbol after the amount. Not sure how to achieve this.\n. That makes a lot of sense! It'd be great if the number formatting would be done external to Money, maybe https://github.com/twitter/twitter-cldr-rb could help?\n. I have a use for this, it'd be great to see it merged. Otherwise, is there a way to show \"US$\" for USD only when the locale isn't en or en_US? It doesn't have a disambiguation column.\n. ",
    "Senjai": "Cheers, I'll do that\n. Cheers, I'll do that\n. ",
    "newstler": "Hahhh, system crashes, of course, Windows ))\nAs I get it right the new ruble sign is in Unicode since version 7.0. And here the main designer of this symbol collects the examples of usage from the real world.\nOk, I'll try to fix the errors soon and let you know, thanks!\n. Updated, seems now tests are passing.\nHad a chance to see the previous version on Windows Chrome and there was blank square instead of \u20bd, but no system crushes :) Hadn't chance to see this version on Windows yet, but according to this msdn blog it might work. No official support of XP, though.\n. Hm, I think I squashed, but not sure if everything's ok because to be honest I've done it for the first time )\n. Ok, I did and and all seems fine now, thank you. But in short, what did I do? :)\n. Hahhh, system crashes, of course, Windows ))\nAs I get it right the new ruble sign is in Unicode since version 7.0. And here the main designer of this symbol collects the examples of usage from the real world.\nOk, I'll try to fix the errors soon and let you know, thanks!\n. Updated, seems now tests are passing.\nHad a chance to see the previous version on Windows Chrome and there was blank square instead of \u20bd, but no system crushes :) Hadn't chance to see this version on Windows yet, but according to this msdn blog it might work. No official support of XP, though.\n. Hm, I think I squashed, but not sure if everything's ok because to be honest I've done it for the first time )\n. Ok, I did and and all seems fine now, thank you. But in short, what did I do? :)\n. ",
    "vandrijevik": "Thank you for the quick merge! :smile: \n. Thank you for the quick merge! :smile: \n. ",
    "unloved": "pull request\n. Well, any instance of Money class has bank, we can pass it as argument. I just don't get why creating new instances with default bank instead of the old one after operations\nmoney_value = Money.new(1000, :usd, MyBank.instance)\nmoney_value.bank => MyBank_instance\nnew_money_value = money_value * 3\nnew_money.bank => Money::Bank::VariableExchange_instance\nI have several arithmetic operations over the money object before it's shown to user, and finally when all operations are done, I can't show it in proper currency, because the bank I passed as argument is throwen away and currency_rates lost\n. pull request\n. Well, any instance of Money class has bank, we can pass it as argument. I just don't get why creating new instances with default bank instead of the old one after operations\nmoney_value = Money.new(1000, :usd, MyBank.instance)\nmoney_value.bank => MyBank_instance\nnew_money_value = money_value * 3\nnew_money.bank => Money::Bank::VariableExchange_instance\nI have several arithmetic operations over the money object before it's shown to user, and finally when all operations are done, I can't show it in proper currency, because the bank I passed as argument is throwen away and currency_rates lost\n. ",
    "ollym": "Could someone push a new gem version with this update? Having trouble using this with 4.2\n. @semmons99 thanks!\n. @printercu any news? would be good to merge and release this soon. Could someone push a new gem version with this update? Having trouble using this with 4.2\n. @semmons99 thanks!\n. @printercu any news? would be good to merge and release this soon. ",
    "jimpo": "Why was https://github.com/RubyMoney/money/commit/ae293095cd461e3396523016f0c6a5bf937f7339 not accepted? Seems much better to return nil than raise an error. The Ruby warning even says that <=> can return nil if the comparison is invalid.\n. Given that https://github.com/RubyMoney/money/pull/470 changed the behavior of ==, as @zhoutong noted, can we revert to using Comparable#== and rename Arithmetic#== to Arithmetic#eql? (which it is currently aliased to)? I'll submit a PR for this.\n. Interesting. Is that in the test suite for this gem or another application? Could you show the line in your application that caused it?\n. It issues the warning in Ruby 2.2.1, not Ruby 2.2.2. The issue is that Money#<=> is throwing a Money::Bank::UnknownRate error when comparing two non-zero amounts with different currencies in the test suite.\nI guess we need to decide what the behavior of Money#== should be in this case. money1.eql?(money2) is false because the currencies are not the same, but if an exchange rate is defined and the converted amounts are equal, money1 <=> money2 == 0. money1 == money2 could either always be false if the currencies are different and the amounts are nonzero, or it could possibly raise a Money::Bank::UnknownRate error. Thoughts?\n. Continuing discussion here.\n. Nope, I think it's settled.\n. Why was https://github.com/RubyMoney/money/commit/ae293095cd461e3396523016f0c6a5bf937f7339 not accepted? Seems much better to return nil than raise an error. The Ruby warning even says that <=> can return nil if the comparison is invalid.\n. Given that https://github.com/RubyMoney/money/pull/470 changed the behavior of ==, as @zhoutong noted, can we revert to using Comparable#== and rename Arithmetic#== to Arithmetic#eql? (which it is currently aliased to)? I'll submit a PR for this.\n. Interesting. Is that in the test suite for this gem or another application? Could you show the line in your application that caused it?\n. It issues the warning in Ruby 2.2.1, not Ruby 2.2.2. The issue is that Money#<=> is throwing a Money::Bank::UnknownRate error when comparing two non-zero amounts with different currencies in the test suite.\nI guess we need to decide what the behavior of Money#== should be in this case. money1.eql?(money2) is false because the currencies are not the same, but if an exchange rate is defined and the converted amounts are equal, money1 <=> money2 == 0. money1 == money2 could either always be false if the currencies are different and the amounts are nonzero, or it could possibly raise a Money::Bank::UnknownRate error. Thoughts?\n. Continuing discussion here.\n. Nope, I think it's settled.\n. ",
    "olliebennett": "For reference, this is a dupe of #469, and yep, fixed on master.\n. For reference, this is a dupe of #469, and yep, fixed on master.\n. ",
    "georgemillo": "I'll dive into it when I get a chance but it won't be for a while.\nIf you don't hear anything within a few weeks drop another comment on this thread to remind me.\n. Fixed the Currency#all problem in #491.\nFor the others, I don't think a MissingAttributeError message is the right solution. When is anyone ever going to deliberately define a currency with no subunit_to_unit, for example? (Looking in currency_iso.json, I see that there are only two \"real-world\" currencies (the Mauritanian Ouguiya and the Malagasy Ariary) that have a subunit_to_unit value that isn't either 1 or 100).\nIt makes more sense to me if we make subunit_to_unit compulsory, although this would be a breaking change and require a major version number bump. And it's not exactly a big issue, so it's probably worth waiting until we have a bunch more breaking changes that we want to push, and putting them all in the same major version upgrade.\n. Done\n. Come to think of it, any chance we can get CC integrated with GH pull requests? http://docs.codeclimate.com/article/213-github-pull-request-integration\n. I'll dive into it when I get a chance but it won't be for a while.\nIf you don't hear anything within a few weeks drop another comment on this thread to remind me.\n. Fixed the Currency#all problem in #491.\nFor the others, I don't think a MissingAttributeError message is the right solution. When is anyone ever going to deliberately define a currency with no subunit_to_unit, for example? (Looking in currency_iso.json, I see that there are only two \"real-world\" currencies (the Mauritanian Ouguiya and the Malagasy Ariary) that have a subunit_to_unit value that isn't either 1 or 100).\nIt makes more sense to me if we make subunit_to_unit compulsory, although this would be a breaking change and require a major version number bump. And it's not exactly a big issue, so it's probably worth waiting until we have a bunch more breaking changes that we want to push, and putting them all in the same major version upgrade.\n. Done\n. Come to think of it, any chance we can get CC integrated with GH pull requests? http://docs.codeclimate.com/article/213-github-pull-request-integration\n. ",
    "jasonahooper": "Not sure about money exchanges practices. Where can I check or find out more? We have users in Iceland who have complained that we are showing minor units. They do not use them as per the link. The updated ISO data at http://www.currency-iso.org/dam/downloads/table_a1.xml reflects this.\n. Commit amended to include changelog update.\n. Should be fixed now.\n. Sorry if it was me. :-)\n-----Original Message-----\nFrom: Ismael Celis notifications@github.com\nTo: RubyMoney/money money@noreply.github.com\nSent: Thu, 21 May 2015 19:30\nSubject: Re: [money] Decouple exchange rates storage from VariableExchange bank (#516)\nYeah someone beat me to the merge:)\nI'll do it in a few hours.\nIsmael Celis\n\nOn 21 May 2015, at 19:06, Shane Emmons notifications@github.com wrote:\nneed a rebase before I can merge\n\u2014\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/516#issuecomment-104379478\n. Not sure about money exchanges practices. Where can I check or find out more? We have users in Iceland who have complained that we are showing minor units. They do not use them as per the link. The updated ISO data at http://www.currency-iso.org/dam/downloads/table_a1.xml reflects this.\n. Commit amended to include changelog update.\n. Should be fixed now.\n. Sorry if it was me. :-)\n-----Original Message-----\nFrom: Ismael Celis notifications@github.com\nTo: RubyMoney/money money@noreply.github.com\nSent: Thu, 21 May 2015 19:30\nSubject: Re: [money] Decouple exchange rates storage from VariableExchange bank (#516)\nYeah someone beat me to the merge:)\nI'll do it in a few hours.\nIsmael Celis\n\nOn 21 May 2015, at 19:06, Shane Emmons notifications@github.com wrote:\nneed a rebase before I can merge\n\u2014\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/pull/516#issuecomment-104379478\n. ",
    "abatko": "https://github.com/RubyMoney/money/pull/485\n. How embarrassing - I totally forgot about that! Sorry!\n. Oops.\n. https://github.com/RubyMoney/money/pull/485\n. How embarrassing - I totally forgot about that! Sorry!\n. Oops.\n. ",
    "jkingdon": "cc @ggilder \n. cc @ggilder \n. ",
    "seongreen": "Hi. could You up version to 6.5.1. Now exist old version 6.5 with old format and new with my fixes.\n. Gem Money should work with minimal unit and only with integer (BigDec) (no string float and other) to avoid collision and wrong work because people use this gem in real 'money' project. \nAlso old version < '5.0.0'  has not oblivious syntax.\n'100'.to_money     => return 100$\n Money.new(100)  => return 1$\n- 100 it's not correct. Some currency has not integer or not 2 exponent\nAll extensions of native classes with \"to_money\" and other methods moved to Monetize gem. \n. Well, I have no experience with Mongo and Money type, but a really recommend you to save amount information like integer(BigDec) in minimal units. And convert it in some money object of necessity (for view in format for ex.) but not for calculation and conversion.\n. All core extension moved to Monetize gem\n. You can use some old version were this feature worked. Or use Monetize.\n. Well, I recommend to use http://www.currency-iso.org/en/shared/amendments/iso-4217-amendment.html instead of wiki. It's site of maintainer ISO :)\n. What the hell ? :) I don't understand a conflict place. \n. @antstorm I found a reason of conflict. After a I get fresh master and started merge, I found this currency in master. Someone added 'BYN' at 24 of december already.\n. Hi, You can make pull request with modifying file of config/currency_iso.json and with set up correct rule in \"lkr\": { section. Hi. could You up version to 6.5.1. Now exist old version 6.5 with old format and new with my fixes.\n. Gem Money should work with minimal unit and only with integer (BigDec) (no string float and other) to avoid collision and wrong work because people use this gem in real 'money' project. \nAlso old version < '5.0.0'  has not oblivious syntax.\n'100'.to_money     => return 100$\n Money.new(100)  => return 1$\n- 100 it's not correct. Some currency has not integer or not 2 exponent\nAll extensions of native classes with \"to_money\" and other methods moved to Monetize gem. \n. Well, I have no experience with Mongo and Money type, but a really recommend you to save amount information like integer(BigDec) in minimal units. And convert it in some money object of necessity (for view in format for ex.) but not for calculation and conversion.\n. All core extension moved to Monetize gem\n. You can use some old version were this feature worked. Or use Monetize.\n. Well, I recommend to use http://www.currency-iso.org/en/shared/amendments/iso-4217-amendment.html instead of wiki. It's site of maintainer ISO :)\n. What the hell ? :) I don't understand a conflict place. \n. @antstorm I found a reason of conflict. After a I get fresh master and started merge, I found this currency in master. Someone added 'BYN' at 24 of december already.\n. Hi, You can make pull request with modifying file of config/currency_iso.json and with set up correct rule in \"lkr\": { section. ",
    "runa": "I can, but I don't really want to add a new gem; for a 3 line function.\nI still think that this should go in Money; the current initializer is\nmisleading and error prone...\nOn Wed, Feb 4, 2015 at 2:12 PM, Shane Emmons notifications@github.com\nwrote:\n\nWhy can't you use the Monetize gem which is intended for this purpose?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/RubyMoney/money/issues/493#issuecomment-72895584.\n. Please @semmons99  accept my apologies, I never wanted to offend nor you or your work.\n\nWe use Money a lot, trusting it since years ago and I've only understood its depth when I started \ndebugging this problem with a currency that had subunits_to_units <> 100.\nMy issue was a minor thing, trying to improve the quality of the gem; I wanted to be constructive, seems I missed completely. So, please accept my apologies and stop reading now and keep the ticket closed if you want ;)\n\nWith the \"3 line function\" I meant the function Monetize.from_fixnum:\nruby\n  def self.from_fixnum(value, currency = Money.default_currency)\n    currency = Money::Currency.wrap(currency)\n    value = value * currency.subunit_to_unit\n    Money.new(value, currency)\n  end\nI find that without this functionality the gem is error prone (from the docs, you get that you need to multiply your amount * 100)\n``` ruby\nrequire 'money'\n10.00 USD\nmoney = Money.new(1000, \"USD\")\n```\nIf you wanted to rewrite the main example for a random currency you should write as:\n``` ruby\nrequire 'money'\namount = 100\ncurrency = :CLP\nmoney = Money.new(amount * Currency.new(currency).subunit_to_unit, currency)\n``\nWhich IMHO is not too straightforward.\nI think that a new Money.from_amount(amount, currency) should be added, with this functionality.\nAnyway, please accept my apologies and feel free to keep the ticket closed.\nThanks\n```\n. ok\nand again, thanks for your hard work.\nOn Thu, Feb 5, 2015 at 2:08 PM, Shane Emmons notifications@github.com\nwrote:\n\nSorry. These projects can really take it out of you. Monetize exists for\nthis purpose and I don\u2019t see us pulling the functionality back into Money\nitself. Monetize is an extraction from Money, so you wouldn\u2019t be adding\nanymore code then was in your project pre-6.0.0\nOn Thu, Feb 5, 2015 at 8:56 AM, seongreen notifications@github.com\nwrote:\n\nGem Money should work with minimal unit and only with integer (BigDec)\n(no string float and other) to avoid collision and wrong work because\npeople use this gem in real 'money' project.\nAlso old version < '5.0.0' has not oblivious syntax.\n'100'.to_money => return 100$\nMoney.new(100) => return 1$\nAll extensions of native classes with \"to_money\" and other methods moved\nto Monetize gem.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/493#issuecomment-73049324\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/RubyMoney/money/issues/493#issuecomment-73084772.\n. I can, but I don't really want to add a new gem; for a 3 line function.\n\nI still think that this should go in Money; the current initializer is\nmisleading and error prone...\nOn Wed, Feb 4, 2015 at 2:12 PM, Shane Emmons notifications@github.com\nwrote:\n\nWhy can't you use the Monetize gem which is intended for this purpose?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/RubyMoney/money/issues/493#issuecomment-72895584.\n. Please @semmons99  accept my apologies, I never wanted to offend nor you or your work.\n\nWe use Money a lot, trusting it since years ago and I've only understood its depth when I started \ndebugging this problem with a currency that had subunits_to_units <> 100.\nMy issue was a minor thing, trying to improve the quality of the gem; I wanted to be constructive, seems I missed completely. So, please accept my apologies and stop reading now and keep the ticket closed if you want ;)\n\nWith the \"3 line function\" I meant the function Monetize.from_fixnum:\nruby\n  def self.from_fixnum(value, currency = Money.default_currency)\n    currency = Money::Currency.wrap(currency)\n    value = value * currency.subunit_to_unit\n    Money.new(value, currency)\n  end\nI find that without this functionality the gem is error prone (from the docs, you get that you need to multiply your amount * 100)\n``` ruby\nrequire 'money'\n10.00 USD\nmoney = Money.new(1000, \"USD\")\n```\nIf you wanted to rewrite the main example for a random currency you should write as:\n``` ruby\nrequire 'money'\namount = 100\ncurrency = :CLP\nmoney = Money.new(amount * Currency.new(currency).subunit_to_unit, currency)\n``\nWhich IMHO is not too straightforward.\nI think that a new Money.from_amount(amount, currency) should be added, with this functionality.\nAnyway, please accept my apologies and feel free to keep the ticket closed.\nThanks\n```\n. ok\nand again, thanks for your hard work.\nOn Thu, Feb 5, 2015 at 2:08 PM, Shane Emmons notifications@github.com\nwrote:\n\nSorry. These projects can really take it out of you. Monetize exists for\nthis purpose and I don\u2019t see us pulling the functionality back into Money\nitself. Monetize is an extraction from Money, so you wouldn\u2019t be adding\nanymore code then was in your project pre-6.0.0\nOn Thu, Feb 5, 2015 at 8:56 AM, seongreen notifications@github.com\nwrote:\n\nGem Money should work with minimal unit and only with integer (BigDec)\n(no string float and other) to avoid collision and wrong work because\npeople use this gem in real 'money' project.\nAlso old version < '5.0.0' has not oblivious syntax.\n'100'.to_money => return 100$\nMoney.new(100) => return 1$\nAll extensions of native classes with \"to_money\" and other methods moved\nto Monetize gem.\nReply to this email directly or view it on GitHub:\nhttps://github.com/RubyMoney/money/issues/493#issuecomment-73049324\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/RubyMoney/money/issues/493#issuecomment-73084772.\n. \n",
    "epidemian": "I added an extra commit to use the updated Money#inspect output on the VariableExchange docs, which i think is clearer because it includes the currency ISO name :)\n. Swift!\nI feared this change would be controversial. Thanks for the invite!\n. :+1:\nWe've had an override for Money's CLF definition in our application for quite some time in order to have a reasonable amount of decimals. Good to see the standard updated :smiley_cat: \n. According to the changelog, that method didn't exist on version 6.5.0. It was added on 6.6.0.\n. This seems like a simple and useful addition :+1: . @sime do you want to take this feature and submit a PR?\n. Hmm. I think i prefer the current behaviour of Money instances not being directly comparable with Numeric values. Although some_money > 0 seems reasonable to define, i think it's not very intuitive for Money instances to be comparable to some numeric values but not others.\nThe case when comparing with a literal 0 seems obvious, but if instead we were comparing against some other expression like make_discount if order_price >= min_order_price_to_make_discount i would like for that comparison to always raise an exception if min_order_price_to_make_discount has a bug and returns a number instead of a Money, not to silently pass because, for some reason, most of the time it returns 0.\nMoney already provides methods like zero?, nonzero?, positive? and negative?, which i think are clearer and more intuitive than asking a money instance how it compares against a bare number 0 :stuck_out_tongue: \n. The <=> operator defined here makes ==, < and friends have some weird algebraic properties.\nFor example, == is not transitive:\nruby\na, b, c = Money.new(10, :USD), 10, Money.new(10, :CAD)\na == b # => true\nc == b # => true\na == c # => false\nAnd inequalities are weird:\nruby\nMoney.add_rate(:USD, :ARS, 13.93)\nMoney.add_rate(:ARS, :USD, 0.072)\na, b, c = Money.new(10, :USD), 15, Money.new(20, :ARS)\na < b # => true\nc > b # => true, though b < c raises a TypeError\na < c # => false\n(The root of this behaviour is that the currency used for the Numeric value depends on the Money value it is being compared to. 15 means two different things when comparing against dollars than against ARS.)\nI don't know if these properties are important in everyday coding, but i think the change proposed here makes the == and inequality operators more complex and harder to explain/reason about than they need to be.\nDoes comparing Moneys to Numerics make the library more approachable or easier to use? Or is it something cool to add, just Because We Can\u2122? Does anyone find it so unintuitive for a_money < a_number to raise an error and having to explicitly convert the RHS to a money (therefore having to choose what currency to use for it)?\n. @antstorm True. Maybe just add the classic The MIT License (MIT) on the top of the LICENSE file would be worth it?\n. > @epidemian btw, next time you open a PR, try doing that from your own fork & branch ;)\nAbsolutely! :sweat_smile: I made the change from GitHub's web interface, and i thought it was going to create a branch on my fork for the PR (which i think is what happens when you don't have commit permissions to a repo).\n. I added an extra commit to use the updated Money#inspect output on the VariableExchange docs, which i think is clearer because it includes the currency ISO name :)\n. Swift!\nI feared this change would be controversial. Thanks for the invite!\n. :+1:\nWe've had an override for Money's CLF definition in our application for quite some time in order to have a reasonable amount of decimals. Good to see the standard updated :smiley_cat: \n. According to the changelog, that method didn't exist on version 6.5.0. It was added on 6.6.0.\n. This seems like a simple and useful addition :+1: . @sime do you want to take this feature and submit a PR?\n. Hmm. I think i prefer the current behaviour of Money instances not being directly comparable with Numeric values. Although some_money > 0 seems reasonable to define, i think it's not very intuitive for Money instances to be comparable to some numeric values but not others.\nThe case when comparing with a literal 0 seems obvious, but if instead we were comparing against some other expression like make_discount if order_price >= min_order_price_to_make_discount i would like for that comparison to always raise an exception if min_order_price_to_make_discount has a bug and returns a number instead of a Money, not to silently pass because, for some reason, most of the time it returns 0.\nMoney already provides methods like zero?, nonzero?, positive? and negative?, which i think are clearer and more intuitive than asking a money instance how it compares against a bare number 0 :stuck_out_tongue: \n. The <=> operator defined here makes ==, < and friends have some weird algebraic properties.\nFor example, == is not transitive:\nruby\na, b, c = Money.new(10, :USD), 10, Money.new(10, :CAD)\na == b # => true\nc == b # => true\na == c # => false\nAnd inequalities are weird:\nruby\nMoney.add_rate(:USD, :ARS, 13.93)\nMoney.add_rate(:ARS, :USD, 0.072)\na, b, c = Money.new(10, :USD), 15, Money.new(20, :ARS)\na < b # => true\nc > b # => true, though b < c raises a TypeError\na < c # => false\n(The root of this behaviour is that the currency used for the Numeric value depends on the Money value it is being compared to. 15 means two different things when comparing against dollars than against ARS.)\nI don't know if these properties are important in everyday coding, but i think the change proposed here makes the == and inequality operators more complex and harder to explain/reason about than they need to be.\nDoes comparing Moneys to Numerics make the library more approachable or easier to use? Or is it something cool to add, just Because We Can\u2122? Does anyone find it so unintuitive for a_money < a_number to raise an error and having to explicitly convert the RHS to a money (therefore having to choose what currency to use for it)?\n. @antstorm True. Maybe just add the classic The MIT License (MIT) on the top of the LICENSE file would be worth it?\n. > @epidemian btw, next time you open a PR, try doing that from your own fork & branch ;)\nAbsolutely! :sweat_smile: I made the change from GitHub's web interface, and i thought it was going to create a branch on my fork for the PR (which i think is what happens when you don't have commit permissions to a repo).\n. ",
    "netwire88": "Yeah. I've tried Stackoverflow and no answers either. \n\nOn Feb 12, 2015, at 12:48 PM, Shane Emmons notifications@github.com wrote:\nClosed #497.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah. I've tried Stackoverflow and no answers either. \nOn Feb 12, 2015, at 12:48 PM, Shane Emmons notifications@github.com wrote:\nClosed #497.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "douglasmiller": "I've added a :translate option to the rules hash and documented the feature.\nI also updated other documentation that was erroneous:\nMoney.new(100, \"USD\").format -> $100.00\n. I recently added support for customizing currency symbols using I18n and the :translate => true option to the format method in PR #499. However, this is not in the current version (6.5.1) of the Money gem yet.\nThere is a way to manage this, though. I'm currently doing the same thing with a 5.x version of the Money gem. You should be able to re-use this with the current version with possible trivial modifications.\n``` ruby\n    def load_custom_currencies\n      # Load in json file and register amex currencies for the money gem\n      custom_currency_file = File.join('path', 'to', 'your', 'override_currency.json')\n      currs = JSON.parse(File.read(custom_currency_file), :symbolize_names => true)\n  currs.each do |curr|\n    Money::Currency.register(curr[1])\n  end\nend\n\n```\nWith override_currency.json being based on currency_iso.json. You only need to specify currencies that you are modifying, but you have to include the full original object.\n. I've added a :translate option to the rules hash and documented the feature.\nI also updated other documentation that was erroneous:\nMoney.new(100, \"USD\").format -> $100.00\n. I recently added support for customizing currency symbols using I18n and the :translate => true option to the format method in PR #499. However, this is not in the current version (6.5.1) of the Money gem yet.\nThere is a way to manage this, though. I'm currently doing the same thing with a 5.x version of the Money gem. You should be able to re-use this with the current version with possible trivial modifications.\n``` ruby\n    def load_custom_currencies\n      # Load in json file and register amex currencies for the money gem\n      custom_currency_file = File.join('path', 'to', 'your', 'override_currency.json')\n      currs = JSON.parse(File.read(custom_currency_file), :symbolize_names => true)\n  currs.each do |curr|\n    Money::Currency.register(curr[1])\n  end\nend\n\n```\nWith override_currency.json being based on currency_iso.json. You only need to specify currencies that you are modifying, but you have to include the full original object.\n. ",
    "qoyyim": "nevermind found solution\nseems my version of money-rails locked money gem insto 6.1.1\nafter update money rails it's good\n. nevermind found solution\nseems my version of money-rails locked money gem insto 6.1.1\nafter update money rails it's good\n. ",
    "arthurkarganyan": "Hi, guys! I am sorry, I have understood.\nhttp://stackoverflow.com/questions/524658/what-does-mean-in-ruby\n. Hi, guys! I am sorry, I have understood.\nhttp://stackoverflow.com/questions/524658/what-does-mean-in-ruby\n. ",
    "reustmd": "Similar issue, but it looks like it was never fixed?\nhttps://github.com/RubyMoney/money/issues/404\nI understand the sentiment that all values should be converted to money before any comparison, but simply returning false for 0 being greater than positive money values seems like bad news bears to me.\nimo, it should either fail loudly when comparing, or return a proper false, when running 0 > 1.to_money\n. @createdbypete I understand your perspective. Coercion might be the wrong answer. I'm still infinitely happier in a world where it throws on invalid comparisons.\nIt's really 0 > 1.to_money ==> true that makes me nervous. Regardless of currency, that seems wrong to me. Throwing for an invalid comparison seems reasonable to me. \n. Similar issue, but it looks like it was never fixed?\nhttps://github.com/RubyMoney/money/issues/404\nI understand the sentiment that all values should be converted to money before any comparison, but simply returning false for 0 being greater than positive money values seems like bad news bears to me.\nimo, it should either fail loudly when comparing, or return a proper false, when running 0 > 1.to_money\n. @createdbypete I understand your perspective. Coercion might be the wrong answer. I'm still infinitely happier in a world where it throws on invalid comparisons.\nIt's really 0 > 1.to_money ==> true that makes me nervous. Regardless of currency, that seems wrong to me. Throwing for an invalid comparison seems reasonable to me. \n. ",
    "jpegjames": "@reustmd, I was coming here to add the same issue. Based on #404, it seems like if you put the Money object first, it works, but this is less than ideal since it is not a normal convention of having to order compare values:\n1.to_money > 0 ==> true\n1.to_money > 1 ==> false\n@semmons99, I'm not sure how to address the problem, but is there anyway we can help?\n. @reustmd, I was coming here to add the same issue. Based on #404, it seems like if you put the Money object first, it works, but this is less than ideal since it is not a normal convention of having to order compare values:\n1.to_money > 0 ==> true\n1.to_money > 1 ==> false\n@semmons99, I'm not sure how to address the problem, but is there anyway we can help?\n. ",
    "mikerodrigues": "This is an interesting issue. I saw saw lots of talk about interface in https://github.com/RubyMoney/money/pull/405 but nothing about implementation.\nThe reason this works when the Money object is first is because it includes Comparable and defines comparison methods. When the Fixnum is first, the > operator isn't the same method as Money#>.\nI don't think monkey patching a comparison operator is the best approach. Ruby doesn't appear to do any implicit type conversion with these comparison operators, otherwise we could just define Money#to_int.\n. I agree with @createdbypete and @reustmd.\n. This is an interesting issue. I saw saw lots of talk about interface in https://github.com/RubyMoney/money/pull/405 but nothing about implementation.\nThe reason this works when the Money object is first is because it includes Comparable and defines comparison methods. When the Fixnum is first, the > operator isn't the same method as Money#>.\nI don't think monkey patching a comparison operator is the best approach. Ruby doesn't appear to do any implicit type conversion with these comparison operators, otherwise we could just define Money#to_int.\n. I agree with @createdbypete and @reustmd.\n. ",
    "greggroth": "In addition to the aforementioned #405, there's an open PR #535 that directly addresses this issue.\n. In addition to the aforementioned #405, there's an open PR #535 that directly addresses this issue.\n. ",
    "createdbypete": "I would like to add to this that the coercion might be causing more trouble that it's worth. For example, I find this comparison a little strange:\n```\nMoney.new(1_00, 'USD') == \"$1.00\"\n=> true #OK\nMoney.new(1_00, 'USD') == \"\u00a31.00\"\n=> true #???\nMoney.new(1_00, \"USD\") == Money.new(1_00, \"EUR\")\n=> false #OK\nMoney.new(1_00, \"USD\") == Money.new(1_00, \"EUR\").to_s\n=> true #???\n```\nWhile I appreciate the convenience, I feel this behaviour is confusing. The library should continue to only compare Money with Money and we should responsible enough to provide it with Money for comparison but it should not attempt to convert another object to Money so if anything I feel #to_money should be removed from these areas to avoid this issue.\nIf this conversion behaviour is required then Monetize is available for explicit conversion.\n. @reustmd the problem in your example is not directly related to Money gem but when it's used with the Monetize gem #to_money method added by the core extension on Numeric.\nHere's what I believe is happening:\n1. You are calling #> on the Fixnum 0 (for those who don't already know these operators are just like any other instance method)\n2. When #to_money is called on 1 it is now equivalent to Money.new(1)\n3. Fixnum doesn't know what to do with Money so the #coerce method is called on Money\n4. The Money implementation of #coerce switches the order so the value originally on the right handles the comparison. We are effectively running Money.new(1) > 0 (the complete opposite to what you actually want to test in this case)\nThis following part is where Monetize is causing the issue. If we were using only the Money gem this would have failed long ago with ArgumentError: comparison of Money with 0 failed.\nBecause Numeric is given a #to_money method by Monetize (mentioned previously) the comparison method #<=> on Money asks 0 if it responds to #to_money (which it does) and so it gets instantiated as a Money object you are finally left with this code (behind the curtain):\n``` ruby\nMoney.new(1) > Money.new(0)\n==> true\n```\nThis comparison of course makes sense if you'd written it this way, but not when you originally wanted:\n``` ruby\n0 > 1.to_money\n==> true\n```\nAs with my string comparison in the previous message the problem here appears to be with the use of #to_money on the value passed to the following methods (the only ones that seem to use it):\n- https://github.com/RubyMoney/money/blob/master/lib/money/money/arithmetic.rb#L37\n- https://github.com/RubyMoney/money/blob/master/lib/money/money/arithmetic.rb#L27\nI've created #547 as a proposal.\n. #547 has been accepted and prevents the implicit conversion with #to_money and also only accepts a Money for comparison.\nThe other issue with #coerce switching the order is being looked at in #535 so I'm going to close this issue so any further discussion can be focused over there.\n. I think this is a great improvement and feel Money is right to be strict on the objects it will interact with. :+1: :shipit: \n. Hey, interesting problem. I've created a quick test example to prove this in an isolated and repeatable way. Does this match your scenario well enough?\n``` ruby\n$LOAD_PATH.unshift File.dirname(FILE)\nrequire \"rspec\"\nrequire \"money\"\nMoney.use_i18n = true\nMoney.infinite_precision = true\nI18n.enforce_available_locales = false\nI18n.backend = I18n::Backend::Simple.new\nI18n.locale = :es\nI18n.backend.store_translations(\n    :es,\n    :number => { :currency => { :format => { :delimiter => \".\", :separator => \",\" } } }\n)\nRSpec.describe \"rounded_infinite_precision bug\" do\n  it \"works\" do\n    I18n.locale = :en\n    expect(Money.new(BigDecimal.new('12.1'), \"USD\").format(:rounded_infinite_precision => true)).to eq(\"$0.12\")\n  end\nit \"proves problem\" do\n    I18n.locale = :es\n    expect(Money.new(BigDecimal.new('12.1'), \"USD\").format(:rounded_infinite_precision => true)).to eq(\"$0,12\")\n  end\nend\n```\n```\n$ bundle exec rspec spec/i18n_prove_spec.rb\nFailures:\n1) rounded_infinite_precision bug proves problem\n     Failure/Error: expect(Money.new(BigDecimal.new('12.1'), \"USD\").format(:rounded_infinite_precision => true)).to eq(\"$0,12\")\n   expected: \"$0,12\"\n        got: \"$0.00\"\n\n   (compared using ==)\n\n```\n. @semmons99 updated the changelog, let me know if it doesn't make sense.\n. @semmons99 no problem, that warning about private attributes is new to me as well.\nEdit: I found https://bugs.ruby-lang.org/issues/10967 talking about removing this \"private attribute\" warning. Personally I use this all the time so would be nice to know it doesn't generate warnings.\n. Updated the change log.\n. I would like to add to this that the coercion might be causing more trouble that it's worth. For example, I find this comparison a little strange:\n```\nMoney.new(1_00, 'USD') == \"$1.00\"\n=> true #OK\nMoney.new(1_00, 'USD') == \"\u00a31.00\"\n=> true #???\nMoney.new(1_00, \"USD\") == Money.new(1_00, \"EUR\")\n=> false #OK\nMoney.new(1_00, \"USD\") == Money.new(1_00, \"EUR\").to_s\n=> true #???\n```\nWhile I appreciate the convenience, I feel this behaviour is confusing. The library should continue to only compare Money with Money and we should responsible enough to provide it with Money for comparison but it should not attempt to convert another object to Money so if anything I feel #to_money should be removed from these areas to avoid this issue.\nIf this conversion behaviour is required then Monetize is available for explicit conversion.\n. @reustmd the problem in your example is not directly related to Money gem but when it's used with the Monetize gem #to_money method added by the core extension on Numeric.\nHere's what I believe is happening:\n1. You are calling #> on the Fixnum 0 (for those who don't already know these operators are just like any other instance method)\n2. When #to_money is called on 1 it is now equivalent to Money.new(1)\n3. Fixnum doesn't know what to do with Money so the #coerce method is called on Money\n4. The Money implementation of #coerce switches the order so the value originally on the right handles the comparison. We are effectively running Money.new(1) > 0 (the complete opposite to what you actually want to test in this case)\nThis following part is where Monetize is causing the issue. If we were using only the Money gem this would have failed long ago with ArgumentError: comparison of Money with 0 failed.\nBecause Numeric is given a #to_money method by Monetize (mentioned previously) the comparison method #<=> on Money asks 0 if it responds to #to_money (which it does) and so it gets instantiated as a Money object you are finally left with this code (behind the curtain):\n``` ruby\nMoney.new(1) > Money.new(0)\n==> true\n```\nThis comparison of course makes sense if you'd written it this way, but not when you originally wanted:\n``` ruby\n0 > 1.to_money\n==> true\n```\nAs with my string comparison in the previous message the problem here appears to be with the use of #to_money on the value passed to the following methods (the only ones that seem to use it):\n- https://github.com/RubyMoney/money/blob/master/lib/money/money/arithmetic.rb#L37\n- https://github.com/RubyMoney/money/blob/master/lib/money/money/arithmetic.rb#L27\nI've created #547 as a proposal.\n. #547 has been accepted and prevents the implicit conversion with #to_money and also only accepts a Money for comparison.\nThe other issue with #coerce switching the order is being looked at in #535 so I'm going to close this issue so any further discussion can be focused over there.\n. I think this is a great improvement and feel Money is right to be strict on the objects it will interact with. :+1: :shipit: \n. Hey, interesting problem. I've created a quick test example to prove this in an isolated and repeatable way. Does this match your scenario well enough?\n``` ruby\n$LOAD_PATH.unshift File.dirname(FILE)\nrequire \"rspec\"\nrequire \"money\"\nMoney.use_i18n = true\nMoney.infinite_precision = true\nI18n.enforce_available_locales = false\nI18n.backend = I18n::Backend::Simple.new\nI18n.locale = :es\nI18n.backend.store_translations(\n    :es,\n    :number => { :currency => { :format => { :delimiter => \".\", :separator => \",\" } } }\n)\nRSpec.describe \"rounded_infinite_precision bug\" do\n  it \"works\" do\n    I18n.locale = :en\n    expect(Money.new(BigDecimal.new('12.1'), \"USD\").format(:rounded_infinite_precision => true)).to eq(\"$0.12\")\n  end\nit \"proves problem\" do\n    I18n.locale = :es\n    expect(Money.new(BigDecimal.new('12.1'), \"USD\").format(:rounded_infinite_precision => true)).to eq(\"$0,12\")\n  end\nend\n```\n```\n$ bundle exec rspec spec/i18n_prove_spec.rb\nFailures:\n1) rounded_infinite_precision bug proves problem\n     Failure/Error: expect(Money.new(BigDecimal.new('12.1'), \"USD\").format(:rounded_infinite_precision => true)).to eq(\"$0,12\")\n   expected: \"$0,12\"\n        got: \"$0.00\"\n\n   (compared using ==)\n\n```\n. @semmons99 updated the changelog, let me know if it doesn't make sense.\n. @semmons99 no problem, that warning about private attributes is new to me as well.\nEdit: I found https://bugs.ruby-lang.org/issues/10967 talking about removing this \"private attribute\" warning. Personally I use this all the time so would be nice to know it doesn't generate warnings.\n. Updated the change log.\n. ",
    "JuanitoFatas": ":sparkles: :sparkles: :sparkles: \n. :sparkles: :sparkles: :sparkles: \n. ",
    "tomas": "Bravo @ismasan.\n. Bravo @ismasan.\n. ",
    "lucascaton": "Nevermind, just realised it's inverted (lower value is more prioritised) :smile:\n. Nevermind, just realised it's inverted (lower value is more prioritised) :smile:\n. ",
    "zkarpinski": "The master branch change log already had a line about changing CLP from 1 to 100, which is confusing.  I added my issue from the GoogleCurrency gem underneath it that entry.  I left out the link to this pull request, I hope that isn't a problem.\n. @semmons99 Sure, I'll start working on that today.\n. The master branch change log already had a line about changing CLP from 1 to 100, which is confusing.  I added my issue from the GoogleCurrency gem underneath it that entry.  I left out the link to this pull request, I hope that isn't a problem.\n. @semmons99 Sure, I'll start working on that today.\n. ",
    "DmitryKK": "Thank you very much)\n. @printercu It's perfect! Thank you very much! \n. Thank you very much)\n. @printercu It's perfect! Thank you very much! \n. ",
    "Eloi": "I was about to properly code my hackish local fix and issue a PR this weekend, thanks a lot for saving me time :)\n. I was about to properly code my hackish local fix and issue a PR this weekend, thanks a lot for saving me time :)\n. ",
    "bnussey": "Silly me, just had to pass it as a symbol not a string\n. Silly me, just had to pass it as a symbol not a string\n. ",
    "lluis": "I was using v5.1.1 which has the to_money method, I'll upgrade to v6 and replace all to_money calls\nthanks!\n. If someone needs a 5.1.1 patch, here it is:\n```\ndiff --git a/lib/money/money/parsing.rb b/lib/money/money/parsing.rb\nindex fddf9e1..befe921 100644\n--- a/lib/money/money/parsing.rb\n+++ b/lib/money/money/parsing.rb\n@@ -352,11 +352,7 @@ class Money\n         minor = if minor.size < currency.decimal_places\n                   (minor + (\"0\" * currency.decimal_places))[0,currency.decimal_places].to_i\n                 elsif minor.size > currency.decimal_places\n-                  if minor[currency.decimal_places,1].to_i >= 5\n-                    minor[0,currency.decimal_places].to_i+1\n-                  else\n-                    minor[0,currency.decimal_places].to_i\n-                  end\n+                  BigDecimal.new(\"0.#{minor}\").round(currency.decimal_places, BigDecimal::ROUND_HALF_EVEN) * 100\n                 else\n                   minor.to_i\n                 end\ndiff --git a/spec/core_extensions_spec.rb b/spec/core_extensions_spec.rb\nindex d86c78f..986aecb 100644\n--- a/spec/core_extensions_spec.rb\n+++ b/spec/core_extensions_spec.rb\n@@ -50,7 +50,7 @@ describe Money, \"core extensions\" do\n         \"-1,000\"          => Money.new(-1_000_00)         ,\n         \"1,000.5\"         => Money.new(1_000_50)          ,\n         \"1,000.51\"        => Money.new(1_000_51)          ,\n-        \"1,000.505\"       => Money.new(1_000_51)          ,\n+        \"1,000.505\"       => Money.new(1_000_50)          ,\n         \"1,000.504\"       => Money.new(1_000_50)          ,\n         \"1,000.0000\"      => Money.new(1_000_00)          ,\n         \"1,000.5000\"      => Money.new(1_000_50)          ,\ndiff --git a/spec/money/parsing_spec.rb b/spec/money/parsing_spec.rb\nindex ab38dfa..96c940a 100644\n--- a/spec/money/parsing_spec.rb\n+++ b/spec/money/parsing_spec.rb\n@@ -298,6 +298,9 @@ describe Money, \"parsing\" do\n     it \"correctly treats pipe marks '|' in input (regression test)\" do\n       Money.extract_cents('100|0').should == Money.extract_cents('100!0')\n     end\n+    it 'applies bankers rounding' do\n+      Money.extract_cents('0.005').should == 0\n+    end\n   end\ncontext \"given the same inputs to .parse and .from_*\" do\n```\n. I was using v5.1.1 which has the to_money method, I'll upgrade to v6 and replace all to_money calls\nthanks!\n. If someone needs a 5.1.1 patch, here it is:\n```\ndiff --git a/lib/money/money/parsing.rb b/lib/money/money/parsing.rb\nindex fddf9e1..befe921 100644\n--- a/lib/money/money/parsing.rb\n+++ b/lib/money/money/parsing.rb\n@@ -352,11 +352,7 @@ class Money\n         minor = if minor.size < currency.decimal_places\n                   (minor + (\"0\" * currency.decimal_places))[0,currency.decimal_places].to_i\n                 elsif minor.size > currency.decimal_places\n-                  if minor[currency.decimal_places,1].to_i >= 5\n-                    minor[0,currency.decimal_places].to_i+1\n-                  else\n-                    minor[0,currency.decimal_places].to_i\n-                  end\n+                  BigDecimal.new(\"0.#{minor}\").round(currency.decimal_places, BigDecimal::ROUND_HALF_EVEN) * 100\n                 else\n                   minor.to_i\n                 end\ndiff --git a/spec/core_extensions_spec.rb b/spec/core_extensions_spec.rb\nindex d86c78f..986aecb 100644\n--- a/spec/core_extensions_spec.rb\n+++ b/spec/core_extensions_spec.rb\n@@ -50,7 +50,7 @@ describe Money, \"core extensions\" do\n         \"-1,000\"          => Money.new(-1_000_00)         ,\n         \"1,000.5\"         => Money.new(1_000_50)          ,\n         \"1,000.51\"        => Money.new(1_000_51)          ,\n-        \"1,000.505\"       => Money.new(1_000_51)          ,\n+        \"1,000.505\"       => Money.new(1_000_50)          ,\n         \"1,000.504\"       => Money.new(1_000_50)          ,\n         \"1,000.0000\"      => Money.new(1_000_00)          ,\n         \"1,000.5000\"      => Money.new(1_000_50)          ,\ndiff --git a/spec/money/parsing_spec.rb b/spec/money/parsing_spec.rb\nindex ab38dfa..96c940a 100644\n--- a/spec/money/parsing_spec.rb\n+++ b/spec/money/parsing_spec.rb\n@@ -298,6 +298,9 @@ describe Money, \"parsing\" do\n     it \"correctly treats pipe marks '|' in input (regression test)\" do\n       Money.extract_cents('100|0').should == Money.extract_cents('100!0')\n     end\n+    it 'applies bankers rounding' do\n+      Money.extract_cents('0.005').should == 0\n+    end\n   end\ncontext \"given the same inputs to .parse and .from_*\" do\n```\n. ",
    "colbywhite": ":+1: Nice. That method seemed to escape my greps. Might want to add that to the README. Thanks!\n. :+1: Nice. That method seemed to escape my greps. Might want to add that to the README. Thanks!\n. ",
    "taki": "I am sorry. I have rebuild it by mistake.\nI am surprised to all test pass.\nBelow link is failed test.\nhttps://github.com/RubyMoney/money/blob/master/spec/currency_spec.rb#L204-207\nThe result is that ids.uniq.length is 2.\n. > Are you running the same version as Travis?\nYes. I running the Ruby 2.0.0 settings.\n. @antstorm Tnank you.\n. I close this issue because it has been solved.\n. I think it is in the specification.\nIf you want to include fractional , infinite_precision option is necessary.\nPlease see below code.\n``` ruby\nrequire 'money'\nMoney.add_rate \"TWD\", \"USD\", 0.03086610284585468\nMoney.add_rate \"USD\", \"TWD\", 32.398\nMoney.infinite_precision = true\np Money.new(1, \"USD\").exchange_to(\"TWD\") #\n```\n. I close this issue because it is be solved.\n. I close this issue because it is solved.\n. Thank you.\n. > I don't see a reason to stop supporting it unless new development is being hindered.\nI understand your opinion and close this PR.\n. I am sorry. I have rebuild it by mistake.\nI am surprised to all test pass.\nBelow link is failed test.\nhttps://github.com/RubyMoney/money/blob/master/spec/currency_spec.rb#L204-207\nThe result is that ids.uniq.length is 2.\n. > Are you running the same version as Travis?\nYes. I running the Ruby 2.0.0 settings.\n. @antstorm Tnank you.\n. I close this issue because it has been solved.\n. I think it is in the specification.\nIf you want to include fractional , infinite_precision option is necessary.\nPlease see below code.\n``` ruby\nrequire 'money'\nMoney.add_rate \"TWD\", \"USD\", 0.03086610284585468\nMoney.add_rate \"USD\", \"TWD\", 32.398\nMoney.infinite_precision = true\np Money.new(1, \"USD\").exchange_to(\"TWD\") #\n```\n. I close this issue because it is be solved.\n. I close this issue because it is solved.\n. Thank you.\n. > I don't see a reason to stop supporting it unless new development is being hindered.\nI understand your opinion and close this PR.\n. ",
    "saizai": "Can't; I don't know what to patch (what's included vs not).\n. https://github.com/RubyMoney/money/pull/541\n. Can't; I don't know what to patch (what's included vs not).\n. https://github.com/RubyMoney/money/pull/541\n. ",
    "AlexVPopov": "Do you mean doing this in my local app like this:\nruby\nActiveSupport::Inflector.inflections do |inflect|\n  inflect.irregular 'stotinka', 'stotinki'\nend\nor can I submit a patch to rails/i18n so that it is available globally for everybody. I am asking this, because I've seen that some people have submitted PRs for other words in the past, but I am not sure exactly where this can be done.\nThanks once again.\n. OK, thank you.\n. Do you mean doing this in my local app like this:\nruby\nActiveSupport::Inflector.inflections do |inflect|\n  inflect.irregular 'stotinka', 'stotinki'\nend\nor can I submit a patch to rails/i18n so that it is available globally for everybody. I am asking this, because I've seen that some people have submitted PRs for other words in the past, but I am not sure exactly where this can be done.\nThanks once again.\n. OK, thank you.\n. ",
    "josephjaber": ":+1: \n. :+1: \n. ",
    "nilbus": "Thanks for the quick response! If you could release this quickly, that would be helpful to myself and @josephjaber. I believe this would qualify as a patch release (6.6.1), as it seems like a fix to something that was already intended. What do you think?\n. Thanks Shane!\u200b\n. Thanks for the quick response! If you could release this quickly, that would be helpful to myself and @josephjaber. I believe this would qualify as a patch release (6.6.1), as it seems like a fix to something that was already intended. What do you think?\n. Thanks Shane!\u200b\n. ",
    "Funfun": "nice patch\n. :cake: \n. @antstorm i've been thinking about better name too. I totally agree with your suggestion.\n. @antstorm trying to understand the correlation btw failing test and my changes. I freeze FORMAT_SERIALIZERS hash as well as RATE_FORMATS. let's see. \n. @antstorm it's green.\n. nice patch\n. :cake: \n. @antstorm i've been thinking about better name too. I totally agree with your suggestion.\n. @antstorm trying to understand the correlation btw failing test and my changes. I freeze FORMAT_SERIALIZERS hash as well as RATE_FORMATS. let's see. \n. @antstorm it's green.\n. ",
    "Carpela": "Ok. I get that.\nJust that whatever the default value is has changed and is breaking tests in money-rails between 6.5 and 6.6\n. Ok. I get that.\nJust that whatever the default value is has changed and is breaking tests in money-rails between 6.5 and 6.6\n. ",
    "phlegx": "Please add it. Thx. Can we also add currencies GGP and IMP? This two currencies are in the currencylayer.com list but not in the money gem.\n. @semmons99 here the data of the two currencies:\n``` ruby\n  # Add GGP currency\n  Money::Currency.register_currency = {\n    priority:              100,\n    iso_code:              'GGP',\n    name:                  'Guernsey Pound',\n    symbol:                '\u00a3',\n    alternate_symbols:     [],\n    symbol_first:          true,\n    subunit:               'Penny',\n    subunit_to_unit:       100,\n    html_entity:           '\u00a3',\n    decimal_mark:          '.',\n    thousands_separator:   ',',\n    smallest_denomination: 1\n  }\n# Add IMP currency\n  Money::Currency.register_currency = {\n    priority:             100,\n    iso_code:             'IMP',\n    name:                 'Isle of Man Pound',\n    symbol:               'M\u00a3',\n    alternate_symbols:    [],\n    symbol_first:         true,\n    subunit:              'Penny',\n    subunit_to_unit:      100,\n    html_entity:          'M\u00a3',\n    decimal_mark:         '.',\n    thousands_separator:  ',',\n    smallest_denomination: 1\n  }\n```\n. @printercu ok no problem. Mom\n. See PR #557.\n. @semmons99 when will a new release made?\n. Hehehe no, it was a test. The chain is this in my example. If I add a rate, do I have to pass the rate as BigDecimal?\nUPDATE\nNo, a rate is used as BigDecimal lib/money/bank/variable_exchange.rb#L129\n. Could the error be in this line (.to_f)? lib/money/bank/variable_exchange.rb#L129\nSolution: to_f should be removed\nruby\nclass Money\n  module Bank\n    class VariableExchange < Base\n      ...\n      def exchange(fractional, rate, &block)\n        ex = (fractional * BigDecimal.new(rate.to_s)) #.to_f\n        if block_given?\n          yield ex\n        elsif @rounding_method\n          @rounding_method.call(ex)\n        else\n          ex.to_s.to_d\n        end\n      end\n    end\n    ...\n  end\nend\nI have configured Money gem to Money.infinite_precision = true\n. calculate_fractional seams ok! It wraps all params in BigDecimal. See here lib/money/bank/variable_exchange.rb#L121.\n. @antstorm yes, subunit_to_unitare Fixnum! But the division should return a BigDecimal.\nBecause of lib/money/money.rb#L626:\nruby\ndef return_value(value)\n    if self.class.infinite_precision\n      value\n    else\n      value.round(0, self.class.rounding_mode).to_i # <= this still return a non BigDecimal number\n    end\nend\ncalled from lib/money/money.rb#L57:\n``` ruby\ndef fractional\n    # Ensure we have a BigDecimal. If the Money object is created\n    # from YAML, @fractional can end up being set to a Float.\n    fractional = as_d(@fractional)\nreturn_value(fractional) # <= here\n\nend\n```\nThe division should always return a BigDecimal.\nMy opinion: We can leave this method like it is.\nruby\ndef calculate_fractional(from, to_currency)\n        BigDecimal.new(from.fractional.to_s) / ( # can return Fixnum without BigDecimal\n          BigDecimal.new(from.currency.subunit_to_unit.to_s) / # is a Fixnum without BigDecimal\n          BigDecimal.new(to_currency.subunit_to_unit.to_s) # is a Fixnum without BigDecimal\n          # ( Fixnum / Fixnum) return a Fixnum, eg. 1 / 2 return 0 but should return 0.5\n          # Real subunit_to_unit: 1, 5, 10, 100 e.g 1 / 5 != 0 but 0.2\n        )\n       # Fixnum / ( Fixnum / Fixnum ) return a Fixnam\n       # BigDecimal / ( Fixnum / Fixnum ) return a BigDecimal\nend\nSo, removing BigDecimal to one of this three instructions can raise a round problem.\nUPDATE\nIn theory we can do the following (only one number should be BigDecimal to get a result in BigDecimal):\nruby\ndef calculate_fractional(from, to_currency)\n        from.fractional / ( # can return Fixnum without BigDecimal\n          from.currency.subunit_to_unit /\n          BigDecimal.new(to_currency.subunit_to_unit.to_s)\n        )\nend\n. @antstorm can you commit the bugfix please? https://github.com/RubyMoney/money/issues/654#issuecomment-243708582\n. Please add it. Thx. Can we also add currencies GGP and IMP? This two currencies are in the currencylayer.com list but not in the money gem.\n. @semmons99 here the data of the two currencies:\n``` ruby\n  # Add GGP currency\n  Money::Currency.register_currency = {\n    priority:              100,\n    iso_code:              'GGP',\n    name:                  'Guernsey Pound',\n    symbol:                '\u00a3',\n    alternate_symbols:     [],\n    symbol_first:          true,\n    subunit:               'Penny',\n    subunit_to_unit:       100,\n    html_entity:           '\u00a3',\n    decimal_mark:          '.',\n    thousands_separator:   ',',\n    smallest_denomination: 1\n  }\n# Add IMP currency\n  Money::Currency.register_currency = {\n    priority:             100,\n    iso_code:             'IMP',\n    name:                 'Isle of Man Pound',\n    symbol:               'M\u00a3',\n    alternate_symbols:    [],\n    symbol_first:         true,\n    subunit:              'Penny',\n    subunit_to_unit:      100,\n    html_entity:          'M\u00a3',\n    decimal_mark:         '.',\n    thousands_separator:  ',',\n    smallest_denomination: 1\n  }\n```\n. @printercu ok no problem. Mom\n. See PR #557.\n. @semmons99 when will a new release made?\n. Hehehe no, it was a test. The chain is this in my example. If I add a rate, do I have to pass the rate as BigDecimal?\nUPDATE\nNo, a rate is used as BigDecimal lib/money/bank/variable_exchange.rb#L129\n. Could the error be in this line (.to_f)? lib/money/bank/variable_exchange.rb#L129\nSolution: to_f should be removed\nruby\nclass Money\n  module Bank\n    class VariableExchange < Base\n      ...\n      def exchange(fractional, rate, &block)\n        ex = (fractional * BigDecimal.new(rate.to_s)) #.to_f\n        if block_given?\n          yield ex\n        elsif @rounding_method\n          @rounding_method.call(ex)\n        else\n          ex.to_s.to_d\n        end\n      end\n    end\n    ...\n  end\nend\nI have configured Money gem to Money.infinite_precision = true\n. calculate_fractional seams ok! It wraps all params in BigDecimal. See here lib/money/bank/variable_exchange.rb#L121.\n. @antstorm yes, subunit_to_unitare Fixnum! But the division should return a BigDecimal.\nBecause of lib/money/money.rb#L626:\nruby\ndef return_value(value)\n    if self.class.infinite_precision\n      value\n    else\n      value.round(0, self.class.rounding_mode).to_i # <= this still return a non BigDecimal number\n    end\nend\ncalled from lib/money/money.rb#L57:\n``` ruby\ndef fractional\n    # Ensure we have a BigDecimal. If the Money object is created\n    # from YAML, @fractional can end up being set to a Float.\n    fractional = as_d(@fractional)\nreturn_value(fractional) # <= here\n\nend\n```\nThe division should always return a BigDecimal.\nMy opinion: We can leave this method like it is.\nruby\ndef calculate_fractional(from, to_currency)\n        BigDecimal.new(from.fractional.to_s) / ( # can return Fixnum without BigDecimal\n          BigDecimal.new(from.currency.subunit_to_unit.to_s) / # is a Fixnum without BigDecimal\n          BigDecimal.new(to_currency.subunit_to_unit.to_s) # is a Fixnum without BigDecimal\n          # ( Fixnum / Fixnum) return a Fixnum, eg. 1 / 2 return 0 but should return 0.5\n          # Real subunit_to_unit: 1, 5, 10, 100 e.g 1 / 5 != 0 but 0.2\n        )\n       # Fixnum / ( Fixnum / Fixnum ) return a Fixnam\n       # BigDecimal / ( Fixnum / Fixnum ) return a BigDecimal\nend\nSo, removing BigDecimal to one of this three instructions can raise a round problem.\nUPDATE\nIn theory we can do the following (only one number should be BigDecimal to get a result in BigDecimal):\nruby\ndef calculate_fractional(from, to_currency)\n        from.fractional / ( # can return Fixnum without BigDecimal\n          from.currency.subunit_to_unit /\n          BigDecimal.new(to_currency.subunit_to_unit.to_s)\n        )\nend\n. @antstorm can you commit the bugfix please? https://github.com/RubyMoney/money/issues/654#issuecomment-243708582\n. ",
    "muichkine": "OK, thanks. :) My mistake, sorry guys.\n. OK, thanks. :) My mistake, sorry guys.\n. ",
    "poc7667": "Excuse me,Just a question to ask, how to convert dollars into cents for money gem ?\nThere're many currencies type in my database.\nsuppose I have these 3 items in my database\n- amount: 100, currency: NTD\n- amount:100, currency: USD\n- amount:100, currency: JPY\nThen\nMoney.new(100, :NTD), the result will be 1 dollar for NTD, but actually it should be 100 dollars.\nAs as in USD\nHowever,\nMoney.new(100, :JPY), the result is just 100 dollars for JPY, it's as my expect.\nHow could I handle this situation in my case. it's not possible to acquire my user to type 100 for 1 dollar with NTD currency.\nIn the amount field, I want to only save the number for dollar unit.\nHowever the money gem seems only accepts cents as its input.\nIs there any good practice to solve my problem.\n. Excuse me,Just a question to ask, how to convert dollars into cents for money gem ?\nThere're many currencies type in my database.\nsuppose I have these 3 items in my database\n- amount: 100, currency: NTD\n- amount:100, currency: USD\n- amount:100, currency: JPY\nThen\nMoney.new(100, :NTD), the result will be 1 dollar for NTD, but actually it should be 100 dollars.\nAs as in USD\nHowever,\nMoney.new(100, :JPY), the result is just 100 dollars for JPY, it's as my expect.\nHow could I handle this situation in my case. it's not possible to acquire my user to type 100 for 1 dollar with NTD currency.\nIn the amount field, I want to only save the number for dollar unit.\nHowever the money gem seems only accepts cents as its input.\nIs there any good practice to solve my problem.\n. ",
    "wingleungchoi": "thank you for your reply.\nI am using Money::Bank::GoogleCurrency.new.\nThe exchange rate is correct bank.get_rate(\"HKD\", \"VND\").to_f # => 2884.5162 Correct\nHowever Money.new(1, 'HKD').exchange_to('VND').cents # => 28 Wrong\n. Thank you for reply. I tried but unfortunately it fails.\nMoney.infinite_precision = true\nMoney.new(1, 'HKD').exchange_to('VND').to_f #=> 28.0\nshould be 2884.50\nhttps://www.google.com.hk/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=1%20HKD%20to%20VND\n. @printercu  Appreciate for your active response. \nThe problem is that exchange rate of Money.new is different from bank\nexchange rate VND is wrong in Money.new\n```\nMoney.new(1, :HKD).exchange_to(:VND)\n=> # #=> 1HKD to 29 VND (Wrong exchange rate) which is 100 times smaller\n```\n```\nbank = Money::Bank::GoogleCurrency.new\n=> bank.get_rate(\"HKD\", \"VND\").to_f #=> 1HKD => 2884.505 VND (Right exchange rate)\n```\nCurrent gem version i used\ngem 'money', '~> 6.6.1'\ngem 'google_currency', :git => 'git@github.com:RubyMoney/google_currency.git'\n. I see your point.\nFor example, when i exchange 1 dollar of HKD to VND\ni need change to 100 cents of HKD\n Money.new(100, :HKD).exchange_to(:VND).cents\n#=> 2885 Question: is 2885 cents or dollar?\nAlso Money.new(100, :HKD).exchange_to(:VND).dollars.to_f #=> 2885.0\nMoney.new(100, :HKD).exchange_to(:VND).cents#=>2885  conflicts upper line\nis it Because Vietanese VND doesn't  have cents,  2885 is VND (dollar) not cent?\nhttps://github.com/RubyMoney/money/pull/441\nhttps://github.com/RubyMoney/money/blob/1f916a55ffbd554a136285d1f75f50825c587512/config/currency_iso.json#L2301\n. @printercu  I checked.\nhkd_decimal = Money.from_amount(100, :HKD).to_d #=> #<BigDecimal:7fefcdc79510,'0.1E3',9(36)>\nvnd_decimal = Money.from_amount(100, :VND).to_d #=> #<BigDecimal:7fefcd848a40,'0.1E3',9(36)>\nusd_decimal = Money.from_amount(100, :USD).to_d #=> #<BigDecimal:7fefd292ddc0,'0.1E3',9(36)>\nusd_decimal == hkd_decimal #=> true\nusd_decimal == vnd_decimal #=> true\nSorry to trouble you.\nMy concerns is the following\nline1:   Money.new(100, :HKD).exchange_to(:VND).dollars.to_d == Money.new(100, :HKD).exchange_to(:VND).cents #=> true \nline2:   Money.new(100, :HKD).exchange_to(:USD).dollars.to_d == Money.new(100, :HKD).exchange_to(:USD).cents #=> false\nLine 1 is wrong. It should return false\nMy gem version:\ngem 'money', '~> 6.6.1'\ngem 'google_currency', :git => 'git@github.com:RubyMoney/google_currency.git'\n. As i know VND has no cents and has only dollar, it may be reasonable to only return VND dollar\nMoney.new(100, :HKD).exchange_to(:VND).cents #=> 2890\nwhat i expect is: 100 cents HKD is equal to 2890 cents VND\nIn fact: the real meaning: 100 cents HKD is equal to 2890 dollars VND because VND DOES NOT have cents\nHowever, it may be confusing. I expected it should returns VND in cents, NOT dollars\n. I think this issue is ready to be closed.\nAppreciate for your active response. Help me a lots. Thanks.\n. thank you for your reply.\nI am using Money::Bank::GoogleCurrency.new.\nThe exchange rate is correct bank.get_rate(\"HKD\", \"VND\").to_f # => 2884.5162 Correct\nHowever Money.new(1, 'HKD').exchange_to('VND').cents # => 28 Wrong\n. Thank you for reply. I tried but unfortunately it fails.\nMoney.infinite_precision = true\nMoney.new(1, 'HKD').exchange_to('VND').to_f #=> 28.0\nshould be 2884.50\nhttps://www.google.com.hk/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=1%20HKD%20to%20VND\n. @printercu  Appreciate for your active response. \nThe problem is that exchange rate of Money.new is different from bank\nexchange rate VND is wrong in Money.new\n```\nMoney.new(1, :HKD).exchange_to(:VND)\n=> # #=> 1HKD to 29 VND (Wrong exchange rate) which is 100 times smaller\n```\n```\nbank = Money::Bank::GoogleCurrency.new\n=> bank.get_rate(\"HKD\", \"VND\").to_f #=> 1HKD => 2884.505 VND (Right exchange rate)\n```\nCurrent gem version i used\ngem 'money', '~> 6.6.1'\ngem 'google_currency', :git => 'git@github.com:RubyMoney/google_currency.git'\n. I see your point.\nFor example, when i exchange 1 dollar of HKD to VND\ni need change to 100 cents of HKD\n Money.new(100, :HKD).exchange_to(:VND).cents\n#=> 2885 Question: is 2885 cents or dollar?\nAlso Money.new(100, :HKD).exchange_to(:VND).dollars.to_f #=> 2885.0\nMoney.new(100, :HKD).exchange_to(:VND).cents#=>2885  conflicts upper line\nis it Because Vietanese VND doesn't  have cents,  2885 is VND (dollar) not cent?\nhttps://github.com/RubyMoney/money/pull/441\nhttps://github.com/RubyMoney/money/blob/1f916a55ffbd554a136285d1f75f50825c587512/config/currency_iso.json#L2301\n. @printercu  I checked.\nhkd_decimal = Money.from_amount(100, :HKD).to_d #=> #<BigDecimal:7fefcdc79510,'0.1E3',9(36)>\nvnd_decimal = Money.from_amount(100, :VND).to_d #=> #<BigDecimal:7fefcd848a40,'0.1E3',9(36)>\nusd_decimal = Money.from_amount(100, :USD).to_d #=> #<BigDecimal:7fefd292ddc0,'0.1E3',9(36)>\nusd_decimal == hkd_decimal #=> true\nusd_decimal == vnd_decimal #=> true\nSorry to trouble you.\nMy concerns is the following\nline1:   Money.new(100, :HKD).exchange_to(:VND).dollars.to_d == Money.new(100, :HKD).exchange_to(:VND).cents #=> true \nline2:   Money.new(100, :HKD).exchange_to(:USD).dollars.to_d == Money.new(100, :HKD).exchange_to(:USD).cents #=> false\nLine 1 is wrong. It should return false\nMy gem version:\ngem 'money', '~> 6.6.1'\ngem 'google_currency', :git => 'git@github.com:RubyMoney/google_currency.git'\n. As i know VND has no cents and has only dollar, it may be reasonable to only return VND dollar\nMoney.new(100, :HKD).exchange_to(:VND).cents #=> 2890\nwhat i expect is: 100 cents HKD is equal to 2890 cents VND\nIn fact: the real meaning: 100 cents HKD is equal to 2890 dollars VND because VND DOES NOT have cents\nHowever, it may be confusing. I expected it should returns VND in cents, NOT dollars\n. I think this issue is ready to be closed.\nAppreciate for your active response. Help me a lots. Thanks.\n. ",
    "sime": "I'll try and cook something up tonight.\n. I'll try and cook something up tonight.\n. ",
    "popup-user": "Whoops - you're right - I posted in the wrong project :/. I tried being adventurous and tried ActionView::Base.money_without_cents, but it actually didn't work - but thanks for posting!\n. Whoops - you're right - I posted in the wrong project :/. I tried being adventurous and tried ActionView::Base.money_without_cents, but it actually didn't work - but thanks for posting!\n. ",
    "j15e": "I honestly do not really get what is wrong with defining the i18n methods the way it was, but it does create an issue on ruby 2.3 : it seems they are private (maybe because they are defined on the Formatting module, not the base class itself?) :\n8) Money formatting with i18n with number.format.* should use '.' as the thousands separator\n     Failure/Error: expect(money.thousands_separator).to eq '.'\n     NoMethodError:\n       private method `thousands_separator' called for #<Money fractional:0 currency:USD>\n     # ./spec/money/formatting_spec.rb:68:in `block (4 levels) in <top (required)>'\nSee #578 for an other solution which I think would be cleaner. \n. There is an image on RVM, it is named ruby-2.3.0-preview1 (I think you have to provide the full name otherwise it won't install a preview version).\nMoving methods definition outside the included block to the module directly as you suggested does fix the issue too (and I agree it is cleaner than my suggestion in #578). Sorry for this, at my first look of your exemple, I didn't exactly got what you suggested.\nThinking about it, maybe the ideal solution would be to transform those 2 methods into regular module methods & use a private method to avoid duplication of code? Names of the methods are not dynamic, so defining them dynamically is not totally required.\n``` ruby\n    def thousands_separator\n      i18n_format_for(:thousands_separator, :delimiter, \",\")\n    end\ndef decimal_mark\n  i18n_format_for(:decimal_mark, :separator, \".\")\nend\n\nalias_method :delimiter, :thousands_separator\nalias_method :separator, :decimal_mark\n\n\nprivate\n\ndef i18n_format_for(method, name, character)\n  if self.class.use_i18n\n    begin\n      I18n.t name, :scope => \"number.currency.format\", :raise => true\n    rescue I18n::MissingTranslationData\n      I18n.t name, :scope =>\"number.format\", :default => (currency.send(method) || character)\n    end\n  else\n    currency.send(method) || character\n  end\nend\n\n``\n. Cool thanks! If you get to install 2.3.0 maybe you can look into the remaining arithmetic issues which would be easier to fix with better knowledge of the code. There is now only 5 failing tests on ruby 2.3.\n. [ruby-2-3-0-preview2](https://www.ruby-lang.org/en/news/2015/12/11/ruby-2-3-0-preview2-released/) was released an the private method bug [is fixed](https://bugs.ruby-lang.org/issues/11754), but there is still aTypeErrorwith the money exchangeexchange_with` method in the specs with ruby 2.3. \nI haven't investigated this issue, it seems a bit complex.\n. The issue with the TypeError seems to be that in 2.3 the arithmetic == is using Money Arithmetic <=> rather than eql? when two objects aren't of the same type. Which raise a TypeError in our case. I have try to reproduce the issue with a simple class & module example but I could not.\nThis backtrace might be a place to start, it reports the following, which is very weird :\nBacktrace:\n--\nmoney/lib/money/money/arithmetic.rb:66:in `<=>'\ngems/ruby-2.3.0-preview2/gems/rspec-expectations-3.4.0/lib/rspec/matchers/built_in/eq.rb:35:in `=='\ngems/ruby-2.3.0-preview2/gems/rspec-expectations-3.4.0/lib/rspec/matchers/built_in/eq.rb:35:in `match'\nI still have no clue why ruby money <=> method is invoked when the actual rspec matcher code is : \nruby\n  # rspec-expectations-3.4.0/lib/rspec/matchers/built_in/eq.rb\n  def match(expected, actual)\n    actual == expected\n   end\n. Forget the last comment, I got what is wrong, it was already doing this in ruby 2.2 but a deprecation warning was there : \nlib/rspec/matchers/built_in/eq.rb:35: warning: Comparable#== will no more rescue exceptions of #<=> in the next release.\n/lib/rspec/matchers/built_in/eq.rb:35: warning: Return nil in #<=> if the comparison is inappropriate or avoid such comparison\nSo I guess we should update <=> to return nil as suggest I update specs accordingly. \n. Pending Ruby 2.3.0 release and/or update on Ruby Bug #11754\n. The ruby 2.3 bug was fixed, but I still think the it would be cleaner with two real methods + a private method as suggest in this pull request, rather than using meta programming to define only two methods. Up to you to decide what you prefer, no hard feelings! :+1: \n. I would like to have @printercu input on this as he voiced concern over theses changes.\n. The changes were initially made for the 2.3 change/bug, but they are very compatible with current & previous versions of ruby. And they simplify the code. So I think it could be merge no matter the release status of 2.3.0. \nPS There is also specs for theses methods in spec/money/formatting_specs.rb and they still run good.\n. Yeah not a bad idea to bump major version as it does change the API for anyone using <=> that would expect a raise on inappropriate comparaison (it is probably not a very common use case but still possible and could cause major pain).\n. In my app I made a custom helper to deal with this like so (I also think that specific code should be be in the gem itself, or at lest not with a ifcondition that specific) : \n``` ruby\n  def money_format(amount, currency = nil, options = {})\n    # This is just some defaults for my app \n    money_options = {\n      no_cents_if_whole: true,\n      display_free: I18n.t('free')\n    }.merge(options)\n# Overwrite Money symbol position for some locales (what you want)\ni18n_position = I18n.t(\"number.currency.format.#{currency.upcase}.symbol_position\",\n    fallback: [], default: '')\nmoney_options[:symbol_position] = i18n_position.to_sym if i18n_position.present?\n\nMoney.new(amount, currency).format(money_options)\n\nend\n```\nAnd my i18n files looks like so : \nyml\nfr:\n  number:\n    currency:\n      name:\n        USD: \"Dollar des \u00c9tats-Unis\"\n        CAD: \"Dollar Canadien\"\n      format:\n        delimiter: \"\u00a0\"\n        separator: \",\"\n        CAD:\n          symbol_position: \"after\"\n        EUR:\n          symbol_position: \"after\"\nThis way I can have custom position format based on currency and locale.\n. I honestly do not really get what is wrong with defining the i18n methods the way it was, but it does create an issue on ruby 2.3 : it seems they are private (maybe because they are defined on the Formatting module, not the base class itself?) :\n8) Money formatting with i18n with number.format.* should use '.' as the thousands separator\n     Failure/Error: expect(money.thousands_separator).to eq '.'\n     NoMethodError:\n       private method `thousands_separator' called for #<Money fractional:0 currency:USD>\n     # ./spec/money/formatting_spec.rb:68:in `block (4 levels) in <top (required)>'\nSee #578 for an other solution which I think would be cleaner. \n. There is an image on RVM, it is named ruby-2.3.0-preview1 (I think you have to provide the full name otherwise it won't install a preview version).\nMoving methods definition outside the included block to the module directly as you suggested does fix the issue too (and I agree it is cleaner than my suggestion in #578). Sorry for this, at my first look of your exemple, I didn't exactly got what you suggested.\nThinking about it, maybe the ideal solution would be to transform those 2 methods into regular module methods & use a private method to avoid duplication of code? Names of the methods are not dynamic, so defining them dynamically is not totally required.\n``` ruby\n    def thousands_separator\n      i18n_format_for(:thousands_separator, :delimiter, \",\")\n    end\ndef decimal_mark\n  i18n_format_for(:decimal_mark, :separator, \".\")\nend\n\nalias_method :delimiter, :thousands_separator\nalias_method :separator, :decimal_mark\n\n\nprivate\n\ndef i18n_format_for(method, name, character)\n  if self.class.use_i18n\n    begin\n      I18n.t name, :scope => \"number.currency.format\", :raise => true\n    rescue I18n::MissingTranslationData\n      I18n.t name, :scope =>\"number.format\", :default => (currency.send(method) || character)\n    end\n  else\n    currency.send(method) || character\n  end\nend\n\n``\n. Cool thanks! If you get to install 2.3.0 maybe you can look into the remaining arithmetic issues which would be easier to fix with better knowledge of the code. There is now only 5 failing tests on ruby 2.3.\n. [ruby-2-3-0-preview2](https://www.ruby-lang.org/en/news/2015/12/11/ruby-2-3-0-preview2-released/) was released an the private method bug [is fixed](https://bugs.ruby-lang.org/issues/11754), but there is still aTypeErrorwith the money exchangeexchange_with` method in the specs with ruby 2.3. \nI haven't investigated this issue, it seems a bit complex.\n. The issue with the TypeError seems to be that in 2.3 the arithmetic == is using Money Arithmetic <=> rather than eql? when two objects aren't of the same type. Which raise a TypeError in our case. I have try to reproduce the issue with a simple class & module example but I could not.\nThis backtrace might be a place to start, it reports the following, which is very weird :\nBacktrace:\n--\nmoney/lib/money/money/arithmetic.rb:66:in `<=>'\ngems/ruby-2.3.0-preview2/gems/rspec-expectations-3.4.0/lib/rspec/matchers/built_in/eq.rb:35:in `=='\ngems/ruby-2.3.0-preview2/gems/rspec-expectations-3.4.0/lib/rspec/matchers/built_in/eq.rb:35:in `match'\nI still have no clue why ruby money <=> method is invoked when the actual rspec matcher code is : \nruby\n  # rspec-expectations-3.4.0/lib/rspec/matchers/built_in/eq.rb\n  def match(expected, actual)\n    actual == expected\n   end\n. Forget the last comment, I got what is wrong, it was already doing this in ruby 2.2 but a deprecation warning was there : \nlib/rspec/matchers/built_in/eq.rb:35: warning: Comparable#== will no more rescue exceptions of #<=> in the next release.\n/lib/rspec/matchers/built_in/eq.rb:35: warning: Return nil in #<=> if the comparison is inappropriate or avoid such comparison\nSo I guess we should update <=> to return nil as suggest I update specs accordingly. \n. Pending Ruby 2.3.0 release and/or update on Ruby Bug #11754\n. The ruby 2.3 bug was fixed, but I still think the it would be cleaner with two real methods + a private method as suggest in this pull request, rather than using meta programming to define only two methods. Up to you to decide what you prefer, no hard feelings! :+1: \n. I would like to have @printercu input on this as he voiced concern over theses changes.\n. The changes were initially made for the 2.3 change/bug, but they are very compatible with current & previous versions of ruby. And they simplify the code. So I think it could be merge no matter the release status of 2.3.0. \nPS There is also specs for theses methods in spec/money/formatting_specs.rb and they still run good.\n. Yeah not a bad idea to bump major version as it does change the API for anyone using <=> that would expect a raise on inappropriate comparaison (it is probably not a very common use case but still possible and could cause major pain).\n. In my app I made a custom helper to deal with this like so (I also think that specific code should be be in the gem itself, or at lest not with a ifcondition that specific) : \n``` ruby\n  def money_format(amount, currency = nil, options = {})\n    # This is just some defaults for my app \n    money_options = {\n      no_cents_if_whole: true,\n      display_free: I18n.t('free')\n    }.merge(options)\n# Overwrite Money symbol position for some locales (what you want)\ni18n_position = I18n.t(\"number.currency.format.#{currency.upcase}.symbol_position\",\n    fallback: [], default: '')\nmoney_options[:symbol_position] = i18n_position.to_sym if i18n_position.present?\n\nMoney.new(amount, currency).format(money_options)\n\nend\n```\nAnd my i18n files looks like so : \nyml\nfr:\n  number:\n    currency:\n      name:\n        USD: \"Dollar des \u00c9tats-Unis\"\n        CAD: \"Dollar Canadien\"\n      format:\n        delimiter: \"\u00a0\"\n        separator: \",\"\n        CAD:\n          symbol_position: \"after\"\n        EUR:\n          symbol_position: \"after\"\nThis way I can have custom position format based on currency and locale.\n. ",
    "joekur": "Ah good suggestion, thanks :)\n. Ah good suggestion, thanks :)\n. ",
    "paulkoegel": "you're very welcome :)\n. you're very welcome :)\n. ",
    "yltsrc": "if you want I can write some tests for this case, but not sure if I should\n. thanks for merges! \ud83c\udf89\nthere are a lot of changes which are not released yet, do you plan to publish new release on rubygems?\n. if you want I can write some tests for this case, but not sure if I should\n. thanks for merges! \ud83c\udf89\nthere are a lot of changes which are not released yet, do you plan to publish new release on rubygems?\n. ",
    "HaleTom": "Closed with commit 4a3c6da3584530226d23bc2c33dc0226096f5c74\n. @semmons99 perhaps you could answer this?\nI think we should either have the code do what it looks like it intends to do, or remove the statement of intent. I'm not fussed either way.\n. @printercu, thanks for the specificity - yes, that's the one.\n. My bad - I got the two confused.\n. For now (and backward compatibility) how about:\nruby\nalias :code :iso_code\nand defining is_iso? as you had it?\nShall I make a PR? (it would otherwise be my first non-trivial commit with the docs and spec)\n. Ah. I see... #code actually returns a currency symbol in the usual case.\nHmmm.\n. @RubyMoney/money-devs is there any reason NOT to change iso_numeric's type (string => [int|null]) in json files?\n. I take it that there is no option other than rolling my own with sprintf. Happy to be corrected though!\nClosing.\n. It does sound a lot like a code_position: being :before or :after to match :symbol_position.\nI don't feel moved to update the code given the work-around, but I will update the README after 3 days (Merry Festivus!) unless someone else pipes up and takes on the code change.\n. Closed with 9dc6dba011da3a0854bdb3075ca05a6bfac84419\n. There was one other item I'm aware of which was waiting for a major version bump. \n.code actually returns a currency symbol, unless the symbol is not defined, in which case it returns a code string like 'USD'.\ndef code\n      symbol || iso_code\n    end\nThis is counter-intuitive, but fixing it will probably break legacy code, hence waiting for a major version bump.\n- [ ]  Have .code actually return the currency code (eg 'USD')\n.symbol will continue to return the symbol, eg '$' for USD.\nSupport for non-ISO currencies:\n.iso_code doesn't make sense for BTC and other user-defined non-ISO currencies\n- [ ] Rename .iso_code to be just .code\n- [ ] Keep .iso_code as an alias for .code for backwards compatibility\n- [ ] Implement is_iso? to distinguish between the ISO and non-ISO currencies\nSee Issue #598 for background on all the above.\nThe main one which requires the version bump is .code actually returning a currency code, possibly breaking existing other client code.\nI'd be happy to code this up if the consensus is a GO.\n. Cheers! You're on fire!\n. Closed with commit 4a3c6da3584530226d23bc2c33dc0226096f5c74\n. @semmons99 perhaps you could answer this?\nI think we should either have the code do what it looks like it intends to do, or remove the statement of intent. I'm not fussed either way.\n. @printercu, thanks for the specificity - yes, that's the one.\n. My bad - I got the two confused.\n. For now (and backward compatibility) how about:\nruby\nalias :code :iso_code\nand defining is_iso? as you had it?\nShall I make a PR? (it would otherwise be my first non-trivial commit with the docs and spec)\n. Ah. I see... #code actually returns a currency symbol in the usual case.\nHmmm.\n. @RubyMoney/money-devs is there any reason NOT to change iso_numeric's type (string => [int|null]) in json files?\n. I take it that there is no option other than rolling my own with sprintf. Happy to be corrected though!\nClosing.\n. It does sound a lot like a code_position: being :before or :after to match :symbol_position.\nI don't feel moved to update the code given the work-around, but I will update the README after 3 days (Merry Festivus!) unless someone else pipes up and takes on the code change.\n. Closed with 9dc6dba011da3a0854bdb3075ca05a6bfac84419\n. There was one other item I'm aware of which was waiting for a major version bump. \n.code actually returns a currency symbol, unless the symbol is not defined, in which case it returns a code string like 'USD'.\ndef code\n      symbol || iso_code\n    end\nThis is counter-intuitive, but fixing it will probably break legacy code, hence waiting for a major version bump.\n- [ ]  Have .code actually return the currency code (eg 'USD')\n.symbol will continue to return the symbol, eg '$' for USD.\nSupport for non-ISO currencies:\n.iso_code doesn't make sense for BTC and other user-defined non-ISO currencies\n- [ ] Rename .iso_code to be just .code\n- [ ] Keep .iso_code as an alias for .code for backwards compatibility\n- [ ] Implement is_iso? to distinguish between the ISO and non-ISO currencies\nSee Issue #598 for background on all the above.\nThe main one which requires the version bump is .code actually returning a currency code, possibly breaking existing other client code.\nI'd be happy to code this up if the consensus is a GO.\n. Cheers! You're on fire!\n. ",
    "ReadmeCritic": "@seongreen updated\n. :tada: \n. @seongreen updated\n. :tada: \n. ",
    "danielricecodes": "@HaleTom - are you defining BTC and LTC as their own custom currencies?  You can register a custom currency and in the case of BTC, give it 8 decimal places for cents.  \nruby\n  config.register_currency = {\n    :priority            => 1,\n    :iso_code            => :btc,\n    :name                => \"Bitcoin\",\n    :symbol              => \"BTC\", #or an existing character like, \u0243\n    :symbol_first        => true,\n    :subunit             => \"Satoshi\",\n    :subunit_to_unit     => 10_000_000,\n    :thousands_separator => \",\",\n    :decimal_mark        => \".\"\n  }\nIf you wanted to convert currency, say USD to BTC, you'd just have to hard code a pegged rate\nruby\n  config.add_rate \"USD\", \"BTC\", 1.2 #represents 120%, or 1 USD = 1.2 BTC.\n  config.add_rate \"BTC\", \"USD\", 0.8 #represents 80%, or 1 BTC = 0.8 USD.\nOr you can wire up your own live exchange using Money::Bank.  The https://github.com/RubyMoney/google_currency project might support BTC, but I did not verify.  . @kernow - This is a classic rounding loss scenario.  Anytime you multiple or divide Money objects, ESPECIALLY with odd dollar or cent values or decimal rate factors (APRs, Yields, etc...) you can encounter loss of precision.  To avoid this, you have to add room on your Money objects for the fractional cents (i.e. subcents).  I've done this in the past by defining a custom currency with room for 8 subcents as opposed to the usual 2.  \n```ruby\n  config.register_currency = {\n    :priority            => 1,\n    :iso_code            => :us8,\n    :name                => \"US Dollar with subunit of 8 digits\",\n    :symbol              => \"$\",\n    :symbol_first        => true,\n    :subunit             => \"Subcent\",\n    :subunit_to_unit     => 100000000,\n    :thousands_separator => \",\",\n    :decimal_mark        => \".\"\n  }\nconfig.add_rate \"USD\", \"US8\", 1\n  config.add_rate \"US8\", \"USD\", 1\n```\nThe pegged 1:1 exchange rate is key.  This is how you round off the fractional cents at the end to get to the value you're looking for.   \nruby\n  204.87.to_money(:us8) + (204.87.to_money(:us8)/100) * 22.4\nResults in a precise value #<Money fractional:25076088000 currency:US8>\nIn order to get the rounded value, exchange back to your base currency.\nruby\n  precise_value.exchange_to(:usd)\n=> #<Money fractional:25076 currency:USD>\nIn short, this isn't a bug.  money makes no assumptions about how to round.  If you need this level of precision, I recommend defining a custom currency to carry the fractional cents.\n@antstorm - I think I've answered this completely and you can close this issue?. @HaleTom - are you defining BTC and LTC as their own custom currencies?  You can register a custom currency and in the case of BTC, give it 8 decimal places for cents.  \nruby\n  config.register_currency = {\n    :priority            => 1,\n    :iso_code            => :btc,\n    :name                => \"Bitcoin\",\n    :symbol              => \"BTC\", #or an existing character like, \u0243\n    :symbol_first        => true,\n    :subunit             => \"Satoshi\",\n    :subunit_to_unit     => 10_000_000,\n    :thousands_separator => \",\",\n    :decimal_mark        => \".\"\n  }\nIf you wanted to convert currency, say USD to BTC, you'd just have to hard code a pegged rate\nruby\n  config.add_rate \"USD\", \"BTC\", 1.2 #represents 120%, or 1 USD = 1.2 BTC.\n  config.add_rate \"BTC\", \"USD\", 0.8 #represents 80%, or 1 BTC = 0.8 USD.\nOr you can wire up your own live exchange using Money::Bank.  The https://github.com/RubyMoney/google_currency project might support BTC, but I did not verify.  . @kernow - This is a classic rounding loss scenario.  Anytime you multiple or divide Money objects, ESPECIALLY with odd dollar or cent values or decimal rate factors (APRs, Yields, etc...) you can encounter loss of precision.  To avoid this, you have to add room on your Money objects for the fractional cents (i.e. subcents).  I've done this in the past by defining a custom currency with room for 8 subcents as opposed to the usual 2.  \n```ruby\n  config.register_currency = {\n    :priority            => 1,\n    :iso_code            => :us8,\n    :name                => \"US Dollar with subunit of 8 digits\",\n    :symbol              => \"$\",\n    :symbol_first        => true,\n    :subunit             => \"Subcent\",\n    :subunit_to_unit     => 100000000,\n    :thousands_separator => \",\",\n    :decimal_mark        => \".\"\n  }\nconfig.add_rate \"USD\", \"US8\", 1\n  config.add_rate \"US8\", \"USD\", 1\n```\nThe pegged 1:1 exchange rate is key.  This is how you round off the fractional cents at the end to get to the value you're looking for.   \nruby\n  204.87.to_money(:us8) + (204.87.to_money(:us8)/100) * 22.4\nResults in a precise value #<Money fractional:25076088000 currency:US8>\nIn order to get the rounded value, exchange back to your base currency.\nruby\n  precise_value.exchange_to(:usd)\n=> #<Money fractional:25076 currency:USD>\nIn short, this isn't a bug.  money makes no assumptions about how to round.  If you need this level of precision, I recommend defining a custom currency to carry the fractional cents.\n@antstorm - I think I've answered this completely and you can close this issue?. ",
    "spk": "On jruby the result is 2.9999999999999996 for this spec\n. Does everyone agree with expect(Currency.new(:iqd).exponent).to be_within(0.01).of(3) ?\n. I've update the PR accordingly to the comments and build is green, just one issue with Currency#inspect which is normal I think.\n. \\o/\n. @antstorm yep I will look it up too\n. On jruby the result is 2.9999999999999996 for this spec\n. Does everyone agree with expect(Currency.new(:iqd).exponent).to be_within(0.01).of(3) ?\n. I've update the PR accordingly to the comments and build is green, just one issue with Currency#inspect which is normal I think.\n. \\o/\n. @antstorm yep I will look it up too\n. ",
    "evheny0": "Also, if result of Money.new(10, 'USD') > 1 can be controversially, result of Money.new(10, 'USD') > 0 is clearly defined. So it's must be a check for zero in <=>, like it is in + or -.\n. Ok, #606\n. Also, if result of Money.new(10, 'USD') > 1 can be controversially, result of Money.new(10, 'USD') > 0 is clearly defined. So it's must be a check for zero in <=>, like it is in + or -.\n. Ok, #606\n. ",
    "Saicheg": "+1 for this, having same issue here with new version of gem. \n@semmons99 is there any reason why we can't do self.money > 0 ?\n. my opinion here is that we should follow ruby-way and make it less surprising for future developers. it feels really intuitive to write some_money_field > 0. I am agree that in cases where it's not a zero - good to throw an error, but 0 is 0 everywhere for every currency. \n. +1 for this, having same issue here with new version of gem. \n@semmons99 is there any reason why we can't do self.money > 0 ?\n. my opinion here is that we should follow ruby-way and make it less surprising for future developers. it feels really intuitive to write some_money_field > 0. I am agree that in cases where it's not a zero - good to throw an error, but 0 is 0 everywhere for every currency. \n. ",
    "bryanrite": "I've tried out the master branch with #607 merged and the ability to smartly coerce seems to work well in our app.  One issue I had was with equality... it technically makes sense, but its a bit dangerous, especially for people upgrading their money version.\nFor example:\n``` ruby\n\n0.to_money == 0\n=> true\n1.to_money >= 0\n=> true\n1.to_money >= 1\nArgumentError: comparison of Money with 1 failed\n1.to_money == 1\n=> false # Expected an ArgumentError here.\n```\n\nIt might be safer to raise an ArgumentError for equality if the compared numeric is not zero, much like the other comparatives (>=) do, rather than return the boolean?\nThoughts?\n. Fantastic, I'll test again once you've pushed the changes. :smile:\n. Yah, I thought about that a lot too. Like I said, its technically true that 1.to_money != 1 but I think that when people are comparing money to numerics, its more likely to be surprising and cause issues than be technically correct.\nIt makes a lot of sense to me that 1.to_money == [] #=> false or comparing Money to anything else returns a boolean but for Integers, Floats, BigDecimals, it might be safer to raise an exception rather than return false as there is a cognitive connection between Money and Numbers and if they're not explicit, could be kinda dangerous, especially when money is concerned?\nWhat if we just raised when comparing equality vs. numeric types?\n. I guess messing with equality for certain cases is messy and could cause some weird behaviour. It seems non-intuitive but is more consistent.\n. I've tried out the master branch with #607 merged and the ability to smartly coerce seems to work well in our app.  One issue I had was with equality... it technically makes sense, but its a bit dangerous, especially for people upgrading their money version.\nFor example:\n``` ruby\n\n0.to_money == 0\n=> true\n1.to_money >= 0\n=> true\n1.to_money >= 1\nArgumentError: comparison of Money with 1 failed\n1.to_money == 1\n=> false # Expected an ArgumentError here.\n```\n\nIt might be safer to raise an ArgumentError for equality if the compared numeric is not zero, much like the other comparatives (>=) do, rather than return the boolean?\nThoughts?\n. Fantastic, I'll test again once you've pushed the changes. :smile:\n. Yah, I thought about that a lot too. Like I said, its technically true that 1.to_money != 1 but I think that when people are comparing money to numerics, its more likely to be surprising and cause issues than be technically correct.\nIt makes a lot of sense to me that 1.to_money == [] #=> false or comparing Money to anything else returns a boolean but for Integers, Floats, BigDecimals, it might be safer to raise an exception rather than return false as there is a cognitive connection between Money and Numbers and if they're not explicit, could be kinda dangerous, especially when money is concerned?\nWhat if we just raised when comparing equality vs. numeric types?\n. I guess messing with equality for certain cases is messy and could cause some weird behaviour. It seems non-intuitive but is more consistent.\n. ",
    "kayzee": "@antstorm any idea when a new version will be released?  I upgraded my gems and now my app is broken. :S\n. @antstorm any idea when a new version will be released?  I upgraded my gems and now my app is broken. :S\n. ",
    "kernow": "Any idea when this fix is going to be released as a gem?\n. Thanks @antstorm \n. @ct-clearhaus sorry, they should all be 100.0 in the original message, I have updated it. The issue is still the same regardless. Money.new(20487)/100.0 results in #<Money fractional:205 currency:GBP>. We have moved to doing all of our calculations on cents values and only creating Money objects once all calculations have been performed.. @antstorm our app has very few situations where a calculation can result in a part of a cent but we are rounding those calculations as needed. Working in cents everywhere is far easier than using decimals in my experience. We now only really convert to dollars.cents when we need to display something to the user and a couple of other situations.. Any idea when this fix is going to be released as a gem?\n. Thanks @antstorm \n. @ct-clearhaus sorry, they should all be 100.0 in the original message, I have updated it. The issue is still the same regardless. Money.new(20487)/100.0 results in #<Money fractional:205 currency:GBP>. We have moved to doing all of our calculations on cents values and only creating Money objects once all calculations have been performed.. @antstorm our app has very few situations where a calculation can result in a part of a cent but we are rounding those calculations as needed. Working in cents everywhere is far easier than using decimals in my experience. We now only really convert to dollars.cents when we need to display something to the user and a couple of other situations.. ",
    "cade": "forgot to add [ci skip] sorry about that :disappointed:\n. > I'd suggest splitting each test into 2 separate ones, because they kinda handle different cases\n:+1: Sounds good.\n\nwhy the decimal mark isn't used in ISK example? Shouldn't that be 300.000,00?\n\nI'm not sure which instance(s) you're referring to, but ISK doesn't use cents, so it shouldn't be 300.000,00 in any of the stated cases. (Only time that decimal comes into play for ISK is with infinite_precision turned on.)\n. > got it, my mistake, wasn't familiar with the \"ISK\" currency\nNo worries. I wasn't either until a customer wrote in and told me the formatting was wrong! :smile: \n\nCan you please squash your commits \n\nSquashed!\n. > Btw, can you please use your own fork in the future, thanks!\nSure thing. Mind if I ask why? Not sure why I have commit access then?\n. > it's a good practice\nNot trying to be difficult -- genuinely trying to learn something new. You mention that it's good practice twice, but you didn't tell me what makes it a good practice.\nI definitely don't mind keeping PRs on my own branches, but I'm curious what makes it a good practice. We have open source repos at work that we PR directly from with commit access. If there's demonstrable benefit to always PRing from separate forks, I'd be interested in learning what those are and presenting those benefits to my co-workers. :heart: \n. Thanks for the feedback, @printercu and @antstorm!\n. forgot to add [ci skip] sorry about that :disappointed:\n. > I'd suggest splitting each test into 2 separate ones, because they kinda handle different cases\n:+1: Sounds good.\n\nwhy the decimal mark isn't used in ISK example? Shouldn't that be 300.000,00?\n\nI'm not sure which instance(s) you're referring to, but ISK doesn't use cents, so it shouldn't be 300.000,00 in any of the stated cases. (Only time that decimal comes into play for ISK is with infinite_precision turned on.)\n. > got it, my mistake, wasn't familiar with the \"ISK\" currency\nNo worries. I wasn't either until a customer wrote in and told me the formatting was wrong! :smile: \n\nCan you please squash your commits \n\nSquashed!\n. > Btw, can you please use your own fork in the future, thanks!\nSure thing. Mind if I ask why? Not sure why I have commit access then?\n. > it's a good practice\nNot trying to be difficult -- genuinely trying to learn something new. You mention that it's good practice twice, but you didn't tell me what makes it a good practice.\nI definitely don't mind keeping PRs on my own branches, but I'm curious what makes it a good practice. We have open source repos at work that we PR directly from with commit access. If there's demonstrable benefit to always PRing from separate forks, I'd be interested in learning what those are and presenting those benefits to my co-workers. :heart: \n. Thanks for the feedback, @printercu and @antstorm!\n. ",
    "we138": "https://github.com/RubyMoney/money/pull/643\n. :boom:\n. @antstorm done! \n. https://github.com/RubyMoney/money/pull/643\n. :boom:\n. @antstorm done! \n. ",
    "xxswingxx": "Yes seems a behavior designed on purpose,  but why are not the integer and decimal parts kept? If I enter 234 cents, I expect the amount to be 2.34 not 234 or 0.0243. It's a bit counterintuitive as I have no idea of what is happening. Maybe I'm missing something and CLF hasn't the usual concept of \"cents\" \u2026\n. Thanks for the article, seems pretty clear now. I've been always living in a world with cents and now\u2026mindblown\n. Yes seems a behavior designed on purpose,  but why are not the integer and decimal parts kept? If I enter 234 cents, I expect the amount to be 2.34 not 234 or 0.0243. It's a bit counterintuitive as I have no idea of what is happening. Maybe I'm missing something and CLF hasn't the usual concept of \"cents\" \u2026\n. Thanks for the article, seems pretty clear now. I've been always living in a world with cents and now\u2026mindblown\n. ",
    "deepredsky": "agree with @printercu, does not seem to be a good idea to build up localize_formatting_rules like so. \n. I think this is much better handling of localised currency formatting rather than putting them into the library. The default formatting for JPY when using :ja locale has been done by building up localize_formatting_rules. This limits the formatting option.\nFor example. if for some reason i want to display \u00a5 instead of \u5186, i can't do that anymore because of hardcoded localisation rule in there. Might be a better idea to extract that out or make it overwritable.\n. agree with @printercu, does not seem to be a good idea to build up localize_formatting_rules like so. \n. I think this is much better handling of localised currency formatting rather than putting them into the library. The default formatting for JPY when using :ja locale has been done by building up localize_formatting_rules. This limits the formatting option.\nFor example. if for some reason i want to display \u00a5 instead of \u5186, i can't do that anymore because of hardcoded localisation rule in there. Might be a better idea to extract that out or make it overwritable.\n. ",
    "otagi": "I believe putting the symbol at the end is true for all French localizations, not only Canadian.\nAlso, it would be wonderful if the existing number_to_currency localization was used for that. (i.e. fr.number.currency.format.format: \"%n %u\").\n. I believe putting the symbol at the end is true for all French localizations, not only Canadian.\nAlso, it would be wonderful if the existing number_to_currency localization was used for that. (i.e. fr.number.currency.format.format: \"%n %u\").\n. ",
    "dmitry": "@printercu please ask @semmons99 to be one of the maintainers: https://github.com/RubyMoney/money/issues/628 Would be really great to see all your changes in the main repo as well!. Someone before already tried to provide such functionality: https://github.com/RubyMoney/money/issues/300\nI really :+1: for this feature in a Money core, as an exchange rates are always changing and there should be mechanism to retrieve them.\n. @printercu please ask @semmons99 to be one of the maintainers: https://github.com/RubyMoney/money/issues/628 Would be really great to see all your changes in the main repo as well!. Someone before already tried to provide such functionality: https://github.com/RubyMoney/money/issues/300\nI really :+1: for this feature in a Money core, as an exchange rates are always changing and there should be mechanism to retrieve them.\n. ",
    "bdewater": "Wondering if there's any progress on this, I'm liking these changes a lot!. Wondering if there's any progress on this, I'm liking these changes a lot!. ",
    "NGMarmaduke": "The second example should return a EUR amount; due to \u00a30 and \u20ac0 being equal. A zero money object should not have an explicit currency and should be considered to be any currency value\n. @printercu maybe when Money.disallow_currency_conversion! is set raising an error on both cases should be the behavour\n. The second example should return a EUR amount; due to \u00a30 and \u20ac0 being equal. A zero money object should not have an explicit currency and should be considered to be any currency value\n. @printercu maybe when Money.disallow_currency_conversion! is set raising an error on both cases should be the behavour\n. ",
    "textgoeshere": "Given a bank with eur to gbp and gbp to eur rates, this is what happens:\n```\nMoney.new(1, \"EUR\") + Money.new(0, \"GBP\")\n=> #\nMoney.new(1, \"EUR\") + Money.new(1, \"GBP\")\n=> Money::Bank::DifferentCurrencyError: No exchanging of currencies allowed: \n0.01 GBP to EUR\n```\nIMO either neither should raise an error, or both should.\nThe first option would change the way Money::Arithmetic#+ implicitly exchanges to the receiver object's currency. That's problematic, too, but bigger issue.\nSo for consistency and simplicity, I think the zero check here lib/money/money/arithmetic.rb#L111 should attempt conversion via exchange_to.\n. Given a bank with eur to gbp and gbp to eur rates, this is what happens:\n```\nMoney.new(1, \"EUR\") + Money.new(0, \"GBP\")\n=> #\nMoney.new(1, \"EUR\") + Money.new(1, \"GBP\")\n=> Money::Bank::DifferentCurrencyError: No exchanging of currencies allowed: \n0.01 GBP to EUR\n```\nIMO either neither should raise an error, or both should.\nThe first option would change the way Money::Arithmetic#+ implicitly exchanges to the receiver object's currency. That's problematic, too, but bigger issue.\nSo for consistency and simplicity, I think the zero check here lib/money/money/arithmetic.rb#L111 should attempt conversion via exchange_to.\n. ",
    "invidian": "Ah, now I can see, that link redirects me to my browser's proffered language and there is 404. Original link works. I'm sorry for rising an issue then!\n. Ah, now I can see, that link redirects me to my browser's proffered language and there is 404. Original link works. I'm sorry for rising an issue then!\n. ",
    "victormartinezsimon": "First of all, thanks for your answers.\nThis happen for any amount, the 1 was an example.\nLooking for the first page that @printercu  says (https://www.google.com/finance/converter?a=1&from=vnd&to=usd) it allways return a fail, so maybe is a google error.\n. First of all, thanks for your answers.\nThis happen for any amount, the 1 was an example.\nLooking for the first page that @printercu  says (https://www.google.com/finance/converter?a=1&from=vnd&to=usd) it allways return a fail, so maybe is a google error.\n. ",
    "ajahongir": "@antstorm thanks for help. done\n. @antstorm actually it should :+1:  I thought utf8 doesn't support but it does \n. done :100: \n. @antstorm thanks for help. done\n. @antstorm actually it should :+1:  I thought utf8 doesn't support but it does \n. done :100: \n. ",
    "samstickland": "Sorry, just found this in the API documentation:\nMoney.rounding_mode = BigDecimal::ROUND_DOWN\n. Yup, thanks the reply though!\nI also found infinite_precision which I think might actually be a better solution to my problem.\nAre there still potential rounding problems with BigDecimal and infinite_precision that I should be aware of, or is BigDecimal's precision better than float?\nInitially this looks like this is a problem:\n```\nrequire 'bigdecimal'\nrequire 'bigdecimal/util'\n\na = 1.0.to_d/3\n=> #\na * 3\n=> #\n```\n\nBut conversion to float gives a whole number:\n```\n\n(a * 3).to_f\n=> 1.0\n```\n. Sorry, just found this in the API documentation:\n\nMoney.rounding_mode = BigDecimal::ROUND_DOWN\n. Yup, thanks the reply though!\nI also found infinite_precision which I think might actually be a better solution to my problem.\nAre there still potential rounding problems with BigDecimal and infinite_precision that I should be aware of, or is BigDecimal's precision better than float?\nInitially this looks like this is a problem:\n```\nrequire 'bigdecimal'\nrequire 'bigdecimal/util'\n\na = 1.0.to_d/3\n=> #\na * 3\n=> #\n```\n\nBut conversion to float gives a whole number:\n```\n\n(a * 3).to_f\n=> 1.0\n```\n. \n",
    "rubemz": "@antstorm thanks for your quick feedback! \nI'm using an old version of this gem (6.1.1) which has no caching at Currency initialization. I will close this PR and I will try to update the gem version to the latest.\n. @antstorm thanks for your quick feedback! \nI'm using an old version of this gem (6.1.1) which has no caching at Currency initialization. I will close this PR and I will try to update the gem version to the latest.\n. ",
    "chargio": "It would be great to update the LICENSE file to reflect so...\n. It would be great to update the LICENSE file to reflect so...\n. ",
    "naps62": "@antstorm yes, I'll consider that, thanks. This is just what I came up with in about an hour, since I needed this ASAP\n. @antstorm yes, I'll consider that, thanks. This is just what I came up with in about an hour, since I needed this ASAP\n. ",
    "mcnelson": "I had to dig for this issue to understand that thousands_separator is based on I18n locale. I think that's fine, but either I'm blind or that little detail is not documented anywhere.\nBtw, setting it in Money.default_formatting_rules works, but that would be the bulldozer approach.\n. Are you suggesting to set the separator in I18n rather than Money.default_formatting_rules? If so, yes, that's a great place for it.\n. But setting it in an I18n language file is also the bulldozer approach, right? The docs say:\n\nIf you want thousands seperator and decimal mark to be same across all currencies\n\nFrom what I can tell, Ruby Money has a table of currencies that each know their own thouands_separator. But, in order for the format method to use the correct thousands_separator for the given currency, it all depends on I18n.locale.\nI was just suggesting to add that to the documentation.\n. Ah, yes, totally makes sense. Is there another thread somewhere discussing this?\n. I had to dig for this issue to understand that thousands_separator is based on I18n locale. I think that's fine, but either I'm blind or that little detail is not documented anywhere.\nBtw, setting it in Money.default_formatting_rules works, but that would be the bulldozer approach.\n. Are you suggesting to set the separator in I18n rather than Money.default_formatting_rules? If so, yes, that's a great place for it.\n. But setting it in an I18n language file is also the bulldozer approach, right? The docs say:\n\nIf you want thousands seperator and decimal mark to be same across all currencies\n\nFrom what I can tell, Ruby Money has a table of currencies that each know their own thouands_separator. But, in order for the format method to use the correct thousands_separator for the given currency, it all depends on I18n.locale.\nI was just suggesting to add that to the documentation.\n. Ah, yes, totally makes sense. Is there another thread somewhere discussing this?\n. ",
    "prokopsimek": "Thousand separator is not possible to redefine in yaml as described in readme.\n```\nconfig/locale/cs.yml\ncs:\n  number:\n    format:\n      delimiter: \",\"\n      separator: ' '\n  # or\n  number:\n    currency:\n      format:\n        delimiter: \",\"\n        separator: ' '\n```\nnor\ncs:\n  currency:\n    format:\n      separator: ' '\nneed to do it in method:\nhumanized_money_with_symbol(\n      money_object,\n      translate: true,\n      display_free: t('money.free'),\n      thousands_separator: t('number.currency.format.delimiter')\n    ). No, it\u00b4s not by default? Why?\nSent from my iPhone\n\nOn 25 Nov 2016, at 23:15, Anthony Dmitriyev notifications@github.com wrote:\n@prokopsimek do you have use_i18n enabled?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @antstorm thx, really hard work \ud83d\ude04 . Thousand separator is not possible to redefine in yaml as described in readme.\n\n```\nconfig/locale/cs.yml\ncs:\n  number:\n    format:\n      delimiter: \",\"\n      separator: ' '\n  # or\n  number:\n    currency:\n      format:\n        delimiter: \",\"\n        separator: ' '\n```\nnor\ncs:\n  currency:\n    format:\n      separator: ' '\nneed to do it in method:\nhumanized_money_with_symbol(\n      money_object,\n      translate: true,\n      display_free: t('money.free'),\n      thousands_separator: t('number.currency.format.delimiter')\n    ). No, it\u00b4s not by default? Why?\nSent from my iPhone\n\nOn 25 Nov 2016, at 23:15, Anthony Dmitriyev notifications@github.com wrote:\n@prokopsimek do you have use_i18n enabled?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @antstorm thx, really hard work \ud83d\ude04 . \n",
    "jdatti": "Thank You so much @antstorm \n. Thank You so much @antstorm \n. ",
    "MiguelBel": "@antstorm done!\n. @antstorm done!\n. ",
    "alexdunae": "@antstorm unbelievable - I hadn't even had time to clone the repo and start investigating.  You're a legend!\n. I wasn't aware of .positive? -- that would definitely work in my use case. \nI just assumed Money.zero would be currency-insensitive, since zero is the same everywhere.  It took a bit of time to figure out it was currency mismatch.  Not a huge issue in the end.\n. @antstorm unbelievable - I hadn't even had time to clone the repo and start investigating.  You're a legend!\n. I wasn't aware of .positive? -- that would definitely work in my use case. \nI just assumed Money.zero would be currency-insensitive, since zero is the same everywhere.  It took a bit of time to figure out it was currency mismatch.  Not a huge issue in the end.\n. ",
    "spalenza": "No problemas @antstorm.\nExcelente! I searched this method but I don't found.\nThanks. \ud83d\ude04 \n. No problemas @antstorm.\nExcelente! I searched this method but I don't found.\nThanks. \ud83d\ude04 \n. ",
    "kaspernj": "Would this be something you guys would be interested in? The idea is to have variable exchange rates based on exchange rate dates.\n. @antstorm To my great disappointment this doesn't seem to be possible with Google Currency based on my research of the following page, which the google-currency gem seems to be based upon:\nhttps://www.google.com/finance/converter?a=1&from=EUR&to=DKK\nhttps://github.com/RubyMoney/google_currency/blob/master/lib/money/bank/google_currency.rb#L147\nIt looks like it would be possible with this API however:\nhttp://fixer.io/\nThe requirement would be, that whatever service the user decided to use supports historical data.\n. @antstorm I have been making efforts in order to both keep backwards compatibility and make this optional. I don't really know how I would implement warnings.\nMaybe warn the first time, that someone try to exchange an amount with an exchange date, but where the used bank doesn't support it, and then suppress further warnings to avoid spamming the users log?\n. I will be adding specs, once I get this working. First time working on this code base, so I find it difficult to add tests before beginning to actually code the feature :-/\n. Would this be something you guys would be interested in? The idea is to have variable exchange rates based on exchange rate dates.\n. @antstorm To my great disappointment this doesn't seem to be possible with Google Currency based on my research of the following page, which the google-currency gem seems to be based upon:\nhttps://www.google.com/finance/converter?a=1&from=EUR&to=DKK\nhttps://github.com/RubyMoney/google_currency/blob/master/lib/money/bank/google_currency.rb#L147\nIt looks like it would be possible with this API however:\nhttp://fixer.io/\nThe requirement would be, that whatever service the user decided to use supports historical data.\n. @antstorm I have been making efforts in order to both keep backwards compatibility and make this optional. I don't really know how I would implement warnings.\nMaybe warn the first time, that someone try to exchange an amount with an exchange date, but where the used bank doesn't support it, and then suppress further warnings to avoid spamming the users log?\n. I will be adding specs, once I get this working. First time working on this code base, so I find it difficult to add tests before beginning to actually code the feature :-/\n. ",
    "olimart": "@ct-clearhaus Thank you very much. So obvious that I missed it.\n. @ct-clearhaus Thank you very much. So obvious that I missed it.\n. ",
    "project-eutopia": "This PR, if merged, would also obviate the need for this line in money-rails:\nruby\noptions.delete(:symbol) if options[:disambiguate]\n. @antstorm Thank you for taking the time to review and consider this pull request.\nI now use && as you mention to fall in line with the Ruby style guide, and also updated an extra line that was using and over && in the same method.\nAlso, should the contributing file be updated to no longer mention that one should update the authors file when making a pull request?\nI also noticed that some pull requests include CHANGELOG updates under a ## Next release header.  Should this be done in this PR as well?\n. @antstorm Great!  Thank you for your help.\n. This PR, if merged, would also obviate the need for this line in money-rails:\nruby\noptions.delete(:symbol) if options[:disambiguate]\n. @antstorm Thank you for taking the time to review and consider this pull request.\nI now use && as you mention to fall in line with the Ruby style guide, and also updated an extra line that was using and over && in the same method.\nAlso, should the contributing file be updated to no longer mention that one should update the authors file when making a pull request?\nI also noticed that some pull requests include CHANGELOG updates under a ## Next release header.  Should this be done in this PR as well?\n. @antstorm Great!  Thank you for your help.\n. ",
    "Fryie": "Thanks, disabling i18n will presumably help at least a bit. :). Thanks, disabling i18n will presumably help at least a bit. :). ",
    "tmlee": "@kernow To narrow down the problem, you have the following\n204.87 + (204.87/100.0) * 22.4\nMoney.new(20487).to_f + (Money.new(20487).to_f/100.0) * 22.4\nMoney.new(20487) + (Money.new(20487)/100.0) * 22.4\nThe first part of the arithmetic is probably fine\n204.87 == Money.new(20487).to_f and Money.new(20487) is going to convert correctly\nThe problem seems to occur in the 2nd part. Ignore the * 22.4 for now\n(204.87/100.0)\n(Money.new(20487).to_f/100.0)\n(Money.new(20487)/100.0)\nThe 1st and 2nd both undergo the same calculation, divide as a float\nBut the 3rd, the division is called on the Money object.\nThis means, this is getting called\nhttps://github.com/RubyMoney/money/blob/master/lib/money/money/arithmetic.rb#L178\nBecause a Money object is trying to divide a non Money object. It does the arithmetic and then creates a new Money object in which the rounding occur like @ct-clearhaus described\nIn a way it does not work intuitively base on your example. But i think to be safe is to conduct all arithmetic that is non Money object related inside a single Money instance. That is\n(Money.new(20487/100.0*22.4))\n. @kernow To narrow down the problem, you have the following\n204.87 + (204.87/100.0) * 22.4\nMoney.new(20487).to_f + (Money.new(20487).to_f/100.0) * 22.4\nMoney.new(20487) + (Money.new(20487)/100.0) * 22.4\nThe first part of the arithmetic is probably fine\n204.87 == Money.new(20487).to_f and Money.new(20487) is going to convert correctly\nThe problem seems to occur in the 2nd part. Ignore the * 22.4 for now\n(204.87/100.0)\n(Money.new(20487).to_f/100.0)\n(Money.new(20487)/100.0)\nThe 1st and 2nd both undergo the same calculation, divide as a float\nBut the 3rd, the division is called on the Money object.\nThis means, this is getting called\nhttps://github.com/RubyMoney/money/blob/master/lib/money/money/arithmetic.rb#L178\nBecause a Money object is trying to divide a non Money object. It does the arithmetic and then creates a new Money object in which the rounding occur like @ct-clearhaus described\nIn a way it does not work intuitively base on your example. But i think to be safe is to conduct all arithmetic that is non Money object related inside a single Money instance. That is\n(Money.new(20487/100.0*22.4))\n. ",
    "catalin88": "@antstorm you are right. The issue was coming from the Spree app which uses the Money gem. Thank you!. @antstorm you are right. The issue was coming from the Spree app which uses the Money gem. Thank you!. ",
    "Nerian": "@antstorm Done.. Well, they have been in < 1.0 for more than 7 years \ud83d\ude04  \ni18n is fairly stable; I think there are move advantages to keeping the version constraint relaxed than to keep it fixed. If there happens to be a conflict in the future we can constraint it.\nThoughts?\n. You are perfectly correct. New PR:  https://github.com/RubyMoney/money/pull/729. @antstorm Done.. Well, they have been in < 1.0 for more than 7 years \ud83d\ude04  \ni18n is fairly stable; I think there are move advantages to keeping the version constraint relaxed than to keep it fixed. If there happens to be a conflict in the future we can constraint it.\nThoughts?\n. You are perfectly correct. New PR:  https://github.com/RubyMoney/money/pull/729. ",
    "karthikmuralidharan": "@printercu I meant value from the database returned back as nil. The nil value returned from the data store is app specific. But the gem throws a weird error and does not default to the default currency as explained below:\nPassing nil in the second argument of the Money.from_amount constructor leads to error. \n[2] pry(main)> Money.from_amount(99, nil)\nNoMethodError: undefined method `subunit_to_unit' for nil:NilClass\nfrom /Users/karthik/.rbenv/versions/jruby-1.7.12/lib/ruby/gems/shared/gems/money-6.8.1/lib/money/money.rb:233:in `from_amount'\nThis is not the case with the default constructor method as this edge case has been handled in https://github.com/RubyMoney/money/blob/master/lib/money/money.rb#L261 :\n[1] pry(main)> Money.new(99, nil)\n=> #<Money fractional:99 currency:USD>. @antstorm I have added the test case for it. Thanks \ud83d\ude03 . Actually, I was about to raise a PR that throws an exception for cases where currency_code is provided as nil, but then I saw the previous behaviour and the former spec for Money.new and went with the same pattern for Money.from_amount for consistency purpose.. @printercu I meant value from the database returned back as nil. The nil value returned from the data store is app specific. But the gem throws a weird error and does not default to the default currency as explained below:\nPassing nil in the second argument of the Money.from_amount constructor leads to error. \n[2] pry(main)> Money.from_amount(99, nil)\nNoMethodError: undefined method `subunit_to_unit' for nil:NilClass\nfrom /Users/karthik/.rbenv/versions/jruby-1.7.12/lib/ruby/gems/shared/gems/money-6.8.1/lib/money/money.rb:233:in `from_amount'\nThis is not the case with the default constructor method as this edge case has been handled in https://github.com/RubyMoney/money/blob/master/lib/money/money.rb#L261 :\n[1] pry(main)> Money.new(99, nil)\n=> #<Money fractional:99 currency:USD>. @antstorm I have added the test case for it. Thanks \ud83d\ude03 . Actually, I was about to raise a PR that throws an exception for cases where currency_code is provided as nil, but then I saw the previous behaviour and the former spec for Money.new and went with the same pattern for Money.from_amount for consistency purpose.. ",
    "ricardopacheco": "@antstorm @printercu my bad guys, piece of code was calling a Money method with the wrong amount of arguments.. @antstorm @printercu my bad guys, piece of code was calling a Money method with the wrong amount of arguments.. ",
    "stereobooster": "Removing is pretty easy. Added deprecation with error. https://github.com/stereobooster/money-heuristics. @antstorm I do not have rights to push to this repo. And cannot fork it because it is empty.. @antstorm any plans to release this?. Removing is pretty easy. Added deprecation with error. https://github.com/stereobooster/money-heuristics. @antstorm I do not have rights to push to this repo. And cannot fork it because it is empty.. @antstorm any plans to release this?. ",
    "tobypinder": "Excellent stuff, many thanks! :+1: . Excellent stuff, many thanks! :+1: . ",
    "dilumn": "Great, I'll do that soon. Thanks for the quick response. Is there a way to fix this issue for now? because adding \"lkr\" to config file will take at lease one month to go with the next release.\nI tried this way, But now it's not showing any symbol in front of the amount.\ncurr = {\n  :priority        => 100,\n  :iso_code        => \"LKR\",\n  :iso_numeric     => \"144\",\n  :name            => \"Sri Lankan Rupees\",\n  :symbol          => \"Rs\",\n  :subunit         => \"Cent\",\n  :subunit_to_unit => 100,\n  :separator       => \".\",\n  :delimiter       => \",\",\n  :thousands_separator => \",\",\n  :symbol_first    => true\n}. @antstorm I created a pull request with the correct symbol. Actually there was an entity for lkr but the html_entity was wrong. That's why I got the wrong symbol. For now I register LKR as a new record for my use.\n. updated the pull request with the requested change. Thanks for the quick new version release. Great, I'll do that soon. Thanks for the quick response. Is there a way to fix this issue for now? because adding \"lkr\" to config file will take at lease one month to go with the next release.\nI tried this way, But now it's not showing any symbol in front of the amount.\ncurr = {\n  :priority        => 100,\n  :iso_code        => \"LKR\",\n  :iso_numeric     => \"144\",\n  :name            => \"Sri Lankan Rupees\",\n  :symbol          => \"Rs\",\n  :subunit         => \"Cent\",\n  :subunit_to_unit => 100,\n  :separator       => \".\",\n  :delimiter       => \",\",\n  :thousands_separator => \",\",\n  :symbol_first    => true\n}. @antstorm I created a pull request with the correct symbol. Actually there was an entity for lkr but the html_entity was wrong. That's why I got the wrong symbol. For now I register LKR as a new record for my use.\n. updated the pull request with the requested change. Thanks for the quick new version release. ",
    "ngan": "I think custom format names would be great, like what Rails does with Time#to_s (https://robots.thoughtbot.com/custom-formats-for-datetime). Defining a custom format with a proc would cool as well.\n```\nconfig/initializers/money.rb\nMoney.define_format(:formal) do |money|\n  money.curency.name.singularize.pluralize(money.to_i)\nend\nMoney.define_format(:informal) do |money|\n  money.curency.name.downcase.singularize.pluralize(money.to_i)\nend\nprice = Money.new(100, :foo)\nprice.format(:formal) #=> 100 Foos\nprice.format(:informal) #=> 100 foo\n```. I think custom format names would be great, like what Rails does with Time#to_s (https://robots.thoughtbot.com/custom-formats-for-datetime). Defining a custom format with a proc would cool as well.\n```\nconfig/initializers/money.rb\nMoney.define_format(:formal) do |money|\n  money.curency.name.singularize.pluralize(money.to_i)\nend\nMoney.define_format(:informal) do |money|\n  money.curency.name.downcase.singularize.pluralize(money.to_i)\nend\nprice = Money.new(100, :foo)\nprice.format(:formal) #=> 100 Foos\nprice.format(:informal) #=> 100 foo\n```. ",
    "maltoe": "Hey @printercu,\nas said, we already have these money < Money.zero lines in our code base, as <=> 0 wasn't possible at the time we put them in, and I wanted to avoid having to change them. And it was kind of unexpected change in behaviour for <=>, so I thought maybe others might suffer from this as well.\nAdmittedly, .negative? reads way better and seems to have been in existence for ages, so might end up just changing it to this instead :-)\nThank you!. @antstorm Thanks for your quick response.\n\nReleasing a major version every time it happens will get us to version 100 sooner than you think :)\n\nThat might be the case, but I'd still argue that sticking to semantic versioning makes sense here. The 100 isn't too bad by itself, sure looks funny, but at least clearly communicates there's breaking changes in there. In our case, we only noticed this change through a random test case that does something like expect('1000 RWF'.to_money).to eq(Money.new(100000, 'RWF')). If we had updated and released this to production without noticing, really bad things would have happened. $$$-related things, obviously :-)\nAs for the migration: We use money-rails and I think that would be a good place to have a default data migration for something like this, as it already has all the information.\nFix: Yeah, I agree we should face the truth and fix our data. Requires checking the code thought for places where we deal with decimal RWF values :/\nthanks again\nmalte\n. Hey @printercu,\nas said, we already have these money < Money.zero lines in our code base, as <=> 0 wasn't possible at the time we put them in, and I wanted to avoid having to change them. And it was kind of unexpected change in behaviour for <=>, so I thought maybe others might suffer from this as well.\nAdmittedly, .negative? reads way better and seems to have been in existence for ages, so might end up just changing it to this instead :-)\nThank you!. @antstorm Thanks for your quick response.\n\nReleasing a major version every time it happens will get us to version 100 sooner than you think :)\n\nThat might be the case, but I'd still argue that sticking to semantic versioning makes sense here. The 100 isn't too bad by itself, sure looks funny, but at least clearly communicates there's breaking changes in there. In our case, we only noticed this change through a random test case that does something like expect('1000 RWF'.to_money).to eq(Money.new(100000, 'RWF')). If we had updated and released this to production without noticing, really bad things would have happened. $$$-related things, obviously :-)\nAs for the migration: We use money-rails and I think that would be a good place to have a default data migration for something like this, as it already has all the information.\nFix: Yeah, I agree we should face the truth and fix our data. Requires checking the code thought for places where we deal with decimal RWF values :/\nthanks again\nmalte\n. ",
    "RomainGoncalves": "Thanks for that answer @antstorm . I will implement that then. Thanks for that answer @antstorm . I will implement that then. ",
    "krtschmr": "can't we just simply migrate to bigint?. can't we just simply migrate to bigint?. ",
    "abbyetwu": "I am sorry that I committed on the wrong repo, have a nice day :). I am sorry that I committed on the wrong repo, have a nice day :). ",
    "samnissen": "Sorry, I've just seen the documentation part:\nruby\nI18n.enforce_available_locales = false\nIs it possible for money to set this as its default?. @antstorm I'm running in pure Ruby 2.4 and getting this error, so I guess the global default has recently been changed to true? If that's accurate, I would assume setting the default to false for the relevant Ruby and/or Rails versions would be ideal. However, I yield to you on that -- I don't have the expertise. \nBut yes, I think you're right on -- if not changing the default, it might be worth raising the profile of this particular bit of documentation. As an addition, maybe its worth adding some messaging from the app? I'm imagining something that rescues relevant I18n::InvalidLocale errors, adds some messaging and re-raises. I realize this could be a very high-level change, so again I defer as to whether this is a good idea.\nLMK if I can help in any way.. Sorry, I've just seen the documentation part:\nruby\nI18n.enforce_available_locales = false\nIs it possible for money to set this as its default?. @antstorm I'm running in pure Ruby 2.4 and getting this error, so I guess the global default has recently been changed to true? If that's accurate, I would assume setting the default to false for the relevant Ruby and/or Rails versions would be ideal. However, I yield to you on that -- I don't have the expertise. \nBut yes, I think you're right on -- if not changing the default, it might be worth raising the profile of this particular bit of documentation. As an addition, maybe its worth adding some messaging from the app? I'm imagining something that rescues relevant I18n::InvalidLocale errors, adds some messaging and re-raises. I realize this could be a very high-level change, so again I defer as to whether this is a good idea.\nLMK if I can help in any way.. ",
    "stanley90": "@antstorm yes, here it is #723 . @antstorm yes, here it is #723 . ",
    "ianmurrays": "Chilean here. These changes don't really make sense, as CLP doesn't have a subunit in circulation. The changes actually seem to refer to the chilean \"escudo\", which stopped circulating in 1975 (see here). \nThis site (in spanish, from the Chilean Central Bank) shows the smallest denomination, which is a 1 CLP coin, and they will actually stop minting 1 and 5 CLP coins on November 1st, 2017.. Chilean here. These changes don't really make sense, as CLP doesn't have a subunit in circulation. The changes actually seem to refer to the chilean \"escudo\", which stopped circulating in 1975 (see here). \nThis site (in spanish, from the Chilean Central Bank) shows the smallest denomination, which is a 1 CLP coin, and they will actually stop minting 1 and 5 CLP coins on November 1st, 2017.. ",
    "jesuiswk": "Thank you all for the input! will close it for now. . Thank you all for the input! will close it for now. . ",
    "sj26": "Awesome! Any chance we could see this in a release soon? We'd love to to update i18n in our app.. Awesome! Any chance we could see this in a release soon? We'd love to to update i18n in our app.. "
}