{
    "hkellaway": "PR was made against incorrect branch\n. good suggestions! i'll keep you posted\n. the referenced PRs take your suggestions into account. non-optional properties are now allowed by using forceDecode_ functions or by using the <~~! operator. Additionally, I did like the idea of having to initialize with JSON, so the Decodable protocol was updated to reflect that.\nyou'll see these updates in 0.4.0 :boom: \n. Mantle is implemented in Objective-C, this is implemented in Swift. I'm not sure how well Mantle works interoperating with Swift apps (this thread may be relevant: https://github.com/Mantle/Mantle/issues/421), but this would be for people wanting to use a Swift pod for the same purpose.\n. I don't feel it is a needless split - for folks wanting a Swift implementation, Mantle is not an option.\n. Let me know if you have more comments on the issue? Otherwise, I'll close out tomorrow. Thanks for bringing this up\n. The implementation is purely Swift (which some would want), Swift users don't have to deal with Objective-C interoperability, the code base itself is smaller and easier to comprehend as a side-effect of it being Swift. I also don't believe that Mantle has to be the only library of this kind.\n. Now Carthage compatible as of version 0.5.1 :tada: \n. Thinking alike here! This recent PR changed to using init(json:): https://github.com/hkellaway/Gloss/pull/30\nIt doesn't introduce a failable initializer, so that's definitely something to consider. Do you want to update your PR to just reflect the failable initializer?\n. I see you're advocating for a failable initializer over a force unwrap operator. I see virtue in both - can you let me know why you think failable initializer is the way to go?\n. i have been thinking about this all day; i'm liking the failable initializer for safety. this will come in the release after the latest i've prepared - will ask for a rebase then\nthanks! :sparkles: \n. in progress\n. Replacing this PR with rebased version: https://github.com/hkellaway/Gloss/pull/38\n. Nice! :+1: \n. thanks @bojan, will review this tonight\n. I appreciate the assistance with Carthage, I'm not super familiar. \nCan you tell me the particular need to remove Pods from source control - it's not immediately apparent\n. Removing all schemes from the GlossExample project leaves it and its test suite unable to be run. Would it mess with Carthage to reintroduce one un-shared scheme on that project ?\n. @bojan can you weigh in on this before i merge ^\n. Awesome, thanks. Yep, deployment should be 8.0\n. latest, Sunday 9/20\n. Nice catch\n. Resolved in PR https://github.com/hkellaway/Gloss/pull/57\n. there isn't a plan right now to go towards a class cluster/factory design.\ni don't know if this helps you, but you can represent your Gloss models as classes instead of structs. what was originally this:\n```\nimport Gloss\nstruct RepoOwner: Decodable {\nlet ownerId: Int?\nlet username: String?\n\n// MARK: - Deserialization\n\ninit?(json: JSON) {\n    self.ownerId = \"id\" <~~ json\n    self.username = \"login\" <~~ json\n}\n\n}\n```\nwould become\n```\nimport Gloss\nclass RepoOwner: Decodable {\nlet ownerId: Int?\nlet username: String?\n\n// MARK: - Deserialization\n\nrequired init?(json: JSON) {\n    self.ownerId = \"id\" <~~ json\n    self.username = \"login\" <~~ json\n}\n\n}\n```\n. PR was made against incorrect branch\n. after reading this - http://stackoverflow.com/questions/25974779/convert-json-anyobject-to-int64\ni'd suggest you actually model your timestamp as an NSNumber. if you for some reason needed to get an Int64 value from timestamp, you could use timestamp.longlongValue\n. alternatively, use a custom Encoder:\n```\nstruct ConfigurationMetadata: Encodable {\n    let protocolVersion: String\n    let timestamp: Int64\n    let appId: String\n    let appVersion: String\n    let cardIdType: String\nfunc toJSON() -> JSON? {\n    return jsonify(\n        [\n            \"protocolVersion\" ~~> self.protocolVersion,\n            Encoder.encodeInteger64(\"timestamp\")(NSNumber(longLong: self.timestamp)),\n            \"appId\" ~~> self.appId,\n            \"appVersion\" ~~> self.appVersion,\n            \"cardIdType\" ~~> self.cardIdType\n        ]\n    )\n}\n\n}\nextension Encoder {\nstatic func encodeInteger64(key: String) -> NSNumber? -> JSON? {\n    return {\n        integer in\n\n        if let integer = integer {\n            return [key : integer]\n        }\n\n        return nil\n    }\n}\n\n}\n``\n. :+1: \n. Release0.7.3adds decoding forInt64\ud83c\udf89 \n. I guess the original thought behind that was that is if the array was empty, the JSON encodings had failed - and returningnilin that case would be more consistent. But, thinking about it now, that is probably too opinionated for that call to be\n. Thanks for pointing that out - it'll be fixed next version\n. fixed as of version0.6.0:tada: \n. Mac OS X is not my forte - so I'm not sure what it needs to take it there. If you have any thoughts on that, please share\n. thanks for the tip - support added as of version0.6.0:tada: \n. i'd handle this nesting in one of two ways. either create nested Gloss models for each step - or, useguard` statements within the initializer to assure the JSON has the desired values.\nthe two examples you provided are similar, so i'm only going to illustrate one unless there's a particular need.\nStrategy 1 - Everything is a model:\n```\nstruct MyObject: Decodable {\nlet data: Data\n\ninit?(json: JSON) {\n    guard let data: Data = \"data\" <~~ json\n        else { return nil }\n\n    self.data = data\n}\n\n}\n```\n```\nstruct Data: Decodable {\nlet user: User\n\ninit?(json: JSON) {\n    guard let user: User = \"user\" <~~ json\n        else { return nil }\n\n    self.user = user\n}\n\n}\n```\n```\nstruct User: Decodable {\nlet id: Int\nlet name: String\n\ninit?(json: JSON) {\n    guard let id: Int = \"id\" <~~ json,\n        let name: String = \"name\" <~~ json\n        else { return nil }\n\n    self.id = id\n    self.name = name\n}\n\n}\n```\nHere, we see the object that represents the full JSON, MyObject, has a property that is another Gloss model, Data, which has a property that is another Gloss model, User.\nStrategy 2 - Use guard statements to drill down to the model you want\n```\nstruct MyObject2: Decodable {\nlet user: User\n\ninit?(json: JSON) {\n    guard let dataJSON = json[\"data\"] as? JSON, user: User = \"user\" <~~ dataJSON\n        else {\n        return nil\n    }\n\n    self.user = user\n}\n\n}\n```\nHere, the desired property was a User model instead of a Data model, so we guaranteed with our guard statement that the nested JSON under the \"data\" key was present before constructing our property out of it.\nHope that helps. \n. thanks for reading the post and trying it out \ud83d\udc4c\ud83c\udffc\nyes, a benefit comes in taking away a lot of boilerplate you'd have to write in translating all sorts of values - numbers, strings, enums, arrays, other models - from JSON yourself and allows you to focus on an almost one to one matching of property to JSON key\n. thanks for the PR @Broich. my take, though, is that this is a bit too specific to include in the core library. rather, its a good candidate for a custom transformation in your own application.\n. hm, the CI fail is on a test that isn't impacted by your change. tests pass locally before the change and i also pulled your branch and tests passed locally as well. not sure why Travis isn't handling it :confused: \n. good call @ishaq - i will fix this\n. now available if you point your pod/cartfile to develop - will be available in the next, 0.6.1, release\n. sorry guys, haven't figure this one out quite yet.\n. will be addressed with 0.7.0 - thanks @bachino90!\n. will look into this @milancermak - thanks for the suggestion\n. sorry it took me a couple days to come around. gave this a try and only received obscure errors. if you find a way to include this one, i'd encourage you to submit a PR!\n. no particular reason, except I've not worked with watchOS yet in any capacity enough to tell me if simply adding that to the podspec will allow watchOS developers to use the library without any hitches. is that something you can verify? let me know - if it's all good, I'll make the PR if you haven't yet\n. did my best to address in PR #93 - thanks for the suggestion!\n. you've got that snippet correct. large numbers in JSON are NSNumbers (http://stackoverflow.com/questions/25974779/convert-json-anyobject-to-int64) - if you want an Int64 of it, you'll have to make your own decode function\n. Release 0.7.3 adds decoding for Int64 \ud83c\udf89 \n. i'm not quite gathering the utility of this. what is not working about toJSON() that this fixes?\n. i see. does this work for nested models? e.g. i'd implement the example as below - does decoding still work? what about if i wanted a model with mixed  properties - i.e. some are other Glossy models and some are declared in the format you're proposing (e.g. args.id).\ni do appreciate the thought/work, but i'd not consider it unless it worked for toJSON() and the cases mentioned above.\n```\nstruct Person: Glossy {\nlet args: Args?\n\n// MARK: - Deserialization\ninit?(json: JSON) {\n    self.args = \"args\" <~~ json\n}\n\n// MARK: - Serialization\n\nfunc toJSON() -> JSON? {\n    return jsonify([\n        \"args\" ~~> self.args\n        ])\n}\n\n}\nstruct Args: Glossy {\nlet id: String?\nlet name: String?\n\ninit?(json: JSON) {\n    self.id = \"id\" <~~ json\n    self.name = \"name\" <~~ json\n}\n\nfunc toJSON() -> JSON? {\n    return jsonify([\n        \"args.id\" ~~> self.id,\n        \"args.login\" ~~> self.name\n        ])\n}\n\n}\n``\n. great - i'll have to spend some time playing with this myself this weekend; i'll respond back here if i encounter issues\n. @RahulKatariya can you rebase this? conflicts with the latestdevelop. @RahulKatariya i rebased and merged this intodevelopoutside of this PR - will be available in0.7.0`. thanks! :tada: \n. no prob. would it be possible to make that today? I have time to review\nWhat is the issue?\n. thanks @RahulKatariya \n. thanks @RahulKatariya !\n. nice - i'll need to play with this a bit myself this weekend and add some tests. if i surface any issues, i'll respond here\n. this is cool - thanks @dwb357 :smile: \n. hi @HamedMP - can you link me to a sample project where you're experiencing these issues?\n. As mentioned on StackOverflow - you're on Xcode 7.2 which comes with Swift 2.2. Gloss was last updated with Swift 2.1. I'll add a task for myself to update. If the functionality Gloss provides is needed before that happens, a different library should be used.\n. @Pericharan thanks! \nit sounds like what you're describing is simply what JSON looks like when printed out in Xcode's console. accessing that JSON in code would be as expected.\n. @HamedMP - so i ran the project with both Xcode 7.2 and 7.3, with no issues; so i'd say my theory is incorrect. \nif you try what this user on StackOverflow suggests and have any luck let me know http://stackoverflow.com/a/35201355/3777116\n. closing due to 2+ weeks of inactivity. the next version, 0.7.0 was just released - if desired, give that a try and submit another issue if you run into errors.\n. ran with Xcode 7.3, no issues\n. awesome, thanks. i need to look at this closer and see why tests are failing - likely this weekend. i'll post back here if i run into issues\n. good idea, i always forget about default parameters\n. it's not clear to me that there's a good way to handle that situation the library itself. it could be managed client-side by doing the following.\ncreate a model with a new initializer that takes in JSON array - and creates a JSON dictionary with a custom key, which is passed to the required initializer:\n``` swift\nstruct Test: Glossy {\nlet urls: [String]\n\n// introduce JSON array initializer that creates JSON with a custom key\ninit?(jsonArray: [AnyObject]) {\n    let jsonDictionary = [\"myCustomJSONArrayKey\" : jsonArray]\n\n    self.init(json: jsonDictionary)\n}\n\ninit?(json: JSON) {\n    guard let urls: [String] = \"myCustomJSONArrayKey\" <~~ json else {\n        return nil\n    }\n\n    self.urls = urls\n}\n\nfunc toJSON() -> JSON? {\n    return jsonify([\n        \"myCustomJSONArrayKey\" ~~> self.urls\n        ])\n}\n\n}\n```\nclient-side, use the custom key to retrieve values:\n``` swift\nlet testJSON = [ \"http://google.com\", \"http://facebook.com\" ]\nlet test = Test(jsonArray: testJSON)\nprint(test?.urls)\n// use the custom key to retrieve array\nlet myJSON: [String]? = test?.toJSON()?[\"myCustomJSONArrayKey\"] as? [String]\nprint(myJSON)\n```\ni get its not ideal - but the designation of JSON as a dictionary is currently part of the library. thoughts on this solution?\n. sure, if you have the time to work on it. i'd love to see what you come up with\n. why is it better in the framework project would you say?\n. fair enough, i don't have a case for keeping it with the example project; i had them there because i use the example project when i work on development\n. it'd be easiest to recreate this once the release is stable.\n. the result value in your examples is actually part of the Alamofire library, and not Gloss :/\nfor good measure, i tested just the Gloss portion of what you have there (the models and the initializing with JSON) - and that's just fine\n. oh, sorry - i misunderstood; i'll take another look\n. in order for the nested model to be translated as expected, you need to indicate it's Decodable:\n```\nstruct Response: Decodable {\n    let status: String?\n    let message: String?\n    let result: T?\ninit?(json: JSON) {\n    self.status = \"status\" <~~ json\n    self.message = \"message\" <~~ json\n    self.result = \"result\" <~~ json\n}\n\n}\n``\n. good call. the onlyNSDateFormattercreated by the library is for ISO8601 dates - that will be made lazy. for other dates, the client passes in the date formatter, so it's up to them to make sure it's instantiated only once. this update will be available in0.7.0` - thanks!\n. here's how i might handle that one:\n``` swift\nprotocol TimelineItem {\nvar id: Int { get }\nvar type: TimelineType { get }\nvar startDate: String { get }\n\n}\n```\nswift\nenum TimelineType: String {\n    case Header = \"header\"\n    case Session = \"session\"\n}\n``` swift\nstruct Header: Decodable, TimelineItem {\nlet id: Int\nlet type: TimelineType\nlet startDate: String\nlet text: String\n\ninit?(json: JSON) {\n    guard\n        let id: Int = \"id\" <~~ json,\n        let startDate: String = \"startDate\" <~~ json,\n        let text: String = \"text\" <~~  json else {\n        return nil\n    }\n\n    self.id = id\n    self.type = TimelineType.Header\n    self.startDate = startDate\n    self.text = text\n}\n\n}\n```\n``` swift\nstruct Session: Decodable, TimelineItem {\nlet id: Int\nlet type: TimelineType\nlet name: String\nlet room: String\nlet startDate:  String\nlet duration: Int\n\ninit?(json: JSON) {\n    guard\n        let id: Int = \"id\" <~~ json,\n        let name: String = \"name\" <~~ json,\n        let room: String = \"room\" <~~ json,\n        let startDate: String = \"startDate\" <~~ json,\n        let duration: Int = \"duration\" <~~ json else {\n            return nil\n    }\n\n    self.id = id\n    self.type = TimelineType.Session\n    self.name = name\n    self.room = room\n    self.startDate = startDate\n    self.duration = duration\n}\n\n}\n```\n``` swift\nstruct Timeline: Decodable {\nlet timelineItems: [TimelineItem]\n\ninit?(json: JSON) {\n    guard\n        let timelineItems: [TimelineItem] = \"timeline\" <~~ json else {\n        return nil\n    }\n\n    self.timelineItems = timelineItems\n}\n\n}\n```\nswift\nfunc <~~ (key: String, json: JSON) -> [TimelineItem]? {\n    return Decoder.decodeTimelineItems(json, key: key)\n}\n``` swift\nextension Decoder {\nstatic func decodeTimelineItems(json: JSON, key: String) -> [TimelineItem]? {\n    guard let timelineJSONArray = json[key] as? [[String : AnyObject]] else {\n        return nil\n    }\n\n    var timelineItems: [TimelineItem] = []\n\n    for timelineItemJSON in timelineJSONArray {\n        guard\n            let timelineItemTypeString = timelineItemJSON[\"type\"] as? String,\n            let timelineItemType = TimelineType(rawValue: timelineItemTypeString) else {\n                return nil\n        }\n\n        switch timelineItemType {\n        case .Header:\n            if let header = Header(json: timelineItemJSON) {\n                timelineItems.append(header)\n            }\n        case .Session:\n            if let session = Session(json: timelineItemJSON) {\n                timelineItems.append(session)\n            }\n        }\n    }\n\n    return timelineItems\n}\n\n}\n```\nnote: i didn't handle decoding the date - i don't know the format off the top of my head; you'd want to use Decoder.decodeDate(_:dateFormatter:) for that.\nalso, adding a custom <~~ operator for your case is  entirely optional\nhope that helps\n. super neat :+1: \n. @RahulKatariya you'll notice i made a slight change to your model array implementation - i found that initializer syntax to be confusing (e.g. let result = [TestModel](json : testJSONArray!)); so this is now fromJSONArray(_:) (e.g. let result = [TestModel].fromJSONArray(testJSONArray!). same concept applies\n. how modelsFromJSONArray is implemented is changed slightly in upcoming 0.7.0release - and its updating to not be optional there. i'll leave this open until that release\n. 0.7.0 has been release :tada: should not longer be experiencing this issue\n. to play devil's advocate - is this not something a client could create a custom transformation for? the question being - is it really the library's responsibility to do this? i'm open to hearing yes, i just don't want the library making unnecessary assumptions on the client's behalf\n. point taken - thanks for the care :+1: \n. @ejmartin504 heads up, this is creating issues: https://github.com/hkellaway/Gloss/issues/238\ni'm inclined to go with my original thought of the library is making unnecessary assumptions about the URLs and remove this escaping. as of the soon-to-be release 1.1.2, you'll have to escape your own URLs. that file was renamed in the latest version. can you try clearing whatever you have downloaded and doing a clean install?\n. I'll give that a try\n. @nmodin you're totally right - thanks for catching that! can i bother you to try using the version at the branch bugfix/carthage_missing_dictionary and verifying that works as expected?\n. no prob - will be releasing a new version shortly. thanks for the help\n. i'm not very familiar with implementing Realm and whether that may be affecting the outcome. however, i was able to get the following model, similar to what you've depicted, to decode properly - without the Realm superclass.\n```\n// super class\nclass Super { }\n// sub class\nclass Sub: Super, Decodable {\ndynamic var nome: String! = \"\"\n\nrequired init?(json: JSON) {\n    self.nome = \"nome\" <~~ json\n}\n\n}\n```\ndecoding:\n```\nlet jsonArray: [[String : AnyObject]] = [\n        [\n            \"nome\" : \"1\"\n        ],\n        [\n            \"nome\" : \"2\"\n        ],\n        [\n            \"nome\" : \"3\"\n        ]\n]\nlet subs = [Sub].fromJSONArray(jsonArray)\nprint(subs)\n``\n. @dwb357 this failed on thetestEncodeEncodableDictionarytest (tests can be found in theGlossExample` project currently). can you fix the test to pass?\n. thanks @dwb357 \n. im going to have to look into this on the weekend; no answer springs out at me immediately.\n. if i'm understanding your example correctly, you could achieve this in a way very similar to this question: #113 \n``` swift\nprotocol MyListItem {\nvar type: MyListItemType { get }\nvar prop: String { get }\n\n}\n```\nswift\nenum MyListItemType: String {\n    case A = \"A\"\n    case B = \"B\"\n}\n``` swift\nstruct MyListItemA: Decodable, MyListItem {\nlet type: MyListItemType\nlet prop: String\n\ninit?(json: JSON) {\n    guard\n        let prop: String = \"AProp\" <~~ json else {\n        return nil\n    }\n\n    self.type = MyListItemType.A\n    self.prop = prop\n\n}\n\n}\n```\n``` swift\nstruct MyListItemB: Decodable, MyListItem {\nlet type: MyListItemType\nlet prop: String\n\ninit?(json: JSON) {\n    guard\n        let prop: String = \"BProp\" <~~ json else {\n            return nil\n    }\n\n    self.type = MyListItemType.B\n    self.prop = prop\n\n}\n\n}\n```\n``` swift\nstruct MyModel: Decodable {\nlet myProp: String\nlet myList: [MyListItem]\n\ninit?(json: JSON) {\n    guard\n        let myProp: String = \"MyProp\" <~~ json,\n        let myList: [MyListItem] = \"MyList\" <~~ json else {\n        return nil\n    }\n\n    self.myProp = myProp\n    self.myList = myList\n}\n\n}\n```\n``` swift\nfunc <~~ (key: String, json: JSON) -> [MyListItem]? {\n    return Decoder.decodeListItems(json, key: key)\n}\n```\n``` swift\nextension Decoder {\nstatic func decodeListItems(json: JSON, key: String) -> [MyListItem]? {\n    guard let listItemsJSONArray = json[key] as? [[String : AnyObject]] else {\n        return nil\n    }\n\n    var listItems: [MyListItem] = []\n\n    for listItemJSON in listItemsJSONArray {\n        guard\n            let listItemTypeString = listItemJSON[\"Type\"] as? String,\n            let listItemType = MyListItemType(rawValue: listItemTypeString) else {\n                return nil\n        }\n\n        switch listItemType {\n        case .A:\n            if let itemA = MyListItemA(json: listItemJSON) {\n                listItems.append(itemA)\n            }\n        case .B:\n            if let itemB = MyListItemB(json: listItemJSON) {\n                listItems.append(itemB)\n            }\n        }\n    }\n\n    return listItems\n}\n\n}\n```\nwriting your own <~~ operator is, of course optional.\nwith this setup, the following produces your models as expected:\n``` swift\nlet json = [\n        \"MyProp\" : \"1234567890\",\n            \"MyList\" : [\n                [\n                    \"Type\" : \"A\",\n                    \"AProp\" : \"A Field\"\n                ],\n                [\n                    \"Type\" : \"B\",\n                    \"BProp\" : \"B Field\"\n                ]\n        ]\n]\nguard let myModel = MyModel(json: json) else {\n        print(\":(\")\n    return\n}\nprint(myModel)\n```\nhope that helps\n. thanks! :tada: \n. thanks :tada: \n. here is one interpretation of that JSON into models.\n``` swift\nstruct BookListing: Decodable {\nlet kind: String\nlet totalItems: Int\nlet books: [Book]\n\ninit?(json: JSON) {\n    guard\n        let kind: String = \"kind\" <~~ json,\n        let totalItems: Int = \"totalItems\" <~~ json,\n        let books: [Book] = \"items\" <~~ json else {\n        return nil\n    }\n\n    self.kind = kind\n    self.totalItems = totalItems\n    self.books = books\n}\n\n}\nstruct Book: Decodable {\nlet id: String\nlet title:  String\nlet authors: [String]\nlet identifiers: [BookIdentifier]\n\ninit?(json: JSON) {\n    guard let id: String = \"id\" <~~ json,\n        let title: String = \"volumeInfo.title\" <~~ json,\n        let authors: [String] = \"volumeInfo.authors\" <~~ json,\n        let identifiers: [BookIdentifier] = \"volumeInfo.industryIdentifiers\" <~~ json else {\n            return nil\n    }\n\n    self.id = id\n    self.title = title\n    self.authors = authors\n    self.identifiers = identifiers\n}\n\n}\nstruct BookIdentifier: Decodable {\nenum Type: String {\n    case ISBN10 = \"ISBN_10\"\n    case ISBN13 = \"ISBN_13\"\n}\n\nlet type: Type\nlet identifier: String\n\ninit?(json: JSON) {\n    guard  let type: Type = \"type\" <~~ json,\n        let identifier: String = \"identifier\" <~~ json else {\n            return nil\n    }\n\n    self.type = type\n    self.identifier = identifier\n}\n\n}\n```\ngiven this JSON:\njson\n        let json = [\n            \"kind\" : \"books#volumes\",\n            \"totalItems\" : 5,\n            \"items\" : [\n                [\n                    \"id\" : \"hqKfQwAACAAJ\",\n                    \"volumeInfo\" : [\n                        \"title\" : \"\\\"I Ain't Yo Bitch\\\"\",\n                        \"authors\" : [ \"Jabulile Bongiwe Ngwenya\" ],\n                        \"industryIdentifiers\" : [\n                            [\n                                \"type\" : \"ISBN_10\",\n                                \"identifier\" : \"0733426093\"\n                            ],\n                            [\n                                \"type\" : \"ISBN_13\",\n                                \"identifier\" : \"9780733426094\"\n                            ]\n                        ]\n                    ]\n                ]\n                ]\n        ]\nthose models would decode successfully:\n``` swift\n let bookListing = BookListing(json: json)\nprint(bookListing)\n```\nIf that JSON was instead an array of those same models:\nswift\nlet bookListings = [BookListing].fromJSONArray(jsonArray)\nwhether those are the specific models you come out with is up to you; but this should be enough to help you understand how to construct Gloss models. hope that helps\n. super. happy coding\n. :+1: \n. @tholo has provided some additional context:\n\nFWIW I am seeing this issue with some of my stuff too \u2014 but moving the statement to remove element 0 does not fix it \u2014 and indeed, at the point where it is being removed we already know that there are at least one element in the set of keys.\nBuilding the framework (I am using Carthage) for Debug instead of Release does fix it, and it seems to me that this must be an issue not with Gloss but with Swift / LLVM somewhere...\n. thanks @tholo \n\n@stuartervine if you have the time, can you try seeing if your problems are resolved when using branch bugfix/crash_valueforkeypath_when_optimized \n. thanks for that feedback (and @tholo for the solution), i'll do more testing and likely merge it\n. now present in 0.7.2 :tada: \n. hey @sfaxon - thanks for reporting. nope, you're not missing anything; i'll have to do more investigation\nthe temporary solution, of course, would be to not use nested keypaths for the time being\n. i just released 1.0.0, which is compatible with Swift 3.0 \ud83c\udf89  however, i was not comfortable including a feature that caused crashes at runtime - and had yet to figure out an implementation. therefore, nested keypaths have been removed.\napologies to those who have a lot of nested keypaths! models should be updated before moving to 1.0.0 (or 0.8.0 if you're using Swift 2.3). See more here https://github.com/hkellaway/Gloss#nested-keypaths-deprecation\n. yes, it's likely possible to turn off optimization for the Release confguration of the library - but that's not what's expected of the configuration. so the choice was turning off the proper optimization level or keep this convenience feature. It's a nice-to-have, not a need-to-have, for any JSON parsing library in my mind - so I chose to stick with the proper settings. I totally get if that's a dealbreaker; I'd recommend you another library that does that if I knew of one.\nI currently don't have the bandwidth to work on reincorporating it, though may eventually - so I can't give a guarantee. I'm open to others submitting PRs to that effect.\nanother possibility is creating your own fork, reapplying the implementation, and adding what can be done to adjust the optimization level.\n. nested keypaths have been reintroduced as of the latest version, 1.1.0 \ud83c\udf89 \nyou can thank @ferusinfo  for that \n. thanks for catching that, I'll review soon \n. this appears to cause one of the tests to fail - if you can update the test, that'd be great. otherwise, i'll address when i get the chance\n. @stuartervine the proposed solution doesn't seem to work - you can check that out by running the example project under GlossExample. is it possible to provide me with steps to reproduce your scenario with optimizations so I can test solutions ?\n. @stuartervine closing this PR for now, as it breaks library functionality and i'm currently unable to reproduce. to get around your issue in the meanwhile, you could create nested models as opposed to using the . syntax. i reopened the original issue; if you find a viable solution, definitely submit another PR!\n. thanks @tholo - i'm gonna copy this response to the original issue ( #135 ) so we can keep track of it in one spot\n. Gloss does not currently have any features related to CoreData and support isn't currently intended. Good luck with the search!\n. apologies for the late response, couldn't dig into this until the weekend.\nto achieve the desired effect, your model should look as such:\n```\nstruct testStruct : Decodable, Encodable {\nlet attrib : String\n\ninit?(json: JSON) {\n    guard let attrib: String = \"attrib\" <~~ json else {\n        return nil\n    }\n\n    self.attrib = attrib\n}\n\ninit(attrib: String) {\n    self.attrib = attrib\n}\n\nfunc toJSON() -> JSON? {\n    return jsonify([\n        \"type\" ~~> \"TEST\",\n        \"attrib\" ~~> attrib\n        ])\n}\n\n}\n```\nnotice the additions - the model is now declared as Decodable and the required init?(json:) is defined. \ni have to think through what the expected outcome of providing a dictionary with Encodable values without providing Decodable information should be. however, this should achieve your intention. hope that helps!\n. the issue is the timeCreate property which is of type Int64 - that is not a type automatically handled.\ni'd suggest creating a custom Decoder and Endcoder as described here: https://github.com/hkellaway/Gloss#custom-transformations\nhere's an example Decoder; i'll leave Encoder to you if that's something you want to do.\n```\nextension Decoder {\nstatic func decodeInt64(key: String, json: JSON) -> Int64? {\n    if let number = json[key] as? NSNumber {\n        return number.longLongValue\n    }\n\n    return nil\n}\n\n}\n```\nthen, when you decode timeCreate, instead of  let timeCreate: Int64 = \"timeCreate\" <~~ json its let timeCreate: Int64 = Decoder.decodeInt64(\"timeCreate\", json)\nhope that helps\n. Release 0.7.3 adds decoding for Int64 \ud83c\udf89 \n. fromJSONArray will always return an array, not an Optional array - it will be an array of any values that were parsed.\nif at the application level something is wrong - for example, you're expecting the repoOwners array to equal the number of objects in the JSON array else the application should cease execution - your application could include the following: \n```\nlet repoOwners = [RepoOwner].fromJSONArray(repoOwnersJSON)\nguard repoOwners.count == repoOwnersJSON.count else {\n    fatalError(\"Cease execution\")\n}\n```\nhope that helps!\n. good call - thanks!\n. hey @jirizoudun -\nthis is because . is a special value for Gloss for keys - Gloss allows you to specify values nested in models by delimiting the key with a period (e.g. self.myNestedValue = \"outerModel.innerModel\" <~~ json) (see: https://github.com/hkellaway/Gloss#retrieving-nested-model-values-without-creating-extra-models)\nyou can get around that by creating your own transformer for that specific property (see: https://github.com/hkellaway/Gloss#custom-transformations). or, you can pass another value as the delimiting character instead of period - e.g.  here i'm indicating the delimiter should be ///: self.meta = Decoder.decodeDecodable(\".meta\", keyPathDelimiter: \"///\")(json)\nhope that helps!\n. thanks @whvandervelde\n. Int32 is not one of the types handled automatically (https://github.com/hkellaway/Gloss#on-using-gloss-operators). you can create your own custom decoding function (https://github.com/hkellaway/Gloss#custom-transformations); you might extend Decoder something like as follows:\n```\nextension Decoder {\nstatic func decodeInt32(key: String, json: JSON) -> Int32? {\n    if let number = json.valueForKeyPath(key) as? NSNumber {\n        return number.intValue\n    }\n\n    return nil\n}\n\n}\n```\nhope the helps!\n. Release 0.7.3 adds decoding for Int32 \ud83c\udf89 \n. hm, not sure what's going on just yet. can you try something? model the number as an Int32 and use the branch 'release/0.7.3' - that has decoding added for detecting NSNumbers and converting them to Int32 (or Int64)\n. I'll look more closely when I have the chance. If nothing else you can make your own tranformation (https://github.com/hkellaway/Gloss#custom-transformations) using the code you mentioned to transform into an Int\n. sorry hadn't got the chance to think through this until today. if the type is coming through as an NSString but you want it to be an Int, I should have suggested a custom transformation originally. you could use something like this:\n```\nextension Decoder {\nstatic func decodeStringToInt(key: String, json: JSON) -> Int? {\n    if let string = json.valueForKeyPath(key) as? String {\n        return Int(string)\n    }\n\n    return nil\n}\n\n}\n```\nand that would be called as such: let iconserver: Int = Decoder.decodeStringToInt(\"person.iconserver\", json: json)\nhope that works for you\n. the initializer is failable - you must use 'guard' or 'if let' to make sure the model is instantiated at runtime (https://github.com/hkellaway/Gloss#initializing-model-objects-and-arrays).\nthe fact that you're coming out with that error means decoding is failing for some reason - perhaps the setup in your model is not quite right\n. you'll want to get creative with your own transformation (https://github.com/hkellaway/Gloss#custom-transformations). #113 is an example.\n. wow thats neat \ud83d\ude04  i'll add it to the README. thanks @Ahmed-Ali & @CodeEagle !\n. i'm not really sure what you're asking here. can you provide sample code or pseudocode of what you're attempting?\n. i see. that's more of a coding question not specific to Gloss so I'm not going to go too in depth. \noff the top of my head, without giving it a try - it may be that you just need to implement the Equatable protocol for your Location model.\n. i don't see that one could get around having to serialize the property of the superclass A - what B is doing with its override is saying, ignore As implementation and do this instead; it makes sense.\na more descriptive way of achieving the full JSON in class B might be something like:\n``` swift\noverride func toJSON() -> JSON? {\n    guard\n        let superJSON = super.toJSON(),\n        var json = jsonify([ \"bar\" ~~> self.bar ]) else {\n            return nil\n    }\njson.add(superJSON) // `add` is a custom function that combines two dictionaries\n\nreturn json\n\n}\n```\nthe add function you see there combines two dictionaries (see the ExtensionDictionary.swift file in the Gloss library for an example of how one might implement that).\nbut the  bigger issue i see is that this set up violates (my understanding of) the Liskov Substitution Principle - which says that a subclass should be substitutable for its superclass. in this setup, your application code would have to know it was using an instance of B in order to access the bar property, which means A and B are not substitutable. another way to phrase this is, whether we have a class of type A or of type B at runtime, we want calling toJSON on it to produce the same output. so, perhaps, a rethink of the models is due.\nhope that helps!\n. thanks!\n. @4ch7ung this is great - thanks!\nwould you mind also listing these in this section of the README: https://github.com/hkellaway/Gloss#on-using-gloss-operators ?\n. thanks!\n. in the example, we have a package named HelloWorld whose dependency is Gloss - going to keep as-is, thanks for the thought though\n. @coverback nice. i just created a branch swift_2.3 - can you resubmit against that ?\n. that's great \ud83d\ude04 can you actually resubmit against a new branch I created - swift_3.0 ?\n. good thought. want to submit that change against develop - wrapped in a a check for Swift 2.3 ?\n. Theres nothing in the library specific to this scenario. Perhaps, create a custom transformation (https://github.com/hkellaway/Gloss#custom-transformations) - in the function you use, you can figure out all the key names based on the number of keys in the dictionary, and transform them how you want. That assumes the pattern for what the keys are is consistent and known.\nHope that helps!\n. sorry for the delay there. here's on way you might break down that structure:\n`````` swift\nstruct MyModel: Decodable {\nlet jsonMIDI: MIDI\n\ninit?(json: JSON) {\n    guard let jsonMIDI: MIDI = \"jsonMIDI\" <~~ json else {\n        return nil\n    }\n\n    self.jsonMIDI = jsonMIDI\n}\n\n}\nstruct MIDI: Decodable {\nlet header: MIDIHeader\n\ninit?(json: JSON) {\n    guard let header: MIDIHeader = \"header\" <~~ json else {\n        return nil\n    }\n\n    self.header = header\n}\n\n}\nstruct MIDIHeader: Decodable {\nlet formatType: String\nlet trackCount: String\nlet tracks: [MIDITrack]\n\ninit?(json: JSON) {\n    guard\n        let formatType: String = \"formatType\" <~~ json,\n        let trackCount: String = \"trackCount\" <~~ json,\n        let tracks: [MIDITrack] = \"tracks\" <~~ json else {\n        return nil\n    }\n\n    self.formatType = formatType\n    self.trackCount = trackCount\n    self.tracks = tracks\n}\n\n}\nstruct MIDITrack {\nlet deltaTimes: [Int]\n\n}\nfunc <~~ (key: String, json: JSON) -> [MIDITrack]? {\n    return Decoder.decodeTracks(key, json: json)\n}\nextension Decoder {\nstatic func decodeTracks(key: String, json: JSON) -> [MIDITrack]? {\n    guard let tracksNestedJSONArray = json[\"tracks\"] as? [[JSON]] else {\n        return nil\n    }\n\n    var tracks: [MIDITrack] = []\n\n    for tracksJSONArray in tracksNestedJSONArray {\n        guard let deltaTimes = decodeDeltaTimes(tracksJSONArray) else {\n            return nil\n        }\n\n        let track = MIDITrack(deltaTimes: deltaTimes)\n\n        tracks.append(track)\n    }\n\n    return tracks\n}\n\n}\nextension Decoder {\nstatic func decodeDeltaTimes(jsonArray: [JSON]) -> [Int]? {\n    var deltaTimes: [Int] = []\n\n    for json in jsonArray {\n        guard let deltaTime = json[\"deltaTime\"] as? Int else {\n            return nil\n        }\n\n        deltaTimes.append(deltaTime)\n    }\n\n    return deltaTimes\n}\n\n}```\nhope that helps!\n``````\n. not sure i fully get your question here.\nin the scenario you provide, there isn't enough information to determine how to \"parse the entire JSON\" object. \ntypically,you'd either want to extend User to be Decodable as well - and provide the key for the User JSON (not just a blank string).\nor, if you're attempting to avoid making User a Decodable object, as in your code snippets - make your own decoding function:\n``````\nextension Person: Decodable {\ninit?(json: JSON) {\n    guard let user: User = \"user\" <~~ json else {\n        return nil\n    }\n\n    self.user = user\n}\n\n}\nfunc <~~ (key: String, json: JSON) -> User? {\n    return Decoder.decodeUser(key, json: json)\n}\nextension Decoder {\nstatic func decodeUser(key: String, json: JSON) -> User? {\n    guard\n        let id = json[\"id\"] as? String,\n        let name = json[\"name\"] as? String else {\n        return nil\n    }\n\n    return User(id: id, name: name)\n}\n\n}``\n``````\n. Gloss does not automatically handle theNSDecimalNumbertype (handled types: https://github.com/hkellaway/Gloss#on-using-gloss-operators). you should consider a custom transformation (https://github.com/hkellaway/Gloss#custom-transformations)\n. not entirely sure what you're asking. if you mean you'd like to verify that thename,age, etc. are available - thats what you'd use aguard` statement for:\n```\nimport Gloss\nstruct MyModel: Decodable {\nlet name: String\nlet age: Int\n\ninit?(json: JSON) {\n    guard \n        let name: String = \"name\" <~~ json,\n        let age: Int = \"age\" <~~ json else {\n            return nil\n    }\n\n    self.name = name\n    self.age = age\n}\n\n}\n```\nif you're asking about how to write tests for your models, you can have a look at the tests in the GlossTests folder of the project https://github.com/hkellaway/Gloss/tree/master/GlossTests\n. thanks for the idea! im gonna think about/play with this a bit.\n. @marcopompei gave this a try! i don't see a reason not to have this option. however, i don't have the bandwidth now to implement. \nif you're interested in doing so - i'd be happy to see a PR. it'd need to have implementations for all the existing convenience functions for Decoding and Encoding, tests for all the new operators and their underlying functions, as well as an update to documentation. i'm not well-versed at naming operators either - but i think that one may be confusingly close to the other - so let's say <~~* would be acceptable. \nlet me know if you're game.\n. it doesn't seem like there are additional changes made in this PR - closing for now.\n. suggested changes have been merged into develop. \nbecause this represents an API change, this won't come out until 0.8.0 is released - which may not be for some months. until then, have your project point to develop or commit 39bf67ba74141951a42946716a08cc7e1019e626 to be more specific.\n. ah! i only covered fromJSONArray and toJSONArray. will update.\n. updated. you can point toward develop for the latest, or commit 7868347e2fc93487d1a9d2cb4621a88b247986e4 to be more specific\n. wow I really appreciate the thoughtwork here! cool stuff. \nthis is a vast change - I'll need some time to try it out think about the ramifications. I'll reply back here with my thoughts \n. thanks!\n. Thanks!\n. not sure i understand completely. to get the subways objects, you can do:\n```\nguard let subways = [Subway].fromJSONArray(json[\"stations\"]) else {\n        // handle parsing failure here\n}\nprint(subways)\n``\n. @aventurella can you explain what this does?\n. yeah, i don't use Linux and am not sure how to troubleshoot these issues really. :confused: would love to see that PR if you're able to\n. @tsheaff good q. i've yet to have time to download the latest and make sure things are in working order. once i do so, yes - you'll see a new version\n. @illyaBakurov i will work on it this coming weekend\n. will be giving it a once-over with fresh eyes tomorrow night then pushing to CocoaPods. branchrelease/1.0.0can be pointed to in the meanwhile, if desired.\n. tried to push to the master CocoaPods repo tonight - but encountered error (https://github.com/CocoaPods/CocoaPods/issues/5908). hope to resolve soon; apologies for delaying\n. version1.0.0` has been released and is compatible with Swift 3.0! \ud83c\udf89 \n. i'm closing the original issue as preview 4 is no longer applicable\n. @pascalfribi i appreciate the effort regardless\n. thanks @pascalfribi for helping out! hope that helps\n. thanks! it does not\n. i've not actually saved Glossy objects to file, so i can't speak to it. i would love if you had thoughts from your experimentation to see them posted back here.\nglad you like the library \ud83d\ude04 \n. that's not a sort of thing built into Gloss - so you'll want to create your own decoding function (https://github.com/hkellaway/Gloss#custom-transformations).\ni don't know exactly your JSON situation, so i'd think on a couple things. if you know that the metadata will always have certain structures like Editor and Source and that Editor and Source structures will always have 1 value - perhaps make them their own models. if this is really a random assortment of things that can have any number of values - perhaps model the Values as always an array, and some will simply have only 1 entry.\nhope that gives you some ideas!\n. @ejmartin504 i cannot seem to merge this due to conflicts\n. this is the same issue listed here https://github.com/hkellaway/Gloss/issues/135 - which i've yet to find a solution for. that setValue implementation is intended to allow nested keys paths (e.g. self.userID = \"account.user.id\" <~~ json), but can exhibit a crash on Release. \ni'm considering removing simply removing support for nested keypaths in the next major version due to it.\nif you need to re-work any nested keypaths you can - 1. create nested models 2. create custom transformations, e.g.\n``` swift\nextension Decoder {\nstatic func decodeUserID(key: String, json: JSON) -> String? {\n\n    guard let userID = json[\"account\"][\"user\"][\"id\"] as? String else {\n        return nil\n    }\n\n    return userID\n}\n\n}\n```\n. @nuudles you mentioned settings the optimization level to None - did you mean for the framework or for your application? if the latter - i instead tried setting the optimization level to None for the framework and this seems to address the crash. do you see an issue with that solution?\nthat update is available on branch swift_2.3 if you wanted to try it out\n. 1.0.0 was just released, as compatible with Swift 3.0.  however, i was not comfortable including a feature that caused crashes at runtime. therefore, nested keypaths have been removed.\napologies if you have a lot of nested keypaths!  See more here https://github.com/hkellaway/Gloss#nested-keypaths-deprecation\n. nested keypaths was reintroduced in the latest version 1.1.0 \ud83c\udf89 \n. i was actually just thinking that myself - was going to work on it tonight. good call!\n. included in version 1.0.0 \ud83c\udf89 \n. I'm having issues pushing to CocoaPods currently. The most current version on CocoaPods would be 0.7.4\n. 0.8.0was actually just pushed\n. yep, released 0.8.0 and 1.0.0 this morning. Swift 2.3 and Swift 3.0 respectively\n. thanks @gerbiljames !\n. appreciate the cleanup effort \ud83d\udc4d \n. you are correct, that did change as of 0.8.0 (reference: https://github.com/hkellaway/Gloss/issues/189) - to be more consistent with how the rest of decoding is done.\ni would recommend you do exactly what you suggested with decodePartialArray there.\ni'm of the mind to keep the operator parlance of this library pretty focused, so i would likely not introduce that operator for that behavior. \nbut, you could actually include decodePartialArray in your own application and create the operator yourself. i haven't tested this code, but it'd look something like this:\n```\ninfix operator <~~! : DecodingPrecedence\nfunc <~~! (key: String, json: JSON) -> T? {\n    return Decoder.decodePartialArray(key: key, json: json)\n}\n```\n. it does return a function, not for good reason. i will be changing that in a subsequent version to improve clarity.\nthough decoding for Date works a bit differently as it is not binary (it also takes in a DateFormatter). to decode Dates you will lot use the <~~ operator.\n. i've never actually worked with UUIDs. is there a type (e.g. like String) for UUIDs?\n. apologies for the delay at considering this. will review your PR this week\n. available as of 1.1.0 thanks to you! \ud83c\udf89 \n. This doesn't sound like an issue specific to Gloss. Perhaps try submitting this issue to the Cocoapods repo? https://github.com/CocoaPods/CocoaPods\n. thats great @ferusinfo! i appreciate the effort, as i'm sure other Gloss users would.\ni've not had a chance to look closely at it yet, but will review it this week. the first issue i see is that Travis CI is failing. is this something you could look into?\n. might just need to update the Gemfile to specify RC 3 gem 'cocoapods', '1.1.0.rc.3'\n. actually, lets try:\n```\nsource 'https://rubygems.org'\ngem 'cocoapods', :git => 'https://github.com/CocoaPods/CocoaPods.git', :tag => '1-1-stable'\n``\n. awesome! i'll be reviewing this tomorrow\n. @ferusinfo looks good - left a few comments\n. @ferusinfo another PR was just merged intodevelopthat introduces a new type to decode/encode (UUID). can you rebase your PR on develop and update to includeUUID`?\n- [x] rebase\n- [x] update for UUID type\n. @ferusinfo thanks! i'll give it another look when i'm free\nnow worries - i'll take care of documentation\n. now available as of version 1.1.0 \ud83c\udf89  thanks for your hard work @ferusinfo \n. nice. i'll be reviewing this tomorrow\n. @Hiiragisan09 thanks! this will be available in the next release 1.1.0; until then - develop can be pointed to \ud83c\udf89 \n. thanks teddy! looks like CI is failing though as of your final commit - can you take a look at that ? @ejmartin504 \n. the commit messages make this PR appear unfinished. what is the status?\n. no need to apologize! yes, let's close this for now and reopen or make a new PR once resolved. appreciate the effort \n. i don't have a good answer for that one. in the division we seem to lose a millisecond\n. I've yet to have a chance to look into this. were you able to resolve or try using a previous version in the interim?\n. anything 0.8.0 and prior is Swift 2.3 syntax\n. sorry about that, moved swift_2.3 back to 0.8.0. this was actually a purposeful decision to keep the semantics more consistent. i.e. if the value is not present or valid see: https://github.com/hkellaway/Gloss/issues/189 and https://github.com/hkellaway/Gloss/pull/197\nif you'd like to implement a different behavior, you could consider your own transformations (https://github.com/hkellaway/Gloss#custom-transformations)\n. an oversight! thanks for catching that. thanks!. i'm not sure i understand - both appear to be dictionaries. the syntax in the first one (i.e. key-value pairs) wouldn't make sense for an array. \ndid you find when running your code that the object retrieved from toJSON() was an array? that couldn't be. or, perhaps, what you're pasting here what you see in the console..?. no problem :). of course!. but could you make the PR against develop instead of master ? develop is the landing page so it'll show immediately and it'll make it's way into master next release. that was a change made here https://github.com/hkellaway/Gloss/pull/119\nand, good point, it should have been applied to urlArray as well\n@ejmartin504 can you chime in again here as to why you think the escaping is a good idea ?. removed escaping as of version 1.2.0!. that was intentional. arrays in Swift are homogenous, i would not expect to have an array of various enum types. if that is something your application does have, i'd contend you should create a custom transformation. it seems to me this issue is similar in nature to this one - https://github.com/hkellaway/Gloss/issues/189\ni.e. what is the expected behavior for unexpected input. in that issue, we resolved that for unexpected input, decoding functions that returned arrays would not return partial or empty arrays but would return nil.\nthis is a bit different in that what programmatically unifies enums is that they are RawRepresentable - but from a model point of view, what unifies them is that they are of the same \"type\", i.e. belong to the same enum. \ni'm still of the mind that having an enum array with the same types is what is expected.. no problem reopening, of course.\ni don't see this as rude, but opinionated - the library expects homogenous arrays and will carry on effortlessly in that case. i find the potential for partial arrays adds an element of surprise to the output the library has, that i'd rather the specific application explicitly handle. that's how i personally  expect JSON libraries to behave; i took that original cue from other libraries like Mantle.. alright. something like including an 'allowPartialArrays' flag argument that is defaulted to 'false' in the operator definitions? or did you have another implementation in mind? and would you be willing to make a pull request to that effect?. i am not sure looking at that how recursion might address an issue. if you find you can, read the section in the README on including your own Custom Transformations. I've not written extensions much myself and do not have a way to get around a 'final' requirement while using inheritance. if anyone reading does, please chime in.. i just read this this morning:\n\"dynamic can be used to allow methods declared in extensions to be overridden\"\nhttps://www.raizlabs.com/dev/2016/12/swift-method-dispatch\ni haven't tried it myself though. nice, thanks!. @ed-mejia left a few comments. so sorry, I missed the additions. I left a question. I also need to thoroughly test this myself . looks like this needs to be rebased\n\n[ ] rebase. the Double type would normally be picked up by this function:\n\npublic static func decode<T>(key: String, keyPathDelimiter: String = GlossKeyPathDelimiter) -> (JSON) -> T?\nive yet to test your PR - but i'm wondering if this new function might interfere with the decoding of Doubles that are not NSTaggedPointerStrings?\n\n[ ] verify this doesn't conflict with current Double decoding. in the event this new type is added - there will also need to be updates to Encoder, tests, etc. you can view this PR to get an idea of what tall might be changed: https://github.com/hkellaway/Gloss/pull/243. following up on this - were you able to check on that question ?. closing now as i prepare a new version - please resubmit against a later version if still desired. there's nothing within Gloss to do that. i'd consider conforming your models to CustomStringConvertible and providing the required description variable.. @rbukovansky im not familiar with Linux in the least; not sure how to get Travis CI to build Gloss on Linux as well. @rbukovansky this PR seems to include changes already in develop not made by you (e.g. update to the CHANGELOG and podspec) - i'm having trouble telling what changes are specific to you. is there a way to remove any changes that weren't made by you?. Executed 170 tests, with 5 failures (0 unexpected) in 0.188 (0.364) seconds\nFailing tests:\n    -[DecoderTests testDecodeUInt64()]\n    -[DecoderTests testDecodeUInt64Array()]\n    -[FlowObjectCreationTests testObjectDecodedFromJSONHasCorrectProperties()]\n    -[FlowObjectCreationTests testObjectDecodedFromJSONHasCorrectProperties()]\n    -[OperatorTests testDecodeOperatorUInt64ArrayReturnsDecoderUInt64Array()]. no problem! i appreciate the effort. is there a reason not to have them besides the failing Linux tests..?. someone uses them https://github.com/hkellaway/Gloss/pull/168. @rbukovansky thanks for your work on this! apologies its taken me a while to get back around to it.\n\none stipulation i have about this is - i'm not at all familiar with Linux and cannot personally provide a guarantee from version to version that Linux won't break. can i hold you accountable for fixing issues if raised by Linux users? otherwise i cannot with good conscience offer Linux support.. regarding squashing - would you mind doing so ?. \ud83c\udf89 . hello @rbukovansky - i didn't have your email but wanted to put you in touch with another developer who would like to help support Gloss on Linux: @crspybits\ni'm going to add you both as Collaborators so i can tag you on Linux issues; i'd leave it to you two to communicate on who had the bandwidth to address the Issue. despite being Collaborators, i ask that you make pull requests (only against the linux branch) - and i'll be the one to make a final review and merge.\nif you're okay with sharing your email - please email me at hello@harlankellaway.com so i can put you in touch with @crspybits that way. @rbukovansky shouldn't this succeed on Travis?. will work on testing and merging these this coming weekend. thanks for your patience!. @rbukovansky a couple new tests were added and now the Linux build is breaking - see https://github.com/hkellaway/Gloss/issues/264\nhttps://travis-ci.org/hkellaway/Gloss/jobs/192383224\ni've added you as a Collaborator so that i'm able to tag you in Issues. though it grants you push access, i'd like, for now, to still orchestrate merges and releases - so if you could continue to submit Pull Requests in the same manner as before, that'd be great.. the branch where this is present is named linux. you'll probably want to create your own encoding function (see Custom Transformations: https://github.com/hkellaway/Gloss#custom-transformations). there isn't a feature like that. you may need to get creative with a Custom Transformation - here's an example https://github.com/hkellaway/Gloss/issues/113. thanks!. @heshamsalman thanks for taking a stab at this - though i had failed to recognize originally that this actually breaks support for Mac OSX, tvOS, and watchOS. so i'll be reverting these changes. i don't quite understand what you're describing. can you provide an example of the JSON?. given that JSON, you could create your models as such:\n``` swift\nstruct ObjectCollection: Glossy {\nlet objects: [Object]?\n\ninit?(json: JSON) {\n    self.objects = \"objects\" <~~ json\n}\n\nfunc toJSON() -> JSON? {\n    return jsonify([\n        \"objects\" ~~> self.objects\n        ])\n}\n\n}\nstruct Object: Glossy {\nlet value1: String?\nlet value2: String?\nlet value3: String?\nlet keyValue: String?\nlet nameValue: String?\nlet nestedObjects: [NestedObject]?\nlet someOrder: String?\n\ninit?(json: JSON) {\n    self.value1 = \"value1\" <~~ json\n    self.value2 = \"value2\" <~~ json\n    self.value3 = \"value3\" <~~ json\n    self.keyValue = \"key_value\" <~~ json\n    self.nameValue = \"name_value\" <~~ json\n    self.nestedObjects = \"nested_objects\" <~~ json\n    self.someOrder = \"some_order\" <~~ json\n}\n\nfunc toJSON() -> JSON? {\n    return jsonify([\n        \"value1\" ~~> self.value1,\n        \"value2\" ~~> self.value2,\n        \"value3\" ~~> self.value3,\n        \"key_value\" ~~> self.keyValue,\n        \"name_value\" ~~> self.nameValue,\n        \"nested_objects\" ~~> self.nestedObjects,\n        \"some_order\" ~~> self.someOrder\n        ])\n}\n\n}\nstruct NestedObject: Glossy {\nlet anotherValue: String?\nlet firstValue: String?\nlet value3: String?\nlet secondValue: String?\n\ninit?(json: JSON) {\n    self.anotherValue = \"another_value\" <~~ json\n    self.firstValue = \"first_value\" <~~ json\n    self.value3 = \"value3\" <~~ json\n    self.secondValue = \"second_value\" <~~ json\n}\n\nfunc toJSON() -> JSON? {\n    return jsonify([\n        \"another_value\" ~~> self.anotherValue,\n        \"first_value\" ~~> self.firstValue,\n        \"value3\" ~~> self.value3,\n        \"second_value\" ~~> self.secondValue\n        ])\n}\n\n}\n```\nand deserialization/serialization:\n``` swift\nguard let objects = ObjectCollection(json: json) else {\n        print(\"Failed deserialization\")\n        return\n}\nprint(objects.objects)\nguard let objectsJSON = objects.toJSON() else {\n        print(\"Failed serializtation\")\n        return\n}\nprint(objectsJSON)\n``. yes, simply conform to 'Encodable' instead of 'Glossy'. jsonify() does not return an array, it returns the Gloss type JSON - which is a dictionary of [String : Any]. @kampro are you able to follow up on the additinal comments to this pull request?. Merged separately from command line - this behavior will be available as of version1.1.2. @rbukovansky just released version1.2.0- and ended up reverting theISO8601DateFormatter` changes; so i imagine this PR is no longer necessary.\nsorry to drag this out longer - but can i ask you to rebase and re-test whichever of your PRs are to be merged? then i can do final testing and create a new release. Please follow this issue: https://github.com/hkellaway/Gloss/issues/242. sorry my mistake. thanks for sharing the fix!. the idea has just been to stick with JSON\nif you like the implementation Gloss uses, I'd encourage you to take inspiration and write those libraries yourself!. just checking in on this one - any movement. maybe we should keep linux support on a separate branch? that way if you need time to work on it, it doesn't block the development of the general library.. sure - just rebased linux on develop. there is no guarantee that the order of attributes are maintained. there is no implementation in the library that attempts to maintain some sort of order - and its not a feature that's intended to be supported. of course, folks can submit pull requests to that effect. thanks! would it also be 'major' instead of 'majorVersion'?. i'm open to considering that, but don't have the bandwidth right now to implement myself\nif desired, can you submit a pull request to that effect? it should also include Int64 as well as UInt32 and UInt64, and all their array counterparts. and tests should be updated to reflect that such values can be created from Strings.. @crspybits responses to code review have been inactive for over a month - closing for now; feel free to re-submit. good catch! will release a bug fix tonight. fixed in 1.2.1 \ud83c\udf89 \n. @rbukovansky reverting Linux additions to develop for now - we'll maintain experimental support on the linux branch. It should. Did you have an issue?. this was thought about - the ultimate conclusion being its more consistent with the rest of the decoding functions to return nil (https://github.com/hkellaway/Gloss/issues/189). for your case, you could do a custom transformation (https://github.com/hkellaway/Gloss#custom-transformations). in version 1.2.3 \ud83c\udf89 \n. can you provide the JSON and your Gloss model?. i tried your example - i do not get a boolean value, rather a fatal error at the force cast !. thanks!. hey - had a chance finally to think critically about this. I'm not convinced it's the job of the library to assume that Strings should be translated to other types - it could indeed represent malformed data and therefore a bug when the JSON-parsing succeeds. If it isn't malformed data, that's implementation specific - and you can do your own transformation explicitly.. Gloss cannot encode properly without being able to determine the type (e.g. Int, String, Encodable, etc.). hi @NausJessy - not sure if you noticed the code review request. tests need to be added to this PR.. if you have time, it would be good to also have the complement - Encoder update for Double. if not, i'll do when i have a chance. sorry this one got away from me @NausJessy - just rebased and merged manually into develop; so you'll see it in the 2.0.0 release. it means a value was found in the JSON for the image key but could not be transformed into a value\nhttps://github.com/hkellaway/Gloss/pull/277. can you provide the JSON and your Gloss model. the json?. the issue is with this line: let image: NSURL = (\"image\" <~~ json)\nGloss doesn't have decoding for NSURL - only URL.  if you can change that to URL, it should work fine - otherwise do your own transformation (https://github.com/hkellaway/Gloss#custom-transformations). i copy/pasted your model there using the latest Gloss version as well as the version you say you're using (1.0.0) and i am not getting any message about not conforming to a protocol, sorry.\nusually Xcode will help you out by allowing you to insert whatever function it is you're missing.. im not quite sure what you're asking for. you mean documentation on the fact that if one of your properties is an array of Gloss models it will be handled? all the types Gloss handles are listed, including arrays: https://github.com/hkellaway/Gloss#on-using-gloss-operators. i ran this example myself - except changed the type of flyerRegion to [[Int]] to reflect the JSON; decoding was successful. I've not run your test, just read through this. what is invalid about this JSON?\n[\"description\": \"A shiny JSON parsing library in Swift\", \"name\": \"Gloss\", \"owner\": [\"id\": 5456481, \"login\": \"hkellaway\"], \"language\": \"Swift\", \"id\": 40102424]\n. yeah - i saw that and was thinking similarly \ud83d\ude11  perhaps JSONDecodable and JSONEncodable. \ni'll create a swift_4.0 branch for if you or any of the WWDCers feel inspired to get tinkering. Neat ideas! Though I had not considered a re-write on top of Swift JSON parsing. I was simply going to update for compatibility. I was more viewing this an opportunity to eventually halt feature development as native JSON parsing gains popularity. I don't have the bandwidth to personally support Gloss indefinitely.\nI agree there's room for a DSL on top of Swift's and others are free to take that notion and other ones present in Gloss and run with it.. @lastcc im interpreting this as 2 separate questions\n\nim not familiar with ObjectMapper - taking a quick look at their docs, maybe you're talking about their TransformOf syntax? no, there is not an equivalent in Gloss\ntrue, the naming of the framework targets could be more precise as you describe. @ergunkocak swift_4.0 is currently the same as master so you can point to 1.2.4 in your private spec. once updates for Swift 4.0 are made i can release specific betas on CocoaPods, sure. thats good to know, tnx @ryanschneider . fyi - version 2.0.0-beta.1 has been released with minimum changes for Swift 4 compability. @GabrielAraujo i appreciate you asking - i could use assistance.\n\nversion 2.0.0-beta.1 should work with Swift 4. however, it would be nice to have uniquely named protocols to disambiguate from Foundation. i was thinking JSONDecodable and JSONEncodable.\nare there other Swift 4 migration tasks you see?. @GabrielAraujo i think i still prefer JSONDecodable and JSONEncodable, more descriptive\nif you'd like to help move to that, that'd be great. thanks @gabrielaraujo! im okay leaving those as-is. naming will be updated to JSONDecodable and JSONEncodable as of version 2.0.0-beta.2\nthanks @GabrielAraujo!. just giving folks time to report any issues with the Swift 4 version before the official release of 2.0\nthere is one outstanding PR submitted before Swift 4 transition I want to revisit . can yo provide the JSON itself, not what's printed in the console. with these models:\n```\nstruct MyObject: Decodable {\nlet message: String\nlet authToken: String\nlet data: MyData\nlet isVerified: Bool\n\ninit?(json: JSON) {\n    guard\n        let message: String = \"message\" <~~ json,\n        let authToken: String = \"auth_token\" <~~ json,\n        let data: MyData = \"data\" <~~ json,\n        let isVerifiedNum: Int = \"is_verified\" <~~ json\n        else {\n        return nil\n    }\n\n    self.message = message\n    self.authToken = authToken\n    self.data = data\n    self.isVerified = (isVerifiedNum == 1) ? true : false\n}\n\n}\nstruct MyData: Decodable {\nlet id: String\nlet phoneNumber: String\n\ninit?(json: JSON) {\n    guard\n        let id: String = \"id\" <~~ json,\n        let phoneNumber: String = \"phone_number\" <~~ json else {\n            return nil\n    }\n\n    self.id = id\n    self.phoneNumber = phoneNumber\n}\n\n}\n```\nthis works as expected:\n```\n        let json: JSON = [\n            \"message\" : \"OTP is sent to your phone to verify your account\",\n            \"auth_token\" : \"\",\n            \"data\" : [\n                \"id\" : \"12\",\n                \"phone_number\" : \"+91-XXXXXXXXXX\"\n            ],\n            \"is_verified\" : 0\n        ]\n    guard let myObj = MyObject(json: json) else {\n        print(\"DECODING FAILURE :(\")\n        return\n    }\n\n    print(myObj)\n\n```. would you be able to submit a PR with the suggested update to documentation?\nand for the data convenience function can you file a separate Issue and include the JSON and your model(s). For all types, Gloss returns nil in the case there was an issue parsing the indicated value\n (see https://github.com/hkellaway/Gloss/issues/189). Changing this just for enum arrays would make the behavior different in only this one case\nIf a different behavior is needed specific to your application, you can create custom functions like the one indicated. reading this is seems like one would always get an array of values or an empty array - and to maintain the same behavior as today, it would have to return nil, not an empty array\ncan you provide an example of the usages you're referring to - one with a default and one without? i'm not sure i fully understand. ah yes, i see what you're saying - that's neat. should probably have the same functionality for just an enum as well as the array variety\nwould you be able to create a PR with that functionality along with tests?. Calling UserData.toJSON() implies toJSON() is a static function on UserData. what you need is an instance of UserData to POST.\ni.e. \nlet myUserData = UserData(firstName: \"Usama\", email: \"a@b.com\", lastName: \"Bin Attique\", password: \"Abc123\")\nlet json = myUserData.toJSON()\nhere, myUserData is an instance of UserData. try using the explicit namespace - Gloss.Decoder. naming will be updated to JSONDecodable and JSONEncodable as of version 2.0.0-beta.2. from the sound of the error message it's that a public initializer needs to be added to GlossJSONSerializer as such:\npublic init() { }\ncan you try making that change to the pod locally and seeing if it fixes the issue?. I'll update the swift_4.0 branch accordingly. thanks!. @jannejava merged - you can now work off branch swift_4.0. i think the simplest course of action would be changing their names (i'd say JSONDecodable and JSONEncodable); until then, Gloss.Decodable and Gloss.Encodable should work for clients.\nif you're interested in helping out, there's a swift_4 branch with no activity on it as of yet. naming will be updated to JSONDecodable and JSONEncodable as of version 2.0.0-beta.2. Travis hasn't completed yet, but i'm guessing it might fail - probably need to update .travis.yml to use xcode9, perhaps OS=11.0. @ryanbaldwin can you give updating the Travis file a try per my comment above?. these changes were included in this PR: https://github.com/hkellaway/Gloss/pull/307. @andrewjmeier great! can you actually re-submit this PR against the swift_4.0 branch?\nafter merging that, i'll attempt to release a beta version to cocoapods\nuntil then, you can always point to your own Gloss branch/commit in your applicatin's Podfile to continue using the library (unless you're using it as a subspec in your own pod). @andrewjmeier this is no longer passing Travis :/ Invalid redeclaration of 'init()'. fyi - version 2.0.0-beta.1 has been released with these updates \ud83c\udf89 . hm, seems you should use Gloss, '2.0.0-beta.1' specifically. i will update the README.. i'm genuinely not sure if there's a way to solve that problem with the current implementation as im not 100% sure what you're describing. if you could provide a concrete example, that might help. also not clear on what a general-purpose init?(json: JSON, option: Any) would be for. \nas you've gathered, the library is quite straight forward - given a type, it'll try to decode/encode and be a little smart about arrays and dictionaries.. cool. works for your use case?. im not certain the issue. if you\u2019re using nested key paths that was causing a crash in certain versions including 0.7.4 (https://github.com/hkellaway/Gloss/issues/135). that feature was removed in 0.8.0. if that\u2019s your issue, perhaps try removing nested key paths and using 0.8.0 or turning off optimization\nim no longer actively supporting Swift 2.x fyi, and so am not troubleshooting further. hope that helps.. no, toJSON() is intended to produce a JSON dictionary.\nyou could create a function custom to your application to map over your Skills and gets the ids instead of attempting to use the toJSON() function. thanks @rbukovansky! \ud83d\ude38 . ive not encountered this myself; so i'm not sure what's going on.\nwhat version of Gloss are you using?. this issue may be from you as well? https://github.com/hkellaway/Gloss/issues/314\nas mentioned there, if you\u2019re using nested key paths that was causing a crash in certain versions including 0.7.4 (#135). that feature was removed in 0.8.0. if that\u2019s your issue, perhaps try removing nested key paths and using 0.8.0 or turning off optimization\nim no longer actively supporting Swift 2.x fyi, and so am not troubleshooting further. hope that helps.. looks good, just waiting for CI to pass. hm CI failed at pod lib lint --quick\n[!] InvalidGloss.podspecfile: undefined methodswift_version=' for #. sure, can mention in the next release Changelog notes that Linux isn't supported. Failing CI - perhaps becausecompactMapis Swift 4.1 only i believe. im going to make aswift_4.1branch - you can recreate this pull request against that. you may also need to specify inGloss.podspecthats.swift_version    = \"4.1\". great, thanks. CI is failing though. perhaps try updating.travis.ymlwithosx_image: xcode9.3. addressed in: https://github.com/hkellaway/Gloss/pull/327. can you create this against theswift_4.1` branch. it may also be the same as this PR: https://github.com/hkellaway/Gloss/pull/324\nwill review whichever one passes CI. can you try updating .travis.yml with osx_image: xcode9.3. yes, compactMap is Swift 4.1 you can use Gloss version 2.0.1. thanks for tracking that! glad to see its not a blocker. feel free to submit cosmetic changes that don't impact functionality but keep AppCode happy\ni'll take the platform though to document that i won't personally be supporting AppCode. can you provide example JSON and the data structure you're wanting to create from it?. here's one way to do it @humayunharoon:\n```\nstruct Geometry: JSONDecodable {\ntypealias Coordinate = [Double]\n\nenum `Type` {\n    case polygon\n    case unknown\n\n    init(string: String?) {\n        guard let string = string else {\n            self = .unknown\n            return\n        }\n\n        switch string {\n        case \"Polygon\":\n            self = .polygon\n        default:\n            self = .unknown\n        }\n    }\n}\n\nlet type: Type\nlet coordinates: [Coordinate]\n\nstatic func example() -> Geometry? {\n    let exampleJSON: JSON = [\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [6316441.4998557, 2238781.999901123],\n            [6316597.000106672, 2238781.750082011]\n        ]\n    ]\n    return Geometry(json: exampleJSON)\n}\n\ninit?(json: JSON) {\n    guard let coordinates: [Coordinate] = \"coordinates\" <~~ json else {\n        return nil\n    }\n\n    self.init(type: Type(string: \"type\" <~~ json), coordinates: coordinates)\n}\n\ninit(type: Type, coordinates: [Coordinate]) {\n    self.type = type\n    self.coordinates = coordinates\n}\n\n}\nfunc <~~ (key: String, json: JSON) -> [Geometry.Coordinate]? {\n    return Gloss.Decoder.decodeCoordinates(key: key, json: json)\n}\nextension Gloss.Decoder {\nstatic func decodeCoordinates(key: String, json: JSON) -> [Geometry.Coordinate]? {\n    guard let coordinates = json[key] as? [Geometry.Coordinate] else {\n        return nil\n    }\n    return coordinates\n}\n\n}\n```\nto see the example in action:\nlet example = Geometry.example()!\nprint(example.type)\nprint(example.coordinates). im not currently familiar with Swift Package manage and how it works, so cannot provide a solution for this. there must be a way to have tests in a project and not have Swift Package manager fail \ud83e\udd14 . mistake on my part, i'll take a look. if you want to point to a specific branch at the moment, release/2.0.1 has this fix; will be making an official 2.0.1 release some time today. welcome! 2.0.1 is out. I am so sorry I missed responding to this! there is a swift_4.1 branch where this is updated. these are the types that Gloss handles automatically: \nhttps://github.com/hkellaway/Gloss#the-decode-operator-'\nThat doesn't include [String :  [String : Decodable]] (we could imagine tons of variants like this so Gloss has a minimum set of typical ones)\n--\nIf you want to stay in the semantic pattern of Gloss, consider adding an extension to Decoder and Encoder that decodes/encodes that special value for you (and new <~~ and ~~> operation definitions even). \n^ but, that's not necessary - it would only to have your models be consistent in their usage of that operator. this is psuedocode. i don't know if this will work, just a place to start trying:\n```\nextension Decoder {\nstatic func decode(customDictionaryForKey key: String, json: JSON) -> [String : [String : Decodable]]? {\n    // logic to extract your type from json, nil if it fails\n}\n\n}\nfunc <~~ (key: String, json: JSON) -> [String : Decodable]]? {\n    return Decoder.decode(customDictionaryForKey: key, json: json)\n}\n```. perhaps the type of currebtUserJSONData is not defined as the Gloss JSON type. it looks from that code like SwiftyJSON may also have its own JSON type so you\u2019d have to specify:\ntry:\nguard let currentUserJSONData = QueriedJsonData[0] as? Gloss.JSON\nor\nas? [String : Any]\nsince Gloss.JSON is just a typealias for [String : Any]. that doesn\u2019t indicate a problem with Gloss, rather perhaps CocoaPods or Xcode configuration.. im genuinely not sure what the issue is. id try exploring integration issues with CocoaPods or Xcode - clear DerivedData, make sure yr using a stable version of CocoaPods, search CocoaPods issues / Google your specific error . Gloss has a finite amount of types it handles automatically (https://github.com/hkellaway/Gloss#the-decode-operator-) - arrays of arrays of Decodable is not one of them. you\u2019ll have to create your own decoding logic for that . good catch ! i've fixed that. you can point to develop or commit 5f848a0db7c0b89e128e0a75d2b5b7b5e78525b3 until the next release. no you're not missing something!\nwhat i'd actually advise - it sounds from the types you're writing that you may be close the start of a project, it might be better to utilize the first-class Codable framework instead of relying heavily on a third-party.. good call - will update & release 2.1.0. stay tuned. as of right now, you can point to develop or commit f9dfa86476a5f9e2ffeb777dfb3f98f52a23e16f for Swift 4.2\nstill working on releasing to CocoaPods, having issues pushing the updated podspec. released - find in version 2.1.0 \ud83c\udf89 . looking into it. so instead of guard let topStory: NewsItem? = \"topStory\" <~~ json use the following:\nguard let topStory: NewsItem? = \"topStory\" <~~ json\ni.e. its NewsItem not NewsItem?\nits displaying that error because its looking for non-optional NewsItem not NewsItem?. thats a good point; i hadn't registered that - i'll switch to standard\n. good call \ud83d\ude05 \n. @marcopompei do you know what MultiplicationPrecedence signifies? i.e. are there other types and is this the correct one?\n. @marcopompei fascinating! my first impression is that the custom one is more intelligible. looking at those values though - i think it would be higherThan: AdditivePrecedence, to keep it the same. is it preferable to choose CastingPrecedence do you think?\n. i agree it's more expressive. would you mind adding that custom precedence with this PR?\n. two is fine - DecodingPrecedence and EncodingPrecedence\n. its not clear to me this function actually belongs in Encoder. i get its here because its used by jsonify which is then used for encoding behavior - but jsonify is meant to be a convenience function and Encoder doesn't \"know\" anything about it. i think this might better be placed alongside jsonify in Gloss.swift\n- [ ] consider moving setValue\n. i don't think we need to mark the entire extension public - lets just remove that keyword here and mark the individual functions with their access modifiers\n. to be consistent, can you move this private function under a separate MARK: -\n- [ ] MARK\n. the library uses Any now instead of AnyObject. to be consistent - can we update the signature on this function\n- [ ] use Any\n. i think that Encoder already has its clear responsibility - it transforms input values into JSON. this setValue function doesn't inherently have anything to do with that - we just happen to know its used for that purpose. it's more like a JSON utility function that we use for encoding.\nthis functionality was before in the Dictionary extension and it made more sense to me there\n. i don't get that warning. but if you do - okay.\nthen we should explicitly make init(elements:) and flatMap(_:) as internal\n- [x] mark non-public Dictionary functions as internal\n. can you move your new assertions into the test above (called testDecodeNestedModel)?. can you add code with an example of how to do so?\n\n\n[ ] improve documentation. would this not need to be added to every array decoding function - instead of just for simple types and enums - to keep things consistent?\n\n\n[x] address this question. TestPartiallyDecodedModel.swift\n\n\nCopyright ( c) 2016 Edison Mejia\n\n\n[ ] update credits. i've not tested this PR yet - does encoding work as expected for partial arrays? do we need to add tests to make that explicit?\n\n\n[x] verify Encoding works as expected. change to as? JSON. change to as? JSON. i'd prefer the initializer take in Data instead of optional Data? - let the client unwrap that Data. i'd prefer the initializer take in Data instead of optional Data? - let the client unwrap that Data. I don't really understand this response - can you clarify a bit more? why does this make sense specifically for only simple types and enums..?. sorry - let me phrase this differently, because i still don't understand. \n\n\nwhat is special about decodableArrayForKey and enumArrayForKey that the check for they ArrayPartiallyDecodable type whereas the other array functions do not?. why specifically decodableArrayForKey and enumArrayForKey. to match the semantics of the current creation-from-array functionality, the function signature should be:\nstatic func from(data: Data) -> [Self]?. to match the semantics of the current creation-from-array functionality, the function should return nil in the event that [Self].from(jsonArray: json) fails - not an empty array. ah - sorry for being dense. \ni don't think it makes sense for an end user of this library that only simple types and enum types would be partially Decodable - one would expect any type to be so. what do you think?. it's not that I'm deadset against this feature - i just don't want to include it if there's an aspect of confusion to it for end users. if it works in certain cases and not others, Decoding may become unpredictable. \nsorry it didn't work out with this implementation - i do appreciate your time and effort on it!. ",
    "Haud": "Yes!\nI've had time to take a deeper look into the code base. My thoughts are maybe there can be two operators: <~? for optional and <~! for non-optional. I think it's more immediately clear that way which operator does what, though I'm ok with <~~ and a non-optional type: <~~! or something.\nI would also be more in favor of a init( json: JSON) as the protocol method than fromJSON, though I do understand its semantic equivalent in Encoder's toJSON\n. ",
    "michaeleiselsc": "Please figure all of this out then, before we risk needlessly splitting the developers on which library to use.\n. What are the pros of a Swift implementation, simply the ability to change Swift code if you want to change the library?\n. If there are API differences enabled by Swift, that's fine, I just wanted to make sure that there were. It would still be good to note Mantle in the README.\n. ",
    "morganchen12": "@michaeleiselsc If this library was an exact Swift port of Mantle, how would you propose this issue be resolved? By deleting this repository? Is there anything constructive that could come out of this question?\nEven as a totally academic pursuit, it's worthwhile to have Swift ports of Objective-C libraries in order to highlight the differences between the two languages especially as Swift matures and especially as new developers and developers from other communities familiarize themselves with iOS and OS X development. In practicality, a relatively simple Swift library like this one may help newer developers learn how to contribute to open source codebases. This codebase makes extensive use of curried functions and other functional paradigms, which may help older object-oriented folk understand functional programming basics. \nAt the very least, if this library becomes massively popular, it won't split the community any more than the introduction of Swift already has.\n. Yeah, just squashed a bunch of merge conflicts. Not perfect yet though, still got some issues.\n. Should be good now.\n. When serializing concrete model objects from arbitrary data, it's usually a given that not all data will result in a valid model object. In this case, it makes sense to return nil from the initializer as an indicator of failure, rather than returning a non-nil model object with all of its fields set to nil. In the case where some fields are essential and must not be nil (i.e. a User model fetched from a remote database somewhere might not make sense without its unique id), a failable initializer allows us to express this requirement as a non-optional field without the use of force-unwrapping, which as you know is crashy and frowned upon.\nThe init? definition in the protocol doesn't forbid adopters of that protocol from defining a non-failable initializer, it just indicates that some serialization may fail.\n. Hm, looks like the code examples in the README may need to be updated as well.\n. ",
    "fdiaz": "If you use Mantle, you'd need to subclass MTLModel which conforms to NSObject. If you want to use a lightweight struct for your data model, Mantle just won't work (as long as I'm aware).\nI'd say that Mantle is a really good Objective-C solution for this problem, this library is trying to tackle the same problem from a Swift point of view.\n. ",
    "AndrewSB": "thank you @hkellaway :smile: \n. Apologies for the unrelated interjection:\n@tholo how did you embed that diff?\n. I was trying to ask how you embedded this code snippet\n\n. Ahh, thats a really cool feature.\nThanks @tholo\nOn Tue, Jun 21, 2016 at 9:42 AM Thorsten Lockert notifications@github.com\nwrote:\n\nOh. Used the standard markdown for code, in this case specifying that it\nwas in \"diff\" format...\nSo, pasted in some code (diff output, in this case), and wrapped it in\nbacktick sections with the opening section saying\ndiff\n... lines ...\nThis is documented in Creating and highlighting code blocks\nhttps://help.github.com/articles/creating-and-highlighting-code-blocks/\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/hkellaway/Gloss/issues/135#issuecomment-227498997,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ADo1dFwp0mfrJMRmY9TJSRYjwEQD5a3gks5qOBR7gaJpZM4H2j4U\n.\n. I was unclear, sorry @hkellaway.\nI realized what I want is easily fixed by initializing a User inside Person's initializer.\n\nThank you!\n. ",
    "bojan": "Since the pods can be recreated using the podfile at anytime, we shouldn't add the Pods directory, only the podfile. It's just good practice to keep your repository cleaner.\n. @hkellaway I've manually added the GlossExampleTests target and the test seem to work just fine. Few of them fail, but the target compiles.\n. Also, before I push the new commits, I've noticed that the deployment target of the library is iOS 9.0. No iOS 8 support or is this a mistake?\n. I've updated the readme for a better Carthage integration. Everything should work now.\n. @hkellaway Great :+1: When's 0.5.3 coming? \n. ",
    "ikravchenko": "Thanks for your help!\n. ",
    "nuudles": "Yeah, I think it makes more sense to encode it as an empty JSON array. In my case, I have a non-optional array property of my struct, so it currently fails since the encoded JSON doesn't include the empty array. I end up having to do something like:\nself.array = \"array\" <~~ json ?? []\nWhich is less than ideal.\n. Awesome, thanks!\n. @hkellaway I set the optimization level to None for the framework, which enables me to use the framework for now, but I don't believe it to be a long-term solution; I'd rather have the optimization settings set for Release mode as recommended by Apple.\n. ",
    "CodeEagle": "It's working on Mac OS X.\nJust copy and paste in a Cocoa Framework\nSupport Mac OS X just like iOS!!\n\n\n. final is marked can not be subclassing, is that right?\n. ProductDetail subclassing Product ?\n. Could you paste your code here?\n. not that clear, sorry buddy, thus I wanna take a look at it for sure\nif you want to reuse you code, abstract one base Class for Product and  ProductDetail\n. got it\n. ",
    "ed-mejia": "Hey thanks mate!, this really put it clear to me.\nBtw I came here because I read your blog http://harlankellaway.com/blog/2015/07/05/swift-json-parsing-by-example/\nI ended using your solution since it seems less complicated and allows me to deal with object construction within the init?(json: JSON) which is great but it seems that the only benefit here is the use of the operator <~~ otherwise we would end just crating an object as a normal init in your model.\nI was trying to implement ObjectMapper before, I must say it has really good features like nested values using dot notation, the func value(), valuerOrFail(), valueOf(default) are really awesome tools but unfortunately it doesn't work well on real world scenarios where JSON are big, diverse and more complicated that the usual \"samples\"\nThanks again great work :+1: \n. I agree with @hkellaway about keeping the right values for optimisation and dropping the feature.. but must to say as well like many others, that dot notation was a killer feature for me and it is really sad to go back to the messy nested handling \u2639\ufe0f\n. Yayyyyy!!!!! thanks @ferusinfo ... AWESOME!\n. In my case color_elements is homogenous, but contains a value not present in the enum... I think that should not avoid the generation of the array... just ignore it... all values are the same type of the enums \"Strings\". Let me know what do you think about this, otherwise I will follow your suggestion about creating a custom transformation for this case and we can close this issue.. Fair enough, I will go with the custom transformation.\nThanks \ud83d\udc4d . Sorry for the re-opening...\nI think actually that way of working is introducing limitations to the library.\nFor example I'm actually working on a news feed api, it could return different types of objects under the same root container \"items\" this way:\n```\n{\n  \"data\": {\n    \"pagination\": {\n        \"total\": 11124,\n        \"per_page\": 30,\n        \"offset\": 0\n    },\n    \"items\": [\n      {\n        \"picture\": \"Some picture\"\n      },\n     {\n       \"story\": \"Some Story\"\n     },\n    {\n      \"video\": \"Some video\"\n    }\n    ]\n }\n}\n```\nThe library now requires all elements within items must be the same model, which is a very rude... so now I can't do something like this \npictureList = \"items\" <~~ data ?? []\nstoryList = \"items\" <~~ data ?? []\nvideoList = \"items\" <~~ data ?? []\nbecause the library will stop parsing all element in the array....  I think the idea should be to facilitate functionality not to impose a particular way of thinking? \nI think it should not be considered as a parsing error to find some different element type within the parsing array... the lib is not being open to \"internet\" in which many requirements and many situations might me present.\nWhat do you think with this scenario?\n. Yep, opinionated... \nIt is a restriction based on an opinion of how should behave, of course there is no right or wrong with this case.\nWould be nice at least, to provide the option and let the users decide how they whant to use the library instead of forcing a particular point of view of how they should do it, well that's just my opinion.\nSo yes... I will have to follow the custom transformation way for everything that implies this scenario, even for normal arrays \ud83d\ude29\nAs an extra note: this is a library to deal with parsing json, I think that for something as wide as json data could be, the lib should be as open to many scenarios as possible, yes in the prefect world everything should be homogenous, but sometimes you will not have access to the API, you will not be able to create the API structure but just consume it and then you will be struggling, obviously you can always create your own custom transformation which I think is the only option available (which is not bad at all)\n. @hkellaway  Any chance to make the behaviour optional to let users decide how they need the lib to behave in these particular scenarios?\nI'm ok dealing with a custom transformation for enums, but doing the same for general arrays doesn't feels right. \n. Sure, I would make a pull request tomorrow I already did some testing using Protocol conformance instead of a flag.\nMy idea, in order to do not mess with the actual implementation is to create additional protocols \npublic protocol PartiallyDecodable { }\npublic protocol PartiallyEncodable { }\nThis way if you need to make your model \"partially\" decodable or encodable you just conform to this protocol, no need for a flag messing around \ud83d\udc4d and it could apply to any array type (enums, structs, class)\n. Not sure about naming though!..\nBecause the idea of this is that it will apply when parsing arrays of the types implementing those protocols, if I see any type implementing that I could think it means that the actual type could be somehow partially parsed which is not correct.\nthinking about it...\n. Hi, @hkellaway thanks for the feedback, I will have a look and will come back asap \ud83d\udc4d . @hkellaway I did some minor updates and added some explanation to your questions, let me know what you think . Hi @hkellaway any feedback about this PR?. Encoding relies on the implementation of Encodable protocol so, it doesn't matter since any type of object implementing the protocol would be able to be Encoded.\nI think this logic applies to Decode since it is an external data (JSON) we don't control, but when encoding you rely on the type system and you have proper objects in place.\nI was trying to get some scenario when Encoding partially would be useful the same way Decode is but nothing pops in...\nIf you have some ideas please let me know.. Done. I was thinking about that as well, but the problem is that if you apply that logic to primitive types you would not be able to distinguish when you want that to happen, when you create your own type (struct, class, enum) you can specify \"hey I want just this model to be able to be partially parsed\", but to apply that to primitive types like URL, Dates, Bool etc.. you would have to adopt the protocol to the type via an extension making the type partially decodable throughout the entire code base so you can't have control over it... \nFor this case if you need that functionality then you will have to create a wrapper on top of the primitive value like:\n```\nimport Gloss\nstruct PartiallyDecodableBool: Glossy, ArrayPartiallyDecodable {\nlet value: Bool\n\n// MARK: - Deserialization\n// ...\n\n// MARK: - Serialization\n\n}\n```\n. Improved. . @hkellaway when you apply the PartiallyDecodable logic to a user defined type it's applied only to the types you need to, if you apply that to primitive types then ALL types will become PartiallyDecodable which is not the intended functionality, the user must indicate what needs to be Partially or not, that's why I wrote the PartiallyDecodableBool wrapper example.. hehehe no problem, that's the issue, is not about those functions it's about to who those functions will be applied to, let's say we add the logic of ArrayPartiallyDecodable to any array of Bools, we could do that right? the problem will be that you will not have any way to distinguish if the user wants that for just a particular array of Bools or.. for ANY array of Bools since once you apply ArrayPartiallyDecodable to the primitive type then it will apply for Any Bool. @hkellaway \ud83d\ude44  because those are the only one acepting Generics \"T\", this means you can pass custom types not concrete types like all the other functions. If you still don't understand me the only way to clarify this is for you to try to make this function partially decodable:\npublic static func decode(dateArrayForKey key: String, dateFormatter: DateFormatter, keyPathDelimiter: String = GlossKeyPathDelimiter) -> (JSON) -> [Date]?\nYou can't apply the same logic here, if you know how please let me know I'm black!. No Worries, I clearly understand you don't want to include this feature in the repo, it's being a large debate on this, honestly I just tried to find a generic way to solve a problem that came to me and that potentially could happen to other users while keeping it in the same Repo, I see it just as something useful you could use if needed, the solution is non intrusive and at the end of the day (as everything in life) has requirements in order to work (for me it makes sense)\nI will try to find some other way to solve the problem that I still have and I haven't been able to work around any other way.\nThanks for the time though, and no issues, everything's cool you have the right to push the project the best direction you think it should be. \ud83d\udc4d . ",
    "Broich": "@hkellaway Agreed and thanks for the link to the custom transformations. However, do you have an idea why the CI tests failed. I could not really make sense out of the error log other than it is some kind of a configuration issue.\n. ",
    "ishaq": "great :-)\n. yes.\n. no. because Product is final\n. @CodeEagle what are you getting at if I may ask?\n. 1. Write a class that implements any of Gloss protocols (these are Glossy, Decodable and Encodable).\n2. The compiler will tell you that you need to mark the class final.\nDoes it help?\n. I know this is an academic discussion when it comes to Swift or Obj-C, but here I go anyway: Fast enumeration does not guarantee iteration order. (Swift docs don't say this, neither do Obj-C).\n. ",
    "bachino90": "This is my solution to this issue: https://github.com/hkellaway/Gloss/pull/103\n. ",
    "micpringle": "Great, thanks!\nApologies for not responding sooner, but it's just been crazy lately.\n. ",
    "RahulKatariya": "It looks if i don't use extension then there is no error.\n```\nimport Gloss\nstruct Response: Glossy {\n    var errorMessage: String?\n    let status: Bool\n    var data: T?\ninit?(json: JSON) { \n    guard let status: Bool = \"status\" <~~ json else { return nil }\n\n    self.errorMessage = \"errorMessage\" <~~ json \n    self.status = status\n    self.data = \"data\" <~~ json\n}\n\nfunc toJSON() -> JSON? {\n    return jsonify([ \n        \"errorMessage\" ~~> self.errorMessage,\n        \"status\" ~~> self.status,\n        \"data\" ~~> self.data\n    ])\n}\n\n}\n```\n. The toJSON() is not working correctly right now. If you are interested in this feature then i can spend more time optimising it and include test cases.\n. Value for key path increases the flexibility. If we have a JSON like below.\n{\n    \"addressLine\" : \"\",\n    \"city\" : \"\",\n    \"state\" : \"\",\n    \"location\": {\n        \"lat\" : 23.0078201,\n        \"lng\" : 88.5428696\n    }\n}\nthen we can skip the Location struct and use location in directory Address object using keyPath\n```\nstruct Address: Decodable {\nlet addressLine: String?\nlet city: String?\nlet state: String?\nlet latitude: Double?\nlet longitude: Double?\n\n// MARK: - Deserialization\n\ninit?(json: JSON) {\n    self.addressLine = \"addressLine\" <~~ json\n    self.city = \"city\" <~~ json\n    self.state = \"state\" <~~ json\n    self.latitude = \"location.lat\" <~~ json\n    self.longitude = \"location.lng\" <~~ json\n}\n\n}\n```\nThis pull request is working fine in Deserialisation but not while converting back to JSON().\nFor example you can run the test case at https://github.com/RahulKatariya/Reactofire/blob/master/ReactofireTests/ReactofireTests.swift\n. Hi Harlan,\nI have fixed the toJSON() method and have also added the test case which you can see at https://github.com/RahulKatariya/Gloss/blob/glossy-keypath/Sources/GlossTests/KeyPathTests.swift\nBest Regards,\nRahul\n. \ud83d\udc4d\ud83c\udffc\n. @hkellaway Sorry i was on weekend vacation. I have one more pull request to make which i think could be available in 0.7.0. There is some issue in modelsArrayFromJson.\n. I have opened the issue #106 .\nI am trying to work on it. Hopefully i would be able to make it today.\n. You don't have to extend Int to conform to Decodable. It will just work. Below is the code for model for that json.\n```\nstruct Dummy: Decodable {\nvar name: String\nvar values: [Int]?\n\ninit?(json: JSON) {\n    guard let name: String = \"name\" <~~ json else { return nil }\n\n    self.name = name\n    self.values = \"values\" <~~ json\n}\n\n}\n```\n. You could also use the default parameters keyPathDelimiter: String = GlossKeyPathDelimiter() instead of two functions. It will behave the same.\n```\npublic static func decodeDecodable(key: String, keyPathDelimiter: String = GlossKeyPathDelimiter()) -> JSON -> T? {\n    return {\n        json in\n    if let subJSON = json.valueForKeyPath(key, withDelimiter: keyPathDelimiter) as? JSON {\n        return T(json: subJSON)\n    }\n\n    return nil\n\n}\n\n}\n```\n. \ud83d\udc4d\ud83c\udffc\n. The solution works but I guess this will increase more work for the developer. \nJSON could be Object, Array, String, Number and NSNull.\nRefer to https://github.com/thoughtbot/Argo/blob/master/Argo/Types/JSON.swift. It is handling all the scenarios of JSON.\nThe same issue exists with Alamofire also. The parameters are the type of [String: AnyObject] so it doesn't allow us to send post requests using Array of objects. We always have to keep a rootKey like \"results\" and then pass the array into it.\nhttp://stackoverflow.com/questions/27026916/sending-json-array-via-alamofire\nI can work on this with the test cases if you like. I kind of need this functionality to save myself from extra work \ud83d\ude0b.\n. Update: I was able to solve this in Reactofire itself and it seems to work without changing the Gloss Library. Regards\n. Every time you make a change in Gloss and write a test case. To check the functionality you need to open Example Project and run the tests. \nIdeally it should be contained in Gloss because we are testing the framework itself. \nWhen i made the first pull request i thought this library doesn't contain any test cases because everyone writes the test cases in the framework itself.\nAny thoughts ?\n. You may discard it if its easier for you that way. But i feel ideal place to keep tests for framework is in framework itself.\n. \ud83d\udc4d\ud83c\udffc.The reason i used that syntax was because I was trying to conform Array to Decodable and Encodable. Apple is going to allow inheritance with where clauses. So we will be able to write like extension Array: Decodable where Element: Decodable. This will allow to play only on protocol without worrying about the type. \nPlus the initialisation is the standard way provided by Apple. We can initialise swift string array using [String](). In this case we are having parameters.\nWe can also provide modelsFromArray and toJSONArray with the deprecated mark on them so it doesn't break existing Api but only warn people to switch to the new syntax.\nAny thoughts?\n. ",
    "op": "Amazing. Thank you! :dancer: \n. ",
    "Pericharan": "Hi hkellaway, first congratulations, its really nice library for json to object, but i am having issues when i convert object to Json with toJSON. The sample toJson is below. its creating ( brackets instead of { and has = sign instead of : in key value. So its not a valid json. Only URL are wrapped in double quotes other strings are not..  So could please help me clarify what setting needs to be set to get the correct json. Note: i ran your sample program i still got the same answer.. \n[\"products\": (\n {\n \"id_dt_ot_product\" = 1;\n \"product_image\" = \"HTTPS://UPLOAD.WIKIMEDIA.ORG/WIKIPEDIA/COMMONS/7/7C/CAPPUCCINO_CHIANG_MAI.JPG\";\n\"product_name\" = CAPPUCCINO;\n}\n)]\n. ",
    "kentwinder": "No, it's the result in Response class, not the result from Alamofire\nHere is the log\nTest_Project.Response<Test_Project.TestResponse>(status: Optional(\"success\"), message: nil, result: nil)\n. Oh, works like charm!\nThank you very much, have a good day! ^^\n. ",
    "HEYGUL": "That is perfect help!\nI was looking on extending Decoder to add a custom decode method but was not sure how to do it.\nMany thanks for your great help!\nNote: do not worry for dates, it is ISO8601 and already handled thanks to your great lib.\n. ",
    "ejmartin504": "Looks to be no longer an issue on the current development branch, using the new fromJSONArray() method.\n. Whoops, realize you wanted it to be open before your release -- my bad :-)\n. I definitely see your point, though we would then lose the convenience of the glorious Gloss custom operators. \nI agree that you don't want to make too many assumptions on the client's behalf, but on the other hand, I don't see many clients objecting to a straightforward sanitization of their strings. In our case, all we want is to simply get an NSURL object from a URL string -- we're not really doing anything custom as such, it's just that our data is unusual in some cases. \n. Yeah I saw that... the log is a bit opaque to me, but lemme see what I can figure out.\n. Hard to tell from the log why the build is failing @hkellaway -- I don't see any indication of what is going wrong, aside from that it seems to be erring out when it tries to code sign...\n. whoops @hkellaway didn't see this until just now. I added it mainly because of some URLs on a project that weren't getting decoded properly. But really that's the responsibility of the backend, not the client in this case. Glad it got cleared up!. Since Swift has module namespacing, for now Gloss is usable in XCode 9 by simply prepending \"Gloss.\" to all use of Decodable and Encodable. Probably not an ideal solution long term though!\n. ",
    "ghost": "So I downloaded a new clean zip copy and opened the project into xcode and it seems to still think this file should be there. The \"Dictionary.swift\" is marked red and the build fails with :\n<unknown>:0: error: no such file or directory: '/Users/nmodin/Downloads/Gloss-develop/Sources/Dictionary.swift'\nCommand /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc failed with exit code 1\nRemoving the reference to Dictionary gives an error as expected, and then adding ExtensionArray and ExtensionDictionary to the project fixes the issue. \nPerhaps the xcode project file changes wasn't committed for some odd reason ?\n. Boom ! Worked like clockwork. Now I'll get back to the tutorial ....  thanks for a speedy fix ! :)\n. ",
    "valeIT": "It was: [[String : AnyObject]], thanks =)\n. Reporting in as well and same:\n\nChanging the Swift Optimization to None (on our custom build configuration called AdHoc) is resolving the problem, but that should be temporary. \nNot using nested keypaths is not something we want to follow - changing that in our models would cause a lot of work..\n\nFound it as well in an application distributed via Test Flight. I've disabled optimisations and now it works.\n. ",
    "dwb357": "I'll take a look at it this afternoon.\nDavid\n\nOn Mar 1, 2016, at 12:45, Harlan Kellaway notifications@github.com wrote:\n@dwb357 this failed on the testEncodeEncodableDictionary test (tests can be found in the GlossExample project currently. can you fix the test to pass?\n\u2014\nReply to this email directly or view it on GitHub.\n. Should be gtg now.\n. \n",
    "gfelot": "Yep I figure it out by myself by writing my issue. It become clear enough after that ;)\nBut you solve my second problem with the BookIdentifier and the enum.\nThanks a lot it was fast ;)\n. ",
    "ryanschneider": "Not sure if it's bad form to comment on a closed issue, but I don't feel that this comment is worth opening a new issue.  Anyways, I would suggest adding an nested array to the Repo example in the README.  I saw the code about fromJSONArray and was trying to use something like:\nswift\nguard let items : [Item] = [Item].fromJSONArray(json[\"items\"]) else { return nil }\nInstead of the (now obvious):\nswift\nguard let items : [Item] = \"items\" <~~ json else { return nil }\nTime permitting I'll try to do a PR to add that.  Thanks for a great library, loving it so far!\n. Thanks for the feedback (and a great framework in general!).  I agree with keeping the operators focused, so opted not to implement my own either.\nAnd for future reference in case anyone else runs into the same issue, here's my extension:\n``` swift\nextension Decoder {\n    /**\n     Decodes JSON to a Decodable object array.  Emulates pre-0.8 behavior\n     where elements of the JSON array that cannot be converted to T are skipped instead\n     of returning nil.\n - parameter decodePartialArrayForKey: Key used in JSON for decoded value.\n\n - returns: Array of values that could be decoded from JSON, or nil if key is not found.\n */\npublic static func decode<T: Decodable>(decodePartialArrayForKey key: String) -> (JSON) -> [T]? {\n    return {\n        json in\n\n        if let jsonArray = json[key] as? [JSON] {\n            var models: [T] = []\n\n            for subJSON in jsonArray {\n                if let model = T(json: subJSON) {\n                    models.append(model)\n                }\n            }\n\n            return models\n        }\n\n        return nil\n    }\n}\n\n}\n```\nUsage like so:\nswift\n// Replace:\nlet arr: [Value]? = \"values\" <~~ json\n// With:\nlet arr: [Value]? = Decoder.decode(decodePartialArrayForKey: \"values\")(json)\n. If this is implemented, it needs to be implemented for every \"numeric\" type Gloss supports, so Int, Double, Float, Decimal, etc.\nThat is to say you might want to serialize your [\"key\": \"100\"] example to:\nswift\nstruct QueryParams {\n   let key: Int\n}\nBut I might want to serialize it to:\nswift\nstruct QueryParams {\n   let key: Double?\n}\nBut personally, I think this String -> Type conversion would be something better handled inside Kitura/Vapor/etc.  It looks like Vapor at least already does that with SwiftyJSON style .int extensions.  Also it looks like SwiftyJSON is vendored inside Kitura releases anyways.  \nI think SwiftyJSON is the framework focused on manipulating \"untyped\" JSON, Gloss is really for JSON <-> struct serialization, IMO adding edge cases to handle malformed JSON sounds like a dangerous path.\nAnd besides, HTTP query parameters aren't really JSON to begin with.  Don't forget that ?key=100&key=101&key=Foo is a valid query parameter in a URL.  Lots of server frameworks in other languages would map to to something like '[\"key\": [100, 101, \"Foo\"]]'.  My point is that even if this code was added to Gloss it still sounds like there are additional situations that need to be handle upstream and/or in your code.. Can't you do?\nswift\nif let f: String = \"key\" <~~ json {\n    self.fileVersion = Int32(f)\n}\nelse {\n    self.fileVersion = nil\n}\nOr replace the if let with some ! if fileVersion is Int32 rather than Int32?.\nWhich brings up another good point: these built-in methods would need to return T? since the string might not be parseable so you'd still need to handle that. \nYou could write your own ~~> function to convert a String to Int? but IMO this shouldn't be something exported by default from Gloss since it'll hurt far more people than it'll help (I'd be mad if I accidentally passed Gloss a string when I typoed an input to a to an Int and it led to runtime issues rather than a failure to compile).  At the very least I'd want it to be a different op like -!> so it's obvious it's doing something non standard, but if I recall correctly Harlan has said he's opposed to adding more ops since it complicates learning the framework. . Have you considered making a Gloss 2.0 which builds on top of the Swift 4 primitives?\nI haven't dug in deeply, but I feel like these spots can be much more ergonomically handled by a 3rd party library like Gloss than what's in Swift 4:\n\n\ncustom date encoding/decoding.  Personally I have Glossy structs that have Date fields that need to use different DateFormatters (e.g. for legacy reasons some fields are UTC, some ISO8601, and others just MM/DD/YYYY).  Swift.Codable requires me to set the encoder/decoders date decoding to custom, and then inspect the CodingKey keyPath to decide on the DateFormatter to use (since I can't use the same DateFormatter for all of the fields)\n\n\ncustom encode/decode functions:  Personal choice, but I prefer Gloss' ~~> and <~~ to the try-heavy approach used in init(from decoder: Decoder) and func encode(to encoder: Encoder). \n\n\nI feel like there's room for a \"DSL\" over Codable that combines the CodingKey concept (which is great!) with Gloss' ergonomics (which is even greater!).\nEven a Gloss 1.x that adds support for CodingKeys for the JSON keys would be awesome (no more duplicating key name strings in toJSON and `init1!).. FYI it sounds like the Cocoapods situation for Swift 4 hasn't been fully\nresolved:\nhttps://github.com/CocoaPods/CocoaPods/issues/6791\nThis link has some potential solutions.  The good news is that your Podfile\ncan include all Swift 3 projects, and your main project can be Swift 4, as\nthat's what I've been doing.  During the migration, just upgrade your main\nxcodeproj to Swift 4, leave all your Pods unchecked in the first screen of\nthe migration wizard.\nCurrently, it sounds like if you want to have individual pods built with\nSwift 4, you need to use the installer.pods_project.targets.each do\n|target| loop suggested in the comments, as pod specs don't yet have a\nfield for defining the Swift version of a project (understandably as Apple\nhas changed the combat story w/ every Xcode release).\nSo, until things shake out a little more, my suggestion would be for the\nofficial Gloss release to remain Swift 3.2, and for most people to use\nSwift 3.2-compatible pods in their Podfile.  If Gloss 1.3 was released as\nSwift-4 only code before Cocoapods adds Swift version support to the pod\nspec DSL it'll probably just cause more confusion and Github issues to be\nopened than it's worth at the moment.\nOn Fri, Sep 15, 2017 at 8:26 AM, Harlan Kellaway notifications@github.com\nwrote:\n\n@ergunkocak https://github.com/ergunkocak swift_4.0 is currently the\nsame as master so you can point to 1.2.4 in your private spec. once\nupdates for Swift 4.0 are made i can release specific betas on CocoaPods,\nsure\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/hkellaway/Gloss/issues/296#issuecomment-329815421,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AADREItS8FBmlNPiUdL98ESZQlp7TwqMks5sipcegaJpZM4NxFog\n.\n. \n",
    "johngoren": "Just realized that all math operators act like this too. Anyway just thought this one might be extra-prone to spacing confusion for folks...thanks again.\n. ",
    "stuartervine": "This looks like a bug in the ExtensionDictionary valueForKeyPath method. I'll submit a pull request - unfortunately testing for it is pretty difficult as it only occurs when optimizations are switched on. This causes a crash when trying to remove an element from the keys array - but it doesn't crash when not optimized.\n. Will do - I've had to rollback my xcode version. Once I update I'll get on\nit.\nCheers\nS.\nOn 27 Mar 2016 6:38 p.m., \"Harlan Kellaway\" notifications@github.com\nwrote:\n\n@stuartervine https://github.com/stuartervine closing this PR for now,\nas it breaks library functionality and i'm currently unable to reproduce.\nto get around your issue in the meanwhile, you could create nested models\nas opposed to using the . syntax. if you find a viable solution,\ndefinitely submit another PR!\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/hkellaway/Gloss/pull/136#issuecomment-202099211\n. \n",
    "tholo": "I did come up with a (not very pretty) workaround...\n``` patch\n---Sources/ExtensionDictionary.swift      2016-03-29 11:11:46.000000000 -0700\n+++ Sources/ExtensionDictionary.swift   2016-04-01 11:54:02.000000000 -0700\n@@ -49,11 +49,9 @@\n         guard let value = self[first] as? AnyObject else {\n             return nil\n         }\n-\n-        keys.removeAtIndex(0)\n-\n-        if !keys.isEmpty, let subDict = value as? JSON {\n-            let rejoined = keys.joinWithSeparator(delimiter)\n+\n+        if keys.count > 1, let subDict = value as? JSON {\n+            let rejoined = keys[1..<keys.endIndex].joinWithSeparator(delimiter)\n         return subDict.valueForKeyPath(rejoined, withDelimiter: delimiter)\n     }\n\n```\nHm, if this is done then keys should be let and not var too, I guess...\n. > On Jun 20, 2016, at 21:37, Andrew Breckenridge notifications@github.com wrote:\n\nApologies for the unrelated interjection:\n@tholo https://github.com/tholo how did you embed that diff?\nI \u2026 am not sure I understand the question. Can you rephrase it?\n\nThorsten\n. Oh. Used the standard markdown for code, in this case specifying that it was in \"diff\" format...\nSo, pasted in some code (diff output, in this case), and wrapped it in backtick sections with the opening section saying\n```diff\n... lines ...\n```\nThis is documented in Creating and highlighting code blocks\n. FWIW I am seeing this issue with some of my stuff too \u2014 but moving the statement to remove element 0 does not fix it \u2014 and indeed, at the point where it is being removed we already know that there are at least one element in the set of keys.\nBuilding the framework (I am using Carthage) for Debug instead of Release does fix it, and it seems to me that this must be an issue not with Gloss but with Swift / LLVM somewhere...\n. ",
    "darkFunction": "I was having the same problem. bugfix/crash_valueforkeypath_when_optimized resolves it. Thanks!\n. ",
    "sfaxon": "I think I've run into this issue running 0.7.2 and 0.7.3 in a different scenario. \nswift\nfunc testNestedEncoding() {\n    var result: [JSON?] = []\n    result.append(Encoder.encode(\"stripe.account.legal_entity.last_name\")(\"User\"))\n    result.append(Encoder.encode(\"stripe.account.legal_entity.dob.year\")(2014))\n    let x = jsonify(result)\n    print(x)\n}\nRunning this in a test with optimization turned on will stop on line 135 of ExtensionDictionary.swift with an EXC_BAD_INSTRUCTION error and print the same Gloss was compiled with optimization - stepping may behave oddly; variables may not be available message. Running without optimizations does not produce the error. \nI'm getting this error with Xcode 7.3.1. and the newly released Gloss 0.7.3. I first noticed the problem when the error happened in an application distributed via Test Flight. \nAm I missing something? Thanks! \n. ",
    "ferusinfo": "Reporting the same in my project, both on 0.7.2 and 0.7.3\nChanging the Swift Optimization to None (on our custom build configuration called AdHoc) is resolving the problem, but that should be temporary. \nNot using nested keypaths is not something we want to follow - changing that in our models would cause a lot of work..\n. Here is a quick snippet for those of you who use CocoaPods and wants to disable the code optimization on the pods targets (put it at the end of your Podfile):\nruby\npost_install do |installer_representation|\n    installer_representation.pods_project.targets.each do |target|\n            target.build_configurations.each do |config|\n                if config.name == 'AdHoc'\n                    config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] ||= \"-Onone\"\n                end\n            end\n    end\nend\nWe are temporarily using this solution to build adhoc builds for our CI.\nHope that will help someone.\n. Hey @hkellaway - after I read that - the best JSON library written in Swift, that we've been using in both commercial and in-house apps is just making us sad.\nCould you work on the feature a little bit more? \nWe will stick with 0.7.x version for now, but we are moving to the Swift 3.0 in our newest project and moving away from Gloss that we use heavily will impact our development (we need to find a good alternative as we have a lot of nested keypaths models).\nDoes the optimization fix does not work for you at this time? \nI am sure you can add a Pod post-install hookup to the documentation and it will make a lot of developers happy.\n. I will look into that in a second, let me try.\nEdit: Looks that it works! :)\n. Hopefully everything is allright now. \nShould I reintroduce the feature in the documentation as well? \n. Sorry for missing that when I was pushing the nested model fixes, my bad.. Sure, I was wondering where to put it :). Changed.. @hkellaway \n\nive yet to test your PR - but i'm wondering if this new function might interfere with the decoding of Doubles that are not NSTaggedPointerStrings?\n\nThat's needs to be checked, but we are using the Decoder.decode(doubleForKey: in our project instead of <~~. If you mark any of the functions in the extension public, it gives a warning that the extension must be public as well (at least for me).\n. I must disagree - putting this function into the Gloss class would mean that we are extracting a \"hey, set this value in this JSON\" function to a \"master\" object, and that function belongs to the Encoding part of the library, so I would leave that there. \nWhat you think?\n. Sure, will do later.\n. ",
    "cody1024d": "ahh shucks, haha.  Either way, thank you for the quick response!\n. ",
    "milankamilya": "109 Solution. Sorry, I didn't see that first.\n. ",
    "whvandervelde": "Thanks, yes I did something similar like this indeed. \nIt can detect if something went wrong, but perhaps not what went wrong exactly?\nIn any case, the example  in the doc might need a small update then.\nThanks again!\n. ",
    "jirizoudun": "Ok, thank you for your help!\nHave a nice day.\n. ",
    "psparago": "Thank you so much for the quick response and interest Harlan. Especially since it seems unlikely like it is a Gloss issue. By the way, I really like Gloss. Thank you for your contribution!!\nI will do this.\n. I updated my podfile like this:\npod 'Gloss', :git=>'https://github.com/hkellaway/Gloss', :branch=>'release/0.7.3'\nand added this test code:\n`\n                        if let iconServer: Int32 = \"person.iconserver\" <~~ json {\n                            print(\"iconserver: (iconServer)\")\n                        } else {\n                            print(\"no good\")\n                        }\n`\nUnfortunately, iconServer is still nil.\nThank you again for your interest.\n. Thank you Harlan. That code works well. I'm still baffled regarding why the JSONSerializer returns both String and Int types for integers seemingly randomly.\n. ",
    "jose920405": "I have 2 arrays type Glossy\nvar locations: [Location] = [Location]()\nvar filterLocations: [Location] = [Location]()\nin a loop a need know if any object inside locations exist in filterLocations\nexample:\nfor loc in locations {\n   if filterLocations.contains(loc) {\n      ///Here contain\n   }\n}\n. ",
    "doncorsean": "So I've got a test working where super.toJSON() is merged with the result of jsonify. My problem is I have hundreds of generated classes which each require implementation of these initializer/toJSON methods. Seems like tons of boilerplate code for already known and defined properties within a class. Would be nice if Swift's \"reflection\" would allow us to skip this manual declaration of all the mapping if the structure of the JSON and property names were verbatim and we would only need to implement toJSON when one wanted to customize the serialization.\n. ",
    "4ch7ung": "Done. Sorry, cannot update documentation\n. ",
    "mdhari": "Found out I can use NSNull() with an [AnyObject] array to accomplish this, thanks.\n. ",
    "karpelcev": "Deprecated by #177\n. Hi! When I was making this change in Swift 2.3 branch, I thought of this solution too and decided against it, because I think you can safety transition to new syntax without the #if. Reason is, new code is still compiled correctly and behaves in the same way. The signature simply added one more optional to url?.absoluteString, but it doesn't impact the unwrapping.\n. ",
    "pournam": "Ok I did it like this, was simple in the end, just nesting the fromJSONArray calls:\nmidi = \"jsonMIDI\" <~~ json\ntracks = [Track].fromJSONArray([json])\nevents  = [Event].fromJSONArray([json])\ntype = \"type\" <~~ json,\n deltaTime = \"deltaTime\" <~~ json\n. ",
    "anazareth-rmn": "What is the destination number type?\n. ",
    "sssilver": "``` swift\nimport Gloss\nclass GFCBalance: Decodable {\n    let balance: NSDecimalNumber?\n    let lastUpdated: NSDate?\n    let balanceStale: Bool?\nrequired init?(json: JSON) {\n    self.balance = \"balance\" <~~ json\n    self.lastUpdated = Decoder.decodeDateISO8601(\"lastUpdated\")(json)\n    self.balanceStale = \"balanceStale\" <~~ json\n}\n\n}\n```\n. ",
    "marcopompei": "I'll try to implement it during this week.\n. I updated the commit, I'm not sure if Github sends you a notification about that.\n. SE-0077 discuss this change, it has the list of operator groups.\nI picked that one because it shouldn't change the current behavior.\nChecking a list of swift operators precedence I saw the one that behaves like ~~> (same associativity and precedence) are the ones in the multiplication group.\nMaybe we should define our own group?\nswift\nprecedencegroup DecodingPrecedence {\n  associativity: left\n  higherThan: CastingPrecedence\n}\n. Yeah, you are right, it would be AdditivePrecedence to keep the same.\nI believe it makes little difference, I think higherThan: CastingPrecedence is more expressive. \nWe aren't supposed to be being mixed with math operators anyway, and we make it clear to anyone reading that we need to have precedence over casting and expressions like let id = \"id\" <~~ json as Int? work without trying to cast json.\n. One group named GlossPrecedence or DecodingPrecedence?\nOr two groups, DecodingPrecedence and EncodingPrecedence?\nI'd go for GlossPrecedence.\n. ",
    "GoldenJoe": "What ever happened with this? It would be very helpful.. ",
    "htinlinn": "Changes made seem to cover only one of the many array decoding functions. decodeDecodableArray, decodeEnumArray, etc...  needs updating as well.\n. ",
    "aventurella": "it tells the compiler to use swift 3\nOn Thu, Aug 4, 2016 at 10:48 Harlan Kellaway notifications@github.com\nwrote:\n\n@aventurella https://github.com/aventurella can you explain what this\ndoes?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hkellaway/Gloss/pull/200#issuecomment-237629415, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAEmMxSeP5KRzPAlmrh6cJo3th8K5s4Oks5qciXegaJpZM4Jc8yT\n.\n. Xcode throws a compile time warning when it's left at undecided\n. Just for a reference, here's the error Xcode 8 Beta 4 throws up:\n\n\nSetting \"Use Legacy Swift Version\" to No sets SWIFT_VERSION=3.0\n. ",
    "tsheaff": "@hkellaway semi-unrelated question \u2014 when will swift_3.0 branch be merged to master and pushed to pod trunk as a new version of the pod?  I'm assuming a major version bump would be in order given that swift 3 breaks backwards-compatibility.\n. ",
    "ibakurov": "@hkellaway is it any timeline you could provide, just to schedule things properly?\n. ",
    "marianoprettysimple": "Hey, I think you just need to change JSON definition to\npublic typealias JSON = [String : Any]\nand ExtensionDictionary.swift line 149 to\nprint(\"[Gloss] Unable to set value: \\(subdict) to dictionary of type: \\(type(of: self))\")\nI made those changes and the Gloss pod project seems to be building now. I'm still trying to figure out all the stuff that broke on my own project, so I can't report if there are any runtime problems.\n. ",
    "pascalfribi": "Hi guys,\nI was just about to create a pull request for the same changes :-) Now I can throw them away. Nevermind, they look (almost) the same, apart from naming variables.\n. Hi,\nyes of course this is possible. Gloss is really neat.\nBut your example has a few issues. First of all you need to implement a failable initializer as the decoding could go wrong. Furthermore it seems, that you JSON is not really correct.\nWith your example you need something like this (Note that events in the json needs to have \"\" around it):\n```\n{\n\"events\": [\n        {\n          //event: A JSON object I already have a modal for. \n        },\n        ... \n    ]\n}\npublic struct Events: Decodable {\npublic let events: [EventObject]\n\npublic init?(json: JSON) {\n\n    // First make sure you can decode EventObject\n    guard let events: [EventObject] = \"events\" <~~ json\n        else { print(\"Error decoding EventObject Array\"); return nil }\n\n    // Now assign local events to self.events\n    self.events = events\n}\n\n}\npublic struct EventObject {\n// Your EventObject struct with failable initializer....\n}\n```\n. ",
    "wangguangfeng": "OK, the most current version on CocoaPods is 1.0.0 \n. ",
    "Hiiragisan09": "Yes, new in Swift3 the type UUID, previously you had to use NSUUID. https://developer.apple.com/reference/foundation/uuid and with init?(uuidString: String) you can parse a String to UUID\n. I was waiting for this, and so i made it my self, pull request [https://github.com/hkellaway/Gloss/pull/226]. I also added unit testes to test the type. Maybe you can include it in the next release?\n. ",
    "StateMachineJunkie": "For any who are interested, you need to update to CocoaPods 1.1.0 (gem install cocoapods --pre or using Bundler) for it to properly set the Swift version.\n. ",
    "rbukovansky": "This is officially weird. It passes on Mac, but not on Linux? :eyes: \n. As original comment states, it's still work in progress. I have 2 issues on Linux, which I have reported to Swift development team, but they are still not resolved. Sorry.\nIf you want you can close this PR. I will reopen it when it's resolved. My intentions were to let you know I'm working on this.\nThanks.\n. @hkellaway Well, we really do. What the hack?\nBut guess what... On Linux, it gets more messed up... https://bugs.swift.org/browse/SR-3158 :disappointed: \n. @hkellaway I have absolutely no idea why that build on Travis CI failed. Could you please take a look and let me know? Thank you.\nBTW Could we please get Travis CI to try build Gloss on Linux as well? Thanks.. Yeah, I will rework this... \ud83d\ude44 Sorry!\nAnd will take a look on that Travis guy as well... Thanks.\nAnd thanks for those findings... I was lost a little bit.... @hkellaway Do we really need all those ([)(U)Int32(]), ([)(U)Int64(]) encoders and decoders? Asking for friend.... Well, is there anybody insane who uses Int32 or UInt64 directly in code instead of Int/UInt? :smirk: \nI just hope not...\nBTW The build using the new .travis.yml file which uses swift toolchain, instead of Xcode, and original code fails too for macOS on ([)UInt64(])... :roll_eyes: EDIT: On Travis-CI, to be exact.... And of course, directly on my girlfriend's Mac it builds normally without problem...\nWhy me?. I see... Madness, but OK. Thanks.. @hkellaway \n1. So I have reverted back to using NSNumber. I've tried to get all the code to use \"natural\" types, because NSNumber doesn't work for those size-specific Ints and UInts on Linux, but I have failed. \ud83d\ude22\n2. That means, Gloss wouldn't be able to support ([)(U)Int32(]) & ([)(U)Int64(]) on Linux. There is something fundamentally broken in Swift or Foundation library on Linux, so I have \"removed\" tests for these on Linux and added remark to README file.\n3. If you accept this PR, please squash the commits (you can do it directly here within this PR, Github will make squashed merge commit to your develop branch) and leave there this commit message:\nInitial Linux support. (Or do you want me to redo this?)\n4. I will monitor future developments of Swift and will try to move to those mentioned \"natural\" types again when Swift/Foundation is fine again on Linux.\nThank you. For this library and your patience.. @hkellaway \n1. Time - that's OK. We all had holidays... ;)\n\n\nSupport for Linux: Yes, I will take care of it. No worries...\nGloss is IMHO the best JSON library for Swift and I'm happy it can be used on Linux.\n\n\nSquashing those commits: I will take care of it, no worries here either.. @hkellaway To get this all going could you please accept #258 #250 and then this PR... We will then have Linux support in Gloss and tests of any new code for both platforms (OS X and Linux) on Travis CI.\n\n\nI have merged all those three PRs to one branch in my repo as a proof and it builds OK https://travis-ci.org/rbukovansky/Gloss/builds/189439692.\nThank you.. @hkellaway Rebased on top of develop branch. #250 needs to be merged first.\nTest build of both PRs merged is here: https://travis-ci.org/rbukovansky/Gloss/builds/192286539. @hkellaway Thanks. Hooray, another Mt. Everest conquered! \ud83d\ude09. @hkellaway Reply over e-mail sent. And it's good I'm not alone in this effort. Hooray to @crspybits!. @hkellaway It should and will when you merge #258, which makes that new code compatible with macOS and Linux actually...\nThe thing is, with this Travis won't be running Xcode for build and test with iOS as a target anymore, but directly running swift compiler.... @hkellaway As I stated here https://github.com/hkellaway/Gloss/pull/249#issuecomment-270860442 the merge of those tree PRs needs to happen to get things going. Please, do so. Thank you!. That's OK, sounds good to me!. @hkellaway Rebased on top of develop branch. #249 needs to be merged following merge of this branch.\nTest build of both PRs merged is here: https://travis-ci.org/rbukovansky/Gloss/builds/192286539. @hkellaway Thanks, now we will know if anybody makes changes that work on Mac, but break on Linux! \ud83d\ude08 . @hkellaway No worries, I have no plans for world domination... Well, except for one of my projects... :wink:. @hkellaway Yup, it's not needed anymore. So I'm gonna close it.\nI rebased both branches on top of develop and force pushed changes, so #250 (this one first, please) and #249 are both ready to be merged. Test merge and build of both is here: https://travis-ci.org/rbukovansky/Gloss/builds/192286539 (both platforms are OK).. @hkellaway I will take a look.. @hkellaway I'm working on it... Slowly, but I'm... Just a lot's of work... \ud83d\ude22 Sorry. But I hope to have it resolved this weekend.. @hkellaway Hi, I've got finally some time to look at this. Could you please make a merge of develop branch to linux branch? I tried to do that myself but got some conflicts I'm not sure if I would solve correctly. Thanks.. @hkellaway PR submitted. I'm probably going to unleash the hell on Swift devs, what's going on, why Swift/Linux is such a mess... :unamused: . @hkellaway He, @maximveksler, is right. Welcome to sometimes really weird naming conventions of Swift dev team.. Are those errors from building your app or from building Gloss?\nI'm able to build Gloss from swift_4.0 branch using swift build && swift test normally (tests fail, but I have created PR #303 to have them pass). It's also \"buildable\" on Travis as you can see here: https://travis-ci.org/rbukovansky/Gloss/jobs/260950618. @hkellaway Congratulations! \ud83d\udc4f . It's not. For now...\nBut when I finish this one project I'm currently working on, I will get to it and redo Linux support (approx. after April).\nI just hope Swift language devs resolved issues I had with Swift on Linux.. @str11ngfello @hkellaway Resolution of SPM issues will be part of Gloss on Linux solution I will be working on soon.... ",
    "ashishonmobile": "I guess same problem for me. I am new to swift. and trying to integrate it to one of my project.\n. ",
    "philmuse": "I did a checkout of the swift2_3 branch and it appears to include 3.0 syntax and compile options.  When I try to add to my Swift 2.3 project, I get error about Gloss being built as 3.0x.  I'm happy to pull earlier version of code, do you have a commit date or TAG to recommend?  Thanks.  And thanks for making this available to the community, it looks really cool.\n. ",
    "bitkill": "Sorry, my bad. Still getting used to swift \"JSON as dictionary\" approach to converting stuff.\nThe output I posted was from the console. I eventually needed the String to tunnel back to a WKWebView and was not getting the \"String\", just the dictionary.\nThis did the trick:\n```\n    func getPointsForJs() {\n    var allPoints = [JSONPoint]()\n\n    DatabaseApi.sharedInstance.allPoints().forEach { point in\n        let jPoint = JSONPoint(coreData: point)\n        allPoints.append(jPoint)\n    }\n\n\n    let jsonData = try! JSONSerialization.data(withJSONObject: allPoints.toJSONArray()!, options: [])\n    let sPoints : String = String(data: jsonData, encoding: String.Encoding.utf8)!\n\n\n    let jsCode = \"NativeInterface.setPoints({ \\\"points\\\": \\(sPoints) })\"\n\n    print(jsCode)\n\n    webView!.evaluateJavaScript(jsCode, completionHandler: nil)\n}\n\n```\nI'm wondering if a function that converts from the dictionary to string would be a good idea.\nAnyway, thanks for the reply :). ",
    "niedfelj": "This is also breaking URLs with a fragment:\nhttps://medium.com/the-coffeelicious/the-flaw-of-love-77a848c7703e#.54mta71a9\nGloss turns that into:\nhttps://medium.com/the-coffeelicious/the-flaw-of-love-77a848c7703e%23.54mta71a9\nWhich then 404's on the Medium site. ",
    "gerbiljames": "This is the best I could come up with while still allowing User to be subclassed:\n```swift\nclass User {\n  let name: String\ninit(name: String) {\n    self.name = name\n  }\n}\nextension User {\n  struct JSONInitializer: Decodable {\n    let model: User\n    init?(json: JSON) {\n      let name: String = \"name\" <~~ json ?? \"\"\n      model = User(name: name)\n    }\n  }\n}\n```\nBut it means you have to initialize your models like this: \nswift\nlet user = User.JSONInitializer(json: [\"name\": \"James\"])?.model\nwhich is ugly and unintuitive.. ",
    "frootloops": "@gerbiljames yes, it's kind of ugly. But thank you for an answer :) . ",
    "heshamsalman": "@frootloops what you're doing is currently unsupported by Swift. \nHere's why: \n- Extensions can only provide convenience initializers\n- Initializers that are implemented as a result of protocol conformance must be marked as required (on classes). \n- required init can only be implemented within the body of a class. \nWhat you're doing is completely valid for structs. \n```swift\nstruct User {\n    let name: String\n}\nextension User: Decodable {\n    init?(json: JSON) {\n        let name: String = \"name\" <~~ json ?? \"\"\n        self.init(name: name)\n    }\n}\n```\nAlthough you've expressed that you don't want to do this, this is the correct solution: \n```swift\nclass UserClass: Decodable {\n    let name: String\ninit(name: String) {\n    self.name = name\n}\n\nrequired convenience init?(json: JSON) {\n    let name: String = \"name\" <~~ json ?? \"\"\n    self.init(name: name)\n}\n\n}\n```. ",
    "Progern": "I need to create something like this\n{\n   \"objects\":[\n      {\n         \"value1\":\"4278255360\",\n         \"value2\":\"\",\n         \"value3\":\"472632b338\",\n         \"key_value\":\"68\",\n         \"name_value\":\"Hello\",\n         \"nested_objects\":[\n            {\n               \"another_value\":\"\",\n               \"first_value\":\"22\",\n               \"value3\":\"701dee3003eee\",\n               \"second_value\":\"38\"\n            }\n         ],\n         \"some_order\":\"2\"\n      }\n   ]\n}\nBut I get something like this\n[   \"objects\":[      [        \"value1\":\"4278255360\",         \"value2\":\"\",         \"value3\":\"472632b338\",         \"key_value\":\"68\",         \"name_value\":\"Hello\",         \"nested_objects\":[            [               \"another_value\":\"\",               \"first_value\":\"22\",               \"value3\":\"701dee3003eee\",               \"second_value\":\"38\"            ]        ],         \"some_order\":\"2\"      ] ] ]\nWhere I need objects, they are arrays.  For example, we have an array called \"objects\", but in my case this is an JSONarray of JSONarrays.. I need an JSONarray of JSONobjects.. Can I avoid init?() if i just need my objects to be packed into JSON?. Btw, thank you for responding to my, maybe, stupid questions. Your library is best opensource so I wish to use it now and in all my next projects.\nI changed to Encodable. I guess the problem is in calling function jsonify([]) cause it returns a JSON Array, or am I wrong? I have this function in my class model (I'm not using structures btw, can the problem be in this?)  So every time it is called with an independent object it creates a JSON Array for one object. \n. ",
    "frios": "I actually got it all working. Seemed to be a cocoapods issue. Thank you. \nFGR\n\nOn Dec 31, 2016, at 8:45 AM, Hesham Salman notifications@github.com wrote:\nBy any chance, do you have a post install script which forcefully sets swift version on pods?\nIf you do:\npod deintegrate\nupdate your cocoapods version\ngo to your project and set your project target swift version to Unspecified\nremove the post install script from your pod file\npod install\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "kampro": "\nare you able to follow up on the additinal comments to this pull request?\n\n@hkellaway Sorry for delayed reply, I am not sure what you mean, but all I can see is what you can see in the screen shot. After your comment I immediately fixed problems and pushed commit.\n\n. ",
    "shamikagasc": "FYI my issue has nothing to do with #242 . To resolve it I had to navigate to the gloss target within the cocoapods project and set Require Only App-Extension-Safe API to true. \nRefer to https://github.com/CocoaPods/CocoaPods/issues/5373 for more information. ",
    "lmsmartins": "Does this happen due to the design of the library or because of the iOS's JSONSerialization class itself? Is there a way to make this possible?\nIt's really important to maintain the order of the attributes, because if you serialize the json to NSData and you use an MD5 string to determine whether the data has changed, it's good to know that it hasn't.. ",
    "maximveksler": "don't think so. This works for me for a Linux-Docker-AWS Lambda build.\n```\nimport PackageDescription\nlet package = Package(\n    name: \"Collection\",\n    dependencies: [\n      .Package(url: \"https://github.com/hkellaway/Gloss.git\", majorVersion: 1, minor: 2)\n    ]\n)\n```\n. ",
    "crspybits": "Thanks-- I'll see if I can get on that.. Thanks for the feedback, Harlan. For some reason when I was first looking at this, I believed that the JSON standard for numbers included representing them as strings. Now, looking at this again, and searching a little more, I appear to have been wrong about that (e.g., see http://www.json.org). I'll have to look into my code to see what was originally making numbers come back as strings in JSON. If for some reason I stick with strings, does Gloss have a simple transformation/extension capability? . OK- I'm seeing that now, under Custom Transformations in your docs.. Interesting. Perhaps I'm using Gloss for something it's not intended for. But, perhaps something could be clarified in the Gloss documentation. Gloss converts between objects and the JSON type which is a Swift dictionary. I usually think of JSON as being either in string format or in actual Javascript, not as Swift dictionaries. I agree that HTTP query parameters are not JSON-like. Swift dictionaries are more JSON-like, but are they JSON?\nIn any event, for me right now, without this numeric <-> string conversion it costs me specifically is a little less clarity in my model conversion code. I can't use the nice \"~~>\" style operators in some cases, and have to do things like:\n    self.fileVersion = Decoder.decode(int32ForKey: UploadFileRequest.fileVersionKey)(json)\n\nPlus, of course, I have to have an additional Decoder implementation to support this.\nSo, this raises a slightly different question: Is there a way I could use the \"~~>\" style notation and \"plugin\" my feature of numeric <-> string conversion? Does that make sense?\n. ",
    "jsonfellin": "Thanks for responding. \nI would argue returning nil only makes sense on the single object level, not a collection. Why would I ever want to return nil for an Array or Dictionary if more than zero of its Elements are decoded successfully?\nI know about the custom decoders and have already written one for this purpose. This was to be used on a property with a generic type, hence the convenience factor.\n\nOn Mar 15, 2017, at 5:04 PM, Harlan Kellaway notifications@github.com wrote:\nthis was thought about - the ultimate conclusion being its more consistent with the rest of the decoding functions to return nil (#189 https://github.com/hkellaway/Gloss/issues/189). for your case, you could do a custom transformation (https://github.com/hkellaway/Gloss#custom-transformations https://github.com/hkellaway/Gloss#custom-transformations)\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/hkellaway/Gloss/issues/275#issuecomment-286790395, or mute the thread https://github.com/notifications/unsubscribe-auth/AJaRteUNJITKrooNz-EP15cPCPWk5Tn1ks5rmAwAgaJpZM4MeIRU.\n\n\n. ",
    "arbitur": "@hkellaway Still happening in 1.2.4 for me. @hkellaway It seems to be when trying to parse a Bool from integer 1 or 0. But it seem to work, my booleans get their correct value [true or false] but still getting the warning:\n\n[Gloss] Value found for key \"paid\" but decoding failed.\n\n// JSON\n{\n    \"paid\": 1,\n}\n\nlet isPaid: Bool\ninit?(json: JSON) {\n    isPaid = (\"paid\" <~~ json)! // = true\n}. Its weird because when parsing a json string to Dictionary using JSONSerializer it works, but when passing a Dictionary literal it fails.\n\n```swift\nstruct Paid: Decodable {\n    let isPaid: Bool\n    init?(json: JSON) {\n        isPaid = (\"paid\" <~~ json)!\n    }\n}\nlet json = \"{\\\"paid\\\": 1}\"\nlet dict = try! JSONSerialization.jsonObject(with: Data(json)!, options: []) as! [String: Any]\nlet p = Paid(json: dict)! // Works\nprint(\"p:\", p.isPaid) // p: true\nlet p2 = Paid(json: [\"paid\": 1])! // Crashes\nprint(\"p2:\", p2.isPaid)\n```. ",
    "fedetrim": "This is really great. This way I can log non-fatal errors in Crashlytics using a custom Logger, without having to sacrifice the <~~ notation.. ",
    "NausJessy": "@hkellaway Sorry, I forgot the tests. I will add them as soon as possible and get back to you.. I updated the Encoder as to include the Double complement. \nFurthermore, I changed all Double test to use the new decoder and added a case for when an Integer is casted to a Double. I am not very experimented with writing tests, so please feel free to give some feedback about them. If needed, I will change them accordingly.. ",
    "adeperio": "Hey guys, thanks for the work on this PR. This is tripping me up on an issue as well. Any idea when you think you'll be pulling this through? Thanks... :) . ",
    "haiderashfaq": "@hkellaway , do you know the fix? it worked before with the <~~ operator (before swift3 upgrade) -  i inspected the data and yes valid json data. @hkellaway Please see below:\n```SWIFT\nfinal class Product: Glossy, Equatable {\n    fileprivate (set) var id: Dynamic = Dynamic(0)\n    fileprivate (set) var name: Dynamic = Dynamic(\"\")\n    fileprivate (set) var wasPrice: Dynamic = Dynamic(NSDecimalNumber())\n    fileprivate (set) var price: Dynamic = Dynamic(NSDecimalNumber())\n    fileprivate (set) var reviewAverage: Dynamic = Dynamic(0)\n    fileprivate (set) var reviewCount: Dynamic = Dynamic(0)\n    fileprivate (set) var image: Dynamic = Dynamic(NSURLComponents().url!)\n    fileprivate (set) var isFavorite: Dynamic = Dynamic(false)\ninit(id: Int, name: String, wasPrice: NSDecimalNumber, price: NSDecimalNumber,\n    reviewAverage: Float, reviewCount: Int, image: URL, isFavorite: Bool = false) {\n        self.id = Dynamic(id)\n        self.name = Dynamic(name)\n        self.wasPrice = Dynamic(wasPrice)\n        self.price = Dynamic(price)\n        self.reviewAverage = Dynamic(reviewAverage)\n        self.reviewCount = Dynamic(reviewCount)\n        self.image = Dynamic(image)\n}\n\nrequired init?(json: JSON) {\n     print(\"PROD HERE\")\n    guard let id: Int = (\"id\" <~~ json),\n        let name: String = (\"name\" <~~ json),\n        let reviewAverage: Float = (\"reviewAverage\" <~~ json),\n        let reviewCount: Int = (\"reviewCount\" <~~ json),\n        let image: NSURL = (\"image\" <~~ json),\n        let wasPrice = Decoder.decodeNSDecimalNumber(\"wasPrice\")(json),\n        let price = Decoder.decodeNSDecimalNumber(\"price\")(json)\n    else {\n        return nil\n    }\n\n    self.id = Dynamic(id)\n    self.name = Dynamic(name)\n    self.wasPrice = Dynamic(wasPrice)\n    self.price = Dynamic(price)\n    self.reviewAverage = Dynamic(reviewAverage)\n    self.reviewCount = Dynamic(reviewCount)\n    self.image.value = Dynamic(image as URL).value\n}\n\nfunc toJSON() -> JSON? {\n    return jsonify([\n        \"id\" ~~> self.id.value,\n        \"name\" ~~> self.name.value,\n        Encoder.encodeNSDecimalNumber(\"wasPrice\")(self.wasPrice.value),\n        Encoder.encodeNSDecimalNumber(\"price\")(self.price.value),\n        \"reviewAverage\" ~~> self.reviewAverage.value,\n        \"reviewCount\" ~~> self.reviewCount.value,\n        \"image\" ~~> self.image.value])\n}\n\n}\nfunc ==(lhs: Product, rhs: Product) -> Bool {\n    if lhs.id.value != rhs.id.value {\n        return false\n    }\nif lhs.reviewCount.value != rhs.reviewCount.value {\n    return false\n}\n\nif lhs.name.value.compare(rhs.name.value) != ComparisonResult.orderedSame {\n    return false\n}\n\nif lhs.wasPrice.value.compare(rhs.wasPrice.value) != ComparisonResult.orderedSame {\n    return false\n}\n\nif lhs.price.value.compare(rhs.price.value) != ComparisonResult.orderedSame {\n    return false\n}\n\nif fabs(lhs.reviewAverage.value - rhs.reviewAverage.value) > Constants.FloatingPointMinimumAccuracy {\n    return false\n}\n\nif lhs.image.value.absoluteString.compare(rhs.image.value.absoluteString) != .orderedSame {\n    return false\n}\n\nif lhs.isFavorite.value != rhs.isFavorite.value {\n    return false\n}\n\nreturn true\n\n}\n. @hkellaway hold on, i am noticing some very strange behaviour with my json and from which api call its coming from. Let me get back you asap please. Thanks.\nPROD HERE: [\"reviewCount\": 13, \"name\": product1, \"id\": 515, \"image\": http://images.example.jpg, \"reviewAverage\": 4.6, \"price\": 7.99, \"mf_sort_priority\": 12, \"wasPrice\": 0]\n```\n@hkellaway . @hkellaway thanks mate. ",
    "vandanakanwar": "Hi @hkellaway \nActually, In my project, I was also using public typealias JSON = [String: AnyObject],\nwhich was creating a problem because in Gloss same name type alias is used.\nBut compiler was giving me an error regarding protocol compliance. That was quite weird.\nThanks for your quick reply.\nI am closing this issue.\n. ",
    "Isuru-Nanayakkara": "That indeed worked. Thank you!. That works! Thanks.. ",
    "AdamLenda": "I've updated the example code. I found the problem to be that I was trying to output the result of the .toJSON call.\n```\n        print(\"Doing it wrong....\")\n        print(repo.toJSON()!)\n    print(\"Doing it right.....\")\n    let jsonData = try! JSONSerialization.data(withJSONObject: repo.toJSON()!)\n    print(String.init(data: jsonData, encoding: .utf8)!)\n\n```\nI think that if you updated the documentation to include the example code applying the library in practice it would help. I am new to Swift and didn't realize that .toJSON was supposed to be filtered through another function before it would actually be valid json.\nThank you for your time and quick reply.. ",
    "lastcc": "@hkellaway according to the doc, we have to write 2 separate methods to support transform and reverse transform, but ObjectMapper requires only one.\nI know if we use 2 methods there are certain benefits, but can I only write one?\n--------------------------------\nIf you use carthage the display names in the terminal output have some issues:\n Building scheme \"Gloss\" in Gloss.xcodeproj\n Building scheme \"Gloss MacOS\" in Gloss.xcodeproj\ni think we can change it to be Gloss iOS and Gloss macOS\n. ",
    "ergunkocak": "Is it possible to start a new version string for swift 4 branch like 1.4.x and release on Cocoapods?\nI know we can use with branch parameter in cocoapods but to be able to use in podspec file of my private pod i need a seperate version. AFAIS pod version is same in \"swift_4.0\" branch as \"master\". ",
    "GabrielAraujo": "@hkellaway do you need some help fully migrating to swift 4?. @hkellaway I would go with something gloss unique like GlossDecodable and GlossEncodable to avoid this happening again in the future. Hahah\nI don't think so.. This is the only thing the compiler is complaining.\nI think it would be great to release the swift 4.0 as the official so the projects that depend on gloss like moya-gloss can also be migrated! =). @hkellaway I began to perform the changes to JSONDecodable and JSONEncodable but I also noticed that Encoder, Decoder, JSONEncoder and JSONDecoder are already being used by swift. Do you think we should also change the names for Encoder and Decoder or is it just too much? hahah\nhttps://github.com/GabrielAraujo/Gloss. @hkellaway \nhttps://github.com/hkellaway/Gloss/pull/311. @hkellaway glad to help!!\nMan, is there any remaining changes in the roadmap? Why is it beta?. ",
    "hujunfeng": "Run into the same error in Xcode 9 beta 2. It looks like that Gloss could not decode a value if the property is type of Float.\nHere is example:\n```swift\n// Model\nstruct MyStruct: Gloss.Decodable {\n    var floatValue: Float\npublic init?(json: JSON) {\n    guard let floatValue: Float = \"floatValue\" <~~ json else { return nil }\n    self.floatValue = floatValue\n}\n\n}\n// Using the following example to decode\nlet exampleJSON: JSON = [\n    \"floatValue\" : 1.23,\n]\nguard let device = MyStruct(json: exampleJSON) else {\n    print(\"DECODING FAILURE :(\")\n    return\n}\n```\nIt would fail in Xcode 9 with the following error:\n[Gloss] Value found for key \"floatValue\" but decoding failed.\nDECODING FAILURE :(\nIt might be related to the changes of NSNumber in iOS 11 and macOS 10.13:\n\nBridging NSNumbers in swift to numeric types now uniformly limits the cases of as? cast no matter how the NSNumber was created. Casting NSNumbers to numeric types will return nil if the number cannot be safely represented as the target type.\nFoundation Release Notes\n\nHere is what I found in debugger:\n. ",
    "Bathibabu": "@hkellaway \n{\n  \"message\": \"OTP is sent to your phone to verify your account\",\n  \"auth_token\": \"\",\n  \"data\": {\n    \"id\": \"12\",\n    \"phone_number\": \"+91-XXXXXXXXXX\"\n  },\n  \"is_verified\": 0\n}\n. Thank you, It is working fine. ",
    "xaphod": "Sure i'll try to get to it next week.. ",
    "Blackjacx": "YES that\u2019s true but I can partially initialize my objectors and this that should be possible for meins too. You wouldn\u2019t break anything if you\u2019d provide a optional default value so everybody can feel free to throw in an .unknown value as default that is set for the unknown cases. If it is not provided ( the default ) the user will get the same behavior as today.\nI understand that you want to keep everything consistent. But I didn\u2019t expect that I don\u2019t receive any enum case, even not the ones I know.. Concretely I mean the following:\n```\nimport Foundation\n// JSON:\n// {\n//     \"cases\": [\"first\", \"third\"]\n// }\nenum MyEnum: String {\n    case unknown\n    case first\n    case second\n}\npublic static func decode(enumArrayForKey key: String, keyPathDelimiter: String = GlossKeyPathDelimiter, defaultValue: T? = nil) -> (JSON) -> [T]? {\n    return { json in\n    if let rawValues = json.valueForKeyPath(keyPath: key, withDelimiter: keyPathDelimiter) as? [T.RawValue] {\n        var enumValues: [T] = []\n\n        for rawValue in rawValues {\n            guard let enumValue = T(rawValue: rawValue) else {\n                guard let defaultValue = defaultValue else {\n                    return nil\n                }\n                enumValues.append(defaultValue)\n                continue\n            }\n            enumValues.append(enumValue)\n        }\n        return enumValues\n    }\n    return nil\n}\n\n}\n// Will result in an array returned which will contain known cases and the default value for all cases that could not be parsed, i.e. are unknown.\nlet parsedCasesWithDefaultValue = Gloss.Decoder.decode(enumForKey: \"key\", defaultValue: .unknown)(json)\n// Will represent the current behaviour, i.e. returning nil when one case is unknown\nlet parsedCasesWithoutDefaultValue = Gloss.Decoder.decode(enumForKey: \"key\")(json)\n```\nThis way you can support both behaviours. Does this make sense?. Apparently I have currently no time for this. As you said I simply have written my own function for this. . ",
    "Sihak": "Gloss.Decodable works . ",
    "jannejava": "Thanks for your reply! It's coming from ExtensionArray.swift and ExtensionDecodable.swift found inside the Gloss project. \nMy app is it self a just migrated from Swift 3 to Swift 4.\nI created a new fresh project with Gloss swift_4, and it does indeed compile but not my migrated project. I don't know if it's Xcode9-beta is pulling my legs. Cannot understand why it should be different?\n\n. Ah, that's it! Seems to compile just fine now.. Needed to add public init() { } in GlossLogger as well. The app is now running.. ",
    "stefanomondino": "It may not be an elegant solution, but I resolved conflicts by placing a typealias Decodable = Gloss.Decodable in one of my files to remove all warnings. ",
    "andrewjmeier": "@hkellaway Are there plans to update to Swift 4 soon? . @hkellaway looks like it passed! . @hkellaway I changed the branch to swift_4.0. Ah rip. @hkellaway hopefully that fixes it. I didn't realize there were already changes in the swift 4 branch. . ",
    "dhushon": "Just picked it up... I just have to overwrite the Encodable / Decodable protocols, e.g.\npublic init?(json: JSON, option: option) {\n        // decode option\n        self.init(json:json)\n    }\npublic init?(json: JSON) {\n   // do selected parsing\n  switch(option): \n       case optionA:\n       case optionB:\n\n}\n}\nI believe... thanks for the quick response!\n. will let you know in a few... . ",
    "hcanzonetta": "@hkellaway CI was using an older version of pods. Also, we could remove the gem install cocoapods in .travis.yml since bundler is already installing the version specified in the Gemfile. ",
    "syn-deepakbadiger": "made the changes into swift_4.1 for compactMap issue and pushed the code... Not sure, why it failed, though i removed flatMap and converted the code to compactMap and ran a build on my side to ensure it builds fine and with no errors. is there something that i would need to do so as to ensure travis CI builds properly?\n. \n\n\nas can be seen from the screen shots, Travis is failing on line 82 for \"Unresolved Identifier compactMap\", but i have already tested that with the build on my side and i don't see any unresolved errors on my side as evident in the code screen shot..\n\n. updated the yml file and it went through the CI again. However, unfortunately, it failed this time even without completing the build process.. @hkellaway i got this to work and the travis-Ci has executed well. FYA now.. ",
    "mladen7": "Getting this error with version 2.1.0... I see the issue is closed, any way to resolve it? Using swift 4.0, is compactMap only 4.1?. > yes, compactMap is Swift 4.1 you can use Gloss version 2.0.1\nThanks for the quick reply, think i'll boost the project to latest swift instead :). ",
    "humayunharoon": "I ran into a similar problem, i was trying to decode the following\n\"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [6316441.4998557, 2238781.999901123],\n                [6316597.000106672, 2238781.750082011],\n                [6316753.500046402, 2238773.499977206],\n                [6316915.500055061, 2238769.2499266085],\n                [6316971.00007257, 2238768.000012289],\n                [6317270.000126404, 2238767.999932552],\n                [6317557.499930823, 2238770.7500937157],\n                [6317574.4998469725, 2238770.74989819],\n                [6317574.500009165, 2237796.249847131],\n                [6316915.000084694, 2237809.2499545123],\n                [6316840.00009377, 2237810.7500073947],\n                [6316454.000149357, 2237818.5000326806],\n                [6316443.9999227375, 2238214.999842878],\n                [6316574.500093954, 2238220.7498998777],\n                [6316580.000100006, 2238377.0001023966],\n                [6316915.500070422, 2238388.2499773093],\n                [6316915.500138131, 2238622.7500463747],\n                [6316440.50000006, 2238628.250137332],\n                [6316440.500050454, 2238748.2500674333],\n                [6316441.4998557, 2238781.999901123]\n            ]\n        ]\n    }\nI set up the following classes\n```\nstruct GeoJSONGeometry: JSONDecodable\n{\n    let type: String?\n    let coordinates : [Polygon]?\ninit?(json: JSON) {\n\n    self.type = \"type\" <~~ json\n    self.coordinates = \"coordinates\" <~~ json\n}\n\n}\n```\n```\nstruct Polygon : JSONDecodable {\nlet coordinates : [Float]?\n\ninit?(json: JSON) {\n}\n\n}\n```\nand i'm having trouble figuring out how to decode the polygon.\n. ",
    "str11ngfello": "Thanks for the response.  I found a workaround.  Your Test folder causes that command to fail. Apparently it doesn't like that layout. If I remove the test folder, Swift Package Manager works fine.\nCheers!. ",
    "Abushawish": "Thank you!. ",
    "AlexandreMinard": "Thanks for your answer.\nWould you mind to give me a sample code for such extension please?\nRegards,\nAlexandre. ",
    "george-gymamigo": "How would you fix this? As it isn't appearing for my other pods installed. ",
    "JacquesCobi": "Ah interesting, would have thought both non-optional and optional would be effectively equivalent. I've used guards with optionals in a lot of other places fine, but I guess non-optional is the correct way to go.\nThanks. "
}