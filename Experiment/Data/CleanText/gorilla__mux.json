{
    "soul9": "An other problem with the Host() function is that it can't handle ipv6 addresses well.\nFor the \"http://[::1]:8080/foo\" url, and Host(\"{host:.+}\") regexp, mux.Vars returns map[string]string{\"file\":\"foo\", \"host\":\"[\"}\n. the other pull request looks just as good, and faster, so i'm closing this one. Cheers!\n. ",
    "dominikh": "What's the status of this issue? Experimentation makes me believe that currently, one has to call Host() without a port, and that will work even if the Host header includes a port. Is that correct?\nAlso, in response to @soul9, getHost() should probably use net.SplitHostPort instead of just splitting on a colon, but that's a different issue.\n. Is there any progress on making this a part of gorilla/mux, or should one stick to MethodHandler?\n. ",
    "kisielk": "Honestly I haven't looked in to it since Oct 2012 most likely :)\n. As far as I understand it + and %20 are only equivalent after the ? query parameters in a URL.\n. Not sure if this is the right way to go about correcting this problem. Current (and maybe @moraes can correct me if I'm wrong here) the context is only used by mux to store the information for mux.Vars.\nI think a better solution than adding more stuff in to mux would be to extend the context package so that it didn't just have one global context store, but a ContextStore type. That way the mux package could have its own package-scoped ContextStore and you could make your own to store your information. Then you wouldn't need to worry about different packages that use context stomping all over each other.\nThoughts?\n. Exactly, mux's use of context is an implementation detail and currently it's leaky. That's why I propose making a ContextStore type. The context library would maintain one global ContextStore to preserve the current behaviour and API.\nThen each mux.Router would create its own ContextStore, this would also allow arbitrary nesting of mux's because they would each manage their own contexts with their own vars instead of using the global one.\nAs for  your use, you could either create one package-level ContextStore or if you are using a type for your handler it could just be a field of the type.\n. @moraes by leaky I meant that the abstraction is leaky. It shouldn't be obvious or necessary for users of mux to know that it uses context under the hood.\nAnd yes, the variable overwriting for different router instances is one of the ways that this can manifest.\nI just finished prototyping my proposed changes to context and I'll have a prototype of the mux changes soon, then we can discuss if it's a good solution. I think it's possible to change this without having to break the existing API, just augment the context package with a new type and have mux use that.\n. I had an idea for a handler that could be used for this purpose here: https://gist.github.com/4561395\nIt doesn't have the Allow header yet but that should be easy to add by just using the keys of the map.\n. I intentionally hid the map behind a bunch of methods in case there's a\nneed to add some other options etc to the handler, but I guess that works\ntoo :)\nI also have something similar called AcceptHandler kicking around which\ndispatches to different handlers based on the best match of the Accept\nheader. Maybe we could make a gorilla/handlers package?\nKamil\nOn Tue, Jan 22, 2013 at 1:27 PM, rodrigo moraes notifications@github.comwrote:\n\nVery cool.\nWith a header (and simplified to a map): https://gist.github.com/4598513\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/gorilla/mux/issues/6#issuecomment-12567526.\n. The second syntax is actually pretty attractive especially when\ninitializing with several handlers at once. I think that's the most common\ncase. I think it's a good argument for just making it a map type.\n\nKamil\nOn Tue, Jan 22, 2013 at 1:46 PM, rodrigo moraes notifications@github.comwrote:\n\nI think something like this would be a good addition! :)\nI can only think about one reason to hide the map -- add multiple HTTP\nmethods at once:\nr.Path(\"/foo\").Handler(new(MethodHandler).Add(myHandler, \"GET\", \"POST\"))\nOtherwise usage is like this:\nr.Path(\"/foo\").Handler(MethodHandler{\"GET\": myHandler})\nWhich one?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/gorilla/mux/issues/6#issuecomment-12568452.\n. Do you have any idea how this could be implemented in mux? I can't see any obvious way to do it with the current design. It would need to recognize that one or more of the routes matched, apart from the method matcher. This is further complicated by the fact you can have multiple routers with the same URL but different sets of methods, so it's not enough to check within the route.\n. I uploaded an implementation of the handler version to https://github.com/gorilla/handlers\n\nRefined the code a bit further and also added support for OPTIONS. \n. @peterretief I think you are thinking of a different project.. that looks like Python code to me.\n. I think so. I don't think it's possible to add it to the library without rewriting most of the route matching.\n. I'm going to close this as WontFix for now since I don't see any obvious solution to this problem given the current way the router is implemented. My suggestion is to use MethodHandler from gorilla/handlers if you really need this functionality. If someone comes up with a good solution to integrate this in to mux, I'd be happy to look at it.\n. Sorry I totally missed your update for some reason.\n. mux doesn't work the same way as the default net/http handler, it doesn't match as prefixes by default. You can use router.PathPrefix or route.PathPrefix if you want to get that behaviour.\nUsually I use something like router.PathPrefix(\"/css/\").Handler(http.StripPrefix(\"/css/\", http.FileServer(....))) for serving static resources.\n. There's actually a typo in this that for some reason the tests still pass with. Will investigate further.\n. Need to tweak this a little bit more, will re-open the pull request when I'm done.\n. I believe this will be fixed in #117 \n. How about adding a Scheme() function to the router to match URL schemes as\nwell? Then the router can use that if it's available when constructing\nURLs, similarly to how it uses Host() now.\nOn Tue, Feb 5, 2013 at 2:36 PM, rodrigo moraes notifications@github.comwrote:\n\nWell it doesn't have a parameter for that to bloating the common case. It\nis easy enough to create a helper function to build the URL and set scheme\nto https. What else could we do?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/gorilla/mux/issues/13#issuecomment-13156200.\n. Not sure how I missed the existence of Schemes() but I swear I checked for it in the docs :)\n\nWhat if we default to http, but if there's a schemesMatcher in the route, use the first scheme defined there?\n. Thanks :+1: \n. @jmassara please open a separate issue for that.\n. Do you have a link to the specific bug that fixes this behaviour? It would be nice to have a test case for it at least.\n. The reason this isn't reflected in the mux tests is because we build all our own requests. It seems the bug is mostly to do with net/http not setting some fields in the URL. I think it would help increase the quality of the tests if we actually used net/http via httptest instead of just constructing fake requests, as that's probably the most common use case.\n. Accept needs special parsing beyond what you can do with regular expressions. Trying to use the Headers directive is probably not the best fit for it. The values of the accept header need to be sorted based on their q value and then dispatched to the best matching handler. Currently there is not support for this in Mux buit could probably  be added with another directive.\n. You can read any of the headers just fine, there's just no parsing of the\nstrings in to values that are convenient to work with, as you have\ndiscovered when trying to match the Accept header.\nOn Tuesday, April 16, 2013, richard bucker wrote:\n\nActually there is a much bigger problem here. It seems that Go1.0.3 has\nnot completed the net/html implementation:\n// TODO: Parse specific header values:\n//  Accept\n//  Accept-Encoding\n//  Accept-Language\n//  Authorization\n//  Cache-Control\n... and many more\nhttp://golang.org/src/pkg/net/http/request.go\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/gorilla/mux/issues/18#issuecomment-16480961\n.\n\n\nKamil\n. Seems to have worked well in practice thus far. Not sure what you are proposing with this issue?\n. I doubt we will change it again any time soon as we already went from one->many repos last year and so far it seems to be working alright. I haven't seen any talks or screencasts that give any strong rationale for one way or the other, so I'd be interested in seeing those.\n. I looked at this today but there doesn't seem to be any obvious way to implement it. NotFoundHandler is only called from ServeHTTP, which is only ever called on the top-level router and not the subrouters. Furthermore there is no concept of a partial match, that is the top-level part of the subrouter path matching but the inner part not matching. \n. Closing in favour of #6 \n. 7a711bc already contained the changes needed here.\n. Looks good overall, I'll merge it after the API adjustment.\n. Not a problem, thanks for the code.\nThe indenting seems weird though, did you run it through gofmt?\n. Merged as e718e932ee606838744df844eb75064959eb74bc\n. Sorry for not getting back to you sooner, I just had a look and am thinking about this. \n. Thanks for the update, don't worry about the time :) I'll try to give your changes a spin in the next few days and see how it feels.\n. I agree with Moraes that this a is a bit bolted on, but I'm not sure what else we can do without a larger rewrite that perhaps includes some breaking API changes.\n. Sorry I didn't get a chance to finish my thoughts because of pesky work interruptions :) \nI still think it's probably worthwhile to merge this since it's a fairly minimal and fully backwards-compatible change.\n. I'm still unsure about returning such verbose messages in the 404 handler. I have a feeling that most users would prefer a simple behaviour of the status code with the default message.\n. Yeah I think we should just remove them altogether, users can always install their own.\n. Hi John,\nFinally had some time to take a look at the code. I think we're almost there. Thanks for your patience.\n. Yes, sorry I haven't merged it yet. I am just trying it out in a project now to see if I'm actually happy with the API :)\n. @josharian if you've actually tried this PR feedback on how well it works would be useful too.\n. The project is already formatted with gofmt. If you run your changes through gofmt it should match the current formatting conventions.\nMaybe you have sublime configured to use spaces instead of tabs?\n. Have you taken a look at the gorilla/handlers package? It uses a different pattern for implementing middleware. I'm no sure if adding this to mux is really necessary.\n. If you don't mind, I would like to close this pull request. I think that wrapping a mux.Router in another handler is a already a good way of providing middleware without having to change the API.\n. I don't see any obvious reasons why it should not work. Can you provide any more details? Are you sure the client is going specifically to the /ws URL and not a sub-path thereof? The gorilla mux example will return 404 for anything that's not exactly /ws or /\n. Do you have the actual code available somewhere, to provide a runnable example?\n. Yeah, I've seen other people using it successfully. Please reopen if there is a specific example of it not working.\n. For the latter you need to make two routes, and use .Methods()\neg:\nr.HandleFunc('/foo', getFoo).Methods('GET')\nr.HandleFunc('/foo', postFoo).Methods('POST')\nIf you want a route to match both with and without a trailing slash, but not have any redirection, you just have to make two routes with the same handler.\n. Also in the future you can ask questions here instead of filing an issue: https://groups.google.com/forum/#!forum/gorilla-web\n. @corey-garvin can you provide a runnable code example that demonstrates? \n. Hi @fvosberg , I left a comment on your commit.\n. Thanks :+1: \n. To be honest I don't think I like the syntax for this. I know @moraes was thinking about a different model for mux altogether so maybe he can pitch in.\n. Well, you could solve that kind of thing with a loop:\n```\nfor _, ct := range []string{\"application/json\", \"text/x-json\"} {\n    r.Headers(\"Content-Type\", ct).HandlerFunc(MyHandler)\n    ...\n}\n```\n. Not denying that, but I think it needs a larger API rethink.\n. going to close this for now, will revisit the idea when we are looking at doing a v2.\n. Thanks :+1: \n. It's already possible to do this two ways:\nrouter := mux.NewRouter()\nrouter.Handle(\"/foo\", handler)\nhttp.Handle(\"/\", middleware(router))\nor \nrouter := mux.NewRouter()\nrouter.Handle(\"/foo\", middleware(handler))\nhttp.Handle(\"/\", router)\napart from saving a bit of typing in the second case, are there any other benefits from this approach?\n. I guess only the second approach I outlined above works in the case of subrouters, but that still works doesn't it?\n. You can do it without growing the mux API:\n```\nfunc Use(handler http.Handler, middleware ...func(http.Handler) http.Handler) http.Handler {\n    for _, m := range middleware {\n        handler = m(handler)\n    }\n    return handler\n}\nmiddleware := []func(http.Handler) http.Handler{middleware1, middleware2}\nsub := router.PathPrefix(\"/sub\").SubRouter()\nsub.Handle(\"/foo\", Use(fooHandler, middleware...))\nsub.Handle(\"/bar\", Use(barHandler, middleware...))\n```\nSorry for being a stickler, I would just prefer to avoid adding unnecessary API functions to mux and growing the internal complexity. \n. I think that illustrates another problem, everyone is going to want to have some different way to want to stack their handlers. Instead of committing to one, I think we should leave it open. mux is not a framework, it's merely an HTTP router. If you need handler stacking or other functionality like that, that's to be implemented elsewhere.\nI discussed the idea with some of the other maintainers and I think we are in agreement.\nApart from that, the implementation of this suffers from a few problems in that it rebuilds the function call stack on every single call to ServeHTTP, the other approach I posted here avoids that.\n. I wish changes like this were discussed before the PRs were sent. There's already some prior attempts at this sort of thing in #36 and #28 \n. Sorry, I'm not going to merge this as is. For large feature additions please discuss the design ahead of time via an issue or on the mailing list: https://groups.google.com/forum/#!forum/gorilla-web\n. Thanks. :+1: \n. Thanks Philip. You should be able to just push the \"pull request\" button in your repo.\nDo you think you'd be able to add a test for this?\n. I haven't seen any pull request yet. However when you have a pull request open adding more commits to the branch will automatically add them to the pull request.\n. The PR (#41) was merged and fixed this.\n. Thanks :+1: \n. Schemes() just looks at what comes through in the http.Request object, it's up to the net/http Server to fill that in, which as you've seen it doesn't for some cases. Also I think in general it's not a good idea to redirect from HTTP to HTTPS, it's better to fail and let your clients know they're hitting the wrong URL.\n. I agree, and I'd be happy to merge a patch with tests that included the check for req.TLS in schemeMatcher if https is one of the schemes to be matched.\n. @lukescott yes I think that's good, though I would write the if block as:\nscheme = \"http\"\nif req.TLS != nil {\n    scheme = \"https\"\n}\nI like that you have left the possibility of req.URL.Scheme being set in there, since according to the RFC it's possible the client will put something in that field.\nAs far as tests, just to show that the matcher matches and does not match the various combinations of requests. Eg: request with TLS == nil is not matched for https, etc.\n. Thank you.\n. I have started adding some example tests (not pushed yet). Would probably be nice to have one of those.\n. Repo collab is just a tag that shows I am one of the repo collaborators :)\nWhat I meant was that the sentence is missing a period at the end.\n. Sorry but I think most users would be unhappy with this. If you want an easy way to add logging to your handler try the logging handler from github.com/gorilla/handlers, it doesn't require modifying gorilla/mux.\n. I believe this will be fixed in #117 \n. I would consider it for a future version of the project, but at this point we cannot change the API. The reason the route is returned is to allow chaining additional functions, eg: x.HandleFunc(f).Name(\"foo\")\n. Thanks\n. I think for now I would prefer people use the github/gorilla import paths than gopkg.in. Besides we have committed to not breaking the API for these import paths, so versioning is not a concern right now.\n. Thanks. I probably won't get a chance to review this till next week as I'm travelling.\n. Ok I had a look, I think it's good overall. Do you think this changes any reasonable behaviour for existing users?\n. I wonder if we should make it an error to add a route with \"/foo\" and \"/foo/\" to the same router if StrictSlash is enabled...\n. Going to merge this for now, we can always refine it later :)\n. Thanks. I probably won't get a chance to review this and your other PR till next week as I'm travelling right now.\n. Nope, it would be nice to be there to meet all the other gophers, but I'm in Africa until next week.\n. Code looks good, and it's an interesting idea, but I'm not sure I'm entirely convinced yet. Why not just define:\nfunc xURL(args ...string) *url.URL {\n    // do stuff to args\n    //\n    r.Get(\"X\").URL(args...)\n}\ninstead of using this? in fact that seems more powerful because you could limit the arguments to xURL and use types to get further safety. That's the technique I usually use for URL generation.\n. Okay, after thinking on it some more I decided to merge this. It doesn't complicate things too much and it does indeed seem useful in some cases. Thanks and sorry for taking so long :)\n. I'll have to think about this one for a bit. Will need to look in to what other routers do.\n. Interesting idea.\nSo in this case if you had Queries(\"id\", \"{id:[0-9]+}\") the route would only match numeric id's ? Perhaps we should have a test for that.\nAlso can you see why the other tests in the Travis build have failed?\n. Cool, thanks :+1: \n. Great. Reads much better now.\n. Yeah I thought about that as well. It's one of those could go either way things. On the one hand few people will probably need this, but it would be a nice convenience for those that do...\n. I looked at some other web tools. Some include it right in the base router (Django, ASP.NET) others (Flask, Martini) provide it as middleware. I'm thinking given the approach of Gorilla, it might be better off to make this a handler in gorilla/handlers like @zeebo suggests.\n. I agree with @morson here, it's something you could do with a handler that wraps mux.\n. Given that the behaviour would be different for each application, I think it's just as easy to write one each time you need it\n. It's not really a mux issue, but a general net/http one. Having an example in the net/http docs or on the go wiki would probably be more appropriate. Though really it's just standard panic recovery like elsewhere in Go.\n. Thanks.\n. I don't really think a warning would help since it's a pretty obscure case that would require a fair bit of effort on the developer's part to debug.\nI'd rather see us redesign the route matching algorithm so that this kind of thing wasn't a problem, I think the current method is a bit brittle and suboptimal.\n. How do you propose to fix it?\nIf I added a note \"backreferences should not be used in regexp patterns\" would that have been helpful in avoiding the problem?\n. There's still a lot of ways that could break. The addition of braces around the variables is required so that they can be pulled out in to mux.Vars. You're right that having nested braces causes the same match to appear in two subsequent indices of the submatch result. mux isn't expecting this to happen when unpacking, so it uses the same pattern match twice.\nMaybe the solution would be to use SubexpNames and only extract vars with that? All the route vars should be named so any unnamed results could be ignored.\n. Okay, I believe the patch linked in #117 will fix the problem with subexpression. Before merging I'd like people to try it out with some of the patterns they've had problems with and let me know if it solves the issue. \n. Are you sure you ran it with the correct version? I tried adding the following test, and it worked correctly:\n{\n            title:       \"subexp\",\n            route:       new(Route).Path(\"/again/{name:bl(ah|at)}/{profile:.+}\").Methods(\"GET\"),\n            request:     newRequest(\"GET\", \"http://localhost/again/blah/up\"),\n            vars:        map[string]string{\"name\": \"blah\", \"profile\": \"up\"},\n            host:        \"\",\n            path:        \"/again/blah/up\",\n            shouldMatch: true,\n        },\nOtherwise can you provide a full runnable example so I can test it?\n. @joegrasse any chance you can try it for your use cases?\n. Great. Hopefully that works for everyone :)\n. I don't think we can justify adding this to the API. The example could just be written as:\nr := mux.NewRouter()\ns := r.Host(\"www.domain.com\").Subrouter()\ndomaindotcom.getRoutes(s)\nWhy do you feel this requires an API addition to mix?\n. Sorry, I'm still not convinced. It's something that's already achievable via the existing API or you could even add your own function to do it:\nattach(r.PathPrefix(\"/users\"), user.GetRoutes)\nif that's the way you prefer to structure your code. Everyone has a slightly different preference and we can't grow the API to accommodate each person. Personally I don't like having methods which just call callbacks and don't provide any other functionality.\n. Thank you\n. What kind of debugging would you like to see? Which route matches it tries?\n. I agree, if such a feature were to be implanted it would have to be enabled\nwith a build flag or something similar so that production use would not be\nimpacted. But in think that would significantly increase the code\ncomplexity and maintenance burden for just a small payoff.\nOn Thursday, September 11, 2014, Gediminas Morkevicius \nnotifications@github.com wrote:\n\nwell, in my opinion such features aren't useful for production mode, since\nit adds extra checks for the flag in the sensitive place. Just edit the\nsources of the mux package in your GOPATH and have a development\nenvironment you want. For production, reload or switch the branch.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/68#issuecomment-55230133.\n\n\n-K\n. Good point about the constant, I'm not sure if the compiler eliminates code\nnot reached through a constant branch, will need to check the output of\nsome test programs. Is rather not have the decision made at runtime, we'd\nneed to check a flag on every potential match.\nOn Thursday, September 11, 2014, Dave Rolsky notifications@github.com\nwrote:\n\n@l3pp4rd https://github.com/l3pp4rd - doesn't the Go compiler compile\nout unused statements? Why not have a Debug constant that defaults to\nfalse, then all someone would need to edit would be that one constant.\nThat said, absent benchmarks showing that this is an issue, it'd be nice\nto make this a flag.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/68#issuecomment-55269223.\n\n\n-K\n. I think this would be pretty complicated to add and I don't have much inclination to work on it. If someone has a good idea or implementation that wouldn't impact performance with debugging turned off, I'd be willing to look at PR.\n. Done.\n. Much clearer, thanks.\n. I think this is probably a good match for inclusion, I like how you've implemented it in a non-intrusive way.\nI'm going to spend some more time next week to review the patch before merging it. Thanks.\n. Getting around to some old bugs....\nI don't think this needs to be in the router, it could easily be a middleware wrapper that gets called before getting to the router stage. \nI think it's important to try to keep the mux complexity down to make it easier to maintain, so I'm going to stick with features that pertain to matching and dispatching requests as opposed to modifying them. Modifications can be done by a middleware layer.\n. Not really a bug... I think the stackoverflow post answered your question.\n. Closing this for now since it's vague. If you are still having problems please file a new issue with a runnable code example.\n. You just have to save the router or subrouter somewhere where you can access it from your route to call the URL() method. Either a global or a field on your handler struct would work. I usually just use global routers and subrouters in the majority of apps. If they are only modified at initialization time there's nothing wrong with that...\n. If you need to match on specific headers, there is already a matcher for that. You could make another route in addition to the one that matches on method but routes to the same handler.\nWe can't change the current behaviour without adding another flag, since existing users may depend on it.\n. I think a better question is whether there's a use case for deleting routes.\n. I agree with @avrtno 's comment on this. Allowing deleting or modification of routes while the router is running would be troublesome to add at this point, and there's not many uses for it. \n. hm ok, how about handling of subrouters? I don't think your current method lets the walk function recognize when it has descended in to a subrouter, does it? For example in the test I don't see the \"/z\" path appear anywhere.\n. Yeah I don't think we should skip the subrouters, also we need some way to signal to the walk function that it's encountered one so it can push to a stack or something like that.\nI also agree about the special error to avoid descent.\n. yeah that's one possibility. I think a good litmus test is whether or not we can produce a tree with all the paths, including subrouters, in a print function.\n. Merged #106 instead.\n. Your interceptor is calling mux.Vars before it calls the router, so the router code which extracts the route vars hasn't run yet.\n. Well, the main reason it's not exported is that it's generally not that useful. The named routes just contains whatever routes you've added to the router and then named with .Name...\n. There's another issue for that. getNamedRoutes won't do anything to help you.\n. I was referring to #83\n. I just merged #106 which implements the walk functionality originally proposed in #83. It should should be able to do what you need.\n. Site seems to be working fine here. I haven't been very good at keeping on top of it though :/\n. Thank you.\n. Thanks. Sorry for the delay :+1: \n. Curious as to what the use-case for this is? I can't think of a situation where I'd define a route that only matches one particular username and password. Usually I would wrap the router or a path prefix in another handler that does authentication. \n. I agree with @avrtno, I've never seen a scenario where you'd want to authorize exactly one hardcoded user in a real application. There is usually a lot more complex machinery involved which is beyond the scope of this package.\n. Would need more details about what the request looks like, and what you mean by \"all requests go through\"... do they actually get routed to the desired handlers regardless of the header? or? May be better to post this to the mailing list: https://groups.google.com/forum/#!forum/gorilla-web\n. Cool, thanks for helping out :)\n. That shouldn't be happening, and I've never seen that behaviour before. Some code to reproduce would be helpful :+1: \n. Thanks :)\n. The cleanPath behaviour is identical to that of the net/http mux. \n. and actually the redirect behaviour is basically the same as well... so I'm not really inclined to change the way it is working right now\n. So can this be closed?\n. I'm inclined not to merge this because it relies on an internal implementation detail. I think we would lose some flexibility in changing the inner functioning of mux if we committed to returning a path template in a particular format. Feel free to re-open for discussion if you disagree.\n. Thanks\n. Hm, I think it's a good idea but potentially problematic for existing users who may be matching literal header values. Interpreting the literal values as regex all of the sudden could mean matching (or not matching) things that weren't intended to be.\n. So if we want this functionality, I think adding a HeadersRegexp function would be better, and then create a new matcher which does that. That will also avoid the overhead of running a regexp instead of a standard string comparison for when it's not needed.\n. Well, it is only used by the header, but say someone has an existing header matcher that looks for a value like (foobar), foo* or foo+ literally. If we now interpret those patterns as regexps they'll match things they didn't match before, potentially breaking the app.\n. It's a good start, but it's unnecessary to compile the regexp each time the match is attempted, which is what regexp.MatchString will be doing. You should Compile the regexp just once when the matcher is created and then just use the compiled version's MatchString method.\n. Just return the error for now like elsewhere in the code, I'd rather change it all in one fell swoop later.\n. Looks good, thanks. As usual GitHub's notification system is a failure as far as telling me things :) Took the @ mention for me to see it...\n. Also what happens if the the query parameter you are matching is not the first one? \nI think this can be achieved by using req.URL.Query() and applying the regexp to each key in the map\n. ok that seems good. Damn that code (not yours, just the matcher code in general...) is hard to follow though :/\n. Not going to merge this since I want to change up the error handling strategy in mux.\n. This doesn't have anything to do with mux in particular. I believe on Linux if you import the \"net\" library it links to libc in order to use the DNS resolver.\nYou can rebuild your Go standard library with the -tags netgo and then rebuild your program with the same if you want to use the pure Go resolver. \n. This looks good, thanks.\n. I'm not sure these are generally applicable enough for all users of Mux. People will have different preferred ways of doing this and it's simple enough functionality that someone else could implement it in their own app if they needed it.\n. Looks good, thanks.\nReally need to refactor addRegexpMatcher in to three separate functions at some point, it's getting kind of ridiculous with all the flags....\n. @burrbd sounds good. I figured the whole thing could be a lot simpler if there was a separate function to create a matcher for each, since really there is not much overlap between the logic there...\n. @burrbd any chance you can have a look at this?\n. Thanks for the fix.\nIt really seems unnecessary to put the key and = in to the template now, I have to get around to refactoring this code and creating a dedicated query matcher which just has a key and value field to avoid all of this mess.\n. You could already extract that from r.URL.Queries()[\"foo\"] inside your handler if that's what you need...\n. Yeah, it's unfortunate about vars but we can't change the API.\nBut yes, I the matcher should check each foo and just return the first match, which is what it's doing now.\n. Actually, that's not quite right.. it's only attempting the match on the first query... sigh. It seems like we'd probably have to do a fair bit of refactoring to get the desired behaviour with multiple query items with the same name.\n. I think there's other ways to test this that would be just as effective or more, without needing to expand the API of the package.\n. The way I usually test is create a mock server using the net/http/httptest package and actual create a router instance. Then I send requests to the server which will call the appropriate handler and produce the vars I want to test. That way the routing can be tested as well.\n. @elithrar any thoughts on this?\nIt does add to the API a bit, but then again it doesn't add more methods to Route or Router...\nMy only qualm is that people may abuse it for things other than testing and that may complicate some uses of the package later...\n. Ah right, I didn't even think of that :) Right then, going to close this.\n. mux never touches the request body, so there must be something else going on here...\n. are you able to put a fully runnable example in a gist that reproduces this?\n. Ok, but that example is not runnable... I'm just asking for a minimal reproducer, you don't need to show all your ode.\n. I ran the code (after commenting out the use of ffjson and replacing with a Println) and hit the server with curl http://127.0.0.1:8888/api/catalog -d \"{}\", I didn't get any EOF errors...\n. So you were using middleware which wrapped the Router? It should be available in middleware which wraps a handler since mux will call it...\n. Yes, that's correct.\nIf you want to do it that way, you can enable KeepContext and then manually clear with another middleware that wraps the whole stack.\n. The examples should really use example.com instead. Do you mind just replacing all occurrences of domain.com or other URLs with that?\n. Seems reasonable. Breaking hyphenated names was certainly un-intentional, so thanks for finding that.\nAny particular reason you chose to remove the name != \"\" checks in setMatch though?\n. That's true, but you can skip the Sprintf call entirely if the name is empty since you know it will never match. It would probably afford a slight difference in performance when there are nested subexpressions (and hence blank names).\nFor that matter, I'd rather varGroupName didn't use fmt.Sprintf since that requires additional interface to concrete type conversions. I think a string concatenation with the result of strconv.FormatInt would be preferable. \n. That looks good, thank you. Also thanks a lot for the thorough test cases, it's much appreciated.\n. oops :)\n. These kind of questions are better suited for the mailing list (https://groups.google.com/forum/#!forum/gorilla-web). I usually pass in functions to generate URLs via http://golang.org/pkg/html/template/#FuncMap\n. @mtso go for it!. oops :)\n. Awesome. Thanks :+1: \n. I am a bit concerned about the addRegexpMatcher modification. That function just simply does too much and is really complicated to maintain, I'd rather not grow it. I hope to be able to do some refactoring and split it up, to have a separate function for each kind of matcher. I have a local branch that does some of this, but it's not fully functional yet...\n. I pushed the branch up to GitHub, it's in the matcher-refactor branch. It looks like so far I got Queries to create its own matcher without relying on that big mess of a function. The other types of matches still need to happen.\nNot sure if you want to take a look at it or not, but I'd appreciate some help working on the refactor if you're interested. I don't have a whole lot of time to devote to it at the moment.\n. I think we should wait till the net/context situation is resolved before making the API. It could totally change the design and drop the need to use gorilla/context at all. The other option is to build it with the current x/net/context for now and then migrate to the standard library version.\n. @marcelloh Please open a new bug with a fully reproducible example. @odlp What kind of problems were you having with adding tests?. Ping @odlp . Is there still interest in merging this?. I agree with @ChrisHines . The isSecure() method seems a bit weird to me in comparison to actually checking for the schemesMatcher and returning the first found scheme.. @ChrisHines @elithrar can this be closed now?. I was actually thinking of doing that this weekend, but I guess you beat me to it ! \nThe implementation looks great to me, very elegant.\nThe only thing I can think of it breaking is people who were manually extracting route vars via the gorilla/context package, but nobody should be doing that...\n. Yeah, that was explicitly for this reason, so we could change the context\nstorage method in the future.\nOn Sat, Jun 4, 2016 at 09:44 Matt Silverlock notifications@github.com\nwrote:\n\n@kisielk https://github.com/kisielk Thankfully we didn't expose the\ncontext keys in #167 https://github.com/gorilla/mux/issues/167 or #112\nhttps://github.com/gorilla/mux/pull/112!\nThanks for merging as well.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/169#issuecomment-223765555, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AADk-iRGK5Es4kHI90_ZYdNkAJZId7V3ks5qIatigaJpZM4IuFga\n.\n. I think the original assumption was that WalkFuncs would only ever return SkipRouter, but I guess it makes sense that they could also return other error values that cause an abort.\n. @elithrar any problem with merging this?\n. This is an unfortunate breakage. However I also feel like gorilla/context has outlived it's purpose now that context will be in the stdlib. It's a much better way to manage per-request state and will probably also interact better with the new per-goroutine GC stuff that will be making its way in.\n\nIt may be extreme, but maybe in the interest of backwards compatibility we should put go1.7 context behind a build tag (other than go1.7) for now?\n. It seems like we should probably put a warning in the readme of gorilla/context that it's not compatible with using the new http context?\n. I think you need to have a separate getPath for versions < go1.5\n. LGTM. @elithrar  ?\n. I'm in Africa for the next 3 weeks so won't be reviewing code. If it looks\ngood, just go ahead.\nOn Tue, Aug 23, 2016 at 22:30 Matt Silverlock notifications@github.com\nwrote:\n\nAssigned #184 https://github.com/gorilla/mux/pull/184 to @kisielk\nhttps://github.com/kisielk.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/184#event-764999429, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AADk-lBig2wGntLOmNIwMq4Kmdu_jkU-ks5qi0pUgaJpZM4Jlh1O\n.\n. Seems this is a result of 0b13a922203ebdbfd236c818efcd5ed46097d690 \nIt works fine with the commit just prior.\n\nPinging @neelance to see if he has any ideas why this is happening.\n. Thank you!\n. I don't really like the idea of this PR. It's maintaining a secondary copy of the methods information for each route, something that doesn't seem necessary at all. If it's desirable to retrieve the list of supported methods for a route during a walk, why not add an API to do that and use the existing method list? \nAlso I'm not sure about the utility of add a whole generic string \"information\" API, which currently has only one field that itself may be wholly redundant.. That's a question for @moraes \n. I can't really say whether it was a mistake or intentional, I'm not the original author of the project, @moraes is. AFAIK the license has been like that all along.. I appreciate some of the befits of Ginkgo even though it's not really my preferred style of testing. However I'd rather not add any external dependencies to the project, even if it's only for tests.. Your wrappers are being applied in the wrong order. Assuming you are serving preparedRouter, then ContextGet is the top-level handler and will be called first, after which it will call ContextSet and then finally the mux router. This is probably something better discussed on the mailing list.. Hi,\nDo you have any benchmarks to show that this is actually faster?\nI'm skeptical about the schemaMatcher and methodMatcher changes, the slices are very small so the actual cost of the O(n) search should be very small.\nAdding a map allocation to uniqueVars is going to increase the pressure on the garbage collector significantly since it's an often-used function.. Closing for now. Please resubmit with benchmarks if it is indeed more performant.. Did you find a solution?. LGTM as well. Thanks!. I think I agree with @scisci ... looking at it again I can't seem to make this logic make sense in my head, unless I am missing something.. \ud83d\udc4d . LGTM. @elithrar merge when ready :). For your existing regexp the fix is easy:\nr.HandleFunc(`/delay/{n:\\d+(?:\\.\\d+)?}`, DelayHandler).Methods(\"GET\"). I am looking into it. Dusty Wilson is managing the DNS (I don't remember why) but I have access to the GAE console. Might have to wait till tomorrow since I literally just got off a plane. \n\nOn Jan 29, 2017, at 18:29, Matt Silverlock notifications@github.com wrote:\nPing @moraes - are you able to take a look?\n(Note: happy to take over admin/move this to a shared Google Cloud project to manage/pay for it going forward)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. There were some DNS changes. It looks like it has been resolved.. @elithrar I would add you to the the permissions for the gorilla website, but I only have Editor level. Something @moraes would have to do.. I think that's outside the scope of mux itself. You need to find another handler that does that and wrap mux with it.. Hi jonathan,\n\nPRs would be great!. If there's actually a bug and you have a reproducible example please reopen. . Any PR should include a description of what the change does, and why it's necessary. If there is no description it makes it difficult to determine if we should merge the patch or not. If it's a feature addition, an example of a use case is really helpful.\nReverse routing is tested here, and this is applied to all tests which call testRoute:\nhttps://github.com/gorilla/mux/blob/master/mux_test.go#L1458\nIt would probably be necessary to extend it to also include queries.\n. This was implemented in #270 . You should benchmark it with your intended use case and see if it's fast enough for you.. In that case I look forward to your contributions with performance improvements.. Right on :). Thank you.. Thanks!. Please provide a small example to reproduce the error. \n\nOn Mar 3, 2017, at 16:14, Jeff Willette notifications@github.com wrote:\nI was writing some code and forgot to name a route, but I was calling it by its intended name. THis caused a panic that took me a while to track down in my code.\nI haven't looked around in the internals too much yet, but I am wondering if there is a way to give a clear error for this situation to avoid confusion and save some time?\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Is this still needed now that mux has Middleware support?. This seems like a problem with your go installation and not gorilla/mux. Can you give an example of where this will be used?. Ok. Seems reasonable to me. @elithrar what do you think?. > The Routes() functions could accept a mux.Router, but why? It doesn't actually depend on the router to do any work.\n\nIsn't the point of it to add routes to the router? It should probably take a router then. If you want to defer adding of the routes you could return a function that will add routes to a router. Then you could do:\npackage main\nrouter := mux.NewRouter()\nfor _, routeFn := range append(foo.Routes(), bar.Routes()...) {\n    routeFn(router)\n}\nThis would achieve the same thing without having to expand the API surface.. Looks like you're trying to modify the router after the server is running. mux doesn't support that, since it's not needed in the vast majority of cases, and the locking required would unnecessary slow down the router.. Implemented in #270 . I don't really like these kind of special-cased handler insertions. Does this mean we need an AfterHandler too? And then what if some routes need exceptions to those? etc.\nCouldn't the decorator problem be solved by just wrapping the call to r.HandleFunc instead of calling it directly? Then it can be solved without adding to the mux API.. mux doesn't support changing the routes while the server is running (it's a race condition) so you don't really need to worry about that ;). Looks good, but I'm not sure adding URLScheme is necessary. It's true that it seems to be symmetric with the rest of the API, but how useful is it really? I can't imagine it being used very often.\nAlso you could achieve the same thing by doing\nschemeURL := &url.URL{Scheme: r.URL().Scheme}\nin the case that you really need it... I really would like to avoid increasing the already massive API surface of this package. I don't see a problem with changing the Walk behaviour if it fixes a bug.... I agree with @elithrar . LGTM!. I think #26 implemented this but it's way out of date now. . Sure, if you want to refresh the PR to work with the current codebase we'll review it.. If you're still having the problem please reopen with code for reproducing the bug.. Thanks!. Fixed by #280 . Great. Thanks a lot!. I think the API is a bit too specific, what if someone wants to have some other criteria?\nYou could always create a list of route metadata first, sort it according to priority (or whatever other method you want), and then add the routes to mux.. Overall approach looks good to me, I left some comments about possible improvements. What do you think?. @elithrar can you give this a second look ?. LGTM after the requested change.. Thanks a lot!. @adamo57 if you have time, please do. It would be much appreciated.. Hm, I'm not sure how I feel about the interface. What would the alternative look like?. Ah I understand now. Yes I think just using func (http.Handler) http.Handler as a type for the middleware is just fine. No need to make everything into an interface that you need to implement. A much less \"object-oriented\" approach and more a functional transformation.. Yeah, I understand that, but having the MiddleWare method on the type is unnecessary.\n```\n// Define our struct\nvar tokenUsers :=  map[string]string{\n    \"00000000\": \"user0\",\n    \"aaaaaaaa\": \"userA\",\n    \"05f717e5\": \"randomUser\",\n    \"deadbeef\": \"user0\",\n}\n// Middleware function, which will be called for each request\nfunc AwmMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        token := r.Header.Get(\"X-Session-Token\")\n    if user, found := tokenUsers[token]; found {\n        // We found the token in our map\n        log.Printf(\"Authenticated user %s\\n\", user)\n        next.ServeHTTP(w, r)\n    } else {\n        http.Error(w, \"Forbidden\", 403)\n    }\n})\n\n}\n```\nThen you don't need to create additional type boilerplate. At this point the interface would be created solely for the purpose of calling one method on Mux, which seems like it's unnecessary.. That one is just something that stands out because it used to be a really bad habit of mine. I used to write stuff that had parentheses in nearly every sentence because that's just how my train of thought works. Then based on feedback I realized it doesn't necessarily make for the easiest reading for other people :). It should be r.Use(myMiddleware). Seems we forgot to adjust that one example in the docs.. Updated the docs in  85e6bff, @elithrar should we tag a new release for the doc update?. @silverweed @leofachini @stevenh @roobre can you check if the PR today fixed this for you?. Thanks :). Thanks \ud83d\udc4d . Is there a reason you'd want just the Regexp or just the templates? Is there value in it being two separate functions? . The symmetry with the GetPathXXX methods makes sense. Sorry I missed the last email update. Thanks for the patch!. Please reopen with a real example if you're still having the problem.. Agreed\n\nOn Oct 17, 2017, at 19:32, Matt Silverlock notifications@github.com wrote:\nI am OK with this, and this makes more sense than the other PR.\n1.5 has been around for a long while.\nOn Tue, Oct 17, 2017 at 10:37 PM Mike Busch notifications@github.com\nwrote:\n\nThis change drops support of go < 1.5. go1.4 has been officially\nunsupported https://golang.org/doc/devel/release.html#policy since\ngo1.6 was released 2016/02/17.\nThe PR was motivated by a bug I discovered, where req.RequestURI was\nreturning \"\", so my router was failing to route on the escaped path.\nVery open to thoughts and/feedback on how to proceed. Thanks!\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/306\nCommit Summary\n\nuse req.URL.EscapedPath() instead of getPath(req)\n\nFile Changes\n\nM mux.go https://github.com/gorilla/mux/pull/306/files#diff-0\n(25)\nM regexp.go https://github.com/gorilla/mux/pull/306/files#diff-1\n(6)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/306.patch\nhttps://github.com/gorilla/mux/pull/306.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/306, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcLbYkeXV5VmuwpF2TwqtYRUhSk8iks5stQ_8gaJpZM4P8yMy\n.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n. Can you check if the latest version fixes the problem for you?. Can you provide a log of the full request sent by Postman? I imagine it must print it somewhere. Here's a reproducer in Go, using the server code from the post above:\n\n```\npackage main\nimport (\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n)\nfunc main() {\n    urls := []string{\n        \"http://localhost:8080/files/path/to/file.txt\",\n        \"http://localhost:8080/files/path/to/./file.txt\",\n    }\n    for _, url := range urls {\n        req, err := http.NewRequest(\"POST\", url, nil)\n        if err != nil {\n            log.Fatal(err)\n        }\n        client := &http.Client{}\n        resp, err := client.Do(req)\n        if err != nil {\n            log.Fatal(err)\n        } else {\n            out, _ := ioutil.ReadAll(resp.Body)\n            log.Println(string(out))\n        }\n    }\n}\n```\nThe first one results in [POST] but the second one in [GET]. With some further testing and debugging I narrowed the problem down to here: https://github.com/gorilla/mux/blob/master/mux.go#L122\nWhen the client receives the redirect, it retries the request with a GET instead of a POST. I guess this must be what's happening with postman too.. It behaves correctly when using http.StatusPermanentRedirect instead of http.StatusMovedPermanently. So maybe the code should switch to that?. I'm inclined to leave it as it is. At least 301 is understood by all clients, and nothing bad will happen. If you have a client that's making POST requests to a URL that results in a redirect, and they turn into GETs then you could either:\na) Fix your request URL\nb) Configure your client to try the redirected URL with POSTs instead of switching to GETs (it seems curl already does this).\nIf we switch it to 308, the only advantage is that you don't need to do a) or b), but the potential consequence is that some clients won't understand the status code at all, and it could break some existing uses.. I don't think it's necessary to extend the API to do this. One way it could be achieved is with a top-level handler that matches the path prefix and does whatever you need with it there, otherwise passes the handling to the mux.. LGTM other than comment. Thanks! I don't mean to be too nitpicky, but the code base is already pretty hard to follow so any little bit helps.. Really makes me realize that the passing match by pointer and bool return value is a pretty ugly API :(. LGTM! Thanks. \ud83d\udc4d . Looks great. Thanks a lot!. > Addresses #308\nInteresting numerical coincidence :). I think a better name is needed too. Starting it with Test implies that the function is a test, to me.... Where do you set up the routes in faas-swarm, where it doesn't work?. I understand that, but where is the code that attaches that function to the router?. I'm not really clear on how that ends up calling the result of FunctionProxy, it's a lot of indirection to follow and I'm not familiar with your codebase. Maybe you can reduces this to a more minimal reproducer? . I wish there was some way to tell how many people are still compiling with old Go versions. It's possible, not sure how much actual demand there is to maintain a feature like that.\nCan't you get this by wrapping Mux and then inspecting the Header field of the ResponseWriter ?. Definitely. I actually tried to refactor this code at least 4 times over the past few years, using interfaces and different types for matchers, but it never really worked out. This seems to at least make it a bit clearer for now.. LGTM. Go ahead and merge it. I\u2019m without proper computer access for the next week so won\u2019t be able to reply to or act on most PRs. \n\nOn Jan 5, 2018, at 23:44, Matt Silverlock notifications@github.com wrote:\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/329\nCommit Summary\n[docs] Add graceful shutdown example\nFile Changes\nM README.md (64)\nPatch Links:\nhttps://github.com/gorilla/mux/pull/329.patch\nhttps://github.com/gorilla/mux/pull/329.diff\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Travis seems backlogged or stalled, but since this is only to the README I'm merging anyway... The only thing that needs to change is the documentation has to be updated to indicate that it returns a copy of the request with the variables changed. An example should also be added to show how to use it. The function shouldn't modify its argument, that's by design.. You should stop thinking that way, because that doesn't generally hold true in Go. For example nowhere in the net/http package is Request used, it's always *Request. I doubt you'd find code anywhere that passes it by value.\n\nA PR for the docs would be appreciated.. I'm well aware of the differences (I've been programming go since before 1.0). This is actually covered in the Go FAQ: https://golang.org/doc/faq#methods_on_values_or_pointers\n\nNext is consistency. If some of the methods of the type must have pointer receivers, the rest should too, so the method set is consistent regardless of how the type is used.\n\nThere are other reasons as well. For example if a type contains a mutex or other kind of lock, you should never pass it by value because you will be copying the lock and that can lead to very bad things happening.\n. Can you make the example a runnable example test? The function doc can be shorter, just \"... does not modify its arguments, but returns a shallow copy..\", it should be obvious that it can be assigned to something.. Make a function in one of the test files called ExampleSetURLVars  and put the whole example in there. That will show up in the documentation alongside the SetURLVars function. More details in the \"Examples\" section here: https://godoc.org/testing. Good catch, thanks!. The \"Examples\" section could link to eg: https://godoc.org/github.com/gorilla/mux#pkg-examples. Yeah the embedmd thing looks like it's worth a try.. Whoops, screwed up the file rename..  . Won't this break if using eg: HTTPS since schema is being reset?. Looking at it now, maybe this whole section of code should just use http.Redirect instead, which deals with these issues already.\nSeems the whole block could be replaced by just http.Redirect(w, r, p, http.StatusMovedPermanently). The query string is in the original request which is passed to http.Redirect. The function takes care of preserving that, you can verify this in the source: https://golang.org/src/net/http/server.go?s=58879:58944#L1959. @elithrar what are your thoughts on just simplifying the code after cleanPath down to http.Redirect ? . I would prefer to go the http.Redirect route if it makes sense. There's already a lot of special cases in the code and I'd prefer to not add more.. Cool thanks.. Good idea, thanks. . Makes sense for API consistency purposes. Can you add some tests?. Good catch, thank you.. The usage of this seems a bit confusing to me. The idea is that the router will use itself as middleware?. Since it doesn't depend on any unexported fields of the router, I don't think it needs to be a method of the router itself. It could be a new middleware function or type that takes the router as an argument. That way we don't need to grow the already large API of the Router type.. I think the difference is that @EmmanuelVlad is using GET instead of POST. Most likely curl doesn't preserve the body when following the redirect.. Thanks!. I\u2019m just reading this off my phone so I could be wrong, but it seems in your test you never actually instantiate a mux, you\u2019re just hanging the handler off the http recorder. \n\nOn May 12, 2018, at 10:04, Sean Walberg notifications@github.com wrote:\nI changed my tests to set the vars directly like in #342 and it passes:\npackage main\nimport (\n  \"fmt\"\n  \"github.com/gorilla/mux\"\n  \"net/http\"\n  \"net/http/httptest\"\n  \"testing\"\n)\nfunc TestMetricsHandler(t *testing.T) {\n  tt := []struct {\n      routeVariable string\n      shouldPass    bool\n  }{\n      {\"goroutines\", true},\n      {\"heap\", true},\n      {\"counters\", true},\n      {\"queries\", true},\n      {\"adhadaeqm3k\", false},\n  }\nfor _, tc := range tt {\n      path := \"whocares\"\n      req, err := http.NewRequest(\"GET\", path, nil)\n      if err != nil {\n          t.Fatal(err)\n      }\n      req = mux.SetURLVars(req, map[string]string{\n          \"type\": tc.routeVariable,\n      })\n      rr := httptest.NewRecorder()\n      / Appears we can call it directly if we want?\n          handler := http.HandlerFunc(MetricsHandler)\n          handler.ServeHTTP(rr, req)/\n      MetricsHandler(rr, req)\n  expected := fmt.Sprintf(\"Type: %v\", tc.routeVariable)\n\n  if rr.Body.String() != expected {\n      t.Errorf(\"handler should have failed on routeVariable %s: got %v want %v\",\n          tc.routeVariable, rr.Body.String(), expected)\n  }\n\n}\n}\nCan you elaborate on comments in #342? My understanding is \"yes you can use mux.SetURLVars but you should really do it the way I've shown\" which I prefer, but can't get to work.\nThanks!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. That's not really what the Subrouter mechanism was designed for. It's for grouping together routes that have a common matching condition. What you've done is create two subrouters with the same matching condition, just as a way to later apply the same middleware to them. But I guess that's how people are using the package now so maybe we should just support that. All this match error handling code is pretty convoluted, so I'm worried that by changing it we're going to introduce other unintended consequences. . @sothychan We are probably going to go with the fix in #422. Can you give that version a try and see if it fixes your issue? It would be great to get some feedback.. It's a bit of a scary change, but it makes sense in theory and I guess we can merge it if all the tests (plus additional ones) pass. . I am also not sure if it's safe to change to this at this point, there's a lot of risk of breaking existing code.. Hm, should we update this repo to say \"The Gorilla Authors\" and then use an AUTHORS file instead?. Yeah it's something that's long overdue, there wasn't anything pushing for it before but I guess it's time to get a bit more formalized :). One thing which I think would help reduce the size of the mux API by roughly half is if the Router / Route duality was eliminated. They both have roughly the same methods, with just a few extras on Router. We should evaluate what's strictly necessary to have only once at the Router scope and then just put everything else on Route. The Router could have top-level Route for the root path and then a tree below that.. Not sure if I'm on board with that idea. There's an infinite number of possible HTTP methods, so you can't cover them all that way. It also doesn't read well to me because it looks like you're trying to get something from the router.. According to git blame that's been there since the beginning. Since it's been the behaviour for 6 years now I don't think it's worth changing, we should just delete the inaccurate comment.. You shouldn't rely on the pointer address to identify a request. mux uses Request.WithContext internally, which creates a shallow copy of the request.. The order of operations doesn\u2019t really matter in this case, the middleware applies to the whole router. If you want middleware only on /test then create a sub router at that path and place the middleware on the sub router. \nOn Aug 9, 2018, at 20:17, Matej Kramny notifications@github.com wrote:\nDescribe your problem (and what you have tried so far)\nIn the simple middleware example given, the chain of routes doesn't make sense:\nr := mux.NewRouter()\nr.HandleFunc(\"/\", handler)\nr.Use(simpleMw)\nThis implies that if I visit /, the router will invoke handler. Any routes below the registration of simpleMw would invoke simpleMw and then subsequent routes.\nHowever what happens is that simpleMw is invoked first anyway and then handler is invoked.\nIs this correct behaviour?\nConsider the example below: - only the /test handler should be having simpleMw in it's \"routing stack\"\nr := mux.NewRouter()\nr.HandleFunc(\"/\", handler)\nr.Use(simpleMw)\nr.HandleFunc(\"/test\", handler)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. It would help if you provide a full log of the requests before they hit mux. You can wrap it in another handler which does the logging.. Help would be much appreciated. The test cases should be a good start.. Still valid . I believe that's behaving as expected. Mux checks the routes in the order that they are declared and the subrouter with an empty path would match before r1. Yes, I believe you're right. The middleware and subrouters really complicate things.... Thanks. If that's the API you prefer, you could easily write it yourself as a wrapper for mux. eg:\n\nfunc MyHandle(HandleWhatever w) {\n    s.HandleFunc(w.Route, w.Handler).Methods(w.Methods...)\n}\nNo need to change the mux API for this purpose.. That was a lot less work than I expected :) Thanks! . Doesn't this result in just eating any errors that come from earlier routes? What if the first route checked is the right path, but has a method mismatch, and the second route is the wrong path? The method mismatch logic won't be triggered in that case.. I am more concerned about the unknown regressions, I don't believe the test suite is fully comprehensive. \nWhat happens if the MatchErr is ErrNotFound in the first case, but then that gets wiped out to try other routes, will the NotFoundHandler ultimately be called?. I'm ok to merge this after the doc changes.. @jwilner This looks great to me. I think it's a great simplification of the implementation and hopefully will help squash a lot of the bugs people have been seeing with regards to middleware and subrouters.\nThanks for taking the time to dive into the code at this level, I've been way too busy with other things and not programming with this package at the moment so the internals have been kind of unloaded from my brain :) \n. Thanks!. What if you have a router whose only routes are subrouters, and all of them return ErrNotFound?. Yes I think adding this test is useful just to verify that this and any future changes won't break this.. mux does not support adding routes concurrently. You can protect it with a mutex yourself if that's something you need to do.. Hey @blakemscurr. \nSeems like a useful bot overall, but it should probably ignore test files. The function comments are usually not used for API documentation. Thanks. Feel free to run the bot on the other gorilla projects later!. Cool, thanks for this and the travis update.. I became a maintainer of mux because I used it on several commercial projects. I was subsequently hired as a contractor on another few projects that also used mux. It's been a while since I've really had to use it a lot, but it's definitely suitable for production.. Do these need to be exported?\n. I'm not sure if having this be an exported function is the best approach for extensibility in the future, but I am thinking on it some more.\n. Rename to KeepContext\nDocumentation:\n// If true, do not clear the the request context after handling the request\n. I meant the NotFound function, not mapListToString :)\nI'm debating if it's better to have a struct type as a handler, to which we can later add more knobs as to what kind of errors it reports.\n. Basically I would like to preserve the current behaviour if possible, but give people a means by which they can enable additional return codes that depend on the mux internal state.\n. Kind of. Basically by default it would be good if it worked exactly like it does now, in case people are relying on the existing behaviour.\nHowever we could provide a NotFoundHandler struct type that could have some boolean options to enable different features. Someone who wanted mux to be more clever about error handling could then install that as their not found handler.\nFor example\ntype NotFoundHandler struct {\n    // Return StatusMethodNotAllowed and set the Allow header for requests with invalid methods\n    AllowedMethods bool\n}\n. Good points. I think I'm okay with it.\nHowever the implementation is still a bit lacking, and I would like to keep any code additions un-exported. I'll comment with more specifics below.\n. Instead of printing the Allowed methods, this needs to set the Allow header of the response. From the spec:\n\"The response MUST include an Allow header containing a list of valid methods for the requested resource.\"\nWe need to return the list of allowed methods in the context and then read it back in the not found handler.\n. I can't see where this would be the case, shouldn't the body of  this be in the else clause when ok is not true?\n. I think we can remove the message from the body.\nHow about using a custom error type that has a []string with the list of allowed methods? Then there's no need for additional context variables.\nI was thinking there could just be a single context key, MuxMatchErr, and then store error values in there. The values could contain both the message and the status code. For the 405 there can be an additional field for the allowed headers.\n. KeepContext should still be false by default, that's how it works now.\n. Yeah I think that's good. For Headers, use the http.Header type since it provides some convenience functions like Get and Set.\n. Sounds reasonable, let's leave it.\n. received is now dead code? should be removed.\n. We should call this field Header to mach the convention in net/http\n. Seems we don't use this function any more.\n. received is not used for anything\n. Please use example.com as the domain.\n. period.\n. I think we could use a test case or two here with query regexp matches.\n. using Sprintf here is probably overkill... how about just pairs[i] + \"=\" + pairs[i+1]\n. This check is redundant. Just use append every time: http://play.golang.org/p/hjQzZ0IGXn\n. drop the } else { since the if returns anyway. Not only is it considered better style, but it also makes the change Go 1.0 compatible.\n. you can actually skip this check entirely. Just leave the for _, q := range v.queries loop below. It works with nil and 0-length slices. That will remove an indent level and make this code easier to grok.\n. Similarly you can skip this check here and just leave the range loop.\n. I think this should check the error and panic. regex will be nil in the error case and the developer will get a panic when the mux tries to match, but it will be hard to trace down the root cause.\nIf this panics with a message, something like \"invalid regular expression: %s\" it will be obvious they made a mistake when setting up the routes in the first place.\n. I guess you can just return the error, that will be more in line with the rest of the package's error handling (which badly needs an overhaul, ugh)\n. I don't like the idea of compiling a regexp during every match attempt, that's going to hurt performance a lot.\n. use SplitN here with a max of 2\n. I just did this quickly :)\n. Change the wording a bit. Remove \"Note:\" and instead of \"it uses context.Get()\" say:\n\"the matched route is stored in the request context which is cleared after the handler returns, unless the KeepContext option is set on the Router.. This is part of the public API so we can't change it now.\n. The phrasing of this is kind of a double negative. I'd suggest documenting it similarly to Router.SkipClean\n. Why set this to \"application/json\", or anything at all? It doesn't really contribute anything to the example.\n. Agreed, I don't think it's necessary at all. Since callingPathpanics right away, that can just be done as its own test. Not all the tests need to follow the exact same structure and go throughtestRoute`.\nThis way shouldPanic can also be removed.. Just rewrite this function:\ndefer func() {\n    if recover() == nil {\n        t.Errorf(\"(%v) Expected panic, however test completed sucessfully.\\n\", test.title)\n    }\n}()\nr.NewRoute().Path(\"/{type:(promo|special)}/{promoId}.json\")\nThe rest of the test changes can then be removed. There are already tests for capturing groups.. This is the wrong way around.. I'm not sure if this is correct. When Schemes is called it should set the schemes for the route, regardless of what the parent's schemes are. In this case the build scheme would always be the parent's, even if the route's schemes didn't include it.. Exactly. The routing will only make it to the child route if the parents also include its schemes, but the build scheme of the parent is not necessarily the one that the child will want to build with, so its schemes should take precedence if they are defined.. I don't think this needs to be exported. This probably doesn't need to be exported either. I wonder if it would be better to have a MatchError error field instead. Then there could be a ErrMethodMismatch value used there in the case of methodMatcher, and then it could be extended with other error types in the future.. The purpose of this is not to customize the response, but a way for the match to signal to the router the reason why it failed to match anything. The other option is to have a flag on RouteMatch specifically for the method not matching, but that feels less extensible to me.\nI agree that the router should ultimately have a way to customize the handler, but that's a separate bit of logic than this.. non-mismatching is a bit of a double negative :) how about just \"matching\" so it's less confusing?. I actually don't quite understand it, is it just to show which methods matched? Why not use a map[string]bool for this?. I would also call it something like matched_methods instead of just flags. The tests for this package are pretty confusing and convoluted, so anything that helps add some clarity is a big plus.. I think this would make it more clear:\nfunc methodHandler(method string) http.HandlerFunc {\n   return func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(method))\n   }\n}\nThat way when you're defining the test fixtures, the string returned by the handler is right there in the fixture as opposed to these global functions.. You could probably just the put the strings inline, yeah. I don't think it helps much to have them as constants here. Move next to the declaration of req1. move to just before the fmt.Printf, leave a space here to separate the r and route from the rest.. Move to just above the req2.Header.Set.... Similar changes to this function.. ??. IMO it's bad style to place so many sentence fragments in parentheses. It just adds unnecessary noise to the text and obfuscate the meaning. You can almost always restructure text to not use them. In this sentence you could say \"router or subrouter\" instead, or add another sentence here or later in the text that says \"when a match is found the request is passed to the middleware in the current router and its parents\". . The (typically) is arguably one valid use of parentheses, but the examples could be another sentence to not interrupt the flow.. Another use of parens that could be avoided.. Maybe instead of changing them we could add a XXXXMiddleware function for each one?. Add // endpoints_test.go comment here, or remove the one in the above code example.. That's actually not what this function does. It reports whether the SkipClean option is enabled for this route.. Mux doesn't really support multiple handlers, whether explicit or as subrouters, at the same path. I actually think instead of overwriting the old one it should probably panic, since it's basically a configuration error that can lead to confusion and unexpected results.. That's up for debate, but IMO you should put all paths rooted at a subrouter on the subrouter itself to avoid accidental duplication.. ",
    "stale[bot]": "This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. This issue has been automatically marked as stale because it hasn't seen a recent update. It'll be automatically closed in a few days.\n. ",
    "manveru": "OK, after reading https://tools.ietf.org/html/rfc3986#section-2.2 again, I guess it can be seen both ways.\n. ",
    "surma": "First of all: As I said, I think the behaviour of mux clearing the context is wrong. It is not obvious or expected that mux is using context \u2013 let alone modifying/clearing it. I believe it's the users responsibility to use  context.ClearHandler. But as I said, a lot of programs probably rely on the current behaviour.\nI don't see how your proposal fully solves the problem at hand. Even if mux (or I) would be using my own ContextStore, cascades of mux.Router could still behave badly e.g: a deeply nested mux.Router clears the context, and a top-level router want's to access mux.Vars afterwards.\nAnyhow, I think I haven't fully grasped your idea: So your solution for my problem would be, that I set up my own ContextStore of which I can be sure, that I won't be cleared by anyone but me, yes? Do I have to pass around my ContextStore to access its contents? How do you specify in which ContextStore a value will be saved?\n. @moraes I just skimmed through pat and afaic you are talking about storing variables in request.URL.Query(), right?\nThis would not be an option for me as I cannot marshal (all of) my variables into strings. At least not in a practical way.\n. After taking a short break and looking at this again, I realize that @kisielk actually proposed a much more elegant solution indirectly ;) Rather than patching around in gorilla/mux I'll just use a vanilla fork of gorilla/context for the time beeing :)\n. ",
    "moraes": "One note not related to the issue, which I don't completely understand yet: context is not leaky -- it leaks if used incorrectly.\nAnd another one: I consider the ServeHTTP method in the Router a code that is perfectly replaceable. pat does replace it and it doen't even use context.\nAlso, context as it is now is capable of storing variables for different router instances -- ServeHTTP use the same variable which means that vars will be overridden, but it could be different.\nBut I'll be back to this issue. :)\n. I wanted -- and gave up - a global container for variables stored in http.Request; let's call it a \"registry\", which is how context would be called if it was named today. That's the only way it would not require cleanup and would never \"leak\".\nAlexander: what would happen in your case if variables were stored in the URL query, like in pat?\n. That being said, I don't think context needs any changes. How mux uses it, probably.\n. Yes, the route should be aware of the allowed methods.\nAs I see, this must be implemented as a special subrouter that carries the general rules. The method rules are nested in it. When the general rules match, the subrouter tries the methods and if none matches it is responsible for setting the 405 status and header.\nThe problem is not how to do it but how to make the API look good in the end.\n. Very cool.\nWith a header (and simplified to a map): https://gist.github.com/4598513\n. I think something like this would be a good addition! :)\nI can only think about one reason to hide the map -- add multiple HTTP methods at once:\nr.Path(\"/foo\").Handler(new(MethodHandler).Add(myHandler, \"GET\", \"POST\"))\nOtherwise usage is like this:\nr.Path(\"/foo\").Handler(MethodHandler{\"GET\": myHandler})\nWhich one?\n. A handlers package will be useful independently of mux -- used in combination or separated. But mux should handle methods with proper 405 by itself too.\n. With the current design, I can only think about using a special subrouter as mentioned in https://github.com/gorilla/mux/issues/6#issuecomment-12560325.\nWhen the subrouter is tested:\n- It tests the base rules, and return false if they don't match, otherwise:\n- It sets the handler to the one corresponding to the request method, or:\n- It sets a handler for 405.\n. Funny, I wonder how that was not a compiler error.\n. This is interesting. The reason why subexpressions are avoided is that it is impossible to build the URL for a regexp like that (unless it is ok that we only allow passing the arguments from the outer capturing groups).\n. We could also allow pure-regexp patterns in some way. We can even reverse them with gorilla/reverse -- with some limitations, like nested groups are ignored to build URLs.\n. Well it doesn't have a parameter for that to avoid bloating the common case. It is easy enough to create a helper function to build the URL and set scheme to https. What else could we do?\n. It already has a scheme matcher: Schemes().\n. Idea: special parameters passed as variables: \"_scheme\", \"_fragment\" etc. I used this before and it worked well.\n. I think it's time for a bigger refactoring of mux.\nReturning info to set an \"Allow\" header, for example, is an old problem, and easy to solve in a different, simpler design.\n. Using a custom matcher in this case looks cleaner:\n```\nfunc matchJsonHeader(r http.Request, m mux.RouteMatch) bool {\n    ct := r.Header.Get(\"Content-Type\")\n    if ct == \"application/json\" || ct == \"text/x-json\" {\n        return true\n    }\n    return false\n}\n// ...\nr.MatcherFunc(matchJsonHeader).HandlerFunc(MyHandler)\n```\nNo?\nIn any case, let's keep this in mind.\n. - I thought about coining a new name; gorilla/muxy maybe, but I was afraid of it having a bad connotation instead of a cute/snarky one (although the word is labeled as \"dated\" and \"dialect\", it sounds funny to me).\n- The thing I'm playing with doesn't use gorilla/context to store variables. It's a muxy trick, though (wink wink nudge nudge :stuck_out_tongue_winking_eye:), and we should keep an eye on net/context.\n- Dropping regexp support is a requirement for routes that doesn't depend on registered order. Registering a duplicated/ambiguous pattern should be an error and we can't detect this with regexps. The loss comes with some benefits: simplicity, predictability and speed. And there are always workarounds.\n- Below is an API draft. These are not real interfaces in the Go sense; it is just to show how methods could look like, and how slim and simpler it could be. Everything is subject to change; I'm particularly inclined to try to find better names for Sub()/Subrouter:\nEdit: I moved the API draft to a gist to update it as proposals arrive. Here it is:\nhttps://gist.github.com/moraes/fba14ffd6c3e091b2c68\n- Middleware support was not considered (yet); it may be included in the subrouter interface, I guess.\n. Declaration syntax draft. Nothing is set in stone, etc.\n``` go\n// creates a new router\nr := New()\n// -------------------------------------------\n// basic usage: host, path and method matching\n// -------------------------------------------\n// matches a static path\nr.Handle(\"/foo/bar\", myHandler)\n// matches a path with a variable\nr.Handle(\"/foo/{bar}\", myHandler)\n// matches a path prefix\nr.Handle(\"/foo/{*}\", myHandler)\n// matches a path with a variable and the given HTTP verb.\nr.Handle(\"/foo/{bar}\", myHandler).Methods(\"GET\")\n// matches a host and path\nr.Handle(\"www.mydomain.com/foo/bar\", myHandler)\n// ------------------------------\n// extended usage: path subrouter\n// ------------------------------\ns := r.Sub(\"/users\")\ns.Handle(\"/new\", myHandler)      // matches \"/users/new\"\ns2 := s.Sub(\"/{id}\")\ns2.Handle(\"/\", myHandler)        // matches \"/users/{id}/\"\ns2.Handle(\"/tickets\", myHandler) // matches \"/users/{id}/tickets\"\n// ------------------------------\n// extended usage: host subrouter\n// ------------------------------\ns := r.Sub(\"{subdomain}.mydomain.com\")\ns.Handle(\"/foo/{bar}\", myHandler) // matches \"{subdomain}.mydomain.com/foo/{bar}\"\n```\n. Setting/retrieving variables can be left as \"undefined\" or \"subject to changes\" until a context resolution comes, and we take our time to discuss features, declaration syntax and the broader general API.\nThat said, I'll talk a bit about...\nDeclaration syntax\nThe general idea is that we don't need to have Schemes(), Host(), Path() and PathPrefix() methods: we can support them all in the declared pattern to be matched. As mentioned before:\ngo\nr := mux.New()\nr.Handle(\"/foo\", myHandler)     // matches \"/foo\" in any scheme and host\nr.Handle(\"/bar/{*}\", myHandler) // matches the path prefix \"/bar/\" in any scheme and host\ns1 := r.Sub(\"//{subdomain}.mydomain.com\")\ns1.Handle(\"/{baz}\", myHandler)   // matches \"//{subdomain}.mydomain.com/{baz}\" in any scheme\ns2 := r.Sub(\"https://{subdomain}.mydomain.com\")\ns2.Handle(\"/{baz}\", myHandler)   // matches \"https://{subdomain}.mydomain.com/{baz}\"\nNotes:\n- Variables are declared like in gorilla/mux, minus the regexp support. That is, a variable name is enclosed by curled braces, as in {name};\n- A special variable {*} is used exclusively in the end of a path to declare path prefixes;\n- Extra constraint: each host or path segment can have only one variable (so you cant have a /user-{id} path; it must be /{user-id});\n- If a scheme is not defined but a host is, the pattern must start with two slashes (like in the first subrouter above). In case scheme matching was not supported, this could be simplified a bit (we'd consider a host definition anything before the first slash), but I don't think it should be dropped;\n- The simpler colon prefix syntax used by sinatra (and later pat and others, e.g. /:name) was considered, but several concerns came to mind: 1. It doesn't look good in host definitions (e.g. www.:domain.com; 2. It looks even worse with an eventual support for mixed static and variable parts in a segment (e.g. /user-:id); 3. In case point 2 ever happens, or no matter what happens, colon is a valid character in hosts and paths (RFC 3986) and curly braces are not valid characters in any URI part (this was taken into account to choose curly braces for gorilla/mux; the other considered options were [] or <>);\nThat's all for now. Let me know what you hate most, other ideas etc. :v:\n. @margaery: I took a quick look at RFC 6570, and that's a huge spec. We are doing simple string expansion with {name}, which looks like their syntax; but this proposal has a lot more strict rules for their use (\"alone in path or host segments\"), so the similarity ends where it began. I like that it reminds RFC 6570, though; it suggests that braces are a good choice: they stand out and make variables easy to scan at a glance.\n@garyburd:\n1. Re: r.RequestURI: good point, or r.URL.RawPath but maybe it is too soon for this one;\n2. Re: More specific patterns have priority and left to right specificity: that's the idea;\n3. Re: redirect path-with-no-trailing-slash to path-with-trailing-slash and vice-versa: it's on the checklist;\n4. Re: r.Route(\"/foo/{bar}\").Get(showFoo).Post(updateFoo) (or .Handler(aHandler, \"GET\",  \"POST\")): this looks much better than the initial proposal, and makes more sense too.\n. @elithrar: A default OPTIONS handler would be trivial to define, as well as a 405 handler that sets a proper Allow header (somewhat related). This remained unsolvable in current gorilla/mux because the same URL pattern can lead to different Routes, and it is not easy to identify \"same URL pattern\" because of regexps and separated matchers for host, scheme etc. In the new design each URL pattern always leads to the same Route, which knows about the methods it supports.\n@garyburd, @elithrar: RE middleware in subrouters: I think we are again on the right direction here, because subrouters are just dumb factories that create routes with a given pattern prefix (they are not \"nested\"; they just carry a prefix). A subrouter could also carry a middleware list to pass to routes (or to sub-subrouters, which could have extra middleware). The exact API is something to discuss (.Sub(pattern string, midlewares ...InterfaceOrWhatever) ?).\nRe: functional options: I need to think about it. The example was not very obvious to me, but I'm tired or something is missing.\nI moved the API draft to a gist to update it as proposals arrive. Here it is:\nhttps://gist.github.com/moraes/fba14ffd6c3e091b2c68\n. New repo or new branch? I want to push my prototype in the following days.\n. New repo is ok. :) The spice must flow. \n. This discussion has now its own place: gorilla/muxy. It may be a temporary repo or not. We will see.\n- There isn't a lot more than the API skeleton there. Sorry for the vaporware sound (heh), but I'll need some time to put together what I've done so far;\n- It gives a better idea of how subrouting is implemented: Subrouter is a factory for routes with a prefix. The implementation doesn't need much more than what is there already (except that it may include middleware);\n- Let's create separated issues for each subject that comes up (middleware, config, declaration syntax, naming, testing, performance etc).\nThanks for the great feedback so far. :+1: \n. ",
    "felixge": "Not that it makes things easier, but the http spec also requires returning an Allow header in this case:\n\nThe response MUST include an Allow header containing a list of valid methods for the requested resource.\n-- http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n. :+1: to the second syntax.\n. \n",
    "peterretief": "I am having the same problem redirecting a blob upload handler\n405 Method Not Allowed\nThe method POST is not allowed for this resource. \nroute:\n   RedirectRoute('/upload/', handlers.UploadHandler, name='upload-handler', strict_slash=True),\nfetch form:\n\nclass FetchHandler(BaseHandler):\n          def get(self):\n                upload_url = blobstore.create_upload_url('/upload')\n                params = {'upload_url': upload_url,}\n                return self.render_template('index.html', **params)\n\nerror before the redirect? do I have to rewrite the routes? \n\nclass UploadHandler(blobstore_handlers.BlobstoreUploadHandler ):\n  def post(self):\n    pass\n\n. @kisielk ja sorry about that - I saw you guys are using Go, which is cool, just not the right question ;)\n. ",
    "sandeepraju": "is there any progress?\n. ",
    "martensson": "I will join the thread since I was looking for a solution to the 405 problem and everything was leading to this issue. \n. ",
    "bkeroackdsc": "+1\n. @elithrar For the love of all that is holy, please just expose a SetVars function. The implementation behind it will be opaque so it preserves separation of concerns, and it will allow us to test our handlers in isolation without having to spin up an entire HTTP server just to test a single function!. Thanks @elithrar !. ",
    "binarylogic": "+1, would like to see this supported as well.\n. ",
    "elithrar": "@kisielk \u2014 did we want to recommend your https://godoc.org/github.com/gorilla/handlers#MethodHandler as the canonical solution for this one?\nThe other alternative is to provide an AutomaticOptions middleware like Goji provides, and populate the request context based on the contents of Methods? I haven't looked into this too deeply but may represent a simple approach.\n. I'm going to close this as wontfix: if you do need separate a NotFoundHandler you can use nested routers (via mux.NewRouter()). Happy to open it again if there's a desire to.\n. You're getting undefined errors because your program doesn't know what mux.HandleFunc is. Note that HandleFunc is a function of the Router method\u2014so mux.HandleFunc doesn't refer to anything.\nIf you take a look at the first example on http://www.gorillatoolkit.org/pkg/mux you'll find the following:\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/\", HomeHandler)\n    r.HandleFunc(\"/products\", ProductsHandler)\n    r.HandleFunc(\"/articles\", ArticlesHandler)\n    http.Handle(\"/\", r)\n}\nYou need to create Router with mux.NewRouter and pass the router to http.Handle so it can offload your routes to the mux router.\nRe-write your main function so it looks like this:\n```\nfunc main() {\nr := mux.NewRouter()\n\nr.HandleFunc(\"/\", func(w http.ResponseWriter, r http.Request) { fmt.Fprint(w, \"Hello\")})\n\nhttp.Handle(\"/\", r)\nhttp.ListenAndServe(\":10000\", nil)\n\n}\n```\nThat should solve the problem.\n. mux doesn\u2019t \u201cinterfere\u201d with WebSockets: it will route the initial\nhandshake request to the handler you define, just like the standard library.\nTaking the gorilla/websocket \u201cchat\u201d example & adapting for mux:\nhttps://github.com/gorilla/websocket/blob/master/examples/chat/main.go\nAll I do is create a Router and replace http.HandleFunc with mux.Router\u2019s\nHandleFunc methods.\n```\nfunc main() {\nflag.Parse()\nhub := newHub()\ngo hub.run()\nr := mux.NewRouter() // Create a mux instance\nr.HandleFunc(\"/\", serveHome)\nr.HandleFunc(\"/ws\", func(w http.ResponseWriter, r http.Request) {\nserveWs(hub, w, r)\n})\nerr := http.ListenAndServe(addr, r)\nif err != nil {\nlog.Fatal(\"ListenAndServe: \", err)\n}\n}\n```\nOn Wed, Jul 25, 2018 at 12:41 AM Bipin notifications@github.com wrote:\n\nCan anyone please share a working example of WebSocket with gorilla mux?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/29#issuecomment-407664130, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcH_vnzez145DqfeZOeQVfNZDdihAks5uKCEqgaJpZM4AyeGk\n.\n. (Excuse the formatting, I typed this on my phone)\nOn Wed, Jul 25, 2018 at 6:47 AM Matt S matt@eatsleeprepeat.net wrote:\nmux doesn\u2019t \u201cinterfere\u201d with WebSockets: it will route the initial\nhandshake request to the handler you define, just like the standard library.\nTaking the gorilla/websocket \u201cchat\u201d example & adapting for mux:\nhttps://github.com/gorilla/websocket/blob/master/examples/chat/main.go\nAll I do is create a Router and replace http.HandleFunc with mux.Router\u2019s\nHandleFunc methods.\n```\nfunc main() {\nflag.Parse()\nhub := newHub()\ngo hub.run()\nr := mux.NewRouter() // Create a mux instance\nr.HandleFunc(\"/\", serveHome)\nr.HandleFunc(\"/ws\", func(w http.ResponseWriter, r http.Request) {\nserveWs(hub, w, r)\n})\nerr := http.ListenAndServe(addr, r)\nif err != nil {\nlog.Fatal(\"ListenAndServe: \", err)\n}\n}\n```\nOn Wed, Jul 25, 2018 at 12:41 AM Bipin notifications@github.com wrote:\n\nCan anyone please share a working example of WebSocket with gorilla mux?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/29#issuecomment-407664130, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcH_vnzez145DqfeZOeQVfNZDdihAks5uKCEqgaJpZM4AyeGk\n.\n\n\n. Does the trailing slash need to be in the regular expression?\n\nIf it absolutely must, use an optional non-capturing group to indicate it\nas optional only.\nOn Tue, Aug 8, 2017 at 5:34 AM Brendan Abolivier notifications@github.com\nwrote:\n\nFWIW, you can do this using patterns:\nm.Handle(\"/{route:route\\/?}\", handler)\nwill handle /route as well as /route/\nIs there a way to do this when the last part in your path is a variable,\nfor example, if I want the same route to match for /{var} and /{var}/? Or\ndoes it necessary lead to code duplication?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/30#issuecomment-320942296, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcP7AxZUjp_Bgpuyh_Lb9aj7muiNHks5sWFXAgaJpZM4A1FC_\n.\n. e.g.\n\n\"/{route:route(?:\\\\/)?}\"\nsh\n\u279c  ~ curl http://localhost:8080/route\nHello\n\u279c  ~ curl http://localhost:8080/route/\nHello\nIf that doesn't make sense, provide an example of what you think the duplicate is.. What would that parameter look like?\nEach new parameter we add is more API surface for users to learn and understand.\nThis can be achieved via existing pattern support here: https://github.com/gorilla/mux/issues/30#issuecomment-321045004. See https://github.com/gorilla/mux/issues/215. I'd be more than happy to contribute here. Are their specific examples/use cases you want to cover, or just an even spread of functionality?\nI'm assuming a good mix of vanilla routes, method filtering, subrouters and pattern matching across 3-4 handlers would make for a solid \"catch all\" demo. \n. See https://github.com/gorilla/mux/pull/118 \u2014 added a runnable example to fill out the API-centric docs.\n. PathPrefix and StrictSlash received a few documentation improvements in https://github.com/gorilla/mux/commit/033224c12ed48938d1815f4851103f86abcf6201 - closing. Re-open if there are any concerns about related docs.\n. Are you forcing (via re-direct/HSTS) users to hit these routes via HTTPS? .Scheme() won't redirect for you (and if you're already doing these things, sorry - wanted to be sure)\n. @evantbyrne @Zikes What do you think is missing at the moment? It's documented as part of the Router type:\n``` go\ntype Router struct {\n    // Configurable Handler to be used when no route matches.\n    NotFoundHandler http.Handler\n// If true, do not clear the request context after handling the request\nKeepContext bool\n// contains filtered or unexported fields\n\n}\n```\nIf you think it should be included in the main body of the documentation, submit a PR (following the format for code samples) ;)\n. @whatupdave @vtolstov \nThis will need to be rebased against master. I'd strongly prefer that this only apply to a *Route and not a *Router so that you can selectively \"not clean\" specific routes rather than an entire application.\n. @jingweno Alright, I'm convinced!\nChecklist:\n- Rebase against master\n- Update comments to indicate that SkipClean should only be used when needed, and that failing to clean routes can have unintended consequences\n- Tests! \n. Already added: https://godoc.org/github.com/gorilla/mux#Router.SkipClean. The \"issue\" you're running into is that .Methods(\"GET\") only accepts a GET\nrequest. Using curl -I sends a HEAD request, which does not match and\ntherefore 404's.\nYou can resolve this by using .Methods(\"GET\", \"HEAD\").\nOn Saturday, 14 June 2014, Matthias Plappert notifications@github.com\nwrote:\n\nMore updates: If I provide the -X GET flag in curl, everything works as\nexpected even with the Methods(\"GET\") call. Is this expected behavior?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/59#issuecomment-46088243.\n. gorilla/mux does not implement a graceful shutdown, but you can leverage other packages that are compatible with http.Handler. The graceful package included with the Goji framework is easy to bolt on:\n\n``` go\npackage main\nimport ( \n    \"net/http\"\n    \"github.com/gorilla/mux\"\n    \"github.com/zenazn/goji/graceful\"\n)\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/\", SomeHandler)\ngraceful.ListenAndServe(\":8000\", r)\n\n}\nfunc SomeHandler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello\\n\"))\n}\n```\n. You can't use any Goji-specific middleware\u2014that is, anything with the\nsignature of func(web.C, http.Handler) http.Handler - because the request\ncontext (web.C; that allows you to pass data between middleware) is tied to\nthe Goji router by necessity.\nYou can use any generic middleware that has the signature\nfunc(http.Handler) http.Handler - some of Goji's middleware does match\nthis. An example is the Basic Auth middleware I wrote at\nhttps://github.com/goji/httpauth - this will work with gorilla/mux.\nOn Tuesday, July 1, 2014, Adrien Delorme notifications@github.com wrote:\n\nHem another question, I like more gorilla.mux, but goji seems nice for a\nweb app !\nSo, would it be possible to use Goji's middlewares and everything but\nstill be using gorilla.mux ?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/61#issuecomment-47624961.\n. The best way to do this is to write middleware that walks routes & adds other useful debug info. The challenge is that \u201cuseful\u201d is defined differently from person to person. \n\nOpen to a documentation PR with an example of said middleware, but not including by default. . See https://github.com/gorilla/mux/issues/215. Just to clarify, when you say \"/admin/ works, but /admin does not\" do you mean /admin does not work at all and causes a 404?\n. The connections will stay up.\nOn Tue, Jul 5, 2016 at 12:45 AM mogthesprog notifications@github.com\nwrote:\n\nHey guys. I know this is an old issue, but i had a question about the\nmethod outlined above.\nIf i've got an open websocket connection being routed by the router when i\ncall rs.Swap(), will those connections stay up until they're closed by\neither client/server, or will the router tare down those connections during\nthe swap?\nA little more detail, i'm using gorilla/mux and gorilla/websocket to\nreverse proxy multiple users and wanted to use this method to update the\nrouter on the fly. But i'm wondering whether the swapping process will\ninterfere with already established connections.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/82#issuecomment-230408883, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AABIcA-IS8Af-t1f0fyDd5V1vDk8wi0Zks5qSguhgaJpZM4DVyBK\n.\n. See https://groups.google.com/d/msg/gorilla-web/WR3yOKeas5o/Y7bUgR58JtQJ\n\nThe issue was that the sub-router was being passed to the DefaultServeMux via http.Handle(\"/\", s) instead of the mux.Router instance.\n. Related: https://github.com/gorilla/mux/issues/142\n. One (quick and dirty) option would be to provide a .NoClean() method on Route to skip the path cleaning logic and leave that up to the package user.\nThe risk there is that it's a sharp edge that\u2014if you don't carefully write your own path-cleaning logic\u2014you could break your application in other ways.\n. This should be fixed in #154.\n. I'm going to close this one out as I don't think it's a useful addition to the public API, but I'm happy to be convinced otherwise if others have a need for it.\n. @djgilcrease \nIf you can address my comment and add tests I'll re-consider. Really big on having tests for this since mux sees a lot of PRs.\n. Merged. Thanks!\nOn Sat, Mar 5, 2016 at 3:28 AM Dj Gilcrease notifications@github.com\nwrote:\n\nAll updated based on latest feedback\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/pull/104#issuecomment-192624668.\n. I'd prefer to keep it private\u2014since writing your own test helper should be a fairly simple case of calling context.Set. If you had to write a ton of boiler-plate then the argument for making it public would definitely be stronger.\n. The only way I can generate a \"EOF\" error is if I send a nil body in the GET or POST (aka the expected result as you don't handle that case).\n\nHere's a (slightly) simplified version of your program:\n``` go\npackage main\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc main() {\n    mainRoute := mux.NewRouter()\n    // Simplified\n    apiRoute := mainRoute.PathPrefix(\"/api\").Subrouter()\n    apiCatalogRoute := apiRoute.PathPrefix(\"/catalog\").Subrouter()\n    apiCatalogRoute.HandleFunc(\"/\", getCatalog)\nhttp.ListenAndServe(\":8000\", mainRoute)\n\n}\nfunc getCatalog(w http.ResponseWriter, r *http.Request) {\n    // Decode data\n    var Data struct {\n        // Simplified\n        Limit int\n        Page  int\n    }\nerr := json.NewDecoder(r.Body).Decode(&Data)\nlog.Println(err)\nif nil != err {\n    // Simplified\n    log.Println(err)\n    return\n}\n\n// Simplified\nlog.Println(Data)\nfmt.Fprintf(w, \"%v\\n\", Data)\n\n}\n```\nHitting with a simple {\"limit\": 1, \"page\": 2} JSON file generates the expected result:\nsh\n~/Desktop curl -X GET -H \"Content-Type: application/json\" --data @body.json http://localhost:8000/api/catalog/\n{1 2}\nHitting it with an empty request body generates the expected EOF result:\nsh\n~/Desktop curl -X GET -H \"Content-Type: application/json\" http://localhost:8000/api/catalog/\n<from the server log>\n2015/08/03 06:15:46 EOF\nHow are you sending your handler data? Does your custom handler type's ServeHTTP method touch the request at all? Middleware?\n. Thanks for catching that!\n. @themihai If you can submit a PR documenting this it'd be hugely appreciated. I don't think we can (safely) change this behaviour given applications depending on it in the wild.\n. @bluehallu I get that: but changing it would impact other applications out there. I'm not defending code I wrote (I didn't write it), I'm just making sure we don't make breaking changes where we can avoid that.\n. I'm open to that, if you have a proposal?\nOn Mon, Jun 20, 2016 at 3:42 AM bluehallu notifications@github.com wrote:\n\nWhat about an optional flag to change this behaviour?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/124#issuecomment-227108800, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AABIcBmNGavIE74avrI54Cwp3QjqWWKtks5qNm6IgaJpZM4F5W0f\n.\n. @themihai That would be great.\n. Closing due to inactivity.\n. Thanks for these\u2014appreciated. \n. You can use Router.Walk for this with a Router.WalkFunc to walk through the URLs (and then build a map/slice of structs with the results).\n. Refer to #104 for an upcoming approach for addressing this. \n. - I'm definitely for a slimmer API, even if it means (spitballing here!) a new package under the gorilla organization to allow mux to stay \"stable\" for existing users.\n- Could add a note to the current mux (v1) README and a bunch of \"this is how you would achieve X in mux v1 in the new mux v1\" examples elsewhere to help push users to the new package.\n- Coin a new name - gorilla/multiplex or even just gorilla/router (naming is hard)\n\nOther thoughts:\n- Merging Path, Handler and HandlerFunc is A++ in my books.\n- Dropping the regex support might hurt a few users (there at least seems to be a history around it here in the GitHub issues) but is probably the right decision in terms of complexity. Without knowing what the new API looks like, you could facilitate custom matching (be it regex-based or otherwise) with a Pattern interface similar to Goji's.\n- I'm okay with the query and header matching going. Those can be replicated in middleware and we can solve that with examples: I'd hazard a guess that they aren't often used and the semantics of matching on headers/queries aren't that great either.\nAlso worth reading (in case you haven't yet) is the plan to move net/context into the std. lib and make Context part of the http.Request struct: https://groups.google.com/d/msg/golang-dev/cQs1z9LrJDU/6_9FMmGNCQAJ (may factor into design decisions)\nKeen to see where this is going.\n. Gary's requests are all great - automatic slashes are very useful.\nOne additional thing on my list: support for automatic OPTIONS responses,\nwhether built-in or via providing a hook to construct the response. Being\nable to OPTIONS /some-path and get the supported methods makes CORS much\neasier to reason with.\n. - Agreed RE: middleware. I touched on this in the mailing list. A Use(...http.Handler) method or Middleware method that you can use to chain http.Handlers to all the routes within a subrouter is definitely useful for auth, verbose logging, CSRF, etc. Middleware applied to a top-level router should also apply to all subrouters below it by default. \n- I love functional options, but having ErrorHandler(http.Handler) as a method on *Router is probably easier for most to understand. ErrorHandler should accept a http.Handler so you pass it anything you want - either a simple http.HandlerFunc or something more complex.\n. New repo on a non-master branch (and push a one-liner README to the\nmaster)? Will prevent people from pulling it 'accidentally'.\nOn Mon, Oct 26, 2015 at 9:28 AM Gary Burd notifications@github.com wrote:\n\nI suggested a new repo because I assumed that the new mux will be\npublished in a new repo. Where do you plan publish the new mux?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/130#issuecomment-150998473.\n. The new (in progress) https://github.com/gorilla/muxy library should be\nable to handle this.\n\nOn Thu, Jan 7, 2016 at 12:42 PM Nathan Sullivan notifications@github.com\nwrote:\n\n+1 to the idea of returning HTTP 405's in the appropriate places (eg. if a\nrequest is made to a URI that has a .Methods() filter on it that doesn't\nallow it)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/130#issuecomment-169799054.\n. Closing due to inactivity. Please re-open if need be!\n. Note that using the EscapedPath() method would require us to drop support for all versions of Go prior to 1.5. I don't think we're ready to do that just yet.\n\nThe alternative would be to implement our own function that takes a *url.URL and performs the same logic, with the maintenance overhead that goes along with such an approach.\n. No - I'm open to a PR, but as this has been quiet I'd intepreted the feature wasn't required. I'm not entirely convinced it's a \"bug\".\nThe fix is: either break compat for all users pre Go-1.5 (not an option) or add in logic to handle that ourselves. \n. @chrisdostert Alright\u2014that's all I needed. Are you able to submit a PR? Happy to work with you on it/review, but I don't have time to fix this any time in the near future.\nAny fix must be backwards compat.\n. Open to any pull requests to fix this.\nOn Tue, Jun 7, 2016 at 2:29 AM hsinhoyeh notifications@github.com wrote:\n\nhey guys, do we have any update here? I also hit into this.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/132#issuecomment-224227880, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AABIcH-wgT0MiEiRwwSIVp9y4qkr5EJeks5qJTnfgaJpZM4GdG7A\n.\n. Done. \n. Thanks for this @mttrs!\n. LGTM. vet already passes so should not cause existing code to fail.\n\nI should note that the race detector flag is not foolproof though as tests are usually self-contained, and therefore checking for races in tests may not actually uncover any races.\nAlso - the gofmt change - I assume any output from the diff will cause the test to fail?\n. Yep - I am open to better Travis configs. The ones across the Gorilla\nproject are pretty simple (and old!) so updating these to be more\ncomprehensive is OK. I don't think vet (unlike lint) will require any\nbreaking changes to existing code either.\nOn Mon, Nov 9, 2015 at 10:00 AM Dmitri Shuralyov notifications@github.com\nwrote:\n\nAnother benefit in doing this is to advertise better CI practices to more\npeople. This is a very popular Go package, so I imagine many people will be\nlooking at how it does things. It's better to set a better example for\nothers to follow.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/pull/134#issuecomment-154902023.\n. @shurcooL - Nope, have just been busy planning a move! Thanks again for submitting this. \n. Are you accidentally importing a vendored copy of mux in the other package? Importing a handler from another package shouldn't change the behaviour.\n\nSee here for a small demo of the (working, correct) behaviour - https://gist.github.com/elithrar/077ce461183517c2f73b - just unzip it into your $GOPATH/github.com/tonycosentini/muxdemo, move handlers.go into a handlers directory and build it.\n(does your program differ from that in terms of structure?)\n. Closing out, but keeping tagged as v2 for reference.. Hi @elico - what path are you trying to access below /ui/ - i.e. what is the full URL you're attempting to access? Something like http://localhost:8000/ui/style.css?\n. Sorry for the delay (forgot about this one!) \u2014 but the reason router.PathPrefix(\"/ui/\").Handler(http.StripPrefix(\"/ui/\", http.FileServer(http.Dir(\"/tmp/ui/)))) works is because PathPrefix(\"/ui/\") means \"/ui/\" (wildcard) - *anything under /ui/ should be handled here.\nSimply putting router.Handle(\"/ui\") doesn't work, as whilst that matches http://domain.com/ui/ it does not match http://domain.com/ui/style.css as the path component is now /ui/style.css and not /ui/ (i.e. not a match).\nSome other routing libraries use a wildcard syntax instead, to the same effect.\n. I'm not sure I'm sold on this, as it's substantial addition to the size of the public API. \nRight now, if you need a way to get the routes in your application, you are better off creating a map[string]http.Handler and creating Routes from each key:value pair.\nThis patch effectively does the reverse, but since you control the routes you add, you shouldn't need to retrieve them from the mux. \n. Going to close this one out due to a lack of activity.\n. Are you able to provide a test case for this, @bign8?\n(Thanks for the PR, too)\n. LGTM, and thanks for adding the test. Merged!\n. https://github.com/gorilla/muxy (the eventual successor to mux) supports net/context out of the box. \nIt is (very) unlikely to support fasthttp: fasthttp is very different from net/http and therefore incompatible with the large number of existing libraries that use the http.Handler interface.\nThe \"10x\" benchmarks are also unlikely to be realized into actual \"request per second\" gains, and in many cases template rendering or DB connections will limit your application well before net/http does. Something like 80k/req/sec returning static JSON will drop to sub-15k/req/sec once you start rendering templates. \n. Thanks @tcyrus. The original README was mostly lifted from doc.go so appreciate the effort to make it a little prettier!\n. See https://github.com/gorilla/mux/pull/154\n. Thanks for reporting this! I'll fix the docs to make this clearer.\n. This may have changed since #144 and #155 - can you confirm?\n. Did you want to submit a PR updating the docs? I won't have time for a while.\n. Refer to https://github.com/gorilla/mux/issues/200. This looks good from a high-level POV. I haven't had a chance to dive in too deeply, but are there any cases where the new regex would break existing behavior?\n(not wrapping existing groups is a nice touch) \n. Alright:\n- This looks solid\u2014there's a good performance boost here (although router performance isn't a bottleneck for 99% of applications)\n- Doesn't break existing tests\n- No objections in a month.\nGoing to merge. Thanks for the work on this @tumdum!\n. Resolved in https://github.com/gorilla/mux/pull/155\n. Thanks for the report. I won't have a chance to address this any time soon,\nbut am open to documentation PRs.\nOn Wed, Feb 10, 2016 at 7:46 AM George Dobrovolsky notifications@github.com\nwrote:\n\nThere is also another problem with this setting.\nIf I define my path like\nr.Methods(\"POST\").Path(\"/users/\")\n(note the trailing slash) this setting won't work at all. Either it should\nbe fixed or mentioned in the docs.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/145#issuecomment-182437039.\n. What features do you have in mind?\n\nWe're always happy to consider new features, but raising an Issue to\ndiscuss/debate first will help to make sure you don't do work that won't be\nmerged!\nOn Fri, Feb 12, 2016 at 9:07 AM suanlihong notifications@github.com wrote:\n\nWhen i use mux,I think some features are not perfect.I hope join the\ninterceptor for monitor.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/146.\n. This is typically referred to as middleware and you can do this in mux today - e.g.\n\n``` go\nfunc main() {\n    r := mux.NewRouter()\n// Single handler\nr.HandleFunc(\"/form\", use(http.HandlerFunc(formHandler), csrf, logging)\n\n// All handlers\nhttp.Handle(\"/\", recovery(r))\n\n// Sub-routers\napiMiddleware := []func(http.Handler) http.Handler{logging, apiAuth, json}\napi := router.PathPrefix(\"/api\").Subrouter()\napi.Handle(\"/users\", use(usersHandler, apiMiddleware...))\n\n}\n// You could also create a type for this\ntype Chain []func(http.Handler) http.Handler\n// Middleware chainer\nfunc use(h http.Handler, middleware ...func(http.Handler) http.Handler) http.Handler {\n    for _, m := range middleware {\n        h = m(h)\n    }\n    return h\n}\n// Middleware (just a http.Handler)\nfunc AddHeaders(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        // do stuff before\n        w.Header().Set(\"X-Some-Header\", \"Value\")\n        h.ServeHTTP(w, r)\n        // do stuff after\n    })\n}\n// Basic handler at the end of it all.\nfunc formHandler(w http.ResponseWriter, r *http.Request) {\n      // do stuff\n}\n```\nLibraries like https://github.com/justinas/alice can help simplify it as well.\n. Wrap admin with middleware that inspects the request.\n. Closing as this can already be achieved.\n. I don't think this is worth extending the public API - you can write a helper like Use in your own code, or look at a mature library like justinas/alice.\n. @mikijov I get that, but gorilla/mux has a fairly large API as-is. Do we then add UseHandleFunc and UseHandler functions? What is the ordering? (first added?)\nThere are some great libraries out that work well with mux, and if someone has authored a PR without checking first, I can't be responsible for that.\nSorry to be blunt, but I can't say \"yes\" to every well-intentioned PR.\n. You should get nothing. Are you seeing otherwise?\n. Update:\n\nmiddleware was covered by the recent middleware feature.\nI covered how to test handlers a while ago on my blog: http://blog.questionable.services/article/testing-http-handlers-go/ (and need to port it here / use mux in the examples). Going to work on this over the coming weekend.. I think this is better handled in https://github.com/gorilla/mux/pull/54 (i.e. optional behaviour). If you want to pick that up and address my comments there, then that'd be appreciated.\n. This is similar to #145 #79 #78 and #31 - that is, the root path of a sub-router isn't routable.\n\nI'd love to see a PR for this (I haven't got the time myself) that:\n- Makes the root path of a Subrouter routeable\n- Plays well with StrictSlash\n- Has tests to cover each combination.\n. @benma Likely - as above there are a number of issues related to this. I can't confirm until I have time to dig into the source.\n. does https://github.com/gorilla/mux/issues/215 resolve this for you now? a failing test case will help. . Confirming that this works:\n```go\n    r := mux.NewRouter().StrictSlash(true)\n    r.Use(Logger)\n    r.HandleFunc(\"/\", handler)\n    r.HandleFunc(\"/{name}\", handler)\n// Internal metrics\nmetrics := r.PathPrefix(\"/metrics\").Subrouter()\nmetrics.HandleFunc(\"/{variable:.*}\", handler)\n\n```\nOutput:\nsh\n\u279c  ~  curl localhost:8080/metrics/hello\nhello: /metrics/hello\n\u279c  ~  curl localhost:8080/metrics\nhello: /metrics. Ping @jingweno in case you didn't see my line notes.\n. Sure, looking at it now!\n. LGTM. Thansk @jingweno!\n. Thanks @jprobinson\u2014and thanks for adding the benchmarks (which I was just about to ask for). Happy to lose a few % if it means we maintain API compat, especially since request muxes are almost never bottlenecks in real applications.\n. Thankfully, I know what software versions are ;)\nI'll look at doing a release/tag this weekend.\n. Done.\n@onlyjob \u2014 just to be clear, versioning is useful when vendoring using Go's vendoring capabilities. Given that gorilla/mux is a library, building it into a Debian package would be a bad idea, and would island users relying on it/rely on a third party to update it.\nIt's extremely unlikely gorilla/mux will ever have a truly breaking version (a \"2.0\") due to the age of the library (pre-dating vendoring) and goals of the Gorilla project.\nv1.1:\n\nWe're now tagging releases with SemVer, something that was long overdue. gorilla/mux has strict API compatibility guarantees, excepting any security issues, but we understand that being able to vendor specific versions is a useful feature.\nMinor breaking changes (i.e. regex functionality) will be treated as minor releases.\nWe also strongly recommend that you stay up to date: although this project has not had any security issues to date, back-porting security patches across multiple releases (v1.1.1, v1.2.1, etc.) is not maintianable for us.\n. > It is absolutely normal for users of GNU/Linux distributions to rely on pre-built binary packages provided by OS from native repositories.\n\nJust to be clear: a binary (application) that vendored gorilla/mux would make sense, as that binary should not be fetching dependencies at install time (bad).\nSomething like lib-gorilla-mux would be bad for users as it becomes an islanded version of the library. \n. > Golang produces static executables with all libraries built-in. Resulting binary package have no dependencies on source library packages.\nNot true as of Go 1.5 ;)\n. Are you explicitly using .Queries(\"detach\", \"\") here?\n. That's the correct behaviour (the same as net/http)\u2014the docs could be clearer here.\n(mux is probably the Gorilla library I've had the least exposure to, so I often have to check the behaviour myself!)\n. I'm not sure on the need for this: as this is a library, your vendoring tool (e.g. glide, gvt) should handle that. \ngorilla/mux doesn't have any dependencies outside gorilla/context, and we control both.\n. Does glide need a dependency file to work this out? Can it not just vendor\non fetch?\nOn Wed, Mar 23, 2016 at 3:46 PM Marcel Gotsch notifications@github.com\nwrote:\n\nIf a library depends on other libraries than there should be a dependency\nfile. A vendoring tool is not able to figure it out by itself.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/159#issuecomment-200572721\n. Can you show me in the glide docs where a dependency file is required for\nan upstream library? Vendoring via (e.g.) gvt will create a manifest with\nthe versions of the pinned dependencies\u2014there is no \"on the fly vendoring\"\nafter the initial fetch.\n\nOn Wed, Mar 23, 2016 at 3:56 PM Marcel Gotsch notifications@github.com\nwrote:\n\nWould also be nice if you guys would use SemVer for your libraries! :)\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/159#issuecomment-200574763\n. That doesn't say that a library must have the glide.yaml file. I don't believe it actually does.\n\nNote that I'm resisting this here as I don't want to support multiple vendoring tools. The vendoring tool can discern the dependencies during the initial fetch and then vendor/pin those versions as necessary.\n. From one of the authors of glide:\n\nWith Glide, if gorilla/mux has a dependency on gorilla/context it will be picked up\n. Use https://github.com/cespare/reflex to rebuild your program when files\nchange.\nOn Fri, Apr 1, 2016 at 3:48 AM Aniket notifications@github.com wrote:\nIf i change anything in service files and if i save the changes and build\nthe service, the gorilla mux service should be reload automatic.\nat the time of development i have to stop and restart the service again\nand again every time for even small changes.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/160\n. Looks good: can you add a test for this as well? @ADone \n. Marking as helpwanted.. Thanks @ChrisHines - appreciated!. The LICENSE is the 3-Clause BSD license. The FSF indicate that it is indeed GPL-compatible: http://www.gnu.org/licenses/license-list.en.html#GPLCompatibleLicenses\n\nI wasn't the original author, but I suspect the 3-Clause BSD license was used for the third clause (re: preventing endorsement), which is the same reason I use it for many of my own projects.\n. 100% agree. Thanks for submitting this. \n. @themihai Can you provide an example?\n. That's correct: the walkFn is only called if there are routes to walk:\nhttps://github.com/gorilla/mux/blob/master/mux.go#L284\n``` go\nnc (r Router) walk(walkFn WalkFunc, ancestors []Route) error {\n    for _, t := range r.routes {\n        if t.regexp == nil || t.regexp.path == nil || t.regexp.path.template == \"\" {\n            continue\n        }\n    err := walkFn(t, r, ancestors)\n    if err == SkipRouter {\n        continue\n\n...\n``\n. @themihai The docs are misleading here: what do you expect should be returned if you have a*Routerwith just aHost` but no actual routes (paths)?\n. I haven't had time to debug this: what is the length of r.routes inside\nr.walk under different conditions?\ne.g. adding just a host, adding actual routes, etc. If you can also show\nyour router code alongside it will help.\nOn Wed, Jun 8, 2016 at 9:21 PM Mihai notifications@github.com wrote:\n\n@elithrar https://github.com/elithrar I've found that even routes with\npaths are not provided, though I can't figure out why (some are provided\nand some are not provided) so AFAIC this is beyond undocumented.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/166#issuecomment-224796709, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AABIcBG6ux3PEQVKI8k4txfTtawV3tgsks5qJ5TAgaJpZM4Ir30I\n.\n. Note: also discussed in https://github.com/gorilla/mux/pull/112\n\nThe short answer: using https://golang.org/pkg/net/http/httptest/#Server + setting server.URL = /your/test/url is the right way to test this. You can still test multiple handlers, use table driven tests for testing different route variables, etc - without tying your tests to mux's implementation.\nThe long answer: changing the type of contextKey to int would cause collisions with other packages also using the request context. The gorilla/context docs cover this. Making the key type public would also add to the API and prevent us from ever changing things.\n. @bhirbec You populate the context by passing the correct URL - e.g.\n``` go\n    r := mux.NewRouter()\n    r.HandleFunc(\"/hello/{name}\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintln(w, \"Hello, client\")\n    }))\nts := httptest.NewServer(r)\ndefer ts.Close()\n\n// Table driven test\nnames := []string{\"kate\", \"matt\", \"emma\"}\nfor _, name := range names {\n    url := ts.URL + \"/hello/\" + name\n    resp, err := http.Get(url)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    if status := resp.Code; status != http.StatusOK {\n        t.Fatalf(\"wrong status code: got %d want %d\", status, http.StatusOK)\n    }\n}\n\n```\nThis way\u2014regardless of whether you use gorilla/mux or not\u2014you're still testing that your application handles the route variables you're passing.\n. Closing this out for now. Re-open if any questions!\n. @vincent6767 - https://godoc.org/github.com/gorilla/mux#SetURLVars. @palsivertsen Would you like to PR that? :). Thanks for reporting this\u2014it does makes sense. The new *http.Request is a new pointer and is therefore not the same map key as the original request. I (indirectly) addressed this for gorilla/csrf - https://github.com/gorilla/csrf/pull/35 - by using build tags to use http.Request.Context() in >= Go 1.7.\nWe can do this without breaking the public API as the only uses of context.Set in setVars and setCurrentRoute: https://github.com/gorilla/mux/blob/bd09be08ed4377796d312df0a45314e11b8f5dc1/mux.go#L346-L356 - these are only called in router.ServeHTTP so we can safely modify these to return the copied *http.Request.\nYou're welcome to submit a PR (with tests) and/or I'll have something done by early next week. You can pretty much lift the build-tag based implementation out of gorilla/csrf: https://github.com/gorilla/csrf/blob/master/context_legacy.go\nPS: My bigger problem is gorilla/sessions which does require breaking the API to fix it as a couple of public functions will need to return a *http.Request.\n. This LGTM! If @kisielk is happy with the PR as well we can merge.\n. @kisielk Thankfully we didn't expose the context keys in #167 or #112!\nThanks for merging as well.\n. Can you share an example of what you would like this to look like and/or\nwhat your use-case is?\nOn Wed, Jun 8, 2016 at 3:22 PM James notifications@github.com wrote:\n\nwould be nice is there was a way to get the results of mux.Vars (using a\ndifferent function) in a format that schema.Decoder can understand.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/171, or mute the thread\nhttps://github.com/notifications/unsubscribe/AABIcAPk6LiKK3-LIz6cVrxyc_uG4XTiks5qJ0C2gaJpZM4IxdpE\n.\n. Unlikely to implement this directly in mux, but open to a documentation PR for mux.Vars -> r.PostForm.\n. Can you provide example code that demonstrates the deadlock behavior? \n. @anacrolix Are you still seeing this issue? Definitely want to get to the bottom of it if you are.\n. Closing for now, as haven't had any other reports, but re-open if you're able to share some code/stack traces.\n. > I used to do this with a pointer receiver, inside a router folder. But as I sson as I move them around. The compiler complains about attaching method to a non local type.\n\nCan you show this error, and which line(s) it points to?\n. Creating package functions instead of closures should be better, but the\ndifference is tiny (and using fmt.Fprintf is probably more of a\nbottleneck).\nIn short: premature optimization :)\nOn Wed, Jun 29, 2016 at 11:34 AM pjebs notifications@github.com wrote:\n\nI have a question.\nWhich is better practice from a garbage collection Point of View:\nSetting the handler like this:\nappRoutes.Methods(\"GET\").Path(\"/customer/\\\").HandlerFunc(cAc.CreateCode)\nfunc CreateCode(w http.ResponseWriter, r *http.Request) {\n...\n}\nOR like this\nfunc Handler1() func(http.ResponseWriter, http.Request) {\n    return func(w http.ResponseWriter, r http.Request) {\n        fmt.Fprint(w, \"/api -> Handler1 - protected by RestGate (Static Mode)\\n\")\n    }\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/174, or mute the thread\nhttps://github.com/notifications/unsubscribe/AABIcHZDoVx8yJbavUEr75I1iK2B9GXFks5qQpBqgaJpZM4JBRDx\n.\n. Have you profiled? And yes, closures are heavier on the GC, but total GC\nimpact is likely to be insignificant compared to other parts of your\nprogram.\nOn Wed, Jun 29, 2016 at 12:34 PM pjebs notifications@github.com wrote:\nI believe it may not be that simple.\nI'm only speculating but I think in top example the package level function\nis kept in memory the whole time.\nI think in second example, the closure is garbage collected and recreated\nevery time the route is called.\nI'm only speculating and haven't properly looked into it but my handlers\nare very large and I have almost 50 routes. I think I noticed my memory\nusage decrease significantly when I changed it to type 2.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/174#issuecomment-229413042, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AABIcDzg9SEvGnBu0Nh5gdUpX5hq7mKuks5qQp5xgaJpZM4JBRDx\n.\n. Closing out, but please re-open if any questions.\n. Thanks for the fix. \n. Where is 'router' defined?\n\nOn Tue, Jul 19, 2016 at 6:53 AM Andrew Watson notifications@github.com\nwrote:\n\nI have a simple Go app that i'm trying to run with mux and when it gets\nits first HTTP request it panics.\n2016/07/19 13:23:13 http: panic serving 127.0.0.1:65156: runtime error: invalid memory address or nil pointer dereference\ngoroutine 6 [running]:\nnet/http.(_conn).serve.func1(0xc82007c580)\n    /Users/andy/utils/go_appengine/goroot/src/net/http/server.go:1389 +0xc1\npanic(0x5123c0, 0xc82000a070)\n    /Users/andy/utils/go_appengine/goroot/src/runtime/panic.go:443 +0x4e9github.com/gorilla/mux.(_Router).ServeHTTP(0x0, 0x9dd998, 0xc820111380, 0xc82000c460)\n    /Users/andy/go/src/github.com/gorilla/mux/mux.go:78 +0x2a\nnet/http.(_ServeMux).ServeHTTP(0xc820010b10, 0x9dd998, 0xc820111380, 0xc82000c460)\n    /Users/andy/utils/go_appengine/goroot/src/net/http/server.go:1910 +0x17d\nappengine_internal.handleFilteredHTTP(0x9dd998, 0xc820111380, 0xc82000c460)\n    /Users/andy/utils/go_appengine/goroot/src/appengine_internal/api_dev.go:100 +0x44c\nnet/http.HandlerFunc.ServeHTTP(0x6d1cc8, 0x9dd998, 0xc820111380, 0xc82000c460)\n    /Users/andy/utils/go_appengine/goroot/src/net/http/server.go:1618 +0x3a\nnet/http.serverHandler.ServeHTTP(0xc82007c480, 0x9dd998, 0xc820111380, 0xc82000c460)\n    /Users/andy/utils/go_appengine/goroot/src/net/http/server.go:2081 +0x19e\nnet/http.(_conn).serve(0xc82007c580)\n    /Users/andy/utils/go_appengine/goroot/src/net/http/server.go:1472 +0xf2e\ncreated by net/http.(*Server).Serve\n    /Users/andy/utils/go_appengine/goroot/src/net/http/server.go:2137 +0x44e\nINFO     2016-07-19 13:23:13,849 module.py:788] default: \"GET / HTTP/1.1\" 500 1528\nfrom init()\nr := mux.NewRouter()\nr.HandleFunc(\"/dashboard\", handleDashboard)\nr.HandleFunc(\"/\", handleCreateForm)\nhttp.Handle(\"/\", router)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/176, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcF5Qzh0uu1WDTfhDBDnQT3qfQpwzks5qXNbDgaJpZM4JPv7e\n.\n. LGTM!\n. Why not middleware on your router?\nOn Thu, Jul 28, 2016 at 5:33 AM Anis Elleuch notifications@github.com\nwrote:\nIt is an important feature to secure our servers from malicious clients\nsending very large requests.\nThough, we can do that in our handlers, it would still be good to be able\nto add this feature only one time via a new mux API.\nhttps://golang.org/pkg/net/http/#MaxBytesReader\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/178, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJXrj8ZhuQuoQrqSwqqP9t2e8jXuks5qaKF9gaJpZM4JXKbu\n.\n. mux itself doesn't buffer the request - it works just like net/http in that regard (I don't know any reasonable Go mux that would do that). You could just write some middleware that wraps mux and enforces the limit.\n. Hi @vadmeste - do you need any further help with this? If you're still stuck, open an issue on http://stackoverflow.com/questions/tagged/go - will get you a more complete response than I have time for right now.\n. @nwidger Can you share your code so I can get a better understanding how you are using context + mux today? Go 1.6?\n. @nwidger So you're using Go 1.7 rc3? (it's not clear: the behaviour should not have changed at all, but especially for Go 1.6, where the implementation never changed at all).\n\nI have libraries using gorilla/context + gorilla/mux together. mux intentionally doesn't expose its context keys, so other libraries/users can't clobber them, so any conflict here is strange.\n(I'll provide a quick MVE of gorilla/csrf + gorilla/mux on Go 1.6 - both using gorilla/context - that should highlight any potential regressions)\n. No problems - thanks for the runnable example. I'll take a look when I get\nhome tonight!\nOn Mon, Aug 8, 2016 at 2:50 PM Niels Widger notifications@github.com\nwrote:\n\nHere's a runnable example that shows the problem:\nhttps://play.golang.org/p/KHn9Fcv-ZN\nRun it and navigate to http://localhost. If built with Go 1.6.3 it prints\n\"bob\" to the screen. If built with Go 1.7 rc6 it prints \"no context stored\nfor request\".\nHopefully that highlights the issue better, I apologize if my original bug\nreport wasn't clear.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/182#issuecomment-238388886, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMLSc9pd2U0S0ostN9OBeGYwUpPBks5qd6SwgaJpZM4JfAVC\n.\n. OK, so this happens because r.WithContext() in Go 1.7, which gorilla/mux uses in Go 1.7, creates a shallow copy of the request: https://github.com/golang/go/blob/master/src/net/http/request.go#L288-L298\n\nThis shallow copy, as you'd expect, changes the address of the request in gorilla/context's map[*http.Request]map..., effectively islanding any context values.\nThis is a shortcoming in gorilla/context: any library, mux included, will break it come Go 1.7 and the http.Request.WithContext() method.`\nI'm not sure if there's a clean way to fix this: one option would be to call context.GetAll to copy all values from the old request before we call WithContext, and then save them back into the (shallow) copy, but if you have private types as keys (which is recommended), then we can't reliably achieve that. It would also add context back as a dependency to mux.\nThe short answer here, which involves some pain up-front: move off gorilla/context. Write a shim like we have in context_native.go and context_gorilla.go to abstract this across versions.\nI hope this helps. The breaking change was hard to anticipate here and was not intended, but was ultimately unavoidable. Any package that mixes gorilla/context and http.Request.WithContext() will run into this.\n. > It may be extreme, but maybe in the interest of backwards compatibility we should put go1.7 context behind a build tag (other than go1.7) for now?\nI'm more concerned that, even with a build tag (e.g. +newcontext) that anyone using gorilla/context and request.WithContext() (even indirectly via a library) will run into this issue. If gorilla/mux still relies on gorilla/context, then it would break mux.Vars.\nIt's definitely unfortunate, but I don't think it's actually fixable in a mixed-context environment.\n. > Technically, so long as you use gorilla/context.Set after all calls to request.WithContext() you shouldn't run into this issue.\nCorrect, but this is the less-common use-case: most users are calling Set in middleware (and before routing), and then Get in their handlers - which is intractable.\n.  Yep! Was going to do that tonight.\nOn Tue, Aug 9, 2016 at 6:57 PM Kamil Kisiel notifications@github.com\nwrote:\n\nIt seems like we should probably put a warning in the readme of\ngorilla/context that it's not compatible with using the new http context?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/182#issuecomment-238745320, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMOFVIY_sb2-YzQ-0yGQOv5kg-cLks5qeS_2gaJpZM4JfAVC\n.\n. The pre-1.7 builds should include the old gorilla/context module. Are you\nsaying Godeps does not see this?\nOn Wed, Aug 17, 2016 at 8:16 AM PolyviosT notifications@github.com wrote:\nHello,\nIt seems with Go 1.7 this tag you have under context_gorilla: // +build\n!go1.7 is breaking the vendoring of godeps as it is not including the\ncontext module. Any workarround?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/182#issuecomment-240445060, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcDV5M8rr1_lNw43ZtnicJ81nI5RNks5qgyXIgaJpZM4JfAVC\n.\n. https://github.com/tools/godep/issues/367\n\nDoes anything there fix the issue? This sounds like a bug with godep as mux\nisn't doing anything special here.\nOn Wed, Aug 17, 2016 at 3:55 PM PolyviosT notifications@github.com wrote:\n\nYes it seems Godeps don't see it, unless I am missing something.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/182#issuecomment-240574092, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCnVYc-6bmgslbYuABTXk3v1qCTmks5qg5FRgaJpZM4JfAVC\n.\n. Closing this out - see docs.\n. router.Headers (https://godoc.org/github.com/gorilla/mux#Route.Headers)\ndoesn't add headers to the router.\n\nWhere are you adding w.Header().Add(...) - can you show a more complete\nexample?\nAlso see https://godoc.org/github.com/gorilla/handlers#CORS and\nhttps://github.com/rs/cors that can handle this for you.\nOn Fri, Aug 12, 2016 at 10:58 PM Ahmadreza Zibaei notifications@github.com\nwrote:\n\nI added w.Header().Add(\"Access-Control-Allow-Origin\", \"\")\nw.Header().Set(\"Access-Control-Allow-Origin\", \"\") and i saw my network\nheader on chrome.\ni didn't saw Access-Control-Allow-Origin on response header ...\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/183#issuecomment-239604459, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcKOELBKqI66Hs1JabY1ktSc9tU3Qks5qfV0VgaJpZM4JjnQK\n.\n. Post your full handler code.\nOn Sat, Aug 13, 2016 at 12:27 AM Ahmadreza Zibaei notifications@github.com\nwrote:\nbut i don't know how can i use cors ! :|\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/183#issuecomment-239607605, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcASfVmqSOEug4Z7rfawlsy_e8E-Kks5qfXHRgaJpZM4JjnQK\n.\n. Is the CORS middleware package working for you now?\n. Correct. You need to put it in its own file with a build tag so that it\nonly builds on go 1.5.\n\nsometimes it can make sense to copy std lib code in to backport the\nbehavior, with the risk that you don't benefit from upstream fixes. This\ncan be OK for small functions/logic.\nOn Tue, Aug 16, 2016 at 11:42 AM Kamil Kisiel notifications@github.com\nwrote:\n\nI think you need to have a separate getPath for versions < go1.5\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/184#issuecomment-240197793, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJBLG3CuswYDFqF2FHZ6-Io5VukXks5qggRwgaJpZM4Jlh1O\n.\n. One reasonably key comment, and the follow-up question: could this be done in middleware prior to mux handling the request?\n. Running some benchmarks on this (just for documentation) and running some further testing. I was checked out into this branch and it broke an API proxy I had running for a project, so want to replicate and ensure we are testing more thoroughly.\n\n(\"blocked\")\n. @kushmansingh Will try to get something to you tonight - it's easy to replicate but want to dig into why first.\n. OK - with the tip of this branch installed: run https://gist.github.com/elithrar/51399e558e517bade6c29fed7ee72dbd (a minimal version of my API proxy with all of the CORS/RW wrapper pulled out for simplicity).\nmux is panicking when parsing the URL. The master branch does not suffer this problem.\n2016/08/23 05:43:52 listening on host 127.0.0.1 - port 8000\n2016/08/23 05:43:54 method=\"GET\" req=\"/\"\n2016/08/23 05:43:54 http: panic serving 127.0.0.1:55787: runtime error: slice bounds out of range\nStack trace:\n```\ngithub.com/gorilla/mux.getPath(0xc4200d21e0, 0xc42003fbf8, 0x854ed)\n        /Users/matt/.go/src/github.com/gorilla/mux/mux.go:372 +0x18f\ngithub.com/gorilla/mux.(*Router).ServeHTTP(0xc420012780, 0x3b0e80, 0xc4200f2000, 0xc4200d21e0)\n        /Users/matt/.go/src/github.com/gorilla/mux/mux.go:80 +0x21a\nmain.testlog.func1(0x3b0e80, 0xc4200f2000, 0xc4200d21e0)\ngithub.com/gorilla/mux.getPath(0xc420114000, 0xc42003fbf8, 0x854ed)\n        /Users/matt/.go/src/github.com/gorilla/mux/mux.go:372 +0x18f\ngithub.com/gorilla/mux.(*Router).ServeHTTP(0xc420012780, 0x3b0e80, 0xc4200f20d0, 0xc420114000)\n        /Users/matt/.go/src/github.com/gorilla/mux/mux.go:80 +0x21a\n```\nmux.go:372 (mux.go:80 just calls getPath)\npath := req.RequestURI[iStart:]\n. @kushmansingh see above (just in case GitHub chooses not to send you the notification).\n. Thanks. LGTM to me and the updated branch no longer panics.\n- @kisielk - if you agree, merge at will!\n. I appreciate the feedback @shurcooL - this definitely was not intended as a breaking change, but (as you detailed) ended up being one due to oversight.\nAs an aside: mux has a lot of users, and an API that we are trying to keep useful-yet-flexible. The Issues and PR tabs are littered with rejections of features, but perhaps not as many rejections as I'd like (given 20/20 hindsight!). That's not unique for an OSS project though!\n. @neelance Would you be able to submit a PR that reverts this? (it's not a one-click revert). I won't have time until tonight or tomorrow (at the earliest).\n(or, at the least, open an issue with your comment above)\n. > The easiest; drop support for anything below 1.5. This is not immediately viable but I think there is merit in encouraging users to upgrade since the standard library has changed a significant amount in net/http\nPossible, but not now. gorilla/mux has been around for a long while and Ubuntu/Debian, et. al, still package < Go 1.5 (horrible, but reality).\n\nProvide an optional middleware which must be used as first in the chain. This middleware will parse RequestURI and place the escaped path into req.URL.Path. This breaks the assumption provided by the standard lib about req.URL.Path being unescaped already but would allow other middleware down the line to still function and route.\n\nThis would likely live outside of mux, since mux doesn't have an API for middleware. Alternatively, it would work like StrictPath as a method on *Router. This is probably my preferred approach: opt-in, with docs around what this might break. It does add to the API however.\n\nProvide a flag on the basis of which either the parsed RequestURI will be used or req.URL.Path. If this flag was on, then other middleware would break the way that @shurcooL and @neelance are currently experiencing but it would be a very explicit \"TURN THIS ON AND STUFF MIGHT BREAK\" flag.\n\nAs above (so yes, I agree).\n. My preference is to be explicit rather than implicit ('clever').\n@kushmansingh Are you able to submit a PR that (my preference) adds a UseEscapedPath method on *Router?\n. See https://github.com/gorilla/mux/pull/190 - feedback welcome. \n. Can you add a (pre-fix) failing test case for this?\n. Thanks for this @neelance!\n.  Use https://godoc.org/github.com/gorilla/mux#Router.Walk to walk the\nRoutes in the Router.\nOn Wed, Aug 17, 2016 at 11:32 AM Pete Morgan notifications@github.com\nwrote:\n\nIs there a way to get a list of all routes.. The application has a few\nmodels and subrouters, so it be great to be able to see all these routes as\npart of the dev cycle.\neg a plain text of\n/\n/contact/{id}\n/foo\n/foo/{bar}.{ext}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/186, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBhpzlKWzM77R9_9erCoGg5-5PTAks5qg1POgaJpZM4JmwFB\n.\n.  \ud83d\udc4c\ud83c\udffc\nOn Fri, Sep 23, 2016 at 10:45 PM Shawn Smith notifications@github.com\nwrote:\n\u279c  ~  go run foo.go\n/\n/products\n/articles\n/articles/{id}\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/186#issuecomment-249347090, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcAqCNeB9OrHtQc0v1gfy1DjX2Ijsks5qtLjqgaJpZM4JmwFB\n.\n. @shawnps More examples are always good!. Closed via #217. Thanks @shawnps!. The custom, private types exist so that other packages won't clobber over it. If any other user was using int(0) as a key, it would override mux's vars.\n. Would the solution in https://github.com/gorilla/mux/issues/167 not work for you? Directly mutating internal state should be avoidable.\n. If you're testing multiple routes via table-driven testing, I would think\nthe extra 5-10 lines of boilerplate would be a wash?\n\nThe benefit to not just injecting into the context is that you also ensure\nthat mux's own route/var parsing is what your application expects over\ntime, rather than shortcutting it.\nOn Sat, Aug 20, 2016 at 7:36 PM Colton Baker notifications@github.com\nwrote:\n\nOf course it would work, but I'm not trying to handle the response or even\ncare about the route itself. I'm just pulling params from the\n*http.Request.\nIt would be so much easier for people to use this:\nrequest, _ := http.NewRequest(\"PATCH\", \"\", nil)ctx := context.WithValue(request.Context(), 0, map[string]string{\n    \"param1\": param1,\n    \"param2\": param2,\n})data := mapParams(request.WithContext(ctx))// assertions to check data\nVerses having all of this to achieve the same result:\nrouter := mux.NewRouter()\nrouter.HandleFunc(\"/%s/%s\", func (response http.ResponseWriter, request *http.Request) {\n    data := mapParams(request)\n    // assertions to check data\n})\nts := httptest.NewServer(router)defer ts.Close()\nurl := fmt.Sprintf(\"/%s/%s\", param1, param2)request, _ := http.NewRequests(\"PATCH\", url, nil)\nc := &http.Client{}\nresponse, e := c.Do(request)if e != nil {\n    t.Error(e)\n}\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/187#issuecomment-241235423, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPl2tvEpi5xITBoyThUgOEzwFY3Zks5qh7mhgaJpZM4JpFkr\n.\n. Closed via #189\n. Fantastic - thanks for this. \n. I'm OK with this so far.\n\nWill merge tomorrow night PST unless any objections. Appreciate the effort\non this Kush!\nOn Wed, Aug 31, 2016 at 11:12 AM Kush Mansingh notifications@github.com\nwrote:\n\nI added a separate test function for having a router with the feature\nturned on and also a check that it plays nicely with other features as well\n(as far as we can tell).\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/190#issuecomment-243851765, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMo1V7WaoJmjKvJrveTLVAyGoKN6ks5qlcQMgaJpZM4Jw235\n.\n. Not running into this myself. Is this a build-related issue?\n\nOn Thu, Sep 1, 2016 at 2:39 AM Marko Tikvic notifications@github.com\nwrote:\n\nHi.\nI went and 'go get -u github.com/gorilla/mux' after this merge and the\nproblem with raw path doesn't exist anymore but there seems to be a problem\nwith UseEncodedPath method:\n(type *mux.Router has no field or method UseEncodedPath)\nBut maybe I'm doing something wrong:\nr := mux.NewRouter()\nr.UseEncodedPath(true)\nThis seems OK to me, but I might be mistaken. Any ideas?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/190#issuecomment-244028568, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNZtkj3nDe-f6CW6e3HvlT57bw0fks5qlp03gaJpZM4Jw235\n.\n. Scratch that -\nI went and 'go get -u github.com/gorilla/mux' after this merge and the\nproblem with raw path doesn't exist anymore but there seems to be a problem\nwith UseEncodedPath method:\n\nUnless you checkout this PR and go install it, you won't see the changes\nhere.\nOn Thu, Sep 1, 2016 at 6:03 AM Matt S matt@eatsleeprepeat.net wrote:\n\nNot running into this myself. Is this a build-related issue?\nOn Thu, Sep 1, 2016 at 2:39 AM Marko Tikvic notifications@github.com\nwrote:\n\nHi.\nI went and 'go get -u github.com/gorilla/mux' after this merge and the\nproblem with raw path doesn't exist anymore but there seems to be a problem\nwith UseEncodedPath method:\n(type *mux.Router has no field or method UseEncodedPath)\nBut maybe I'm doing something wrong:\nr := mux.NewRouter()\nr.UseEncodedPath(true)\nThis seems OK to me, but I might be mistaken. Any ideas?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/190#issuecomment-244028568, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNZtkj3nDe-f6CW6e3HvlT57bw0fks5qlp03gaJpZM4Jw235\n.\n. @kushmansingh None. LGTM. Merging now.\n. What Go version are you using? I see the expected URL variable.\n\n\n``` go\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\nauth \"github.com/abbot/go-http-auth\"\n\"github.com/gorilla/mux\"\n\n)\nfunc Secret(user, realm string) string {\n    if user == \"john\" {\n        // password is \"hello\"\n        return \"$1$dlPL2MqE$oQmn16q49SqdmhenQuNgs1\"\n    }\n    return \"\"\n}\nfunc handle(w http.ResponseWriter, r *auth.AuthenticatedRequest) {\n    vars := mux.Vars(&r.Request)\n    fmt.Fprintf(w, \"key: %s\\n\", vars[\"key\"])\n    fmt.Fprintf(w, \"Hello, %s!\", r.Username)\n}\nfunc main() {\n    r := mux.NewRouter()\n    authenticator := auth.NewBasicAuthenticator(\"example.com\", Secret)\n    r.HandleFunc(\"/{key}\", authenticator.Wrap(handle))\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```\nOutput:\nkey: thing\n<html><body><h1>Hello, john!</h1></body></html>\n. Can you show a curl that demonstrates the input / output? Are you using PATCH? I wasn't able to replicate the issue.\n. sh\n~/Desktop curl -XPATCH http://localhost:8080/licenses/4707f1fe-98b9-40bc-835d-4f0db678ec4c/status -u john:hello\nkey: 4707f1fe-98b9-40bc-835d-4f0db678ec4c\n<html><body><h1>Hello, john!</h1></body></html>%\nCan you provide an example I can run without modification - so I can replicate exactly what you are seeing? \nAlso make sure you have the latest version of the basic auth package you are using, or use https://github.com/goji/httpauth instead.\n. - Are you getting nothing back for the key, but otherwise a successful HTTP\n  200?\n- Are you getting a status code other than HTTP 200?\n- What are you using to make the request? A browser? curl? Can you show\n  both the request (URI, headers) and the response (headers, body) you get?\n- If you run my example below - does it work as expected?\n``` go\npackage main\nimport (\n\"fmt\"\n\"log\"\n\"net/http\"\nauth \"github.com/abbot/go-http-auth\"\n\"github.com/gorilla/mux\"\n)\nfunc Secret(user, realm string) string {\nif user == \"john\" {\n// password is \"hello\"\nreturn \"$1$dlPL2MqE$oQmn16q49SqdmhenQuNgs1\"\n}\nreturn \"\"\n}\nfunc handle(w http.ResponseWriter, r *auth.AuthenticatedRequest) {\nvars := mux.Vars(&r.Request)\nfmt.Fprintf(w, \"key: %s\\n\", vars[\"key\"])\nfmt.Fprintf(w, \"Hello, %s!\", r.Username)\n}\nfunc main() {\nr := mux.NewRouter()\nauthenticator := auth.NewBasicAuthenticator(\"example.com\", Secret)\nr.HandleFunc(\"/licenses/{key}/status\",\nauthenticator.Wrap(handle)).Methods(\"PATCH\")\nlog.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```\nI can't replicate this (and your server has a lot of hard-coded config -\nit's not a minimal example!). I'd love to help more but my testing doesn't\nshow a problem.\nOn Tue, Sep 6, 2016 at 10:59 PM Hanna Boychenko notifications@github.com\nwrote:\n\nhttps://1drv.ms/u/s!AiHa-7v0RdbXnGpziq20pSHqwL6F\nthis is an example.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/191#issuecomment-245183165, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCpkweQehti4d2A40zb5j7z-fq9tks5qnlKzgaJpZM4J1og3\n.\n. Can you answer my other questions? Are you on the latest gorilla/mux?\n\nOn Tue, Sep 6, 2016 at 11:23 PM Hanna Boychenko notifications@github.com\nwrote:\n\nchecked your example (to make more useful to me add\ngrohl.Log(grohl.Data{\"fk\": vars[\"key\"]})\nafter\nfmt.Fprintf(w, \"\nHello, %s!\", r.Username))\nthe result: fk is nil\ni'm testing it using advanced REST client (chrome extension)\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/191#issuecomment-245186556, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcO9fKYj1GBmFqzVCn7BvKsDwh6HVks5qnlhhgaJpZM4J1og3\n.\n. To be honest, I'm stumped. Can you run a curl to rule out your REST client?\n\ncurl -XPATCH http://localhost:8080/licenses/4707f1fe-98b9-40bc-835d-4f0db678ec4c/status\n. I'm stumped. I can't replicate your issue, and if you're using the latest version of gorilla/mux (0a192a1) then I can't see why this is happening. Are you also on the latest version of go-http-auth (cb43723) as well?\n. Are you using the latest gorilla/mux?\nOlder versions still using gorilla/context have this problem (it's\nunavoidable).\nOn Tue, Jan 3, 2017 at 4:18 PM Daniel Russell notifications@github.com\nwrote:\n\nI'm running into a similar issue, although it's when using our own auth\nservice, which alters the context like:\nctx := context.WithValue(req.Context(), UserContextKey, user)\nreq = req.WithContext(ctx)return next(res, req)\nLater on in the request, mux.Vars is nil, unless I remove the line\naltering the context.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/191#issuecomment-270263073, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBEtSwy9wW9GufgKEx8BnTI_vsR2ks5rOuVMgaJpZM4J1og3\n.\n. Please update the version of mux you are using.\nOn Tue, Jan 17, 2017 at 5:22 AM G. Ralph Kuntz, MD notifications@github.com\nwrote:\nI found the same problem yesterday. It appears that using the new context\npackage interferes with using mux, because it uses the Gorilla context\npackage. I am creating a test case now.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/191#issuecomment-273153035, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcD0ivlItYK7Z0QoJr-pDr8qhBsZPks5rTMCZgaJpZM4J1og3\n.\n. What is the actual URL you are trying to match with?\nOn Mon, Sep 12, 2016 at 8:38 PM nasihong notifications@github.com wrote:\n/{url}/,someHandler\n/123%0A123/\nThe url \"/123 123/\" does not match any handlers.\nI hope the expected results url is 123%0A123\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/192, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcHyj2Sh30l3lqfxeaWBUt_0GiLdeks5qphqngaJpZM4J7Qoz\n.\n. Just to clarify: \"handler\" means a type that satisfies http.Handler, rather than the Handle and HandleFunc methods on *Router.\n\nThe naming conventions are shared with net/http.\n. That would be because you are using the old context. You would need to\nclear it manually, but as per the context docs, I do not recommend mixing\ncontext types.\nOn Wed, Sep 21, 2016 at 12:21 AM nvartolomei notifications@github.com\nwrote:\n\nOr this is because I'm using old gorilla/context?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/198#issuecomment-248531592, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPRmM-WWk_zOFP6SyXQZdhABFNEMks5qsNrvgaJpZM4KCehJ\n.\n. gorilla/mux uses the new http.Request.Context as of Go 1.7 - failing to do\nso means that any users (or libraries imported by the user!) using\nhttp.Request.Context would break when mixed with gorilla/context.\n\nI'm suggesting that you remove gorilla/context from any 1.7+ application,\nand especially so those with mux\nOn Wed, Sep 21, 2016 at 5:47 AM nvartolomei notifications@github.com\nwrote:\n\nI just recompiled the app using 1.7.1 compiler and it caused memory leaks.\nI'm not mixing anything, gorilla/mux together with gorilla/context does.\nOn 21 Sep 2016, 15:41 +0300, Matt Silverlock notifications@github.com,\nwrote:\n\nThat would be because you are using the old context. You would need to\nclear it manually, but as per the context docs, I do not recommend mixing\ncontext types.\nOn Wed, Sep 21, 2016 at 12:21 AM nvartolomei notifications@github.com\nwrote:\n\nOr this is because I'm using old gorilla/context?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/198#issuecomment-248531592,\nor mute\nthe thread\n<\nhttps://github.com/notifications/unsubscribe-auth/AABIcPRmM-WWk_zOFP6SyXQZdhABFNEMks5qsNrvgaJpZM4KCehJ\n.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub (\nhttps://github.com/gorilla/mux/issues/198#issuecomment-248600085), or\nmute the thread (\nhttps://github.com/notifications/unsubscribe-auth/AAhJ2W6qfE57HQEw1Vnhc3y-daXRrhQDks5qsSYGgaJpZM4KCehJ\n).\n\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/198#issuecomment-248601802, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcLwha4R25plVGtKpnwP2FBn48W7oks5qsSd7gaJpZM4KCehJ\n.\n. That's not entirely true, if you control the situation and know the risks. We're probably picking nits at this point though.\n. @darrenmcc @kallekrantz If you can submit a PR with an additional test case (e.g. your example), and that doesn't break existing tests, it'd be hugely appreciated.\n. @kallekrantz Test looks good. Did you want to also add a commit that reverts the simplification in 0b13a92 to the same PR?\n\n(thanks heaps!)\n. We should consider calling panic() if regexp.NumSubexp() != 0 - and providing a useful error message in the trace.\n\nHere: https://github.com/gorilla/mux/blob/master/regexp.go#L108-L110\nNeed a full suite of tests to ensure correct behaviour\nAdd to documentation\nIncrement version (minor breaking change). Of course @aeijdenberg - send a PR when you're ready. . Thanks. We should document the \"panics if capture groups are provided\" piece however as the failure is harsher, but more explicit.. Closed via #218 and tagged as v1.3.0 - https://github.com/gorilla/mux/releases/tag/v1.3.0. https://godoc.org/github.com/gorilla/mux#Route.GetPathTemplate\n. @Fruchtgummi You can't get the template for an empty route.\n. I'm open to that. We should also document this (in both the code, the\ntests, and docs).\nOn Sat, Oct 22, 2016 at 9:00 AM Richard Musiol notifications@github.com\nwrote:\n\n\n@neelance commented on this pull request.\nIn mux_test.go https://github.com/gorilla/mux/pull/202:\n\n@@ -1014,6 +1004,26 @@ func TestBuildVarsFunc(t *testing.T) {\n  }\n }\n\n+// Addresses https://github.com/gorilla/mux/issues/200\n+func TestCorrectVars(t *testing.T) {\n- tests := []routeTest{\n-     {\n-         title:        \"Correct nested regex vars\",\n-         route:        new(Route).PathPrefix(\"/{id}/{kind:(a|b)}/{idx:[0-9]+}\"),\nWhat about using a regexp replace to automatically turn capturing groups\ninto non-capturing ones? Then we don't need a panic.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/202, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcHCGCDcXXhzxMZcXBc8PMzkNjsZdks5q2jMngaJpZM4KWYMj\n.\n. Indirectly addressed in https://github.com/gorilla/mux/pull/218. also refer to https://github.com/gorilla/mux/issues/215. @captncraig Did you resolve?\n. @captncraig ah, see it here. phew :)\n. What is a valid semver version that gb supports? 1.1.0 - ?\n\nOn Fri, Oct 21, 2016 at 2:46 PM Roger Welin notifications@github.com\nwrote:\n\nI'm using gb as build tool / dependency manager. I'm listing this lib in\nmy depfile as such (which is the only available tag):\ngithub.com/gorilla/mux http://github.com/gorilla/mux version=1.1\nAnd I'm getting:\nFATAL: unable to construct context: github.com/gorilla/mux\nhttp://github.com/gorilla/mux: \"1.1\" is not a valid SemVer 2.0.0 version\nPlease add a tag that's support semver versioning\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/206, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcIg44MXdNGf_BLBDgzpJaUK9XDN8ks5q2TLKgaJpZM4KdnpR\n.\n. Fixed - https://github.com/gorilla/mux/releases/tag/v1.2.0. Thanks for submitting.\n\nCan you also add a test and documentation to the README on how someone\nmight range over routes to get their docs?\nOn Fri, Oct 28, 2016 at 12:48 PM craigsammisutherland \nnotifications@github.com wrote:\n\nThis patch allows adding additional information to a route. This allows\nfor automatic generation of documentation about a route.\nAt the moment, the only information associated with a route is the methods.\nThis can be combined with the Walk() function to allow something like this:\nfunc documentRoute(route _mux.Route, router *mux.Router, ancestors\n[]_mux.Route) error {\ntemplate, _ := route.GetPathTemplate()\nmethod, _ := route.GetInformation(mux.InformationMethods)\nfmt.Println(\"[\" + method + \"]\" + template)\nreturn nil\n}\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/207\nCommit Summary\n- Added information to a route for documentation (Methods).\nFile Changes\n- M route.go https://github.com/gorilla/mux/pull/207/files#diff-0\n  (48)\nPatch Links:\n- https://github.com/gorilla/mux/pull/207.patch\n- https://github.com/gorilla/mux/pull/207.diff\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/207, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMOnu5qm6osbthqtn7uSh5BOGOH2ks5q4lF0gaJpZM4Kjy0u\n.\n. We can't modify the license ad-hoc. Does this impact you using the library?\nOn Wed, Nov 30, 2016 at 2:08 AM St\u00e9van Le Meur notifications@github.com\nwrote:\nHi @kisielk https://github.com/kisielk any updates on this?\nWould you be able to handle that?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/208#issuecomment-263833953, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBF4jKCWxuKGjNR55QBC9cR_RfLaks5rDUsogaJpZM4KvJIG\n.\n. Closing. I don't see this as an issue. . Can you explain the rationale behind this?\n. HTTP headers are typically http.Header - which is a map[string][]string, not a map[string]string.\n\nIf you have an existing data structure, write a helper to convert. I'm not sure this adds value for all (or even most) users of this library.\n. The tests we have now are table driven tests.\nWhat would Ginkgo improve in that regard?\nOn Sat, Dec 3, 2016 at 7:01 AM Oliver Peate notifications@github.com\nwrote:\n\nWould you be open to adopting a testing framework like Ginkgo\nhttp://onsi.github.io/ginkgo/? I think this could make contributing to\nmux easier because it:\n\nHas a clearer output when a test is failing (and catches panics,\n   marking that test as a failure).\nProvides structure to the tests (Describe, Context)\nHas table driven tests\n   http://onsi.github.io/ginkgo/#table-driven-tests which could allow these\n   tests to be declared more succinctly\n   https://github.com/gorilla/mux/blob/master/mux_test.go#L53:L237\n\nSplitting out groups of tests into distinct files could be helpful too, as\nmux_test.go for example is now > 1500 lines long.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/210, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcM1sx6qmzx_W4kzia-CzcIYf5Qx5ks5rEYRegaJpZM4LDUQd\n.\n. Have your handler check for the presence of a file, and if it doesn't\nexist, serve the dir listing? Or 404?\n\nOn Tue, Jan 3, 2017 at 8:15 PM huytn notifications@github.com wrote:\n\nI'm building a RESTful file server which supports listing a specified\ndirectory, and download file. To build such url template I need put dir\npath or file path in url. I found the following things from RFC 6570:\n{+path}/here /foo/bar/here\nIn my case:\nrtr.HandleFunc(\"/v1/{+path}\", List_files).Methods(\"GET\")\nWill list dir or download file.\nIs there anyway to do this?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/213, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcHpKCPSLwBXgRFmGO9HwPrSYRSKlks5rOxz2gaJpZM4LaRsY\n.\n. Closing due to inactivity.. Thanks for submitting this. Will review tomorrow!. Can you add some additional test cases to this?\n\n\n/foo/bar\n/foo/bar/\n/{category}\n/{category}/\n\nThis will help prevent any regressions in future. mux has grown a lot over time & I want to make sure the testing story is as robust as it can be.  . LGTM - @kisielk?. Thanks @aeijdenberg - appreciate it!. Sure, you're more than welcome to!\nOn Thu, Apr 20, 2017 at 4:18 AM Erwin notifications@github.com wrote:\n\n@elithrar https://github.com/elithrar do you mind if I pick this up?\nI'd like to help out.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/219#issuecomment-295647199, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcFx5MCG_H2x_qxOhyxMyRMvgYe58ks5rxyLXgaJpZM4Lm5zN\n.\n. Covered in a previous change to the README: https://github.com/gorilla/mux#static-files. This (capture groups) was already broken: we now just fail fast to prevent incorrect behavior. \n\nThis project does use SemVer but we considered this a bugfix.  . Unfortunately we can't blindly trust this. If you need to use X-Forwarded-Host, you should put some middleware before mux's matcher that populates r.Host for hostnames you trust (only), or use https://godoc.org/github.com/gorilla/handlers#ProxyHeaders.. Ping @moraes - are you able to take a look?\n(Note: happy to take over admin/move this to a shared Google Cloud project to manage/pay for it going forward) . No problems @kisielk - no rush.\nOn Sun, Jan 29, 2017 at 10:17 PM Kamil Kisiel notifications@github.com\nwrote:\n\nI am looking into it. Dusty Wilson is managing the DNS (I don't remember\nwhy) but I have access to the GAE console. Might have to wait till tomorrow\nsince I literally just got off a plane.\n\nOn Jan 29, 2017, at 18:29, Matt Silverlock notifications@github.com\nwrote:\nPing @moraes - are you able to take a look?\n(Note: happy to take over admin/move this to a shared Google Cloud\nproject to manage/pay for it going forward)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/222#issuecomment-275987479, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcDSA9UTgZ6h8ztMrhxYH4gtcsoL4ks5rXYBdgaJpZM4Lw-2b\n.\n. Thanks for this + the related PR. I'll take a look this week - at a high-level it looks good.. No problems. Can keep the original issue open to track this in future.\nAppreciate the investigation!\nOn Tue, Feb 7, 2017 at 1:18 PM tro3 notifications@github.com wrote:\nOkay - not as simple as I thought. The templates are created looking\nupward when a new Route is attached. So if you have a Router with a bunch\nof Routes created before that Router is added to a parent, none of the\nRoutes below will have the proper prefixes. This would require a\nrecurvise-downward prefix adder function. I may take a look at this when\ntime allows.\nPR closed for now, as it is broken.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/223#issuecomment-277897328, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPBXJXYd2neeBab72uJx9MJ429bBks5rZ_CYgaJpZM4L4b0m\n.\n. SkipClean?\nOn Fri, Feb 10, 2017 at 7:41 PM krasi-georgiev notifications@github.com\nwrote:\nI am trying to solve an issue with the docker api where the endpoint takes\na param like\n/containers/{name:.*}/checkpoints\nfor example if name is passed as \"../\"\ninstead of serving /containers/..//checkpoints the path becomes\n/checkpoints\nand doesn't get passed to the handler function because it doesn't match\nthe added route path.\nThere are too many endpoints that are affected and I would be interested\nto hear if there would be an easy way to solve this globally.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/226, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcIjrNMfl8Mt05wMT8KR0LvhmwxwUks5rbD7JgaJpZM4L9PKw\n.\n. It's not immediately clear why \"../\" exists in your URLs? I can understand\nwhy the Docker team might see it as a possible security issue.\nOn Sat, Feb 18, 2017 at 5:57 AM Krasi Georgiev notifications@github.com\nwrote:\nthe PR was rejected due to some security implications.\ndocker/docker#30933 https://github.com/docker/docker/pull/30933\nI am back to the original request.\nwould it make sense to allow running some variable validation before\npassing the reuqest to url cleanup and redirecting the ../\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/226#issuecomment-280764200, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcC71g7gEnrm7StYFrIKmIrS4CFtMks5rdgmdgaJpZM4L9PKw\n.\n. I think you should - as per the discussion in the PR you linked -\nhttps://github.com/docker/docker/pull/30933 - not use \"../\" as a container\nname.\n\n(It's still not clear why you must accept that container name as valid?)\nOn Sat, Feb 18, 2017 at 5:54 PM Krasi Georgiev notifications@github.com\nwrote:\n\nIt is marked as bug in the docker issues and I am trying to solve it.\neven if it is not ../ , if that part of the url is set to be a variable it\nshouldn't be considered to be part of the url right ?\n/containers/{name:.*}/checkpoints\nyou don't think that the option to validate the var before doing an url\ncleanup is going to be worth the effort ?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/226#issuecomment-280832319, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBfTf5zLcrftSo31m9O6LX8cwADMks5rdrGpgaJpZM4L9PKw\n.\n. OK, but there's nothing to fix on this side, and I don't think Docker has anything to fix either. . Can you share a minimal example I can run?. Can you please explain the need behind this? An example will help. . In short: you want this feature so that you can use call GetRoute and have it include the query string?\n\nIt's important to provide a summary of the PR, rather than just submitting a PR. Adding more features adds complexity to the API, and we need to manage that.\n(this will also need tests if we agree it is useful, before merging). Needs a full review (code, tests, docs, examples). You are welcome to give\nit a review; I will try to make time tomorrow (Monday, PST).\nAs the API grows I'm enforcing more docs + examples so that godoc isn't the\nonly reference ;)\nOn Sun, May 21, 2017 at 6:11 PM Chris Hines notifications@github.com\nwrote:\n\nI would like to see this functionality get merged. What work remains to be\ndone?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/230#issuecomment-302976865, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPliWVIsbPF_LTF4LmyDHDX2ji-Rks5r8ODagaJpZM4MFgSY\n.\n. To further note, if gorilla/mux is the bottleneck in your application,\nplease file an issue with profile output.\n\nRouters are rarely the bottleneck in any networked-application.\nOn Wed, Feb 22, 2017 at 5:58 AM Kamil Kisiel notifications@github.com\nwrote:\n\nYou should benchmark it with your intended use case and see if it's fast\nenough for you.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/231#issuecomment-281478080, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcOqm9hwk8jdnIv2Xg2nSJCHEG_Dyks5re0_zgaJpZM4MHZtj\n.\n. What's the difference between a public SetVars() and this proposal? :)\nOn Fri, Feb 24, 2017 at 10:44 PM Akira Chiku notifications@github.com\nwrote:\nThank you for creating such a wonderful library!! I have gone through\nissues/prs, and now put a proposal up. Any comments are welcomed!\nProposal\nHow do you think about adding a function to set URL params in context,\nwhich is implicitly declared as an API only for test. Testing as a public\nAPI is borrowed from this slide Advanced Testing with Go\nhttps://speakerdeck.com/mitchellh/advanced-testing-with-go?slide=53.\nBackground\nFirst of all, as it's discussed in several issues, it's not good idea to\nmake context key public or basic type since it may conflict with other keys\nset from different packages, and accidentally overwrite values. Secondally,\nit is also not good idea to make a setVars function public, since it is\nfundamentally not necessary for this library to work as intended, and widen\nits API boundary, which tend to increase difficulty to maintain a clean\nproject.\nHowever, it is still useful if library users can add URL params to context\nfor testing. The main reason is that users can separate middlewares, and\nother routing mechanism aside when they test a function that implements\nhttp.Handler interface.\nImplementation\nBelow is just an example.\n\nachiku@f8f4828\n   https://github.com/achiku/mux/commit/f8f4828232971c798713d8c4f7bb9739f9950dc4\n\nRelated issues/prs\n\n\n187 https://github.com/gorilla/mux/issues/187\n\n\n167 https://github.com/gorilla/mux/issues/167\n\n\n112 https://github.com/gorilla/mux/pull/112\n\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/233, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBnORNtOBIeSwKO9lUfO49lcYOTlks5rf83lgaJpZM4ML7XM\n.\n. Answered above - closing.. The problem is that any use of gorilla/context in Go 1.7 - where\nRequest.Context() could exist in any part of the application - does not\nwork.\n\nCan you show the application code where this problem occurred? Go must do a\nshallow copy of the Request which is why the address changes.\nOn Thu, Mar 2, 2017 at 7:07 AM AndyHaskell notifications@github.com wrote:\n\nRecently I was using Gorilla Mux in a deployed App Engine app and got the\npanic in appengine.NewContext:\nNewContext passed an unknown http.Request\nWhen I pinned my Gorilla Mux dependency to the version immediately before\nthe logic was added for Go 1.7+ to use request.WithContext rather than a\nGorilla context, though, I didn't get the panic. Looking at the source code\nfor http.Request.NewContext, that function returns a pointer to a\ncompletely new http.Request, so I think the issue was that that request\nwas not known to App Engine since it's a fresh pointer.\nBecause of this, I would like to send a feature request for a Router to\nhave a WithGorillaContext() method that would override the default Mux\nbehavior that in Go 1.7+ we use Request.WithContext if it's set to true.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/237, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCtcyADCHRjJF8PNPmHp-mNIA2c6ks5rhts9gaJpZM4MRGoH\n.\n. If you are running an older mux with newer middleware, or newer middleware\nwith an older mux, there is no practical way to avoid this.\n\nWhat version of mux were you on?\nOn Thu, Jun 1, 2017 at 8:30 PM Wyatt Arent notifications@github.com wrote:\n\nThis bug is really unfortunate. Spent way too much time trying to isolate\nit back here.\nAlso for some reason even pinning the version back to an old version of\nmux doesn't fix it for me. The only solution is to remove gorilla/mux\nentirely in my case\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/237#issuecomment-305680064, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcGdTIjIfS0tSoQeiFJv3edQlU-8Jks5r_4HFgaJpZM4MRGoH\n.\n. Closing this as wontfix (\"cannotfix\").. Open to documentation PRs for this!\n\nOn Tue, Mar 28, 2017 at 1:44 PM Micah Willard notifications@github.com\nwrote:\n\nOkay, This is definitely broken. LUCKILY, there is a gorilla mux way of\nfixing it. You have to use the route.Queries() and give it a {name:pattern}\nfor it to use (using {query:.+} fixes my above issue). If you give\nroute.Queries() just {name}, it will fail with the example url I gave\nabove. Hope this helps someone down the road.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/238#issuecomment-289898742, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJAAvsIq5y5MJUn_fFaQCx5xtkJdks5rqXEugaJpZM4MReOu\n.\n. Can you explain this further? unless you are concurrently modifying a request, the current approach - which saves the shallow copy - should not break applications.. This is now possible as of v1.6.1 as middleware is invoked after mux has performed a match, which means that route variables are available within a middleware handler.\n\ne.g.\n```go\nfunc Logger(next http.Handler) http.Handler {\n    fn := func(w http.ResponseWriter, r *http.Request) {\n        vars := mux.Vars(r)\n        log.Printf(\"url=%s method=%s vars=%s\", r.URL, r.Method, vars)\n        next.ServeHTTP(w, r)\n    }\nreturn http.HandlerFunc(fn)\n\n}\n```\nOutput:\nsh\n~ curl localhost:8080/matt\n2018/01/16 14:24:48 url=/matt method=GET vars=map[name:matt]. Closing as not a mux issue, but re-open if otherwise.. https://dave.cheney.net/2013/07/07/introducing-profile-super-simple-profiling-for-go-programs\nmay help. Profiling a Go program is no different when using mux.\nOn Wed, Mar 15, 2017 at 10:37 AM Theo Bouwman notifications@github.com\nwrote:\n\nHow can I implement\nhttp://blog.ralch.com/tutorial/golang-performance-and-memory-analysis/ in\nmy application which uses the Mux router.\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/242, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcHQ1PJtCYMXZjxr3Y9WDOC1YiaF3ks5rmCHEgaJpZM4MeSTT\n.\n. What have you tried so far? :)\n\nOn Wed, Mar 15, 2017 at 11:13 AM Theo Bouwman notifications@github.com\nwrote:\n\nI want to create a static folder /storage to store different files, but I\nalso want /storage to be a subrouter so I can serve files to users and\nadd logic/middleware to it.\nThis is what I want to accomplish:\nrouter.PathPrefix(\"/storage/\").Handler(http.StripPrefix(\"/storage/\", http.FileServer(http.Dir(helpers.GetMakePath(\"/storage\")))))\napiRouter := router.PathPrefix(\"/storage/\").Subrouter()\nAnd then attach routes like /contract?contractid=1234 to serve the user a\nspecific contract. And maybe log in a database when a user accessed/\ndownloaded that file.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/243, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcFzoZhfT8l8ZBGoAZ6w0EUMqZUd-ks5rmCpVgaJpZM4MeVPe\n.\n. I will review it today.\nOn Wed, Apr 19, 2017 at 5:08 AM Bulat Gaifullin notifications@github.com\nwrote:\nIs there any chance that this PR will be merged?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/244#issuecomment-295200542, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcEQzmoaP-8R6LiO1O-RIkNbJ5rxwks5rxd0hgaJpZM4Mg3WS\n.\n. LGTM. @kisielk?. This would not be safe to do concurrently.. Correct, but NewRoute() implies less concurrency.\n\nWould you not create a *Router in a function and then return that instead of adding to mux's API?\ne.g. \n```go\npackage handlers\nfunc CreateRoutes() mux.Router {\n   // create a new Router, add routes\n   return router\n}\n```\n```go\npackage main\nimport \"handlers\"\nfunc main() {\n    routes := handlers.CreateRoutes()\n    // Can be applied as a Subrouter, used as the primary router, etc\n}\n```\nAm I misunderstanding your use-case here?. Can you show how NewRoute() improves things over returning a *mux.Router\nfrom a constructor?\ne.g. Show what the code looks like.\nOn Mon, May 15, 2017 at 7:36 AM Daniel Nephin notifications@github.com\nwrote:\n\nMy use case is building up routes in different components and combining\nthem into a single router. This is common in larger applications, or in\nlibraries where the caller could pass in routes.\nIt would be possible to create a router first, and pass it around as a\ndependency, but as this PR demonstrates it's a somewhat artificial\ndependency. There's really no need to create a route from a router when you\ncan add routes.\nNewRoute() implies less concurrency\nI personally don't really see that implication.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/245#issuecomment-301494705, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcDLF5m0plLZyuPu41SXnef2wtczOks5r6GLzgaJpZM4MhEBo\n.\n. Timing out. Please re-open if you have further questions!. How are you validating that the mux isn't being modified by another goroutine also calling AddRoute or otherwise mutating the router?. Can you show the code that caused this? You shouldn't add routes concurrently, if that's what you're doing.. https://github.com/gorilla/mux/blob/master/README.md#static-files has an example.\n\nCan you share what doesn't work/what errors you get?. Closing due to inactivity.. What is the URL you are passing?\nOn Tue, Apr 11, 2017 at 7:14 AM facundomedica notifications@github.com\nwrote:\n\nMaybe I'm using this library wrong, but just in case this is a bug, I'm\nreporting it.\nr.HandleFunc(\"/locations/{location}/devices/delete/{device}\", v1f.NeedsAuthorization(v1f.GetLocationDeleteDevice, db)).Methods(\"GET\")\nr.HandleFunc(\"/locations/{location}/devices\", v1f.NeedsAuthorization(v1f.GetLocationDevices, db)).Methods(\"GET\")\nThe problem is quite simple to explain, I have this two routes with\nfunctions but both go to the second one. If I change the route of the first\none to .../adevices/... or something else it will work.\nIf you need an app that recreates this issue I can write one.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/248, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJ5MYwaorDOuRqLuBoXo8eRdG64Lks5ru4rLgaJpZM4M6KJW\n.\n. There is nothing here that points to mux.\n\nCan you show how you're testing?\n\nIs the browser autocompleting?\nHave you added a log.Println(r.URL) statement to confirm the input URL is the one you actually input?\n\n\nNot working (prints \"GET\", meaning that is not working as expected, and it cuts off the last part):\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491849169864000000\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491922212261000000\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491922220620000000\n\nAll of these work as intended for me and output DELETE!.\n. What does echo $GOPATH show on your shell?\nIDEA indicates that your GOROOT & GOPATH are at the same location, which is\nalmost certainly not correct.\nOn Mon, Apr 17, 2017 at 5:43 AM ConnelBLAZE notifications@github.com\nwrote:\n\nJust started GoLang, got into web dev. Did go get -u\ngithub.com/gorilla/mux/ in terminal to my path, it worked. Downloaded the\npackage in src directory. But when I tried using the router and importing\n\"github.com/gorilla/mux/\" package IDEA shows error asking to download it,\ntried it it shows GOROOT=/usr/local/go\nGOPATH=/usr/local/go:/usr/local/go/src /usr/local/go/bin/go get -t\ngithub.com/gorilla/mux/... package github.com/gorilla/mux/...: cannot\ndownload, $GOPATH must not be set to $GOROOT. For more details see: go help\ngopath\nAny idea?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/249, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcB1oR_qJNIYMDhplw5m3MLsng8AFks5rw0I4gaJpZM4M_DZQ\n.\n. How did you install Go?\n\nYou should update to Go 1.8, which sets the GOPATH for you.\nOn Tue, Apr 18, 2017 at 3:07 AM ConnelBLAZE notifications@github.com\nwrote:\n\nshows nothing\n[image: screenshot from 2017-04-18 09-05-34]\nhttps://cloud.githubusercontent.com/assets/13662770/25120514/53d8e160-2416-11e7-9508-5fe8031763c5.png\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/249#issuecomment-294722441, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcL5Bhw-IzZrFjswCjMmyheI4mAoyks5rxG8ogaJpZM4M_DZQ\n.\n. Did you set your GOPATH as per https://github.com/golang/go/wiki/GOPATH -?\nYour previous code indicated you had not.\n\nGo 1.4 is also very old. See https://golang.org/doc/install for updated\nversions\nOn Tue, Apr 18, 2017 at 3:21 PM ConnelBLAZE notifications@github.com\nwrote:\n\nDownloaded go1.4.linux-amd64.tar.gz then extracted it tar -C /usr/local\n-xzf go1.4.linux-amd64.tar.gz for the go tree. I then tested it by\nrunning normal GoLang programs, it worked well. Decided to do web, worked\nwell not until i decided to use github.com/gorilla/mux package for\nrouting.\nHow do i update it now? can that fix this issue for me cos i'm getting\ntired.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/249#issuecomment-294969017, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcAsoO7OeJ6jbNvsFhQdQevFIczrEks5rxRthgaJpZM4M_DZQ\n.\n. Thanks!. This breaks the public API: I know it's a golint issue but was committed a long while ago. Can't merge.. Yes: https://godoc.org/github.com/gorilla/mux#Router.Walk will walk through\nevery route and pass it to the provided WalkFunc.\nOn Sat, Apr 29, 2017 at 4:53 PM Thales Pinheiro notifications@github.com\nwrote:\nHello!\nIs it possible to get a list of registered routes against a router?\nThank you!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/252, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcKR8xiMjfcgfDrHWg9ZjiS6tHxMUks5r081kgaJpZM4NMa19\n.\n. https://godoc.org/github.com/gorilla/mux#Route.GetPathTemplate\nOn Tue, May 2, 2017 at 12:01 PM Thales Pinheiro notifications@github.com\nwrote:\n@elithrar https://github.com/elithrar is there some way to not only get\nthe routes but the registered verbs? Example:\nGET /product/{id:[0-9]+}\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/252#issuecomment-298729427, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCzGexBItmWTEvhN1v2_UacnzFX5ks5r1318gaJpZM4NMa19\n.\n. Closing out.. Based on the RFC, that would only apply to the Accept header, not to all\nheaders. The Headers/HeadersRegexp expand beyond that, so it's not clear\nthat we should send a 406 in those cases.\n\nI would say that users should use middleware to 406 in front of us if the\nAccept doesn't match.\nOn Wed, May 3, 2017 at 12:33 PM Daniel Hodges notifications@github.com\nwrote:\n\nI think this applies to HeadersRegexp\nhttps://github.com/gorilla/mux/blob/master/route.go#L238 and Headers\nhttps://github.com/gorilla/mux/blob/master/route.go#L213. If there in\nnot a match it currently returns a 404, but should probably return a 406\ninstead to be more HTTP compliant:\nThe resource identified by the request is only capable of generating\nresponse entities which have content characteristics not acceptable\naccording to the accept headers sent in the request.\nUnless it was a HEAD request, the response SHOULD include an entity\ncontaining a list of available entity characteristics and location(s) from\nwhich the user or user agent can choose the one most appropriate. The\nentity format is specified by the media type given in the Content-Type\nheader field. Depending upon the format and the capabilities of the user\nagent, selection of the most appropriate choice MAY be performed\nautomatically. However, this specification does not define any standard for\nsuch automatic selection.\nSee W3 https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/253, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcHRfALIr9WnHMoQtopdtO76kouMQks5r2NafgaJpZM4NP2kp\n.\n. This is odd, and I can't replicate this - using the exact code you have above:\n\nsh\n~/Desktop curl localhost:2000\n404 page not found\n~/Desktop curl localhost:2000\n404 page not found\n~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl localhost:2000/subpath/\nYou made a GET request%                                                                                                                                                                                                                                                         ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%                                                                                                                                                                                                                                                        ~/Desktop curl -XPOST localhost:2000/subpath/\nYou made a POST request%\nWhat version of mux are you on?. (going to close out due to age, but re-open if you still see this @bleakley). Where does http.Handler come into play in your example here?\n*mux.Router already satisfies the http.Handler interface.\nOn Tue, May 16, 2017 at 4:51 AM kamal namdeo notifications@github.com\nwrote:\n\nI am using nrgorilla\nhttps://github.com/newrelic/go-agent/blob/master/_integrations/nrgorilla/v1/nrgorilla.go\nand gokit https://github.com/go-kit/kit(having mux as router) how to\nConvert http.HandleFunc to *mux.Router.\nSo to instrument all routes I need to pass mux.Router to InstrumentRoutes\nfunction, but I have http.Handler which I want to assert to mux.Router\nto make it run.\nfunc InstrumentRoutes(r mux.Router, app newrelic.Application) mux.Router {\n  r.Walk(func(route mux.Route, router mux.Router, ancestors []*mux.Route) error {\n      h := instrumentRoute(route.GetHandler(), app, routeName(route))\n      route.Handler(h)\n      return nil\n  })\n  if nil != r.NotFoundHandler {\n      r.NotFoundHandler = instrumentRoute(r.NotFoundHandler, app, \"NotFoundHandler\")\n  }\n  return r\n}\nAny help would be appreciated. Thanks!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/256, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcM1cM1NlMBL3YFHpogu4NQpbAeo0ks5r6Y3DgaJpZM4NcYC6\n.\n. You can't - a Router satisfies the http.Handler interface, but also has a\nnumber of additional methods.\n\nYou should pass your base mux.Router instance to that function.\nOn Thu, May 18, 2017 at 2:59 AM kamal namdeo notifications@github.com\nwrote:\n\nI am using go-kit for our micro services, so in my transport.go it is\nreturning http.Handler, but nrgorilla's func InstrumentRoutes(r\nmux.Router, app newrelic.Application) mux.Router{...} function accepts\none *mux.Router, but I am getting below error.\ncan not convert http.HandlerFunc to *mux.Router\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/256#issuecomment-302358887, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMHS9S3zJVk-M63f7E3Sw8J0-tXMks5r7BZtgaJpZM4NcYC6\n.\n. @kamal-github Let me know if you still need help w/ this.. First: Call https://godoc.org/github.com/gorilla/mux#CurrentRoute inside\nyour handler/middleware\n\nSecond: call https://godoc.org/github.com/gorilla/mux#Route.GetPathTemplate\n- which provides the template - e.g. /profile/{user} - of the route, rather\nthan the literal path - /profile/16272eaf2\nHope that helps!\nOn Tue, May 16, 2017 at 7:12 AM Antoine Hedgecock notifications@github.com\nwrote:\n\nHeya\nI'm trying to track response times of various endpoints using a middleware\nwrapping the muxer\npackage middleware\nimport (\n  \"context\"\n  \"net/http\"\n\"time\"\n\"github.com/davecgh/go-spew/spew\"\n  \"github.com/prometheus/client_golang/prometheus\"\n  \"github.com/satori/go.uuid\"\n)\nconst RequestCtxRequestId = \"requestId\"\nvar endpointDurations = prometheus.NewSummaryVec(\n  prometheus.SummaryOpts{\n      Namespace:  \"infinity\",\n      Name:       \"http_endpoint_duration_seconds\",\n      Help:       \"Duration spent on each endpoint\",\n      Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n  },\n  []string{\"endpoint\", \"method\"},\n)\ntype requestTracker struct {\n  nextHandler http.Handler\n}\nfunc init() {\n  prometheus.MustRegister(endpointDurations)\n}\nfunc RequestTracker(handler http.Handler) http.Handler {\n  return &requestTracker{nextHandler: handler}\n}\nfunc (middleware requestTracker) ServeHTTP(rw http.ResponseWriter, r http.Request) {\n  requestId := r.Header.Get(\"X-Request-Id\")\n  if requestId == \"\" {\n      requestId = uuid.NewV4().String()\n  }\nctx := r.Context()\n  ctx = context.WithValue(ctx, RequestCtxRequestId, requestId)\nstartedAt := time.Now()\n// return the request id for future tracking\n  rw.Header().Set(\"X-Request-Id\", requestId)\nmiddleware.nextHandler.ServeHTTP(rw, r.WithContext(ctx))\n// This will never have any long time duration\n  if r.Method != http.MethodOptions {\n  spew.Dump(r.Context())\n\n  endpointDurations.\n      WithLabelValues(r.URL.Path, r.Method).\n      Observe(time.Since(startedAt).Seconds())\n\n}\n}\nThis works great IF I don't use dynamic routes, but using something\nlike /users/{uuid} I'm screwed because I will get an entry for each user\nin the system which is not really awesome.\nDo you have any suggestions on a clean way to resolve this ?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/257, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcHYmwcA5Dw6o3SsttvpUYjtNzv6rks5r6a7bgaJpZM4Ncj89\n.\n. If you move the CurrentRoute above where you copy the request with\nWithContext, what do you get?\nOn Tue, May 16, 2017 at 8:02 AM Antoine Hedgecock notifications@github.com\nwrote:\n@elithrar https://github.com/elithrar mux.CurrentRoute(r) always\nreturns nil\nThis is the updated code\npackage middleware\nimport (\n  \"context\"\n  \"net/http\"\n  \"time\"\n\"github.com/gorilla/mux\"\n  \"github.com/prometheus/client_golang/prometheus\"\n  \"github.com/prometheus/common/log\"\n\"github.com/satori/go.uuid\"\n)\nconst RequestCtxRequestId = \"requestId\"\nvar endpointDurations = prometheus.NewSummaryVec(\n  prometheus.SummaryOpts{\n      Namespace:  \"infinity\",\n      Name:       \"http_endpoint_duration_seconds\",\n      Help:       \"Duration spent on each endpoint\",\n      Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n  },\n  []string{\"endpoint\", \"method\"},\n)\ntype requestTracker struct {\n  nextHandler http.Handler\n}\nfunc init() {\n  prometheus.MustRegister(endpointDurations)\n}\nfunc RequestTracker(handler http.Handler) http.Handler {\n  return &requestTracker{nextHandler: handler}\n}\nfunc (middleware requestTracker) ServeHTTP(rw http.ResponseWriter, r http.Request) {\n  requestId := r.Header.Get(\"X-Request-Id\")\n  if requestId == \"\" {\n      requestId = uuid.NewV4().String()\n  }\nctx := r.Context()\n  ctx = context.WithValue(ctx, RequestCtxRequestId, requestId)\nstartedAt := time.Now()\n// return the request id for future tracking\n  rw.Header().Set(\"X-Request-Id\", requestId)\nmiddleware.nextHandler.ServeHTTP(rw, r.WithContext(ctx))\n// This will never have any long time duration\nif r.Method == http.MethodOptions {\n      return\n  }\nroute := mux.CurrentRoute(r)\n  if route == nil {\n      log.Warnf(\"No route matched '%s' for request tracking\", r.RequestURI)\n      return\n  }\nif template, err := route.GetPathTemplate(); err == nil {\n      endpointDurations.\n          WithLabelValues(template, r.Method).\n          Observe(time.Since(startedAt).Seconds())\n  } else {\n      log.Error(err)\n  }\n}\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/257#issuecomment-301810821, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcC3FqSJ3NKGZdImN8gr6bR4q-KOOks5r6bqHgaJpZM4Ncj89\n.\n. ```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc main() {\n    r := mux.NewRouter()\n    r.Handle(\"/hello\", RouteMiddleware(http.HandlerFunc(HelloHandler))).Name(\"helloRoute\")\nlog.Fatal(http.ListenAndServe(\"localhost:8000\", r))\n\n}\nfunc RouteMiddleware(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        route := mux.CurrentRoute(r)\n        log.Printf(\"current route: %s\", route.GetName())\n})\n\n}\nfunc HelloHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"hello\")\n}\n```\nsh\n~/Desktop go run mux.go &\n~/Desktop curl localhost:8000/hello\n// Outputs: 2017/05/17 05:48:23 current route: helloRoute. Are you definitely on the latest version of mux?. The new middleware functionality allows you to run \"pre-processing\" after a match: https://github.com/gorilla/mux/#middleware\ne.g.\n```go\nfunc RouteMetricsMiddleware(next http.Handler) http.Handler {\n    fn := func(w http.ResponseWriter, r *http.Request) {\n        routeVars := mux.Vars(r)\n        // for example...\n        sendToMetrics(ctx, routeVars)\n        next.ServeHTTP(w, r)\n    }\nreturn http.HandlerFunc(fn)\n\n}. Why not just wrap the router?\nr := mux.NewRouter()\n// add routes\nhttp.ListenAndServe(\":8000\", YourMiddleware(r))\n-\nThat would always be executed, doesn't require you to decorate each route,\nand can implement before/after logic.\nOn Thu, May 18, 2017 at 12:16 AM Nick Miyake notifications@github.com\nwrote:\n\nAlternate approach that I just thought of that is similar to this but\nwould be a bit more scoped and may not have the baggage of a before/after:\nInstead of BeforeHandler, add MatchCallback func(*http.Request,\nRouteMatch)\n\nOn any match, ServeHTTP would invoke r.MatchCallback(req, match)\n\nThis gets at the underlying issue (add a way to extract information about\nthe match outside of the scope of the handler itself) without opening the\npandora's box of full-blown special-case matchers.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/258#issuecomment-302321630, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCJzBsGiaEmkE-PIBFQBWJtrIfvVks5r6_BggaJpZM4Nexsu\n.\n. Merged. Thanks @ChrisHines!. Waiting on #265 to be reviewed+merged.. I'm OK with a minor behavioural change as well to keep the API surface\nsane(r). I'll tag the version as a minor release (1.x+1) to signal that.\n\n(Thanks for the proposal Nick)\nOn Fri, May 19, 2017 at 11:43 AM Nick Miyake notifications@github.com\nwrote:\n\nOK. I'm personally fine with either approach, but was just flagging that\nfixing this bug will create a behavioral difference in API behavior for\nexisting clients -- previously, it happened to be the case that every\nroute passed to WalkFunc would have t.regexp.path.template != \"\", so any\nexisting consumers that make this assumption would be broken by a change\nhere -- to preserve it, they would need to add the following to their\nWalkFunc:\n_, err := route.GetPathTemplate()if err == nil {\n    return nil\n}\nIf you guys are fine with this, then it works for me -- I've opened #265\nhttps://github.com/gorilla/mux/pull/265 to implement the fix in this\nmanner.\nIf you want to preserve the old behavior for back-compat, then I would\nlike to propose implementing this \"fix\" via the method outlined above (and\ncan update my PR to do so).\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/262#issuecomment-302780988, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcLil_ml2x_lXpUEnS_ooTyxv3O8Nks5r7eLbgaJpZM4NgyiL\n.\n. Can you also add a (short) example of using WalkFunc to the README to supplement this? Add it as the next section after https://github.com/gorilla/mux#registered-urls. LGTM. @kisielk?. I'm open to this. We should profile the performance before/after if we are stuffing more into mux.Vars though.. Yes, that is by design.\n\nCall HandleFunc on a Router, or call HandlerFunc(...).Path(...) if you are\nbuilding up a Route manually.\nOn Mon, May 22, 2017 at 2:05 AM bilc notifications@github.com wrote:\n\nMethods() returns Route, but Route doesnot have function HandleFunc. It\nhas function:\nfunc (r Route) HandlerFunc(f func(http.ResponseWriter, http.Request))\nRoute {\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/267, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcM7zO3r6Uc37oZnsQPHY_CaX3qzMks5r8U-6gaJpZM4NiErJ\n.\n. Good catch, thanks!. This is great - thank you Chris. I'll make a concerted effort to review\nthis ~tomorrow given the effort you put in!\n\nOn Tue, May 30, 2017 at 1:25 PM Chris Hines notifications@github.com\nwrote:\n\nThis PR builds on and supersedes #230\nhttps://github.com/gorilla/mux/pull/230. It fixes #238\nhttps://github.com/gorilla/mux/issues/238 and #255\nhttps://github.com/gorilla/mux/issues/255.\n\nRebased the two commits by @pamburus https://github.com/pamburus\n   from #230 https://github.com/gorilla/mux/pull/230 and resolved the\n   conflicts.\nUpdated README.md and the godocs to reflect the new functionality.\nAdded a test for escaped query values, which duplicated #238\n   https://github.com/gorilla/mux/issues/238 and added a fix for that.\n   The fix for that\u2014changing the default pattern for query values from\n   [^?&] to .\u2014is safe because the Go standard library has already\n   removed the semantically important ? and & characters from the query\n   string when parsing it into individual key/value pairs. The matching logic\n   in routeRegexp.matchQueryString uses the regex to match already parsed\n   and decoded query values returned by routeRegexp.getURLQuery.\n\n\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/270\nCommit Summary\n\nAdd support for queries in URL reversing.\nAdd tests for support for queries in URL reversing.\nUpdate docs.\nAdd test and fix for escaped query values.\n\nFile Changes\n\nM README.md https://github.com/gorilla/mux/pull/270/files#diff-0\n   (10)\nM doc.go https://github.com/gorilla/mux/pull/270/files#diff-1\n   (12)\nM mux_test.go\n   https://github.com/gorilla/mux/pull/270/files#diff-2 (35)\nM regexp.go https://github.com/gorilla/mux/pull/270/files#diff-3\n   (5)\nM route.go https://github.com/gorilla/mux/pull/270/files#diff-4\n   (15)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/270.patch\nhttps://github.com/gorilla/mux/pull/270.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/270, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCMg-guShHylLlwreb-TCrbbhUEzks5r_HtFgaJpZM4Nqzbq\n.\n. Write middleware - e.g.\n\nfunc TimeRequest(h http.Handler) http.Handler {\n    return http.HandlerFunc(func (w http.ResponseWriter, r *http.Request) {\n        // start := startTimer()\n        h.ServeHTTP(w, r) // call handler\n        // duration := stopTimer(start)\n    }\n}\nOn Tue, Jun 6, 2017 at 7:24 AM Collin Guarino notifications@github.com\nwrote:\n\nI'm trying to implement a feature that will benchmark the time it takes to\nhandle a route and return the result. For example, when the GET /api/info\nroute is visited then a timer will start, the handler to get the info will\nbe called, then the elapsed time will be appended to the JSON body\nresponse. This is similar to golang.org/pkg/testing/benchmark\nhttps://golang.org/pkg/testing/#hdr-Benchmarks except I would like to\navoid having to start a timer within every single route's handler.\nDoes mux have a way to add this underlying feature to all routes?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/272, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPzr-mdGqHI1DLfI7zqTNoaswjTMks5sBWEegaJpZM4Nxa0A\n.\n. Name is defined on a Route, not a Router -\nhttps://godoc.org/github.com/gorilla/mux#Route.Name\n\nOn Wed, Jun 7, 2017 at 8:14 PM Rob Graham notifications@github.com wrote:\n\nBear in mind i'm very new to Go. and I believe this may completely be the\nlinters fault but i'm having a hard time understanding why i'm seeing this\nerror\n[image: linterr]\nhttps://user-images.githubusercontent.com/1311204/26910688-479295c6-4bbd-11e7-8049-d6c424bb8191.png\nIf I move the Name chain below any of the other methods here, the linter\nwon't complain even though Name is returning *Router just like the other\nmethods...\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/273, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJA_NoOkPs4G7FVPmrh1wSsFDeWnks5sB2cXgaJpZM4NzhyO\n.\n. There's a semantic difference here: 404 means not found, which is\nreflective of the route not existing for that method.\n\n405 means method not allowed, which often has intent, and a router library\ncan't know that ahead of time.\nYou can always create middleware or modify Router.NotFoundHandler to return\n405 instead of 404 for routes that exist.\nOn Thu, Jun 15, 2017 at 2:49 AM hellojukay notifications@github.com wrote:\n\nouter.HandleFunc(\"/index\", func(w http.ResponseWriter, r *http.Request) {\nw.Write([]byte(\"hello\")) }).Methods(\"POST\")\nthis code , i regist a url \"/index\",but when i access the url by get\nmethod,it return httpstatus is 404,i think it should return 405\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/275, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcD_gF0a-_nGdMQtC5vVJe2CFjuauks5sEP43gaJpZM4N6-pY\n.\n. Your regex does not accept an empty query value:\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc main() {\n    r := mux.NewRouter()\n    sub := r.PathPrefix(\"/1/classes\").Subrouter()\nsub.Path(\"/products\").Methods(\"GET\").HandlerFunc(someHandler).Queries(\"type\",\n    \"{type:[a-zA-Z0-9:_-]+}\", \"next_token\", \"{next_token:(?:[a-zA-Z0-9_-]+)?}\",\n    \"max_result\", \"{max_result:[0-9]+}\")\n\nhttp.ListenAndServe(\"localhost:8080\", r)\n\n}\nfunc someHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"someHandler\")\n}\n```\nNote that ?:[a-zA-Z0-9_-]+)?} allows an empty value, whereas [a-zA-Z0-9:_-]+ does not.\nsh\n\u26a1\ufe0f  ~ curl \"http://localhost:8080/1/classes/products?type=a&next_token=\u2022&max_result=5\"\n404 page not found # Correctly fails as '\u00b7' does not match a-zA-Z0-9\n\u26a1\ufe0f  ~ curl \"http://localhost:8080/1/classes/products?type=a&next_token=&max_result=5\"\nsomeHandler # Correctly matches\n\u26a1\ufe0f  ~ curl \"http://localhost:8080/1/classes/products?type=a&next_token=abc123&max_result=5\"\nsomeHandler # Correctly matches. Priority is ascertained by the order in which routes are added, so I\u2019m not sure this PR simplifies the API in a meaningful way. \nFurther: how are identical priorities resolved? Where are the tests? \ud83d\ude43. @DEATH-TROOPER I'm not sure we want to expand the API here, as the value of these helper methods is minimal. Calling HandleFunc and Methods is slightly more verbose, but clearer.\n(Appreciate the PR, but please raise an issue with your idea/suggestion first to avoid unnecessary work!)\n. Can you show the error? The code you have provided does not use mux.\nOn Thu, Jul 20, 2017 at 6:22 AM kinjal1296 notifications@github.com wrote:\n\nzed.txt https://github.com/gorilla/mux/files/1162391/zed.txt\ni have done successfull installation with variable settings.\n\"fmt\" package works completely , when i import another packages it doesn't\nwork i mean it gives an error\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/284, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMDpWftnDVIFj0RrFloeO6XzObaGks5sP1SMgaJpZM4OeF2S\n.\n. Many clients do not understand 308, and thus I'm hesitant to set that as\nthe default.\n\nOn Thu, Jul 20, 2017 at 9:51 AM Nick Miyake notifications@github.com\nwrote:\n\nIn projects using Go 1.7+, gorilla/mux should use 308 as the response\ncode for redirects for non-GET methods.\nCurrently, when the redirect behavior is turned on, the redirection is\nalways done with a 301: m.Handler = http.RedirectHandler(u.String(), 301)\n(\nhttps://github.com/gorilla/mux/blob/18fca31550181693b3a834a15b74b564b3605876/regexp.go#L293\n)\nPer the RFC and other online resources, the method behavior for 301\nretries is not strictly defined, and there exist user agents that will\nalways retry a 301 using GET.\nThe 308 response code was created for non-get methods to specifically\nindicate that the method and body must not be changed. Support for this was\nadded in Go 1.7.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/285, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcAU59_ghydwAgLEVa9IPNSCDgoGlks5sP4V9gaJpZM4OeYo-\n.\n. Timing out. Please re-open if you have further questions!. What does\n\n$ go get -u github.com/gorilla/mux\n... show?\nDoes it appear in $GOPATH/src after that?\nOn Fri, Jul 28, 2017 at 6:06 AM Robert Sayakhov notifications@github.com\nwrote:\n\nI have issue with package importing. Error - can't find import: \"\ngithub.com/gorilla/mux\". I'm tried to reinstall, but it doesn't help.\nHere is my Go version and environments If you want to I can attach my code.\n$ go version\ngo version go1.6.2 linux/amd64\n$ go env\nGOARCH=\"amd64\"\nGOBIN=\"/home/rob/Desktop/Go/bin\"\nGOEXE=\"\"\nGOHOSTARCH=\"amd64\"\nGOHOSTOS=\"linux\"\nGOOS=\"linux\"\nGOPATH=\"/home/rob/Desktop/Go\"\nGORACE=\"\"\nGOROOT=\"/usr/lib/go-1.6\"\nGOTOOLDIR=\"/usr/lib/go-1.6/pkg/tool/linux_amd64\"\nGO15VENDOREXPERIMENT=\"1\"\nCC=\"gcc\"\nGOGCCFLAGS=\"-fPIC -m64 -pthread -fmessage-length=0\"\nCXX=\"g++\"\nCGO_ENABLED=\"1\"\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/286, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcOAZ8i3BJ6nDyTfNC73HQsDipJtAks5sSdzJgaJpZM4OmlKZ\n.\n. Where are you running your code? Are you sure the environment you printed\nabove is available where you are running it?\n\nWhat does the full error say?\nOn Fri, Jul 28, 2017 at 6:24 AM Robert Sayakhov notifications@github.com\nwrote:\n\nWhat does\n$ go get -u github.com/gorilla/mux\n... show?\nNothing\nDoes it appear in $GOPATH/src after that?\nYes\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/286#issuecomment-318650721, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCWRB53MhxeerOeSTj1ytnEQDAWnks5sSeDxgaJpZM4OmlKZ\n.\n. @paulbes I'd happily accept a PR for GetQueriesTemplate() functionality.. No current plans, but open to a proposal that doesn't complicate the API.\n\nmux has a large API, and the more we add, the higher the barrier to\nnewcomers as well as the more we need to document, maintain, test.\nOn Mon, Oct 9, 2017 at 12:01 PM Paul B. Beskow notifications@github.com\nwrote:\n\n@elithrar https://github.com/elithrar, as a side-note, is there any\nintention for adding optional query parameters, e.g., a more concise way of\nachieving this:\nhttps://stackoverflow.com/questions/45378566/gorilla-mux-optional-query-values\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/287#issuecomment-335125751, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMHY9xi2pEPlq9Wo6-94zbOTuzgZks5sqfz2gaJpZM4O7Fpw\n.\n. The challenge here is that the \"magic\"\u2014using build tags\u2014solves the case where http.Request.Context does not exist pre-Go 1.7. We still need to cover that case to support older versions of Go, and allowing users to swap between context versions adds complexity to the API \u2014 i.e. \"why is there a choice? is one better?\" \u2014 instead of having sane defaults.\n\nI get that it's frustrating after debugging for several hours, but I don't think we should throw the baby out with the bathwater because of a GAE-specific regression.\n. Thanks!. Let me think on the design. Custom middleware interfaces can be tricky and\nisolate mux. I'd want to see how something like Chi solves this use-case\nfirst.\nOn Mon, Sep 11, 2017 at 8:25 AM Abdullah Saleem notifications@github.com\nwrote:\n\nCan I send a pull request with something like this\nmaster...Abdullah2993:master\nhttps://github.com/gorilla/mux/compare/master...Abdullah2993:master\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/293#issuecomment-328565008, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcKBluOGYU55F4pq5dqp9y-Rq4JT_ks5shVEAgaJpZM4PRbdT\n.\n. What does func (http.Handler) http.Handler) not solve here, as the\n\"defacto\" middleware interface? (I may be missing something)\n\nOn Mon, Sep 11, 2017 at 9:12 AM Roberto Santalla notifications@github.com\nwrote:\n\nMy fork actually looks like this:\nmaster...roobre:middleware\nhttps://github.com/gorilla/mux/compare/master...roobre:middleware\nAs I said, I feel that returning the responseWriter and request seems\nbetter (to me at least) than adding a third parameter like Negroni does.\nOther options are, of course, open to discussion. However, please take into\naccount that middleware writers would value the ability to hijack these two\nobjects, so a modification to the http.Handler interface is required.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/293#issuecomment-328579162, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcAqVzLP7FFVRlZ4uS5jzekfbKmqGks5shVvUgaJpZM4PRbdT\n.\n. You create closures - which is a fairly common way for writing middleware,\nand makes it portable across any sane library - net/http, gorilla/mux, chi,\netc - as it's just http.Handler\n\nfunc MyMiddleware(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        // do things\n    })\n}\nThen you can wrap routers or routes - e.g.\nr := mux.NewRouter()\n// Some routes go here\nhttp.ListenAndServe(\"localhost:8000\", MyMiddleware(r))\nFurther reading:\n\nhttps://justinas.org/writing-http-middleware-in-go/\n\nOn Tue, Sep 12, 2017 at 9:11 AM Roberto Santalla notifications@github.com\nwrote:\n\nNow it's me who is probably missing something. How can you create a\nmiddleware chain using that interface?\nWhich http.Handler is passed and what meaning have the returned\nhttp.Handler? The purpose of middleware is to operate on the\nResponseWriter and Request objects, not on handlers themselves.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/293#issuecomment-328902696, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcN5BUBktowizhez1xZO7aTuHi7JUks5shq1AgaJpZM4PRbdT\n.\n. We won't have to change mux to support this :)\n\nOn Tue, Sep 12, 2017 at 9:59 AM Roberto Santalla notifications@github.com\nwrote:\n\nThanks for the info :D\nIt certainly looks good, I'll take a look at it and change the\nimplementation if no functionality is lost.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/293#issuecomment-328916956, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJ3R1QtkwVkpuevt2lUXnW2ug63aks5shrhYgaJpZM4PRbdT\n.\n. Can you share a design proposal for this? Take a look at how other routers are doing this, as well as the previous PRs/Issues raised here for background.. @roobre Thanks for describing the design in detail. I'll make time to review today/tomorrow and we can decide about moving ahead.. That part [the ordering of matching vs. middleware] makes sense to me!\n\nOn Thu, Sep 28, 2017 at 7:21 AM Roberto Santalla notifications@github.com\nwrote:\n\nSure!\nAlso please note that the particular signatures and implementation are\nopen to discussion. The key feature I'm trying to get with this is putting\nmiddleware after a match is found, and before the handler is called.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/293#issuecomment-332851651, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcO7udp_ul9Oy4DdBw7soGstOZmghks5sm6tSgaJpZM4PRbdT\n.\n. I would make the order apply in the order that myMux.AddMiddleware(mw) was\ncalled, which aligns with route definition (routes defined first take\nprecedence).\n\nOn Fri, Sep 29, 2017 at 4:23 AM Abdullah Saleem notifications@github.com\nwrote:\n\n@roobre https://github.com/roobre you are right about the routeLogger\nbeing created for each request which is a problem.\nas for your implementation can the for range that handles the middlewares\ncan be moved on to the Router ( Here\nhttps://github.com/gorilla/mux/blob/3f19343c7d9ce75569b952758bd236af94956061/mux.go#L245\n)?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/293#issuecomment-333101231, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcA0bWicOblNOMY2Y913rvvfNq-wKks5snNMrgaJpZM4PRbdT\n.\n. @Abdullah2993 Can you show a simple example of the benefits of your approach from an user API perspective?\n\nRight now, @roobre's approach\u2014scoping to (sub-)routers makes sense to me, and aligns with other libraries like chi.. Thanks Roberto.\nI'm pretty convinced that the router-scoped approach (as opposed to\nroute-scoped) is the best one here, so will start reviewing this during the\nweek. A good few examples in the README will go a long way too.\nOn Mon, Oct 2, 2017 at 5:55 PM Roberto Santalla notifications@github.com\nwrote:\n\nStatus update: I moved middleware chain building from ServeHTTP() to\nMatch().\nThis is because ServeHTTP() is called on the parent router, even if the\nmatch is a subrouter. See 9315e1c\nhttps://github.com/gorilla/mux/commit/9315e1c71fb892c302548df09295aecd0c2f5171\nfor details.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/293#issuecomment-333595443, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCOH1v1No1wr6XSSDSyQvp2Z8c5jks5soRWFgaJpZM4PRbdT\n.\n. Thanks Roberto!\n\nAs a heads up, I am on vacation at the moment\u2014without a \u201creal\u201d computer\u2014but\nwill try to get an initial first-pass review done between now and the end\nof next week!\nOn Tue, Oct 3, 2017 at 5:36 PM Roberto Santalla notifications@github.com\nwrote:\n\nStatus update: Test cases added, brief documentation included in README.md\nand doc.go.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/293#issuecomment-333862224, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMhmGtstUt4Vlxqo7k8J1PcvgqbGks5sokZhgaJpZM4PRbdT\n.\n. Sorry for the slow reply @roobe - catching up on issues.\n\nI'm not the original author for mux, so I can't explain precisely why it behaves that way.\nI'm OK with:\n\nMethod mismatch (not-found) returning false and setting matchError\nRoute not-found returning false and setting matchError to ErrMatchNotFound\n\nNotably, there may be valid cases where you still want middleware to execute when there is no match (logging all requests, for example!), so we should provide a way to account for that too.. Perfect - SGTM.\nOn Sun, Oct 29, 2017 at 4:22 PM Roberto Santalla notifications@github.com\nwrote:\n\nNo prob, I agree with you in both points. I think it's best if I create a\nnew PR for setting ErrMatchNotFound when falling back to NotFoundHandler,\nand then continuing on the middleware branch when it is merged. That should\navoid unnecessary conflicts. Are you okay with that?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/293#issuecomment-340311632, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcI0mw4ty-ZvntAMzizZYmaSpdNhUks5sxQi1gaJpZM4PRbdT\n.\n. Closed in #294.. >  Also it gives the API some parallelism with http.Handler and http.HandlerFunc: Same concept, but in different places. Other routers and middleware managers use the same strategy, as it is a simple way to keep complex middlewares tidy and clean.\n\nDo you have examples? I'm partial to chi, which has a Use((http.Handler) http.Handler) method on the router, but the concept of a Middleware interface seems less common.\nFor context: adding two methods is 100% more decision-making that a package user has to make, and adds to our already extensive package API. Thus, I'm pushing hard for utmost simplicity unless there's a clear case where the interface-based support makes sense. I can't see that it makes sense right now.. Still needs review, and I\u2019m just getting back from vacation. Soon!\nOn Sat, Nov 18, 2017 at 2:49 PM Ad van der Veer notifications@github.com\nwrote:\n\nAny progress on this? Would love to use this for a new project ;)\n\u2014\nYou are receiving this because your review was requested.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/294#issuecomment-345466567, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcH6mB6pICNIIx3a5cqCiw0s7sdS1ks5s3zTfgaJpZM4PTaEY\n.\n. @kisielk - let me know if you echo my thoughts here.. No inconvenience at all!\n\nOn Mon, Dec 11, 2017 at 4:59 AM Roberto Santalla notifications@github.com\nwrote:\n\nI'll address the changes listed above when I return from vacation. I'm\nsorry for the inconvenience :(\n\u2014\nYou are receiving this because your review was requested.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/294#issuecomment-350717459, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcF9qAba43ejVIg0EZcDxPGXHhsZMks5s_ScwgaJpZM4PTaEY\n.\n. @roobre - let me know if you need any help here. Would love to help get this merged in! \ud83d\ude4c\ud83c\udffc. @kisielk \n\nWithout the interface, we should just have (as the public API):\n// Takes a func (http.Handler) http.Handler\nroute.AddMiddleware(mw)\nThe interface we rally around is http.Handler rather than anything else.\nThere may be *some desire for a http.HandlerFunc option - \n// Takes a func (http.HandlerFunc) http.HandlerFunc\nrouter.AddMiddlewareFunc(mw)\n... but I'd rather tease that out by starting minimally.. Thanks for the update.\nI do understand your consternation here, but since we already have a widely\nused function signature in the wild + in-use elsewhere, pragmatism beats\nout purism.\nIf this were \u201cgreenfields\u201d, as it were, defining our own interface would\nmake more sense \ud83d\ude09\nOn Thu, Jan 4, 2018 at 8:33 AM Roberto Santalla notifications@github.com\nwrote:\n\nOk, I've made the Middleware interface private. This is because if, in\nthe future, we change our mind and decide to make it public, it will be a\nlot easier than if I just wipe it from existance:\n-\nThe middleware list would no longer be of type middleware, but a\n   function instead, which would require a dirty rewrite of the\n   addMiddleware method (we can easily store MiddlewareFuncs as middlewares\n   because MiddlewareFunc implements middleware, but the opposite would\n   be dirty).\n   -\nHaving a type named MiddlewareFunc instead of just Middleware would be\n   a bit confusing, and certainly problematic if in the future we wanted to go\n   back to both APIs.\nPlease tell me what you think about this. As always, let me kindly remind\nyou that this is, from my humble point of view, a mistake. The \"Interface\nplus function which implements the interface\" is a common pattern in go,\nand the idiomatic way of doing things, as we can clearly see in the\nnet/http design and implementation.\n\u2014\nYou are receiving this because your review was requested.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/294#issuecomment-355329898, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPNNMJaWzUcq9-19einykef2_lj9ks5tHP1YgaJpZM4PTaEY\n.\n. Plus, as you say: we can expose the interface (and the extra methods)\nwithout too much pain if there\u2019s demand.\n\nmux has a big API and thus the friction to add to it should grow over time\nin order to keep it digestible to users.\nOn Thu, Jan 4, 2018 at 9:07 AM Matt S matt@eatsleeprepeat.net wrote:\n\nThanks for the update.\nI do understand your consternation here, but since we already have a\nwidely used function signature in the wild + in-use elsewhere, pragmatism\nbeats out purism.\nIf this were \u201cgreenfields\u201d, as it were, defining our own interface would\nmake more sense \ud83d\ude09\nOn Thu, Jan 4, 2018 at 8:33 AM Roberto Santalla notifications@github.com\nwrote:\n\nOk, I've made the Middleware interface private. This is because if, in\nthe future, we change our mind and decide to make it public, it will be a\nlot easier than if I just wipe it from existance:\n-\nThe middleware list would no longer be of type middleware, but a\n   function instead, which would require a dirty rewrite of the\n   addMiddleware method (we can easily store MiddlewareFuncs as\n   middlewares because MiddlewareFunc implements middleware, but the\n   opposite would be dirty).\n   -\nHaving a type named MiddlewareFunc instead of just Middleware would\n   be a bit confusing, and certainly problematic if in the future we wanted to\n   go back to both APIs.\nPlease tell me what you think about this. As always, let me kindly remind\nyou that this is, from my humble point of view, a mistake. The \"Interface\nplus function which implements the interface\" is a common pattern in go,\nand the idiomatic way of doing things, as we can clearly see in the\nnet/http design and implementation.\n\u2014\nYou are receiving this because your review was requested.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/294#issuecomment-355329898, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPNNMJaWzUcq9-19einykef2_lj9ks5tHP1YgaJpZM4PTaEY\n.\n\n\n. Thanks for noting RE: vet. I couldn't see any relevant changes in the Go 1.6 release notes, but we'll see if it comes up again. I suspect it might be trying to overly-aggressively check whether Route exists as a top-level type (which it does not).. Good to review?\nOn Wed, Jan 10, 2018 at 2:38 AM Roberto Santalla notifications@github.com\nwrote:\nRebased to latest commits on master.\n\u2014\nYou are receiving this because your review was requested.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/294#issuecomment-356564135, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcB5KHrRtnDw4V6yspm9PjzjlKu1Oks5tJJMugaJpZM4PTaEY\n.\n. OK - I'm going to test this in an application I have running (hopefully tonight) so we can get this merged.\n\nExcited to land this.\n@kisielk - if you can review in the interim that'd be great!. OK: sanity checked locally and all works as expected, esp. around Subrouters. I'm going to put this in prod soon to expose some heap & goroutine profiles behind authentication, so timing is good!. Thanks for your work on this @roobre\u2014appreciate your responsiveness and patience!. Tagged in v1.6.1 - https://github.com/gorilla/mux/releases/tag/v1.6.1. See https://github.com/gorilla/mux/pull/332 for the docs fix.. I'll tag a new version w/ release notes soon (today). https://github.com/gorilla/mux/releases/tag/v1.5.0 done!. This is because loginHandler is called before mux is. Wrapping your handlers themselves will solve:\n```\nfunc main() {\n    httpListenAddr := fmt.Sprintf(\"0.0.0.0:3000\")\n    r := mux.NewRouter()\n    zRouter := r.PathPrefix(\"/z/{client_id:[-\\w]+}\").Subrouter()\n    zRouter.Handle(\"/recipes\", loginHandler(http.HandlerFunc(Handler)))\nif err := http.ListenAndServe(httpListenAddr, r); err != nil {\n    log.Fatalln(\"Unable to start the HTTP Server\")\n}\n\n}\n```. Thanks @mmdriley .  * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\nCommonly you'll see a LICENSES file or similar that references the licenses\nof other projects. Given that the license is included with a source\ndistribution (by nature of mux being a dependency, or vendored), then I'd\nsay that this isn't entirely necessary. Anyone who needs to build your\nproject has a copy of mux w/ its license.\n * Redistributions in binary form must reproduce the above\n\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\nSuggestion: a --copyright flag or way of showing the copyright notice +\nlicenses for all contributing projects. Look at how iOS and Android apps\nrecognize OSS libraries used for a good example.\nOn Fri, Sep 22, 2017 at 10:20 AM Dustin Graham notifications@github.com\nwrote:\n\nI'm beginning to work on an open source project that may pull in\ngorilla/mux.\nI'm not sure what that means from my end as far as keeping the copyright\nin compiled binaries? I think we are expecting to simply compile the app to\nlinux, mac, windows, and provide tagged downloads on github, as well as the\ngithub source.\nWhat does that mean we need to do in order to respect the bsd license on\ngorilla mux?\nThanks.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/298, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcAWeXQHUXux2mjADh75aNUTLGG8Wks5sk-xdgaJpZM4Pg_3f\n.\n. The mutex overhead is extremely minimal; some previous benchmarks show how\nfast the locking/unlocking is (https://github.com/gorilla/context/pull/10).\n\nFurther, mux on Go 1.7+ does not use gorilla/context with a global map.\nOn Fri, Sep 22, 2017 at 5:06 PM Vitold S notifications@github.com wrote:\n\nI think that using context without change contract may be a bottleneck.\nCould you explain more about mutex and blocking global context variable and\nmay be it a bottleneck in highload solutiuon? Thanks.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/299, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcINjjIgjmoecxTpP0n4o62d7dGxWks5slEuegaJpZM4PhXoO\n.\n. Pinging @kisielk, because I\u2019m away, but if it\u2019s critical I suggest updating\nyour dependency manifest to pin against the ref that resolves the bug\n(which is what makes pinning useful!).\nOn Thu, Oct 19, 2017 at 1:11 PM Steven Hartland notifications@github.com\nwrote:\nThis has hit us too, the current 1.5.0 release is totally broken for any\nusers that have Method based routing.\nIt appears to be fixed in master, but no release has been performed yet\nwhich means anyone updating using ^1.x... semantic versioning will end up\nwith broken apps.\nGiven this there really need to be 1.5.1 release urgently to address this.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/300#issuecomment-337876270, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcC2JR7kIHRG4XhRWGPLxfvtYxgfvks5sty5zgaJpZM4PqdDa\n.\n. Plan:\n\n\nAdd more test cases to the library for this - especially around\nSubrouters / PathPrefix cases, to see whether we can reproduce internally\nw/o user code\nIf  identifies issues, fix.\n\nThere are already a good number of tests for no. 1 so these reports are\nworrying, but definitely want to fix. I'll earmark some time tomorrow to\ntackle no. 1.\nOn Fri, Nov 3, 2017 at 11:23 AM Roberto Santalla notifications@github.com\nwrote:\n\nMaybe I can look into this if any of the affected users add some test\ncases. I just tweaked this code in #311\nhttps://github.com/gorilla/mux/pull/311, so it shouldn't be difficult\nfor me to fix this.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/300#issuecomment-341787868, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcN-TO4CmdI-Wj4fjkitvpRhKWsI4ks5sy1ovgaJpZM4PqdDa\n.\n. Closing this out.. I don\u2019t think this adds enough value to afford adding to the API surface.\n\nA PR to improve the docs on StrictSlash would be better.\nOn Mon, Oct 9, 2017 at 12:26 AM Omar A. Hachach notifications@github.com\nwrote:\n\nI've kept the StrictSlash function for backwards compatibility. The\nStrictRouting function is only there to serve as a clearer way to impose a\nstrict slash.\nIt does the opposite of StrictSlash.\n\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/302\nCommit Summary\n\nCreate StrictRouting function.\n\nFile Changes\n\nM mux.go https://github.com/gorilla/mux/pull/302/files#diff-0\n   (13)\nM mux_test.go\n   https://github.com/gorilla/mux/pull/302/files#diff-1 (74)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/302.patch\nhttps://github.com/gorilla/mux/pull/302.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/302, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcEuiicWFon6_yecu94tSisVWxb1Gks5sqVoTgaJpZM4Px5Pq\n.\n. Thanks for the detailed write-up: it helps a lot. The patch looks good to\nme; @kisielk as a second pair of eyes before merging.\nOn Wed, Oct 11, 2017 at 12:22 PM Paul B. Beskow notifications@github.com\nwrote:\nDevelopers can now extract the query templates and regexps from a router\nas lists of combined query pairs.\nDescription\nThe implementation returns lists of combined pairs of registered Queries;\nas templates or regexps. It was deemed more appropriate to return lists, at\nleast for regexps, rather than a joined string of all combined pairs, since\neach query pair is considered a separate matcher, e.g., if we have the\nfollowing: Queries(\"foo\", \"{v1}\", \"baz\", \"{v2}\"), when joined using\nregexps we would end up with: ^foo=(?P.)$,^baz=(?P.)$. The\nmultiple v0 entries might be confusing. For the query template, we could\nconsider joining, but even then it will be a bit strange, e.g.,\nfoo={v1},baz={v2}.\nMotivation and Context\nBeing able to extract all parts of a registered route, including queries,\ncan be very useful. In particular when generating REST API documentation.\nIn addition, it can be useful to determine that tests have been written for\nall registered routes; by matching recorded and registered routes with\ntheir various parts.\nHow Has This Been Tested (if appropriate)?\nAdded testQueriesRegexp and testQueriesTemplates methods and added\nqueriesTemplate and queriesRegexp fields to routeTest. All TestQueries\ncases are using this functionality.\nTypes of changes\n\nBug fix (non-breaking change which fixes an issue)\nNew feature (non-breaking change which adds functionality)\nBreaking change (fix or feature that would cause existing\n   functionality to change)\nRefactoring (non-breaking changes, no bug fixing, no new features)\nTesting (New unit/integration/performance tests)\n\nChecklist:\n\nI have updated the documentation accordingly.\nI have added tests to cover my changes.\n\nRelated tickets or issues:\nThis resolves issue #287 https://github.com/gorilla/mux/issues/287\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/304\nCommit Summary\n\nGetQueryTemplates and GetQueryRegexp extraction\n\nFile Changes\n\nM README.md https://github.com/gorilla/mux/pull/304/files#diff-0\n   (28)\nM mux_test.go\n   https://github.com/gorilla/mux/pull/304/files#diff-1 (588)\nM route.go https://github.com/gorilla/mux/pull/304/files#diff-2\n   (38)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/304.patch\nhttps://github.com/gorilla/mux/pull/304.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/304, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcH0xTE2I6GvnwjUr1pNouebnNj5eks5srIi9gaJpZM4P1KaM\n.\n. If @kisielk is OK with the API here then it\u2019s OK to merge.. .Vars is defined as a package-level function, not a method on *Router. Are\nyou also calling your Router \u201cmux\u201d and thus shadowing the import?\nOn Fri, Oct 13, 2017 at 1:37 PM Oytun \u00d6zdemir notifications@github.com\nwrote:\n../evaluator/builtins.go:319:37: mux.Vars undefined (type *mux.Router has\nno field or method Vars)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/305, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJa3xce6cALxOgi6zNVn0STBLxgMks5srz1zgaJpZM4P4TBc\n.\n. Is this your exact code? There is no \u201chttp\u201d package, only \u201cnet/http\u201d.\n\nThe code you posted would not generate this error. Can you post the code &\nthe full error, including the line number?\nOn Fri, Oct 13, 2017 at 11:09 PM Oytun \u00d6zdemir notifications@github.com\nwrote:\n\nYes. I already imported. And go get success.\nMy other test code same;\nimport (\n   \"http\"\n   \"github.com/gorilla/mux\"\n)\nfunc TestHandler(w http.ResponseWriter, r *http.Request) {\n  vars := mux.Vars(r)\n  w.WriteHeader(http.StatusOK)\n  fmt.Fprintf(w, \"Test Parameter: %v\\n\", vars[\"name\"])\n}\nfunc main(){\n      r := mux.NewRouter()\n      r.HandleFunc(\"/hello/{key}\", TestHandler)\n      srv := &http.Server{\n      Handler:      r,\n      Addr:         \"127.0.0.1:8000\",\n      WriteTimeout: 15 * time.Second,\n      ReadTimeout:  15 * time.Second,\n  }\nlog.Fatal(srv.ListenAndServe())\n}\nSame error: mux.Vars undefined (type *mux.Router has no field or method\nVars)\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/305#issuecomment-336555008, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNfNyQ7rgyfum8yeTIXK-t9sCfuOks5sr8NhgaJpZM4P4TBc\n.\n. I am OK with this, and this makes more sense than the other PR.\n\n1.5 has been around for a long while.\nOn Tue, Oct 17, 2017 at 10:37 PM Mike Busch notifications@github.com\nwrote:\n\nThis change drops support of go < 1.5. go1.4 has been officially\nunsupported https://golang.org/doc/devel/release.html#policy since\ngo1.6 was released 2016/02/17.\nThe PR was motivated by a bug I discovered, where req.RequestURI was\nreturning \"\", so my router was failing to route on the escaped path.\nVery open to thoughts and/feedback on how to proceed. Thanks!\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/306\nCommit Summary\n\nuse req.URL.EscapedPath() instead of getPath(req)\n\nFile Changes\n\nM mux.go https://github.com/gorilla/mux/pull/306/files#diff-0\n   (25)\nM regexp.go https://github.com/gorilla/mux/pull/306/files#diff-1\n   (6)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/306.patch\nhttps://github.com/gorilla/mux/pull/306.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/306, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcLbYkeXV5VmuwpF2TwqtYRUhSk8iks5stQ_8gaJpZM4P8yMy\n.\n. The docs state that the URL is parsed into this field, so should we not\nhandle that case?\n\nhttps://golang.org/pkg/net/http/#Request\n\nFor server requests the URL is parsed from the URI supplied on the\nRequest-Line as stored in RequestURI.\n\nThus, if req.URL.RequestURI() works, when does it behave differently from\nthe regular struct field?\nI\u2019d like to understand the fix before approving.\nOn Wed, Oct 18, 2017 at 12:48 AM Mike Busch notifications@github.com\nwrote:\n\n(sorry for the noise... I expected this to be ok on the older go versions)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/307#issuecomment-337398731, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNbQa5qMb8TNcFMnMuweOxRAjEE_ks5stS6TgaJpZM4P87E0\n.\n. Noted. Feel free to post back here if you need any help!\nOn Wed, Oct 18, 2017 at 1:44 PM Mike Busch notifications@github.com wrote:\n@elithrar https://github.com/elithrar I think this might be something\nin my service's tests. I'm going to close it.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/307#issuecomment-337564197, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcP8ChLGOwovJj9hoVFXgYp59qUkCks5steR-gaJpZM4P87E0\n.\n. This may be related to https://github.com/gorilla/mux/issues/300. Normal paths from the tests in the OP:\n\nfor i in `seq 20`; do curl http://localhost:8080/files/path/to/file.txt; done\n[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt[GET] path/to/file.txt%\nfor i in `seq 20`; do curl -XPOST http://localhost:8080/files/path/to/file.txt; done\n[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt%\nPaths noted as \"unexpected\" in the OP:\nfor i in `seq 20`; do curl -XPOST \"http://localhost:8080/files/path/to/./file.txt\"; done\n[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt%\n```\nre-directs at first due to the double slash.\nfor i in seq 20; do curl -L -XPOST \"http://localhost:8080/files/path/to//file.txt\"; done\n[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt[POST] path/to/file.txt% \n```\nI don't see the bug on the latest HEAD (65ec7248c53f499f6b480655e019e0b9d7a6ce11).. Very odd. Can you just have the handler log directly, hit it with Postman,\nand see what the server itself says?\nI suspect Postman has buggy output given that curl has no issue.\nOn Wed, Nov 29, 2017 at 11:23 PM Sergey Seleznev notifications@github.com\nwrote:\n\nI have this one, but it is more like request-response details:\n[image: image]\nhttps://user-images.githubusercontent.com/18219010/33418740-02848548-d5b0-11e7-96ce-f7e26f984251.png\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/308#issuecomment-348104431, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcDXBnn1Vgg23dpgr0X5A4L9U4OZnks5s7lgGgaJpZM4QFqAe\n.\n. @kisielk Correct, a 308 allows a retry w/ the same method, and a 301/302 must change to a GET on the subsequent (re-directed) request.\n\n308 isn't as widely supported on all clients, so this is a little tricky. This isn't so much \"broken\" as implicit. I also loathe \"more dials\" to configure things.\nPerhaps default to 308 (newer) and allow a hook to modify that if need be? RedirectHandler?. SGTM.\nWe should add this to the documentation for StrictSlash to make the\nbehavior clear to users.\nOn Fri, Dec 1, 2017 at 3:46 PM Kamil Kisiel notifications@github.com\nwrote:\n\nI'm inclined to leave it as it is. At least 301 is understood by all\nclients, and nothing bad will happen. If you have a client that's making\nPOST requests to a URL that results in a redirect, and they turn into GETs\nthen you could either:\na) Fix your request URL\nb) Configure your client to try the redirected URL with POSTs instead of\nswitching to GETs (it seems curl already does this).\nIf we switch it to 308, the only advantage is that you don't need to do a)\nor b), but the potential consequence is that some clients won't understand\nthe status code at all, and it could break some existing uses.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/308#issuecomment-348644162, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPLGjg8RrMNpv_pjgGa0T_IiG4kBks5s8I_bgaJpZM4QFqAe\n.\n. See PR https://github.com/gorilla/mux/issues/321\n\nClosing this out, but let me know if there are outstanding concerns.. Thanks for this. Let me see why gofmt is failing [only] on tip.. Rebase against master to pull in https://github.com/gorilla/mux/pull/312\nOn Fri, Nov 3, 2017 at 12:55 PM Roberto Santalla notifications@github.com\nwrote:\n\nI've added the matching route where none is expected but one is got. I've\nalso moved the last two test cases above the private functions, which I\nthink is more appropriate.\nThe go fmt issue with travis is bugging me a bit, but afaik it's not my\nfault. It appeared when I merged upstream :/\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/311#issuecomment-341810035, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcFRthFq0H5NDllXQu0ATJaDGYz6Sks5sy2-ggaJpZM4QRfiH\n.\n. Great idea, thanks @kisielk!. Tagged with v2 (aka \"hopes and dreams\"). Thanks @chrisdostert!. Go uses RE2 regular expressions, not PCRE.\n\nYou\u2019ll find that {8}+ is not a valid quantifier:\nhttps://regex101.com/r/GMwvYP/1\nOn Tue, Nov 21, 2017 at 4:19 AM Denis Sedchenko notifications@github.com\nwrote:\n\nReopened #316 https://github.com/gorilla/mux/issues/316.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/316#event-1351861319, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AABIcGzsjCWXpRRf-xjg3jYtexFPNw6Gks5s4r_agaJpZM4Qlv2J\n.\n. Thanks for the contribution @mtso!. You\u2019ll want to change \n\n\nfunc wrapHandler(h http.Handler) httprouter.Handle to return http.Handler instead, and use mux.Vars(r) to fetch params.\ncreate a new router via mux.Router()\nuse (e.g) Handle(\u201c/\u201c, yourFunc).Methods(\u201cGET\u201d) in place of your GET methods on the httprouter instance. (Let me know if any more questions; traveling but wanted to get you started). Can you show me what you\u2019ve tried so far?\nOn Thu, Nov 30, 2017 at 6:41 AM sttyru notifications@github.com wrote:\n\n\nThank you! But at now I can't to find an solution :(\nIf it's not too much trouble, can you to write a short example?\n/ I can't to rewrite an wrapHandler by your recommends./\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/319#issuecomment-348207473, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcA2FU4viDerOGWGWiGv4GwJvDw4fks5s7r6igaJpZM4Qwgaa\n.\n. Timing out. Please re-open if you have further questions!. \ud83d\ude4c\ud83c\udffc. Good catch. An empty slice vs. error is debatable; the error makes it clear, and the code to handle a nil slice vs. an explicit error is about the same. Nevertheless, it's part of the public API now, so it can't be changed.\n\nI'll make a plan to update the docs to include a route with a query-string.. You're running a version of Go older than 1.5 - which was when URL.EscapedPath was introduced. Go 1.5 was released in August 2015 (https://blog.golang.org/go1.5) and is no longer supported.\nI'd recommend uninstalling your system-provided Go and installing an up-to-date version via https://golang.org/doc/install. Also - b9f261986a88ce62bbca20af2ff2dcf1d46a8df8 - is not a valid commit ID\nwithin the mux repository.\nCan you make sure:\n\nYou're on master\nYou have done a go get -u github.com/gorilla/mux or a git pull\nThat you end up on the commit ID below:\n\n$ git rev-parse HEAD\n5ab525f4fb1678e197ae59401e9050fa0b6cb5fd\nOn Thu, Dec 21, 2017 at 1:56 PM Kamil Kisiel notifications@github.com\nwrote:\n\nWhere do you set up the routes in faas-swarm, where it doesn't work?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/325#issuecomment-353467506, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNZxIvOxk-sZ9GuaFWgbEbs3kdRgks5tCtQDgaJpZM4RKZOH\n.\n. @alexellis - did you manage to resolve this, or still seeing issues?. Ah - glad you managed to get it sorted!\n\nOn Tue, Jan 2, 2018 at 9:20 AM Alex Ellis notifications@github.com wrote:\n\nI am not sure what caused this but I suspect it may be related to the dep\nvendoring tool for go adding an old mux version somewhere in the vendor\nhierarchy.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/325#issuecomment-354820305, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcGrKMf1CDwBYDIvNSODQ7Q45_L4kks5tGmVGgaJpZM4RKZOH\n.\n. I think that\u2019s what we\u2019ll likely do. Once dep is in the official toolchain\nwe can also break out a v2.0 \ud83c\udf1f\nOn Sat, Jan 6, 2018 at 11:04 AM Roberto Santalla notifications@github.com\nwrote:\nIf Ubuntu LTS users are a concern, maybe we can wait to the release of\n18.04, which is scheduled for April iirc.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/326#issuecomment-355768170, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcP2PYyzyyX3R2F08Dc-oI8kYRJYdks5tH8PLgaJpZM4RQy8s\n.\n. I'm planning on doing this before the end of June.. See #391 . Do you have an example of what your custom handler would do here?\nOn Thu, Jan 4, 2018 at 3:23 PM Adam Talsma notifications@github.com wrote:\nIt would be really nice if we could supply our own Handler for strict\nslash redirects.\nhttps://github.com/gorilla/mux/blob/5ab525f4fb1678e197ae59401e9050fa0b6cb5fd/regexp.go#L293\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/327, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJ7ScUQl6Ndaudl-5g5Yxgs6E4Jvks5tHV2BgaJpZM4RT1ud\n.\n. Going to suggest that application-level middleware + context may be a better approach here.. Thanks for this Kamil! Would be nice for the both of us to continue to\nrefactor some of the internals: mux is a bit of a beast \ud83d\ude09\n\nOn Fri, Jan 5, 2018 at 10:41 AM Kamil Kisiel notifications@github.com\nwrote:\n\nMerged #328 https://github.com/gorilla/mux/pull/328.\n\u2014\nYou are receiving this because your review was requested.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/328#event-1411771668, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJJjGI9-oowYpPbb-GploqS-owCPks5tHmy8gaJpZM4RT3ix\n.\n. To be clear, it accepts (and returns) a *http.Request, not a *http.Handler (which would be a pointer to an interface): rarely useful.\n\nReturning the pointer is a common pattern to allow method chaining. You can ignore the returned variable, but you could also call mux.SetURLVars(r, vars).AddCookie(cookie).\n. Thanks @kisielk!. Note: potentially minor breaking change for some users.. Agree. I do like the code in the README as it's a very popular place for newcomers to land on, and is more readable than godoc.org in many cases (better for prose, links, etc.)\nI'd like to make time to use https://github.com/campoy/embedmd to help us here - we can run it in CI and build our README from {name}_example.go. Thoughts?. Appreciate the refactored PR:\n\nbut it does not show nor test route variables as far as I can see.\n\nIt does, as a black box. We create requests with our table of route\nvariables, and check that we get the expected response. You don\u2019t have to\nknow the internals of the handler here: I intentionally left it out in\norder to keep the example focused.\nI\u2019m OK with a longer PR, but I also want to make sure we\u2019re on the same\npage regarding beginner-friendless.\nOn Sat, Jan 27, 2018 at 5:46 AM P\u00e5l Marius Sivertsen \nnotifications@github.com wrote:\n\nI'm not sure I follow. Yes, the example do show how to use table-driven\ntesting, but it does not show nor test route variables as far as I can see.\nIn the current example there is a main function:\n// endpoints.gofunc main() {\n    r := mux.NewRouter()\n    // A route with a route variable:\n    r.HandleFunc(\"/metrics/{type}\", MetricsHandler)\nlog.Fatal(http.ListenAndServe(\"localhost:8080\", r))\n\n}\nThis shows how to use the MetricsHandler but the not source code. Since\nMetricsHandler is what we actually want to test, the source should be\nincluded as well. I'm guessing it would look something like this:\nfunc MetricsHandler(w http.ResponseWriter, r *http.Request) {\n  vars := mux.Vars(r)\n  typeVar, found := vars[\"type\"]\n  if !found {\n      // This should never happen as the Gorilla Mux should set it for us\n      panic(\"The request is missing path variable 'type'\")\n  }\n  switch typeVar {\n  case \"goroutines\", \"heap\", \"counters\", \"queries\":\n      w.WriteHeader(http.StatusOK)\n  default:\n      w.WriteHeader(http.StatusNotFound)\n  }\n}\nIf you then to run the example, you'll discover it does not compile and\nhas a bug when checking the response so I made a few adjustments:\npackage examples\nimport (\n  \"fmt\"\n  \"net/http\"\n  \"net/http/httptest\"\n  \"testing\"\n)\n// endpoints_test.go\nfunc TestMetricsHandler(t *testing.T) {\n  tt := []struct {\n      routeVariable string\n      shouldPass    bool\n  }{\n      {\"goroutines\", true},\n      {\"heap\", true},\n      {\"counters\", true},\n      {\"queries\", true},\n      {\"adhadaeqm3k\", false},\n  }\n-     for , t := tt {-       path := fmt.Sprintf(\"/metrics/%s\", t.routeVariable)+    for , data := range tt {+      path := fmt.Sprintf(\"/metrics/%s\", data.routeVariable)\n      req, err := http.NewRequest(\"GET\", path, nil)\n      if err != nil {\n          t.Fatal(err)\n      }\n  rr := httptest.NewRecorder()\n  handler := http.HandlerFunc(MetricsHandler)\n  handler.ServeHTTP(rr, req)\n\n  // In this case, our MetricsHandler returns a non-200 response\n  // for a route variable it doesn't know about.-               if rr.Code == http.StatusOK && !t.shouldPass {+       if (rr.Code == http.StatusOK) != data.shouldPass {\n      t.Errorf(\"handler should have failed on routeVariable %s: got %v want %v\",-             t.routeVariable, rr.Code, http.StatusOK)+               data.routeVariable, rr.Code, http.StatusOK)\n  }\n\n}\n}\nIf you then try running the test you'll see that MetricsHandler complains\nthat it can not find the type path variable.\nWhat I then did was:\n\nRemoved table-driven part of test for simplicity. Although it is an\n   excellent way to write tests, it has nothing to with path variables.\nAdd the source of what is actually being tested. MetricsHandler was\n   reanmed to VarLogger to make it more clear what is does.\nFixed syntax errors in test example\nFixed bug in test example\n\nAlternatively I could add the VarLogger handler to a mux.Router and test\nthis using mux.Router.ServeHTTP but I feel it's out of scope for the\nexample and unit test.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/342#issuecomment-360985957, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNUsQ297QybkBj2Yhvu1WiXkKbk-ks5tOyjDgaJpZM4RuBU7\n.\n. Note that mux does not use the global gorilla/context from Go 1.7 onwards,\nso context.ClearHandler is a no-op under those conditions.\n\nmux, by default, calls clearContext internally for versions of Go < 1.7.\nOn Tue, Jan 30, 2018 at 5:16 AM Jonas Svarvaa notifications@github.com\nwrote:\n\nOne or more examples in README should reflect this user (dev)\nresponsibility.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/343#issuecomment-361590129, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcApe1qwtwD2ocUMlBWzKSO-CEy5qks5tPxZCgaJpZM4RyT2l\n.\n. I'd suggest snapshotting your heap and goroutine profiles and seeing what's allocating or leaking. Useful resource if you're not familiar: https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/ @xolan . Do you want to attach middleware to a single route, as in your example, or\nto the router/subrouter? The latter is more common.\nOn Mon, Feb 12, 2018 at 7:13 AM Ilija Matoski notifications@github.com\nwrote:\nHow would someone best implement chainable middlewares?\nr := mux.NewRouter() r.HandleFunc(\"/test\", middleware1, middleware2,\nmiddleware3, finalHandler).Methods(\"GET\")\nWhat would be the best way to implement this?\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/344, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcEOwQ4oqHa8xRgOq-Ilj4jFUy2Ftks5tUFUFgaJpZM4SCUe8\n.\n. Yes, you can use .Use() on Routers/Subrouters.\n\nIf you need to wrap only a single route, you could:\n\nconfigure it as a sub router & call .Use()\nuse .Handle(\u201c/path\u201d, a(b(c(http.HandlerFunc(yourHandler))\nwrite a helper than abstracts the above.\nOn Mon, Feb 12, 2018 at 7:58 AM Ilija Matoski notifications@github.com\nwrote:\n\n\nSingle route only\nIf i need to attach to the subrouter I can use .Use to attach a middleware?\nOn Feb 12, 2018 16:57, \"Matt Silverlock\" notifications@github.com wrote:\n\nDo you want to attach middleware to a single route, as in your example,\nor\nto the router/subrouter? The latter is more common.\nOn Mon, Feb 12, 2018 at 7:13 AM Ilija Matoski notifications@github.com\nwrote:\n\nHow would someone best implement chainable middlewares?\nr := mux.NewRouter() r.HandleFunc(\"/test\", middleware1, middleware2,\nmiddleware3, finalHandler).Methods(\"GET\")\nWhat would be the best way to implement this?\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/344, or mute the thread\n<\nhttps://github.com/notifications/unsubscribe-auth/AABIcEOwQ4oqHa8xRgOq-\nIlj4jFUy2Ftks5tUFUFgaJpZM4SCUe8>\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/344#issuecomment-364966863, or\nmute\nthe thread\n<\nhttps://github.com/notifications/unsubscribe-auth/ABFi49ZbwvYAF5cx6-v9FPDX1AFjUwuGks5tUF9RgaJpZM4SCUe8\n.\n\n\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/344#issuecomment-364967352, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPA24xdd2XU1IeZVmJNGoVBTI17Oks5tUF-dgaJpZM4SCUe8\n.\n. Sorry, missed this reply.\n\nWhat is the intended behaviour you expect?. Whilst I\u2019m not opposed to this, can you explain the use-case more clearly?\nDoes the name not provide sufficient context here?\nOn Sat, Feb 17, 2018 at 10:48 AM Nathan McCloskey notifications@github.com\nwrote:\n\nThis PR exposes an ordered list of route param variable names. Existing\nAPIs return insufficient information to determine the order of vars in a\npath: mux.Vars() returns an unordered map, GetPathTemplate() returns an\nunparsed path template string.\n\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/345\nCommit Summary\n\nexpose ordered route param variable names\n\nFile Changes\n\nM route.go https://github.com/gorilla/mux/pull/345/files#diff-0\n   (16)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/345.patch\nhttps://github.com/gorilla/mux/pull/345.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/345, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcOfHD1Q4pMXgYe4fxnbgwmIEZeTnks5tVx7kgaJpZM4SJamb\n.\n. Can you show me a concrete example here, where unique names (which also\nrepresent function arguments) do not suffice?\n\nFor added context: mux has a large and useful API. Adding to that API\nincreases the learning curve & maintenance burden, and thus we can't always\naccept every feature request at face value. It seems that there's another\nway to achieve what you're after.\nOn Sun, Feb 18, 2018 at 10:39 AM Nathan McCloskey notifications@github.com\nwrote:\n\nA route path in general is an ordered sequence, and a name alone does not\nindicate the position in that sequence.\nA concrete example: mapping route params to function arguments.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/345#issuecomment-366537028, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMnwEMyjeXzNV0e1xPHu0MKwKrveks5tWG5egaJpZM4SJamb\n.\n. Hi @npgm - I don't think this makes sense to add to the API.\n\n\nThe name of the route variable provides sufficient context in nearly all cases: in your \"function argument\" example, names are useful. If you truly need ordering, you can use a naming scheme that covers this.\nSupporting the (very) narrow use-case of building routes via reflection is not worth the addition to the API\n*Route.GetPathTemplate can approximate this\n. This is normal. Keys in a form may not be unique, and so you get a slice of\nvalues.\n\nYou can default to checking only the first possible instance by using\nhttps://golang.org/pkg/net/http/#Request.FormValue - the docs explain the\nbehavior here.\nOn Mon, Feb 19, 2018 at 1:54 PM Nick Kotenberg notifications@github.com\nwrote:\n\nHere is an example. It does not feel right.\n[image: selection_018]\nhttps://user-images.githubusercontent.com/6416323/36398524-bd5b6e18-1584-11e8-9280-e1d11bfa87ec.png\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/347#issuecomment-366811692, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJDEf3WMM04nHzQVg4jxEQsklDtAks5tWe2SgaJpZM4SLJXk\n.\n. https://github.com/gorilla/mux/blob/master/README.md#middleware \ud83d\ude09\nOn Thu, Feb 22, 2018 at 4:06 AM Francis Sunday notifications@github.com\nwrote:\nMiddleware channing could be another way out, I want to know if gorilla\nMux does it out of the box\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/348#issuecomment-367660841, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCcaMF0IC9j5trYCNj_LXXt1VlRhks5tXVhHgaJpZM4SPKNT\n.\n. Thanks. . Can you please share your router code?\nOn Mon, Feb 26, 2018 at 12:09 AM Ankit Kumar notifications@github.com\nwrote:\nWhen I enable the StrictSlash mode then my CORS Middleware and preflight\nrequest handler has stopped working.\nSuppose my API end point is /api/user/{id}\nso if I make a request to /api/user/{id}/ then server is responding with\n405 Method not allowed\nif I make rerquest to /api/user/{id} then it is ok, and my CORS and\npreflight request handler works perfectly.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/351, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcFkEEcp4AR2b1jNdKPl2D5lMO2t1ks5tYmangaJpZM4SS0gL\n.\n. Slow reply; have been travelling.\n\nI was unable to replicate the issue here: r.StrictSlash does not change whether mux returns a 405 or not. \nAdapted (runnable) example):\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc main() {\n    r := mux.NewRouter()\n// Handle all preflight request\nr.Methods(\"OPTIONS\").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    // fmt.Printf(\"OPTIONS\")\n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, DELETE\")\n    w.Header().Set(\"Access-Control-Allow-Headers\", \"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, Access-Control-Request-Headers, Access-Control-Request-Method, Connection, Host, Origin, User-Agent, Referer, Cache-Control, X-header\")\n    w.WriteHeader(http.StatusNoContent)\n    return\n})\n\nr.StrictSlash(true)\n\nr.HandleFunc(\"/user/{role}\", handler).Methods(\"POST\")\n\nhttp.ListenAndServe(\"localhost:8000\", r)\n\n}\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"/user/{role}\")\n}\n```\nOutputs:\n```\n\u279c  ~/Desktop  curl -sv -X POST localhost:8000/user/admin 2>&1 | ag 'HTTP'\n\nPOST /user/admin HTTP/1.1\n< HTTP/1.1 200 OK\n\n\u279c  ~/Desktop  curl -sv -X GET localhost:8000/user/admin 2>&1 | ag 'HTTP'\n\nGET /user/admin HTTP/1.1\n< HTTP/1.1 405 Method Not Allowed\n\n\u279c  ~/Desktop  curl -sv -X OPTIONS localhost:8000/user/admin 2>&1 | ag 'HTTP'\n\nOPTIONS /user/admin HTTP/1.1\n< HTTP/1.1 204 No Content\n```\n\nCommenting out r.StrictSlash(true):\n```sh\n\u279c  ~/Desktop  curl -sv -X POST localhost:8000/user/admin 2>&1 | ag 'HTTP'\n\nPOST /user/admin HTTP/1.1\n< HTTP/1.1 200 OK\n\n\u279c  ~/Desktop  curl -sv -X GET localhost:8000/user/admin 2>&1 | ag 'HTTP'\n\nGET /user/admin HTTP/1.1\n< HTTP/1.1 405 Method Not Allowed\n\n\u279c  ~/Desktop  curl -sv -X OPTIONS localhost:8000/user/admin 2>&1 | ag 'HTTP'\n\nOPTIONS /user/admin HTTP/1.1\n< HTTP/1.1 204 No Content\n```\n\nSame responses. This is on the latest mux (HEAD) -\nsh\ngit rev-parse --short HEAD\n53c1911\n\nAs a further recommendation, the rs/cors package can handle this for you, and you can use it via r.Use(cors.Defaults().Handler) to get a secure CORS setup out-of-the-box.. This makes sense.\n```sh\n// Without r.StrictSlash(true)\n\u279c  ~/Desktop  curl -sv -X POST localhost:8000/user/admin/ 2>&1 | ag 'HTTP'\n\nPOST /user/admin/ HTTP/1.1\n< HTTP/1.1 405 Method Not Allowed\n\n// With r.StrictSlash(true)\n\u279c  ~/Desktop  curl -sv -X POST localhost:8000/user/admin/ 2>&1 | ag 'HTTP'\n\nPOST /user/admin/ HTTP/1.1\n< HTTP/1.1 301 Moved Permanently\n```\n\nThe r.Method(\"OPTIONS\") is matching first, because it specifies no route. This is normal behaviour given what you have configured.\nIf you implement your CORS requirements as middleware (which passes back to the router) - then -\n```sh\n// Without r.StrictSlash(true)\n\u279c  ~/Desktop  curl -sv -X POST localhost:8000/user/admin/ 2>&1 | ag 'HTTP'\n\nPOST /user/admin/ HTTP/1.1\n< HTTP/1.1 404 Not Found\n\n// With r.StrictSlash(true)\n\u279c  ~/Desktop  curl -sv -X POST localhost:8000/user/admin/ 2>&1 | ag 'HTTP'\n\nPOST /user/admin/ HTTP/1.1\n< HTTP/1.1 301 Moved Permanently\n```\n\nThe first case (without StrictSlash) 404's as no route matches the trailing slash, as expected.\nThe presence of an Origin request header does not impact the routing logic.\n. Closing as answered.. Closing as timed out.\nFor future readers: mixing applications that use the \"old\" pre Go 1.7 context implementation with r.Context() (which shallow clones the request, and thus changes the address) is not recommended.. You could implement this as middleware by calling route.GetMethods() and then setting the response header. Does that not achieve your need to dynamically set the header?\ne.g.\n```go\nfunc AutoCORS(next http.Handler) http.Handler {\n    fn := func(w http.ResponseWriter, r *http.Request) {\n        route := mux.CurrentRoute(r)\n        methods, err := route.GetMethods()\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n    w.Header().Set(\"Access-Control-Allow-Methods\", strings.Join(methods,\n        \",\"))\n    next.ServeHTTP(w, r)\n}\n\nreturn http.HandlerFunc(fn)\n\n}\n```. @fharding1 \nThinking on this more:\n\nYou'd probably need to build your own map of routes via Router.Walk\nWith that in hand, you'd likely want to match on prefix and then use middleware to handle OPTIONS requests\n\nI'd be open to a PR that can do this as a feature on Router.. That'd be great @fharding1 - if you can get a PR up, I'll do my best to be more responsive to review!. * You can use Route.SkipClean() to avoid cleaning a specific route - https://godoc.org/github.com/gorilla/mux#Route.SkipClean - there is also a similar method on Router\n The path cleaning code mirrors net/http - https://github.com/gorilla/mux/blob/master/mux.go#L439-L456 - and isn't something we can change. Most users do want mux to clean such paths, which is why we provide an escape hatch for the few cases where you may not.. I'm OK with a PR to use RawPath. Needs significant tests + must pass existing tests.. @chriskolenko - are you still interested in finishing this one off?. Timed out..     r.HandleFunc(\"/{path:js|js/lib}/{.}\", handler)\nWorks for me (note the named route variable) - to workaround your issue in\nthe short term. I suspect the issue is because multiple unnamed groups are\nambiguous, but need to confirm.\nOn Wed, Mar 21, 2018 at 6:20 PM opennota notifications@github.com wrote:\n\nWhat version of Go are you running?\ngo1.10 linux/amd64\nWhat version of gorilla/mux are you at?\n4dbd923\nhttps://github.com/gorilla/mux/commit/4dbd923b0c9e99ff63ad54b0e9705ff92d3cdb06\nDescribe your problem\n/ inside a variable regexp doesn't work.\nPaste a minimal, runnable, reproduction of your issue below\nhttps://play.golang.org/p/1gqiL9mvdBL\npackage main\nimport (\n  \"fmt\"\n  \"github.com/gorilla/mux\"\n  \"net/http\"\n  \"net/http/httptest\"\n)\nfunc handler(w http.ResponseWriter, r http.Request) {\n  fmt.Println(r.URL.Path)\n}\nfunc main() {\n  r := mux.NewRouter()\n  r.HandleFunc(\"/{js|js/lib}/{.}\", handler)\n  w := httptest.NewRecorder()\n  req, _ := http.NewRequest(\"GET\", \"/js/1.js\", nil)\n  r.ServeHTTP(w, req)\n  req, _ = http.NewRequest(\"GET\", \"/js/lib/2.js\", nil)\n  r.ServeHTTP(w, req)\n  req, _ = http.NewRequest(\"GET\", \"/js%2Flib/3.js\", nil)\n  r.ServeHTTP(w, req)\n}\nOut of the three requests only the first one hits the handler.\nIt would be good if {js|js/lib} just worked (or at least panicked in\nHandle/HandleFunc, as it doesn't do what the programmer might be expecting\nanyway).\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/358, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcKFQZ34Gjlx7aYBoRS5Qnm3sta5yks5tgvxegaJpZM4S2Tbz\n.\n. Does it work with my proposed approach? We received no response & timed the issue out as it was closer to a usability issue based on my reproduction. . Sure - what is your proposed, non-breaking fix?\n\nWithout names to assign to each route variable, you can\u2019t address them in\nthe mux.Vars(r) map.\nWe should improve the docs here regardless.\nOn Thu, Oct 18, 2018 at 8:20 PM opennota notifications@github.com wrote:\n\nIt's somewhat counter-intuitive. The user can't easily figure out that the\npattern which doesn't work without a name somehow works if there is a\nname. So yes, a usability issue.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/358#issuecomment-431232599, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcL_L9KkrXe5gYQ4UlCBFzWqxSZZ5ks5umUTogaJpZM4S2Tbz\n.\n. * You don't have any route vars. mux.Vars(r) prints out the route parameters, not POST form values. You want r.PostFormValue (and related methods) for that - https://golang.org/pkg/net/http/#Request.PostFormValue\n* You also don't need runtime.GOMAXPROCS(runtime.NumCPU()) - Go will do this by default since ~1.5.. https://godoc.org/github.com/gorilla/mux#Router.PathPrefix\n\n\n\nYou can use r.PathPrefix(\u201c/prefix\u201d).Subrouter() to create a subrouter that only has specific middleware applied.\n\n\nAlternatively, your middleware can take a list of paths to skip. . As mux is focused on routing requests, these methods don\u2019t make much sense, and are both fairly small. I should also note that both functions don\u2019t return the error and instead swallow it.\n\n\nhttps://github.com/gorilla/schema can do this out of the box, if needed.. If you use only the id query param, does that also work? Can you share a runnable example?. OK - so note that Route.Queries requires a match of all query parameters. If you have optional query parameters, that logic should belong in your handler.\nFrom the docs:\n\nThe above route will only match if the URL contains the defined queries values, e.g.: ?foo=bar&id=42. \n\nIf you have cases where only one is applied, you can match on that and then check the other via v := r.URL.Query() as you have used in your latest comment.\n. @brunovlucena - Request.URL will return a *url.URL - which you can then call Query() on.\nYou could get clever and use https://godoc.org/github.com/gorilla/mux#Route.GetQueriesTemplates to match the two.. Can you please show your code (a minimum runnable example), and the panic stack trace? If you can also follow the issue template it'd be appreciated.\n```\nWhat version of Go are you running? (Paste the output of go version)\nWhat version of gorilla/mux are you at? (Paste the output of git rev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\nDescribe your problem (and what you have tried so far)\nPaste a minimal, runnable, reproduction of your issue below (use backticks to format it)\n```. Thanks @fharding1 - can you add tests to this as well? . Thanks for the reminder. On my list for this week!. With the way it\u2019s been implemented, it doesn\u2019t need to be on the router at all.\nI had assumed it would be similar to NotFoundHandler, where it is a field on the Router, or a toggle (Boolean). I don\u2019t feel strongly either way. . Thanks for the contribution. Apologies for the slow responses. Right in the middle of changing jobs, so have been extremely busy!. I don't see any route variables in those routes: neither \"/cashdrawer\" nor\n\"/zebra\" have a route variable.\nIf the routes were \"/cashdrawer/{labels}\" - then you would expect to have\na route variable accessible via vars[\"labels\"].\nOn Fri, Apr 27, 2018 at 2:30 PM cybercrypt13 notifications@github.com\nwrote:\n\nWhat version of Go are you running? (Paste the output of go version)\n1.9.2\nWhat version of gorilla/mux are you at? (Paste the output of git\nrev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\n18fca31\nhttps://github.com/gorilla/mux/commit/18fca31550181693b3a834a15b74b564b3605876\nDescribe your problem (and what you have tried so far)\nI have server running but when I attempt the following:\nvars := mux.Vars(r)\nI get an empty map and attempting to println(vars) gives me a hex number\nand no map contents. My code looks exactly like your examples so confused\nas to what I might be doing wrong.\nPaste a minimal, runnable, reproduction of your issue below (use\nbackticks to format it)\n`\nfunc main() {\nrouter := mux.NewRouter()\nrouter.HandleFunc(\"/cashdrawer\", OpenCash).Methods(\"GET\")\nrouter.HandleFunc(\"/zebra\", PrintZebra).Methods(\"GET\")\nlog.Fatal(http.ListenAndServeTLS(\":8001\", \"cert.pem\", \"key.pem\", router))\n}\nfunc PrintZebra(w http.ResponseWriter, r *http.Request) {\nvars := mux.Vars(r)\nst := vars[\"labels\"]\nprintln(vars)\nprintln(vars[\"labels\"])\nif strings.TrimLeft(st, \" \") == \"\" {\nvar msg resp\nmsg.Status = \"Failure, no label sent.\"\nSendResponse(w, msg, 400)\nreturn\n}\n}\n`\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/367, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcO8PCk3oP6FHMDPN7shfHOgYyxyaks5tsyuCgaJpZM4TqecC\n.\n. - Mux stores route variables - e.g. variables in the path component of\nthe URI itself - in mux.Vars. Handling and matching on route variables is\nwhat a router like mux is useful for.\n- Query parameters aren't handled by mux (or most routers, to be clear) as\nthey are handled by the built-in r.ParseForm() and r.FormValue helpers on\nthe *http.Request\n\nHope that clarifies!\nOn Fri, Apr 27, 2018 at 3:19 PM cybercrypt13 notifications@github.com\nwrote:\n\nI guess I'm confused because I'm used to passing Get variables using ? and\n& to separate them. It appears this needs to have a separate route setup\nfor each set of variables that might be passed in?\nie: I had to change Postman to send my variable called \"labels\" through\nusing url/zebra/labels=hello instead of url/zebra?labels=hello\nA little confused there but changing it did make it work properly.\nThanks,\nGlenn\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/367#issuecomment-385002630, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCFx96ll1ug2yJrDcN37Q0Q8bUylks5tszcGgaJpZM4TqecC\n.\n. mux can definitely play part of building a RESTful API - e.g.\n\nr.Handle(\"/products/{id}\", UpdateProductHandler).Methods(\"PUT\")\nr.Handle(\"/products/{id}\", GetProductHandler).Methods(\"GET\")\nr.Handle(\"/products\", CreateProductHandler).Methods(\"POST\")\n... is exactly the use-case that mux can help with, by routing based on\npath, method and injecting route params (e.g. the \"id\") into your handler.\nOn Fri, Apr 27, 2018 at 3:36 PM cybercrypt13 notifications@github.com\nwrote:\n\nYeah, I was trying to setup a REST server and might have chosen the wrong\npackage. Sorry for the confusion.\nGlenn\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/367#issuecomment-385007738, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNL0T980VfB7TZL8Npe5f62_xM_7ks5tszrpgaJpZM4TqecC\n.\n. Can you show the code you've attempted? You can create a Subrouter with a PathPrefix - e.g.\n\ngo\nsubrouter := router.PathPrefix(\"/prefix\").Subrouter(). How are you making requests? e.g. another Go program?\nOn Mon, Apr 30, 2018 at 9:27 AM Emmanuel Vlad notifications@github.com\nwrote:\n\nWhat version of Go are you running? go1.9.4 darwin/amd64\nWhat version of gorilla/mux are you at? b57cb16\nhttps://github.com/gorilla/mux/commit/b57cb1605fd11ba2ecfa7f68992b4b9cc791934d\nDescribe your problem\nStrictSlash works partially, it enters in the route Handler but the body\nis empty.\nResults:\nGET /test BODY { \"something\": \"something\" }\nit returns \"Nice\", that means the body is not empty\nGET /test/ BODY { \"something\": \"something\" }\nit returns nothing, you can see error EOF in the logs\nTry the code below\nPaste a minimal, runnable, reproduction of your issue below\npackage main\nimport (\n  \"encoding/binary\"\n  \"encoding/json\"\n  \"fmt\"\n  \"net/http\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n\"github.com/gorilla/mux\"\n)\nfunc main() {\n  router := mux.NewRouter()\nrouter.StrictSlash(true)\nrouter.HandleFunc(\"/test\", func(w http.ResponseWriter, r *http.Request) {\n      var body map[string]interface{}\n  if err := json.NewDecoder(r.Body).Decode(&body); err != nil {\n      fmt.Println(err)\n      return\n  }\n  fmt.Fprintf(w, \"Nice\")\n\n})\n  http.ListenAndServe(\":\"+port, router)\n}\nHave a good day! :)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/369, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCKfWGkZ0kChGEHbDLlxudwxZuW2ks5ttztsgaJpZM4Ts2py\n.\n. Unable to reproduce - slightly modified to log requests:\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc LogRequest(h http.Handler) http.Handler {\n    fn := func(w http.ResponseWriter, r *http.Request) {\n        log.Printf(\"method: %s | url: %s\", r.Method, r.URL.String())\n        h.ServeHTTP(w, r)\n    }\nreturn http.HandlerFunc(fn)\n\n}\nfunc main() {\n    router := mux.NewRouter()\nrouter.StrictSlash(true)\nrouter.Use(LogRequest)\n\nrouter.HandleFunc(\"/test\", func(w http.ResponseWriter, r *http.Request) {\n    var body map[string]interface{}\n\n    if err := json.NewDecoder(r.Body).Decode(&body); err != nil {\n        http.Error(w, err.Error(), 400)\n        return\n    }\n    fmt.Fprintf(w, \"body: %s\\n\", body)\n})\n\nlog.Fatal(http.ListenAndServe(\"localhost:8000\", router))\n\n}\n```\nRequest:\nsh\n\u279c  ~/Desktop  go run body.go\n2018/04/30 13:58:11 method: POST | url: /test\nOutput:\nsh\n\u279c  ~/Desktop  curl -X POST localhost:8000/test --data '{\"hello\":\"world\"}'\nbody: map[hello:world]\nNote the body: map[hello:world] in the response body returned by curl, as expected.. Correct, it does not. A POST request that receives a HTTP 301 / 302 will be followed up as a GET, which follows HTTP semantics.\nA HTTP status of 307 would instruct the client to follow up with a POST and preserve the body.. Just recalled that we did document this a while ago: https://godoc.org/github.com/gorilla/mux#Router.StrictSlash (in c572efe4)\n\nThe re-direct is a HTTP 301 (Moved Permanently). Note that when this is set for routes with a non-idempotent method (e.g. POST, PUT), the subsequent re-directed request will be made as a GET by most clients. Use middleware or client settings to modify this behaviour as needed. . Here's middleware that you can use to re-write 301 && 302 to 307 && 308 \n\n```go\ntype ResponseWriter struct {\n    http.ResponseWriter\n    status               int\n    retainRedirectBodies bool\n    wroteHeader          bool\n}\nfunc NewResponseWriter(w http.ResponseWriter, retainRedirectBodies bool) *ResponseWriter {\n    return &ResponseWriter{ResponseWriter: w, retainRedirectBodies: retainRedirectBodies}\n}\nfunc (w *ResponseWriter) Status() int {\n    return w.status\n}\nfunc (w *ResponseWriter) Write(p []byte) (n int, err error) {\n    if !w.wroteHeader {\n        w.WriteHeader(http.StatusOK)\n    }\nreturn w.ResponseWriter.Write(p)\n\n}\nfunc (w *ResponseWriter) WriteHeader(code int) {\n    if w.retainRedirectBodies {\n        switch code {\n        case http.StatusPermanentRedirect:\n            code = 308\n        case http.StatusTemporaryRedirect:\n            code = 307\n        }\n    }\nw.ResponseWriter.WriteHeader(code)\nif w.wroteHeader {\n    return\n}\nw.status = code\nw.wroteHeader = true\n\n}\nfunc RetainBodyOnRedirect(h http.Handler) http.Handler {\n    fn := func(w http.ResponseWriter, r *http.Request) {\n        wr := NewResponseWriter(w, true)\n        h.ServeHTTP(wr, r)\n    }\nreturn http.HandlerFunc(fn)\n\n}\n```\nThen just add it to your middleware stack:\n```go\n    router := mux.NewRouter()\nrouter.StrictSlash(true)\nrouter.Use(RetainBodyOnRedirect)\n\n```\nHope that helps. Closing this, but re-open if you have any issues or questions!. Ah, yes. Will fix.\nOn Mon, Apr 30, 2018 at 9:23 PM Kamil Kisiel notifications@github.com\nwrote:\n\n@kisielk commented on this pull request.\nIn route.go\nhttps://github.com/gorilla/mux/pull/370#discussion_r185164491:\n\n@@ -43,6 +43,8 @@ type Route struct {\n  buildVarsFunc BuildVarsFunc\n }\n\n+// SkipClean bypasses cleaning the path, which includes removing duplicate\n+// slashes and URL encoding.\nThat's actually not what this function does. It reports whether the\nSkipClean option is enabled for this route.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/370#pullrequestreview-116499538, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcIElAtZT-Z9dkWF3ZuKFJ5g2s8nCks5tt-MwgaJpZM4Ttg9t\n.\n. Fixes in https://github.com/gorilla/mux/pull/375. This won't be specifically related to gorilla/mux, but in an effort to help:\n\n\nWhat does entr make restart do?\nWhere do you specifically kill the go process?\nHave you considered using https://github.com/cespare/reflex ?. (Closing as it's not a mux-related issue, but happy to answer any questions). Mirrors what I\u2019m seeing.\n\nmux.SetURLVars uses the request context directly, and thus doesn\u2019t rely on\na Router instance.\nThe URL parsing into vars does (as expected) require a Router instance.\nOn Sat, May 12, 2018 at 11:57 AM Kamil Kisiel notifications@github.com\nwrote:\n\nI\u2019m just reading this off my phone so I could be wrong, but it seems in\nyour test you never actually instantiate a mux, you\u2019re just hanging the\nhandler off the http recorder.\n\nOn May 12, 2018, at 10:04, Sean Walberg notifications@github.com\nwrote:\nI changed my tests to set the vars directly like in #342 and it passes:\npackage main\nimport (\n\"fmt\"\n\"github.com/gorilla/mux\"\n\"net/http\"\n\"net/http/httptest\"\n\"testing\"\n)\nfunc TestMetricsHandler(t *testing.T) {\ntt := []struct {\nrouteVariable string\nshouldPass bool\n}{\n{\"goroutines\", true},\n{\"heap\", true},\n{\"counters\", true},\n{\"queries\", true},\n{\"adhadaeqm3k\", false},\n}\nfor _, tc := range tt {\npath := \"whocares\"\nreq, err := http.NewRequest(\"GET\", path, nil)\nif err != nil {\nt.Fatal(err)\n}\nreq = mux.SetURLVars(req, map[string]string{\n\"type\": tc.routeVariable,\n})\nrr := httptest.NewRecorder()\n/ Appears we can call it directly if we want?\nhandler := http.HandlerFunc(MetricsHandler)\nhandler.ServeHTTP(rr, req)/\nMetricsHandler(rr, req)\nexpected := fmt.Sprintf(\"Type: %v\", tc.routeVariable)\nif rr.Body.String() != expected {\nt.Errorf(\"handler should have failed on routeVariable %s: got %v want\n%v\",\ntc.routeVariable, rr.Body.String(), expected)\n}\n}\n}\nCan you elaborate on comments in #342? My understanding is \"yes you can\nuse mux.SetURLVars but you should really do it the way I've shown\" which I\nprefer, but can't get to work.\nThanks!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/373#issuecomment-388575681, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcOws8EcHTZQ7EWvl11cBOIFBWC9aks5txzB9gaJpZM4T8cnN\n.\n. Thanks for this @swalberg.\n\nWe'd eventually like to make our README examples testable via something like embedmd, which will help address this.. @ashanbrown - it'd be great if you can ensure the test cases capture all of the reports here?\n\nThe test case currently addresses your case, where a duplicate router prevents middleware from running on subrouters\nIt's not clear that @tkinz27's case is the same, where a handler that conflicts with a prefixed subrouter doesn't run.\n\nTest cases that capture these would be ideal.. See #418. Note that 418 will not run middleware on every request, which is different from what this PR aimed to achieve. I'm open to commentary / review on 418.. Thanks for the report ribice. I was able to replicate this. \nNext steps:\n\nAdd a (failing) test - TestPathPrefix_LeadingCharacters (test underscores, hyphens, etc. for completeness)\nInvestigate why *Route.addRegexpMatcher - https://github.com/gorilla/mux/blob/e3702bed27f0d39777b0b37b664b6280e8ef8fbf/route.go#L176 - is failing to either create the match, or why it's not being matched.\n\nI'm tied up right now @ribice, but if you want to take a stab (creating the test would be a good first test) we'd appreciate it.. @aswinmprabhu Can you show me your \"working fine\" example?. I've taken a look and your example works as expected for me. It's been a while since I originally tested, and thus I'm unsure whether my repro was the same.\nAdding tests with leading underscores to the test suite did not induce a failure.\n@ribice - can you reconfirm this, and include how you're testing from the client side? I'm going to close this out as invalid for now.\n. @pierreprinetti - we're looking at expanding middleware to run even without a match, as per https://github.com/gorilla/mux/pull/378\nIf you'd like to give that PR a cursory review/feedback, I'd appreciate. Currently traveling and may not have time to address for a few weeks.. Let\u2019s definitely document that against the middleware. There are cases\nwhere you may not want to expose routes via CORS, and that seems like a\nsensible compromise without enabling too much magic.\nOn Thu, May 24, 2018 at 8:54 AM Pierre Prinetti notifications@github.com\nwrote:\n\n@elithrar https://github.com/elithrar Thanks for the fast response!\nJust one thing:\nWith the current code, setting \"OPTIONS\" explicitly as a verb when\nregistering a route will have the effect of allowing the\nCORSMethodMiddleware to handle it.\nI think it's a totally valid solution! If this is the intended behaviour?\nIf it is, then maybe we could add a short line in the docs about it.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/381#issuecomment-391623390, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCSAERMIqCzSVlg9-ES5Toi7e7jvks5t1mcbgaJpZM4UKzLf\n.\n. Can you post a reproducible example, and include what your requests are, and what errors are returned?. Yes: you need to explicitly allow the origin by adding an Access-Control-Allow-Origin header, as per the error message. localhost is not a valid origin.\n\nI recommend taking a look at https://github.com/rs/cors. The middleware here is designed to dynamically handle the Methods you add to a route, which other middleware can't easily do without integrating into mux.\nYour application doesn't respond with the ACAM header unless you explicitly ask the route to handle OPTIONS requests.\n(Closing this as we generally agreed on leaving as-is; happy to answer questions but best to open a new issue in future). Thanks for the feedback Pierre. If we see a few more reports we can revisit\nthis conversation.\nOn Mon, Sep 3, 2018 at 6:26 AM Pierre Prinetti notifications@github.com\nwrote:\n\nI'm closing this as #381 https://github.com/gorilla/mux/issues/381 has\nbeen identified as a wontfix. Please consider reusing this code if the CORS\nmiddleware discussion comes up again.\nIn the meantime, I have implemented a custom solution in the codebase I\nwas working on, as the API of this specific feature in mux is a bit too\nmagic for me.\nThank you!\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/382#issuecomment-418114983, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcOXxvC6jgG0jgTR7nMKRF8A3ebg8ks5uXS4HgaJpZM4UNiru\n.\n. I'm OK to merge this. It will require:\n\n\nA minor version bump (tagged as such)\nA commit message that clarifies this - \n\nsummary: getHost() now returns full host & port information. \nfull commit message: Previously, getHost only returned the host. As it now returns the port as well, any .Host matches on a route will need to be updated to also support matching on the port for cases where the port is not 80 (scheme == \"http\").\n. I'm open to a PR for that.\nOn Tue, Feb 12, 2019 at 10:29 AM M@ notifications@github.com wrote:\n\nTracking down why my apps suddenly stopped doing host matching properly,\nand stumbled onto this. Seems like a big backward-breaking change for a\nminor release. At the very least, when the .Host() contains just a host,\nand not a port, then hostname:* should be assumed, I'd think.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/383#issuecomment-462877858, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBssUbxHGPjewAPXr-5-Vk1l1Eclks5vMwgagaJpZM4UQJkz\n.\n. Update the schemes comment.\n\nI am reticent to add a new method to the API with a similar name. It will\nbe confusing and the benefit seems minimal.\nGiven the risk of breaking existing users, it makes sense to hold off until\na potential v2.\nOn Tue, May 29, 2018 at 6:39 PM santsai notifications@github.com wrote:\n\n@elithrar https://github.com/elithrar Do you mean to update the\n.Schemes() comment or to do it only when some flag is enabled?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/384#issuecomment-392869825, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcLofxZwmKtwvSbGkqUH5GER8BywHks5t3Ye2gaJpZM4UQaO8\n.\n. I've marked this as v2 - which we can review as part of #130 at \"some point\" in the future.\n\n. I'm happy to do that. I can update those PRs tonight to standardize:\n\nUpdate LICENSE files to say \"The Gorilla Authors\"\nAdd an AUTHORS file to list contributors.\n\nI'll do this for all of the major projects (mux, sessions, securecookie, csrf, context, handlers, schema) and then the long tail on an as-needed basis.\n(I guess you can tell where I work now?). Great idea, and definitely agree. Let me think on that and draft up what\nthe API would look like under that approach.\nNeed to think about inheritance/parent-child relationships between a router\n/ sub-routers, etc.\nThinking out loud: Having a Router return a \u201cimplicit\u201d Route would\nsupport method chaining, and that implicit route would simplify internals\ntoo.\nOn Fri, Jun 8, 2018 at 8:15 AM Kamil Kisiel notifications@github.com\nwrote:\n\nOne thing which I think would help reduce the size of the mux API by\nroughly half is if the Router / Route duality was eliminated. They both\nhave roughly the same methods, with just a few extras on Router. We\nshould evaluate what's strictly necessary to have only once at the Router\nscope and then just put everything else on Route. The Router could have\ntop-level Route for the root path and then a tree below that.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/387#issuecomment-395792994, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMxbwm9uiLyQk8u7gtoWDXSBl9LGks5t6pUGgaJpZM4UgeL_\n.\n. Agree. Further, one of the friendliest features of mux is that you can swap from net/http's ServeMux to mux.Router easily, since the Handle and HandleFunc arguments are the same.\n\nPer-route middleware is often a mistake, especially for security and logging. Log at the router level, and apply security features at the SubRouter level to prevent \"missing\" applying to a route. It would also be hard to express the default - HandleFunc(\"/path\", nil, myHandler) would be more common than the per-route middleware use-case.. Thanks @jwilner - \n\nI agree that the API has grown, although some of that flexibility is often why users leave the std. lib (i.e. as they outgrow it)\nI'd argue that fixing each handler to a single method promotes repetition and doesn't make things much clearer - there are other libraries that promote the func(method string, h http.Handler[Func]) signature as first-class. If users prefer that, it probably makes sense for them to use those libraries over mux.\nI am for making sure that method chaining works easily - e.g. methods should all return a *Route such that you can either chain more specific matching logic, or build your own on top.\nI don't think breaking everything is the right move (also see no. 2) - a clear migration path is key. Yes, mux' API has grown a little larger than anticipated - such is the life of any widely used software project - but each addition has often been rational at the time. The bar for adding to the API has also increased over time - dramatically (I think we say \"no\" a lot more now).\n\nCritically:\n\nI think a lot of the current accessories that go beyond path and method -- scheme, host, header matching -- get away from that goal, are comparatively unused, and introduce a whole ton of complexity to the internal logic.\n\nI'd want to be careful about assuming this! In fact, I'm working on a project that can help quantify the methods-in-use by importers, so that we don't have to make assumptions here.. Please share your code. . Your package should be package main if it has a main() function.\nOn Mon, Jun 11, 2018 at 12:23 AM ajay-aravind notifications@github.com\nwrote:\n\npackage http_muxer\nimport (\n\"log\"\n\"net/http\"\n\"github.com/gorilla/mux\"\n)\nfunc main() {\nr := mux.NewRouter()\nr.HandleFunc(\"/\", HomeHandler)\n// r.HandleFunc(\"/products\", ProductsHandler)\n// r.HandleFunc(\"/articles\", ArticlesHandler)\nhttp.Handle(\"/\", r)\nlog.Fatal(http.ListenAndServe(\":8000\", r))\n}\nfunc HomeHandler(w http.ResponseWriter, request *http.Request) {\nw.Write([]byte(\"Got request on /\"))\n}\n// func ProductsHandler(responce http.ResponseWriter, request\nhttp.Request) {\n// responce.Write([]byte(\"Got a request on /products\"))\n// }\n// func ArticlesHandler(responce http.ResponseWriter, request\nhttp.Request) {\n// responce.Write([]byte(\"Got a request on /articles\"))\n// }\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/388#issuecomment-396146858, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcLO6aR2pvGLS8ENjvmunuyVanMeWks5t7hrcgaJpZM4Uh1IL\n.\n. Thanks for the report.\n\nAre you interested in PR\u2019ing a failing test (first), and then we can look\nto resolve?\nOn Thu, Jul 5, 2018 at 4:45 PM Filip Stanis notifications@github.com\nwrote:\n\nWhat version of Go are you running? (Paste the output of go version)\ngo version go1.9.4 linux/amd64\nWhat version of gorilla/mux are you at? (Paste the output of git\nrev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\ncb46983\nhttps://github.com/gorilla/mux/commit/cb4698366aa625048f3b815af6a0dea8aef9280a\nDescribe your problem (and what you have tried so far)\nIt seems that creating a Subrouter to filter out methods doesn't work.\n300 https://github.com/gorilla/mux/issues/300 is possibly related.\nPaste a minimal, runnable, reproduction of your issue below (use\nbackticks to format it)\nfunc main() {\n  r := mux.NewRouter().Methods(\"POST\").Subrouter()\n  r.Path(\"/test\").Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))\n  http.Handle(\"/\", r)\n  http.ListenAndServe(\":8080\", nil)\n}\nNavigating to http://localhost:8080/test returns an empty page.\nCompare with:\nfunc main() {\n  r := mux.NewRouter()\n  r.Methods(\"POST\").Path(\"/test\").Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))\n  http.Handle(\"/\", r)\n  http.ListenAndServe(\":8080\", nil)\n}\n...where it returns 405.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/389, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBPoC-Au9VRD8yvLbvhoht8X0EFqks5uDqUrgaJpZM4VEr91\n.\n. Thanks @fstanis - I'm pretty swamped right now but the test is helpful. Going to dive a little deeper later this week.. Failing tests: https://travis-ci.org/gorilla/mux/jobs/400834766#L521-L529\n\nsh\n--- FAIL: TestSubRouter (0.00s)\n    mux_test.go:1680: () Should not match:\n        Route: &Route{matchers:[]matcher{&routeRegexp{template: \"/foo/\", regexpType: 0, options: {false false}, regexp: regexp.MustCompile(\"^/foo/$\"), reverse: \"/foo/\", varsN: [], varsR: []}}\n        Request: &http.Request{Method:\"GET\", URL:(*url.URL)(0xc42039e100), Proto:\"HTTP/1.1\", ProtoMajor:1, ProtoMinor:1, Header:http.Header{\"User-Agent\":[]string{\"Go-http-client/1.1\"}}, Body:http.noBody{}, GetBody:(func() (io.ReadCloser, error))(nil), ContentLength:0, TransferEncoding:[]string(nil), Close:false, Host:\"localhost\", Form:url.Values(nil), PostForm:url.Values(nil), MultipartForm:(*multipart.Form)(nil), Trailer:http.Header(nil), RemoteAddr:\"\", RequestURI:\"http://localhost/foo/\", TLS:(*tls.ConnectionState)(nil), Cancel:(<-chan struct {})(nil), Response:(*http.Response)(nil), ctx:context.Context(nil)}\n        Vars: map[]\n    mux_test.go:1680: () Should not match:\n        Route: &Route{matchers:[]matcher{&routeRegexp{template: \"/foo/\", regexpType: 0, options: {false false}, regexp: regexp.MustCompile(\"^/foo/$\"), reverse: \"/foo/\", varsN: [], varsR: []}}\n        Request: &http.Request{Method:\"GET\", URL:(*url.URL)(0xc42039e100), Proto:\"HTTP/1.1\", ProtoMajor:1, ProtoMinor:1, Header:http.Header{\"User-Agent\":[]string{\"Go-http-client/1.1\"}}, Body:http.noBody{}, GetBody:(func() (io.ReadCloser, error))(nil), ContentLength:0, TransferEncoding:[]string(nil), Close:false, Host:\"localhost\", Form:url.Values(nil), PostForm:url.Values(nil), MultipartForm:(*multipart.Form)(nil), Trailer:http.Header(nil), RemoteAddr:\"\", RequestURI:\"http://localhost/foo/\", TLS:(*tls.ConnectionState)(nil), Cancel:(<-chan struct {})(nil), Response:(*http.Response)(nil), ctx:context.Context(nil)}. #422 should resolve this and rationalize Subrouter configuration propagation.. See https://github.com/gorilla/mux/pull/422. You\u2019ll need to:\n\nupdate travis.yml to remove versions < 1.7 \nupdate documentation to make it clear that clearing the context only applies when using > Go 1.7. @fharding1 Did you want to make the adjustment here as per @flibustenet's comment?. It would provide Module support before the change.\n\nI don\u2019t think it\u2019s explicitly required, but I hadn\u2019t seem acknowledgement\neither way.\nOn Tue, Aug 28, 2018 at 7:18 AM Franklin Harding notifications@github.com\nwrote:\n\nI'm not sure what he means, why is it required?\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/391#issuecomment-416601965, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcKq7tfJXNlyJiZ29grEXjcU_kwf7ks5uVVEdgaJpZM4VIfhX\n.\n. Thanks for the report. I don't have time to look at this in-depth until later this week (at best), so if you're interested in helping fix it, writing:\n\n\nA failing test case (cases)\nA PR to address that test case\n\n... would be super helpful.. The best way to \u201cstore\u201d values in the request is in the context.Context -\naccessed via Request.Context() - which is what WithContext() enables.\nOn Tue, Aug 7, 2018 at 9:38 PM Matej Kramny notifications@github.com\nwrote:\n\nAha, sorry. The reason I'm tracking the addresses is that the context\npackage uses them (here\nhttps://github.com/gorilla/context/blob/master/context.go#L15) to store\ncontext data.\nIn my effort to find and recover some data from the (logging) middleware\nit would need to keep the same address.\nIt makes sense that if mux uses WithContext, then the gorilla/context\npackage won't work with it. I will look into removing gorilla/context in\nfavour of the new way.\nPS: since WithContext is passed down the middleware chain, it won't be\npossible for any middleware at the top to find something like user ID being\nstored in middleware that happens afterwards. Is there any good way to do\nthis?\nMany thanks!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/395#issuecomment-411264881, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcI4F4KntRAT-2ANKekMh6vFtY0Ssks5uOk8cgaJpZM4VxuK0\n.\n. Closing as answered.. What is the curl command you are running?\n\ncurl -sv yoururl should return a HTTP 405.\nOn Mon, Aug 27, 2018 at 11:57 PM Rishubh Jain notifications@github.com\nwrote:\n\nI have defined a REST ENDPOINT,\nroute.Route{\n          Name:         \"GetRequest\",\n          Method:       \"GET\",\n          Pattern:      \"/requesturl\",\n          Version:      1,\n          HandlerFunc:  getRequestHandler,\n      },\nIf I hit a POST request instead of GET request to this URL via curl I dont\nget any response.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/397, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNJMZ6LmeTx6vCAyKkZ-LVrI6oZfks5uVOnVgaJpZM4WPBZS\n.\n. Please post a minimal, runnable example and fill out the issue template:  https://github.com/gorilla/mux/blob/master/ISSUE_TEMPLATE.md. e.g.\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"gorilla!\")\n}\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/requesturl\", handler).Methods(\"GET\")\nhttp.ListenAndServe(\"localhost:8000\", r)\n\n}\n```\nHTTP 405 on POST:\n```sh\n\u279c  ~  curl -XPOST -sv localhost:8000/requesturl\n   Trying 127.0.0.1...\n Connected to localhost (127.0.0.1) port 8000 (#0)\n\nPOST /requesturl HTTP/1.1\nHost: localhost:8000\nUser-Agent: curl/7.47.0\nAccept: /\n< HTTP/1.1 405 Method Not Allowed\n< Date: Tue, 28 Aug 2018 13:00:46 GMT\n< Content-Length: 0\n```\n\nHTTP 200 on GET:\n```sh\n\u279c  ~  curl -sv localhost:8000/requesturl\n   Trying 127.0.0.1...\n Connected to localhost (127.0.0.1) port 8000 (#0)\n\nGET /requesturl HTTP/1.1\nHost: localhost:8000\nUser-Agent: curl/7.47.0\nAccept: /\n< HTTP/1.1 200 OK\n< Date: Tue, 28 Aug 2018 13:01:01 GMT\n< Content-Length: 9\n< Content-Type: text/plain; charset=utf-8\n<\ngorilla!\n```. Thanks!. Can you share:\n\n\n\nhow you are testing this from the client?\n\n\nhow your program runs locally vs. on the server? Reverse proxy? Etc.\nOn Wed, Sep 12, 2018 at 8:33 AM Ollie Phillips notifications@github.com\nwrote:\n\n\n\nWhat version of Go are you running? (Paste the output of go version)\ngo version go1.10 darwin/amd64\nWhat version of gorilla/mux are you at? (Paste the output of git\nrev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\n9e1f5955c0d22b55d9e20d6faa28589f83b2faca\nDescribe your problem (and what you have tried so far)\nUsing mux.Host as a subrouter, I see different behavour running locally\nthan on remote server.\n// router\nmux.Host(\"{domain}\").PathPrefix(\"/\").HandlerFunc(SiteHandler).Methods(\"GET\")\n// SiteHandler function\nfunc SiteHandler(w http.ResponseWriter, r *http.Request) {\n  vars := mux.Vars(r)\n  domain := vars[\"domain\"]\n}\nLocally the correct handler is called, and domain variable is initialised\nwith the correct domain of the site being called.\nRemotely (on Ubuntu 18.04), the expected handler is not called but instead\nthe NotFoundHandler is called.\nWhen If I remove the subrouter the correct handler is called, but\nobviously I can't access vars[\"domain]. I can see the domain via r.Host\nhowever.\nLocally, the subrouter works and with localhost and other hostnames set in\netc/hosts\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/404, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJlFsCXsPfVBgs0oYLbEqS4wu8OJks5uaSligaJpZM4WlpPg\n.\n. To expand on this, the logs should log r.Host directly, as well as\nr.URL.String()\n\ne.g.\nlogger := func(next http.Handler) http.Hander {\n    return http.HandlerFunc(func (w http.ResponseWriter, r *http.Request) {\n        log.Printf(\"url=%s host=%s method=%s\", r.URL.String(), r.Host,\nr.Method)\n       next.ServeHTTP(w, r)\n    }\n}\nhttp.ListenAndServe(addr, logger(r)) // where \"r\" is a *mux.Router\nOn Wed, Sep 12, 2018 at 8:52 AM Kamil Kisiel notifications@github.com\nwrote:\n\nIt would help if you provide a full log of the requests before they hit\nmux. You can wrap it in another handler which does the logging.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/404#issuecomment-420700270, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcDpKN2IicjxCsSf21AkKqqAVBS5nks5uaS3KgaJpZM4WlpPg\n.\n. Passing test case:\n\ngo\n        {\n            title:        \"Host route with pattern (only)\",\n            route:        new(Route).Host(\"{domain}\"),\n            request:      newRequest(\"GET\", \"http://localhost:8081/\"),\n            vars:         map[string]string{\"domain\": \"localhost:8081\"},\n            host:         \"localhost:8081\",\n            path:         \"\",\n            hostTemplate: `{domain}`,\n            shouldMatch:  true,\n        }\nFailing test case - a host template attempting to match a hostname that contains dots fails.\ngo\n        {\n            title:        \"Host route with pattern (only) and subdomain\",\n            route:        new(Route).Host(\"{domain}\"),\n            request:      newRequest(\"GET\", \"http://fly2buy.co.uk:8081/\"),\n            vars:         map[string]string{\"domain\": \"fly2buy.co.uk:8081\"},\n            host:         \"fly2buy.co.uk:8081\",\n            path:         \"\",\n            hostTemplate: `{domain}`,\n            shouldMatch:  true,\n        },\nSubdomain match only:\ngo\n        {\n            title:        \"Host route with fixed ccTLD\",\n            route:        new(Route).Host(\"{domain}.co.uk\"),\n            request:      newRequest(\"GET\", \"http://fly2buy.co.uk:8081/\"),\n            vars:         map[string]string{\"domain\": \"fly2buy\"},\n            host:         \"fly2buy.co.uk\",\n            path:         \"\",\n            hostTemplate: `{domain}.co.uk`,\n            shouldMatch:  true,\n        }\nExisting host tests are defined here: https://github.com/gorilla/mux/blob/master/mux_test.go#L50-L211. I\u2019m currently just logging progress. I don\u2019t have a fix identified yet, and\nit\u2019s unlikely I will have any time to fix this until October.\nMatt\nOn Fri, Sep 14, 2018 at 1:39 PM Ollie Phillips notifications@github.com\nwrote:\n\nHey, is this something I need to act on, or can help with?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/404#issuecomment-421478199, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNnOr-Zwsxe4SapfkVIMdASqNE3oks5ubBQYgaJpZM4WlpPg\n.\n. Suggestions:\n\n\nAdd a series of new Host based tests, based on acceptable hostnames in the RFC - steal some from Go's own test suite for r.Host and r.URL.Host as applicable\nInvestigate the regexp at https://github.com/gorilla/mux/blob/9e1f5955c0d22b55d9e20d6faa28589f83b2faca/regexp.go#L53-L55. https://regex101.com/r/bfzyDp/1 - the pattern is in the failing test output regexp: regexp.MustCompile(\"^(?P<v0>[^.]+)$\") - you can see it doesn't match as it intentionally does not match periods.\n\n\nNamed Capture Group v0 (?P[^.]+)\nMatch a single character not present in the list below\n[^.]+\n+ Quantifier \u2014 Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)\n. matches the character . literally (case sensitive)\n$ asserts position at the end of a line. See how this is done here: https://github.com/gorilla/mux/blob/9e1f5955c0d22b55d9e20d6faa28589f83b2faca/middleware.go#L42-L59\n\nYou could factor that out, then re-use the route-walking approach in both cases.. (if you want to take a crack at that, let me know - tests -> factor out the shared logic -> submit PR!) \ud83d\udcaf . To confirm, both Windows & Debian have the same version of mux?\nOn Sat, Sep 29, 2018 at 3:17 AM Axel Lindgren Wenell \nnotifications@github.com wrote:\n\nWhat version of Go are you running? (Paste the output of go version)\nDebian: go version go1.11 linux/amd64\nWindows: go version go1.11 windows/amd64\nWhat version of gorilla/mux are you at? (Paste the output of git\nrev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\n9e1f595\nhttps://github.com/gorilla/mux/commit/9e1f5955c0d22b55d9e20d6faa28589f83b2faca\nDescribe your problem (and what you have tried so far)\nSetting up a mux router application on Windows 10 works perfectly fine,\nbut trying the exact same code on a Debian Stretch server returns error 503\nin the browser. I have checked all logs for errors, warnings etc and there\nis nothing. I tried using an older application where I use the default\nnet/http package with standard routing system and that works good.\nIt's worth mentioning I'm using Apache for proxying the server. The server\ncan not be accessed locally either without returning 503. Again there are\nno logs or info provided by Apache either. The needed ports are open. We\nare not using any server-side firewalls that'd block this, and no\nCloudFlare or anything like that.\nPaste a minimal, runnable, reproduction of your issue below (use\nbackticks to format it)\nI have it structured in a certain way. I call a function in my middleware\npackage that sets the route, allowing for better formating when defining\nthem in my route package.\nmiddleware.go\nfunc SetRoute(r mux.Router, uri string, handle func(http.ResponseWriter, http.Request), methods string) {\n    r.HandleFunc(uri, handle).Methods(methods)\n    r.Use(MiddlewareHandle)\n}\nfunc MiddlewareHandle(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n    defer func() {\n        log.Println(r.URL.Path, time.Since(start))\n    }()\n\n    next.ServeHTTP(w, r)\n})\n\n}\nroute.go\nr := mux.NewRouter()\nmiddleware.SetRoute(r, \"/\", index.Index, \"GET\")\nsrv := &http.Server{\n    Handler:      r,\n    Addr:         \"127.0.0.1:8080\",\n    WriteTimeout: 15 * time.Second,\n    ReadTimeout:  15 * time.Second,\n}\nlog.Fatal(srv.ListenAndServe())\nhandle\nfunc Index(w http.ResponseWriter, r *http.Request) {\n   fmt.Println(\"Hello World\")\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/406, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBhceQTfWrfJrEvNWTtX8vVXa1_nks5uf0jSgaJpZM4XAcS3\n.\n. >  I tried using an older application where I use the default net/http\npackage with standard routing system and that works good.\n\n\nIs the only change you make here to replace mux.Router with\nhttp.ServeMux? (I want to be precise/clear)\nOr are there other changes?\nAre you sure the Apache server is hitting the Go backend at all?\nThe only case where Go returns a HTTP 503 is in\nhttps://github.com/golang/go/blob/77c575d2e2cc320b62cbbdefbc6840a8cff2163c/src/net/http/server.go#L3135-L3180\nin the timeout handling part.\nIf you remove the timeouts, or increase them, does the problem persist?\n(try both, report both cases)\n\nThis is not a trivial issue to debug - nothing in your code points to a\nproblem nor would I expect a problem - so specificity is important.\nOn Sat, Sep 29, 2018 at 6:34 AM Matt S matt@eatsleeprepeat.net wrote:\n\nTo confirm, both Windows & Debian have the same version of mux?\nOn Sat, Sep 29, 2018 at 3:17 AM Axel Lindgren Wenell \nnotifications@github.com wrote:\n\nWhat version of Go are you running? (Paste the output of go version)\nDebian: go version go1.11 linux/amd64\nWindows: go version go1.11 windows/amd64\nWhat version of gorilla/mux are you at? (Paste the output of git\nrev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\n9e1f595\nhttps://github.com/gorilla/mux/commit/9e1f5955c0d22b55d9e20d6faa28589f83b2faca\nDescribe your problem (and what you have tried so far)\nSetting up a mux router application on Windows 10 works perfectly fine,\nbut trying the exact same code on a Debian Stretch server returns error 503\nin the browser. I have checked all logs for errors, warnings etc and there\nis nothing. I tried using an older application where I use the default\nnet/http package with standard routing system and that works good.\nIt's worth mentioning I'm using Apache for proxying the server. The\nserver can not be accessed locally either without returning 503. Again\nthere are no logs or info provided by Apache either. The needed ports are\nopen. We are not using any server-side firewalls that'd block this, and no\nCloudFlare or anything like that.\nPaste a minimal, runnable, reproduction of your issue below (use\nbackticks to format it)\nI have it structured in a certain way. I call a function in my middleware\npackage that sets the route, allowing for better formating when defining\nthem in my route package.\nmiddleware.go\nfunc SetRoute(r mux.Router, uri string, handle func(http.ResponseWriter, http.Request), methods string) {\n    r.HandleFunc(uri, handle).Methods(methods)\n    r.Use(MiddlewareHandle)\n}\nfunc MiddlewareHandle(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n    defer func() {\n        log.Println(r.URL.Path, time.Since(start))\n    }()\n\n    next.ServeHTTP(w, r)\n})\n\n}\nroute.go\nr := mux.NewRouter()\nmiddleware.SetRoute(r, \"/\", index.Index, \"GET\")\nsrv := &http.Server{\n    Handler:      r,\n    Addr:         \"127.0.0.1:8080\",\n    WriteTimeout: 15 * time.Second,\n    ReadTimeout:  15 * time.Second,\n}\nlog.Fatal(srv.ListenAndServe())\nhandle\nfunc Index(w http.ResponseWriter, r *http.Request) {\n   fmt.Println(\"Hello World\")\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/406, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBhceQTfWrfJrEvNWTtX8vVXa1_nks5uf0jSgaJpZM4XAcS3\n.\n\n\n. > I'm sure. I tried running the application without Apache, on a different non-related (but still open and valid) port, and it refused my connection.\n\nCheck your Windows firewall logs. Try telnet\u2019ing into the listening Go service. . Can you confirm it\u2019s listening?\nnetstat -tunapl | grep \u201cportnum\u201d\nOn Sat, Sep 29, 2018 at 7:48 AM Axel Lindgren Wenell \nnotifications@github.com wrote:\n\nMy Windows firewall logs are sending and receiving. When telnet'ing the Go\nservice running on Linux it throws Unable to connect to remote host:\nConnection refused.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/406#issuecomment-425650593, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPLg_dad-Wi1cio2uZhJ4crm_Zo7ks5uf4gugaJpZM4XAcS3\n.\n. Please share a minimal reproduction with your code.\nOn Thu, Oct 11, 2018 at 3:00 AM AP8050 notifications@github.com wrote:\nWhat version of Go are you running? (Paste the output of go version)\nWhat version of gorilla/mux are you at? (Paste the output of git\nrev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\nDescribe your problem (and what you have tried so far)\nWhile executing go file with tcp port,I got this error. Please anyone help\nme to fix this error.\nError\nDialing connection failed due to dial tcp ****:8080: connect: connection\nrefused\nThanks in advance!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/407, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcB_09RFOTv3WJAxBlFSbrHUVH9Ipks5ujxaygaJpZM4XXMpH\n.\n. It's not clear what the issue is - re-directing to a GET is expected, and\nthat's how a Go client (and curl, etc) behaves:\n\n\u279c  ~  go run client.go -url \"http://localhost:8000/foo//bar\" -method \"GET\"\nHTTP status: 200\nGot a GET\nWhere the meaningful part of my repro program is:\n    r := mux.NewRouter()\n    r.HandleFunc(\"/foo/{bar}\", handler).Methods(\"PUT\", \"GET\")\n\n    log.Fatal(http.ListenAndServe(\"localhost:8000\", r))\n\n... and my client is:\n    req, err := http.NewRequest(method, uri, nil)\n    if err != nil {\n            log.Fatal(err)\n    }\n\n    resp, err := client.Do(req)\n    if err != nil {\n            log.Fatal(err)\n    }\n\n    b, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n            log.Fatal(err)\n    }\n\n    fmt.Printf(\"HTTP status: %d\\n\", resp.StatusCode)\n    fmt.Printf(\"%s\\n\", b)\n\nIf you wanted the client to retry with a POST/PUT/DELETE/PATCH (i.e. a\nnon-idempotent method), you'll need to return a HTTP 307 or 308. There's\nsome example middleware here that can do that for you:\nhttps://github.com/gorilla/mux/issues/369#issuecomment-385550817\nOn Fri, Oct 12, 2018 at 2:52 AM Pavel Emelyanov notifications@github.com\nwrote:\n\nWhat version of Go are you running? (Paste the output of go version)\n1.9\nWhat version of gorilla/mux are you at? (Paste the output of git\nrev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\n9e1f595\nhttps://github.com/gorilla/mux/commit/9e1f5955c0d22b55d9e20d6faa28589f83b2faca\nDescribe your problem (and what you have tried so far)\nI have a server driven by the mux framework. When a client sends PUT\nrequest on a URL with mistakenly set double /-s in path (e.g. like this PUT\nhost/foo//bar) the server responds with 301 code providing the \"fixed\"\n(with all single slashes) URL in the Location header.\nThe standard golang net/http client lib says that RFC 7231 allows\nredirection of GET-s only and re-sends the original request with the method\nchanged to GET. Server handles both, PUT and GET on the specified URL and\nworks well, responding with the Success code.\nTechnically everything is correct, but this behavior apparently confuses\nthe client, as it expects an updated object after PUT request or an error,\nindicating that something went wrong. Instead, it receives \"all is OK\"\ncode, but no update happened.\nPaste a minimal, runnable, reproduction of your issue below (use\nbackticks to format it)\n\ncreate a router with the\n   r.HandleFunc(\"/foo/{bar}\", handleFooBar).Methods(\"PUT\", \"GET\")\ncall the go client library\n   req := http.NewRequest(\"PUT\", \"host/foo//bar\")\n   http.Client.Do(req)\n\nthe request would succeed, but for GET method, not PUT.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/408, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPnA-4gTz8uhy42_sfMb5exV0kv1ks5ukGZSgaJpZM4XZKBr\n.\n. No problems, and sorry it took so long! I'll take it as feedback to make smaller, more incremental releases, esp. as Modules take off. @pierrre . Fixed (typo; need automation around this)\nOn Mon, Jan 28, 2019 at 2:14 AM Dale Hui notifications@github.com wrote:\nCould you re-tag as v1.7.0 since SemVer requires all versions (major,\nminor, and patch) to be specified?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/410#issuecomment-458070862, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJcTSnR34tenyZ92K3GOY6nIvsLNks5vHs2agaJpZM4XdQBu\n.\n. https://github.com/gorilla/mux/pull/422 should resolve this: confirm back if not. . The docs show that the method only accepts two arguments - path and a\nhandler type.\n\nhttps://godoc.org/github.com/gorilla/mux#Router.HandleFunc\nOn Tue, Oct 23, 2018 at 8:49 PM Operations Research Engineering Software+ \nnotifications@github.com wrote:\n\nUsing Go version 1.11.1\nr := mux.NewRouter()\nr.HandleFunc(\"/nearby\", nearby.First, nearby.Second, nearby.GetMany).Methods(\"GET\")\nI was hoping the above was possible, but I don't see anything in the\nreadme that suggests we can put multiple function handlers as varargs\nthere. Is there a way to do this? If I do the above I get \"too many\narguments...\"\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/413, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcIRr9K8FxbHCH3QKR6fM2BEmMHGgks5un-NMgaJpZM4X3Exu\n.\n. Can you describe the goal / problem you are trying to solve?\n\nI assume you might be looking at using middleware:\nhttps://github.com/gorilla/mux/blob/master/README.md#middleware\nOn Tue, Oct 23, 2018 at 10:16 PM Operations Research Engineering Software+ \nnotifications@github.com wrote:\n\nthe docs could have been missing it, but I guess they aren't. is there not\na way to pass multiple handlers that can be strung together?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/413#issuecomment-432515780, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcBYm6BsAU_H8WfuZBRpTtAoT-yRCks5un_ebgaJpZM4X3Exu\n.\n. Closing as answered.. Correct. Middleware only executes on matches.\n\nYou can log all requests by wrapping the top level router itself before\npassing it to a listener.\nOn Tue, Oct 30, 2018 at 9:25 PM kanozec notifications@github.com wrote:\n\nSeems only if the route path is matched, the middleware handler will be\nexecuted.\nFor those not matched path, you should customize your \"NotFoundHandler\" to\ndo something.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/416#issuecomment-434556653, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcLT-6M6uFnO81E0dVT1e0SDjSY2mks5uqSYxgaJpZM4YDFSm\n.\n. We should move them to a dedicated property: it will make it easier to\nmaintain in the future.\nOn Wed, Oct 31, 2018 at 4:10 PM S\u00e9bastien Lavoie notifications@github.com\nwrote:\nVery good point. It\u2019s confusing because the ErrMethodMismatch logic is\ninverted.\nI added an exception and a test for it.\nIt would probably be cleaner to move the allowed methods to a dedicated\nproperty, but this seems good enough for now.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/417#issuecomment-434878435, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcAHK4-oH4zTa601AAc1UufYWteREks5uqi3cgaJpZM4YFfgb\n.\n. Closing in favor of #418. I'm travelling, so just haven't had time to review in proper given it\ntouches a bunch of internal structures. Will try to set some time aside on\nmy flight back.\n\nOn Wed, Nov 7, 2018 at 9:52 AM S\u00e9bastien Lavoie notifications@github.com\nwrote:\n\n@kisielk https://github.com/kisielk @elithrar\nhttps://github.com/elithrar Would you like more information about this\npatch?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/418#issuecomment-436649016, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcFwjaUAH77ok3M2HCbnUYw77sN-Fks5usvO9gaJpZM4YM9ZG\n.\n. OK. Can you also update https://github.com/gorilla/mux#middleware in the docs to describe when Middleware will run / not run? I think this will clear up expectations.\n\nA small table might work to explain it - route match vs. method match vs. no match with a \"Y\" or \"N\" for the state (or tick / cross emoji if you prefer, not fussed!).\nI would argue that middleware running on every request is a sensible use-case though, and I think the adoption of the middleware logic without explicitly agreeing on when it runs has led us to ambiguous \"fixes\" like this.. OK, so I really wanted to dwell on this for a while.\n\nI think only running middleware, by default, on a route match is a mistake: it's non-obvious, and breaks use-cases/expectations around logging middleware, custom NotFound handlers, etc. It requires users to understand the difference between .Use and also just wrapping http.Handlers.\nThe path forward should be to run middleware on every request through the Router, or if only applied to Subrouter, that matches any route in the Subrouter (since applying it at the sub-router level implies a match, since a Subrouter requires a match-constraint)\nOptionally, an option on Router that allows you to RunMiddlewareOnMatchOnly for users that want to opt-in.\n\nI'm happy to accept this PR if we can achieve the above. Sorry again for the long delay @lavoiesl - but there are a LOT of mux users, and many of them tend towards being newer Gophers coming from net/http or wanting a feature-full router\nSane defaults / a consistent API are important, and our change history shows that these \"implicit behavioural changes\" hurt more users than we expect (since it's hard to analyze API expectations!). I don\u2019t think it makes sense to do so for a single use-case like this: we\nare then adding an array to every match, whether consumed or not.\nHave you considered using named route variables to positionally number\nthem? Or giving them contextual names.\n\u201c/{one}/{two}/{etc}\u201d\nAlternatively you could use GetPathTemplate and determine the positions\nfrom there: https://godoc.org/github.com/gorilla/mux#Route.GetPathTemplate\nOn Thu, Nov 8, 2018 at 8:28 AM Per Borgman notifications@github.com wrote:\n\nI'd like to map a route to a controller action that receives the URL vars\nas its arguments (using reflection). For that there needs to be a way to\nget the vars in order, but right now the only way is mux.Vars and that\nreturns a map.\nI figure RouteMatch needs an additional field (an array), and extractVars\nneeds to fill that up too. Shouldn't be too hard? :)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/419, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPPj6z1fu3BCN7LFWy9sLApqfpT6ks5utDFlgaJpZM4YUq-y\n.\n. Earmarking this for v2.0, but won\u2019t change today.\n\nYou can use middleware to change 301/2\u2019s into 307/8\u2019s in the meantime. . I'd accept a PR that makes this an option on the Router, but am unlikely to change this as a default.. .Queries is used for adding matches to a route -\nhttps://godoc.org/github.com/gorilla/mux#Route.Queries\nmux.Vars returns route variables, not query parameters. If you want to\nfetch those, use r.URL.Query() to get a map of url.Values -\nhttps://golang.org/pkg/net/url/#URL.Query\nOn Sun, Nov 18, 2018 at 10:10 AM Vasiliy Tolstov notifications@github.com\nwrote:\n\ni have url like: /xxx?fields=name&fields=public_key\ni have pattern like .Queries(\"fields\", \"{fields}\") but in this case in\nmux.Vars i have only one field (first with name = name)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/421, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcKyH31e-N1gURPxzuJsYJW2tlDX-ks5uwaJ3gaJpZM4YoD_F\n.\n. This looks great (at first pass).\n\nWhat would be useful w.r.t reviewing this is a short list of bullet points\nthat communicate behavior changes\u2014such that as can use them in the release\nnotes verbatim as well.\nOn Sat, Nov 24, 2018 at 5:18 PM Joe Wilner notifications@github.com wrote:\n\nproblem\nIn #389 https://github.com/gorilla/mux/issues/389, @fstanis\nhttps://github.com/fstanis highlighted an issue with routes branched\noff a subrouter not filtering by Methods() as intended; they wrote\ndemonstrative tests in #390 https://github.com/gorilla/mux/pull/390.\nI identified several more matchers which suffered the same problem.\nSpecifically, if you invoke Schemes(), Headers(), or Query() before\ninvoking Subrouter(), your config is discarded for child routes. I have\nincorporated @fstanis https://github.com/fstanis' tests for Methods()\nand added a few more for the other three methods; all of the negative cases\n(shouldMatch: false) would currently fail on master.\nAs far as I can tell, passing on these matchers isn't addressed in the\ncode because I don't think this is necessarily the most likely use case for\nSubrouter (I imagine it was written to effectively avoid typing out\ncertain hierarchical path prefices over and over, and it does so very\nexpressively) but I do think it seems worth fixing. Consider that,\nprogrammers might be using Schemes(\"https\") to make a best effort to\nensure that all requests over a given subrouter are via https, or Headers(\"User-Agent\",\n\"FooBar\") to ensure that certain endpoints under the subrouter fire only\nfor certain user agents -- neither of those use cases would currently be\nmet.\nproposal\nThe fix is to make the config actually be communicated via the subrouter.\nThe current pattern for communicating config between parent and children\nroutes has been the parentRoute interface. It has its advantages, but it\nis verbose and decentralizes the \"inheritance\" logic; to adopt it here\nwould've required adding four new methods to the interface, satisfying them\non both Router and Route, and largely duplicating the logic in each of\nthose methods.\nInstead, I suggest defining a common data structure (here named routeConf)\nfor those properties which need to be passed on. I used an embedded struct\nhere to keep the relative diff as small as possible. When calling Route\nor Subrouter, the struct is copied and passed on to the new child object.\nThis centralizes the inheritance logic (effectively putting it in the\ncopyRouteConf func) and guarantees that the values are carried over as\nthe API suggests.\nnotes\n\nTo clearly highlight the behavioral change in this diff, I left\n   intact some parentRoute usage that is now effectively obsolete. If\n   this PR gets a tentative \ud83d\udc4dfrom the powers that be, I'd like to go\n   ahead and strip out some of that dead code.\nThe TestWalkSubrouters test was modified to pass with the new logic;\n   I think that the new behavior is actually the correct behavior. The old\n   behavior appears inconsistent to me (the second pathTemplate includes\n   its parent route, but the third and fourth don't include theirs), and\n   GetPathTemplate() is most likely to be useful if it provides the whole\n   path, not a partial. If I'm misunderstanding or we want to prioritize the\n   backwards compatibility for this scenario, I can preserve the behavior.\n\nThanks!\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/422\nCommit Summary\n\nPull out common shared routeConf so that config is pushed on to\n   child\n\nFile Changes\n\nM mux.go https://github.com/gorilla/mux/pull/422/files#diff-0\n   (67)\nM mux_test.go\n   https://github.com/gorilla/mux/pull/422/files#diff-1 (120)\nM route.go https://github.com/gorilla/mux/pull/422/files#diff-2\n   (17)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/422.patch\nhttps://github.com/gorilla/mux/pull/422.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/422, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcNIoajhLXxctz1qRkT2pOWZ0ymyNks5uye_UgaJpZM4Yxqgx\n.\n. Huge thanks for this @jwilner, and apologies for the delay in reviewing (been travelling for work!).. Can you share your before and after, to better illustrate the change you\nmade post-1.7?\nOn Thu, Jan 31, 2019 at 5:05 PM Benoit Sigoure notifications@github.com\nwrote:\nThere is no mention of this bugfix in the 1.7.0 changelog. I think it's\nworth mentioning because it fixes a bug that will make some user code more\nrestrictive. For example we have some code that does:\nmux.NewRouter().Host(\"{customerId:[0-9]}{dot:[.]?}example.com{hostPort:[:0-9]}\").Subrouter().StrictSlash(true).UseEncodedPath()\nBefore this change, the host matcher wasn't copied into the subrouter.\nThis meant that a request to wrong.com would pass the matchers but would\nfail to extract the var customerId, but would still be passed on to the\nuser handler code anyway. With this change the request no longer passes the\nhost matcher and gets a 404 instead of going to the user handler. To be\nclear, I think the new behavior is the correct one, but I'm just saying\nthis deserves a mention in the release note as it was quite a head\nscratcher for me to figure out why after upgrading to 1.7.0 some tests\nweren't matching any route anymore.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/422#issuecomment-459567300, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcHVk1Fpi8MjQB9fqoqOLTkh27nTIks5vI5K4gaJpZM4Yxqgx\n.\n. I assume this was a mistake (the import path is not changing to point to another repo).. Thanks M\u0336e\u0336r\u0336g\u0336e\u0336B\u0336o\u0336t\u03362\u03360\u03360\u03360\u0336 Kamil! \ud83d\ude09\nOn Fri, Dec 7, 2018 at 10:41 AM Kamil Kisiel notifications@github.com\nwrote:\nMerged #424 https://github.com/gorilla/mux/pull/424 into master.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/424#event-2012889265, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AABIcD4mC0-7CKVVfRm5W0R-qhzQNVhQks5u2ppOgaJpZM4ZIppz\n.\n. Hey @andrewpillar - more than happy for someone to contribute this. Taking a quick look at your code, it's similar to what I was thinking from an example - but critically, I'd want the certificate provisioning to be automatic.\n\nThus:\n\nUse https://github.com/mholt/certmagic as a library for automatic generation of certs.\nProvide two concurrent listeners with cancellation for HTTP and HTTPS\nOptional, for development: use https://github.com/FiloSottile/mkcert to set up a cert and then pass it to the *tls.Config of the server.\n\nSome of the existing examples should give you guidance - e.g. https://github.com/gorilla/mux#testing-handlers:\n\nHeavily commented code to explain why\nLinked within the README at the top to support jumping down\nAn explanation of what the example itself achieves. Thanks!. Keep in mind: Middleware only runs on a route match.\n\nAre the routes you\u2019re hitting valid & returning a 200 from mux?\nOn Wed, Dec 19, 2018 at 1:08 AM Operations Research Engineering Software+ \nnotifications@github.com wrote:\n\nhttps://stackoverflow.com/questions/53846042/gorilla-mux-middleware-not-being-hit\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/429#issuecomment-448521845, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcOksX8Tc6WtwzIwc28oZdzSpadRoks5u6gIRgaJpZM4ZZhb4\n.\n. I can take a look this weekend, but:\n\nNote that adding middleware to the stack does not run it. Your logs will\nnot be written as the middleware only runs when a route is matched. It\ndoesn\u2019t run when you call Router.Use - there\u2019s no request to pass to it.\nOn Wed, Dec 19, 2018 at 2:10 PM Operations Research Engineering Software+ \nnotifications@github.com wrote:\n\n@elithrar https://github.com/elithrar I have a git repo that can demo\nthe problem, it doesn't make any db connections or anything, just responds\nto requests, so it's easy to reprodoce. Can you take a look? this problem\nis rough.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/429#issuecomment-448762064, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcG1fCVcFC2N1gBwK5-BL7nRPWb7vks5u6rlugaJpZM4ZZhb4\n.\n. Can you also make sure you\u2019re using the latest version of mux? The hash you supplied is > 2 months old. . If you have a similar issue, please provide responses to the issue template\nin your comment (mux version, Go version), and a minimal, reproducible\nexample of your route configuration and the requests you are making.\n\nIdeally, an example I can go run and a set of curl requests I can reproduce\nwith.\nOn Thu, Dec 20, 2018 at 10:16 AM tomare notifications@github.com wrote:\n\nI have similar issue, and I find something in Route.Match\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/429#issuecomment-449088887, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcO6uTWyICG5XF92Iv_bTXwlN9wz2ks5u69P6gaJpZM4ZZhb4\n.\n. I don't think Skype is a productive way to debug this. Here's what will help:\n\n\nBe clearer - provide a single piece of example code that reproduces the issue\nProvide either tests in Go or as curl requests that show expected vs. actual\nDo the same for \"405's in weird places\" - it is otherwise impossible to understand what the problem is.. I want to replicate your issue, be able to apply a fix/patch (if necessary), and re-run the requests to resolve it.\n\nI understand the problem you're describing, but being able to programatically reproduce it makes fixing it much easier, and avoids missing any cases you consider \"broken\" that I do not.\nThere is no need to get snarky - I'm volunteering my time to help you. \nProvide matching test cases in Go, or as simple curl requests, and I'm more than happy to help.. As basic as possible - literally:\ncurl -svo /dev/null $YOURURL\nReturns 405\nExpected 200\netc.\nThat would allow me to match up what you're expecting for each route vs.\nwhat you get, and easily run them locally before writing out Go tests.\nNode.js is OK, but simpler is better still.\nOn Mon, Dec 24, 2018 at 4:56 PM Operations Research Engineering Software+ \nnotifications@github.com wrote:\n\n@elithrar https://github.com/elithrar would accept test cases written\nin Node.js? The reason I would rather discuss first is perhaps this is just\nexpected behavior.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/429#issuecomment-449781887, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPhDAZUDDrwt1Y3zk7R0i--T6Epoks5u8Xe-gaJpZM4ZZhb4\n.\n. ```\n\nBefore PR 431 was applied\n\u279c  /mnt/c/Users/Gamer/repos/mux-problem-demo/src/huru (master) \u2717  huru_api_port=3000 huru\nINFO[0000] Huru API server listening on port 3000\nINFO[0017] the logging handling middleware should have logged something before this.\nINFO[0028] the logging handling middleware should have logged something before this.\n^C\nAfter PR 431 was applied\n^[\u279c  /mnt/c/Users/Gamer/repos/mux-problem-demo/src/huru (master) \u2717  huru_api_port=3000 ./huru\nINFO[0000] Huru API server listening on port 3000\nINFO[0005] logging middleware registered\nINFO[0005] logging middleware registered\nINFO[0005] logging middleware registered\nINFO[0005] logging middleware registered\nINFO[0005] We are handling errors with defer.\nINFO[0005] Here is the request URI: /api/v1/foo\nINFO[0005] We are handling errors with defer.\nINFO[0005] Here is the request URI: /api/v1/foo\nINFO[0005] We are handling errors with defer.\n```. Can you please provide:\n\nA test\nA clearer issue description / comment around the fix.\n\nOn Thu, Dec 20, 2018 at 12:17 PM tomare notifications@github.com wrote:\n\nfix for issue #429 https://github.com/gorilla/mux/issues/429\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/431\nCommit Summary\n\nUpdate route.go\n\nFile Changes\n\nM route.go https://github.com/gorilla/mux/pull/431/files#diff-0\n   (2)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/431.patch\nhttps://github.com/gorilla/mux/pull/431.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/431, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcDSOY12WWgTQvkdWYksxMcRQmtZYks5u6_BWgaJpZM4Zc2NW\n.\n. Yep - the tests need to be comprehensive. It\u2019s clear that our already large test suite doesn\u2019t cover all behaviours, especially with complex subrouter + middleware interactions.\n\nThe burden on PRs to provide more complete test cases will only increase \ud83d\ude09. Looks like the comment was addressed, just didn\u2019t see a reply comment. Let me review in full at a computer later today before merging.. Thanks @tomare!. A custom NotFoundHandler should not prevent middleware from running on a\nsubrouter, so I would consider this a bug.\nOn Fri, Dec 21, 2018 at 1:57 PM Ben Hartshorne notifications@github.com\nwrote:\n\nWhat version of Go are you running?\n\u279c  go version\ngo version go1.11.4 darwin/amd64\nWhat version of gorilla/mux are you at?\n\u279c  git rev-parse HEAD\n6137e193cdcba2725f16de84eaf0db2b769d9668\nDescribe your problem (and what you have tried so far)\nRouting behaves differently when a submux has a NotFoundHandler defined\nand other available routes might match.\nWhen a NotFoundHandler is defined if route matches a prefix and\ndescends into a subrouter but then does not find an exact match, the\nmatch search stops and returns the submux's NotFoundHandler\nWhen a NotFoundHandler is not defined if a route matches a prefix and\ndescends into a subrouter but then does not find an exact match, the\nmatch search continues to other available routes in the parent mux.\nI would not expect route selection to be influenced by whether on not a\nNotFoundHandler was default or custom. And if it is supposed to behave\ndifferently, I would hope to find a method of toggling the behavior while\nstill being able to change the NotFoundHandler. In other words, I would\nlike to separate the logic of whether a route matches from what happens\nwhen it doesn't.\nIf this behavior is expected, I would like to consider updating the\ndocumentation to make more clear the effects of overriding the\nNotFoundHandler.\nAs an aside, I believe that when #431\nhttps://github.com/gorilla/mux/pull/431 lands, it will also be the case\nthat if a submux has the NotFoundHandler defined then middleware on the\nparent mux will run (whereas it would not run if the NotFoundHandler were\ndefault).\nPaste a minimal, runnable, reproduction of your issue below (use\nbackticks to format it)\nhttps://github.com/maplebed/gorilla-mux-routing-example/tree/notfound has\na runnable example illustrating both cases.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/432, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcF9IxQpu3JeoF0lFkVkqlktGgZM_ks5u7VkrgaJpZM4ZfI4x\n.\n. Can you be clearer about your reasons? You can provide named groups if needed. . Can you show how mux.Vars is not usable?\n\nSomething like gorilla/schema or https://github.com/mitchellh/mapstructure should be able to do this for you.. Kai - can you perhaps outline how you want to \u201ctrack\u201d a user? Across all of\ntheir visits to the site? How will you analyze it later? What is the goal\nof tracking them?\nOn Wed, Jan 2, 2019 at 1:48 AM Kai Hendry notifications@github.com wrote:\n\nFollowing up on\nhttps://groups.google.com/d/msg/gorilla-web/Ga1X6kTzImQ/whjJH89DDgAJ\nFirst Matt, happy new year and thanks for answering my question, though I\nam stuck what you mean by Request in your pseudocode:\nhttp://play.golang.org/p/GZzJdAHDGu0\nTbh, I am a total newb when it comes to context, so I am little\nbewildered how it can replace the functionality of a cookie. Since the UA\nof the visitor might have a longer session than my running lambda server.\nI am also a little puzzled how to get logging object back into the\nhandler. I am more familiar with https://github.com/apex/log if you don't\nmind.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/436, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcIorHU0MSrmasitSJtcDUGqzte-Cks5u_IBfgaJpZM4ZmaUi\n.\n. Yes, in that case, just give them a cookie. The concept of a \u201cstore\u201d in\ncookie parlance is to save it somewhere - in this case, the client computer.\n\nI had interpreted your ask as \u201cI want to trace a request through my\nhandlers & middleware\u201d.\nOn Wed, Jan 2, 2019 at 5:37 AM Kai Hendry notifications@github.com wrote:\n\nI just want to be able to see their journey through the routes of the\napplication.\n\n/\n/about\n/bus/id?=12345\n/bus/id?=41323\n/contact\n\nWithout using JS. I think the easiest way to do that, is logging a cookie\nid in the middleware somehow.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/436#issuecomment-450864989, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcFuOokVL6uC42D6mbYO6shifpzJxks5u_LYRgaJpZM4ZmaUi\n.\n. That looks fine. Adding it to the context is only useful if you plan to\ncapture it later - i.e. in a logging handler, or in metrics, etc.\n\nOn Wed, Jan 2, 2019 at 4:35 PM Kai Hendry notifications@github.com wrote:\n\nClosed #436 https://github.com/gorilla/mux/issues/436.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/436#event-2051504674, or mute the\nthread\nhttps://github.com/notifications/unsubscribe-auth/AABIcDTq8vBi4S5HI5CRcov425l0Y8Ojks5u_VA-gaJpZM4ZmaUi\n.\n. Thanks. Are you interested in submitting a PR that tackles this?\n\nThe challenge is that ef912dd and this are conflicting behaviour - you need\nto track two \"kinds\" of matchErr (matchRouteErr, matchMethodErr?) in order\nto handle this. That also won't solve host matches, etc.\nOn Mon, Jan 7, 2019 at 7:36 AM Gregor Weckbecker notifications@github.com\nwrote:\n\nWhat version of Go are you running?\ngo version go1.11.4 linux/amd64\nWhat version of gorilla/mux are you at?\nf3ff42f\nhttps://github.com/gorilla/mux/commit/f3ff42f93a451d7ffb2ff11cb9485f3f88089c83\nDescribe your problem\nCurrently the router returns 404 instead of 405 if the path matches but\nnot the method. This is only the case if another not matching route was\nregistered after the matching one.\nThis issues seems to be introduced through the changes in ef912dd\nhttps://github.com/gorilla/mux/commit/ef912dd76ebe9d9848c6e0fd80eaebccc9a11631\n.\nPaste a minimal, runnable, reproduction of your issue below\nfunc TestMethodNotAllowed(t testing.T) {\n  router := NewRouter()\n  router.HandleFunc(\"/thing\", func(w http.ResponseWriter, r http.Request) { w.WriteHeader(http.StatusOK) }).Methods(http.MethodGet)\n  router.HandleFunc(\"/something\", func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) }).Methods(http.MethodPost)\nw := NewRecorder()\n  req := newRequest(http.MethodPut, \"/thing\")\nrouter.ServeHTTP(w, req)\nif w.Code != 405 {\n      t.Fatalf(\"Expected status code 405 (got %d)\", w.Code)\n  }\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/437, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcGIp-QzB3drMj0VdT_YkSUDRLCYdks5vA01TgaJpZM4Zzg_P\n.\n. Thanks @g-w! . Are you after the server base URI, or the base URI for that router /\nsubrouter?\nOn Tue, Jan 15, 2019 at 12:16 AM Ivan Delsinne notifications@github.com\nwrote:\n\ngo version: go version go1.11.4 linux/amd64\ngorilla/mux version: ef912dd76ebe9d9848c6e0fd80eaebccc9a11631\n\nDescribe your problem (and what you have tried so far)\nI'd need to get the http server's base URI, but I'd like to avoid having\nto r-trim the Path URL of the route suffix in every route.\nIs there an \"automated\" way of getting the \"global\" base URI no matter the\nroute?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/440, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcHnvJcOHkmu41exHPv9LtE79fhNlks5vDY5vgaJpZM4aAcgQ\n.\n. Not directly. You can get the current Route from the request via\nhttps://godoc.org/github.com/gorilla/mux#CurrentRoute - but not router vs.\nsubrouter vs. the route itself.\n\nOn Tue, Jan 15, 2019 at 4:46 AM Ivan Delsinne notifications@github.com\nwrote:\n\nThe router base URI.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/440#issuecomment-454380248, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcJtTU0qsXCAqa9dnekvAZoqeamD8ks5vDc2ZgaJpZM4aAcgQ\n.\n. Closing out, but let us know if you have a follow-up question!. Closing out, but let us know if you have any follow-up questions!. Good catch, thanks!. LGTM, thanks!. Have you tried just passing promhttp.Handler() as the handler, instead of wrapping it? . In the default net/http mux, you're calling http.Handle. mux has an identical method on its router - *Router.Handle().\n\nThe promhttp.Handler() function returns a http.Handler, but when you call it in your function as you do, you're not passing the request or response to it.\nThus, either:\nrouter.Handle(\"/metrics\", promhttp.Handler()`)`\nor\nfunc metrics(w http.ResponseWriter, r *http.Request) {\n    promhttp.Handler().ServeHTTP(w, r)\n}\nEither is valid. The second is unnecessary unless you want to wrap the metrics collection with additional logic.. Yes - you should use a Subrouter and PathPrefix to separate out where middleware needs to be applied: https://godoc.org/github.com/gorilla/mux#Route.Subrouter\n```go\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc MiddlewareOne(next http.Handler) http.Handler {\n    fn := func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\"middleware one\")\n        next.ServeHTTP(w, r)\n    }\nreturn http.HandlerFunc(fn)\n\n}\nfunc MiddlewareTwo(next http.Handler) http.Handler {\n    fn := func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\"middleware two\")\n        next.ServeHTTP(w, r)\n    }\nreturn http.HandlerFunc(fn)\n\n}\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"hello\")\n}\nfunc main() {\n    r := mux.NewRouter()\nhealthchecks := r.PathPrefix(\"/health\").Subrouter()\nhealthchecks.Use(MiddlewareOne)\nhealthchecks.HandleFunc(\"/ready\", handler)\n\nprotected := r.PathPrefix(\"/admin\").Subrouter()\nprotected.Use(MiddlewareTwo)\nprotected.HandleFunc(\"/dashboard\", handler)\n\nlog.Fatal(http.ListenAndServe(\"localhost:8000\", r))\n\n}\n```\n~/repos \n\u279c  curl localhost:8000/admin/dashboard \nhello\n~/repos \n\u279c  curl localhost:8000/health/ready    \nhello\nsh\n\u279c  go run main.go\n2019/02/13 06:32:27 middleware two \n2019/02/13 06:32:36 middleware one\nLet me know if any questions!. PS: I would almost definitely reconsider how you're building routes using reflect - that's error prone and likely to panic if you misconfigure. It's hard to see from your very limited example, but a map of map[string]YourHandlerType would be easy to iterate over and build a subrouter from.. There are no explicit plans to add this to mux - with router.Walk - http://www.gorillatoolkit.org/pkg/mux#Router.Walk - you could generate an OpenAPI compatible schema. \nAn example in the documentation would be great; adding code would be a much higher bar due to the specificity of it. . If you can talk through your intent / plan first it\u2019ll help - a PR that\nadds code to mux for this is unlikely to be accepted.\nOn Sun, Feb 17, 2019 at 7:51 AM Vincent LE GOFF notifications@github.com\nwrote:\n\nI will look forward on it. Maybe if i find something usefull and revelant\nfor this case do i submit a PR?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/452#issuecomment-464472980, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMn1eplOvayI9F8vI2i6fA6xzbX8ks5vOXphgaJpZM4a_F47\n.\n. mux matches based on registration order, not prefix length. \n\nDocs: https://github.com/gorilla/mux/blob/master/README.md#matching-routes. Thanks Anton - will take a look.\n(I think adding the CORSMethodMiddleware was originally a mistake, but here\nwe are, so need to fix!)\nOn Mon, Mar 4, 2019 at 10:55 AM Anton Vlasenko notifications@github.com\nwrote:\n\nI got a feeling that CORSMethodMiddleware got stuck between several\niterations, and current condition does not make much sense to me.\nSee for yourself:\n\nIf you don't specify .Methods() it does not work at all. That was\n   not documented in the actual body of the middleware until this PR and it's\n   actually needs effort to discover.\nIf you do specify .Methods(\"GET, \"POST\") it starts to work and\n   return the headers, but for some reason returns that you also support\n   OPTIONS, which you don't, because all OPTIONS calls end up with 405\n   response and no headers are being set.\nIf you do specify that your endpoint support OPTIONS with .Methods(\"GET\",\n   \"POST\", \"OPTIONS\") the middleware outputs something weird back to the\n   users: \"Access-Control-Allow-Methods\": \"GET,POST,OPTIONS,OPTIONS\".\n\nI've seen that @pierreprinetti https://github.com/pierreprinetti was\nbringing this problem before (#381\nhttps://github.com/gorilla/mux/issues/381, #382\nhttps://github.com/gorilla/mux/pull/382), and the fix was not merged\nfor different reasons and different ideas on how things could work in Mux\nin the future, but since that time things have changed, and only the\nMiddleware still keeps behaving unexpectedly and weirdly both for end users\nand for developers.\nSo without the second-commit fix the tests would fail like this:\nExpected Access-Control-Allow-Methods 'POST,PUT,GET,OPTIONS',\nfound 'POST,PUT,GET,OPTIONS,OPTIONS'\nFAIL\nI've also improved the test to remove unnecessary complexity of different\nsimilar conditions testing and actually testing out more things.\nLooking forward to hear what do you think about this change!\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/459\nCommit Summary\n\nRedo CORS test to be more explicit on what we test\nDo not set OPTIONS as allowed method unless it is\n\nFile Changes\n\nM middleware.go\n   https://github.com/gorilla/mux/pull/459/files#diff-0 (10)\nM middleware_test.go\n   https://github.com/gorilla/mux/pull/459/files#diff-1 (36)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/459.patch\nhttps://github.com/gorilla/mux/pull/459.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/459, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcCq2SLacl_ilaY3u6SP2Rh7Q-Nerks5vTU_kgaJpZM4bcxk5\n.\n. The other part: having to specify the methods via .Methods was an\nintentional decision as otherwise you have to assume all methods, which\nmay not be the case.\n\nI\u2019m not sure implicitly dumping all HTTP methods into the ACAM response\nheader makes sense otherwise.\nOne thing we can do: clearer, more obvious docs. I\u2019m going to review your\nPR this weekend (been traveling all week), but README and godoc additions\nto clarify usage are always my first places to look when reviewing -\nespecially so as mux has grown \ud83d\ude09\nOn Tue, Mar 5, 2019 at 7:08 AM Anton Vlasenko notifications@github.com\nwrote:\n\n@elithrar https://github.com/elithrar yeah, especially I understand you\nnow even more than when I made this PR, this particular code is not\ncompatible much with\nhttps://github.com/gorilla/handlers/blob/master/cors.go and is not\nsolving any CORS challenges. It probably needs to be integrated into\ngorilla/handlers code or just removed completely.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/459#issuecomment-469673112, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcHeiHfEre1g5xoXtOwdK9Rq7R9Kqks5vTmw3gaJpZM4bcxk5\n.\n. Agree that subroutes should be able to define this.\n\n(Preventing applying this to subrouters is both harder technically & less\nobvious).\nWould welcome a PR.\nOn Wed, Mar 13, 2019 at 11:01 AM George Vilches notifications@github.com\nwrote:\n\nWhat version of Go are you running? (Paste the output of go version)\ngo version go1.11.5 darwin/amd64\nWhat version of gorilla/mux are you at? (Paste the output of git\nrev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\n15a353a\nhttps://github.com/gorilla/mux/commit/15a353a636720571d19e37b34a14499c3afa9991\nDescribe your problem (and what you have tried so far)\nSkipClean when applied only on subrouters does not check for cleaned URLs\non subroutes. It only applies to the entire routing event, on or off.\nWhat we expect to happen: On routes that are declared with\nSkipClean(false), those routes are checked against the cleaned URL. On\nroutes that are declared with SkipClean(true), those routes are checked\nagainst the original URL.\nOr else, SkipClean should only be allowed on the parent Router, and not on\nany subrouters, since it's currently ineffective.\n(This probably opens the door for also processing those routes as an\ninternal redirect instead of a public 302 as an option, but I think that\nshould be a separate ticket and isn't required for this behavior).\nPaste a minimal, runnable, reproduction of your issue below (use\nbackticks to format it)\nfunc TestSkipCleanSubrouter(t testing.T) {\n  func1 := func(w http.ResponseWriter, r http.Request) {}\n  func2 := func(w http.ResponseWriter, r *http.Request) {}\nr := NewRouter()\n  r.HandleFunc(\"/api/\", func1).Name(\"func2\")\n  r.SkipClean(true)\n  subRouter := r.PathPrefix(\"/v0\").Subrouter().SkipClean(false)\n  subRouter.HandleFunc(\"/action/do/\", func2).Name(\"func2\")\nreq, _ := http.NewRequest(\"GET\", \"http://localhost/api/?abc=def\", nil)\n  res := NewRecorder()\n  r.ServeHTTP(res, req)\nif len(res.HeaderMap[\"Location\"]) != 0 {\n      t.Errorf(\"Req 1: Shouldn't redirect since route is already clean\")\n  }\nreq, _ = http.NewRequest(\"GET\", \"http://localhost//api/?abc=def\", nil)\n  res = NewRecorder()\n  r.ServeHTTP(res, req)\nif len(res.HeaderMap[\"Location\"]) != 0 {\n      t.Errorf(\"Req 2: Shouldn't redirect since skip clean is disabled\")\n  }\nreq, _ = http.NewRequest(\"GET\", \"http://localhost/v0/action//do/?ghi=jkl\", nil)\n  res = NewRecorder()\n  r.ServeHTTP(res, req)\nif len(res.HeaderMap[\"Location\"]) == 0 {\n      t.Errorf(\"Req 3: Should redirect since skip clean is enabled for subroute\")\n  }\n}\nExpected:\nTests pass.\nActual:\n--- FAIL: TestSkipCleanSubrouter (0.00s)\n    mux_test.go:2029: Req 3: Should redirect since skip clean is enabled for subroute\nI'm happy to provide a patch that would address this in whichever\ndirection should be supported. I'm of the opinion that subroutes should be\nable to determine whether or not they should be tested against the original\nor the cleaned URL.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/460, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcDuu3JGptUQ2vWN99ewlyhfEEFx2ks5vWTz8gaJpZM4buYXR\n.\n. https://godoc.org/github.com/gorilla/mux?importers\n\nDocker & Kubernetes components both use mux.\nI would say that mux & Chi aren\u2019t so vastly different, though. Pick the\nlibrary with the API & documentation you understand best.\nOn Thu, Mar 14, 2019 at 8:58 PM ZL notifications@github.com wrote:\n\nWhat version of Go are you running? (Paste the output of go version)\nlatest\nWhat version of gorilla/mux are you at? (Paste the output of git\nrev-parse HEAD inside $GOPATH/src/github.com/gorilla/mux)\nlatest\nDescribe your problem (and what you have tried so far)\ni want to use gorrial mux to replace the native http.ServeMux in our\nproduct(object storage service), and i serach google, it show that Chi is\nsimilar with gorilla, but Chi are used in many company, so i want to know\nis there any company that use gorilla mux in product ?\nPaste a minimal, runnable, reproduction of your issue below (use\nbackticks to format it)\nrefer above describtion.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/461, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcC1ZR64smojWVGrZ9S8qxJcSsbwZks5vWxp_gaJpZM4b1qbD\n.\n. Thanks for this - I hadn\u2019t been keeping up!\n\nOn Sat, Mar 16, 2019 at 1:28 AM sekky0905 notifications@github.com wrote:\n\nWhat I did\nRemove sudo: false setting from travis.yml .\nContext\nAccording to the following posts, Travis-CI had two Linux infrastructures\nwhich are containers and virtual machines, but recently Travis-CI was\ncombined two Linux infrastructures into a virtual machine-based Linux\ninfrastructures.\nhttps://blog.travis-ci.com/2018-11-19-required-linux-infrastructure-migration\nhttps://blog.travis-ci.com/2018-10-04-combining-linux-infrastructures\nNow Container-based environment is duplicated.\nBuild Environment Overview - Travis CI\nhttps://docs.travis-ci.com/user/reference/overview/#deprecated-virtualization-environments\nIf you currently specify sudo: false in your .travis.yml, we recommend\nremoving that configuration soon.\nquoted by\nhttps://blog.travis-ci.com/2018-11-19-required-linux-infrastructure-migration\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/462\nCommit Summary\n\nRemove sudo setting from travis.yml\n\nFile Changes\n\nM .travis.yml\n   https://github.com/gorilla/mux/pull/462/files#diff-0 (2)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/462.patch\nhttps://github.com/gorilla/mux/pull/462.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/462, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcDbTACLhskPh4uZIQDNOYxkQdKxCks5vXKsegaJpZM4b3r4U\n.\n. I assume any output from the diff will cause the test to fail?\n. What is the goal of making a route private? I don't think this is worth adding to the public API, and it could be confused for some kind of authentication functionality. \n. This would need documentation if we were to merge it. \n. This would need documentation if we were to merge it. \n. Totally fine by me :+1: \n. If we don't report it as a match we would need to re-engineer how sub-router 404 handling works (e.g. revert this).\n\nThe alternative would be to set match.Handler == nil and then add another field to Router to handle this behaviour.\n. Can you expand on this? What is this useful for?\n. go\n// GetPathTemplate returns the template used to build the\n// route match.\n. go\n// This is useful for building simple REST API documentation and for instrumentation\n// against third-party services.\n// An error will be returned if the route does not define a path.\n. Need its own godoc string.\ngo\n// GetHostTemplate returns the template used to build the\n// route match.\n// An error will be returned if the route does not define a host.\n. We should still add SkipClean() as a method on *Route as well.\n. SkipClean defines the path cleaning behaviour for new routes. The initial value is false. Users should be careful about which routes are not cleaned.\n. Could a panic be triggered here? punycode and RFC compliant hosts should not (I have not tested exhaustively...), but worried about adding MustCompile to the request critical path.\n. typo: \"unintended\" \n. I'm all for breaking it out.\nOn Tue, Aug 30, 2016 at 2:22 PM Kush Mansingh notifications@github.com\nwrote:\n\nIn mux_test.go\nhttps://github.com/gorilla/mux/pull/190#discussion_r76857850:\n\n@@ -336,8 +336,8 @@ func TestPath(t *testing.T) {\n            shouldMatch:  false,\n        },\n        {\n-           title:        \"Path route, URL with encoded slash does match\",\n-           route:        new(Route).Path(\"/v1/{v1}/v2\"),\n-           title:        \"Path route with useEncodedPath, URL with encoded slash does match\",\n-           route:        (&Route{useEncodedPath: true}).Path(\"/v1/{v1}/v2\"),\n\nI don't really like this. I'm debating whether it's worth breaking out\ninto something like TestSkipClean\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/190/files/80a7f1ea478c9ef6768a3e1f24e15b57a6d0f563#r76857850,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPDuuP1tz2imALcD9F21ofwNn210ks5qlH0OgaJpZM4Jw235\n.\n. Better: UseEncodedPath() - because UseEncodedPath(false) doesn't make a ton of sense.\n. I don't think that'd be possible: the routes are all walked together before\nserving, so you can't change the state of the *Router.\n\nOn Thu, Sep 1, 2016 at 6:28 AM Kush Mansingh notifications@github.com\nwrote:\n\nIn mux.go https://github.com/gorilla/mux/pull/190#discussion_r77173217:\n\n@@ -152,6 +157,23 @@ func (r Router) SkipClean(value bool) Router {\n    return r\n }\n+// UseEncodedPath defines the route matching behavior. The initial value is\n+// false.\n+//\n+// When true, the router will match the encoded original path to the routes.\n+// For eg. \"/path/foo%2Fbar/to\" will match the path \"/path/{var}/to\".\n+// This behavior has the drawback of needing to match routes against\n+// r.RequestURI instead of r.URL.Path. Any modifications (such as http.StripPrefix)\n+// to r.URL.Path will not affect routing when this flag is on and thus may\n+// induce unintended behavior.\n+//\n+// When false, the router will match the unencoded path to the routes.\n+// For eg. \"/path/foo%2Fbar/to\" will match the path \"/path/foo/bar/to\"\n+func (r Router) UseEncodedPath(value bool) Router {\n\nSilly edge case but what if someone wants to turn it off later? They turn\nit on, add a couple of routes, turn it off and add some routes they don't\nwant the behavior for.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/190/files/e1369e2f556615f31a912d38297ba821fdf3c5e5#r77173217,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcGPVVk352T7TlMdaWyOMeoN2lXIJks5qltLsgaJpZM4Jw235\n.\n. // Addresses https://github.com/gorilla/mux/issues/200\n. Is it not possible for this test case to stay? If we keep it, do the tests fail?\n. @neelance Does failing this test break the intent of your original changes in 0b13a922203ebdbfd236c818efcd5ed46097d690?\n. Yes - most users probably don't know the difference between a capturing and non-capturing group (or care), we could show an error.\n\nHowever, the only path to doing so is a panic, and we'd effectively have to use a regex on the pattern first to look for non-capturing groups...\n. Handle the errors in the docs.\n. Should describe a use-case - e.g. \"Routes on a mux can be listed using the Router.Walk method\u2014useful for generating documentation:\". We shouldn't link to the issue. We should instead show the failing route - \"route %q contains capture groups in its regexp. Only non-capturing groups are accepted: e.g. (?:pattern) instead of (pattern)\"\n(or an approximation of that). Can this not be rolled into an existing field for testing? (just wary of adding once-off test fields). Don't modify these - should show both the simple (non-method) and precise (provide a method) use-cases.. Don't ignore errors in READMEs; newbies learn bad practices ;). nitpick: s/doesn't/does not/. nitpick: s/doesn't/does not/. Add comments to describe why these are useful in the example - e.g. example output. The paths/regexp here is simple.. \"expanded regular expression\" (less abbreviations). \"GetMethods returns the methods the route matches against.\". Since we don't use the text for this, we should either:\n\nLowercase this as convention - e.g. method is not allowed\nUse an enum to reflect the type of error it is.\n\nString errors are inflexible and fragile.. Call it handler. Follow the format used elsewhere in this file - e.g. Expected: %v Got: %v  . This doesn't feel right: if you provide an error here you can't are extremely limited in how you can customize 405 responses.\nShould we not offer a MethodNotAllowedHandler field on the Router akin to NotFoundHandler that a package user can customize? See https://godoc.org/github.com/gorilla/mux#Router. @maknahar If you can add that as well, we can merge - that way it's feature-complete :). Change to \"Configurable Handler to be used when the request method does not match the route.\". I would add some context - \u201dsubrouter should not have matched: got %v\u201d, route\u201d to aid debugging.. Here too.. Here too.. Replace \"router\" with [Router](https://godoc.org/github.com/gorilla/mux#Router) so that we link to the docs.. s/function/type. s/Structs/Types. Examples for both please!. I'm not entirely convinced this interface is useful. Can you expand more on how this is a better API vs. only supporting func(http.Handler) http.Handler - ?. It may be better to break this up a little, to allow parallel test execution (via t.Parallel()),.. It isn't obvious (e.g. at first) what the purpose of the slice of bools / flags are for at first. Can you add a comment here to aid future contributors, and/or (better) look at a better way to test these that doesn't require this state tracking?. \ud83d\udc4d . Use backticks (`) for raw strings so you don't have to escape quotes.. Need to fix. Can't do that in GitHub.. Introduced a space and can\u2019t edit my branch via the web UI (not at my laptop) \ud83d\ude09. Could you expand on this? Why it exists, what the normal way of setting params is; URL should also be capitalized. . Suggestion:\n// TestSetURLParam sets the URL params for the given request, to be accessed via mux.Vars for testing route behaviour.\n//\n// This API should only be used for testing purposes; it provides a way to inject variables into the request context.. I don't think we should keep this. Single method interfaces can be restrictive; best to let the package user define a wrapper if needed. We end up adding similarly-named methods to the API.\n(if there is demand over time, we can re-assess). We should document/clarify how handlers are executed (in order they added).. \ud83d\udc4c\ud83c\udffc. * Add a quick paragraph describing what middleware is / what it can be used for, and link to https://github.com/gorilla/handlers\n* Version will be v1.6.1 if we merge this week (I'll cut a new release after this PR is merged in)\ne.g.\n\nMiddleware describes intermediate handlers that can check, mutate or log the incoming request or outgoing response. mux makes it easy to add middleware to a Router or Subrouter.... > \"This can be used to avoid passing the request on, but make sure to return a response to the client from within the middleware\"\nNote: a library of useful logging, CORS and proxy-related middleware can be found in the gorilla/handlers package. Update to align with the README\n\n(Note to self: use tooling to make this automatic...). Update this? As we don't export the Middleware interface (middleware) this may be confusing.. AddMiddleware, Add or UseMiddleware or just Use might be less verbose here.\n\nchi and echo call their methods Use\nexpress also calls it use\nDownside to Use - not entirely self-documenting.\n\nI'd be OK with just calling this function Middleware as \"Add\" is obvious, and subtracting it/removing it later is (mostly) a non-option.. > Middleware adds a middleware to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router.. Just the comment \ud83d\udc4c\ud83c\udffc. Let\u2019s just stick with Use - as that\u2019s familiar and aligns with the Handle (takes a http.Handler) and HandleFunc (takes a HandlerFunc) on Router. This somewhat sits in the middle, but familiarity wins out in lieu of other objections.\n. Good move. I think it's fair to assume that the documentation reflects HEAD.. Fixed (added). Also added to the other two examples to make it clear to a beginner which files the snippets are from.. I\u2019ll take a look today. The website doesn\u2019t do Markdown, which is a bit of a pain.. https://github.com/gorilla/mux/pull/333. Two parts:\n\nI think the function name could be more descriptive here: CORSMethodMiddleware - something to indicate that it applies to a CORS-driven use-case.\nDo we want to build the routes on every request? (may not be avoidable to avoid stale data, but thinking out loud here). \"to the http.ResponseWriter\" or just \"to the response\".. Extra space between \"a\" and \"request\". \"Sets the Access-Control-Allow-Methods response header...\". Can you point me to the relevant section of the RFC that covers this requirement for the Host header? It is mentioned in the context of a URL, but seems more ambiguous in the context of a Host header. It is not immediately clear in 7230 either: https://tools.ietf.org/html/rfc7230#section-5.4\n\n\n3.2.2 http URL\nThe \"http\" scheme is used to locate network resources via the HTTP\n   protocol. This section defines the scheme-specific syntax and\n   semantics for http URLs.\n http_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query ]]\nIf the port is empty or not given, port 80 is assumed. \n\nI'm cautious about making changes here as it may change the matching behaviour (read: breaking change) of existing users.. The docs here should be clear that the middleware will respond with a default set of methods, and list those methods, unless a specific set of methods apply to that route.\nHowever, the more I think on this, adding non-idempotent methods by default seems risky. Why not just safe + idempotent (yes, I'm aware that people break these semantics...) methods - OPTIONS, GET, HEAD, TRACE - as per https://tools.ietf.org/html/rfc7231#section-8.1.3 - ?. Can you rebase this to pick up the addition of 1.11.x ?. Rename this to context.go. Rename to context_test.go. Maybe the better fix is to prevent this from happening, and overwrite a duplicate router rather than naively appending to the routes []*Route slice?\nThis will make the addition of new routes slower, but should not impact runtime performance as adding new routes is typically a once-off occurrence.\n. I would also describe \"why\" this is a problem (user error).. Explain why, not what.. Needs trailing newline.. type emptyHandler struct{} (same line). Middleware. Middleware and Routing. : middleware will not run before/after these handlers.. Can you add a test for this that ensures it copies all fields? This way, any new fields added to routeConf will cause tests to fail if copyRouteConf is not updated in kind.. Can you add a third test here for a non-matching route? e.g. Hit /second/not-exists.. t.Failf(\"Middleware did not run: expected %s middleware to write a response (got %s)\", first, body). t.Failf(\"Middleware did not run: expected %s middleware to write a response (got %s)\", second, body). Tell a story / why - it's obvious that we reset it :)\nInstead, say: \"Set MatchErr to nil to prevent subsequent matching subrouters from failing to run middleware. If not reset, the middleware would see a non-nil MatchErr and be skipped, even when there was a matching route\". ",
    "paddycarver": "I implemented this crudely as part of our fork of mux, in 3 commits:\nhttps://github.com/DramaFever/mux/commit/dcdec4c5bd3a42e787fe707eaea0e9ae8127683c\nhttps://github.com/DramaFever/mux/commit/a18be6ab3ee63fa23d339c4ec3fc1abe13f7d184\nhttps://github.com/DramaFever/mux/commit/8051bd6b1896148d25b231079b9ce4765296837b\nI'd be happy to clean it up, add some tests, and contribute it back.\nNote that it doesn't automatically send back the 405, but the NotFound handler can then be extended to do so:\ngo\nr.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n        methods := r.GetMethods(req)\n        if len(methods) > 0 {\n                        // return 405\n            return\n        }\n                // return 404\n        return\n    })\nAdditionally, with a bit more intrusive hacking, a MethodNotAllowedHandler property could be added, to avoid overriding the NotFoundHandler.\nAgain, happy to contribute this back if this is something that's desired in the upstream.\n. ",
    "toovs": "router.Handle(\"/{_:(.*)}\", http.FileServer(http.Dir(\"../\"))) seems to work for now.. don't know if this is the intended behavior or not.\n. ",
    "atomaths": "@moraes Apparently, it seems to be legitimate. http://golang.org/ref/spec#Signature\n. ",
    "donovanhide": "Hi Rodrigo, \nthanks for getting back! There's a bit more discussion here.\nI guess some url validation is so complicated that you can't avoid subexpressions for repeated elements that make up a fragment. My use case is fine with just the outer capture group, but the inner groups are required to deal with validating each sequence of an interval. It is complicated, but allows for powerful querying in my app :-)\nThe patch doesn't break any existing functionality - it always returns the outer group, but works when subexpressions are present.\nLet me know if you need anything else!\nCheers,\nDonovan. \n. ",
    "tcard": "I just hit the same problem! Regexps cannot be properly called regexps if subexpressions aren't allowed, regardless they are passed or not. For example, a simple list of comma-separated words [a-z]+(,[a-z]+)* is impossible to express (if I'm not mistaken). I think this should be merged.\n. (I suppose I just intend commit 7a711bc to be merged for this pull request.)\n. ",
    "attilaolah": "We have something very similar in our app. I am matching something like /path/to/{id:[1-9]\\d*}+{hash:[0-9a-z]{40}}@example.com, where I prefer the email format validation to be kept in the regex, but I do actually need the outer group. My solution is not to use subexpressions and just reconstruct what otherwise would be the outer group inside the handler.\nIt would be much nicer though if this gets pulled, then I can just grab that value from mux.Vars().\n. ",
    "djgilcrease": "Since you are not actually using the sub expressions (capture groups)\n/{v1:\\\\d+(-\\\\d+)?(:\\\\d+(-\\\\d+)?)*}/{v2:\\\\d+(-\\\\d+)?(:\\\\d+(-\\\\d+)?)*}\ncould be\n/{v1:\\\\d+(?:-\\\\d+)?(?::\\\\d+(?:-\\\\d+)?)*}/{v2:\\\\d+(?:-\\\\d+)?(?::\\\\d+(?:-\\\\d+)?)*}\nAnd it will work as expected with the existing code\n. @KoFish There is a big difference between Path & PathPrefix\nIn your example the only paths that would actually be matched are\n/foo/\n/bar/\n/{id}\n/\nPath changes the regex used to match to be <path>$ which means that the whole path must end with <path> So in almost all cases you want to use PathPrefix \n. This does not walk down named routes properly\n``` go\nrouter.Handle(\"/\", handlers.Index(router))\napi_v1 := router.PathPrefix(\"/api/v1\")).Subrouter()\n//Define all URLs for Products\nproducts := api_v1.PathPrefix(\"products\")).Name(\"products\").Subrouter()\nproducts_by_id := products.Path(\"{product_id:[a-f0-9]{8}(?:-[a-f0-9]{4}){3}-[a-f0-9]{12}}\").Name(\"product-by-id\").Subrouter()\nproducts_by_name := products.Path(\"{product_name:[a-z0-9-_~.]+}\").Name(\"product-by-name\").Subrouter()\n```\nThe current implementation will only walk / & /api/v1 but none of the /api/v1/products routes\n. Take a look at https://github.com/gorilla/mux/pull/104 and see if it would meet your requirements.\nYou would need to do something like\ngo\nfunc (h *InstrumentMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    route := mux.CurrentRoute(r)\n    path, _ := route.URLPathTemplate()\n    h.instrumenter.Start(path)\n    defer h.instrumenter.End()\n    h.handler.ServeHTTP(w, r)\n}\n. Obviously I find it useful. I use it in every rest service I have written with gorilla to serve up a simple api doc. I also use it heavily for instrumentation with new relic to ensure it is reporting consistently.\nThis also allows @tleyden to do what he is requesting in issue #129\n. Updated comments, and added a new testTemplate method that is called everywhere testRoute is called.\n. All updated based on latest feedback\n. Sounds good, and what I figured :)\n. ",
    "fluffysquirrels": "\nWhat if we default to http, but if there's a schemesMatcher in the route, use the first scheme defined there?\n\n+1 @kisielk\n. ",
    "adone": "Any opinions for this solutions?\n. Hi @odlp! It will be great! I don't have enough free time for this \ud83d\ude1e \n. added test for https URL building\nnot sure it is enough\n. I am not interesting in upgrade this PR for more complex logic because I don't use mux anymore. ",
    "ChrisHines": "I am interested in moving this feature forward. I can work on adding the tests.. I am interested in moving this PR forward. I can work on adding tests.. What was the thinking behind the implementation in this PR? In particular, why does Route.URL only choose a scheme of \"http\" or \"https\", and why does \"https\" always take priority when multiple schemes are configured?\nWas the idea proposed by @kisielk in https://github.com/gorilla/mux/issues/13#issuecomment-13209910 rejected or found to be a bad idea for some reason?. I will take this over. I plan to change the implementation to use the first registered scheme or a default of \"http\" when no schemes are registered. I will open a new PR when I have it ready.. @kisielk Yes. #260 and #280 make this PR obsolete.. I would like to see this functionality get merged. What work remains to be done?. It appears #230 is already in progress to address this shortcoming.. What about using Router.Walk to decorate post-facto? You could write a function like this:\ngo\nfunc DecorateHandlers(r *mux.Router, decorate func(http.Handler) http.Handler) error {\n    return r.Walk(func(route *Route, router *Router, ancestors []*Route) error {\n        return route.Handler(decorate(route.GetHandler())).GetError()\n    }\n}\nGiven that, you build your routes undecorated then make one call to DecorateHandlers(r, my.DecoratorFunc) at the end.. >As you can see, the test passes (so the handler is clearly invoked), but handler reports as nil when walking the routes, so the decoration approach is out -- although I'm sure I could debug this/figure out a way to try to get at all the handlers in the walk, I'm weary of adding too much logic there and would be afraid of the consequences of missing an edge case where some handler would not be found by the walk and thus not wrapped properly.\nIf Walk is broken I don't think the solution is to add more API surface area as a work around. Let's fix Walk first.. Agreed. I was having doubts about URLScheme myself.. I'm trying to remove URLScheme, but it doesn't work as cleanly as I'd hope. Specifically the suggested work around of schemeURL := &url.URL{Scheme: r.URL().Scheme} doesn't work if the route doesn't have a host or path. Similarly, r.URLHost() returns an error if r doesn't have a configured host.. The testing is less elegant, but it works. PTAL.. Rebased on master to resolve conflicts in mux_test.go.. Somehow mux_test.go had acquired a BOM.. > Somehow mux_test.go had acquired a BOM.\nThe tool I used to resolve the conflict when rebasing was the source of the BOM. I've changed the settings on that so I won't have that problem again.. Good catch. Fixed.. My thinking was that since the choice was made that building a URL uses the first scheme set, the extension of that for subrouters would be using the first scheme found starting at the root.\nI am just now starting to understand the relationship between routes with schemes at multiple levels. When matching, I suppose the parent would need to include all schemes that its child routes care about. The children could either match all schemes of the parent, or a subset.\nGiven that relationship, I see how building a URL for a child route should prefer the scheme of the child (if present), rather than the way I implemented this.\nDo you agree? If so, I can add a test to verify that behavior and update the implementation.. ",
    "jmassara": "This would be really useful.  See here.  It would be nice to do something like this:\ngo\nr.HandleFunc(\"/myapp\", MyHandler).\n    Methods(\"GET\").\n    Headers(\"Accept\", \"application/vnd.myapp-v{version:[0-9]+}+json\")\nhttp.Handle(\"/\", r)\nOr:\ngo\nr.HandleFunc(\"/myapp\", MyHandler).\n    Methods(\"GET\").\n    Headers(\"Accept\", \"application/vnd.myapp-v{version:[0-9]+}+{format:json|xml}\")\nhttp.Handle(\"/\", r)\n. It would be nice to support capturing regex matches in mux.Vars() (see my previous comment), similiar to how the router.HandlerFunc does it.\n. ",
    "fdelbos": "+1 \nthis:\ngo\nr.HandleFunc(\"/path\", MyHandler).\n        Methods(\"POST\").\n        Headers(\"Content-Type\", \"application/json\")\nwill not match a request with \"Content-Type\", \"application/json;charset=UTF-8\"\nand this:\ngo\nr.HandleFunc(\"/path\", MyHandler).\n        Methods(\"POST\").\n        Headers(\"Content-Type\", \"application/json;charset=UTF-8\")\nwill not match a request with \"Content-Type\", \"application/json\"\n. ",
    "eastwood": "I've added regex support. An example of usage is as follows:\nr := mux.NewRouter()\n    r.HandleFunc(\"/\", RootHandler).Headers(\"Content-Type\", \"application/json.*\")\n    http.ListenAndServe(\":8080\", r)\n}\nNow both requests will work:\ncurl -X GET -H \"Content-Type: application/json\" localhost:8080\ncurl -X GET -H \"Content-Type: application/json;charset=UTF-8\" localhost:8080\nMy personal uses were for handling application/(json|text)\n. @bluehallu  That's correct. Above comment is out of date. The documentation should be up to date with this, if anybody requires it\n. Ah I see :) Good pickup, sorry about the confusion, must of been a legacy commit. I'll clean that up right away to fix the confusion. Alternatively, you can fix the change and make a pull request, the more contributors the merrier!\n. #125 Should fix this up for us\n. This is how I achieve the desired result. I believe the idiomatic way to achieve this is using PathPrefix\n```\nfunc main() {\n    r := mux.NewRouter()\n    foo := r.PathPrefix(\"/foo\").Subrouter()\n    foo.Path(\"/{key}\").HandlerFunc(Test)\n    bar := foo.PathPrefix(\"/bar\").Subrouter()\n    bar.Path(\"/\").HandlerFunc(Test)\n    bar.Path(\"/baz\").HandlerFunc(Test)\nhttp.ListenAndServe(\":8080\", r)\n\n}\n``\n. I believe this is correct behavior. Though I can understand the confusion. ThePathPrefixdoesn't prefix all the setPathroutes per se, but in fact behaves just likePath` does. However, with the exception that it matches any path appended to the value. That may be a little verbose so, a little explanation! \nIn the source, the Route type uses Matchers to determine whether a request is matching a given Handler. Think of a matcher like a regular expression and the route your creating is in essence, building up a regular expression.\nIn your code, the first statement:\nr.Path( \"/testpath\")\nYou've essentially create a route that matches on specifically /testpath. Continuing on...\nr.Path(\"/testpath\").PathPrefix(\"/prefix/\")\nWhen you add another matcher to the stack (it's sequential), it's says to match the criteria of /prefix/.* after you've matched \"/testpath\". Therefore, you've essentially created a route that says match any request with the Matcher (or regex):\n/testpath/prefix/.* \nIn lieu, think of the PathPrefix Matcher, just like Path in that it chains Matchers. However, instead of matching strictly on the path given, it matches on anything beginning with the path given.\n. Yea good point. Though, I thought that the matchMap function was only used on the header, so I assumed it wouldn't break backwards compatibility. However, a separate matcher does have the perf benefits\n. Yea I understood you're meaning, just didn't have the foresight to see what people would put in their headers (anything). Anyway, I've made alterations, let me know what you think :)\n. Thanks for the tip, I should have assumed there was an equivalent to Pattern#compile(String s) for Golang. Will rebase and try again :)\n. It's probably not the most idiomatic way to do things. Still learning the best way to do things. Not having inheritance is always fun :P \n. @kisielk  Did you decide what you want to do? Do you want me to throw a panic message upon error, or did you want me to let the code to be synonymous with the other style?\n. Yea that's a good idea. I'll be interested in seeing what ideas you have with solving that.\n. @kisielk\nHow'd we go on this one?\n. Yea I figured as much :)\nI got a bit delayed with RL, but cheers for code review\n. Yea sounds great. Thanks for the code review, really appreciate :) Will fix this up tomorrow afternoon\n. ",
    "bluehallu": "@eastwood isn't HeadersRegexp what should be used here?\n. @eastwood I've tested the code and it behaves as you'd expect, but the docs are in sync with your comment above:\n\"...Alternatively, you can provide a regular expression and match the header as follows...\"\n. I wanted to make sure I wasn't misunderstanding this before doing a PR. All\nfixed now so thanks :)\nOn Tue, 8 Sep 2015 12:34 Clinton Ryan notifications@github.com wrote:\n\n125 https://github.com/gorilla/mux/pull/125 Should fix this up for us\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/16#issuecomment-138526635.\n. @elithrar The problem is that it's not just undocumented behaviour, it's actually preventing you from supplying your own raw regex!\n. What about an optional flag to change this behaviour?\n. I'm afraid I only used Go once in my life, spotted this weird behaviour in one of the main libraries and reported it, but that's where my Mux knowledge ends. I don't think I'm in a position to make recommendations about how the Api for this library should be designed in any more detail than I already have. An optional boolean parameter \"strict\" comes to mind though :)\n. \n",
    "rbucker": "After some analysis I was able to determine that this and several other req.URL bugs exist in go1.0.3 and is tagged to be fixed in go1.1. I will test with 1.1 when it's available and reopen if still a problem.\n. Here is the bug report for the empty URL.Scheme. It is reported to be repaired in Go1.1. I'm on the fence as whether or not you need a test case for this, however, the actual test cases do not actually test real behavior and that's why it was not caught sooner.\nhttps://code.google.com/p/go/issues/detail?id=3805\n. agreed.  More and better tests are always welcome.\n. Actually there is a much bigger problem here. It seems that Go1.0.3 has not completed the net/html implementation:\n// TODO: Parse specific header values:\n//  Accept\n//  Accept-Encoding\n//  Accept-Language\n//  Authorization\n//  Cache-Control\n... and many more\nhttp://golang.org/src/pkg/net/http/request.go\n. Merging the 5 main gorilla projects. For tempered rational you need only watch one of the many rob pike screencasts. \nSent from my iPhone\nOn Apr 16, 2013, at 18:45, Kamil Kisiel notifications@github.com wrote:\n\nSeems to have worked well in practice thus far. Not sure what you are proposing with this issue?\n\u2014\nReply to this email directly or view it on GitHub.\n. I disagree. One repo for each package is just wasteful. Specially when the packages import each other. And when you consider the underlying principles of go. But I'm not the maintainer so it's not up to me. Thank you for humoring me. \n\nSent from my iPhone\nOn Apr 16, 2013, at 19:19, Dave Cheney notifications@github.com wrote:\n\nI think the gorilla project layout is one the best I have seen. \nOn 17/04/2013, at 9:03 AM, Kamil Kisiel notifications@github.com wrote: \n\nI doubt we will change it again any time soon as we already went from one->many repos last year and so far it seems to be working alright. I haven't seen any talks or screencasts that give any strong rationale for one way or the other, so I'd be interested in seeing those. \n\u2014 \nReply to this email directly or view it on GitHub.\n\u2014\nReply to this email directly or view it on GitHub.\n. If you do not use a package you cannot import it. It's an intentional language feature. So if you do not use mux you'll never import it because you'll get a compiler error. \n\n\nSent from my iPhone\nOn Apr 16, 2013, at 19:33, Nick Saika notifications@github.com wrote:\n\nFor what it's worth, I quite like the current layout of the project; the parts that are separated make logical sense. For instance, I may not want to have to import mux if all I want is the json/rpc library.\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks. Not necessary.\n. \n",
    "davecheney": "I think the gorilla project layout is one the best I have seen.\nOn 17/04/2013, at 9:03 AM, Kamil Kisiel notifications@github.com wrote:\n\nI doubt we will change it again any time soon as we already went from one->many repos last year and so far it seems to be working alright. I haven't seen any talks or screencasts that give any strong rationale for one way or the other, so I'd be interested in seeing those.\n\u2014\nReply to this email directly or view it on GitHub.\n. You need to set GOPATH correctly. Please review \n\nhttp://golang.org/doc/code.html\nOn 10/06/2013, at 14:17, Matthew Taylor notifications@github.com wrote:\n\nI have a very simple go file, and when I try to build, i get this:\ngo build\n_/home/matt/projects/goprojects/muxHello\n./main.go:10: undefined: mux.HandleFunc\n./main.go:14: undefined: mux.DefaultRoute\nhere is my code:\npackage main\nimport (\n    \"fmt\"\n    \"github.com/gorilla/mux\"\n    \"net/http\"\n)\nfunc main() {\n    mux.HandleFunc(\"/\", func(w http.ResponseWriter, r http.Request) {\n        fmt.Fprint(w, \"Hello\")\n    })\nhttp.Handle(\"/\", mux.DefaultRoute)\nhttp.ListenAndServe(\":10000\", nil)\n}\nI set my GOPATH to /home/matt/projects/goprojects/muxHello\nthen do\ngo get github.com/gorilla/mux\nand the folders show up in\n/home/matt/projects/goprojects/muxHello/src/github.com/gorilla/mux\n/home/matt/projects/goprojects/muxHello/src/github.com/gorilla/context\nI've tried other imports and they have worked. for instance, https://code.google.com/p/goauth2/ and https://github.com/eaigner/jet both work using the exact same steps I took with gorilla/mux.\nIt's like it is finding the package; but the package isn't exporting anything.\nhere is the output of \"go env\"\nGOARCH=\"amd64\"\nGOBIN=\"\"\nGOCHAR=\"6\"\nGOEXE=\"\"\nGOHOSTARCH=\"amd64\"\nGOHOSTOS=\"linux\"\nGOOS=\"linux\"\nGOPATH=\"/home/matt/projects/goprojects/muxHello\"\nGORACE=\"\"\nGOROOT=\"/home/matt/go\"\nGOTOOLDIR=\"/home/matt/go/pkg/tool/linux_amd64\"\nCC=\"gcc\"\nGOGCCFLAGS=\"-g -O2 -fPIC -m64 -pthread\"\nCGO_ENABLED=\"1\"\nI installed go from source. I used the release branch of go 1.1.\ngo version go1.1 linux/amd64\nI am building a restful api as my first go project. I apologize in advance if this is because of a mistake I've made or if this isn't the right \"forum\" for this. I have spent several hours trying to make sure everything is setup correctly. I don't know what else to do. I created an issue because I feel like I've done everything correctly, I followed the directions on the gorilla/mux site and I haven't had this issue with other libraries.\n\u2014\nReply to this email directly or view it on GitHub.\n. rm -rf $GOPATH/pkg\n. \n",
    "nesv": "For what it's worth, I quite like the current layout of the project; the parts that are separated make logical sense. For instance, I may not want to have to import mux if all I want is the json/rpc library.\n. This issue is already covered by issue #6.\nIt would require some heavy refactoring of the matching portions of the code base; that's not to say it cannot be done or is not being worked on, it would just require a lot of work.\n. ",
    "zeebo": "The only kinds of changes that having each package in a repo would effect are changes that break the package API which probably won't happen without a really good reason. Those kinds of changes are large enough that coordinating changes between repos is the least of the worries.\nThe only waste I see from this is having to do a couple git clones instead of one, which I don't believe is a big deal.\nFeel free to reopen this if you have a specific design issue or problem due to having multiple repos.\n. It's hard to figure out of it should be merged in because of all the whitespace diff noise. The source files appear to be formatted with standard settings. Can you fix it?\n. You can also use http://godoc.org/github.com/gorilla/mux#Router.StrictSlash\n. Does this necessarily have to be part of gorilla? Can't you do something like:\nfunc rewriteMethodFromHeader(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n        if value := req.Header.Get(\"X-Whatever\"); value != \"\" {\n            req.URL.Method = value\n        }\n        h.ServeHTTP(w, req)\n    })\n}\nand wrap your top level router? @kisielk's call.\n. You should use urlsafe base64 encoding that avoids the / character. See http://golang.org/pkg/encoding/base64/#pkg-variables\n. ",
    "error10": "I've worked around this by using a PathPrefix() after the home page route for the subroute.\nr := mux.NewRouter()\n    s := r.Host(\"{subdomain}.\" + domain).Subrouter()\n    //...more routes..\n    s.Handle(\"/\", commonChain.Then(subdomainHomepageHandler()))\n    s.PathPrefix(\"/\").Handler(commonChain.Then(http.HandlerFunc(subdomainNotFound)))\nLater, subdomainNotFound(), which for me does some extra work, will generate a (nicely templated) 404 if necessary.\n. ",
    "johnnadratowski": "@kisielk Let me know if this is sufficient.  I'm going to take a look at your suggestions for the error messages now.\n. LOL I can't believe I missed that.  I'm generally not this absent minded, it's my second day back from vacation though so I'm still shaking off the rust ;-)\nThanks for the help on this.\n. Yep, forgot that too.  Sorry about that.  I formatted the files and checked in.\n. @kisielk Sorry this took so long to get back to you with.  I've been really busy dealing with personal stuff since vacation (Mortgages are fun, yay!)\nAnyway, I think I've finished implementing your changes.  I'm going to go through and make some more comments on the last commit now.  Please let me know if there is anything else I can do, although I will be gone for the next 4 days.\n. Hey guys,\nI was just revisiting some of this stuff for a project I have coming up.  I am curious as to what was decided here.  I think this pull request should be reconsidered as it is a compliance issue.  I don't think that using the context for errors is such a bad design, as it makes it dead simple for people to customize and process these errors.   \nI hope that you agree, and reconsider this pull request.  Thanks.\n. Sorry, I pushed the close button by accident, lol.  Thank god it's Friday.\n. Well, this provides quite a bit of value right now.  I'm not sure how much value a rewrite of these modules provides.  Updating these sources was simple.  The code was easy enough to understand.  \nFrom a practical perspective, it makes sense to add this in.  Especially if you're talking about a major rewrite that would probably have other breaking changes anyway.\n. Oh, great :-)\nI will make the updates ASAP.  Can you tell me which messages specifically you'd like me to update?  Some of them don't need a body at all as per the spec, so I can just remove some of the body messages altogether.\n. Kamil:\nHey, I was away over the weekend but I put this in as soon as I saw your email.  I removed all of the message bodies from the errors.  Please let me know if there are any other changes you'd like.\nThanks!\n. Kamil:\nThanks for the help.  I finished up your suggestions.  If you have any more send them my way.\nI also have a quick question, if you don't mind:  I was wondering if there was some mechanism in place for printing out some information about the routes registered with a Router?  I didn't see anything like that in the code, but I may have just missed it.  \nI thought it would be useful in some cases where you may want to ensure that your routes are properly set up.  I was thinking something along the lines of two modes: one that would just print to stdout the list of URLs, and another mode that would print them out in a hierarchy by the router structure.\nWhat do you think?\n. @kisielk \nI exported them so people could use them to write their own custom error handlers\n. It's a nice utility method to have when you need it.  I didn't export it because it is in mux.go... If there was a pre-existing \"utils\" type of namespace I would have put it there and exported it.\n. Ahhh, haha.  I'm actually on hold on customer service right now and I wasn't paying attention too well. :-)\nI see what you mean, I think.  You want to see if there is a way to make this extensible so that devs could just tack on extra error codes/messages, customize the current messages, or turn off certain ones.  Is that along the lines of what you were thinking?\n. I see your point about backwards compatibility, but I don't think it'll be\nan issue because of two things:\n1) If they are using a custom handler for their error handling, that\nbehavior doesn't change at all.  The only difference is that temporarily\nthe error information will get added to the context, but it won't be used\nand should be cleared.\n2) The implementation of the original HTTP Not Found Handler always returns\na 404.  This, to me, seems undesirable in almost all circumstances.\n Actually, since the HTTP specification necessitates these error codes in\nthe cases I've provided, I would consider this a bug.\nUnless there is a case I'm missing, I think that backwards compatibility\nshouldn't be a huge issue for this.  Of course, I'd love to hear your\nfeedback.\nOn Mon, Jul 8, 2013 at 6:45 PM, Kamil Kisiel notifications@github.comwrote:\n\nIn mux.go:\n\n+\n+// Pretty-Prints map[string][]string to a pretty formatted string\n+func mapListToString(m map[string][]string) string {\n-    output := []string{}\n-    for key, val := range m {\n-        entry := key\n-        if val != nil {\n-            entry += \"=\" + strings.Join(val, \"|\")\n-        }\n-        output = append(output, entry)\n-    }\n-    return strings.Join(output, \", \")\n  +}\n  +\n  +// Default handler for when a URL was not matched\n  +func NotFound(w http.ResponseWriter, r *http.Request) {\n\nKind of. Basically by default it would be good if it worked exactly like\nit does now, in case people are relying on the existing behaviour.\nHowever we could provide a NotFoundHandler struct type that could have\nsome boolean options to enable different features. Someone who wanted mux\nto be more clever about error handling could then install that as their not\nfound handler.\nFor example\ntype NotFoundHandler struct {\n    // Return StatusMethodNotAllowed and set the Allow header for requests with invalid methods\n    AllowedMethods bool\n}\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/gorilla/mux/pull/26/files#r5078472\n.\n. Ah, nice catch.  I'll add the header in when I print the error.  Should I keep the response body the way it is, or remove it?  I think it might be nice to keep the body, but I'm not convinced everyone would want that as the default behavior.\n\nIn terms of implementation, I'll also store the Allow header data in a new context variable.  That context variable will be specific to the missing header errors, so it won't be used for any other error.\n. I think this was simply a mistake on my part.  I forget why I even had that error variable there.  I agree I can just check if we were able to retrieve the code variable, and if not, it's a 500.  I'll update it in my next checkin.\n. So, let me know which variables you want me to unexport.  I exported this and the context keys above because I figured that people could use them in their own implementations.  For example:\ngo\n// Custom not found handler\nfunc NotFound(w http.ResponseWriter, r *http.Request) {\n   // Do something custom\n   mux.NotFound(w, r)\n}\n. Absolutely.  We could have a struct type that defines the data structure for a mux error.  That struct could define a code int, a message body string, and whatever else we may need.  Then we'd just need 1 context key/value for any given error.  \nWhat do you think about this:\ngo\ntype MuxError struct {\n    Code int\n    Body string\n    // Instead of having one specifically for allow headers, we can just put headers that will be added to the response, like code and body\n    Headers map[string][]string\n}\nThoughts?\n. We still wanted to export this, so users could use it when writing their own NotFound handlers, right?\n. This struct should contain everything we talked about, but I'm not sure if there was any more functionality you wanted to add to it.  Also, I couldn't think of a better name than \"MatchError\", suggestions are welcome :-)\n. Previously I was defaulting this to a 500, but I thought that might be a little too harsh, so I changed it to default to 404.\n. I'm not sure if there is a better way to merge these headers.  I didn't want to use w.Header().Set in case the user had previously added header values.  I also didn't want to just use matchStruct.Headers.Get as it returns the full string and I wanted to append the values, but that  concern might be unfounded. \n. Do we want to keep the message body for these?\n. ",
    "jmoiron": "Looks good to me :ok_hand:\n. ",
    "josharian": "Is this still alive? I'd love to see it make it in. (I'd also be a-ok with a bigger refactoring that covers this territory, even if it means it is time for mux2.)\n. ",
    "mttrs": "Is it still alive?\n. ",
    "solarfly73": "I'm still getting familiar with the code. Is the differentiation between a missing endpoint vs. a missing method happen the regexp.go area?. Looks like the problem is r.addMatcher doesn't know the context of the type of thing it's matching on. There's no relationship between MatcherFunc a return code if a match wasn't found, but there needs to be an association. . That's 2013. Can we reinvigorate that effort? I'm willing to dive into it to get a 405 instead of a 404, since it both makes unit testing more precise and returns the correct code to 3rd party API integrators. Also I didn't see a 405 in the code diff, but I'm still getting familiar with the code (as of this morning). . ",
    "luv2code": "I can confirm that using the new route fixed my issue.  I got the code by googling \"gorilla mux hello world example\" and got a really old example.\nIt is just a case of staring at a problem too long and missing the obvious. I could've figured this out myself if I had just read through mux.go.\n@davecheney I read that article and I don't see what's wrong with my GOPATH. It's set to the root of my workspace just like the web page says. Please pm me if you don't feel like replying here. I am eager to learn.\nSorry for creating an issue for something so dumb, and thanks for the help.\n. ",
    "chuckpreslar": "Great call @kisielk, wasn't think about running gofmt manually.\n. i have not @kisielk.  code seems documented well, i'll give it a try.  thanks for the tip!\n. I agree, I meant to close this out first thing this morning.  Thanks you guys!\n. ",
    "tchap": "Even\ngo\nr.PathPrefix(\"/ws\").Handler(ws.Server{\n        Handshake: s.handleWSHandshake,\n        Handler:   s.handleWSConnection,\n})\nis not working. It's giving me GET /ws -> 404.\n. ",
    "longsleep": "Gorilla works fine with /ws handler for us. See https://github.com/strukturag/spreed-speakfreely/blob/master/src/app/spreed-speakfreely-server/main.go#L309 - i guess this can be closed.\n. ",
    "bipin244": "Can anyone please share a working example of WebSocket with gorilla mux?. Okay thank my friend.. ",
    "fbjork": "What if I don't want the redirect, but just match the trailing slash optionally?\n. ",
    "tnine": "+1 to the question from @fbjork.  I also want to have this behavior\n. ",
    "m90": "FWIW, you can do this using patterns:\nm.Handle(\"/{route:route\\\\/?}\", handler)\nwill handle /route as well as /route/. The second part of the pattern is not really static, it's a regular expression (route is a very strict one). Consider the following example:\n```go\npackage main\nimport (\n    \"log\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc main() {\n    m := mux.NewRouter()\n    m.HandleFunc(\"/things/{id:0-9?}\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"match\"))\n    })\n    log.Fatal(http.ListenAndServe(\":1337\", m))\n}\n```\nThis will match /things/9 just like /things/7/. ",
    "babolivier": "\nFWIW, you can do this using patterns:\nm.Handle(\"/{route:route\\\\/?}\", handler)\nwill handle /route as well as /route/\n\nIs there a way to do this when the last part in your path is a variable, for example if I want the same route to match for /{var} and /{var}/? Or does it necessary lead to code duplication?. How would you do that in my case? Sorry for asking, I might not be familiar enough with the groups' syntax. I tried a few things but none of them worked.. My use case is that the last part of the root path is a variable, while your example shows the case of a static last part. I'd like the route to match both /{myVar} and /{myVar}/ but without capturing the trailing slash in the myVar variable.. I understand that (sorry for not being specific enough between static/strict regular expression). However, a regular expression isn't declared the same way a variable is in a route. eg:\ngo\nm.HandleFunc(\"/things/{thing:[a-z]}\", handler)\nisn't, from what I understand, the same as\ngo\nm.HandleFunc(\"/things/{thing}\", handler)\nmy case is the second one. Sorry if I'm not clear enough.\nI perfectly understand how to do it with a regular expression, but not how to do it with just the variable name.. ",
    "PierBover": "Wouldn't it be simpler to just have a parameter to ignore trailing slashes?. ",
    "benyanke": "Any updates on this one? This seems like prime real estate for a simple parameter. . ",
    "jnishiyama": "@elithrar how would one take care of the situation where the last part of the path is a variable\ne.g. \"/products/{id:[0-9]+(?:\\\\/)?}\" \nThis will match both /products/1 and /products/1/, but id will be passed as id == 1 and id == 1/, respectively. Is there a way to elegantly handle this situation?\nFrom the source code, it seems pretty hard to get around as I believe that the relevant part of the regex expression generated would be (?P<id>[0-9]+(?:\\/)?) which will have a named group match at <id> == 1/.\n. ",
    "Crisfole": "Just for clarity: you're not using a Subrouter that I can see anywhere...PathPrefix doesn't create a Subrouter, Subrouter does.  Try doing this instead:\nr := mux.NewRouter()\nsr := r.PathPrefix(\"/foo\").Subrouter()\nsr.Path(\"/\").HandlerFunc(...)\n. Actually, that's definitely what's happening, your current route says: \"Only Match on Root, AND when the Prefix is '/foo'\" You'll note that's not a possible combination.  Notice the return type of PathPrefix.\n. @kisielk Not a fan either: it was the first thing I came up with. Using And and Or as a function name has always bugged me.\nI do think my other suggestion would work very well: Making sure that all the mux methods allow expressing alternatives.\nThe downside of that suggestion is the fact that it's 100% backwards incompatible.\n. Just so we're entirely clear: my main irritation is that I dislike entering the same code in over and over:\nr.Headers(\"Content-Type\", \"application/json\").HandlerFunc(MyHandler)\nr.Headers(\"Content-Type\", \"text/x-json\").HandlerFunc(MyHandler)\n. Yes, it definitely works, until you want to add a bunch of other matching features and you've got a large, complex application there:\nfor _, ct := range []string{\"application/json\", \"text/x-json\"} {\n  sr := r.Headers(\"Content-Type\", ct).Subrouter()\n  sr. //COMPLEX STUFF GOES, with more loops and sub routes, and stuff.\n}\nWhile it definitely works, it's not nearly as elegant as (and it's probably quite a bit slower than) having a simple way to indicate that either content type is ok.  It also doesn't allow for alternation between different Match types:\nr.Host(\"api.mysite.com\").Subrouter().//whatever\nr.PathPrefix(\"/api\").Subrouter().//whatever\nA little contrived, maybe, but some legacy systems require craziness like that.\nAgain, I agree that my implementation leaves something to be desired, but I think the current state of affairs does too.\n. Cool, looking forward to seeing what happens.  Happy to help somehow.\n. ",
    "jagregory": "Thanks for the reply. My example was slightly wrong, it seems. Have you tried your example? Because that's what I was actually doing and it doesn't work quite how I expect it to.\nThe behaviour is specifically just for Path(\"/\") on a subrouter, it behaves differently to Path(\"/\") on a top-level router.\nUsing your example:\ngo\nr := mux.NewRouter()\nsr := r.PathPrefix(\"/foo\").Subrouter()\nsr.Path(\"/\").HandlerFunc(...)\nGET http://localhost/foo => 404\nGET http://localhost/foo/ => 200\nWhen not using a top-level router:\ngo\nr := mux.NewRouter()\nr.Path(\"/\").HandlerFunc(...)\nGET http://localhost => 200\nGET http://localhost/ => 200\nThis makes it difficult for me to make nesting independent routes. I want to be able to define something like:\n``` go\npackage mymodule\nfunc Routes(r *mux.Router) {\n  r.Path(\"/\").Handler(rootHandler)\n  r.Path(\"/{id}\").Handler(idHandler)\n}\n// elsewhere\nmymodule.Routes(r.PathPrefix(\"/v1/abc\").Subrouter())\n```\n. ",
    "agness": "I can confirm I'm also getting behavior like @jagregory saw, which looks to me like a problem of StrictSlash not being observed by subrouters.  \nI'm a fan of StrictSlash -- would love to see subrouters handle trailing slashes too!\n``` go\nr := mux.NewRouter()\nr.StrictSlash(true)\nr.HandleFunc(\"/page\", pageHandler)\ns := r.PathPrefix(\"/search\").Subrouter()\ns.HandleFunc(\"/\", searchIndexHandler)\ns.HandleFunc(\"/tag/{tag_name}\", searchByTagHandler)\n```\nGET http://localhost:8080/page             => 200\nGET http://localhost:8080/page/            => 200\nGET http://localhost:8080/search           => 404\nGET http://localhost:8080/search/          => 200\nGET http://localhost:8080/search/tag/blah  => 200\nGET http://localhost:8080/search/tag/blah/ => 404\n. ",
    "ttencate": "The trouble is, PathPrefix turns off StrictSlash on that route, and that is propagated to subroutes. You can turn it back on for subroutes individually:\nr := mux.NewRouter().StrictSlash(true)\nsr := r.PathPrefix(\"/foo\").Subrouter()\nsr.Path(\"/\").StrictSlash(true).HandlerFunc(...)\nThis gives you a redirect from /foo to /foo/, but won't serve a 200 directly.\nI'm going to send a pull request to improve documentation and add some more tests for handling of slashes, at least. I'll see if I can fix the StrictSlash propagation to subrouters as well.\nI don't think I can easily make it work without needing the redirect; the code assumes that the path (whether Path or PathPrefix) starts with a /, and I'm worried that removing that restriction might break things.\n. No rush! I posted a workaround to the bug, which will continue to work\nafter this PR.\nOn Apr 23, 2014 10:00 PM, \"Kamil Kisiel\" notifications@github.com wrote:\n\nThanks. I probably won't get a chance to review this till next week as I'm\ntravelling.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/gorilla/mux/pull/51#issuecomment-41207385\n.\n. If users are enabling StrictSlash on a root router, but relying on StrictSlash being disabled on subrouters, this will break them. For instance, if they were adding a route for both \"/foo\" and \"/foo/\". That seems pretty rare though. The only reason I can imagine for anyone to do this if they don't know about StrictSlash; but they were setting it on the root, so they clearly know.\n. That would be nice, but (nearly?) impossible. For instance, someone could add /foo/{{var}} and /{{var}}/bar/.\n\nThe behaviour is that the first-defined route matches, and with StrictSlash, the first route will match both /foo/ and /foo and redirect one to the other. The second route would never be used. So this is only really a problem if the user defines different handlers for both, right? (Apart from taking an extra redirect. But if they cared about that, they wouldn't be using StrictSlash to begin with.)\n. ",
    "anacrolix": "Is there any update on this?\nI have the situation where I want to handle just the path prefix for a subrouter, but I can't unless there's a trailing /. I think that's the same as this issue.\ns := r.PathPrefix(\"/path\")\ns.Handle(\"\", handler) // Here I want to set the handler for \"/path\" alone.\n. It also occurs with golang master, so I believe behaviour has changed significantly when context_native is in use.\n. Sorry I switched to another muxer rather than go back to Go 1.6. It may be because a panic was occurring in my code, because the *Request changed when the http.Request.WithContext() call is used in the Go 1.7 specific implementation. Perhaps a test could be added for a panic in a handler with an altered Context if one does not exist already. Sorry I can't be of further help.\n. ",
    "corey-garvin": "Having a similar issue.\nRouter with strictslash = true, and seems to properly propagate to subrouter\nHowever, the path \"/\" on the sub redirects OK, but POSTs are being redirected to GET, which is bad\nIs this a known issue?\n. ",
    "victorcoder": "Getting the same behaviour.\nAs a workaround I'm declaring the root path for the prefix outside the subrouter, and the subrouter with the path prefix for the other routes just after, like:\nr.Path(\"/v1\").HandlerFunc(a.indexHandler)\nsubver := r.PathPrefix(\"/v1\").Subrouter()\n. ",
    "krak3n": "This is the best solution I can come up with to get the desired behaviour:\n``` go\nr := mux.NewRouter()\nr.HandleFunc(\"/a\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"/a\"))\n})\ns := r.PathPrefix(\"/a\").Subrouter()\ns.HandleFunc(\"/a\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"/a/foo\"))\n})\n```\nGET /a       => 200\nGET /a/      => 404\nGET /a/foo   => 200\n. ",
    "kidtronnix": "I need a fix for this as well!\n. ",
    "fvosberg": "I have the same problem and wanted to start writing some tests, because I am quite new to go. \nCan somebody check my commit before I start to implement this?\nThanks in advance\nhttps://github.com/fvosberg/mux/commit/24794edfcc6d48816df40f958cd5e3bc186caea5\n. ",
    "ORESoftware": "was there a fix for this? . the docs could have been missing it, but I guess they aren't. is there not a way to pass multiple handlers that can be strung together?. ah ok, sorry kinda newb with Go, that sounds about right\n. https://stackoverflow.com/questions/53846042/gorilla-mux-middleware-not-being-hit. @elithrar the clue is that the middleware are not being registered, as I said above:\n\nnone of these are being logged:\nlog.Println(\"error handling middleware registered\");\n  log.Println(\"auth middleware registered\");\n  log.Println(\"logging middleware registered\");\n\nbut yes, the routes I have send right responses, it just looks like the middleware is just be ignored/bypassed.. @elithrar I have a git repo that can demo the problem, it doesn't make any db connections or anything, just responds to requests, so it's easy to reproduce. Can you take a look? this problem is rough.. @elithrar yeah the problem is real, the middleware gets registered if I do this:\n```golang\nfunc getMiddleware(h http.HandlerFunc)  http.Handler {\n    return mw.Error(mw.Auth(mw.Logging(h)));\n}\nrouter.Handle(\"/share\", getMiddleware(h.makeGetMany(v))).Methods(\"GET\")\n```\nI get this logged:\nINFO[0000] logging middleware registered                \nINFO[0000] auth middleware registered                   \nINFO[0000] error handling middleware registered\nbut if I do this:\ngolang\n    router.Use(mw.Auth,mw.Logging,mw.Error);\n    router.Handle(\"/share\", h.makeGetMany(v)).Methods(\"GET\")\nthen nothing gets logged and the middleware is never invoked\n. @elithrar updated to latest using go get -u (I think that's all you have to run right?), same problem. @elithrar are you available to discuss this issue over skype? I can walk you through the repo I have...I am also getting some HTTP 405's in weird places.. @elithrar please see this demo repo\nhttps://github.com/ORESoftware/mux-problem-demo\nthe problem occurs in src/huru/main.go, the subRouters dont inherit the middleware of their parents, nor can I create middleware using subRouter.Use - it doesn't get hit\nThe repo is about as simple as can be, honestly if you are going to bother to take a look at it, a skype call with a verbal explanation would actually save time.. @elithrar would you accept test cases written in Node.js? The reason I would rather discuss first is perhaps this is just expected behavior.. @elithrar ok here it is\nhttps://github.com/ORESoftware/mux-problem-demo/blob/master/test/mia-mw.js\nif we agree that there is a problem, I can write you tests with bash or golang, that you can use in the real test suite. just want to make sure that the problem actually exists first.\nThere is one test case in that file - it fails. In main.go you can see where the handler is for /api/v1/foo, basically the context should be set in the mw.ContextHandler middleware, but that middleware doesn't get called before the handler for /api/v1/foo gets called. Let me know if you have questions.\nSo my problem is that subrouters don't seem to inherit their parent's middleware, nor can I attach unique middleware to that same subrouter.. @elithrar that looks much better is that a new PR? It's here:\nhttps://github.com/gorilla/mux/pull/431. ",
    "IvanDelsinne": "As far as I see it (#215), it seems to impose using an empty string to avoid the trailing slash, which kind of makes sense. The router base URI.. ",
    "kevinburke": "Specifically, it would be great to have a simple example of how to serve this. This is great if you already know how to do it, not great if you don't know how to have Go listen on a port and serve the mux routes you've added here.\n. @kisielk would be great to add docs around this middleware based approach\n. ",
    "scttnlsn": "@kisielk I use it frequently with subrouters.\n. Yeah, the second approach works with subrouters but you have to apply the middleware to each handler:\nsub := router.PathPrefix(\"/sub\").Subrouter()\nsub.Handle(\"/foo\", middleware2(middleware1(fooHandler)))\nsub.Handle(\"/bar\", middleware2(middleware1(barHandler)))\nInstead of:\nsub := router.PathPrefix(\"/sub\").Subrouter().Use(middleware1, middleware2)\nsub.Handle(\"/foo\", fooHandler)\nsub.Handle(\"/bar\", barHandler)\n. Yeah, fair enough.  Thanks for talking through it.\n. ",
    "marpaia": "FWIW, although I understand the desire to not want to add unnecessary API functionality for complexity reasons, I feel like it would be much cleaner and idiomatic to be able to define a subrouter and immediately define all of it's middlewares once, in a single place via a clean syntax.\nComplexity issues are often a real concern, but this is a 56 loc change WITH tests; I don't think that anyone's ability to understand the codebase will ever be affected by a change of this size.\nAs a mux user, I would really like to see this merged.\n. ",
    "sinni800": "I think this is great because it gives you an easy way to push multiple middleware functions onto a stack. \nThough I think this might be workable with one less layer of nesting if the thing it accepts wasn't a http.Handler, but rather something else (I am thinking HandlerFunc with the \"next\" parameter right in it). It's not a regular handler anyway because it needs to call the \"next\" middleware. Unless I am overseeing something, of course.\n. ",
    "mrhwick": "For anyone who is still frustrated by not having a clean way to apply a set of middleware to all Routes in a Subrouter, here's a solution that allows you to specify everything without repeating yourself.\nIt's a bit complicated, but you can walk the Route tree starting at a certain Subrouter and apply your middleware to all of the Routes below that Subrouter.\n```go\nfunc Use(handler http.Handler, middleware ...func(http.Handler) http.Handler) http.Handler {\n    for _, m := range middleware {\n        handler = m(handler)\n    }\n    return handler\n}\nmiddleware := []func(http.Handler) http.Handler{middleware1, middleware2}\nsub := router.PathPrefix(\"/sub\").Subrouter()\nsub.Handle(\"/foo\", fooHandler)\nsub.Handle(\"/bar\", barHandler)\nsub.Walk(func(route mux.Route, router mux.Router, ancestors []*mux.Route) error {\n    route.Handler(Use(route.GetHandler(), middleware...))\n    return nil\n})\n```. Thanks for highlighting that new function.\nHere's the godoc in case the source tree changes in the future: https://godoc.org/github.com/gorilla/mux#Router.Use. ",
    "0xdevalias": "In case google or something else leads you here like it did for me.. it seems there is a Use function now\nhttps://github.com/gorilla/mux/blob/master/middleware.go#L23-L28 :\ngolang\n// Use appends a MiddlewareFunc to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router.\nfunc (r *Router) Use(mwf ...MiddlewareFunc) {\n    for _, fn := range mwf {\n        r.middlewares = append(r.middlewares, fn)\n    }\n}\nIt appears to exist for both routers, and subrouters.. ",
    "pschlump": "I found the \"pull request\" button  (I think and clicked it).  Thanks for being patient with me.  I am not a github.com expert.  Give me a few days and I will be able to write a test for this.\n. I added a test to mux_test.go for this.  It is in my fork of your wonderful code.  Do I make a new pull request?\n. I think I finally figured out what to click to make a pull request!  I am so excited!\n. ",
    "dalu": "no re-direct that I know of, just plain go and no hosts file, dhcpd\nhttp://192.168.178.2:3000/\nhttps://192.168.178.2:3443/\n^ gentoo remote\nor\nhttp://mango.dev:3000/\nhttps://mango.dev:3443/\n^ arch local\nin firefox\nthe frontend is angularjs and ok it redirects / to /#/ but that's just client-side and the scheme remains the same.\nhowever I was thinking about redirecting http / to https / for the next step\nI've changed the Log function to\ngo\nlog.Printf(\"%s %s %s %s\", r.RemoteAddr, r.URL.Scheme, r.Method, r.URL)\nr.URL.Scheme is always \" \"\ntried on arch and gentoo\np.s. It's the same without wrapping in Log() \n. from the G+ community Jongmin Kim wrote:\nisHTTPS := req.TLS != nil\ufeff\n. Yes but what's the point of having Schemes() if the Scheme in URI is always empty since at least one popular browser won't set it?\nExcept if you explicitly set it in the proxy in front of the app using mux and then you won't serve https anyway.\nWhat other use-cases could there be for mux, except http & https? If there are none might aswell take a practical approach. And apparently it's not a Go bug because the behaviour is documented (? logic). So chicken and egg, catch 22.\nI agree with the 2nd part, I'm forcing users to sign up/in over https in the client. At first it was just a workaround and then it made sense. However given that intelligence agencies are sniffing internet traffic redirecting would be the right thing to do. But for performance and energy consumption the first makes more sense.\n. Hmm yeah that would probably be the best but more complicated approach. I'll likely write something when doing the finishing touches on the app. Could take a while. Testing is a subject I have not touched yet.\n. ",
    "lukescott": "@kisielk would something like this work?\ngo\nfunc (m schemeMatcher) Match(r *http.Request, match *RouteMatch) bool {\n    scheme := req.URL.Scheme\n    if len(scheme) == 0 {\n        if req.TLS != nil {\n            scheme = \"https\"\n        } else {\n            scheme = \"http\"\n        }\n    }\n    return matchInArray(m, scheme)\n}\nWhat would the pros/cons of doing this be? As far as I can tell Scheme is always blank when coming from an net/http server. Are there cases where it would be set? Is it safe to assume that it's http/https based on the TLS value when Scheme is blank?\nIf this is good, what tests in particular are you looking for (that don't already exist)?\n. ",
    "zikes": "It's also missing from the tests, which is where I usually look for usage when it's not documented.\nIn case anyone else Googles this and needs it:\n``` go\nfunc Handle404(w http.ResponseWriter, r *http.Request) {\n    // Handle 404\n}\nr := mux.NewRouter()\nr.NotFoundHandler = Handle404\n```\n. ",
    "heisGarvit": "Please add 404 code to https://github.com/gorilla/mux and http://www.gorillatoolkit.org/pkg/mux pages it took a while to look for it!\n\nmux.NewRouter()\nr.NotFoundHandler = http.HandlerFunc(func (w http.ResponseWriter, req *http.Request) {\n                 // Handle 404\n}. ",
    "tarrsalah": "@kisielk  I don't think that I'm getting your reply really well :) (What do you mean by repo collab note ).\n. ",
    "dukex": "I can't use gorilla/handlers now in my project, I will need use my fork. \nThanks\n. ohh I try gorilla/handler https://github.com/dukex/uhura/commit/77acaf44351ae314e679dc42ff2bb6acbb632c52 It's fine for me!\n. ",
    "jadekler": "Adtl note: Adding regexp matching () to id, as in...\nr.HandleFunc(\"/user/{_:(view/)?}{id:([0-9]+)}\", user.GetViewPage).Methods(\"GET\")\n...produces the same result.\n. ",
    "sqs": "No problem. I'm at GopherCon if that's where you are!\n\nOn Apr 23, 2014, at 14:01, Kamil Kisiel notifications@github.com wrote:\nThanks. I probably won't get a chance to review this and your other PR till next week as I'm travelling right now.\n\u2014\nReply to this email directly or view it on GitHub.\n. The benefit is that it's harder to make a certain class of mistakes if you can define this logic as a part of the router. Nobody can ever create incorrect URLs for those routes with BuildVarsFunc. If you have xxxURL funcs, then people can still call .URL on the router and get a bad URL. Sure, you could treat the router as private and expose only the xxxURL funcs, but then you have to replicate a lot of the route generation API of mux in your own code.\n\n(BTW, nice to meet you at dotGo!)\n. Thanks!\n. ",
    "beyang": "+1 for making this change!\n. awesome, thanks!\nOn Mon, Sep 22, 2014 at 8:31 AM, Kamil Kisiel notifications@github.com\nwrote:\n\nDone.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/70#issuecomment-56391061.\n. \n",
    "vtolstov": "any news ?\n. How can i specify capture group? I need to auto fill struct with variables from path and other parameters, \nfor variables i'm use reflection to fill struct fields, but also i want to fill and path based params.\nP.S. i know about mux.Vars but this is not so usable for me use-case. i want to move all fill stuf to one place, but in case of mux.Vars i have 2 places , one is parsing in gorilla/mux and another - my own stuff.\nMay be i'm try to live with mux.Vars and thanks for https://github.com/mitchellh/mapstructure . ",
    "jingweno": "\nI'd strongly prefer that this only apply to a Route and not a Router so that you can selectively \"not clean\" specific routes rather than an entire application.\n\nI would want to disable clean path for the entire app since our routes are created dynamically and I don't know ahead of time if the path contains a http URL.\nI could rebase this and resolve the conflict.\n. I rebased it here: https://github.com/gorilla/mux/pull/154.\n. @elithrar Sorry for the late response. I addressed all comments and added a test. Could we merge this if it looks okay? I'd need the change to fix a production issue. Thanks.\n. This closes https://github.com/gorilla/mux/pull/54.\n. I removed installing go-vet as part of the build since it's now part of Go std distro: https://travis-ci.org/gorilla/mux/builds/127283267.\n. Thanks @elithrar!\n. :+1: Was thinking of doing this.\n. ",
    "raphael": "Yes that's the idea. There are already tests covering the use of regular expressions when using variables (https://github.com/gorilla/mux/blob/master/mux_test.go#L130-L136 for example - it's the same code being used) so I didn't think it was necessary to duplicate. I'm trying to get 1.0.3 installed on my system to reproduce the failure but gvm install is failing. I'll see if I can install from source (ugh). I wasn't able to reproduce the issue with \"tip\" (the tests pass on my machine).\n. I added a couple of tests like you suggested and fixed the bug that was causing the tests to fail \"sometimes\".\n. This a follow up to #55 that fixes an issue it introduced where the matches defined using \".Queries\" had to be in the same order as the actual parameters in the query string. Added a test to cover this case (this test passed pre-#55 and now passes as well).\n. I've addressed both of your comments (thank you!).\n. Thanks, addressed both of these as well.\n. ",
    "Winslett": "Right on.  @kisielk & @zeebo, thank you guys for the quick feedback.  I'll put something together.\n. Good eye; submitted a fix.\n. ",
    "ghost": "The 404 handling is related to muxing. Panics are not. \nI think this functionality belongs in https://github.com/gorilla/handlers.\n. The mux matches against the the URL path. The path is percent decoded. In your example, %20 is decoded to a single space.  Try \nr.HandleFunc(\"/info/{name:[A-Za-z0-9._ -]+}/\", getInfo).Methods(\"GET\")\n. @Knetic The router does not concurrent modification and request routing. If you want to reload routes, then you should create a new router and swap it with the old one.  For example:\n```\ntype routerSwapper struct {\n     mu sync.Mutex\n    root *mux.Router\n}\nfunc (rs routerSwapper) Swap(newRouter mux.Router) {\n     rs.mu.Lock()\n     rs.root = newRoot\n     rs.mu.Unlock\n}\nfunc (rs routerSwappter) ServeHTTP(w http.ResponsWriter, r http.Request) {\n    rs.mu.Lock()\n    root := rs.root\n   rs.mu.Unlock()\n   root(w, r)\n}\n```\nUse routerSwapper as the root handler with the HTTP server. Call Swap wit a newly constructed router.\n. Should the server reply with the www authenticate challenge for unauthorized access?  If yes, then this feature does not belong in the router.  If no, what is the use case for this feature?\nWhat are some use cases where the application authenticates against exactly one user name and password where the password is static for the lifetime of the application process? \nShould other authentication methods be supported in the router?  Where should the maintainers draw the line for what's in and what's out?  \nUse the standard library to parse and format the auth headers:\n```\nfunc (m authorizationMatcher) Match(req http.Request, match *RouteMatch) bool {\n    u, p, ok := req.BasicAuth()\n    return ok && u == m.username && p = m.pasword\n}\nfunc newRequestWithCredentials(method, url, username, password string) *http.Request {\n    req, err := http.NewRequest(method, url, nil)\n    if err != nil {\n        panic(err)\n    }\n    req.SetBasicAuth(username, password)\n    return req\n}\n```\n. What is the use case for the application distinguishing between these errors?  \nThis PR exports error values. It does not create custom error types.\n. Not that this is the cause of the problem, but the code is not conventional. The usual way to check for a specific type is with a type assertion:\nbytes, ok := response.([]byte)\n if !ok {\n    bytes, err = ffjson.Marshal(response)\n    if err != nil {\n        http.Error(w, \"Error marshaling JSON\", http.StatusInternalServerError)\n        return\n    }\n}\n. I think your viewpoint is right.\nHere are some of my thoughts\uff1a\n1.When I developed my blog, I can not use the mux to intercept login.Perhaps, your design is at the back end of the service. But, I  found mux can parse HTML. So I think the mux will be better after add the interceptor.\n2.Interceptor not only can intercept login,I hope it can intercept the recipient before and after.\nExamples:\nfunc (i *MyInterceptor) Before() int {\n}\nfunc Login(w http.ResponseWriter, r *http.Request) {\n}\nfunc (i *MyInterceptor) After(status int) int {\n}\n3. Interceptor often do not intercept a request, compare to url for Interceptor.\nExamples:\nr.HandleFunc(/hello/a, Login)\nr.HandleFunc(/hello/b, Login)\nr.HandleFunc(/hello/c, Login)\nThese three use the same interceptor.\n. Thanks.\n. ",
    "AlekSi": "Right, I can wrap the whole mux. Thanks.\nI would like to see similar handler in gorilla/handlers though.\n. Example on site then. :)\n. ",
    "matthiasplappert": "After playing around with this a bit more, the problem appears to be the call to Methods(\"GET\"). If I remove this, everything works fine.\n. More updates: If I provide the -X GET flag in curl, everything works as expected even with the Methods(\"GET\") call. Is this expected behavior?\n. Thanks, my bad.\n. ",
    "azr": "Okay, awesome, thanks for your answer :)\n. Hem another question, I like more gorilla.mux, but goji seems nice for a web app ! \nSo, would it be possible to use Goji's middlewares and everything but still be using gorilla.mux ?\n. Okay then, I changed my mind. I think I'm totally going to use goji now, even if I can't name my routes, too bad it doesn't have some magick JSON/XML/Whatsoever parser/generator like gin-gonic.\nI guess I can make a JSON/XML middleware that will automatically detect type of sent stuff and parse it as http parameters.\nThanks for your time :)\nPS:  is it common to be go a developer and alcoholic ? :laughing:\n. ",
    "gravis": "Any news regarding this?\n. Actually, this will pass:\ngo\n{\n    title:       \"Path route with multiple patterns with pipe, match\",\n    route:       new(Route).Path(\"/{category:a|b/c}/{product}/{id:[0-9]+}\"),\n    request:     newRequest(\"GET\", \"http://localhost/a/product_name/1\"),\n    vars:        map[string]string{\"category\": \"a\", \"product\": \"product_name\", \"id\": \"1\"},\n    host:        \"\",\n    path:        \"/a/product_name/1\",\n    shouldMatch: true,\n},\nWe could probably close this.\n. ",
    "xdmnl": "In fact, the issue comes from the parentheses and the backreference generated.\nIn the example I gave, they are useless (a|b/c is equivalent to a|(b/c)) but for more complex URL variable regexp with parentheses, it might be necessary to have them.\nThe generated backreferences mess with the variables (hence the weird order we see with failing tests). To avoid that, you must use (?:) to set a group without backreference.\nIf I update the regexp of previously failing tests, it works :\ngo\n{\n    title:       \"Path route with multiple patterns with pipe, match\",\n    route:       new(Route).Path(\"/{category:a|(?:b/c)}/{product}/{id:[0-9]+}\"),\n    request:     newRequest(\"GET\", \"http://localhost/a/product_name/1\"),\n    vars:        map[string]string{\"category\": \"a\", \"product\": \"product_name\", \"id\": \"1\"},\n    host:        \"\",\n    path:        \"/a/product_name/1\",\n    shouldMatch: true,\n},\n{\n    title:       \"Path route with multiple patterns with pipe, match\",\n    route:       new(Route).Path(\"/{category:a|(?:b/c)}/{product}/{id:[0-9]+}\"),\n    request:     newRequest(\"GET\", \"http://localhost/b/c/product_name/1\"),\n    vars:        map[string]string{\"category\": \"b/c\", \"product\": \"product_name\", \"id\": \"1\"},\n    host:        \"\",\n    path:        \"/b/c/product_name/1\",\n    shouldMatch: true,\n},\nIn the end, it was just simple regexp logic.\n@kisielk, do you think a warning should be added about that in the documentation ?\n. ",
    "joegrasse": "Just ran into this. \nWith the following\nrouter.HandleFunc(\"/{assetType:(js|css|fonts)}/{filepath:.*}\", serveAssets)\nand url\nhttp://127.0.0.1/css/foo\nvars := mux.Vars(r)\nfmt.Println(vars)\nwould produce\nmap[assetType:css filepath:css]\nIt would be nice if this bug was fixed.\n. Works for my case as well.\n. ",
    "bundah": "Bump!  Please reopen this issue... also ran into this issue that joegrasse describes very well above.\n. Yes, communication in documentation would help for those that RTFM, however not fool proof :)  But in general, the path of least surprise is the correct choice (and preferably not at runtime)... That said, I haven't looked that closely as to how/where/why it is happening... Any pointers on which area of code (assuming around regexp.go:166 or where varsR is filled) you believe to be the offending lines?  ... and I'm happy to take a look...\n. Finally got a free moment to look... the code appears to rewrite the regex in question with parenthesis... My reduced repro was this subroute:\nsub.Path(\"/not/{name:(.+)}/{profile:.+}\").Methods(\"GET\").HandlerFunc(profile)\nAdded some printlines and found that regexp.go had this:\nfmt.Fprintf(pattern, \"%s(%s)\", regexp.QuoteMeta(raw), patt)\nCausing the regex of (.+) to be ((.+)), meaning this has two groups in it...  Not exactly clear why but current hypothesis is that there is an iteration later on w/ two group matches for the {name} template portion of the path and forward poisons the {profile} template...\nThis is admittedly a hack and wouldn't work for xdmnl's example above of a|(bc), but...\n// Build the regexp pattern.\n        // don't create another nested regex group if already supplied\n        if strings.HasPrefix(patt, \"(\") && strings.HasSuffix(patt, \")\") {\n            fmt.Fprintf(pattern, \"%s%s\", regexp.QuoteMeta(raw), patt)\n            fmt.Println(fmt.Sprintf(\"%s%s\", regexp.QuoteMeta(raw), patt))\n        } else {\n            fmt.Fprintf(pattern, \"%s(%s)\", regexp.QuoteMeta(raw), patt)\n            fmt.Println(fmt.Sprintf(\"%s(%s)\", regexp.QuoteMeta(raw), patt))\n        }\nThoughts ?\n. So I pulled the subexp-fix branch however it still fails for the following paths and corresponding curl...Looks to still be forward poisoning the next template because regex group inn group...\nsub.Path(\"/not/{name:(.+)}/{profile:.+}\").Methods(\"GET\").HandlerFunc(profile)\n    sub.Path(\"/again/{name:bl(ah|at)}/{profile:.+}\").Methods(\"GET\").HandlerFunc(profile)\n...\n...\n    w.Write([]byte(fmt.Sprintf(\"\\n\\nHello %s with profile %s params: %v\\n\", name, profile, params)))\ncurl -v \"http://127.0.0.1:3000/v3/again/blah/up\"\nHello blah with profile ah params: map[name:blah profile:ah]\nand\ncurl -v \"http://127.0.0.1:3000/v3/not/blah/up\"\nHello blah with profile blah params: map[name:blah profile:blah]\n. oh hrm, yea... let me double check...\n. aha, you are correct... my bad on that.. it is legit for above use cases...\n. I agree with your reasoning. Granted, the client is hitting the endpoint incorrectly.  However path.Clean doesn't just trim trailing slashes (as code comments say https://github.com/gorilla/mux/blob/master/mux.go#L348), it trims all extra slashes and in some cases dots too... because it is meant more for filesystem pathing IMO.  Perhaps a better approach ( don't know the exact rationale for the current implementation) is logic surrounding StrictSlash and https://golang.org/pkg/strings/#TrimRight with \"/\" as the cutset...\n. ",
    "omeid": "I totally understand that the function does very little to justify adding this to the API, however, I think it makes the code far more readable and concise in that it will make the code flow in the right direction.\nConsider this example:\ngo\nr := mux.NewRouter()\nu := r.PathPrefix(\"/users\").Subrouter();\nusers.SetRoutes(u)\np := r.PathPrefix(\"/posts\").Subrouter()\nposts.SetRoutes(p)\nc := r.PathPrefix(\"/comments\").Subrouter()\ncomments.SetRoutes(c)\nor even if we write it more compact, like so:\n``` go\nr := mux.NewRouter()\nusers.GetRoutes(r.PathPrefix(\"/users\").Subrouter())\nposts.SetRoutes(r.PathPrefix(\"/posts\").Subrouter())\ncomments.SetRoutes( r.PathPrefix(\"/comments\").Subrouter())\n```\nI think It is still not as clean as following code for at least two reasons, obviously less keystrokes and more neat looking code, and more importantly, in the following code we consume the sub-packages in the main, like we should, unlike the earlier example which we pass the main router to a sub-package.\n``` go\nr := mux.NewRouter()\nr.PathPrefix(\"/users\").Attach(users.GetRoutes)\nr.PathPrefix(\"/posts\").Attach(posts.GetRoutes)\nr.PathPrefix(\"/comments\").Attach(comments.GetRoutes)\n```\n. ",
    "burrbd": "My PR https://github.com/gorilla/mux/pull/101 should fix this issue.\n. Good point and suggestion. Please take a look at my refactored version. Thanks.\n. @kisielk Have another branch to refactor the addRegexpMatcher, which I'll submit soon. Currently experimenting with lexical analysis and parsing the template (which may be overkill) as opposed to looping over the brace positions and splitting strings (which IMO is difficult to follow).\n. I think the query parameter defaultPattern change from #108 is causing this.\n. Was a bad thing to break. Hopefully those extra tests will help with any refactoring. It would be nice if the refactoring could handle foo=1&foo=2&foo=3. Might need a new queries variable along with mux.Vars(request) to do this.\n. True. But it's not great that in this case vars[\"foo\"] would be equal to a string (the first value) as opposed to a slice.\nAnd the matcher should test the value of each &foo rather than just one item ... I think? O_o\n. This is the test that should cover #109.\n. ",
    "autarch": "@kisielk - yes, basically some debugging for each match it does, showing the thing it's testing (path, method, etc.) vs what would match (absolute path, regex, array of accepted methods, etc.)\n. @l3pp4rd - doesn't the Go compiler compile out unused statements? Why not have a Debug constant that defaults to false, then all someone would need to edit would be that one constant.\nThat said, absent benchmarks showing that this is an issue, it'd be nice to make this a flag.\n. ",
    "l3pp4rd": "well, in my opinion such features aren't useful for production mode, since it adds extra checks for the flag in the sensitive place. Just edit the sources of the mux package in your GOPATH and have a development environment you want. For production, reload or switch the branch.\n. ",
    "roshan3133": "In python flask  framework has this debug mode, will you be able to possible for you to have a look into it.\n. ",
    "stephanwesten": "I would like to see the request body content when debug is turned on. ",
    "epelc": "I made a wrapper that doesnt need to modify gorilla instead. If you need it let me know i'll send it over.\n. ",
    "runcom": "this code just handle /foo/11 and /bar/11. Based on what are you expecting to request /foo/bar/11?!\n. ",
    "KoFish": "Since the foo router is a subrouter to root on the path /foo/ I expect adding the path /bar/ to it would serve /foo/bar/\nHonestly it's been too long since I wrote this ticket for me to actually care any more.\n. ",
    "JosephTurner": "Why are you handling \"/\" again with http.Handle?\n. Yeah nevermind, it doesn't make a difference. I pass the router into ListenAndServe instead of nil.\n. Ok the problem comes from line 379 in route.go in Subrouter()\nr.addMatcher(router)\nWhen you call Subrouter(), it is making a change to the route.\n. ",
    "achedeuzot": "I have been following examples & documentation (Gorilla Mux first example):\nr := mux.NewRouter()\nr.HandleFunc(\"/\", HomeHandler)\nr.HandleFunc(\"/products\", ProductsHandler)\nr.HandleFunc(\"/articles\", ArticlesHandler)\nhttp.Handle(\"/\", r)\nHow can I register the router with the http package then ?\n. ",
    "fesja": "Hi kisielk!\nI'm having this problem. You can see here a code example that other person posted on SO almost a year ago. Here you can find another example in SO.\nThe problem appears when we try to get another route URL form inside a Handler. For example from the PostUpdateHandler we want to redirect the user to the PostShowHandler. On those examples people (and myself) are trying to do:\nrootUrl, err := mux.CurrentRoute(r).Subrouter().Get(\"PostShow\").URL()\nbut this changes the original Router. So then it's when we have the problem with the 404 error.\nA solution could be to use a global router variable, but I'm trying to avoid having global variables (I'm doing a clean architecture). I've tried to add the router to my Handler class but it appears to be nil on the Handler.\nAny idea on how can we solve this?\nthanks a lot!\n. ",
    "vip8439": "I'm having the same issue.  Did you figure out a workaround?\n. @philicious I ended up using query parameters instead.  My co-worker found (https://golang.org/pkg/net/url/#URL).  See the last part of URL.  The issue is probably related to that and not gorilla mux itself.  If I get the time I'll look at the gorilla mux source and verify whether it's using that.\n. ",
    "philicious": "@vip8439 no I didnt. I used a POST request instead and put the URL in the POST data\n. ",
    "gulyasm": "I believe this is definietly the reason. \nhttps://github.com/gorilla/mux/blob/master/route.go#L466-L483\nI don't see any obvious fix, I'll try to look into it tomorrow. For now, moving the parameter after the ? as a GET parameter solves the issue.\n. I will try to fix this next week or the one after that. But I am a little confused what the correct behaviour should be. Returning 404 is obvious, but the URL should be resolved correctly or this is something we can't / shouldn't change? I'm still not convinced by https://github.com/golang/go/issues/7356 that this is the correct way of handling the Path parameters. Ideas? @kisielk ?\n. I think this issue was resolved. I've run the following test:\nmain.go\ngo\nfunc A(rw http.ResponseWriter, r *http.Request) {\n    log.Println(\"Called: \" + r.URL.String())\n}   \nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/hello\", A).Queries(\"world\", \"\")\n    http.ListenAndServe(\":4999\", r)\n}\nThe output was:\nbash\ngofix $ go run main.go \n2016/02/27 23:59:41 Called: /hello?world\n. ",
    "echlebek": "I think @vip8439 is correct. See http://play.golang.org/p/syfazuTMbV\nAlso see https://github.com/golang/go/issues/7356.\nIt seems to me that gorilla is doing the right thing here.\n. Actually, I guess it's not doing the right thing since it ends up responding with 301 instead of 404. So that should probably be fixed.\n. Are you using base64 encoded strings or base64url encoded strings? You\ncannot use base64 as it includes '/' in its charset.\nOn Monday, May 18, 2015, Rogier Lommers notifications@github.com wrote:\n\nSame problem here; indeed a bug of the net/url package. I tried to\nimplement a workaround: not using urlencoded data, but base64 strings.\nUnfortunately this does not work for me. I have created an issue for this:\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/77#issuecomment-103177791.\n. \n",
    "rogierlommers": "Same problem here; indeed a bug of the net/url package. I tried to implement a workaround: not using urlencoded data, but base64 strings. Unfortunately this does not work for me. I have created an issue for this: https://github.com/gorilla/mux/issues/96\n. Well, my source string is var url=\"https://www.youtube.com/watch?v=TmiK9skef3s\". I need a way to pass this string to my Go program as a parameter. r.HandleFunc(\"/add/{value}\". I have tried several ways to encode the string through JavaScript (I need to do this through JavaScript, because it's done through a bookmarklet).\n```\nurlEscaped(url): https%3A//www.youtube.com/watch%3Fv%3DTmiK9skef3s\nencodeURIComponent(url): https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DTmiK9skef3s\nbtoa(url): aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1UbWlLOXNrZWYzcw==\n```\nNow what is the safest way to encode the string so I can decode it in Golang (and how?)\n. Thanks; working fine with query parameters, instead of path parameters.\n. Wow, that's quick :). Still in the process of editing my post :).\n. Yes, thanks.\n. ",
    "garyburd": "In Javascript, encode the value with encodeURIComponent and pass it as a query parameter.\nIn the Go code, call req.FormValue(\"parameterName\") to get the decoded value.\nPassing encoded values as a path element is tricky because of the design error in the net/url package. It's simpler to use query parameters.\n. @highway900 Unescaping a path to a string is a lossy operation.  \nA specific example is that it's not possible to distinguish a \"/\" in a path element from a \"/\" used as a path element separator. A workaround was added in 0a192a193177452756c362c20087ddafcf6829c4 and updated in c9183aaddd2672bdebcc2d2192ed9c788b4af1e8.\n. Yup, something is wrong witht site. You can read the documentation at http://godoc.org/github.com/gorilla/mux.\n. I like the model where dispatching is logically by path and then method:\n```\ntype Router interface {\n    Route(pattern string) *Route // defines a pattern to match: scheme, host, path and/or path prefix definitions\n    ...\n}\ntype Route interface {\n    // Get specifies handler for GET and HEAD if not otherwise specified.\n    Get(h http.HandlerFunc) Route\n// Post specifies the handler for POST.\nPost(h http.HandlerFunc)  Route\n\n// Handler specifies the handler the specified methods.  If len(m) == 0, then h is \n// used as a fallback when there are no specific method matches for the route.\nHandler(h http.HandlerFunc, m ...string) Route\n\n}\n```\nExamples:\nr.Route(\"/foo/{bar}\").Get(showFoo).Post(updateFoo)\n r.Route(\"/a\").Handler(aHandler, \"GET\",  \"POST\") // GET and POST go to aHandler\n r.Route(\"/b\").Handler(bHandler)  // all methods go to bHandler\nIf there's no match on method for a given route, than the mux replies with status 405.\n. To handle URI path segments containing an encoded \"/\", the router should dispatch on req.RequestURI instead of req.URL.Path.  Matched variables are percent decoded.  For example:\nr.Handle(\"/foo/{bar}/baz\", serveFooBaz)\nmatches \"/foo/hello%2fworld/baz\" with the variable bar set to \"hello/world\".\n. More specific patterns should override less specific patterns. In this example, \nr.Handle(\"/{user}\", serveUser)\nr.Handle(\"/help\", serveHelp)\nthe path \"/help\" should dispatch to serveHelp.\nLeft to right order should be used as a tiebreaker. In this example\nr.Handle(\"/{user}/followers\", serveUserFollwers)\nr.Handle(\"/help/{topic}\", serveHelpTopic)\nthe path \"/help/folllowers\" should dispatch to serveHelpTopic with variable \"topic\" set to followers.\n. The router should automatically handle redirects for \"/\" at end of the path.\n- If path does not match, path does not have \"/\" suffix and path + \"/\" does match, then redirect to path + \"/\".\n- If path does not match, path has \"/\" suffix and path[:len(path) -1] does match, then redirect to path[:len(path) -1]\n. Some more suggestions:\n- Provide a mechanism for wrapping subrouters with a \"middleware\" handler.  This handler can be used to implement authorization for a branch of the namepace and other features.\n- Add mechanism for specifying an application supplied function for handling 404 and 405 responses. \n- Specify router options using functional options on the New() function.  Here's an example:\n```\n  type Option struct { / unexported fields / }  // this can also be func(*options)  \nfunc New(options ...Option) Router\n// WithErrorHandler specifies the function the router calls to generate error\n  //  responses. The router calls http.Error by default.\n  func WithErrorHandler(f func(status int, w http.ResponseWriter, r *http.Request)) Option\n  ```\n. @moraes How about creating a repo for the new mux and writing the proposal as godoc? People can propose changes or request features using issues and PRs in that repo.\n. I suggested a new repo because I assumed that the new mux will be published in a new repo. Where do you plan publish the new mux?\n. The problem is that the mux matches the fully decoded path in req.URL.Path.  This issue can be fixed by changing the mux to match  req.RequestURI, but that change might break existing applications.  RequestURI has been available since Go 1.\nA workaround is to change the pattern to:\napiRouter.HandleFunc(\"/foo/{bar:.*}\", getFoo).Methods(\"GET\")\nThis pattern matches \"/foo/bar%2ftest\" and \"/foo/bar/test\". If you don't want \"/foo/bar/test\" to match, the modify the handler to check req.RequestURI or the req.URL.RawPath and return status 404 as appropriate.\n. The context setting wrapper is ignored. I think you want:\npreparedRouter := ContextSet(router)\npreparedRouter =  ContextGet(preparedRouter)\n\n. The function mux.SetURLVars returns a shallow copy of the argument.  \nIt is idiomatic to use a pointer for a large argument value, even when the value is not modified by the function.\n. The function argument and return type are http.Request, not http.Handler.\nThe mux.SetURLVars function creates the shallow copy by calling Request.WithContext.  . ",
    "derekdowling": "I'm running Go 1.5.1 which claims to have been the issue here https://github.com/gorilla/mux/issues/77#issuecomment-101772763 and I am still seeing this issue.\nExample:\n``` go\n    // router build\n    router = mux.NewRouter()\n    router.HandleFunc(\"/status\", status).Methods(\"GET\")\napiRouter := mux.NewRouter()\napiRouter.HandleFunc(\"/foo\", getFooList).Methods(\"GET\")\napiRouter.HandleFunc(\"/foo/{bar}\", getFoo).Methods(\"GET\")\n\nrouter.PathPrefix(\"/foo\").Handler(negroni.New(\n    OAuthRequired(config.OAuth),\n    negroni.Wrap(apiRouter),\n))\n\nurl := httptest.NewServer(router).URL\nurl1 := strings.Join([]string{url, \"/foo/bar%2ftest\"}, \"\")\n// url2 := strings.Join([]string{url, \"/foo/bar.test}\", \"\")\n\nreq, err := http.NewRequest(\"GET\", url1, nil)\n\nclient := &http.Client{}\nreq, err := client.Do(req)\nfmt.Printf(\"Req: %+v \\n Err: %+v \\n\", req, err)\n\n```\nIf I use url1 I get a 404, if I use url2 I get a 200. Thoughts? I am using Ember-Data to generate API calls so short of performing a huge hack on both ends, I need this to work properly, or alternatively to find a new router.\n. Even just being able to do this for debugging via fmt.Printf(\"%+v\", router.Tree()) would be super helpful when dealing with subrouters. \n. @garyburd thanks for the speedy response and getting me unstuck! Okay, while this isn't exactly ideal, it should at least work. How then would I handle:\napiRouter.HandleFunc(\"/foo/{bar%2ftest}/{baz}\", getFoo).Methods(\"GET\")? I assume that :.* is an inline regex, so do I need to come up with a regex rule to accommodate this?\n. ",
    "highway900": "Sorry to bring this up again. But this is still a bug. @garyburd can you explain this a little more? \"Passing encoded values as a path element is tricky because of the design error in the net/url package. It's simpler to use query parameters.\"\n. this is the same for {value} parameters see #77. ",
    "chadkouse": "that will match /subroute/ -- I also would like to match /subroute with no trailing slash so I have to have additional routes outside of the subrouter to match those.\nIdeally this would work:\nsubrouter := router.PathPrefix(\"/subroute\").Subrouter()\nsubrouter.Methods(\"GET\").Path(\"\").HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n    res.Write([]byte(\"/subroute\"))\n})\nbut currently it does not.\n. ",
    "jonathaningram": "@chadkouse don't suppose you found a workaround did you?\n. ",
    "dcelasun": "Sorry to resurrect an old issue, but this is still relevant in 2016 and it isn't specific to POST. Here's an example:\ngo\nadminRouter := router.PathPrefix(\"/admin\").Subrouter()\nadminRouter.HandleFunc(\"\", someHandler)\nadminRouter.HandleFunc(\"/\", someHandler)\nWith this configuration, /admin/ works, but /admin does not.\n. Exactly.\n. ",
    "konradjurk": "@kisielk Why did you close this, it is still relevant right?. ",
    "husainaloos": "@kisielk Why is this closed? I am experiencing this problem also.. ",
    "williambao": "please close this issue.\nI wrap a function on first route, and just directly set value to mux.Vars in this function, it works.\n```\nrouter.HandleFunc(\"/_Users\", controller.AddUser)\nfunction AddUser(req *http.Request, w http.ResponseWriter){\n    mux.Vars(req)[\"resourceName\"] = \"_User\"\n    controller.AddResource(w, req)\n}\n```\n. ",
    "Knetic": "I'd +1 this, I use mostly dynamically-mapped routes loaded from a mappings file. Being able to reload the file (and change the routes) without restarting the service (and thereby having to drain connections) would be ideal.\nI'm currently using a forked Go stdlib muxer that supports route deregistration, but it's clunky and i'd prefer to use Gorilla's mux.\n. ",
    "mogthesprog": "Hey guys. I know this is an old issue, but i had a question about the method outlined above.\nIf i've got an open websocket connection being routed by the router when i call rs.Swap(), will those connections stay up until they're closed by either client/server, or will the router tare down those connections during the swap?\nA little more detail, i'm using gorilla/mux and gorilla/websocket to reverse proxy multiple users and wanted to use this method to update the router on the fly. But i'm wondering whether the swapping process will interfere with already established connections.\n. thank you sir!\n. ",
    "hjr265": "We also talked about adding a method that will print the routes in a human-readable format. There is something we might need to discuss before I can implement that. Regarding formatting and the method's signature, that is. I will send an email in the group thread regarding this.\n. Ah. Yes. That's true. May be a simple strategy is to not skip those routes that hold the sub-router. That way, the one who is providing the walkFn can account for this.\nAlso, I was taking a closer look at filepath.Walk, and they have a way of preventing the Walk method from descending into sub-directories. May be we should have that in Router.Walk. The way they do it is they have a special error that the walkFn can return, and this indicates the Walk function to skip the descend.\n. In that case, shouldn't we also have an indication that it has returned from its descend? I guess that may not be necessary depending on what we push to the stack.\nMay be we should have a second argument in the walkFn function, which can be a pointer to the current router we are walking on.\n. So, I made some changes. Two important things to notice here is that we are introducing a SkipRouter value, and changed the WalkFunc function's signature to have three arguments. Here, the route argument, is still what it used to be, the current router; the router argument holds a pointer to the current router; and finally, the ancestor argument keeps track of an array of pointers to the routes that lead to this current route/router.\nI am not entirely sure if this last argument is an overkill or not, but it certainly is going to be useful, because if someone is using sub-routers and want to use this function, they will always want to keep track of what routes lead to a leaf route in the tree. We are just doing it for them.\nThis last argument should also allow us build the complete path to any given route from inside a WalkFunc.\n. ",
    "tcurdt": "Ahhhhhhhh!\nNot sure there is a suggested way of handling such things but simple chaining did the trick for me:\nrouter.HandleFunc(\"/feedback/{project:[0-9a-zA-Z]+}\", handler.Test(handler.PutProject)).Methods(\"PUT\")\nAnd then I can either call the callback to pass it on in the chain or handle it myself\n```\nfunc Test(router http.HandlerFunc) http.HandlerFunc {\n  return http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\nvars := mux.Vars(req)\nglog.Infof(\"Vars: [%q]\", vars)\n\nrouter(res, req)\n\n})\n}\n```\n. ",
    "mpolden": "I agree. Being able to retrieve all defined routes would be useful.\n. ",
    "oveddan": "+1\n. It would be useful to be able to be able to grab all of the routes from the outside.  Let's say we want to print them in development environment, or generate some sort of documentation based off of what the routes are and their paths/constraints.\n. ",
    "cfchris": "Will someone please provide the link to the issue mentioned by @kisielk? I looked and could not find it. We would really like to generate documentation of our API tree using a method to retrieve registered routes. We would even be willing to write the functionality.\n. ",
    "endophage": "Yeah, I worked it out eventually. PathPrefix seems like a generally poorly named and probably redundant function IMO. If a developer knows only one regex, it's probably .*\n. Appears to still be broken. I ran my tests against the older version (e444e69) I had in my go vendoring, saw the expected failure, updated to mux's head of master, ran the same tests and got the same failure.\n. I'm a little overbooked right now too. No promised but if I get time I'll submit an update.\n. ",
    "gotjosh": "Thanks buddy.\n. ",
    "tasdomas": "This looks like a valuable improvement.\n. ",
    "alesstimec": "@kisielk use-case is when you want to secure only a specific endpoint using basic auth, and when you're using subrouters.. example:\nroot := mux.NewRouter()\nsecureSubrouter := root.PathPrefix(\"secure\").BasicAuthorization(\"username\", \"password\").Subrouter()\npublicSubrouter := root.PathPrefix(\"public\").SubRouter()\nnow i can register handlers to each subrouter and have them either secure or public.. \n. ",
    "JorgeRdg": "Yes, they just ignore the header value and are handled by the proper handler. The request would be a normal GET request from Chrome: http://localhost:3000/anything/product-images/whatever.\nDidn't know of that mailing list. Gonna check it ;) Thanks!\n. ",
    "bieber": "Awesome, I went to sleep, went to work, came home and tried to set into it again...and now after rebuilding with a debug.PrintStack() thrown in I can't repro any more.  So I'll just assume it was some bizarre compilation bug or something and you can pretend you never heard from me :p\n. ",
    "dylanmei": "Since I've started using Traefik -- which enlists gorilla/mux in its routing layer -- I've discovered two backend apps that no longer function as designed.\n- thumbor/thumbor\n- Capgemini/mesos-ui\nThey both use urls with their proxy data in the path, as opposed to a query-string. For example:\nhttp://my-app/proxy/http://another-app\nWhile I don't personally agree with their design decisions, these apps and probably many more are unusable due to the path cleaning / redirect.\n. ",
    "GeneticGenesis": "Great, thanks!\n. ",
    "crafet": "same problem happened to me\n. ",
    "aaronjwood": "Sorry, my mistake. Thanks for the explanation!\n. ",
    "dkumor": "The merged PR fixed the issue. Thanks a lot!\n. ",
    "mathvav": "Sorry, didn't realize the is-open flag was the default on GitHub and didn't notice #36. However, I don't understand why you don't want this... API complexity is understandable, but I think that this would be really helpful.\nThe \"opinionated\" argument doesn't really stand since you don't have to use the middleware. Plus, there's no way to integrate anything into a subrouter, so it's painful to \"implement it elsewhere.\"\n. ",
    "zimmski": "It seems to me that it is the easiest. Create a http.Request, add the vars to mux.SetVars and then forward it into the handler. There is actually no other mux code involved.\nI am up for suggestions.\n(thanks for the awesome package btw, using it for what seems ages)\n. Yes, I always did that too, but I noticed that testing controller handlers could be much simpler and resource friendly by simply calling them directly with a self-made http.Request instance. That way there are no unneeded server and router instances. Also then there is no need for knowing the URI. Do not get me wrong, I still test the routers. However, the dependencies of the controllers and handlers in the project are completely mockable and therefore can run perfectly fine in parallel tests. Instantiating a server and a route for every handler is just inefficient and that is the reason why I made the change in the first place.\nEDIT: Also, knowing the URI is another reason to move away from the server+router test.\n. I thought so too but that does not work. The call would mimic context.Set(r, varsKey, val) and varsKey is of type contextKey. Both are not exported, so I thought I could just use the value, which is always \"0\". However, the key is of type interface{}, so the type of the key value becomes important. To get context.Get to work, you need a mux.contextKey(0).\n. ",
    "arkan": "+1 for this change too!\n. ",
    "cam-stitt": "Aware that this has been closed and is an older issue, but I think @zimmski makes a pretty good point that you can't use context.Set because of the private contextKey type as well. If I am testing the handlers using httptest.NewRecorder it would be great to have one of these exported.\n. ",
    "bhirbec": "I gave some thoughts about this too and I join @zimmski and @cam-stitt. My handlers are wrapped into several middlewares and using the mux/server approach would require me to write more code. As an example, my authentication middleware requires some specific HTTP headers which I could get rid of by calling the handler directly. \nIt's really unfortunate that there's no way to directly call the handler. I will be glad to provide a PR to open SetVar().\n. @elithrar thanks for the reply. I'm not sure to understand your solution. How does the context get populated if the mux isn't involved? Can you please provide more informations or point to an example? \n. ",
    "Allendar": "I use this wrapping handler:\n``` go\n// Error response contains everything needed for http.Error\ntype handleHTTPError struct {\n    Error   error\n    Message string\n    Code    int\n}\n// A custom type that we can use for handling errors and formatting responses\ntype handler func(w http.ResponseWriter, r http.Request) (interface{}, handleHTTPError)\n// Attach the standard ServeHTTP method to our handler so the http library can call it\nfunc (function handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    // start := time.Now().UnixNano()\n    // log.Println(\"Request Recieved\", start)\n    var err error\n    // Room for preparation code\n    // ...\n// Call the actual handler\nresponse, errh := function(w, r)\n\n// Check for errors\nif nil != errh {\n    if errh.Error != nil {\n        log.Printf(\"ERROR: %v\\n\", errh.Error)\n    }\n    http.Error(w, fmt.Sprintf(`{\"error\":\"%s\"}`, errh.Message), errh.Code)\n    return\n}\n\nif response == nil {\n    log.Println(\"ERROR: response from method is nil\")\n    http.Error(w, \"Internal server error. Check the logs.\", http.StatusInternalServerError)\n    return\n}\n\nvar bytes []byte\n// Trigger buffer, otherwise turn the response into JSON\nif reflect.ValueOf(response).Kind() == reflect.Slice {\n    bytes = response.([]byte)\n} else {\n    bytes, err = ffjson.Marshal(response)\n    if nil != err {\n        http.Error(w, \"Error marshaling JSON\", http.StatusInternalServerError)\n        return\n    }\n}\n\n// Send the response and log\nw.Header().Set(\"Content-Type\", \"application/json\")\nw.Write(bytes)\n// end := time.Now().UnixNano()\n// fmt.Println(float64((end - start)) / float64(1e9))\n\n}\n```\n. Thanks for the note! I've changed it :-)\n. I sadly can't share all my code. I can try to following to show the purest path to achieve a call:\n``` go\nfunc main() {\n    initializeServer()\n}\n// Initialize all the server requirements and boot it\nfunc initializeServer() {\n    initializeRoutes()\nrunHTTPSServer()\n// go runHTTPSServer()\n// runHTTPServer()\n\n}\n// Start the HTTPS Server\nfunc runHTTPSServer() {\n    log.Println(\"Starting HTTPS Server..\")\n    addr := fmt.Sprintf(\"%s:%d\", clFlagServerHost, clFlagServerSSLPort)\n    err := http.ListenAndServeTLS(addr, clFlagTLSCertificatePath, clFlagTLSPrivaryKeyPath, nil)\n    if err != nil {\n        panic(err)\n    }\n}\n// Initialize all routes and the static file serving handler\nfunc initializeRoutes() {\n    // Setup routes\n    mainRoute := mux.NewRouter()\n    mainRoute.StrictSlash(true)\n    // mainRoute.Handle(\"/\", http.RedirectHandler(\"/static/\", 302))\n    // mainRoute.PathPrefix(\"/\").Handler(http.StripPrefix(\"/\", fileHandler))\n// Basic routes\n\n// User routes\nuserRoute := mainRoute.PathPrefix(\"/users\").Subrouter()\nuserRoute.Handle(\"/is_logged_in\", handler(userIsLoggedIn)).Methods(\"GET\")\nuserRoute.Handle(\"/login\", handler(userDoLogin)).Methods(\"POST\")\nuserRoute.Handle(\"/logout\", handler(userDoLogout)).Methods(\"GET\")\nuserRoute.Handle(\"/forgot_password\", handler(forgotPassword)).Methods(\"POST\")\n\nmainRoute.Handle(\"/api/catalog\", handler(getCatalog)) // FIXME :: Not as Subrouter() because it destroys r.Body..\n\n// apiCatalogRoute := apiRoute.PathPrefix(\"/catalog\").Subrouter()\n// apiCatalogRoute.Handle(\"/\", handler(getCatalog))\n\n// Bind generic route\nhttp.Handle(\"/\", mainRoute)\n\n}\n// Attach the standard ServeHTTP method to our handler so the http library can call it\nfunc (function handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    // start := time.Now().UnixNano()\n    // log.Println(\"Request Recieved\", start)\n    var err error\n    // Room for preparation code\n    // ...\n// Call the actual handler\nresponse, errh := function(w, r)\n\n// Check for errors\nif nil != errh {\n    if errh.Error != nil {\n        log.Printf(\"ERROR: %v\\n\", errh.Error)\n    }\n    http.Error(w, fmt.Sprintf(`{\"error\":\"%s\"}`, errh.Message), errh.Code)\n    return\n}\n\nif response == nil {\n    log.Println(\"ERROR: response from method is nil\")\n    http.Error(w, \"Internal server error. Check the logs.\", http.StatusInternalServerError)\n    return\n}\n\nvar bytes []byte\n// Trigger buffer, otherwise turn the response into JSON\nif reflect.ValueOf(response).Kind() == reflect.Slice {\n    bytes = response.([]byte)\n} else {\n    bytes, err = ffjson.Marshal(response)\n    if nil != err {\n        http.Error(w, \"Error marshaling JSON\", http.StatusInternalServerError)\n        return\n    }\n}\n\n// Send the response and log\nw.Header().Set(\"Content-Type\", \"application/json\")\nw.Write(bytes)\n// end := time.Now().UnixNano()\n// fmt.Println(float64((end - start)) / float64(1e9))\n\n}\nfunc getCatalog(w http.ResponseWriter, r http.Request) (interface{}, handleHTTPError) {\n    // Decode data\n    decoder := json.NewDecoder(r.Body)\n    var Data struct {\n        Filters          map[string]map[string]interface{}\n        Languages        map[string]string\n        OrderBy          map[string]map[string]string\n        Limit            string\n        Page             string\n        Search           string\n        SearchProperties map[string]map[string]string\n    }\n    err := decoder.Decode(&Data)\n    log.Println(err)\n    if nil != err {\n        return nil, &handleHTTPError{err, \"Couldn't decode data\", http.StatusBadRequest}\n    }\nresponseData := map[string]map[string]interface{}{\n    \"properties\": map[string]interface{}{},\n    \"results\":    map[string]interface{}{},\n}\n\nreturn responseData, nil\n\n}\n```\n. My apologies. Again:\n``` go\npackage main\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"github.com/gorilla/mux\"\n    \"github.com/pquerna/ffjson/ffjson\"\n    \"log\"\n    \"net/http\"\n    \"reflect\"\n)\nvar clFlagServerHost string\nvar clFlagServerPort int\nfunc main() {\n    clFlagServerHost = \"127.0.0.1\"\n    clFlagServerPort = 8888\ninitializeServer()\n\n}\n// Error response contains everything needed for http.Error\ntype handleHTTPError struct {\n    Error   error\n    Message string\n    Code    int\n}\n// A custom type that we can use for handling errors and formatting responses\ntype handler func(w http.ResponseWriter, r http.Request) (interface{}, handleHTTPError)\n// Initialize all the server requirements and boot it\nfunc initializeServer() {\n    initializeRoutes()\n// go runHTTPSServer()\nrunHTTPServer()\n\n}\n// Start the HTTP Server\nfunc runHTTPServer() {\n    log.Println(\"Starting HTTP Server..\")\n    addr := fmt.Sprintf(\"%s:%d\", clFlagServerHost, clFlagServerPort)\n    err := http.ListenAndServe(addr, nil) //http.HandlerFunc(redirectToHTTPS))\n    if nil != err {\n        panic(err)\n    }\n}\n// Initialize all routes and the static file serving handler\nfunc initializeRoutes() {\n    // Setup routes\n    mainRoute := mux.NewRouter()\n    mainRoute.StrictSlash(true)\n    // mainRoute.Handle(\"/\", http.RedirectHandler(\"/static/\", 302))\n    // mainRoute.PathPrefix(\"/\").Handler(http.StripPrefix(\"/\", fileHandler))\nmainRoute.Handle(\"/api/catalog\", handler(getCatalog)) // FIXME :: Not as Subrouter() because it destroys r.Body..\n\n// apiCatalogRoute := apiRoute.PathPrefix(\"/catalog\").Subrouter()\n// apiCatalogRoute.Handle(\"/\", handler(getCatalog))\n\n// Bind generic route\nhttp.Handle(\"/\", mainRoute)\n\n}\n// Attach the standard ServeHTTP method to our handler so the http library can call it\nfunc (function handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    // start := time.Now().UnixNano()\n    // log.Println(\"Request Recieved\", start)\n    var err error\n    // Room for preparation code\n    // ...\n// Call the actual handler\nresponse, errh := function(w, r)\n\n// Check for errors\nif nil != errh {\n    if errh.Error != nil {\n        log.Printf(\"ERROR: %v\\n\", errh.Error)\n    }\n    http.Error(w, fmt.Sprintf(`{\"error\":\"%s\"}`, errh.Message), errh.Code)\n    return\n}\n\nif response == nil {\n    log.Println(\"ERROR: response from method is nil\")\n    http.Error(w, \"Internal server error. Check the logs.\", http.StatusInternalServerError)\n    return\n}\n\nvar bytes []byte\n// Trigger buffer, otherwise turn the response into JSON\nif reflect.ValueOf(response).Kind() == reflect.Slice {\n    bytes = response.([]byte)\n} else {\n    bytes, err = ffjson.Marshal(response)\n    if nil != err {\n        http.Error(w, \"Error marshaling JSON\", http.StatusInternalServerError)\n        return\n    }\n}\n\n// Send the response and log\nw.Header().Set(\"Content-Type\", \"application/json\")\nw.Write(bytes)\n// end := time.Now().UnixNano()\n// fmt.Println(float64((end - start)) / float64(1e9))\n\n}\nfunc getCatalog(w http.ResponseWriter, r http.Request) (interface{}, handleHTTPError) {\n    // Decode data\n    decoder := json.NewDecoder(r.Body)\n    var Data struct {\n        Filters          map[string]map[string]interface{}\n        Languages        map[string]string\n        OrderBy          map[string]map[string]string\n        Limit            string\n        Page             string\n        Search           string\n        SearchProperties map[string]map[string]string\n    }\n    err := decoder.Decode(&Data)\n    log.Println(err)\n    if nil != err {\n        return nil, &handleHTTPError{err, \"Couldn't decode data\", http.StatusBadRequest}\n    }\nresponseData := map[string]map[string]interface{}{\n    \"properties\": map[string]interface{}{},\n    \"results\":    map[string]interface{}{},\n}\n\nreturn responseData, nil\n\n}\n```\n. Hmm that's odd. Then it must be something somewhere else in my code. I guess it's not bug then hehe ^_^. Thanks for the help tho!\n. ",
    "brocaar": "I'm using mux with negroni. If I understand it correctly, when you use negroni.New(Middleware, ...) and then negroni.UseHandler(r) to set the router, the middlewares will be called before the mux handler. So before calling the next middleware, mux hasn't set context yet, after the call the context is already cleared:\nMiddleware 1\n    -> Middleware 2\n        -> Gorilla mux\n            * Set current handler + vars (context)\n              -> Call handler\n            * Context.Clear\n. Yep, I saw that in the code. Just created this pull-request since I think it would be good to add a small comment to the documentation about this behaviour :-) Potentially, more people run into this \"issue\".\n. Done\n. ",
    "shkw": "Thanks for the prompt response.\n\nAny particular reason you chose to remove the name != \"\" checks in setMatch though?\n\nThe name == varGroupName(varName) checks ensure the name is not empty since varGroupName func always returns a non-empty string, so I think the name != \"\" checks can be removed.\n. I totally agree with you.\nI will make changes accordingly.\n. I made changes as you suggested.\nCould you please review the code again?\n. ",
    "themihai": "I find this kind of behaviour/regex flavour quite disturbing especially because it's not documented. For example using signin.api{_:(^$|^\\.sandbox$)}.example.co.uk with the standard regexp package matches sigin.api.example.co.uk and signin.api.sandbox.example.co.uk but on route.Host that doesn't happen.\n. I think a method StrictRegex on type Router[0] would work best. It would be in line with StrictSlash[1]. What do you think?\n[0]\n// StrictRegex defines the behaviour of HeadersRegexp, Host and regular expressions\n// within the route paths. The initial value is false which means it wraps regexp \n// in wildcard by default.\nfunc (r *Router) StrictRegex(value bool) *Router\n[1] https://godoc.org/github.com/gorilla/mux#Router.StrictSlash\n. ```\npackage main\nimport (\n    \"github.com/gorilla/mux\"\n)\nfunc main() {\nrouter := mux.NewRouter()\nrouter.Host(\"example.com\")\nfn := func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {\n    panic(\"this should panic but it doesn't\")\n    return nil\n}\nif err := router.Walk(fn); err != nil {\n    panic(err)\n}\n\n}\n``\n. But router.Host(\"example.com\") creates a new route, isn't it? It's a bug, right? I think the same applies to router.Methods(). I was using Walk to debug some strange behaviour of the Host() method thus the reason of the report.\n. @elithrar  One Router.Host() route could be just one of the routes not the only one. For example I would like all the requests to xapi.domain.net to return HTTP 401 (Gone) to signal that it is no longer available so I setup a Router.Host(xapi.domain.net).Handler(GoneHandler). The other subdomains may have different routes with paths etc.\n  OnWalkyou could useGetHostTemplate` to get the host template. As this function already exists I assume it has some use-cases. \n  Design-wise it would make the API more orthogonal. \nTbh I don't really use/need this but I reported it because it doesn't match the documentation so I thought there could be other bugs. The documentation states Walk walks the router and *all* its sub-routers, calling walkFn for *each* route in the tree. which is clearly not the case.\n. @elithrar I've found that even routes with paths are not provided, though I can't figure out why (some are provided and some are not provided) so AFAIC this is beyond undocumented.\n. The routes configuration looks pretty much like this. It seems that only the routes that have both Host and Path are returned\n```\n  {\n    \"Routes\": [  {\n      \"Method\": \"OPTIONS\"\n   },\n    {\n      \"Method\": \"POST\",\n      \"Href\": \"/discover\"\n    },\n    {\n      \"Method\": \"GET\",\n      \"Href\": \"/{userId}/{sessionStatus}/{sessionId}\",\n        \"Host\": \"session{:(^$|^\\.sandbox$)}.example.com\"\n    },\n    {\n      \"Method\": \"POST\",\n      \"Href\": \"/authUserId\"\n    },\n    {\n      \"Method\": \"POST\",\n      \"Href\": \"/registerUserId\"\n    },\n    {\n      \"Method\": \"POST\",\n      \"Href\": \"/forgotPassword\"\n    },\n    {\n      \"Method\": \"POST\",\n      \"Href\": \"/resetPassword\"\n    },\n    {\n      \"Method\": \"POST\",\n      \"Href\": \"/changePassword\",\n      \"Host\": \"signin.api{:(^$|^\\.sandbox$)}.example.co.uk\"\n    },\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/checkUsernameAvailability\"\n},\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/disableSession\"\n},\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/getActiveSessions\"\n},\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/userIdByEmail\"\n },\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/emailByUserId\"\n},\n{\n  \"Method\": \"POST\",\n  \"Href\": \"/changeEmail\"\n\n},\n{\n  \"Method\": \"POST\",\n  \"Href\": \"/changeEmailUnconfirmed\"\n\n},\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/confirmEmail\"\n},\n{\n  \"Method\": \"POST\",\n  \"Href\": \"/resendConfirmEmail\"\n},\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/disableUserId\"\n},\n\n{\n      \"Method\": \"GET\",\n      \"Href\": \"/reinstateUserId\"\n    },\n   {\n      \"Method\": \"GET\",\n      \"Href\": \"/userInfo\"\n    },\n    {\n      \"Method\": \"POST\",\n      \"Href\": \"/identity/\"\n    },\n    {\n      \"Method\": \"PUT\",\n      \"Href\": \"/identity/{sub}\"\n    },\n    {\n      \"Method\": \"PUT\",\n      \"Href\": \"/identity/{sub}/expiration\"\n    },\n{\n  \"Method\": \"POST\",\n  \"Href\": \"/token\"\n},\n{\n  \"Method\": \"PUT\",\n  \"Href\": \"/token/revoke\"\n},\n{\n  \"Method\": \"HEAD\",\n  \"Href\": \"/identity/{key}/iss\"\n\n},\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/user/info\"\n\n},\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/.well-known/openid-configuration\"\n\n},\n{\n  \"Method\": \"GET\",\n  \"Href\": \"/lookup\"\n\n}\n\n]\n}\n```\n// The routes are decoded from json and then loaded using something as below\n```\n        router :=  mux.NewRouter().StrictSlash(true)\n    for _, rt := range routes {\n        route := m.router.Methods(rt.Method)\n        if rt.Host != \"\" {\n            route.Host(host)\n        }\n    if rt.Href != \"\" {\n        route.Path(href)\n    }\n}\n\n```\n// After the routes are loaded a \"debug\" route is injected at /muxdebug which uses Walk to retrieve the routes and return them (as json). \n[{\"Host\":\"session{_:(^$|^\\\\.sandbox$)}.example.com\",\"Path\":\"/{userId}/{sessionStatus}/{sessionId}\",\"Ancestors\":null},{\"Host\":\"signin.api{_:(^$|^\\\\.sandbox$)}.example.co.uk\",\"Path\":\"/changePassword\",\"Ancestors\":null}]\nIt seems that only the routes that have both a Host and a Path are returned.  To make \"Walk\" useful I think all the routes should be returned regardless how many \"parts\" they have (i.e. host, path , method ). That you can debug what exactly the router is routing. I expected Walk to work somehow like the path/filepath -> Walk from the std library except that instead of files you would have routes. \n. @james-lawrence but you do that anyway with the PostForm isn't it? You could use a middleware to copy mux.Vars to PostForm (so that you have to map only PostForm) or even decode it directly using schema.Decode but what if the body is encoded differently(e.g. json or another format)? There are several magic(more or less) frameworks (e.g. martini) but I think it's really something that should be built on top of gorilla mux not part of it. All that magic has tradeoffs (i.e. performance, flexibility etc) \n. ",
    "mtso": "I'd like to add two examples to the documentation for Route.HeadersRegexp. I'm thinking of adding a new file named example_route_test.go using this article as a guide: https://blog.golang.org/examples.\nThe example file would contain two runnable examples:\n1. func ExampleRoute_HeadersRegexp() for the general behavior where the given pattern matches any substring of the header value.\n1. func ExampleRoute_HeadersRegexp_exactMatch() to show how to do a strict pattern that does an exact match with ^pattern$.. Hi @roobre, are you still working on this? If not, I'd like to take a stab at it.\nI found something odd here: https://github.com/gorilla/mux/blob/master/route.go#L84\nUsing OP's example, it's assigning a handler only if match.Handler is nil, but it\u2019s already assigned to GET when executing the POST match. The fix may lie before that, though, because match.Handler should be nil for an invalid method match.. Broke up TestMethodsSubrouter into five separate test cases based on the router initialized for each one. t.Parallel is also invoked in each one, so they run concurrently. Breaking them up further without t.Run would make the router initialization strategy more verbose.\nmethodsSubrouterTest has also been made stateless so the handler-match assertions are cleaner.. The relevant string literals have been updated to use backticks. Thanks for both your helpful feedback!. The global method handler variables and constants have been removed.. Wow, I'm surprised how much more readable that became, thanks.. Ok, I can try that.. Yes, I can try that, would inspecting the response body be better?. The flags are used to check which handler is invoked. I wanted to check sequentially (for when two same routes are registered, but only the first one should be matched), but I can use map[string]bool with [method][number] like get1 and get2.. Ok, makes sense. I noticed the HTTP methods in other tests are raw strings. Should these constants be replaced, too?. ",
    "pH14": "Working on this--I have something that kinda works but I did some horrible things to the existing code to make it happen :smile:\nI'll work on cleaning it up and then send in a PR\n. That seems reasonable, I can wait and merge my changes into what you come up with\n. Reworking that might be biting off more than I can chew at the moment, but once I have a bit more time I'd be happy to take a look\n. ",
    "elico": "@elithrar I have tried to use the Walk function to print the list of pathes which the router handles but something is wrong, every single route have an empty name: https://gist.github.com/elico/170b4d98b52b1da58d56\nAm I doing something wrong?\n. @nicowernli OK, from the code I was suspecting that this is what I would be required to do.\nIsn't there any other way to get the route path?matcher without setting the name??\nWhat would be the right way to use a Walk function to achieve that? I tried to see in godoc.org but have not found an example or some way I could understand to do so. \n. @nicowernli @elithrar I am thinking about patching the source and to add a getMatchers to kind of solve the issue.\n. Hi @elithrar - I have tried accessing both the root ie \"/ui/\" and some sub-directories and files ie \"/ui/1.txt\" or \"/ui/ui/1.txt\" which is like your example.\nThe only url which worked with the http.FileServer.. was the \"/ui/\" which returned the directory files listing(which I wanted also) all other files or folders returns a 404.\n. ",
    "nicowernli": "You have to add the name to the routes if you want to get it later using the Name() method\n. I'm sory @elico, I'v been reading the source code and it looks like you can't access the path but not 100% sure\n. ",
    "CpuID": "+1 to the idea of returning HTTP 405's in the appropriate places (eg. if a request is made to a URI that has a .Methods() filter on it that doesn't allow it)\n. ",
    "vaikas-google": "I am also running into this (last issue in this thread) and have made the following unit tests and changes to use EscapedPath() instead of Path directly and it now works great for my needs. Is this something that might be considered for a pull request?\nhttps://github.com/gorilla/mux/compare/master...vaikas-google:master\n. Thanks much!\nAha, I was not aware of that :) Seems like a solid reason. I can try to\ntake a crack at implementing a method like that if it seems like a viable\napproach?\nAlso, I currently return the encoded variable, it's probably better to\nreturn the decoded one, but thoughts on that?\nOn Tue, Nov 24, 2015 at 4:00 PM, Matt Silverlock notifications@github.com\nwrote:\n\nNote that using the EscapedPath() method would require us to drop support\nfor all versions of Go prior to 1.5. I don't think we're ready to do that\njust yet.\nThe alternative would be to implement our own function that takes a\n*url.URL and performs the same logic, with the maintenance overhead that\ngoes along with such an approach.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/gorilla/mux/issues/132#issuecomment-159443370.\n. \n",
    "duglin": "Would using URL.RawPath instead of URL.Path at this line: https://github.com/gorilla/mux/blob/master/mux.go#L71  be an option?  I guess if support for pre-Go 1.5 is required then probably not.\nIt was mentioned that using RequestURI might break existing apps, but couldn't treating %2F as / be considered a bug and therefore the change in behavior needed/expected?\nWe're running into a similar issue: https://github.com/docker/docker/pull/16577\n. Ah, never mind about RawPath - I see that EscapedPath() is the proper way to get the same info.\n. @elithrar is this now fixed?\n. @vaikas-google were you going to submit a PR?\n. ",
    "chrisdostert": "+1. I'm also in need of this\n. @elithrar in re: \"I'm not entirely convinced it's a bug\"\nthrowing the rfc @ you in hopes of buy in ; ) \nsee rfc3986#section-2.2\n\"When a URI is dereferenced, the components and subcomponents\n   significant to the scheme-specific dereferencing process (if any)\n   must be parsed and separated before the percent-encoded octets within\n   those components can be safely decoded, as otherwise the data may be\n   mistaken for component delimiters.\" \n. ",
    "hsinhoyeh": "hey guys, do we have any update here? I also hit into this.\n. ",
    "kushmansingh": "184 created, does not break backwards compatibility.\n. #184 merged. This issue can be closed? \n. #190 also merged. @elithrar, issue resolved?\n. The new test case fails on < go1.5. Please advise on how to skip this case for those versions.\n. I actually found the way recommended to do it in < 1.5 as mentioned here: https://golang.org/pkg/net/url/#URL\nI'm essentially doing what the new URL.EscapedPath() function does.\nGoing to now see if I can replace the regex matching with simple string slicing.\n. I realized the regex was unnecessary and would probably have large performance impacts, the parsing is cleaner and tighter now with just some simple indexing. As for the middleware, are you suggesting we forcibly assign req.URL.Path the escaped path we extracted? I think that would be unwise as it would break what is expected in req.URL.Path as specified by the stdlib.\n. @elithrar Can you provide a test case/situation that's causing the breakage?\n. @elithrar Added a test case to replicate the condition, everything should be good now hopefully \ud83d\ude04 \n. Reversion is probably the fastest solution if this is breaking for a lot of users. Here are some options for how to get this behavior functioning:\n1. The easiest; drop support for anything below 1.5. This is not immediately viable but I think there is merit in encouraging users to upgrade since the standard library has changed a significant amount  in net/http\n2. Provide an optional middleware which must be used as first in the chain. This middleware will parse RequestURI and place the escaped path into req.URL.Path. This breaks the assumption provided by the standard lib about req.URL.Path being unescaped already but would allow other middleware down the line to still function and route.\n3. Provide a flag on the basis of which either the parsed RequestURI will be used or req.URL.Path. If this flag was on, then other middleware would break the way that @shurcooL and @neelance are currently experiencing but it would be a very explicit \"TURN THIS ON AND STUFF MIGHT BREAK\" flag.\nI'm open to any other solutions and comments and I apologize for the inconvenience caused by this breakage.\n. @elithrar I'll be working on it and should have one up in the next day or two. I'll post updates if anything changes.\n. I added a separate test function for having a router with the feature turned on and also a check that it plays nicely with other features as well (as far as we can tell).\n. @elithrar Any other feedback?\n. Have you tried using http://www.gorillatoolkit.org/pkg/mux#Router.UseEncodedPath ? %0A is a newline character so the router probably needs to match against the encoded path.\n. I don't really like this. I'm debating whether it's worth breaking out into something like TestSkipClean\n. Silly edge case but what if someone wants to turn it off later? They turn it on, add a couple of routes, turn it off and add some routes they don't want the behavior for. \n. Right, that'd probably also cause some weird behavior with the regexp path variable matching. Making the change now \ud83d\ude04 \n. ",
    "dmitshur": "\nI should note that the race detector flag is not foolproof though as tests are usually self-contained, and therefore checking for races in tests may not actually uncover any races.\n\nAgreed. I don't see it as something that provides any kind of guarantees. Instead, it's more of \"given the option to run this or not, it's better to run it, just in case it helps catch issues.\" It's also consistent with the Travis build files I have in pretty much all of my Go projects - it's not specific to just gorilla/mux.\n. Another benefit in doing this is to advertise better CI practices to more people. This is a very popular Go package, so I imagine many people will be looking at how it does things. It's better to set a good example for others to follow.\n. Is there anything else that needs to be done from my side here?\n. No problem, happy to be able to help!\n. Some of my code stopped working after this change. I came to this PR to understand the change better and to figure out if the problem was in my code, or in this change.\nIn general, I don't mind breaking changes in APIs, as long as they are done intentionally and lead to an improvement, so it's not a problem. But I wish this PR was documented better - it was hard to figure out why it was done and what it attempted to accomplish.\nAfter looking around, I think I've figured out what happened, so I'll offer some suggestions for improvement (for next time) and explain for posterity in case others run into the same issue as I did:\n- The title is \"Add mechanism to route based on the escaped path\".\n  - That's somewhat misleading. It doesn't add a new optional mechanism, it changes the actual routing to be based on the escaped path.\n- The PR description is \"No description provided.\"\n  - This isn't very descriptive. I wish it said why this change was being done at all. I could not figure it out at first, but then I found #132, which is an issue this PR seems to be trying to resolve. It would be helpful if it said \"Fixes #132.\" or included more details.\n  - As a side benefit, if it included that text, then the issue would be closed automatically when the PR is merged (instead of having to be closed manually).\nThe reason my code stopped working (all routes stopped matching) is because I was modifying the req.URL.Path (stripping off a prefix) in my handler before passing it off to a gorilla/mux router (I'm still not quite sure if that's a valid use of this library or I shouldn't really be doing that). However, after this change, it's not enough to only modify req.URL.Path, one must also modify req.RequestURI (or simply clear it so that it's not used by getPath in this PR).\nI'll note that I'm thankful to the developers/maintainers of this library for doing a great job overall, and to the PR creator for working on resolving an issue. This comment is simply to provide what I hope is helpful additional information and suggestions for improvement for next time. I'm not trying to be negative. Thanks!\n. Here's an idea, but I'm unsure if it's viable or not.\nIf you look at how https://godoc.org/net/url#URL.EscapedPath works:\n\n// EscapedPath returns the escaped form of u.Path.\n// In general there are multiple possible escaped forms of any path.\n// EscapedPath returns u.RawPath when it is a valid escaping of u.Path.\n// Otherwise EscapedPath ignores u.RawPath and computes an escaped\n// form on its own.\n\nCan we do something similar and detect if req.URL.Path is a valid/possible encoding of req.RequestURI, and only use req.RequestURI in that case? Otherwise defer to req.URL.Path?\n. Thanks for improving it!. That's correct.\nFrom man pages on diff:\n\nExit status is 0 if inputs are the same, 1 if different, 2 if trouble.\n\nSo diff is used precisely to cause Travis to fail if there's a non-zero gofmt -d output. Just running gofmt -d by itself has 0 exit status and wouldn't cause Travis to fail.\n. Minor style nit. Unlike all others, this comment is missing a space between // and the text.. Maybe it'd be a good idea to remove the word \"also\":\n// Middleware implements the middleware interface.\nWhen reading documentation for this method, it might be confusing. \"Middleware also implements it? In addition to what?\". I suspect \"when the error in the request\" should be \"when the method in the request\".. ",
    "tonycosentini": "I totally missed this :(, it was Godeps vendoring in one file, but not a new file.\nSorry - and huge thanks for clarifying.\n. ",
    "marcelloh": "I somehow have this behavior too.\nStrange thing is, when this line runs:\nfmt.Fprintf(w, \"Vars: %v\\n%v\", mux.Vars(r), r.URL.Path)\nthis is my output\nmap[]\n/hello/testnaam\nNormally it runs coeerect, but when debugging a testscenario, it has empty Vars.\nCan't figure out how to solve this.\n. ",
    "bign8": "How's this @elithrar ?\n. I can remove the self reference if desired.  Just figured I would have a little fun with the test. :wink: \n. ",
    "olt": "I was hit by this issue, but it's possible to workaround with non-capturing groups. #196 contains an update to the documentation. \n. ",
    "tumdum": "I did not find any input that didn't work. But I don't know this code base at all ;)\n. ",
    "jprobinson": "Hi guys. I haven't figured out which change did it exactly, but this commit broke one of my project's builds today.\nThe test that broke has this as the route:\n/v2/puzzle/{type:(?i:daily|mini|.*?bonus|.*?variety)}-{date:\\\\d{4,4}-\\\\d{2,2}-\\\\d{2,2}}.json\nIt still matches this route:\n/v2/puzzle/daily-2015-02-01.json\nBut the value from \"date\" is getting put into the \"type\" value in the map returned by mux.Vars.\nIf it helps, this path is registered to a mux.PathPrefix(\"/svc/xxxx\").Subrouter().\n. Benchmark changes: \nbenchmark                             old ns/op     new ns/op     delta\nBenchmarkMux-4                        2712          2569          -5.27%\nBenchmarkMuxAlternativeInRegexp-4     3835          3860          +0.65%\nBenchmarkManyPathVariables-4          4410          4476          +1.50%\n. ",
    "dobegor": "There is also another problem with this setting.\nIf I define my path like \nr.Methods(\"POST\").Path(\"/users/\")\n(note the trailing slash) this setting won't work at all. Either it should be fixed or mentioned in the docs.\n. @elithrar \nok, I can fix it a bit later.\np.s.\nsorry, does it work at all with POST methods?\nhere are details link\n. @elithrar sorry, I can't test if this setting works with POST methods at all or I am doing something wrong (doesn't work for me, it just ignores this setting). That's why this needs some additional testing, because it can be related not only to documentation. Can't figure out reason myself. \n. ",
    "timjacobi": "I agree it is confusing. Express calls it strict routing which make more sense.\nhttp://expressjs.com/en/api.html#express.router\n. ",
    "viktorbenei": "Just a note: if you'd change this I'd suggest you to opt for a different name, to not to silently break existing codes which depend on how this flag works today.. ",
    "elvizlai": "@elithrar \n``` go\nfunc main() {\n    r := mux.NewRouter()\nadmin:=outer.PathPrefix(\"/admin\").Subrouter()\n//need a method to filter if req is authorized\n//if unauthorized, it blocked and return 401\n\nadmin.Handle(\"/add\", AddHandler)\nadmin.Handle(\"/delete\", DelHandler)\nadmin.Handle(\"/list\", ListHandler)\n\n}\n```\n. ",
    "antonbz": "@suanlihong @ElvizLai what do you think about something like this?\n``` go\nrouter := NewRouter().Use(globalMiddleware)\nrouter.Path(\"/use-global-middleware-only\").HandlerFunc(requestHandlerFuncA)\nsubRouter := router.PathPrefix(\"/admin\").Subrouter().Use(middlewareA, middlewareB)\nsubRouter.Path(\"/hello\").HandlerFunc(requestHandlerFuncB)\nsubRouter.Path(\"/hi\").HandlerFunc(requestHandlerFuncC)\nsubRouter.Path(\"/login\").HandlerFunc(requestHandlerFuncD)\n```\nIt's implemented here\n. @elithrar, don't know how many people need this.. But I can make PR with this \"Use\" feature if needed.\n. ",
    "cescoferraro": "@bezrukovspb :+1: :100: \n. @elithrar is it on the docs? the .Use(middleware) part \n. On diferent packages, using a function, it does not error. I just does not register the routes.\nDoing it a single time works\nThere is no way o doing this with a pointer receiver, as the compiler wont let you extend a non-local type.\nUnless on the same package which will make it a local type.\n. I got it to work. \nfunc InitRouter() *util.MyRouter {\n    router := mux.NewRouter()\n    user.UserRoutes(router)\n    ws.WsRoutes(router)\n    return &util.MyRouter{router}\n}\nSomewhy you cant return the pointer, the function has to have nothing to return.\nfunc UserRoutes(router *mux.Router) {}\nfunc WsRoutes(router *mux.Router) *mux.Router {}\nAnd you cant return the function argument directly, you need to create another variable\nWont work, No errors\n```\nfunc WsRoutes(router mux.Router) mux.Router {\n    go DashboardHub.Run()\n    router.PathPrefix(\"/iot\").Subrouter()\n    router.Handle(\"/lights/ws\", util.Adapt(WSHandler(router),\n        util.EnableCORS(),\n    ))\n    return router\n}\n```\nWorks!\nfunc WsRoutes(router *mux.Router) *mux.Router {\n    go DashboardHub.Run()\n    wsRouter := router.PathPrefix(\"/iot\").Subrouter()\n    wsRouter.Handle(\"/lights/ws\", util.Adapt(WSHandler(router),\n        util.EnableCORS(),\n    ))\n    return wsRouter\n}\n. ",
    "mikijov": "@elithrar I think the point is that people are used to chaining in node.js, and it is really powerful feature. I don't think I ever created a with a route where I did not use middleware. Authentication, logging, decoding etc. all middleware that is ubiquitous. I think we are confused by \"wontfix\" attitude. @bezrukovspb already implemented it... why not add it and make it simple than make people learn new way of dong things or add more dependencies?\n. Fair enough. Let's hope it is only little growing pains getting used to the new platform.  I have an aversion towards having too many dependencies, so that is my big argument. But, I will take your word as someone who has spent more time on the platform. Let's hope you are still right in a year's time. :-)\n. ",
    "morenoh149": "nope just have a codebase I inherited and it was difficult to inspect this behaviour, so I was hoping the test suite covered it.\n. ",
    "benma": "Thanks. #31 sounds the most similar, though in my case, everything works as expected until I add a variable to the route. Is that still the same root cause?\n. ",
    "onlyjob": "Please consider assigning version numbers and tagging releases. Tags/releases\nare quite useful for downstream package maintainers (in Debian and other distributions) to export source tarballs, automatically track new releases and to declare dependencies between packages. Read more in the Debian Upstream Guide.\nThank you.\nSee also\n- http://semver.org/\n- https://en.wikipedia.org/wiki/Software_versioning\n. Thank you. :)\n. > versioning is useful when vendoring using Go's vendoring capabilities.\nIndeed. Versioning can provide additional benefits to encourage vendoring of a particular (e.g. latest stable) release contrary to random unreleased snapshots.\n\nGiven that gorilla/mux is a library, building it into a Debian package would be a bad idea, and would island users relying on it/rely on a third party to update it.\n\nPackaging build dependencies is useful to reduce duplication and to run tests properly on build -- a something often neglected for vendored libraries.\nIt is absolutely normal for users of GNU/Linux distributions to rely on pre-built binary packages provided by OS from native repositories.\nDevelopers can still fetch latest sources themselves. Packaging can't stop them from doing that.\n\nv.1.1\n\nThank you. :)\n. Don't you worry, we always want to do the right thing. :)\nOf course primary purpose of source packages is to provide build (not run-time) dependencies.\nGolang produces static executables with all libraries built-in. Resulting binary package have no dependencies on source library packages.\nAs for concept of \"islanded\" libraries I think it is worth reading about problems with static linking:\nhttps://wiki.debian.org/StaticLinking\n. Unfortunately true.  :(\nYou can not yet make a dynamic Golang library even with Golang 1.5 or 1.6.\nExecutables generated by Golang-1.5 at least depend on libc6 but not on precompiled object go-libraries...\nMaybe eventually Golang will evolve to support dynamic linking properly but until then abuse of best practices in software engineering will continue... :(\n. ",
    "tpiron": "Having a mux release version that I could have use with gom would have prevent me for getting this issue btw : https://github.com/gorilla/mux/issues/194\nCan we consider having release versions / tags ? that would be very helpful and clean.\n. @neelance Thanks for the fix, it works. \nShould it be possible to tag the Mux releases? I'm using Gom (not probably the only one) to manage my go dependencies with Docker, and it would be awesome to be able to select a specific version/tag. (and it would probably have prevent me from having this issue)\nThanks again for the hard work on mux! (thanks @kisielk)\n. ",
    "akutz": "Hi @elithrar,\nI am. You'd have to trace it, but it starts here where you'll note I'm only calling Queries(\"detach\"). Well, that's because I created a wrapper for a Route and when you invoke Queries(q ...string), if len(q) == 1 then an additional, zero-length string is appended to the wrapper Route's internal queries []string collection.\nFinally, this is where I'm invoking the Gorilla toolkit's Queries function.\nf := s.makeHTTPHandler(ctx, r)\n            mr := m.Path(r.GetPath())\n            mr = mr.Name(r.GetName())\n            mr = mr.Methods(r.GetMethod())\n            mr = mr.Queries(r.GetQueries()...)\n            mr.Handler(f)\n            ctx.Log().WithField(\"route\", r.GetName()).Debug(\"registered route\")\nWhile I'm only emitting the name of the route in the log at the moment, the log statement used to look like this:\nctx.Log().WithFields(log.Fields{\n                \"route\":        r.GetName(),\n                \"path\":         r.GetPath(),\n                \"method\":       r.GetMethod(),\n                \"queries\":      r.GetQueries(),\n                \"len(queries)\": len(r.GetQueries()),\n            }).Debug(\"registered route\")\nIn fact, for giggles I added that back and am including the relevant portion of the logs:\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=0 method=GET path=/snapshots/{service} queries=[] route=shapshotsForService tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=0 method=GET path=/snapshots/{service}/{snapshotID} queries=[] route=snapshotInspect tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=0 method=POST path=/snapshots/{service}/{snapshotID}?create queries=[] route=snapshotCreate tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=0 method=POST path=/snapshots/{service}/{snapshotID}?copy queries=[] route=snapshotCopy tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=0 method=DELETE path=/snapshots/{service}/{snapshotID} queries=[] route=snapshotRemove tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=0 method=GET path=/volumes queries=[] route=volumes tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=0 method=GET path=/volumes/{service} queries=[] route=volumesForService tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=0 method=GET path=/volumes/{service}/{volumeID} queries=[] route=volumeInspect tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=2 method=POST path=/volumes/{service} queries=[create ] route=volumeCreate tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=2 method=POST path=/volumes/{service}/{volumeID} queries=[copy ] route=volumeCopy tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=2 method=POST path=/volumes/{service}/{volumeID} queries=[snapshot ] route=volumeSnapshot tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=2 method=POST path=/volumes/{service}/{volumeID} queries=[attach ] route=volumeAttach tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=2 method=POST path=/volumes queries=[detach ] route=volumesDetachAll tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=2 method=POST path=/volumes/{service} queries=[detach ] route=volumesDetachForService tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=2 method=POST path=/volumes/{service}/{volumeID} queries=[detach ] route=volumeDetach tls=true\nDEBU[0000] registered route                              host=tcp://127.0.0.1:7979 len(queries)=0 method=DELETE path=/volumes/{service}/{volumeID} queries=[] route=volumeRemove tls=true\nINFO[0000] api listening                                 host=tcp://127.0.0.1:7979 tls=true\nAs you can see, the routes with the detach query string do note that there are two query elements, and the output shows the second is an empty string.\nFWIW, I have it working temporarily by making it necessary to use the create query string to POST a new object to a collections resource. Ideally the default action should be create, without the need for an explicit query string. However, this alleviates the issue by making nothing use the default Path/Method combination, sans query string constraint.\n. I wonder if it's the order in which the routes are registered? I'm going to try registering the more specific ones first, specifically this use case.\n. Ha! That was it! This new order works as expected:\n```\n        // POST\n    // detach all volumes for a service\n    router.NewPostRoute(\n        \"volumesDetachForService\",\n        \"/volumes/{service}\",\n        r.volumeDetachAllForService,\n        handlers.NewServiceValidator(r.services),\n        handlers.NewSchemaValidator(\n            schema.VolumeDetachRequestSchema,\n            schema.VolumeMapSchema,\n            func() interface{} { return &httptypes.VolumeDetachRequest{} }),\n    ).Queries(\"detach\"),\n\n    // create a new volume\n    router.NewPostRoute(\n        \"volumeCreate\",\n        \"/volumes/{service}\",\n        r.volumeCreate,\n        handlers.NewServiceValidator(r.services),\n        handlers.NewSchemaValidator(\n            schema.VolumeCreateRequestSchema,\n            schema.VolumeSchema,\n            func() interface{} { return &httptypes.VolumeCreateRequest{} }),\n        handlers.NewPostArgsHandler(),\n    ), //.Queries(\"create\"),\n\n```\n. I'll let you verify the behavior is a bug / by design based on my feedback and then leave it up to you to close this as by design or track it as a bug. Either way, there appears to be a fairly simple workaround :)\n. Thank you for the answer!\n. ",
    "dselans": "Just ran into this myself - thank you @akutz for bringing this up (and documenting the resolve).. ",
    "gotschmarcel": "If a library depends on other libraries than there should be a dependency file. A vendoring tool is not able to figure it out by itself.\nImagine that I want to use gorilla/mux. I add it to my dependency file and my vendoring tool downloads it. Still go build will fail since gorilla/context is missing. So I have to go to your source code and figure out the dependency myself.\n. Yes, it requires a dependency file and I think most of the other tools do too. On the fly vendoring has some serious caveats - no dependency version (see go get).\n. Would also be nice if you guys would use SemVer for your libraries! :)\n. Docs section How It Works. Glide will look for one of these files in a downloaded library: glide.yaml, Godep, gb, or GPM config file.\nIt also checks any existing vendor/ folders. But it does not automatically figure out dependencies.\n. Glide may have some issues regarding recursive dependencies. I understand that supporting multiple vendoring tools isn't what anyone wants :).\n. ",
    "odlp": "Hi @ADone - can I offer any assistance on this PR to add the test requested so it can be merged to master?\nWould love to use this feature via gorilla/mux rather than the fork so we can stay current.\n. I had a shot at this but got stuck trying to introduce a new route_test.go file and was unsure whether to layer the tests into mux_test.go. Any hints on the best level to test this at?. Sorry I switched teams and don't work on a project using Gorilla Mux any longer, so I don't think I'll get round to this. Apologies for not updating the PR.. Yes, valid point that these are table tests today - there is less to be gained from Ginkgo on this point. I think clearer test failures & catching panics as failures can still be of benefit. \nOne other advantage to consider is that using Gomega with Ginkgo could make assertions more readable:\nBefore\ngo\nif path != \"\" {\n    u, _ := route.URLPath(mapToPairs(match.Vars)...)\n        if path != u.Path {\n            t.Errorf(\"(%v) URLPath not equal: expected %v, got %v -- %v\", test.title, path, u.Path, getRouteTemplate(route))\n            return\n        }\n}\nAfter\ngo\nif path != \"\" {\n    u, _ := route.URLPath(mapToPairs(match.Vars)...)\n    Expect(u.Path).To(Equal(path), \"Error message...\")\n}\nThis reduces indentation, and prevents the need for explicit early returns on failures. However I can see these are subjective benefits. \nFor context, I was trying to help out and write tests for PR#161 but found it tough to get going. I just thought I'd see if there was any appetite for using Ginkgo but appreciate it'd quite a lot of work to migrate.. ",
    "fern4lvarez": "Since SkipRouter cannot be changed as it is part of the public API, the purpose of this PR is not valid anymore. Closing.\n. ",
    "binarytrails": "Thank you. It may be a good idea to state that it is a 3-Clause BSD license. It is very clear now!\n. ",
    "nmiyake": "@themihai @elithrar I believe this is resolved by #261 and can be closed.. It seems like we're actually tracking a similar issue -- see #258 for discussions around possible approaches here (still trying to figure out a clean/general solution). Yup, I definitely understand the concerns around special-casing like this, and understand if ultimately you don't think this is a good fit for the library. However, thought it would be worth discussing.\nBy \"wrapping the call\", I assume you mean something like:\ngo\nfunc RegisterHandler(r *mux.Route, handler http.Handler) *Route {\n   r.Handler(my.DecoratorFunc(handler))\n}\nThis certainly works, but the main drawback is that it still requires a programmer to remember to register all handlers using this function. If they happen to forget to register a handler using this function and call r.Handler directly instead, then it won't work. In any large project, I don't have confidence that programmers (even with CR) can be protected from this (I could add linting rules to flag all uses of r.Handler, but that's a project-level modification that's heavier-weight).\nI could type alias/wrap mux.Route and only expose the \"wrapper\" function there, but because there are multiple mux.Route and mux.Router functions that return mux.Route , I'd basically have to define wrapper functions for all of it, which would get pretty tedious.\nAdding a Before handler (or some other mechanism to inject logic after the variables and routes are processed for a matched handler) seemed much cleaner/easier compared to these approaches.. Also, to zoom out a bit -- the objective that I'm ultimately trying to accomplish is to be able to store the current route and path parameter variables for every matched route. The approach outlined in this issue seemed like the most generic/cleanest way to enable this in a manner that doesn't require auditing every caller, but if you have other ideas for how to solve this underlying issues I'd be open to suggestions!. Alternate approach that I just thought of that is similar to this but would be a bit more scoped and may not have the baggage of a before/after:\n\nInstead of BeforeHandler, add MatchCallback func(*http.Request, RouteMatch)\nOn any match, ServeHTTP would invoke r.MatchCallback(req, match)\n\nThis gets at the underlying issue (add a way to extract information about the match outside of the scope of the handler itself) without opening the pandora's box of full-blown special-case handlers.. @elithrar wrapping the route doesn't work because the matched variables are only available within the scope of the handler itself. Per the documentation on CurrentRoute:\n// This only works when called inside the handler of the matched route\n// because the matched route is stored in the request context which is cleared\n// after the handler returns, unless the KeepContext option is set on the\n// Router.\nI have verified that this is the case -- because the router's ServeHTTP copies the context before setting the variables on it (which I agree is the correct approach), they aren't visible before or after in middleware calls. FWIW, I'm guessing that something like this is the motivation behind the PR https://github.com/gorilla/mux/pull/240 as well.\n@ChrisHines I considered that solution as well, and it's definitely still in the running as it does work. The one case where it doesn't work is if people attach more handlers to the router after the server has started/DecorateHandlers have been called. That probably isn't great practice so not quite as worried about it, but it still isn't as foolproof at intercepting at the call site itself (which effectively provides the guarantee that any match provided by the root router will be intercepted).\nIf something like this isn't a good fit, I'll likely go with either walking to decorate (and warning people not to attach routes afterwards) or defining my own \"root router\" (effectively a copy mux.Router that adds what I want here), return that in my library and have clients attach all routes/subrouters etc. to that base router (since only the top-level ServeHTTP needs to be intercepted, all the subrouters and routes underneath it can still be vanilla mux.Router or http.Handler and be fine).. Good to know! In that case, walking the handlers and decorating them is probably a sufficient solution for me. Will close out this issue -- thanks for the help!. @ChrisHines your solution worked in simple cases, but unfortunately it looks like there are some valid constructions of routers/handlers where Walk will not return the handler even though one is clearly registered. Example code:\n```go\nfunc TestWalk(t *testing.T) {\n    router := mux.NewRouter().StrictSlash(true)\n    v1 := router.PathPrefix(\"/v1\").Subrouter()\nstacks := v1.PathPrefix(\"/products\").Subrouter()\nstackInstance := stacks.PathPrefix(\"/{product}\").Subrouter()\n\nhandlerInvoked := false\nstackInstance.Methods(\"GET\").Handler(http.HandlerFunc(func(http.ResponseWriter, *http.Request) {\n    handlerInvoked = true\n}))\n\nserver := httptest.NewServer(router)\ndefer server.Close()\n\nif handlerInvoked == true {\n    t.Errorf(\"handler should not be invoked\")\n}\n\nhttp.Get(server.URL + \"/v1/products/myProduct\")\n\nif handlerInvoked != true {\n    t.Errorf(\"handler should have been invoked\")\n}\n\nrouter.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {\n    tmpl, _ := route.GetPathTemplate()\n    fmt.Printf(\"route: %s, handler: %v\\n\", tmpl, route.GetHandler())\n    return nil\n})\n\n}\n```\nOutput:\nroute: /v1, handler: <nil>\nroute: /v1/products, handler: <nil>\nroute: /v1/products/{product}, handler: <nil>\nAs you can see, the test passes (so the handler is clearly invoked), but handler reports as nil when walking the routes, so the decoration approach is out -- although I'm sure I could debug this/figure out a way to try to get at all the handlers in the walk, I'm weary of adding too much logic there and would be afraid of the consequences of missing an edge case where some handler would not be found by the walk and thus not wrapped properly.\nFundamentally, I'm still looking for a way to have the guarantee that, if a match is found and match information is recorded, there's a way to get that information externally every time.\n@kisielk what do you think about the notion of adding a callback hook/function? Concretely:\n```go\ntype Router struct {\n    // Configurable Handler to be used when no route matches.\n    NotFoundHandler http.Handler\n        // MatchCallback is invoked on any route match before the handler is invoked\n        MatchCallback func(*http.Request, RouteMatch)\n        ...\n}\nfunc (r Router) ServeHTTP(w http.ResponseWriter, req http.Request) {\n     ...\n     if r.Match(req, &match) {\n        handler = match.Handler\n        req = setVars(req, match.Vars)\n        req = setCurrentRoute(req, match.Route)\n                if r.MatchCallback != nil {\n                      r.MatchCallback(req, match)\n                }\n     }\n     ...\n}\n```\nI know that this still adds a call-back, but it is a bit more scoped. I do have a plan for working around this in my own library/use case (basically by duplicating the code for Router, making this modification and using that as the top-level router that everything else registers routes on), but I do think this is a more general concern (for example, this mechanism would allow https://github.com/gorilla/mux/issues/257 to be solved as well), and think that providing some kind of first-class mechanism to enable this would be nice.. Filed https://github.com/gorilla/mux/issues/261 for the Walk issue.\nFixing Walk would fix the decorator approach, but I think that the general issue/request may still make sense independently, so keeping the issue open for now. However, if we come to the conclusion that this kind of API hook does not make sense for the project (whether it be because the primary use case cited can be solved by another approach or just that it doesn't make sense as part of the API), then fine with closing this out without further action.. Dug around more and understand what's going on now -- the issue is that Walk only walks routes/subroutes with concrete paths registered, so if a path has subrouters with method handlers registered, those are never visited.\nFiled #262 to provide a proposal for exposing a way to walk all routes, and updated #261 to track the fact that the current behavior of Walk is inconsistent with the documentation.. After investigation, I believe that, as long as other issues are fixed, there are sufficient mechanisms to work around this.\nOnce #261 and #263 are fixed, it should be possible to walk all routes and decorate all of the handlers. Because WalkFunc is provided with both the route and all of the ancestors, it's possible to register a handler that records both the path variables and the first non-empty template path from the closes ancestor route.\nIt is also possible to wrap the root Router and use its Match function to extract the match and path variable information:\n```go\ntype RootRouter mux.Router\nfunc (r RootRouter) ServeHTTP(w http.ResponseWriter, req http.Request) {\n    var match mux.RouteMatch\n    if (mux.Router)(r).Match(req, &match) {\n        // match.Route.GetPathTemplate() may return error/no path template: need #266 to be fixed so that,\n        // if that is the case, first non-nil path template from ancestor can be retrieved\n        matchCallback(match)\n    }\n    (mux.Router)(r).ServeHTTP(w, req)\n}\n```\nCurrently, this has the issue that, if the matched route doesn't have a path defined, there's no way to retrieve the matched path template. However, if #266 is fixed, this would be possible as well and it would be a plausible workaround.\nClosing out this issue in favor of the other ones.. Related to https://github.com/gorilla/mux/issues/166 and https://github.com/gorilla/mux/issues/252 . Note that fixing this issue will cause a behavioral change in the API -- the previous implementation had the effective invariant that, for any route passed to WalkFunc by Walk, route.GetPathTemplate() would return a non-empty template (and nil error).\nAfter this issue is resolved, if callers want their WalkFunc implementations to preserve the previous behavior, they can add the following to the beginning of their WalkFunc:\ngo\n// skip routes that do not have a path template defined to match previous Walk behavior\nif _, err := route.GetPathTemplate(); err != nil {\n   return nil\n}. OK. I'm personally fine with either approach, but was just flagging that fixing this bug will create a behavioral difference in API behavior for existing clients -- previously, it happened to be the case that every route passed to WalkFunc would have t.regexp.path.template != \"\", so any existing consumers that make this assumption would be broken by a change here -- to preserve it, they would need to add the following to their WalkFunc:\ngo\n_, err := route.GetPathTemplate()\nif err == nil {\n    return nil\n}\nIf you guys are fine with this, then it works for me -- I've opened https://github.com/gorilla/mux/pull/265 to implement the fix in this manner.\nIf you want to preserve the old behavior for back-compat, then I would like to propose implementing this \"fix\" via the method outlined above (and can update my PR to do so).. OK great -- in that case, will close this issue out in favor of #261. Thanks!. @elithrar @kisielk I believe this fix is fairly straightforward -- would appreciate feedback/review when you get a chance!. The \"Listing Routes\" section of the README contains an example of using WalkFunc -- do you want me to add another section separately from that, add something to (or rename) that section, or is it okay as-is given that the section exists?. Addressed PR feedback: tightened up the example in \"Listing Routes\" a bit, renamed it to \"Walking Routes\" and moved it to a section after \"Registered URLs\".\nReady for review.. @elithrar @kisielk thanks for merging #265 -- if you could review/provide feedback on this PR and move to merge as well that would be great (both of them together will allow me to resolve the underlying issue described in #258) . @kisielk @elithrar any thoughts on this? Not urgent since I'm able to work around this at the handler level (I use Walk to register a handler that knows its own match path based on the ancestors built up in Walk), but I do think that, from an API standpoint, it'd be nice if mux.Vars had an equivalent mux.Path/mux.Template (or something similar) where you could determine the path/path template that was used for a match. Currently, it's not possible to do this cleanly if the matched route itself doesn't have a regexp.. ",
    "astromahi": "It would be great help, if you guys export the setVars. It forcing me to do functional testing.\nfunc setVars(r *http.Request, val interface{}) *http.Request {\n    return contextSet(r, varsKey, val)\n}. ",
    "vincent6767": "Any update on this? . Yep. I have just seen them several hours ago. Thank you!. ",
    "palsivertsen": "Handy function for testing!\ntesting-handlers section in Readme could use this update. @elithrar Sure. See pull #342 . I'm not sure I follow. Yes, the example do show how to use table-driven testing, but it does not show nor test route variables as far as I can see.\nIn the current example there is a main function:\n```go\n// endpoints.go\nfunc main() {\n    r := mux.NewRouter()\n    // A route with a route variable:\n    r.HandleFunc(\"/metrics/{type}\", MetricsHandler)\nlog.Fatal(http.ListenAndServe(\"localhost:8080\", r))\n\n}\nThis shows how to use the `MetricsHandler` but the not source code. Since `MetricsHandler` is what we actually want to test, the source should be included as well. I'm guessing it would look something like this:go\nfunc MetricsHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    typeVar, found := vars[\"type\"]\n    if !found {\n        // This should never happen as the Gorilla Mux should set it for us\n        panic(\"The request is missing path variable 'type'\")\n    }\n    switch typeVar {\n    case \"goroutines\", \"heap\", \"counters\", \"queries\":\n        w.WriteHeader(http.StatusOK)\n    default:\n        w.WriteHeader(http.StatusNotFound)\n    }\n}\nIf you then to run the example, you'll discover it does not compile and has a bug when checking the response so I made a few adjustments:diff\npackage examples\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n)\n// endpoints_test.go\nfunc TestMetricsHandler(t *testing.T) {\n    tt := []struct {\n        routeVariable string\n        shouldPass    bool\n    }{\n        {\"goroutines\", true},\n        {\"heap\", true},\n        {\"counters\", true},\n        {\"queries\", true},\n        {\"adhadaeqm3k\", false},\n    }\n\nfor _, t := tt {\npath := fmt.Sprintf(\"/metrics/%s\", t.routeVariable)\nfor _, data := range tt {\npath := fmt.Sprintf(\"/metrics/%s\", data.routeVariable)\n        req, err := http.NewRequest(\"GET\", path, nil)\n        if err != nil {\n            t.Fatal(err)\n        }rr := httptest.NewRecorder()\nhandler := http.HandlerFunc(MetricsHandler)\nhandler.ServeHTTP(rr, req)\n\n// In this case, our MetricsHandler returns a non-200 response\n// for a route variable it doesn't know about.\n\n\nif rr.Code == http.StatusOK && !t.shouldPass {\nif (rr.Code == http.StatusOK) != data.shouldPass {\n        t.Errorf(\"handler should have failed on routeVariable %s: got %v want %v\",\nt.routeVariable, rr.Code, http.StatusOK)\ndata.routeVariable, rr.Code, http.StatusOK)\n    }\n}\n}\n``\nIf you then try running the test you'll see thatMetricsHandlercomplains that it can not find thetype` path variable.\n\n\n\nWhat I then did was:\n Removed table-driven part of test for simplicity. Although it is an excellent way to write tests, it has nothing to with path variables.\n Add the source of what is actually being tested. MetricsHandler was reanmed to VarLogger to make it more clear what is does.\n Fixed syntax errors in test example\n Fixed bug in test example\nAlternatively I could add the VarLogger handler to a mux.Router and test this using mux.Router.ServeHTTP but I feel it's out of scope for the example and unit test.. I think we are on the same page regarding beginner friendliness :)\nBut I think I'm missing something. Please correct me if I'm wrong:\nWhen the readme mentions variables it's referring to path variables. mux.Vars is how you retrieve variables from a request. There are two ways of setting a path variable, add a new route with /path/{myVar} path syntax or use mux.SetURLVars.\nI don't see how the current example illustrates how to use path variables when it does not include any of mux.Vars, /path/{myVar} or mux.SetURLVars?. ",
    "ejholmes": "Thanks for the tips @elithrar. I just opened https://github.com/gorilla/mux/pull/169 that adds support for this using build tags.\n. ",
    "james-lawrence": "absolutely, excuse any blatant errors in the example, psuedo coding =)\ngolang\nfunc handler(w *http.ResponseWriter, req *http.Request) {\n  type Msg struct {\n      Field1 bool   `schema: 'field1'`\n      Field2 string `schema: 'field2'`\n  }\n  var (\n    msg Msg\n  )\n  _ =  req.ParseForm()\n  _ = schema.NewDecoder.Decode(&msg, mux.Vars(req))\n  _ = schema.NewDecoder.Decode(&msg, req.PostForm)\n}\nrouter := mux.NewRouter()\nrouter.Handle(\"/foo/{field1}\", handler)\nwhile I was writing a handler it felt kind of kludgey to have to manually map the results of mux.Vars\n. I don't see how different encodings matter in this case? My point was an attempt to make it a little more accessible using off the shelf tools, All it really needs is a method to return url.Values instead of a map[string]string.\nthis is hardly 'magic' its just a convience. yes there is a performance tradeoff but you can still map manually if you want/need to. \nAnyways this was more just a question of if there was anyone else who felt it was kludgey.\n. ",
    "pjebs": "I believe it may not be that simple.\nI'm only speculating but I think in top example the package level function is kept in memory the whole time.\nI think in second example, the closure is garbage collected and recreated every time the route is called.\nI'm only speculating and haven't properly looked into it but my handlers are very large and I have almost 50 routes. I think I noticed my memory usage decrease significantly when I changed it to type 2.\n. I haven't profiled. What I'm 'feeling' is that the closure version is lighter - not heavier.\n. ",
    "andrewwatson": "oh.\n. ok this was totally my fault. i cut and pasted the example code from the mux docs but I didn't notice I had named my router variable \"router\" instead of \"r\".   my bad!\n. ",
    "vadmeste": "It depends on whether mux waits for the request to be completely received before dispatching to handlers or not.\n. @elithrar, your answer is convincing but I didn't test anything yet, thanks for assisting me..\n. ",
    "heiing": "pull\n. ",
    "nwidger": "I can provide a more detailed example but hopefully this demonstrates how I was using context+mux in the past: https://play.golang.org/p/LoejXfXWtu\nThis was working previously with Go 1.6 as well as many previous versions.\n. Here's a runnable example that shows the problem:\nhttps://play.golang.org/p/KHn9Fcv-ZN\nRun it and navigate to http://localhost.  If built with Go 1.6.3 it prints \"bob\" to the screen.  If built with Go 1.7 rc6 it prints \"no context stored for request\".\nHopefully that highlights the issue better, I apologize if my original bug report wasn't clear.\n. @elithrar For my own situation, I've already bypassed this issue by replacing gorilla/context with the new context package, similar to what you suggested.  So this isn't an issue for me anymore, but it may be for others which is why I reported it.\n. Technically, so long as you use gorilla/context.Set after all calls to request.WithContext() you shouldn't run into this issue.\n. ",
    "marcosnils": "Just ran across this. Too bad I need to refactor my app to make this work :(\n. ",
    "plv1313": "Hello, \nIt seems with Go 1.7 this tag you have under context_gorilla: // +build !go1.7 is breaking the vendoring of godeps as it is not including the context module. Any workarround?\n. Yes it seems Godeps doesn't see it, unless I am missing something.\n. I am not convinced that this is a godep bug. Godep by default is including all deps it finds regardless of tags (except for ignore and app engine). So as expected when Godep see this tag // +build !go1.7 will ignore it.\n. ",
    "ahmdrz": "I added w.Header().Add(\"Access-Control-Allow-Origin\", \"*\") w.Header().Set(\"Access-Control-Allow-Origin\", \"*\") and i saw my network header on chrome.\ni didn't saw Access-Control-Allow-Origin on response header ... \n. I added my header on :\nfunc GetNewsListHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Add(\"Access-Control-Allow-Origin\", \"*\")\n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\nheaders still not changed !\nbut i think i can solve it by cors...\n. | but i don't know how can i use cors ! : |\n| --- |\n:+1: \nfinally\n```\npackage main\nimport (\n    \"log\"\n    \"net/http\"\n\"github.com/rs/cors\"\n\n)\nfunc main() {\n    log.Println(\"Database : Checking\")\n    if OpenDatabase() != nil {\n        log.Fatalln(\"Database : Failed\")\n    }\n    log.Println(\"Database : Success\")\n    log.Println(\"Crawler : Started\")\n    go Crawl()\n    log.Println(\"WebService : Checking\")\n    router := NewRouter()\n    log.Println(\"WebService : Success on \" + WEB_PORT)\n    log.Println(\"Cors : Configuring...\")\n    handler := cors.Default().Handler(router)\n    log.Println(\"Cors : Serving...\")\n    log.Fatalln(http.ListenAndServe(\":\"+WEB_PORT, handler))\n}\n```\n. Okay !\nHere is my router.go file\n```\npackage main\nimport (\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\ntype Route struct {\n    Name        string\n    Method      string\n    Pattern     string\n    HandlerFunc http.HandlerFunc\n}\ntype Routes []Route\nfunc NewRouter() *mux.Router {\nrouter := mux.NewRouter().StrictSlash(true)\nfor _, route := range routes {\n    router.\n        Methods(route.Method).\n        Path(route.Pattern).\n        Name(route.Name).\n        Handler(route.HandlerFunc)\n}\nreturn router\n\n}\nvar routes = Routes{\n    Route{\n        \"GetNewsList\",\n        \"POST\",\n        \"/GetNewsList/\",\n        GetNewsListHandler,\n    },\n    Route{\n        \"GetNews\",\n        \"POST\",\n        \"/GetNews/\",\n        GetNewsHandler,\n    },\n}\n```\n. Absolutely yes. It's working for me !\nI want to close this issues\nThank a lot for making powerful router. :+1: \n. ",
    "neelance": "As @shurcooL already correctly described, this change assumes that req.RequestURI is always in sync with req.URL.Path. This assumption does not even hold in Go's standard library, for example https://golang.org/pkg/net/http/#StripPrefix modifies req.URL.Path, but not req.RequestURI. Also, modifying the req.RequestURI field does not really fit to its documentation: \"RequestURI is the unmodified Request-URI of the Request-Line (RFC 2616, Section 5.1) as sent by the client to a server.\"\nThis change probably breaks a lot of exiting uses of gorilla/mux and imho reverting this change should be considered until there is a better solution.\n. @calebcase The documentation of URL.Path recognizes this fact (https://golang.org/pkg/net/url/#URL):\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/. A consequence is that it is impossible to tell which slashes in the Path were slashes in the raw URL and which were %2f. This distinction is rarely important, but when it is, code must not use Path directly.\n\nSo I wouldn't say that \"URL.Path is broken for any use as a routing path\". They chose to ignore this edge case for simplicity. If your application depends on this edge case, then unfortunately you have to roll your own implementation based on URL.RawPath or Request.RequestURI instead of relying on the standard library's tools. I think the same applies to gorilla/mux.\n. @elithrar I've added a test which fails before the fix.\n. The reason for the exception is that the regexp contains capturing groups (...) while it is only allowed to contain non-capturing ones (?:...). The fixed regexp looks like this: /exception/{from:(?:[0-9]+)?}{to:(?:\\/to\\/[0-9]+)?}.\nNote: The given regexp does not fit to the URL http://localhost:8000/exception/?to=42 mentioned above. I tested with http://localhost:8000/exception/11/to/42 instead.\n. Just to be clear: I don't have the time to implement this right now, quite busy with working on other projects. Sorry.\n. @elithrar Yes, breaking this test means that extractVars is showing the faulty behavior again, which is not surprising since this PR reverts extractVars to its earlier implementation.\n. This pattern has a capturing group, which is not allowed. (a|b) should be (?:a|b) instead. When using (?:a|b) the test passes with the extractVars implementation of current master. This would mean to me that #200 is invalid, because it is caused by a bad pattern input. However, some automatic check with a nicer error message would definitely be helpful in such cases.\n. What about using a regexp replace to automatically turn capturing groups into non-capturing ones? Then we don't need a panic.\n. ",
    "calebcase": "It appears the URL.Path is broken for any use as a routing path. Even in newer version of Go it contains an 'unescaped' path, but they don't take any precautions to only unescape valid characters in a segment. The result is a path that can contain '/' where it should NOT exist.\nhttps://play.golang.org/p/j41wEQeMM-\n```\npackage main\nimport (\n    \"fmt\"\n    \"net/url\"\n)\nfunc main() {\n    raw := \"/foo%2Fbar/baz\"\n    u, _ := url.Parse(raw)\n// Default behaviours:\nfmt.Printf(\"[default] Path: %s\\nRawPath: %s\\n\\n\", u.Path, u.RawPath)\nfmt.Printf(\"[default] EscapedPath: %s\\n\\n\", u.EscapedPath())\n\n// What happens if Path is manually overwritten:    \nu.Path = \"/fun%2Ftimes/baz\"\nfmt.Printf(\"[path   ] EscapedPath: %s\\n\\n\", u.EscapedPath())\n\n// Must overwrite both to get the right behavior (including creating Path with the invalid unencoded value):\nu.Path = \"/fun/times/baz\"\nu.RawPath = \"/fun%2Ftimes/baz\"\nfmt.Printf(\"[both   ] EscapedPath: %s\\n\", u.EscapedPath())\n\n}\n```\nResult:\n```\n[default] Path: /foo/bar/baz\nRawPath: /foo%2Fbar/baz\n[default] EscapedPath: /foo%2Fbar/baz\n[path   ] EscapedPath: /fun%252Ftimes/baz\n[both   ] EscapedPath: /fun%2Ftimes/baz\n```\nThe documentation examples for ServeMux imply that request.URL.Path is a public interface suitable for overriding (e.g. StripPrefix ). It probably shouldn't since this won't result in proper behavior.\nGorilla Mux should be clear in the docs about what value is used to route on so users can use that as part of the public API. The tricky bit here is that Path and RawPath must both be in sync or EscapedPath() will not work as expected (see above example). It should also be made clear if the paths given to routers need to be URL encoded themselves.\n. Since we have the raw query string and fragment can we just get the length of those and strip that off via a slice as well?\n. ",
    "shawnps": "@pedromorgan I threw a quick example together, hope this helps:\n```\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    return\n}\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/\", handler)\n    r.HandleFunc(\"/products\", handler)\n    r.HandleFunc(\"/articles\", handler)\n    r.HandleFunc(\"/articles/{id}\", handler)\n    r.Walk(func(route mux.Route, router mux.Router, ancestors []*mux.Route) error {\n        t, err := route.GetPathTemplate()\n        if err != nil {\n            return err\n        }\n        fmt.Println(t)\n        return nil\n    })\n    http.Handle(\"/\", r)\n}\n.\n\u279c  ~  go run foo.go\n/\n/products\n/articles\n/articles/{id}\n```\n. @elithrar let me know if you think this would be useful to have in docs/README and I can add it in, otherwise maybe we can close this issue out if no response from @pedromorgan?\n. @elithrar cool. PR is here, let me know if it can be made better:\nhttps://github.com/gorilla/mux/pull/217. ",
    "adelowo": "@pedromorgan if you want a visual display (in the cli), you might want to check out this repo https://github.com/adelowo/muxlist. I really need the GetMethods . Ha, thank you... ",
    "Southern": "Ah. In that case, could we expose ContextKey or something so that mux.Vars can be used without having to setup a route and use httptest?\n. Of course it would work, but I'm not trying to handle the response or even care about the route itself. I'm just pulling params from the *http.Request.\nIt would be so much easier for people to use something like:\ngo\nrequest, _ := http.NewRequest(\"PATCH\", \"\", nil)\nctx := context.WithValue(request.Context(), 0, map[string]string{\n    \"param1\": param1,\n    \"param2\": param2,\n})\ndata := mapParams(request.WithContext(ctx))\n// assertions to check data\nVerses having all of this to achieve the same result:\n``` go\nrouter := mux.NewRouter()\nrouter.HandleFunc(\"/{param1}/{param2}\", func (response http.ResponseWriter, request *http.Request) {\n    data := mapParams(request)\n    // assertions to check data\n})\nts := httptest.NewServer(router)\ndefer ts.Close()\nurl := fmt.Sprintf(\"%s/%s/%s\", ts.URL, param1, param2)\nrequest, _ := http.NewRequest(\"PATCH\", url, nil)\nc := &http.Client{}\nresponse, e := c.Do(request)\nif e != nil {\n    t.Error(e)\n}\n```\n. I'm not testing routes at all. I would just like to be able to force a context with params during testing instead of setting up a router, handler, httptest server, http client, and then finally be able to send my request for testing.\nI'm not sure that's a benefit because I highly doubt most people will ever want to modify the context during runtime in the first place.\n. ",
    "chr0n1x": "I'm not testing routes either. Instead, I have collections of func(ResponseWriter, *Request)s that I would just like to test without having to set up an http server. All I want to do is call http.NewRequest and throw the object directly into the handlers to test specific cases.\nThat being said, I do see my doing this as a code smell in my application. I guess that it would be preferable to have middleware that passes mux.Vars(r) as a separate argument to all of my handlers, however that's a fairly large refactor in my apps current state.\n@elithrar - do you have any other suggestions on how to test functions that use mux.Vars(r)? I kind of want to avoid splitting mux.Vars(r) calls into a separate object that I can swap out with some sort of test dummy object.\n. ",
    "grim-fendango": "Hey we can close this now \ud83c\udf89 since this PR has been merged.\nTo set context vars you just need to do the following:\nrequest, _ := http.NewRequest(\"PATCH\", \"\", nil)\nrequest = mux.SetURLVars(request, map[string]string{\n    \"param1\": param1,\n    \"param2\": param2,\n}). I think the provided implementation strikes a good balance between testibility and discouraging bad behaviour. Could we please get this into a PR and merged ASAP?. Hey peeps, I've cherry picked the commit provided by @achiku and spun up a PR would love to hear your feedback \ud83d\ude38 . Hey we can close this now \ud83c\udf89 since this PR has been merged.. @kisielk and @elithrar thanks again for your feedback \ud83d\ude3a . I think I've addressed you're concerns. Let me know if you find anything else.. Wow thanks for a fast response! \ud83d\ude03  I was just thinking about that myself. I'm just looking up some other concrete examples for this sort of thing and then I'll reword it.. I just wrote something but yours is nicer. Thanks again.. ",
    "kujenga": "Some additional information here that more tightly scopes this problem, this issue only occurs within the deployed Google App Engine environment. It does not occur in local development with the App Engine SDK.\nI have a project here that that I just updated, and demonstrates the same problem (note that I'm using specifically the ae-glide branch).  https://github.com/kujenga/vendorexpr/tree/ae-glide\nVisiting the URL this app after it's deployed results in the same stack trace:\n```\npanic: runtime error: slice bounds out of range\ngoroutine 6 [running]:\npanic(0x146efa0, 0xc01040e020)\n    go/src/runtime/panic.go:443 +0x4e9\ngithub.com/gorilla/mux.getPath(0xc0104c42a0, 0x0, 0x0)\n    github.com/gorilla/mux/mux.go:373 +0x166\ngithub.com/gorilla/mux.(Router).ServeHTTP(0xc010454460, 0x2af5afbbd818, 0xc010451900, 0xc0104c42a0)\n    github.com/gorilla/mux/mux.go:80 +0x48\nnet/http.(ServeMux).ServeHTTP(0xc010410ba0, 0x2af5afbbd818, 0xc010451900, 0xc0104c42a0)\n    go/src/net/http/server.go:1910 +0x17d\nappengine_internal.executeRequestSafely(0xc010451900, 0xc0104c42a0)\n    go/src/appengine_internal/api_prod.go:303 +0x8d\nappengine_internal.(*server).HandleRequest(0x18af390, 0xc0104dd200, 0xc010400a80, 0xc010439d40, 0x0, 0x0)\n    go/src/appengine_internal/api_prod.go:237 +0x15b5\nreflect.Value.call(0x149eb00, 0x18af390, 0x213, 0x1555ef8, 0x4, 0xc010513f30, 0x3, 0x3, 0x0, 0x0, ...)\n    go/src/reflect/value.go:435 +0x120d\nreflect.Value.Call(0x149eb00, 0x18af390, 0x213, 0xc010513f30, 0x3, 0x3, 0\n```\nI'm going to add some middleware to get debug information about the URL format to try to narrow this down further.\n. For App Engine requests in the deployed environment, The value of RequestURI does not contain a \"host\", so for a request to the root URL on the deployed test app I linked to above, the value of RequestURI is \"/\". \nThis is the debug printed output (with %#v) of the URL entity:\ngo\nurl: &url.URL{Scheme:\"http\", Opaque:\"\", User:(*url.Userinfo)(nil), Host:\"vendorexpr-dot-my-app.appspot.com\", Path:\"/\", RawPath:\"\", RawQuery:\"\", Fragment:\"\"}\nI found an issue on Google App Engine relating to this discrepancy:\nhttps://code.google.com/p/googleappengine/issues/detail?id=7679\nThe fix should be fairly simple, I'll have a PR up shortly.\n. Opened PR https://github.com/gorilla/mux/pull/189 with a fix and test coverage.\n. Awesome, sure thing!\n. ",
    "manisenkov": ":+1: It works for our GAE project\n. ",
    "markotikvic": "Hi.\nI went and 'go get -u github.com/gorilla/mux' after this merge and the problem with raw path doesn't exist anymore but there seems to be a problem with UseEncodedPath method:  \n(type *mux.Router has no field or method UseEncodedPath)\nBut maybe I'm doing something wrong:\nr := mux.NewRouter()\nr.UseEncodedPath(true)\nThis seems OK to me, but I might be mistaken. Any ideas?\n. That's most likely it.\nThank you.\n. ",
    "Boichenko": "I use go version 1.6.2 windows/amd64\nNeed to notice that this code works fine without basic authentication. i checked a lot of times.\n. func Secret(user, realm string) string {\n    if user == \"john\" {\n        // password is \"hello\"\n        return \"$1$dlPL2MqE$oQmn16q49SqdmhenQuNgs1\"\n    }\n    return \"\"\n} //(this is from your example, the same result)\nbasicAuth:= auth.NewBasicAuthenticator(\"Basic Realm\", Secret)\nr.HandleFunc(\"/licenses/{key}/status\", basicAuth.Wrap(apilsd.CancelLicenseStatus)).Methods(\"PATCH\")\nfunc CancelLicenseStatus(w http.ResponseWriter, r *auth.AuthenticatedRequest) {\n    vars := mux.Vars(&r.Request)\n    fmt.Printf(\" %#v\", &r.Request)\n    licenseFk := vars[\"key\"]\n    grohl.Log(grohl.Data{\"fk\": licenseFk}) //fk=nil\n}\nhttp://localhost:8990/licenses/4707f1fe-98b9-40bc-835d-4f0db678ec4c/status - to check\ncan you help me via skype, if you don't mind? i just \"broke\" my head trying to solve this problem :(\n. https://1drv.ms/u/s!AiHa-7v0RdbXnGpziq20pSHqwL6F\nthis is the example. just run lsdserver.go\n. checked your example (to make more useful to me add \ngrohl.Log(grohl.Data{\"fk\": vars[\"key\"]})\nafter \nfmt.Fprintf(w, \"<html><body><h1>Hello, %s!</h1></body></html>\", r.Username))\nthe result: fk is nil\ni'm testing it using advanced REST client (chrome extension)\n. made go get github.com/gorilla/mux again. the result is the same\n1)- Are you getting nothing back for the key, but otherwise a successful HTTP\n200?  - yes i get 200 status code, because i insert the code and leave only getting {key} route value.\n2) - What are you using to make the request? A browser? curl? Can you show\nboth the request (URI, headers) and the response (headers, body) you get? - advanced REST client (chrome extension) request headers - http://prntscr.com/cf3cfv response headers - http://prntscr.com/cf3cl8\nresponse and request above - your example of code that you wrote\n. Have you ideas how to resolve this problem? \n. Ran this code:\n```\npackage main\nimport (\n\"fmt\"\n\"log\"\n\"net/http\"\nauth \"github.com/abbot/go-http-auth\"\n\"github.com/gorilla/mux\"\n\"github.com/technoweenie/grohl\"\n)\nfunc Secret(user, realm string) string {\nif user == \"john\" {\n// password is \"hello\"\nreturn \"$1$dlPL2MqE$oQmn16q49SqdmhenQuNgs1\"\n}\nreturn \"\"\n}\nfunc handle(w http.ResponseWriter, r *auth.AuthenticatedRequest) {\nvars := mux.Vars(&r.Request)\nfmt.Fprintf(w, \"key: %s\\n\", vars[\"key\"])\nfmt.Fprintf(w, \"Hello, %s!\", r.Username)\ngrohl.Log(grohl.Data{\"fk\": vars[\"key\"]})\n}\nfunc main() {\nr := mux.NewRouter()\nauthenticator := auth.NewBasicAuthenticator(\"example.com\", Secret)\nr.HandleFunc(\"/licenses/{key}/status\",\nauthenticator.Wrap(handle)).Methods(\"PATCH\")\nlog.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```\nthe result is:\nC:\\curl-7.50.2-win64-mingw\\bin>curl --user john:hello -XPATCH http://localhost:8080/licenses/4707f1fe-98b9-40bc-835d-4f0db678ec4c/status\nkey:\n<html><body><h1>Hello, john!</h1></body></html>\nAs you can see, the key is empty\n. This is very strange behavior, the same code and different results...\n. https://github.com/goji/httpauth - about this package - i didn't find the posibility to use .htpasswd files. So this package doesn't macth to our functionality.\nYesterday i also tried to find the answer why it works if this way and have no results.\nMaybe you find some way to solve it problem?\n. We didn't resolve the problem with wrapping of the request. We use this code befole calling function, because we found that request is created again with wrapping:\nif username = authenticator.CheckAuth(r); username == \"\" {\n            grohl.Log(grohl.Data{\"error\": \"Unauthorized\", \"method\": r.Method, \"path\": r.URL.Path})\n            w.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+authenticator.Realm+`\"`)\n            problem.Error(w, r, problem.Problem{Type: \"about:blank\", Detail: \"User or password do not match!\"}, http.StatusUnauthorized)\n            return\n        }\n. ",
    "ilius": "I have the exact same problem.\nIt works fine without authentication, but mux.Vars(&r.Request) gives map[] when I enable the authentication, while r.URL.Path and r.Request.URL.Path is showing the variable.\nHere is my code\n. ",
    "russelldc": "I'm running into a similar issue, although it's when using our own auth middleware, which alters the context like:\ngo\nctx := context.WithValue(req.Context(), UserContextKey, user)\nreq = req.WithContext(ctx)\nreturn next(res, req)\nLater on in the request, mux.Vars is empty, unless I remove the line altering the context.\nEDIT: Disregard this comment. I needed to update mux, and go get -u wasn't doing the job (complained about git status). Now all is fine.. ",
    "grkuntzmd": "I found the same problem yesterday. It appears that using the new context package interferes with using mux, because it uses the Gorilla context package. I am creating a test case now.. @elithrar: I just did. The problem is resolved. Thanks.. ",
    "squallcx": "r := mux.NewRouter().StrictSlash(true)\nr.HandleFunc(\"/{context}\", noteHandler)\nhttp://127.0.0.1:8080/title%0Asome\nnot work\n http://127.0.0.1:8080/title%0A\nis work\nr := mux.NewRouter().StrictSlash(true)\nr.HandleFunc(\"/{context}/\", noteHandler)\nhttp://127.0.0.1:8080/title%0Asome/\nnot work\n http://127.0.0.1:8080/title%0A/\nnot work\nr := mux.NewRouter().StrictSlash(true)\nr.HandleFunc(\"/{context:.+}/\", noteHandler)\nhttp://127.0.0.1:8080/title%0Asome/\nnot work\n http://127.0.0.1:8080/title%0A/\nnot work\n. http.HandleFunc(\"/\",noteHandler)\nhandler use  r.URL.Path[1:]\nis work\n. ",
    "raminfp": "Sorry for open issue, Resolved,\n. ",
    "lindaxie": "Sorry, did not mean to open this here!\n. ",
    "nvartolomei": "Or this is because I'm using old gorilla/context?\n. I just recompiled the app using 1.7.1 compiler and it caused memory leaks.\nI'm not mixing anything, gorilla/mux together with gorilla/context does.\nOn 21 Sep 2016, 15:41 +0300, Matt Silverlock notifications@github.com, wrote:\n\nThat would be because you are using the old context. You would need to\nclear it manually, but as per the context docs, I do not recommend mixing\ncontext types.\nOn Wed, Sep 21, 2016 at 12:21 AM nvartolomei notifications@github.com\nwrote:\n\nOr this is because I'm using old gorilla/context?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/198#issuecomment-248531592, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcPRmM-WWk_zOFP6SyXQZdhABFNEMks5qsNrvgaJpZM4KCehJ\n.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub (https://github.com/gorilla/mux/issues/198#issuecomment-248600085), or mute the thread (https://github.com/notifications/unsubscribe-auth/AAhJ2W6qfE57HQEw1Vnhc3y-daXRrhQDks5qsSYGgaJpZM4KCehJ).\n. > You should either use just gorilla/context, or moving forward, the new http.Request.Context().\n\nSo this actually should say: do not use gorilla/context with Go 1.7\n. ",
    "kallekrantz": "Hey\nWe're facing the same issue on our project https://github.com/thiderman/drunkenfall on master. \nOur subrouter is defined as,/tournament/{id}/{kind:(tryout|runnerup|semi|final)}/{idx:[0-9]+}\nWith the input /api/towerfall/tournament/lii/tryout/6/start/ we're getting the following output map[id:lii kind:tryout idx:tryout] from mux.Vars\nWhereas the correct one would be map[id:lii kind:tryout idx:6]\nWe managed to track down the revision where the issue was introduced to the following revision 0b13a922203ebdbfd236c818efcd5ed46097d690, where it's probably the simplification that is causing  the issue.\n. Hey, @elithrar, created #202 which adds a test for it. \nSorry if I added it to the wrong place, pretty new to Go!\n. @elithrar Sure! I'll do it during the weekend.\n. @elithrar reverted the commit, tests seem to be passing as well. Sorry for taking a bit longer than expected.\n. The test started failing if I reverted extractVars. \nI tried making the test pass by modifying the function, but the testcase itself seemed a bit strange imo.\nThe map {\"v1\": \"111\", \"v2\": \"\", \"v3\": \"222\"} being the result of the path 111/222 seemed funky to me, as there seems to be route parameters missing (shouldn't match at all)\nBut maybe I'm just missing something\n. ",
    "aeijdenberg": "We also had this problem, and after reading this bug, and the follow-up discussion in the linked PR, determined that the problem was that we were incorrectly specifying our regex and were using capturing rather than non-capturing groups.\ni.e., to fix the example in this bug, change /{type:(promo|special)}/{promoId}.json to /{type:(?:promo|special)}/{promoId}.json\nWhile it would be nicer to have seen this fail fast instead of producing erroneous results, I'm glad we can \"workaround\" by fixing our original code.. Matt, I'd be happy to volunteer to write a PR including tests to do as you suggested. Would that be helpful?. First cut of pull request added here:\nhttps://github.com/gorilla/mux/pull/218\nThe documentation change appears to have already been made last September in 14f5df0128b7c89faab437c00d0ea98fb56e03a0.\n. Simplified test as suggested, and rebased to squash commits.. You're welcome @elithrar - I think I spent most of a morning debugging an issue that ended up being due to this (after I upgraded a heap of vendored dependencies), so hopefully this saves someone else that time. :). I just added an alternative test - and I didn't see this last comment before I pushed it.\nLet me know if you're happy with the alternative which I think is probably more reusable than it previously was, or if you'd like me to just test the parsing separately and remove the additional fields.. ",
    "danhardman": "Surely you know the path to have routed the handler to it. Why don't you hardcode it in? \n. ",
    "Fruchtgummi": "`\nvar g *mux.Route\nff, _ := g.GetPathTemplate()\nlog.Println(ff)\n`\nI unterstand :/\n2016/10/13 19:12:51 http: panic serving [::1]:61148: runtime error: invalid memory address or nil pointer dereference\ngoroutine 41 [running]:\nnet/http.(*conn).serve.func1(0xc0821eb600)\n    c:/go/src/net/http/server.go:1389 +0xc8\npanic(0x8b8240, 0xc082008090)\n    c:/go/src/runtime/panic.go:443 +0x4f7\nmain.seminarortePage(0xfd9ed0, 0xc08210f040, 0xc0821ee620)\n    c:/goworkspace/src/Promillo/seminarorte.go:39 +0x95\nnet/http.HandlerFunc.ServeHTTP(0xa33f18, 0xfd9ed0, 0xc08210f040, 0xc0821ee620)\n    c:/go/src/net/http/server.go:1618 +0x41\ngithub.com/gorilla/mux.(*Router).ServeHTTP(0xc08200ab90, 0xfd9ed0, 0xc08210f040, 0xc0821ee620)\n    c:/goworkspace/src/github.com/gorilla/mux/mux.go:107 +0x28c\ngithub.com/gorilla/csrf.(*csrf).ServeHTTP(0xc08213edc0, 0xfd9ed0, 0xc08210f040, 0xc0821ee620)\n    c:/goworkspace/src/github.com/gorilla/csrf/csrf.go:264 +0x86f\nnet/http.serverHandler.ServeHTTP(0xc082174400, 0xfd9ed0, 0xc08210f040, 0xc0821ee620)\n    c:/go/src/net/http/server.go:2081 +0x1a5\nnet/http.(*conn).serve(0xc0821eb600)\n    c:/go/src/net/http/server.go:1472 +0xf35\ncreated by net/http.(*Server).Serve\n    c:/go/src/net/http/server.go:2137 +0x455\n. ",
    "anthcor": "hey @jhernandezme any specific reason(s) why this pr was closed?. ",
    "captncraig": "Tested and this does resolve #204 for me.\n. holy crap I was using an old version. nevermind me.\n. ",
    "rogerwelin": "Yes, major.minor.patch. So 1.1.0 would work fine \n. ",
    "craigsammisutherland": "Test and documentation have been added.\n. ",
    "bgaifullin": "I need this patch, but I agree with @kisielk, that it is not good to store additional information about method just for documentation.\nIMO: the methods can be extracted from route.matcher like this:\n``` golang\nfunc (r *Route) GetMethods() ([]string, error) {\n    if r.err != nil {\n        return nil, r.err\n    }\n        for _, m := range r.matchers {\n            if methods, ok := m.(methodMatcher) {\n                  return []string(methods)\n            }\n       }\n       return nil, nil\n}\n```\n. Folks, please review. . We have service, where each deamon should register its API.\nI automated this procedure by using router.Walk, but I do not have enough information about route.\ncurrently I use custom function pathTemplate2Regexp, which converts the path template back to regex, and I use fact, that my service has only \"GET\" methods. It is temporary solution and I want this PR to make normal solution.\n```go\n// getResources returns the list of resources in format {\"name\", \"action\", \"method\", \"pattern\"}\nfunc getResources(router mux.Router) func(w http.ResponseWriter, r http.Request) {\n    return func(w http.ResponseWriter, r *http.Request) {\n        resources := []map[string]string{}\n    router.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {\n        path, err := route.GetPathTemplate()\n        if err != nil {\n            return err\n        }\n        name := route.GetName()\n        // private urls starts with '_'\n        if name != \"\" && name[0] != '_' {\n            // TODO need interface to return methods from route.\n            resource := map[string]string{\n                \"resource\": name,\n                \"action\":   \"READ\",\n                \"method\":   \"GET\",\n                \"pattern\":  pathTemplate2Regexp(path),\n            }\n            resources = append(resources, resource)\n        }\n        return nil\n    })\n    formatters[\"json\"].Write(w, 200, resources, true)\n}\n\n}\n```. @elithrar Thank you for review. I have addressed your comments. Could you please re-review.. I have just updated commits by using flag 'force', to avoid extra commits in log, which is not related to main purpose of this PR.\nIs it OK, that GitHub still shows \"changes requested\" ?. @elithrar, could you please look this patch again,  I really need this PR.. ping. Is there any chance that this PR will be merged? . @elithrar thank you for review. I have addressed your comments.. @elithrar, could you please review this PR again? . Thank you.. done. done. done. done. ",
    "sharonlcorbett": "@moraes Are you able to help clarify this matter? Thanks!. We were trying to ascertain if it was a mistake or not.  If it is not, then that is fine.  We are not asking for a change to the license.. ",
    "slemeur": "Hi @kisielk any updates on this? \nWould you be able to handle that?. ",
    "wofr": "Well I found it more \"natural\" adding headers from a map (key,value) rather than from a list of strings.  In my setup I got the headers I 've to use handed-over via a map and I don't not want to convert the header-map into a header-array which is than again converteded into a map.   It just about the usability.\n. Fair enough!\nPersonally I find it handier handling my headers with a map rather than array of string.  This prevents me form accidently overriding header values, but of course implementing a converter works as well.\n. ",
    "grsmv": "@garyburd - sure, sorry for typo - I've edited initial message. In my code I have correct version and unfortunately, this isn't a working variant.. @kisielk - Moving middlewares in opposite direction fixes this problem.\nThank you!. ",
    "huytn": "I did, many thanks.. thanks you. ",
    "felipeweb": "Yes just call routes before PathPrefix().Handler. ",
    "ShaneSaww": "If it helps this is the code I used to test:\n```go\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc main() {\n    router := mux.NewRouter()\n    adminRouter := router.PathPrefix(\"/admin\").Subrouter()\n    adminRouter.HandleFunc(\"\", someHandler)\n    adminRouter.HandleFunc(\"/\", someHandler)\nlog.Print(\"Listening on :5000\")\nhttpErr := http.ListenAndServe(\":5000\", router)\nif httpErr != nil {\n    log.Fatal(\"ListenAndServe:\", httpErr)\n}\n\n}\nfunc someHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Printf(\"In the handler\\n\")\n}\n```\nRunning this with my fix should allow you to hit both \n localhost:5000/admin\n localhost:5000/admin/. @elithrar  Just added the extra test cases!\n. @scisci the reason that it makes sense (and it's kinda strange) is that if    \ntpl = \"/\" then  tpl[0] == 47\nwhich is why  if tpl == \"/\" && (len(tpl) == 0 || tpl[0] != '/') { works. \nWith all that in mind you are correct that if len(tpl) > 0 && tpl[0] != '/' { would make more sense. . After playing with it in the playground it's broken. \nhttps://play.golang.org/p/nQ3jNgUA-P\nI can push up a fix for it later. . ",
    "scisci": "The code added doesn't seem to make any sense:\nif tpl == \"/\" && (len(tpl) == 0 || tpl[0] != '/') {\nWouldn't that always evaluate to false?\nI would think you would want to say:\nif len(tpl) > 0 && tpl[0] != '/' {. OK, guess I'm missing something :) \nIt looked to me like this code would always return false, so it wouldn't catch truly bad templates that don't start with a slash like router.HandleFunc(\"someNonEmptyRouteWithNoSlash\", ...)\nBut I'm new to gorilla so maybe this is on purpose or maybe I'm wrong.. ",
    "eticzon": "@elithrar do you mind if I pick this up? I'd like to help out.. ",
    "ahmetb": "@kisielk thanks!. ",
    "yegle": "Is this an App Engine app with a custom domain and SSL? https://cloud.google.com/appengine/docs/python/console/using-custom-domains-and-ssl. ",
    "tro3": "Okay - not as simple as I thought.  The templates are created looking upward when a new Route is attached.  So if you have a Router with a bunch of Routes created before that Router is added to a parent, none of the Routes below will have the proper prefixes.  This would require a recurvise-downward prefix adder function.  I may take a look at this when time allows.\nPR closed for now, as it is broken.. Actually - hold off on this a bit.  Just saw some wierdness in my server behavior I need to track down and test against.. Okay - not as simple as I thought.  The templates are created looking upward when a new Route is attached.  So if you have a Router with a bunch of Routes created before that Router is added to a parent, none of the Routes below will have the proper prefixes.  This would require a recurvise-downward prefix adder function.  I may take a look at this when time allows.\nThis also means I misunderstood the testRoute function.  I suspect the router.Path setup was creating the path to be tested, so it masked this issue.  If I find a way to do the above, I also need to make sure the tests are nonmasking of errors.. ",
    "helmutkemper": "Sorry!\nPlease, close.. ",
    "krasi-georgiev": "thanks I will try it. it does the trick , Docker uses an older version of the gorila lib so need to check what is the procedure with the upgrades.. the PR was rejected due to some security implications.\nhttps://github.com/docker/docker/pull/30933\nI am back to the original request.\nwould it make sense to allow running some variable validation before passing the request to url cleanup and redirecting the ../ . It is marked as bug in the docker issues and I am trying to solve it.\neven if it is not ../ , if that part of the url is set to be a variable it shouldn't be considered to be part of the url right ?\n/containers/{name:.*}/checkpoints\nyou don't think that the option to validate the var before doing an url cleanup is going to be worth the effort ?\n. @elithrar I am just trying to solve a problem marked as a bug. It is not my use case.\neven if you ignore this use case , I thought that an option to validate {name:.*} would be helpful as many docker api endpoints have similar format  and maybe some other weird characters will cause other issues.\n. ",
    "matthewvalimaki": "Wanted to log this here as an solution: https://github.com/didip/tollbooth.\nYou would use tollbooth with mux somehow like this:\nr *mux.Router\nr.Handle(\"/my/route\", tollbooth.LimitHandler(\n  tollbooth.NewLimiter(1, time.Second),\n  &handler.MyHandler{},\n)).Methods(\"POST\")\n. ",
    "cseeger-epages": "Another option is to use https://github.com/throttled/throttled. This worked well for me with gorilla/mux\n```\nimport (\n  \"github.com/gorilla/mux\"\n  \"gopkg.in/throttled/throttled.v2\"\n  \"gopkg.in/throttled/throttled.v2/store/memstore\"\n  \"log\"\n  \"net/http\"\n)\n...\nr *mux.Router\n  store, err := memstore.New(65536)\n  if err != nil {\n    log.Fatal(err)\n  }\nquota := throttled.RateQuota{throttled.PerMin(20), 5}\n  rateLimiter, err := throttled.NewGCRARateLimiter(store, quota)\n  if err != nil {\n    log.Fatal(err)\n  }\nhttpRateLimiter := throttled.HTTPRateLimiter{\n    RateLimiter: rateLimiter,\n    VaryBy:      &throttled.VaryBy{Path: true},\n  }\nr.Handle(\"/my/route\", httpRateLimiter.RateLimit(handler))\n``\nthe installation is a bit messy since you need to installthrottledand for thememstoregolang-lru` package from hashicorp\ngo get gopkg.in/throttled/throttled.v2\ngo get github.com/hashicorp/golang-lru\n. ",
    "hueich": "To tell the client to delete the cookie, you should set the Expires value to sometime in the distant past, like the epoch, to get around clock skew between server and client.  Also, since cookie expiration value only has granularity in seconds, if the following http request comes within the same second, the client might still send the cookie.. ",
    "pamburus": "Your mux package has very powerful and flexible abilities of HTTP routing.\nOne of them is routing by queries with ability to specify some predefined query values or use pattern-matching exactly the same way as you can do that in path routing.\nBut when using routing by queries, it is impossible to make an URL for some resource under that route by calling route.URL() with key/value pairs for the route variables because the resulting URL does not contain query parameters and when client uses that URL it does not return back to the same route.\nIdeally, reverse routing (building URL by route) should include all parameters used from URL for routing.\nIf my explanation is still unclear, I can make an example.. I don't know how to upload go source code here, so I created an example here:\nhttps://gist.github.com/pamburus/32d120eecacc8bc73dc77ae9174f8faa\nThere are two routes registered for \"/items/{item}\" and \"/items/{item}?version={version}\"\nFirst one addresses some \"item\" resource without specifying a version for the item, just referring an item with specific ID implying default version (i.e. latest).\nSecond one addresses some \"item\" resource with specific version which is specified by query parameter.\nWhen you use first route, there are no any issues, just check:\nGET http://localhost:8080/items/1\n\nItem: \"1\"\nVersion: \"\"\nReversed URL: \"/items/1\"\n\nBut when you use second route, reversed route URL does not include version, so referring to the same item without version, which is another resource, check it:\nhttp://localhost:8080/items/1?version=20\n\nItem: \"1\"\nVersion: \"20\"\nReversed URL: \"/items/1\"\n\nWith my patch, you get the following response:\n\nItem: \"1\"\nVersion: \"20\"\nReversed URL: \"/items/1?version=20\"\n\nReally, making an URL to the same resource which is being served by the handler (like in the example above), is not very useful. I used that just for simplicity. In real project it is often needed to refer to another resource by some set of parameters identifying the resource. \nImagine that we have some other resource which may want to refer either to an item with some ID and default version (using first route), or to an item with specific version (using second route) and send a link to that resource in a response. It is very common for REST APIs.. > In short: you want this feature so that you can use call GetRoute and have it include the query string?\nYes, more precisely, GetRoute(name).URL(pairs...)\n\nIt's important to provide a summary of the PR, rather than just submitting a PR\n\nOk, do you have an example of such summary, or just tell what it should include.\n\n(this will also need tests if we agree it is useful, before merging)\n\nI tried to find out the place where tests should be added for this feature, but there are no tests for reverse routing at all, even for paths.\n. > Reverse routing is tested here, and this is applied to all tests which call testRoute:\n\nhttps://github.com/gorilla/mux/blob/master/mux_test.go#L1458\n\nThank you. I did not notice that. I've added description to the PR and implementing tests now. Soon I'll update the PR with the tests.. Tests for queries modified to test reverse routing also. Please check them.. ",
    "iamybj": "Fuck.\nYour know why we China becomes the most advanced internet/mobile country in the world ?\n We China have the most amount users of internet, so the programmers in China are all like and  write high performance codes.\nRoll out of IT industry if you cannot write hight performance code.. ",
    "achiku": "No difference in implementation, but clearly stating \"this function is for test\" by making it public test API like TestSetURLParam(r *http.Request, val map[string]string) *http.Request, the library can provide a feature making unit test finer grain without encouraging misuse of context.Context modification in production code.. ",
    "andrefsp": "Is there any development on this? IMO this is a quite important issue to be solved as it makes unittest a lot more complicated than it should. . ",
    "micahkwillard": "I don't think getting the value of an env variable has anything to do with Mux. Try these to get what you need:\nhttps://golang.org/pkg/os/#Getenv\nscriptFilename := os.Getenv(\"SCRIPT_FILENAME\")\nhttps://golang.org/pkg/os/#Open\nfile, err := os.Open(scriptFilename)\nFrom there you should be able to Google how to read the file the way you need to.\nGood luck! . I'm also now noticing a similar issue with encoded \"?\" (%3F). If I set up Query params and an encoded \"?\" is present, I'll get a 404 since mux won't match the path.. Okay, This is definitely broken. LUCKILY, there is a gorilla mux way of fixing it. You have to use the route.Queries() and give it a {name:pattern} for it to use (using {query:.+} fixes my above issue). If you give route.Queries() just {name}, it will fail with the example url I gave above. Hope this helps someone down the road.. ",
    "andyhaskell": "Here's the stack trace:\ngoogle.golang.org/appengine/panic(0xc96560, 0xc420339ee0)\n    /usr/local/go/src/runtime/panic.go:489 +0x2cf\nlog.Panic(0xc4206c9628, 0x1, 0x1)\n    /usr/local/go/src/log/log.go:322 +0xc0\ngoogle.golang.org/appengine/internal.WithContext(0x7fac6a3e3070, 0xc4200103f0, 0xc420317600, 0x0, 0x7fac6a3e3070)\n    /go/src/app/_gopath/src/google.golang.org/appengine/internal/api.go:268 +0x17f\ngoogle.golang.org/appengine.WithContext(0x7fac6a3e3070, 0xc4200103f0, 0xc420317600, 0x7fac6a3e3070, 0xc4200103f0)\n    /go/src/app/_gopath/src/google.golang.org/appengine/appengine.go:73 +0x3f\ngoogle.golang.org/appengine.NewContext(0xc420317600, 0x3, 0xc42001a050)\n.\n.\n.\ngithub.com/gorilla/mux.(*Router).ServeHTTP(0xc420294960, 0x12bc740, 0xc420b1ca80, 0xc420317600)\n    /go/src/app/_gopath/src/github.com/gorilla/mux/mux.go:114 +0x10c\nnet/http.(*ServeMux).ServeHTTP(0x12f77c0, 0x12bc740, 0xc420b1ca80, 0xc4208d7900)\n    /usr/local/go/src/net/http/server.go:2238 +0x130\ngoogle.golang.org/appengine/internal.executeRequestSafely(0xc420b1ca80, 0xc4208d7900)\n    /go/src/app/_gopath/src/google.golang.org/appengine/internal/api.go:156 +0x77\ngoogle.golang.org/appengine/internal.handleHTTP(0x12beac0, 0xc4203f81c0, 0xc4208d7900)\nI saw that Request.WithContext creates a fresh HTTP request when it's called from setVars and setCurrentRoute, so as you said, that is where we get a request with a new address. The simplest way I can think of for keeping access to the original Request would be a setOriginalRequest method storing the original request pointer in the context, but that feels kinda unidiomatic and unintuitive to me to be using different copies of the same request to use mux.Vars vs. appengine.NewContext. @cnbuff410  I use Glide so I did\nyaml\n- package: github.com/gorilla/mux\n  version: [the commit before Go 1.7 came out]. ",
    "cnbuff410": "I'm having this issue as well on appengine managed VM. Ever since the VM starts using Go 1.8, all requests going through mux break.\n@AndyHaskell , how do you pin the mux dependency? Did you manually download that specific version and overwrite the one on your disk?. For now I'm still using the commit before Go 1.7 came out and everything still works so far. Once I upgrade things will break. ",
    "deltaskelta": "Ahh I can't reproduce it and it was a while ago in my code. closing, will reopen if it happens again and I can reproduce it.. ",
    "olivoil": "@elithrar There's an issue at adams-sarah/test2doc#9 that this PR seems to solve. ",
    "kmikiy": "Without this PR I wouldn't be able to write a middleware that runs after Gorilla mux handling and also use e.g. mux.Vars(r)\n```go\nfunc Middleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n                //...\n        next.ServeHTTP(w, r)\n           vars := mux.Vars(r)\n           log.Printf(\"vars: %#+v\\n\", vars)\n           // Will always print out map[string]string{nil}\n\n           // but with the PR it will print out what I would expect. \n           // e.g map[string]string{\"user\":\"201\"}\n\n           // ...\n})\n\n}\n```\nPS, maybe my approach is wrong though.. ",
    "theobouwman": "Thanks. I have a subrouter with routes that just serves the specific files to the user, which is actually what I want.. ",
    "dnephin": "That's true, but that's also the case with NewRoute(), right?. My use case is building up routes in different components and combining them into a single router. This is common in larger applications, or in libraries where the caller could pass in routes.\nIt would be possible to create a router first, and pass it around as a dependency, but as this PR demonstrates it's a somewhat artificial dependency. There's really no need to create a route from a router when you can add routes.\n\nNewRoute() implies less concurrency\n\nI personally don't really see that implication. . Sure, here's a short example:\n```go\npackage foo\nfunc Routes() []mux.Route {\n    return []mux.Route{\n        mux.NewRoute()...,\n        mux.NewRoute()...,\n    }\n}\n```\n```go\npackage bar\nfunc Routes() []mux.Route {\n    return []mux.Route{\n        mux.NewRoute()...,\n        mux.NewRoute()...,\n    }\n}\n```\n```go\npackage main\nrouter := mux.NewRouter()\nfor _, route := range append(foo.Routes(), bar.Routes()...) {\n    router.AddRoute(route)\n}\n```\nThe Routes() functions could accept a mux.Router, but why? It doesn't actually depend on the router to do any work. \nThis is a simple case, I'm waiting for a repo to be make public and I can show something more involved.. ",
    "zoltan123": "@elithrar I have checked the stacktrace after panic, and only this goroutine mentioned corresponding functions.\nYour question implies that the gorilla mux does NOT support concurrent access to the router object. Is that right? So the intended usage is that any access to the router object must be synchronized by the user? I was not aware of that.\nUnfortunately, I could not reproduce the error by running restarting the program/running it for a long time, it is probably a rare race condition. Probably heavy load on the machine is also a factor (2 chromium browsers were started right after this program when the problem manifested, but at later attempts even this was not enough to trigger the error).\nI thought, it is overkill, but here is the full stack trace:\nfatal error: concurrent map writes\ngoroutine 26 [running]:\nruntime.throw(0x6df090, 0x15)\n    /usr/lib/go-1.7/src/runtime/panic.go:566 +0x95 fp=0xc420161628 sp=0xc420161608\nruntime.mapassign1(0x68aee0, 0xc42000c7b0, 0xc420161750, 0xc420161748)\n    /usr/lib/go-1.7/src/runtime/hashmap.go:458 +0x8ef fp=0xc420161710 sp=0xc420161628\ngithub.com/gorilla/mux.(Route).Name(0xc4201269a0, 0xc420063ae6, 0x9, 0xc4201269a0)\n    /home/user/prg/go/src/github.com/gorilla/mux/route.go:122 +0xf6 fp=0xc4201617a0 sp=0xc420161710\nmain.AddRoute(0xc420054320, 0xc420063ae0, 0x6, 0xc420061680, 0x6b1140, 0xc42005eba0)\n    /home/user/prg/go/src/serverproject/router.go:39 +0x169 fp=0xc4201617f8 sp=0xc4201617a0\nmain.newDataSeriesGen.func1(0x803e60, 0xc4200ed520, 0xc4200d7e00)\n    /home/user/prg/go/src/serverproject/handlers_generic.go:210 +0x95b fp=0xc420161978 sp=0xc4201617f8\nnet/http.HandlerFunc.ServeHTTP(0xc420010990, 0x803e60, 0xc4200ed520, 0xc4200d7e00)\n    /usr/lib/go-1.7/src/net/http/server.go:1726 +0x44 fp=0xc4201619a0 sp=0xc420161978\nmain.CORS.func1(0x803e60, 0xc4200ed520, 0xc4200d7e00)\n    /home/user/prg/go/src/serverproject/cors.go:134 +0x1f8 fp=0xc420161a88 sp=0xc4201619a0\nnet/http.HandlerFunc.ServeHTTP(0xc420012d80, 0x803e60, 0xc4200ed520, 0xc4200d7e00)\n    /usr/lib/go-1.7/src/net/http/server.go:1726 +0x44 fp=0xc420161ab0 sp=0xc420161a88\nmain.Logger.func1(0x803e60, 0xc4200ed520, 0xc4200d7e00)\n    /home/user/prg/go/src/serverproject/logger.go:30 +0xae fp=0xc420161b88 sp=0xc420161ab0\nnet/http.HandlerFunc.ServeHTTP(0xc42000cc60, 0x803e60, 0xc4200ed520, 0xc4200d7e00)\n    /usr/lib/go-1.7/src/net/http/server.go:1726 +0x44 fp=0xc420161bb0 sp=0xc420161b88\ngithub.com/gorilla/mux.(Router).ServeHTTP(0xc420054320, 0x803e60, 0xc4200ed520, 0xc4200d7e00)\n    /home/user/prg/go/src/github.com/gorilla/mux/mux.go:114 +0x10d fp=0xc420161cb0 sp=0xc420161bb0\ngithub.com/braintree/manners.(gracefulHandler).ServeHTTP(0xc4200132e0, 0x803e60, 0xc4200ed520, 0xc4200d70e0)\n    /home/user/prg/go/src/github.com/braintree/manners/server.go:277 +0x8f fp=0xc420161ce0 sp=0xc420161cb0\nnet/http.serverHandler.ServeHTTP(0xc4200f6780, 0x803e60, 0xc4200ed520, 0xc4200d70e0)\n    /usr/lib/go-1.7/src/net/http/server.go:2202 +0x7d fp=0xc420161d28 sp=0xc420161ce0\nnet/http.(conn).serve(0xc420076580, 0x804460, 0xc4200155c0)\n    /usr/lib/go-1.7/src/net/http/server.go:1579 +0x4b7 fp=0xc420161f88 sp=0xc420161d28\nruntime.goexit()\n    /usr/lib/go-1.7/src/runtime/asm_amd64.s:2086 +0x1 fp=0xc420161f90 sp=0xc420161f88\ncreated by net/http.(*Server).Serve\n    /usr/lib/go-1.7/src/net/http/server.go:2293 +0x44d\ngoroutine 1 [IO wait]:\nnet.runtime_pollWait(0x7eff5d117fb0, 0x72, 0x0)\n    /usr/lib/go-1.7/src/runtime/netpoll.go:160 +0x59\nnet.(pollDesc).wait(0xc420110990, 0x72, 0xc420049c58, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:73 +0x38\nnet.(pollDesc).waitRead(0xc420110990, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:78 +0x34\nnet.(netFD).accept(0xc420110930, 0x0, 0x800720, 0xc420013980)\n    /usr/lib/go-1.7/src/net/fd_unix.go:419 +0x238\nnet.(TCPListener).accept(0xc4200280f8, 0x4438ee, 0xc420049d08, 0x4c446d)\n    /usr/lib/go-1.7/src/net/tcpsock_posix.go:132 +0x2e\nnet.(TCPListener).Accept(0xc4200280f8, 0x701c40, 0xc4200f6e00, 0x804520, 0xc42000d920)\n    /usr/lib/go-1.7/src/net/tcpsock.go:222 +0x49\nnet/http.(Server).Serve(0xc4200f6780, 0x803c60, 0xc4200280f8, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/http/server.go:2273 +0x1ce\ngithub.com/braintree/manners.(GracefulServer).Serve(0xc4200e6ae0, 0x803c60, 0xc4200280f8, 0x5, 0x803c60)\n    /home/user/prg/go/src/github.com/braintree/manners/server.go:224 +0x1d3\ngithub.com/braintree/manners.(GracefulServer).ListenAndServe(0xc4200e6ae0, 0x3, 0x1d)\n    /home/user/prg/go/src/github.com/braintree/manners/server.go:117 +0x9b\nmain.main()\n    /home/user/prg/go/src/serverproject/main.go:131 +0x287\ngoroutine 17 [syscall, locked to thread]:\nruntime.goexit()\n    /usr/lib/go-1.7/src/runtime/asm_amd64.s:2086 +0x1\ngoroutine 19 [syscall]:\nos/signal.signal_recv(0x0)\n    /usr/lib/go-1.7/src/runtime/sigqueue.go:116 +0x157\nos/signal.loop()\n    /usr/lib/go-1.7/src/os/signal/signal_unix.go:22 +0x22\ncreated by os/signal.init.1\n    /usr/lib/go-1.7/src/os/signal/signal_unix.go:28 +0x41\ngoroutine 4 [select, locked to thread]:\nruntime.gopark(0x702200, 0x0, 0x6da7a9, 0x6, 0x18, 0x2)\n    /usr/lib/go-1.7/src/runtime/proc.go:259 +0x13a\nruntime.selectgoImpl(0xc420025730, 0x0, 0x18)\n    /usr/lib/go-1.7/src/runtime/select.go:423 +0x11d9\nruntime.selectgo(0xc420025730)\n    /usr/lib/go-1.7/src/runtime/select.go:238 +0x1c\nruntime.ensureSigM.func1()\n    /usr/lib/go-1.7/src/runtime/signal1_unix.go:304 +0x2f3\nruntime.goexit()\n    /usr/lib/go-1.7/src/runtime/asm_amd64.s:2086 +0x1\ngoroutine 5 [chan receive]:\nmain.InitGracefulServer.func1(0xc4200e6b40, 0xc4200e6ae0)\n    /home/user/prg/go/src/serverproject/gracefuller.go:98 +0x44\ncreated by main.InitGracefulServer\n    /home/user/prg/go/src/serverproject/gracefuller.go:106 +0x2d0\ngoroutine 6 [chan send]:\ngithub.com/braintree/manners.(GracefulServer).Serve.func1(0xc4200e6ae0, 0xc4200132e0, 0x803c60, 0xc4200280f8)\n    /home/user/prg/go/src/github.com/braintree/manners/server.go:161 +0x4e\ncreated by github.com/braintree/manners.(GracefulServer).Serve\n    /home/user/prg/go/src/github.com/braintree/manners/server.go:166 +0xf8\ngoroutine 16 [select]:\nmain.(localWriter).writerNormalMode(0xc4200e7740)\n    /home/user/prg/go/src/serverproject/localwriter.go:303 +0x4a9\nmain.(localWriter).writer(0xc4200e7740)\n    /home/user/prg/go/src/serverproject/localwriter.go:291 +0x2b\ncreated by main.(*localWriter).Start\n    /home/user/prg/go/src/serverproject/localwriter.go:264 +0x122\ngoroutine 14 [runnable]:\nsyscall.Syscall(0x0, 0xc, 0xc42013e000, 0x1000, 0x1ce, 0x1000, 0x0)\n    /usr/lib/go-1.7/src/syscall/asm_linux_amd64.s:18 +0x5\nsyscall.read(0xc, 0xc42013e000, 0x1000, 0x1000, 0x72, 0x0, 0x0)\n    /usr/lib/go-1.7/src/syscall/zsyscall_linux_amd64.go:783 +0x55\nsyscall.Read(0xc, 0xc42013e000, 0x1000, 0x1000, 0xffffffffffffff01, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/syscall/syscall_unix.go:161 +0x49\nnet.(netFD).Read(0xc420110d20, 0xc42013e000, 0x1000, 0x1000, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/fd_unix.go:239 +0x10f\nnet.(conn).Read(0xc420028138, 0xc42013e000, 0x1000, 0x1000, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/net.go:173 +0x70\nnet/http.(connReader).Read(0xc4200136a0, 0xc42013e000, 0x1000, 0x1000, 0xc4200f6e68, 0x100000000, 0xc420015201)\n    /usr/lib/go-1.7/src/net/http/server.go:586 +0x144\nbufio.(Reader).fill(0xc4200e7080)\n    /usr/lib/go-1.7/src/bufio/bufio.go:97 +0x10c\nbufio.(Reader).Peek(0xc4200e7080, 0x4, 0x6da05b, 0x4, 0xc4200e6b01, 0x522ec9, 0xc4200e6b10)\n    /usr/lib/go-1.7/src/bufio/bufio.go:129 +0x62\nnet/http.(conn).readRequest(0xc4200f6e00, 0x804460, 0xc420015700, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/http/server.go:762 +0xdff\nnet/http.(conn).serve(0xc4200f6e00, 0x804460, 0xc420015700)\n    /usr/lib/go-1.7/src/net/http/server.go:1532 +0x3d3\ncreated by net/http.(Server).Serve\n    /usr/lib/go-1.7/src/net/http/server.go:2293 +0x44d\ngoroutine 15 [select]:\nmain.(localWriter).writerNormalMode(0xc4200e75c0)\n    /home/user/prg/go/src/serverproject/localwriter.go:303 +0x4a9\nmain.(localWriter).writer(0xc4200e75c0)\n    /home/user/prg/go/src/serverproject/localwriter.go:291 +0x2b\ncreated by main.(*localWriter).Start\n    /home/user/prg/go/src/serverproject/localwriter.go:264 +0x122\ngoroutine 25 [IO wait]:\nnet.runtime_pollWait(0x7eff5d117770, 0x72, 0x7)\n    /usr/lib/go-1.7/src/runtime/netpoll.go:160 +0x59\nnet.(pollDesc).wait(0xc420126290, 0x72, 0xc42015da20, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:73 +0x38\nnet.(pollDesc).waitRead(0xc420126290, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:78 +0x34\nnet.(netFD).Read(0xc420126230, 0xc420142000, 0x1000, 0x1000, 0x0, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_unix.go:243 +0x1a1\nnet.(conn).Read(0xc420072048, 0xc420142000, 0x1000, 0x1000, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/net.go:173 +0x70\nnet/http.(connReader).Read(0xc4200135c0, 0xc420142000, 0x1000, 0x1000, 0xc420076568, 0x100000000, 0xc420015201)\n    /usr/lib/go-1.7/src/net/http/server.go:586 +0x144\nbufio.(Reader).fill(0xc4200e7140)\n    /usr/lib/go-1.7/src/bufio/bufio.go:97 +0x10c\nbufio.(Reader).Peek(0xc4200e7140, 0x4, 0x6da05b, 0x4, 0xc4200e6b01, 0x522ec9, 0xc4200e6b10)\n    /usr/lib/go-1.7/src/bufio/bufio.go:129 +0x62\nnet/http.(conn).readRequest(0xc420076500, 0x804460, 0xc420015600, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/http/server.go:762 +0xdff\nnet/http.(conn).serve(0xc420076500, 0x804460, 0xc420015600)\n    /usr/lib/go-1.7/src/net/http/server.go:1532 +0x3d3\ncreated by net/http.(Server).Serve\n    /usr/lib/go-1.7/src/net/http/server.go:2293 +0x44d\ngoroutine 27 [IO wait]:\nnet.runtime_pollWait(0x7eff5d1179b0, 0x72, 0x9)\n    /usr/lib/go-1.7/src/runtime/netpoll.go:160 +0x59\nnet.(pollDesc).wait(0xc420126370, 0x72, 0xc420047a20, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:73 +0x38\nnet.(pollDesc).waitRead(0xc420126370, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:78 +0x34\nnet.(netFD).Read(0xc420126310, 0xc42013c000, 0x1000, 0x1000, 0x0, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_unix.go:243 +0x1a1\nnet.(conn).Read(0xc420072058, 0xc42013c000, 0x1000, 0x1000, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/net.go:173 +0x70\nnet/http.(connReader).Read(0xc4200d0980, 0xc42013c000, 0x1000, 0x1000, 0xc420076668, 0x100000000, 0xc420060c01)\n    /usr/lib/go-1.7/src/net/http/server.go:586 +0x144\nbufio.(Reader).fill(0xc4200e6fc0)\n    /usr/lib/go-1.7/src/bufio/bufio.go:97 +0x10c\nbufio.(Reader).Peek(0xc4200e6fc0, 0x4, 0x6da05b, 0x4, 0xc4200e6b01, 0x522ec9, 0xc4200e6b10)\n    /usr/lib/go-1.7/src/bufio/bufio.go:129 +0x62\nnet/http.(conn).readRequest(0xc420076600, 0x804460, 0xc420060cc0, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/http/server.go:762 +0xdff\nnet/http.(conn).serve(0xc420076600, 0x804460, 0xc420060cc0)\n    /usr/lib/go-1.7/src/net/http/server.go:1532 +0x3d3\ncreated by net/http.(Server).Serve\n    /usr/lib/go-1.7/src/net/http/server.go:2293 +0x44d\ngoroutine 28 [IO wait]:\nnet.runtime_pollWait(0x7eff5d1178f0, 0x72, 0xa)\n    /usr/lib/go-1.7/src/runtime/netpoll.go:160 +0x59\nnet.(pollDesc).wait(0xc4201263e0, 0x72, 0xc42004ba20, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:73 +0x38\nnet.(pollDesc).waitRead(0xc4201263e0, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:78 +0x34\nnet.(netFD).Read(0xc420126380, 0xc420131000, 0x1000, 0x1000, 0x0, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_unix.go:243 +0x1a1\nnet.(conn).Read(0xc420072060, 0xc420131000, 0x1000, 0x1000, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/net.go:173 +0x70\nnet/http.(connReader).Read(0xc4200d0a60, 0xc420131000, 0x1000, 0x1000, 0xc4200766e8, 0x100000000, 0xc420060e01)\n    /usr/lib/go-1.7/src/net/http/server.go:586 +0x144\nbufio.(Reader).fill(0xc42005e3c0)\n    /usr/lib/go-1.7/src/bufio/bufio.go:97 +0x10c\nbufio.(Reader).Peek(0xc42005e3c0, 0x4, 0x6da05b, 0x4, 0xc4200e6b01, 0x522ec9, 0xc4200e6b10)\n    /usr/lib/go-1.7/src/bufio/bufio.go:129 +0x62\nnet/http.(conn).readRequest(0xc420076680, 0x804460, 0xc420060e80, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/http/server.go:762 +0xdff\nnet/http.(conn).serve(0xc420076680, 0x804460, 0xc420060e80)\n    /usr/lib/go-1.7/src/net/http/server.go:1532 +0x3d3\ncreated by net/http.(Server).Serve\n    /usr/lib/go-1.7/src/net/http/server.go:2293 +0x44d\ngoroutine 29 [IO wait]:\nnet.runtime_pollWait(0x7eff5d117830, 0x72, 0xb)\n    /usr/lib/go-1.7/src/runtime/netpoll.go:160 +0x59\nnet.(pollDesc).wait(0xc420126450, 0x72, 0xc420163a20, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:73 +0x38\nnet.(pollDesc).waitRead(0xc420126450, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_poll_runtime.go:78 +0x34\nnet.(netFD).Read(0xc4201263f0, 0xc420141000, 0x1000, 0x1000, 0x0, 0x801ae0, 0xc4200620a0)\n    /usr/lib/go-1.7/src/net/fd_unix.go:243 +0x1a1\nnet.(conn).Read(0xc420072068, 0xc420141000, 0x1000, 0x1000, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/net.go:173 +0x70\nnet/http.(connReader).Read(0xc4200d0940, 0xc420141000, 0x1000, 0x1000, 0xc420076768, 0x100000000, 0xc420061001)\n    /usr/lib/go-1.7/src/net/http/server.go:586 +0x144\nbufio.(Reader).fill(0xc42005e480)\n    /usr/lib/go-1.7/src/bufio/bufio.go:97 +0x10c\nbufio.(Reader).Peek(0xc42005e480, 0x4, 0x6da05b, 0x4, 0xc4200e6b01, 0x522ec9, 0xc4200e6b10)\n    /usr/lib/go-1.7/src/bufio/bufio.go:129 +0x62\nnet/http.(conn).readRequest(0xc420076700, 0x804460, 0xc420060c00, 0x0, 0x0, 0x0)\n    /usr/lib/go-1.7/src/net/http/server.go:762 +0xdff\nnet/http.(conn).serve(0xc420076700, 0x804460, 0xc420060c00)\n    /usr/lib/go-1.7/src/net/http/server.go:1532 +0x3d3\ncreated by net/http.(Server).Serve\n    /usr/lib/go-1.7/src/net/http/server.go:2293 +0x44d\ngoroutine 30 [select]:\nmain.(localWriter).writerNormalMode(0xc42005ea20)\n    /home/user/prg/go/src/serverproject/localwriter.go:303 +0x4a9\nmain.(localWriter).writer(0xc42005ea20)\n    /home/user/prg/go/src/serverproject/localwriter.go:291 +0x2b\ncreated by main.(*localWriter).Start\n    /home/user/prg/go/src/serverproject/localwriter.go:264 +0x122\ngoroutine 32 [select]:\nmain.(localWriter).writerNormalMode(0xc42005eba0)\n    /home/user/prg/go/src/serverproject/localwriter.go:303 +0x4a9\nmain.(localWriter).writer(0xc42005eba0)\n    /home/user/prg/go/src/serverproject/localwriter.go:291 +0x2b\ncreated by main.(*localWriter).Start\n    /home/user/prg/go/src/serverproject/localwriter.go:264 +0x122\ngoroutine 33 [select]:\nmain.(localWriter).writerNormalMode(0xc42005ed20)\n    /home/user/prg/go/src/serverproject/localwriter.go:303 +0x4a9\nmain.(localWriter).writer(0xc42005ed20)\n    /home/user/prg/go/src/serverproject/localwriter.go:291 +0x2b\ncreated by main.(*localWriter).Start\n    /home/user/prg/go/src/serverproject/localwriter.go:264 +0x122\ngoroutine 34 [select]:\nmain.(localWriter).writerNormalMode(0xc42005ef60)\n    /home/user/prg/go/src/serverproject/localwriter.go:303 +0x4a9\nmain.(localWriter).writer(0xc42005ef60)\n    /home/user/prg/go/src/serverproject/localwriter.go:291 +0x2b\ncreated by main.(*localWriter).Start\n    /home/user/prg/go/src/serverproject/localwriter.go:264 +0x122. @kisielk Sorry for reopening the thread. Just to clarify for anyone with the same problem.\n(I have missed the notifications of this thread)\nYes, I am doing exactly what You suspect, I am adding new routes after starting the server:\nfunc YourHandler(w http.ResponseWriter, r *http.Request) {\n    // modifying the router\n    r.HandleFunc(\"/bla\", YourHandler)\n}\n\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/\", YourHandler)\n\n    http.ListenAndServe(\":8000\", r)\n}\n\nI have just re-read the README.md, but I did not find anything about this limitation. I think it would worth mentioning, since it seems to be a very rarely surfacing race condition, so users may assume no such limitation exists, but their code will fail mysteriously from time to time:\n\"After the server is started (e.g. through http.ListenAndServe()), the router must not be modified - i.e. HandleFunc() most not be called.\". ",
    "renannprado": "where did this variable router come from?. ",
    "facundomedica": "http://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491849169864000000\nI've realized that with some values it works and with some it doesn't. I made a small test app but I can't recreate the problem.\nedit:\nI made some tests by adding a fmt.Println() printing the name of the function. I've seen that the first time I access it, it works as expected, but the second time it does not.\nMaybe something to do with my browser cache? I'll keep testing from a json rest client or something like that. (But I'm using it for web)\nedit 2:\nIt's quite random, in some cases it cuts off the /delete/123123213123213123123 part.\nWorking (prints \"DELETE\", meaning that it's working as expected):\n\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491922215895000000\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491922218252000000\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491925240638000000\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491925242290000000\n\nNot working (prints \"GET\", meaning that is not working as expected, and it cuts off the last part):\n\n\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491849169864000000\n\n\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491922212261000000\n\nhttp://localhost:5001/locations/58ebc870242ac9d73eb6a23c/devices/delete/1491922220620000000\n\nNote: when I say GET and DELETE I'm not talking about HTTP Methods, I'm just using this words as reference to my functions. \nMy functions:\n```go\nfunc GetLocationDevices(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"GetLocationDevices\")\n    w.Write([]byte(\"GET!\"))\n}\nfunc GetLocationDeleteDevice(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"GetLocationDeleteDevice\")\n    w.Write([]byte(\"DELETE!\"))\n}\n```\nNow I'm going to test it in a fresh project.. Okay I recreated the issue in a new project, and it works exactly like the one I showed before.\nI tested it by clicking the links in the above comment.\n``` go\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc main() {\n    router := mux.NewRouter()\n    router.HandleFunc(\"/locations/{location}/devices/delete/{device}\", GetLocationDeleteDevice).Methods(\"GET\")\n    router.HandleFunc(\"/locations/{location}/devices\", GetLocationDevices).Methods(\"GET\")\n    if err := http.ListenAndServe(\"localhost:5001\", router); err != nil {\n        log.Fatal(err)\n    }\n}\nfunc GetLocationDevices(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"GetLocationDevices\")\n    w.Write([]byte(\"GET!\"))\n}\nfunc GetLocationDeleteDevice(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"GetLocationDeleteDevice\")\n    w.Write([]byte(\"DELETE!\"))\n}\n```\n@elithrar am I using mux right?. @elithrar I couldn't keep testing this issue and it seems that it is not related with mux but with the browser, so I'm closing it. If I encounter this problem in the future, I'll let you know. Thanks!. ",
    "connelevalsam": "shows nothing\n\n. Downloaded go1.6.linux-amd64.tar.gz then extracted it tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz for the go tree. I then tested it by running normal GoLang programs, it worked well. Decided to do web, worked well not until i decided to use github.com/gorilla/mux package for routing.\n-\nHow do i update it now? can that fix this issue for me cos i'm getting tired.. Thanks. I removed the former and extracted the new into usr/local/go. Now it's working. Using sublime. IDEA still can't figure out. echo $GOPATH doesn't still show anything. ",
    "dlsniper": "Not sure which editor / plugin you are using, but this is definitely not a mux issue, ping me on Slack if you need further help on this or please open an issue on: https://youtrack.jetbrains.com/issues/Go and I'll be happy to help you out.. ",
    "thalesfsp": "Thank you @elithrar! My idea is to, when someone hit /, it returns a JSON with the available resources/endpoints. Is there a plugin for it?. @elithrar is there some way to not only get the routes but also the registered verbs? Example:\nGET /product/{id:[0-9]+}. ",
    "hodgesds": "Yeah, I guess doing the extra match of the Accept header might be a little heavy and middleware seems like a decent option. Closing.. ",
    "kamal-github": "I am using go-kit for our micro services, so in my transport.go it is returning http.Handler,  but     nrgorilla's func InstrumentRoutes(r *mux.Router, app newrelic.Application) *mux.Router{...} function accepts one *mux.Router, but I  am getting below error.\ncan not convert http.HandlerFunc to *mux.Router. Thanks for fast response.. ",
    "macnibblet": "@elithrar mux.CurrentRoute(r) always returns nil\nThis is the updated code\n```go\npackage middleware\nimport (\n    \"context\"\n    \"net/http\"\n    \"time\"\n\"github.com/gorilla/mux\"\n\"github.com/prometheus/client_golang/prometheus\"\n\"github.com/prometheus/common/log\"\n\"github.com/satori/go.uuid\"\n\n)\nconst RequestCtxRequestId = \"requestId\"\nvar endpointDurations = prometheus.NewSummaryVec(\n    prometheus.SummaryOpts{\n        Namespace:  \"infinity\",\n        Name:       \"http_endpoint_duration_seconds\",\n        Help:       \"Duration spent on each endpoint\",\n        Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n    },\n    []string{\"endpoint\", \"method\"},\n)\ntype requestTracker struct {\n    nextHandler http.Handler\n}\nfunc init() {\n    prometheus.MustRegister(endpointDurations)\n}\nfunc RequestTracker(handler http.Handler) http.Handler {\n    return &requestTracker{nextHandler: handler}\n}\nfunc (middleware requestTracker) ServeHTTP(rw http.ResponseWriter, r http.Request) {\n    requestId := r.Header.Get(\"X-Request-Id\")\n    if requestId == \"\" {\n        requestId = uuid.NewV4().String()\n    }\nctx := r.Context()\nctx = context.WithValue(ctx, RequestCtxRequestId, requestId)\n\nstartedAt := time.Now()\n\n// return the request id for future tracking\nrw.Header().Set(\"X-Request-Id\", requestId)\n\nmiddleware.nextHandler.ServeHTTP(rw, r.WithContext(ctx))\n\n// This will never have any long time duration\nif r.Method == http.MethodOptions {\n    return\n}\n\nroute := mux.CurrentRoute(r)\nif route == nil {\n    log.Warnf(\"No route matched '%s' for request tracking\", r.RequestURI)\n    return\n}\n\nif template, err := route.GetPathTemplate(); err == nil {\n    endpointDurations.\n        WithLabelValues(template, r.Method).\n        Observe(time.Since(startedAt).Seconds())\n} else {\n    log.Error(err)\n}\n\n}\n`` . @elithrar Same, I also removed all other middleware and called it before the next handler . From what I can see therouteis never stored in the context after usingspew.Dump` on it. Regardless of where I put the dump. If I find some time later, I will try and write a breaking test or at least reproducible example. . @elithrar Hmm that works, which made me think i'm doing something wrong when i register the middleware.\nThis worked\ngo\n    router := mux.NewRouter()\n    router.Handle(\"/metrics\", middleware.RequestTracker(promhttp.Handler())).Name(\"metrics\")\nThis did not work, i'm not sure why the route is not available when you register the middleware this way, since I want this to apply to all routes without having to register it on every route.\n```go\nrouter := mux.NewRouter()\nrouter.Handle(\"/metrics\", promhttp.Handler()).Name(\"metrics\")\n\nhandler := handlers.RecoveryHandler(\n    handlers.PrintRecoveryStack(true),\n)(router)\n\nhandler = middleware.RequestTracker(handler)\n\nhandler = handlers.CORS(\n    handlers.AllowedOrigins([]string{\"*\"}),\n    handlers.AllowedHeaders([]string{\"Authorization\", \"Content-Type\"}),\n)(handler)\n\nhandler = handlers.ProxyHeaders(handler)\nhandler = middleware.Jwt(app, handler)\n\nsrv := http.Server{\n    Addr:    app.HttpBindAddr,\n    Handler: handler,\n}\n\n```. I think the problem is that the middleware is executed before the router? But I'm not sure that this can be resolved?. That is the problem, so I ended up looping over all my endpoints and wrapping with the request tracker but a cleaner solution to this problem would be much appreciated. . ",
    "nickhudkins": "@bilc please see #269 which I suspect may be the reason you were asking. This question appears in a few issues, so hopefully this will clarify.. ",
    "bilc": "@nickhudkins OK. I think readme should be updated.. ",
    "gotoxu": "+1\nThis should return 405 instead of 404. ",
    "maknahar": "Is anybody working on this? If not I would like to give it a shot.. All changes suggested by you make perfect sense @kisielk . I will make the change ASAP.. @kisielk I have made the changes. Please let me know if anymore improvement is required.. @elithrar I have added custom MethodNotAllowedHandler in Router. Please have a look.. @kisielk I have done the requested change.. Will Change it to lower case.. I agree that router should have MethodNotAllowedHandler. We can default to local methodNotAllowedHandler if it is not set, same as we do with http.NotFoundHandler. Should we make those change in a current fix #271 is the question.. @elithrar @kisielk Can we look into merging this PR if no other change is required? Or do you guys want to add methodNotAllowedHandler in this as well?. Sure.. ",
    "jimmyislive": "+1. ",
    "RobGraham": "Aha! While your answer was sort of helpful, I started digging back in the source code and realized you have mux.go which is your *Router and route.go (*Route) which shares some method names that caused my confusion. Thank you. ",
    "iron-s": "This behavior is described here: https://golang.org/doc/faq#closures_and_goroutines\nRelevant excerpt is \n\neach iteration of the loop uses the same instance of the variable v, so each closure shares that single variable\n\nSo both paths will return the same value - either \"AA\" or \"BB\" (depending on the order in which config was iterated).\nIt can be fixed this way:\ngo\nfor routPath, value := range config {\n    value := value // we create new variable here\n    r.PathPrefix(routPath).HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        fmt.Println(value)\n    })\n}. ",
    "farnasirim": "The + to [space] transformation happens (as it should) here in /net/url/url.go.\nSince the following piece of code is working as you would like\nGo\nu, _ := url.Parse(\"/check?mime=image/svg%2Bxml\")\nprintln(u.Query().Get(\"mime\")) // prints image/svg+xml\nI guess you should also be getting the correct result  if you do something similar to a query which correctly escapes the plus character.\nBut if you're getting a query and you're sure about the parameters being escaped correctly, and you're still getting the incorrectly decoded string image/svg xml, I would blame any sort of  middleware which would intercept and somehow modify the request object (assuming you're using this in the context of an http server) for routing or logging purposes.\nCould you peek at r.URL.String() right before you try to .Get(\"mime\")?\nCould you provide a full example which recreates this issue?. ",
    "emilevauge": "@elithrar I didn't say this PR was simplifying anything.\nIt adds the possibility to control the priority using something else than inserted order.\nI did this on a fork for Traefik because we had a use case for this.\nIf you think it worth it, I'll write some tests, other than that, I'll just close this PR :). Closing this one then.. ",
    "Pobepto": "\nWhat does\n$ go get -u github.com/gorilla/mux\n... show?\n\nNothing\n\nDoes it appear in $GOPATH/src after that?\n\nYes. I found where there was a problem. I had another name for the package, not \"main\". When I change package to \"main\" this solved problem.\nThanks!\n. ",
    "paulbes": "We are also interested in this type of functionality, is it best to open a PR for this?. @elithrar, as a side-note, is there any intention for adding optional query parameters, e.g., a more concise way of achieving this: https://stackoverflow.com/questions/45378566/gorilla-mux-optional-query-values. I can't speak for all use-cases, but we will end up using GetQueriesTemplates primarily, I added the GetQueriesRegexp for completeness primarily; there being an equivalent one for Path. I am not sure when it would be used, perhaps in use-cases where a developer wants to examine the final regexp that is being matched with by mux.\nAre you considering merging them into one or dropping either? If merging, what would this look like?. Do we need to make any changes to this PR or should it be merged?. ",
    "silverweed": "This commit breaks the possibility to have a \"catch-all\" route, as it will always be called instead of any specific route with a different method.\nConsider the following code:\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc main() {\n    router := mux.NewRouter()\n    get := router.Methods(\"GET\").Subrouter()\n    post := router.Methods(\"POST\").Subrouter()\n    // Specific POST route without parameters\npost.HandleFunc(\"/something\", func(rw http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(rw, \"post\")\n})\n    // Catch-all route that should match any GET request, and only GET requests \nget.HandleFunc(\"/{anything}\", func(rw http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(rw, \"get\")\n})\n\nhttp.Handle(\"/\", router)\nhttp.ListenAndServe(\":8888\", nil)\n\n}\n```\nThe expected behaviour (and the actual behaviour before this commit) is:\nsh\ncurl localhost:8888/something -X POST  # -> post\ncurl localhost:8888/foobar # -> get\nThe actual behaviour as of this commit is that both requests are answered with GET. \nIt appears to only happen for routes without parameters.\nThis is especially problematic with routes that have the same path but different methods, as they'll all be answered with the method of the catch-all route. \nThe problem disappears when lines 61-64 are commented out or removed from route.go.. Even worse:\ngo\npost.HandleFunc(\"/some/{thing}\", func(rw http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(rw, \"post\")\n})\n // Same route but different method\nget.HandleFunc(\"/some/{thing}\", func(rw http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(rw, \"get\")\n})\nsh\ncurl localhost:8888/some/thing -X POST # -> get. I opened an issue for this.. @kisielk Looks like it's working well :)\nThank you!. ",
    "adamo57": "I could take a look at this. @lekoder I think the problem here is that you used an already urlencoded string as input to the router. One solution that I was thinking of was to add a check to see if the input url was already encoded, only to find that determining that would be near to impossible. Any thoughts, @kisielk ?. ",
    "abdullah2993": "I second this proposal. it will actually be very useful...I'm currently working on an authentication middleware so I wanted to add the ability to allow certain routes without authentication but can't because mux.CurrentRoute returns nil if not called from the the handler it self\n@roobre IMO you are making it more complex then it has to be. something like this is fine IMO. Can I send a pull request with something like this\nDiff: https://github.com/gorilla/mux/compare/master...Abdullah2993:master\ncommit: https://github.com/Abdullah2993/mux/commit/5297e1495880923aed73b18911ad4ce6f4e27472. > Basically your middleware might want to create a new Request or ResponseWriter, and pass them down to the rest of the chain. Think about returning Request.WithContext(), for example. Or maybe creating a custom ResponseWriter implementation.\n@roobre this can be done with the classical func(http.Handler)http.Handler\n. @elithrar thats the whole point, the ability to get current route on the Request object is what is desired in the middleware especially with middlewares that deals with auth. With conventional middlewares a call to mux.CurrentRoute returns nil because the context is set after matching and the middlewares are executed before matching the route.\nBut IMO its much better to use the classic func(http.Handler) http.Handler for this as demonstrated in https://github.com/gorilla/mux/compare/master...Abdullah2993:master . @roobre it is actually much simpler then you think...take a look at this all the middlewares use this pattern and it is actually quite simple and elegant  \nhere is a sample of it working\n```\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\"github.com/abdullah2993/mux\"\n\n)\ntype routeLogger struct {\n    logger *log.Logger\n    next   http.Handler\n}\nfunc (rl routeLogger) ServeHTTP(w http.ResponseWriter, r http.Request) {\n    mr := mux.CurrentRoute(r)\n    if mr != nil {\n        if rl.logger != nil {\n            rl.logger.Printf(\"[%s] %s\", mr.GetName(), r.URL)\n        } else {\n            log.Printf(\"[%s] %s\", mr.GetName(), r.URL)\n        }\n    }\n    rl.next.ServeHTTP(w, r)\n}\n//RouteLogger creates a new route logging middleware which logs to the logger if the\n//logger is nil then logs to the stdLogger\nfunc RouteLogger(l *log.Logger) func(http.Handler) http.Handler {\n    return func(h http.Handler) http.Handler {\n        return &routeLogger{logger: l, next: h}\n    }\n}\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/\", index).Name(\"Index\")\nmw := RouteLogger(nil)\n\nr.AddMiddleware(mw)\n\nhttp.ListenAndServe(\":8081\", r)\n\n}\nfunc index(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello World\")\n}\n``. @roobre you are right about therouteLoggerbeing created for each request which is a problem.\nas for your implementation can thefor rangethat handles the middlewares moved on to theRouter` ( Here )?. @roobre besides performance gain...it will allow us to apply incremental middlewares i.e the middlewares will only be applied to the routes that are registered after regirstering that middleware...for example in case of some auth middleware you can register allowed path before registering the middleware hence some routes will be executed with middleware and some won't be.  In the current situation all the registerd middlewares are applied to all the routes.... @roobre subrouters can be used to achieve the same thing but this will allow an elegant alternative and will come in handy, not to mention the negligible performance gain.\nPS: You don't need 10 instances for 10 routes...you only need 1 instance provided that the routes are registered after registering  the middleware...also i don't see this cluttering the code after all its only 3 lines of code, which if needed can be refactored in to a function. @elithrar sure as soon as I get my hands on the computer. This approach will allow not keep you from scoping to sub-routers, if you want to you can but if you don't want to then you can get away with it. @elithrar @roobre \n```\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\nm \"github.com/abdullah2993/mux\"\n// m \"github.com/abdullah2993/mux1\"\n\n)\nfunc main() {\n    r := m.NewRouter()\nr.AddMiddleware(mw(\"1\"))\nr.Handle(\"/\", dummyHandler(\"Index\"))\n\nr.AddMiddleware(mw(\"2\"))\nr.Handle(\"/login\", dummyHandler(\"Login\"))\nr.Handle(\"/user\", dummyHandler(\"User\"))\n\nr.AddMiddleware(mw(\"3\"))\nr.Handle(\"/about\", dummyHandler(\"About\"))\n\nfmt.Printf(\"------------\\n\")\nhttp.ListenAndServe(\":8080\", r)\n\n}\nfunc mw(name string) func(h http.Handler) http.Handler {\n    return func(h http.Handler) http.Handler {\n        fmt.Printf(\"Evaluating Middleware %s\\n\", name)\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            fmt.Printf(\"[Middleware: %s]: %s\\n\", name, r.URL)\n            h.ServeHTTP(w, r)\n        })\n    }\n}\nfunc dummyHandler(name string) http.Handler {\n    fmt.Printf(\"Adding Handler for %s\\n\", name)\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintf(w, name)\n    })\n}\n```\nOutput with first approach: \n```\nAdding Handler for Index\nAdding Handler for Login\nAdding Handler for User\nAdding Handler for About\n\nEvaluating Middleware 1\nEvaluating Middleware 2\nEvaluating Middleware 3\nEvaluating Middleware 1\nEvaluating Middleware 2\nEvaluating Middleware 3\nEvaluating Middleware 1\nEvaluating Middleware 2\nEvaluating Middleware 3\nEvaluating Middleware 1\nEvaluating Middleware 2\nEvaluating Middleware 3\n```\nOutput with 2nd approach:\n```\nAdding Handler for Index\nEvaluating Middleware 1\nAdding Handler for Login\nEvaluating Middleware 1\nEvaluating Middleware 2\nAdding Handler for User\nEvaluating Middleware 1\nEvaluating Middleware 2\nAdding Handler for About\nEvaluating Middleware 1\nEvaluating Middleware 2\nEvaluating Middleware 3\n\n```\nwhich can also allow us to have an api like this\n```\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n    // m \"github.com/abdullah2993/mux\"\n    // m \"github.com/abdullah2993/mux1\"\n    m \"github.com/abdullah2993/mux2\"\n)\nfunc main() {\n    r := m.NewRouter()\n    mw1 := mw(\"1\")\n    mw2 := mw(\"2\")\n    mw3 := mw(\"3\")\nr.WithMiddlewares(mw1)\nr.Handle(\"/\", dummyHandler(\"Index\"))\n\nr.WithMiddlewares(mw1, mw2)\nr.Handle(\"/login\", dummyHandler(\"Login\"))\nr.Handle(\"/user\", dummyHandler(\"User\"))\n\nr.WithMiddlewares(mw1, mw2, mw3)\nr.Handle(\"/about\", dummyHandler(\"About\"))\n\nfmt.Printf(\"------------\\n\")\nhttp.ListenAndServe(\":8080\", r)\n\n}\nfunc mw(name string) func(h http.Handler) http.Handler {\n    return func(h http.Handler) http.Handler {\n        fmt.Printf(\"Evaluating Middleware %s\\n\", name)\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            fmt.Printf(\"[Middleware: %s]: %s\\n\", name, r.URL)\n            h.ServeHTTP(w, r)\n        })\n    }\n}\nfunc dummyHandler(name string) http.Handler {\n    fmt.Printf(\"Adding Handler for %s\\n\", name)\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintf(w, name)\n    })\n}\n```. any status update so far?. ",
    "roobre": "My fork actually looks like this:\nhttps://github.com/gorilla/mux/compare/master...roobre:middleware\nAs I said, I feel that returning the responseWriter and request seems better (to me at least) than adding a third parameter like Negroni does. Other options are, of course, open to discussion. However, please take into account that middleware writers would value the ability to hijack these two objects, so a modification to the http.Handler interface is required.. > Also, http.ResponseWriter and *http.Request can be hijacked if the middleware wants to.\nBasically your middleware might want to create a new Request or ResponseWriter, and pass them down to the rest of the chain. Think about returning Request.WithContext(), for example. Or maybe creating a custom ResponseWriter implementation.. Now it's me who is probably missing something. How can you create a middleware chain using that interface?\nWhich http.Handler is passed and what meaning have the returned http.Handler? The purpose of middleware is to operate on the ResponseWriter and Request objects, not on handlers themselves.. Thanks for the info :D\nIt certainly looks good, I'll take a look at it and change the implementation if no functionality is lost.. Then that is not the same approach I'm proposing here. There are plenty of tools which can be used to chain middleware before (and after, I guess) mux, but they get executed wether there is a route match or not. The point of adding middleware support inside mux was to circunvent this limitation, allowing middlewares to perform expensive tasks only if the endpoint is correct, or modifying the http status code only if a route is found (particularly useful for authentication middlewares).. I've looked at Negroni and Martini, each having his own approach. I'll look at a couple more and add a few drawings to explain my point better. I'm not sure when I'll be able to do this, this is being a tough week at work. Stay tuned :D. ## Key differences bewteen external and embedded middleware\nHello again. I finally have some time to explain this with more detail. I've (hand-)drawn a diagram to better illustrate the difference between the external middleware approach, which is what you are mentioning, and mine:\n\nAs i've said, middleware embedded in mux is evaluated only if a route matches. This saves processing time for non-existing routes, and allows writing of coherent authentication middleware: It will return 404 if no route is found, and 403 if a route matches but the middleware doesn't like it).\nRegarding the Middleware and MiddlewareFunc interfaces\nIf we look at how urfave/negroni implements middlewares, we see: \ngo\nHandlerFunc func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)\nThis final next parameter allows middlewares to do two important things:\n\n\nStop the Handler chain, and abort the request if they don't call next(rw, r) (pressumably writing an error to rw)\n\n\nCall the next Handler with new, modified, or tweaked ResponseWriter and Request.\n\n\nI've chosen to keep both functionalities, so a modified http.Handler which returns its own ResponseWriter and Request. This approach allows the same a flexibility as the third next parameter, but I personally found it more elegant.\nI hope this will help to clarify my point, and why I find this useful.\nPS: I know there are more ways to do this. In fact, our project does have an authentication middleware implemented with the default mux, which works by creating a new middleware object per route, and wrapping the route handler inside a closure. This is ugly, performs really bad, and has multiple race conditions. So this is why I'm trying to found an alternative.. Sure!\nAlso please note that the particular signatures and implementation are open to discussion. The key feature I'm trying to get with this is putting middleware after a match is found, and before the handler is called.. I'll do some experiments tomorrow and think about how could this be implemented using func(http.Handler) http.Handler. I'm concerned about how we could define an interface with this signature, as often middlewares are complex enough to be full objects and not just functions.. Correct me if I'm wrong, but doesn't this method imply the creation of a new routeLogger for each HTTP request? I find that a bit suboptimal.. Ok, I have migrated implementation to the proposed func(http.Handler) http.Handler function. I've also added an interface (Middleware) which can be used to write complex middlewares without a malloc hell. MiddlewareFunc implements Middleware so it's pretty straightforward.\nHere's an example implementation\n```go\npackage main\nimport (\n    \"log\"\n    \"net/http\"\n    \"roob.re/gorilla-mux\"\n)\nfunc main() {\n    myMux := mux.NewRouter()\n    myMux.AddMiddlewareFunc(simpleMw)\nmw := &myMw{}\nmyMux.AddMiddleware(mw)\n\nmyMux.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) {\n    writer.Write([]byte(\"Handled\"))\n})\n\nhttp.ListenAndServe(\"0.0.0.0:8080\", myMux)\n\n}\n// Simple middleware function\nfunc simpleMw(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\"Yee-haw\")\n        h.ServeHTTP(w, r)\n    })\n}\n// Complex middleware object\ntype myMw struct {\n    logger *log.Logger\n}\nfunc (mw *myMw) theRealThing(uri string) {\n    if mw.logger != nil {\n        mw.logger.Println(uri)\n    } else {\n        log.Println(uri)\n    }\n}\nfunc (mw myMw) Middleware(handler http.Handler) http.Handler {\n    return http.HandlerFunc(func (rw http.ResponseWriter, r http.Request) {\n        mw.theRealThing(r.RequestURI)\n        handler.ServeHTTP(rw, r)\n    })\n}\n```\nHowever, due to how the middleware chain is parsed, middlewares are executed in reverse order. Using for len instead of for range would solve this, but I'd like to hear your opinion on that.. @elithrar Yes, I find it more appropiate and intuitive. I'll change it the next time I'll put my hands on the code.\n@Abdullah2993 That would require duplicating the code, for both Router.Handle() and Router.HandleFunc(). What are the benefits of moving it there, if I may ask? Moving the load of iterating over the list away from the HTTP request? I guess there could be a performance gain, but I'm not sure if it would be worth the cringe of having the same code written on two places.. @Abdullah2993 I was planning to circunvent that using subrouters, which I find prettier. Otherwise, if you wanted to add the same auth middleware for 10 routes, you'll end up with 10 different instances of it.. @Abdullah2993 Another problem of moving middleware handling to the route is that becomes difficult to add a middleware to the whole router. Either the user copypastes the whole .AddMiddleware(mw) thing for every route, or they need to use NewRoute().AddMiddleware().Subrouter(), which seems really ugly to me.\nWe could also allow both Route and Router middlewares, where routes would have their own middlewares []Middleware and AddMiddleware(). However, I find this too complex and maybe confusing (could easily lead to wrong setups where the same middleware is executed twice).\nMy personal opinion is that middlewares should belong to a router, and not to a route. It just seems more coherent that way. In the end, if you have a middleware that you need to apply to only one or two routes, it makes more sense for that code to be in the route handler instead.. I definitely don't like this. Using order of addition to define which middlewares affect which routes is completely intuitive.. Status update: I moved middleware chain building from ServeHTTP() to Match().\nThis is because ServeHTTP() is called on the parent router, even if the match is a subrouter. See https://github.com/gorilla/mux/pull/294/commits/9315e1c71fb892c302548df09295aecd0c2f5171 for details.. No prob. I'll probably add a few test cases tomorrow, as well as code documentation and README manuals.. Status update: Test cases added, brief documentation included in README.md and doc.go.. I've discovered an annoying bug on my implementation.\nMiddlewares aren't supposed to be run if no match is found, however, given how Router.Match() works right now, if a subrouter's Router.NotFoundHandler is not nil, the middleware will be executed, as the match is not nil.\nThis bug makes me think about the way mux handles this event: correct me if I'm wrong, but if a method mismatch occurs, Route.Match() returns false and sets matchError accordingly. However, if no route is found, instead of returning false and setting matchError to ErrMatchNotFound (or something like that), Router.Match() just returns true as if it were a normal match. Why does mux behaves this way?\nChanging this behaviour as I described would allow an easy check for a not found event, and avoid building the middleware chain if it took place.. No prob, I agree with you in both points. I think it's best if I create a new PR for setting ErrMatchNotFound when falling back to NotFoundHandler, and then continuing on the middleware branch when it is merged. That should avoid unnecessary conflicts. Are you okay with that?. #311 created.. Status update: I've rebased middleware branch to match latest version of master. Now middlewares are not executed if a not found or method mismatch event occurs, even if custom handlers are used. I've added test cases for these, and improved some existing ones.\nAs this commit list is getting huge, I'll squash them after you review individual changes.. Thanks for the comments. You're right about the docs, its a bit lacking. Middleware interface is useful for building complex middlewares which need to hold some data and/or extra logic. Also it gives the API some parallelism with http.Handler and http.HandlerFunc: Same concept, but in different places. Other routers and middleware managers use the same strategy, as it is a simple way to keep complex middlewares tidy and clean.\nI'll add extra examples and fix the issues you pointed out over the course of this week, I'll be pretty busy at work until Wed :(. I've fixed some of the issues you pointed out in the commit above. Please tell me if there are something else which needs improvement.. There is an example on https://github.com/roobre/gorilla-mux/blob/middleware/README.md#middleware, line 427:\n```go\n// Define our struct\ntype authenticationMiddleware struct {\n    tokenUsers map[string]string\n}\n// Initialize it somewhere\nfunc (amw *authenticationMiddleware) Populate() {\n    amw.tokenUsers[\"00000000\"] = \"user0\"\n    amw.tokenUsers[\"aaaaaaaa\"] = \"userA\"\n    amw.tokenUsers[\"05f717e5\"] = \"randomUser\"\n    amw.tokenUsers[\"deadbeef\"] = \"user0\"\n}\n// Middleware function, which will be called for each request\nfunc (amw authenticationMiddleware) Middleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r http.Request) {\n        token := r.Header.Get(\"X-Session-Token\")\n    if user, found := amw.tokenUsers[token]; found {\n        // We found the token in our map\n        log.Printf(\"Authenticated user %s\\n\", user)\n        next.ServeHTTP(w, r)\n    } else {\n        http.Error(w, \"Forbidden\", 403)\n    }\n})\n\n}\n```\n```go\nr := mux.NewRouter()\nr.HandleFunc(\"/\", handler)\namw := authenticationMiddleware{}\namw.Populate()\nr.AddMiddleware(&amw)\n```\nWithout implementing this interface, instead of mux.AddMiddleware(authenticator) we would have to write mux.AddMiddlewareFunc(authenticator.Middleware), which seems a bit clunkier to me.\nIt's just the same as http.Handler. Go devs could have left the API without the Handler interface and everything would work the same, but instead of http.ListenAndServe(\":8000\", mux) we would have to write http.ListenAndServe(\":8000\", mux.ServeHTTP).\nThe extra decision making is indeed here, but it is for a reason: You either want a simple middleware which, for example, logs requests, or a complex one which can hold data structures, have extra logic, etc. Just like it happens with handlers.\nThe Middleware interface helps code reusability too, as having a middleware interface kind of forces users to name their middleware methods all the same, so they can be exchanged with ease. Let try to give an example: Let's suppose my logger middleware becomes extremely popular, and I decide to give it a separate package: roob.re/loggermiddleware. A potential user which already have another middleware, let's say, randomRejectMiddleware, wants to add it to their stack:\n```go\npackage main\nimport (\n    \"net/http\"\n    \"github.com/gorilla/mux\"\n    \"roob.re/loggermiddleware\"\n)\n// [...]\nfunc main() {\n    mux := mux.NewRouter()\nrrmw := &randomRejectMiddleware{}\nlgmw := loggermiddleware.New(log)\n\nmux.AddMiddleware(rrmw)\nmux.AddMiddleware(lgmw)\n\n// [...]\n\n}\n```\nThis looks simple enough. Without the middleware interface, we could have called our Middleware(http.Handler) http.Handler function different, and it would probably look like:\n```go\npackage main\nimport (\n    \"net/http\"\n    \"github.com/gorilla/mux\"\n    \"roob.re/loggermiddleware\"\n)\n// [...]\nfunc main() {\n    mux := mux.NewRouter()\nrrmw := &randomRejectMiddleware{}\nlgmw := loggermiddleware.New(log)\n\nmux.AddMiddleware(rrmw.DoMiddleware)\nmux.AddMiddleware(lgmw.MiddlewareLogic)\n\n// [...]\n\n}\n```\nI know the names are quite absurd, but you get the point. The middleware interface forces an standard middleware writes can adhere to, and makes the code to add them look simpler and nicer. Just like http.Handler does.. I'll address the changes listed above when I return from vacation. I'm sorry for the inconvenience :(\nBtw, I'll probably rebase master and squash some (or all) of the PR commits, as the list seems to be getting too big.. Sorry, I'm on vacation until maybe 3-4 Jan, so I've been quite inactive here :_\nI'll get this rebased and fixed as soon as I get home. But I'd like to see if you have reached a consensus about the Middleware interface (basically if I should remove it or not) (/cc @kisielk). @kisielk It's not exactly as you said. The interface just wraps func (http.Handler) http.Handler as a receiver and gives it a name. Just like http.Handler does with http.HandlerFunc. You can see a detailed explanation above: https://github.com/gorilla/mux/pull/294#issuecomment-343438301. It's there just to standarize the receiver name, just like http.Handler. They're even defined the same way! (see https://golang.org/pkg/net/http/#Handler and https://golang.org/pkg/net/http/#HandlerFunc).\nAnyway, in the end it's not my decision to make, so I'll rebase, squash, and remove it. Please ping me if you change your mind.. Ok, I've made the Middleware interface private. This is because if, in the future, we change our mind and decide to make it public, it will be a lot easier than if I just wipe it from existance:\n\n\nThe middleware list would no longer be of type middleware, but a function instead, which would require a dirty rewrite of the addMiddleware method (we can easily store MiddlewareFuncs as middlewares because MiddlewareFunc implements middleware, but the opposite would be dirty).\n\n\nHaving a type named MiddlewareFunc instead of just Middleware would be a bit confusing, and certainly problematic if in the future we wanted to go back to both APIs.\n\n\nPlease tell me what you think about this. As always, let me kindly remind you that this is, from my humble point of view, a mistake. The \"Interface plus function which implements the interface\" is a common pattern in go, and the idiomatic way of doing things, as we can clearly see in the net/http design and implementation.. I understand your points too, and I'm happy with the middleware interface staying, but private :D\nI'll change the pertinent parts of the docs and comments and squash tomorrow evening (GMT).\nPD: Btw, it looks like Travis hasn't complained for this PR, but the instance I keep on my repo yelled at me for some vet things on 1.6 (???) https://travis-ci.org/roobre/gorilla-mux/jobs/325103855\nI guess I shouldn't worry about this, but I'll leave it here just in case.. Rebased to latest commits on master.\nNote: I've also squashed the whole history to make rebase easier from now (it started giving conflicts on re-edited files and it is a bit of a pain).. I'll patch this along the weekend, probably tomorrow.. Fixed most of the things, please tell me what you think :D. There you go, @kisielk. I appreciate feedback on these grammar mistakes, as I'm not a native speaker I sometimes slip things here and there :(. Same here, I usually think the main points while mentally adding small exceptions and clarifications here and there, so I tend to add parenthesis and clarifications everywhere instead of rewording the whole thingk and making it more linear. Anyway, as I said, I appreciate the feedback :D. Middleware does indeed need to be thread-safe if it keeps state across requests, as go's http server spawns a new goroutine per request. Maybe I thought this was more obvious than it actually is, so writing it down may help some users. May I open a new PR clarificating it or do you guys prefer to handle this yourselves?. Maybe I can look into this if any of the affected users add some test cases. I just tweaked this code in #311, so it shouldn't be difficult for me to fix this.. Maybe I can take a look at the user examples to see if they can be ported to tests. I'll give it a try tomorrow.. I'm quite on hold since reviewers are on vacation :(\nI planned to get on this when my PR (#294) gets resolved, but if you want to look at it, be my guest :3. I've added the matching route where none is expected but one is got. I've also moved the last two test cases above the private functions, which I think is more appropriate.\nThe go fmt issue with travis is bugging me a bit, but afaik it's not my fault. It appeared when I merged upstream :/. @kisielk No prob! I'm not a native speaker, so I can make some grammar mistakes here and there. Also, I'd do the same on projects I mantain :P. If Ubuntu LTS users are a concern, maybe we can wait to the release of 18.04, which is scheduled for April iirc.. Hm, I used that wording to make clear that the ErrMethodMismatch found on the previous iteration no longer applies. But I guess I can reword it a bit.\nI'll do it tomorrow tho, its 2AM here and I'm quite asleep.. Roger, I'll clarify the calling order and stopping condition.. I still think that adding the Middleware interface will help to keep middlewares more standard, and the parallelism with net/http Handler and HandlerFunc helps users to understand the behaviour. This pattern is also seen in other routers and middleware managers (see negroni, for example).\nHowever, if you think it doesn't fit the project, I'll remove it.. Do you mean the comment or the implementation?\nThe implementation needs to be there in order to store MiddlewareFunc as Middleware in the middlewares slice. But the comment needs to be updated indeed, I slipped there :P. I don't like the AddMiddlewareFunc name either, seems way too long to me. But I think we should keep the \"func\" part somewhere, as it makes what this function expects very clear, and avoids the need for a breaking change if the middleware interface is exported in the future.\nWhat about UseFunc?. Added!. Added, but reworded \"make sure\" to \"should\", as some particular scenarios may apply and it is not a mux requirement.. I removed the version thingie. I'm not sure if its an important enough information to be in the readme. Feel free to re-add it if you think it is.. Done!. Done. I've renamed the internal addMiddleware to useInterface, to avoid collision with Use.. Btw, I forgot to mention I did not add the link because most handler don't actually implement mux.Middleware, as they require additional parameters. We could circunvent this using closures, but I think it would confuse some users instead of adding clarity. Maybe we could rework some handlers to make them comply with the interface?. Yes, of course. We should not break existing handlers, so maybe wrapping them somehow, or refactoring the core logic into a different, private function and exposing both the actual and the Middleware flavours of it. I can give it a shot if you think it's worth it.. Yikes, I totally missed that one :/\nI can fix it and create a new PR if you want, but maybe you can edit it quicker @elithrar . ",
    "advanderveer": "Any progress on this? Would love to use this for a new project ;). ",
    "xgfone": "I like this feature, too!. ",
    "ckeyer": "like. ",
    "iambudi": "Trying to use middleware but i have this error message.\nr.AddMiddleware undefined (type *mux.Router has no field or method AddMiddleware)\nr := mux.NewRouter()\nr.HandleFunc(\"/\", handler)\nr.AddMiddleware(myMiddleware). @kisielk Thanks. It works now. . ",
    "kgadams": "Hi,\nI love this feature, however I think you should clarify in the documentation if the middelware needs to be concurrency safe (I assume it does).\nSo the authenticationMiddleware only works if the amw.tokenUsers hash is never updated while the webserver is running. Otherwise you get nasty races.. Just go ahead, it's your baby :-). ",
    "galdor": "Thank you very much !. ",
    "avinassh": "Thank you very much, that worked. I thought I ran into some bug since there were issues raised with older versions and go context.. ",
    "dustingraham": "Right.\n\nRedistributions in binary form must reproduce the above copyright notice\n\nIs specifically what I'm asking about. I suppose that copyright flag idea makes sense. Thanks.. ",
    "vit1251": "Sorry for duplicate question.. ",
    "leofachini": "I'm facing the same problem as you @silverweed, but with another route setup. (Would you think these might be related? If not, I will open a new issue.)\nWith the following code:\n`\nfunc main() {\n    r := mux.NewRouter()\n    sub := r.PathPrefix(\"/\").Subrouter()\nsub.StrictSlash(true).Path(\"/test\").Methods(\"GET\").HandlerFunc(getFunc)\nsub.StrictSlash(true).Path(\"/test\").Methods(\"POST\").HandlerFunc(postFunc)\n\nlog.Fatal(http.ListenAndServe(\":3000\", r))\n\n}\nfunc getFunc(w http.ResponseWriter, r *http.Request) {\nfmt.Printf(\"%+v\\n\", r.Method)\n\njson.NewEncoder(w).Encode(r.Method)\n\n}\nfunc postFunc(w http.ResponseWriter, r *http.Request) {\nfmt.Printf(\"%+v\\n\", r.Method)\n\njson.NewEncoder(w).Encode(r.Method)\n\n}\n`\nA GET to localhost:3000/test will result in:\nGET :heavy_check_mark:\nA GET to localhost:3000/test/ will result in:\nGET :heavy_check_mark:\nA POST to localhost:3000/test will result in:\nPOST :heavy_check_mark:\nA POST to localhost:3000/test/ will result in:\nGET :x: (unexpected behavior)\n. ",
    "stevenh": "This has hit us too, the current 1.5.0 release is totally broken for any users that have Method based routing.\nThis means anyone updating using ^1.x... semantic versioning will end up with broken apps.\nGiven this there really needs to be 1.5.1 release urgently to address this.. Yes thats exactly what we\u2019ve done but not before it caused an outage for our customers.\nSo just trying to help protect others from such an outage.. ",
    "omarhachach": "Sure, you can just close this pr if you don't feel like it's good enough.\n2017-10-09 6:02 GMT+02:00 Matt Silverlock notifications@github.com:\n\nI don\u2019t think this adds enough value to afford adding to the API surface.\nA PR to improve the docs on StrictSlash would be better.\nOn Mon, Oct 9, 2017 at 12:26 AM Omar A. Hachach notifications@github.com\nwrote:\n\nI've kept the StrictSlash function for backwards compatibility. The\nStrictRouting function is only there to serve as a clearer way to impose\na\nstrict slash.\nIt does the opposite of StrictSlash.\n\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/gorilla/mux/pull/302\nCommit Summary\n\nCreate StrictRouting function.\n\nFile Changes\n\nM mux.go https://github.com/gorilla/mux/pull/302/files#diff-0\n(13)\nM mux_test.go\nhttps://github.com/gorilla/mux/pull/302/files#diff-1 (74)\n\nPatch Links:\n\nhttps://github.com/gorilla/mux/pull/302.patch\nhttps://github.com/gorilla/mux/pull/302.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/302, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcEuiicWFon6_\nyecu94tSisVWxb1Gks5sqVoTgaJpZM4Px5Pq\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/302#issuecomment-335063242, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AMdcuvFiFgqlcP8iXcMfTX-DkbnFib7tks5sqZrZgaJpZM4Px5Pq\n.\n. \n",
    "oytunistrator": "Yes. I already imported. And go get success.\nMy other test code same;\n```\nimport (\n   \"http\"\n   \"github.com/gorilla/mux\"\n)\nfunc TestHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    w.WriteHeader(http.StatusOK)\n    fmt.Fprintf(w, \"Test Parameter: %v\\n\", vars[\"name\"])\n}\nfunc main(){\n      r := mux.NewRouter()\n      r.HandleFunc(\"/hello/{key}\", TestHandler)\n      srv := &http.Server{\n        Handler:      r,\n        Addr:         \"127.0.0.1:8000\",\n        WriteTimeout: 15 * time.Second,\n        ReadTimeout:  15 * time.Second,\n    }\nlog.Fatal(srv.ListenAndServe())\n\n}\n```\nSame error:  mux.Vars undefined (type *mux.Router has no field or method Vars). ",
    "mikelikesbikes": "(sorry for the noise... I expected this to be ok on the older go versions). @elithrar I think this might be something in my service's tests. I'm going to close it.. ",
    "sergey-seleznev": "Seems not to fix that. I having cleared out the previous package traces from src and pkg, and updated to commit 65ec7248c53f499f6b480655e019e0b9d7a6ce11 of the package. Still incorrect methods are called in unexpected scenarios listed above. It's quite easy to verify: all the sample code I run is in the 1st message. Does it execute correctly on your side?. Thank you for the details!\nI've tried with CURL now as you did - it worked fine for me as well.\nThe incorrect result seems to be specific to Postman:\n. I have this one, but it is more like request-response details:\n\n. @elithrar it outputs the same that Postman receives.\n```\nfunc main() {\n    router := mux.NewRouter()\n    router.HandleFunc(\"/files/{path:.}\", getHandler).Methods(\"GET\")\n    router.HandleFunc(\"/files/{path:.}\", postHandler).Methods(\"POST\")\n    log.Fatal(http.ListenAndServe(\":8080\", router))\n}\nfunc getHandler(w http.ResponseWriter, r *http.Request) {\n    log := \"[GET] \" + mux.Vars(r)[\"path\"]\n    fmt.Println(log)\n    w.Write([]byte(log))\n}\nfunc postHandler(w http.ResponseWriter, r *http.Request) {\n    log := \"[POST] \" + mux.Vars(r)[\"path\"]\n    fmt.Println(log)\n    w.Write([]byte(log))\n}\n```\nI would blame Postman, but it's actually getting expected response calling a sample ASP.NET Core WebAPI server containing just a couple lines of custom code:\n```\n[HttpGet(\"/files/{*path}\")]\npublic String GetHandler(String path) => \"[GET] \" + path;\n[HttpPost(\"/files/{*path}\")]\npublic String PostHandler(String path) => \"[POST] \" + path;\n```\nSo I guess it's some request specifics of Postman (that could come from other client as well) that gets mux to mix up the handlers.. ",
    "clanstyles": "Wrong repository, sorry.. ",
    "sttyru": "Thank you! But at now I can't to find an solution :(\nIf it's not too much trouble, can you to write a short example?\n/ I can't to rewrite an wrapHandler by your recommends./. ",
    "armhold": "Thanks!. ",
    "ScottHale": "Thanks for the help! It worked perfectly. . ",
    "alexellis": "It's the function route (linked in the source) the vars are completely empty. . It's linked above... I.e. here https://github.com/openfaas/faas-provider/blob/0.4/serve.go#L29. Thank you for trying to help. This is a blocking issue and I'd like to continue using mux across our projects, but this issue is causing a lot of headaches.\nfaas-provider sets up the mux etc... with a struct passed in with all the handlers we want. That means whoever wants to implement the \"FaaS\" interface only needs to setup a config struct and call Serve.\nHere is where each route is setup up\nhttps://github.com/openfaas/faas-provider/blob/0.4/serve.go#L32\nHere is where client code sets up its handler for FunctionProxy:\nhttps://github.com/openfaas/faas-netes/blob/master/server.go#L49\nHere Serve is called\nhttps://github.com/openfaas/faas-netes/blob/master/server.go#L66\nSummary:\nfaas-provider exists to bind a set up handlers to pre-defined routes\nfaas-swarm or faas-netes only have to provide handlers in a struct and call Serve - nothing more or less. The faas-netes one works perfectly and faas-swarm (new) fails to show mux.Vars as anything but empty.\n. I am not sure what caused this but I suspect it may be related to the dep vendoring tool for go adding an old mux version somewhere in the vendor hierarchy. Thanks for the suggestions. . ",
    "deviantony": "FYI just had the same problem when leveraging gorilla/mux inside a library using dep to vendor it.\nI then tried to use that library in another project and had the same problematic behavior. Removing the vendor folder of the library fixed the issue.\nNot sure about the root cause here.\n. ",
    "a-tal": "send a metric, for one. ",
    "fharding1": "Thanks for the quick response! I might misunderstand, but in this circumstance if you are returning a modified shallow copy, what are the advantages of not just passing by value and modifying that? And even if you weren't, and actually modifying the http.Request by pointer, what would be the point of returning the pointer again?. My bad, meant and was thinking of *http.Request, just a typo.\n@elithrar You cannot ignore the returned variable from mux.SetURLVars I don't think, otherwise it will not work as seen in my example. \n@garyburd hmm did not see that, might make it harder to do what I suggested then.. @kisielk okay, I still think that maybe if you aren't modifying it's argument you shouldn't pass a pointer, but I understand you may not want to do that because http.Request is fairly large and for method chaining. If you want me to create a PR to update the docs, I'd be glad to.. I think in that case it's because Request is such a large struct, but in most cases I'm pretty sure using a pointer receiver on a method (or passing a pointer in a function) that just reads is not idiomatic. One reason why is safety, (see this example) and also clarity, you can just look at a function param or pointer receiver and see if any modification is going to be done. I do understand the +'s of using pointers though, and the argument for using them in this case.\nWill get to work on it! \ud83c\udf89 yay OSS!. Hmm, thanks for that link, didn't know that was recommended by the Go FAQ. Seems weird to me since you can use non-pointer receiver methods on pointers anyways, but I guess the uniformity makes sense. Also a good point about locks.. Sure! Just to clarify, would you want me to include package, imports, etc, or just the relevant parts, like\n```go\npackage example\nimport (\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n\"github.com/gorilla/mux\"\n\"github.com/stretchr/testify/assert\"\n\n)\nconst (\n    varKey   = \"foo\"\n    varValue = \"bar\"\n)\nfunc ExampleHandler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(mux.Vars(r)[varKey]))\n}\nfunc TestExample(t *testing.T) {\n    req, _ := http.NewRequest(\"GET\", \"/foo\", nil)\n    req = mux.SetURLVars(req, map[string]string{varKey: varValue})\n    rr := httptest.NewRecorder()\nExampleHandler(rr, req)\n\nassert.Equal(t, varValue, string(rr.Body.Bytes()))\n\n}\nvsgo\nconst (\n    varKey   = \"foo\"\n    varValue = \"bar\"\n)\nfunc ExampleHandler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(mux.Vars(r)[varKey]))\n}\nfunc TestExample(t *testing.T) {\n    req, _ := http.NewRequest(\"GET\", \"/foo\", nil)\n    req = mux.SetURLVars(req, map[string]string{varKey: varValue})\n    rr := httptest.NewRecorder()\nExampleHandler(rr, req)\n\nassert.Equal(t, varValue, string(rr.Body.Bytes()))\n\n}\n``. Added. It's my first time using example test functions, so I apologize if I messed up.. @elithrar Thank you for the response! That somewhat works I think, but OPTIONS requests still don't work right. Because the two URL's are the same format, an OPTIONS request to /reports/{eventKey}/{matchKey} or /reports/{eventKey}/{team} returns **either** PUT, OPTIONS or GET, OPTIONS (assuming both .Methods() include OPTIONS) when they should return GET, PUT, OPTIONS. Is there any way around this? To accumulate all methods on \"the same\" format URL's?. bump. @elithrar I would be into trying to get that working myself.. @elithrar :+1: done.. bump @elithrar . Yeah, because you might only want to apply the middleware to certain routes. I'm not super familiar with mux beyond using it in personal projects with fairly normal use cases, would there be a better way to do this that you would recommend? @kisielk . Hmm, I implemented it as a method on Router as that's how @elithrar recommended it in #353: \"I'd be open to a PR that can do this as a feature on Router.\", but I also agree with what you've said. @elithrar ?. Alright, I've removed it fromRouter, the usage now looks likerouter.Use(MethodMiddleware(router))which I think makes sense.. Fixed! Thank you for maintaining gorilla/mux and helping me add this feature!. Don't mean to butt in, but why would we want to respond with a default set of methods? If the developer does not use .Methods() on a route, it doesn't make sense to set the Access-Control-Allow-Methods header on it to me. Not even just safe and idempotent ones. I think it would be fine to implement behavior with CORSMethodMiddleware that allows you to set default methods for routes that don't have .Methods() set, but assuming that everyone wants to set those CORS methods on a route whenever they use the middleware and don't specify .Methods() seems dangerous. We could do something like change CORSMethodMiddleware so it's like mux.CORSMethodMiddleware(r, nil) for no default methods or mux.CORSMethodMiddleware(r, []string{\"OPTIONS\", \"GET\", \"HEAD\", \"TRACE\"}) for setting those default methods on routes that don't specify .Methods().. I get your point, but it seems to me that if I didn't set Methods() on a route I am purposely not setting any CORS headers because setting CORS headers is tied to .Methods(). It seems like it would be better to force the developer to explicitly allow all methods for CORS. That being said, that's mostly my opinion and what you're saying is valid too.. Alright. Also, I'm not sure, but it seems like we can remove contextClear from context_native and the code block from mux.go 158:160. If we did thatRouter.KeepContext` would be basically useless (I think), but removing it would be breaking. Should I just put a comment on it that says this has no effect?. I'm not sure what he means, why is it required?. I'm not super familiar with modules, but yeah, I don't think it's required. Wasn't planning on addressing that feedback unless @flibustenet can clarify why it's required.. I agree with the first part. As for building the routes on every request, I think it would be fairly difficult to do, but I don't know the mux architecture super well either. I can't think of any clean solution that keeps our data fresh. It would be nice to not have to walk the router on each request though of course, so I'm open to any ideas!. ",
    "mreithub": "The Scheme, Host and User fields are usually empty in http.Request.URL.\nreq.URL.String() will therefore return something like: /path/to/file.html?q=123\nwhich will in turn result in a response like:\nHTTP/1.1 301 Moved Permanently\nLocation: /path/to/file.html?q=123\n\n(i.e. no scheme, user or hostname)\nsomething every browser I know (even IE6 back in the day) is fine with.\nThey'll simply keep these values the same -> HTTPS stays HTTPS, etc...\nTo be fair, manually overriding the request user isn't documented in handlers.CombinedLoggingHandler, but its source does evaluate the value - and there's no other way I can think of to get it to log the username. According to the MDN's Location header page:\n<url>: A relative (to the request URL) or absolute URL.\n\nBut if you suspect the patch might cause issues, I could add a check for url.Host == \"\".\nHere's a quick play.golang.org snippet with a few hand-crafted URLs: https://play.golang.org/p/lsGWk-0sfsl\nBtw. I hope the travis build failing is just an issue of missing secrets (or something like that). Ok - sorry for spamming - according to this SO post, the golang doc for http.Request.URI and RFC 2616, section 5.1.2,\nScheme and Host may not be empty (in case of proxy requests).\nI've just added the url.Host == \"\" check, that should prevent any issues.\nOh, and I've fixed a typo in the last commit, sry about that.\nNow the tests pass again.. Wouldn't that strip the query string? (since p is only the URL.Path)\nThe lines \nw.Header().Set(\"Location\", p)\nw.WriteHeader(http.StatusMovedPermanently)\nshould probably be replaced by the http.Redirect() call though - to fix encoding issues (unless that's been done somewhere earlier already)\n. I'm sorry, I just noticed that I've tried fixing my issue at the wrong place in the code (I assumed that was the part responsible for the strictSlash redirects).\nNow I've found out that adding the following lines to regexp.go:299 will fix my issue:\ngo\n// Prevent malformed redirect URLs (if for example some outer Handler set u.User)\nif u.Host == \"\" {\n  u.Scheme = \"\"\n  u.User = nil\n}\nShould I close this PR?\nHow are your thoughts on opening another one for the actual fix?. I had trouble actually testing the changes (other than go test) - and only later found out that was because I changed the code in ~/go/src/... while my project was using vendor/.\nAgain, sorry for wasting your time on this.. I'll close this then.\nThanks a lot for your time (and quick responses). ",
    "xolan": "One or more examples in README should reflect this user (dev) responsibility.. It seems this made no difference. Still diagnosing. Closing for now.. Thank for that! Turns out it was a third party library having trouble flushing messages.\nWent from ~2GB while stress testing to ~40MB. :+1: . ",
    "ilijamt": "Single route only\nIf i need to attach to the subrouter I can use .Use to attach a middleware?\nOn Feb 12, 2018 16:57, \"Matt Silverlock\" notifications@github.com wrote:\n\nDo you want to attach middleware to a single route, as in your example, or\nto the router/subrouter? The latter is more common.\nOn Mon, Feb 12, 2018 at 7:13 AM Ilija Matoski notifications@github.com\nwrote:\n\nHow would someone best implement chainable middlewares?\nr := mux.NewRouter() r.HandleFunc(\"/test\", middleware1, middleware2,\nmiddleware3, finalHandler).Methods(\"GET\")\nWhat would be the best way to implement this?\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/344, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcEOwQ4oqHa8xRgOq-\nIlj4jFUy2Ftks5tUFUFgaJpZM4SCUe8\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/344#issuecomment-364966863, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABFi49ZbwvYAF5cx6-v9FPDX1AFjUwuGks5tUF9RgaJpZM4SCUe8\n.\n. ```\nvar middleware []mux.MiddlewareFunc\nmiddleware = []mux.MiddlewareFunc{middleware1, middleware2, middleware3, ...}\nr := mux.NewRouter()\nmethods := []string{ http.MethodGet }\n\nroute := r.NewRoute().Subrouter()\nfor _, m := range middleware {\n    route.Use(m)\n}\npath := \"/test/{param}\"\nroute.HandleFunc(path, handler).Methods(methods...)\n```\nWould something like this work properly then?\nIf I call it with GET it will call all the middlewares, but if I call POST it will not call the middlewares is it that how it's supposed to work ?\nShouldn't it call the middlewares before calling the final handler?. I was expecting for the middlewares to be evaluated before the final\nhandler, when you have a Method set\nBut they are not, and if that is the correct behavior it's fine then\nOn Tue, Feb 20, 2018 at 7:35 PM, Matt Silverlock notifications@github.com\nwrote:\n\nSorry, missed this reply.\nWhat is the intended behaviour you expect?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/344#issuecomment-367074605, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABFi464fn96V-tXaDcK_rHWP1Gz8Y3Esks5tWxBbgaJpZM4SCUe8\n.\n\n\n-- \nIlija Matoski\n. ",
    "npgm": "A route path in general is an ordered sequence, and a name alone does not indicate the position in that sequence. \nA concrete example: mapping route params to function arguments.. Golang's reflect package lets you inspect function argument types and position in the parameter list, but doesn't let you inspect the name of the argument. So if you want to map route parameters to function parameters, the only way to achieve this mapping (from what I can gather) is to rely on relative position. \nSee NumIn() int and In(i int) Type: https://golang.org/pkg/reflect/#Type\nHowever beyond this specific use case, it makes sense to me that this would be exposed in the API because a path is an ordered sequence. \n```\nfunc Bind(fn interface{}) http.HandlerFunc {\n    var (\n        fninputs []reflect.Type\n    )\nfnval := reflect.ValueOf(fn)\nfntyp := fnval.Type()\n\n     // gather the types of the function's inputs \nfor i := 0; i < fntyp.NumIn(); i++ {\n    argtyp := fntyp.In(i)\n    fninputs = append(fninputs, fntyp.In(i))\n}\n\nreturn func(w http.ResponseWriter, r *http.Request) {\n    route := mux.CurrentRoute(r)\n    vars := mux.Vars(r)\n    varnames, _ := route.GetVarNames()\n    if len(varnames) !=  len(fninputs) {\n        http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n    }\n\n    curVarName := 0\n    fnargs := make([]reflect.Value, len(fninputs))\n\n             // for each function input's type, cast the corresponding var to the type and add it to the arg slice\n    for i, vtyp := range fninputs {\n        switch i {\n                      / * snip some irrelevant logic from this switch */\n        default:\n            vn := varnames[curVarName]\n            curVarName += 1\n\n                              // this converts the string to the type (not included here)\n            vcast, err := cast(vtyp, vars[vn])\n\n            if err != nil {\n                http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n            }\n\n            fnargs[i] = reflect.ValueOf(vcast).Convert(vtyp)\n        }\n    }\n\n             // Finally, call the function with the args\n    _ = fnval.Call(fnargs)\n}\n\n}\n```. @elithrar is there any other information that would be helpful? Do you think this is a valid use case? . ",
    "happilymarrieddad": "Here is an example. It does not feel right.\n\n. @elithrar oh cool thanks so much man!. ",
    "codehakase": "Middleware channing could be another way out, I want to know if gorilla Mux does it out of the box. ",
    "anks333": "Sure,\n```\n        r := mux.NewRouter()\n    r.Use(m.AllowCors)\n    r.Use(m.LoggingMiddleware)\n// Handle all preflight request\nr.Methods(\"OPTIONS\").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    // fmt.Printf(\"OPTIONS\")\n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    w.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, DELETE\")\n    w.Header().Set(\"Access-Control-Allow-Headers\", \"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, Access-Control-Request-Headers, Access-Control-Request-Method, Connection, Host, Origin, User-Agent, Referer, Cache-Control, X-header\")\n    w.WriteHeader(http.StatusNoContent)\n    return\n})\n\n    r.StrictSlash(true)\n\n    r.HandleFunc(\"/user/{role}\", h.Register).Methods(\"POST\")\n\n``. @elithrar add Slash at the end of the urllocalhost:8000/user/admin/` and send the request from some different Origin, then probably you'll be able to replicate the issue.\nThanks for the reply. ",
    "rojakcoder": "I corrected some mistakes/omissions in the sample code that I wrote.\nAfter some more investigation, it seems that version 1.9.57 of the SDK (which uses Go 1.6.4) uses contextSet() from \"context_gorilla.go\"\nVersion 1.9.65 of the SDK (which uses Go 1.8.5) uses contextSet() from \"context_native.go\"\nI believe it is the native context that's causing the request to be re-created.\nSince only the original request is registered in the Sessions registry, and the re-created requests are treated as different instances by the registry, they don't get the same session value attached to the original one.\nI find it odd that I'm the only person encountering this problem.\nI'm sure this has to to do the migration of the context package in Go 1.7. I just noticed that context_gorilla.go is built for Go 1.6 and before whereas context_native.go is built for Go 1.7 onwards. Given that Gorilla Sessions uses the request in its registry to store the session values, I'm not sure if this is something to be fixed by Mux or Sessions.. ",
    "cjellick": "The cleaning code is fine and I agree it  mirrors net/http, I think the problem is you are cleaning and setting req.URL.Path and not req.URL.RawPath. This makes RawPath an invalid escaping of Path and thus causes url.String() (used in the rediect) to ignore it.\nAccording to the HTTP spec, you are doing the wrong thing by turning %2F in / and then treating it as a path segment delimeter:\nWhen a URI is dereferenced, the components and subcomponents\n   significant to the scheme-specific dereferencing process (if any)\n   must be parsed and separated before the percent-encoded octets within\n   those components can be safely decoded, as otherwise the data may be\n   mistaken for component delimiters.\nI think the more correct thing to do would be to continue to clean the path but also mirror net/url's setPath() for setting both Path and RawPath correctly so that the url you pass back as the redirect location is accurate:\n// setPath sets the Path and RawPath fields of the URL based on the provided\n// escaped path p. It maintains the invariant that RawPath is only specified\n// when it differs from the default encoding of the path.\n// For example:\n// - setPath(\"/foo/bar\")   will set Path=\"/foo/bar\" and RawPath=\"\"\n// - setPath(\"/foo%2fbar\") will set Path=\"/foo/bar\" and RawPath=\"/foo%2fbar\"\n// setPath will return an error only if the provided path contains an invalid\n// escaping.\nfunc (u *URL) setPath(p string) error {\n    path, err := unescape(p, encodePath)\n    if err != nil {\n        return err\n    }\n    u.Path = path\n    if escp := escape(path, encodePath); p == escp {\n        // Default encoding is fine.\n        u.RawPath = \"\"\n    } else {\n        u.RawPath = p\n    }\n    return nil\n}. Let me know whether you agree or disagree with that. If you disagree and still think there is no bug, we can close the issue and move on.\nIf you agree, I wouldn't mind taking a stab at submitting a PR to address the issue.\nAlso, I get it if the answer is \"yes it is technically wrong, but it impacts almost no one and changing it is too risky\".. ",
    "gavbaa": "While this has been marked as stale, this is still a legitimate problem with the router's behavior, and should be reopened for discussion.  We're encountering the same issue, and no resolution was reached on this ticket.  This requires feedback from a core member.. ",
    "chriskolenko": "@elithrar apologies. I'll get onto this tonight.. ",
    "magicalbanana": "Never mind, it was an issue on my end.. ",
    "kikihakiem": "@magicalbanana I have the same scenario (same path, different method and handler), and I also got the same error. What did you do to fix that?. ",
    "opennota": "Why is this issue closed? It is not fixed.. It's somewhat counter-intuitive. The user can't easily figure out that the pattern which doesn't work without a name somehow works if there is a name. So yes, a usability issue.. Oh. I was under the false impression that one could use a regexp without a name. But the following works:\n```\npackage main\nimport (\n    \"fmt\"\n    \"github.com/gorilla/mux\"\n    \"net/http\"\n    \"net/http/httptest\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(r.URL.Path)\n}\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/{pattern}\", handler)\n    w := httptest.NewRecorder()\n    req, _ := http.NewRequest(\"GET\", \"/this-doesnt-have-to-match-pattern\", nil)\n    r.ServeHTTP(w, req)\n}\n```\nSo this is at most a documentation issue.. ",
    "bminer": "Might be good to note this in the docs.  It is not entirely clear that r.PathPrefix bypasses the middleware set in r.Use. Thoughts?. Perhaps this behavior was changed after #431?. I don't see this in master branch.  When will this be released?  How do I go get it?. @tomare - Sorry, can you provide more info?  Why was it changed?  Is there an associated issue, so I can read up on it?. ",
    "ashwiniverma": "```package main\nimport (\n    \"net/http\"\n    \"github.com/gorilla/mux\"\n)\nfunc main() {\n    r := mux.NewRouter()\n    r.UseEncodedPath()\nr.HandleFunc(`/credit-cards/accounts/recurring-merchants`, YourHandler).\n    Methods(http.MethodGet)\n\nhttp.ListenAndServe(\":8000\", r)\n\n}\nfunc YourHandler(w http.ResponseWriter, r *http.Request) {\n    v := r.URL.Query()\n    a := v.Get(\"isRecurringOnly\")\n    b := v.Get(\"toDate\")\n    c := v.Get(\"fromDate\")\n    println(\"a ::: \", a)\n    println(\"b ::: \", b)\n    println(\"c ::: \", c)\n}\nThis is the example I am using , curl command - \ncurl -i -X GET localhost:8000/credit-cards/accounts/recurring-merchants?isRecurringOnly=true&toDate=true&fromDate=true\nOutput : \na :::  true\nb :::\nc :::\n. Sure Matt, I can try that. One more update - I just found that the issue was with the curl command\ncurl -v -XGET 'http://localhost:8080/credit-cards/accounts/recurring-merchants?isRecurringOnly=abc&toDate=def&fromDate=ddd'\nThanks Matt for helping me out, I will implement your suggestion and see how it goes.. ",
    "brunovlucena": "Anyway to get name={name}&data.{key}={val} from the url?. ",
    "yadkit": "@elithrar updated the post.. ",
    "cybercrypt13": "I guess I'm confused because I'm used to passing Get variables using ? and & to separate them.  It appears this needs to have a separate route setup for each set of variables that might be passed in?\nie: I had to change Postman to send my variable called \"labels\" through using url/zebra/labels=hello instead of url/zebra?labels=hello\nA little confused there but changing it did make it work properly.\nThanks,\nGlenn. Yeah, I was trying to setup a REST server and might have chosen the wrong package.  Sorry for the confusion.\nGlenn. ",
    "EmmanuelVlad": "Hey, first of all thanks for the help\nI had to change\ngo\ncase http.StatusPermanentRedirect:\n    code = 308\ncase http.StatusTemporaryRedirect:\n    code = 307\nto\ngo\ncase http.StatusFound:\n    code = 308\ncase http.StatusMovedPermanently:\n    code = 307\nin order to redirect from 301/302 to 307/308\nThanks again :). Another problem I found:\nANY METHOD /test// redirects to /test/ (loses the body) then redirects (301) to /test. ",
    "Maykonn": "@elithrar I solved using reflex in this way: https://github.com/cespare/reflex/issues/50\nThanks!. ",
    "swalberg": "Been trying this out with a few different versions of gorilla/mux as far back as 94903de and none of them work with this. Am I doing something incorrectly? Possibly a dupe of #342?. I changed my tests to set the vars directly like in #342 and it passes:\n```go\npackage main\nimport (\n    \"fmt\"\n    \"github.com/gorilla/mux\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n)\nfunc TestMetricsHandler(t *testing.T) {\n    tt := []struct {\n        routeVariable string\n        shouldPass    bool\n    }{\n        {\"goroutines\", true},\n        {\"heap\", true},\n        {\"counters\", true},\n        {\"queries\", true},\n        {\"adhadaeqm3k\", false},\n    }\nfor _, tc := range tt {\n    path := \"whocares\"\n    req, err := http.NewRequest(\"GET\", path, nil)\n    if err != nil {\n        t.Fatal(err)\n    }\n    req = mux.SetURLVars(req, map[string]string{\n        \"type\": tc.routeVariable,\n    })\n    rr := httptest.NewRecorder()\n    /* Appears we can call it directly if we want?\n        handler := http.HandlerFunc(MetricsHandler)\n        handler.ServeHTTP(rr, req)*/\n    MetricsHandler(rr, req)\n\n    expected := fmt.Sprintf(\"Type: %v\", tc.routeVariable)\n\n    if rr.Body.String() != expected {\n        t.Errorf(\"handler should have failed on routeVariable %s: got %v want %v\",\n            tc.routeVariable, rr.Body.String(), expected)\n    }\n}\n\n}\n```\nCan you elaborate on comments in #342? My understanding is \"yes you can use mux.SetURLVars but you should really do it the way I've shown\" which I prefer, but can't get to work.\nThanks!. OK, thanks @elithrar and @kisielk, that was enough to get me to something working. I've made a PR to fix the docs to reflect our discussion. If that's still not the right way please let me know and I'll be happy to fix!\nSean. ",
    "rspier": "Never mind, closing this PR.  I was thrown off by how the int types were stringified.  My change has little (if any) benefit.. ",
    "nolta": "I ran into this issue trying to apply middleware to groups of unrelated paths:\n```go\nr := mux.NewRouter()\nprivate := r.NewRoute().Subrouter()\nprivate.Use(isUser)\nprivate.HandleFunc(\"/a\", ...)\nprivate.HandleFunc(\"/b\", ...)\nadmin := r.NewRoute().Subrouter()\nadmin.Use(isAdmin)\nadmin.HandleFunc(\"/c\", ...)\nadmin.HandleFunc(\"/d\", ...)\n```\nHere isAdmin never runs.\n. Sorry for the noise, the above code snippet does work.\nIt should have read:\ngo\nsub1 := r.PathPrefix(\"/sub\").Subrouter()\nsub2 := r.PathPrefix(\"/sub2\").Subrouter()\nwhich is exactly the same issue as #378.\nPlease merge or fix #378.. ",
    "tkinz27": "I am also running into this issue. I boiled down my code to the following to reproduce. \n```go\npackage main\nimport (\n    \"net/http\"\n    \"time\"\n\"github.com/gorilla/mux\"\n\"github.com/pkg/errors\"\n\"go.uber.org/zap\"\n\n)\nfunc main() {\nr := mux.NewRouter()\n\nlogger, _ := zap.NewDevelopment()\nr.Use(func(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        logger.Debug(\"Running in middleware\")\n    })\n})\n\nv0 := r.PathPrefix(\"/v0\").Subrouter()\nv0apis := v0.PathPrefix(\"/apis\").Subrouter()\n\nv0.HandleFunc(\"/apis\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"[\\\"/v0/apis/test\\\"]\"))\n}).Methods(\"GET\")\n\nv0Test := v0apis.PathPrefix(\"/test\").Subrouter()\nv0Test.Methods(\"GET\").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"v0 test api\"))\n})\n\n// Start the actual HTTP server\ns := &http.Server{\n    Addr:           \"localhost:8080\",\n    Handler:        r,\n    ReadTimeout:    24 * time.Hour,\n    WriteTimeout:   24 * time.Hour,\n    MaxHeaderBytes: 1 << 20,\n}\n\nlogger.Debug(\"ready?\")\nerr := s.ListenAndServe()\nif err != nil {\n    panic(errors.Wrap(err, \"error with HTTP server\"))\n}\n\n}\n```\ncurl http://localhost:8080/v0/apis/test will get me the middleware log but not curl http://localhost:8080/v0/apis. ",
    "ashanbrown": "@elithrar @kisielk I thought I'd check in on this one since it's been sitting around for a few months.  Is there anything I can do to help you accept this change?  Thank you.. Thanks for the example @makkes .  Our own case can be seen a https://github.com/launchdarkly/ld-relay/blob/67cd728e941df5d975a53a232e64ea394ae4d97a/relay.go#L421.  We also have some middleware that only applies to a subset of the route paths.  I've taken the fact that PathPrefix is not required to mean that the router is just a grouping of routes that runs the same middleware but can also be limited to a path, if so desired.. @kisielk @elithrar I'm not sure how to proceed with this PR.  It would help me if you could tell me exactly changes you'd like me to make.  Thank you.. @elithrar I'm not sure we agree that this is a user error, as you suggested in your next comment.  I believe a subrouter is something with a path prefix and possibly some middleware.  It's not obvious to me that subrouters should be mutually exclusive unless that is implied by the possibility of having a NotFound handler (specifically by the resultant ambiguity about which NotFound or MethodNotAllowedHandler to use in the case of overlapping subroutes).  Also, while we can recognize identical subroute segments, I think recognizing the full set of possibly overlapping routes would add considerable complexity.  The feature of allowing reuse of middleware between arbitrary groups of routes does seem a valuable one.  I've updated the test case name and behavior to match the simpler example provided by @tkinz27.  The problem is not specific to duplication -- I was just trying to come up with the simplest possible example -- but I think the overlapping subrouter and path case is clearer.. I updated my test case so it wasn't simply a case of duplication.  That was just a subset of the cases where the middleware isn't run.  The current test case setup looks like this:\nrouter.PathPrefix(\"/x\").Subrouter()\n    router.HandleFunc(\"/x\", dummyHandler).Methods(\"GET\")\n@kisielk  In this case, do you feel the second line should panic?. ",
    "makkes": "Perhaps it helps to add mux user's perspective to the discussion, so I'll jump in here. I have the following route definitions:\n```\n    authenticatedRoutes := s.router.NewRoute().Subrouter()\n    authenticatedRoutes.Use(authenticate)\n    authenticatedRoutes.HandleFunc(\"/accounts\", http.HandlerFunc(s.handlers.GetAccountsHandler)).Methods(\"GET\")\n    authenticatedRoutes.HandleFunc(\"/accounts/{id}\", s.handlers.GetAccountHandler).Methods(\"GET\")\n    authenticatedRoutes.HandleFunc(\"/accounts/{id}/roles\", s.handlers.GetRolesHandler).Methods(\"GET\")\n    authenticatedRoutes.HandleFunc(\"/apps\", s.handlers.CreateApp).Methods(\"POST\")\n    authenticatedRoutes.HandleFunc(\"/apps\", s.handlers.GetApps).Methods(\"GET\")\n    authenticatedRoutes.HandleFunc(\"/apps/{id}\", s.handlers.GetAppHandler).Methods(\"GET\")\nopenRoutes := s.router.NewRoute().Subrouter()\nopenRoutes.Use(appID)\nopenRoutes.Use(middleware.CheckReferer)\nopenRoutes.Handle(\"/accounts/{id}/active\", http.HandlerFunc(s.handlers.ActivateHandler)).Methods(\"POST\")\nopenRoutes.Handle(\"/accounts\", handlers.ContentTypeHandler(http.HandlerFunc(s.handlers.CreateHandler), \"application/json\")).Methods(\"POST\")\nopenRoutes.HandleFunc(\"/tokens\", s.handlers.CreateTokenHandler).Methods(\"POST\")\n\n```\nAs you can see, I have several routes that have the same prefix but need a different middleware. As a mux user it would be very verbose to create a new router for each of those and logically it makes sense to have router for authenticated routes and another one for routes that don't need authentication. Therefore I stand in support of @ashanbrown's approach.. ",
    "sothychan": "Any thoughts on when this can get merged into master?  This currently fixes a bug that I'm also experiencing.  Thanks!. @kisielk Thanks for your quick response.  I will give that a shot and will let you know.  Thanks again!. ",
    "ribice": "Alternatively, this works fine:\ngo\nrouter := mux.NewRouter().StrictSlash(true)\nrouter.HandleFunc(\"/_ah/test\",handler).Methods(\"POST)\nhttp.Handle(\"/\", router). I confirm that it does work now. Curious which commit fixed it \ud83e\udd14.. ",
    "aswinmprabhu": "Hey, @elithrar \nHas this issue been fixed?\nI am new to Golang and was trying to fix this bug. But it seems to be working fine.. @elithrar Its the same one in the original comment. \nThe example in a gist gives me \"works\" when I curl it.\n$curl -X POST localhost:8000/_ah/test\nworks\nI also added a couple of test cases to see if they are failing.. @elithrar Can you please tell me if my example is alright or if I have made some mistake?. ",
    "coolboi567": "@ribice No need to worry till it works \ud83d\ude2c. ",
    "pierreprinetti": "@elithrar Thanks for the fast response!\nJust one thing:\nWith the current code, setting \"OPTIONS\" explicitly as a verb when registering a route will have the effect of allowing the CORSMethodMiddleware to handle it.\nI think it's a totally valid solution! If this is the intended behaviour? If it is, then maybe we could add a short line in the docs about it.. If #378 was to be merged, these docs would have to be amended.\nWith the current logic, the OPTIONS preflight request will only be responded to by the CORSMethodMiddleware if the method is matched by a route. If instead the middlewares were to be triggered even without a match, the OPTIONS call would be responded anyway once CORSMethodMiddleware is Used.. See a preview of the changes here. Hmm wait there's a problem. I'm adding a test to get it. OK, it seems like we have a couple problems.\nWithout method matcher\nIf the methods are not set explicitly, the middleware should allow a reasonable amount of methods.\nWith method matcher\nIn case of a route with explicit method matchers, \"OPTIONS\" should be specified. This means that the production code should not add it explicitly:\nhttps://github.com/gorilla/mux/blob/c85619274f5d55a67491010f883a91f568b3a9b0/middleware.go#L62\nDoing so would result in a duplicate.. The tests now pass. ptal! :). >  why would we want to respond with a default set of methods? If the developer does not use .Methods() on a route, it doesn't make sense to set the Access-Control-Allow-Methods header on it to me.\nThe rationale behind defaulting to a comprehensive set of allowed methods was that when you attach routes to a router, you attach it with opt-in filters. If you don't attach a .Methods on it, you're setting the route to be matched no matter the HTTP method. Therefore it made sense to me to output all the methods as allowed, once the consumer asks for an AllowedMethods on that route(r).\nWith the code below, I'd expect the Allowed-Methods header to be attached to both routes. I'd be surprised if not setting a filter would have the effect of taking the allmethods route out of the CORS-allowed paths.\n```Go\nrouter.Path(\"/onlyput\").Methods(\"OPTIONS\", \"PUT\").Handler(onlyPutHandler)\nrouter.Path(\"/allmethods\").Handler(allmethodsHandler)\nrouter.Use(CORSMethodMiddleware(router))\n```\nHaving said this, I may not have a complete understanding of the logic underlying this package, as I haven't used it heavily.. With 560baa1, a route without explicit Method filters will be ignored by the middleware. Please take a look!. (I'm not sure the documentation label still applies). I'm closing this as #381 has been identified as a wontfix. Please consider reusing this code if the CORS middleware discussion comes up again.\nIn the meantime, I have implemented a custom solution in the codebase I was working on, as the API of this specific feature in mux is a bit too magic for me.\nThank you!. ",
    "vcGF": "Sorry what is the status of this? I am trying to get my code working with CORS\nI can't see how to use the  CORSMethodMiddleware method. \nSomehow I get this error, even if I have the latest release code. Hmmm\n. Oh I changed my code to \nr := mux.NewRouter()\nmux.CORSMethodMiddleware(r)\nr.HandleFunc(\"/test\", testFunc)\nhttp.Handle(\"/\", r)\nIs it how to use it ? Because I'm still facing errors on OPTIONS request :/. I m using Google App Engine to host my service.\nSending my payload through POSTMAN doesn't trigger the OPTIONS method, hence it goes straight to POST and is successful.\nHowever, utimately the API is to be trigerred from a Angular6 frontend, and Chrome (or Safari) are sending those POST request first, the POST and the JSON payload don't even reach the server as the OPTIONS call fails.\nHere is the trace from the Chrome debug tools\n\n\nHere is how I setup the router in my Go file.\n\n. Did I miss one step in the configuration here ?. But isnt the whole purpose of the CORS middleware func ,mentioned above, to\nadd on those requires headers and handle OPTIONS method ?\nWhat puzzles me is that even when the request goes through that middle\nfunction , it dooesnt seem to set the proper headers.\nLe lun. 3 sept. 2018 \u00e0 12:32, Matt Silverlock notifications@github.com a\n\u00e9crit :\n\nYes: you need to explicitly allow the origin by adding an\nAccess-Control-Allow-Origin header, as per the error message. localhost\nis not a valid origin.\nI recommend taking a look at https://github.com/rs/cors\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/issues/381#issuecomment-417997498, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AJj5aeUvvthjmaJ5Vr0eSLeWXEfqjYhcks5uXLDSgaJpZM4UKzLf\n.\n. \n",
    "cognusion": "Tracking down why my apps suddenly stopped doing host matching properly, and stumbled onto this. Seems like a big backward-breaking change for a minor release. At the very least, when the Route.Host() contains just a host, and not a port, then hostname:* should be assumed, I'd think.. PR #447 does the job efficiently.\n\nI'm open to a PR for that.\n\u2026\nOn Tue, Feb 12, 2019 at 10:29 AM M@ @.**> wrote: Tracking down why my apps suddenly stopped doing host matching properly, and stumbled onto this. Seems like a big backward-breaking change for a minor release. At the very least, when the .Host() contains just a host, and not a port, then hostname: should be assumed, I'd think. \u2014 You are receiving this because you modified the open/close state. Reply to this email directly, view it on GitHub <#383 (comment)>, or mute the thread https://github.com/notifications/unsubscribe-auth/AABIcBssUbxHGPjewAPXr-5-Vk1l1Eclks5vMwgagaJpZM4UQJkz .\n\n. ",
    "santsai": "@elithrar Do you mean to update the .Schemes() comment or to do it only when some flag is enabled?. The section covering Host header is here https://tools.ietf.org/html/rfc2616#section-14.23\nI understood your concern about breaking changes, however it's strange for getHost() to have different behaviour for host from abs url (requires \"host:port\" in non-80 port case for .Host() to match)  and host from header (requires \"host\" and no port for non-80 port). In the later case, if one build a url from such route, the resulting url would also be wrong since the port number would be missing.\nthe abs url behaviour is covered by existing test case: https://github.com/gorilla/mux/blob/e0b5abaaae35242fa74372f26c24107711702a4e/mux_test.go#L80-L88\nthe host from header behaviour is marked as bug in a test case:\nhttps://github.com/gorilla/mux/blob/e0b5abaaae35242fa74372f26c24107711702a4e/mux_test.go#L116. ",
    "pzillmann": "What features I use most\n\nI name my routes so a worker can run a function according to that name in a function register\nI check for Authentication Headers\nI use Regex to serve static files when using no proxy\n\nI'm sometimes confused between the difference of Route vs. Router. ",
    "matejkramny": "We use a lot of subrouter and middleware functions. Also sort of intermediate middleware, example route below:\nr.Handle(\"/my-route\", myMw(myHandler))).Methods(\"GET\", \"HEAD\")\nIdeally it would be something like\nr.Get(\"/my-route\", myMw, myHandler)\n    // or\n    r.HandleFunc(\"/my-route\", myMw, myHandler).Methods(\"GET\", \"HEAD\")\nI should note we use a wrapper for mux (https://github.com/castawaylabs/mulekick) for readability. Aha, sorry. The reason I'm tracking the addresses is that the context package uses them (here) to store context data.\nIn my effort to find and recover some data from the (logging) middleware it would need to keep the same address.\nIt makes sense that if mux uses WithContext, then the gorilla/context package won't work with it. I will look into removing gorilla/context in favour of the new way.\nPS: since WithContext is passed down the middleware chain, it won't be possible for any middleware at the top to find something like user ID being stored in middleware that happens afterwards. Is there any good way to do this?\nMany thanks!. Many thanks. ",
    "jwilner": "Hi -- I'd like to chime in as a many-time user and one-time contributor to mux and maybe revitalize this convo, which I think is important! \nI very much think there is a space for a new v2 gorilla mux. I think that the API has gotten to a place where it tries to be all things to all people and that can both increase the complexity of use and implementation. To me, I think it makes sense that mux coordinate on http.Handler and http.HandlerFunc are good ideas, and more generally that it aim to be the easiest router to adopt when you step out of the stdlib for dynamic routing.  I think a lot of the current accessories that go beyond path and method -- scheme, host, header matching -- get away from that goal, are comparatively unused, and introduce a whole ton of complexity to the internal logic. I also would argue that the subrouter concept is more powerful simply as an unfinished route builder. I would argue for a course would be to aim for a V2 which provides breaks support for the more ancillary options, while keeping the core ones. \nAs a general API, I think mux should have a core Router which embeds\u00a0some sort of zero'd RouteBuilder, the RouteBuilder be treated as an immutable value builder for chaining, and the chain always end with a Handle(METHOD, handler) or a HandleFunc(METHOD, handleFunc), which are the only actions which actually mutate the core router.  \nSpitballing the interface:\n```go\nfunc New() Router {\n     ...\n}\ntype Router interface {\n       RouteBuilder\n      // maybe some shortcuts permitting common use cases\n       http.Handler\n}\ntype RouteBuilder interface {\n       // maybe some other things, always returning RouteBuilder though\n       Path(path string) RouteBuilder\n       Middleware(mw Middleware) RouteBuilder\n   Handle(method string, handler http.Handler)\n   HandleFunc(method string, f func(http.ResponseWriter, *http.Request))\n\n}\n```\nE.g.\ngo\nr := v2.NewRouter()\n// bar is a RouteBuilder and the conceptual replacement for a \"subrouter\"\nbar := r.Path(\"/foo/bar\") \n// bar value remains unchanged -- barID is a qualified version of it\nbarID := bar.Path(\"/{bar_id}\")  \n// Handle (or HandleFunc) always terminates a RouteBuilder; handling methods at the end is consistent\n// with the RESTful notion of resources IMO -- you build the URI to a resource and then define various \n// operations (methods) on it.\nbarID.Handle(http.MethodGet, barReadHandler)\nbarID.HandleFunc(http.MethodPut, barUpdateHandler.ServeHTTP)\nbar.Handle(http.MethodPost, barCreateHandler)\nEquivalently:\ngo\nr := v2.NewRouter()\nr.Path(\"/foo/bar\").Handle(http.MethodPost, barReadHandler)\nr.Path(\"/foo/bar\").Path(\"/{bar_id}\").Handle(http.MethodGet, barReadHandler)\nr.Path(\"/foo/bar\").Path(\"/{bar_id}\").HandleFunc(http.MethodPut, barUpdateHandler.ServeHTTP)\nResulting routes:\nPOST /foo/bar\nGET /foo/bar/{bar_id}\nPUT /foo/bar/{bar_id}\nEach route chain method would have clearly defined compositional behavior. E.g.:\ngo\nr.Path(\"/foo\").Path(\"/bar\") // r.Path(\"/foo/bar\")\nr.Middleware(f).Middleware(g) // r.Middleware(f(g))\nBest of all, this would be relatively simple to implement.\n```go\nfunc New() Router {\n        r := &router{trie: make(trie) / or whatever /}\n        r.RouteBuilder = routeBuilder{router: r}\n        return r\n}\ntype router {\n        RouteBuilder\n        trie\n}\ntype routeBuilder struct {\n        router *router\n        path string\n        // other stuff\n}\n// note no pointer receivers! this is key\nfunc (rb routeBuilder) Path(p string) RouteBuilder {\n        rb.path += p\n        return rb\n}\nfunc (rb routeBuilder) Handle(string method, handler http.Handler) {\n        if rb.middleware {\n                 handler = rb.middleware(handler)\n        }\n        rb.router.trie.insert(method, rb.path, handler)\n}\n```\nEnded up writing more than I intended, but I hope this is helpful.\nPS to the degree that it's important to keep host, header, etc matching, I'd encourage having a general purpose:\ngo\nfunc (rb routeBuilder) MatchFunc(mf MatchFunc) RouteBuilder {\n         rb.matchFuncs = append(rb.matchFuncs, mf)\n         return rb\n}\nWith orthogonal helper methods:\ngo\nfunc HeaderMatcher(headers ...string) MatchFunc {\n    ...\n}. Sure, @elithrar. I've pushed some further clean up of obsolete parentRoute stuff. My notes would be:\n\nRoute matching\u00a0configured via Methods, Schemes, or Headers now carries through Subrouters to \"subroutes,\" just as path and host matching does.\nGetPathTemplate always returns the path template through to the root router, whereas previously it sometimes returned an empty string.\n\nTwo edge-casey things that would only affect users chaining successive calls of methods:\n- Successive calls to BuildVarsFunc are now always composed, whereas previously newer ones might have overridden older ones (after a subrouter). In pseudocode, BuildVarsFunc(f).BuildVarsFunc(g) == m => g(f(m)) whereas previously BuildVarsFunc(f).BuildVarsFunc(g) == g.\n- Built URLs now always use the first scheme argument from the latest invocation of Schemes,  rather than preferring the first argument of the first invocation on a subroute. In other words, now Schemes(\"https\").Schemes(\"http\") will use \"http\" for building URLs, while previously it would've used \"https\" (note matching is broken in this scenario anyway since you can never satisfy both predicates).. @kisielk glad it seems helpful. I did a little cursory review of the middleware issue (#378) and I don't think this solves it unfortunately. I intend to look at it more deeply though and have some ideas. . No worries, glad it was helpful!\nOn Fri, Dec 7, 2018 at 10:49 AM Matt Silverlock notifications@github.com\nwrote:\n\nHuge thanks for this @jwilner https://github.com/jwilner, and apologies\nfor the delay in reviewing (been travelling for work!).\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/gorilla/mux/pull/422#issuecomment-445273819, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AByubeR4tZmkWg1up70fJJpWB26T7Xxrks5u2o36gaJpZM4Yxqgx\n.\n. Definitely, good thinking. \n",
    "ajay-aravind": "package http_muxer\nimport (\n    \"log\"\n    \"net/http\"\n\"github.com/gorilla/mux\"\n\n)\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/\", HomeHandler)\n    // r.HandleFunc(\"/products\", ProductsHandler)\n    // r.HandleFunc(\"/articles\", ArticlesHandler)\n    http.Handle(\"/\", r)\n    log.Fatal(http.ListenAndServe(\":8000\", r))\n}\nfunc HomeHandler(w http.ResponseWriter, request *http.Request) {\n    w.Write([]byte(\"Got request on /\"))\n}\n// func ProductsHandler(responce http.ResponseWriter, request http.Request) {\n//  responce.Write([]byte(\"Got a request on /products\"))\n// }\n// func ArticlesHandler(responce http.ResponseWriter, request http.Request) {\n//  responce.Write([]byte(\"Got a request on /articles\"))\n// }\n. ",
    "fstanis": "Sure, created #390 for a quick minimal test, seems to failing (as expected).. ",
    "flibustenet": "Actually gorilla/context is required. \nI think it will be more explicit to update go.mod to reflect this now with a require github.com/gorilla/context, then release the last mux that require it and then remove it in this PR.. I was just thinking of the historical side. We could see it was required and not after. But the changelog is ok also, nothing more.... ",
    "zhyq0826": "I will have a try. It may take more time to fix it. . @elithrar  I have tried to trace this problem today and found that it seems that  #378  has fix it. The reason for this problem is that when in subRouter has not found matched route, then match.MatchErr = ErrNotFound\uff0cthen later in other subRouter\uff0cthe check : \ngo\nif match.MatchErr == nil {\n    for i := len(r.middlewares) - 1; i >= 0; i-- {\n        match.Handler = r.middlewares[i].Middleware(match.Handler)\n    }\n}\nwill fail.. ",
    "bestform": "I am experiencing the same problem. I tried the proposed changes in #378 and they did indeed fix it for me.. There is a merged PR in the context of this whole problem. I will try with the changes of #422 and see if this fixes my issue and close it if it does. . ",
    "rishubhjain": "@elithrar I was running curl -X POST url , but I  tried curl -sv url, still getting empty output.. @elithrar Thanks, problem solved. ",
    "KimMachineGun": "Thank you for your fast answer.\nBut, I think that useless condition check and call empty body function are unnecessary.\nI hope that they are removed on next release. \ud83d\ude04 . ",
    "TheImpressionist": "Alright, scratch this. Apparently the deployed server just refused connections itself. Had to be reconfigured.. ",
    "olliephillips": "Hello yes:\n1) I'm testing local and server from the browser. There's a domain pointing at the server, and locally I'm using localhost and a domain configured in /etc/hosts\n2) There is no difference in terms of how they run, aside for the fact binary is cross compiled for Ubuntu before I transfer it to the server. I am running as a service, but I've also tested by running the binary directly.. Thanks, I had it, but was going to dump the entire request object.\nBelow just output requested:\nLocal:\nurl=/ host=localhost:8081 method=GET\nRemote:\nurl=/ host=fly2buy.co.uk:8081 method=GET\n. Hey, is this something I need to act on, or can help with?. I can take a look at this issue myself once I'm clear of my project if that helps? For the moment, I've reverted to parsing r.Host for the domain. No big deal.. ",
    "jbowen93": "Scrolling through old threads it seems like the suggested workaround is to use the gorilla/handlers methodHandler. This is what I've done as it gets the jobs done (on a deadline I'm afraid). I'll keep this in mind but don't have a lot of free time right now. Thanks for elaborating on logic. . ",
    "akkelw": "\nTo confirm, both Windows & Debian have the same version of mux?\n\nCorrect. Both of them use the same version of mux.\n\nIs the only change you make here to replace mux.Router with\nhttp.ServeMux? (I want to be precise/clear): This one is a bit tricky. When using net/http I don't have to pass the route like so r *mux.Router in SetRoute() - this is the middleware package for that use case link - and as seen in the pastebin my old middleware did things a bit differently. My current middleware package used for mux are only those two functions in the issue.\nAre you sure the Apache server is hitting the Go backend at all?: I'm sure. I tried running the application without Apache, on a different non-related (but still open and valid) port, and it refused my connection.\n- The only case where Go returns a HTTP 503 is in\nhttps://github.com/golang/go/blob/77c575d2e2cc320b62cbbdefbc6840a8cff2163c/src/net/http/server.go#L3135-L3180: It's not Go returning HTTP 503, that is the default response from Apache when my server is not up and listening to the webserver port.\nin the timeout handling part. If you remove the timeouts, or increase them, does the problem persist?: The problem persists if I remove them or increase the value.\n\nI'm going to see if I can try it out on a different distro/server later, that way we can exclude if there's something wrong with the actual code or if it's due to improper server configuration from my part.. My Windows firewall logs are sending and receiving. When telnet'ing the Go service running on Linux it throws Unable to connect to remote host: Connection refused.\nJust to be clear here, the port is open, I'm 100% sure of that.. tcp        0      0 127.0.0.1:8080         0.0.0.0:*               LISTEN      32622/./app\nIt's listening.. Okay I managed to solve it. The issue was that specifying the host AND the port in http.Server would mess it up. By only specifying the port :8080 I got it to run. Thanks for the help!. ",
    "xemul": "The issue was, well, unexpected and confusing (by me) behavior when an URL \"looks correct from the first sight\". Confusing, because no client's part reported any error, but the overall system didn't work properly, as the server-side object was not updated. The expected was either another automatic PUT or some code that would propagate back to client as an error (letting me fix the URL string).\nBut since this all conforms to standards, I'm OK with just using the proposed middleware and change error to 307/308, thank you!. ",
    "kanozec": "I think I can take this, but I'm not familiar with the go test. I just have some practice before.\nCould you give me some advice for which test file to refactor first.\nI think that would be really helpful, thx.. Seems only if the route path is matched, the middleware handler will be executed.\nFor those not matched path, you  should customize your \"NotFoundHandler\" to do something.. ",
    "pierrre": "This issue is still valid.. resolved in https://github.com/gorilla/mux/releases/tag/v1.7\nThank you ! :+1:. ",
    "dhui": "Could you re-tag as v1.7.0 since SemVer requires all versions (major, minor, and patch) to be specified?. ",
    "s4t13": "It makes sense. But instead of having a 404, handler is still called at the end of the line, without passing through middleware.. ",
    "Sterd": "Definitely a bug. I think this return true: https://github.com/gorilla/mux/blob/master/mux.go#L93 should be one row up.. ",
    "janisz": "Can you show me example how to do it? I'd like to log 404 and 405 errors too. ",
    "lavoiesl": "Very good point. It\u2019s confusing because the ErrMethodMismatch logic is inverted.\nI added an exception and a test for it.\n~It would probably be cleaner to move the allowed methods to a dedicated property, but this seems good enough for now.~ Just tested it, doesn't work either. This solution seems like the best compromise.. As I said, I couldn't find a proper solution with a dedicated property that was working. It might take a more significant refactoring.\nI had a very real bug related to this that took me a shameful amount of time to diagnose. I propose merging this as is, considering it works for the new test case without introducing a known regression, and revisit later.. Your points are valid, I think I found a solution that tackles everything at once: https://github.com/gorilla/mux/pull/418. @kisielk @elithrar Would you like more information about this patch?. No worries, ping me if you want more info on my thought process.. Yes, your understanding is correct. Same goes for the NotFoundHandler.. The table is pretty simple, so I went for a long form explanation with an example.. All good. Anything else required here?. I tried several alternative ways, but the way the code is structured doesn't lend well to what @elithrar is asking, I couldn't find a way without very significantly rearchitecting the matching mechanisms. I already spent close to 8 hours on this and cannot afford more.\nTherefore, I\u2019m abandoning this PR for the time being.\nI still very much want it and will continue to use my patch for now on, but I fear I will have to switch router at some point.. Good catch. ",
    "or-else": "Thanks!\nI can sure find a workaround, the simplest being just to make sure all URLs have a trailing slash. \nIt's that I just killed half a day trying to figure out why Android clients can't upload.\nAnd the possible fix on Gorilla's side seems to be so trivial.. ",
    "drum445": "This would be a nice change, would mean I can delete my clunky middleware I am using currently. There were compatibility issues with the new http codes, but I think that is a thing of the past . ",
    "tsuna": "There is no mention of this bugfix in the 1.7.0 changelog. I think it's worth mentioning because it fixes a bug that will make some user code more restrictive.  For example we have some code that does:\ngo\n  mux.NewRouter().Host(\"{customerId:[0-9]*}{dot:[.]?}example.com{hostPort:[:0-9]*}\").Subrouter().StrictSlash(true).UseEncodedPath()\nBefore this change, the host matcher wasn't copied into the subrouter.  This meant that a request to wrong.com would pass the matchers but would fail to extract the var customerId, but would still be passed on to the user handler code anyway.  With this change the request no longer passes the host matcher and gets a 404 instead of going to the user handler.  To be clear, I think the new behavior is the correct one, but I'm just saying this deserves a mention in the release note as it was quite a head scratcher for me to figure out why after upgrading to 1.7.0 some tests weren't matching any route anymore.. In my case I had requests coming from an internal service that was using a different hostname, so I needed to change the .Host(..) call to .Host({customerId:[0-9]*}{dot:[.]?}{domain:internal-name|example.com}{hostPort:[:0-9]*}\") because before v1.7.0 requests coming in with Host: internal-name were incorrectly passed through, while with v1.7.0 this bug has been fixed and the request will 404.. ",
    "trtg": "Yup, sorry about that. ",
    "andrewpillar": "Hey, how much progress have you made with this?\nI've got a project, flump, that has TLS implemented with an HTTP -> HTTPS redirect handler, if TLS has been configured. You can see the logic of it in the handler/redirect.go file, and the listeners getting configured in the main.go file too.\nI would like to help with documenting some of this. Would some of the code that I have written be good enough examples for the self-signed certificates, specifically the secure redirect handler, and the concurrent listeners, provided I clean up the code a bit, and make it less specific to my use-case?\nIs there also a typical structure to the documentation that should be adhered to when written, and submitted?. Ok, I've forked the repository, and documented how certmagic integration can be achieved. Added a section to the README.md detailing how concurrent HTTP/HTTPS listeners can be setup using certmagic for a graceful shutdown.\nWasn't able to get around to figuring out/documenting how mkcert could be used for local development though.\nAlso provided additional links in the section I added to some of the Let's Encrypt documentation, if that may be of use to people.\nThe example I've provided is good enough to run on any server, provided you change example.com to the necessary domain name that points to the server. If this looks good for the public certs aspect of the documentation then I'll open up a PR.. ",
    "elycruz": "Issue not relevant - Errors for Queries being returned  as part of Route (Route.err) (closing issue).. ",
    "maplebed": "I came here with my own version of middleware not getting run.\nMy example has instructions up at https://github.com/maplebed/gorilla-mux-routing-example/tree/middleware_bug and the code to be run at https://github.com/maplebed/gorilla-mux-routing-example/tree/middleware_bug/main.go\nMy problem feels a little different from those others described here but it's close enough I'm putting it in this same bug in case it is the same.\ncurl to localhost/8080/s1/hello triggers all expected middleware (mroot and m1)\ncurl to localhost:8080/s2/hello and /s3/hello triggers no middleware (neither mroot nor m2/m3)\ncurl the same paths on localhost:8081 and all middleware gets executed every time.\nI am running against git hash 6137e193cdcba2725f16de84eaf0db2b769d9668 of gorilla/mux (that's the version checked out in my gopath) and go version go1.11.4 darwin/amd64. After applying the patch that @tomare suggested, middleware runs as expected in my example. In other words, I see middleware executed for all expected queries on both ports 8080 and 8081, whereas before they only matched on the curl against port 8081.\nHere's the patch as I applied it:\n```diff\n:) (12/20/18T10:39) ~/hound/goroot/src/github.com/gorilla/mux@master\u2717 \u2739\n\u279c  git patch\ndiff --git a/route.go b/route.go\nindex acef919..022be5e 100644\n--- a/route.go\n+++ b/route.go\n@@ -57,8 +57,8 @@ func (r Route) Match(req http.Request, match *RouteMatch) bool {\n                }\n        }\n\nmatch.MatchErr = matchErr\n        if matchErr != nil {\nmatch.MatchErr = matchErr\n                return false\n        }\n```. hrmph. other tests fail with this change.. I clearly don't understand how errors are supposed to move... This is part of one of the tests that's failing: https://github.com/gorilla/mux/blob/master/mux_test.go#L2076-L2086:\n\ngo\n    // Test the subrouter first\n    match = new(RouteMatch)\n    matched = s.Match(req, match)\n    // Now we should get a match\n    if !matched {\n        t.Errorf(\"Subrouter should have matched %s\", req.RequestURI)\n    }\n    // But MatchErr should be set to ErrNotFound anyway\n    if match.MatchErr != ErrNotFound {\n        t.Errorf(\"Expected ErrNotFound MatchErr, but was %v\", match.MatchErr)\n    }\nIt is asserting there should be a match and that match.MatchErr should be ErrNotFound even when there was a match. grumps.. closing in favor of PR #431 . \ud83d\udc9a thank you for this patch.. ::bump:: I'd really love to see this merged. Is the only thing we're waiting on a small addition to the test (to add a third non-matching route)?. I have discovered via the next experiment that any variables set by the router prior to handing off to the disconnected router will get masked by the disconnected router. I'm sorry, this is confusing to try and write out, but it's visible on this branch: https://github.com/maplebed/gorilla-mux-routing-example/tree/discon_mux_context\nThe setup it is testing imagines a root mux that branches in to a private and public mux then comes back together in the main mux, where all the actual handlers are defined. The private and public muxers are split based on the host header, which is captured as hostvar. \nSending curl -H \"Host: private\" localhost:8080/public/e1 will print the value of mux.Vars(r)[\"hostvar\"] at each middleware and then the full context once it hits the handler.\nYou can see from the output that the root middleware can resolve the hostvar variable to its value \"public\", as can the public mux. But once it hits the main mux, the hostvar element of mux.Vars is empty. \n\u279c  go run main.go\nINFO[0000] launching example app\nINFO[0001] starting mRoot\nINFO[0001] at middleware root hostvar contents           hostvar=private\nINFO[0001] starting mPriv\nINFO[0001] at middleware priv hostvar contents           hostvar=private\nINFO[0001] starting mMain\nINFO[0001] at middleware main hostvar contents           hostvar=\nINFO[0001] starting e1\nLooking at the full context dump, it is clear that there are two copies of the internal gorilla data structure, and that the one added in the main router (added last) is masking the earlier copy (added by the root router).\n\nThis doesn't surprise me terribly, and makes me lean towards categorizing this method of chaining routers together in a DAG as \"unsupported; some feature loss\". I would love to see an improvement where a router could avoid adding its own data structure when one already exists in the request's context, but I could also imagine there being all sorts of traps hiding there.\nStill curious what other people think about\n using a DAG of routers in the first place\n whether or how to support that design using gorilla/mux. ",
    "tomare": "I have similar issue, and I find something in Route.Match is weird .\nAnd I changed the source code fixed this issue.\n` \n func (r Route) Match(req http.Request, match *RouteMatch) bool {\n    if r.buildOnly || r.err != nil {\n        return false\n    }\nvar matchErr error\n\n// Match everything.\nfor _, m := range r.matchers {\n    if matched := m.Match(req, match); !matched {\n        if _, ok := m.(methodMatcher); ok {\n            matchErr = ErrMethodMismatch\n            continue\n        }\n        matchErr = nil\n        return false\n    }\n}\n\n    //Here match.MatchErr is not nil, and matchErr is nil\n    match.MatchErr = matchErr\nif matchErr != nil {\n    match.MatchErr = matchErr\n    return false\n}\n\n\nif match.MatchErr == ErrMethodMismatch {\n    // We found a route which matches request method, clear MatchErr\n    match.MatchErr = nil\n    // Then override the mis-matched handler\n    match.Handler = r.handler\n}\n\n// Yay, we have a match. Let's collect some info about it.\nif match.Route == nil {\n    match.Route = r\n}\nif match.Handler == nil {\n    match.Handler = r.handler\n}\nif match.Vars == nil {\n    match.Vars = make(map[string]string)\n}\n\n// Set variables.\nif r.regexp != nil {\n    r.regexp.setMatch(req, match, r)\n}\nreturn true\n\n}\n`. ```\npackage main\nimport (\n    \"github.com/gorilla/mux\"\n    \"log\"\n    \"net/http\"\n)\nfunc MiddleA(next http.Handler) http.Handler  {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\"In Middle A\")\n        next.ServeHTTP(w, r)\n    })\n}\nfunc MiddleB(next http.Handler) http.Handler  {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\"In Middle B\")\n        next.ServeHTTP(w, r)\n    })\n}\nfunc MiddleC(next http.Handler) http.Handler  {\nreturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    route := mux.CurrentRoute(r)\n    log.Println(\"In Middle C, route name=\", route.GetName())\n    next.ServeHTTP(w, r)\n})\n\n}\nfunc APIA(w http.ResponseWriter, r *http.Request)  {\n    w.Write([]byte(\"I'm A\"))\n}\nfunc APIB(w http.ResponseWriter, r *http.Request)  {\n    w.Write([]byte(\"I'm B\"))\n}\nfunc APIC(w http.ResponseWriter, r *http.Request)  {\n    w.Write([]byte(\"I'm C\"))\n}\nfunc APID(w http.ResponseWriter, r *http.Request)  {\n    w.Write([]byte(\"I'm D\"))\n}\nfunc main()  {\nrouterA := mux.NewRouter()\n\n\n\nfreeRouter := routerA.PathPrefix(\"/\").Subrouter()\n\nlimitRouter := routerA.PathPrefix(\"/\").Subrouter()\n\n\n\nfreeRouter.HandleFunc(\"/a\", APIA).Name(\"FreeA\").GetError()\n\nfreeRouter.HandleFunc(\"/d\", APID).Name(\"FreeD\").GetError()\n\nlimitRouter.HandleFunc(\"/b\", APIB).Name(\"LimitB\").GetError()\n\n\n\nfreeRouter.Use(MiddleA)\n\nlimitRouter.Use(MiddleB)\n\n\nrouterA.HandleFunc(\"/c\", APIC).Name(\"HomeC\")\n\n\nhttp.ListenAndServe(\":9999\", routerA)\n\n}\n```\n1. If I visite \"localhost:9999/a\" will apply the Middleware A\n2. But If I visite \"localhost:9999/b\" Middleware B will not be applied\nwith the fix in function Route.Match  case 2 works. \ngo version  is go1.11.2\nmux version is  latest.\n. match.MatchErr was contaminated in loop.\neven the route matched but match.MatchErr will not be reseted. Condition:\n1. one route has more than 2 subrouters.\n2. bind middleware for each subrouter.\n3. the request matches the second subrouter.\nIssue and reason:\nIn function func (r *Router) Match(req *http.Request, match *RouteMatch) bool\na. search for all route (r.routes)\nb. share the match\nc. after calling match for the first subrouter, the match.MatchErr will be set to no matching route was found, and then goes to the second subrouter.\nd. if second subrouter was matched, then in function func (r *Route) Match(...), the match.MatchErr is not nil, and will not be set to nil. and Match return true. but the mat.MatchErr is not nil\ne.  then the middleware of second subrouter will not be applied.\nFix:\nreset the match.MatchErr before check the match. because share the match object for route, if we have multi subrouters in one route, the MatchErr will be  contaminated by the previous subrouter.. > I don't see this in master branch. When will this be released? How do I go get it?\nIt was released and changed on later commit.. > @tomare - Sorry, can you provide more info? Why was it changed? Is there an associated issue, so I can read up on it?\nyou can check out on this commit. \nhttps://github.com/gorilla/mux/commit/08e7f807d38d6a870193019bb439056118661505. ",
    "kaihendry": "I just want to be able to see their journey through the routes of the application.\n\n/\n/about\n/bus/id?=12345\n/bus/id?=41323\n/contact\n\nWithout using JS. I think the easiest way to do that, is logging a cookie id in the middleware somehow.\n. Just a thought: Another reason why I would want to use this, is the individually track a user who has his IP changing or something like that.\nI think I've found the way to do it. Be good if you could review the code and perhaps publish it as an example?\nhttps://play.golang.org/p/2jwrUKnAOvH. ",
    "g-w": "I will have a look into this and try to provide a PR. . @elithrar I've created a PR #438. . In this case no route should match and https://github.com/gorilla/mux/blob/master/mux.go#L167 should be reached. This sets MatchErr to ErrNotFound.\nI've checked this through this test:\n```\nfunc TestMethodSubrouterNotFound(t testing.T) {\n    handler := func(w http.ResponseWriter, r http.Request) { w.WriteHeader(http.StatusOK) }\n    router := NewRouter()\n    router.Path(\"/a\").Subrouter().HandleFunc(\"/thing\", handler).Methods(http.MethodGet)\n    router.Path(\"/b\").Subrouter().HandleFunc(\"/something\", handler).Methods(http.MethodGet)\nw := NewRecorder()\nreq := newRequest(http.MethodPut, \"/not-present\")\n\nrouter.ServeHTTP(w, req)\n\nif w.Code != 404 {\n    t.Fatalf(\"Expected status code 404 (got %d)\", w.Code)\n}\n\n}\n```\nIf you think it useful, I will add it to my PR.\nBTW: This fixes #437. I've added the test.. ",
    "ellismg": "I actually looked into this a little bit as well, I think a problem could be in func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)\nI believe that the mutation of Path on url.Url invalidates whatever was in .RawPath meaning that it will be ignored u.String() is called to generate the URL for the redirect, since it is no longer a valid encoding of what is in Path.. ",
    "ssmails": "@elithrar  Cannot pass promhttp.Handler() directly . instead of wrapping it in MetricsGetHandler, because of the requirement that router.HandleFunc(), should be a function that must implement (w http.ResponseWriter, r *http.Request)\nrouter.HandleFunc(\"/metrics\", MetricsGetHandler).Methods(\"GET\")\nError-\ncannot use promhttp.Handler() (type http.Handler) as type func(http.ResponseWriter, *http.Request) in argument to router.HandleFunc. ",
    "BlakeMScurr": "Hi Gorilla team and mux contributers,\n@BlakeMScurr from CodeLingo here. This PR is testing out a new service. I'd love to hear your feedback or answer your questions. We're keen to learn how we can best help dev teams without getting in your way.\n@BlakeMScurr & the CodeLingo Team. @kisielk Yeah fair enough. We'll update our tenet (rule for generating rewrites) accordingly \ud83d\udc4d\nLooks like we have only updated test files in your project so feel free to close the PR.. ",
    "yogo1212": "works for me. ",
    "zekth": "I will look forward on it. Maybe if i find something usefull and revelant for this case do i submit a PR?. I was meaning as an example for the documentation.. ",
    "nanmu42": "Got the same problem. Just see that from README.md:\n\nRoutes are tested in the order they were added to the router. If two routes match, the first one wins.\n\nI do hope this sentence be emphasized, though. :rofl:  . ",
    "peterbourgon": "Nevermind, I've brain farted on how context propagation works. What I want to do isn't possible with this set of features from mux, I don't think, but it's simple enough to build something that will work.. ",
    "seriousben": "Working on a PR right now.. The go vet issue is fixed in https://github.com/gorilla/mux/pull/458. Good news. gorilla/mux works in go1.12 \ud83c\udf89 . This PR will fix https://github.com/gorilla/mux/pull/457. ",
    "Sapphire64": "@elithrar yeah, especially I understand you now even more than when I made this PR, this particular code is not compatible much with https://github.com/gorilla/handlers/blob/master/cors.go and is not solving any CORS challenges. It probably needs to be integrated into gorilla/handlers code or just removed completely. Linked code does OPTIONS call handling too.. ",
    "lianzeng": "@elithrar \nThanks  for your quick reply, i'm going to use Mux. it's really powerful and easy to understand.. ",
    "awly": "Does it really make sense to report this as a match?\nhttp://play.golang.org/p/SIL-WWftyQ\nSeems confusing when request didn't match any real route but router.Match reports true.\nFWIW I got a panic in my stats collection code which assumed that if router.Match(...) == true, returned RouteMatch would have a non-nil Route.\n. Or add a flag to RouteMatch that says \"this is a not-found handler, not an actual route match\".\nOr add a non-exported matchHandler() that does the regular Match behavior or returns NotFoundHandler if it's set.\nI did not dig into the implementation of this package enough to come up with an actual valid suggestion, simply complaining :)\nIt basically feels like this is mixing up internal implementation details and exported API in a way that makes exported API unintuitive.\n. ",
    "christian-blades-cb": "This handles URLs in the form scheme://host/path?query and scheme://host/path?query#fragment, but not scheme://host/path#fragment. \n. ",
    "wirehead": "Good point.  I'll fix that. :)\n. ",
    "dgellow": "Hi there. I can see that the online documentation has the *vX.Y.Z*. Also the link [Router](...) hasn't been converted to HTML.\n\n. Cool, thanks guys :). "
}