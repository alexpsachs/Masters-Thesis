{
    "raphw": "Hi Jonathan,\nyou are defining a package-private class org.modelmapper.FooTest.Foo for which you define a default-package subclass FooBar.Foo. This latter class cannot access its super class. Therefore, you need to either define the subclass to be in the same package as its super class or you need to change the visibility of the super class to public. The naming strategy is supposed to create a fully qualified name.\nThank you for using Byte Buddy! You are somewhat an early adopter and I hope to improve this behavior in later versions. A future version of Byte Buddy will definitely come with an (optional) validator that will throw an appropriate exception. Today's version does not yet catch all validation errors with a detailed error message because this validation generates some run time overhead.\nAlso note that I am planing to release a version 0.2 of Byte Buddy in only a couple of weeks. It comes with several bug fixes, some new functionality to better support Java 8 and improved support for creating proxy classes.\nBest regards, Rafael\n. Java is a quite tricky language when it comes to package-private access. Package-private access is also rather an invention for being used by compilers rather then by users since they have strange semantics. \nYou might have heard before that two classes are only consider equal by the Java run time if they were loaded with the same class loader even if they otherwise represent an identical class. The same is true for Java packages. If a class is loaded with a different class loader, it cannot get private-package access to any classes (or class members) that belong to another class loader.\nThe injection strategy uses reflection to load a class into a given class loader. The wrapper class loader on the other hand, creates a new child class loader for loading a given class. The former strategy is more efficient since a class loader is a rather expensive object to Java (takes about 70 nanoseconds to create it in my benchmarks). However, it does not need to call internal methods. Also, the wrapper class loader allows the unloading of the generated class if none of its instances and its class and class loader are not longer reachable. This is handy when creating classes that are only needed for a limited amount of time such as in bootstrap procedures. One specific use case of this strategy would be mocking for example as for creating type safe DSLs. This allows to keep the perm gen requirements of an application down as the injector strategy often targets the system class loader what makes loaded classes invincible for the application's life time.\nThe injector strategy is equivalent to Javassist and cglib's approaches.\n. I thought about predefining such a strategy for Byte Buddy 0.2. However, this would require you to resolve any invokable method of a class in order to check if any of those methods is package-private relatively to the generated class in order to determine its necessity. Such reflective look-ups are unfortunately expensive. I might still just add the strategy and add an explicit warning of its costs.\n. As for private constructors, there is no possibility to add them as they could not call their private super constructor equivalent. Private members are not visible even to their sub types. I think, cglib and javassist do not add private constructors to their proxy types.\nAs for package-private members, it depends. A package-private super constructor could only be called if the defined class was defined in the same package as its super class. This cannot be assured at the point the constructor strategy is applied. I will however add another strategy in version 0.2 that allows for adding package-private members on demand. For now, implementing the strategy is however quite straight-forward:\n```\nenum MyConstrutorStrategy implements ConstructorStrategy {\n@Override\n  public MethodList extractConstructors(TypeDescription superType) {\n    return superType.getDeclaredMethods().filter(not(isPrivate()));\n  }\n@Override\n  public MethodRegistry inject(MethodRegistry methodRegistry,\n                                               MethodAttributeAppender.Factory defaultMethodAttributeAppenderFactory) {\n  return methodRegistry.append(new MethodRegistry.LatentMethodMatcher.Simple(isConstructor()),\n    SuperMethodCall.INSTANCE,\n    defaultMethodAttributeAppenderFactory);\n  }\n}\n```\nAre you using code generation for creating proxies of random types? You should really consider using a library such as objenesis for construction and use the NO. When dealing with package-private classes, you cannot assure that there is a package-private constructor available that you can call. The Java compiler normally adds an additional synthetic constructor to the class that takes an additional synthetic class as its argument to distinguish itself from the normal constructor. You would have to resolve this bridge if you wanted to construct an instance of such a class.\n. All right, after looking into the matter, I reworked the ConstructorStrategy to only be applied after the type definition phase is finalized. I ran some benchmarks and it does not create any overhead to delay the application to this later phase such that the constructor strategy can be applied to a fully defined type. This way, ConstructorStrategy.Default.IMITATE_SUPER_TYPE creates package-private constructors if they are visible. Private constructors are never copied as they are not invokable from their sub type. This resembles the behavior of cglib and javassist. The change will be included in Byte Buddy 0.2 which should be released some time in June 2014. Thanks for your feedback!\n. I would not be too concerned about using the Unsafe class. As of today, there are too many libraries built around this class that a new JVM implementation would probably always chose to also offer this class. There is a bigger chance of your users encountering issues with side effects of constructor definitions as with objenesis not being compatible to an exotic JVM implementation.\n. This is implemented from Byte Buddy, version 0.2.\n. This is absolutely possible. In general, you are able to create any possible Java class by using the exposed ASM-API. However, for your example, you can even use the ASM wrapper classes that already ship with Byte Buddy to implement this.\nPlease see my answer on StackOverflow (http://stackoverflow.com/questions/24711172/how-in-java-to-assign-to-fields-with-byte-buddy/24735122#24735122) for how to implement this with Byte Buddy.\n. It looks like you are trying to find a method named a in the Object class:\njava\nTypeDescription.ForLoadedType(Object.class)\n  .getDeclaredMethods()\n  .filter(isMethod(). and(named(name)). and(takesArguments(0)). and(returns(int.class)))\n  .getOnly();\nThe Object class does however not define any method named a. Rather check instrumentationTarget.getTypeDescription() for the method which you defined for your newly defined type (the instrumentation target's type).\n. The DynamicType interface already supports access to a byte[] array that represents the type which can be directly consumed by a OutputStream. \n. Agree, Byte Buddy v0.3 is released in 2-3 weeks and I'll integrate OSGI with this new version. Is this early enough for your needs?\n. I do not have a lot of OSGI experience and I cannot use the maven-bundle-plugin as it does not play nicely with the maven-shade-plugin. I had to put the OSGI entries into the manifest using the shade plugin. Could you do me a favor and run:\ngit clone https://github.com/raphw/byte-buddy.git\ncd byte-buddy\nmvn install -Pextras\nand check if this looks okay? Thanks!\n. I tried to recreate this problem, but I cannot find out what goes wrong when you build. I doubt that it is related to the JDK but rather to your system context. Are you using MacOS? This is the only OS I never built on. I wonder if Apple has something customary to its JDK. I currently build Byte Buddy on Windows and on Linux with JDKs 1.6, 1.7 and 1.8, this is part of the Travis CI integration. I also built it on various machines and it never caused trouble.\nI wonder if this could be related to your Maven version? I also wonder why it is complaining about OutputTimeUnit what is a JMH class which is clearly available with the configured version and which is never referenced in the javadoc anywhere. Alltogether, it should not even create a javadoc when you do not add the -Pextras profile.\nBut for the time being, try this prebuilt jar: https://www.dropbox.com/s/lahrljtd1we46o5/byte-buddy-0.3-SNAPSHOT.jar?dl=0\nThanks!\n. That's a relief, I want the build to be clean. Never encountered the GPG thing, it should only pop up when you use the extras profile but I will investigate. Did you verify the OSGI compatibility? I am on vacation next week but I'll release a new version right after, I miss some test cases and some documentation and then its good to go.\n. Sure thing, but have you tried the version I uploaded? \n. Fixed in version 0.3.\n. Not entirely sure. To be honest, I do not use OSGi, I only googled my way. I am going to have a look at it.\n. The current version or your build?\n. Version 0.6.7 should have correct OSGi headers. Thanks @CodingFabian for fixing this!\n. On second look, it seems like the shaded POM is not longer overriding the original POM. The dependency remains declared...\n. Okay, I had to tweak the build a bit. The shade plugin does not play nice with the bundle plugin. I had to list the exports explicitly. It works with version 0.6.8.\n. It's a bug. Thanks for reporting. Its gonna be fixed with the 0.3 release which is due in September.\n. Fixed in version 0.3\n. Good catch. The same problem could be observed for the jar injection method. I also adapted this in the test cases.\n. Hei, this is indeed an issue and something I want to work with in the future. I will leave this issue open until I got a chance to improve this.\n. I refactored all built-in Instrumentation implementations to provide better error messages. This is therefore resolved in version 0.4.\n. This is indeed a bug, rather a faulty default setup. You can resolve this by setting a different Assigner which knows how to assign a void type to an Object type. \nWhen defining the MethodDelegation, set \nnew VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE), true)\nusing the withAssigner method.\nThis is of course inconvenient and the upcoming version will provide a better solution and you will not longer be required to do so. Thanks for reporting this and for using Byte Buddy.\n. As a matter of fact, due to another bug, I planed a bug-fix release later this day. Simply upgrade to version 0.4.1 once this version is available.\n. The bug-fix release 0.4.1 is already available in JCenter and is currently synchronized to Maven Central. It should be available from there in a couple of hours.\n. You are welcome. And thanks for reporting this and helping to improve Byte Buddy.\n. This is indeed a bug. I simply forgot to apply a boxing assignment for the arguments. I just implemented a reproducing test and prepare a fix. I'll release a version 0.4.1 with this some minor bug-fixes later this day.\n. The bug-fix release 0.4.1 is already available in JCenter and is currently synchronized to Maven Central. It should be available from there in a couple of hours.\n. It is because Byte Buddy figured out that another method defined on the Object type is more suitable for binding. You can restrain this by defining:\nMethodDelegation.to(new GeneralInterceptor(new ProxyedInterfaceDelegate(10L)))\n                        .filter(not(isDeclaredBy(Object.class)))\nto tell the method delegation not to consider the Object type's methods. However, this default behavior is a little bit unintuitive. I'll see if I find a more intuitive default for a future version without breaking the general idea of the MethodDelegation's binding algorithm.\n. For clarification: There are two filters involved:\n1. The filter for the methods of the dynamically generated type. Saying: When you define that you want to subclass(type), you are further saying you want to override methods that match isDeclaredBy(type) and let the others alone.\n2. The filter for the MethodDelegation where you are constraining to methods of your GeneralInterceptor that are not(isDeclaredBy(Object.class)), i.e. the intercept method.\nIn Byte Buddy 0.5, I added an additional AmbiguityResolver that automatically selects the method out of two that is declared by the most specific type which is a better default. This behavior bothered me before, I think this is a better approach for the future. Expect a release of this version sometime the year-shift.\nPS: There is a bug fix release 0.4.1 available that allows you to use the InvocationHandlerAdapter if you want to. Its now also on Maven Central.\n. It does! It just prefers methods of a subtype without discarding them. You are also always free to configure your own AmbiguityResolver or to rearrange the existing ones. If you want to delegate to equals(Object), it however sounds like you might be able to use the more efficient Forwarding instrumentation which always delegates to a method with identical signature.\nWhen filtering, you can always include the equals method by for example specifying not(isDeclaredBy(Object.class)).or(named(\"equals\")).\n. Thanks for your suggestion. I thought about this before, there is however one caveat with this strategy. Interface methods are never package-private, super class methods might however be (often implicitly, as non-public classes implement their public methods as package-private ones). At the same time, the interface type itself might be package-private where your suggested naming strategy makes more sense.\nYou are also right about the fact that package-private would not be an issue when subclassing Object. I thing it makes sense to apply this strategy when a user specifies \"subclassing\" an interface. This should however not consider the first interface but the specified one as one might have defined the implementation of an interface on the ByteBuddy configuration.\nI'll give it some thought and implement the changes for version 0.5. Thanks for the input.\n. This is now implemented in the most recent 0.5 snapshot and is included in the next iteration.\n. Version 0.5 is released.\n. Implementing the methods is quite easy as you can use the FileAccessor.ofBeanProperty() interception. However, you would still need to define the fields. With Byte Buddy, you would therefore define a bean as follows:\njava\nnew ByteBuddy()\n  .subclass(UserConfig.class)\n  .method(isGetter().or(isSetter())).intercept(FieldAccessor.ofBeanProperty())\n  .defineField(\"name\", String.class, Visibility.PRIVATE)\n  .defineField(\"age\", int.class, Visibility.PRIVATE)\n  .make()\nI take it that you want Byte Buddy to generate the fields for you? While I understand that this is convenient, I feel that it is somewhat out of scope for the library as one can easily write a custom adapter. For example:\njava\n<T> DynamicType.Builder<T> fields(DynamicType.Builder<T> builder, Class<?> type) {\n  for(Method method : type.getDeclaredMethods()) {\n    if(method.getName().startsWith(\"set\") {\n      String name = method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4);\n      builder = builder.defineField(name, method.getParameterTypes()[0], Visibility.PRIVATE);\n    }\n  }\n  return builder;\n}\nThis way, one could for example also add annotations, custom visibility, custom names, different field mappings, etc. If Byte Buddy did all this automatically, it would take this freedom away. In Java 8, the above code can even be expressed as a one liner.\nI would recommend you to hide this away in an adapter or even by subclassing Byte Buddy and overriding the subclass method and everything is done under the covers. Would this be a solution for you?\n. I will give it some thought. I do not want to bloat the library with too many common use cases as this caused quite some trouble with cglib where something similar was attempted. But I see the use of it.\n. I decided against an explicit API. From my experience with cglib, this can be better solved by an external library which is specialized in handling exceptions. However, I decided to add some convenience methods to make adding methods from reflection results more easy. I hope you can live with this compromise.\nThank you again for using Byte Buddy and your feedback!\n. Hei Sirinath,\nI am glad you like Byte Buddy. I tested the API with both Scala and Groovy which are the two JVM languages that I occasunally use and those work just fine and especially in Scala, the DSL is very nice to read when ommitting dots and paranteses. And especially when using the more low-level APIs, it is not an accident that many methods of the functional interfaces in use are named apply.\nDid you think about some specific language which would require improved support? If you have a language you would like to support, pull requests are very welcome!\nOr did you speak about support for manipulating code written in other languages? In this case, Byte Buddy works with byte code which is language agnostic. With for example Scala, Byte Buddy behaves the same way as Java reflection does. As Byte Buddy ignores synthetic memebers in its default configuration, using Byte Buddy with other languages is however quite straight forward most of the time. A lot of code relies on reflection, thus languages often try to expose a Java-compatible interface what of course helps a lot.\nAll the best, Rafael\n. You are right, Scala is a problematic use-case in many relations. I do consider adding more Scala sensitive matchers at some point, the problem is however that these matchers would need to relate to a specific version of Scala as changes in the language would of course also affect the provided matchers.\nI hope that I will find the time at some point to better analyze what changes are custom and to provide matchers that are least likely to fail. Up till now it is more or less the responsibility of the user to provide appropriate matchers or to, for example, only intercept methods on annotations instead of naming patterns when working with Scala.\n. I thought about this and I came to the conclusion that this should not be a part of the core library but should rather be covered by an external library. The future of languages like Scala is uncertain and there are no guareantees about how their compilation is handled in the future.\nIf I added this fearure, I wanted to always be in sync with the compiler which is something I cannot promise. I therefore recommend Scala developers to use more explicit marks such as annotatations when identifying methods.\n. Hi Sinirath, \nByte Buddy is built arround the assumption to manipulate Java byte code at runtime. This assumption is pretty crucial as it for example allows to directly load the manipulated code etc. Also, working with byte code assures that the library remains language agnostic.\nTherefore, Byte Buddy has no concept of an AST, it simly provides some glue between precompiled components to wire them together or allows to inject any custom byte code into a class.\nBest regards, Rafael\n. Hi David, your aproach is correct. If it throws a NullPointerException, you found a bug. ByteBuddy should never do this. I will test it later and might ask for a more detailed description. Expect a bugfix realease at the end of next week.\nFor creating a root interface, you would subclass Object and define the modifier to represent an interface, on the byte code level, interfaces are represenred as Object subclasses. I will add a specific DSL element for that.\nThanks for using Byte Buddy and for your feedback. I am working on additional documentation and hope to make Byte Buddy easier in the future. \n. Interfaces do not add the super flag which, until now, were always added to subclasses, including interfaces. Also, the default implementations of ConstructorStrategy did not consider the possibility of interfaces where the super classes are considered null. Both was fixed.\n. Byte Buddy 0.5.2 is released and it fixes the bug you found. Note that interface methods must be public. Also, implementations are only allowed on from Java 8.\n. I mean a default method implementation. When you define an interface method, it needs to be abstract as long as the byte code version is not 52 (Java 8) where you can optionally provide an implementation (also for static methods).\n. Building additional artifacts takes a lot of time, therefore you need to build Byte Buddy with the extras profile to build the repackaged artifact. On ByteBuddy.net, you can find a developers page with some infos on that.\nRun: mvn package -Pextras\nThere is also info in the root pom.\n. Thanks! I am really glad that you like Byte Buddy. I am happy that all the time spent pays off. I am more than happy to merge the suggested addition. If you stumpled upon it, others will probably stumble, as well. Your bug is fixed and I added an exteded API to make interface creation more easy. Just note that interface methods must always be public.\nI want to add some additional API improvements in the upcoming week. Once I am done, I will push the changes to Maven Central. Thank you once again for your kind words.\n. Calling withoutCode creates an abstract method and a constructor cannot be abstract. Instead, you would need to call the Object class's default constructor. For this, you would need to implement approriate byte code. You can do this by creating a simple Instrumentation:\nTypeDescription objectType = new TypeDescription.ForLoadedType(Object.class);\nnew Instrumentation.Simple(\n  MethodVariableAccess.forType(objectType).loadFromIndex(0), \n  MethodInvocation.invoke(objectType.getDeclaredMethods().filter(isConstructor()).getOnly())\n    .special(objectType),\n  MethodReturn.VOID);\nI recognize this use case and that this should be easier. I will add a utility instrumentation that makes this a one-liner in the future.\nAlso, you might want the type itself to be public what you did not specify.\n. Great, I would like to keep this issue open until I had the time to implement an instrumentation that makes this impler. Thanks for reporting and providing feedback.\n. No worries. I appreciate the clean-up and the feedback. This just serves me as a reminder.\n. I implemented a MethodCall instrumentation that is included in the next version of Byte Buddy. You can then create the instrumentation by:\njava\nMethodCall.invoke(Object.class.getDeclaredConstructor())\nThis instrumentation also allows you to hand over parameters if you wanted to call a constructor that takes parameters.\n. This instrumentation is now implemented in the latest version and pushed to Maven Central.\n. Currently, you can use the MethodCall instrumentation which is composable. For field access, there is no short cut way to do explicit instrumentations yet. Note that you need to call the super constructor in any constructor. It seems like you use a MethodConstant where you probably want to invoke a constructor. This you can do via a MethodInvocation in combination with a TypeCreation.\n. Are those classes described as Java source code? Byte Buddy operates on the byte code level. You probably require a Java compiler API. Javac offers such an API for example.\n. Byte Buddy is language agnostic by design, it will never contain a compiler, sorry. The code would not share any requirements, it would make more sense to write a different library for that. I am sure, there exists something suited to your needs already, though.\n. Are you subclassing a class with a final method? It is not possible to override such a method, you would need to use a Java agent or some other sort of class redefinition. I once blogged about this: http://mydailyjava.blogspot.no/2015/01/make-agents-not-frameworks.html\n. Can you post a running example that uses Byte Buddy to instrument your class?\n. Hi, as I said, it is not possible to *subclass and override a final method. Not with Byte Buddy and not on the Java platform in general. You would need to use a Java agent and redefine the class as I described in the linked blog posting.\n. No, it is simply not possible to override a final method, any (generated) class that would override such a method would be rejected with a verification error by the Java virtual machine. For this reason, Byte Buddy does not even consider overriding such a class.\n. Thanks!\n. This choice was made as the order in which the interfaces are declared is exposed via the reflection API. Because of this, it may affect code that uses reflection.  Requiring lists should reflect this consequence.\nLet me however think about it, I might adapt a different signature.\n. I have adopted your suggestion with some additional validation of the input which was meaningful for lists that can (illegally) contain duplicates even though it would not be allowed. I adapted this throughout all of Byte Buddy's API where it appeared meaningful, i.e. where the order of arguments does not always have a meaning. I will soon push an updated version. Thanks for your input.\n. You are right. Initially, I did not want to do it because I wanted to avoid polluting the API with additional method names. However, I will now add overloaded methods based on Iterable:\njava\nmakeInterface(Iterable<? extends Class<?>> types)\n. The changes are now in place.\n. I found the bug. Currently, I am releasing a new bug-fix version. It should be synchronized to Maven Central in a couple of hours.\n. Hi, I already identified the actual issue. Refactoring gone wrong. I fixed the problem and just released version 0.6.10 where the visibility is appropriately resolved.\n. Great! This time I actually cloned Mockito and tested it and then reproduced the problem in my tests. I think I knew the issue and did not test it properly. Moved to fast. \nI really hope there will not be too many of these corner cases coming up to the surface. Mockito is the first large-scale user of Byte Buddy, there will probably be one or two things I have not thought off. \n. When you mock a class, you delegate all invocations to an instance field:\njava\n.method(any()).intercept(toInstanceField(MockMethodInterceptor.class, \"mockitoInterceptor\")\n       .filter(isDeclaredBy(MockMethodInterceptor.class)))\nIf the field is not yet set (during a constructor call), a null pointer exception is thrown.\nTo avoid this, you can for example delegate to a static interceptor which then checks if the interceptor is already set and only delegates a method if the interceptor is already set: https://gist.github.com/raphw/8789f5ef08240008efc8\n. You are right. I am changing this as soon as I find the time to do it. Alternatively, if you have a couple of minutes, feel free to submit a pull request.\n. In order to implement this, the current MethodLookupEngine must be replaced with a richer structure, a MethodGraph.Factory. A method graph is to be assembled as a collection of Nodes where each node represents an invokeable method within the method graph.\nThe graph needs to expose the following information:\n- What methods are visible to a certain type (instrumentable methods, super type invokeable methods)?\n- What default methods can be invoked?\n- What bridge methods need to be implemented when implementing a method? Idea: Implement TypePool.MethodRegistry.Records by bridge method weaving records.\nImplementation idea: Create the graph as a recursive data structure where any type points to its parents and its interfaces which are itself method graphs. \n. Thanks for reporting this. You are right, this is required by an ASM adapter I am using which has this requirement without documenting it. I am not yet sure when I have time to look at it. The easiest is to redefine the class itself instead of renaming it:\njava\nFoo foo = new Foo();\nnew ByteBuddy()\n  .redefine(Bar.class)\n  .method(named(\"m\")).intercept(FixedValue.value(\"bar\")) \n  .make()\n  .load(Foo.class.getClassLoader(), classLoadingStrategy);\nSystem.out.println(foo.m());\nI will however fix this on the long run once I have taken care of more pressing problems with 0.7.\n. No there is not and this is by design. Byte Buddy is designed with binary compatible instrumentation in mind. You would rather create a new class that subclasses the desired subclass for implementing the desired class.\n. Thank you. All the class swapping functionality is not used by too many people but I hope that these features become more useful with the evolution of the JVM.\nFor the reported error: The ASM library could actually work with the non-expanded frames. The remapper that I use is rather generic in its functionality  which is why they require it. The easiest would however be to not require the expansion for simple use cases. I filed a bug with ASM and I hope that they will take it. Otherwise, I need to craft some sort of work-around in the future.\n. I leave the issue open until it no longer fails.\n. No problem. Again, thanks for reporting.\n. I resolved this issue on master with a workarround that works for Byte Buddy's use case. At best, ASM will offer support for this out-of-the-box at some point. Since the 0.7 release has gone wrong, I reverted master to a stable non-generic version for now and will release a version 0.6.13 some time soon.\n. 0.6.13 is released where this should be fixed.\n. This is the reason. In order to intercept the method, Byte Buddy needs to add an overriding version to the redefined class. This is an unfortunate limitation in the JVM and is adressed by JEP-159: http://openjdk.java.net/jeps/159\nThis JEP is rather dormant but I hope it will be realized in the future.\n. No, please ask. For longer questions, please also consider Stack Overflow with the byte-buddy tag or the mailing list.\n. Hi Fabian, you are right. If you can think of a better example, please send\na pull request!\nAm 02.08.2015 12:49 vorm. schrieb \"Fabian Lange\" notifications@github.com:\n\nHi Rafael,\ni just noticed that you use quite an obscure example in the 3-1 = 2\ncomparison example in the main readme.\nIt is correct, but it evokes a wtf moment when you see that it substracts\nhash codes. Is that intended, or shall I send a PR to make that less\nmagical?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/raphw/byte-buddy/issues/49.\n. This is way better. Thanks for doing this!\n. I am currently on vacation, but I will look at it first time I am back. First suspicion: Byte Buddy is not currently configured to keep a reference to the generated class'es byte code after it is first loaded. Try the manifest version of the wrapper strategy. I guess, power mock requires explicit access to the byte code!\n. I had a look at it. The error lies with Power Mock, in my opinion. During class loading, Byte Buddy's class loader is queried for the super class of the runtime generated class SampleClass. This is standard class loader behaviour and cannot be changed.\n\nThis class is however not longer available. The error breaks down to:\njava\n@Test\npublic void testFoo() throws Exception {\n  sample.getClass().getClassLoader().loadClass(sample.getClass().getName());\n}\nwhat causes the same error, even without using Byte Buddy. From PowerMock's MockClassLoader I can see that there are loading exceptions for specific libraries, like e.g. cglib or javassist to presumeable prevent the same problem. The would need to include Byte Buddy in this list, I assume.\n. If you have the minutes, please report it to PowerMock. I am still officially on vacation, I can alternatively do it afterwards.\n. I researched this a bit and this is not J9 specific. As a matter of fact, J9 did it right in the first place as it returned the JRE location from java.home while OpenJDK returned the installation folder (different for JRE and JDK installations). However, both VMs are now supported. Additionally, the folder layout of the Macintosh build of the JVM is now supported.\nFixed in master.\n. Fixed in master.\n. I have considered this for an early version but I have finally decided not to support this kind of feature. Inlining for performance is better applied by the JIT compiler and it creates strange debugging behavior for users, not to speak of countless edge-problems like different versions of the generated byte code and the target class. Byte Buddy will not support such a feature as it is always better to create appropriate class loader hierarchies in combination with MethodDelegation.\n. Javapoet is a source code generation library and can therefore imitate the Java language what is of course more intuitive. The Byte Buddy API is constantly refactored and extended but there will not be a higher-level API than the one offered today. For a more high-level API, it would be better-suited to implement a new library that can of course be based upon Byte Buddy.\n. Optimization of class-layouts is a complex-operation and is difficult to implement in a generic, type-safe manner. Byte Buddy already allows the registration of custom ASM-visitors to alter the byte-code / field layout what would be a better entry-point for such layout improvements.\n. It is already possible but loop unrolling is nothing that is recommended for general use what does not make it worth to support (and maintain) as an out-of-the-box feature.\n. Delegation is already supported using the MethodDelegation and the Forwarding classes. An annotation cannot offer the same flexibility and readability to implement similar behavior.\n. I agree that there could be many other ways to make specific use cases easier. My concern is to make the library difficult to maintain by allowing for such feature-creep. The current MethodDelegation allows for any thinkable delegation binding and it already is very extendable by allowing for custom annotations and more. If you have such a demand, you can always implement it the way that suits you best. If you need help with a particular use-case, please feel free to ask.\n. You can use the ASM-API to create custom byte code. Currently, Byte Buddy never generates any switch statement in its standard-adapters. Also, the assertion is not true. The JIT compiler takes care of performance optimizations and can transform your code accordingly.\n. You are right, fixed on master.\n. You are right, this is currently difficult. I will try to think of a way. It is a bit tricky though, to supply better such matching introspection. Any matcher and interceptor could be user-supplied and this approach would require implementors to supply such information. At the same time, I do not want to add a logging dependency to Byte Buddy.\nIdealy, the error messages of any interceptor supply sufficient information for debugging but I am aware that this is currently not always the case.\n. I looked into this and I enriched the error message thrown by MethodDelegation. Further than that, I do not think that I want to add any listener abstraction. Normally, it is not possible to recover from a falsly set-up delegation what makes an exception the appropriate reaction.\nAlso, I went through previous issues on this matter. Many of them suffered from the former visibility abstraction that made methods invisible despite them being visible. This should be solved already.\nA detailed explenation of the binding would require user-custom components to provide additional information on a binding failure. I do not want to make this mandatory, though.\nAnother alternative would be to add a logging API but I do not think that this would help either. The best way of debugging would be to set a breakpoint at the root of the exception. From there, it should be possible to debug a user's code.\n. You have a point there. In theory, the retransformation process would result in a no-op as the class file transformer would not attempt to redefine non-matched classes but it makes sense to do a prefiltering to avoid the retransformation attempt alltogether.\nThis would solve the problem: \njava\nif (retransformation) {\n  List<Class<?>> retransformedTypes = new LinkedList<Class<?>>();\n    for (Class<?> type : instrumentation.getAllLoadedClasses()) {\n      for (Transformation transformation : transformations) {\n        if (transformation.matches(new TypeDescription.ForLoadedType(type), type.getClassLoader(), type, type.getProtectionDomain())) {\n          retransformedTypes.add(type);\n          break;\n        }\n      }\n    }\n    try {\n      instrumentation.retransformClasses(retransformedTypes.toArray(new Class<?>[retransformedTypes.size()]));\n    } catch (UnmodifiableClassException exception) {\n      throw new IllegalStateException(\"Cannot retransform classes: \" + retransformedTypes, exception);\n    }\n  }\n}\n. No, I do not think it should be. I expect that people that enable retransformation actually want to conduct a retransformation of the matched classes in the first place. It is most convenient if Byte Buddy applies the retransformation. Otherwise, one can always create the raw retransformer and setup the process manually.\nNow merged to master.\n. Fixed in master.\n. Internally, the TypePool has to transform the name of a class into the form of com/package/Foo.class by suffixing .class anyways. Therefore, string transformation is already required and despite, the performance gain would be minimal for avoiding such short-lived objects.\nI prefer to not bloat the API, the transformation should be easy enough, potentially, one can simply wrap a TypePool by another API.\n. I added methods to the ClassVisitorWrapper that allow to specify hints to the ClassWriter and  ClassReader (if applicable) instances. The above logic can be implemented as follows:\n``` java\nclass MyClassVisitorWrapper implements ClassVisitorWrapper {\n@Override\n  public int wrapWriter(int hint) {\n    return hint | ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES;\n  }\n@Override\n  public int wrapReader(int hint) {\n    return hint | ClassReader.EXPAND_FRAMES;\n  }\n@Override\n  public ClassVisitor wrap(ClassVisitor classVisitor) {\n    return new MyClassVisitor(classVisitor);\n  }\n}\n``\n. Thanks for that! Could you fix the trailing spaces and ammend the commit to your push? You can run alls tests locally with-Pchecks -Pintegration.\n. I use IntelliJ. Thechecks` profile should be active by default. But there is a bug in Maven where that does not work for Windows machines.\n. I though the agent API was smarter. This is exactly what I would do, thanks for that, all is fine. Please fix the one test case and ammend the change.\n. No need for that. Simply change the Mockito assertion for the invocation of the method which is still required for the empty array.\n. If you want to use ASM directly, you should repackage Byte Buddy dep into your own namespace. Otherwise, compatibility cannot be guaranteed as the ASM namespace defines many different versions that are incompatible to one another.\nFor further reference, have a look at the ASM FAQ where this is recommended and the Byte Buddy readme that discusses the issue.\n. Good catch, thanks. Could you add a unit test that verifies this logic? Also, please remove the white space that checkstyle complains about and ammend the commits. (Simply push force to your branch and your pull request is automatically updated.\n. It says:\n/home/travis/build/raphw/byte-buddy/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java:346:49: '!' is followed by whitespace.\n. Thank you. Could you please squash the commits and force push this to your branch? This would allow me to easier merge this to the current development branch. (http://stackoverflow.com/questions/5189560/squash-my-last-x-commits-together-using-git)\n. Thanks.\nDifficult to say. There is still quite a lot to do, unfortunately. I have to rework the internal representation of the type system what will require a refactorization of a large amount of code. Also, I am currently not having too much free time to work on it. I hope to releasing it early next year. Generics has been an insane amount of work, but I want to do it properly in order to allow for the integration of value types and primitive generic types etc. in the future which will be a more pressing use-case.\n. Ifyour delegators are equal, this is exactly what is happening. I guess that you have some additional configuration like a filter? Let me look into it and see if I can remodel this solution.\n. The wait it is thought of is that you would append an AmbigouityResolver that figures out what method to bind in each case but I understand why this is not great. \njava\n.defineMethod(getSomething)\n.intercept(MethodDelegation.to(delegate, Delegate.class).withAmbiguityResolver(myResolver))\n.defineMethod(getSomethingElse)\n.intercept(MethodDelegation.to(delegate, Delegate.class).withAmbiguityResolver(myResolver))\nAs long as the resolver implements the correct hashCode, equals contracts, Byte Buddy figures out that the implementations are identical and therefore compatible.\nThe problem is that there is currently no way for two Implementation instances to negotiate a common definition state for an instance. This would require to detach the preparation logic what would be a significant change in the application's architecture and the public API. The best Byte Buddy can do is to trivially merge implementations if they are equal and throw an exception if they register conflicting state. I will keep this in the back of my head but for now I can unfortunately not offer a solution.\n. I am going to include this in the currently planned revision of the public API which will also allow for definition of generic types. The idea is, that this form of interception allows for a simple decoration of existing methods without rebasing / redefining them, i.e. that the MethodVisitors become stackable. The same will go for adding annotions without changing an existing method what is another feature that was requested.\nSo to speak, it will take a little bit to include this as I need to rework the internal representations of types before taking on the API refactorizatization. But it will become a part of the API, so much I can say.\n. I chose a slightly different part for allowing for such wrapping.\nI believe that using ASM visitors is mainly desireable for users that want to redefine classes. In this case, a user only wants to change declared methods. For the general use case, it is already possible to use MethodVisitors implementing a custom Implementation.\nTherefore, I tweaked the existing API for ClassVisitorWrappers a bit and added convenience visitors for ForDeclaredMethod and ForDeclaredField. This gives a big advantage that these visitors only require discovering declared methods instead of parsing the entire method inheritance tree for a given type (i.e. allows for using ByteBuddy with a precomputed MethodGraph.Empty to speed up the instrumentation process).\nThe new API can be used as follows:\n``` java\nnew AsmVisitorWrapper.ForDeclaredField()\n    .match(someFieldMatcher(), bew FieldVisitorWrapper() { ... })\n    .match(someOtherFieldMatcher(), bew FieldVisitorWrapper() { ... })\nnew AsmVisitorWrapper.ForDeclaredMethod()\n    .match(someMethodMatcher(), bew MethodVisitorWrapper() { ... })\n    .match(someOtherMethodMatcher(), bew MethodVisitorWrapper() { ... })\n```\nThe matchers are cummulative, i.e. if two matchers match the same field, both wrappers are applied. The field and method visitor wrappers are functional interfaces to ease their use with Java 8.\nThis API will be part of Byte Buddy 0.8 which is planned for release some time this month. The current state is already implemented in the 0.8 branch.\n. Exactly like you wrote it. I will write some unit tests that demonstrate this and also update the documentation what hopefully makes it clearer.\n. This is expected behaviour. @Origin returns a reference to the method that was matched upon defining the interception. Reflection is not a good way to invoke original code. This code could for example be defined by a super class which is then not accessible to reflection. Therefore, Byte Buddy offers other approaches for invoking such code.\nLook into the @SuperCall and @Morph annotations instead which are meant for this.\n. Do I understand you correctly that you are trying to delegate from a proxy class to another proxy class? The @Origin annotation is built such that you can invoke an unproxied instance from a proxied instance. If you rebase a class such that you use a class either as a proxy or not, I would recommend you to add a boolean field to the class which activates or deactivates a proxy mode for instances of a class. If a class is not proxied, you can simply invoke the super method from the delegator.\n. You are right that this is not (currently) possible what you are trying to do. To begin with, the @Origin annotation is mainly used to explore the context of a method invocation. The annotation is mainly used for retreiving information about the method being intercepted, for example for doing reflection, e.g. accessing annotations (where it does not make sense to read the rebased method which is not annotated). Also, it can be used to make a genuine call to another instance.\nFurthermore, it is more of an implementation detail that a method is rebased for a given interception. For example, if a method is overridden and not rebased, no alternative, invokable method exists and Byte Buddy would need to fall back to exposing a reference to the now overridden method. Using such a reference, it is again not possible to invoke another instance's original method as a super class's method can only be invoked from within a class.\nI am wondering what you are trying to achieve? Are you proxing an instance using another instance of the same, rebased class? Or are you chaining instances in some way? I wonder why you do not simply use the original instance (with the rebased class) as a proxy. If you give me some context to what you are trying to achieve, I might suggest you a better way of doing the same thing.\nFrom what you told me so far. I can only guess but maybe you want to define different interceptions for different instances? If so, have a look at the MethodDelegation class which allows for the delegation to some instance field instead of a \"global\" proxy. In this case, you can set an intercepting delegator for the proxy instance while defining some form of \"no-op\" interceptor for the actual instance.\n. Well, the problem would be that if the modify method was defined in a superclass of MyObject, this method would no longer be invokable using reflection. That is why I mentioned that the reflection API should only be used for genuine method calls. It should not matter for the behavior of a delegation if a method is rebased or defined by a super class, this is why the synthetic delegator method is not exposed. The rebasement process is an implementation detail that should not surface. There is no defined process or mapping constraint where the original method of an interceotion would be registered which is why your suggestion to add a utlity method would not work. Even worse, the interceptor is not aware of a rebasement itself; this is what makes it possible to subclass or rebase a class using the same API and expecting the same outcome.\nMy argument is that in your case, you have to adapt in your code that you want to use different instances of the same class in different ways. I would therefore suggest you to do something like the following:\n- Change your interceptor to read a field that is stored in the instance level (e.g. Dispatcher).\n- Run the interception only if this field is set, call the original code otherwise.\njava\npublic class Interceptors {\n    public static void modify(@This MyObject myObject, \n                              @Origin Method method, \n                              @SuperCall Runnable runnable,\n                              String newState,\n                              @Field(\"dispatcher\") Dispatcher dispatcher) {\n     if (dispatcher != null) {\n       dispatcher.dispatch(myObject, method, newState);\n       // Can print: System.out.println(method);\n     } else {\n         runnable.run();\n     }\n    }\n}\n- Now, to activate \"interception mode\", you simply need to set the Dispatcher field that you defined for the instance. (You can make this type-safe by impementing a setter interface):\njava\npublic interface Dispatchable {\n  void setDispatcher(Dispatcher dispatcher);\n}\nThis is what I would suggest.\n. I would make such an exception, however, the way that Byte Buddy is build, no Implementation instance is allowed to know if it is triggered for a rebasement or subclass instrumentation. This is by design and I argue that the advantages outweigh the disadvantages. Changing this, would be a major change in Byte Buddy. \nYou can however trick by implementing your own work-arround. Implement your own annotation Binder where you call SpecialMethodInvocation invokeSuper(MethodDescription.Token) on the intercepted source method. You will receive an instance of SpecialMethodInvocation which exposes the rebased method via getMethodDescription(). You can expose this method by returning a MethodConstant pointing to this description from the binder. Have a look at the Origin.Binder as an example.\nNote that this will only work if your method was really rebased. Otherwise, you are receiving an instance of the super class's method or an illegal representation if no super method exists for an intercepted method.\nBeyond that, I want to keep the way of rebasement an implementation detail as I consider to offer an invokedynamic based replacement in the future. Therefore, unfortunately, I do not want to allow for accessing the rebased methods.\nI understand that breaking out from the constraint to not allow Implementations to distinguish between interception type can be a limitation but I argue that there is always a better solution to this problem as the one I suggested in your case.\nIf I ever find a way to solve this problem in a better way, I will remember this discussion and try to implement your suggestion but for now I am afraid that it would bloat the code base and break Byte Buddy for future changes. But for now, I must unfortunately say that I do not want to support such a feature. Thank you however for your thoughts, I do very much understand your requirement.\n. Thank you for the hint. I fixed the documentation. The rebase method was renamed to type.\n. Unfortunately, you cannot. Lambda expression classes are loaded by so called anonymous class-loaders which I once discussed in a blog article. Lambda expressions are not considered real objects of real classes, despite their VM implementation. Therefore, the virtual machine's ClassFileTransformer API is not notified of such cases. This official API is the fundament of Byte Buddy's interception mechanism and Byte Buddy can only support what the JVM does.\n. If you bother to do so, you are more then welcome. I also consider to open a kind of FAQ some time but I have the experience that not many people read such question dictionaries. I probably collect questions for another while before I open something. Thank you for the suggestion / reminder.\n. Groovy implements some methods that you must never intercept. We had this problem in Mockito: https://github.com/mockito/mockito/blob/7fabd84fdfb2f80f8c135fe3865263c684c0d4e7/src/main/java/org/mockito/internal/creation/bytebuddy/MockBytecodeGenerator.java -\nIt is sufficient to exclude Groovy's internal methods which it needs for dynamic dispatch to work from instrumentation as shown in the linked code example. Does this solve your problem?\nOther than that, it looks like a bug in Groovy to me.\n. Could you set a breakpoint at defineClassAndGetConstructor use the ASM ClassReader (ASM is on Maven central, just add a dependenca to your project, you will need the util version) in combination with a TraceClassVisitor to print out the generated byte array that is handed to the above method as Java byte code to the console. Then please attach this output to this issue. This way, I can find out what is actually wrong with the byte code and hopefully determine the problem.\n. The class you sent me is ch/concordia/cip/library/Gau$controlGetHandle, not ch/concordia/cip/library/PowerBuilderAppsLib$controlWaitGetHandle. The former class does neither define a <clinit> (class initializer method). Does the former class throw another exception?\n. It seems to me like this class is alright. Then Byte Buddy might actually cause the problem during instrumentation. Can you register an AgentBuilder.Listener and extract the class file of the instrumented class withing onTransformation where you can get the instrumented byte array via the DynamicType argument. Same procedure, I need to have a look at the instrumention class file for ch/concordia/cip/library/Gau$controlGetHandle.\nThank you!\n. Thanks, quick turn-arround! I assume that you are running your code on a JVM before Java 8? The verifier error is unfortunately very unspecific and there is nothing that jumps onto me. Could you therefore do two things for me:\na) Try reading the class file with ASM's CheckClassAdapter. This could cut down the verifier error to something more concrete.\nb) Try producing the verifier error on Java 8. It should give a more detailed error message.\nI assume that Groovy produces some byte code that I did not anticipate. (I only know that Byte Buddy works nicely with Clojure.) Generally, I would however recommend you to ignore all methods that start with org.codehaus.groovy as instrumenting these methods can have strange side-effects.\n. Now it all makes sense, sorry I did not see this before.\nGroovy creates a class file in version 48 (Java 1.4). It is however only legal to register class constants in a class's constant pool since version 49 (Java 1.5). \nYou can still do basic instrumentation in such a case; all you need to do is:\na) If you use @Origin, set the cache property to false.\nb) Set the SelfInitializationStrategy of the AgentBuilder to Disabled.\nThen, Byte Buddy does not need to write class constants. I can consider to add a compatibility mode one day where I support these features for Java classes below version 1.5, but this is really the first time in three years that someone had this problem. The Clojure compiler compiles everything to Java 8 these days, to create more efficient dynamic classes. I wonder if you can instruct Groovy to do the same.\n. No problem. Thank you for helping out with this! Almost all code these days is Java 5+ and I have not tested Byte Buddy much using earlier versions than 5.\n. Sorry, I should have been more precise. @Origin(cache = false) disables the storage of a Method instance in a class cache but rather looks up the instance on each invocation. The AgentBuilder allows for setting an InitializationStrategy which also runs in the static class initializer which can be disabled. Without these two, Byte Buddy does not break compatibility with Java 1.4 and earlier.\nAs for your suggestion. I will add a filter where Byte Buddy can translate the class constant reads into explicit class loader lookups. Then this should work as expected.\n. The problem is that Byte Buddy needs to generate helper (auxiliary) classes to allow the instrumentation to work. Normally, these auxiliary classes must be loaded after the instrumentation since these classes can have references back to the instrumented type what could trigger the instrumented type to be loaded prematurely (aborting the instrumentation). Thefore, the self initiailizing strategy triggers the loading only from the instrumented type's class initiailizer. The NoOp strategy drops the loading alltogether (thus, causing the NoClassDefFoundError).\nThis is however not always the case, e.g. not for @SuperCall, therefore, I added a Premature initialization strategy for the next release which optimistically loads the auxiliary types before completing the instrumentation.\nAlso, I added a TypeConstantAdjustment visitor that can be registered as a ClassVisitorWrapper to fix the problem for Java 4 and ealier by substituting these pool entries with Class.forName(\"typeName\") calls. This visitor will probably be added by default for a future version but I delay it until the API refactoring.\nFor now, you can however use this remapping explcitly when building from head or when using release 0.7.2 which I want to complete tonight.\n. 0.7.2 is now released.\n. No worries, but what you mean by \"out of the box\"? I guess, you are using the Premature strategy disabling all caches? Or are you using the TypeConstantAdjustment?\n. Okay, that is strange as it should not. The only expanation that I have is that Groovy now generates \"newer\" byte code for some reason. (I wrote explicit tests that check for an exception of the validator if the legacy class files contain newer instructions.\nAre you sure that the methods are intercepted? The agent might swallow exceptions and not instrument the classes. In this case, no log statement should be printed.\nIf something works even if it should not, this is not normally a problem but feel free to intercept the byte code and check if Groovy really still generates 1.4 byte code.\n. No hurry, thanks for the feedback once you find the time!\n. Okay, I figured it out:\nAfter the update, Byte Buddy's internal validator finds the problems in the\nJava 4 classes and throws an exception BEFORE the class's instrumentation\nrather than throwing a verifier error AFTER instrumenting. This leads to\nthe class not being instrumented what does however not result in the\napplication to fail. Therefore, your code works now.\nFrom this I learned that most Groovy classes are created in version 1.5 and\nonly few in 1.4 format. Only the latter class's instrumentation fails\nwithout applying the remapper. (I also found a bug with arrays in the\nremapper that is fixed in master.)\n2015-11-27 9:18 GMT+01:00 Peti Koch notifications@github.com:\n\nHi @raphw https://github.com/raphw,\nhere's is an example to reproduce to behaviour:\nhttps://github.com/Petikoch/bytebuddy_groovy_methodlogging\nWith Byte Buddy 0.7.1 -> VerifyError\nWith Byte Buddy 0.7.2 -> ok\n(just switch the version number and run \"Main\" or the JUnit-Test)\nIt's now also clear for me, where exactly the Groovy byte code generation\nhappens... when some Groovy code calls methods from an other class (Java or\nGroovy).\nBest regards & have a nice day,\nPeti\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/raphw/byte-buddy/issues/81#issuecomment-160066073.\n. Right, the interception does not currently consider the redefined state. This can be fixed easily.\n. This is now fixed in master and will be part of the next release.\n. You are right, I improved the error message.\n. Hi, thanks for the report. Inner classes have spefic meta information attached to them in order to represent class-contextual modifiers such as private classes. Byte Buddy has not patched this attribute but only changed the actual modifiers. This is now fixed in master and will be part of the next release.\n. The problem here is that it is impossible to override a final method. But in order to change the method's behavior, it is necessary to do that. The contract of the @Super annotation clearly states that this is the case. Additionally, it is not currently possible to redefine a modifier such that this would be visible to the @Super annotation. I hope to be able to include such a possibility in a future version of Byte Buddy. Note however, that it would still be necessary to remove the modifier.\n\nHowever, what you want to do is trivial. Since the method is not overridden, change your interceptor like follows:\njava\npublic class Interceptors {\n    public static void method(@This SimpleObject thisObject) {\n        thisObject.method();\n    }\n}\nNow everything works as expected for a final method. Byte Buddy cannot really offer a better alternative since the Java type system sets this restriction.\n. That is what Byte Buddy is doing under the covers. But in order to allow for type-safe access to the instrumented type, @Super needs to retain the names, otherwise, a virtual dispatch would not invoke the correct method. Maybe you want to use @SuperCall instead? Here, this limitation does not apply as the type of the intercepted class is not reused:\njava\npublic class Interceptors {\n    public static void method(@SuperCall Runnable runnable) {\n        runnable.run();\n    }\n}\n. The problem with @Super here is the way it is implemented in order to reuse Java types. The interception looks like this:\n``` java\npublic class SimpleObject$Super extends SimpleObject {\nSimpleObject actual$super;\n@Override\npublic void method() {\n    actual$super.method$super();\n}\n\n}\n```\nIn order to implement such a proxy, neither the instrumented type or the instrumented method must be final. There is no way arround this, as the JVM enforces this.\n. Eventually, I plan to allow for this. Currently, I have some issues with the internal type representation that I need to refactor first. Once these changes are made, I hope that I can allow for such transformations.\n. You can always implement a BinaryResolver that supresses types that cannot be resolved. However, in theory, Byte Buddy cannot tell that PageableHandlerMethodArgumentResolver does not implement MyInterface, therefore the exception is a sensible action.\nI do however wonder: Why is the Spring jar file not visible to the agent? It should be resolvable via the instrumented class's ClassLoader. Otherwise, the class can never be loaded successfully anyways.\nAlternatively, you can always implement your own MethodMatcher. See how the exception is thrown at:\n\nnet.bytebuddy.matcher.SubTypeMatcher.matches(SubTypeMatcher.java:28)\n\nThe subtype matcher is created by ElementMatchers::isSubtypeOf. You can always implement your own matchers where you catch such an exception or never browse down the hierarchy (all types are resolved lazily).\n. Glad that helped and that you like Byte Buddy!\nAlso, I included a new failSafe matcher for the upcoming version. In the future, you can simply do:\njava\ntype(failSafe(isSubTypeOf(MyInterface.class)))\n. It is not a bug, Byte Buddy tries to find a best match among the possible delegation methods and fails due to their ambiguity. Without the @AllArguments parameter, Byte Buddy needs to decide which one of:\n``` java\n@RuntimeType\npublic Object delegate(@SuperCall Callable<?> zuper /, @AllArguments Object... args /) throws Exception {\n  return zuper.call();\n}\npublic String hello(@SuperCall Callable zuper) throws Exception {\n  return zuper.call().toUpperCase();\n}\npublic String world(@SuperCall Callable zuper) throws Exception {\n  return zuper.call().toUpperCase();\n}\n```\nto select. Both have the same injector requirement (a Callable) and all return types are assignable to the return type of the intercepted method. Therefore, Byte Buddy - instead of magically choosing for your - fails with an exception. However, with the parameter present, Byte Buddy decides that the delegate method renders the most complex interceptor and chooses this one over the two other possibilities.\nI am however wondering what you are trying to achieve. As a fallback, when all interceptors are ambigous, Byte Buddy considers the name of the interceptor and chooses that interception method with an equal name to the intercepted method. This works for hello and world. If you renamed delegate to greet, it would also work in your case.\nI can however only recommend you not to rely on the built-in selection mechanisms for complex, unintuitive cases. Rather make the selection explicit what results in more readable code. You can even implement your own AmbiguityResolver and register it with the MethodDelegation.\n. I think what you are trying to achieve might already be covered by the BindingPriority annotation. Can you look into this possibility for your use-case?\n. Yes, you are suffering the same issue with this strategy. Byte Buddy can now discard the first method due to its low priority but is still faced with two ambiguous choices. You would need to set @BindingPriority(Integer.MAX_VALUE) on the first method. However, you probably want the method name to be considered first. This you can achieve by adjusting the default order of the resolvers:\njava\n.intercept(to(new GreeterInterceptor()).defineAmbiguityResolver(\n        MethodNameEqualityResolver.INSTANCE,\n        BindingPriority.Resolver.INSTANCE)\nThis way, the method name is considered as a first criteria and the priority as a second. By default, it is the other way arround.\n. I hope this helped. As I have not heard back from you, I am now closing this issue. Feel free to reopen it if any question remains.\n. I was under the impression that you did not want to intercept the greet method. You need to specify this on your matcher such as not(isDeclaredBy(Object.class).or(named(\"greet\")). In this case your example works. Otherwise, intercepting greet is still ambiguous as all three methods could be used for delegation. Byte Buddy only discards the first one due to the low binding priority, leaving it to decide between the other two where none has an equal name to greet what renders the binding ambiguous.\n. Then you should set the priority to Integer.MAX_VALUE or some other high value. In this case, all methods are bound to an interceptor of their name first and by their priority second. This way, the equal-named methods are bound to their equivalents and all other methods fallback to your _default interceptor.\n. You are right, I fixed this on head. Thanks for the report.. You are right with that this is a class loading issue but I think you are looking in the wrong direction. The problem is indeed that Spring Boot does not show its application dependencies on the class path but encapsulates everything in its own class loader.\nA Java agent is a program of its own and needs to have all of its dependencies on the class path. Byte Buddy does not assume this for the instrumented classes such that a BinaryLocator attemps to create TypeDescriptions from an instrumented type's class loader.\nHowever, your problem is caused by the MethodDelegation.to(HttpClientInterceptor4dot3Plus.class) call which analyzes the type hierarchy of all relevant types that are referenced by the interceptor class. Some of the argument types do apparently reference AbstractHttpClient in their method signatures or as a super type such that Byte Buddy at some time requests the loading of a type in order to reflect on it causing the error as the system class loader that loads any Java agent is incapable of loading this class:\n\nat java.lang.Class.getDeclaredMethods(Class.java:1975)\n  at net.bytebuddy.description.method.MethodList$ForLoadedType.(MethodList.java:106)\n  at net.bytebuddy.description.type.TypeDescription$ForLoadedType.getDeclaredMethods(TypeDescription.java:985)\n   at >net.bytebuddy.implementation.MethodDelegation$MethodContainer$ForExplicitMethods.ofStatic(MethodDelegation.java:1037)\n   at net.bytebuddy.implementation.MethodDelegation.to(MethodDelegation.java:247)\n\nThe last line more or less triggers clazz.getDeclaredMethods() what would fail equally if you did it from a Java agent without using Byte Buddy at all.\nWhat you can do to overcome this problem:\n1. Add the dependencies that the Java agent requires to your class path. Spring Boot should then use that same dependency if the Spring Boot class loader has the system class loader as its parent.\n2. A MethodDelegation can also delegate to an unloaded type using a TypeDescription as its argument. If you can locate the Spring Boot class loader, you can create such a description using a TypePool.\nLet me know if you have trouble doing so. This is less a Byte Buddy specific issue than an issue of Spring Boot not playing nice with Java agents.\nPS: It should be equivalent to write: type(is(abstractHttpClientDescription())) and type(named(\"org.apache.http.impl.client.AbstractHttpClient\"))\n. Great! Thanks for the feedback. You might be able to solve this more elegantly by creating a compound class file locator that consumes both class loaders:\njava\nnew ClassFileLocator.Compound(ClassFileLocator.ForClassLoader.of(classLoader), ClassFileLocator.ForClassLoader.ofClassPath());\nThis way, you would have both loaders in scope when locating your interceptor. This would however still require that the interceptor class is in scope during runtime and can be seen by the intercepted classes.\nCould you also do me a favor in this relation? Could you maybe bring this up with Spring Boot and explain their problem to them? Maybe they can fix it. Can you also answer your Stack Overflow question on this matter with an expanation to solve this problem? SO get much more hits than this issue tracker and it might help someone in the future.\nCheers!\n. Thank you for your effort and reporting this!\n. This is a difficult task and you would need some sort of deployment descriptor to do this. You could, for example, inject all classes within a jar file if those files are listed somewhere, for example in a POM. From this, you could iterate over all class files that you find and inject each into the Spring class loader. Would this work for you?\n. The change is now part of 1.0.0 - for your case, you do however need to enable dynamic assignment. Thanks for the suggestion! Cheers.\n. The javac compiler would not compile your above example due to the ambiguous name. It would however be permissive on the byte code level, that is correct. I might be able to add a possibility in the future.\n. You are right. I am currently preparing the release of version 1.0 and I redid a lot of the things. There is also a new validation API that can be disabled but I just updated it to recognize fields as a pair of type and name.\nCheers!\n. Thanks for the hint. 1.0 should be release some time next week for everybody that can wait that long.\nCheers!\n. Resolved in master.\n. Thanks, probably forgot to include something.\nIn production, you should always disable validation for performance reason:\njava\nnew ByteBuddy().with(TypeValidation.DISABLED);\n. Chances are that you will. The class file format gained some exceptions and quirks over the years. Thank you!\n. The problem was a missing filtering of the deprecation-pseudo modifiers by the TypePool. This is now resolved.\n. First of all, to me this is clearly a bug in Spring Boot. It is not feasible to define a field or any other part of a class signature by a type that is only optionally present. This breaks any use of core reflection on such classes. The way it should be done is to declare a field of type Object and to cast the field to the Groovy type only if Groovy is present. Even without using a Java agent, optional types must not be part of any member within a class that is loaded within an application when this optional type is not present as the JVM can choose to resolve such types eagerly. Even if it works on HotSpot, it will fail on other VMs.\nThe purpose of the InitializationStrategy is to guarantee that a class is fully usable when it is loaded. For example:\njava\nnew ByteBuddy()\n  .subclass(Foo.class)\n  .method(named(\"toString\"))\n  .intercept(MethodDelegation.to(new Object() {\n    public String doSomething() {\n      return \"something\";\n    }\n  }))\n  .make();\nThe above example delegates to an instance and this instance needs to be stored in a static field. This static field is set to null after creating the class. Within a Java agent instrumentation, a class only exists as a byte array. Therefore, Byte Buddy applies an initialization strategy where the aboves class's initializer (static { ... }) is implemented to call back into Byte Buddy such that the framework can set the static field to carry the anonymous instance. You can avoid this by not delegating to any instances but rather to static methods by supplying a type reference to the MethodDelegation. The problem you observe is caused by the call to getDeclaredField of LoadedTypeInitializer.ForStaticField which triggers the VM to resolve all field types where one is not defined. (Note that Byte Buddy does not access the field in question at all, it is only a side effect of using reflection where all fields are loaded implicitly as part of the field search.)\nThe strategies you mention have different levels of resolution:\n- NoOp does not apply any class setup. This only works if there is nothing do be done, i.e. there are no static fields to set up and there exist no auxiliary types (An auxiliary type is a helper class, like an inner class for implementing a Runnable that fullfils the @SuperCall contract.)\n- Minimal does not apply any LoadedTypeInitializers and only loads auxiliary classes that are explicitly marked to be safe. Loading an auxiliary type can cause problems when the auxiliary type is a subclass of the instrumented class what would cause the subclass to be loaded.\n- SelfInjection is a strategy where Byte Buddy implements the class initializer to set all fields once the class is loaded. The initializer then calls back to the framework and asks for itself being initialized. The type of self-injection determines if the auxiliary types are either loaded in the intiializer (LAZY), during instrumentation (EAGER) or depending on their safeness of being loaded eager or lazy (SPLIT).\nIf you choose to not use SelfInjection, you need to make sure that you initialize your classes manually what is an option to avoid your current problem. The real problem is though, if the dependency is missing, it is not possible to set any field of the class using core reflection. Even if you do it manually, reflection will always fail with a ClassNotFoundError. The easiest way would be to include a dummy class in your project that is named org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader. This will not trigger that Spring Boot considers Groovy to be present but avoid the resolution error.\n\nLooking at your stack trace, one possibility would be to avoid any field setting on your agent. Instead of delegating to an instance, rather delegate to a class. You can then set the instance to which you actually want to delegate as a static field in the delegator. This way, Byte Buddy does not need to reflectively access the class in question and the JVM never attempts to resolve the field with the illegal type declaration. So instead of:\n``` java\nclass Foo {\n  public void intercept() {\n    / do interception /\n  }\n}\nMethodDelegation.to(new Foo());\n```\nYou do:\n``` java\nclass Foo {\n  static Foo dispatcher; // You need to set this field!\npublic static void doIntercept() {\n    dispatcher.intercept();\n  }\npublic void intercept() {\n    / do interception /\n  }\n}\nMethodDelegation.to(Foo.class)\n```\nThen again, none of this should be necessary. It is a clear contract that no optional dependency must be part of a type signature as the JVM does not support optional typing. The Spring Boot people should fix this. I did also create a pull request for fixing this trivial problem. Feel free to reopen this issue if you have further problems.\n. Spring uses a lot of optional dependencies but none of this is legal as I currently try to explain it on the linked ticket. There is nothing a third-party framework can do about it and if they choose not to fix it, there is nothing I can do.\nThanks for reporting!\n. FYI, Spring Boot has fixed their bug on HEAD.\n. You specify:\njava\n.type(isAnnotatedWith(Log.class))\n.transform((builder, typeDescription) -> builder.method(any())\n      .intercept(MethodDelegation.to(LogInterceptor.class)\n           .andThen(SuperMethodCall.INSTANCE)))\nWhat you are saying is that you want to intercept any type that is annotated with @Log. However, only your method is annotated with this annotation. Try declaresMethod(isAnnotatedWith(Log.class)) or any(). \nAlso, make sure that this is what you want. Currently, you intercept any method if it is inherited or not. Consider adding isDeclaredBy(typeDescription) to your method matching.\nByte Buddy builds a standard Java agent. The official documentation is rather short but contains all relevant information.\n. Your\njava\nstatic void interceptor(@Origin Method method)\nmethod is package-private. Is this method visible to the Hello class? If not, change the visibility of the static method to public or change the package of the interceptor class and it should work.\n. What you are trying to do is unfortunately not supported by the JVM. There is an enhancement proposal for JEP 159 that wants to add this feature in a future release of HotSpot but I would be surprised to see it merged before Java 10.\nYou can currently only instrument a class when you fully replace a method, e.g. apply a redefinition instead of rebasing a class. And even then you must not add fields (implcitily done when delegating to an instnace). \nWhat you can do as a work-arround is to preemtively instrument all classes and to switch out the interceptor on demand. E.g. do the following:\n``` java\ninterface MyInterceptor {\n  Object intercept(@SuperCall Callable<?> zuper, @AllArguments Object... args) throws Exception;\n}\nclass NoOp implements MyInterceptor {\n  @Override\n  Object intercept(@SuperCall Callable<?> zuper, @AllArguments Object... args) throws Exception {\n    return zuper.call();\n  }\n}\nclass FieldSetter {\n  static void (@This Object value) throws Exception {\n    value.getClass().getDeclaredField(\"foo\").set(value, new NoOp());\n  }\n}\nnew ByteBuddy().rebase(typeDescription, locator)\n  .method(not(isDeclaredBy(Object.class)))\n  .intercept(MethodDelegation.toInstanceField(\"foo\", MyInterceptor.class)))\n  .constructor(any())\n  .intercept(SuperMethodCall.INSTANCE.andThen(MethodDelegation.to(FieldSetter.class)))\n  .make()\n  .load(ClassLoader.getSystemClassLoader(), ClassLoadingStrategy.Default.INJECTION);\n```\nDoes this serve your purposes?\n. Hi, the thing is that MethodDelegation.to(new GreetingInterceptor()) needs to define a synthetic field on the generated class to store new GreetingInterceptor(). If you use MethodDelegation.to(GreetingInterceptor.class), this does not happen (just declare the method static).\nIn this case, you can redefine a class (not rebase). This way, you are however loosing the original method's code.\n. You need to apply the instrumentation at the beginning at your program but in such a generic way that you can exchange the behavior on demand only. So instead of redefining a class, you implement it to always delegate the behavior to custom code, in this case the MyInterceptor.\nYou can then implement this interface and set the field value by value.getClass().getDeclaredField(\"foo\").set(value, new MyCustomInterceptor()) if you need a behavioural change. This way, you can avoid the necessary redefnition of the class, you piggy back on behavior that you have already implemented.\n. You can always rebase the class but it is not legal to substitute the loaded class with its rebased version. You can however always represent the class as an interface within your application and then load the rebased version of the class with another class loader. This does however result in your instances being retained and you would need to capture and transfer their state in some form.\nSubstituting class loaders is not permitted by the JVM.\n. This was adressed in version 1.1.0 - what version are you using?\n. The beta versions have some bigger api changes. This is now more stable since 1.0.0\n. You are right. The update introduced a source-compatible but a binary-imcompatible change. It was necessary to incorporate receiver types into the API.\ni can say that this was the last missing feature such that API incomible changes will not happen anymore until Java 9 comes out.\nI will look into the plugin and incorporate it into the build! Thanks for the hint.\n. To be fair: Byte Buddy is intended to be usable without repackaging as long as the byte-buddy artifact is used rather than byte-buddy-dep. In the 0.* versions, I still considered Byte Buddy a beta version and applied some major renamings and API refactorings. \nI am trying to keep Byte Buddy stable from now on. Since version 1.2, Byte Buddy supports receiver type annotations and therewith all features that Java 8 currently offers. Due to the increasing download numbers I understand that changing the API too much will lead to incompatibilities and this is not in the library's interest. I can however not promise to not make changes outside of major version releases as the byte code format itself - other than Java - is not backwards-compatible and Byte Buddy being an API for manipulating byte code needs to evolve with that format. If I contained changes following a new Java major release in a single release of Byte Buddy, I could for example not support any Java 9 features before I fixed them all into the library. While this would be the ideal solution, this bursts my capacities such that I have to distribute such updates better. Therefore, I will encapsulate API changes in feature versions but mark these changes explicitly.\nThat said, I will from now on announce API-breaking changes in the release notes and I will not apply them form bug-fix versions. Also, I hope that most features are correctly abstracted already and I do not need to change the library too much before Jigsaw breaks all the things\u2122.\nThank you all for your input, I appreciate it!\n. Basically, you want to have a TypePool that uses loaded types when possible but without triggering any type loading by itself? I am a bit sceptical for two reasons:\n1. The above approach can still trigger class loading. A loaded class does not require its field or method types to be loaded. Accessing a field or method of a loaded class can still trigger class loading.\n2. The performance can be terrible in scenarios. Looking up a class is something that happens fairly often when navigating types. For each type, finding out if there already is a loaded type is quite a heavy-load operation. One would need to be very careful when using this approach.\n. I found some time to play with this idea. The problems I discovered with implementing such a solution is both:\n1. The getAllLoadedClasses array can be huge. I tried it on WebSphere, OMG.\n2. A loaded class can be ambigous. On an application server, for example, different loaded classes Foo might exist, so a name is not definite. It is not enough to resolve all classes, one also needs to resolve any class relatively to a class loader hierarchy. This can be tricky with non-standard class loaders with multiple parents that some application servers use.\nWorst case, such a TypePool would return false results. I am not sure if that justifies an implementation, especially since I am bit doubtful about the performance advantages.\n. I hope he is good because I am picky with accepting new features ;)\n. When you redefine a class, the original method is lost. (This is in contrast to rebasing a class.)\nSince the method is lost, @SuperCall Callable<?> zuper cannot longer be bound as there is no super method (the original method is replaced) and Byte Buddy throws an exception.\nYou would need to apply a Java agent to get what you are attempting where you get a chance to redefine a class before it is loaded for the first time. It is not possible to add a new method to a class after it was loaded which is why rebasing the classes as you intend it is impossible.\n. What you are trying to do is exactly what Byte Buddy would do when using a rebasement. Unfortunately, a rebasement needs to copy the original method into a new method in order to low the external @SuperCall trigger.\nWhat you can do: \n1. You define an AgentBuilder and modify the class before it is loaded for the first time. This way, it is possible to transform the method as you intended it originally.\n2. Alternatively, you can use Byte Buddy to prepent the ASM code to your method. This way, you do not require Byte Buddy to create external triggers. This is possible using a AsmVisitorWrapper.ForDeclaredMethods where you can prepend byte code to existing methods.\n. You are welcome. Feel free to reopen this ticket if you have further questions.\n. Of course that is possible:\n``` java\nclass MyInterceptor {\n  public static Object intercept(Object arg) {\n    // do what you intend to do such as:\n    return ((Person) arg).getName();\n  }\n}\nnew ByteBuddy()\n  .subclass(AttributeGetter.class)\n  .method(named(\"getAttr\"))\n  .intercept(MethodDelegation.to(MyInterceptor.class))\n  .make();\n```\n. You can just hard-code a method call using dynamic assignment:\njava\nnew ByteBuddy()\n  .subclass(AttributeGetter.class)\n  .method(ElementMatchers.named(\"getAttr\"))\n  .intercept(MethodCall.invoke(Person.class.getDeclaredMethod(\"getName\"))\n                                    .onArgument(0)\n                                    .withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC))\n  .make();\nAlternatively, make your interceptor a bit more flexible and use it as an instance rather than a class reference:\njava\nclass MyInterceptor {\n  private final Method method; // constructor omitted\n  public Object intercept(Object arg) throws Exception {\n    return method.invoke(arg);\n  }\n}\nI do however believe that the first solution is cleaner and it surely is a bit more performant.\n. I added support for the new JDK 9 version string but I do now depend on the jdk.Version class which is supposed to be renamed in the future. As for the byte code level, Byte Buddy still treats Java 9 as Java 8 byte code as the byte code level was not yet updated in the JDK. This is always done rather late in the process.\n. This problem is not as easy as it might seem as this requires a dependant change in two classes and not an isolated change. To make Byte Buddy do this, you would need to memorize the change in A in order to make the change in B valid whereas the JVM does not offer a standardized way of reading the instrumented version of A during the instrumentation of B. In theory, it would be possible to store modified byte code of a class but this would potentially cause memory leaks as there is not possibility to decide that all subclasses of A are loaded.\nI do not know if your example resembles your actual problem but I would isolate the change to A if I were you:\njava\nnew AgentBuilder.Default()\n  .type(ElementMatcher.named(\"Agent$A\"))\n  .transform((builder, type, loader) ->\n      builder.method(named(\"test\"))\n             .intercept(MethodDelegation.to(MyInterceptor.class)))\n  .installOn(instrumentation);\nwith the following interceptor class:\njava\npublic class MyInterceptor {\n  public static String intercept(@This Object instance, \n                                 @SuperCall Callable<String> zuper) throws Exception{\n    return instance instanceof B\n        ? \"B\"\n        : zuper.call();\n  }\n}\nDoes this solution work for you?\n. I agree with you that it should ideally be possible to view classes in their transformed view, i.e. the A class where the method in question is no longer final but this is difficult to achieve in the current implementation. Ideally, I would like to implement a TypePool where loaded classes are described by these loaded Class instances but this can contradict the current instrumentation if these classes circularly reference the currently instrumented class. Therefore, Byte Buddy rather manually parses byte code that is provided by the class loaders where classes always appear in their original format.\nAlso, as for diagnostics, I agree with you. The problem here is that Byte Buddy aims for performance what sometimes contradicts the collection of additional information that would make such debugging output meaningful. Other than make, Byte Buddy is executed at runtime, after all. I did however try my best to avoid obscure scenarios and added hopefully explanatory exception messages. Please bring up any specific case you experienced and I will try to make the library better.\nFor your last point, I believe that can be solved. In the end, you can always change your interceptor once you learn about a new class as in:\n``` java\npublic class MyInterceptor {\n  static Map, Dispatcher> dispatchers = new HashMap<>();\npublic static String intercept(@This Object instance, \n                                 @SuperCall Callable zuper) throws Exception{\n    Dispatcher dispatcher = dispatchers.get(instance.getClass());\n    return dispatcher == null\n        ? zuper.call()\n        : dispatcher.dispatch();\n  }\n}\n```\nI am closing this question. Please reopen it if you have any further questions.\n. No worries. Just ask if there are any more questions.\n. As you closed this ticket, did you manage to resolve this issue by yourself?\n. Hi Felix,\nthe interception API requires the modification of the original class format which is not permitted by most JVMs. (Actually, there is a JEP for allow such transformations, one beautiful day in the future.)\nFor runtime instrumentation, you need to use the advice API. For timing a method, you would use code like the following:\njava\nclass Advice {\n  @Advice.OnMethodEnter\n  static long enter() {\n    return System.nanoTime();\n  }\n  @Advice.OnMethodExit\n  static exit(@Advice.Return long value) {\n    System.out.println(System.nanoTime() - value);\n  }\n}\nThis was the easy part. Unfortunately, the Advice API does not currently allow to intercept methods with arbitrary arity what I assume you require. Otherwise, an explicit argument of an intercepted method can be accessed using @Advice.Argument(x). Adding a possibility to extract a signature would be trivial but expanding the latter mechanism to random arities would be a tougher extension.\n. Hi Felix, all of this is possible using Byte Buddy. Byte Buddy agents are created by specifying ElementMatchers. This way, you can specify generic type / method pairs to instrument. Doing so, you can:\n- Adding local variables: In the code example above, I already showed how you can transport a local variable on the stack from the before to the after method. For the future, I also plan to allow adding further local variables by a designated annotation such that becomes possible to transport several values via the stack.\n- Accessing the return value: Add an annotation@Advice.Return in the @Advice.OnMethodExit method.\n- Adding catch clauses: Add an annotation @Advice.Thrown in the @Advice.OnMethodExit method. If no exception was thrown from the intercepted method, this parameter will be null.\nAs for the other points:\n- Performance: Byte Buddy should be much faster here. It uses the advice methods as byte code templates and simply remaps parameter access to the corresponding values of the instrumented method. All of this is single pass-through. One current performance downside is that Byte Buddy still computes the frames from scratch, so it could be even faster but this feature is on the bucket list.\n- Class loaders: The type matching is applied by matching a type / class loader pair. To share objects between classes loaded by different loaders, I would suggest you to inject a dispatcher class into the bootstrap class loader which is visible to all class loaders. That is common practice for communicating without being constraint by custom class loader implementations. Such a class would be quite trivial. For example, a class like:\njava\npublic class Dispatcher {\n  public static Map<Object, Object> VALUES = new HashMap<>();\n}\ncan be injected into the bootstrap class loader using the Instrumentation API. Byte Buddy can help you to write a class file into a jar but this is not too difficult to do, even without the library. \n- Chaining agents: Byte Buddy respects chained agents by default.\n. Hi Felix,\nthe unit tests show several examples of how to use the Advice API. With the agent builder, there does not change much. You simply integrate it into the builder as in the unit tests. The interface is identical:\njava\nnew AgentBuilder.Default()\n                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n                .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)\n                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)\n                .type(ElementMatchers.named(ProfiledClass.class.getName()))\n                .transform((builder, typeDescription, classLoader) -> builder\n                        .visit(Advice.to(MyAdvice.class).on(ElementMatchers.any()))\n                .installOnByteBuddyAgent();\nAs for the appending: Yes, this is what I mean. You would need to create a seperate module that only contains this single class. The accessing code would only reference this module in provided scope whereas the agent would contain the entire jar file, store it on disk and append it to the bootstrap class path before applying the instrumentation. This way, the class becomes available universally on the JVM. Byte Buddy has an API for extracting a class file for a given class but ideally you would simply bundle the full jar and never load it implciitly via the agent. If the Dispatcher class ends up being loaded twice, you might end up accessing two different maps from different places.\nPlease not that you should use the latest snapshot using a solution like Jitpack. I have extended the Advice API a little bit last night and you might require the additional annotations. If you find any problems, please let me know and I will look into it and see how I can improve things.\nI am closing the issue. But please feel free to reopen it if there are more questions.\n. Yes, this is exactly how it would be done.\n. There are several problems with your code. First of all, I recommend you to register a listener to your agent for debugging purposes. Byte Buddy prevents the instrumenting procedure from throwing exceptions what is not supposed to happen within the VM's internal byte code transformation stack. Therefore, illegal transformations are simply suppressed. You can for example set:\njava\nnew Agent.Builder().with(AgentBuilder.Listener.StreamWriting.toSystemOut())\nwithin your test. Doing so, you can see that the advice adapter complains about incompatible types in your exit-mapping. You are using @Advice.Return where you want to use @Advice.Enter. But as a matter of fact you want to do both:\njava\n@Advice.OnMethodExit\npublic static void exit(@Advice.Enter long value, @Advice.Return int value2) {    \n  returnValue = value2;\n  executionTime = System.nanoTime() - value;\n}\nFinally, the Advice adapter will still complain. It will say that the makeSureClassIsLoaded and the class's constructor do not return int. If you change your matcher to ElementMatchers.returns(int.class), everything works as you expect it.\nNote that the current release adds some performance improvements to the Advice which do however break for advice with \"too comples\" branching instructions. To avoid this, set\njava\nAdvice.to(ProfilingAdvice.class)\n  .on(ElementMatchers.returns(int.class))\n  .writerFlags(ClassWriter.COMPUTE_FRAMES))\nfor now. I hopefully find time to fix this some time this week.\n. Just a quick note: With Byte Buddy 1.3.9 (released just now) everything should work as expected. The component is still quite young but I think it has now matured to something of full production quality.\nI also squeezed every last bit of performance out of the Advice component by translating stack map frames compared to computing them from scratch for each interception. I also made sure that the computed frames are optimal, i.e. that they do not add any overhead compared to a scenario where the Java compiler generates them. In the process I found out that computation of stack map frames based on byte code compared to Java source code does not allow for arriving at optimal frames but results in bigger frames which contributes to the method's size. Computation also requires a lot of IO for reading many class files as the full type hierarchy for every type needs to be considered. All this goes away with the newly introduced frame translation.\nLet me know how it goes. I appreciate any feedback if you find mistakes or API limitations.\nFinally, for purposes of a runtime agent, I added a convenience method. Simply start your agent with:\njava\nnew AgentBuilder.Default()\n  .disableClassFormatChanges()\n  .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION);\nand you are good to go. The overall setup for redefining agents was a bit too verbose for my taste.\n. Hi, it is no problem to implement advice adapters that are capable of reading a boxed return value or that read an array of arguments. The semantics would be pretty easy:\njava\nvoid advice(@Advice.BoxedReturn Object ret, @Advice.BoxedArguments Object[] args);\nThe boxing would happen whenever the parameter is accessed.\nAdding callbacks is however less trivial but I will think about a way that allows to inject custom code by custom annotations. This would probably work something like:\njava\nAdvice.to(MyAdvice.class)\n           .bind(MyAnnotation.class, method -> method.getReturnValue())\n           .on(myMatcher);\nThe first two are quick fixes but the latter one can take some time. I hope to find some time before the end of the month.\n. That went fast. Thank you for giving the library a chance, that is exciting!\nIn the mean time, I have implemented all the required additions to the Advice adapter on the development branch. I still need to add documentation and some additional tests before I merge it to master and release a new version. However, if you want to try the features out already now, simply build the branch yourself without the checks Maven profile:\nYou can now read a return value as an Object type by @Advice.BoxedReturn and arguments by @Advice.BoxedArguments. You can also inject individual values into the advice methods by registering your own annotations using Advice.withCustomMapping() and using them on your advice class.\nFor exporting byte code, you can register an AgentBuilder.Listener where the byte code is exposed via the DynamicType instance on the onTransformation method call. From this callback, you can persist the byte array representing the transformed class file.\nI can only speculate why the order of the transformers matters in your code. Byte Buddy respects transformations that were applied before it, i.e. it takes the byte array that the class file transformer hands over and does not read the class file from disk. I assume that there might be an error or some problem with the class file. A listener can expose such potential problems.\n. I think I understand the problem now. I do not register the exception handler in the correct order. In case of an exception, Byte Buddy steals any exception from a nested try-catch block and the inner exception handler is never triggered. This is of course not supposed to happen and can cause significant problems. Good catch!\n. All fixed now with Byte Buddy 1.3.11. The agent order does no longer matter and the new annotations are introduced as well as a mechanism for adding custom annotations with runtime-dependant constant values was added. I also extended the @Advice.Origin annotation a bit but if this does not suffice, you can build a string programmatically by using the Advice.withCustomMapping() API.\nThe new version is currently uploaded to JCenter and should synchronize with Maven Central until the end of the day.\n. Hi, thanks for the report. It seems as if there are still some issues with the Advice component, sigh. I try to have it fixed as quickly as possible. Also, I indeed forgot the docs. I added #s for the signature and #r for the return type.\n. The problems you found showcased another problem with the computation of remapped offsets in the advice. Sorry for these childhood diseases, the component is six weeks old and testing stack map frames is not trivial.\nPlease let me know if anything else blows up and I will fix it. All that you reported in is fixed in 1.3.12 that is already synchronized to Maven Central and JCenter.\n. I am currently contracting for a firm who needed such a component and they were generous enough to let me open-source. All this gave me the time to bootstrap Byte Buddy Advice.  Ever since, the component is a part element of my current contract. The library itself is however a free-time project. Not that I did not like to get payed to work on it from time to time, I would love to add much more documentation, for example.\nThe bugs you encountered were not big issues from an implementation perspective and were therefore fixable in short time. The last bug was basically a one-off error when remapping exception tables what is much more difficult than it should be because of the order in which ASM processes meta data. As a matter of fact, the errors always seem much worse than they are. The JVM is (for a good reason) very resolute even about small inconsistencies in a class file. Java is meant to be a safe platform; anything slightly ambiguous fails the class loading even if it would not affect the execution result.\nYou can set an option for ASM to recompute the frames from scratch but be aware that the frame computation is much heavier than Byte Buddy's remapping. For it, ASM needs to parse all class files that are super types of any class that are referenced within a method what causes a lot of I/O. One of the major reasons for avoiding the recomputation is also that ASM sometimes fails to compute correct frames; the remapping is another way to cover corner cases where ASM cannot help out. If you implement a switch, you might however be able to offer a quick fix for some people, so you might just make it an option but I would not recommend making it the default as this option can also break complex code. (Btw, Javassist is also known to struggle sometimes, especially when instrumenting dynamic code such as Clojure or Javasscript where the languages need to map everything to static types in their byte code what sometimes results in ridiculous combinations.) None of this is common, but bug reports still pop up regularly.\nThe idea of remapping frames means that we use stack map frames that were already inserted by the origin-compiler which has more information about the original program as it knows the source code. For example, javac knows control flow such as if-else or while whereas all of this is reduced to goto statements in byte code. When recomputing stack map frames from byte code, you face an inherently more difficult task than javac as you need to compute a common set of types that is available at any statement that can be possibly reached from a goto. The control-flow is less structured than in most high-level programs, so to speak. If these gotos are nested, this can become quite intense and in the worst case, the approximation of these computed stack map frames does not match the verifier's expectations even with ASM. This is quite frustrating if you do not have another choice as Javassist or generic ASM does not but I found this loop-hole to make Byte Buddy work with existing frames that were inserted by the root compiler as long as the advice method is of byte code level six or higher. In this case, if the remapping is working correctly, I can make only small changes to already existing stack map frames what allows me to do the computation in a single pass-through of the byte code while not suffering the same problems when instrumenting less deterministic languages such as Clojure. But as it has not been done before I  experience a few bumps on the road with byte code information that is non-sequential to the instruction set (such as exception tables). All this just as a quick overview to the problems you experienced and what trade-off to consider when offering to activate the stack map computation by ASM. I really hope this is the last version I need to deploy to fix the Advice component, though.\nYou should also know that all of the previous problems were caused by the byte code generation engine which then fed wrong stack map information to the meta data processor. ASM \"fixed\" this problem by voiding certain stack map indices in its recomputation which worked for some (common) scenarios where the voided index was not accessed at a later point within the advice method. Making ASM recompute the frames did however not offer a universal solution as there was still an inconsistency in the generated byte code / exception table. In the end, I will always rather fight the cause, not the symptoms but I understand that a quick-fix might be desirable for a production environment.\n. You can not put a break point into the advice method, that is true. You can however set break points in the original method even after it was instrumented. The original debugging information is kept intact by Byte Buddy. Triggering breakpoints from the inlined advice method is not possible on the JVM as any class file can only maintain a single reference to any source file. Within a method itself, only line numbers are set as debugging information and no separate source file can be referenced. Therefore, mixed origin sources are not possible.\nYou can however call your advice methods directly from a unit test where setting break points is possible.\n. That is indeed strange. IntelliJ has added some functionality to discover mismatches of byte code and source code in 2016.1 to discover debugging the wrong source in case of a version mismatch. Maybe that changed something (and maybe you can turn it off)? Debugging client code works fine on 15.0.5. I rolled back to that version myself after my current work project did not play together well with 2016.\n. Since you are applying runtime attachment, you want to use REDEFINE_DECLARED_ONLY (which the Advice enforces implicitly anyways) as you must not change the class file layout what is not supported by the JVM.\nThe easiest would be to simply drop the requirement isSubTypeOf(DataSource.class) and define the advice as @Advice.This Object dataSource instead where you add a condition:\njava\nif (!(dataSource instanceOf DataSource)) { \n  return; \n}\nin the beginning of the method. This is the only way for Byte Buddy to guarantee that the advised method can always fulfill the contract of the advice method. As the AbstractTestDataSource is the only type that declares the method, doing the type check upon the method call is the only way of doing it anyways, even if Byte Buddy did the check for you but I think making it explicit makes this more intuitive. Byte Buddy can not virtualize the call for as this would imply changing the class layout for subtypes. If any implementation of AbstractTestDataSource is an instance of DataSource, the JVM will remove the check anyways at runtime.\n. Hi, glad it is going so well!\nI am not sure if I understand correctly how you imagine the @Advice.OnClassLoaded annotation. Do you want to use it similarly to a static initializer block? This would require to add such a block and would require a byte code change what is illegal for retransformations if no such initializer already exists. Can you maybe give an example for what you require?\nAlso, I maybe I do not think about it correctly but does the InjectAnnotationDynamicValue work? An annotation value cannot be added to a class's constant pool and therefore it should not be able to serve as a dynamic value as the annotation is non-constant.\nFinally, can I ask you why you add the intermediate dispatcher enter instead of making monitorSla the dispatcher? Are you trying to avoid byte code size or are there still problems with the remapping?\n. Have you looked at the AgentBuilder.Listener API? It allows you to apply a callback for onTransformation which is invoked after a type is successfully transformed. The callback provides the instrumented type and lets you do this independently of the Advice component what I would consider a better separation of concern. You can implement a callback such as:\n``` java\nclass MyListener implements AgentBuilder.Listener {\n  // omitted other callback methods.\n@Override\n  public void onTransformation(TypeDescription typeDescription, DynamicType dynamicType) {\n    for (MethodDescription methodDescription : typeDescription.getDeclaredMethods()\n          .filter(isAnnotatedBy(SLA.class).and(isAnnotatedBy(SLAs.class)).and(isAnnotatedBy(MonitorRequest.class)))) {\n      SLA sla = instrumentedMethod.getDeclaredAnnotations().ofType(SLA.class).loadSilent();\n      SLAs slas = instrumentedMethod.getDeclaredAnnotations().ofType(SLAs.class).loadSilent();\n      MonitorRequest monitorRequest = instrumentedMethod.getDeclaredAnnotations().ofType(MonitorRequest.class).loadSilent();\n      // do some validation here\n    }\n  }\n}\n```\nLet me know if this does not work for you. If there is something missing in the way the transformer works, I will think about how to extend the callback mechanism. I would rather create a more generic listener mechanism than extended existent transformers with transformer-specific callbacks.\n. As for injecting the annotation itself: This is unfortunately not possible. For the Java runtime, a read Java annotation is nothing but another object. Those cannot be represented within a constant pool.\nIn a Java class file, an annotation is stored as meta data for each byte code element that can be annotated (which is almost anything since Java 8, Byte Buddy only recently added support for type annotations). This meta data table is not processed by the JVM's runtime and you can write more or less anything into it. Even if the data is missing or corrupt, the JVM does not care about it as this section is not even processed by the verifier to leave room for extensions and other JVM languages. For this and other reasons, you cannot access this meta data from Java byte code which is statically verified; the meta data is kept entirely separate. The only way to access an annotation is via reflection where the API - under the covers - manually accesses the underlying class file, parses the annotation values and creates a new object that implements the annotation interface. Once this reflective call returns, the annotation is just another instance with its own identity. None of this can be done via Java byte code.\nAll you can do is to extract the values of the annotation into primitives that can be stored in a class file's constant pool (such as String values and primitives).\n. I thought about it but I eventually decided against it. I could of course modularize it but one of the downsides of the convention-over-configuration approach is the requirement of generic components needing to know a default implementation additional to the interface to any dependant component. Slicing out the non-default features would however not save much space. My reasoning:\n1. For server applications, two megabytes for a dependency do not matter much.\n2. If size matters (like on Android) you should shade and minimize your dependencies anyways to reduce the artifact size. Only removing debugging information from Byte Buddy would save you more than any modularization. (ASM does not include debugging information to \"be small\" by default and it makes the library a pain to work with. I think considering size here has caused more problems than advantages which makes me sceptical about this.)\n3. Many components require ASM under the covers which I shade. For this, I would need to offer all modules as both -dep and shaded versions, this would become a problem if some project accidentally uses the non-shaded artifacts in a different module combination to another project that uses the shaded ones. NoClassDefFoundError all the things...\nIn the end, Byte Buddy is more or less feature complete, the size will probably not increase much over the years whereas memory gets still cheaper so time is on my side as well.\nAnd yes, I would love to blog and write and speak more about Byte Buddy, there are many great features that only I really know about but money needs to be earned and only development steals most of my \"free\" time, unfortunately. One beautiful day! In the mean time, the more people start using Byte Buddy, the more ready code examples people can look at, so you are partly taking this job away from me ;)\n. This is indeed strange. The ASM part is cryptic because - as mentioned - it does not include debugging information. I tried to run the test myself just now but I cannot reproduce it. Does the error always happen? Maybe you changed something while debugging and pushed ASM into an illegal state as it seems like a problem within ASM?\n. I did check out that branch and I have run the test from the recent version. Just pulled this second and ran the test, it is successful without any stack traces.\nHave you tried with a recent jdk __77_? There were bugs within _javac_s code generation before that ASM could not process (but that are flagged as acceptable by the HotSpot VM to avoid a regression. I run a 64 AMD build on Linux.\n. That is strange. Do you have your current state committed? Everything works fine on my machine. Might even be a bug in the MacOS build.\n. Ah, I should have mentioned this. By default, Byte Buddy runs in a debugging mode where it validates additional properties. This is the default because I get so much mail and introducing this really cut this down. Before, defining illegal types (such as interfaces with a constructor etc.) would cause a verification error which is less clear.\nYou can turn this off by setting\njava\nnew AgentBuilder.Default(new ByteBuddy().with(TypeValidation.DISABLED));\nBut I recommend it to turn on during debugging and tests. I will have a look at the problem with the modifier. And no, I run Linux, not MacOS.\n. I do generally recommend people that shading Byte Buddy is not required. That said, the API does change, I try to avoid it but small changes are common, I do not deprecate minor API chages, at least not for the time being.\nWould you shade Guava? If yes, you can consider it but after all they do already more changes then me, for example.\n. I was able to reproduce the stack trace on a collegues Mac. I will look into this some time. Does the same happen when you run the InstrumentationPerformanceTest from your IDE? Just checking for quicker reproduction.\nAlso, I found the validation problem; Byte Buddy does not resolve synthetic fields correctly. Will be fixed some time soon.\n. I also tried it on a Windows machine in my virtual box and it does not show up there, either. Seems to be mac-specific.\n. All of those are fair points but the big problem of this approach is the fact that the advice method must be visible to the instrumented class what can be difficult in certrain class loader setups. Also, it is no longer possible to load values lazy. You can however already emulate this behaviour by creating a dispatcher advice class manually.\nIt would however not be difficult to implement something like this, I will have a look.\n. As a matter of fact, I think you can already improve a lot by setting a better ignore class loader on the agent builder. The default ignore matcher rejects type that are synthetic what already requires parsing the class file of this type. The default was set because it is a requirement for many smaller agents.\nIf you specify a pair of type and class loader matcher, note that the class loader matcher is executed first as they are typically cheaper. All types are first evaluated by the ignore matcher then by the type matchers for transformation and for each pair, the class loader matcher is applied first.\nByte Buddy heavily optimizes for matching names as those are available from the transformer API without parsing a class file. If you can exclude a namespace, always add this first, Byte Buddy only parses class files if it must. Also, if it holds your case, make sure to ignore classes loaded by the bootstrap class loader; that might be a heavy load there already. Note that matchers such as subclass or super class matchers are typically the most expensive (if a class is not yet loaded) as it might trigger class loading.\nIf you do not care about a class being loaded during transformation, you can use a different BinaryStrategy.\n. As in:\njava\nnew AgentBuilder.Default().ignore(any(), isBootstrapClassLoader());\nThe default is:\njava\nnew AgentBuilder.Default().ignore(isSynthetic(), any());\n. Also, if you can guarantee that two interceptor do not need to redefine the same type, it makes sense to rather chain all type matchers in the same agent builder and only register a transformer (\"installOn\"). Otherwise, Byte Buddy has to serialize and deserialize a type several times.\n. I have looked into the issue with the modifiers and the field validation. Seems to be a Java 1.0 obscurity that I have not come across. I need to do some research as it is difficult to get hold of a spec for Java 1.0 but I will take care of it in the long run.\nOtherwise, it is sufficient to disable validation here to avoid the problem in the mean time.\n. Performance should not be the issue. From my experience, Byte Buddy by itself is normally a lot faster than Javassist because it does not serialize the byte code and because it does not need to compile source code but works exclusively on the byte code level. The performance is lost by excessive matching, I am sure. (Good to see how performance improved, I did not see your last posting before writing this.)\nAs for your matcher: Caching is probably the best way. I would add a weak-hash-map to your class utils where you reference class loaders mapping to a boolean. That way, you do not leak the class loaders and once a loader is collected it is collected from the map but has anyways become irrelevant to you. The current exceptional-control-flow is quite expensive. Also, the class loading attempt itself burns quite some cycles.\nFor the matchers: You need to read them as a pair. The first line reads ignore any type loaded by the bootstrap loader whereas the second line reads ignore synthetic types that are loaded by any class loader.\nAnd yes, the \"ignore matcher\" is a pre-filtering mechanism. Many users of Byte Buddy have delegation components that register different matchers (as you do). This makes it desirable to apply a pre-filtering. If you for example know that you never want to instrument any class from the bootstrap class loader, you can set the suggested switch. This already excludes a couple of thousand classes from the JDK that do not longer need to be matched (and parsed) by Byte Buddy if some matcher wants to instrument any subclasses of some domain class. As I mentioned, Byte Buddy parses types lazily if you can exclude a match for a class loader or the type's name. This way, you can avoid ever resolving a class file to a TypeDescription what saves significant amount of time. The alternative would be to wrap any component matcher by such an exclusion matcher what I consider less clean. (Great to see the improved values, I wrote this before you put your answer.)\nAs for the reported bugs: I found the problem with the field modifier validation and it is a strange \"feature\" of ASM that I did not know about and that is neither documented or mentioned in the public API. In old class files (like Java 1.0 which log4j is compiled to) some flags did not exist and were rather included as debugging attributes. ASM communicates this implementation detail by returning pseudo-flags that are out of the valid range and that I never considered. I already fixed it on master and include it in the next release. But for a production environment you should always disable the TypeValidation to save you quite some overhead in resolving all byte code elements for a valid state.\nI still need to do some digging about the MacOS problem, I have only limited access to MacOS and I only run Byte Buddy's test on Linux and Windows (in a virtual box). But I will find out about it and fix it as soon as I find the time; cannot be a big issue. If you want to speed this up a bit, maybe you can set an exception break point for the out of bound array index and  and help me to narrow this down a bit further. For example: what exact method is breaking in ASM; even with the missing debug information, IntellIj is normally smart enough to figure out an approximation.\nAlso, I looked into the delegation over inlining thing and the implementation is quite trivial so I will add it. I have not yet decided if I make it an API feature such in Advice.withDelegation().to(type) or if I add an annotation property to the OnMethodEnter and OnMethodExit annotations. I find the latter more intuitive since several things will not work with delegation (such as changing fields, parameters or return types) and this should be explicit at the declaration site. However, the other option is resolved at runtime rather than at compile time what can be of advantage. Any inputs on this?\nFinally, I have thought about your problem with including \"any\" values with the custom annotation and I came up with something that is surprisingly reliable. If you return a serializable value (such as an annotation instance), Byte Buddy will now serialize this instance and add the string-encoded byte array to the class's constant pool. Upon accessing the custom parameter, the dynamic class decodes and deserializes the instance and assigns it to the accessed index within the advice method. This adds some overhead but deserializing from a byte array is not as bad as standard serialization when it comes to performance. In the end, this is however more of a \"handy\" feature as it is applicable in a context of high-performance requirement.\n. Your ignore matcher looks good but in the spirit of this matcher, you probably want to exclude jdk.* as well as OpenJDK 8 moved most internal classes to this namespace. The same goes for the old namespace sun.*. When not running Websphere, the majority of classes of a Java application comes from this region so exluding those really pays off.\n. You are correct. You need to chain the matchers if you want to achieve what you are trying:\njava\nignore(any(), isBootstrapLoader()).or(nameStartsWith(\"com.sun\"))\nshould do the trick. This way, you define two pairs which are matched subsequently. The com.sun part is only required if you want to exclude tooling which the JDK normally loads with the system class loader. Other VMs, like J9, do however have a different namespace for those.\nAs for manual vs automatic delegation: the big advantage is that you do not longer need to parse the byte code of the delgation targets what improves performance. Its not on my priority list but I will do it once I find the time.\n. I added the delegation approach in 1.3.13. Simply set inlined = false within OnMethodEnter and OnMethodExit. If the method is visible, implementing this advice is actually much faster as you only need to parse the byte code of one method instead of 2 or 3.\nI also fixed the bug with the field validation, I will have a look at the MacOS-related bug once I have the time and access to the hardware.\n. You can have a look at the TypePool.LazyFacade to see how it is done. Basically; access to the first non-name property triggers the parsing by delegating to the regular pool.\nThat said, both the ignore matcher and any regular matcher can trigger parsing. They do not have different semantics.\n. I recently struggled with this myself. I changed the signature in 1.3.13 to include the class loader.\nThere is no explanation on why a class is ignored, this would limit the scope of the matchers which currently can be custom and statefull.\n. No, variable names do not even exist in the eyes of the virtual machine. All that exists is an indexed space where longs and doubles take two slots. Byte Buddy only remaps any access to the correct index in this space when a method is inlined. Also, the debugging information is discarded as it is not possible to point to a different class file than to the original one.\nAlso, I am not a big fan of argument objects as arguments should travel on the stack and not on the heap. At the same time, I am aware that those additions are breaking changes but the entire agent part is about a year old and the listener is not used too much. In a world where Guava breaks its APIs every other month, I think people that still maintain there software upgrade pretty regularly and the download statistics confirm this view. I would not do this with a more mature component but I am pretty sure that I will not extend the listener from here on.\nI looked at the JBoss class loader as well. The class loader offends the class loader contract at multiple points what is not surprising for an application server that needs to be child-first. The problematic part is its filtering for namespace prefixes where only classes within java/ are attempted to be loaded by the underlying bootstrap class loader whereas any other namespace is excluded by a premature ClassNotFoundException if it cannot be located by the module class loader itself. This is really a bug in JBoss which incorrectly assumes that no class loading of a bootstrap class outside of the java. namespace can ever be initiated via the JBoss class loader. I could name you at least 20 tools that would break by this assumption and even the OpenJDK has added additional root namespaces over the latest releases that would not be covered by this assumption.\n. are you calling installOn 18 times? And how did you apply the transformation before using Javassist and how long did that take?\nIn order to being able to instrument all classes, Byte Buddy needs to firstly register a class file transformer and then afterwards iterate over all loaded classes which are provided by the instrumentation API. If a class is loaded during iteration, this class will be catched by the class file transformer. Otherwise, classes would slip through the cracks, it is really the only way to do it correctly, even with Javassist. I assume that this procedure is what takes time.\nIf you install 18 agents without applying a transformation, this will be done 18 times for each agent and will probably take ~18 times as much time. I assume that in your case you should use a compound agent if the time for applying attachment matters (most of the time it does not as the attachment API runs in a separate thread when attaching after startup).\n. Then I assume this is the problem. \njava.lang.instrument.Instrumentation#getAllLoadedClasses is a rather expensive operation (needs to reach a safe-point internally to collect all classes from all class loaders; stop-the-world-event, i.e. blocks internally until the information is available) and you should avoid calling it from a main thread. If you use runtime attachment, it should however not influence application performance much as it only needs to wait for this (natural) event to happen - it \"only\" has poor latency implications so to speak - without consuming resources in the mean time.\n. Ok, what do you then mean by startup time? I still suspect that the 18 chained transformers are the problem, without being able to point a finger without looking a bit deeper into it.\nAlso, I just pulled stagemonitor on a Mac to look into your problem with ASM not being able to parse some class file and I could no longer reproduce the problem. Did you find out the root of the problem?\n. Can you reference me a tag from a revision where it still occured? If the stack trace lies in ASM, I am pretty much certain that the class file was corrupt. Therefore I would still like to investigate the problem. (Might also explain why I could not reproduce it at the time.)\nAbout the start-up time: is this really a significant factor in APM? I understand that you do not want a regression but I still hope that is no show-stopper. Yet I am pretty certain you can speed this up by merging the transformers.\n. Seems like the class file is corrupted at this point but as it does not longer occurs I am no longer breaking it down. I have evened out some rough edges since 1.3.12 so I simply assume it was covered by some of the obscurities I have found.\n. That is really good to know and a relief for me too; the registration of multiple agents is indeed not ideal if you have a lot of agents and if time until completion of attachment is an important factor; I never experience this situation myself. I will try to build a better compound agent in the future to require less manual work to set up your scenario. This should not even be a big problem to make.\nAnd you are very welcome for the help; as said, the advice component is six weeks old; having a framework stress testing it a great opportunity for myself to even out the early problems.\nThe ClassCircularityError comes from you instrumenting a class that is used by the framework during instrumenting a class. If your agent code loads a class for the first time, this class will also be passed through the transformer and be transformed by Byte Buddy which is now currently transforming the class (i.e. a circularity). In your case, you are using ApplicationClassLoaderMatcher which is using a MessageFormatter for logging. This means, the first time the formatter is used, Byte Buddy is triggered and tries to instrument the formatter which is again required for applying the instrumentation.\nTypically, you should exclude all classes that you require yourself within the agent any you should also exclude Byte Buddy. Ideally, you are loading the entire agent code from a separate class loader and simply exclude this class loader. Within the agentmain method, you merely initiate the agent and then call an initiation method.\n. By the way, if you have comparions from Javassist to Byte Buddy that relate to runtime performance, I am more than happy to look into the numbers. Javassist is a good framework but it is much more low-level in its workings (and requires more manual work, in my eyes). Code generation performance is a topic I get asked about a lot so I am happy to see any hard fact. I have enough numbers on the generation itself but less on writing an agent.\nThanks for that!\n. I just looked into the performance difference and I found what makes the difference. You are optimizing for reusing the ClassPools of Javassist what Byte Buddy does not do to avoid memory leaks. (As a matter of fact, I would consider your current implementation a memory leak). This is how it is done in Stagemonitor:\njava\nprivate CtClass getCtClass(ClassLoader loader, byte[] classfileBuffer, String className) throws Exception {\n  final int classLoaderHash = System.identityHashCode(loader);\n  ClassPool classPool;\n  final String classNameDotSeparated = className.replace('/', '.');\n  if (classPoolsByClassLoaderHash.containsKey(classLoaderHash)) {\n    classPool = classPoolsByClassLoaderHash.get(classLoaderHash);\n  } else {\n    classPool = new ClassPool(true);\n    classPool.insertClassPath(new LoaderClassPath(loader));\n    classPoolsByClassLoaderHash.put(classLoaderHash, classPool);\n  }\n  classPool.insertClassPath(new ByteArrayClassPath(classNameDotSeparated, classfileBuffer));\n  return classPool.get(classNameDotSeparated);\n}\nThese class pools become huge over time. In Byte Buddy, it is still acceptable as it only references information about the shape of types and not the actual byte code. But in an application with a couple of thousand classes this quickly pollutes the heap.\nYou can change this behavior by implementing a custom AgentBuilder.BinaryLocator. I  implemented a skeleton BinaryLocator.WithTypePoolCache where the ground functionality is added but I leave the actual caching to you.\n\n. The problem with the weak concurrent map is that it would require the class loaders to be collected for being effective. Most applications load by some class loader(s) and at some point in life almost all classes are loaded where the transformer is no longer active. The class loaders are however still strongly referenced by the application such that nothing could be collected from the cached type pools.\nIn order to make this meaningful, one needs to know something about the life-cycle of the instrumentation procedure. Most users do not have such information and if you attach an agent at startup, class loading might just be distributed over the first few hours of the app's life time. I gave this a lot of thought already but so far, I did not really come up with something good, in the end you probably need a dedicated cache to take that job and that is out of scope for Byte Buddy.\n. I have now added a simple implementation based on a ConcurrentMap. I think, ideally one would use a different dependency for something like this such as expiring map or Caffeine which are dedicated to this task.\n. You could implement your own BinaryLocator for this. Simply add an AtomicBoolean switch that always returns a fresh CacheProvider.Simple once it was turned and clears the concurrent map you used for caching upon changing the mode. You can use the skeleton for such an implementation.\n. You are right, the bootstrap class loader which is null is not allowed in a concurrent hash map. Look at the current head where I fixed it.\n. Great. That is what I originally designed Byte Buddy for, the byte code layer is really thin and I had JITWatch spinning over the entire code base to make sure there is almost no allocation left once the code becomes hot.\nThe error you saw is a common problem with ASM. Are you using byte-buddy-dep at some point? This one must always be shaded for the exact above reason.\nI am planning to extend the AgentBuillder API some time this weekend, I will probably release afterwards.\n. PS: Would you do me a favour and test out how caching works when registering the 18 agents? I have a minor idea that the overhead from that approach was mainly rooted in the fact that this now optimized overhead was applied 18 times (for each transformation).\n. I agree, thanks for checking though, the approximation suffices for the information I wanted out of this. I will try to improve the API; what I thought off would be to add something like:\njava\nAgentBuilder builder = builder\n  .type(foo)\n  .transform(bar)\n  .withFallThrough();\nI have to change some of the internals of the AgentBuilder for this though so I do not yet know when I will find the time but I like this better than the manual merging.\n. It would mean that the matched transformation would be merged with any prior transformations that also match the type until a non-fall-through transformation is reached.\n. The behaviour would be as follows:\njava\nAgentBuilder builder = builder\n  .type(foo)\n  .transform(bar)\n  .withFallThrough()\n  .type(qux)\n  .transform(baz)\n  .withFallThrough();\nwould apply both bar and baz if foo and qux positively match a type. The application order from the last to the first registered type would be followed through until a matcher is reached that does not declare itself as fall-through.\nCurrently, if qux matches, no other matcher is applied after; therefore fallThrough but I welcome suggestions for a different name.\n. I want to avoid the duplication of API and keep it fluent. Currently, it is already possible to define a matcher - transformer combination, I do not think that this alternative would make sense to a reader without proper context. With an extra word in the DSL, at least one knows what documentation to read.\n. I just released 1.3.15 with the functionality we discussed. Wasn't really a big deal. You can now chain transformations by:\njava\nAgentBuilder agentBuilder = new AgentBuilder.Default()\n  .type(foo).transform(bar)//.asDecorator() - perfectly legal\n  .type(foo).transform(qux).asDecorator();\nAs the last (dominant) matcher is defined as decorator, it is applied additionally (after) to the bar transformation that was applied before. The matching chain continues down to up until a matcher is hit that does not declare itself as decorator.\n. No, by using this decorator pattern, a transformation can either be applied entirely or not at all. Once the transformers are resolved, they are applied in one wash by the core engine which is not aware of the listener which operates around this application instead.\n. I agree that this one should be called from the Transformer and not from the Listener. You could still add logging for a ignore by wrapping the matchers with logging logic. If the wrapped matcher returns false then the transformation is not applied (even though matchers are called twice on redefinition so you would need to make them statefull in the sense that they deactivate themselves). \n. Implement a raw matcher such as:\n``` java\nclass LogMatcher implements AgentBuilder.RawMatcher {\n  WeakSet avoidDuplication;\nboolean matches(TypeDescription typeDescription,\n                              ClassLoader classLoader,\n                              Class<?> classBeingRedefined,\n                              ProtectionDomain protectionDomain) {\n    boolean result = // invoke actual matcher.\n    if (avoidDuplication add (typeDescription, classLoader) == false) return result;\n    if (result == true) \n    if (result == false) \n    return result;\n  }\n}\n```\nThen, for each matcher that your components register, instead of registering them directly, you register them after wrapping them in an instance of the above class. If you also want to log types that are ignored, you also need to wrap the ignore logic where you only log for a true return value which means that the value is not transformed, for false, you do nothing as that one is rehandled by the actual type matchers.\n. This is more of a really annoying limitation of the HotSpot VM. Once you load the VirtualMachine class from any ClassLoader, the attachment-process is spoiled and cannot be repeated via some other class loader from the same VM process. If EhCache is collected, it is not even possible to do it ever again.\nThe \"easiest\" would be to run Stagemonitor from a different process but I guess you do not want to do that. One possibility would be to implement your own ByteBuddyAgent.AttachmentProvider which checks for the existance of the EhCache class upon attachment. Then simply call:\njava\nByteBuddyAgent.install(new AttachmentProvider.Compound(\n  new MyEhCacheArghsStupidVmProvider(),\n  AttachmentProvider.DEFAULT\n));\ninstead of ByteBuddyAgent.install(). All you really need to do for this is to implement the isAvailable() method that checks if EhCache loaded the virtual machine class and if so, you need to return the loaded class from the getVirtualMachienType method.\n. I thought about it but the problem is that it will not work in app-servers etc as you do not necessarily find the right libraries on the current class loader. The problem will go away with Java 9, though, that is something.\n. None, really, your approach is not guaranteed to work either. Calling: Class.forName(\"net.sf.ehcache.pool.sizeof.AgentLoader\") resolves the class relatively to the current class loader. If the current class loader is not the same as that of EhCache, you will not discover the class and end up with the same problem.\nThe problem is that the VM cannot load two versions of the same native library. Even EhCache would break other instances of EhCache with this behavior.\n. Those classes must be injected into the bootstrap loader. Only then the java prefix is allowed and only then the classes are guaranteed to be universally visible.\n. This is implemented on development. I will however not attempt to reuse the agent jar as you suggested. It is a really good idea but many people shade Byte Buddy and as a result, you cannot rely on the manifest being present in the containing jar file.\n. This is already possible in the current development version where the @Advice.Origin annotation includes additional values and where you can also compute a custom value by adding your own annotation and mapping.\n. This is not too surprising. In order to avoid interference with a program, IntelliJ runs all of its code in a separate class loader. This separate class loader has your application classes accessible but does not load them from the system class loader (i.e. sun.misc.Launcher$AppClassLoader) but from a custom class loader that references the same jar file via a custom URL class loader (com.intellij.util.lang.UrlClassLoader).\nA Java class is represented by a tuple in its loaded format that is a class name and a class loader. In this case, the instances are not equal. The instance you create is an instance of the app class loader's class, when the IntelliJ class is instrumented, it however resolves the class to the one loaded by the IntelliJ class loader. The types are no longer equal and the exception you observe is happening.\nOne option would be to use a primitive for representing the interceptor type. Neither class loader can avoid loading a class from the bootstrap class loader where types are always shared. (e.g. make your \"interceptor\") an instance of java.lang.function.Function.\n. The problam is that a class loaded by two different class loaders constitues two different types.\nBy using a type that both class loaders consider equal (java.* types), you can resolve this disagreement. \n. You would apply the same pattern that you suggested with setDispatcher(Function function).\n. The problem is that two types are only equal if they are loaded by the same class loader. If you have two types Foo and you attempt to assign one instance to the other, these types are incompatible and this causes the IllegalArgumentException you observe.\nThe instrumented class is loaded in isolation by IntelliJ and your new Interceptor() is not assignable to the IntelliJ version of theInterceptor type. If you are using class delegation, Byte Buddy hard-codes the type reference into the IntellIJ class which implicitly references the \"right\" version of the class.\nIn order to avoid the boundary between \"your\" and the \"IntelliJ\" version of this class, you need to use a type that is equal for both sides of the view. The only class loader that IntelliJ and you have in common is the bootstrap class loader. The remaning challange is that you need to transport this instance from your side to the IntelliJ side of things where Byte Buddy cannot offer you an out of box solution. You would need to transfer the instance by putting it into, for example, the system propery map, which is however discouraged by the API contract.\n. I added an exception that is a bit more explicit over the problem. Thanks for the feedback!\nThe reflection is not so bad, performance-wise; the JVM is pretty smart about optimizing reflective calls. What is a bit problematic is the reflective lookup and the abuse of the system properties for a storage.\nI think the easiest solution would be to add the classes in question to the bootstrap class loader via the Instrumentation interface. This is the preferred approach.\n. Great, thank you for the feedback. \n. You are right. From my experience, it is always best to prefix such injected classes by java.*\n. This only happens when you load such classes in a class loader that is not the bootstrap class loader. It was my understanding that you were using the bootstrap class loader (see the respective ClassInjector).\n. You can create an instance using the constructor taking an explicit version, for example:\njava\nnew ByteBuddy(ClassFileVersion.V1_6);\nUnfortunately, Android does not well-behave with respect to the standard properties and Byte Buddy could only guess the correct version. Therefore, there is no work around specifying it explicitly.\n. Are you defining a constant field value using the API? That is only possible for static fields in Java byte code.\n. I will have a look, probably a mistake somewhere. You can turn off the validator in the mean time.\n. Also, could you do me a favour and set a break point at the exception and check what value defaultValue has.\n. What version does the class file have? I currently cannot see that Byte Buddy would be able to insert a value here.\n. Never mind, found it. Will fix today. ASM's implementation does something that is not specified in the Javadoc.\n. Fixed on master.\n. The problem is that anyOf(Type...) overloads anyOf(Object...) where the former compares types for equality and the latter compares objects to be equal. Overloading anyOf(Iterable) is not possible due to type erasure. The rationale behind this ambiguity is that the matchers are mostly used in a DSL-like manner where this confustion is rare as people provide explicit arguments. I do however agreee that those should be usable in an interchangeable manner. Unfortunately, this is not possible on the JVM.\nI will however add a Javadoc comment regarding this. Thanks for your feedback!\nThe correct way of doing it would be to use anyOf(new TypeList.Explicit(foo, bar)) for triggering a type-based comparison.\n. I will have a look. Again, it seems like a problem with overvalidation. Do you enable validation in production?\nAnother question. Do all of them complain about the type mentioned in the getReceiverType? In this case, I might know what the problem is. Receiver types were added with Java 8 but they are poorly supported by the current VM implementation what requires Byte Buddy to do some work-arounds. I wonder if this is the problem.\nI can however not reproduce your issue on my machine when running your current master.\n. Hi, I ran the test from IntelliJ. I just figured out that there was a null-pointer exception happening which did not apply the instrumentation but still run the test successfully. I currently build the project. Once I have a reproduction, it should hopefully be easy to fix.\nIf they all contain the line, I think I know what the problem is. Java 8 receiver types are a bit ill-defined. Hopefully this becomes better in Java 9 but I will fix it nevertheless.\n. Ok, thanks, no problem. (Maybe add an explicit check with an exception that points this out if the getResource method returns null?)\nI just reproduced it and it is the problem that I thought it was. FYI: If you do not call getReceiver anywhere and if you do not enable validation, this problem has no side-effect in a production environment.\n. Fixed on master.\n. You have two possibilities:\n1. Either you compile your code with -parameter such that the parameter names are attached as explicit meta data by javac. This makes the information available for any class in its loaded or unloaded form when using a TypePool or when running a Java 8 VM.\n2. Or you use the TypePool.Default.ReaderMode.EXTENDED where Byte Buddy also parses the debugging information of any (non-abstract, non-native) Java method for parameter names. This information is then available for non-loaded (non-redefined) types.\nYou can always check the ParameterDescription::isNamed() method to check if a non-implicit name is available. With the arg0 value, Byte Buddy emulates the behavior of the Java reflection API when using getName on a parameter when -parameters is not active during compilation.\n. This should work as all examples from the tutorial are constantly unit-tested.\nDoes your class my.class.Class exist? class is a keyword so you should not have been able to create such a class. Maybe you mistyped?\nThe exception is expected as it seems like Byte Buddy cannot resolve the class file of your class from the class path. The default TypePool is hierarchical and at the top, there always sits an empty TypePool to close the hierarchy. That is not unexpected.\n. Fixed on master by the optional attribute.\n. Byte Buddy already reads any property lazy if it is resolved lazily by the JVM itself. Examples for VM-lazy properties are annotations or generic type information. The VM's performance of parsing meta information is unfortunately far from ideal. \nBut in contrast to what you said: yes you do (implicitly) access the parameter annotations when you are using the Advice component which needs to read the parameter annotations for resolving its method-to-method mapping. Examples for such parameter annotations are Advice.Argument or Advice.Return. I think that the problem in this particular benchmark is that the Advice.to call happens from within the AgentBuilder.Transformer which is invoked for each applied transformation, i.e. all classes that are defined by Elasticsearch.\nOutside of a benchmark, you would not apply the Advice.to method that many times. Most agents only instrument a handful of classes where the transformation is triggered. If you really need to avoid this performance overhead, simply store references of the Advice.to instances outside of the AgentBuilder.Transformation that you register to reuse it. Everything in Byte Buddy's public API is immutable what makes this a safe operation. \n. Generally, do as little as possible within the transformers and the matchers and access as few properties on description objects as possible but precompute as much as possible. Especially meta data (annotations and generic types) and hierarchy traversals are expensive.\nIronically, Byte Buddy's type pool description are more efficient when accessing properties then going via the Java reflection API but the initial costs of parsing a class file is an initial cost that the type pool cannot avoid.\nFor performance reasons, always disable type validation in production as it accesses all meta data.\n. Thanks for the feedback. I am still thinking about how to solve this better but I think the best solution really is to install some cache as this is really about storing instances without a predefined life-cycle. I consider offering an integration with some caching solution in a seperate module.\n. Thanks, good catch. I did not realize that I did not do this change already, I thought this already was the current state. Long time ago, I streamlined everything to rely on binary names instead of internal names as a loaded intances cannot provide an internal name without transformation.\n. By default, the Advice component does no longer catch exceptions for Advice.OnMethodExit. You now have to specify the exception that is to be catched (if any) on the latter annotation in order to use Advice.Thrown. For example:\njava\n@Advice.OnMethodExit\nstatic void exit(@Advice.Thrown Throwable t) { }\nis illegal because no exception is caught by default whereas\njava\n@Advice.OnMethodExit(onThrowable = RuntimeException.class)\nstatic void exit(@Advice.Thrown Throwable t) { }\nis legal.\nThe reason for this change is that catching all throwables by default turned out to be a bad idea. This would for example swallow OutOfMemoryErrors and the like if they were thrown at the wrong spot.\n. This is most likely a class loader issue. The difference is: If you are loading a Java agent, it is loaded on the class path. If your application is however loaded by an application server and not on the class path (i.e. redis.clients.jedis.Connection.class.getClassLoader() != ClassLoader.getSystemClassLoader()), the Java agent cannot locate the Jedis connection and the above error is thrown. In order to avoid this, you need to add the Jedis dependency to your Java agent.\n. The Advice.Origin and Origin annotations are a bit different. When you use the delegation approach, which is exposed by the.method( ... ).intercept( ... )API, you have more degrees of freedom. Using this API, Byte Buddy will alter a class file to override the method and to delegate to your actual advice method. If you added a parameter naming@Origin Method m, Byte Buddy would create a field with theMethod` reference and store it in the instrumented class.\nWith the Advice component, things are a bit different. For Advice instrumentations, Byte Buddy inlines your code into the instrumented method. As Method instances are no primitives to Java byte code, Byte Buddy cannot define a constant Method instance to exist as Byte Buddy would only be able to look up the Method instance dynamically such as you would do it yourself.\nIn order to access custom meta data from within the method, rather look into using custom annotations to provide this information as it is done with Advice.withCustomMapping().\n. You can use Advice.withCustomMapping().bind(MyAnnotation.class, myBinder) to register an annotation that writes the above value directly into the method instead of accessing it at runtime. This is also a significant performance improvement as looking up a Method reference takes quite some time. You can then use @MyAnnotation on a parameter of your Advice target and read the value from there.\nThe most important difference between the Advice (.visit( ... )) and the delegation (.method( ... ).intercept( ... )) APIs is that the former API guarantees to not alter a class file's shape, e.g. add methods or fields. To a user, any changes are completely invisible. This does however also limit the scope of possible action. It is therefore only possible to add code to the beginning and the end of a method, not to change the control flow. Also, all code is executed from within the instrumented class (and its class loader) what makes it possible to access private members of this class but not to break out from the class and access code that is only known to the instrumentation logic.\nUsing the delegation API, you can completely replace a method and invoke the original method from this method, if you want to. It often leads to an easier programming model as it is more intuitive to read as the inlined advice methods. This API offers a plain-Java execution of the instrumentation logic.\nPerformance-wise both APIs are more or less equivalent. Both have a minimal impact on the inlining behaviour of a JVM. The Advice component adds to a method's code size while the delegation approach adds to the call stack depth. Both can have negative impact but it rarely happens and it is difficult to predict what happens, as well.\n. Great, good luck. Simply open this issue or create another one if you have further questions. \n. Yes, it is thread-safe. A value that is returned from OnMethodEnter is stored on the operand stack where it can only be accessed by the executing thread. This is equivalent to\njava\nvoid foo() {\nObject value = onMethodEnter();\n{ /* actual code */ }\nonMethodExit(value);\n}\nNote that object allocation is not normally a problem here if you are not using primitives. The advice code is inlined (by default) where the JVM easily understands that the object does not escape the method by performing escape analysis. As a result, the object allocation is typically erased.\nIf you are using a hash map, there is no problem as long as you are not making explicit use of non-thread safe constructs (like storing the map in a field).\n. Hello,\nwhen Byte Buddy creates a class for you using an interceptor, the generated class is similar to the following. Assuming the original class Foo:\njava\nclass Foo {\n  String bar() {\n    return \"bar\"; \n  }\n}\nAn interception to some interceptor object Qux would result in the following redefined version (schematic code):\njava\nclass Foo {\n  // Requires your interceptor class to be known\n  static Qux $interceptor;\n  String bar() {\n    return $interceptor.intercept(); \n  }\n  static {\n    // Requires knowing the framework\n    $interceptor = ByteBuddyFramework.defineField(Foo.class);\n  }\n}\nObviosuly, for this to work the class Qux must be known to your target machine that executes the code. This is however not sufficient. Additionally, the $interceptor field must be set which Byte Buddy does by adding a class initializer block to the class (static { ... }) where the field is set. It is impossible to set this field during the instrumentation where the class is not yet loaded.\nIf you are running the class on the same JVM that generates it, Byte Buddy takes care of all of this for you but in your case, this does not work. You can however configure this behaviour:\n1. Byte Buddy lets you choose an initialization strategy that determines the (optional) creation of a class initializer block. You can define a no-op strategy but read the LoadedTypeInitializer using an AgentBuilder.Listener in the onTransformed method. You can serialize this instance (given that your Qux class is serializable) and send it to the machine that loads your class. Also, using this listener, you can find out if there are auxiliary classes that need to be loaded by the target VM. Auxiliary classes are helper classes that need to be loaded to make the instrumentation work. Auxiliary classes are proxies such as the @SuperCall classes.\n2. You can avoid using an instance of Qux but delegate to Qux as a class. This way, it suffices to load the class Qux by the target VM as the LoadedTypeInitializer does not need to be run (it is \"not alive\" in Byte Buddy terminology.\n3. You can replace the interception API with the Advice instrumentation which inlines the byte code of your methods into the class file. This way, you can avoid changes to the class file altogether and you guarantee that the class can be loaded directly. The downside of this API is that the Advice component only allows for around advice. You still need to disable self-initialization; you can call .disableClassFormatChanges().\nPS: Bootstrap injection is disabled by default, you do not need to call the method in the above example.\n. Hi Kuba,\nNo problem. Please always ask.\nThe Advice component will be the only one to support inlining. The delegation model cannot be inlined in the general case which is why it idnotsupported.\nYou can avoid Byte Buddy on the target machine by delegating to a named field (if that is the component you use). You then need to make sure to set that field on the target machine manually before using the class.\n. You are right both times and the fact that you name the instance field made me call this \"named field\" whithout the latter being official terminology. \nNote that you still needto declare annotations on the delegation target. However, the target machine still does not need to know about Byte Buddy as the JVM supresses unknown annotation types.\n. Yes and no. It is possible if you run on a JDK but not a regular JVM. You can have a look at the byte-buddy-agent project that offers APIs for attaching onto the current VM or a remote VM by process id. The javadocs describe the limitations of this approach in detail.\n. Fixed on master.\n. After discussing, this turned out to have a different root cause.\n. The export is missing on purpose. If you are using the ASM API directly, please shade Byte Buddy as I cannot guarantee API compatibility for a third party project. Please refere to the readme for information. Alternatively, if you only compose existing appenders, use the ByteCodeAppender.Simple implementation for composition. \n. I am currently on vacation but I will consider your use case once I am back!\n. This can be directly translated without making any use of the ASM API by using an ByteCodeAppender.Simple:\n``` java\n@Override\npublic ByteCodeAppender appender(final Target implementationTarget) {\n  final FieldList fields = implementationTarget\n         .getInstrumentedType()\n         .getDeclaredFields();\nfinal List stack = new ArrayList(16);\n  stack.add(MethodVariableAccess.REFERENCE.loadOffset(0));\n  if (stringConstructor) {\n    stack.add(MethodVariableAccess.REFERENCE.loadOffset(1));\n    stack.add(MethodInvocation.invoke(new TypeDescription.ForLoadedType(proxyClass)\n            .getDeclaredMethods()\n            .filter(ElementMatchers.isConstructor().and(ElementMatchers.takesArguments(String.class)))\n           .getOnly()));\n  } else {\n    stack.add(MethodInvocation.invoke(new TypeDescription.ForLoadedType(proxyClass.isInterface() \n        ? Object.class : proxyClass)\n            .getDeclaredMethods()\n            .filter(ElementMatchers.isConstructor().and(ElementMatchers.takesArguments(0)))\n            .getOnly()));\n  }\nstack.add(MethodVariableAccess.REFERENCE.loadOffset(0));\n  stack.add(MethodVariableAccess.REFERENCE.loadOffset(1));\n  stack.add(FieldAccess.forField(fields.filter(ElementMatchers.named(AUTHORITY_VAR_NAME)).getOnly()).putter());\nstack.add(MethodVariableAccess.REFERENCE.loadOffset(0));\n  stack.add(MethodVariableAccess.REFERENCE.loadOffset(2));\n  stack.add(FieldAccess.forField(fields.filter(ElementMatchers.named(INTERCEPTORS_VAR_NAME)).getOnly()).putter());\nstack.add(MethodVariableAccess.REFERENCE.loadOffset(0));\n  stack.add(MethodVariableAccess.REFERENCE.loadOffset(3));\n  stack.add(FieldAccess.forField(fields.filter(ElementMatchers.named(ACTUAL_VAR_NAME)).getOnly()).putter());\nstack.add(MethodReturn.VOID);\n  return new ByteCodeAppender.Simple(stack);\n}\n```\nDoes this work for you?\n. First of all, you should upgrade your Byte Buddy version. The current error message would be:\n\njava.lang.IllegalStateException: Duplicate type variable symbol 'T' for class Version\n\nI am looking into a possibility of allowing refinements for type variables. It is not an easy feature as it requires locating all uses of this type variable. Also consider that generics are a compile-time feature; i.e. the runtime does not behave differently after adding the variable, it would however effect libraries that explicitly parse the information.\n. Fixed on master. The DynamicType.Builder now declares a method transform(ElementMatcher, Transformer) that allows the transformation of existing type variables.\n. The java.* namespace is treated specially by the VM. It is only possible to load such classes by the VM's bootstrap class loader. This means that you need to use a Java agent to redefine this class instead of loading the class by another class loader (what is forbidden).\nThis also means that you need to redefine the class what limits the scope of the possible transformations.\n. The Byte Buddy unit tests load a class in a dedicated, newly created class loader in order to make sure that the class in question is not yet loaded when the Java agent is attached. This way, the Java agent can assume that it is instrumenting the class in question before it was loaded for the first time. Otherwise, the unit tests would need to assume that no other test has loaded the class in question previously and introduce a test-order-dependency.\nThis approach is unfortunately not applicable for java.* classes. These classes must be loaded by the bootstrap class loader, this restriction is hard-coded into the ClassLoader implementation. It might just be that the FileInputStream class is not loaded by the bootstrap loader when you execute your test, but you cannot safely assume that.\nGenerally, I would be careful to instrument java.* classes with an Instrumentation as it is perfectly possible that for example FileInputStream is loaded before you have the chance to register an agent. The class is for example used by Byte Buddy itself at multiple points and you would actively need to avoid these code segments in order to make your instrumentation work. Alternatively, have a look at the Advice component which only adds code to the beginning and start of a method without changing the class file format. Such code changes are allowed even after a class was already loaded. This is also possible to unit test without assuming that the FileInputStream class was not yet loaded.\n. With the Advice component, you can add code before or after a method without changing the layout of the class (adding or removing methods/fields). An advice for a file input stream could look like:\njava\nclass BeforeAdvice {\n    @Advice.OnMethodEnter\n    static void enter() {\n      System.out.println(\"Will be printed before adviced method is called\");\n    }\n}\nUsing Advice.to(BeforeAdvice.class).on(matcher()) now allows you to add this code to the beginning of a method. Make sure to activate the disableClassFormatChanges() option on the AgentBuilder. You can subsequently activate the with(RedefinitionStrategy.RETRANSFORM) on the agent and redefine the FileInputStream class even after it was loaded.\n. This is not a Byte Buddy specific problem. If you instrument a class, that class is bound by the visibility of its ClassLoader. The bootstrap class loader only knows classes that are defined by the JVM. You can however add jar files using the Instrumentation interface via ByteBuddyAgent.getInstrumentation().appendToBootstrapSearch( ... ) or using injection via ClassInjector.ForInstrumentation.\n. This is unfortunately how the JVM works, you can only append classes to the bootstrap jar this way. The ClassInjector.UsingInstrumentation injector works the same way.\n. When you are calling .redefine(Book.class), you implicitly add a ClassFileLocator that reads the current class file from the underlying jar file. There is an alternative class file locator that reads the current class file via the Byte Buddy agent, i.e. ClassFileLocator.ForAgent that you need to use. \nHowever, you might want to use a different approach alltogether. I suggest you to look into one of the following alternative approches:\n1. Instead of redefining Book.class using an interception, have a look at the Advice instrumentation which is limited in the sense that it can only add code before or after a method; it is however capable of changing a return value in the OnMethodExit advice.\n2. Instead of changing the byte code in order to enable or disable a feature, simply use the agent to add the instrumentation a single time. Use a MethodDelegation instrumentation and check from the interceptor if the feature is enabled or disabled and act accordingly. The JIT compiler is very powerful and will detect that you only ever use one of the approaches and generate machine code that resemble exactly what you are trying to do; i.e. optimizing for the currently enabled path.\n. As the method suggests, it is not possible to apply Advice to an abstract or native method. Therefore, you need to instrument the super classes. In the current master for Byte Buddy, there exists a hasSuperType matcher that does exactly what you are trying to do:\njava\n.type(hasSuperType(named(\"javax.ws.rs.container.ContainerRequestFilter\")))\n .transform(new RequestFilterAdviceTransformer())\nYou can copy the code from GitHub. Make sure that your check in your transformer if a method is non-abstract as you can only apply the advice on such methods.\n. Sure, please note that it might take me a while to release, I will probably merge the Jigsaw extensions soon and wait with release until then.\n. You have to specify in your element matcher for the advice that you are not interested in abstract or native methods because advice cannot be applied to them.\nThe reason that it works using the subtype matcher is the fact that using the constant triggers the loading of the classprior to the registration of the class file transformer such that the classes (abstract) methods are not attemptet to be advised.\n. Yes, you can. However, you cannot apply advice tk the interface type.\nIf your matcher on the advice constraints abstract and native methods, you are good.\nFor example, wrap your matcher by not(isAbstract().or(isNative()) - ill think about how to make this easier in the future.\n. Hello,\nGlad you like the article. The documentation can of course be improved and I spend time on doing it regularly.\nMaybe you find this article helpful: https://www.infoq.com/articles/Easily-Create-Java-Agents-with-ByteBuddy\nFeel free to submit a PR with suggestions when you find a mistake!\n. You are currently exluding abstract classes and interfaces. It seems to me that you would like to exclude abstract methods.\nIn this case, you should narrow down your method matcher)(within the transformer), not your type matcher.\n. Thank you for the reproduction, this really makes things much easier to look into. I am currently at a conference but I will look at the problem first thing tomorrow. Thanks for that!\n. I have found and fixed the bug. I still have some clean-up to do, I had to change quite some bits in the ground model of the Advice component and I want to avoid that anything breaks that worked before. Thanks again for reporting this, not an easy bug to catch.\n. Fixed on HEAD and to be released via 1.4.2.\n. Great to hear it works and boosts performance. I found some unnecessary allocations but I do not really understand how that could have such a strong effect. Great, though!\n. The benchmarks are exactly that: a measurement of class generation and a measurement of calling generated code. Byte Buddy does voluntarily not add a built-in cache as I consider this pattern flawed.\nIn most applications using Byte Buddy - e.g. Mockito - a key for a cached class can be generated easily and with minimal memory consumption as a mapping from the original class to its generated proxy. This simple cache is of course more efficient as the one built into cglib as it makes an assumption that does not hold in the general case. (To be fair, Javassist only added a cache to its cglib-similar helper API to supply an easy migration path and does not offer such a cache for its core API.) In more complex scenarios, using a fully fledged cache like Caffeine is again much more efficient and customizable so this should be the way to go.\nFinally, I do not think such a benchmark would even make sense if there was something to compare. How many cache misses should I emulate? If the cache was for example always hit like for example by adding a @Param for triggering the built-in caches in the existing bechmarks, the JVM would probably create a fast-path for reading the previously generated class and erasing all other paths with uncommon traps. The benchmark would more or less be a baseline. In the end, a benchmark is only as good as its interpretation and measuring cache efficiency is rather complex on this end.\nAs for my personal use of cglib before I created Byte Buddy, I always disabled the caches and replaced them by something different. A library, in my eyes, should ideally do one thing and do it well. Caching is a different subject and I will not be able to beat a dedicated library on this. \n. Byte Buddy creates any Classes down to custom byte code and is not a limited to proxies like cglib is. I would not know why anybody would expect Byte Buddy to cache anything - maybe that is not even intended - and it has never been a point of confusion in practice. Unless you make a direct comparison to cglib where this practice was introduced but which is flawed in my opinion as explained. Byte Buddy is a much more comprehensive library with a very different API, I do not really see your point here.\nI agree that the Mockito solution can be improved but I do not have the time currently. There is no performance regression so we went for the easy solution and as you say, its not much of a requirement to scale. This does not change a thing about what I have argued before, though. And yes, if I wrote a migration guide, I would mention this but again I did not yet have the time, its a free time project, not a commercial one so documentation falls short easily.\nI understand that you are invested in the cglib caches and props for that. I agree that the slide could be explained in greater detail but in the reality of a conference talk, you do not always have the time for speaking out everything you try to say. The exact wording can depend on my mood, the previous knowledge of the audience and so forth. Of course it is oversimplified in this talk but this is why I provide the reference. If you go into the details, the bottom line is: Byte Buddy is much faster, especially the generated code when its runs. \nFinally, I do not hear myself saying good approach for one library vs bad approach for another one in that video so I do not know what you mean by that.\n. As a final answer to this, I can only summarize what I already said:\n1. A benchmark is only as good as its hypothesis: if I compare how long it takes cglib to return an instance of a cached class to how long it takes Byte Buddy to create this class freshly every time, what would this benchmark prove? That using a cache is more efficient than not using one if you handle expensive objects? I think that is obvious.\n2. Byte Buddy allows you to create a class of any property up to the creation of custom byte code. cglib does not. Therefore, there is no comparing \"the wrong approach of cglib\" with Byte Buddy. cglib is a different library - it creates proxies only - Byte Buddy can create any byte code pattern that javac emits (and more) or a proxy class. For the benchmark, I extracted scenarios where all libraries do a very similar thing. In my eyes, this is the only type of benchmark that makes sense (is \"fair\"). (And even here the comparison is broken. Byte Buddy processes generic type information, type annotations, default interfaces etc. None of this is done by cglib or Javassist's \"cglib immitation API\".)\n3. The benchmark is there to look into the performance of the actual code generation and its runtime. The truth is, if you want a performant cache with explicit controls, you should use a library that specializes on that; even if you use cglib. This does not only allow you to chose proper eviction strategies (if needed) but also gives you the opportunity to choose a good enough hash key where cglib only offers an opt-out global cache. And if your application is simple, it is probably sufficient to stick previously created instances into a ConcurrentMap. \nHistorically, cglib added the cache to mimic the Java proxies which imply such trivial keys. Javassist only added the cache for its \"migration API\" but not to its standard API to ease the migration from cglib. When I created Byte Buddy I wanted to create a code generation library that does one thing and does it well. This is what the benchmark is for - to compare the code generation aspect - and nothing more. Again, I sympathise that you want to see your caching solution excel here, but this is not the point of this benchmark. And of course, if I have had the time to write a migration guide, I would mention the caching aspect.\nAs for Jokerconf, I will change my slide set quite a bit as I was asked to talk a bit more about the performance implications of code generation libraries. I will also talk a bit more about what I think is wrong with cglib and Javassist which I used for years before creating Byte Buddy.\n. I am afraid I have to say the same thing back to you. What you suggest is a different thing. I am trying to compare base-overheads in my (micro!) benchmark, not \"typical use cases\". I am saying that cglib is slow because it is when it comes to code generation or running generated code. This is what the benchmark is. In order to make a comparison as you suggest, I would need to drag in a third-party cache and write a lot of code to implement some form of library. There would be a lot of screws to tweak this benchmark in favour of either one of the libraries and I do not think this is a valid approach to benchmarking.\nYour argument basically is: if you use Byte Buddy exactly as you would use cglib, cglib is faster. My point is: this is not how you should use Byte Buddy. I do not say that you should disable the caches of cglib either, but I do it to render a valid microbenchmark of the part that I actually think is fair to compare directly. If you are using Byte Buddy correctly, however, you do get better results.\nThis is an open source project and as I am not paid for this, I do not have the time to discuss everything in detail. Online discussions tend to never end. I have been working with these things for year. I am afraid you have to trust me on this. Feel free to chat me up at Joker but I do not currently even have sufficient time to support all questions so I do not want to continue this conversation here.\n. You can already store the classes using the DynamicType API. When using an AgentBuilder, you can register a Listener to access this dynamic type, If you really need this ability.\n. In this case, the VerifierError typically suffices for debugging purposes. Otherwise, I rather take a reproduction of the problem. Yet, I might just add such a property at some point.\n. I would probably use some different form of control, not a system property. I have thought about this in the past but there are some problems with a simple \"dump\" that I need to think about first before committing myself to a solution.\n. Also, please do not think that I simply dismiss your solution, I appreciate the hint but I currently need to bundle my efforts to make sure I can continue to maintain this library which has gained quite some users over the last year. I am therefore always careful to add another debugging option as a simple class dump often does not expose a problem as I have learned the hard way.\n. As I said, it is not trivial so I am not sure if it would be a good beginner's issue. For now, I will not fix it, it depends on this ever being an issue.\n. I decided to add this feature nevertheless. My main concern is to create an easy mechanism for an attacker to extract class files that Byte Buddy creates but I assume that in this case an attacker either controls the application where an attack is trivial or a security manager should be used for avoiding such attacks anyways.\n. The problem here is that most JVMs do not currently support adding methods or fields to classes that are redefined. To overcome this limitation, Byte Buddy adds a specific switch to the AgentBuilder API. You would need to set disableClassFormatChanges().\nAfter enabling this switch, Byte Buddy does no longer allow you to add fields or methods which does however imply that you cannot longer use the interception API without replacing the former code as this code is usually added to a private method of your class.\nThe solution to this is to use the Advice component instead of the standard API. This rather new API is not explained in the documentation yet but the javadoc should cover most questions. The Advice API allows you to add before and after advice, including the change of a return value or handling an exception. For example, a simple instrumentation would be:\n``` java\nnew AgentBuilder.Default()\n  .disableClassFormatChanges()\n  .with(RedefinitionStrategy.RETRANSFORM)\n  .type(is(ManagementFactory.class))\n  .transfrom((td, builder, cl) -> builder.visit(Advice.to(MyAdvice.class).on(named(\"getMemoryMXBean\")))\n  .installOnByteBuddyAgent();\nclass MyAdvice {\n  @OnMethodEnter\n  static void foo() {\n    System.out.println(\"foo\");\n  }\n}\n```\nThis advice adds the System.out.println(\"foo\") to the beginning the getMemoryMXBean method without changing the class file.\n. The AgentBuilder is built on top of the Instrumentation API which allows to read all classes that were  loaded by the VM. There are no classes skipped. The classes in question are however loaded by the bootstrap class loader and you need to be extra careful when instrumenting such classes as you can provoke loading circularities (a class is required for instrumenting a class while instrumenting the same class).\nTherefore, you need to set ignore(none()) in your case.\nAs for the Advice, you are already using the normal Byte Buddy API from within transform, but you are right that a direct use might be easier for your goal:\njava\nnew ByteBuddy()\n  .with(Implementation.Context.Disabled.Factory.INSTANCE)\n  .redefine(ManagementFactory.class)\n  .visit(Advice.to(MyAdvice.class).on(ElementMatchers.named(\"getInputArguments\")))\n  .make()\n  .load(ManagementFactory.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());\n. The advice code is inlined into the instrumented code; if you reference any other method from the advice, it is indeed resulting in a NoClassDefFoundError if the bootstrap class loader cannot see these classes.\nGlad it works for you!\n. Thank you for the reproduction. I have tried running your project with a fresh installation of Eclipse Mars - Release (4.5.2), Build id: 20160218-0600 - but I cannot trigger the same error: \n\nAre you sure there is no problem in your setup?\nFrom the error message it seems like the type's generic information does not match its erasure what would be a compiler bug. Chances are this is a problem of the particular Eclipse compiler version you are using. I have experienced the Eclipse compiler to be quite buggy when it comes to nested generics or type annotations (where the latter sometimes even renders problems for javac). That said, processing the latter meta data is not trivial which is why there can always be a bug in Byte Buddy but I this tends to only be the case when the problem is reproducible across the command line and IDEs.\n. As for the reflection API, the methods returning an AnnotatedType go along with the Type API which carry an implicit requirement that the instances are compatible. Therefore, upon observing a ParameterizedType, Byte Buddy assumes to observe an AnnotatedParameterizedType for the type annotation API.\nByte Buddy only calls this method if it really is required as it triggers parsing the meta data by the VM what is costly. This is why this assumption is made in the first place.\nI will look into it and maybe add a check where, in case that this is not given (even though the JVMLS requires it), a fallback is added where no annotations are returned.\n. This being said, what version of the JVM are you running when using Eclipse and what VM is referenced by JAVA_HOME? This might just be the key to the problem. I did use\n\njava version \"1.8.0_91\"\nJava(TM) SE Runtime Environment (build 1.8.0_91-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)\n. No problem, thanks for reporting. \n\nUnfortunately, the type annotations API was very unstable up to update 40+. I reported more than 30 bugs with the API when I implemented support within Byte Buddy. I considered to add work-arounds into Byte Buddy to deal with all the small bugs that are still in the early versions but that would just require too much work. Oracle has fixed most of the problems now and things run smoothly for a year now. Sorry for the hick-up.\n. This is a different error. It seems like you are running with an incompatible version of Byte Buddy. What Mockito and Byte Buddy versions are you using?. Generally, I understand why this is desirable. One practical problem is however the performance implication. Currently, the Advice class shares one ClassReader for parsing advice byte code from the same class. If the advice would be distributed among several classes, this optimization would no longer be possible.\nOut of curiosity; what stops you from registering two advice adapters?\njava\n.visit(Advice.to(BaseAdvice.class).on(...))\n.visit(Advice.to(FirstAdvice.class).on(...))\nThis should have the same effect.\n. You are right about the matchers, one way to prevent this would be the use of ElementMatchers::cached. As for the custom bindings, you can however share the configuration. All Advice instances are immutable such that you can simply continue the advice creation after setting it up once.\nI will look into this and see if there is a way of doing this without hurting performance. \n. I added an alternative entry point to the advice component which allows you to specify two different classes for an entry and an exit advice: Advice.to(EntryAdvice.class, ExitAdvice.class)\nI prefer this over parsing the class hierarchy as the latter could yield ambiguities and I assume that a user typically can provide the information of where to find an advice class.\nFurthermore, I refactored the AsmVisitorWrapper.ForDeclaredMethods to allow reusing a matcher:\njava\nnew AsmVisitorWrapper.ForDeclaredMethods()\n  .method(matcher, Advice.to(Foo.class), Advice.to(Bar.class))\nAs a matter of fact, Advice.to(Foo.class).on(matcher) was never anything more than a short-cut for the above construct anyways.\n. Fixed in 1.4.6.\n. You have two possibilities:\n1. You create class loaders to which you provide the byte code of the classes you want to test (via ByteArrayClassLoader and ClassFileLocator.ForClassLoader::read). You then can limit your instrumentation to this class loader and throw it away after the test.\n2. You use ClassReloadingStrategy::reset after the test. \n. I answered your question on Stack Overflow.\n. You are right, this is a bug and another argument for writing a unit test for really everything. I just fixed it myself as I chose to extend the check and also add a unit test. Good catch, thank you.\nYou can deactivate type checks by new ByteBuddy.with(TypeValidation.DISABLED) until the next release.\n. You actually delegate to the TypePool.Resolution instance as you do not call resolve after reading the class from the TypePool. (The class might not exist.) As a consequence, you do not delegate to a class but to an object which requires Byte Buddy to add a field for this object in the instrumented class. This additional field causes the rejection of the transformation.\n. There is a bug in the VM where classes on the bootstrap class path cannot be located as a class file due to some caching issue such that Byte Buddy (or any library) cannot locate it.\nYou can work around this by resolving the jar file explicitly:\njava\nTypePool typePool = TypePool.Default.of(new ClassFileLocator.Compound(\n    new ClassFileLocator.ForJarFile(new JarFile(file)),\n    ClassFileLocator.ForClassLoader.of(Main.class.getClassLoader())));\nThe file in this context is your reference to the jar added to the bootstrap class path.\nNote that you need to align your matcher accordingly\njava\n.method(named(\"setAccessible\").and(takesArguments(boolean.class)))\nto avoid instrumenting the internal implementation.\n. By the way, after adfing a class to the bootratrap class path, you can simply refer to the loaded version, no need to use the type pool.\n. If you want to use annotations, I would recommend you to use the type pool again as suggested before.\nWhat is your problem with it? I had your example working with the suggestion above.\n. You are welcome. Maybe, you would also be interested in using the Advice class for your purposes. It allows you to add code rather than replacing it. Also, since it is adding the code rather than delegating, you can skip the bootstrap injection.\nLet me know of any write-up!\n. Currently, Advice does not allow skipping the original code, even-though I consider adding this feature jn a future version.\nFor invoking the setAccessible0 method, check out the MethodCall implementation. \n. I thought more about chaining the calls. I assume that you are throwing an exception in your real interceptor if the security check fails? In the case, the following would work:\nbuilder.method(named(\"setAccessible\").and(takesArguments(boolean.class)))\n  .intercept(MethodDelegation.to(typePool.describe(\n    \"com.leacox.example.bytebuddy.instrument.java.lang.reflect.SetAccessibleImplementation\"\n  ).resolve()).andThen(MethodCall.invoke(setAccessible0Method).withThis.withAllArguments()\n));\nThe setAccessible0Method is only called if the interceptor does not throw an exception. If the method disappeared, this would already thrown an exception if the method is attempted to be located. (Byte Buddy would have thrown an exception if the field did not exist as well).\nThat said, I am looking into adding a skip instruction to the Advice component in the future to make this even easier.\n. Well, the documentation does indeed not make this explicit but Byte Buddy generates standard Java code. If an exception is thrown, unless you do not explicitly catch the exception from an interceptor, the chained byte code is never reached.\n. No problem and thanks for the idea of creating a property to skip the original method.\n. Technically, the JVM does not support optional dependencies. Many library developers misunderstand the fact that the HotSpot VM resolves dependent classes lazily on their first usage and write software that depends on this implementation detail. When using reflection, the VM does however overcome the lazy resolution and eagerly resolves any class's type references. If you refer to non-present classes in any signature, the JVM cannot work properly and project Jigsaw will even refuse to start such a program.\nIn the case of Weld, it really is a corner case as the field is (a) private and (b) only uses the \"optional\" type in a generic siganture. The latter makes it possible to still use reflective invocation as the runtime does not care about generic type due to type erasure. If you did however use the reflection API to request information about the generic type of the class, this would still cause a NoClassDefFoundError when asking for the signature of the field in question. This should primarily be seen as a bug in Weld as no class must expose such an optional type within its signature.\nByte Buddy can not really work around this as rewriting a class file requires all signature information to be present for Byte Buddy to be able to process it similar to the work a compiler does. I can however look into making the resolution lazy by default what would work for your specific use case.\n. I have already investigated the feature and I will add it. Stack Overflow is a good place to ask these things as it has the best reach and saves me most from repeated questions.\n. Can you try the current head and see if my recent changes work for your use case? In theory, they should but I only built a simple use case.\nYou can either build Byte Buddy yourself or include it as a dependency using JitPack.\n. Sure, it is really strange, though, I have never seen this error with Byte Buddy. Maybe you are keeping a reference to a byte code array somewhere and unintentionally change the data.\nBest regards, Rafael\n. This problem should be resolved with the latest version, I am therefore closing this issue. Please reopen it if you still have problems after you resolved your other issue.\n. Fixed.\n. Fixed on master.\n. Unfortunately, error prone only works with JDKs 8+ while Byte Buddy triggers CI builds on all VMs of version 6 and older. This would require a seperate compilation profile and I think any actual bug should be covered by a test.\n. Google has no culture for supporting old versions of anything. ;)\n. Fixed on master.\n. Fixed on master.\n. Thanks for the report. This is a problem with a recently added optimization for methods that cannot return regularly, i.e. always throw an exception. Previously, Byte Buddy did not consider this as a special case and created dead code. This is no problem according to the specification but troubles many tools. I will fix this with the next release.\n. Fixed on master.\n. You are right, the FieldProxy can be much better. I will add this improvement in a future version.\n. I looked at this yesterday night and remembered why I split this up. Declaring a setter proxy exlcudes an interceptor if the located field is final. This allows for easy resolution. I did however add an overloaded version of the installer where a combined getter/setter proxy type can be specified. If the setter is called on a final field, this proxy now throws an UnsupportedOperationException. A user can now choose between the two depending on which one is more appropriate.\nFixed on head.\n. What do you mean by invalid? There are no changes that should make a difference in your example. What version were you using previously?\n. Please have a look at the release notes and try incrementing Byte Buddy's version step by step. If you found the release version where you experience changed behavior, I might be able to tell you more.\n. Byte Buddy is transforming your classes on demand. As long as the interception works, I do not think there is anything wrong here. If you migrate version-by-version and find the exact version number where things changed for you, I might be able to help you about what exactly it is that changed.\n. Byte Buddy is not persuing any active life cycle. It is up to you to your application to load classes. The agent rather serves as a callback into the defineClass method of any ClassLoader.\n. Are you using a MethodDelegation or are you using Advice? You can always access annotations by using the @Origin annotation with a Method when using the former. From the Advice component, you can use a Advice.withCustomBinding() to inject a constant value that you read from the annotation during class manipulation time.\n. You can create a DynamicValue for some annotation where you return:\njava\ninstrumentedMethod.getDeclaringType()\n    .getDeclaredMethods()\n    .filter(named(\"test\"))\n    .getOnly()\n    .getDeclaredAnnotations()\n    .ofType(TestAnnotation.class)\n    .loadSilent()\n    .value();\nIf you bind this annotation to some dynamic annotation MyAnnotation, you can access it by:\njava\n@MyAnnotation String value\nfrom your Advice method. Note that the above code assumes that test always exists and is always annotated. You might want to insert existence checks if this is not given.\n. I am closing this ticket. I can reopen it, if the issue is not resolved.\n. Since versions 1.4.*, Byte Buddy excludes the bootstrap class loader from instrumentation by default. It seems like you are trying to instrument too many classes including classes within the JVM.\nI recommend you to change your strategy for instrumenting. Instead of doing \"no-op\" transformations like:\njava\nif (pluginDefine == null) {\n  return builder;\n}\nyou should exclude classes when setting type(exclusivePackageClass()) such that those classes are never triggered. Also, you should not catch exceptions; Byte Buddy catches them and aborts the transformation what is much more performant. You can still log exceptions by registering an AgentBuilder.Listener. \n. In 1.4.17, the sun.reflect. namespace is now excluded if not specified otherwise. After updating, you should be able to run your agent without any preconfiguration; you should still adapt your mapping. I am closing this issue and but I am happy to reopen it if your problem persists and you can provide more information.\n. Fixed on master.\n. Fixed and released.. The problem is that you are delegating to an instance (new ClassConstructorInterceptor(interceptor)). This instance needs to be set within the class which can typically only be done after the class was initialized. Therefore, the field value is null during the initializer initialization; as the initialization is still happening when the first instance is created.\nByte Buddy can initialize fields from within the class initializer to work around this. You can enable so-called activate resolution by:\njava\nnewClassBuilder.make(TypeResolutionStrategy.ACTIVE)\n. The problem is as follows: In order to call your instance of ClassConstructorInterceptor, the instrumented Driver class needs to know about this instance. For this, Byte Buddy adds a static field of type ClassConstructorInterceptor to Driver. Every time, a constructor is executed, it reads this field's value and invokes the interception method on it.\nTypically, Byte Buddy uses reflection to set this field after creating the class. However, when reflection is used, the VM initializes the class reflected upon. This triggers this instance creation:\njava\nprivate static final Driver INSTANCE = new Driver();\nAs you instrumented the constructor, this results in a NullPointerException as Byte Buddy has not yet set the field's value which is null for the time being.\nIn order to avoid this, the ACTIVE type resolution rewrites the class initializer to something like this:\njava\nprivate static final Driver INSTANCE;\nstatic {\n  ByteBuddyNexus.initialize(Driver.class);\n  INSTANCE = new Driver();\n}\nThis way, Byte Buddy can set the field before the new Driver() call is made, avoiding the problem.\n. As you say, it is the default for the agent builder. The assumption is that you know the classes you manually redefine by name. Therefore, you should know their properties. \nThe active strategy adds a type initializer to the class. It is not given you want that which is why its not the default.\n. As for alternative ways to do it: add a static interceptor and you do not need it.\n. You would do something like: MethodDelegation.to(ClassConstructorInterceptor.class) - for this, the interceptor needs to be stateless.\n. Found and fixed the error on master. You can use Jitpack if you need the fix already. I will release a new version soon.\n. Thanks for the report, I will look into it. The reason for this problem is a rather new feature where Byte Buddy discovers atypical byte code that does not allow for instrumentation. This is typically caused by broken tools or old compilers. Byte Buddy tries to fix the byte code in such cases whereas it would have created illegal byte code previously (the same problem goes with Javassist). The problem is that it sometimes tries to fix legal byte code where I have simply overseen a legal pattern. This just FYI.\n. I fixed the issue on master.\n. You need to set the disableClassFormatChanges option on the agent builder. Doing so informs Byte Buddy to disable certain hooks that some instrumentations require but to throw an exception if this is attempted.\n. Added on HEAD.\n. Was already implemented. \n. Fixed.\n. The problem is com.sun.tools.attach.AttachNotSupportedException: no providers installed, so it seems like you need to follow these instructions: http://stackoverflow.com/questions/11134159/how-to-load-attachprovider-attach-dll-dynamically\nIf you update your JVM, this problem should disappear.\n. Fixed on master.\n. Answered on StackOverflow.\n. The value returned by the @OnMethodEnter needs to be added to the local variable array of the method. For this to happen, any other local variables are moved by an offset one by Byte Buddy. This allows Byte Buddy to add the instrumentation \"on the fly\" without preparsing the method which is crucial for performance. It seems like the JRebel agent hard-codes indices into its instrumentation, i.e. expects an exact byte code pattern to be present when instrumenting code.\nI do not currently have a JRebel license available. Can you run your program with -Dnet.bytebuddy.dump=/some/location and send me the corrupted class file in question?\n. The problem is that a Java agent will always change the byte code of a method. That's its main reason to be. Byte code gives a big degree of freedom and it is up to the instrumenting library to ensure that the byte code remains valid no matter what the input is. \nLet's say that you wanted to instrument a method to stub out another method call. You would need to find that method call and replace it with something else, like a constant. Any subsequent agent would no longer be able to locate this method call and the indices of all other instructions would have changed, as well. The Java agent needs to know how to react to this and cannot simply write to the class file blindly. After all, an implementation is not part of the method's contract. Byte Buddy does not change any method contracts, i.e. retains the signature and never changes a method's parameters. Therefore, you can chain Byte Buddy agents as much as you want to.\nMost visitors built using ASM, the most popular byte code processing library in the Java space, imply local variable (re-)sorting (via a subclass of LocalVariableSorter) which is somewhat necessary for many \"on the fly instrumentations\" such as Byte Buddy. Therefore, it is very unlikely that Byte Buddy will ever attempt to work around such limitations. This problem you see would occure with most Javaagents. Also, adding such form of preprocessing would make the library more difficult to maintain and significantly degrade performance.\nFinally, the class file you sent me seems legal. ASM's CheckClassAdapter does not find any problems with the class. Do you not get any additional information from the verifier error? If so, the problem seems to be related to a later redefinition. I assume this is what happens:\n1. The JRebel agent comes first. It parses the class file and caches some indices of variables that it needs to patch regularly.\n2. The Byte Buddy instrumentation comes second, it changes these indices.\n3. The class is loaded for the first time.\n4. The JRebel agents wants to patch some index it cached but that was changed by Byte Buddy. This renders the instrumentation illegal.\nOne way to break this chain - if my assumption is correct - would be to apply the Byte Buddy transformer first. Simply pack your transformer as a Java agent and add it on startup before the JRebel agent. This way, JRebel would cache the right indices. You can also use reflection to hack into the internals of the InstrumentationImpl and simply add the Byte Buddy agent to the beginning of your transformer list.\n. I already contacted a JRebel engineer that I know but please file an official issue. There is always a chance that there is a bug in Byte Buddy but without a license, I cannot reproduce the issue and only guess.\n. I received a first feedback that this is a problem in JRebel and they look into it. I will keep you posted.\n. I already got feedback and it turns out it is indeed a problem in Byte Buddy. The Advice component did not adjust some debugging information of the class file which was used by JRebel to gain some insights that would otherwise need to be inferred in a more complex manner.\nThis is a minor fix which I already pushed to master. Can you try out the current state?\n. Perfect, thanks for the report. I will release a new version next week.\n. Any such agent defines a premain(String, Instrumentation) method. You need to call this method via reflection from your agent and you can expect the same behavior.\n. The JVM makes a reflective call itself. It looks at the manifest file, finds the premain class there and does something like:\njava\nClass.forName(\"some.pre.Main\", true, ClassLoader.getSystemClassLoader())\n          .getDeclaredMethod(\"premain\", String.class, Instrumentation.class)\n          .invoke(null, \"\", inst)\n. Yes, that is most likely what you need to go for.\n. Fixed on master.\n. This is a really strange bug. I do not currently have an Android SDK installed but I do not understand how the emulator breaks this where it runs without problem. Are you using the latest version?\nCould you set a break point where the exception is thrown and check the values? Is it an empty array for A1[] value?\n. Can you share your test project?\n. I cannot reproduce this. The only possibility, that I see is that there is a bug in the Android SDK. Can you check:\njava\nassert A1[].class.isAnnotation() == false;\nThis is required by the JLS but it seems like it returns true on your system.\n. I now switched the checks around which should fix it. I will try to make a release next week. Please report this as a bug to Android, this is a really bad bug in their software.\n. Fixed on master.\n. I cannot make TypeDescription serializable, because it is not serializable for all implementations. For example, a TypePool often looks up type descriptions lazily from a class loader. You cannot serialize a class without retaining this reference but a class loader is neither serializable.\nWhat I can do is make TypeDescription.ForLoadedType serializable.\n. Made TypeDescription.ForLoadedType serializable on master.\n. No worries, glad you found a better solution, serialization is almost never a good choice. I will still retain Serializable to align this better with the Java API. Thanks for your feedback.\n. Try adding: .with(AgentBuilder.Listener.StreamWriting.toSystemOut()) to your agent to see what is going on. Your agent fails to instrument inherited methods when your matcher is less precise. Methods like Object::hashCode.\nYou probably want to match .method(isDeclaredBy(typeDescription).and(eM)).\n. You do not return any value from your interceptor such that Byte Buddy does not know how to handle the instrumentation. As mentioned in the javadoc, you can circumvent this by declaring @RuntimeType:\njava\npublic static class Around {\n  @RuntimeType\n  public static Object m(\n      @Super(proxyType = TargetType.class) Object zuper,\n      @AllArguments Object[] args,\n      @Origin Method method\n    ) throws Throwable {\n      //Before\n      String modifier = Modifier.toString(method.getDeclaringClass().getModifiers());\n      System.out.format(\">*** %s%s %s.%s%n\",\n          modifier + ((modifier == null)?\"\":\" \"),\n          zuper.getClass().isInterface()?\"interface\":\"class\",\n          method.getDeclaringClass().getSimpleName(),\n          method.getName());\n      Object value = method.invoke(zuper, args);\n      //After\n      System.out.println(\"<***\");\n      return value;\n    }\n}\n. Please see the documentation of the Super annotation where this is explained. You can work around this by relying on sun.misc.Unsafe by setting strategy = Super.Instantiation.UNSAFE as an instantiation strategy or by specifying a constructor explicitly.\nFor what you are demonstrating, you should however rather use the@Pipe annotation.\n. Repeating a method call from an exit advice is nothing more then executing a loop. If you mess up the terminal condition, it will run infinitely. The behavior is an explicit opt-in and now available on master.. There is some progress in the MemberSubstitution component. I want to extend its capabilities but for now it is perfectly capable to replace a field or method access with another field or method access.. Yes, you can register an AsmClassVisitorWrapper to create the byte code and then load the type using the AndroidClassLoadingstrategy.\n. Note that you cannot redefine or retransform classes on Android but only create subclasses.\n. Decided to make Advice implement Implementation directly and to merge it with the intercept API as there is no guarantee that ASM visitor wrappers generally offer a meaningful implementation.\n. The version locator is adapted for the latest build of OpenJDK. I only support the latest EA builds as there are too many moving parts. Your version must be outdated (older than b138).\n. That build is ancient. I do not know if it is possible to download the pre-build directly and unpack it on the CI, but I doubt it as it requires accepting a license.\n. You can but I assume that you are trying to implement a method using ASM? Have a look at AsmVisitorWrapper which allows you better access to methods. It is also capable of resolving ASM flags such as ClassWriter.COMPUTE_FRAMES.\n. Does not seem to be problematic in practice.\n. Thanks, its fixed.\n. Good idea, I will add a wiki or something!\n. I added a wiki page for projects using Byte Buddy and linked it at the relevant places. Feel free to add your own project to the list!\n. Fixed on master.\n. Fixed on master.\n. I assume that getClass().getClassLoader() is not the same as the class loader of your stepsClass. If a class is package-private (all inner non-public and non-protected classes are), it is defined to be package-private. A package-private class can only be subclasses if the subclass is also within the same package.\nA package at runtime needs to be defined by the same class loader in order to be equal at runtime. This is a limitation enforced by the JVM. (This should also not work with cglib, so to speak.)\n. I see now what is going on. Byte Buddy mimics the constructors of its super class but it does not change their visibility. Therefore, you would need to set the constructor to be accessible before creating an instance. You can change that by using ConstructorStrategy.Default.IMITATE_SUPER_CLASS_OPENING upon subclassing.\nPS: I changed this to be the default starting from the next version.\n. If you want to instrument classes on the bootstrap class path, you have to set a different ignore-matcher. By default, Byte Buddy does no longer include bootstrap classes as most people do not intend to instrument these classes but do so accidentally. This also improves performance a lot.\nYou can set a different ignore matcher by ignore(none()), for example, to include all bootstrap classes. By default, Byte Buddy also ignores its own classes what would no longer be the case when ignoring nothing.\nAs for your matcher, it seems like your method matcher is not specific enough. Can you show me the code that specifies the matcher and instrumentation? You would typically say something like myMatcher.and(takesArguments(String.class, 1)) to express that you want to match all classes that match your matcher and that take String as their first argument. Probably you want to instrument all execute methods but wrongly assume all of them take an argument.\n. By default, Byte Buddy resolves TypeDescriptions lazily. If you can exclude the entire bootstrap class path, Byte Buddy only needs to check if classLoader == null and does not even need to parse a class file. If your only type matcher says something like isSubtypeOf(Foo.class), Byte Buddy needs to check every single bootstrap class for this super type, i.e. needs to parse all classes.\nGenerally, it is the most efficient to exclude classes by:\n1. A class loader.\n2. Its name (does not require parsing a class file).\n3. Its properties like an annotation. (Requires parsing only the single type.)\n4. Its linked properties like super types. (Requires I/O to process additional type information.)\nIf you set ignore(none()), the performance impact depends therefore on your subsequent matchers. If you are not even interested in transforming classes of the bootstrap loader, it does however improve performance quite a bit.\nAs for a general use case agent, the GitHub page showcases a simple agent. I know that documentation could be improved but I lack some time unfortunately. Byte Buddy evolves a bit by the direction of my customers asking me to improve bits and then I cannot typically write documentation in my paid time. That is of course a shame but a consequence of the OS-based business model. If you are interested in professional help, I am more then willing to contract and to write documentation as an assignment.\n. This would break runtime validation if the outer class was not transformed similarly.\n. Implementations do no longer define fields by default but only delegate to an existing one. For defining fields, the field definition API should be used instead.\n. I think it is because Byte Buddy has started ignoring java.* types by default. Many users had problems by accidentally instrumenting types from the bootstrap path without intending this, thus breaking their apps. You need to explicitly opt-in for such instrumentation adding ignore(none()) to your above builder.\nI would also recommend you adding disableClassFormatChanges() (safes you setting the type and the initialization strategy) to your builder and to match is(System.class) as a more type-safe alternative.\nStrangly enough, this change was done earlier, your example should not work with 1.4.1.\n. No, such modifications are allowed. You are not dllowed to ship a modified JDK for compatibility with other apps.\n. To be honest, this very much looks like a bug in the JVM. I have not tried this extraction mode on lambda expressions in a while but I can easily reproduce this behavior:\n``` java\nclass Foo {\n    void notFoundAfterRetransform() throws Exception {\n        Instrumentation instrumentation = ByteBuddyAgent.install();\n        instrumentation.addTransformer((loader, className, classBeingRedefined, protectionDomain, classfileBuffer) -> null, true); // No-op\n    instrumentation.retransformClasses(fooHolder().getClass()); // instrumentation.isModifiableClass(type) == true\n\n    fooHolder().getClass();\n}\n\nvoid verifierErrorOnRetransform() throws Exception {\n        Instrumentation instrumentation = ByteBuddyAgent.install();\n        instrumentation.addTransformer((loader, className, classBeingRedefined, protectionDomain, classfileBuffer) -> null, true); // No-op\n    instrumentation.retransformClasses(barHolder().getClass()); // instrumentation.isModifiableClass(type) == true\n}\n\nFunction<?, ?> fooHolder() {\n    return this::foo;\n}\n\npublic Object foo(Object p) {\n    return null;\n}\n\nFunction<?, ?> barHolder() {\n    return this::bar;\n}\n\nprivate Object bar(Object p) {\n    return null;\n}\n\n}\n```\nGenerally, its a bad idea to mess with lambdas, but it seems as if the properties of the anonymous class loading disappear upon transformation despite the transformer being a no-op. The verifier error probably happens due to the impossibility to invoke the private method from outside of the class and the NoClassDefFoundError happens due to the impossibility of explicitly looking up the anonymous class. I will report this as a bug to the OpenJDK.\n. I agree that the use case can be meaningful. I submitted a bug, let's hope it gets fixed.\n. I will post it once it passed Q&A and gets a number.\n. Ok, I now remember when dealing with this the last time, sorry for forgetting this.\n. While you cannot add any field or method, you can add meta data to any class that you retransform. I would suggest you to add an annotation for your purposes.\nOne problem with this approach is that you would need to make this annotation type available universally. Otherwise, when Byte Buddy uses the reflection API, where annotations that are not loadable by the respective class loader are suppressed.\nIf you are using an agent builder, you can however work around this by:\n1. Using a DescriptionStrategy.POOL_ONLY. When Byte Buddy parses a class's description, the same constraint does not apply as for the reflection API.\n2. Implementing a custom PoolStrategy where you return a TypePool.Default and give it a parent type pool of TypePool.Explicit that references all types that are relevant for your annotation.\nThe original method is not stored by Byte Buddy but it is available by the JVM. If you reapply a retransformation, the retransformation always starts from the base class implementation. You do therefore not need to worry about transformations to apply twice. All transformations are chainable if you for example chain two Advice implementations.\n. Technically, there is no problem with lambda expressions using the Advice class. However, there is a caveat which is the way lambda expressions are compiled.\nA lambda\njava\nclass Foo {\n  void bar() { Consumer<String> c = s -> System.out.println(s); }\n}\nis syntactic sugar for an explicit reference such as: \njava\nclass Foo {\n  void bar() { Consumer<String> c = Foo::lambda$1; }\n  private static void lambda$1(String s) { System.out.println(s); }\n}\nThe lambda method is created by javac and is defined as private.\nAfter inlining the advice method, lambda$1 is referenced from outside the class. This does however require that the advice class is visible to the instrumented class.\nOf course, Byte Buddy could copy the lambda methods to the target class. In this case, it would however no longer be possible to use Advice for redefinitions which is the main purpose of Advice. Therefore, you either have to make the lambda methods explicitly visible by defining them to be public manually or you have to use the \"old\" APIs without streams. \nGenerally, I would however recommend you to write \"old\" Java code for advice methods your target class might be compiled with a class file format prior to Java 7. Even on a Java 7/8 VM, the runtime would complain when discovering a lambda expression in such a legacy class file.\n. Implemented on head.\n. But the type is not. javac creates a new anonymous type to represent BAR. You probably need to do MethodDelegation.to(Foo.BAR, Foo.class) to indicate delegation to the correct type.\n. Fixed on HEAD.\n. It is possible. I have however not measured any performance impact. It should however not make a big impact, as these dynamic dex files are also compiled: https://www.youtube.com/watch?v=EBlTzQsUoOw\nDo note that Google already abandoned the idea of AOT compilation for future versions of Android.\n. Glad I could help, here is what I meant: https://www.infoq.com/news/2016/03/android-n-aot-jit\n. To me it seems as if you are missing the dx-1.7.jar when running the tests. The AndroidClassLoader has a dependency on Android's DX-compiler which is however available on Maven Central.\n. I assume that you are defining an inner class which never defines a no-argument constructor. Try adding the static keyword where the outer instance does not become an implicit constructor argument.\nThe error is neither related to Byte Buddy but occurs after class generation when using the reflection API. Try calling getDeclaredConstructor().newInstance() instead which probably throws a NoSuchMethodException. (Calling .newInstance() directly was deprecated in Java 9 for this reason.)\n. You can simply ignore such types by setting up an appropriate matcher:\nagentBuilder.ignore(nameStartsWith(\"net.bytebuddy.\")\n    .or(nameStartsWith(\"com.newrelic.\")))\n    .or(any(), isBootstrapLoader())\nThe above matcher ignores any type belonging to Byte Buddy, New Relic or the JVM.\n. You can look into the new relic jars manifest and locate the premain class and method. Invoke this method upon startup using reflection and provide the argument and instrumentation instance.\n. You would probably need to extract the agent and the yml file to the file system. I do not know how New Relic works but this should emulate it.. Are you sure that your intended interceptor can intercept hashCode? Does it return int or uses @RuntimeType?\nThis works fine for me:\njava\nnew ByteBuddy()  \n  .subclass(Object.class)\n  .defineField(\"foo\", Bar.class)\n  .method(isHashCode())\n  .intercept(MethodDelegation.toField(\"foo\"))\n  .make();\nwhen using:\n``` java\nclass Foo {\n  @RuntimeType Object intercept() { return 42; }\n}\nclass Bar extends Foo {\n}\n. java\n        Class<?> type = new ByteBuddy()\n                .subclass(Object.class)\n                .defineField(\"foo\", Object.class, Visibility.PUBLIC)\n                .method(isHashCode())\n                .intercept(MethodDelegation.toField(\"foo\").filter(isHashCode()))\n                .make()\n                .load(Object.class.getClassLoader())\n                .getLoaded();\n    Object instance = type.newInstance(), delegate = new Object();\n    type.getDeclaredField(\"foo\").set(instance, delegate);\n\n    System.out.println(instance.hashCode());\n    System.out.println(delegate.hashCode());\n\n``\n. WithMethodDelegation.toField(\"foo\"), Byte Buddy locates the field's type which in the above example isObject. It then finds a suitable delegation method of the field's type. As we explicitly filtered to only considerObject::hashCode` as a possible delegate (this would have been the best match anyways), this will be used as a target for the delegation. \nBy inherited methods, do you mean you want Byte Buddy to locate methods of the foo instance at runtime? This is not possible. Byte Buddy generates types where methods are dispatched virtually. If you wanted different methods for different types, you need to generate a type for each such type.. Ah, I understand this now. While interfaces are implicitly Object types, they are not considered explicit subclasses of it, i.e. someInterface.getSuperClass() will return null for an interface type. It is neither possible to override hashCode, toString or equals with an interface default method. \nTherefore, the Object methods are not considered here. There are two ways around it:\n1. You declare the methods in the interface.\n2. You implement a custom MethodGraph.Compiler that returns a method graph where these methods are included.\nI will at some point add a convenience method to the latter.. I revisited this and I wonder if MethodDelegation is the right approach for this. Interfaces do, in theory, not define the Object methods and I would break a lot of things by making Byte Buddy think so. Are you trying to redirect an object's methods to another object? I think it would be better to implement this with an explicit call, i.e.:\njava\n.method(HASH_CODE)\n.intercept(MethodCall.invoke(Object.class.getDeclaredMethod(\"hashCode\"))\nI am still looking into a more convenient solution but for the time being, I think this is the best way.. In this case, you can, for now, use MethodCall.invoke(Object.class.getDeclaredMethod(\"hashCode\")).onField(\"foo\").\nI added onField in version 1.5.8 (released yesterday). I hope to come up with something even smarter in the future.. After looking into this, I decided to not add such functionality. The only time where I would like to use a delegation to the Object methods would be when I use a delegation to delegate every method from instance A to instance B where both instances are of the same type. For such cases, it would be best to use the suggested MethodCall which is much better performant and which can be chained. I added a reference to MethodCall in the documentation.. First of all, I apologize for these changes. I sometimes forget that more people then me are using the byte code level API. The particular renamings I made in an airplane when I got annoyed that statements did not fit on my screen so I removed some naming redundancies. Obviously, this is not a good enough reason to break an API and I will better pay attention to this in the future.\nFor some of the primitives, the changes were however necessary as I refactored Byte Buddy to work with generic types where the least-specific representation has become a TypeDefinition rather than a TypeDescription. I did not catch all the places where I should have refactored what is mostly a performance improvements, I just did not have the capacities.\nUntil now, I felt like nobody but me used these low-level representations but I guess the library has grown in a way where I should have realized that I cannot change a few things and then simply update the usage in the code bases of all my users. Again, I am sorry for the inconvenience. I just went through the APIs and improved a few last changes; I promise to attempt better compatibility in the future.\nAs for the use of the TerminationHandler, this change was intended. The termination handler was added to support the fluent API of a method delegation. It does not make sense to use it outside of the context of such a delegation as the implementation might change with the method delegations generated byte code. You should not rely on this. I would therefore replace it with the method body:\njava\nnew StackManipulation.Compound(assigner.assign(target.isConstructor()\n    ? target.getDeclaringType().asGenericType()\n    : target.getReturnType(),\n  source.getReturnType(),\n  RuntimeType.Verifier.check(target)), MethodReturn.of(source.getReturnType()));\nIf you can guarantee that the target is no constructor or/and if you are not using the @RuntimeType annotation, you can simplify this to:\njava\nnew StackManipulation.Compound(\n  assigner.assign(target.getReturnType(), source.getReturnType(), Assigner.Typing.STATIC),\n  MethodReturn.of(source.getReturnType())\n);\nNot reading the annotation will probably improve performance quite a bit.\n. If this only happens in your test, I do not think this is a problem with Byte Buddy but rather with Robolectric. The latter library mocks the Android environment and I assume that its a problem with how they mimic Android.\nI can have a look if you create a reproduction that I can build and run.. Did you make any progress on this?. I looked a bit into this and it seems like Robolectric defines a field libcore/io/Libcore.os:Llibcore/io/Os which is null but should not be. I assume that Robolectric has limited support for Dex class loaders. The way that Robolectric works is that it uses a custom class loader where - at runtime - it replaces the stub implementations of the Dalvik API by its custom logic. What you really see is an exception within Robolectric. I am sure that they can fix this problem. This has nothing to do with Byte Buddy which works with the official Android implementation but which seems to hit a bug in the pseudo-API that Robolectric offers.. My pleasure. You should be able to file the same issue with them. They can compare why this does not work with Robolectrics vs. an Android machine and identify the difference.. It seems to me as if you are providing the method with a Class instance rather than an actual isntance.\nYou still need to call something like proxyAdapter.newInstance() before handing it as an argument.. I am closing this for now. Feel free to reopen the ticket if you have further questions.. Well, Byte Buddy only implements Java code. Javac does not allow implementing a class with missing methods but Byte Buddy does, as this might be what you want. You need to implement the missing methods in your subclass.. The problem here is that MethodDelegation does an actual delegation where the code is probably run in another class loader as you are using an application container to deploy. A Java agent is always run in the application class loader whereas the web application is most likely running in a Jetty application class loader.\nYou have two ways of going around this. One is to make sure that your interceptor is running in the right class loader. The easier way - since you are migrating away from Javassist - is probably to use the advice component instead:\njava\n builder\n  .method(named(\"doHandle\"))\n  .intercept(Advice.to(JettyHandlerAdvice.class))\nwith\njava\n@Advice.OnMethodEnter\npublic static void doHandle(@Advice.AllArguments Object[] args) {\n  System.out.println(\"!!!!!!!!!!!\");\n  ((HttpServletResponse) args[3]).setHeader(\"X-My-Super-Header\", \"header value\");\n}\nIn the latter case, Byte Buddy inlines the code into the target method such that your code is run in the application code's class loader. This way, you do however no longer have access to the agent's class loader if the code you instrument is not a child of it.\nTo generate more efficient byte code, you should do the following:\njava\n@Advice.OnMethodEnter\npublic static void doHandle(@Advice.Argument(\n                value = 3, \n                typing = Assigner.Typing.DYNAMIC) HttpServletResponse response) {\n  System.out.println(\"!!!!!!!!!!!\");\n  response.setHeader(\"X-My-Super-Header\", \"header value\");\n}. The advice class only serves as a template, no reference to it is added to the instrumented class. The parameters only serve as a representant of the business logic, e.g. Byte Buddy will rewire any access to the response parameter to the third parameter of the instrumented method.\nYou can validate this by setting a break-point in the advice method which will not be triggered when calling the instrumented method. As the method is however defined, you are still able to unit test it once it contains a bit more logic than what you added.. With the AgentBuilder you need to register a listener as the instrumentation API suppresses any exception.\njava\nbuilder = builder.with(AgentBuilder.Listener.StreamWriting.toSystemError()). It looks similar, but the issue is different. You are supplying the advice class as a loaded type. In order to find the advice method, Byte Buddy needs to use the reflection API which eagerly resolves all types within method signatures. This causes the no class found error as the signature references a servlet API type that is unknown to the system class loader.\nTo avoid this, you can avoid referencing such application-specific types in method signatures, e.g. use Object and cast in the method body. A nicer approach is however the usage of Byte Buddy's type pools (similar to Javassist's class pools but without the overhead of retaining implementation information) where you can describe types using a combination of class loaders:\njava\nbuilder = builder.transform((builder, typeDescription, classLoader) -> {\n  ClassFileLocator locator = new ClassFileLocator.Compound(\n    ClassFileLocator.ForClassLoader.of(classLoader),\n    ClassFileLocator.ForClassLoader.of(ByteBuddy.class.getClassLoader())\n  );\n  Advice advice = Advice.to(\n    TypePool.Default.of(locator).describe(\"pkg.JettyHandlerAdvice\").resolve(),\n    locator\n  );\n  return builder.method(named(\"doHandle\")).intercept(advice);\n});\nThis way, Byte Buddy can inline the advice method without ever loading the advice class.. Its not really that complex. You can have a look at: https://github.com/stagemonitor/stagemonitor to see an example of it in action.. Sure thing, should learn my own API ;)\nThanks for the hint!. Just FYI, I finally found some time to add an out-of-the-box API for this pattern, see #220.\nYou can now use the advice that you wanted by:\njava\nbuilder = builder.transform(new AgentBuilder.Transformation.ForAdvice()\n  .include(getClass().getClassLoader()) // must be able to see \"pkg.JettyHandlerAdvice\"\n  .advice(named(\"doHandle\"), \"pkg.JettyHandlerAdvice\"));\nLet me know if you are still trying this out and have any questions.. Its not in the release version yet, but you can build Byte Buddy yourself in the mean-time if you want to try it.. So, I keep forgetting this but this is a side-effect of this bug that is currently only resolved in Java 9: https://bugs.openjdk.java.net/browse/JDK-8145964\nIt is caused by the interaction of the instrumentation API with an invokedynamic type. The instrumentation, even it is a no-op resets the lambda class's patched constant pool causing this error. There is, unfortunately, nothing to be done here, this is a VM bug.\nUnfortunately, it seems like the instrumentation API will not have an option to interact with lambda expressions in the future as the easiest solution to this bug.. No, not all issues are backported by the OpenJDK team. Only signigicant ones or you can order a backport on a paid support contract.. A builder was added on head: AgentBuilder.Transformer.ForAdvice.. Ah, shoot. I moved the wrapping to the DSL. You can fix this by wrapping the result in a TypeDescription.ForLoadedType. Sorry for the regression!. As a background, I did a major rewrite of the Advice component. It does now use Byte Buddy's standard StackManipulations what makes it much easier to write to values as the component now uses standard assignment like boxing etc. The generated byte code is also much more efficient and you can even map your own StackManipulations if you want to apply custom byte code. But this one slipped under.\nThe good news: With the rewrite, I think the Advice component has finally stabalized, I do not think there will be further deep changes.. Ah, this is indeed a bug, sorry for this. I will fix this ASAP.. Fixed in 1.5.7.. I know this is unfortunate. The problem is that inlining a method into another one is not quite trivial. You would need to inline all sorts of meta data which requires a lot of adjustment. This would introduce quite a performance overhead you would not want to pay.\nOne solution to overcome this would be to inject some form of utility into a class loader. You can do so by using a ClassInjector. If you do instrumentation, you can also simply inject this utility into the bootstrap class loader what makes it available globally. You can then call the methods from anywhere, i.e. your advice class.. Yes, you can use MethodCall.invoke(Constructor) or MethodCall.invoke(MethodDescription). If the method is yet to be defined, you can use a MethodDescription.Latent for its representation.. MethodCall is just another implementation such as MethodDelegation. You can implement:\njava\nnewClassBuilder.constructor(matcher).intercept(MethodCall.invoke(otherConstructor))\nDo I understand you correctly that you want to implement a constructor to invoke another constructor? If you want to create a new instance from a method call:\njava\nnewClassBuilder.method(matcher).intercept(MethodCall.construct(someConstuctor)). Yes, this is perfectly possible by chaining interceptions:\nnewClassBuilder\n  .constructor(takesArguments(int.class)).intercept( ... )\n  .constructor(takesArguments(String.class)).intercept( ... )\nThe matchers are applied in the order last to first.. The easiest solution is to implement a custom ElementMatcher:\njava\nString typeName = ...\nnew ElementMatcher<MethodDescription>() {\n  @Override\n  public boolean matches(MethodDescription m) {\n    return m.getParameters().size() == 1 \n      && m.getParameters().get(0).getTypes().asErasure().getName().equals(typeName);\n  }\n}. The matcher will be invoked for any discovered method by Byte Buddy. The reason for the asErasure is that any type is first represented in its generic form. For example, a parameter might have a type List<String> where the erasure is List. You want to probably compare the erasure, not the generic type. Generally, this is also more runtime efficinet,. The difference is the representation of TypeDescription.Generic and TypeDescription. The former can be a non-generic type like String but its a different representation.. Possibly, I have not yet looked into all possibilities.. In the DSL, it should be possible to define a value for a field, similar to setting an argument.. Implemented on master.. Yes, you are right. This is a bug and your suggested fix is the solution. This will be fixed in the next version of Byte Buddy. Thanks for reporting and looking into!. This depends very much on what you want to do. You can set an initial constant value easily using the defineField or field API of the DynamicType.Builder. If you want to set a field from a constructor, have a look at the FieldAccessor API. If you want to define a static field with a value, you can register a LoadedTypeInitializer that does so or intercept the type initializer by ElementMatchers::isTypeInitializer.. You cannot set a complex value this way, the Java class file format does not support this. You would need to either intercept constructors to do this or define a loaded type initializer.. The first problem is that you need to explicitly opt-in for instrumenting bootstrap classes. For most people, this does not make sense as this generates quite some overhead. In order to shortcut the process, you should find another ignore matcher that does not include all bootstrap classes but for a general test, it should work like:\njava\nbuilder = builder.ignore(ElementMatchers.none());\nYou are however suffering a second problem. You can debug agents by registering a listener that prints all actions by:\njava\nbuilder = builder.with(Listener.StreamWriting.toSystemOut());\nWhen redefining a class, you can only replace a method but you cannot rebase it what you attempt with using a MethodDelegation. You want to rather enhance a method. For this purpose, Byte Buddy offers a similar but eventually different API called Advice. You should approach this as follows:\njava\nclass ThreadStartAdvice {\n  @Advice.OnMethodEnter\n  static void intercept() {\n    System.out.println(\"Thread '\" + Thread.currentThread().getName() + \"' started\");\n  }\n}\nand use it via:\njava\nbuilder = builder.visit(Advice.to(ThreadStartInterceptor.class).on(named(\"start\")));\nNow everything should work as expected. You should also call disableClassFormatChanges() on the agent builder.. Thanks, I just completed the migration. CI build time went down by a bunch! Thanks for the work.. Thanks, I will have a look as soon as I find some time!. Thanks for your PR. I refactored it a bit and changed some of the naming. Appreciate your effort and will release this soon.. Also, investigate why the Gradle build fails on CI.. I just resyncned, thanks for reporting. I also created a ticket: https://issues.sonatype.org/browse/MVNCENTRAL-1442. Thanks, I fixed the link.. Newer version of Byte Buddy ignore classes on the bootstrap class path by default as most people do not want to instrument those classes. In order to enable bootstrap instrumentation, you have to specify your own ignore matcher such as .ignore(ElementMatchers.nameStartsWith(\"net.bytebuddy.\")) where all Byte Buddy classes would be excluded.\nI updated the example.. You can configure an AgentBuilder to activate a RedefinitionStrategy.RETRANSFORM. Doing so, Byte Buddy registers the agent to also transform already loaded classes. Byte Buddy picks up any retransformation once this strategy is activated. You can trigger a retransformation using Instrumentation::retransformClasses. All you would need to do would be to call this method with supplying the classes in question.\nWhen applying retransformation, you should also activate .disableClassFormatChanges(). This disallows certain operations which most VMs do not support for retransformation. Typically, you would use this feature in combination with an Advice class.. With disableClassFormatChanges, you cannot longer add methods or fields. Some of Byte Buddy's components do this implicitly, for example if you apply a MethodDelegation to an instance rather than to a static method where Byte Buddy needs to store the instance in a static field within the transformed class.\nAlso, you cannot retain the original code of any transformed class when applying a method delegation. The result will be a ByteBuddy::redefine, not a ByteBuddy::rebase. If you want to enhance existing code, you can add code prior and after an existing method using Advice via DynamicType.Builder::visit where you inline the advice method's code.\nYou can have a look at Stagemonitor which implements such an agent using Advice.. With help of tools.jar, you can attach to a JVM at runtime rather than at startup. This is often working well for debugging tools that are primarily using JDKs anyways. We do for example use it in Mockito for the inline mock maker that allows you to mock final methods and classes. I also figured out a way to make it work in Linux SDKs by mimicing the attach API's protocol.\nStategmonitor uses the attachment how it is recomended. It attempts an installation if no javaagent was provided. Otherwise, you need to add the byte buddy agent manually (minimal jar) and Byte Buddy picks it up automatically. The EhCacheAttachmentProvider is added as EhCache attempts the same runtime attachment and breaks loading the (native) library on some JVMs, so it is rather a workaround to a limitation of older VMs.\nNote that you can attach to a VM even if it is run on a JRE as long as you attach from a JDK if you make an external attachment.. Your interceptor exists twice after injection. It is included by both the Javaagent (added to the class path) and injected by you into the bootstrap loader. The typical way to solve this problem would be to make sure that you inject the interceptor class before loading it. As the agent is executed on the system class loader which always asks its parent to load a class first, you need to inject the class without ever referring to the loaded .class.\nA common way of solving this problem would be to extract the interceptor into a seperate jar file which you only ever refer to as provided in your project, i.e. you do not add it to the final agent jar. As a first step of your agent's setup, you extract this jar file from somewhere where it is not available to your agent's class loader and call Instrumentation::appendToBootstrapSearch. Afterwards, the class is available to all of your classes as it is now and will only ever be loaded once.. Fixed, thanks for reporting.. I added an additional constructor to MultipleParentClassLoader where you can supply an explicit parent. Did you encounter this problem when using Mockito on Android by any chance?. I added an additional builder method to MultipleParentClassLoader that allows to define an explicit parent. I will include this in the next release and also update Mockito to use this. Thanks for the report! . Thanks, I updated the Dexmaker dependency to this new release and will include this update in the next version of Byte Buddy.. FYI: I did not include the most recent version of the repacked dx-dependency but rely on the previous version as the latest requires Java 7. However, you can manually require the more recent version if you want to; there are no API changes what makes this quite easy. . Thanks for using Byte Buddy, great that you like it!\nByte Buddy's high-level APIs are not aware of what the low level-APIs are doing. If you choose to write manual ASM then Byte Buddy's Advice does not parse the code to integrate it into its meta description. This is however done when a type is parsed for the first time using a TypePool where no on-the fly modifications are applied.\nWhat you can do: Use Byte Buddy's API to implement an interface using Byte Buddy's API but you would also apply a MethodVisitor where you remove the duplicate interface before it is applied to theClassWriter. Otherwise, Byte Buddy has no chance to know about it.. Fixed on master.. I have been considering this for a while but never found the time but I will try to incorporate this into the next milestone release. Creating the methods has never been much more but the click of a button but it bloats the code. I also want to remove thetoStringmethods alltogether as they account for quite a bit of the project's jar size.. Please do! Thanks a lot!. Fixed on master. Thanks for the very clean PR and doing this very repetitive work. This makes the code base much cleaner, I really appreciate the effort!. The approach was right and I am glad that the manual hashCode/equals are removed. I mainliy pushed this to being able to build on Java 10/11.. I will look into it, should not be a big thing so I can do this.. Instead of making this API public, I created a public classSerializedConstantwhich is aStackManipulation. Using this manipulation, a custom binding is very easy to implement; the constant is now also used by the dynamic binding.. Yes, ASM allows this. Have a look at theClassVisitor` that you can apply via a wrapper.. This has become more urgent in order to support nestmates.. Done on master.. Yes, it is possible by using the type builder DSL. . Using the DSL is already the best way.\nI cannot reproduce this problem. Could you check a little what is going on on your system? Does the class get overridden, i.e. is it stored if you only store inner class? Otherwise, set some breakpoints in saveIn to see if something unexpected happens, maybe your file system is confused over $.. I'd iterate over all inner classes and once you generate all of them, generate the outer class that is required to reference all of its inner classes.. Awesome, thank you. I will try to review this sometime next week. Quite a lot of code changes but I trust its good for! Excited to see the impact on the code size.\nCheers, Rafael. Fixed on master.. Its fixed in the newest version. There is now and injecting and a wrapping strategy for android.. Did it work in between? I tested it successfully on my device. Can you clone Byte Buddy and try to run the included test project?. If this is the case, this is indeed impossible, the JVM does not allow it and there is no way around it.. Yes, please see this issue: https://github.com/raphw/byte-buddy/issues/236. Great, glad you like the library!. Have a look at the Advice component. With this component, you can define OnMethodEnter advice where you use the Argument annotation where you can set a property readOnly = false. This way, you can change the value.. I would not recommend you to read all arguments if you only need to change the first one:\njava\n@Advice.OnMethodEnter\nstatic void before(@Advice.Argument(value = 0, readOnly = false) Runable task) {\n  task = myInterceptedWrapMethod(task);\n}\nBe aware that this code is executed on the bootstrap class loader where your classes might not be available.. You do not seem to specify the advice in your transform method. You have to register it, of course.. you have to set the annotation property readOnly to false for that.. In this case I would need a small reproduction of your problem. From what I have it is difficult to tell what goes wrong and where.. You can, using an AsmVisitorWrapper. You do however need to write your own ASM. In the future, I might supply a better mechanism but generally, I do not recommend writing instrumentation against a method's implementation as such implementations can change easily.. Thanks, I appreciate it. I am planing to write this component at some point: https://github.com/raphw/byte-buddy/issues/187\nIt would allow you to substitute any field or method access within a method with a row of field or method accesses. If you have a commercial project that requires this sort of thing and you do not want to wait for me to find some free time, please get in touch and I could develop it for you in paid time.. Thanks, glad you like the library!\nI have layed the foundation for this with the MemberSubstitution component that already is a part of Byte Buddy which I plan to extend at some point to allow for arbitrary replacements. Unfortunately, I currently lack the time to work on this as Java 9 support has drained my ressources and I have a little kid at home.\nIf you need this for a commercial project, please get in touch and I can offer you a (reasonable) quota for developing this feature.. After considering such an API, from a type-safety perspective it is basically impossible to implement this without requiring any preconfiguration. It would therefore be easiest to implement a custom annotation binding which is probably already sufficiently covering this use case.. Thanks for the explanation.\nBasically, Byte Buddy relies on the readability of class files. This is normally given as classes are stored in class files together with resources. It is a class loader's responsibility to provide these items. If you add a resource my.properties to a jar, publish it then you expect to read these properties at runtime via querying your class loader.\nByte Buddy does something similar. When you request information to a class that is linked in an instrumented type, it requests a .class file as a resource and parses the class file into a TypeDescription. This way, you can query for information like agentBuilder.type(isSubtypeOf(Foo.class). If some class Qux is found which is a subclass of Bar which is a subclass of Foo, Byte Buddy needs to parse both the class files of Qux and Bar to answer the question of subtyping. At this time it is not yet possible to load Bar as you must not load new types during instrumentation which is why the above routine is activated.\nIf this fails and your instrumentation can be applied onto a loaded type, you can fall back to retransformation in a second step.. For now, the resolution is skipped when it is impossible that a type variable is defined for a bound. Furthermore, it should be investigated if the GenericTypeExtractor.ForSignature visitor could explicitly mark this information when parsing, e.g. by adding information when reading visitClassBound or visitInterfaceBound.. Fixed on master.. The error message suggests that you are trying to create advice for a method returning void where you expect a non-void type via @Advice.Return.. I tried the following example which works without a problem:\n```java\npublic static void main(String[] args) {\n  premain(\"\", ByteBuddyAgent.install());\n  new SampleController().foo();\n}\npublic static void premain(String arguments, Instrumentation instrumentation) {\n  System.out.println(\"==============================agent start!======================================\");\n  new AgentBuilder.Default()\n      .type(ElementMatchers.nameEndsWith(\"Controller\"))\n      .transform(new AgentBuilder.Transformer() {\n        @Override\n        public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder,\n            TypeDescription type,\n            ClassLoader classLoader,\n            JavaModule module) {\n        System.out.println(type.asBoxed().getSimpleName());\n        return builder.method(ElementMatchers.any()).intercept(MethodDelegation.to(AccessInterceptor.class));\n      }\n    }\n  ).installOn(instrumentation);\n  System.out.println(\"==============================agent end!======================================\");\n  }\npublic static class AccessInterceptor {\n@RuntimeType\n  public static Object intercept(@Origin Method method, @SuperCall Callable<?> callable) throws Exception {\n    System.out.println(\"start!\");\n    long start = System.currentTimeMillis();\n    try {\n      return callable.call();\n    } finally {\n      System.out.println(method + \" took \" + (System.currentTimeMillis() - start));\n    }\n  }\n}\npublic static class SampleController {\n  public void foo() {\n    System.out.println(\"foo\");\n  }\n}\n```\nMaybe there is something wrong with your class loader composition? You can always register a AgentBuilder.Listener.StreamWriting to see what is going wrong.. I have run this exact code in IntelliJ and it worked. I assume that you change something as you for example added the logger call.\nYou can register a listener with:\njava\nagentBuilder = agentBuilder.with(AgentBuilder.Listener.StreamWriting.toSystemOut());\nI assume that you are loading your type prematurely. In this case, your listener does not report the type that you are looking for.. You are using Advice.Origin instead of Origin in your code.. There are two Origin annotations, one is only to be used with the Advice component which you are not using. In your screenshot above, you are using it and this also explains the error message you get.. This time, you are importing the wrong Method type, you want java.lang.reflect.Method, not the ASM representation. Please read the error message.. I assume that your agent is running on a different class loader then your application. Any instrumented class needs to be able to resolve the interceptor class.\nYou might need to inline the code by using Advice as a visitor or you need to add your interceptor classes to the bootstrap class loader by using Instrumentation::appendToBootstrapSearch.. With a first change, super constructor resolution is lazy. It should be investigated if this should be linked to the required method graph such that the overhead of looking up the structure for any constructor can be avoided.. Added a decorator mode and lazy type hierarchies.. Implemented with 1.7.*.. By doing the above you do not add any code with an effect. Attempt to debug your code by trying something like adding a System.out::println and see if it works.\nYou should also add a AgentBuilder.Listener.StreamWriting::toSystemOutput to see if your types get enhanced the way you want it.\nFrom the little code you provide, I cannot say anything further from what is wrong.. There is a chance that your application class loaders cannot see the your advice types such as PrometheusMetricsModule. Application containers such as Tomcat often shield their deployed applications from the system class path on which the agent is loaded.\nWhat I would recommend you is to start out with a very simple advice that does not rely on any foreign types but only, for example, prints to the console. If this works, it is a class loader issue.\nA common strategy is to add such required infrastructure types to the bootstrap class loader in a specific jar via the Instrumentation interface. This makes those types universally visible to all class loaders.. Byte Buddy exposes a generic description of types. You can use the returnsGeneric matcher and implement any custom logic for it. For example:\njava\nreturnsGeneric(type -> type.asErasure().represents(Set.class) \n  && type.getSort().isParameterized()\n  && type.getTypeArgument().get(0).asErasure().getName(\"well.known.Object\");\nWould cover your use case.\nBy \"hooking into\", do you mean instrument all super types of an interface? This is possible. Just use the agent builder API and match types accordingly.\nYou should, if possible, only register one agent builder and chain all matching:\nnew AgentBuilder.Default()\n  .type( ... ).transform ( ... )\n  .type( ... ).transform ( ... ). You can implement your own ElementMatcher where you can decide for any TypeDescription if you want to instrument this type. The API is similar to the reflection API.. Fixed on master.. Good catch, thanks! (I use Unix and so does Travis.). For chaning values of existing fields, you rather have to change values using the .field(ElementMatcher API. While this allows you to change the fields, you will be out of luck. final values of primitives are compile-time constants that are inlined whereever the field is referenced. Thus, the values are set whereever they are used.. Byte Buddy does not offer any test-tools but matchers can be tested the easiest by creating types that fit the specification. These types can then represented via TypeDescription.ForLoadedType. By my experience, this is the most reliable way and also type-safe.. Like this:\njava\nclass Foo { }\nTypeDescription d = new TypeDescription.ForLoadedType(Foo.class);\nassert ElementMatchers.named(\"Foo\").matches(d) == true;. Byte Buddy puts some preasure on the young GC but if you retain objects (everything is immutable), it should not put problems onto your system. I used Byte Buddy in high performance environments without problems.\nRetransformation is by itself however quite expensive. You should give more time for the attachment.. Bootstrap classes are excluded by default, you have to set an explicit ignore matcher on the agent builder to avoid this.. The Advice component works by more-or-less \"copy-pasting\" the code into the advised method. For this to work, it has to be visible to it.\nNormally, you would create some dispatcher API, put this API into a jar of its own and load it via Instrumentation::appendToBootstrapClassLoaderSearch. By being loaded by the bootstrap loader, the class becomes universially visible to all classes.\nYou can create such a jar by creating a seperate project in a Maven setup and only referencing this jar in provided scope. Within your agent, the first action would be the appending of the jar; after that it is available.\nYou can create a very lean and generic dispatcher, for example the following:\njava\nclass Interceptor {\n  volatile Runnable runnable;\n  void doSomeThing() {\n    runnable.run();\n  }\n}\nIn your agent, you inject this jar and set the Runnable to a value. Now, your agent does what you expect.. You can configure a delegation prior to spplying it by MethodDelegation.withDefaultConfiguration. this way, Byte Buddy can optimize much better if you reuse the instance.. With specifying the REDEFINE strategy, you do not longer rebase the original method (meaning, retaining the original code of foo). Therefore, foo's original implementation is discarded in favor of your new one. \nYou probably want to advice the foo method. Look into the Advice component and apply it as a visitor via DynamicType.Builder::visit.\nI just added a toString implementation for the record class to improve the error message.. Retransformation is a quite expensive operation, unfortunately. The JVM must lock all classes, replace all references and do a lot of maintenance to apply a retransformation. You can measure the difference by supplying a proxy for the Instrumentation interface where you implement retransformClasses as a no-op.\nAs for Byte Buddy, good ignore matchers where you exclude everything but your target namespace often does the job. Byte Buddy only parses class files if it absoloutly has to. Also, you can supply a MethodGraph.Compiler.ForDeclaredMethods to ByteBuddy to avoid parsing a class's class hierarchy. This way, you can however not properly add classes.. The JVM's JIT is doing the exact optimizations that you are proposing. I do not think that you can do any better here and you are also forcing the JIT to discard and recompile any code upon a retransformation. \nAs for removal: You cannot tell Byte Buddy to only remove certrain retransformations. In this case, you would have to manage the installation process yourself by using makeRaw. But remember: retransformation is not for performance improvements. You will not get anywhere with this!. Awesome, thank you! I develop on Linux, this was on my mind before and I will merge this asap.\nOut of curiosity: why is the Maven wrapper necessary? Does AppVeyor not supply a default installation?. I see, thanks for the explanation and your effort!. Try registering a AgentBuilder.Listener which gives you feedback on what might have gone wrong.. I assume that you have to make your interceptor class public.. Unfortunately, there is currently no good way of doing so. You can generate such more complex code by defining a custom ByteCodeAppender. I consider adding something viable in the future.. Captured by #321. You probably want to match all non-abstract methods: method(not(isAbstract())). Otherwise, Byte Buddy requires an original implementation due to @SuperCall.\nI would however recommend you to not use a MethodDelegation when instrumenting bootstrap classes. Rather use the Advice component, the JVM might not resolve added methods correctly.  It also saves you from the bootstrap injection.. You have found a bug when resolving optional this parameters. I just fixed that bug on master. My unit tests did not capture this as the instrumented type's declaring type and the methods declaring type was accidentally identical.\nAs for creating a general interceptor, you can use the Java 8 Executable abstraction to capture both Constructor and Method objects. For static initializers, you do however need to fallback to a String as the JVM does not offer a constant to represent initializers. Alternatively, you can offer two advice classes as before and add a conditional advice specification as you do currently.\nI already fixed the bug on the master branch. Consider using JITPack if it stops you from progressing. The fix will be part of the next release.. This is better covered by reapplying the AgentBuilder which is immutable. The created transformers are stateful objects and should not be reapplied after resetting them.. You still need to be able to locate these classes at runtime for Byte Buddy to work. A Java agent is loaded by the system class loader but this is not necessarily true for your application classes.\nAs a convenience, Byte Buddy offers AgentBuilder.Transformer.ForAdvice as a builder for creating an advice transformer that looks up both your agent and the transformed class loader and creates advice by resolving classes from both class loaders.. Write your matcher as hasSuperType(named(\"org.springframework.http.client.AbstractClientHttpRequest\")).\nGlad it works.\nPS: Technically, it is possible that your VM resolves Probe eagerly and the loading would fail. HotSpot does however not do that but it would be cleaner to reference the class by name.. Byte Buddy repackages ASM to avoid version conflicts with other versions as ASM changed its API quite a lot in its older versions. In the source code, the original signature is referenced which is why you observe this mismatch.\nIf you want to make extensive use of ASM, consider using the byte-buddy-dep package.. I assume that your log method should be declared public. Also, register an AgentBuilder.Listener for getting hold of the events occuring.. Have a look at the Transformer API. Alternatively, you can fallback to the underlying ASM API. Note that you can only change modifiers prior to loading a class.. Have a look at Transformer.ForMethod.withModifiers.. Yes, this is correct, unfortunately. I hope to improve this at some time. Consider using a method visitor for now.. They take the modifiers as an argument.\nYou can also supply SuperMethodCall.INSTANCE as an implementation.. If you are using the @SuperCall annotation, it retains the original arguments. Alteranatively, have a look at the @Morph annotation.. That is not really possible. The origin method is synthetic, i.e. it does not have a representation in the source code; there is no line number Byte Buddy can provide. Can you give an example of what you are trying to achieve?. The line number information can in theory be extracted using Java 9's stack walker API or by creating an exception and reading its stack trace. The information is contained in a class file and it is available using ASM but it is not exposed in the delegation API as there is no guarantee this information exists (either because it is not included or because you are creating a subclass).. Hi, with your linked approach you are creating a new class every time such a method is invoked. This is very expensive. You should of course cache the classes you are generating. Byte Buddy offers such a facility by the TypeCache class.\nInstead of delegating to an instance, you should rather delegate to a field and explicitly set the field value for every instance of this cached class.  You can initialize the field either by reflection or by implementing setters via some interface that you implement using FieldAccessor. . Looking up a constructor is a rather expensive operation. Better reuse the constructors that you retreive via getConstructor. To avoid the reflective call, you can also implement a factory, e.g. by some interface\njava\ninterface MyFactory {\n  RequestSpecificationDecorated make(RequestSpecificationImpl rsi); \n}\nAfter creating the classes, you can implement the interface as a factory using MethodCall and avoid reflection alltogether.. You can create a type-safe factory like the following:\njava\nMyFactory factory = new ByteBuddy()\n  .subclass(MyFactory.class)\n  .method(isDeclaredBy(MyFactory.class))\n  .intercept(MethodCall\n      .construct(requestSpecificationDecoratedClass.getConstructor(RequestSpecificationImpl.class))\n      .withArgument(0))\n  .make()\n  .load(requestSpecificationDecoratedClass.getClassLoader())\n  .newInstance();\nGiven this instance, you can avoid reflection alltogehter. Judging from your code, I doubt that Byte Buddy is the issue here. I assume that it has something to do with the logic you implement in ResponseSpecificationDecorated::core. Try stripping your interceptor to a no-op and see if you still observe the issues. Alternatively, maybe you are creating too many objects using this approach and put too much preasure on garbage collection.. Yes, have a look at the AgentBuilder API which can be used to instrument classes. You can specify this behavior by:\njava\nnew AgentBuilder.Default()\n  .type(named(\"InjectCow\"))\n  .transform((builder, type, cl, module) -> builder.method(named(\"noise\")).intercept( ... ))\n  .installOn(instrumentation);\nThe above code would create an agent that intercepts your method. Have a look at the MethodDelegation API to do so. Alternatively, you can also look into the Advice instrumentation.. Byte Buddy uses compiled code to implement a method. Maybe you want to use templates? In this case, have a look at the Advice class where you would implement your code. Simply provide a static method annotated with OnMethodExit to implement your logic. Otherwise, you can use simple delegation using a MethodDelegation.\nThe tutorial is a good point to start.. By specifying delegation by .to(i), Byte Buddy needs to compute a determinate field name as you do not provide one. The name is derived from the hash value of the delegate. As you use different configuration, Byte Buddy does not treat the delegators as equal while the value is. Provide an explicit field name or use a toField delegation whilst providing the value manually to avoid this. Look at the overloaded delegation types provided by MethodDelegation.. You can implement any matcher yourself by implementing the ElementMatcher interface. You can also compose any number of matchers by the or and and methods. You can for example match types by their name and then chain them using or: named(\"foo.Bar\").or(named(\"qux.Baz\")).. Seems like a bug.\nJust FYI, with Java 9, instrumenting lambda expressions will most likely no longer work as the mechanism gets restricted.. Seems like this is related to a lambda expression that references a constructor as a method reference such as Collectors.toList(). Should be an easy fix.. Fixed on master.. The types are not resolved by Byte Buddy but by the reflection API upon calling any of the getDeclared[Methods|Fields] methods which resolves all signature types eagerly. Optional types are no native concept that the JVM allows and therefore, the error is thrown.\nThe only way to avoid this would be to use a publicly known type (worst case Object) in the signature and to cast the type within the method.. The call is part of creating the Advice class. The initialization is not cheap, therefore, the resolution is done eagerly to create an immutable Advice object. I think that you are currently caching these instances what makes sense for performance but triggers these errors.\nMaybe you can just catch the error and handle this as an indicator for the missing class?. The problem is that Byte Buddy does not have a mechanism to check if signature types exist. The only way to retreive the information (for loaded types) is to use the reflection API which does not give you a \"soft access\" to check if types can actually be loaded. Byte Buddy cannot do much more than to crash and burn. Therefore, the types in question need to be named explicitly and seperatly from the method signature. This is unfortunate but there is no good way around it.. How does your setup look like? This is too little information to help you. The agent does work, the documentation is unit tested.. There are a few things wrong with your example. First of all, to activate a Java agent, you need to set the Premain-Class attribute. Also, there is no *Timed class in your example from what I can tell. You do not need a main method in your agent unless it is both the agent and the run application.. A Java agent is loaded on the Java class path where only classes added to it and included by your agent are available. If you did not add the Filter class, this exception is to be expected.\nIf you are using a MethodDelegation, you need to make sure that all types are compatible what is difficult in an OSGi environment where you would need to make sure to resolve the exact class for the Filter in the delegation target. This would be achieved most easily by injecting or adding the delegation class into the OSGi module. Therefore, I guess that using the Advice class is your best approach where the code is inlined into the target class and this is not an issue.\nHowever, Byte Buddy needs to resolve the Filter class for applying the instrumentation where it needs to look up the filter class from the target class loader. You can use AgentBuilder.Transformation.ForAdvice to do so where Byte Buddy uses both your agents class loader and the intrumented class's class loader to resolve types such that the Filter can be found. Use the named transformer instead of referencing the loaded advice class with Advice.to( ... ).. I assume, the Filter class is probably defined by an OSGi bundle in its own class loader and is therefore not compatible accros modules.\nAs for the circularity, this is something you have to take care of yourself. Byte Buddy basically copy-pastes the code for you. One way to handle this would be to create a flag property that you set before you call a method and check this flag from the called code to avoid the circular segment.. This might be a result of not using AgentBuilder.Transformer.ForAdvice if you use loaded advice classes where your Java agent is loaded with a different class loader.\nWhat does your complete stack trace look like?. What you are experiencing is definetly an issue of class loaders. I do not understand why you require the Filter class in your agent, it should be obsolete when using the Advice class.\nHave you tried to use string constants instead of JettyHandlerAdvice.class.getClassLoader()? Maybe you are triggering class loading. Do you have a stack trace of the NoClassDefFoundError?. Implemented.. Hi, thanks for reporting this. Adding this flag was discussed on the mailing list but was discarded as a bad idea for Java 9 to be set to true by default. I expect this flag to not be set in future releases.\nThen again, this hack is not too bad to offer as an attempt to make the installation process work out of the box. For many users, this might just work at least for test environments where this is intended. I do however consider to just start a new VM process to attach the agent from there. Its a bit of a dirty hack but the whole self-attachment is a bit tricky to begin with, despite its usefulness.. I will check the source to see if there is a way around, therefore I but I think that I will go for the \"secondary VM hack\" without relying on Unsafe to ease the migration for test frameworks that rely on this feature. Long term, people will probably need to set the flag but there needs to be a short-time solution that is less disruptive.. ByteBuddyAgent.install() does now detect Java 9 VMs where self-attachment is forbidden and creates a helper process to attach from there. This was already added to master and will be included in the next release.. Hello,\ngenerally, Byte Buddy can do anything that ASM can as it supports the use of visitor wrappers (ASMVisitorWrapper). If you transform a class, you can also register a Transformer to change modifiers of classes, methods or fields. The removal of modifiers alone without changing a method implementation is however a bit of a blind spot that should be easier.\nAdding a constructor is not difficult. You can use ByteBuddy().redefine(...).defineConstructor(...) to do so.\nClearing an initializers buddy on the other side is not really supported as Byte Buddy makes sure that all changes are additive. Instead, you can however create another AsmVisitorWrapper to simply clear the initializer manually.\nReplacing a method's entire implementation with a call to a mock repository is easy by using the dynamic type builder API. Using rebase, Byte Buddy automatically retains the original implementation and makes it accessible, too. It is however more difficult to replace calls to methods and field access within a method body which is currently only possible by using ASM. I really want to add this functionality and track it by https://github.com/raphw/byte-buddy/issues/187 - currently I do have my hands full with supporting modules.\nSummarizing, Byte Buddy is not yet too powerful when it comes to changing the insides of a method but rather offers ASM to change those parts. This is however a part I prioritize and especially the later mentioned component could really improve this in the future. Also, I need to look into adding an out of the box AsmVisitorWrapper for changing modifiers, I will look into this, too and created this ticket: https://github.com/raphw/byte-buddy/issues/299. Quick update, I see this lack in functionality and just added means to remove members (such as the static initializer) and to easily change modifiers of all members.\nI have also started working on a component that can replace any access to a member with access to another member. This latter component will take a few days or weeks but it will be ready some time in the near future.. How does the call to your MockRepository normally look like? How did you retain the original arguments or did you discard them?. No, this is not possible with Byte Buddy. You can invoke a method of the super class if it is not yet added by creating an instance of MethodDescription.Latent. You would however need to remember that you invoke this method on the super class and add the constructor to the super class once you transform it. Alternatively, you could assume that this constructor exists for any relevant class and also always add it to them.. The @StubValue annotation value can be used for example to override a return value. For primitive values, like int, it is not legal to assign null but only 0. By using this value, a null pointer exception is avoided.\nThe @Unused value can be used to annotate a parameter that is not required for an advice method but which cannot be removed to retain binary compatibility of a program.. You are right, this is a bug. A merge of RIGHT with UNKNOWN should yield RIGHT. I will fix this in the upcoming release.. Fixed on master.. Added on master.. Did you look at the isConstructor() matcher for doing this? I will look into improving this!. I decided to slightly refine the API. The naming method is not really intuitive when working with Java and not thinking of constructors as methods.. What do you mean by the latter? The component is chainable and you can set all three properties to change the modifiers of all components by chaining them together.\nI did all other changes but I am still need to extend the API of the MemberSubstitution to allow replacing method calls with method consuming different arguments. I am still uncertain if I should go for an explicit API such as .replaceBy(method).replacedMethod().allArgumentsAsArray().this() or a target-site API where all parameters are annotated to indicate their value. Any thoughts?. No, Byte Buddy automatically merges the modifiers. Only the spectrum of the specified modifier will be changed. To remove final field modifiers, you would:\njava\nnew ModifierAdjustment().withFieldModifiers(isFinal(), FieldManifestation.PLAIN). That is actually a bug in Byte Buddy where the transient modifier is wrongfully added to the final/volatile family. Normally, a ModifierContributor should describe what modifiers it conflicts with (a final volatile field is for example forbidden).\nI will fix this, of course! Thanks for reporting.. I will push it onto master tonight. I will release a new version once I implemented the mentioned support for MemberSubstitution.. Byte Buddy handles generic types and bridge methods transparently. If you create a generic class as described in this example, any overridden generic method is automatically promoted to its new erasure with the required bridge methods being added. Byte Buddy also handles raw types correctly if you subclass a generic class without specifying generic parameters.. Thanks, I already fixed it. Will be part of the next release.. I just tried and my example terminates without a stack overflow. Maybe it has to do with UsageInterceptor.registerType(typeDescription, methodFilter) which I do not understand what does.\nAs for a reproduction, this would help a lot. Have a look at the byte-buddy-agent project where you can invoke ByteBuddyAgent.install() to get hold of an instance of Instrumentation. Use it to install your agent and call your instrumented code afterwards.. The first problem is caused by a missing validation in Byte Buddy. It is not allowed to define a non-final field in an interface what is necessary to implement your way of interception for the Component type. With Java 8, it is possible to intercept default methods which is why this is possible. I did now add the validation. You can avoid the problem by setting type(not(isInterface())) as a matcher.\nThe stack overflow error comes from your too lax method matcher. You probably want to match .method(isDeclaredBy(typeDescription).and(methodFilter)). Otherwise, you also override methods of super types. This results in an endless loop as you override the innerView method to call itself.. I double-checked and found out what happened. The problem is the fragility of the base class. For your given setup, if you overridde the createView method in Inner, javac will create a bridge for the generic return type where the actual method returns View and the bridge Component, casting the result.  The bridge call is done virtually.\nIf you now override the Outer class to also overridde createView, the super method call will change from invoking the method returning Component to the method returning View to avoid the recursion. However, if you change the Outer class first and later change the Inner class, with javac, you suffer the same problem. It is a form of fragile base class problem. \nByte Buddy struggles with the same challange as it does not know that Inner is changed while instrumenting Outer. Inner is only loaded after Outer which makes this change unclear.\nThe solution is to not add methods that imply bridges. Thus, limiting instrumentation to already declared methods by excluding any methods that are not declared by the instrumented type as I suggested.. Thanks, will fix in the next release!. Fixed on master.. The lambda factory does not currently check for the return type of the lambda but of the invoked method when rendering the return opcode. This is an easy fix, thanks for reporting!. Fixed on master.. Fixed on master.. This is not possible by simple assignment. Instead, you need to use the @Morph annotation instead of @SuperCall where you can explictly supply the arguments. In this case, changing the array value and then supplying the array to @Morph would work. Note that you need to explicitly install the Morph.Binder for the annotation to be available.\nAlternatively, have a look at the Advice class where this is even easier as the code gets inlined where a simple assignment is sufficient.. You need to set something like MethodDelegation.withCustomConfiguration().with(Morph.Binder.install(YourType.class)).. Constructors in Java are a bit particular, they must hard-code an invocation of another constructor inside of the method which makes it obligatory to use SuperMethodCall either before or after the delegation. If you use the delegation before the call, you cannot access the this instance which is considered uninitialized at that point what leads to the above exception.. The easiest way would probably be using Advice where the code gets inlined around the original call.. You imported the wrong namespace, the JDK bundles ASM itself as an internal API.. You can use the isAnnotatedBy matcher. If you want to check all classes down the hierarchy, you can nest a hasSuperType and the previous matcher. You can implement any matcher by yourself, too. If the type is not available, it will still be available as an AnnotationDescription.. Thanks for reporting and tracking this down. We need to add a check to Mockito for package-private classes to not allow creating mocks if there is a different context class loader than class loader.\nAs a matter of fact, I would like to remove the context class loader alltogether from the resolution, but this breaks stuff for some Eclipse/OSGi enviornments where a class class loader implicitly relies on the context class loader.\nAs for more diagnostics; this is difficult to realize as the class loading API provides close to zero feedback on why a resolution fails. I will look into improving this.. Byte Buddy chains the exception, it should be visible from the stack. Did your tooling cut of the stack because it was too long?. I felt ovr this myself. If I remember correctly, there is aproperty to control this. Fixed the errors!. Great, thanks!. Have you tried using Advice rather than a MethodDelegation? Tomcat is sometimes difficult with respect to class loaders.. Glad you figured it out!. FYI: https://stackoverflow.com/questions/2928548/make-mavens-surefire-show-stacktrace-in-console. Glad you like the library.\nI just updated the plugin. Could you do me a favour and clone the repository, build Byte Buddy and try the snapshot version against your project. Otherwise, I will do it myself but would first need to create a project to do so what can take a few days until I find the time.. I can make it configurable and issue a warning by default unless  non-existing folders are explicitly disabled. Thanks for the feedback!. I reworked the plugin. Can you try again?. Fixed on master, will be part of the next release.. It would be but this sort of functionality is not trivial to implement. There is no better way of creating custom byte code than ASM for those who need it. I do not plan to implement a feature like you suggest in the near future.\nThat said, by working with StackManipulations and ByteCodeAppenders you can already encapsulate blocks of code. Would this be a way to go?. Yes, but it requires you to implement a custom ByteCodeAppender.. You would need to implement a custom Binder and register it with the interceptor. You can chain together a constructor call to create a map, then you would iterate over the fields, read the values and names and put those into the map.. I added a BindingResolver abstraction that allows you to customize the binding behavior or to listen/assert an applied binding (by delegation and postprocessing the result). Its added to head and will be part of the next release.. Yes, this is a shortcut for defining an interceptor for all methods that are declared by this interface (but not already overridden by the subclass if any).. Hei,\nthe problem is that Byte Buddy can only define a field and place a value inside of it after a type is loaded. Using reflection, it is in theory possible to change the value of a final field but future versions of Java are unlikely to support this, therefore the field is not final. At the same time, all fields of an interface must be final, what raises this conflict that is detected by the type validator.\nWhat you could do would be to use FieldAccessor to read a value from a field that you define yourself. You can define a static initializer (by intercepting isTypeInitializer) using Advice where you can assign the field in Java code. Byte Buddy then inlines this Java code into your classes static initializer, thus creating a valid Java class.. What you would need to do would be something like:\n```java\nbuilder = builder.method(isTypeInitializer()).intercept(Advice.of(MyAdvice.class))\nclass MyAdvice {\n  static void advice(@Advice.FieldValue(value = \"foo\", readOnly = false) List field) {\n    field = Arrays.asList(\"a\", \"b\");\n  }\n}\n```\nThe only requirement is really that the field must be a constant; therefore, it must be initialized from within the interface type.. Does this happen with PowerMock? Maybe its an error in their code. Can you create a reproduction of this issue?. I am closing the issue. If you can provide more information, I am happy to open it again.. I assume PowerMock disabled validation and then duplicate method declarations triggered the error. . You are right, I did not properly set the field. The few times I do not write a test, I get it wrong, sorry for that.. Fixed on master.. I decided to not extend the latent type description which was not really intended for such use. Rather construct an InstrumentedType which is itself a TypeDescription and offers a convenient builder API for describing any type.. Implemented on master.. Have a look at ElementMatchrs::hasSuperType.. hasSuperType(declaresMethod(whereAny(declaresAnnotation(...)))). Itsa rather expensive matching, though. Ideally, prepend a cheaper criteria like a name suffix.. For example: nameStartsWith(\"foo.\").and(...). Seems like you imported the wrong annotation. The Advice class offers a similar mechanism for delegation but with code inlining. Those annotations are not understood by the delegation mechanism.\nAs a result, your interceptor method cannot be mapped and the toString method is choosen instead. This only works as all your methods return a string.\nIf your interceptor is stateless, I recommend you using a static method with class delegation. If you only want to prepend code, chain the delegation with a super method call using andThen. This way, your delegator can return void without runtime type adoption.. I am closing this issue, please reopen it if you have further questions.. As Fabian states, what you are trying to do is not allowed by the VM. There is no way to reference this at the method entry.. This is the way to go.. You are right, I fixed this. Thanks for reporting!. The + sign in the generic signature is not supposed to be there. Can you see it in the original class file with javap?\nIt breaks the offset contract such that the type is redolved incorrectly (the first character id stripped which should be the L).. Then its correctly formed, you could use the ASMifier in the ASM util package to assure its string representation.\nMaybe AspectJ alters it?. It looks very similar. It might be that AspectJ adds invalid meta information (generics) for such methods. This might never be discovered unless AspectJ itself or another tool performs another instrumentation where this information is required.\nThe JVM itself ignores generic information in its runtime and only evaluates it lazily if it is required.\nIf the error would be in Byte Buddy, I would need a reconstruction, generics are tricky. But they are also really tested to the bone to avoid such confusions. I am pretty confident that Byte Buddy treates generics right.. You could make sure that the Byte Buddy transformation is applied first.\nIt is difficult to impossible to implement a fuzzy parser that strips invalid characters. If you still wanted to go for this approach, you could add your own transformer (e.g. using ASM) that fixes the broken signature.. Great you solved it and thanks for reporting back.. Good idea, I already added the property.. Released as 1.7.2.. Wow, this is great, thanks for your efforts. I will of course add a link, give me a few days!. I added links to the readme and webpage, thanks again!. I updated the link, thanks!. I am not sure what you mean by that. Could you explain this with an example?. You are right, I fixed this on master.. As explained in the Mocktio issue, this cannot be done.. When I run this as a Java test from my IDE, I do not get any error and the transformation is applied as expected. Is the Model class compiled by javac?\nCould you set net.bytebuddy.dump=/some/folder property during your build? This should dump the transformed class file. The only explanation I have is that Groovy does some other stuff to the interface. Also, maybe it helps to make your matcher mor specific like by named(\"isDeletable\").. I am closing this question. Feel free to reopen it if you need further information.. When you use FixedValue.value(new ReturnType()), Byte Buddy has to add a field to store this value in the transformed class. The problem is that an interface cannot contain such a field which must be non-final as Byte Buddy needs to assign after the class loading.\nIf you really want to do return the value, you could use a MethodDelegation to a static method that returns this instance somehow. This way, the reference is fetched from somewhere else without the interface requiring the addition of a non-final field.. A StackManipulation does not track the size of the local variable array. If you want to assign such values, you have to increase the value manually via the ByteCodeAppender. By default, Byte Buddy only reserves space for the variables implicit to a method.\nWriting byte code manually gives you a lot of freedom but you get to be in charge of the bookkeeping, too.. You are welcome!. Implemented.. I had to do the change mostly to increase the flexibility and a bit for performance purposes. They were a redundant specialization of the already existing general API and it should be rather easy to express the one as the other. Sorry for the work that imposes on you. Using the old API, it was for example impossible to bind a writable value. Also, a lot of redundant work was repeated for any application.\nFor loading a constant value using the more general API,  you do:\njava\nOffsetMapping.Target.ForStackManipulation.of( <constant value> )\nYou can create this value from a OffsetMapping.Factory that provides you with the annotation. You should do all possible heavy work from within the factory as it is reused for any advice application.. You are missing one step:\njava\npublic static class ParameterNamesDynamicValue \n      implements Advice.OffsetMapping.Factory<ParameterNames> {\n   @Override\n   public Class<ParameterNames> getAnnotationType() {\n     return ParameterNames.class;\n   }\n   @Override\n   public Advice.OffsetMapping make(ParameterDescription.InDefinedShape target,\n                                    AnnotationDescription.Loadable<ParameterNames> annotation,\n                                    AdviceType adviceType) {\n   final StringBuilder params = new StringBuilder();\n    for (ParameterDescription param : target.getDeclaringMethod().getParameters()) {\n      params.append(param.getName()).append(',');\n    }\n    return new Advice.OffsetMapping() {\n      @Override\n      public Advice.OffsetMapping.Target resolve(TypeDescription instrumentedType,\n                            MethodDescription instrumentedMethod,\n                            Assigner assigner,\n                            Context context) {\n        return Advice.OffsetMapping.Target.ForStackManipulation.of(params.toString());\n      }\n    };  \n  }\n}\nThe idea is the following:\n1.  The OffsetMapping.Factory lives for itself and can be registered in different Advice classes.\n2. The Advice classes use this factory to create an OffsetMapping once the factory is supplied for a given advice class.\n3. For every time a type is instrumented, the OffsetMapping resolves a Target for this particular target type.\nI am therefore wondering if you want to get the names of the instrumentedMethod rather than those of the method that is the advice class.\n(With the old mechanism, step 2 and 3 were a single step which caused unneccessary work for advice classes that were applied to a lot of types but could do most work at step 2 what was the rationale for this change as this resultet in a serious performance degregation with custom bindings that the native ones did not suffer. Therefore, I unified the mechanism to this superior approach.). Yes, you are correct with your summary: the factory is supplied with information regarding the advice method (the parameter that is annotated), the offset mapping is supplied with the instrumented method and the resulting target is used as a dispatcher whereever the instrumented method refers to the annotated value.\nThe error hints that javac has not invoked the correct overloaded method. You do not need the dynamicValue.gerAnnotationType part as the annotation is already supplied. You only need to supply the annotation if you are binding an OffsetMapping directly where Byte Buddy creates the factory for you. This might be sufficient for your use case as you are not doing any precomputation on the factory level?\nYou can do:\nwithCustomMapping.bind(dynamicValue.getAnnotationType(), offsetMapping);\nor\nwithCustomMapping.bind(offsetMappingFactory);\nFor your case, Byte Buddy resolves to the best match which is attempting to bind the provided value as a constant (string, serializable or number) what is impossible.. You are right, this should actually be simply be bind(OffsetMapping.Factory<? extends Annotation> offsetMapping) as the specific annotation type is entirely irrelevant for the signature.\nFeel free to include this in your PR or I will fix it myself some time soon. You can cast to a raw factory in the mean time if you want to get past this.. I will release a new version some time this week. Its JavaZone so I am a bit busy but first thing I find a few minutes. I hope this resolves all of your problems? Please reopen this, if not.. You can register a listener to get notified on instrumentation events, including errors.\nFrom the top of my head, matching any method includes abstract methods without a super method available such that Byte Buddy rejects the instrumentation attempt.. Yes, of course. Ideally, you add a test.. Its easiest if you know how ;) There are a lot of them in AdviceTest, I just added one.. I had a lot of trouble with Travis lately. It is mostly due to their distribution change for the build environment and I assume this is releated. I will have a look!. Have a look at the Advice class which allows you to inline code. The advice to apply would look like:\njava\nclass MyAdvice {\n  @OnMethodExit\n  static void exit(@Advice.Argument(0) File file, @Advice.Argument(1) boolean append) {\n    if (file.getPath().contains(\"abc.txt\")) {\n      DataStore.store(this);\n    }\n  }\n}\nIn order to make this work, the DataStore class needs to be injected into the class path.. I think that is a problem with Byte Buddy validating the constructor incorrectly where the frame is not existant before involking the super constructor. I will have a look, thanks for reporting!. I found the issue and already fixed it on master. I will do a release this weekend. Thanks for reporting!. I wonder how they got this to happen, javac would not create such code. \nYou can (and should) turn validation of in production systems. You can do so by: new ByteBuddy().with(TypeValidation.DISABLED).. Yes.. You are right, I have fixed this on master and will include the fix in the next release. Thanks for reporting!. I would rather not release this validation step but would recommend people to turn off validation as outlined in the related issue. Would disabling validation solve your problem?. Closed, already fixed.. Thanks, I will look into how to make this information available somewhere.. With my model of many nested classes, I found that this metric is rather an approximation. Thanks for sharing it anyways, it motivated me to a journey through my code's history!. Byte Buddy complains that the type is not visible to the proxy class and it probably is not. I will have another look at this but Spock should probably not run the validation in the first place to work around this issue.. If you find the time I will happily take it!. Its on my agenda and I hope to find some time next week!. This seems like a bug in Kotlin. Its compiler creates a synthetic constructor:\npublic synthetic (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;\nThe DefaultConstructorMarker type is package-private and therefore not visible to SomeClass$SpockMock. According to the spec, this is not legal as you must not refer to classes that are not visible to a class but the JVM is sometimes more forgiving like in this case.\nThe javac compiler does a similar thing but creates an anonymous type in the same package of the class it creates. The Kotlin compiler should do the same thing or make the default marker type public (whilst it could still retain the class's constructor public.). Tracked in Kotlin and can be avoided by not validating.. I will wait a bit until there is a bit more know about the version number handling. It will become a bit of a pain in the ass to handle non-numeric versions in this API but I will figure something out.\nThanks for reminding me!. This looks like the previously generated byte code is a bit messy as this is an exception thrown druing reading the class by ASM. If you can, could you create a reproduction and submit it to the ASM issue tracker? They can probably fix that!. It can normally but by disableClassFormatChanges you explicitly forbid it.\nSince you are using this option and Advice, I assume that you are redefining classes that are already loaded? In this case, you cannot add fields as the JVM explicitly forbids it.\nFeel free to reopen the question if you have further things to ask about!. I assume that an error occurs somewhere. Have you registered an AgentBuilder.Listener to keep track of errors?. Yes, this might be an issue . If you load a type during a transformation, the type is not instrumented as it is already loaded. If you cannot see the type being logged at all, this is probably the case. What you can do would be to only reference a type within the method body which is loaded lazily. You can then use a generic type such as Object in combination with @DynamicType.. Well, of course it does work in general and this is tested on many occasions. I would need a more detailed example or even reproduction to look into this. Could you provide such a reprodction? In this case, I am happy to have a look!. This would only be relevant for a return type and when using MethodDelegation, therefore, never mind the dynamic type.\nBy the way, you can also use a TypePool to describe the class and represent it as a TypeDescription where the method signature types are not loaded and this problem does not occur. But this is probably a lot of unneccessary work and if the current solution works for you without too many troubles, this is what you should go for.. It is possible but a bit tricky, there is not yet a good API for such transformations. The problem is that Byte Buddy cannot generally know if a value is represented as a default value or if it is explicitly defined but to this default value. It sounds irrellevant but as a matter of fact, it does matter for (too manny) applications.\nI hopefully can add better support for this in the future. For now, using ASM is the easiest way of getting this done.. Not yet, unfortunately. I use this issue to track the progress. With modules and the sun.misc.Unsafe cleanup, I did not had much time for features recently.. As mentioned, it is not currently possible to remove the existing annotation. This is not currently solved fully satisfactory in Byte Buddy such that you have to reapply all annotations what means filtering out the first annotation using an AsmClassVisitorWrapper where the second one is picked up correctly.. Basically, you need to implement a MethodVisitor that returns null on any annotation you want to remove. You can register such a visitor using a custom instance of AsmVisitorWrapper.. Thanks for the hint, I fixed this on master just now.. This should work already? You can simply rebase native methods where the original methods are renamed. You can then use Instrumentation to define a native method prefix.\nMaybe you meant to work this in another way? Can you show me the code you wrote such that I can get a direction?. When using the Advice component as a visitor, it applies inlining into the existing method what is impossible for native methods as those methods do not define any byte code.\nIn order to rebase a method, you have to implement it where Byte Buddy moves the native method to a new signature. This is done using the .method(...).intercept(...) API. Using the Advice as visitor guarantees that the class file format is not altered making it suitable for redefining agents.\nAlternatively, you can redefine the call sites of such methods. For this, I plan to extend the MemberSubstitution component for what I did not have the time yet.. About the auxiliary classes. Byte Buddy typically injects the auxiliary classes before the instrumented type to avoid exactly this. Byte Buddy offers an Injector to push a class file into some class loader. I assume that you have to do something in this direction, too? The classes have to be visible to the class loader to have them available when the instrumented type requires them. Optionally, have a look at Advice which works similar to method delegation but works by copying byte code what typically makes auxiliary classes obsolete.. Yes, Byte Buddy injects the auxiliary classes first such that they are available once the actual class is loaded. The best order does however depend a bit on the type of reference you can find in a class - if class A references B in a field or method signature, then B should be loaded first. The classes in byte code are typically loaded lazily.\nJust hit me up if you have further questions.. I could write a book on the details but in general the performance cost is aligned to that of the Java reflection API. If you ask for a property that is resolved by the execution engine or the verifier, this property is available anyways. This is for example the type name or a type's raw type. If you request generics or annotations this is meta data that is resolved lazy and especially before Java 8, those operations are costy.\nAlso, when using the TypePool.Default implementation (when instrumenting non-loaded types), this pool is by default wrapped with a projection that resolves the name before parsing any class file if this suffices. Therefore, if you can exclude a lot of classes by a (sub)property based only on a type's name, this is of course a big optimization as Byte Buddy does not need to parse any class files or even do I/O to resolve linked class files.. I will consider that and surely do if I find the time. The problem is that the costs depend on a particular implementation of TypeDescription where a user can in theory implement custom classes. Therefore, the matcher is not really aware of the factual performance implications.. Inner classes are just synthetic sugar for a class that takes its outer class as an implicit constructor parameter to make the instance available. You can also see that in the javap output.. That is so cool, thank you!. I have already answered you on StackOverflow: https://stackoverflow.com/questions/47017235/cans-defined-new-field-to-loading-class/47042478#47042478. You could for example write a matcher that uses a ClassFileLocator.ForClassLoader for looking up the existance of a class file. If you are certain that you would never instrument the class in question, you can also use Class.forName to look it up. In any case, you should implement some caching logic to remember a prior lookup if the matcher's first conditions are not too fine-grained (e.g. mention a particular class).\nOther than that, Byte Buddy has no special powers to know if a class exists or not before it is loaded. It only offers some mechanisms to interact with class files.. No, Byte Buddy does not care about modifications, only the VM. It limits your options, though, what makes redefinition sometimes unattractive (for example, you cannot override a method from a super type).\nGenerally, it is often beneficial to drop the ability to change the layout as you can for example use a less intrusive method graph compiler.. An AgentBuilder can operate on loaded classes by using aRetransformationStrategy. You can use a RawMatcher to detect if you are matching a loaded class or not.\nOnce a class is defined for the first time most JVMs - including HotSpot - do not allow changing the structure of a class. By enabling the above option, you are making sure that Byte Buddy detects any such change if you define it by accident and throws an exception, thus aborting the transformation process.\nBy default, Byte Buddy resolves the entire graph of virtual methods for any type. To do so, it needs to navigate the entire type hierarchy what can be costly. If this is not necessary, you should configure the ByteBuddy instance used by your AgentBuilder to use a less intrusive compilation strategy, typically: http://bytebuddy.net/javadoc/1.7.8/net/bytebuddy/dynamic/scaffold/MethodGraph.Compiler.ForDeclaredMethods.html . Yes, in order to resolve all methods, Byte Buddy has to get hold of Method objects when operating on a loaded type what is rather expensive as it involves security checks and other overhead. Also, the algorithm to resolve methods down a hierarchy (including several type of bridges and visibilities) is quite expensive in itself. If you can avoid it, it is a win.. Closing, please reopen if this is still relevant.. Yes, when using a TypePool.Default, Byte Buddy parses class files instead of relying on reflection where those annotations are available.. Thank you for the information, I will try to update some time soon.  It is too bad that this API breaks all of the time.... It does not seem like there are any newer versions out on Maven Central. How did you encounter a newer version in the first place? Did you update it manually?. I will have a look but typically, this should not be an issue when running\non Android where this bundle is not available.\nIts an issue for me to not have these things available on Maven Central as\nit breaks my usage of CI.\n2017-11-27 15:26 GMT+01:00 Maarten Billemont notifications@github.com:\n\nPretty sure I just got it off Android's SDK manager.\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub\nhttps://github.com/raphw/byte-buddy/issues/366#issuecomment-347196707,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AESAcBx69dWktVPh0qrWkYQWoqgw5JSwks5s6saIgaJpZM4QNPtE\n.\n. I like both suggestions: feel free to come with a PR and I will surely merge it. However, for the logging API you would need to define some minimal interface that both the Gradle and the Maven plugin can implement. I do not want any Maven types in the main artifact.\n\nAlso, if you extend the Maven plugins API, the same must be done for the Gradle plugin.. The type pool: yes, the log interface: no. I suggest that instead, the plugin can define a single argument constructor that accepts the Maven / Gradle logger. What do you think?. I am not a big fan of such context objects. Also, I assume that there will not be many build-tool specific additions in the future. In this case, the context would only ever resolve this single loader type what makes it awkward. Also, there is a chance that two objects of the same type need to be resolvable in what case the API is not sufficient.\nAfter considering this, I also doubt that passing a build-tool dependent logger instance is a good choice as this makes plugins build-tool dependent without any need. I suggest adding a simple interface BuildLogger which is provided as an argument and which can be null.. Ref https://github.com/raphw/byte-buddy/issues/533. I answered your comment on StackOverflow.. Thanks, good catch!. Fixed on master and made more robust for future version increments. Will be fixed with the next release.. Bugfix is released.. You can use the suppress property for this in both the enter and exit advice. By default, the suppression happens silently but you can also register a handler in the Advice class.. Yes, it does. The handler is only invoked if the suppression mechanism kicks in. As said, by default the exception is silently dropped but you can trigger any byte code to process the exception as for example logging it to some API.\nThe suppression only catches exceptions in advice code and leaves the user code untouched.. Hi, examples are more then welcome. If you wanted to extend the tutorial to include a section on Android, this is very welcome!. You probably missed the dexmaker dependency.. It seems like it is not possible to read the class file for org.ofbiz.service.engine.GroovyBaseScript. Byte Buddy is asked to instrument all classes that have a certain super type and for this purpose, it needs to read all class files that are involved in a class's hierarchy.\nWith the mentioned class, in order to apply the check, it is necessary to parse its class file to find the class's super types. Without that information, Byte Buddy cannot check what super types the class has and answer the matching request.\nTo resolve this, you can either check how to better extract class files from specific types of class loaders (by default, the class loader is queried using getResourceAsStream) or you can handle the error by adding another matcher that excludes the type explicitly or by some other criteria. You can also wrap the matcher to suppress the exception.. The easiest way is to use ElementMatchers.failSafe(...) but this swallows the exception. Maybe you want to log the error and then you would need to implement something similar yourself.. I also think that is the best solution for something that custom.. It is expected to not work for a JRE as the required libraries are missing. It is supposed to work for a JDK. What operating system are you using?. If it was possible to include the attachment module in a JRE, this would be possible but I have never tried that.\nCould you help me debug this by checking what arguments are provided here: https://github.com/raphw/byte-buddy/blob/master/byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java#L423\nCould you then try to run https://github.com/raphw/byte-buddy/blob/master/byte-buddy-agent/src/main/java/net/bytebuddy/agent/Attacher.java with these arguments? I assume an exception is thrown, maybe some folder with spaces that is not escaped correctly.. The result is communicated using a status code what is the easiest. Status code 1 means: the self attachment failed.. This is unfortunately difficult to implement as Byte Buddy should not print to standard output, this can cause quite some trouble in managed environments. But I agree that it is difficult to debug. \nThe argument check is guarded against a missing argument as Windows translates the missing argument to \"null\" whereas on Linux, it is translated to an empty string. The check is however overly careful (off by one error). This should however not cause an error.. Of course, too late at night. I have fixed the off by one index check what should fix that by the next release. Could you build Byte Buddy and verify the fix, just to make sure it now works?. Unfortunately, the argument is already used by custom instrumentation. It could be done by an additional argument. In general, this does however add some overhead, I wil think about it.. Thanks for the hint, I really need to get onto this.\nIt seemed simple at first but as of now, Byte Buddy does not duplicate the exit advice code. To allow for this kind of rethrow, it is however not allowed to add any conditionals into the last return of the constructor in case an exception was catched what requires a larger rewrite of the advice component than what I hoped for.. I considered this, however, constructors can be arbitrarily complex. There is no good way to detect the super call without flow analysis. I am still trying out things which is why this has not made it into the library yet.. First of all: thanks for your work. I will make an attempt to get this running with CircleCI before considering Travis again. I am quite happy with CircleCI in terms of stability and Travis does not intend to support JDK6 and 7 with the recent distribution which is the reason for this change.\nIf I cannot get it working, I will create builds using 9 and 10 on Travis and definetly use your work. In any way, I will attempt to port your efforts to CircleCI.. Yes, you can use for example ClassInjector.UsingReflection to do that. If you target the bootrap loader, you must however use ClassInjector,UsingUnsafe.. By automatically you mean: Can Byte Buddy detect what classes to inject?\nIf this is your question the answer is no as Byte Buddy cannot know what classes to expect on the target class path before the instrumentation is complete at what point Byte Buddy has no longer a choice to make this decision. You have to name all classes you want to inject into a target class loader, ideally those are not too many.\nI would suggest you to do this as a seperate step of the instrumentation cycle: .type(...).transform(<inject>).transform(<redefine>).\nThis way you can assure that the types are available during instrumentation if you reference them in any signatures.. This seems to be a bug related to the IBM JDK which can even occure without byte code modification: https://www.ibm.com/developerworks/community/forums/html/topic?id=7f616d94-a4ec-4e32-9ccc-3406ee063a6f\nI would like to look further into it. Can you run your application with `-Dnet.bytebuddy.dump=/some/folder and attach the class file of the non-verified class? I assume that J9 does not accept the try-catch block in the entry of a constructor. This is nothing that javac allows but legitimate from the JVM specification. \nOne work around would be to move the code from the advice to another class, inject that class into the bootstrap class loader and invoke that method from the advice. This might avoid this error.. Yes, have a look at the TargetType class which is used as a placeholder for self-references.. In the onTransformation call, you receive an instance of DynamicType which has a reference to the byte code by getBytes. The onComplete method is also called for types that are ignored, therefore, the method does not carry a byte array.. If you rebase a class, this is necessary to retain the ability to invoke the original code within the constructor. Therefore, this is necessary. What is your use case and why do you want to prevent this?\nIf you do not instrument any constructor, Byte Buddy will not rebase these methods and not generate the synthetic type that is necessary.. Unfortunately, the creation of a constructor is necessary to retain the byte code's validity.\nHowever, Byte Buddy does mark the constructor as synthetic which you can check using reflection. I wonder if Spring is not considering a non-synthetic constructor for usage. Maybe the Spring project can consider such a use case? There are plenty compilers, including javac, that add synthetic constructors.. That Byte Buddy adds the second method is required by the JVM spec, the second method is a bridge for the first method and it is marked as such in the class file. You can check this property using the reflection API. If you create the same class using javac, you get the same method added.\nYou can however shut down this behavior by registering a different MethodGraph.Compiler. By default, the Java type system is used for determing hierarchies but you can choose to use the JVM type hierarchy which however makes your generated code difficult to use from other Java code.\nYou can register a custom compiler in any ByteBuddy instance.. The class is still part of Byte Buddy 1.7.9 so I do not know why you are getting this error. Can you check the jar file in: C:/Users/bb8d/.m2/repository/net/bytebuddy/byte-buddy-maven-plugin/1.7.9/byte-buddy-maven-plugin-1.7.9.jar to make sure it is not corrupted?. Glad this resolved itself. Probably a partial download where only parts of the jar were copied.. javac adds a synthetic parameter to the constructor for implementing the package-private visibility. I assume that this is not reflected in the annotation API while getParameterLength returns 2.\nWhat Java version are you using?\nI am sure Byte Buddy can work around this somehow.. Fixed on master.. Thanks, the meta data was not copied correctly. This will be fixed in the next version.. If you get hold of a MethodDescription, you can invoke getAnnotations and getReturnType as well as getParameters to get descriptions for these objects which define annotations by themselves.. Based on a TypeDescription? The API is fairly similar to the Java reflection API. . I am closing this question, please reopen it if you need further help.. You can define a type variable during the definition step:\njava\nnew ByteBuddy()\n  .makeInterface()\n  .defineMethod(\"m\", void.class, Visibility.PUBLIC)\n  .typeVariable(\"T\")\n  .withoutCode()\n  .make(). Yes, after defining the implementation, you are back on class level. If you define it before the code, it is a method-level variable.. You would most likely use a MethodDelegation: MethodDelegation.to(MyInterceptor.class)\njava\nclass MyInterceptor {\n  static void writeExternal(@Argument(0) ObjectOutput oo, @This YourBean self) {\n    out.writeUTF(self.id());\n  }\n  static void readExternal(@Argument(0) ObjectInput in, @This YourBean self, @FieldProxy(\"base\") YourProxy proxy) {\n    base.set(self.assertBase(in.readUTF()));\n  }\n}\nYou have to install an interface for your proxy yourself in the MethodDelegation.\nIf you want to avoid such proxies, have a look at Advice.\n  . If this is of importance, use the Advice adapter:\njava\npublic static final class SerializeAdvice {\n  @Advice.OnMethodEnter\n  public static void write(@Advice.This BaseInterface base, @Advice.Argument(0) ObjectOutput out) throws IOException {\n    out.writeUTF(base.id());\n  }\n}\nclass DeserializeAdvice {\n  @Advice.OnMethodEnter\n  static void intercept(@Advice.Field(value = \"name\", readOnly = false) FieldType field, @Advice.Argument(0) ObjectInput in) throws IOException, ClassNotFoundException { \n   field = baseSet(assertRawBase(in.readUTF());\n  }\nThis way, Byte Buddy inlines your byte code. You can access the advice using Advice.to(SomeAdvice.class).wrap(StubMethod.INSTANCE).\nI am still planing to expand the direct DSLs a but I cannot offer full access to any level of code complexity. At some point, the advice is a much easier, more reliable way of doing what you want.. Please do! Thanks for your feedback.. You can chain two method calls using the andThen method:\njava\nMethodCall.invoke(CheckUtils.class.getMethod(\"method1\")).andThen(MethodCall.invoke(...)). Yes, it is possible. What you need to do is that you define a dynamic method in some class and then you would need to link this call site to the LambdaMetafactory in the JVM. Byte Buddy has currenctly support for creating dynamic call sites via the InvokeDynamic class but it lacks support for binding these expressions to the named factory. I will definetly look into this and provide it as a feature in a future version.. I added a convenience method via InvokeDynamic.lambda.. Good catch, I will definetly fix that. I have not thought about the fact that the field name is part of the hash code function, it probably would be best to eagerly compute the name here.\nCould you change the method, build the project and see if it makes a real impact? Sometimes such measurements are biased by savepoints.. Fixed on master.. Once you turn on the option, Byte Buddy will transform all loaded classes and there is nothing you need to change. For most JVMs, you probably also want to turn on the .disableClassFormatChanges() option as this is a restrictions imposed by most VMs and also HotSpot.\nThis requires you to not change the class file, i.e. not to add fields or methods what is something that some instrumentations do. Generally, you want to use Advice for such agents and avoid MethodDelegation.. Advice has a quite extensive javadoc. Do you know Stagemonitor? They use this mechanism for APM. Here is the discussion with some code examples: https://github.com/raphw/byte-buddy/issues/110\nHope it helps!. Closing this for now, please reopen if this is still relevant.. Some people write to generic matchers and then intercept bootstrap loader classes by mistake. Therefore, you have to setup a specific ignore matcher that does not exclude the bootstrap loader if you want to make use of this possibility.. Closing for now, please reopen if this is still relevant.. As a matter of fact, I have been looking into removing hashCode/equals methods from most classes as this support is not really an essential issue for Byte Buddy and since it does increase the class file size quite a bit. That it complicates the build chain is another issue that would be resolved by this, the Java 9 incomaptibility is just one issue I have faced. Things are getting worse with Java 10 and I want to keep my build free from most dependencies in the future to being able to update quicker in the future.\nThat said, this is quite an intensive change requiring a major release (1.8) to avoid blowing off users too much. The class file reduction would however make Byte Buddy more attractive to containers and mobile devices so it is on the list.. Lombok is no longer used as of Byte Buddy 1.8.3 which now builds based on its own, previous version.. Do you bundle the agent together with Byte Buddy? You can use the Maven Shade plugin to achieve that, for example. It seems like the Byte Buddy library is missing.. Closing, please reopen if still relevant.. As you say, this will unfortunately not work out since AutoValue requires Java 8 and at this point, I need to support Java 6 and before. For Java 9 and 10, Byte Buddy works, only building it is problematic at this point while it is perfectly possible.\nI just updated Lombok. Does this help you out?. I am already using Spotbugs (see https://github.com/raphw/byte-buddy/blob/master/pom.xml#L194) which can process the findbugs annotations.. I keep the Findbugs dependency for building with Java 6 what Spotbugs does not support.. For me, it is still important to support older Java versions as Byte Buddy is a fairly wide-spread dependency and especially in the enterprise, a lot of people are stuck with older versions.\nI still hope to find a better solution for the Lombok parts, maybe by opening up for less strict rules for equality of objects, but for now, I think that there is no better way.\nHowever, I just updated Lombok to the latest release that claims to be fully Java 9 compatible and even builds on Java 9. I hope to release a new version next week. Could you check against the latest master to check if this works for you?\nAt some point, I will surely update to Java 1.8 but at this moment staying backwards compatible is a decision that I think is in the interest of the wider Java community while I fully understand your point of view.. You can do so easily by builder.executable(ElementMatchers.isTypeInitializer()).intercept(...).. Closing, please reopen if this is still relevant.. Any transformation returns a ResettableClassFileTransformer that offers an API for resetting the applied transformation. You can also add another transformation on top of a previous one. If you know how to implement the original logic using Byte Buddy, you can simply redefine the methods to their original intend.. Closing, please reopen if this is still relevant.. No, unfortunately.. Did you set a custom ignore matcher for AgentBuilder? By default, Byte Buddy ignores all classes on the bootstrap path.. Closing, please reopen if this is still relevant.. You are absolutely right. I will have a look. If you want to speed up the process, feel free to send a PR. The plugin should check the code.level property or something similar and set the class file version accordingly.. I thought about this and I think this mandates an API change. This might break the plugin for some people but as it is now, the unexpected result that varies with the JVM that is used is a pretty severe bug. I rather have the build fail for that reason. I pushed a commit to a branch where I drafted a solution but I need to do a similar thing for the Gradle plugin where I do not yet know how to get hold of the Java version. Feel free to continue, I am currently on parental leave and a bit time constrained.. I already made a few adjustments and merged them to master! Please try them.. Fixed on master.. Wow, thanks for doing that!. It seems like your Gradle build is using some Java agent or other tooling that destroys some of the meta data within the method. The method signature is:\njava\nBrokenClass.someMethod(java.lang.String)\nwhich should at least have one stack map element containing the single string argument. The length was however detected as zero, meaning that the argument was deleted.\nI want to allow Byte Buddy to copy the arguments at some point to avoid this requirement but at the moment, it needs to reuse the existing meta data.\nAre you using some code coverage tool or something similar that might redefine your code?. It might indeed be Spock. Is there cglib on the class path? Newer versions of Spock can use either Byte Buddy or cglib. Cglib creates classes that often embed strange meta data. This might be it? Maybe the code generator is different based on your build location?. As a work-around, you could also turn on ClassWriter.COMPUTE_FRAMES for your build but I do not recommend that in production.. In this case, there should not be a problem. I assume that this might be related to something strange in the Groovy compiler.\nI have plans to add a mode to Byte Buddy Advice that is less powerful but avoids the root cause of this error. It will be a bit of work but in the long time, I think most users can apply this mode to avoid suffering this. It is really strange that this only happens using Gradle but not IntelliJ. The other way round would make more sense. Eventually, one would need to dump the byte code of the class in question for both cases and compare them what could at least give clues.\nIf you would provide me with the byte code, I will have a look without being able to promise that there is anything I can do as the initial byte code seems to be broken to begin with..... You can attach the class file for BrokenClass in this thread. As the class file is apparently transformed such that this error is triggered, you can also set a break point where the exception is thrown. Then browse down to the TypeWriter where the byte array for the original class file is resolved. Store this byte array somehow using your debugger and attach the resulting file to this thread.\nThanks for helping out!. This should no longer happen as of Byte Buddy 1.8.2, please reopen the ticket if you experience this problem again.. No worries, thanks for getting back!. Looks good but could you avoid the whitespace changes?. I cleaned up a bit and merged your PR.. You are right, I have already fixed this on master and added the overloaded version you suggest.. Hey, the problem you encounter is that cglib relies on its own types to work, meaning that cglib must be visible to the class loader you are injecting a class into.\nThere is no such guide, you are correct and I should find the time to write one some day. Let me keep this issue open for a reminder. The most used capability of cglib is probably the enhancer that you are using which should be easy enough to document.\nFor a rough version, there is no direct equivalent but there are several options. For you, the easiest way might even be the InvocationHandlerAdapter:\nnew ByteBuddy()\n  .subclass(delegate.getClass())\n  .method(any()).intercept(InvocationHandlerAdapter.of((proxy, method, args) -> {\n    // put your code here\n  }).make().load(dockerClientClassLoader);\nThe resulting class does not have any type dependencies outside of the JDK and the delegate class such that you should not have any issues.. Why are you using ClassLoadingStrategy.Default.CHILD_FIRST and not ClassLoadingStrategy.Default.INJECTION? With child first, the class is loaded in a new class loader with the specified class loader as a parent but with child first class loading semantics. Using injection, Byte Buddy will use Java reflection to inject a class into dockerClientClassLoader from the outside.\nIn order to debug the memory issues, you would probably need to look at a heap dump. But I am wondering if you create a lot of new classes? Note that Byte Buddy creates a new class every time that you run the above code. If you want to reuse the class, you should probably create a class that you can reuse:\njava\nTypeCache<Class<?>> cache = new TypeCache<Class<?>>(Sort.SOFT);\nByteBuddy byteBuddy = new ByteBuddy().with(new NamingStrategy.PrefixingRandom(\"helloworld\"));\nInvocationHandler invocationHandler = ...\nObject proxy = cache.findOrInsert(dockerClientClassLoader, delegate.getClass(), () -> byteBuddy\n  .subclass(delegate.getClass(), ConstructorStrategy.Default.NO_CONSTRUCTORS)\n  .defineField(\"invocationHandler\", InvocationHandler.class, Visibility.PRIVATE)\n  .defineConstructor(Visibility.PUBLIC)\n  .withParameters(InvocationHandler.class)\n  .intercept(MethodCall.invoke(delegate.getClass().getDeclaredConstructor())\n                                .andThen(FieldAccessor.ofField(\"invocationHandler\").setsArgumentAt(0)))\n  .method(ElementMatchers.any())\n  .intercept(InvocationHandlerAdapter.toField(\"invocationHandler\"))\n  .make()\n  .load(dockerClientClassLoader, ClassLoadingStrategy.Default.INJECTION)\n  .getLoaded()).getDeclaredConstructor(InvocationHandler.class).newInstance(invocationHandler);\nThis way, you only create a single class in case that you create many such proxies.. I wrote a tutorial : https://mydailyjava.blogspot.no/2018/04/jdk-11-and-proxies-in-world-past.html?m=1. I will include something like this in the next release. Thanks for the suggestion!. I just looked into this and this is already supported in Byte Buddy. If you use isAnnotatedWith on a generic type, Byte Buddy will resolve its type annotations.\nFor your example above, you cannot check an instruction annotation as this is not part of a method signature but you can match a type annotation on a generic type for example.. You can do the following:\njava\nTypeDescription typeDescription = new TypeDescription.ForLoadedType(c.getClass());\nSystem.out.println(typeDescription.getInterfaces().getOnly().getDeclaredAnnotations());\nSystem.out.println(hasGenericSuperType(isAnnotatedWith(MyTypeAnnotation.class)).matches(typeDescription));. Perfect, thanks a bunch!. Unfortunately, I would not know a good way from within a Javaagent. This would be easier to achieve from a native agent where you can browse instances of a class from a dedicated thread. This way, you could do it asynchronously.. The MethodDelegation class can be chained using .andThen.. If I was not Java 6 compatible, I could try to evolve the interface. But in reality, I would probably need to extend it a bit different and overload it using some Composable andThen(Composable impl) to allow further chaining.\nFrom a DSL perspective, this would be of course much better but I need to see how I can realize that. Unfortunately, I think that I would need to add some implementations to all subclasses.. Actually, it was quite simple. I like the idea and added it to master: https://github.com/raphw/byte-buddy/commit/3e680ca0f2e0fccb58b800d2619e29d12a5f26cb. Fixed on master.. The NoClassDefFoundError might be misleading and point to an error in your instrumentation. It could be a  erification error in disguise. Are you instrumenting your code using Byte Buddy? I am wondering why you do not operate on a dynamic type.\nI would need to see more of your example to provide better help. I think the actual problem is in the byte code generation.. You can still use ASM with Byte Buddy in this case, have a look at AsmVisitorWrapper.ForDeclaredMethods. you can register frame computation in there and still use ASM for the method body.\nGlad you figured it out.. Yes, please! Could you do a PR on the gh-pages branch with a suggestion?. No worries, if I find time first, I will do it, otherwise, I can easily just merge your PR.. Thanks, glad you like the tool.\nUnfortunately, other than the Java programming language, Java byte code is not backwards compatible.\nHowever, for class file constants, Byte Buddy offers a correction mechanism since that is the most common incompatibility. Register the TypeConstantAdjustment which should take care of that problem.\nBy the way, Java 6 byte code is the most compatible byte code version as of today which you should use for your Advice code to maximize compatibility.. I think I will just add a convenience method to control what output is shown. Thanks for the suggestion.. Convenience methods are added since 1.8.3.. I assume that your classes are not visible to the class loader that loads JavaFX.\nIn this case, you would need to inject your utilities into the JavaFX class loader or any of its parent class loaders.. The agent is on the system class path.\nIf you run javafx.scene.Parent.class.loadClass(\"pkg.LoggingUtils\") do you get an error?. Shouldn't be as that applies to hundrets of unit tests, too.\nCould you try a Class.forName where the error occurs and catch any exception from the call? This way, you could validate any visibility constraints by printing the result.. You can use the instrumentation API to append a jar to the bootstrap class loader. This makes the classes universally visible.. Closing, please reopen if this is still relevant.. You can use code templates from Java classes. Have a look at Advice.. Closing, please reopen if this is still relevant.. What JVM are you using for this? Byte Buddy needs to install an agent. That all values are null seems very strange to me, those are essential properties. If you run in debugging mode, some JVMs enable certain agent adapters that are otherwise not available. Are you using J9 by any chance?. Thanks, I think I identified this problem and it is due to an incompatible behavioral change introduced in ASM 6.1. I will fix this with the next release.. Fixed on master.. @sdfelts In what context are you experiencing this error? This should only happen if you are using ClassLoadingStrategy.Default.INJECTION which does indeed no longer work. This class loading strategy has been discouraged but there are still scenarios where using it is the best option. For the build, I will create a rule to exclude these tests if sun.misc.Unsafe is not available, only few tests rely on it.\nIf you are using this strategy, consider replacing it with ClassLoadingStrategy.UsingLookup which is what @AlanBateman suggested. It takes a method handle lookup as an argument and can define classes only in some packages and class loaders unlike the injection strategy.\n@AlanBateman Thanks for reaching out directly. Unfortunately, Lookup::defineClass is insufficient in many cases. Using a method handle is for example inapplicable for:\n1. Java agents that need to define auxiliary classes for the instrumented types similar to javac sometimes needs to define inner classes to fulfill method contracts. As of today, only strange workarounds can achieve this as embedding the byte code in the instrumented class's constant pool as base64 string and using the method handle received from within this class. Unfortunately, the class file transformer is not provided an appropriate method handle what makes this necessary.\n2. Test frameworks such as Mockito have a good reason to define classes in foreign packages even without receiving a method handle lookup. This is only applicable in a test scope where security or encapsulation is not a big concern. \nThere are plenty of other workarounds as of today such as using a Java agent to open the jdk.internal.misc package, using JNI or extracting the IMPL_LOOKUP field from the MethodHandles.Lookup class by shifting some of the class's byte code to extract it to some accessible field. However, I hope that we can get it right this time such that all current useful Java libraries can continue to work without creating new hacks that will cause new disturbance in future Java releases.\nI have not too long ago summarized my thoughts about the current state of affairs, knowing most low-level libraries fairly well but did unfortunately not receive any feedback. The easiest would be to add defineClass and newInstance methods to the Instrumentation interface as Java agents can already operate outside of the Java security model. If there was additionally a test module to get hold of Instrumentation where that module was not resolved unless explicitly added, this would allow test libraries like Mockito to get to do what they do today without potentially compromising production environments.. Mockito is one of the cases where class file injection is still essential and no good alternative is offered. Mockito often needs to define a class within another package in order to allow mocking of package-private classes and mocking of protected methods. Without Unsafe, this is not currently possible in such a general scope.. @AlanBateman Is that really the right mailing list given that Mockito is more of a code testing tool and less about \"debugging, profiling, monitoring, and management\"? I have mentioned this topic on various OpenJDK mailing lists in the past but never got a proper response, therefore I am hesistant on using even more time on writing up my thoughts. \nMy suggestion still is to add defineClass and allocateInstance methods to the Instrumentation interface. Java agents can always get hold of the jdk.internal.misc.Unsafe instance and open the package to access it, this does therefore not add any security holes, quite the contrary, as Java agents are loaded on the class path in the unnamed module, having these methods available might reduce future security issues if agents just naively open unsafe to the entire class path. This way, we could avoid further hacks and finally rely on a stable API. This would really add to the stability of our libraries that are downloaded many million times every month and have become essential to the Java ecosystem. Furthermore, JVMTI agents have access to these methods already.\nI find it unfortunate that this method is taken away just like that, especially with the wide use of Java agents that currently rely on this method to implement javac-like behavior and the large amount of testing tools such as Mockito that are now broken. Right now, Mockito does not work at all and the only idea I have is to use the mentioned Java agent to overcome this what would just imply more hacks that break in the future. With only these two methods, I do not think Unsafe would be needed anymore. But at the moment, no project can build on JDK 11 what is a large fraction of Java projects what always puts a very unfortunate pressure from upstream upon us.\nOf course, to a given extend, we could use the lookup API but this will not work in many scenarios such as OSGi. I think it is legitimate that some libraries need to get around this.. Brilliant, adding this method would solve 99% of my use cases and avoid the ugly workaround via jdk.internal.misc.\nIt also seems like using MethodHandles.Lookup::defineClass works for the majority of our use cases besides some obscure ones involving serialization which I doubt that those impact too many users.\nI will try to get a release out asap and ask for some community feedback on the changes.. Build does now work again. Mockito is also fixed.. This bug is already resolved with the latest release change: https://github.com/mockito/mockito/pull/1351. Can you give an example of your code? You should probably use AgentBuilder.Transformer.ForAdvice to implement your logic. Doing so, you can specify the class loader that contains your advice code where Byte Buddy makes sure that all the user classes are referenced appropriately.. Yes, advice classes are merely templates, you cannot expect them to have the same class loader scope as the instrumented types. Imagine that Byte Buddy goes into the advice class and copy pastes the method's code to the instrumented class.\nYou should seperate all classes that you reference in advice classes into their own classes and then use a ClassInjector to inject another class into the class loader of the instrumented class as you suggest yourself. If the class loader of this injection target is not the same as that of your initial class, this class will become a class of its own and not have any fields set. You have to do so manually.. You can use reflection after injecting the class, the injector returns the injected class. If you want to execute code in the scope of the instrumented class, you can also instrument the class initializer via .invokeable(isTypeInitializer()).. No, system and bootstrap classes are forever. The only way to unload a class is to unload its class loader.. Glad I could help!. Good idea, thanks!\nI think, primitives first, then strings, the enums, then the rest. Within each group, I would retain declaration order.. I implemented this to allow sorting fields by their type which is either custom but with convenience for:\na) primitive types\nb) enumeration types\nc) primitive wrapper types\nd) string types\nThe build plugin will typically sort fields in this order before any other type.. MethodCallProxys are cached in Implementation.Context::register. This is to avoid that to proxy classes are generated twice without to users needing to know of one another.\nDid you do any measurement of the performance that led you to this? I have not found this to be a problem.. Closing, please reopen if this is still an issue.. What do you mean by that? Can you explain what you are doing and why this consumes too much time?. Transformation is a rather expensive operation but it is only applied once. I do not think that there is much one can do but you could simplify your agent, for example, you can choose to not analyze the call graph of the instrumented class by registering a noop method graph compiler if you do not require this information.. Yes, but Byte Buddy will not attempt to resolve methods declared by super types.\nAbout the time consumption: Are you using SLF4j in your agent? Maybe you are triggering some form of circularity.. Could you try to rip out the slf4j dependency from your agent to try it? If other classes do not take that long, I doubt that it is the method graph compiler. You can provide an agent builder with a Byte Buddy instance where you set a custom compiler if you want to try out anyways.. I tried on a simple project that uses SLF4J and I cannot reproduce the slow project start. Could you also give me a sample project that reproduces this issue?\nAlso, could you try updating to Byte Buddy 1.8.3? I fixed some performance regressions in the 1.8.* releases.. This is what I have tried but the start up takes a bit under a second. Did you try the update that I suggested?. I recreated this example: http://www.baeldung.com/slf4j-with-log4j2-logback and could still not reproduce this.. I tried your project and it runs in less then a second. Are you sure that you do not have a file lock or something that slows things down?\n. You are right, I have used a JDK 10 to run the example but with a JDK 8, I can reproduce the lag.. Alright, the problem is that the performance of LinkedHashMap degrades after a certain amount of entries. The Log4j logger declares around 500 methods and I have never tested for this. I will need to rework parts of the method graph compiler to better handle this. Fortunately, your simple agent can use an optimization where the method graph can be extracted much easier. Define your agent to use:\nnew ByteBuddy().with(MethodGraph.Compiler.ForDeclaredMethods.INSTANCE). This is a tricky one, Byte Buddy runs in a performance issue here that is resolved by JVM improvements in later versions of Java but for Java 8 and before, the only solution would be to replace the LinkedHashMap as a data structure with something tailored to this use case. The problem is that, upon copying, the hash code of every key is recomputed what is fairly inefficient. Maybe adding a wrapper object that caches the key can help.\nAnother reason for this performance problem is the name equality. For simplicity, only the method name is considered for resolving the method graph. However, the number of parameters should also be considered as methods with an unequal number of parameters can never be bridges for one another. This makes this class so vunerable to performance degradation as Log4j defines so many overloads.. It is a key for a method that is gradually expanded by discovering more bridges up the class hierarchy.\nThere is probably quite some potential performance improvement. I will need to have a look. It might be as easy as diffing the Java 9 and 8 linked hash maps to see if I can replicate the Java 9 behaviour. Also, some of the immutability is only for simplifying the code, I can probably ease up on that.. For some reason I believed that duplicating a hash map was a cheap operation but it is actually very expensive. The copy constructor does not copy the internal state of a map but rebuilds the map from scratch. This requires the recomputation of the hash codes of all elements and implies countless invocations of equals.\nI have now reduced this amount drastically by embracing mutability in the computation of the method graph. This makes the code a little more complicated but improves runtime by quite a bit.\nAs of Java 9, it seems like the JIT can detect the immutability pattern much better such that the code optimization makes this improvement close to unneccessary but for the sake of Java 8 and earlier, this change is of course still meaningful.. Implemented sealing mechanism.. Hey, thanks for your PR. Did you measure that this has an actual impact? There are plenty minimal improvements that I skipped to keep the code base cleaned up. This is not to bad and maybe worth it due to the high reliance on names throughout the library. Was that your thought?. Merged manually.. If the list is empty, it would probably be most efficient to return a singleton list returning the single element?. Merged manually.. I always tag the last release version as I sometimes need to break API and then would release 1.9.0.. @testn Out of curiosity: Are you applying these changes based on profiled runs? Did this improve performance for your AssertJ performance issue? Just checking, these changes are not intrusive but decrease the code quality a tiny bit every time, therefore I only want to add them if they have proven useful.. You can bind the maven goal for the Byte Buddy plugin to the make command. Then it is always executed. It should however not be necessary for most cases, the essential hashCode/equals methods must be implemented explicitly.. I am currently busy with a sick kid but I will look at it.\nAs said, I was wondering if you and how you did benchmark this. Just checking to make sure that I do not complicate the code base for no reason,. @testn Just to make sure if you read this section. How did you benchmark this? I am wondering since this avoids additional allocations but adds an additional lookup for all classes that are not in the cache so I wonder if this really pays off.. Brilliant, I will merge this some time this week end, hopefully!. I will not merge this either since validation is a developer configuration that should not be used in production and to keep the code simple.. Since validation is a debugging configuration, I will not merge this to keep the code simpler.. I do not think this is a strict requirement and I found maintaining the header tedious, that is why there is none. Ref: https://softwareengineering.stackexchange.com/questions/270091/is-a-license-header-in-source-files-required-when-applying-the-apache-software-l. Copyright 2018 Rafael Winterhalter.. This is a compiler problem. The exception roots in the reflection API which does not accept an empty parameter name.. Hi, this is an unfortunate side effect of the adjustment for supporting Java 11+ which does no longer allow class injection. To trigger the old behavior, you can explicitly use the ClassLoadingStrategy.Default.INJECTION as a second argument to load. On Java 9 you can however use ClassLoadingStrategy.UsingLookup. If you want to support VMs before and after Java 9 which introduced modules, you can support both.\nThis article might interest you: https://mydailyjava.blogspot.no/2018/04/jdk-11-and-proxies-in-world-past.html and explains the background.. This is part of a necessary transition to support the module system, nothing more to do here. Thanks for reaching out!. I added a readme to the Maven module just as there is one for the Maven plugin. This was really missing. Thanks for bringing it up!. I answered your question on StackOverflow. Please reopen this ticket if you have any further questions.. You can debug such issues by registering a listener such as Listener.StreamWriting.toSystemError. Doing so allows you to see exceptions that are thrown during a transformation.\nIn your case, you have not enabled bootstrap injection such that the proxy class for the SuperMethodCall cannot be injected. This is however a bit of an issue in your case as UrlConnection is used during loading the injected path.\nI would therefore recommend you to write an advice as it seems like you try to add code before and after the original invocation using Advice.to(HttpURLConnectionMethodInterceptor.class):\n```java\npublic class HttpURLConnectionMethodInterceptor {\n  @Advice.OnMethodEnter\n  public static void enter() throws Throwable {\n    System.out.println(\"---[BEGIN] HttpURLConnectionMethodInterceptor\");\n  }\n@Advice.OnMethodExit\n  public static void exit() throws Throwable {\n    System.out.println(\"---[END] HttpURLConnectionMethodInterceptor\");\n  }\n}\n``. No, this is because the code is inlined, not called. Please read the documentation of Advice.. What are you struggeling with? It works when I tried it. For a delegation, theSystemTimeInterceptorclass must however be on the boostrap path. You can avoid that by usingAdvice`. Doing so, you can however not invoke the original method:\n```java\nclass Foo {\n    @Advice.OnMethodExit\n    public static void millis(@Advice.Return(readOnly = false) long x) {\n        x = 123;\n    }\npublic static void main(String[] args) {\n    new AgentBuilder.Default()\n            .enableNativeMethodPrefix(\"wmsnative\")\n            .with(new ByteBuddy().with(Implementation.Context.Disabled.Factory.INSTANCE))\n            .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)\n            .with(AgentBuilder.RedefinitionStrategy.REDEFINITION)\n            .with(AgentBuilder.TypeStrategy.Default.REDEFINE)\n            .ignore(none())\n            .type(ElementMatchers.named(\"java.lang.System\"))\n            .transform(new AgentBuilder.Transformer() {\n                @Override\n                public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) {\n                    return builder.method(ElementMatchers.named(\"currentTimeMillis\")).intercept(Advice.to(Foo.class).wrap(StubMethod.INSTANCE));\n                }\n\n            }).installOn(ByteBuddyAgent.install());\n\n    System.out.println(System.currentTimeMillis());\n}\n\n}\n``. I do not think that is possible. In order to rebase, you need to change the class file layout of theSystemclass what is only possible if the system class is not yet loaded what it always is. This is not possible on the JVM. Your only way is to replace the method alltogether.. In this case, this would unfortunately not help since the native bindings would not be changed just by adjusting the jar.. Extended the check toisAssignableTo` to avoid object allocation. Thanks!. Thanks, I will implement such shortcuts for all loaded type representations to keep it consistent. Thank you!. You are right, I disabled it for all Byte Buddy generated classes.. Byte Buddy only applies the last registered interceptor that matches for performance reasons. Also, the semantics of such a match would not be clear. You have do do these things manually, e.g.:\njava\n.method(isAnnotatedWith(named(\"com.agent.study.bytebuddy.demo4.AnnoTest\")\n                      .or(named(\"com.agent.study.bytebuddy.demo4.Count\")))\n.intercept(MethodDelegation.to(AnnoAndCountInterceptor.class))\nAlternatively, you can use Advice which works using visitors what can be nested. From your example code, it already seems like you want to use advice.. I hope this answered your question. Please reopen this ticket if you need further help.. 1. The question is: Are you trying to create a proxy subclass or do you want to enhance the existing class to include the validation. Currently, you are trying a mixture of both which is why you are experiencing this behavior.\nBy new ByteBuddy().subclass(BankAccount.class), you are creating a subclass of BankAccount that declares constructors with the same signature of those of BankAccount. This is the default behavior, have a look at ConstructorStrategy for alternatives.\nWhen using Advice.to( ... ).on( ... ) you are creating a visitor that enhances all methods that are already declared by a class. In your case, since you subclassed BankAccount, no virtual methods are declared by your subclass as you do not declare any.\nAdvice is meant to enhance existing behavior what is very useful for Java agents to inline code into existing methods where the byte code is then executed in the appropriate class loader but for your case, you might want to use MethodDelegation if you need to call into the Hibernate Validator framework anyways.\nIf you want to use Advice, you do need to declare the methods in the subclass. Advice can be used as an implementation rather than a visitor by declaring a primary implementation that the advice should wrap around by builder.method( ... ).intercept(Advice.to( ... ).wrap(SuperMethodCall.INSTANCE)).\n\n\nAs for getting the actual constructor, this is a bit tricky as the constructor is not considered virtual. You do not override one, you just happen to declare one with the same signature that invokes its equivalent super constructor. Your code would therefore work, given that the constructor is declared public, otherwise, you would need to use getDeclaredConstructor. Alternatively, you can instructor Byte Buddy to only mimic public constructors by using the appropriate ConstructorStrategy.\n\n\nYou can register custom bindings for parameters of both Advice and MethodDelegation. You can read annotation values during the creation of the binding and read the Class<?>[] values to be written as constant values into the validated class. For an array, have a look at ArrayFactory where you could create an array of ClassConstant values and bind this array to an annotated parameter. Have a look at the javadoc for how to do this or ask a follow-up question once you have tried.. Glad I could help!. I just adjusted the build to only include the classes from ASM commons that are really required by Byte Buddy. It is only a few but the commons jar drags in the entire tree API what was an overkill for Byte Buddy's purposes.\n\n\nCould you checkout the project, build it and see if the problem persists? At some point, I hope to generate module-info files myself and include them.. Great, I will do a new release some time soon.\nI will keep this issue open and hopefully integrate a modular artifact in the release at some point.. Could you try to build Byte Buddy from master and include this version? I assume that it is an issue with some updated shading that I presumably just fixed. Android has stricter verification with regards to class path consistency and I excluded some shaded internal code that is never used by Byte Buddy but still referenced by another few unused classes.\nIf master works for you, I can make a quick release.. Did you use the Maven wrapper to use the correct version? If so, could you run with the -e and -X flags?. No, the adviced code is merged into the original code, there is no way to seperate the two programatically. The easiest way to only trigger advice for the first entrance would therefore be, as you suggest, a thread local switch.. Please reopen this issue if you have further questions.. I had to change the default class loading strategy to keep the standard API free from use of the sun.misc.Unsafe class which was partially removed in one of the recent Java 11 EAs. Spock needs to update to the method handle API as I described it in: https://mydailyjava.blogspot.no/2018/04/jdk-11-and-proxies-in-world-past.html - Unfortunately, this cannot be done in Byte Buddy but must be applied by Spock due to the call site sensitivity of method handle lookups.\nI will send them a PR. Thanks for reporting.. For reference: https://github.com/spockframework/spock/issues/843. Byte Buddy is a byte code instrumentation tool and does not hook into C code. It does give you the ability to rebase methods and to use a native method prefix for this rebasement but this only works for classes that are not loaded already when the agent is applies. the UnixFile class is loaded before the agent is applied what makes this impossible, unfortunately.. This summary is a good problem description and no, there is no good way around it other then what you mentioned. Ideally, you \"call down\" to your agent and process any information retreived further within your advice. This means that you would need to split up your helper code to not know any types that are part of the advice class but only Java core types. Alternatively, you can inject code into the target class loader which I would however avoid as class injection is touching some JVM internal APIs which are subject to change. Also, you must make sure that the helper class does not both exist in your agent jar and the injected class as many class loaders resolve parent-first what can cause issues.. Yes.. It does already, have a look at ClassLoadingStrategy.UsingLookup stategy. It does not longer work out of the box, however due to the call site sensitivity.. No, this functionality is no longer part of the JVM for keeping the module boundaries consistent. There is however a discussion about introducing new functionality for Java agents which is still ongoing. Please chip in with your experiences: http://mail.openjdk.java.net/pipermail/serviceability-dev/2018-April/023529.html. This would not allow you to invoke the helper classes via byte code, or how would you approach this? Also, the child loader could be collected.. I am still doubtful that this works. The problem is that you cannot properly bind the life-cycle.\nWith a weak reference, the helper class loader and its class will simply be GCed within the next GC cycle. With a strong reference, you are leaking the helper class loader and its child. The only way to bind the life-cycles of both class loaders would be to reference the helper class loader from the instrumented class and the only way of doing that within byte code is by adding a symbolic reference to a class. Since the helper class loader is however a child of the instrumented class's class loader, this is not possible.\nOr how did you think to work this out in a general way? For your use case, it works as it only references the container class loader which is permanent.. I am afraid that both approaches will cause you a lot of head ache; the application monitoring and the soft reference as for the latter, you will have to recreate classes on demand from the user threads.\nI understand your need, but I do not currently feel comfortable to add such functionality to Byte Buddy; it is too fragile to support it on the long tun.. There is a bit of discussion around this issue on https://bugs.openjdk.java.net/browse/JDK-8200559.\nOne possibility is to use MethodHandles.Lookup which offers a standard API to doing so. The Instrumentation interface offers a way of manipulating modules so you can open any module to a module of your choice which can then use its lookup to define a class in the target module. This does however require that a class is loaded, therefore, if it is not loaded yet, you can inject code into this classes static initializer to load the injected class from there before any other code is run. A downside of this approach is that it can change a class's implicit serial version UID and that it changes the module graph what is observable from user code. The other obvious downside is the negative performance impact as individually changing the module graph for each class is very expensive.\nThe much easier solution would be to open the module of jdk.internal.misc.Unsafe. This is of course an unfortunate choice since this creates another dependency to internal classes but form my point of view, this is currently the only feasible option and an easy replacement for running code on any JVM as it offers the same API as sun.misc.Unsafe. To use the jdk.internal version, you can manipulate the module graph using Instrumentation. Be however very careful to whom you open this module, an agent is normally run in the unloaded module of the system class loader. If you opened this module to the unnamed module of the system class loader, you would give access to any code on the class path what introduces a security vulnerability.. Yes, this is an implication. This is however only true for class loaders that are not the bootstrap loader.\nI add this as Java 11 does not remedy the removal of sun.misc.Unsafe::defineClass. Of course sun.misc.Unsafe::putBoolean will be removed at some point. I do however hope that an alternative for class injection is offered to Java agents at this point.\nAdding the functionality does at least buy some time.. Implemented on master.. 1. I would avoid the usage of a static initializer block as the self-attachment can fail. ByteBuddyAgent.install() will unlikely work in a production environment as it only functions on a JDK-bundled JVM that comes with the attach API. Please read the javadoc for further details. To attach to a JVM in production you must either specify your agent as a Java agent on the command line using -javaagent or deploy an application with a JDK that can then again use ByteBuddy.attach(pid, jar where you again would need to bundle your application. You can however use ByteBuddy.install() in unit tests and test environments where you have JDK-VMs deployed.\n\n\nOn installOn, you receive a ResettableClassFileTransformer. Calling its reset method, undoes any transformation if this is possible. Otherwise, class transformation is applied upon loading a class what is done lazily upon the class's first usage. From an agent's perspective, you do not know when this stage is reached. You do neither know if another agent triggers retransformations where your transformer would still be required for reapplying the transformation. But there is no danger or disadvantage in keeping it registered.\n\n\nYou should not rely on these methods. The getter is exposed to speed up Byte Buddy's annotation handling where you need such a reference to access a loaded annotation's properties. These methods are side-effect free and typically accessible which is why this approach is chosen. For constructors, there is no need for this. To get the class, you can do Class.forName using the member's declaring type for which you do need a class loader. Byte Buddy describes types independently of a class loader as types can be unloaded.\n\n\nYou should be able to describe all matchers using Byte Buddy's TypeDescription and MethodDescription abstractions. It exposes all methods of the Java reflection API but without the invocation APIs.\n\n\nThe problem of these applications is that it makes sense to maintain a cache of type descriptions to enhance performance. This is important for a standalone tool that can be used within many applications but if you do not experience performance problems, there is no need for you to optimize. If you implement such caches, it is important that you do not retain class loader references as this can leak the class loader what does not seem to be relevant for your use case.\n\n\nGlad you like the library!. Despite the method name, this will include matching constructors. This is an unfortunate naming inconsistency that I plan to resolve with Byte Buddy 1.9.0 as this is a breaking change.\nAnd yes, two transformers can be chained, both should applied. If you do however apply two type matchers, you need to call .asDecorator as a last step.\nI would love to offer you more detailed help but my time is limited and I would really need to see an isolated reproduction to offer you a quick answer.. Please reopen this question if you have further questions.. Thank you, glad you like it.\nIf you wanted to cache the value, just add a map to your interceptor, find some key using the @Origin and @This annotations and look up if you previously computed a value for some intercepted method. If so, just return this computed value instead of calling zuper.call().\nIn practice, you probably need to make some more adjustments to get this work in production quality. Those questions are however not really Byte Buddy related.. The agent builder produces byte code based on a variable input byte array (in case other agents are invoked). Also, the agent is only invoked once per class such that there is no need for caching.. No new injection API was introduced in Java 11. The rest is implemented on master.. This has to do with: https://mydailyjava.blogspot.no/2018/04/jdk-11-and-proxies-in-world-past.html and is something that Hibernate needs to adapt to. I made the team aware of it.. Byte Buddy has no way to know what instrumentations depend on one another, therefore, I think it is a sane choice to abort the entire transformation process, if an invalid choice is applied. This is quite deeply built into the implementation of Byte Buddy which is why I cannot offer this functionality. . Spring Boot uses its own class loader hierarchy to support its concept of a far (nested) jar. The Java agent however is loaded on the system class path which is not part of this class loader hierarchy such that your MyAdvice class is not visible.\nIf you wanted to apply this advice class in Spring Boot, you should inject it into the bootstrap class loader via Instrumentation::appendToBootSearchPath.. Please reopen this ticket if you have further questions.. Fully correct, the undefined package should only be used for arrays and primitive types. Fixed on master.. The problem is a bug introduced in ASM 6.2: https://gitlab.ow2.org/asm/asm/issues/317833. The builders are immutable, do you assign the builder to override the old reference in your code?. Ok, I got some time to look into the sample. I see how this is confusing but it is actually expected behavior:\n1. With builder.visit(...), you are registering a low-level transformation that applies during writing the byte code and which does not interfere with Byte Buddy's TypeDescription representation. Therefore, any element matcher only sees a method in their original form.\n2. Visitors are registered in their registration order, i.e. the first visitor is applied last. With modifier transformation, this means that the last visitor will actually define the modifier.\nWith this in mind, you cannot expect a transformation from the first step to be visible to the second transformer. The MakeMarkerInterfaceConstructorNonPublicTransformer does therefore not see the changes of the MakePublicTransformer. Also, the MakePublicTransformer, being registered first, will be the last to being applied such that it always defines the modifier.\nThis is of course not the greatest API behavior and I wish it was different but this requires a bit of a rewrite to offer a better solution. Maybe this can be a change in some 2.0 version some day but for now, this is what I can offer.. I am planing an enhancement of the type modelling API to incorporate such changes which is tracked here: https://github.com/raphw/byte-buddy/issues/479\nPlease reopen the ticket if you have further questions.. The problem here is that Java does not offer an API to distinguish if a value comes from an annotation default or by explicitly setting it, as you said. \nYou can therefore configure an AnnotationValueFilter.Factory on your Byte Buddy instance. Try\njava\nnew ByteBuddy()\n  .with(AnnotationValueFilter.Default.SKIP_DEFAULTS)\nand you should get the desired results. You can also filter the values manually by implementing your own factory.. AnnotationDescriptions can define any type of annotation, a loaded one, a parsed one and a synthetic one that was created with a builder. The idea was that all of those representations are equivalent and since the loaded one - which is a fairly major case - does not support a distinction, there is not currently an API for it.\nBut you are right, this could be solved different and I will consider this case for a future version.. I think the type mirror parses code as files? The TypePool.Default could therefore access this information but for loaded type, a byte representation of a class file might not be available.. Yes, what I consider is adding a property such as getValueType that returns a value of EXPLICIT, DEFAULT or UNKNOWN then you can use the information if it is available.\nI am tracking this here: https://github.com/raphw/byte-buddy/issues/482. That is great, makes things much easier! Well done!. Advice inlines byte code around a regular method call. By calling super, do you intend to invoke the actual super method or the original code? If you want to invoke the actual super method, this is possible by using the MemberSubstitution together with advice:\njava\nclass MyAdvice {\n  @OnMethodEnter\n  static void advice(@This Foo thiz, Object arg) {\n    blaBla(thiz, arg);\n  }\n  static void blaBla(Foo thiz, Object arg) { }\nYou can then register a member substitution to replace the call to blaBla(thiz, object) in the advice class with a call to super.blaBla(arg). Have a look at the javadoc for the component.. So you want to invoke the original (advised) method but without any advice code active?\nHave you looked into repeatOn from the exit advice? (latest update). This allows you to invoke the advised method multiple times possibly.. How do you call the actual method in this case? You can invoke the original method from the exit advice via:\njava\n@OnMethodExit(repeatOn = Advice.NonDefaultValue.class)\nprivate static boolean exit() {\n  boolean shouldCallMethod = ...\n  return shouldCallMethod;\n}. Please reopen the issue if you have any further questions.. It is possible but you need to apply a little trick to avoid Byte Buddy's validation of the ITest during the creation of the parameterized type:\n```java\nDynamicType.Unloaded type = new ByteBuddy()\n.redefine(ITest.class)\n.typeVariable(\"T\",\n  TypeDescription.Generic.Builder.parameterizedType(\n    new TypeDescription.ForLoadedType(Enum.class),\n    TypeDescription.Generic.Builder.typeVariable(\"T\").build()).build(),\n    TypeDescription.Generic.Builder.parameterizedType(\n      new TypeDescription.ForLoadedType(ITest.class) {\n        @Override\n        public TypeList.Generic getTypeVariables() {\n          return new TypeList.Generic.Explicit(TypeDescription.Generic.Builder.typeVariable(\"T\").build());\n        }\n      },\n      TypeDescription.Generic.Builder.typeVariable(\"T\").build()).build()\n  )\n  .defineMethod(\"exampleMethod\",\n      TypeDescription.Generic.Builder.typeVariable(\"T\").build(),\n      Visibility.PUBLIC)\n  .withoutCode()\n  .make();\n``. As for method type variables, the DSL supports it. Typically, your IDE can even help you with code completion here. You would specify the type variable after defining the method viadefineMethod`.\nYou can transform modifiers via the field step. Via the method step, you can match preexisting methods or via defineMethod you could define one. Annotation properties are nothing but methods where there is a defaultValue step where you can define such a value.. This is intentional and there is currently no way in the high-level API to suppress the original initializer. The reason for this is that a skipped execution of the initializer can break a class. You can however register an AsmVisitorWrapper to drop the original initializer by returning null from visitMethod once the <cinit>method is requested.. No, unfortunately.. Fair point, I will try to add this some time.. This is due to Byte Buddy no longer using sun.misc.Unsafe by default as described in the release notes: https://github.com/raphw/byte-buddy/releases/tag/byte-buddy-1.8.4 as this is required for Java 11 compatibility where the latter class does not supply all methods anymore.\nI have mentioned this in https://github.com/spockframework/spock/issues/843\nI would have liked to avoid this necessary change to accomplish compatibility without any breakage but due to the call site sensibility of method handle lookups, this could not be avoided. I also had to introduce a regression instead of discovering the JDK version automatically to avoid that Byte Buddy is working differently on different JVM releases.. Normally, Byte Buddy would set the field value via reflection but since you are storing the class somewhere where Byte Buddy is not in control, this never happens.\nIn your case, you need to initialize the class explicitly by using the DynamicTypes LoadedTypeInitializer. It is however much easier to delegate to a stateless Target class where the interception method is static, if you have a chance to do so.. It seems like Kotlin is creating some buggy Java class files here.\nCould you try, from your application, to call the following code:\njava\nClass<?> c = Class.forName(\"nexstra.portal.model.CampaignsService$$special$$inlined$makeCache$1\");\nMethod m = c.getEnclosingMethod();\nI wonder if you are getting an exception from the reflection API, as well.\nIs the subsequent type transformation throwing you an exception with the same stack trace?. I agree that unresolvable errors should be suppressed rather then to break the library, especially if it is such a non-essential property. At the same time, Byte Buddy tries to imitate the Java reflection API which every Java class needs to adhere. This is done to avoid differences between the type pool and the loaded type representations.\nDid you try to invoke the same method in the Java reflection API? What does happen when calling:\njava\nClass.forName(\"nexstra.portal.model.CampaignsService$$special$$inlined$makeCache$1\").getEnclosedMethod()\nI would like to be consistent to this behavior and I am sure Kotlin should aim to not trigger an error in the Java reflection API either.. If the reflection API fails on a class, it is never safe as many tools can process code on the JVM. Many Java agents do and also debugging tools as the one you got to fail. Therefore, I really hope that the Kotlin team does consider this a bug as this breaks with the JVMS.\nFor your case, you can work around the problem by adding a matcher by name first that excludes such classes, e.g. classes that contain a part of a name. These classes are not parsed before any property is accessed what avoids the error.\nI have considered adding such \"language specific\" whitelistings before but there are unfortunately too many and Byte Buddy would become impossible to maintain. Therefore, I strictly adhere the rule of \"works like the reflection API\" what I find a fair baseline.. The solution is probably somewhere related to the org.jboss.modules.ModuleClassLoader. Your Java agent is loaded on the system class path and you would need to find out if:\n\nThe module class loader can see your agent classes at all (delegates to the system class loader). This can be solved by injecting your classes to the bootstrap loader that is universally visible.\nThe module class loader only delegates specific packages to its parents. (You might need to change your JBoss setup.). I assume that this is because of JBoss not resolving the package as it is not configured in the JBoss modules descriptions. Ideally, you create your custom dispatchers and place them in some java. package on the bootclass path that is normally resolved by any class loader.. You would need to create some class java.some.Dispatcher, inject this class into the bootstrap path and then, from your Advice, you can only access this class to communicate with your agent. Otherwise, you must assume that only the classes that are normally available to the instrumented class are available.. Have a look at byte-buddy-android that offers an Android class loading strategy.. Implemented on master.. Are you using Byte Buddy 1.18.13?. Yes, never thought of it to be honest. Of course, Byte Buddy should support this and I will implement an appropriate measure some time soon.\n\nI cannot cooy the Javassist aproach unfortunately since Byte Buddy is a more general code generator but I think I have an idea of how to get it done.. I have a fix drafted but it will be a bit different in terms of the context being used.\nThe idea of Byte Buddy is to not create dependencies onto the library when creating code. The priviliged call will therefore happen from the static initializer and not from Byte Buddy.\nIs this a problem for your use case?. I have never looked into the proxy implementation of Javassist in detail but after checking, I can only say that this completely circumvents the security manager. It also breaks all compatibility to Java Modules.\nBy defining a publicly callable method RuntimeSupport::find2Methods that can be invoked by anybody on the class path, anybody can now apply the secured action with any inputs using Javassists privilege. I will not implement something like this in Byte Buddy and I would advice you against it as it makes Hibernate vunerable just like Javassist is currently vunerable. I argue that the privilege must be given to the proxy class.\nIf you really want to implement something like this, you can however do it already today, simply by registering a MemberSubstitution that you can register via DynamicType.Builder::visit.\nMemberSubstitution.relaxed()\n  .method(ElementMatchers.is(Class.class.getDeclaredMethod(\"getDeclaredMethod\", String.class, Class[].class)))\n  .replaceWith(Foo.class.getDeclaredMethod(\"getDeclaredMethod\", Class.class, String.class, Class[].class))\n  .on(ElementMatchers.isTypeInitializer())\nAs said, I would however advice against it.\nAs for Byte Buddy, I will add a possibility to make secured calls in the next version but I will keep this configurable to allow redirections such as the one that you suggested.. @gsmet I gave this some more thought and I think it is possible by adding a caller check in the method similar to how the JDK guards its sensitive methods.\nThis would be similar to something like the following:\njava\npublic class HibernateLookupDispatcher {\n  static Set<Class<?>> authorized = new SomeConcurrentSet<>();\n  public static Method getDeclaredMethod(Class<?> type, String name, Class<?>[] parameters) {\n    // Use stack walker API from Java 9 on.\n    if (!authorized.contains(Reflection.getCallerClass())) throw new SecurityException();\n    return AccessController.doPrivileged(() -> type.getDeclaredMethod(name, parameters));\n  }\n}\nDoing so, Hibenate can generate the proxy and then add it to the authorized set before interacting with the class in any way. Since the initializer is triggered upon first use, Hibernate can authorize the class before its initializer is run. With the set being package-private, it is not possible for outsiders to authorize the class either.\nYou can then add the code as follows:\njava\nMemberSubstitution.relaxed()\n  .method(ElementMatchers.is(Class.class.getDeclaredMethod(\"getDeclaredMethod\", String.class, Class[].class)))\n  .replaceWith(HibernateLookupDispatcher.class.getDeclaredMethod(\"getDeclaredMethod\", Class.class, String.class, Class[].class))\n  .on(ElementMatchers.isTypeInitializer())\nThis way, lookups are only possible for proxies with the Hibernate access rights.. Just FYI: I have made two changes to the way this is handled:\n\nByte Buddy will now use getMethod instead of getDeclaredMethod whenever this is possible as the former method requires fewer privileges. If Hibernate proxies would only intercept public methods, this might just solve your problem.\nYou can now enable a privileged = true property on all method proxy instances. This will be disabled by default as I do not think most users are compatible to the security manager to begin with and since the solution adds quite a bit of runtime overhead as Byte Buddy must create auxiliary classes to provide anonymous classes to run in the AccessController. This is required since Byte Buddy does not want to assume that the proxy class module can read the Byte Buddy module, either due to module or class loader boundaries.\n\nFor your use case, I think the solution proposed above is the best way. Doing so, a proxy class does only need to access a Hibernate specific class (the proposed HibernateLookupDispatcher) and nothing about the existence of Byte Buddy.\nYou could even check if a security manager is active before asserting the caller class, this would then probably avoid a performance penalty for the majority of users. Note that the above matcher should now check for both getDeclaredMethod and getMethod as Byte Buddy will be selective about it starting from the next release.. Byte Buddy builders are immutable, you have to assign the result of .visit.. I could not run the tests on my machine, it claims the test does not exist. I do however wonder if you could set a breakpoint at net.bytebuddy.asm.MemberSubstitution$SubstitutingMethodVisitor.visitFieldInsn and check the TypePool being used and see what class file locator is registered with it. That Java types cannot be detected is a bit strange.. That said, I am working on a function to suppress this error when the relaxed mode is used. I am still wondering why this error occurs, therefore I would like to fix the error if there is any, not only the symptom. . Ok, it was so simple as running all tests and I found the problematic code from there. The problem is caused by Byte Buddy falling back to its default TypePool under type creation. This is controlled by invoking DynamicType.Builder::make in ByteBuddyState:168. The method accepts a TypePool in this method.\nWithout supplying a TypePool, Byte Buddy will create one for you based on the ClassFileLocator that is supplied in EnhancerImpl:106.\nThere are two potential solutions to this problem:\n1. You extend the ClassFileLocator that you supply. You can for example supply: new ClassFileLocator.Compount(ClassFileLocator.Simple.of(safeClassName, originalBytes), ClassFileLocator.ForClassLoader.of(enhancementContext.getLoadingClassLoader())). This approach would work but it will probably be less performant as the generatedTypePooldoes not share a cache with theTypePool` that you have already supplied.\n\nYou supply an appropriate TypePool. This is a more efficient solution. Just supply the TypePool from EnhancerImpl as an argument to make.. Thanks a lot for your effort.. Have a look at AgentBuilder and the Instrumentstion API. Is tgat what you are looking for?. I am closing this for now, please reopen if you have further questions.. I am not sure if I follow you here. Even with JNI, it is not possible to change a class's schema, this is pretty much built into the JVM. There is the so-called dynamic-code evolution JVM that has this capability, but this is an entirely different build. \n\nIn its core, Byte Buddy takes one or several byte arrays that represent classes and returns a byte array that represents a transformed class or a new class. Class file locations are performed using a ClassFileLocator and the library yields a DynamicType. There are different adapters for handling transforming results, such as using an AgentBuilder or loading a class using a ClassLoadingStrategy but beyond that, Byte Buddy cannot lift basic restrictions of the JVM.. Thanks, I find the change reasonable, also since some class loaders annoyingly log failed resource lookup attempts. I chose the instrumented class's loader first to minimize the amount of failed lookups but some class loaders are just too weird.. Seems like this comes from an element of the array returned fromInstrumentation::getAllLoadedClasses. A safe-guard cannot hurt.. As Fabian said. Without any ignore matcher, you are likely to run into performance issues.. You have to define an ignore matcher that is differrent from the default:\njava\n.ignore(ElementMatchers.any(), ElementMatchers.isBootstrapClassLoader())\nYou would have to define a similar matcher where the first instruction is less restrictive then any().. This is a consequence of some work being done to establish Java 11+ compatibility. Byte Buddy does no longer use any internal classes in its default configuration and Spock needs to update their class definition strategy to adapt to the changes. There is an open ticket in Spock, also to fix Java 11 compatibility.\nYou can set the org.spockframework.mock.ignoreByteBuddy property to true to use cglib, no matter the class path.. I am glad you like it! The list in the readme is not meant to be inclusive, it just mentions a few early adopters. I am happy to list Skywalking in the Wiki!. Use ClassFileLocator.ForClassLoader.read(...).resolve(). I am planing to remove this utility at some point. It is redundant as Byte Buddy is already capable of such extraction with a better API that gives better error messages. I had introduced it in an early stage, I just need to refactor the tests that still use it at some point.. This is due to changes in the OpenJDK to further conceal internal API. I blogged about this here: http://mydailyjava.blogspot.com/2018/04/jdk-11-and-proxies-in-world-past.html?m=1\nThis requires an update to PowerMock.. Advice only applies to declared method when used via .visit(Advice). . You are right, this check slipped in by accident.. Fixed on master, thanks for reporting.. Thanks, you are absolutely right. I implemented a slightly different solution that does not require an exception to indicate the unavailability what is a bit cleaner.. Thanks, good to know. Have not considered this possibility. I will fix this in the next release.. Fixed on master.. Do you have a stack trace?. You can always implement a custom annotation binding for a value and you can use dynamic typing in the annotation value where Byte Buddy simply attempts a type cast.. You can bind a field value via Advice.withCustomConfiguration().bind(SomeAnnotation.class, ...). Then you can cast types etc. as long as your representation is possible in byte code.\nAlternatively, you can configure Assigner.Typing.DYNAMIC for @FieldValue or FieldAccessor to make Byte Buddy apply a type cast.. I think you did forget to declare the interceptor method as static.\nIf you want to delegate from the bootloader, your interceptor must also be on the bootloader, otherwise, have a look at Advice.. https://www.sitepoint.com/fixing-bugs-in-running-java-code-with-dynamic-attach/. You do need to specify the injection strategy explicilty now (via .load(classLoader, ClassLoadingStrategy.Default.INJECTION).\nOracle has made it clear that this strategy will no longer be supported on the long run, therefore Byte Buddy now defaults to loading the class in a new class loader.\nThe way to injection is to provide a method handle lookup on VMs Java 9+. I have blogged about this in the past: http://mydailyjava.blogspot.com/2018/04/jdk-11-and-proxies-in-world-past.html. Thanks!. Thanks for reporting. MethodDelegation instances are quite expensive by themselves as they process metadata which is another weak spot in the JVM performance-wise. I will have a look how this is used in Hibernate, the instances are immutable and can be reused.. I'll definitely look into optimizing is, the problem is however that I can only cache these instances for every instance of a method description that is created for each method delegation.\nThe delegation instances are not too big, they keep a reference to a single method instance at best.. I added a new build plugin to Byte Buddy that caches method return values on an instance. This is now done for all annotations by classes, methods and fields and for declared members of classes. Completed on master.. Implemented on master via .decorate.. Very much, have not thought of it. Thanks for pointing that out.. Did you try to open a ticket? Feel free to reopen if you have a question.. Yes, this would work, but you can equally apply several advices per instrumented type with same results.. You are right, if you want to guard something that happens in your advice methods, you can advice your advice.\nThis would best be done using the build plugin to avoid additional runtime overhead.. The agent builders can be chained, simply add .asDecorator() to the end after .transform() and only install a single transformer. Every transformer has a large overhead and you should avoid piling them up.. Yes, doing so, Byte Buddy does not need to parse the byte code multiple times and can reuse a single serialization.. Nicely done, thanks for that!. I think the worst leak is that of the class loader which cannot be prevented this way. A best solution removes the future from the root loader which can be done by implementing a custom dispatching scheduler.. Sure, sounds about right. Looking forward to a PR.. I messed up the shading, I had to trim it to get the module-info to work on another branch and did not realize I was missing a class. Fixed on master.. The problem with this approach is that it reads the annotations eagerly while this is not required most of the time, I want to avoid that.. This approach would not be thread-safe. I am aiming in a different direction here. I just added a new plugin for caching method return values and I will add something here in the line of what I started to add to the project. \nI think I want to cache annotations on the basis of the MethodDescription instance that emits the ParameterDescription. In addition, I will try to make better use of the Parameter API where annotations can be read more selectively.. I just tried it using \njava\nreturn not(isInterface())  \n  .and(nameContains(\"Request\"))\n  .and(declaresMethod(any()))\n  .and(hasSuperType(named(\"javax.servlet.http.HttpServletRequest\")));\nand the tests still succeed. Could you investigate this a little closer?. I see, the problem is class loading circularities. If you load a class during a class file transformation, this class will not be transformed. As a matter of fact, Byte Buddy has a mechanism for that, called a CircularityLock to suppress any class loading that occurs during a transformation. If it did not do this, the JVM would yield a CircularityError if the currently transformed class was reached via the load chain.\nTo avoid this, you need to avoid all class loading, for example by using Byte Buddy's pool-only descriptor strategy where the library parses byte code even if a loaded class is available.. Imagine what happened otherwise: the agent was loaded for the first time under transformation and TypeDescription was loaded. Doing so, TypeDescription was described as a type description recursively and things blew up.. Yes, but you would need to get hold of the information of whuch classes were loaded. This is not trivial since the transformer is not called. One way is to keep a reference on what classes were transformed and to check the list of all loaded classes occasionally.\nThis does however burn quite a lot of cycles.. I would only add it if you are certain that a type is within a type hierarchy. Byte Buddy caches type descriptions if you set up your builder correctly (you did with Stagemonitor) so the parsing step in case of unloaded types is cheap. Hierarchy checks with loaded types are also dead-cheap so getting hold of delcared methods really only pay off if you can avoid (re)transforming types unneccesarily.. I see that can be a problem, especially in small environments, but in the end its a trade off between speed and memory as in any application.. Both errors seem to come from a null pointer in the virtual machine class:\nCaused by: java.lang.NullPointerException\nat com.sun.tools.attach.VirtualMachine.attach(VirtualMachine.java:182)\nCould you check what code executes on this line on your installation?. I track the last version of the time of the issue to keep an overview.\nCan you check what AttachProvider.providers() returns for you? I would argue that this must be empty if null is returned.\nAre you sure that you are not running a non-JDK VM?. It seems like you are using a runtime that is bundled with IntelliJ, not the actual JDK. Can you double-check that you are running on the correct runtime?. From your JVM, just print System.getProperty(\"java.home\"). Then check this folder and see if the bin directory for example contains javac etc. Also check if it contains a tools.jar for Java 8.. This does not sound right. To work correctly, the attach mechanism needs to locate your JVM installation folder as specified in https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html. To work on Java 8, there must be a tools.jar file within the installation which is only the case for JDK builds. Have a look at the Byte Buddy code to see how this works.. The java.home property is set by the executing JVM, it is not equal to the JAVA_HOME property which is not required for running a JVM or JDK but rather a convention for tools like Maven or Gradle.\nAre you sure that you are running with the VM that you downloaded? You would need to change the JVM setting within Android Studio. Also, you you send me an overview of the folder structure for the JVM that is bundled with Android Studio? It seems to deviate, maybe I can add a location hint to Byte Buddy.. Could you run find . > output.txt on /Applications/Android Studio.app/Contents/jre and attach the resulting file to this ticket? I would like to have a look. And System.getProperty(\"java.home\") returns /Applications/Android Studio.app/Contents/jre/jdk/Contents/Home?. Android studio bundles a correct JDK. The file in question is at:\n/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/lib/tools.jar\nNormally, for MacOS, tools.jar is located relatively to java.home by navigating to ../Classes/classes.jar.\nBut you are saying that you get /system for java.home? That does not seem right. Is there any file /system/bin/java on your system?. I am trying to figure out how this is different in Android Studio compared to other JVMs.\nIs there a symlink /system/bin/java pointing to /Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/bin/java?. As an explanation for your problem: https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html\nThis is how the mandatory system properties are defined for Java and Android studio breaks this requirement. Could you attach another text file containing all contents of System.getProperties()?. Hm, there is nothing pointing me to anything useful here. I would recommend you to follow this up on an Android-studio related list. This is not at all what most Java programs expect and I would argue that other libraries then Byte Buddy would struggle with that.\nI will however add a possibility to Byte Buddy to specify the tools.jar location using a system property for cases like that. You can then run your tests with -Dnet.bytebuddy.agent.toolsjar=/some/location/tools.jar to make this work.. Its not a feature yet, you will have to wait for the next Byte Buddy release.\nIts strange that IntelliJ picks up the VM like that. Have you tried configuring a different JDK under your project setting?. In the 1.9.0 release next week, you will be able to set a custom tools.jar location using a system property (-Dnet.bytebuddy.agent.toolsjar=/location/of/jar). I think this is the best that I can do, from your setup it is impossible to locate the file without any user input. I still claim that this is a problem in Android studio as it does not fullill the JVM's contract for system properties. I recommend you to follow this up with the Android team.. It is now possible to provide constructor arguments via the Maven POM or the Gradle API and it is possible to inject the build-time specific logger, a BuildLogger or the File representing the target folder into a plugin's constructor. . This is because the class of value is not the same as that referenced in the field. If you call load without an explicit strategy, a new class loader is created with the provided class loader as a parent. If you include the dynamic type in the second class, this child class loader will load the first class individually.\nIf you called field.getType().newInstance(), it would work. Also, skip the first loading of a type to avoid the duplicate loading.. You just have to make sure that the second type can see the class loader of the first type. If you include a dynamic type in another one, you instruct the library to load them in the same class loader, no matter what strategy you are using. Have a look at ClassLoadingStrategy for considering your options.. Caused by use of old version.. This is because by .load(NumberFactoryTemplate.class.getClassLoader()), you create a new class loader using the default class loading strategy. At runtime, packages are only equal if they are defined by the same class loader such that the created class's package differs from the one of the redefined class.\nTo avoid this, you need to inject the class into the package of the loader of the anonymous class. You can use the INJECTION default strategy or, starting with Java 9, you can use a strategy using a method handle lookup to avoid the use of unsafe API.. The problem is that the original class defines an anonymous inner class. This class captures its defining class implicitly, if you look at the anonymous class's class file, you will see that it declares a constructor that takes NumberFactoryTemplate as an argument.\nBy replicating the original class, you do not change the anonymous inner class. You would need to define a similar class and use MemberSubstitution to replace the constructor call. This is however a bit of work and difficult to automate. Ideally, you refactor the code to avoid the anonymous inner class.. Add .asDecorator() after your first transformer.. Good point, I will add a constructor that takes both arguments.. I added a constructor which would allow:\ngroovy\nnew net.bytebuddy.build.gradle.PluginArgument(0, 'Foo')\nI am not sure if this allows you to apply the instance as a closure. Any suggestions?. I added a closure similar to the one for the plugin. Could you build from master and see if it works?. I think I prefer the style to be consistent throughout usages. I will release this within the next few weeks with the final ASM 7 version.. I have to wrap my head around this but I think that the pipe should accept accept the original type, not the proxy type. Could you run your app with -Dnet.bytebuddy.dump=/some/folder and send me the outputs?. The bytecode of the failed method is\ngetstatic \ninvokevirtual \nareturn\nThat is the code of the pipe proxy, it seems. When sending me the classes, please also reattach a stack trace such that I can map the message to the random suffixes.. Could you also double check that there is no other form of weaving on the server where the error occurs, maybe by a Java agent. You can make sure of this by specifying the method to delegate to on:\njava\nMethodDelegation.withDefaultConfiguration()\n                                   .withBinders(Pipe.Binder.install(Function.class))\n                                   .filter(named(\"intercept\").and(takesArguments(Function.class))\n                                   .to(interceptor);. So it does crash on your local machine? I thought this only happened on the server. Or are those the successfully running instrumentations?. I fully understand, I am sure that I can find out either way. Thanks for the dump, I am pretty certain that it is connected to cglib adding something that distracts the location mechanism. Could you try out filtering all methods but the delegation target? If that works, I pretty much know where to look.. I see what the problem is already, it is MethodDelegation.to(bean, RestTemplate.class) where the protected method call is delegated by accident. If you set isDeclaredBy(RestTemplate.class).and(isPublic()), the problem will no longer occur. I have to add a better access check to the Pipe component, the Java language does not allow such calls normally.\nIn this light, it is surprising that this works on your local machine. Does the Docker container run a very different Java version? Or is it just the Oracle build on the server while you use OpenJDK locally?. No, it is simply not allowed to invoke a protected method on another instance of a super class. Consider:\n```java\npackage foo;\npublic class Foo { protected void foo() { } }\npackage bar;\npublic class Bar extends Foo {\n  public static void main(String[] args) { new Foo().foo(); }\n}\n```\nThe call in Bar is not allowed as it comes from a different package. You might argue that the proxy is in the same package but since you are using a wrapper strategy, the runtime packages will not be equal. If you choose to use the injection strategy, I am sure it would work, too.\nThe JVM is required to throw an IllegalAccessError what is spec compliant. Seems like the Docker container runs a version that has a bug violating the spec where a verifier error is thrown instead.\nIn that context, there is not much that Byte Buddy can do as it does not know in what class loader a class ends up. But typically, there should only be an error if a protected method is called directly on the proxy class what should never happen. If you exclude the protected methods from your matcher, this should work for you, too, if they are never invoked directly.. As said, it is impossible to know for Byte Buddy what class loader is targeted. And there might even be an incompatible class change during generation and load. I will add something that throws an error if the method is at minimum package-private and in a different package what you can validate statically. Therefore, the best solution for you is to exclude protected methods from matching by setting .method(isDeclaredBy(RestTemplate.class).and(isPublic())). Or you can use the injection strategy where the generated class would actually be capable of intercepting the protected methods.. As a matter of fact, I already have a check for this, I just overlooked it.\nThe only reason that the delegation works is that the generated class and the base class are in the same compile-time package. The problem is that the runtime-packages are different where the JVM is supposed to throw an IllegalAccessError lazily but breaks in the verifier.\nOut of curiosity, what exact JVM version are you running in the container?. I have decided to only use some NIO2. For jar files, this is sometimes simply impossible since the ZipFileSystem of NIO2 requires directory entries. For the MANIFEST.MF file, this does not work as it must be the first entry while NIO2 would place the directory entry first. I use it for file copies, though.\nAs for your questions, I have answered them on the mailing list.. Could you run with the stacktrace option to see what this is about? I suspect the module-info.class.. Surely related to the module-info. Presumably, the plugin uses an outdated version of ASM or something is broken in my module-info. I will check this weekend. You can work around this by using byte-buddy-1.8.23 explicitly in the mean time.. Looking at tge exception, I am however fairly certain its the tool you are using. module-info is the only class file that contains package names. They probably do not know how to handle that . I meant 1.8.22. you depend on Byte Buddy via Mockito, I guess . I have validated the module-info class files and they are fine. I will however move them to a version-specific entry and publish Byte Buddy as multi-release jar. This should aid tooling to avoid such errors for now.. Same reason, though, the tool incorrectly handles module-info.class files. It should simply ignore them for Android.. Just pin Byte Buddy to version 1.8.22. Byte Buddy supports the Java module system from 1.9.0 up. I figure Android will slowly adapt to the new class files as those will pop up more and more so this will come up anyways. Ideally, Android will not stick on Java 7 forever to begin with.\nI do not think that this will cause any problems on Mockito in the log run as the newer APIs are not required and the major changes in Byte Buddy are extensions or support for new Java VM releases.. Byte Buddy is doing what you are telling it to do. If a method is not declared by a class, it needs to be reimplemented. Java, by default, does not inherit annotations on virtual methods or subclasses, Byte Buddy mimics this behavior. You can either:\n\nDecide to not override methods: Make your matcher more specific for that by also matchin isDeclaredBy(typeDescription).and(...)\nInherit annotations of overridden methods by .attribute(AttributeAppender.ForInstrumentedMethod.INSTANCE.. Glad I could help.. If the system class loader only gets the one class injected, then this will not work as the other classes are still missing from the system class path. You could rather create a new URLClassLoader that references the jar file and inject the class into this new class loader before loading any other class. Doing so, you are guaranteed to load the redefined class first without missing any references.. You can replace the entire method body with an Advice if that works for you. Or you can replace field accesses within a method using MemberSubstitution.. Advice cannot remove code somewhere in the method. Either, you have to reimplement that part in your advice or you need to use ASM.. In this case, you have to instrument the constructors. The Java language differentiates between compile-time constants (set with the fields) and other field assignments which are done in byte code. You can instrument the constructors of a class and set a fixed value using a FieldAccessor.. Please reopen this if you have further question.. You can define an advice class with Advice.OnMethodExit and override the return value from there using a parameter Advice.Return(readOnly = false).. Then you can either: Intercept the original code additionally to registering an advice and use StubMethod.INSTANCE. Or, register an enter advice where you skip the original method.. Glad I could help!. You are right about the folders, I added a check for them to ignore them for now, but I will need to reconsider this issue for the future. I am not yet entirely sure how to handle those, for jar files for example, a directory entry can contain any data and I would not want to loose such information.\n\nAs of now, I am neither sure on how to deal with ignoring resources, but I see the use case. I need to think about this for a bit but you can simply wrap the target and drop the elements that you do not want to keep but delegate the remainder to the original target.. Fixed on master.. My point of view is: I do not know how expensive the supplied matcher is so I assume that it is quite expensive and avoid calling it as good as I can. On the other side, if someone is really out after performance, those folks will often implement their own ElementMatcher anyways.\nDid you benchmark the usage?. I think that I will leave it the way it is, it is just simpler that way given that people might have started using it, expecting the optimization.. Advice works due to reusing compiled byte code; even if you parameterized the advice class, Byte Buddy could not simply \"copy-paste\" the code over. What you can do is to use Advice.AllArguments and change only specific argument values programmatically depending on what method you run.\nIf you need to provide method specific arguments to an advice, note that you can add your custom annotations using Advice.withCustomConfiguration().bind(...).to(MyAdvice.class).. Yes, you can bind any StackManipulation to a custom annotation. You will need to implement a custom binder that creates the array, have a look at ArrayFactory to create an int[]. Also, use standard iteration, lambdas create methods to invoke in the advice class that will not be accessible to your instrumented class.. Yes, this is right. All that is leat to do is to combine array factory with integer constant to produce a stack manipulation that loads the integers.. Please reopen the ticket if you have further questions.. You are probably looking for the Advice component which you can use in combination with the AgentBuilder.. The value part sets a compile-time constant value as the field's value. If you referenced the field from another Java class, it would copy that field value as a constant instead of reading the field. To really set the field's value, you have to do so in the constructor. For example:\n```java\nClass<?> target = new ByteBuddy()\n  .subclass(Object.class)\n  .name(\"com.test.MyClass\")\n  .defineConstructor(Opcodes.ACC_PUBLIC)\n  .withParameters(String.class)\n  .intercept(MethodCall.invoke(Object.class.getConstructor()).andThen(FieldAccessor.ofField(\"hello\").setsArgumentAt(0)))\n  .defineField(\"hello\", String.class, Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL).value(\"world\")\n  .make()\n  .load(ClassLoader.getSystemClassLoader()).getLoaded();\nObject targetObj = target.getConstructor(String.class).newInstance(\"world\");\nField f = target.getDeclaredField(\"hello\");\n  f.setAccessible(true);\n  System.out.println(f.get(targetObj));\n```\nThis defines a specific constructor.\nSetting a field value using the DSL does not currently allow for more flexibility e.g. setting a constant value but this is on my things to do. Alternatively, you can define your custom StackManipulation to do so.. This is not possible, the Java specification requires you to set a field value in the constructor. If you do not see this in your Java source code, it is because javac creates the constructor code for you.. Byte Buddy 1.9.3 does not provide extended support for setting field values via MethodCall and FieldAcessor. Please reopen this ticket if you have futher questions.. Yes, you are right. The member substitution component is still \"in the making\". I just added the possibility recently and it is not yet fully feature complete. That I opened the API without fixing this issue was an oversight that I need to adress in a future release.\nIf this is important to you and you are using it in a commercial context, let me know if you want to sponsor the work; otherwise I hope to make this right some time this year or early next year.. This is fixed on master, could you test it as Byte Buddy is not making use of this feature itself yet? Would help to double-check. Thanks!. Great, will be part of the next release! Thanks for reporting.. I would expect this; you are telling Byte Buddy to copt the methods of the instrumented method while you are not overriding it such that they end up being duplicated. If you skip the attribute appender, it should be fine.\nWhat is it you are trying to do?. Glad you figured it out. Thanks!. I assume this is due to the additional boxing. Rather define your interceptor method as:\npublic long enhance(@Argument long argument) {\n    return injector.elapse(argument);\n}\n\nAnd you should not see any difference.. You are still boxing the return type. But I am wondering how you measure that too. Byte Buddy is fairly well performance-tested, I would have seen issues with this mechanism. But if you box values, you get a performance penalty, this is just normal. It should however not be significant.. Can break some optimizations, the JVM can be particular. But you would need to benchmark that part if you wanted details.. Thanks, fixed on master an will be part of the next release.. Are you sure this is not related to a circularity? Byte Buddy uses strings to work and the string class probably defined lambdas. This strategy is a rather heavy interception for very narrow use cases, I expect it to fail sometimes.. Maybe the bridge methods reference a class that is then loaded and causes a problem. I find the error message strange about the indirect superinterface.\nI wonder if it would be sensible to just deactivate the bridge method generation for the lambda factory. But to be honest, I do not fully understand what the actual problem is.\nCould you create a small reproduction project for me to run? I would then try to debug this. . I think this is a class loading racing condition. The lambda meta factory is instrumented while the agent is loaded what probably causes the failure.\nAre you using this strategy in production systems? This is quite risky as the strategy is fairly instable to begin with.\nI do not have much time in the moment as this issue is so peticular but please send a PR my way and I will look into it!. There is nothing that should prevent that field from being transformed. \nDid you try to register a listener in the agent builder to see if any errors occur: https://github.com/eolivelli/tweakjava/blob/master/src/main/java/tweakjava/Agent.java\nUse for example AgentBuilder.Listener.StreamWriting.toSystemOut().\nAlso, why would you expect the field to be \"definalized\" in JUnit as you filter for annotated fields?. Please reopen this ticket if you have further questions.. You are right that this is not possible. Lambda classes are anonymous and cannot be a delegation target as they cannot be referenced. In this case, you must specify the class explicitly: MethodDelegation.to(hello, Say.class).. The problem is that there is no explicit API for it and another VM implementation might choose to do differently. I will improve this solution if I find a way of doing this without any possible (performance) regression. In the mean time, this remains your responsibility.. I just ran this example and cannot reproduce any error. Are you running any form of code coverage tool from your IDE maybe?. I have not had proper time to investigate this in detail but as said, I have trouble reproducing this. What IDE and exact JVM version are you using?. I got it running and I am planning to fix it, sorry for the delay.. By the way, it took me a while to understand this to begin with and it lead me to a bug in javac that has always existed. javac does not create a visibility bridge what makes it impossible to call operation reflectively from outside the package. If you remove the generic type, javac creates the access bridge as you would expect it. Byte Buddy is in a way fixing the missing bridge by accident. I have to add means to explicitly skip the bridge creation what is a bit tricky as it might come from a change in the type hierarchy that was explicitly requested as for example by adding an interface.\nI have also reported this issue to the OpenJDK so this problem will hopefully disappear away either way but I think that I can add a solution in Byte Buddy.. Ok, this turns out to be a bug in Java 8 that was not backported after being fixed in Java 11. Technically, the visibility bridge needs to be there and Byte Buddy adds it since it cannot know that the original class file was based on the same subclass.\nIt is of course unfortunate that this happens. For your use case, could you use the decorate option to avoid this? It would improve performance over redefine but allow class file changing operations. It is mainly meant for folks that just want to use advice.. You can now set VisibilityBridgeStrategy.Default.NEVER on the ByteBuddy instance.. Jap, my bad. This loop was quite performance heavy, went for the pretty solution and got the bill right there. I am adding a test for an instrumentation of a large class and release a new version right after.. That said, I am wondering why the duplication filter does not kick in. Normally, Byte Buddy checks if an Implementation was applied previously. Even with a lot of methods, I would expect that the implementation only would be applied a single time. I will look into this as well before publishing.. @gsmet, @Sanne: The InlineDirtyCheckingHandler should really implement hashCode and equals methods. Doing so, Byte Buddy will detect equal handlers and only prepare them once. This is true for any custom Implementations. Nevertheless, my fix will speed up things.. I just released Byte Buddy 1.9.4 with the fix for the issue. I still recommend you to add hashCode/equals to all custom implementations to avoid duplicate preparation.. Glad it was so easy! Let me know if you find anything more, I added another test for a \"huge class\" instrumentation but those are sometimes difficult to find.. Very welcome, happy to help!. This is a tiny bit tricky since methods do not inherit annotations. You will need to browse the type hierarchy to discover this. Byte Buddy does not offer a matcher for this but you can implement your own matcher to achieve this. You will need to take the method's declaring type and walk up the type hierarchy for all classes and interfaces to see if any of them declare a method with the same signature (check if the method tokens are equal) and declares @Say.. Are you sure that you are running on a JDK? This will not work on a regular JVM/Android.. Please reopen the ticket if you have further questions.. You can add a TypeConstantAdjustment visitor as your first visitor. This would fix this issue. Otherwise, you can add a raw matcher and read the class file version out of the byte array provided to it if you wanted to ignore classes of given versions. This is also where you could do the logging.\nThe verifiy error points to this issue, too. I bet that adding the adjustment solves all issues.. You are right, I remember that I considered providing the argument. I think that I found that parsing all class files that walk through the transformer played out quite desastrous for performance which is why I hesitated but if you exclude enough classes it should just work.\nI cannot really add the method as this would break with the abstraction between loaded and unloaded classes and it would require keeping a reference to the array what could cause massive leakage.\nWhat you could do would be add an ASM visitor wrapper and to throw an exception (make sure to disable the stack trace capture, forth argument of the runtime exception constructor) when you discover the version in the visitor. This might sound expensive as you are using exceptions for control flow but it will still be much cheaper then parsing the byte array twice.. You can register multiple visitors on the DynamicType.Builder that is provided by the transformer. They are applied in registration order.. Did you solve your problem? Or did you intend to post this to skywalking?. I just released 1.9.5 with the fix.. Thanks, I did a few changes around the testing, I rather generate the class, but otherwise, great. Thanks for providing a fix!. How urgent is this? I can make a quick release tonight but I would ideally fix another minor issue before that I planned to solve early next week.. It is legal for methods that are defined in a static block or inside a constructor block. \nI can neither reproduce this behavior:\n```java\npublic class Foo {\n    public static void main(String[] args) {\n        byte[] x = new ByteBuddy().redefine(Bar.class).make().getBytes();\n        ClassReader r = new ClassReader(x);\n        r.accept(new TraceClassVisitor(new PrintWriter(System.out)), 0);\n    }\nclass Bar { }\n\n}\n```. Are you running the latest version of Byte Buddy? I cannot reproduce this even with your directly copied code. Also, what Java version are you running? That might make a difference in the original class file.\nI have the following output:\n```java\nclass Foo {\npublic static void main(String[] args) throws IOException {\n    System.out.println(\">> ORIGINAL CLASS:\");\n    byte[] originalBytes = ClassFileLocator.ForClassLoader.read(Foo.Bar.class);\n    traceClass(originalBytes);\n\n    System.out.println(\">> REDEFINED CLASS:\");\n    byte[] transformedBytes = new ByteBuddy().redefine(Foo.Bar.class).make().getBytes();\n    traceClass(transformedBytes);\n\n    System.out.println(\"Unchanged: \" + originalBytes.length == transformedBytes.length);\n}\n\nprivate static void traceClass(final byte[] bytes) {\n    ClassReader r = new ClassReader(bytes);\n    r.accept(new TraceClassVisitor(new PrintWriter(System.out)), 0);\n}\n\nstatic class Bar { }\n\n}\n```\nresulting in:\n```\n\n\nORIGINAL CLASS:\n// class version 49.0 (49)\n// access flags 0x20\nclass Foo$Bar {\n\n\n// compiled from: Foo.java\n  // access flags 0x8\n  static INNERCLASS Foo$Bar Foo Bar\n// access flags 0x0\n  ()V\n   L0\n    LINENUMBER 29 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object. ()V\n    RETURN\n   L1\n    LOCALVARIABLE this LFoo$Bar; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n}\n\n\nREDEFINED CLASS:\n// class version 49.0 (49)\n// access flags 0x20\nclass Foo$Bar {\n\n\n// compiled from: Foo.java\n  // access flags 0x8\n  static INNERCLASS Foo$Bar Foo Bar\n// access flags 0x0\n  ()V\n   L0\n    LINENUMBER 29 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object. ()V\n    RETURN\n   L1\n    LOCALVARIABLE this LFoo$Bar; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n}\nUnchanged:  true\n``. Thanks for verifying! The update to 1.9.* should be fairly easy, just send a PR to stagemonitor!. You can trigger a retransformation manually by callingInstrumentation::retransformClasses`. All you need to do is to reregister a changed class file transformer by using the same API, this way you can update any delta. Alternatively, you can register a mutable matcher in byte buddy, as long as it is thread safe.. On a retransformation, all classes that are retransformed walk through the same transformer chain as before. If you registered a new class file transformer, any class that would now result in a different state will have changed as a result of the retransformation. Those who would not change do not need to be retransformed as the retransformation result would be the same.\nThis can be achieved by either creating a new class file transformer or by mutating a transformer that was previously registered.. Hi, the semantics follow that of the @Inherited annotation where @Deprecated is not marked as such. In Java, it is insufficient to simply subclass an annotated class, that annotation must be eligable for such inheritance. Simply iterate over the hierarchy:\ntypeDescription.stream().anyMatch(type -> type.getDeclaredAnnotations()\n              .ofType(Deprecated.class) != null). Glad you like the library. I am not sure that this is a bug in Byte Buddy, it is not possible to locate class files of classes that were appended to the bootstrap class loader (this is why the corresponding method is called \"appendToBootLoaderSearch\" with emphasis on the search-bit.\nIn this case, you would need to adjust the class file locator that is provided to the agent where it would make a normal lookup but also check the location of your boot jar for class files. There is no other way around it.. Because during the instrumentation of A, Byte Buddy receives the class file representation by the class file transformer. During the instrumentation of B, it must query the class loader which cannot locate the class for the mentioned reasons.. What do you mean by \"not fail\"? Byte Buddy is already resolving all types lazily, if it is asked for example if a certain type is a subtype of another type, there is no way around it. If you want to ignored failed resolutions in matchers, have a look at ElementMatchers::failSafe.\nI would recommand you to register your jar into the class file locator that is used, that way, Byte Buddy will not have any issues.. Can you send me a stack trace?. When you define the agent builder, set a byte buddy instance with a method registry compiler for declared methods only. This is if you do not override methods in the agent  but only change existing code.. Please reopen the ticket if you have further questions.. That you change the pool strategy should not make a difference as Default.FAST already is the default setting.\nMight it be that using redefinition in the one agent and retransformation in the other makes the difference? I would guess that this affects agent ordering.. Please reopen the ticket if you have further questions.. Hi, Byte Buddy's API is immutable. You need to assign the result of:\njava\nagentBuilder = agentBuilder\n        .type(ElementMatchers.isSubTypeOf(Thread.class))\n        .transform(new Transformer());\nback to the variable.. Please reopen the ticket if you have any further questions.. Hi, the Nexus reference is kept until the class in question is running its static initializer. If this fails, the Nexus has no way of knowing if a class is already loaded as there can go a lot of time between instrumentation and actual loading. \nOn scale, it is the best if you avoid the nexus altogether and rely on instrumentations that do not require a live initializer. This way, you can avoid this other unsolvable problem.. It is not possible to use a weak reference as the instance only exists in the Nexus. The Class instance is not available during instrumentation as the class is not yet loaded during instrumentation.\nByte Buddy will add a call to the Nexus as a first instruction to the static initializer block. To assure that this works for any class loader, a well-known class loader must be used which is the system class loader in this case.\nThe problem that can occur: if a class is never initialized then the Nexus reference remains and this seems to be happening in your case. The loaded type initializer is used for initializing auxiliary types but you can use InitializationStrategy.Minimal to preload classes. This does however only work if those classes do not cause any premature loading of the instrumented class which is fortunately not the case for most auxiliary classes.. In this case it seems that you have a hard requirement to only load the auxiliary classes after the instrumented class was loaded. All you can do is to refactor your code to resolve this requirement or to run a different initialization strategy (it is an interface) where you have better grip of the life cycle as Byte Buddy can offer for the general case.. Without any callbacks, your code should work just fine. Did you import the correct Origin annotation (within Advice)? There is another annotation for method delegation that would not work.\nYou can register a listener to the agent builder that prints any possible exception that might explain to you what the problem is. If you are using advice, the entire injection bit should be unnecessary.\nIf you want to exchange the print command with a callback bundled with your agent you need to however apply the suggestion of @jpfourny.. Is the class you expect showing up when you add the listener? maybe it is already loaded, you need to enable retransformation in that case. . Also set: .disableClassFormatChanges() and also check the log output for what is happening to the type. All types should be supplied to the listener upon discovery.. I think that the problem is that ArrayList is used by Byte Buddy internally and is loaded during registering the transformer. This also applies to other types but the system is not perfect, unfortunately.\nYou can use .with(AgentBuilder.RedefinitionStrategy.DiscoveryStrategy.Reiterating.INSTANCE) after setting the retransformation strategy. But the class might stil miss if it is loaded after the reiteration. In this case, you have to call retransformClasses(ArrayList.class) manually after registering the transformer. . Glad you figured it out, I was on Christmas vacation, therefore I did not answer you in time.. I assume that your method is not available to the bootstrap class loader. This is typically the case if your method is part of your Java agent that is loaded by the system class loader.\nYou have to put your runtime code into a seperate jar file and attach this jar to the bootstap loader search path using the Instrumentation instance that is provided to your agent.. Your agent is loaded on the system class path, I assume that Spring Boot is run on a different class loader. The only class loader that is universally visible is the bootstrap loader.. You have to create a jar file that contains your shared code and append it to the bootstrap class loader search path using the Instrumentation instance that is provided to your agent.. You probably duplicate your code somehow.\nMake sure you have to cleanly seperate jars, one for the instrumentation, one for the runtime interception. Make the first jar only depend on the second via a provided scoped dependency.\nAttach the second jar before you even load any of the code that will later refer to it. Keep your agent code fully seperate.. Thanks a lot, good catch!. Bootstrap injection only injects any generated auxiliary classes into the bootstrap loader as they are created. It does not inject the Stub class, only the glue classes (the proxies for example generated for implementing SuperCall). Byte Buddy has no chance to know what classes are required for Stub, this is why Byte Buddy does not attempt solving this problem but required you to do so.\nYou can of course use Byte Buddy's convenience APIs as you suggested to inject selected classes.. I assume that you are using rebasing together with an interceptor? In this case, you are correct. Spring is in a way applying a hack here where the name is extracted from the debug attributes for the method. If the method is rebased, this debug attributes are also moved.\nJava 8 added an official way of adding names for parameters by compiling with the -parameters flag what also improves performance slighly if you enable it. This should not be affected.. I think this is the way to go here, remapping debugging attributes would just result in a mess.. I feel your frustration. I reported over 25 bugs regarding type annotations up to today, it does not feel like this was tested properly. However, I just tried a reproduction of your example and it seems to work:\n```java\npublic class Sample {\npublic static void main(String[] args) {\n    TypeToken token = new TypeToken<@FuckingTypeAnnotation Object>() { };\n    TypeDescription td = TypePool.Default.ofSystemLoader().describe(token.getClass().getName()).resolve();\n    AnnotationDescription desc = td.getSuperClass().getTypeArguments().get(0).getDeclaredAnnotations().get(0);\n    System.out.println(desc);\n}\n\nstatic class TypeToken<T> { }\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE_USE)\n@interface FuckingTypeAnnotation { }\n\n}\n```\nThe type path does not look right, as you say, but what you see is exactly what Byte Buddy extracts from the class file, if it is there like that, it seems like you are running a defect version of javac. Which version are you using?. Now I know what bug you are hitting. Unfortunately, the type annotation is written to the wrong attribute. This is a bug in javac (that I actually reported when I implemented support for type annotations) which was unfortunately only solved in JDK 10 but not backported.\nIf you run the same code on JDK 11, everything works as expected.. This is due to type initiailzers not being rerun on a redefinition.\nYou can make this behavior obvious by adding a type initializer to both Foo and Bar where only the initializer of Foo will be run once. Therefore, you would need to explicitly change the field value.. As a start, you should not instrument the Byte Buddy classes, this might initiate this problem.. One last exclusion before I look into it: Please exclude synthetic types as you might hit Byte Buddy proxies that live in different packages,. Have a look at Plugin and Plugin.Engine which allow you to run trasformations from a Gradle plugin, a Maven plugin, the command line or embedded in another application.. You can use MemberSubstitution to replace the method call for doSomething2() by doSomething2() followed by doOtherThing(). Note that this still requires supplying a custom stack manipulation, this component is still in its infancy but for an easy case, this can be done.\nByte Buddy does not allow for adding information at a line number as this is not a stable location in a compiled class. You can implement it yourself by using the underlying ASM API.. Thanks, I thought of that but never prioritized it.. In this case, you need to access the instance on which the method is invoked and check for its type:\njava\npublic class MyAdvisor {\n    @Advice.OnMethodEnter\n    public static void test(@Advice.This Object self) {\n      if (self instanceof Bar) {\n        System.out.println(\"hack\");\n      }\n    }\n}. This is available via the TypeDescription API. If you want to read them using debug symbols, you need to use a TypePool.Default implementation using ReaderMode.EXTENDED where you can access the symbols via the ParameterDescription on a MethodDescription declared by this type.. You can register custom annotation bindings using Advice.withCustomConfiguration().bind(SomeAnnotation.class, binding).\nJust implement something that extracts the method name during instrumentation. Doing so, you only have to pay the costs for looking up a parameter name a single time.. Use:\njava\nAdvice.withCustomMapping().bind(SomeAnnotation.class, new OffsetMapping() { ... });\nIn the offset mapping, you have the instrumented method available. If the class is already processed using Byte Buddy's type pool with extended parsing, the debug information should be available.. Yes, the agent builder provides the instrumented type and dependants, the advice provides the advice class. . For this you would need to use ASM. Byte Buddy is mainly focusing on instrumenting shapes of types which are stable. The closest you can get is to use MemberSubstitution that allows you to do instrumentation based on method calls and field accesses. I would not recommend you to change in-method code as such instrumentations are notoriously instable.. Yes, please refer to the documentation at bytebuddy.net for such information.. This is probably due to a class loading iregularity or your debugger is doing a retransformation that conflicts Byte Buddy. Try using a retransformation as a strategy instead.. Does this also happen when you run the application outside of an IDE? I assume that there is another agent active that overrides your instrumentation.. IntelliJ attaches agents of its own, I assume this is where the problem roots.. That is really very IntelliJ specific, I have no idea, to be honest.. I experience the same issue on my CI servers which is why I do not build the plugin there. It is however annoying me and I wish I would find out what the problem is as this used to work but I cannot reproduce the problem locally.\nI assume that there is something wrong with the Maven-to-Gradle integration. If you have a chance to debug this, I would be very grateful. Otherwise, this is not a problem to worry about.. Thanks for the reproduction, this gives me a chance to look into it.\nThis is really strange, to be honest. Byte Buddy is fully immutable and I would not even know what could cause a race condition here. I wonder if Kotlin is doing some magic but I will know more once I got the chance to check.. This must be one of the strangest issues in quite a while. I reduced the reproduction to:\n```java\npublic class ProblemWithSubclassingKotlinCode {\npublic static void main(String[] args) throws Throwable {\n    try {\n        Class<? extends Channel> cls = new ByteBuddy()\n                .ignore(ElementMatchers.none())\n                .subclass(Channel.class)\n                .method(ElementMatchers.named(\"cancel\"))\n                .intercept(StubMethod.INSTANCE)\n                .make()\n                .load(ClassLoader.getSystemClassLoader(), ClassLoadingStrategy.Default.INJECTION)\n                .getLoaded();\n\n        cls.newInstance().cancel();\n        System.out.println(1);\n    } catch (Throwable error) {\n        try (PrintWriter pw = new PrintWriter(\"error.txt\")) {\n            error.printStackTrace(pw);\n        }\n        System.out.println(0);\n    }\n}\n\n}\n```\nand it still fails. If I replace Channel with Callable for example, the problem goes away.. I found the issue, it is because of Kotlin's declaration of kotlinx.coroutines.channels.ReceiveChannel. It declares two methods:\njava\npublic abstract void cancel();\npublic abstract boolean cancel();\nWhile the JVM supports methods differing only by return type, the Java language does not and neither does the reflection API which Byte Buddy relies on. The result of the instrumentation will depend on the order those two method representations are added to a tree map which makes the outcome random where the other method is discarded as an incompatible covariant override attempt. The Java language always chooses to invoke the void method in this case but Byte Buddy chooses randomly which one to instrumented by said tree map order.\nYou might be able to work around this by registering MethodGraph.Compiler.Default.forJvmHierarchy() which forces Byte Buddy to consider the return type when distinguishing methods but this way you will also miss covariant overrides such as when overriding a method returning Object to return String instead.\nAll in all I consider this a bug in Kotlin, it should not allow to declare methods with the same name as it is not defined which method would be invoked from the Java language when both methods are declared.. This needs to be adressed in Kotlin or by explicit bridge method handling.. A common solution for this problem is to put your interception logic into a jar of its own that you then load on the bootstrap class loader using Instrumentation::appendToBootSearchPath.\nThe boot loader is the only one that is universally visible.. I am not sure what you mean by \"snippet\". ByteBuddyAgent is released on Maven Central as byte-buddy-agent.. Those methods are final to avoid them being proxied or overridden. They are needed to retain the original functionality of the method's implementation.\nThe dispatcher classes are runnable and callable to allow for injecting the proxy for parameters of those types. . Hi, I think you want to:\n```java\n@RuntimeType\npublic static String intercept(@AllArguments Object[] allArguments,\n                                 @SuperMethod Method superMethod,\n                                 @SuperCall Callable<?> callableMethod,\n                                 @This Object self) throws Exception {\n  return (String)  superMethod.invoke(self, allArguments);\n}. Glad it works! . You are right, this is an overly strict visibility check that does not properly consider constuctors. I fixed a false negative in this release and introduced a false positive. Will be fixed in the next release.. Fixed on master for the next release.. You are right, thanks for pointing that out. It will be fixed in the next release.. This issue is a bit confusing as this method should exist as of Java 9. \nCould you ask your customer to get hold of the exception, e.g, by setting a breakpoint. I would not know how this can even happen.. Ah, I have not considered that you are on the boot loader.\nI do not want to add a compile-time dependency to Java 7 as I still rely on testing the build on 5 and 6 but I can override the mechanism when loaded on the boot loader.. You are welcome. It's fixed on master and will be part of the next release, so I am closing this. Can you use JitPack in the meantime since you are shading anyways?. GitHub pages does not update if you add to much code without much of a warning. I had to delete some old javadoc from the page to get things released. Thanks for the heaps up!. You are right, it should be toConstructor.. I think the module dependency is declared to be static as it is possible to attach when including a Linux socket connection or a custom attachment mechanism. Could you give me the stack trace to better understand what happened?. I will consider changing the message but I think I should make the javadoc more clear.. I clarified the javadoc.. This is an oversight, I just did never test the shaded jar properly, sorry for that. I just fixed this and will make a new release some time soon.. No, i 1.9.9, I am using the milestone as a marker for when the issue was found to keep track, not really intuitive if you do not know it, sorry, I cannot change the labels.\nI'll release 1.9.10 today.. I do not think that what you attempt can work. By merging two advice classes, you are loosing all the information on the \"speciality\" of the parameter access. If an advice class is applied, Byte Buddy knows that some variable offsets need to be treated specially as they only exist virtually.\nIn a regular method context, those offsets will appear as if they were regular local variables what is what you are observing.\nYou can advice an advice class but all will apply on the advice method and no longer get translated specially one you apply the adviced advice. \nAt least this is what I see from the code you have sent me. If you still think that this should work differently, maybe you could create a small reproduction of the problem? This way, I could look into it and explain in detail what the problem is.. Oh, I am glad you were able to solve this, of course, now that you say it, it makes perfect sense. I have not thought of this myself.. This is not currently possible but might be a valuable extension. I think I could include an API that allows to chain Advice using something like Advice.to(...).andThen(Advice.to(...)).on(...) where the @Local values from the first advice were accessible to the second one. \nI need to rework some of the Local handling at some point anyways and I will try to include this as a feature.\nIn the mean-time, you can implement a custom binding where you use ASM to read from a given offset where the local variables are stored if you know that some advice is applied before a second one. It should not be too hard to implement but obviously, Byte Buddy will not warn you from generating illegal byte code.. I assume that it might not be possible to start a process on AWS? It is unfortunately required to attach the agent on JVMs post 8: https://github.com/raphw/byte-buddy/blob/master/byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java#L476\nYou can set -Djdk.attach.allowAttachSelf=true during your build to avoid this requirement.. Byte Buddy needs to start a helper process as the JVM forbids to attach to your own JVM unless this property is set. However, it seems like it is generally not possible to attach in your enviornment, maybe the JDK being used does not include the attachment API? If its a linux machone, you can include this as a test dependency where Byte Buddy attempts emulation: https://github.com/raphw/byte-buddy/blob/master/byte-buddy-agent/pom.xml#L32. I assume that it is caused by some environmental restriction enforced by Amazon to using the attach API. You could also try to find out if java.home is set to a strange property on AWS as it is required to resolve a location. . That is interesting. Could you set some breakpoints throughout ByteBuddyAgent and check which attachment provider is used? . You can enable bootstrap injection in the agent builder API.. In this case, add your interceptor to a seperate jar and include it on the boot path using Instrumentation. appendToBootSearchPath. Use an AgentBuilder.Default, match all types annotated with Foo using an ElementMatcher and use the defineMethod API. You would probably need to combine some StackManipulations to write such a custom expression efficiently. Have a look at FieldAccessor and MethodInvokation as well as TextConstant.. On second thought, you can do all this using MethodCall. The outermost call is println on System.out. As an argument, you use the result of another call whete you nest invocations on a constructed StringBuilder and its append methods that you complete with a call to toString. . To create a StringBuilder you call MethodCall.construct(StringBuilder.class.getConstructor())\nYou can then call the append to the string builder like: MethodCall.invoke(StringBuilder.class.getMethod(\"append\", Object.class)).onMethodCall(...).withField(...) where you start with the initial string builder and then reiterate for every field or constant supplying the last input to the next instance.\nYou would have to adjust the method based on the field type, if the type is primitive, for this to work. In the end, you have to do a final method call on toString.. Ok, I was dumb here. I assume that Datadog runs Byte Buddy on the boot loader where the class loader now differs such that the field is no longer visible. I need to move the constant to the accessor, of course.\nI will fix this in the next version.. You can scan the DD jar and disable the nexus using the property in the rebased namespace. I am pretty sure you do not need it there.. I fixed the issue on master, if you use the snapshot version in the mean-time, this should also solve your problem!. There is no straight-forward way to do this since you have no guarantee that Foo and Bar are compatible but in theory, you can create a new DynamicType.Builder from the transformer as you already demonstrate creating one. Skip everything from the call to make and return it from the transformer.. I have answered you on StackOverflow: https://stackoverflow.com/questions/54968317/how-to-use-agentbuilder-replace-the-method-of-class/55032434#55032434. If you want to implement more complex method implementations like the ones you mention, you would need to assemble StackManipulations that represents the above code.\nMainly, you would need to look into FieldAccessor to get and set fields and into MethodInvocation to create the synthetic class.. Unfortunately, not all too much. The best source is the javadoc of those classes. You basically have to make your own Implementation.Simple where you provide the byte code using the mentioned instances. You should read up the basics of byte code to make sense of it. ASM has a great tutorial.. I assume your advice requests a Method as an injected parameter while you are instrumenting a Constructor.. The value indicates what index the argument has that you require.. yes. . What have you tried? You would need to run a Java agent for this.. Byte Buddy needs to redeclare methods if you instrument them as a class manipulation of a given class cannot affect its super classes. What are you trying to do? Maybe there is a better way.. You can think of Byte Buddy as a tool that allows you to write Java code at runtime. If you redeclare a method, it is like implementing it in the class you are instrumenting. By redefining methods, you replace the original methods; by rebasing them, you copy the original code to another method and reimplement the method with the original signature. By subclassing a class, you are doing exactly that.. The module-info.class should apply to all versions starting from Java 9 and older if class loaders adhere to the standard. I am however aware that there is an issue with the folder entries currently missing. I just updated the plugin that I use for generating the module-info to generate these entries.\nCould you try building Byte Buddy but with setting the modulemaker-maven-plugin to version 1.7? Does it work for you then? . That said, using Byte Buddy 1.9.10, I have no problem loading the module-info.class that is included in the jar file.\nWhat is your setup that displays this behavior?. I had a case reported that OSGi-based applications require a folder structure present in the jar to discover any entries within these folders. Since Byte Buddy is Java 5 compatible, I am injecting a module-info.class using a tool that does not create this folder structure which I have now fixed in the tool. With Eclipse being based on OSGi, you might just discover this problem.\nTherefore, I was wondering if you could try Byte Buddy with the updated plugin. For this, you only need to build Byte Buddy and try out the snapshot-version to see if the module-info.class is discovered correctly this time.\nIn any way, this is to be considered a bug in Eclipse as the JVM is capable of discovering the module-info.class even without the folders present.. Great, thanks, I will release a new version in the next days.. Instrumentation is expensive and the fewer classes you choose to transform the less work has to be done in terms of I/O or the JVM runtime. This is mainly about performance but also about observability.. This is an issue in Hibernate, I reported it here: https://hibernate.atlassian.net/browse/HHH-13324. Yes, this behavior is normal as the class preparation and the method instrumentation are seperate steps in the process. This is a conscious choice as instrumentations might add methods under the instrumentation process which could not be supported if the field was missing at this stage.\nYou could also wrap the delegation in your own Implementation instance where you only delegate if the instrumented type is matching a certain form.. This is an emberassing hole in the API as this should of course be possible but was not thought of as the annotation capabilities were added after the method interception. I will need to adress this some time.\nIf it works for you, you can rebase a class and use SuperMethodCall.INSTANCE as the interception.. Do you want to instrument all subclasses? In this case, your matcher needs to reflect that: hasSuperType(named(\"...\")). The file is fully optional and should only be processed by Java-9-capable modular class loaders. That Tomcat picks it up and parsess it despite being in the META-INF is a bug in Tomcat that you should report. The contract of META-INF is that it does not contain class files, a requirement that was weakened with Java 9 that supports multi-release jar files where the versions folder is a magic location known to the JVM.\nYou can remove the file if it serves your purpose. Byte Buddy does not rely on it at all.. I do not want to use this syntax as it will create an additional class, this should rather go into a static initializer.. This should probably just return a TypeDescription. The implementation should not be exposed.. Should probably also go into the ForLoadedType class.. A particular test is not necessary here, this is an implementation detail that should be able to be switched out without noticable changes.. ",
    "jhalterman": "Ah, I assumed that the package was always the same as the superclass and that the naming strategy was just for the class name. Good to know.\nSo using a fully qualified subclass name, things work well, but only if I use ClassLoadingStrategy.Default.INJECTION. Why is this?\n. Good info. I recalled that Guice uses a separate class loader for instrumenting/proxying classes/methods that are not private/package-private and the user classloader for everything else. A hybrid strategy like that is something I might need to look into.\n. Thanks for addressing this.\nRight now I'm constructing proxies via reflection which has various pitfalls, mostly around constructors that take parameters, which I'm usually able to deal with, and those which perform side-effects. This hasn't hit me too much in practice, but it does occasionally. Objenesis would be a great alternative, but so far I've been hesitant to rely on something like sun.musc.Unsafe. I noticed your blog post which mentioned it may become part of the JDK API for 9, so I think it's worth considering now.\n. I think you're right. Thanks for getting me thinking about this!\n. ",
    "binkley": "Thanks!\nThat I can tell I am unable to create new methods, only to\noverride/implement existing methods.  For example I tried making an \"a()\"\nmethod to access the \"a\" field on a class extending Object, and discovered\nthe \"a()\" method is always not found.\npackage lab.bytegen;\nimport net.bytebuddy.ByteBuddy;\nimport net.bytebuddy.instrumentation.Instrumentation;\nimport net.bytebuddy.instrumentation.Instrumentation.Context;\nimport net.bytebuddy.instrumentation.Instrumentation.Target;\nimport net.bytebuddy.instrumentation.method.MethodDescription;\nimport net.bytebuddy.instrumentation.method.bytecode.ByteCodeAppender;\nimport net.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;\nimport net.bytebuddy.instrumentation.method.bytecode.stack.member.FieldAccess;\nimport net.bytebuddy.instrumentation.method.bytecode.stack.member.MethodInvocation;\nimport net.bytebuddy.instrumentation.method.bytecode.stack.member.MethodReturn;\nimport net.bytebuddy.instrumentation.type.InstrumentedType;\nimport net.bytebuddy.instrumentation.type.TypeDescription;\nimport net.bytebuddy.jar.asm.MethodVisitor;\nimport net.bytebuddy.modifier.FieldManifestation;\nimport net.bytebuddy.modifier.TypeManifestation;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport static java.lang.System.out;\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.singletonList;\nimport static net.bytebuddy.ClassFileVersion.JAVA_V8;\nimport static net.bytebuddy.dynamic.ClassLoadingStrategy.Default.INJECTION;\nimport static net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy.Default.NO_CONSTRUCTORS;\nimport static net.bytebuddy.instrumentation.method.bytecode.stack.member.MethodVariableAccess\n.INTEGER;\nimport static net.bytebuddy.instrumentation.method.bytecode.stack.member.MethodVariableAccess\n        .REFERENCE;\nimport static net.bytebuddy.instrumentation.method.matcher.MethodMatchers.isConstructor;\nimport static net.bytebuddy.instrumentation.method.matcher.MethodMatchers.isMethod;\nimport static net.bytebuddy.instrumentation.method.matcher.MethodMatchers.named;\nimport static net.bytebuddy.instrumentation.method.matcher.MethodMatchers.returns;\nimport static net.bytebuddy.instrumentation.method.matcher.MethodMatchers.takesArguments;\nimport static net.bytebuddy.modifier.Visibility.PRIVATE;\nimport static net.bytebuddy.modifier.Visibility.PUBLIC;\n/\n- {@code WriteAClassMain} needs documentation.\n  \n- @author B. K. Oxley (binkley)\n- @see How in Java to assign to fields with Byte Buddy?\n/\n  public final class WriteAClassMain {\npublic static void main(final String... args)\n          throws Exception {\n```\n  final Class<?> aClass = new ByteBuddy().\n          subclass(Object.class, NO_CONSTRUCTORS).\n      classFileVersion(JAVA_V8).\n      modifiers(PUBLIC, TypeManifestation.FINAL).\n\n      name(\"foo.AClass\").\n      defineField(\"a\", int.class, PRIVATE, FieldManifestation.FINAL).\n\n      defineConstructor(singletonList(int.class), PUBLIC).\n\n      intercept(new IntFieldInterceptor(\"a\", IntFieldPutter::new)).\n\n      defineMethod(\"a\", int.class, emptyList(), PUBLIC).\n\n      intercept(new IntFieldInterceptor(\"a\", IntFieldGetter::new)).\n\n      make().\n      // saveIn(File file).\n      load(WriteAClassMain.class.getClassLoader(), INJECTION).\n\n      getLoaded();\n\nfinal Object o = aClass.\n          getConstructor(int.class).\n      newInstance(3);\n\nout.println(Arrays.toString(aClass.getDeclaredFields()));\n  out.println(Arrays.toString(aClass.getDeclaredConstructors()));\n  out.println(Arrays.toString(aClass.getDeclaredMethods()));\n  final Field a = aClass.getDeclaredField(\"a\");\n  a.setAccessible(true);\n  out.println(a.get(o));\n  ```\n}\nprivate interface I {\n      ByteCodeAppender i(final Target instrumentationTarget, final\n  String name);\n  }\nprivate static final class IntFieldInterceptor\n          implements Instrumentation {\n```\n  private final String name;\n  private final I i;\nIntFieldInterceptor(final String name, I i) {\n  this.name = name;\n  this.i = i;\n\n}\n@Override\n  public InstrumentedType prepare(final InstrumentedType\n  ```\ninstrumentedType) {\n```\n      return instrumentedType;\n  }\n@Override\n  public ByteCodeAppender appender(final Target instrumentationTarget) {\n  return i.i(instrumentationTarget, name);\n\n}\n  ```\n}\nprivate static final class IntFieldPutter\n          implements ByteCodeAppender {\n```\n  private final Target instrumentationTarget;\n  private final String name;\nIntFieldPutter(final Target instrumentationTarget, final String name) {\n  this.instrumentationTarget = instrumentationTarget;\n  this.name = name;\n\n}\n@Override\n  public boolean appendsCode() {\n  return true;\n\n}\n@Override\n  public Size apply(final MethodVisitor methodVisitor, final\n  ```\nContext instrumentationContext,\n              final MethodDescription instrumentedMethod) {\n          final StackManipulation arg0 = REFERENCE.loadFromIndex(0);\n          final StackManipulation iArg1 = INTEGER.loadFromIndex(1);\n          final StackManipulation.Size size = new\n  StackManipulation.Compound(arg0,\n                  MethodInvocation.invoke(new\n  TypeDescription.ForLoadedType(Object.class).\n```\n                      getDeclaredMethods().\n                      filter(isConstructor().\n                              and(takesArguments(0))).\n                  getOnly()), arg0, iArg1,\n\n```\nFieldAccess.forField(instrumentationTarget.\n```\n              getTypeDescription().\n              getDeclaredFields().\n              named(name)).\n              putter(), MethodReturn.VOID).\n          apply(methodVisitor, instrumentationContext);\n  return new Size(size.getMaximalSize(),\n\n```\ninstrumentedMethod.getStackSize());\n      }\n  }\nprivate static final class IntFieldGetter\n          implements ByteCodeAppender {\n```\n  private final Target instrumentationTarget;\n  private final String name;\nIntFieldGetter(final Target instrumentationTarget, final String name) {\n  this.instrumentationTarget = instrumentationTarget;\n  this.name = name;\n\n}\n@Override\n  public boolean appendsCode() {\n  return true;\n\n}\n@Override\n  public Size apply(final MethodVisitor methodVisitor, final\n  ```\nContext instrumentationContext,\n              final MethodDescription instrumentedMethod) {\n          final StackManipulation arg0 = REFERENCE.loadFromIndex(0);\n          final StackManipulation.Size size = new\n  StackManipulation.Compound(arg0,\n                  MethodInvocation.invoke(new\n  TypeDescription.ForLoadedType(Object.class).\n```\n                      getDeclaredMethods().\n                      // TODO: No such method in Object\n                              filter(isMethod().\n                          and(named(name)).\n                          and(takesArguments(0)).\n\n                          and(returns(int.class))).\n                  getOnly()), arg0,\n\n```\nFieldAccess.forField(instrumentationTarget.\n```\n              getTypeDescription().\n              getDeclaredFields().\n              named(name)).\n              getter(), MethodReturn.INTEGER).\n          apply(methodVisitor, instrumentationContext);\n  return new Size(size.getMaximalSize(),\n\n```\ninstrumentedMethod.getStackSize());\n      }\n  }\n  }\nCheers,\n--binkley\nOn Fri, Jul 18, 2014 at 6:03 PM, Rafael Winterhalter \nnotifications@github.com wrote:\n\nThis is absolutely possible. In general, you are able to create any\npossible Java class by using the exposed ASM-API. However, for your\nexample, you can even use the ASM wrapper classes that already ship with\nByte Buddy to implement this.\nPlease see my answer on StackOverflow (\nhttp://stackoverflow.com/questions/24711172/how-in-java-to-assign-to-fields-with-byte-buddy/24735122#24735122)\nfor how to implement this with Byte Buddy.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/raphw/byte-buddy/issues/3#issuecomment-49415044.\n. \n",
    "mattbishop": "So I gave this a go but it won't build due to javadoc errors. What version of the JDK does one need? I am using 1.7u60.\n[ERROR] javadoc: warning - Class OutputTimeUnit not found.\n[ERROR] /Users/mbishop/Sides/byte-buddy/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java:180: warning - Tag @link: reference not found: org.objectweb.asm.ClassVisitor\n[ERROR] /Users/mbishop/Sides/byte-buddy/byte-buddy-dep/src/main/java/net/bytebuddy/asm/ClassVisitorWrapper.java:14: warning - Tag @link: reference not found: org.objectweb.asm.ClassVisitor\n[ERROR] /Users/mbishop/Sides/byte-buddy/byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/FieldAttributeAppender.java:15: warning - Tag @link: reference not found: org.objectweb.asm.FieldVisitor\n[ERROR] /Users/mbishop/Sides/byte-buddy/byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/MethodAttributeAppender.java:16: warning - Tag @link: reference not found: org.objectweb.asm.MethodVisitor\n. I am on Mac and that's usually not a problem.\nMaven maybe? I am using 3.2.1.\n. I tried it again with forced updates and now the build is fine. Probably a bad download yesterday.\nOne interesting thing about 'mvn clean' is that it wants a GPG passphrase? To clean?\n. So I can't check the OSGi output because I have to run the extras profile to generate the manifest.\nNonetheless, I think your entries won't be right. I will take some time in the next few weeks to create a pull request for this issue. I cannot commit to a time so go ahead with your release. No doubt another release will come along, it always does. ;)\n. ",
    "ghost": "Hi,\nWe are unable to use bytebuddy for OSGi environments. Are you sure that Export-Package definition is correct?\nExport-Package: !net.bytebuddy.jar.asm.*,net.bytebuddy.*\nRelated issue and comment:\nhttps://github.com/ui4j/ui4j/issues/28#issuecomment-106741600\n. I would think this could have the potential to accidentally cause some serious loop and thread unsafe situations. Seems to me a little bit cleaner way to repeatedly call a method would be to use an executor then just hook that method at timed increments.. One solution I have used in the past to get around this is to make my own class using the same package declaration so i can access more things. Then target a method and have that call my new class to instance it, Dirty but works. Some type of expression editor, again right up my issue alley.. I think this may be similar to my issue, or at least contained within it if you would like to combine them. A way to get an instance of the classPool and pull out the class you want rather than trying to search for classes, Do you think this would be a better/less overhead solution?. Well I started to try to just give you an example but it is not a long page you can get a full understanding of the part of javassist i use more than anything else right here.\nhttps://jboss-javassist.github.io/javassist/tutorial/tutorial2.html#runtime\nIt tells you everything you can do with the expression editors and the class pool stuff. Which is to say pretty much whatever  you want. In fact it is so powerful you have to be careful to use it the right way lol. Cause it will likely do its thing the wrong way and  you won't know till your application throws and error mid operation. Once you understand it though it is so dreamy. Over the last 2 years we have further hooked into it for our purposes and added constants and interfaces directly to it so that we can do most things with just a few lines.  I feel like if bytebuddy had this, everything else would just be obsolete.. Well other than that one other thing I mentioned. Controlling class loaders myself and loading the classes when I wan't to as the application launches.. If  you would like to glance at our implementation for a runtime loading system using javassist. It is not on my repository. I am a contributor and work more with the creation of mods for it, and helping other mods learn to use it. For some reason the branch leader keeps forgetting files though so its really best to grab his release and decompile it (procyon does nice) https://github.com/ago1024/WurmServerModLauncher. I am excited for this. I am having a hard time finding information on how to use Byte Buddy with jars\nFor example, how do you load a jar into the system class loader?\nI've already figured out how to load a jar into a TypePool using a ClassFileLocator\nI'm getting Cannot resolve type description for java.lang.Object errors when trying to do things with the jar's TypePool. I like that idea. I have a working prototype now. Had to use ClassReloadingStrategy.Default.INJECTION\nThanks for being patient with me. I will look into those. But to give you a better idea of what I'm trying to do here's a code example\n```java\nvoid test() {\n/ stuff /\nString thing = \"\";\nif (case1) {\n  thing = \"case1\"\n}\nif (case2) {\n  thing = \"case2\"\n}\nif (case3) {\n  thing = \"case3\"\n}\nif (thing.equals(\"\")) {\n  thing = \"default\";\n}\n/ I want to insert this code below with Byte Buddy /\nthing = \"Intercepted by Byte Buddy\";\n/ stuff /\n}\n```\nThe idea is I want to ignore all the case1-3 so that thing is always what I tell Byte Buddy to set it as\nBut the /* stuff */ at the top and bottom of the method cannot be removed. With \njava\nfield(named(\"foo\")).value(\"hello\")\nthere's no value() for anything other than primitive types. How would I use Byte Buddy to change the value of a field that isn't any of: int long float double String boolean\nFor example, say I have a field that holds a File\njava\npublic File test = null;\nHow do I make Byte Buddy set that to new File(\"hello.txt\")\nWhen working with method interceptors we have FixedValue which is really nice and can make a File returning method return with code as simple as this\njava\nmethod(named(\"getFile\")).intercept(FixedValue.value(new File(\"hello.txt\")))\nAlso, I don't need to remove code somewhere in the method. I just need to insert a reassignment of a local var before it gets used.. ",
    "CodingFabian": "I guys, i will fix this, but I want to get the requirements straigt. \nRight now only byte-buddy-agent produces valid osgi headers, however I assume this is not even included as bundle, because its a javaagent. This is not even a valid bundle (because it doesnt provide services) so I propose to remove it.\nbyte-buddy-dep and byte-buddy both do not produce osgi headers.\nCould you please clarify which Classes you actually want to use form which jar?\n. Update, i am building the 0.7 snapshot and the osgi headers are valid. i am able to load the bundle in karaf:\nkaraf@root()> bundle:install mvn:net.bytebuddy/byte-buddy/0.7-SNAPSHOT\nBundle ID: 53\n53 | Active    |  80 | 0.7-SNAPSHOT   | Byte Buddy (without dependencies)\nkaraf@root()> bundle:info 53\nByte Buddy (without dependencies) (53)\n. without my changes. It works, but as sent to you via skype, a really correct header is pretty long, due to the amount of packages and tangling you have there\n. Here are the new manifest files my upcoming PR will produce. Would these work for you?\nhttps://gist.github.com/CodingFabian/35f727056830156b2756\n. this should fix #5,\nthe manifests generated are here: https://gist.github.com/CodingFabian/35f727056830156b2756\n@raphw I checked the jars, and they look ok, maybe you want to doublecheck that inclusions into the final jars did not change.\n. Sounds reasonable, thank you @raphw \n. In theory it would be a no-op, but inst.retransform() is a super expensive call and also it tends to throw exceptions or even segfault when trying without prefiltering.\nI wonder if it should be part of installOn() or a separate API.\n. thats reasonable, I see a number of ByteBuddy internal classes do the same conversion, perhaps at some point there is a good it to add lookup using internal and normal class name.\n. great!\n. was created mostly using copy and paste, let me know if I missed a place where i should have copied and pasted as well :)\n. didn't know about -Pchecks, thanks. Eclipse is pretty stubborn, do you happen to have an Eclipse formatter? Or only idea? :)\n. If you suggest a different code style, I can do that of course.\n. Yeah sorry, didn't check for tests. You mocked the agent API incorrectly, lets see if i can get mockito to throw a segfault :)\n. awesome. This adds to the versatility of bytebuddy!\n. cool, I saw the changes, but it was hard for me to figure out how you supposed it to be used.\nSo I would do\njava\nnew Transformer() {\n  @Override\n  public Builder<?> transform(Builder<?> builder, final TypeDescription typeDescription) {\n    return builder.visitor(new AsmVisitorWrapper.ForDeclaredMethod()\n        .match(ElementMatchers.nameStartsWith(\"foo\")), new MethodVisitorWrapper() { //do the asm advice }));\n }\n...\n. Imho not leading from the system classloader is a bug with spring boot, but if they really do not load from there, i wonder how it actually works. Please let us know the spring boot issue number, I am also interested in understanding the root cause.\n. and\njava.lang.IllegalStateException: Illegal modifiers 131073 for public void com.mysql.jdbc.PreparedStatement.setUnicodeStream(int,java.io.InputStream,int) throws java.sql.SQLException\n. Thanks for the type validation hin. But I assume I can leave this on for a while to report more edge cases :)\n. great! Yeah I had speculated that its the deprecation, which is somehow hacked into the type system.\nThanks for the quick fix!\n. In my opinion the nature of bytebuddy does not allow it for the semver treatment you might be used to in libraries. I also think ASM does not stick to semver. like when they fixed the stack frame issue with java 8, that was not a major releases, but you could argue it should have been.\nas pointed out in the documentation, you ALWAYS should repackage bytebuddy. By doing so you automatically take care about binary compatibility, as you would-recompile your \"dependency\" when upgrading.\nI would also vote for not forcing any source compatibility. @raphw is doing a fantastic job fixing esotheric edge cases. Sometimes that requires a dramatic change.\nBy forcing clirr compatibility (btw, clirr is broken right now for java 8, because bcel is broken, because cglib is broken, because.. maybe somebody should do a bytecode lib...) one usually slows down the progress because required changes cannot be made.\nI am a heavy user of ByteBuddy since 0.5, and I upgraded on every release. I had never a problem with the amount of incompatible changes I needed to follow.\nI know that this might not apply to everybody, but most people are happy that there is an active bytecode manipulation library which is not yet dead. lets try to keep it that way.\n. or even better a LazyTypeDescription which would be resolved only when needed for the element matcher:\ntransformer = agentBuilder.type(subTypeOf(LazyTypeDescription.of(\"javax.servlet.http.HttpServlet\"))))\n. btw, my proposed solution does not work either :-)\njava.lang.NullPointerException:\nat net.bytebuddy.dynamic.ClassFileLocator$ForClassLoader.locate(ClassFileLocator.java:288)\n. yes it is somewhat into that direction.\nThe most common use case is that I want the TypeDescription for \"name matching\".\nFor example there is a takesArgument(index, typeDescription).\nWhen that analysis is done, I know that the type for the argument has been loaded by the classloader already. So I want to reuse that easily. However when I install the transformer (premain, agentmain), that class might not be loaded (especially in complex classloading scenarios, like springboot). When matching, it is loaded (because it is a prerequiste for the type matched) so in those cases I would like to use it lazily.\nI can show you code examples where that would be super convenient.\n. Actually it does not need to classload. For my purpose of using them in matchers, It has to be loaded to have a chance of actually matching.\nSo basically it is a LazyMatchingTypeDescription\nmatches(type) {\n  desc = typePool.describe(\"foo.bar.Baz\");\n  return desc.isResolved() && desc.resolve().matches(type) \n}\nI think something like that is already possible by using a custom matcher, but I want to move that to the type description so it is usable in all matchers..\n. I hired a consultant to fix this issue for us. He will probably send a PR soon :)\n. I guess we can close this. The type pool is the wrong solution and we should use raw matchers.\n. hey @felixbarny, if i read the exception correctly it is the Tomcat Classloader which is involved with creating the class. It should be the System classloader which is loading your java. prefixed classes. \n. We use https://github.com/jhalterman/expiringmap - which could be small enough to include.\n. you mean by master? Thanks!\n. This might be from a time where there was no access to ASM exposed. Are you trying to us any specifc functionality, or is you bundler complaining?\nAs I assume @raphw has no intentions of wrapping the complete asm api, i think we should just add an export for the 3 asm packages\n. The bundling uses explicitly a handcrafted list:\nhttps://github.com/raphw/byte-buddy/blob/master/byte-buddy/pom.xml#L120\n. @bokken No you can use this API, it is not restricted to byte buddy. But because this is not an API provided by bytebuddy, but by ASM, what you should do is to build your own bytebuddy distribution which repackages ASM. that way you have an asm which is under your control in your namespace. If you use it in OSGi (which I assume because you are asking about the export) you then need to export the package when building your distribution.\n. @bokken I can cite the documentation\n\nHowever, this imposes one possible problem when relying onto Byte Buddy as a project dependency and making use of the exposed ASM API. The authors of ASM require their users to repackage the ASM dependency into a different name space. This is necessary because one cannot anticipate changes in the Java class file format what can lead to API incompatibilities of future versions of ASM. Because of this, each version of Byte Buddy is distributed in two different packaging formats:\nA no-dependency version that repackages the ASM dependency from its org.objectweb.asm into Byte Buddy's own namespace net.bytebuddy.jar.asm. Doing so, the ASM dependency is also contained within Byte Buddy's jar file. By using this version, you do not need to worry about possible ASM version clashes which might be caused by the use of ASM by both Byte Buddy and other libraries. If you do not plan to use ASM, do not know what ASM is or what this is all about, this is the version you want to use. The artifact ID of this packaging format is byte-buddy.\nA version with an explicit dependency on ASM in its original org.objectweb.asm namespace. This version must only be used for repackaging Byte Buddy and its ASM dependency into your own namespace. Never distribute your application while directly relying on this dependency. Otherwise, your users might experience version conflicts of different ASM versions on their class path. The artifact ID of this packaging format is byte-buddy-dep.\nNormally, you would use the first, no-dependency version. However, if you are using Byte Buddy and making use of the exposed ASM API, you must use the second version of Byte Buddy and repackage it into your own name space as suggested. This is in particularly true when you plan to redistribute your code for the use by others. Future versions of Byte Buddy will update their ASM dependency to newer version what will then lead to version clashes between different ASM versions that were repackaged by Byte Buddy, if you have not follow this recommendation! In contrast, the Byte Buddy API itself will only apply version compatible changes.\n\nIt is pretty clear that it is nothing optional, that can be done. It is a requirement that must be done when using ASM. And you are not \"only\" using it as api. MethodVisitor is an abstract class carrying behaviour.\n. I like the idea. I however see practical problems when adviced methods call super(). That basically would mean that advice code would trigger twice for an invocation which conceptually should trigger only once.\nYour proposal would make sure that with crazy subclass combinations you are unlikely to miss an invocation, but on the other hand are likely to double count.\nThe double counting is not avoidable by instrumentation, but would be needed to be checked by advice logic. (aka: if called by method which has been adviced by this advice, do not execute advice code again)\nWe have such recursion control in our use case already, and it would be nice to have native byte buddy support for it.\nHowever, I am a bit sceptical if BB could offer a usable API which fits all use cases. I feel that it is still better as user to control this.\n. :-( Yeah, thought you use 8 to compile backwards to 6. Was not aware the build runs on 6\n. Changes from 5.1:\n\nBetter comments in Opcodes.java\nSuppressWarnings in Opcodes.java for Integer constructor deprecation.\nMore tests to check binary backward compatibility\nBug fixes:\n   #317616 Misleading comment in ClassWriter\n   #317621 Type.getReturnType(desc) returns wrong for types with\nparenthesis in name\n   #317749 ClassCheckAdapter should discover invocation of default\nmethod from pre-Java 8 class file\n   #317626 AnnotationNode incorrectly process array values in\n'visit(final String name, final Object value)' method\n   #317630 Frames are re-calculated for Large Methods\n   #317748 Class after instrumenting loses first BootstrapMethods entry. Imagine you wrote a transformer, this one is now triggered in two way:\nA) the JVM has loaded the class already. This happens directly after you install a transformer. You can navigate the loaded class hierarchy.\nB) the JVM loads the class for the first time. While ByteBuddy helps you to still work on the hierarchy (basically ByteBuddy parses it from the raw class files for you) there can be cases where ByteBuddy is unable to resolve the class hierarchy properly.\n\nIn case B) you can use the resubmitter to \"schedule\" basically the case A happening: You bail and let the JVM load the class and its hierarchy. Now that the class was loaded you can for sure access the whole loaded type hierarchy.\nThere are a few scenarios where this can happen. For example in OSGi, where the delegation model prevents the resource lookup bytebuddy does (the classloader might refuse to load a class as resource, but give it out as class)\nOr some obscure code generation, or just plain buggy classloaders.\n(seen all 3 variants :-)). the transformer gets per Instrumentation API the \"raw bytes\" of the class file. In that class you might reference superclass (which also has not been loaded because this class is the first one using it)\nByteBuddy will then request the \"raw bytes\" of the superclass and parse it.\nWhen you deal with a class that has been loaded already, the JVM already has resolved the superclass by whatever classloaders that were responsible for doing so.\nas said, the core difference is that in the one case ByteBuddy uses getResource() to get the \"raw bytes\", in the other case you can access getClass() to get the loaded class. With compliant classloaders it doesn't make a difference, but that's not always the case :). no that would work normally. Imagine that your ClassFileTransformer does not yet know what to do, because it is interested only in subclasses of a certain class. therefor you would need to navigate the hierarchy to decide wether to modify the class or not.. what we do is to use an element matcher which verifies that all types used in the advice are visible by the class that is being adviced.\nbut that is a bit cumbersome and error prone. Until now I did not have a better idea. Maybe this problem could be generalized into something that BB could verify before applying an advice.. Advice.OnMethodEnter cannot reference Advice.This, this is documented in the Javadoc of Advice.This\nIt is also in the exception:\n\"Cannot map this reference for static method or constructor start\"\nAt the beginning of the constructor \"this\" does not yet exist. it only works at the end of the constructor.\n. IMHO you should anonymize the package name (remove the first half). \nillustration of the problem found in a heap dump. Not sure how a null value can be produced. but I have evidence of it happening ;). Ok, makese sense (I guess) have seen an element from getAllLoadedClasses being null before.. Its excluded by default, because most users of ByteBuddy do not want to do this and it prevents them from accidentally modifying core Java classes. For power users, tool developers and alike, adding the none() ignore is a viable alternative (but you probably also want to have a more narrow exclude/include matching). This has a very similar result as java.util.concurrent.ScheduledThreadPoolExecutor.setRemoveOnCancelPolicy(boolean)\nwhich is unfortunately a Java 7 API. Also it looks like this was not canceled because there are certain edge cases which do not call reset on the instrumentation. Possibly that an API for calling reset and this java / api are sufficient enough without the need for this LeakPrevention layer.. ByteBuddy would. Its the instrumentation API implementation that doesn't trigger instrumentation of classes loaded during instrumentation.. note that the missing closing brace should be fixed even if this pr is not accepted :-)\n. ",
    "tomola": "Thanks Rafael, I can confirm now it works as I expected.\n. ",
    "saden1": "Awesome! I was thinking .method(isDeclaredBy(type)) would filter out object methods.\nThanks for the quick turnarounds and this fantastic library.\n. Got it. I am already using the latest 0.4.1 release. Thank you so much.\n. I just want to add that having to exclude Object class methods is quite problematic. It is preventing me from delegating calls to equals(...) method to an underlying implementation. Hopefully the new solution will allow me to delegate methods like equals.\n. Excellent! \n. That's pretty much what I am doing. I only ask that bytebuddy provide such functionally because it seems like a common usecase. Perhaps bytebuddy should provide utility classes for common usescases so people don't have have to reinvent the wheel. \n. I appreciate that.\n. As always, great explanation. My goal is to only intercept hello and world but not greet. I could write my own AmbiguityResolver or register the two methods I am interested in with my MethodDelegation but that's not clean or as extensible. I really want to avoid having to deal with string representation of method names and instead rely on a type-safe approach where I create an interceptor that selectively declares methods I want to intercept and a catch-all method.\nWhat do you think about ByteBuddy introducing a new @Fallback annotation to denote a method as catch-all method? \n```\npublic static class GreeterInterceptor {\n    @RuntimeType\n    @Fallback\n    public Object delegate(@SuperCall Callable<?> zuper) throws Exception {\n        return zuper.call();\n    }\n\n    public String hello(@SuperCall Callable<String> zuper) throws Exception {\n        return zuper.call().toUpperCase();\n\n    }\n\n    public String world(@SuperCall Callable<String> zuper) throws Exception {\n        return zuper.call().toUpperCase();\n    }\n\n}\n\n```\nRegardless of method parameters if a match is not found in the above example delegate is always called.\n. It was the first thing I tried :smile: It did not work :rage:\n``` java\npublic class TestCase {\npublic static class Greeter {\n\n    public String hello() {\n        return \"hello\";\n    }\n\n    public String world() {\n        return \"world\";\n    }\n\n    public String greet() {\n        return hello() + \" \" + world();\n    }\n}\n\npublic static class GreeterInterceptor {\n\n    @RuntimeType\n    @BindingPriority(Integer.MIN_VALUE)\n    public Object delegate(@SuperCall Callable<?> zuper) throws Exception {\n        return zuper.call();\n    }\n\n    public String hello(@SuperCall Callable<String> zuper) throws Exception {\n        return zuper.call().toUpperCase();\n\n    }\n\n    public String world(@SuperCall Callable<String> zuper) throws Exception {\n        return zuper.call().toUpperCase();\n    }\n\n}\n\npublic static void main(String[] args) throws Exception {\n    Greeter instance = new ByteBuddy().subclass(Greeter.class)\n            .method(not(isDeclaredBy(Object.class)))\n            .intercept(to(new GreeterInterceptor()).filter(not(isDeclaredBy(Object.class)))).make()\n            .load(TestCase.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n            .getLoaded()\n            .newInstance();\n\n    String result = instance.greet();\n    System.out.println(result);\n\n}\n\n}\n```\nResult:\nException in thread \"main\" java.lang.IllegalArgumentException: Cannot resolve ambiguous delegation of public java.lang.String com.tangocard.scratch.TestCase$Greeter.greet() to MethodDelegationBinder.MethodBinding.Builder.Build{target=public java.lang.String com.tangocard.scratch.TestCase$GreeterInterceptor.world(java.util.concurrent.Callable) throws java.lang.Exception, registeredTargetIndices={java.lang.Object@6df97b55=0}, methodInvocation=MethodInvocation.Invocation{typeDescription=class com.tangocard.scratch.TestCase$GreeterInterceptor, methodDescription=public java.lang.String com.tangocard.scratch.TestCase$GreeterInterceptor.world(java.util.concurrent.Callable) throws java.lang.Exception}, parameterStackManipulations=[MethodDelegationBinder.ParameterBinding.Anonymous{anonymousToken=java.lang.Object@6df97b55, delegate=MethodCallProxy.AssignableSignatureCall{specialMethodInvocation=Instrumentation.SpecialMethodInvocation.Simple{typeDescription=class com.tangocard.scratch.TestCase$Greeter, methodDescription=public java.lang.String com.tangocard.scratch.TestCase$Greeter.greet()}, serializableProxy=false}}], terminatingStackManipulation=StackManipulation.Compound{stackManipulations=[StackManipulation.Trivial.INSTANCE, MethodReturn.REFERENCE]}} or MethodDelegationBinder.MethodBinding.Builder.Build{target=public java.lang.String com.tangocard.scratch.TestCase$GreeterInterceptor.hello(java.util.concurrent.Callable) throws java.lang.Exception, registeredTargetIndices={java.lang.Object@7225790e=0}, methodInvocation=MethodInvocation.Invocation{typeDescription=class com.tangocard.scratch.TestCase$GreeterInterceptor, methodDescription=public java.lang.String com.tangocard.scratch.TestCase$GreeterInterceptor.hello(java.util.concurrent.Callable) throws java.lang.Exception}, parameterStackManipulations=[MethodDelegationBinder.ParameterBinding.Anonymous{anonymousToken=java.lang.Object@7225790e, delegate=MethodCallProxy.AssignableSignatureCall{specialMethodInvocation=Instrumentation.SpecialMethodInvocation.Simple{typeDescription=class com.tangocard.scratch.TestCase$Greeter, methodDescription=public java.lang.String com.tangocard.scratch.TestCase$Greeter.greet()}, serializableProxy=false}}], terminatingStackManipulation=StackManipulation.Compound{stackManipulations=[StackManipulation.Trivial.INSTANCE, MethodReturn.REFERENCE]}}\n    at net.bytebuddy.implementation.bind.MethodDelegationBinder$Processor.resolve(MethodDelegationBinder.java:952)\n    at net.bytebuddy.implementation.bind.MethodDelegationBinder$Processor.process(MethodDelegationBinder.java:883)\n    at net.bytebuddy.implementation.MethodDelegation$Appender.apply(MethodDelegation.java:1218)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyBody(TypeWriter.java:510)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod.apply(TypeWriter.java:444)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForCreation.create(TypeWriter.java:3193)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1481)\n    at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:234)\n    at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase$AbstractDelegatingBuilder.make(DynamicType.java:2177)\n    at com.tangocard.scratch.TestCase.main(TestCase.java:59)\n. Your suggestion didn't work.\nHere's what my test case looks like:\n``` java\npublic class FallbackInterceptorTest {\n@Test\npublic void test() throws InstantiationException, IllegalAccessException {\n    GreeterInterceptor interceptor = new GreeterInterceptor();\n    Greeter greeter = new ByteBuddy().subclass(Greeter.class)\n            .method(not(isDeclaredBy(Object.class)))\n            .intercept(to(interceptor)\n                    .filter(not(isDeclaredBy(Object.class)))\n                    .defineAmbiguityResolver(\n                            MethodNameEqualityResolver.INSTANCE,\n                            BindingPriority.Resolver.INSTANCE)\n            )\n            .make()\n            .load(TestCase.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n            .getLoaded()\n            .newInstance();\n\n    String result = greeter.greet();\n}\n\npublic static class Greeter {\n\n    public String hello() {\n        return \"hello\";\n    }\n\n    public String world() {\n        return \"world\";\n    }\n\n    public String greet() {\n        return hello() + \" \" + world();\n    }\n}\n\npublic static class GreeterInterceptor {\n\n    @RuntimeType\n    @BindingPriority(Integer.MIN_VALUE)\n    public Object _default(@SuperCall Callable<?> zuper, @AllArguments Object[] args) throws Exception {\n        return zuper.call();\n    }\n\n    public String hello(@SuperCall Callable<String> zuper) throws Exception {\n        return zuper.call().toUpperCase();\n\n    }\n\n    public String world(@SuperCall Callable<String> zuper) throws Exception {\n        return zuper.call().toUpperCase();\n    }\n\n}\n\n}\n```\njava.lang.IllegalArgumentException: Cannot resolve ambiguous delegation of public java.lang.String bytebuddy.test.FallbackInterceptorTest$Greeter.greet() to MethodDelegationBinder.MethodBinding.Builder.Build{target=public java.lang.String bytebuddy.test.FallbackInterceptorTest$GreeterInterceptor.hello(java.util.concurrent.Callable) throws java.lang.Exception, registeredTargetIndices={java.lang.Object@5204062d=0}, methodInvocation=MethodInvocation.Invocation{typeDescription=class bytebuddy.test.FallbackInterceptorTest$GreeterInterceptor, methodDescription=public java.lang.String bytebuddy.test.FallbackInterceptorTest$GreeterInterceptor.hello(java.util.concurrent.Callable) throws java.lang.Exception}, parameterStackManipulations=[MethodDelegationBinder.ParameterBinding.Anonymous{anonymousToken=java.lang.Object@5204062d, delegate=MethodCallProxy.AssignableSignatureCall{specialMethodInvocation=Implementation.SpecialMethodInvocation.Simple{typeDescription=class bytebuddy.test.FallbackInterceptorTest$Greeter, methodDescription=public java.lang.String bytebuddy.test.FallbackInterceptorTest$Greeter.greet(), stackManipulation=MethodInvocation.Invocation{typeDescription=class bytebuddy.test.FallbackInterceptorTest$Greeter, methodDescription=public java.lang.String bytebuddy.test.FallbackInterceptorTest$Greeter.greet()}}, serializableProxy=false}}], terminatingStackManipulation=StackManipulation.Compound{stackManipulations=[StackManipulation.Trivial.INSTANCE, MethodReturn.REFERENCE]}} or MethodDelegationBinder.MethodBinding.Builder.Build{target=public java.lang.String bytebuddy.test.FallbackInterceptorTest$GreeterInterceptor.world(java.util.concurrent.Callable) throws java.lang.Exception, registeredTargetIndices={java.lang.Object@2fd66ad3=0}, methodInvocation=MethodInvocation.Invocation{typeDescription=class bytebuddy.test.FallbackInterceptorTest$GreeterInterceptor, methodDescription=public java.lang.String bytebuddy.test.FallbackInterceptorTest$GreeterInterceptor.world(java.util.concurrent.Callable) throws java.lang.Exception}, parameterStackManipulations=[MethodDelegationBinder.ParameterBinding.Anonymous{anonymousToken=java.lang.Object@2fd66ad3, delegate=MethodCallProxy.AssignableSignatureCall{specialMethodInvocation=Implementation.SpecialMethodInvocation.Simple{typeDescription=class bytebuddy.test.FallbackInterceptorTest$Greeter, methodDescription=public java.lang.String bytebuddy.test.FallbackInterceptorTest$Greeter.greet(), stackManipulation=MethodInvocation.Invocation{typeDescription=class bytebuddy.test.FallbackInterceptorTest$Greeter, methodDescription=public java.lang.String bytebuddy.test.FallbackInterceptorTest$Greeter.greet()}}, serializableProxy=false}}], terminatingStackManipulation=StackManipulation.Compound{stackManipulations=[StackManipulation.Trivial.INSTANCE, MethodReturn.REFERENCE]}}\n    at net.bytebuddy.implementation.bind.MethodDelegationBinder$Processor.resolve(MethodDelegationBinder.java:952)\n    at net.bytebuddy.implementation.bind.MethodDelegationBinder$Processor.process(MethodDelegationBinder.java:883)\n    at net.bytebuddy.implementation.MethodDelegation$Appender.apply(MethodDelegation.java:1224)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyBody(TypeWriter.java:564)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod.apply(TypeWriter.java:498)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForCreation.create(TypeWriter.java:3450)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1577)\n    at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:164)\n    at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase$Delegator.make(DynamicType.java:2472)\n    at bytebuddy.test.FallbackInterceptorTest.test(FallbackInterceptorTest.java:39)\n. What I am trying to do is have bytebuddy intercept methods defined in the interceptor (hello and world) and for those methods not defined in the interceptor delegated to _default method. In essence I would like to have the interceptor be the place were interception decisions are made. I don't want to intercept the greet method but I also don't want to explicitly specify every method I would like to intercept. For example, the bellow works but it is not strongly typed or scalable when you have to intercept lots of methods:\n```\n  GreeterInterceptor interceptor = new GreeterInterceptor();\n        Greeter greeter = new ByteBuddy().subclass(Greeter.class)\n                .method(named(\"hello\").or(named(\"world\")).or(named(\"rinceAndRepeat\")))\n                .intercept(to(interceptor)\n                        .filter(not(isDeclaredBy(Object.class)))\n                )\n                .make()\n                .load(TestCase.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n                .getLoaded()\n                .newInstance();\n    greeter.greet();\n\n```\nQuestion, does bytebuddy analyze the instance class (Greeter) and the interceptor (GreeterInterceptor) to make decisions about  what method should be used to intercept a particular method call?\n. Also, shouldn't the name of the method take precedence in my test case? If you have two methods with the same name there is bound to be ambiguity but in my case all the methods have a unique name.\n. One thing to note is that the issue also manifests itself when rebasing a class.\n. It worked! Awesome! Thank you for all the help!\n. Just upgraded to release 1.6.9 and the following code no longer seems to work:\n```java\nimport java.util.concurrent.Callable;\nimport net.bytebuddy.ByteBuddy;\nimport net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\nimport net.bytebuddy.implementation.MethodDelegation;\nimport net.bytebuddy.implementation.bind.MethodNameEqualityResolver;\nimport net.bytebuddy.implementation.bind.annotation.AllArguments;\nimport net.bytebuddy.implementation.bind.annotation.BindingPriority;\nimport net.bytebuddy.implementation.bind.annotation.RuntimeType;\nimport net.bytebuddy.implementation.bind.annotation.SuperCall;\nimport net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder;\nimport static net.bytebuddy.matcher.ElementMatchers.isDeclaredBy;\nimport static net.bytebuddy.matcher.ElementMatchers.not;\nimport org.junit.Test;\npublic class FallbackInterceptorST {\n@Test\npublic void test() throws InstantiationException, IllegalAccessException {\n    GreeterInterceptor interceptor = new GreeterInterceptor();\n    Greeter greeter = new ByteBuddy().subclass(Greeter.class)\n            .method(not(isDeclaredBy(Object.class)))\n            .intercept(MethodDelegation.withEmptyConfiguration()\n                    .withBinders(TargetMethodAnnotationDrivenBinder.ParameterBinder.DEFAULTS)\n                    .withResolvers(MethodNameEqualityResolver.INSTANCE, BindingPriority.Resolver.INSTANCE)\n                    .filter(not(isDeclaredBy(Object.class)))\n                    .to(interceptor)\n            )\n            .make()\n            .load(FallbackInterceptorST.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n            .getLoaded()\n            .newInstance();\n\n    String result = greeter.greet();\n}\n\npublic static class Greeter {\n\n    public String hello() {\n        return \"hello\";\n    }\n\n    public String world() {\n        return \"world\";\n    }\n\n    public String greet() {\n        return hello() + \" \" + world();\n    }\n}\n\npublic static class GreeterInterceptor {\n\n    @RuntimeType\n    @BindingPriority(Integer.MAX_VALUE)\n    public Object _default(@SuperCall Callable<?> zuper, @AllArguments Object[] args) throws Exception {\n        return zuper.call();\n    }\n\n    @RuntimeType\n    public String hello(@SuperCall Callable<String> zuper) throws Exception {\n        return zuper.call().toUpperCase();\n    }\n\n    @RuntimeType\n    public String world(@SuperCall Callable<String> zuper) throws Exception {\n        return zuper.call().toUpperCase();\n    }\n\n}\n\n}\n```\nIt looks like the custom binders and resolvers is set are overriden in this line of code.. Thanks for the quick response. I can redefine a method and I don't need to add any fields but I must deal with loaded classes. Can I redefine a method of a loaded class?\n. I'm a bit confused. In your example you used rebase but earlier mentioned that due to JVM limitation we can't define fields. Also, I must use typeDescription and loader or can I just use Greeting.class?\n. Got it. I'm still wrangling with whether it is possible to take in a class (Greeting.class) and rebase it. I was thinking of a) loading the class and capturing the name of the class, b) creating a new classloader, c) setting the current classloader to the new classloader and d) finally used the name captured in step a to rebase the class. \nDo you think that could work?\n. I understand. Thank you for all the help.\n. I was using 1.0.3 and didn't see release 1.1.0. Upgrading to the latest release resolves the issue.\nThanks.\n. ",
    "Flamenco": "Thanks for the example above,  @raphw.  You might want to rename toLowerClase to toLowerCase though.. ",
    "sirinath": "Languages like Scala generate different names at the bytecode level. So you have to know exactly what something is complied into. It would be helpful if you can use the language level symbols which translate into the actual name / representation in bytecode. Also this is frequently changing in the case of Scala.\n. May be you can have a configuration file which match the Scala name with representation for the given version but transparent to the user. One this is defined user for the given version the user do not have to worry about what bytecode is generated underneath.\n. This could be an another abstraction layer on top of the current API.\n. Annotations will be easy to use though less flexible\n. ",
    "DALDEI": "Could you explain the last bit \"Also, implementations are only allowed on from Java 8.\" ?\nFor various reasons I need to stay on Java 7 for a while more.\n. Ah yes of course !  Cant create bytecode for a JVM version thats compatible with the running one.\nJust tried the new code, works perfect !\nTook a few mistakes (mine) to get it right ... (missed at first that the function(Type...) could take no args) and then copy pasted the wrong code and put a field instead of a method.\nBut got it right! \nThank you !\nFuture request ... (way future) ... validate builder operations as they occur \nas well as during make() /load().  By the time it gets to load the message has less\ncontext so is harder to track down  - both by the exception itself and by the stack track.\nIn this case my mistake caused an 'incompatible change' ... yes.  which one ?\nconsidering I had only 1 it wasnt too hard  ,  but catching that I'd added a field\nto an interface during the build process would be more useful - and slower :(  :) \n. Success ! Thanks !\nFirst \nThanks for the great work, unless I hit a major issue that cant be resolved, this is going to make it into xmlsh 2.0 - its been a critical missing link i've been struggling with for months and nearly gave up on.   I only need a tiny bit of the features but those make the all the difference between a clean simple solution vs a huge gap in functionality.  So thank you !\nSuggestion:  ( I'm happy to add this and send a pull request)\nYou put a lot of effort into great docs, and this particular bit (using the -deps vs  not jar) I wouldn't have even guessed was an issue without your detailed explanation.\nWith cglib I just guessed (wrong , twice :) and still didn't understand why the 2 libs issue  until I stumbled on byte-buddy.\nMy suggestion - assume the reader doesn't know what you know at a fundamental level, \nparticularly toolsets, build systems, libraries etc. \nAdd the build command for generating the non dep version.\nIt took me less then 1 minute (including failing, then a mvn clean, then it worked)\nWithout your hint I would never have figured it out, and not for lack of trying ( I spent several hours researching the issue and came up blank ... including reading all the pom files, review a good portion of the source and every kind of web search I could think of).   There were no errors, the jar was built, the docs made it clear that using the non -deps was highly encouraged, every thing I could think of did nothing or appeared to work ... except  - no classes in the jar file.\nThis is undoubtable completely obvious to someone who is an expert in maven but i had no clue at all where to even look ... \nIts difficult to keep in mind, but regardless of popularity at any point, and especially with things like build tools which take vast efforts to learn and become proficient, and come and go so quickly over time - what seems like 'common knowledge' can often be the exact opposite.   Ironically, the entire purpose of build tools is to solve that problem ... but in the process of simplification and abstraction the end result is you need to become an expert in that particular tool in order to understand how to achieve the obvious :)  So a new tool comes out that tries to solve the problems of the previous one, \nand so we go ... its literally impossible to keep up and still get work done ... ( the other irony of software, people like to write new programs more then improving old ones ... )\nSo just a suggestion ...\nJust 1 or 2 lines more in the docs can be the difference between someone being able to get it to work or giving up.\nWriting all this not to complain but to remind myself as much as anyone ... the more you learn the harder it is to remember what you didn't know before.  Its the blind spot of knowledge :)\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO]\n[INFO] Byte Buddy (parent) ................................ SUCCESS [  0.921 s]\n[INFO] Byte Buddy Java agent .............................. SUCCESS [  2.104 s]\n[INFO] Byte Buddy (with dependencies) ..................... SUCCESS [ 18.722 s]\n[INFO] Byte Buddy (without dependencies) .................. SUCCESS [  2.787 s]\n[INFO] Byte Buddy benchmarks .............................. SUCCESS [  2.682 s]\n[INFO] Byte Buddy for Android ............................. SUCCESS [  4.114 s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 31.443 s\n[INFO] Finished at: 2015-01-17T11:46:42-05:00\n[INFO] Final Memory: 32M/706M\n[INFO] ------------------------------------------------------------------------\nE:\\Work\\DEI\\github\\byte-buddy\\byte-buddy\\target>ls -l *.jar\n-rwxr-xr-x 1 DLEE None 4225288 Jan 17 11:46 byte-buddy-0.6-SNAPSHOT-javadoc.jar\n-rwxr-xr-x 1 DLEE None 1050915 Jan 17 11:46 byte-buddy-0.6-SNAPSHOT-sources.jar\n-rwxr-xr-x 1 DLEE None 1131915 Jan 17 11:46 byte-buddy-0.6-SNAPSHOT.jar\n-rwxr-xr-x 1 DLEE None    5236 Jan 17 11:46 original-byte-buddy-0.6-SNAPSHOT.jar\nE:\\Work\\DEI\\github\\byte-buddy\\byte-buddy\\target>jar t < byte-buddy-0.6-SNAPSHOT.jar | tai\nnet/bytebuddy/jar/asm/commons/RemappingFieldAdapter.class\nnet/bytebuddy/jar/asm/commons/RemappingMethodAdapter.class\nnet/bytebuddy/jar/asm/commons/RemappingSignatureAdapter.class\nnet/bytebuddy/jar/asm/commons/SerialVersionUIDAdder$Item.class\nnet/bytebuddy/jar/asm/commons/SerialVersionUIDAdder.class\nnet/bytebuddy/jar/asm/commons/SimpleRemapper.class\nnet/bytebuddy/jar/asm/commons/StaticInitMerger.class\nnet/bytebuddy/jar/asm/commons/TableSwitchGenerator.class\nnet/bytebuddy/jar/asm/commons/TryCatchBlockSorter$1.class\nnet/bytebuddy/jar/asm/commons/TryCatchBlockSorter.class\n. Update:  commenting out those 2 culprits just defered the crash until the next one .. \nThis one burried too deeply in nested blocks, lambdas and synthetic methods to bother debugging :)\nCaused by: org.gradle.api.GradleException: Cannot transform type: com.nexstra.portal.view.CampaignElemDetail$show$2$1$1$1$1\n```\nfun show(ev : CampaignElemsView,\n           cv : CampaignMessageView) {\n,,,,, way way down from here ... \n```\none of these thingies ...\n```\n        button(\"View Message...\",{\n          window(\"Message Content\") {\n            setModal(true)\n            isResizable = true\n```\n. Yes, after I wrote this I did more experimenting. \nKotlin is being very 'creative' with bytecode. Not exactly 'buggy' -- in that as far as I can tell its all 100% legit - but its not 100% like javac would (or could) do.    There is a lot of effort for java compatibility but mostly on integration points not on the entire internals.   I.e. 'normal' java can call kotlin code usually without any changes, and visa versa.  But -- 'normal' meaning generally 'not including fancy-pants stuff' \nfor that there are a few @Annotations  to force compatibility at the expense of feature. \nA simple example is functions with default parameter values like\nfun  doit(  with: String = \"Default String\" )\nif you use @JvmOverloads  then it will create 2 copies of 'doit'\n   doit()\n  doit(  String: with ) \notherwise java source code cant call it easily (it generates a hidden function with an extra argument holding a bitmask for the defaulted parameters)\nSimilar with 'zero arg' constructors, statics,  package and class namings etc ..\nIn this case the 'class' is a lambda function that has no obvious parent,  and calling reflection on it does throw an exception -- although you do have to be quite creative to identify the culprit to call reflection on it in the first place ... seeing as it has no name and not necessarily assigned to a property, you have to go digging with javap or catch a live one to examine it to figure out its fqn -- otherwise it 'just works' .. unless you start recursively reflecting on the entire bytecode \nSuggestion:  (s)\nA) 'Dont Crash Please'  - if you run into 'bogus' JVM stuff, be it from kotlin, scala, some other bytecode factory or a V(n+1) java -- fail nicely and skip over it .. and yes that is ambiguous and not necessarily the correct behaviour.   I would personally prefer simply skipping unexpected cruft over crashing -- especillay in a build plugin where one typically does not have access to the innards - but of course there are good reasons to not blindly stomp on ...\nB) Driver Error: \"dont do that\" -- i.e. I shouldn't be blindly copying sample code that merrily reflects on the entire classpath -- if I had targeted the classes I wanted instrumented the error would not occur.\nBut then the reason I'm blindly copying sample code is I dont know any better !!! so I start with WTF lets try the sample code for the build plugin and see what it does \n\nC) Maybe use samples that don't do exhaustive classpath searching -- at least for nice 'out of the box' experience.  As it was I had to dig quite a bit to get the sample to even run as bits of it didn't exist \n(presumably 'obvious' -- but then if its really obvious there would be no need for a sample.  So if you do have samples (please please)  then making them self contained and as unobtrusive as possible leads to better first-time experiences.   For something as complex as bytebuddy I can attest that a good 'first time' experience makes the difference between \"Ok lets keep trying\" vs \"OMG That hurt, not doing THAT Again\" -- its highly unlikely I would continue trying to learn something more realistic/difficult if I can't figure out how to get a published sample of the basics to run at all or easily )\n. I single stepped in the intellij debugger into a similar call and it produced a similar error.\nI will try this one explictly and report back. As noted it is not the only example of this type of 'odd' bytecode.\nSome ad-hoc research and I find its not unique (among non-java jvm) similar in concept to synthetic methods in that the particular method orr reference is not reachable by language constructs  which is true in this case as well - the enclosedMethod doesn't exist but there is no non-reflection path to access it in the languages (or none that compile successfully).  This case is a inlined lambda which does not refernce the declaration point's parent nor the injected/callee point's parent. \nI cant intelligently speculate whether the kotlin team considers this a bug, feature, or irrelevant.   In any case its currently ill-defined and subject to implementation change (or just 'dont do that' )\nGiven 2 conflicting goals ('do not throw errors on legitimate but ill-behaving reflection code'  +  'do what java API does')  -- they may not both be achievable in the same api/method -- which leads to \"How should one use bytebuddy in this use case\"  --\nI'd be happy with 'don't do that' -- except I have only a foggy understanding of the impact - where else will similar code pop up?  That leads to it being significant effort/pain to attempt and be prepared for the unexpected and then the workarounds for each as they arise.   That is likely to take a good deal of domain knowledge the JVM and Bytebuddy -- precisely the domain knowledge I am using bytebuddy to attempt to avoid having to learn (at least all at once upfront).  Even if this is the only case, the 'cloud of ignorance' is a big deterrent to even start the attempt, and a big risk if new code becomes dependant then later to uncover some critical but unsolvable case. \nA possible solution -- identify a use pattern that avoids this problem altogether.  For example , If I ONLY looked for annotations on public classes perhaps it would skip over the messy parts ?\nAnother nieve idea -- a kind of 'Safe Traversing' API designed to 'Do as good as reasonably possible but avoid the messy parts and just ignore or report errors but dont stop'\nThose may be the same thing --  \n. ( seperate issue maybe - will open if I find more info.  I have a simple case of dynamically creating a 'bean' which is working well except for nullability I ran into the following which is slightly related)\nA little research:\nhttps://discuss.kotlinlang.org/t/where-can-i-find-information-about-the-bytecode-generation/2282\nIm looking at what it would take to detect and generate basic kotlin property semantics, particularly the existence of 'nullable' and var vs val (getter+setter vs getter) such that the generated java class as interpreted as a kotlin class would be a bit closer then I have now.  There is a magic metadata field created for most kotlin classes which contains additional type information. \n. ",
    "uvwild": "Thanks mate. It was working in the end: \nFind all annotated classes:\njava\n    public static Set<Constructor> getSQLInjectedItemSubClassCtors() {\n        Predicate<String> filter = new FilterBuilder().include(\"mycore.legacy.*\")\n                                                    .include(\"myother.legacy.core.*\");\n        Reflections reflections = new Reflections(new ConfigurationBuilder().filterInputsBy(filter)\n                             .setScanners(\n                                   new SubTypesScanner().filterResultsBy(filter), \n                                   new MethodAnnotationsScanner().filterResultsBy( filter), \n                                   new MethodParameterScanner()).setUrls( ClasspathHelper.forClassLoader()));\n        Set<Constructor> annotated = reflections.getConstructorsAnnotatedWith(SQLInject.class);\n        return annotated;\n    }\nThen create the mixin for them:\njava\n    public static Class<?> createMixinFor(final Class declaringClass) {\n        assert(declaringClass != null);\n        try {\n            Annotation methodAnnotation = JacksonItemMixin.class.getDeclaredConstructor(Long.class).getAnnotation(JsonCreator.class);\n            assert(methodAnnotation != null);\n            Annotation parameterAnnotation = JacksonItemMixin.class.getDeclaredConstructor(Long.class).getParameterAnnotations()[0][0];\n            assert(parameterAnnotation != null);\n            LOG.debug(\"Annotation: {}\",parameterAnnotation.annotationType());\n            TypeDescription objectType = new TypeDescription.ForLoadedType(Object.class);\n            Instrumentation instrumentation = new Instrumentation.Simple(MethodVariableAccess.forType(objectType).loadFromIndex(0), MethodInvocation.invoke(\n                objectType.getDeclaredMethods().filter(ElementMatchers.isConstructor()).getOnly()).special(objectType), MethodReturn.VOID);\n            Class<?> dynamicType = new ByteBuddy().withModifiers(TypeManifestation.ABSTRACT)\n                                                  .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)\n                                                  .name(declaringClass.getCanonicalName().concat(\"MixIn\"))\n                                                  .defineConstructor(Arrays.<Class<?>>asList(Long.class), Visibility.PROTECTED)\n                                                  .intercept(instrumentation)\n                                                  .annotateMethod(methodAnnotation)\n                                                  .annotateParameter(0, parameterAnnotation)\n                                                  .make()\n                                                  .load(CachingItemFactory.class.getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST_PERSISTENT)\n                                                  .getLoaded();\n            LOG.debug(\"created Mixin {} for {}\", dynamicType, declaringClass);\n            assert(dynamicType.getDeclaredConstructor(Long.class) != null);\n            assert(dynamicType.getDeclaredConstructor(Long.class).getAnnotation(JsonCreator.class) != null);\n            assert(dynamicType.getDeclaredConstructor(Long.class).getParameterAnnotations()[0][0] != null);\n            return dynamicType;\n        } catch (NoSuchMethodException nme) {\n            LOG.error(\"createMixinFor: \", nme);\n        }\n        return null;\n    }\nFinally, use jackson mapper to apply this all:\njava\n        objectMapper = new ObjectMapper();\n        // use generated Mixin Classes\n        Set<Constructor> ctors = getSQLInjectedItemSubClassCtors();\n        for (Constructor ctor : ctors) {\n            // add mixin annotations for inheritance relationships\n            Class<?> persistenceClass = ctor.getDeclaringClass();\n            objectMapper.addMixInAnnotations(persistenceClass, createMixinFor(persistenceClass));\n        }\n. Oops sorry didn't want to disturb your work flow....\n. ",
    "javadch": "Yes, the classes are java sources. I am using the Java Compiler API but there is a problem that the compiler does not work on production machines as it requires the JDK!\nIs it possible for you to consider this use-case Byte Buddy?\n. Thank you for the clarification.\nOn Sun, Apr 26, 2015 at 6:29 PM, Rafael Winterhalter \nnotifications@github.com wrote:\n\nClosed #25 https://github.com/raphw/byte-buddy/issues/25.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/raphw/byte-buddy/issues/25#event-290293545.\n. \n",
    "Pasupathi-Rajamanickam": "I don't do such. Have look at my code pls.\njava\npublic class Hello {\n  public final String sayHello() {\n    return \"hello\";\n  }\n}\nThat's it. I cannot use byte-buddy to log this 'sayHello' function?\n. Ya here is that. I have these 3 classes in 3 different files.\nMain class - To create bytebuddy class and run it.\n``` java\npublic class ByteEx {\npublic static void main(String[] d) throws Exception{\n    new ByteEx().loadclassDD();\n  }\npublic void loadclassDD() throws Exception{\n    Hello loggingDatabase = new ByteBuddy() \n      .subclass(Hello.class)\n      .method(named(\"sayHello\")).intercept(MethodDelegation.to(LoggerInterceptor.class))\n      .make()\n      .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n      .getLoaded()\n      .newInstance();\n    System.out.println(loggingDatabase.sayHello());\n  }\n}\n```\nLogger class. - This will return upper case of original string data if my method is called.\njava\npublic class LoggerInterceptor {\n    public static String log(@SuperCall Callable<String> zuper)\n        throws Exception {\n    System.out.println(\"Calling database\");\n    try {\n      return  zuper.call().toUpperCase();\n    } finally {\n      System.out.println(\"Returned from database\");\n    }\n  }\n}\nTarget class which have a method will return lower case data\njava\npublic class Hello {\n  public final String sayHello() {\n    return \"hello\";\n  }\n}\n. You mean to say I should remove the final from the class?\n I've seen the blog, but still this cannot be achieved for final method right?\n. OK. Ya I think you are correct. I tried couple of interceptor, but no luck. OK. Thanks for the response. Good luck for your project. It's really awesome and simple. \n. ",
    "rgoldberg": "If a List is passed as the argument to ByteBuddy#makeInterface(Collection), any iteration done inside the method will still be performed in the List order.  So, since the method (and everything that it calls) only uses size() & iterator(), a (Collection) method will behave equivalently for a List argument as a (List) method.\nThe JavaDoc doesn't specify that the super interfaces will be declared in the order of their occurrence in the List, and it doesn't say how duplicates are handled (I would assume that an interface will be declared in the order of its first occurrence in the List).  The same would hold true if you change the signature to (Collection c), and just specify that an interface will be declared in the order of it first occurrence in c.iterator(), which, for List, is obviously exactly the same as the order in the List itself.\nIf I, as the caller, don't care about the order of the interface declarations (or if I care about the order, but just want to specify it via some other Collection, like a SortedSet), why should makeInterface(...) care?\n. Thanks for updating the API so quickly.\nOne additional makeInterface method might be useful.\nRight now, you have:\nmakeInterface(Collection<? extends TypeDescription> typeDescriptions)\nIt would be simpler for a caller who just has Collection<Class<?>> to be able to call:\nmakeInterfaceFromClassCollection(Collection<Class<?>> classColl)\nYou can probably come up with a better name than makeInterfaceFromClassCollection; I just had to pic something that was different from makeInterface to avoid a duplicate method signature due to type erasure.\n. Thanks.\n. I don't know why the build is failing.  It looks like the org.apache.maven.plugins:maven-checkstyle-plugin:2.15 plugin is causing the failure, but the output isn't very helpful.\n. Just saw your comments.  I'll redo my whitespace.  checkstyle really should output that as an error, rather than as an info.  It was buried among tons of other info logs...\n. Squashed.\nWhen do you think 0.7 will be officially released (non RC)?\n. ",
    "bric3": "ok, great :)\n. It indeed fixes the issue :)\n. No problem this is no small piece of development you crafted.\nI'm excited by possibilities now :)\nJust need time to work on it.\nAlso I think there's another issue with ByteBuddy or the way Mockito uses ByteBuddy.\nThe test in this commit hightlight an issue some are facing : https://github.com/bric3/mockito/commit/7f2beb8d0e4819f8dfa6a0fedb0236cec8f4b168\nI didn't have time to dive in here yet, this probably have to do with a feature add in mockito lately that can generated partial mocks, so mocked types may be instantiated with the constructor instead of objenesis. So not sure it's a bytebuddy issue.\nMust go now. Cheers\n. Yeah that's somehow what I suspected. Thanks for the tip.\n. Yes that seems much better, thanks @raphw\n. ",
    "gsson": "Workaround for anyone not using master:\nFixedValue.value(new TypeDescription.ForLoadedType(theClass));\n. ",
    "Anon10W1z": "On a side note, is there any way to modify the class that an existing class extends from?\n. Alright, thank you for your help. I definitely love this library regardless!\n. Oh right, my bad sorry.\n. That's unfortunate. Sorry to bother you. I'm rewriting the method in the superclass to check itself if it's an instance of the subclass as a workaround.\n. Sounds good! Thanks again!\n. ",
    "juherr": "On my side, I succeed to remove my dependency to PowerMock. So no more problem :)\nDo you want I open a issue on PowerMock, or you take the point?\n. ",
    "klaasb": "You're right about the filter, though can a filter actually change the contents of the generated static field?\nSorry for not providing example code, mine looks roughly like this:\njava\n...\n.defineMethod(getSomething)\n.intercept(\n    MethodDelegation.to(delegate, Delegate.class, \"getSomethingDelegate\")\n        .filter(ElementMatchers.named(\"getSomething\"))\n.defineMethod(getSomethingElse)\n.intercept(\n    MethodDelegation.to(delegate, Delegate.class, \"getSomethingElseDelegate\")\n        .filter(ElementMatchers.named(\"getSomethingElse\"))\nThere might be other ways to do this with Byte Buddy's API, that was the first I discovered.\n. ",
    "Spikhalskiy": "Hm... but... yes :) By tutorial @Origin passes link to original method, that was matched and instrumented, but not to the new method version, that was used to replace the original one. So, in case of rebased class, it should be a method that was rebased and shadowed by some generated name like \"MyObject.modify$original$fsxSDRuU\", but not recreated \"MyObject.modify\".\nOk, thanks for advice, I will take a look at SuperCall and Morph to get reference to original method and invoke it.\n. @SuperCall and @Morph can be used to invoke original method on the same entity. But I need to call original method of another entity of the same rebased class. And it's not clear how to get this method reference for invocation in any form if @Origin actually passes not origin information.\n. > Do I understand you correctly that you are trying to delegate from a proxy class to another proxy class?\nYes, you are right.\n\nThe @Origin annotation is built such that you can invoke an unproxied instance from a proxied instance.\n\nSo... it's absolutely useless annotation for rebased class in that case?\n\nIf you rebase a class such that you use a class either as a proxy or not, I would recommend you to add a boolean field to the class which activates or deactivates a proxy mode for instances of a class. If a class is not proxied, you can simply invoke the super method from the delegator.\n\nHm, it's a type of solution, but I want this another proxy instance to still be a proxy on this time for another code.  I want to invoke original version only from my interceptor. Of course, I can make this boolean ThreadLocal :)\nBut it all looks ugly. I think it's easy to add an ability to get a descriptor for original method.\nLooks like... a feature request? Because I can easily do it even with cglib by MethodInterceptor#intercept(arg0, arg1, arg2, MethodProxy)\n. I just found this question https://stackoverflow.com/questions/33842614/is-it-possible-to-redirect-a-method-call-to-another-instance-of-the-same-object and found it good example to start playing with ByteBuddy after your recommendation in one of my question on stackoverflow. So, I'm just taking a look at tutorial. I have not stuck in it in any way because I don't need it for production (if I stuck I would use subclassing and CGLib because I can do it such thing easily with CGLib by it's MethodHandler).\nWhat I try to do - I want to rebase MyObject from this question and intercept modify() method to delegate it to original modify() method of another instance of MyObject, without call of instrumented version (\"active\" instance in context of this question).\nIn general - this stackoverflow question is awful and it's not normal live situation. But getting descriptor of overridden method is definitely normal thing that such library should support. If library don't expose way to get overridden method reference - how should I do that? Manual code with loop by getDeclaredMethods to find $original$randomThing() :)\nSo... I think I don't need an advice how to do this right now in ByteBuddy.\nI believe there is another way to do this.\nAt least I can implement instrumented modify() method of target entity to avoid recursion based on some flags.\nOr I can check in interceptor if current entity is same as delegate and use SuperCall/Morph in this case.\nOr I can expose a new method of MyObject modifyOriginal, which will just call this original method and avoid recursion on delegates. I'm not sure even of this, because I still need to get a descriptor of original method for such a call in some way... maybe it can be just a static util method to make in possible to use it in both interceptor of this method and another code (for example, interceptor of another/new method). For example ByteBuddyUtil.getOriginalMethodFor(Method overriddenMethod). So, maybe new Annotation for this is not enough.\nSo, current task is solvable, but I think I'm talking about very legal think - get meta information of replaced/overridden method. From my point of view, I suggest to convert this into feature request and maybe discuss how it can be implemented. Maybe I could spend some time to take into ByteBuddy's internals and prepare a pull request if design is clear for me.\n. Yep, you recommendation is completely legal and it's a way to solve this specific question.\nOn the other hand, inventing of functionality to get method's original still looks useful for me and it can make it possible to don't think about such tricks all time. Looks like only reasons to don't expose new annotation like @RebasedMethod are\n1) rebase/subclass/redefine should be transparent to interceptor\n2) we now doesn't register that this $original method is origin for this instrumented method.\nCould we make an exception and add such rebase-only annotation and think about implementation details or you don't want to include annotation specific only to one of rebase/subclass/redefine process? \n. Thanks, @raphw!\n. @raphw In case if I don't apply \".modifiers(TypeManifestation.PLAIN)\" I got an error : \"java.lang.IllegalArgumentException: Cannot extend a final type: class SimpleObject\" It's absolutely unclear from this message that I can't use auxiliary type @Super if class remains final and I can solve this both by removing usage of auxiliary type or adding Plain manifestation. It looks like... I just couldn't make all of this (rebasing for example) for final class. Everybody will need some time, desire and patience to find that it's related to @Super parameter. I think diagnostic message here should be improved.\n. Hi @raphw But I make a redefine here. So, what's the problem if I redefine final method before loading it's bytecode? Change it's name and create new one as with non-final method. We even have no need to remove this final modifier from method. Don't see any problem with this process.\n. Yes, SuperCall or Morph can be used here I think. Ok, clear, we just can't make auxiliary class once more because of final modifier and stuck in analog of modifier() absence on MatchedMethodInterception currently in ByteBuddy. Thanks.\n. We have an ability to remove final from class before it get loaded and make @Super for such a class, so we can do same modification for methods? Before loading class byte-code - just remove final from method. It will make all of this possible, no?\n. ",
    "Petikoch": "Thanks a lot @raphw !\n. Thanks @raphw for the answer.\nShould I ask the same question on stack overflow? To have it as kind of FAQ?\n. http://stackoverflow.com/questions/33912026/intercepting-calls-to-java-8-lambda-expressions-using-byte-buddy\n. Good point. \nWell, I intercept only \"my code\" (in \"my packages\"), not the code from Groovy itself. \"My code\" does then the calls to Groovy, which are not intercepted.\nThe .ignoreMethods(isGroovyMethod()) didn't work for me here in this case... \nHmmm...\n. Groovy seems to have the problem to create code at runtime for \"my packages\", which are intercepted and manipulated by Byte Buddy.\n. I used Groovy's own relocated ASM (package groovyjarjarasm.asm) and the expression new ClassReader(bytes).accept(new TraceClassVisitor(new PrintWriter(System.out)),0) in the IDE to get a \"dump\" of the Groovy generated byte code :\n```\n// class version 48.0 (48)\n// access flags 0x41001\npublic synthetic class ch/concordia/cip/library/Gau$controlGetHandle extends org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite  {\n// access flags 0x9\n  public static Ljava/lang/reflect/Constructor; constructor\n...\n```\n(for full output see attached file) \ngen_bytecode.txt\n. Opps... yes, sorry... the call to ch/concordia/cip/library/Gau$controlGetHandle does produce the similiar java.lang.VerifyError, like ch/concordia/cip/library/PowerBuilderAppsLib$controlWaitGetHandle\n```\njava.lang.VerifyError: (class: ch/concordia/cip/library/Gau$controlGetHandle, method:  signature: ()V) Illegal type in constant pool\nat java.lang.Class.getDeclaredConstructors0(Native Method)\nat java.lang.Class.privateGetDeclaredConstructors(Class.java:2671)\nat java.lang.Class.getConstructor0(Class.java:3075)\nat java.lang.Class.getConstructor(Class.java:1825)\nat org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:83)\nat org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\nat org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\nat org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\nat groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\nat org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\nat org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\nat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\nat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\nat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\nat ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$EUCBCmKm(DOS105SearchWindow.groovy:28)\nat ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$EUCBCmKm$accessor$fNGeTyjt(DOS105SearchWindow.groovy)\nat ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$0y1HJHhX.call(Unknown Source)\nat ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:76)\nat ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\nat ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$IDbA5PW2(Dossier.java:23)\nat ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$IDbA5PW2$accessor$qRUTGrkU(Dossier.java)\nat ch.concordia.cip.keywords.Dossier$auxiliary$9whP4xrZ.call(Unknown Source)\nat ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:76)\nat ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\nat ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:497)\nat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\nat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\nat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\nat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\nat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\nat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\nat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\nat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\nat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:497)\nat com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n\n```\n. Here it is... :-)\nGau_controlGetHandle_agentListener.txt\n. The code runs on (and is compiled on) (and did run on)\nJVM: Java HotSpot(TM) 64-Bit Server VM (25.60-b23, mixed mode)\nJava: version 1.8.0_60, vendor Oracle Corporation\nLet's see what the CheckClassAdapter says... \n. When I do CheckClassAdapter.verify(new ClassReader(bytes), true, new PrintWriter(System.out)) \nat the breakpoint in `AgentBuilder.Listener#onTransformation' I get \njava.lang.IllegalArgumentException: ldc of a constant class requires at least version 1.5\n    at jdk.internal.org.objectweb.asm.util.CheckMethodAdapter.checkLDCConstant(CheckMethodAdapter.java:1198)\n    at jdk.internal.org.objectweb.asm.util.CheckMethodAdapter.visitLdcInsn(CheckMethodAdapter.java:813)\n    at jdk.internal.org.objectweb.asm.ClassReader.readCode(ClassReader.java:1431)\n    at jdk.internal.org.objectweb.asm.ClassReader.readMethod(ClassReader.java:1046)\n    at jdk.internal.org.objectweb.asm.ClassReader.accept(ClassReader.java:722)\n    at jdk.internal.org.objectweb.asm.ClassReader.accept(ClassReader.java:535)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:241)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:288)\n    at ch.concordia.cip.testcases.RunlogAgent$1.onTransformation(RunlogAgent.java:47)\n    at net.bytebuddy.agent.builder.AgentBuilder$Listener$Compound.onTransformation(AgentBuilder.java:663)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:2486)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:2916)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:760)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.define(ClassLoaderForClassArtifacts.java:44)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts$1.run(ClassLoaderForClassArtifacts.java:77)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts$1.run(ClassLoaderForClassArtifacts.java:75)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:75)\n    at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\n    at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\n    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\n    at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1(DOS105SearchWindow.groovy:28)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1$accessor$gwqpZzMD(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$TlXTS3Mq.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG(Dossier.java:23)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG$accessor$cLx1vzpU(Dossier.java)\n    at ch.concordia.cip.keywords.Dossier$auxiliary$MOUw9bg6.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\n    at ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nWhen I do this at the breakpoint in ClassLoaderForClassArtifacts#defineClassAndGetConstructor I get \n```\n(Lorg/codehaus/groovy/runtime/callsite/CallSite;Lgroovy/lang/MetaClassImpl;Lgroovy/lang/MetaMethod;[Ljava/lang/Class;Ljava/lang/reflect/Constructor;)V\n00000 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  :  :     ALOAD 0\n00001 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle  :     ALOAD 1\n00002 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle CallSite  :     ALOAD 2\n00003 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle CallSite MetaClassImpl  :     ALOAD 3\n00004 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle CallSite MetaClassImpl MetaMethod  :     ALOAD 4\n00005 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class  :     INVOKESPECIAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite. (Lorg/codehaus/groovy/runtime/callsite/CallSite;Lgroovy/lang/MetaClassImpl;Lgroovy/lang/MetaMethod;[Ljava/lang/Class;)V\n00006 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  :  :     ALOAD 5\n00007 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Constructor  :     PUTSTATIC ch/concordia/cip/library/Gau$controlGetHandle.constructor : Ljava/lang/reflect/Constructor;\n00008 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  :  :     RETURN\njdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 20: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:327)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:262)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:288)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:83)\n    at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\n    at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\n    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\n    at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1(DOS105SearchWindow.groovy:28)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1$accessor$gwqpZzMD(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$TlXTS3Mq.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG(Dossier.java:23)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG$accessor$cLx1vzpU(Dossier.java)\n    at ch.concordia.cip.keywords.Dossier$auxiliary$MOUw9bg6.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\n    at ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nCaused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.getClass(SimpleVerifier.java:346)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:331)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:318)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isSubTypeOf(SimpleVerifier.java:237)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:430)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:76)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Frame.execute(Frame.java:649)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:229)\n    ... 46 more\ncall(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n00000 Gau$controlGetHandle Object Object  :  :    L0\n00001 Gau$controlGetHandle Object Object  :  :     ALOAD 0\n00002 Gau$controlGetHandle Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00003 Gau$controlGetHandle Object Object  : Gau$controlGetHandle Object  :     ALOAD 2\n00004 Gau$controlGetHandle Object Object  : Gau$controlGetHandle Object Object  :     INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;[Ljava/lang/Object;)Z\n00005 Gau$controlGetHandle Object Object  : I  :     IFEQ L1\n00006 Gau$controlGetHandle Object Object  :  :     ALOAD 2\n00007 ?       :     ICONST_0\n00008 ?       :     AALOAD\n00009 ?       :     CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n00010 ?       :     ALOAD 2\n00011 ?       :     ICONST_1\n00012 ?       :     AALOAD\n00013 ?       :     CHECKCAST java/lang/String\n00014 ?       :     INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n00015 ?       :     ARETURN\n00016 Gau$controlGetHandle Object Object  :  :    L1\n00017 Gau$controlGetHandle Object Object  :  :     ALOAD 0\n00018 Gau$controlGetHandle Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00019 Gau$controlGetHandle Object Object  : Gau$controlGetHandle Object  :     ALOAD 2\n00020 Gau$controlGetHandle Object Object  : Gau$controlGetHandle Object Object  :     INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCall (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n00021 ?       :     ARETURN\n00022 Gau$controlGetHandle Object Object  : GroovyRuntimeException  :    L2\n00023 Gau$controlGetHandle Object Object  : GroovyRuntimeException  :     INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n00024 Gau$controlGetHandle Object Object  : Throwable  :     ATHROW\n     TRYCATCHBLOCK L0 L2 L2 groovy/lang/GroovyRuntimeException\njdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 20: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:327)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:262)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:288)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:83)\n    at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\n    at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\n    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\n    at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1(DOS105SearchWindow.groovy:28)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1$accessor$gwqpZzMD(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$TlXTS3Mq.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG(Dossier.java:23)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG$accessor$cLx1vzpU(Dossier.java)\n    at ch.concordia.cip.keywords.Dossier$auxiliary$MOUw9bg6.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\n    at ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nCaused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.getClass(SimpleVerifier.java:346)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:331)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:318)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isSubTypeOf(SimpleVerifier.java:237)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:430)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:76)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Frame.execute(Frame.java:649)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:229)\n    ... 46 more\ncallStatic(Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;\n00000 Gau$controlGetHandle Class Object  :  :    L0\n00001 Gau$controlGetHandle Class Object  :  :     ALOAD 0\n00002 Gau$controlGetHandle Class Object  : Gau$controlGetHandle  :     ALOAD 1\n00003 Gau$controlGetHandle Class Object  : Gau$controlGetHandle Class  :     ALOAD 2\n00004 Gau$controlGetHandle Class Object  : Gau$controlGetHandle Class Object  :     INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;[Ljava/lang/Object;)Z\n00005 Gau$controlGetHandle Class Object  : I  :     IFEQ L1\n00006 Gau$controlGetHandle Class Object  :  :     ALOAD 2\n00007 ?       :     ICONST_0\n00008 ?       :     AALOAD\n00009 ?       :     CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n00010 ?       :     ALOAD 2\n00011 ?       :     ICONST_1\n00012 ?       :     AALOAD\n00013 ?       :     CHECKCAST java/lang/String\n00014 ?       :     INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n00015 ?       :     ARETURN\n00016 Gau$controlGetHandle Class Object  :  :    L1\n00017 Gau$controlGetHandle Class Object  :  :     ALOAD 0\n00018 Gau$controlGetHandle Class Object  : Gau$controlGetHandle  :     ALOAD 1\n00019 Gau$controlGetHandle Class Object  : Gau$controlGetHandle Class  :     ALOAD 2\n00020 Gau$controlGetHandle Class Object  : Gau$controlGetHandle Class Object  :     INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCallStatic (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;\n00021 ?       :     ARETURN\n00022 Gau$controlGetHandle Class Object  : GroovyRuntimeException  :    L2\n00023 Gau$controlGetHandle Class Object  : GroovyRuntimeException  :     INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n00024 Gau$controlGetHandle Class Object  : Throwable  :     ATHROW\n     TRYCATCHBLOCK L0 L2 L2 groovy/lang/GroovyRuntimeException\njdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 19: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:327)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:262)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:288)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:83)\n    at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\n    at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\n    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\n    at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1(DOS105SearchWindow.groovy:28)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1$accessor$gwqpZzMD(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$TlXTS3Mq.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG(Dossier.java:23)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG$accessor$cLx1vzpU(Dossier.java)\n    at ch.concordia.cip.keywords.Dossier$auxiliary$MOUw9bg6.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\n    at ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nCaused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.getClass(SimpleVerifier.java:346)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:331)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:318)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isSubTypeOf(SimpleVerifier.java:237)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:430)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:76)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Frame.execute(Frame.java:649)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:229)\n    ... 46 more\ncall(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n00000 Gau$controlGetHandle Object Object Object  :  :    L0\n00001 Gau$controlGetHandle Object Object Object  :  :     ALOAD 0\n00002 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00003 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object  :     ALOAD 2\n00004 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object  :     ALOAD 3\n00005 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object Object  :     INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z\n00006 Gau$controlGetHandle Object Object Object  : I  :     IFEQ L1\n00007 Gau$controlGetHandle Object Object Object  :  :     ALOAD 2\n00008 ?         :     CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n00009 ?         :     ALOAD 3\n00010 ?         :     CHECKCAST java/lang/String\n00011 ?         :     INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n00012 ?         :     ARETURN\n00013 Gau$controlGetHandle Object Object Object  :  :    L1\n00014 Gau$controlGetHandle Object Object Object  :  :     ALOAD 0\n00015 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00016 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object  :     ALOAD 2\n00017 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object  :     ALOAD 3\n00018 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object Object  :     INVOKESTATIC org/codehaus/groovy/runtime/ArrayUtil.createArray (Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;\n00019 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object  :     INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCall (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n00020 ?         :     ARETURN\n00021 Gau$controlGetHandle Object Object Object  : GroovyRuntimeException  :    L2\n00022 Gau$controlGetHandle Object Object Object  : GroovyRuntimeException  :     INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n00023 Gau$controlGetHandle Object Object Object  : Throwable  :     ATHROW\n     TRYCATCHBLOCK L0 L2 L2 groovy/lang/GroovyRuntimeException\njdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 19: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:327)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:262)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:288)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:83)\n    at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\n    at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\n    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\n    at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1(DOS105SearchWindow.groovy:28)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1$accessor$gwqpZzMD(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$TlXTS3Mq.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG(Dossier.java:23)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG$accessor$cLx1vzpU(Dossier.java)\n    at ch.concordia.cip.keywords.Dossier$auxiliary$MOUw9bg6.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\n    at ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nCaused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.getClass(SimpleVerifier.java:346)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:331)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:318)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isSubTypeOf(SimpleVerifier.java:237)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:430)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:76)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Frame.execute(Frame.java:649)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:229)\n    ... 46 more\ncallStatic(Ljava/lang/Class;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n00000 Gau$controlGetHandle Class Object Object  :  :    L0\n00001 Gau$controlGetHandle Class Object Object  :  :     ALOAD 0\n00002 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00003 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class  :     ALOAD 2\n00004 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object  :     ALOAD 3\n00005 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object Object  :     INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z\n00006 Gau$controlGetHandle Class Object Object  : I  :     IFEQ L1\n00007 Gau$controlGetHandle Class Object Object  :  :     ALOAD 2\n00008 ?         :     CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n00009 ?         :     ALOAD 3\n00010 ?         :     CHECKCAST java/lang/String\n00011 ?         :     INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n00012 ?         :     ARETURN\n00013 Gau$controlGetHandle Class Object Object  :  :    L1\n00014 Gau$controlGetHandle Class Object Object  :  :     ALOAD 0\n00015 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00016 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class  :     ALOAD 2\n00017 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object  :     ALOAD 3\n00018 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object Object  :     INVOKESTATIC org/codehaus/groovy/runtime/ArrayUtil.createArray (Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;\n00019 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object  :     INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCallStatic (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;\n00020 ?         :     ARETURN\n00021 Gau$controlGetHandle Class Object Object  : GroovyRuntimeException  :    L2\n00022 Gau$controlGetHandle Class Object Object  : GroovyRuntimeException  :     INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n00023 Gau$controlGetHandle Class Object Object  : Throwable  :     ATHROW\n     TRYCATCHBLOCK L0 L2 L2 groovy/lang/GroovyRuntimeException\n// class version 48.0 (48)\n// access flags 0x41001\npublic synthetic class ch/concordia/cip/library/Gau$controlGetHandle extends org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite  {\n// access flags 0x9\n  public static Ljava/lang/reflect/Constructor; constructor\n// access flags 0x1\n  public (Lorg/codehaus/groovy/runtime/callsite/CallSite;Lgroovy/lang/MetaClassImpl;Lgroovy/lang/MetaMethod;[Ljava/lang/Class;Ljava/lang/reflect/Constructor;)V\n    ALOAD 0\n    ALOAD 1\n    ALOAD 2\n    ALOAD 3\n    ALOAD 4\n    INVOKESPECIAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite. (Lorg/codehaus/groovy/runtime/callsite/CallSite;Lgroovy/lang/MetaClassImpl;Lgroovy/lang/MetaMethod;[Ljava/lang/Class;)V\n    ALOAD 5\n    PUTSTATIC ch/concordia/cip/library/Gau$controlGetHandle.constructor : Ljava/lang/reflect/Constructor;\n    RETURN\n    MAXSTACK = 5\n    MAXLOCALS = 6\n// access flags 0x1\n  public call(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n    TRYCATCHBLOCK L0 L1 L1 groovy/lang/GroovyRuntimeException\n   L0\n    ALOAD 0\n    ALOAD 1\n    ALOAD 2\n    INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;[Ljava/lang/Object;)Z\n    IFEQ L2\n    ALOAD 2\n    ICONST_0\n    AALOAD\n    CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n    ALOAD 2\n    ICONST_1\n    AALOAD\n    CHECKCAST java/lang/String\n    INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n    ARETURN\n   L2\n    ALOAD 0\n    ALOAD 1\n    ALOAD 2\n    INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCall (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n    ARETURN\n   L1\n    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n    ATHROW\n    MAXSTACK = 3\n    MAXLOCALS = 3\n// access flags 0x1\n  public callStatic(Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;\n    TRYCATCHBLOCK L0 L1 L1 groovy/lang/GroovyRuntimeException\n   L0\n    ALOAD 0\n    ALOAD 1\n    ALOAD 2\n    INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;[Ljava/lang/Object;)Z\n    IFEQ L2\n    ALOAD 2\n    ICONST_0\n    AALOAD\n    CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n    ALOAD 2\n    ICONST_1\n    AALOAD\n    CHECKCAST java/lang/String\n    INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n    ARETURN\n   L2\n    ALOAD 0\n    ALOAD 1\n    ALOAD 2\n    INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCallStatic (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;\n    ARETURN\n   L1\n    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n    ATHROW\n    MAXSTACK = 3\n    MAXLOCALS = 3\n// access flags 0x1\n  public call(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n    TRYCATCHBLOCK L0 L1 L1 groovy/lang/GroovyRuntimeException\n   L0\n    ALOAD 0\n    ALOAD 1\n    ALOAD 2\n    ALOAD 3\n    INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z\n    IFEQ L2\n    ALOAD 2\n    CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n    ALOAD 3\n    CHECKCAST java/lang/String\n    INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n    ARETURN\n   L2\n    ALOAD 0\n    ALOAD 1\n    ALOAD 2\n    ALOAD 3\n    INVOKESTATIC org/codehaus/groovy/runtime/ArrayUtil.createArray (Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;\n    INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCall (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n    ARETURN\n   L1\n    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n    ATHROW\n    MAXSTACK = 4\n    MAXLOCALS = 4\n// access flags 0x1\n  public callStatic(Ljava/lang/Class;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n    TRYCATCHBLOCK L0 L1 L1 groovy/lang/GroovyRuntimeException\n   L0\n    ALOAD 0\n    ALOAD 1\n    ALOAD 2\n    ALOAD 3\n    INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z\n    IFEQ L2\n    ALOAD 2\n    CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n    ALOAD 3\n    CHECKCAST java/lang/String\n    INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n    ARETURN\n   L2\n    ALOAD 0\n    ALOAD 1\n    ALOAD 2\n    ALOAD 3\n    INVOKESTATIC org/codehaus/groovy/runtime/ArrayUtil.createArray (Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;\n    INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCallStatic (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;\n    ARETURN\n   L1\n    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n    ATHROW\n    MAXSTACK = 4\n    MAXLOCALS = 4\n}\n(Lorg/codehaus/groovy/runtime/callsite/CallSite;Lgroovy/lang/MetaClassImpl;Lgroovy/lang/MetaMethod;[Ljava/lang/Class;Ljava/lang/reflect/Constructor;)V\n00000 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  :  :     ALOAD 0\n00001 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle  :     ALOAD 1\n00002 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle CallSite  :     ALOAD 2\n00003 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle CallSite MetaClassImpl  :     ALOAD 3\n00004 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle CallSite MetaClassImpl MetaMethod  :     ALOAD 4\n00005 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class  :     INVOKESPECIAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite. (Lorg/codehaus/groovy/runtime/callsite/CallSite;Lgroovy/lang/MetaClassImpl;Lgroovy/lang/MetaMethod;[Ljava/lang/Class;)V\n00006 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  :  :     ALOAD 5\n00007 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  : Constructor  :     PUTSTATIC ch/concordia/cip/library/Gau$controlGetHandle.constructor : Ljava/lang/reflect/Constructor;\n00008 Gau$controlGetHandle CallSite MetaClassImpl MetaMethod Class Constructor  :  :     RETURN\njdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 20: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:327)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:262)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:288)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:83)\n    at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\n    at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\n    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\n    at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1(DOS105SearchWindow.groovy:28)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1$accessor$gwqpZzMD(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$TlXTS3Mq.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG(Dossier.java:23)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG$accessor$cLx1vzpU(Dossier.java)\n    at ch.concordia.cip.keywords.Dossier$auxiliary$MOUw9bg6.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\n    at ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nCaused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.getClass(SimpleVerifier.java:346)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:331)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:318)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isSubTypeOf(SimpleVerifier.java:237)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:430)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:76)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Frame.execute(Frame.java:649)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:229)\n    ... 46 more\ncall(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n00000 Gau$controlGetHandle Object Object  :  :    L0\n00001 Gau$controlGetHandle Object Object  :  :     ALOAD 0\n00002 Gau$controlGetHandle Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00003 Gau$controlGetHandle Object Object  : Gau$controlGetHandle Object  :     ALOAD 2\n00004 Gau$controlGetHandle Object Object  : Gau$controlGetHandle Object Object  :     INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;[Ljava/lang/Object;)Z\n00005 Gau$controlGetHandle Object Object  : I  :     IFEQ L1\n00006 Gau$controlGetHandle Object Object  :  :     ALOAD 2\n00007 ?       :     ICONST_0\n00008 ?       :     AALOAD\n00009 ?       :     CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n00010 ?       :     ALOAD 2\n00011 ?       :     ICONST_1\n00012 ?       :     AALOAD\n00013 ?       :     CHECKCAST java/lang/String\n00014 ?       :     INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n00015 ?       :     ARETURN\n00016 Gau$controlGetHandle Object Object  :  :    L1\n00017 Gau$controlGetHandle Object Object  :  :     ALOAD 0\n00018 Gau$controlGetHandle Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00019 Gau$controlGetHandle Object Object  : Gau$controlGetHandle Object  :     ALOAD 2\n00020 Gau$controlGetHandle Object Object  : Gau$controlGetHandle Object Object  :     INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCall (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n00021 ?       :     ARETURN\n00022 Gau$controlGetHandle Object Object  : GroovyRuntimeException  :    L2\n00023 Gau$controlGetHandle Object Object  : GroovyRuntimeException  :     INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n00024 Gau$controlGetHandle Object Object  : Throwable  :     ATHROW\n     TRYCATCHBLOCK L0 L2 L2 groovy/lang/GroovyRuntimeException\njdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 20: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:327)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:262)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:288)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:83)\n    at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\n    at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\n    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\n    at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1(DOS105SearchWindow.groovy:28)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1$accessor$gwqpZzMD(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$TlXTS3Mq.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG(Dossier.java:23)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG$accessor$cLx1vzpU(Dossier.java)\n    at ch.concordia.cip.keywords.Dossier$auxiliary$MOUw9bg6.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\n    at ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nCaused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.getClass(SimpleVerifier.java:346)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:331)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:318)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isSubTypeOf(SimpleVerifier.java:237)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:430)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:76)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Frame.execute(Frame.java:649)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:229)\n    ... 46 more\ncallStatic(Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;\n00000 Gau$controlGetHandle Class Object  :  :    L0\n00001 Gau$controlGetHandle Class Object  :  :     ALOAD 0\n00002 Gau$controlGetHandle Class Object  : Gau$controlGetHandle  :     ALOAD 1\n00003 Gau$controlGetHandle Class Object  : Gau$controlGetHandle Class  :     ALOAD 2\n00004 Gau$controlGetHandle Class Object  : Gau$controlGetHandle Class Object  :     INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;[Ljava/lang/Object;)Z\n00005 Gau$controlGetHandle Class Object  : I  :     IFEQ L1\n00006 Gau$controlGetHandle Class Object  :  :     ALOAD 2\n00007 ?       :     ICONST_0\n00008 ?       :     AALOAD\n00009 ?       :     CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n00010 ?       :     ALOAD 2\n00011 ?       :     ICONST_1\n00012 ?       :     AALOAD\n00013 ?       :     CHECKCAST java/lang/String\n00014 ?       :     INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n00015 ?       :     ARETURN\n00016 Gau$controlGetHandle Class Object  :  :    L1\n00017 Gau$controlGetHandle Class Object  :  :     ALOAD 0\n00018 Gau$controlGetHandle Class Object  : Gau$controlGetHandle  :     ALOAD 1\n00019 Gau$controlGetHandle Class Object  : Gau$controlGetHandle Class  :     ALOAD 2\n00020 Gau$controlGetHandle Class Object  : Gau$controlGetHandle Class Object  :     INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCallStatic (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;\n00021 ?       :     ARETURN\n00022 Gau$controlGetHandle Class Object  : GroovyRuntimeException  :    L2\n00023 Gau$controlGetHandle Class Object  : GroovyRuntimeException  :     INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n00024 Gau$controlGetHandle Class Object  : Throwable  :     ATHROW\n     TRYCATCHBLOCK L0 L2 L2 groovy/lang/GroovyRuntimeException\njdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 19: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:327)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:262)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:288)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:83)\n    at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\n    at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\n    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\n    at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1(DOS105SearchWindow.groovy:28)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1$accessor$gwqpZzMD(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$TlXTS3Mq.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG(Dossier.java:23)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG$accessor$cLx1vzpU(Dossier.java)\n    at ch.concordia.cip.keywords.Dossier$auxiliary$MOUw9bg6.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\n    at ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nCaused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.getClass(SimpleVerifier.java:346)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:331)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:318)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isSubTypeOf(SimpleVerifier.java:237)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:430)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:76)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Frame.execute(Frame.java:649)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:229)\n    ... 46 more\ncall(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n00000 Gau$controlGetHandle Object Object Object  :  :    L0\n00001 Gau$controlGetHandle Object Object Object  :  :     ALOAD 0\n00002 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00003 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object  :     ALOAD 2\n00004 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object  :     ALOAD 3\n00005 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object Object  :     INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z\n00006 Gau$controlGetHandle Object Object Object  : I  :     IFEQ L1\n00007 Gau$controlGetHandle Object Object Object  :  :     ALOAD 2\n00008 ?         :     CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n00009 ?         :     ALOAD 3\n00010 ?         :     CHECKCAST java/lang/String\n00011 ?         :     INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n00012 ?         :     ARETURN\n00013 Gau$controlGetHandle Object Object Object  :  :    L1\n00014 Gau$controlGetHandle Object Object Object  :  :     ALOAD 0\n00015 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00016 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object  :     ALOAD 2\n00017 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object  :     ALOAD 3\n00018 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object Object  :     INVOKESTATIC org/codehaus/groovy/runtime/ArrayUtil.createArray (Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;\n00019 Gau$controlGetHandle Object Object Object  : Gau$controlGetHandle Object Object  :     INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCall (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\n00020 ?         :     ARETURN\n00021 Gau$controlGetHandle Object Object Object  : GroovyRuntimeException  :    L2\n00022 Gau$controlGetHandle Object Object Object  : GroovyRuntimeException  :     INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n00023 Gau$controlGetHandle Object Object Object  : Throwable  :     ATHROW\n     TRYCATCHBLOCK L0 L2 L2 groovy/lang/GroovyRuntimeException\njdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 19: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:327)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:262)\n    at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:288)\n    at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:83)\n    at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:246)\n    at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:288)\n    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)\n    at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3385)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:77)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\n    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1(DOS105SearchWindow.groovy:28)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab$original$xPW9cKA1$accessor$gwqpZzMD(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow$auxiliary$TlXTS3Mq.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.strukt.dos105.search.DOS105SearchWindow.selectNummernTab(DOS105SearchWindow.groovy)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG(Dossier.java:23)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen$original$NseMSOkG$accessor$cLx1vzpU(Dossier.java)\n    at ch.concordia.cip.keywords.Dossier$auxiliary$MOUw9bg6.call(Unknown Source)\n    at ch.concordia.cip.testcases.RunlogAgent$LogAndInvokeMethodInterceptor.logAndInvoke(RunlogAgent.java:100)\n    at ch.concordia.cip.keywords.Dossier.dossierNrLesen(Dossier.java)\n    at ch.concordia.cip.testcases.JUnitTestCaseDossier1.testVolldaten1(JUnitTestCaseDossier1.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nCaused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: org/codehaus/groovy/runtime/callsite/CallSite\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.getClass(SimpleVerifier.java:346)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:331)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isAssignableFrom(SimpleVerifier.java:318)\n    at jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier.isSubTypeOf(SimpleVerifier.java:237)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:430)\n    at jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier.naryOperation(BasicVerifier.java:76)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Frame.execute(Frame.java:649)\n    at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:229)\n    ... 46 more\ncallStatic(Ljava/lang/Class;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n00000 Gau$controlGetHandle Class Object Object  :  :    L0\n00001 Gau$controlGetHandle Class Object Object  :  :     ALOAD 0\n00002 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00003 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class  :     ALOAD 2\n00004 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object  :     ALOAD 3\n00005 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object Object  :     INVOKEVIRTUAL org/codehaus/groovy/runtime/callsite/StaticMetaMethodSite.checkCall (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z\n00006 Gau$controlGetHandle Class Object Object  : I  :     IFEQ L1\n00007 Gau$controlGetHandle Class Object Object  :  :     ALOAD 2\n00008 ?         :     CHECKCAST com/sun/jna/platform/win32/WinDef$HWND\n00009 ?         :     ALOAD 3\n00010 ?         :     CHECKCAST java/lang/String\n00011 ?         :     INVOKESTATIC ch/concordia/cip/library/Gau.controlGetHandle (Lcom/sun/jna/platform/win32/WinDef$HWND;Ljava/lang/String;)Lcom/sun/jna/platform/win32/WinDef$HWND;\n00012 ?         :     ARETURN\n00013 Gau$controlGetHandle Class Object Object  :  :    L1\n00014 Gau$controlGetHandle Class Object Object  :  :     ALOAD 0\n00015 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle  :     ALOAD 1\n00016 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class  :     ALOAD 2\n00017 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object  :     ALOAD 3\n00018 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object Object  :     INVOKESTATIC org/codehaus/groovy/runtime/ArrayUtil.createArray (Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;\n00019 Gau$controlGetHandle Class Object Object  : Gau$controlGetHandle Class Object  :     INVOKESTATIC org/codehaus/groovy/runtime/callsite/CallSiteArray.defaultCallStatic (Lorg/codehaus/groovy/runtime/callsite/CallSite;Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;\n00020 ?         :     ARETURN\n00021 Gau$controlGetHandle Class Object Object  : GroovyRuntimeException  :    L2\n00022 Gau$controlGetHandle Class Object Object  : GroovyRuntimeException  :     INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.unwrap (Lgroovy/lang/GroovyRuntimeException;)Ljava/lang/Throwable;\n00023 Gau$controlGetHandle Class Object Object  : Throwable  :     ATHROW\n     TRYCATCHBLOCK L0 L2 L2 groovy/lang/GroovyRuntimeException\n```\n. @raphw, excellent... problem understood! World class support! \nTomorrow, I'll try the workaround... \nI'll consider asking the Groovy developers what they think about updating their code generation to a later class file version (e.g. 50 instead of 48). Groovy 2.4.x requires Java 6+, so 50 would probably fit well.\n. @raphw, just an idea... why not do an explicit check somewhere in Byte Buddy to check if the class file version is 49 or later. If not, byte buddy could throw a runtime exception with a clear message like \"byte buddy doesn't support byte code manipulation for class file versions below 49 (below Java 1.5).\". (Defensive programming). Just an idea... have a nice day!\n. @raphw, I need some more input do apply\n\"You can still do basic instrumentation in such a case; all you need to do is:\na) If you use @Origin, set the cache property to false.\nb) Set the SelfInitializationStrategy of the AgentBuilder to Disabled.\"\nWhat's the API to do these? How do I set the cache property to false? There is no such interface like SelfInitializationStrategy, how to disable this?\n. How do I actually set the InitializationStrategy on the AgentBuilder? \nSomething like \nnew AgentBuilder.Default().withInitializationStrategy(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)?\n(but this guess from me doesn't work at all... NoClassDefFoundError etc...)\n. Excellent. Thanks a lot for the update.\n. @raphw, you are faster than my CPU! With 0.7.2, it works like a charm out of the box :+1: \n. For the rest of the world... http://stackoverflow.com/questions/33942856/intercepting-method-calls-to-my-java-and-groovy-code-using-byte-buddy-strange-j\n. It works \"out of the box\" with 0.7.2.\nNo special InitializationStrategy, no TypeConstantAdjustment, no @Origin(cache = false)\nJust default\nnew AgentBuilder.Default()\n            .type(ElementMatchers.nameContainsIgnoreCase(MAGIC_CLASSNAME_PART))\n            .transform((builder, typeDescription) ->\n                    builder.method(ElementMatchers.any())\n                            .intercept(MethodDelegation.to(LogAndInvokeMethodInterceptor.class).andThen(SuperMethodCall.INSTANCE)));\nAmazing! ;-)\n. Scary, isn't it? ;-) \nI just switch the version from 0.7.2 to 0.7.1 and I get the java.lang.VerfifyError. When I switch back to 0.7.2, it works. \nI double checked it with a breakpoint in my method interceptor: Gau#controlGetHandle passes there. So I assume it was instrumented.\nI have to leave now and can you give more feedback next monday, if you want.\nBest regards from Switzerland & thanks again!\nPeti\n. Hi @raphw, \nhere's is an example to reproduce to behaviour:\nhttps://github.com/Petikoch/bytebuddy_groovy_methodlogging\nWith Byte Buddy 0.7.1 ->  VerifyError\nWith Byte Buddy 0.7.2 -> ok\n(just switch the version number in the build.gradle file and run the gradle build)\nIt's now also clear for me, where exactly the Groovy byte code generation happens... when some Groovy code calls methods from an other class (Java or Groovy).\nBest regards & have a nice day,\nPeti\n. Thanks a lot @raphw for the update. \nHave a nice sunday!\nBest regards,\nPeti\n. ",
    "sevensecondsaway": "A custom matcher does the job! Thanks! \nAnd congratulations on the Duke's Choice award, well deserved! Byte Buddy is a true gem.\n. Many many apologies, this is of course possible. My intellij has been messing with me all day. Maven caches are probably corrupt...\nI'm closing this issue, apologies again.\n. Indeed that was I was missing, thank you! My use case is pretty simple, I'm trying to log sql statements as part a our QA test suite, and maybe also some timing info. I'm basically starting from scratch here, given than byte-buddy has evolved quite a bit since the last time I looked into building similar agents.\nI do have some follow up questions:\n- what's the performance impact of ignore(none())? is it in startup, runtime or both? What would you consider to be best practice here? I'm asking this because byte-buddy is really a fantastic Swiss army knife code generation lib but it's lack of documentation makes its learning curve rather steep, hence limits its adoption. Especially since the API is evolving.\n  Maybe this is something that someone can sponsor or crowdfund through something like patreon.com?\n- Along the same lines, would it be possible for you to provide example code on how to go about building what you'd consider to be common use cases of byte-buddy? The tests are great but they too lack documentation.\nthanks!\n. Thank you, this is exactly what I was looking for. I understand the business situation, and I know you're very proactive in addressing questions, bugs and requests from the community. I can't promise anything, but I'll put a request with my management to look into you contracting with us. I first need to build a solid business case :) \n. ",
    "segeon": "Thank you very much for providing such thorough suggestion so quickly. I finally solved this problem following your advice, but with one more step. \nFirst, I followed your advice to delegate to an unloaded type using TypePool.Default.of(ClassFileLocator.ForClassLoader.of(classLoader)).describe(interceptorClassName).resolve(). In which the classloader is the spring boot classloader that has been set to the thread context classloader. However, the classloader can't resolve the interceptor class neither. So I take a look into the spring boot classloader, and find out a sad fact that it neglect system loader when finding resources.\npublic URL getResource(String name) {\n       URL url = null;\n   if (this.rootClassLoader != null) {\n      url = this.rootClassLoader.getResource(name);\n   }\n   return (url == null ? findResource(name) : url);\n}\nIn above code, the rootClassLoader is the ExtClassloader. As a result, the ClassFileLocator created by ClassFileLocator.ForClassLoader.of(classLoader) can not locate the class file through getResourceAsStream. I worked around this problem by using a second step: package the agent jar into spring boot uber jar. This way, the agent related classes can be loaded by spring boot class loader. Although this solution is not so elegant, it at least works! \n. @raphw I've answered my question on Stackoverflow and raised an issue for spring boot. Hope they can come up with a more elegant solution.\n. @raphw I want to solve this problem more elegantly and not package my agent into spring boot application. One possible method is to inject my agent related classes into spring boot's LaunchedURLClassloader. I find that ClassInjector.UsingReflection can help me achieve this. However, it can not link a class. So I have to manually inject every referenced class into the spring boot's classloader. Is there an better way to solve this using bytebuddy? Thanks again!\n. Yeah, I've thought about the same way. Thanks very much. Maybe this is the best choice I have for now.\n. ",
    "ransoor2": "\nYeah, I've thought about the same way. Thanks very much. Maybe this is the best choice I have for now.\n\nDid this solution work for you? . ",
    "CalebFenton": "Right, javac won't compile it, but javac will in some cases make classes that have multiple fields with the same name and different type.\npublic class OverloadedFields2 {\n    static final int[] $assertionsDisabled = new int[0];\n    public static void main(String[] args) {\n        System.out.println($assertionsDisabled.length);\n        assert System.currentTimeMillis() == 0L;\n    }\n}\njavac adds another field called $assertionsDisabled:\n```\n  static final int[] $assertionsDisabled;\n    descriptor: [I\n    flags: ACC_STATIC, ACC_FINAL\nstatic final boolean $assertionsDisabled;\n    descriptor: Z\n    flags: ACC_STATIC, ACC_FINAL, ACC_SYNTHETIC\n```\nIt's an edge case, sure. I'm dealing with classes that have been obfuscated, so they're using all kinds of tricks and doing things that are valid at the bytecode level but not by the compiler.\n. This library is pretty boss. I'm actually learning some tricks going through the code. Thanks for what must have been a lot of effort and work.\nThis is an ugly hack but I'd feel guilty if I didn't share it. This is the change I made to get things working until 1.x:\nif (!fieldNames.add(fieldName+fieldDescription.getType().toString())) {\n. ",
    "YoannBuch": "Thank you Raphael for the detailed explanation!\nThat seems to me like a reasonable workaround until they fix this issue (though I suspect it's not an isolated case, and not only other parts of Spring Boot but also other projects may have this issue too).\nI wasn't really wanting to use a type reference because it's hard to test. But the example you provided is perfect, I can still inject whatever dependencies I need into Foo without the need to make static calls, awesome. And it works really well, my spring boot application loads with no further issues.\nAnd thank you for the pull request, I'll keep an eye on it.\n. Thank you all! I'll give it a try asap.\n. Tested with the 1.3.x branch and it's fixed. Thank you @wilkinsona and @raphw!\n. Instead of delegating to an instance I tried to delegate to a class (which in turns delegates to an instance) but I run into another issue (as part of the Intellij scenario):\n```\npublic class Interceptor {\n// Using this pattern after our discussion:\n// https://github.com/raphw/byte-buddy/issues/95#issuecomment-175559645\nprivate static volatile Interceptor dispatcher;\n\npublic static void setDispatcher(Interceptor dispatcher) {\n\n    // Prints \"CL: sun.misc.Launcher$AppClassLoader@14dad5dc\"\n    System.out.println(\"CL: \" + Interceptor.class.getClassLoader());\n\n    Interceptor.dispatcher = dispatcher;\n}\n\n@RuntimeType\npublic static Object doIntercept(@SuperCall Callable<?> zuper) throws Exception {\n\n    // Prints \"CL: com.intellij.util.lang.UrlClassLoader@17c386de\"\n    System.out.println(\"CL: \" + Interceptor.class.getClassLoader());\n\n    // 'setDispatcher' was first called, then 'doIntercept'\n    // but 'dispatcher' is null => NullPointerException\n    // \n    // Hypothesis: 'Interceptor' class was loaded twice, the first one\n    // got its static member 'dispatcher' assigned to a value whereas \n    // the second one didn't?\n    return dispatcher.intercept(zuper);\n}\n\nprivate Object intercept(Callable<?> zuper)\n        throws Exception {\n\n    System.out.println(\"Intercepted!\");\n\n    return zuper.call();\n}\n\n}\n```\n. Thank you, Rafael!\nI'm not sure to understand your suggestion. How can I make the interceptor an instance of a primitive and still be able to add my interception methods to it? \n. I think I understand that part. What I don't understand is how I can give an instance of a java.* type to Byte Buddy and at the same time augmenting that same type with methods used for interception. \n. I'm not sure what you mean. What I understand:\nI should not do the following otherwise Interceptor will be loaded twice, which causes the NullPointerException when its static member dispatcher is used:\nreturn builder.method(isDeclaredBy(typeDescription))\n  .intercept(MethodDelegation.to(Interceptor.class));\nMaking the dispatcher an instance of java.* type doesn't solve the problem.\nsetDispatcher(Function function)\ndispatcher will be null.\nI thought I should give to Byte Buddy a java.* type like:\nreturn builder.method(isDeclaredBy(typeDescription))\n  .intercept(MethodDelegation.to(java.lang.Runnable.class));\nHowever I can't add behavior (i.e. a new static member or a new method) to Runnable, like adding that method:\n@RuntimeType\npublic static Object doIntercept(@SuperCall Callable<?> zuper) throws Exception\nExtending or implementing a java.* type won't help either because that new type won't be part of the bootstrap class loader.\nAlso, like mentioned in the first comment, I also tried to give Byte Buddy an instance of Interceptor:\nreturn builder.method(methodMatchers(typeDescription))\n  .intercept(MethodDelegation.to(new Interceptor()));\nWhich gave me the following exception:\n\nCaused by: java.lang.IllegalArgumentException: Can not set static com.test.Interceptor field com.intellij.coverage.CoverageExecutor.delegate$867271420 to com.test.Interceptor\n  at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:167)\n  at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:171)\n  at sun.reflect.UnsafeStaticObjectFieldAccessorImpl.set(UnsafeStaticObjectFieldAccessorImpl.java:79)\n  at java.lang.reflect.Field.set(Field.java:764)\n  at com.test.shaded.net.bytebuddy.implementation.LoadedTypeInitializer$ForStaticField.onLoad(LoadedTypeInitializer.java:105)\n  at com.test.shaded.net.bytebuddy.implementation.LoadedTypeInitializer$Compound.onLoad(LoadedTypeInitializer.java:180)\n  at com.test.shaded.net.bytebuddy.agent.builder.AgentBuilder$InitializationStrategy$SelfInjection$Dispatcher$InjectingInitializer.onLoad(AgentBuilder.java:1542)\n\nWhat am I missing?\n. Thank you so much for taking the time to explain all that!\nIt's a shame the IllegalArgumentException is not more explicit about what really happens. But now I understand.\nI used the system property map and it finally works! Note that I could not cast my instance of Interceptor (same issue with different class loaders) and therefore had to use reflection to make the call. That's probably not a good idea as it will slow things down, right?\n```\npublic class Interceptor {\n@RuntimeType\npublic static Object doIntercept(@SuperCall Callable<?> zuper) throws Exception {\n\n    Properties systemProperties = System.getProperties();\n\n    // the property \"myinterceptor\" was set when the java agent started\n    Object interceptorInstance = systemProperties.get(\"myinterceptor\");\n\n    // Throws ClassCastException:\n    // Interceptor interceptor = (Interceptor) interceptorInstance\n\n    Method interceptMethod = interceptorInstance.getClass().getMethod(\n        \"intercept\", \n        Callable.class);\n\n    return interceptMethod.invoke(interceptorInstance, zuper);\n}\n\npublic Object intercept(Callable<?> zuper)\n        throws Exception {\n\n    System.out.println(\"Intercepted!\");\n\n    return zuper.call();\n}\n\n}\n```\nTaking a step back, I feel like my case is pretty common, don't you think? \nIf we generalize things, one usually gives to Byte Buddy class or instance interceptors that were loaded by the system class loader. It's a problem because instrumented classes may be loaded by class loaders that are different from the system class loader. If I understand things right, it may therefore impact a wide range of applications: web containers, OSGI apps, applications like IntelliJ, etc.\n. I finally got the time to work on this. Thanks for the hint, it solved a bunch of my problems. I added all the classes of my agent to the bootstrap class loader similarly as what was done in this agent:\nhttps://github.com/glowroot/glowroot/blob/9cec83704211d4c374c799ebf9f036be461a7126/agent-parent/agent/src/main/java/org/glowroot/agent/AgentPremain.java \n. FYI, it's not working out of the box for some OSGI frameworks. By default, bundles have a limited access to classes available from the bootstrap class loader. The workaround is to explicitly tell the framework what packages should be available to bundles through the setting org.osgi.framework.bootdelegation.\n. I didn't think about it, thanks!\n. I'm afraid I can't do that:\njava.lang.SecurityException: Prohibited package name: java.com.mycompany\n. You're right. My mistake was that I renamed the packages in the source and therefore I was getting that exception when I was running my tests (where the bootstrap class loader is not used). \nI solved it by renaming my packages only when I maven package my agent jar.\n. Thanks!. I used Advice and it worked pretty well! I don't know why I was reluctant to use it because it meets all my requirements, for now.\nIt's taking ~7 seconds to retransform ~130 classes. Is it normal? Instrumenting these classes at first load  felt a lot faster.. Too bad retransformation is that slow. I had a couple of ideas where I could use it.\nOne was to remove the instrumentation to decrease the overhead when it is no longer needed (my target namespace is generally quite big: all the classes of the running application and optionally some of its dependencies), and re-instrumenting when it is needed again (possibly using a different target namespace). But to be honest I have never really measured the overhead and maybe it is acceptable for my use case. By the way, does Advice gives me better performance (speed) than \"classic\" method delegation?\nThe other idea was to remove the instrumentation from \"noisy\" methods. I noticed that a few methods make up most of the captured calls. If I remove the instrumentation from them I could drastically reduce the amount of calls I have to capture and therefore the overhead. I don't know which methods are the noisy ones prior to execution therefore I have to detect them on the fly and remove the instrumentation from them one by one (and as fast as possible). So how can I tell ByteBuddy to remove a transformation done on a specific class? (vs all classes like ResettableClassFileTransformer.reset does)\nOnce I removed the instrumentation from that class I would reapply the instrumentation on all the methods of this class but the noisy method. Again this should happen fast, but hopefully retransforming just one class is fast.\n. Ok, well that's good to know before I waste more time down that path :)\nThanks again!. ",
    "wilkinsona": "@YoannBuch It's also in the 1.3.x branch. If you'd like to try a 1.3.3 snapshot, one will be available from https://repo.spring.io/libs-snapshot once this build has finished.\n. > I'm still baffled as to why this fails in one environment and not in another\nI've tracked this down to a side-effect of the order in which tests were being run. There was another test in the same module that was causing the thread context class loader to be set and then not restored to its original value. When it ran first, the pollution of the TCCL then prevented the subclass from being created, presumably due to the same package being defined by two different class loaders. . > As for more diagnostics; this is difficult to realize as the class loading API provides close to zero feedback on why a resolution fails. I will look into improving this.\nI was just hoping to see the IllegalAccessError in the exception that Byte Buddy throws, rather than having to do some digging in the debugger to find it.. > Byte Buddy chains the exception, it should be visible from the stack.\nThat's what I thought when I looked at the code\u2026\n\nDid your tooling cut of the stack because it was too long?\n\nI don't think so, but let me double-check.. Well, I'm glad I double-checked as that's exactly what's happening. The stack trace that I posted above is the entirety of what's output by Surefire (both to the console and in its report file). However, if I trigger the problem in Eclipse, I get:\n```\norg.mockito.exceptions.base.MockitoException: \nMockito cannot mock this class: class org.springframework.boot.loader.data.RandomAccessDataFile$FilePool.\nMockito can only mock non-private & non-final classes.\nIf you're not sure why you're getting this error, please report to the mailing list.\nJava               : 1.8\nJVM vendor name    : Oracle Corporation\nJVM vendor version : 25.121-b13\nJVM name           : Java HotSpot(TM) 64-Bit Server VM\nJVM version        : 1.8.0_121-b13\nJVM info           : mixed mode\nOS name            : Mac OS X\nOS version         : 10.12.4\nUnderlying exception : java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#findClass\n    at org.springframework.boot.loader.data.RandomAccessDataFileTests.seekFailuresDoNotPreventSubsequentReads(RandomAccessDataFileTests.java:332)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:48)\n    at org.junit.rules.ExpectedException$ExpectedExceptionStatement.evaluate(ExpectedException.java:239)\n    at org.junit.rules.RunRules.evaluate(RunRules.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#findClass\n    at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Direct.defineClass(ClassInjector.java:412)\n    at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:185)\n    at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:187)\n    at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)\n    at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4376)\n    at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:94)\n    at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)\n    at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)\n    at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)\n    at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)\n    at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)\n    at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)\n    at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)\n    at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)\n    at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)\n    at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)\n    at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)\n    at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)\n    at org.mockito.Mockito.spy(Mockito.java:1812)\n    ... 29 more\nCaused by: java.lang.IllegalAccessError: class org.springframework.boot.loader.data.RandomAccessDataFile$FilePool$MockitoMock$650243775 cannot access its superclass org.springframework.boot.loader.data.RandomAccessDataFile$FilePool\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Direct.defineClass(ClassInjector.java:408)\n    ... 47 more\n```\nSurefire's behaviour is spectacularly unhelpful, but obviously nothing to do with Byte Buddy. Sorry for the noise.\nThe only other thing that I noticed and mentioned above is that the message in the exception created by Byte Buddy is referring to the wrong method. For example it says findClass here where it was actually defineClass that was called. The implementation of getPackage has a similar problem.. ",
    "zcfrank1st": "Thanks, but I tried\n\n\n.type(declaresMethod(isAnnotatedWith(Log.class)))\n.transform((builder, typeDescription) -> builder\n                  .method(isDeclaredBy(any()))\n                  .intercept(MethodDelegation.to(LogInterceptor.class).andThen(SuperMethodCall.INSTANCE)))\n\n\nand run java -javaagent:logger-1.0-SNAPSHOT.jar -cp /Users/zcfrank1st/Desktop/git-svn/agent-demo/target/agent-demo-1.0-SNAPSHOT.jar Main\nthe terminal prints None of [] allows for delegation from void Main.hello()\njava.lang.IllegalArgumentException: None of [] allows for delegation from void Main.hello()\n. :+1:  it worked !  Thanks a lot ~ \n. ",
    "simonjenga": "I just confirmed that this problem has been fixed in the latest:\n<artifactId>mockito-core</artifactId>\n<version>2.0.40-beta</version>\nand\n<artifactId>mockito-core</artifactId>\n<version>2.0.41-beta</version>\nActually, it was a problem of corrupt jars being downloaded. I deleted the two JARS from my .m2 repo and downloaded them again and it worked.\nhttp://stackoverflow.com/questions/23310474/hibernate-commons-annotations-4-0-1-final-jar-invalid-loc-header-bad-signature\nYou may close this issue.\n. @raphw OK, thanks for letting me know.\n. ",
    "bokken": "Can any/all future incompatible changes (whether binary or source) result in major version changes?\n. @CodingFabian, I am using net.bytebuddy.jar.asm.MethodVisitor as part of implementing a custom net.bytebuddy.implementation.bytecode.ByteCodeAppender implementation for a custom net.bytebuddy.implementation.Implementation implementation.\n. I certainly understand your concern about the passivity of asm. \nThis raises some questions for me about the intended use of ByteCodeAppender. It is an interface which defines only a single method which includes a MethodVisitor parameter. Is the intention that only the bytebuddy project provide implementations of ByteCodeAppender?\nThe documentation does provide examples of providing custom implementations of this. Are you saying this should not actually be done? \n. Perhaps there is a easier/better way to accomplish what I am trying to do. I am wanting to define a class with 3 final member variables and a constructor which takes 3 parameters and populates the 3 variables.\nIn some cases, I need to call a super constructor with 1 of the parameters. \nThe only way I found to do this was to write a custom implementation with this appender implementaiton:\n```\n        public ByteCodeAppender appender(final Target implementationTarget)\n        {\n            return new ByteCodeAppender()\n            {                      \n                @Override\n                public ByteCodeAppender.Size apply(final MethodVisitor methodVisitor, final Context implementationContext, final MethodDescription instrumentedMethod)\n                {\n                    final FieldList fields = implementationTarget.getInstrumentedType().getDeclaredFields();\n                final List<StackManipulation> stack = new ArrayList<StackManipulation>(16);\n                stack.add(MethodVariableAccess.REFERENCE.loadOffset(0));\n                if (stringConstructor)\n                {\n                    stack.add(MethodVariableAccess.REFERENCE.loadOffset(1));\n                    stack.add(MethodInvocation.invoke(new TypeDescription.ForLoadedType(proxyClass)\n                                                                         .getDeclaredMethods()\n                                                                         .filter(ElementMatchers.isConstructor().and(ElementMatchers.takesArguments(String.class)))\n                                                                         .getOnly()));\n                }\n                else\n                {\n\n                    stack.add(MethodInvocation.invoke(new TypeDescription.ForLoadedType(proxyClass.isInterface() ? Object.class : proxyClass)\n                                                                         .getDeclaredMethods()\n                                                                         .filter(ElementMatchers.isConstructor().and(ElementMatchers.takesArguments(0)))\n                                                                         .getOnly()));\n                }\n\n                stack.add(MethodVariableAccess.REFERENCE.loadOffset(0));\n                stack.add(MethodVariableAccess.REFERENCE.loadOffset(1));\n                stack.add(FieldAccess.forField(fields.filter(ElementMatchers.named(AUTHORITY_VAR_NAME)).getOnly()).putter());\n\n                stack.add(MethodVariableAccess.REFERENCE.loadOffset(0));\n                stack.add(MethodVariableAccess.REFERENCE.loadOffset(2));\n                stack.add(FieldAccess.forField(fields.filter(ElementMatchers.named(INTERCEPTORS_VAR_NAME)).getOnly()).putter());\n\n                stack.add(MethodVariableAccess.REFERENCE.loadOffset(0));\n                stack.add(MethodVariableAccess.REFERENCE.loadOffset(3));\n                stack.add(FieldAccess.forField(fields.filter(ElementMatchers.named(ACTUAL_VAR_NAME)).getOnly()).putter());\n\n                stack.add(MethodReturn.VOID);\n\n                final StackManipulation manipulation = new StackManipulation.Compound(stack);\n\n                final StackManipulation.Size size = manipulation.apply(methodVisitor, implementationContext);\n\n                return new ByteCodeAppender.Size(size.getMaximalSize(), instrumentedMethod.getStackSize());\n            }\n        };\n    }\n\n```\nIs there a different approach I should be taking?\n. @CodingFabian, while that certainly /can/ be done, in my specific use, that provides no actual additional passivity safety. I simply need the class definition as an import. I call no methods on it. If something were to change about it, it would require changes to the ByteBuddy \"public\" api, which would be non-passive regardless of how I interact with asm.\n. @CodingFabian, I found that paragraph/section this morning. The last sentence or 2 provides warnings of what happens if you do not follow the guidance.\nI am simply trying to point out that in my specific use (which I included above), my code only references the MethodVisitor and takes it from byte buddy code (specifically, whatever it is which calls the ByteCodeAppender.apply method) and gives it to byte buddy code (specifically the StackManipulation.apply method). The code I am providing does not call any methods on the MethodVisitor. The only way I could be impacted by a change in asm is if the change were so dramatic as to cause byte buddy to change the method signatures of either of those 2 methods. If that were to occur, I would be impacted regardless if I shaded (can I use that as a verb?) asm/bytebuddy or not, as this would be a non-passive change to the public byte buddy api.\nSince I /cannot/ be impacted by any asm change which allows byte buddy to keep byte buddy's apis passive, I would prefer not to be required to shade byte buddy just be able to run in an osgi container.\n. Yes, that works. It took me a bit to realize that you added the constructor to ByteCodeAppender.Simple which takes a List in 1.3.20.\n. I want it to delegate it to the hashCode method inherited from Object.\n. Is the punchline that MethodDelegation toField will only delegate to public methods declared on that field's type and not inherited methods?\nIs it not any inherited methods or limited to not methods on Object?. My foo is not of type Object, it is some type which is known at runtime, In the case of the specific example I originally posted about, it is:\n```\npublic interface SomeInterface {\npublic void method1(String string, Object obj, int i, short s, double d, float f, long l);\n\npublic String method2();\n\npublic SomeInterface clone();\n\npublic void ioException() throws IOException;\n\n}\n```\nAny instance of SomeInterface will also be an Object. The Exception message I get, however, lists the methods explicitly on SomeInterface and states no match can be found for hashCode. \nIf I add the filter to the MethodDelegation for hashCode method (as shown in your example above) I get a message stating \"None of [] allows for delegation from public native int java.lang.Object.hashCode()\". This seems to indicate that only methods declared on the type are being examined. Is this expected?\n. I am trying to redirect the call to member variable.. ",
    "hengyunabc": "I don not want to add a method to a loaded class. I want to edit a method in place.\nI use ByteBuddyAgent.install(); and asm to print log before original method be called.\nCan you tell me how to do this in byte-buddy way?\n``` java\nimport java.lang.instrument.ClassFileTransformer;\nimport java.lang.instrument.IllegalClassFormatException;\nimport java.lang.instrument.Instrumentation;\nimport java.lang.instrument.UnmodifiableClassException;\nimport java.security.ProtectionDomain;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport net.bytebuddy.agent.ByteBuddyAgent;\npublic class AsmTest {\npublic static class ModifierMethodWriter extends MethodVisitor {\n\n    private String methodName;\n\n    public ModifierMethodWriter(int api, MethodVisitor mv, String methodName) {\n        super(api, mv);\n        this.methodName = methodName;\n    }\n\n    // This is the point we insert the code. Note that the instructions are\n    // added right after\n    // the visitCode method of the super class. This ordering is very\n    // important.\n    @Override\n    public void visitCode() {\n        super.visitCode();\n        super.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\");\n        super.visitLdcInsn(\"method: \" + methodName);\n        super.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\");\n    }\n\n}\n\n// Our class modifier class visitor. It delegate all calls to the super\n// class\n// Only makes sure that it returns our MethodVisitor for every method\npublic static class ModifierClassWriter extends ClassVisitor {\n    private int api;\n\n    public ModifierClassWriter(int api, ClassWriter cv) {\n        super(api, cv);\n        this.api = api;\n    }\n\n    @Override\n    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n\n        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n        ModifierMethodWriter mvw = new ModifierMethodWriter(api, mv, name);\n        return mvw;\n    }\n\n}\n\npublic static class SimpleClassFileTransformer implements ClassFileTransformer {\n\n    @Override\n    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n            ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n\n        ClassReader classReader = new ClassReader(classfileBuffer);\n\n        final ClassWriter cw = new ClassWriter(classReader, ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n\n        // Wrap the ClassWriter with our custom ClassVisitor\n        ModifierClassWriter mcw = new ModifierClassWriter(Opcodes.ASM5, cw);\n        classReader.accept(mcw, 0);\n\n        byte[] byteArray = cw.toByteArray();\n\n        return byteArray;\n    }\n\n}\n\npublic static class Foo {\n    String m() {\n        return \"foo\";\n    }\n}\n\npublic static void main(String[] args) throws UnmodifiableClassException {\n    Foo foo = new Foo();\n\n    System.out.println(\"before transform\");\n    System.out.println(foo.m());\n\n    ByteBuddyAgent.install();\n    Instrumentation instrumentation = ByteBuddyAgent.getInstrumentation();\n    instrumentation.addTransformer(new SimpleClassFileTransformer(), true);\n\n    instrumentation.retransformClasses(Foo.class);\n\n    System.out.println(\"after transform\");\n    System.out.println(foo.m());\n}\n\n}\n```\n. Thank you very much.\n. ",
    "leon90dm": "It's close but  doesn't solve my problem.\nHow can i generate MyInterceptor in runtime based on Person and attribute name.\nclass MyInterceptor {\n  public static Object intercept(Object arg) {\n    // do what you intend to do such as:\n    return ((Person) arg).getName();\n  }\n}\nthat's to say this stuff return ((Person) arg).getName(); is generated in runtime. Cause i have many other attributes to generate such as\nclass MyInterceptor {\n  public static Object intercept(Object arg) {\n    return ((Person) arg).getAge();\n  }\n}\nWhile i don't want to write MyInterceptor for every attribute of Person.\n. Awesome That's it! Thanks a lot\uff01\n. ",
    "don-vip": "Maybe some other tasks must be done by Oracle first: https://bugs.openjdk.java.net/browse/JDK-8148651\n. ASM6 beta has been released: https://mail.ow2.org/wws/arc/asm/2017-07/msg00002.html. It seems it has finally reached Maven Central: http://repo1.maven.org/maven2/org/ow2/asm/asm/6.0_BETA/. ",
    "norswap": "Thanks for the detailed answer.\nIt was more of a general question -- I struggled against not being able to do this when trying things out (mostly not understanding why it didn't work), but I don't actually need it.\nBy the way, is there a way to get some kind of diagnostics of byte buddy's operations? As a beginner, a few times I felt puzzled as things I expected to work didn't and I couldn't really tell what Byte Buddy's decision process was. Just some form of log would be very helpful (kind of like make has).\nThe solution you propose does seem satisfactory. The exception is perhaps when the list of classes for which the behavior should be modified is not known in advance.\n. ",
    "dragontree101": "i slove this problem, because in springboot exclude javaagent\nso i add myagent.jar url into springboot classloader by reflect in springboot ApplicationEnvironmentPreparedEvent , \n\nprivate static Method ADD_URL;\n  private static Set URL_SET = new HashSet<>();\n  static {\n    try {\n      ADD_URL = URLClassLoader.class.getDeclaredMethod(\"addURL\", URL.class);\n      ADD_URL.setAccessible(true);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n  public boolean injectToURLClassLoader(URL[] urls, URLClassLoader classLoader)\n      throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {\n    if (urls != null) {\n      for (URL url : urls) {\n        if (!URL_SET.contains(url)) {\n          ADD_URL.invoke(classLoader, url);\n          URL_SET.add(url);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\nand i use \nbuilder.method(...)..intercept(...) can works\nbut\uff0c i want to update to byte buddy 1.3.19 and use advice annotation to refactor my code\nbuilder.visit(Advice.to(....).on(.....));\nand has error\nonError:org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher\njava.lang.NoClassDefFoundError: javax/ws/rs/core/Response\n    at java.lang.Class.getDeclaredMethods0(Native Method)\n    at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)\n    at java.lang.Class.getDeclaredMethods(Class.java:1975)\n    at net.bytebuddy.description.method.MethodList$ForLoadedType.<init>(MethodList.java:90)\n    at net.bytebuddy.description.type.TypeDescription$ForLoadedType.getDeclaredMethods(TypeDescription.java:7414)\n    at net.bytebuddy.asm.Advice.to(Advice.java:227)\n    at net.bytebuddy.asm.Advice.to(Advice.java:211)\n.... \ni don't know what's different from builder.method(...)..intercept(...) bewteen builder.visit(Advice.to(....).on(.....))\ni guess when i use  builder.method(...)..intercept(...)  springboot's classloader not load this class,\nnow i doesn't slove this problem again \n. thanks very much ,  i try it tomorrow  \uff1a\uff09\n. thanks very much\n. if i both use .method( ... ).intercept( ... ) API and Advice API ,  have any bad influence \uff1f if i want to get Method i use .method( ... ).intercept( ... ) and others use Advice API\n. i both use .method( ... ).intercept( ... ) API and Advice API, it works ok,\nbut i want to know Advice API's  performance and .method( ... ).intercept( ... ) 's performance  which is best? have any test data?\n. because of i custom a java annotation(@count(value=\"123\")) on some methods,\nactually i want to know the the method of annotation's value,  if i use Advice API,  have any way to get the value: \"123\" on @Advice.OnMethodEnter ?\n. thanks very much!\ni will study  how to use Advice.withCustomMapping().bind(MyAnnotation.class, myBinder), i will update some code to my byte buddy demo.\n. now in @Advice.OnMethodEnter return hashmap parameter, and in @Advice.OnMethodExit get hashmap parameter, use this way to pass parameter between in @Advice.OnMethodEnter and  @Advice.OnMethodExit is best way? or have any better way?\nthanks very much\n. thanks!\n. thanks, i am waiting for you to deploy the lastest jar to maven.\n. i update to 1.4.0 version, and use \n.type(hasSuperType(named(\"javax.ws.rs.container.ContainerRequestFilter\")))\n .transform(new RequestFilterAdviceTransformer())\n\band also has the same exception: \njava.lang.IllegalStateException: Cannot advice abstract or native method public abstract void javax.ws.rs.container.ContainerRequestFilter.filter(javax.ws.rs.container.ContainerRequestContext) throws java.io.IOException\ndoes my code error?\nbut when i use\n.type(isSubTypeOf(ContainerRequestFilter.class))\n .transform(new RequestFilterAdviceTransformer())\nis ok\n. so i can't use hasSuperType(named(\"javax.ws.rs.container.ContainerRequestFilter\"))  constant triggers  ?  \n. i found \n@Advice.FieldValue(value = \"args\")\nObject field\ncan get private field   :)\n. previously version is 1.3.19,  previous i startup app it can intercept, but i use 1.4.15 it intercept when i call method.\n. i means in 1.4.15 version \uff0c  \npublic class AdviceProfiledTransformer  implements AgentBuilder.Transformer{\n  @Override\n  public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder,\n      TypeDescription typeDescription, ClassLoader classLoader) {\n  }\n}\nwill be call when i new AdviceProfiled()   and in 1.3.19 version at application startup\n. i am so sorry,  orz,   it seems my fault .  seems 1.3.19 and 1.4.15 seems the same\ncould i  call transform  method when i startup my application?\nbecause of if i can call transform  method when i startup my application i will cause my first request faster, maybe startup will slow\n. i use Advice   i want to get others method's annotation, \ni want to get this @TestAnnotation value when i call foo() function?\n. yes,  that agent has premain(String, Instrumentation) method.\nbut i don't know how to call it's premain(String, Instrumentation)  method in my code ,\ncould you give me an example?\n. thanks .\ni need use byte-buddy's inst by ByteBuddyAgent.getInstrumentation() ?\n. thanks very much\uff0c i will try it\uff0c hope it will success! \n. thanks, i add ignore code, the error message not to print.\nhow can i use NewRelic's jar use bytebuddy's api rather than -javaagent? \nbecause of we startup application use java -jar app.jar command, but i don't want to add -javaagent command on startup, i'm not found any way can remove -javaagent command.\n. sorry my response is late,  i find new relic jars manifest, it want to read a yml file (normal new relic use -javaagent to start up), and this file in my uber's jar (i use springboot), so new relic jar can not read this yml and throw exception :( \nmaybe it not byte buddy's question.... it seems i can set readonly to false\uff0c and set t = null \ni found if t = null , the exception will not to be throw.. ",
    "felixbarny": "I just scanned through my StagemonitorJavassistInstrumenters and I actually don't need access to the method arguments. But I have come across some more requirements:\n- Accessing the return value: SpringMvcRequestNameDeterminerInstrumenter\n- Adding local variables: TimedInstrumenter\n- Adding catch clauses: ExceptionMeteredInstrumenter\nIs it possible to use the Advice API with the AgentBuilder to for example profile all classes that are in a certain package or is it only possible to instrument individual classes?\nThese are some of the pain points I currently have with javassist:\n- Especially my ProfilingInstrumenter is quite slow, because it is applied to many methods and Javassist has to compile the source every time. This increases startup times a bit\n- Instrumenting classes that are loaded by a different classloader than the ApplicationClassLoader is very tricky in application server environments. For example the javax.sql.DataSource is often loaded by a ModuleClassLoader of the application server and the class is loaded only once, even if you have deployed multiple applications. This makes it very hard to only apply the instrumentation to one of the deployed applications and requires some fancy hacks like in ConnectionMonitoringInstrumenter where I (ab)use System.getProperties().put(Object, Object) to share objects between classloaders. This leads to a lot of trouble because many libraries only expect Strings in the system properties: https://github.com/stagemonitor/stagemonitor/issues/99.\n- Javassist loads the CtClasses classes directly from the classpath and thus erases any previous bytecode manipulations: https://github.com/stagemonitor/stagemonitor/issues/130\n. Hi Raphael,\nthat's awesome news!\nCould you give me a quick example of how to use the Advice API in combination with the AgentBuilder API?\n\nFor example, a class like: [...] can be injected into the bootstrap class loader using the Instrumentation API\n\nI guess you mean the instrumentation.appendToBootstrapClassLoaderSearch(JarFile) method? How can Byte Buddy assist here? The Dispatcher pattern is exactly what I need, thanks a lot! Works just like the system property hack but without breaking things for others. Do you know of any blog which describes that in more detail?\n. Ah, nice. I was missing the builder.visit(Advice.to(MyAdvice.class).on(ElementMatchers.any())) part.\nWould the agent contain the jar as a resource? This is my current understanding of it:\n```\nagent\n+- src/main/java\n|   - org.example.Agent.java // instrumentation.appendToBootstrapClassLoaderSearch(dispatcherJar)\n+- src/main/resources\n|   - dispatcher.jar\n|       - org.example.Dispatcher.class\n- pom.xml\n    provided dispatcher\n    some magic to add the dispatcher jar into the agent jar\ndispatcher\n- src/main/java\n    - org.example.Dispatcher.java\naccessing-code\n+- src/main/java\n|   - ... // Dispatcher.VALUES.get(String)\n- pom.xml\n    provided dispatcher\n```\n. ~~Have you already added the possibility to extract a signature in a custom format?~~\nnevermind, just found this commit: https://github.com/raphw/byte-buddy/commit/7823ff84afc9d7dbc90e3a4f51416f5260ad2648\n. I tried using the Advice API but I thinks there is something wrong with my matchers. The advice does not get applied: https://github.com/felixbarny/byte-buddy-test/blob/686953fd20b15036f4e01abbc87194a425edbdd8/src/test/java/net/bytebuddy/test/TestByteBuddyProfiler.java\nAlso, how do I capture the return value when value is the added local variable?\n. That's great news!\nIt will probably take a while until I find the time to migrate all of the Javassist code to Byte Buddy. But I think some migrations won't be that easy. With Javassist It's easy to make dynamic templates by just concatenating strings. For example, I'm using this in the MonitorRequestsInstrumenter to compile the dynamic request name into the bytecode that should be inserted. In Byte Buddy the bytecode templates are fairly static. Afaik, you can only customize them with the @Origin annotation. I don't know if this is possible, but one idea would be an annotation that can be put on a method which then gets evaluated at bytecode templating time (or whatever this is called) instead of be part of the bytecode that will be inserted. Does that make sense?\nAlso, I realized that I do need to get all method arguments. Also, is it possible to @Advice.Return Object returnValueOfAnyType?\n```\n@Advice.OnMethodEnter\npublic static void onEnter(@Origin Method method, @Arguments Object[] args) {\n    MonitorRequestsInstrumenter.getRequestMonitor().monitorStart(new MonitoredMethodRequest(getRequestName(method), null, args));\n}\n@Inline\npublic static String getRequestName(Method Method) {\n    return configuration.getBusinessTransactionNamingStrategy().getBusinessTransationName(method.getDeclaringClass().getSimpleName(), method.getName());\n}\n@Advice.OnMethodExit\npublic static void exit(@Advice.Return Object returnValueOfAnyType) {  \n     MonitorRequestsInstrumenter.getRequestMonitor().monitorStop(returnValueOfAnyType);\n}\n```\n. I've managed to implement the dispatcher. There was one pitfall, though. \nJBoss' ModuleClassLoader is not kind enough to load the class, even if it is added via Instrumentation#appendToBootstrapClassLoaderSearch(JarFile). I worked around this by reflectively loading the class and getting the dispatcher's map. See https://github.com/stagemonitor/stagemonitor/pull/144/commits/25afd93d06bf3be70b95a2e76c5369e94b75a089#diff-49e6f419628c01b107f821cb65b0934a.\nThe only thing that stops me from merging this is #111 \nThank you very much for your help! Greatly appreciate it!\n. I just successfully migrated the profiler to Byte Buddy!\nI really love the clean and simple API. The only tricky part is boolean logic :laughing:.\nI encountered a strange error in combination with Javassist, though. If I apply the Byte Buddy ClassFileTransformers before the Javassist ones everything is working fine, but when I put it the other way around (by swapping the lines 85 and 86 in MainStagemonitorClassFileTransformer),  suddenly this test fails. It seems that the insertAfter call in MonitorRequestsInstrumenter gets deleted then.\nIs there a possibility to store the transformed class on disk with byte buddy? I did this with my Javassist based ClassFileTransformer with a decorator. But the Byte Buddy API does not seem to allow for decorators to be injected.\nThe classes.zip contains two versions of the SlaInstrumenterTest$SlaTestClass class. In the byte-buddy-first folder you can see the result of both transformers with Byte Buddy being the first transformer. The javassist-folder contains a version of the class with only the Javassist transformation applied (because I don't know how to export the class after the Byte Buddy transformation). \n. Thx for the hint, I've now also exported the class when the Byte Buddy transformer was last: \nclasses.zip\nInterestingly, the monitorStart call via insertBefore does get executed but the monitorStop call added via insertAfter does not.\nBut all calls seem to be included in the resulting bytecode. This is an excerpt of the decompiled method (via jd):\njavassist-first (not working)\n@SLAs({@SLA(metric={SLA.Metric.P95, SLA.Metric.MAX}, threshold={0.0D, 0.0D}), @SLA(errorRateThreshold=0.0D)})\n  @MonitorRequests\n  void monitorSla()\n  {\n    Profiler.start(\"org.stagemonitor.alerting.annotation.SlaInstrumenterTest$SlaTestClass.monitorSla()V\");\n    try\n    {\n      try\n      {\n        MonitorRequestsInstrumenter.getRequestMonitor().monitorStart(new MonitoredMethodRequest(\"Monitor Sla\", null, new Object[0]));throw null;\n      }\n      catch (Exception localException)\n      {\n        localException = localException;MonitorRequestsInstrumenter.getRequestMonitor().recordException(localException);throw localException;\n      }\n      finally\n      {\n        localObject2 = finally;Object localObject1 = null;MonitorRequestsInstrumenter.getRequestMonitor().monitorStop();throw ((Throwable)localObject2);\n      }\n    }\n    finally\n    {\n      Profiler.stop();\n      if (localException == null) {\n        return;\n      }\n    }\n  }\nbyte-buddy-first (working)\n@SLAs({@SLA(metric={SLA.Metric.P95, SLA.Metric.MAX}, threshold={0.0D, 0.0D}), @SLA(errorRateThreshold=0.0D)})\n  @MonitorRequests\n  void monitorSla()\n  {\n    try\n    {\n      MonitorRequestsInstrumenter.getRequestMonitor().monitorStart(new MonitoredMethodRequest(\"Monitor Sla\", null, new Object[0]));Profiler.start(\"org.stagemonitor.alerting.annotation.SlaInstrumenterTest$SlaTestClass.monitorSla()V\");\n      try\n      {\n        throw null;\n      }\n      finally\n      {\n        Profiler.stop();\n      }\n      break label73;\n      throw ((Throwable)localObject1);\n    }\n    catch (Exception localException)\n    {\n      localException = localException;MonitorRequestsInstrumenter.getRequestMonitor().recordException(localException);throw localException;\n    }\n    finally\n    {\n      localObject3 = finally;localObject2 = null;MonitorRequestsInstrumenter.getRequestMonitor().monitorStop();throw ((Throwable)localObject3);\n    }\n    label73:\n    Object localObject2 = null;\n    MonitorRequestsInstrumenter.getRequestMonitor().monitorStop();\n  }\n. nice! glad i could help!\n. Thx, you are awesome!\n. The withCustomMapping() API is working great! What did you extend in the @Advice.Origin annotation? More patterns? Could not find it in the docs.\nI also have encountered a VerifyError when the @Advice.OnMethodExit is more complicated. When the annotation is placed here instead of there, I get a verify error when executing the tests.\n. Do you think it would be better to recompute stack frames in production for now? Would this avoid such problems? I could even make this configurable.\nIt is astonishing how fast you are in fixing bugs and implementing features! Kudos! Are you working full time on Byte Buddy?\n. Thx for the tips.\nI've just noticed that I can't debug classes that are transformed. Even with previous versions of Byte Buddy. Is this some sort of limitation or am I doing something terribly wrong?\n. The problem is that I can't debug the \"client code\" I'm instrumenting which is quite scary. For example when I'm instrumenting a Elasticsearch class, I'm not able to debug it anymore. Maybe this is an issue of IntelliJ 2016.1.0... I'll try it with a different IDE.\n. I have a question on how to match a method in a tricky case.\nI want to instrument the javax.sql.DataSource.getConnection() method. Sounds easy, but if this method is declared in a superclass which does not implement the DataSource interface, things get tricky.\n```\nprivate class AbstractTestDataSource {\n    Connection connection;\npublic Connection getConnection() throws SQLException {\n    return connection;\n}\n\n}\nprivate class TestDataSource extends AbstractTestDataSource implements DataSource {\n}\n```\nMy first naive attempt was to use this type matcher\nnameEndsWith(\"DataSource\")\n        .and(isSubTypeOf(DataSource.class))\n        .and(not(isInterface()))\nand this method matcher:\nnamed(\"getConnection\")\n        .and(returns(Connection.class))\n        .and(isPublic())\n        .and(takesArguments(String.class, String.class).or(takesArguments(0)))\nBut this obviously fails, because the javax.sql.DataSource.getConnection() method is not declared inside TestDataSource. Can you think of a clever way to match this? Is this a matter of AgentBuilder.TypeStrategy.Default.REDEFINE vs REDEFINE_DECLARED_ONLY?\nNote that I also want to inject @Advice.This DataSource into the @Advice.OnMethodExit like this:\n@Advice.OnMethodExit\nprivate static void addDirectMonitorMethodCall(@Advice.This DataSource dataSource, \n                                                @Advice.Return(readOnly = false) Connection connection, \n                                                @Advice.Enter long startTime) {\n    connection = monitorGetConnection(dataSource, connection, startTime);\n}\n. Aah, of course. I see what you did there ;)\nAt runtime the @Advice.This Object dataSource is TestDataSource which implements DataSource and not AbstractTestDataSource.\nThx for your great support. Asking you is much easier than thinking myself :laughing: \n. Hi Raphael, its me again ;)\nI'm almost done with the Byte Buddy migration! It is really exciting how fast it is going.\nIn order to properly migrate the SlaTransformer I'd need a possibility to not transform the class but just use Byte Buddy for classpath scanning to select some methods. So I'd propose a @Advice.OnClassLoaded annotation which just executes the annotated method and injects the values for the selected methods but does not modify it's bytecode.\nAlso the InjectAnnotationDynamicValue might be worth to be included as a standard feature in Byte Buddy.\n. @OriginAnnotation would probably be a better name though\n. In a way similar to a static initializer but without modifying the class. Just as a callback executed within the ClassFileTransformer#transform method. Obviously, @This, @Thrown, @Return, @FieldValue and the like can't be applied in that context, because we are not \"inside\" the class nor is there a concrete instance. It would just be a feature for class path scanning.\nFor example Spring uses a simmilar mechanism to find all classes which are annotated with @Component and then registers them in it's container. In my case, I want to find all methods annotated with @SLA and automatically create a check for those methods which alerts if a performance threshold is breached. Therefore, I don't want to modify the class at all. I just want to find those methods and then read the values of the @SLA annotation to create and register the check. The insertion of the underlying timer only stems from the @MonitorRequests annotation. This could potentially be very interesting for other frameworks as well. I don't know if the Agent API is the right place for this, but the @Origin and the DynamicValue features could be used then.\nTo be honest, I didn't test this I only committed the class to show my work in progress to you. But I don't want to inject a annotation value but the annotation itself which is placed upon the instrumented method.\nActually for four reasons. To avoid potential subtile bugs that may be left over, to minimize the byte code size, because I suppose that the calculation of stack frames is cheaper then and because debugging is easier.\n. I worked around this by abusing the DynamicValue interface as the callback mechanism: https://github.com/stagemonitor/stagemonitor/commit/f210dfa2c452ff2c10a79f993ccc363d11290e41#diff-20d34e096b9571f629b86bd30f0078dbR72\n. Ah, sure, that makes sense. I have used the listener before but did not think of it in this case! That could be something that you could promote more or write a blog about: \"Hyper fast class path scanning with Byte Buddy\" :D\nI've noticed Byte Buddy is quite large (I don't really have a problem with that though). Did you think about modularizing Byte Buddy? Just a thought...\n. That makes sense.\nI'm not quite sure whether I should shade byte-buddy (and byte-buddy-agent) into org.stagemonitor.bytebuddy. What would you recommend?\n. I just encountered an ArrayIndexOutOfBoundsException when executing org.stagemonitor.InstrumentationPerformanceTest#main with a strange stack trace..\nSLF4J: Actual binding is of type [org.slf4j.impl.SimpleLoggerFactory]\n[main] INFO org.stagemonitor.core.instrument.AgentAttacher - Registering ServletProfilingTransformer\n[main] INFO org.stagemonitor.core.instrument.AgentAttacher - Registering FilterProfilingTransformer\n[main] INFO org.stagemonitor.core.instrument.AgentAttacher - Registering SpringMvcRequestNameDeterminerTransformer\n[main] WARN org.stagemonitor.core.instrument.StagemonitorByteBuddyTransformer - org.springframework.web.servlet.DispatcherServlet\njava.lang.ArrayIndexOutOfBoundsException: 7\n    at net.bytebuddy.jar.asm.ClassReader.a(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.a(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.a(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.b(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.doCreate(TypeWriter.java:2719)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2702)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1572)\n    at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:179)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:4564)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:4865)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)\n    at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)\n    at net.bytebuddy.agent.builder.AgentBuilder$RedefinitionStrategy$Collector$ForRetransformation.apply(AgentBuilder.java:2202)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default.installOn(AgentBuilder.java:4006)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Delegator.installOn(AgentBuilder.java:5046)\n    at org.stagemonitor.core.instrument.AgentAttacher.initByteBuddyClassFileTransformers(AgentAttacher.java:105)\n    at org.stagemonitor.core.instrument.AgentAttacher.performRuntimeAttachment(AgentAttacher.java:57)\n    at org.stagemonitor.core.Stagemonitor.reset(Stagemonitor.java:246)\n    at org.stagemonitor.core.Stagemonitor.<clinit>(Stagemonitor.java:39)\n    at org.stagemonitor.InstrumentationPerformanceTest.main(InstrumentationPerformanceTest.java:32)\n. You checked out the byte-buddy-advice branch, right? I've just added a gradle task to execute this test: ./gradlew instrumentationPerformanceTest. Tested with jdk1.8.0_25 and jdk1.8.0_66 on OSX.\n. This also happens with 1.8.0_77-b03 :( And it happens on every execution.\n. Yes, the current state is committed. Are you working on OSX as well?\nI just encountered another exception when deploying spring petclinic with the current snapshot of stagemonitor powered by Byte Buddy which is caused by the transformation in org.stagemonitor.logging.MeterLoggingTransformer\nWARN  StagemonitorByteBuddyTransformer - org.apache.log4j.Logger\njava.lang.IllegalStateException: Illegal field modifiers 266248 for static java.lang.Class org.apache.log4j.Logger.class$org$apache$log4j$Logger\n    at net.bytebuddy.dynamic.scaffold.InstrumentedType$Default.validated(InstrumentedType.java:747) ~[byte-buddy-1.3.12.jar:na]\n    at net.bytebuddy.dynamic.scaffold.MethodRegistry$Default.prepare(MethodRegistry.java:530) ~[byte-buddy-1.3.12.jar:na]\n    at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:164) ~[byte-buddy-1.3.12.jar:na]\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:4564) ~[byte-buddy-1.3.12.jar:na]\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:4865) ~[byte-buddy-1.3.12.jar:na]\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188) [na:1.8.0_25]\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428) [na:1.8.0_25]\n    at java.lang.ClassLoader.defineClass1(Native Method) [na:1.8.0_25]\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:760) [na:1.8.0_25]\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) [na:1.8.0_25]\n    at org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:2957) [catalina.jar:7.0.57]\n    at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1210) [catalina.jar:7.0.57]\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1690) [catalina.jar:7.0.57]\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1571) [catalina.jar:7.0.57]\n    at java.lang.Class.forName0(Native Method) [na:1.8.0_25]\n    at java.lang.Class.forName(Class.java:344) [na:1.8.0_25]\n    at org.jboss.logging.LoggerProviders.tryLog4j(LoggerProviders.java:91) [jboss-logging-3.1.3.GA.jar:3.1.3.GA]\n    at org.jboss.logging.LoggerProviders.findProvider(LoggerProviders.java:68) [jboss-logging-3.1.3.GA.jar:3.1.3.GA]\n    at org.jboss.logging.LoggerProviders.find(LoggerProviders.java:31) [jboss-logging-3.1.3.GA.jar:3.1.3.GA]\n    at org.jboss.logging.LoggerProviders.<clinit>(LoggerProviders.java:28) [jboss-logging-3.1.3.GA.jar:3.1.3.GA]\n    at org.jboss.logging.Logger.getLogger(Logger.java:2163) [jboss-logging-3.1.3.GA.jar:3.1.3.GA]\n    at org.jboss.logging.Logger.getLogger(Logger.java:2188) [jboss-logging-3.1.3.GA.jar:3.1.3.GA]\n    at org.hibernate.jpa.HibernatePersistenceProvider.<clinit>(HibernatePersistenceProvider.java:55) [hibernate-entitymanager-4.3.10.Final.jar:4.3.10.Final]\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) [na:1.8.0_25]\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) [na:1.8.0_25]\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) [na:1.8.0_25]\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:408) [na:1.8.0_25]\n    at java.lang.Class.newInstance(Class.java:438) [na:1.8.0_25]\n    at org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter.<init>(HibernateJpaVendorAdapter.java:93) [spring-orm-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) [na:1.8.0_25]\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) [na:1.8.0_25]\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) [na:1.8.0_25]\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:408) [na:1.8.0_25]\n    at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:147) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:89) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1094) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1046) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:476) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:299) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:122) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1477) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1222) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:476) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:303) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:299) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194) [spring-beans-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:956) [spring-context-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:747) [spring-context-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:480) [spring-context-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:434) [spring-web-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306) [spring-web-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106) [spring-web-4.1.7.RELEASE.jar:4.1.7.RELEASE]\n    at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4994) [catalina.jar:7.0.57]\n    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5492) [catalina.jar:7.0.57]\n    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) [catalina.jar:7.0.57]\n    at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:901) [catalina.jar:7.0.57]\n    at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877) [catalina.jar:7.0.57]\n    at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:649) [catalina.jar:7.0.57]\n    at org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1760) [catalina.jar:7.0.57]\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_25]\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_25]\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_25]\n    at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_25]\n    at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:301) [tomcat-coyote.jar:7.0.57]\n    at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) [na:1.8.0_25]\n    at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) [na:1.8.0_25]\n    at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:618) [catalina.jar:7.0.57]\n    at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:565) [catalina.jar:7.0.57]\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_25]\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_25]\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_25]\n    at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_25]\n    at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:301) [tomcat-coyote.jar:7.0.57]\n    at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) [na:1.8.0_25]\n    at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) [na:1.8.0_25]\n    at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1466) [na:1.8.0_25]\n    at javax.management.remote.rmi.RMIConnectionImpl.access$300(RMIConnectionImpl.java:76) [na:1.8.0_25]\n    at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1307) [na:1.8.0_25]\n    at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1399) [na:1.8.0_25]\n    at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:828) [na:1.8.0_25]\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_25]\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_25]\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_25]\n    at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_25]\n    at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:323) [na:1.8.0_25]\n    at sun.rmi.transport.Transport$1.run(Transport.java:178) [na:1.8.0_25]\n    at sun.rmi.transport.Transport$1.run(Transport.java:175) [na:1.8.0_25]\n    at java.security.AccessController.doPrivileged(Native Method) [na:1.8.0_25]\n    at sun.rmi.transport.Transport.serviceCall(Transport.java:174) [na:1.8.0_25]\n    at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:557) [na:1.8.0_25]\n    at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:812) [na:1.8.0_25]\n    at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:671) [na:1.8.0_25]\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_25]\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_25]\n    at java.lang.Thread.run(Thread.java:745) [na:1.8.0_25]\n. The application is however able to start and even the logging metrics seem to work. I should note that Spring PetClinic is actually using LogBack as the logging provider.\n. Great, thx. Any suggestion regarding shading for stagemonitor (see https://github.com/raphw/byte-buddy/issues/110#issuecomment-209868603)?\n. That's great. I hate shading. Especially with gradle.\n. Yes, this also happens when just executing the main method inside IntelliJ 2016.1.0. Importing stagemonitor as a gradle project in IntelliJ should be straightforward.\n. If this makes sense:\n\nActually for four reasons. To avoid potential subtile bugs that may be left over, to minimize the byte code size, because I suppose that the calculation of stack frames is cheaper then and because debugging is easier.\n\nMaybe it is something that should be done automatically, if the @Advice.On... method is public. If it's private it could be inlined (current behavior). The biggest advantage is that you can then debug the method. But this may be to magical...\n. I just made a few simple performance measurements and to be honest, I was quite shocked. I should have done this earlier...\nI've logged the time it takes for each agent I created to call the installOn(instrumentation) method. As you can see the agents mostly don't even match anything so there are not a lot of retransformations going on (which are quite expensive). I think this is probably due to slow matchers, I will investigate more. \nDEBUG AgentAttacher - Attached SlaTransformer in 729 ms\nDEBUG AgentAttacher - Attached ExceptionMeteredTransformer in 474 ms\nDEBUG AgentAttacher - Attached TimedTransformer in 401 ms\nDEBUG AgentAttacher - Attached MeteredTransformer in 378 ms\nDEBUG AgentAttacher - Attached GaugeTransformer in 393 ms\nDEBUG AgentAttacher - Attached DefaultConnectionMonitoringTransformer in 552 ms\nDEBUG AgentAttacher - Attached ReflectiveConnectionMonitoringTransformer in 466 ms\nINFO  StagemonitorByteBuddyTransformer - Transformed ch.qos.logback.classic.Logger with MeterLoggingTransformer\nDEBUG AgentAttacher - Attached MeterLoggingTransformer in 892 ms\nDEBUG AgentAttacher - Attached ProfilingTransformer in 523 ms\nDEBUG AgentAttacher - Attached MethodLevelMonitorRequestsTransformer in 496 ms\nDEBUG AgentAttacher - Attached ClassLevelMonitorRequestsTransformer in 451 ms\nDEBUG AgentAttacher - Attached ServletProfilingTransformer in 379 ms\nDEBUG AgentAttacher - Attached FilterProfilingTransformer in 383 ms\nINFO  StagemonitorByteBuddyTransformer - Transformed org.springframework.web.servlet.DispatcherServlet with ServletProfilingTransformer\nINFO  StagemonitorByteBuddyTransformer - Transformed org.springframework.web.servlet.FrameworkServlet with ServletProfilingTransformer\nINFO  StagemonitorByteBuddyTransformer - Transformed org.springframework.web.servlet.DispatcherServlet with ServletProfilingTransformer\nINFO  StagemonitorByteBuddyTransformer - Transformed org.springframework.web.servlet.DispatcherServlet with SpringMvcRequestNameDeterminerTransformer\nDEBUG AgentAttacher - Attached SpringMvcRequestNameDeterminerTransformer in 453 ms\nDEBUG AgentAttacher - Attached agents in 7328 ms\nFor most transformers, the scope is limited to org.springframework.samples.petclinic. For others, the scope is even more narrow (like SpringMvcRequestNameDeterminerTransformer and MeterLoggingTransformer which have a explicit named() matcher)\nTotal time to start Tomcat 7 with Spring Petclinic:\nJavassist: 14s\nByte Buddy: 24s\nRight now I'm creating quite a few agents. Is there a possibility to create some kind of compound agents? What I mean by that there is only one installOn(instrumentation) call and the ClassFileTransformer contains multiple type matchers and transformers. Maybe this would allow for better optimizations. But this is highly speculative. Will try to get more insight of what is actually slow.\n. Most of the time seems to be burned by my shitty ElementMatcher<ClassLoader> which checks ClassUtils.canLoadClass(target, \"org.stagemonitor.core.Stagemonitor\") which in turn calls classloader.load(String). That is expensive, of course. Will try to cache the result.\n. What do you mean by ignore class loader?\n. Thx for the tips. I'm confident that I'll be able to make it a lot faster. What is the difference between ignore and type? Is ignore just a default not(type) that is always applied before the type matcher? I dont really get why ignore any() seems to mean don't ignore anything. How would you apply such a classloader matcher in a performant way: https://github.com/stagemonitor/stagemonitor/blob/master/stagemonitor-core/src/main/java/org/stagemonitor/core/instrument/StagemonitorJavassistInstrumenter.java#L92? Cache the results?\n. Looking much better now:\n```\nDEBUG AgentAttacher - Attached SlaTransformer in 137 ms\nDEBUG AgentAttacher - Attached ExceptionMeteredTransformer in 11 ms\nDEBUG AgentAttacher - Attached TimedTransformer in 10 ms\nDEBUG AgentAttacher - Attached MeteredTransformer in 9 ms\nDEBUG AgentAttacher - Attached GaugeTransformer in 12 ms\nDEBUG AgentAttacher - Attached DefaultConnectionMonitoringTransformer in 15 ms\nDEBUG AgentAttacher - Attached ReflectiveConnectionMonitoringTransformer in 8 ms\nINFO  StagemonitorByteBuddyTransformer - Transformed ch.qos.logback.classic.Logger with MeterLoggingTransformer\nDEBUG AgentAttacher - Attached MeterLoggingTransformer in 410 ms\nDEBUG AgentAttacher - Attached ProfilingTransformer in 13 ms\nDEBUG AgentAttacher - Attached MethodLevelMonitorRequestsTransformer in 10 ms\nDEBUG AgentAttacher - Attached ClassLevelMonitorRequestsTransformer in 11 ms\nDEBUG AgentAttacher - Attached ServletProfilingTransformer in 9 ms\nDEBUG AgentAttacher - Attached FilterProfilingTransformer in 10 ms\nDEBUG AgentAttacher - Attached SpringMvcRequestNameDeterminerTransformer in 10 ms\nDEBUG AgentAttacher - Attached agents in 842 ms\nINFO  metrics - Metrics ========================================================================\n-- Timers ----------------------------------------------------------------------\nname                                                                                   | count     | mean      | min       | max       | stddev    | p50       | p75       | p95       | p98       | p99       | p999      | mean_rate | m1_rate   | m5_rate   | m15_rate  | rate_unit     | duration_unit\n                         element_matcher,transformer=MeterLoggingTransformer,type=type |     1.137 |      7,25 |      0,40 |  5.248,99 |    163,66 |      1,25 |      1,59 |      5,00 |      8,73 |     16,13 |    161,36 |  1.702,60 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                       element_matcher,transformer=MeterLoggingTransformer,type=method |        95 |      6,81 |      1,88 |     92,40 |     12,18 |      3,80 |      5,55 |     19,16 |     61,08 |     92,40 |     92,40 |    177,44 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                                  element_matcher,transformer=SlaTransformer,type=type |     1.138 |      4,88 |      1,25 |     74,66 |      5,00 |      3,90 |      4,78 |     10,88 |     16,89 |     25,72 |     72,64 |  1.203,70 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                           element_matcher,transformer=SlaTransformer,type=classloader |     2.244 |      4,31 |      0,13 |    460,40 |     29,38 |      1,05 |      1,31 |      3,33 |     35,47 |     77,24 |    449,94 |  2.372,40 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                            element_matcher,transformer=ProfilingTransformer,type=type |     1.482 |      1,64 |      0,45 |     36,99 |      1,74 |      1,19 |      1,90 |      3,15 |      3,73 |      4,54 |     21,16 |  5.682,02 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                     element_matcher,transformer=ExceptionMeteredTransformer,type=type |     1.137 |      1,24 |      0,42 |     18,50 |      1,09 |      1,02 |      1,17 |      2,06 |      2,64 |      4,73 |     17,43 |  1.289,38 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                                element_matcher,transformer=TimedTransformer,type=type |     1.137 |      1,05 |      0,37 |     14,02 |      0,74 |      0,92 |      1,07 |      1,55 |      1,84 |      2,60 |     13,73 |  1.307,42 |      0,00 |      0,00 |      0,00 | second        | microseconds\n           element_matcher,transformer=MethodLevelMonitorRequestsTransformer,type=type |     1.482 |      0,99 |      0,46 |     12,10 |      0,53 |      0,91 |      1,04 |      1,64 |      1,88 |      1,97 |      7,56 |  5.887,05 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                                element_matcher,transformer=GaugeTransformer,type=type |     1.137 |      0,95 |      0,35 |     20,77 |      0,69 |      0,88 |      0,95 |      1,31 |      1,62 |      2,09 |      7,56 |  1.338,95 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                              element_matcher,transformer=MeteredTransformer,type=type |     1.137 |      0,94 |      0,32 |     14,97 |      0,51 |      0,88 |      0,96 |      1,24 |      1,58 |      1,80 |      5,31 |  1.313,32 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                      element_matcher,transformer=FilterProfilingTransformer,type=type |     1.482 |      0,84 |      0,34 |    107,26 |      3,73 |      0,57 |      0,64 |      0,90 |      1,15 |      2,17 |     32,35 |  6.652,51 |      0,00 |      0,00 |      0,00 | second        | microseconds\n          element_matcher,transformer=DefaultConnectionMonitoringTransformer,type=type |     1.137 |      0,81 |      0,13 |     43,41 |      2,34 |      0,38 |      0,59 |      2,32 |      4,29 |      7,98 |     29,91 |  1.426,56 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                     element_matcher,transformer=ServletProfilingTransformer,type=type |     1.482 |      0,70 |      0,36 |     13,64 |      0,54 |      0,64 |      0,76 |      1,02 |      1,19 |      1,31 |     10,84 |  6.270,24 |      0,00 |      0,00 |      0,00 | second        | microseconds\n            element_matcher,transformer=ClassLevelMonitorRequestsTransformer,type=type |     1.482 |      0,67 |      0,36 |      6,29 |      0,38 |      0,57 |      0,65 |      1,37 |      1,75 |      2,07 |      5,61 |  5.895,20 |      0,00 |      0,00 |      0,00 | second        | microseconds\n       element_matcher,transformer=SpringMvcRequestNameDeterminerTransformer,type=type |     1.482 |      0,63 |      0,37 |      5,30 |      0,20 |      0,59 |      0,68 |      0,87 |      1,05 |      1,17 |      1,78 |  6.756,89 |      0,00 |      0,00 |      0,00 | second        | microseconds\n   element_matcher,transformer=DefaultConnectionMonitoringTransformer,type=classloader |     2.243 |      0,37 |      0,13 |     12,86 |      0,45 |      0,34 |      0,43 |      0,55 |      0,90 |      1,28 |      3,44 |  2.786,15 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                     element_matcher,transformer=ProfilingTransformer,type=classloader |     2.608 |      0,31 |      0,06 |     42,96 |      2,32 |      0,16 |      0,19 |      0,21 |      0,28 |      0,36 |     33,56 |  9.142,40 |      0,00 |      0,00 |      0,00 | second        | microseconds\n              element_matcher,transformer=ExceptionMeteredTransformer,type=classloader |     2.243 |      0,30 |      0,13 |      6,37 |      0,32 |      0,30 |      0,31 |      0,55 |      0,94 |      1,21 |      3,84 |  2.476,04 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                         element_matcher,transformer=TimedTransformer,type=classloader |     2.243 |      0,28 |      0,09 |      3,71 |      0,23 |      0,30 |      0,32 |      0,47 |      0,73 |      1,20 |      2,99 |  2.511,96 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                       element_matcher,transformer=MeteredTransformer,type=classloader |     2.243 |      0,28 |      0,09 |     14,70 |      0,56 |      0,29 |      0,31 |      0,35 |      0,64 |      1,02 |      9,98 |  2.538,58 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                  element_matcher,transformer=MeterLoggingTransformer,type=classloader |     2.243 |      0,26 |      0,10 |     15,69 |      0,57 |      0,24 |      0,27 |      0,43 |      0,53 |      0,94 |      8,90 |  3.178,15 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                         element_matcher,transformer=GaugeTransformer,type=classloader |     2.243 |      0,25 |      0,09 |      2,38 |      0,16 |      0,28 |      0,30 |      0,35 |      0,55 |      0,93 |      2,15 |  2.567,53 |      0,00 |      0,00 |      0,00 | second        | microseconds\nelement_matcher,transformer=ReflectiveConnectionMonitoringTransformer,type=classloader |     2.243 |      0,25 |      0,14 |      7,99 |      0,32 |      0,21 |      0,25 |      0,34 |      0,48 |      1,28 |      3,14 |  3.116,31 |      0,00 |      0,00 |      0,00 | second        | microseconds\n       element_matcher,transformer=ReflectiveConnectionMonitoringTransformer,type=type |     1.106 |      0,21 |      0,08 |     24,16 |      0,81 |      0,15 |      0,22 |      0,30 |      0,38 |      0,48 |      9,18 |  1.534,51 |      0,00 |      0,00 |      0,00 | second        | microseconds\nelement_matcher,transformer=SpringMvcRequestNameDeterminerTransformer,type=classloader |     2.608 |      0,16 |      0,05 |      9,26 |      0,29 |      0,20 |      0,21 |      0,22 |      0,25 |      0,32 |      0,79 | 11.125,69 |      0,00 |      0,00 |      0,00 | second        | microseconds\n    element_matcher,transformer=MethodLevelMonitorRequestsTransformer,type=classloader |     2.608 |      0,16 |      0,06 |     17,89 |      0,56 |      0,16 |      0,18 |      0,25 |      0,28 |      0,30 |      1,35 |  9.219,82 |      0,00 |      0,00 |      0,00 | second        | microseconds\n               element_matcher,transformer=FilterProfilingTransformer,type=classloader |     2.608 |      0,14 |      0,05 |      1,46 |      0,09 |      0,18 |      0,20 |      0,21 |      0,26 |      0,28 |      1,42 | 10.474,58 |      0,00 |      0,00 |      0,00 | second        | microseconds\n     element_matcher,transformer=ClassLevelMonitorRequestsTransformer,type=classloader |     2.608 |      0,11 |      0,05 |      8,48 |      0,28 |      0,08 |      0,08 |      0,26 |      0,49 |      0,65 |      1,60 |  9.494,58 |      0,00 |      0,00 |      0,00 | second        | microseconds\n              element_matcher,transformer=ServletProfilingTransformer,type=classloader |     2.608 |      0,08 |      0,05 |      0,66 |      0,04 |      0,08 |      0,08 |      0,11 |      0,15 |      0,20 |      0,54 |  9.938,58 |      0,00 |      0,00 |      0,00 | second        | microseconds\n```\nStartup times:\nByte Buddy ~10s\nNo instrumentation ~7s\nIm caching the results of my ClassLoader matcher. The key is the identityHash of the classloader (to not create memory leaks by storing classloader references). This is my ignore setting: .ignore(nameStartsWith(\"java\").or(nameStartsWith(\"com.sun\")), isBootstrapClassLoader()).\nTimers after startup:\n-- Timers ----------------------------------------------------------------------\nname                                                                                   | count     | mean      | min       | max       | stddev    | p50       | p75       | p95       | p98       | p99       | p999      | mean_rate | m1_rate   | m5_rate   | m15_rate  | rate_unit     | duration_unit\n                              element_matcher,transformer=TimedTransformer,type=method |        63 |      5,35 |      0,46 |     25,65 |      4,79 |      3,82 |      7,37 |     16,39 |     18,89 |     25,65 |     25,65 |      8,64 |     12,60 |     12,60 |     12,60 | second        | microseconds\n        element_matcher,transformer=DefaultConnectionMonitoringTransformer,type=method |        25 |      4,89 |      0,46 |     36,43 |      8,93 |      1,49 |      2,74 |     30,55 |     36,43 |     36,43 |     36,43 |      3,39 |      5,00 |      5,00 |      5,00 | second        | microseconds\n                                element_matcher,transformer=SlaTransformer,type=method |        63 |      4,83 |      0,44 |     41,52 |      5,74 |      3,49 |      5,33 |      9,41 |     23,49 |     41,52 |     41,52 |      8,60 |     12,60 |     12,60 |     12,60 | second        | microseconds\n                       element_matcher,transformer=MeterLoggingTransformer,type=method |       158 |      4,51 |      0,50 |     55,13 |      5,58 |      3,52 |      4,68 |     11,12 |     19,24 |     29,80 |     55,13 |     15,34 |     23,36 |     24,50 |     24,70 | second        | microseconds\n                            element_matcher,transformer=MeteredTransformer,type=method |        63 |      4,09 |      0,29 |     40,52 |      5,85 |      2,16 |      4,01 |     12,38 |     19,74 |     40,52 |     40,52 |      8,65 |     12,60 |     12,60 |     12,60 | second        | microseconds\n                           element_matcher,transformer=SlaTransformer,type=classloader |     8.615 |      3,43 |      0,18 |    494,80 |     27,74 |      0,84 |      1,28 |      2,64 |      6,28 |     67,43 |    484,43 |    792,38 |    851,11 |    862,92 |    864,97 | second        | microseconds\n         element_matcher,transformer=MethodLevelMonitorRequestsTransformer,type=method |        63 |      3,39 |      0,43 |     11,02 |      1,98 |      3,28 |      3,96 |      7,14 |      7,49 |     11,02 |     11,02 |      8,69 |     12,60 |     12,60 |     12,60 | second        | microseconds\n                                  element_matcher,transformer=SlaTransformer,type=type |     6.880 |      3,00 |      1,03 |    133,35 |      5,15 |      2,07 |      2,99 |      6,85 |      9,81 |     12,21 |     64,72 |    632,61 |    614,38 |    614,71 |    614,77 | second        | microseconds\n                   element_matcher,transformer=ExceptionMeteredTransformer,type=method |        63 |      2,75 |      0,56 |     11,05 |      2,09 |      1,92 |      3,34 |      6,63 |      9,96 |     11,05 |     11,05 |      8,62 |     12,60 |     12,60 |     12,60 | second        | microseconds\n                          element_matcher,transformer=ProfilingTransformer,type=method |        63 |      2,15 |      0,54 |     13,30 |      1,82 |      1,53 |      2,43 |      3,69 |      9,01 |     13,30 |     13,30 |      8,67 |     12,60 |     12,60 |     12,60 | second        | microseconds\n                    element_matcher,transformer=FilterProfilingTransformer,type=method |        22 |      1,64 |      0,40 |      3,65 |      0,94 |      1,21 |      2,25 |      3,43 |      3,65 |      3,65 |      3,65 |      5,51 |      0,00 |      0,00 |      0,00 | second        | microseconds\n     element_matcher,transformer=SpringMvcRequestNameDeterminerTransformer,type=method |       106 |      1,50 |      0,28 |     24,36 |      2,41 |      0,95 |      1,73 |      3,41 |      4,11 |      4,78 |     24,36 |     14,64 |     21,20 |     21,20 |     21,20 | second        | microseconds\n                         element_matcher,transformer=MeterLoggingTransformer,type=type |     6.879 |      1,34 |      0,28 |     53,38 |      3,09 |      0,84 |      1,16 |      3,13 |      4,59 |      5,54 |     47,85 |    655,49 |    716,70 |    727,25 |    729,08 | second        | microseconds\n                      element_matcher,transformer=FilterProfilingTransformer,type=type |     7.224 |      1,24 |      0,26 |    249,42 |     11,47 |      0,44 |      0,55 |      0,86 |      1,07 |      1,41 |    204,41 |    726,09 |    941,40 |    941,40 |    941,40 | second        | microseconds\n                   element_matcher,transformer=ServletProfilingTransformer,type=method |        99 |      1,10 |      0,29 |      4,69 |      0,84 |      0,72 |      1,28 |      3,21 |      3,46 |      4,69 |      4,69 |     26,29 |      0,00 |      0,00 |      0,00 | second        | microseconds\n                            element_matcher,transformer=ProfilingTransformer,type=type |     7.224 |      1,02 |      0,26 |     72,32 |      3,63 |      0,44 |      0,67 |      2,36 |      4,52 |      5,34 |     72,32 |    720,68 |    890,08 |    915,40 |    919,79 | second        | microseconds\n                     element_matcher,transformer=ExceptionMeteredTransformer,type=type |     6.879 |      0,90 |      0,31 |     64,05 |      2,85 |      0,53 |      0,79 |      2,04 |      2,21 |      2,47 |     63,72 |    638,48 |    652,80 |    656,93 |    657,64 | second        | microseconds\n                                element_matcher,transformer=GaugeTransformer,type=type |     6.879 |      0,83 |      0,30 |     91,12 |      3,86 |      0,45 |      0,64 |      1,56 |      1,73 |      2,03 |     79,15 |    642,38 |    675,38 |    682,22 |    683,40 | second        | microseconds\n                              element_matcher,transformer=MeteredTransformer,type=type |     6.879 |      0,76 |      0,25 |    130,05 |      4,05 |      0,42 |      0,62 |      1,53 |      1,73 |      2,16 |     15,60 |    641,17 |    669,05 |    675,36 |    676,45 | second        | microseconds\n                     element_matcher,transformer=ServletProfilingTransformer,type=type |     7.224 |      0,68 |      0,26 |     60,40 |      2,58 |      0,47 |      0,57 |      1,03 |      1,19 |      1,47 |     60,40 |    724,72 |    939,60 |    939,60 |    939,60 | second        | microseconds\n            element_matcher,transformer=ClassLevelMonitorRequestsTransformer,type=type |     7.224 |      0,64 |      0,28 |     93,77 |      2,98 |      0,44 |      0,57 |      0,85 |      1,07 |      2,43 |     16,53 |    723,44 |    935,40 |    935,40 |    935,40 | second        | microseconds\n                                element_matcher,transformer=TimedTransformer,type=type |     6.879 |      0,62 |      0,27 |     11,11 |      0,52 |      0,44 |      0,64 |      1,53 |      1,64 |      1,81 |      4,04 |    639,90 |    662,31 |    667,78 |    668,72 | second        | microseconds\n       element_matcher,transformer=SpringMvcRequestNameDeterminerTransformer,type=type |     7.224 |      0,62 |      0,25 |     80,90 |      2,55 |      0,46 |      0,58 |      0,88 |      1,05 |      1,37 |     19,06 |    726,32 |    944,00 |    944,00 |    944,00 | second        | microseconds\n           element_matcher,transformer=MethodLevelMonitorRequestsTransformer,type=type |     7.224 |      0,59 |      0,27 |     14,58 |      0,57 |      0,43 |      0,61 |      1,51 |      1,71 |      1,92 |      3,39 |    722,15 |    897,14 |    923,52 |    928,10 | second        | microseconds\n                     element_matcher,transformer=ProfilingTransformer,type=classloader |     8.980 |      0,56 |      0,05 |    320,91 |      9,70 |      0,19 |      0,27 |      0,54 |      0,59 |      0,99 |     14,07 |    895,01 |  1.132,70 |  1.168,16 |  1.174,30 | second        | microseconds\n       element_matcher,transformer=ReflectiveConnectionMonitoringTransformer,type=type |     1.736 |      0,56 |      0,12 |     11,99 |      0,68 |      0,29 |      0,75 |      1,49 |      2,14 |      2,73 |      6,00 |    165,01 |    236,96 |    248,10 |    250,03 | second        | microseconds\n          element_matcher,transformer=DefaultConnectionMonitoringTransformer,type=type |     6.879 |      0,43 |      0,17 |     16,62 |      0,76 |      0,34 |      0,43 |      0,70 |      1,03 |      1,46 |     15,92 |    646,20 |    691,38 |    700,12 |    701,64 | second        | microseconds\n              element_matcher,transformer=ExceptionMeteredTransformer,type=classloader |     8.615 |      0,37 |      0,05 |     43,44 |      1,67 |      0,23 |      0,31 |      0,52 |      0,81 |      1,27 |     32,86 |    798,77 |    888,84 |    904,04 |    906,67 | second        | microseconds\nelement_matcher,transformer=ReflectiveConnectionMonitoringTransformer,type=classloader |     8.615 |      0,29 |      0,13 |     24,66 |      0,78 |      0,20 |      0,26 |      0,68 |      0,99 |      1,35 |      4,73 |    818,66 |    952,42 |    974,14 |    977,90 | second        | microseconds\n                       element_matcher,transformer=MeteredTransformer,type=classloader |     8.615 |      0,27 |      0,05 |     11,66 |      0,46 |      0,20 |      0,27 |      0,48 |      0,57 |      0,77 |      6,66 |    802,13 |    905,09 |    922,47 |    925,48 | second        | microseconds\n                         element_matcher,transformer=TimedTransformer,type=classloader |     8.615 |      0,26 |      0,06 |      6,55 |      0,27 |      0,20 |      0,27 |      0,48 |      0,56 |      0,83 |      2,87 |    800,75 |    898,35 |    914,89 |    917,76 | second        | microseconds\n                  element_matcher,transformer=MeterLoggingTransformer,type=classloader |     8.615 |      0,26 |      0,06 |      3,03 |      0,21 |      0,20 |      0,27 |      0,54 |      0,74 |      0,84 |      2,49 |    819,48 |    953,66 |    975,35 |    979,11 | second        | microseconds\n   element_matcher,transformer=DefaultConnectionMonitoringTransformer,type=classloader |     8.615 |      0,25 |      0,05 |      9,14 |      0,32 |      0,19 |      0,27 |      0,46 |      0,60 |      0,83 |      2,94 |    808,88 |    928,31 |    948,21 |    951,66 | second        | microseconds\n                         element_matcher,transformer=GaugeTransformer,type=classloader |     8.615 |      0,24 |      0,05 |      4,67 |      0,21 |      0,19 |      0,26 |      0,47 |      0,55 |      0,60 |      2,69 |    803,29 |    911,42 |    929,33 |    932,44 | second        | microseconds\n    element_matcher,transformer=MethodLevelMonitorRequestsTransformer,type=classloader |     8.980 |      0,23 |      0,05 |     15,71 |      0,49 |      0,19 |      0,22 |      0,44 |      0,46 |      0,52 |      2,82 |    896,81 |  1.139,76 |  1.176,28 |  1.182,61 | second        | microseconds\n              element_matcher,transformer=ServletProfilingTransformer,type=classloader |     8.980 |      0,21 |      0,05 |     11,95 |      0,38 |      0,18 |      0,21 |      0,31 |      0,34 |      0,64 |      2,10 |    899,45 |  1.195,00 |  1.195,00 |  1.195,00 | second        | microseconds\n               element_matcher,transformer=FilterProfilingTransformer,type=classloader |     8.980 |      0,20 |      0,05 |     15,33 |      0,51 |      0,18 |      0,21 |      0,31 |      0,41 |      0,48 |     15,33 |    900,60 |  1.196,80 |  1.196,80 |  1.196,80 | second        | microseconds\nelement_matcher,transformer=SpringMvcRequestNameDeterminerTransformer,type=classloader |     8.980 |      0,19 |      0,05 |      4,27 |      0,20 |      0,17 |      0,20 |      0,30 |      0,33 |      0,53 |      2,73 |    901,63 |  1.199,40 |  1.199,40 |  1.199,40 | second        | microseconds\n     element_matcher,transformer=ClassLevelMonitorRequestsTransformer,type=classloader |     8.980 |      0,18 |      0,05 |      1,92 |      0,10 |      0,17 |      0,20 |      0,32 |      0,39 |      0,43 |      1,05 |    897,68 |  1.143,98 |  1.181,12 |  1.187,56 | second        | microseconds\nThis is pretty decent I think!\n. Reading\n\nYou need to read them as a pair.\n\nI think that my matcher does not what I intended. I wanted to exclude all java* and com.sun* types and all classes loaded by the bootstrap classloader. But it actually only excludes java* and com.sun* types which are loaded by the bootstrap classloader. So ignore(any(), isBootstrapClassLoader()) would make more sense. I probably don't have to manually exclude java* and com.sun* types, because they are all loaded by the bootstrap class loader. Except for maybe some javax classes. So i'd prepend these exclusions to my type ElementMatchers\n. > Finally, I looked into the delegation over inlining thing and the implementation is quite trivial so I will add it. \nI'd prefer the annotation approach because in my case, I have a central method which creates the transformer (org.stagemonitor.core.instrument.StagemonitorByteBuddyTransformer#getTransformer). With the annotation based approach, the subclasses can decide whether or not to inline. But manually delegating is so trivial that I don't know if I would migrate to the automatic delegation at all... \n. Nice! I'm in the process of ironing out bugs discovered by my integration tests. \nAre all classes which pass the ignore matcher parsed? Or only those where It's required due to the type matcher. If so, I don't need ignore a lot, because my first type matcher includes a quite narrow namespace matched via named(). I require my users to set the package name for their poject in order to enable the instrumentation. \nI also excluded the sun.reflect.DelegatingClassLoader. This one is used to create byte code for reflection calls so I think classes loaded by that one are not interesting. \n\nByte Buddy will now serialize this instance and add the string-encoded byte array to the class's constant pool\n\nNice one^^\n. Cool.\nI'm currently trying to find out why a particular class is ignored on JBoss, but it's quite hard because the Listener#onIgnored method only provides the TypeDescription but not the ClassLoader this class was loaded by. Is there any way I can get ahold of the classloader? Or is there any other method to get a full explanation on why a particular class did not match i.e. which ElementMatcher was responsible for excluding the class?\n. lol, nice :laughing: \nHave you considered using argument objects to be able to evolve the arguments? But that might have performance implications for a component like the Listener which is called so frequently.\n. Remember when I said that JBoss' ModuleClassLoader would not load my Dispatcher class which I appended to the bootstrap classpath? Turns out that if the Dispatcher class is inside the java.lang package, the ModuleClassLoader does not complain anymore: https://github.com/stagemonitor/stagemonitor/commit/6166453d0c6b4c4ec006c89e63cbfb0afd7bd4c8#diff-ad5480a1eefc25ee8fb1362ee3258415R1\n. When inlining a method, do we have to be careful about not declaring a variable name that is already present in the instrumented method? I guess not, because the variable name is not in the bytecode but only in the debugging information (which Byte Buddy does not insert), right? Nevertheless I'd include this in the Javadoc of the @Advice.OnMethod{Enter,Exit} annotations.\n. I've tested my new Agents with a medium sized real world application with around 1000 classes. Unfortunately, the startup time has increased a lot - from ~30s to ~1:20s.\nI've excluded some possible factors.\n- Matcher time: The total time spent matching is only 4.5 seconds. So this can't be the root cause. Looking at the LazyFacade it seems that the time parsing classes is also included in this number.\n- Transformation time. I temporarily set the transformer to AgentBuilder.Transformer.NoOp.INSTANCE so no transformation should be going on.\n- Retransformation time: only one class is retransformed and the total time to install the agents is about 1 second. If a class is not loaded yet, Byte Buddy does not retransform it but rather uses the java.lang.instrument.ClassFileTransformer#transform method, even when set to AgentBuilder.RedefinitionStrategy.RETRANSFORMATION, right?\nI thought these where the main contributors to Byte Buddy's performance, but there seem to be other ones I can't think of. Maybe it is the fact that I'm using 18 individual agents. I'll now try to use the AgentBuilder.Transformer.Compound and only register one ClassFileTransformer to see if that helps. Maybe that is not even Byte Buddy's \"fault\" but some caveat of the Instrumentation API then.\n. > are you calling installOn 18 times?\nYes\n\nIn order to being able to instrument all classes, Byte Buddy needs to firstly register a class file transformer and then afterwards iterate over all loaded classes which are provided by the instrumentation API.\n\nDo you mean the time caused by java.lang.instrument.Instrumentation#getAllLoadedClasses?\n\nAnd how did you apply the transformation before using Javassist?\n\nI only registered one ClassFileTransformer which acted as a compound transformer.\n. I don't think that it can be caused by Instrumentation#getAllLoadedClasses, because the agent attaches within 1 second. This includes the 18 calls to installOn which probably in turn calls Instrumentation#getAllLoadedClasses.\n. By startup time I mean the time between the first timestamp which appears in the logs until the first timestamp after the line Started Tomcat Server. Or in other words, the time until the web application is \"ready\" or available.\n\nI could no longer reproduce the problem\n\nThat is strange. I actually didn't investigate further in that regard, but I can't reproduce it either. Must have been a side effect of some change.\n. The problem occurred in https://github.com/stagemonitor/stagemonitor/commit/067baf880f9a6d0e60b6f9a054bf3346d35b303f. I can still reproduce it at that revision.\n. Thank god, using the compound transformer improved performance a lot! Even though It not has to apply matchers multiple times.\nFor the agentBuilder.type method, I'm or-combining all type and classloader matchers of my StagemonitorByteBuddyTransformers to check whether a class should be transformed by any transformer. Inside the AgentBuilder.Transformers of the individual transformers I'm checking whether their specific type and classloader matchers match. For some reason, this is way faster. Maybe the instrumentation API just gets slower with each registered agent.\nThx for your help and for acting as my rubber duck ;). I hope I didn't seem like a \"difficult customer\" or something. It really helped my to sort my thoughts and I hope it helped you and other users which might have similar issues as well.\nStartup time does matter, because stagemonitor also is a developer tool. It's in-browser-widget is basically the open source alternative to XRebel. Developers would probably abandon a tool which \"makes things slower\".\nHowever, I'm seeing a lot of ClassCircularityErrors catched by Listener.onError. For example:\njava.lang.ClassCircularityError: org/slf4j/helpers/MessageFormatter\n    at org.slf4j.impl.Log4jLoggerAdapter.info(Log4jLoggerAdapter.java:345)\n    at org.stagemonitor.core.instrument.ApplicationClassLoaderMatcher.matches(ApplicationClassLoaderMatcher.java:31)\n    at org.stagemonitor.core.instrument.ApplicationClassLoaderMatcher.matches(ApplicationClassLoaderMatcher.java:19)\n    at org.stagemonitor.core.instrument.CachedClassLoaderMatcher.matches(CachedClassLoaderMatcher.java:29)\n    at org.stagemonitor.core.instrument.CachedClassLoaderMatcher.matches(CachedClassLoaderMatcher.java:8)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:98)\n    at org.stagemonitor.core.instrument.TimedElementMatcherDecorator.matches(TimedElementMatcherDecorator.java:49)\n    at net.bytebuddy.agent.builder.AgentBuilder$RawMatcher$ForElementMatcherPair.matches(AgentBuilder.java:686)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple.resolve(AgentBuilder.java:4549)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Compound.resolve(AgentBuilder.java:4794)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:4932)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n    at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n    at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n    at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1227)\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1690)\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1571)\n    at org.slf4j.impl.Log4jLoggerAdapter.info(Log4jLoggerAdapter.java:345)\n    at org.stagemonitor.core.instrument.ApplicationClassLoaderMatcher.matches(ApplicationClassLoaderMatcher.java:31)\n    at org.stagemonitor.core.instrument.ApplicationClassLoaderMatcher.matches(ApplicationClassLoaderMatcher.java:19)\n    at org.stagemonitor.core.instrument.CachedClassLoaderMatcher.matches(CachedClassLoaderMatcher.java:29)\n    at org.stagemonitor.core.instrument.CachedClassLoaderMatcher.matches(CachedClassLoaderMatcher.java:8)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:98)\n    at org.stagemonitor.core.instrument.TimedElementMatcherDecorator.matches(TimedElementMatcherDecorator.java:49)\n    at net.bytebuddy.agent.builder.AgentBuilder$RawMatcher$ForElementMatcherPair.matches(AgentBuilder.java:686)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple.resolve(AgentBuilder.java:4549)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Compound.resolve(AgentBuilder.java:4794)\n    at net.bytebuddy.agent.builder.AgentBuilder$RedefinitionStrategy$Collector$ForRetransformation.consider(AgentBuilder.java:2252)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default.installOn(AgentBuilder.java:4042)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Delegator.installOn(AgentBuilder.java:5119)\n    at org.stagemonitor.core.instrument.AgentAttacher.initByteBuddyClassFileTransformers(AgentAttacher.java:184)\n    at org.stagemonitor.core.instrument.AgentAttacher.performRuntimeAttachment(AgentAttacher.java:89)\n    at org.stagemonitor.core.Stagemonitor.reset(Stagemonitor.java:248)\n    at org.stagemonitor.core.Stagemonitor.<clinit>(Stagemonitor.java:40)\n    at org.stagemonitor.web.WebPlugin.<clinit>(WebPlugin.java:57)\n    at java.lang.Class.forName0(Native Method)\n    at java.lang.Class.forName(Class.java:348)\n    at org.apache.catalina.startup.WebappServiceLoader.loadServices(WebappServiceLoader.java:187)\n    at org.apache.catalina.startup.WebappServiceLoader.load(WebappServiceLoader.java:152)\n    at org.apache.catalina.startup.ContextConfig.processServletContainerInitializers(ContextConfig.java:1559)\n    at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1281)\n    at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:889)\n    at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:386)\n    at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117)\n    at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5380)\n    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1575)\n    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1565)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n. I don't know why, but the startup time with Javassist is still a bit faster: No instrumentation ~30s, Javassist ~34s, Byte Buddy ~38s (total time spent matching <1s). But I think this is totally acceptable for now. Maybe somewhere there is some hidden overhead which does not fall into the categories matching time and transformation time. Regarding the runtime performance, I'll rewrite/repair my JMH benchmarks.\nFixed the ClassCircularityError by excluding ignore(nameStartsWith(\"org.slf4j.\").and(not(nameStartsWith(\"org.slf4j.impl.\")))).\n\nIdeally, you are loading the entire agent code from a separate class loader and simply exclude this class loader. Within the agentmain method, you merely initiate the agent and then call an initiation method.\n\nI don't have an agentmain method, because I'm Attaching at runtime to not require the application to start with -javaagent. I'm using ServiceLoader hooks which are triggered by the application servers (javax.servlet.ServletContainerInitializer, java.sql.Driver) to get notified about the application start as soon as possible (to reduce the classes I have to retransform as much as possible). Do you happen to know another way to get notified about the application start which does not rely on the app server calling something like ServiceLoader.load(Driver.class)?\nAlso, when loading the agent from a different classloader, either the agent can't see the application classes or the application classes can't see the agent. See also http://stackoverflow.com/questions/31191202/access-servlet-api-within-javaagent. If I could solve that problem, I could offer a different deployment mode to stagemonitor where the application does not have a compile time dependency on stagemonitor (like it currently has) but only attaches an -javaagent which contains all the stagemonitor code.\nI've updated the byte-buddy-agent branch and I think it's pretty close to be mergeable!\n. Wow, nice catch! Maybe it would make sense to include your WeakConcurrentMap into Byte Buddy?\nThis method is called after startup and is supposed to avoid a memory leak:\n/**\n     * This method should be called when the instrumentation of the classes is mostly done.\n     * <p/>\n     * This makes sure that the {@link ClassPool} including all it's {@link ByteArrayClassPath} can be garbage collected.\n     * Instrumentation is still possible afterwards, the {@link ClassPool}s just will be recreated\n     */\n    public static void clearClassPools() {\n        classPoolsByClassLoaderHash.clear();\n    }\n. But it would probably be better to not cache after the startup. That way there is no leak but the startip time where most classes are loaded is faster. \n. Is there a way to unset the cacheProviders map after the startup of the application? That would speed up the startup in most cases and limit the scope of the potential memory leak. I'm not feeling quite comfortable putting class loaders as a key into a map and keep them there. Even if I'm calling clear, there could still be classes loaded after the startup which would populate the cache again.\n. Using Simple I get a lot of NPEs:\n10:25:47.537 [main] WARN org.stagemonitor.core.instrument.ErrorLoggingListener - ERROR on transformation java.util.concurrent.ConcurrentHashMap$MapEntry\njava.lang.NullPointerException: null\n    at java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:936)\n    at net.bytebuddy.agent.builder.AgentBuilder$BinaryLocator$WithTypePoolCache$Simple.locate(AgentBuilder.java:1082)\n    at net.bytebuddy.agent.builder.AgentBuilder$BinaryLocator$WithTypePoolCache.typePool(AgentBuilder.java:1034)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:5045)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at java.util.concurrent.ConcurrentHashMap$EntryIterator.next(ConcurrentHashMap.java:3461)\n    at java.util.concurrent.ConcurrentHashMap$EntryIterator.next(ConcurrentHashMap.java:3446)\n    at org.stagemonitor.core.metrics.metrics2.Metric2Registry.getMetrics(Metric2Registry.java:297)\n    at org.stagemonitor.core.metrics.metrics2.Metric2Registry.getGauges(Metric2Registry.java:195)\n    at org.stagemonitor.core.metrics.metrics2.ScheduledMetrics2Reporter.report(ScheduledMetrics2Reporter.java:46)\n    at org.stagemonitor.core.instrument.TimedElementMatcherDecorator.logMetrics(TimedElementMatcherDecorator.java:59)\n    at org.stagemonitor.core.instrument.AgentAttacher.performRuntimeAttachment(AgentAttacher.java:85)\n    at org.stagemonitor.core.Stagemonitor.reset(Stagemonitor.java:249)\n    at org.stagemonitor.core.Stagemonitor.<clinit>(Stagemonitor.java:40)\n    at org.stagemonitor.requestmonitor.prof.ProfilerTest.attachProfiler(ProfilerTest.java:16)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:119)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nMaybe because the reference for the bootstrap class loader is represented as null? I'm a bit confused why Byte Buddy seems to transform java.util.concurrent.ConcurrentHashMap$MapEntry as I excluded the java.* namespace. But probably Byte Buddy still needs to parse the class file if it parses a class which has a field of type ConcurrentHashMap?\nRegarding the onThrowable change in @Advice.OnMethodExit: The @Advice.Thrown annotation still seems to require a Throwable type. I was expecting that the type can be of the same type as the onThrowable type (or a super type).\njava.lang.IllegalStateException: Parameter must be a throwable type for java.lang.Exception arg2\n    at net.bytebuddy.asm.Advice$Dispatcher$OffsetMapping$ForThrowable$Factory.make(Advice.java:4457)\n    at net.bytebuddy.asm.Advice$Dispatcher$Delegating$Resolved.<init>(Advice.java:6195)\n    at net.bytebuddy.asm.Advice$Dispatcher$Delegating$Resolved$ForMethodExit.<init>(Advice.java:6582)\n    at net.bytebuddy.asm.Advice$Dispatcher$Delegating$Resolved$ForMethodExit$WithExceptionHandler.<init>(Advice.java:6674)\n    at net.bytebuddy.asm.Advice$Dispatcher$Delegating$Resolved$ForMethodExit.of(Advice.java:6614)\n    at net.bytebuddy.asm.Advice$Dispatcher$Delegating.asMethodExitTo(Advice.java:6137)\n    at net.bytebuddy.asm.Advice.to(Advice.java:231)\n    at net.bytebuddy.asm.Advice$WithCustomMapping.to(Advice.java:7284)\n    at net.bytebuddy.asm.Advice$WithCustomMapping.to(Advice.java:7269)\n    at net.bytebuddy.asm.Advice$WithCustomMapping.to(Advice.java:7258)\n    at org.stagemonitor.core.instrument.StagemonitorByteBuddyTransformer$1.transform(StagemonitorByteBuddyTransformer.java:97)\n    at net.bytebuddy.agent.builder.AgentBuilder$Transformer$Compound.transform(AgentBuilder.java:866)\n    at net.bytebuddy.agent.builder.AgentBuilder$Transformer$Compound.transform(AgentBuilder.java:866)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:4746)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:5050)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)\n    at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)\n    at net.bytebuddy.agent.builder.AgentBuilder$RedefinitionStrategy$Collector$ForRetransformation.apply(AgentBuilder.java:2373)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default.installOn(AgentBuilder.java:4178)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Delegator.installOn(AgentBuilder.java:5231)\n    at org.stagemonitor.core.instrument.AgentAttacher.initByteBuddyClassFileTransformer(AgentAttacher.java:166)\n    at org.stagemonitor.core.instrument.AgentAttacher.performRuntimeAttachment(AgentAttacher.java:81)\n    at org.stagemonitor.core.Stagemonitor.reset(Stagemonitor.java:249)\n    at org.stagemonitor.core.Stagemonitor.<clinit>(Stagemonitor.java:40)\n    at org.stagemonitor.requestmonitor.prof.ProfilerTest.attachProfiler(ProfilerTest.java:17)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:119)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\n. With the latest version I'm getting strange IncompatibleClassChangeErrors. While installing Byte Buddy I made sure everything is mvn clean. In my unit tests and with Spring PetClinic everything is working fine, but when I use it with a project of one of my customers, those exceptions suddenly pop up and the transformation fails. This project is started with gradle and an embedded Tomcat 7 server if that matters. It happens with and without a BinaryLocator set. The performance with a caching BinaryLocator looks promising in combination with Spring PetClinic.\nERROR on transformation org.elasticsearch.action.search.SearchRequestBuilder\njava.lang.IncompatibleClassChangeError: class net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ValidatingClassVisitor has interface org.objectweb.asm.ClassVisitor as super class\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n    at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n    at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n    at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1227)\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1690)\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1571)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.doCreate(TypeWriter.java:2812)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2794)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1572)\n    at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:179)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:4788)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:5089)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)\n    at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)\n    at net.bytebuddy.agent.builder.AgentBuilder$RedefinitionStrategy$Collector$ForRetransformation.apply(AgentBuilder.java:2412)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default.installOn(AgentBuilder.java:4217)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Delegator.installOn(AgentBuilder.java:5270)\n    at org.stagemonitor.core.instrument.AgentAttacher.initByteBuddyClassFileTransformer(AgentAttacher.java:165)\n    at org.stagemonitor.core.instrument.AgentAttacher.performRuntimeAttachment(AgentAttacher.java:79)\n    at org.stagemonitor.core.Stagemonitor.reset(Stagemonitor.java:249)\n    at org.stagemonitor.core.Stagemonitor.<clinit>(Stagemonitor.java:40)\n    at org.stagemonitor.web.WebPlugin.<clinit>(WebPlugin.java:57)\n    at java.lang.Class.forName0(Native Method)\n    at java.lang.Class.forName(Class.java:348)\n    at org.apache.catalina.startup.WebappServiceLoader.loadServices(WebappServiceLoader.java:187)\n    at org.apache.catalina.startup.WebappServiceLoader.load(WebappServiceLoader.java:152)\n    at org.apache.catalina.startup.ContextConfig.processServletContainerInitializers(ContextConfig.java:1559)\n    at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1281)\n    at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:889)\n    at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:386)\n    at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117)\n    at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5380)\n    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1575)\n    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1565)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nERROR on transformation org.webstage.shop.ui.http.SessionCollector\njava.lang.IncompatibleClassChangeError: class net.bytebuddy.pool.TypePool$Default$TypeExtractor has interface org.objectweb.asm.ClassVisitor as super class\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n    at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n    at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n    at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1227)\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1690)\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1571)\n    at net.bytebuddy.pool.TypePool$Default.parse(TypePool.java:1098)\n    at net.bytebuddy.pool.TypePool$Default.doDescribe(TypePool.java:1083)\n    at net.bytebuddy.pool.TypePool$Default$Precomputed.doDescribe(TypePool.java:8218)\n    at net.bytebuddy.pool.TypePool$AbstractBase.describe(TypePool.java:383)\n    at net.bytebuddy.pool.TypePool$AbstractBase$Hierarchical.describe(TypePool.java:440)\n    at net.bytebuddy.pool.TypePool$LazyFacade$LazyResolution$LazyTypeDescription.resolve(TypePool.java:8387)\n    at net.bytebuddy.pool.TypePool$LazyFacade$LazyResolution$LazyTypeDescription.getDeclaredAnnotations(TypePool.java:8452)\n    at net.bytebuddy.matcher.DeclaringAnnotationMatcher.matches(DeclaringAnnotationMatcher.java:29)\n    at net.bytebuddy.matcher.DeclaringAnnotationMatcher.matches(DeclaringAnnotationMatcher.java:11)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:98)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:98)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:98)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:98)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:98)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:98)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Disjunction.matches(ElementMatcher.java:145)\n    at org.stagemonitor.core.instrument.TimedElementMatcherDecorator.matches(TimedElementMatcherDecorator.java:49)\n    at net.bytebuddy.agent.builder.AgentBuilder$RawMatcher$ForElementMatcherPair.matches(AgentBuilder.java:688)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple.resolve(AgentBuilder.java:4700)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Compound.resolve(AgentBuilder.java:4945)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:5083)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n    at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n    at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n    at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1227)\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1690)\n    at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1571)\n    at org.apache.catalina.util.Introspection.loadClass(Introspection.java:143)\n    at org.apache.catalina.startup.WebAnnotationSet.loadApplicationListenerAnnotations(WebAnnotationSet.java:82)\n    at org.apache.catalina.startup.WebAnnotationSet.loadApplicationAnnotations(WebAnnotationSet.java:63)\n    at org.apache.catalina.startup.ContextConfig.applicationAnnotationsConfig(ContextConfig.java:415)\n    at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:892)\n    at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:386)\n    at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117)\n    at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5380)\n    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1575)\n    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1565)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n. Probably I did something wrong when building Byte Buddy locally. I executed mvn clean source:jar install. Do I have to enable shading somehow?\n. Nevermind, building with mvn clean source:jar install -Pextras did the trick...\n. Nice! Now the overhead in startup time is virtually zero! It's within the bounds of uncertainty. Looking forward to 1.3.15 :)\n. Registering individual agents is way faster than before (startup time ~35s) but combining the agents is still slightly faster (~33s). Also, these are by no means scientific measurements. I just started the application a couple of times and took the average.\nI'll probably stick with the combined agent. Especially since I'm deactivating the cache after startup and it is still possible that classes are loaded after that (for example compiled JSPs, classes only referenced in method bodies, ...).\n. I agree that a better support for compound agents would be nice. What would be the semantics of withFallThrough()?\n. I'm afraid I still don't quite get it.\nFor my use case a transformTypes method would be nice that can be called multiple times to add multiple Transformers which are applied to the corresponding matching types.\nAgentBuilder#transformTypes(ElementMatcher<? super TypeDescription>, ElementMatcher<? super java.lang.ClassLoader>, Transformer)\n. Ok, now I get it. But I think my suggestion would probably be simpler to understand for an API user. Is it harder to implement?\n. I see. I wasn't aware of such a method. Which method is that by the way?\n. What are the semantics for listeners then? Is it possible to register an onTransformation listener for a specific transformer as well as to register a global listener for onError?\n. Unfortunately, I think that I can't use this feature then, because I currently rely on my custom onTransformation method being called. \n. But wait, I can still call this method in my Transformers.. Only a transformer specific onIgnore (neat for debugging purposes) would be difficult. \n. Any idea about how to implement a onIgnored callback? This ist not a deal breaker but would be nice to have. \n. The stagemonitor build is currently failing, because EhCache's AgentSizeOf can't be instantiated: https://travis-ci.org/stagemonitor/stagemonitor/builds/124459926#L489. Unfortunately, I can't reproduce it locally. Before using ByteBuddyAgent I sometimes had this problem when wanting to attach my own agent: java.lang.UnsatisfiedLinkError: Native Library /usr/java/jdk1.8.0_40/jre/lib/amd64/libattach.so already loaded in another classloader. I was able to solve that with a pretty dirty hack: https://github.com/stagemonitor/stagemonitor/blob/6d477f49afaf11c7af747f873784557b056ffec7/stagemonitor-core/src/main/java/org/stagemonitor/core/instrument/AgentLoader.java#L64.\nDo you think that could be the problem or does Byte Buddy work around the problem that the native library for the attachment could already be loaded by another agent's ClassLoader? For now, I'll probably remove the instantiation of AgentSizeOf and see if it causes reproducible real problems.\n. So basically I have to re-apply my dirty hack \ud83d\ude1e . But at least it is abstracted in a better way. I hope that the Byte Buddy Agent will become the standard for runtime attachment as it can be used even without using Byte Buddy itself. Then this would not be a problem anymore...\nWould it make sense to include the detection of known other agents into byte-buddy-agent?\n. You mean for example if EhCache is included within the app server? But even then, you still have access to the AgentSizeOf, don't you? What is the difference if I'm doing this within stagemonitor?\n. FYI: placing the dispatcher class inside the java. package can lead to a SecurityException.  I haven't observed this behavior myself but I got a but report about it. See https://github.com/stagemonitor/stagemonitor/issues/204. I don't quite know the circumstances which lead to the exception and why it has always been working for me.\nIn the ClassLoader class, there is a check which prevents defining classes inside the java. package: http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/ClassLoader.java/#656\nTo solve this and also work around the JBoss ModuleLoader issue, I reexamined the Module source code: https://github.com/jboss-modules/jboss-modules/blob/master/src/main/java/org/jboss/modules/Module.java#L92. JBoss seems to treat the package name __redirected. as a system package as well. So my dirty workaround is to move my dispatcher class to __redirected.org.stagemonitor.dispatcher.Dispatcher which seems to work. I can only hope that they don't change this magic package name. It's a pitty to say the least that the guys at JBoss don't seem like they want to address the issue you've created (https://issues.jboss.org/browse/MODULES-250).\n. You are right. The exception is triggered here: https://github.com/stagemonitor/stagemonitor/blob/0.27.0/stagemonitor-core/src/main/java/org/stagemonitor/core/instrument/AgentAttacher.java#L105\nSomething must have gone wrong in ensureDispatcherIsAppendedToBootstrapClasspath. I think bootstrapClassloader.loadClass(DISPATCHER_CLASS_NAME) did for some reason not throw an exception so it is assumed the class has already been injected. Probably it's better for the class to stay in the java package rather than in the weird JBoss specific __redirected package.\n. Actually, I'm not modifying any fields with Byte Buddy but only use the Advice API to modify methods.\n. The defaultValue is an Integer of value 0\n. This is the rest of the debug information at this point:\n| variable | value |\n| --- | --- |\n| this | TypeWriter$Default$ValidatingClassVisitor  (id=111) |\n| modifiers | 18 |\n| name | \"deactivateActionRights\" (id=125) |\n| descriptor | \"Z\" (id=130) |\n| signature | null |\n| defaultValue | Integer  (id=131)  value: 0 |\n. Hi Raphael,\nno, I don't enable validation in production - only in testing environments. But it's not always apparent whether such an exception is just a validation error or the transformation actually fails. Even if these are not big issues it's probably still be worth taking a look at them.\nIt's strange that you can't reproduce it. The current master should be fine. You executed gradle clean instrumentationPerformanceTest, right? But yes, they all contain the line at net.bytebuddy.description.method.MethodDescription$Latent.getReceiverType(MethodDescription.java:1125)\nAnyway, here is the complete log: instrumentationPerformanceTest.txt\n. ah, yes, sorry. you have to initially execute gradle processResources. otherwise it can't find the dispatcher.jar\n. Thank you! Works like a charm.\n. > simply store references of the Advice.to instances outside of the AgentBuilder.Transformation that you register to reuse it\nThx, this worked great and cut down the startup time in half.\n\nOutside of a benchmark, you would not apply the Advice.to method that many times.\n\nActually, this benchmark isn't that unrealistic. Stagemonitor offers a profiler which has to insert code to every method in the monitored project. Most codebases are not as large as Elasticsearch (especially since they shade a lot to the org.elasticsearch namespace) but fast startup times are really relevant to stagemonitor. Especially if you are monitoring a rich client application, because end users are affected if the startup time increases. So do you think there is any more potential to optimize (the use of) Byte Buddy in case that there are a lot of transformations?\n. > The backgroud for my investigation is that I've recently added stagemonitor to an Eclipse RCP application with a quite large codebase and the startup time increased quite considerably.\nTo give you an update about this: The increased startup was caused by deactivating the type pool cache too early. I'll probably just clear the cache every minute and never deactivate it.\n. Sounds like a good idea. But I think for me it is sufficient to just use a WeakConcurrentMap that is cleared every minute. I don't feel the necessity to pull in another dependency.\n. Thx for the ~quick~ instant answer!\nUnfortunately, I get a different error now:\n@Override\nprotected Object doResolve(TypeDescription instrumentedType,\n                           MethodDescription instrumentedMethod,\n                           ParameterDescription.InDefinedShape target,\n                           AnnotationDescription.Loadable<MeterExceptionsFor> annotation,\n                           Assigner assigner, boolean initialized) {\n    return new TypeDescription.ForLoadedType(instrumentedMethod.getDeclaredAnnotations().ofType(ExceptionMetered.class).loadSilent().cause());\n}\njava.lang.IllegalStateException: An illegal stack manipulation must not be applied\n    at net.bytebuddy.implementation.bytecode.StackManipulation$Illegal.apply(StackManipulation.java:47)\n    at net.bytebuddy.implementation.bytecode.StackManipulation$Compound.apply(StackManipulation.java:214)\n    at net.bytebuddy.asm.Advice$Dispatcher$Delegating$Resolved$AdviceMethodWriter.doApply(Advice.java:6938)\n    at net.bytebuddy.asm.Advice$Dispatcher$Delegating$Resolved$AdviceMethodWriter$ForMethodExit.apply(Advice.java:7106)\n    at net.bytebuddy.asm.Advice$AdviceVisitor$WithExitAdvice.onUserEnd(Advice.java:7838)\n    at net.bytebuddy.asm.Advice$AdviceVisitor.visitMaxs(Advice.java:7579)\n    at net.bytebuddy.jar.asm.MethodVisitor.visitMaxs(Unknown Source)\n    at net.bytebuddy.asm.Advice$AdviceVisitor.visitMaxs(Advice.java:7580)\n    at net.bytebuddy.jar.asm.ClassReader.a(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.b(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:3095)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1693)\n    at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:171)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:7396)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doTransform(AgentBuilder.java:7859)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:7824)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1100(AgentBuilder.java:7611)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:8249)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:8199)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:7750)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:760)\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n    at java.net.URLClassLoader.defineClass(URLClassLoader.java:455)\n    at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:367)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:360)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n    at org.stagemonitor.alerting.annotation.SlaCheckCreatingClassPathScannerTest.init(SlaCheckCreatingClassPathScannerTest.java:90)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\n    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:237)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\n. Thx, working nicely!. But Byte Buddy does call getDeclaredMethods so it indirectly resolves the types. Maybe it would be possible to lazily call getDeclaredMethods? Otherwise a hint on @Advice.This would be helpful.. > Maybe you can just catch the error and handle this as an indicator for the missing class?\n+1. Thx for you help! But I still don't quite get it to work.\nThis is my current attempt:\n```java\npublic static class ParameterNamesDynamicValue implements Advice.OffsetMapping.Factory {\n@Override\npublic Class<ParameterNames> getAnnotationType() {\n    return ParameterNames.class;\n}\n\n@Override\npublic Advice.OffsetMapping make(ParameterDescription.InDefinedShape target,\n                                 AnnotationDescription.Loadable<ParameterNames> annotation,\n                                 AdviceType adviceType) {\n    StringBuilder params = new StringBuilder();\n    for (ParameterDescription param : target.getDeclaringMethod().getParameters()) {\n        params.append(param.getName()).append(',');\n    }\n    return Advice.OffsetMapping.Target.ForStackManipulation.of(params.toString());\n}\n\n}\n```\nBut I get a compile error:\nIncompatible types:\nRequired: net.bytebuddy.asm.Advice.OffsetMapping\nFound: net.bytebuddy.asm.Advice.OffsetMapping.Target. Thx a lot, I think I get it now. So it helps to improve performance in case the OffsetMapping.Target does not only depend on the actual instrumented method but rather on the advice method like annotation type?\nIn other words, the OffsetMapping.Factory#make method refers to the @Advice.OnMethodEnter annotated advice method and Advice.OffsetMapping#resolve refers to the actual instrumented methods?\nOne more question: how can I bind offset mapping factories?\nI tried:\njava\nList<Advice.OffsetMapping.Factory<?>> dynamicValues = getDynamicValues();\nAdvice.WithCustomMapping withCustomMapping = Advice.withCustomMapping();\nfor (Advice.OffsetMapping.Factory<?> dynamicValue : dynamicValues) {\n    withCustomMapping = withCustomMapping.bind(dynamicValue.getAnnotationType(), dynamicValue);\n}\nreturn withCustomMapping;\nBut got the following exception:\nCaused by: java.lang.IllegalStateException: Not a constant value: org.stagemonitor.tracing.profiler.ProfilingTransformer$ProfilerDynamicValue@51f8f916\n    at net.bytebuddy.asm.Advice$OffsetMapping$ForStackManipulation$Factory.of(Advice.java:3165)\n    at net.bytebuddy.asm.Advice$WithCustomMapping.bind(Advice.java:8347)\n    at org.stagemonitor.core.instrument.StagemonitorByteBuddyTransformer.registerDynamicValues(StagemonitorByteBuddyTransformer.java:131)\n    at org.stagemonitor.core.instrument.StagemonitorByteBuddyTransformer.getAdvice(StagemonitorByteBuddyTransformer.java:117)\n    at org.stagemonitor.core.instrument.StagemonitorByteBuddyTransformer.getTransformer(StagemonitorByteBuddyTransformer.java:100)\n    at org.stagemonitor.core.instrument.AgentAttacher.initByteBuddyClassFileTransformer(AgentAttacher.java:163)\n    at org.stagemonitor.core.instrument.AgentAttacher.performRuntimeAttachment(AgentAttacher.java:85)\n    at org.stagemonitor.core.Stagemonitor.reset(Stagemonitor.java:360)\n    at org.stagemonitor.core.Stagemonitor.reset(Stagemonitor.java:342)\n    at org.stagemonitor.core.Stagemonitor.init(Stagemonitor.java:62)\n    ... 39 more. Currently, the signature is bind(OffsetMapping.Factory<? super T> offsetMapping) shouldn't it be bind(OffsetMapping.Factory<? extends T> offsetMapping)? \nWhile I can bind a single OffsetMapping.Factory, I can't add them to a List<Advice.OffsetMapping.Factory<? super Annotation>> first, only a List<Advice.OffsetMapping.Factory<? extends Annotation>> from where it's not possible to do the following:\njava\nfor (Advice.OffsetMapping.Factory<? extends Annotation> offsetMappingFactory : dynamicValues) {\n    withCustomMapping = withCustomMapping.bind(offsetMappingFactory);\n}. > Feel free to include this in your PR or I will fix it myself some time soon.\nI'll make a pull request\n\nYou can cast to a raw factory in the mean time if you want to get past this.\n\nThat's what I currently do. It does. Also, there are workarounds for everything, so no need to hurry.. Any hints on how to test this? Is there an existing test method I can enhance?. Strange errors during build:\nnet.bytebuddy.build.gradle.ByteBuddyExtensionTest > testTaskExplicitExcluded STANDARD_ERROR\n    Sep 11, 2017 9:39:41 AM org.codehaus.groovy.runtime.m12n.MetaInfExtensionModule newModule\n    WARNING: Module [groovy-all] - Unable to load extension class [org.codehaus.groovy.runtime.NioGroovyMethods]\nGradle Test Executor 1 finished executing tests.\n[INFO] Execute :test\n*** buffer overflow detected ***: /usr/lib/jvm/java-6-openjdk-amd64/bin/java terminated\n======= Backtrace: =========\n/lib/x86_64-linux-gnu/libc.so.6(__fortify_fail+0x37)[0x7fd9e208fdb7]\n/lib/x86_64-linux-gnu/libc.so.6(+0x10bcb0)[0x7fd9e208ecb0]\n/usr/lib/jvm/java-6-openjdk-amd64/jre/lib/amd64/libnet.so(Java_java_net_Inet4AddressImpl_getLocalHostName+0x1a0)[0x7fd9d15f9df0]\n[0x7fd9d87d86b0]\nHave you seen that before?. I know that feel. Having the same trouble with travis atm.... Thanks for your answer. This is somewhat both a downer and a relief. It makes the instrumentation read more clumsy, but dealing with injecting classes to class loaders sounds like a world of pain. Good to know that that is not the way to go anyway.. > Alternatively, you can inject code into the target class loader which I would however avoid as class injection is touching some JVM internal APIs which are subject to change.\nAre you referring to Unsafe#defineClass?. Will Byte Buddy offer alternatives based on MethodHandles.Lookup.defineClass?. But due to the fact that MethodHandles.Lookup.defineClass only allows injecting classes into the same class loader the lookup was requested from (call site sensitivity), there is no way to inject classes into arbitrary class loaders, right?\nExcept maybe if you would use instrumentation to add a public method returning the result of MethodHandles.lookup() into a public class which is loaded by the target class loader. Then you could call this method via reflection (that would only work if the module of the enhanced class is exported, however) and get a MethodHandles.Lookup, which is sensitive to the target class loader, allowing you to inject classes into it. But that does not sound like a compelling solution.... How do you feel about the approach of creating a class loader as the child of the target class loader and to load the helper classes with it?. Sorry for the delay. It was just an idea first but I now have a working prototype.\nThe idea is that the agent provides an interface which is implemented by a helper class. The helper is then loaded by a classloader which is a child of the target class loader. That way, the advice does not need to know the implementation type of the interface and can just refer to the known interface.\nI have documented that approach in more detail in this PR: https://github.com/elastic/apm-agent-java/pull/126/commits/5654dbfab6b149e99daf646bb01b28bb06fe73cb#diff-9727737e518096628fbe78bd3a415ac8R22\nDo you think this approach is feasible once I make sure that the helper classes and the helper class loader can't cause classloader leaks (by storing them in a weak map)?\nDo you see any way to add this functionality into Byte Buddy so that it works more seamlessly and similar to net.bytebuddy.agent.builder.AgentBuilder.Transformer.ForAdvice#include(java.lang.ClassLoader...)?. I have modified the HelperClassManager in my PR a bit.\nIt's not an interface and the currently single implementation assumes that there is only one target CL and that it never gets shuts down, like the container class loader.\nWhen instrumenting classes which are part of the user application, however, I'll need another implementation. That one could use your WeakConcurrentMap with the target class loader as the key and the helper class instance as the value. As the helper class instance references the target class loader, which prevents it to become collectable, I'd have to wrap the helper class instance in a SoftReference. This could lead to the helper instance being collected, without the target class loader being collected, so that I would have to re-create that helper. Another disadvantage of this approach is that the WeakConcurrentMap creates garbage on lookups, as it creates short-lived wrapper objects in WeakConcurrentMap#get. As these are very short-lived, however, GC'ing is probably relatively cheap.\nAnother, less elegant solution would be to store the helper class and the target classloader in a regular ConcurrentHashMap and explicitly remove class loaders which are shutting down. However, this requires integration with the corresponding framework. For example, one could intercept calls to javax.servlet.Servlet#destroy and remove the Thread.currentThread().getContextClassLoader() from the map. That seems very brittle though.. This is definitely not thought through well enough for the general case to bake it into Byte  Buddy. Just wanted to hear if you had any ideas how to solve that. \nLet\u2019s hope that Java 11 does not ship without a replacement for Unsafe#defineClass. How do you see the chances for that?. Does your Add dispatcher for using Unsafe::putBoolean to allow class injection on Java 11 (https://github.com/raphw/byte-buddy/commit/6f52a88fc6bff9ed65c3941806d22bfba07a3912) commit mean that it supports injecting helper classes even on Java 11? That would be great! Are there any caveats?\nBut doesn't that also mean the module system has a hole you are \"exploiting\" with this? I'm worried that putBoolean will be the next thing which gets removed from Unsafe. But hopefully, we'll have a more appropriate alternative to Unsafe#defineClass by then.. I forgot to mention this, but yes, I'm using the latest Byte Buddy version: https://github.com/elastic/apm-agent-java/commit/4acfcb960aefb16f16438e84cb905d697e66b394#diff-600376dffeb79835ede4a0b285078036R75. I could sear, I have tried with -Dnet.bytebuddy.experimental=true before but it seems to do the trick.... Thanks for merging!\nI'd appreciate a release for this. I think it should be in the milestone 1.8.14, as 1.8.13 is already released.. Did you see https://github.com/raphw/byte-buddy/issues/492?. I guess you could probably use the Byte Buddy maven plugin to enhance all the advice methods which have a special annotation, for example.. > you can equally apply several advices per instrumented type with same results\nBut applying an OnMethodExit advice to an OnMetodEnter advice i.e. clean up stuff after the OnMethodExit has been executed would probably not work then, right?\nEven if you apply three OnMetodEnter advices, one for generic pre-processing one for the actual OnMetodEnter advice and one for generic post-processing of the actual OnMetodEnter advice, you can't make sure the generic post-processing is executed with finally semantics (in case the actual OnMetodEnter advice throws an exception).. Hey Rafael,\nthanks a lot for having a look and sorry for the faulty instructions.\nThe error happens when you remove the .and(nameContains(\"Request\")) matcher i.e.\nreturn not(isInterface())\n  .and(declaresMethod(any()))\n  .and(hasSuperType(named(\"javax.servlet.http.HttpServletRequest\")));\nSome observations:\n\nWhen adding org.eclipse.jetty.server.Request.class.getName(); to the first line of co.elastic.apm.servlet.AsyncServletTest#setUp, the test succeeds. This loads the class before registering the transformers, which makes Byte Buddy retransform this class (instead of transforming when it is loaded).\nReading the methods of all classes by calling and(declaresMethod(any())) seems to mess up something.\n\nQuestions:\n\nWhen retransforming a class, Byte Buddy uses reflection instead of parsing the class byte array, right?\nWhat happens when calling something like and(declaresMethod(named(\"startAsync\"))? I assume byte buddy lazily parses the class file to get the required information. But does it parse the whole bytecode of the method or just enough to get the method descriptor/method name?\nWould you consider prepending a declaresMethod(named(...)) matcher before a hasSuperType(named(...)) matcher a good idea in order to avoid super type lookups for types which don't declare the methods I want to instrument?\n\n. What is the reason that Byte Buddy does not retransform those classes? Would that be too slow?\nSo using a declaresMethod might not be the best idea because it causes loading of classes during transformation and those classes can't be transformed then. Or would you suggest just using the pool-only descriptor strategy and do use declaresMethod before hasSuperType?. I get that, but wouldn't it be possible to use java.lang.instrument.Instrumentation#retransformClasses to retransform the classes, which were loaded during a java.lang.instrument.ClassFileTransformer#transform invocation? The prerequisete would be calling net.bytebuddy.agent.builder.AgentBuilder#disableClassFormatChanges, of course.. Ok, makes sense, thanks.\nAny advice (pun intended) in regards to whether you think using a declaresMethod(named(...)) matcher before a hasSuperType(named(...)) makes sense at all?. >  Byte Buddy caches type descriptions if you set up your builder correctly\nI (or rather a customer) once ran into an OOME because of the type cache pool size, that's why I'm a bit cautious to set up that cache. Back then, I fixed it with prepending a matcher like nameContains(\"Servlet\") but that can yield false negatives.. Great, thanks a lot for the tip!. > Otherwise, you can add a raw matcher and read the class file version out of the byte array provided to it if you wanted to ignore classes of given versions.\nNot quite sure how that would work, as the byte[] is not provided in net.bytebuddy.agent.builder.AgentBuilder.RawMatcher#matches. What would be cool is if TypeDescription had a method ClassFileVersion getClassFileVersion() which would make this quite easy. Then there could even be a convenience ElementMatcher in ElementMatchers.\nThe TypeConstantAdjustment sounds great but I think just not messing with bytecode older than Java 5 seems to be safer. I could imagine that there are even some nasty bugs in such old javac compilers which might interfere with Byte Buddy.. I'm sorry but I can't seem to find how I can add an AsmVisitorWrapper to an AgentBuilder.Transformer.ForAdvice().advice. I can see that it's possible with AgentBuilder.Transformer.ForAdvice().transform, however.. Implemented in https://github.com/elastic/apm-agent-java/pull/320\nThanks for your help!. ",
    "shot-mk": "Thanks for fast reply. This is not actual name i was trying.. But still u was right about the source of the problem. The class that i was trying to intercept wasn't in a classpath.. i just moved from ofClassPath() strategy to of(ClassLoader) strategy and eveything works as a charm.\n. ",
    "coveralls": "\nCoverage remained the same at 92.251% when pulling bd8acd7149089753c3b6b7b8bf145aaed434e539 on felixbarny:equals-optimization into 6b903e5f0c82b90807bdceda64ec0a4ee81b0c8a on raphw:master.\n. \nCoverage remained the same at 91.956% when pulling 3475bbcea94e14ae4599be52ab5761fa1de17008 on orange-buffalo:javadoc-update into b365f38f8d446ccf200a9592bfef2bb9c18099be on raphw:master.\n. \nCoverage decreased (-0.3%) to 91.527% when pulling 2e89801d14788c0f804fab25473ac410e6edb339 on CodingFabian:google-errorprone into b248beef9ffba6b513322fb45a75e937de9667c8 on raphw:master.\n. \n\nCoverage decreased (-0.05%) to 93.483% when pulling f481e6614834a39a385e7507b6768857061752fe on cemelo:master into 365ec804a2da71fbbe7c0419afdf2bd78d92f51f on raphw:master.\n. \n\nCoverage decreased (-0.05%) to 93.483% when pulling f481e6614834a39a385e7507b6768857061752fe on cemelo:master into 365ec804a2da71fbbe7c0419afdf2bd78d92f51f on raphw:master.\n. \n\nCoverage remained the same at 93.537% when pulling 1ab92863e6128e778990315e7a748f2f52839b91 on Godin:jacoco into 365ec804a2da71fbbe7c0419afdf2bd78d92f51f on raphw:master.\n. \n\nCoverage remained the same at 93.453% when pulling a2a4d8734a18d3a5a7d5dc2cf56f8afc99ba35cd on Godin:upgrade-asm into 930ea63cfec4f490b9f85ed705640de13ffa5c9b on raphw:master.\n. \n\nCoverage decreased (-0.8%) to 92.47% when pulling 580a30eb7f501177c3396850f6244450c7405279 on orange-buffalo:issue-245 into 9a2e50f3ecd0ef19d55ab370eb0b3ccaadd51c6d on raphw:master.\n. \n\nCoverage remained the same at 92.142% when pulling d1be13d7a96b6a1320200aad9579389f44b6998f on mches:fix-build-plugins into a72c9f9db6a8e77f77ab1a862d3e95021be0ecb6 on raphw:master.\n. \n\nCoverage remained the same at 92.143% when pulling e7648699cf101ed362acc24ece9e41a3b5191aa9 on mches:fix-documentation into 72307066f0c239b357597223b5b04d94e968472c on raphw:master.\n. \n\nCoverage remained the same at 92.149% when pulling 43c1dbbe55798ab0a8b565fdf4377f50a81ca35a on mches:add-appveyor-windows-ci into 28e1b33344ca5caa2b37d346199d6c2c773452a1 on raphw:master.\n. \n\nCoverage remained the same at 92.149% when pulling c2c3a7fd59a5f59feea1681e5158586c1e7a595c on mches:add-appveyor-windows-ci into 28e1b33344ca5caa2b37d346199d6c2c773452a1 on raphw:master.\n. \n\nCoverage remained the same at 92.149% when pulling 5470de4084199c03e840ffc91fa91ebd1be111ca on mches:add-appveyor-windows-ci into 28e1b33344ca5caa2b37d346199d6c2c773452a1 on raphw:master.\n. \n\nCoverage remained the same at 92.149% when pulling 36115c1e0df3023d45684b8001c6f70b79c4b730 on mches:add-appveyor-windows-ci into 28e1b33344ca5caa2b37d346199d6c2c773452a1 on raphw:master.\n. \n\nCoverage remained the same at 92.149% when pulling 36115c1e0df3023d45684b8001c6f70b79c4b730 on mches:add-appveyor-windows-ci into 28e1b33344ca5caa2b37d346199d6c2c773452a1 on raphw:master.\n. \n\nCoverage remained the same at 92.149% when pulling 855bd92e8945998dc694c584554e6fdfc4926da0 on mches:add-appveyor-windows-ci into 28e1b33344ca5caa2b37d346199d6c2c773452a1 on raphw:master.\n. \n\nCoverage remained the same at 92.149% when pulling 04dca6e951da778a30598245b89cf6b3742f2749 on mches:add-appveyor-windows-ci into 28e1b33344ca5caa2b37d346199d6c2c773452a1 on raphw:master.\n. \n\nCoverage remained the same at 92.149% when pulling 04dca6e951da778a30598245b89cf6b3742f2749 on mches:add-appveyor-windows-ci into 28e1b33344ca5caa2b37d346199d6c2c773452a1 on raphw:master.\n. \n\nCoverage remained the same at 91.829% when pulling 3a4e08ba98e55c40ba8144c095c894aadb607fc9 on anuraaga:dev_rag into f11ee5a16d5965112cc60cda966e83eca0d16846 on raphw:master.\n. \n\nCoverage remained the same at 91.703% when pulling 93668b92d4eb2084fe4402f9e962ba479b2209a4 on CodingFabian:fix-typos into 838148dd9b735651720094e59f7ce10c1fe7880f on raphw:master.\n. \n\nCoverage remained the same at 91.703% when pulling 93668b92d4eb2084fe4402f9e962ba479b2209a4 on CodingFabian:fix-typos into 838148dd9b735651720094e59f7ce10c1fe7880f on raphw:master.\n. \n\nCoverage decreased (-0.005%) to 88.979% when pulling 70237d1f8e9d259d9514c9055399bf8ad29669ae on skapral:master into 982034f8660679dd878cd7fd4a8eeb407227de5b on raphw:master.\n. \n\nCoverage decreased (-0.005%) to 88.979% when pulling 70237d1f8e9d259d9514c9055399bf8ad29669ae on skapral:master into 982034f8660679dd878cd7fd4a8eeb407227de5b on raphw:master.\n. \n\nCoverage increased (+0.004%) to 88.988% when pulling 6467f9c41b60a98538d84873fb24bec54dfedc03 on skapral:master into 982034f8660679dd878cd7fd4a8eeb407227de5b on raphw:master.\n. \n\nCoverage decreased (-0.2%) to 88.747% when pulling 7e6de0b65501cc1c63236cdc326c4bfd51d33af8 on felixbarny:accept-null into 53c1f008de2615986806c9af9cbf4e8261447821 on raphw:master.\n. \n\nCoverage decreased (-0.2%) to 88.747% when pulling de2f0f5ffec567ec020c8f1316d8d17e6a18f91c on felixbarny:accept-null into 53c1f008de2615986806c9af9cbf4e8261447821 on raphw:master.\n. \n\nCoverage decreased (-0.2%) to 88.758% when pulling ff69e22bea3f685daf1f2c51a110ae8738ef0a01 on felixbarny:fix-bind-signature into 53c1f008de2615986806c9af9cbf4e8261447821 on raphw:master.\n. \n\nCoverage remained the same at 88.797% when pulling ee998b7cb976af170640299e0b59aaacef719d7e on jamesdbowman:master into 91dc3ae833506c49aa0c083317902646c700cd4b on raphw:master.\n. ",
    "jakubhava": "Hi,\n  thanks a lot for great explanation! I'll have a look on it today.\nKuba\nOn 11 May 2016 03:03, \"Rafael Winterhalter\" notifications@github.com\nwrote:\n\nHello,\nwhen Byte Buddy creates a class for you using an interceptor, the\ngenerated class is similar to the following. Assuming the original class\nFoo:\nclass Foo {\n  String bar() {\n    return \"bar\";\n  }\n}\nAn interception to some interceptor object Qux would result in the\nfollowing redefined version:\nclass Foo {\n  static Qux $interceptor;\n  String bar() {\n    return $interceptor.intercept();\n  }\n}\nObviosuly, for this to work the class Qux must be known to your target\nmachine that executes the code. This is however not sufficient.\nAdditionally, the $interceptor field must be set which Byte Buddy does by\nadding a class initializer block to the class (static { ... }) where the\nfield is set. It is impossible to set this field during the instrumentation\nwhere the class is not yet loaded.\nIf you are running the class on the same JVM that generates it, Byte Buddy\ntakes care of all of this for you but in your case, this does not work. You\ncan however configure this behaviour:\n1.\nByte Buddy lets you choose an initialization strategy that determines\n   the (optional) creation of a class initializer block. You can define a\n   no-op strategy but read the LoadedTypeInitializer using an\n   AgentBuilder.Listener in the onTransformed method. You can serialize\n   this instance (given that your Qux class is serializable) and send it\n   to the machine that loads your class. Also, using this listener, you can\n   find out if there are auxiliary classes that need to be loaded by the\n   target VM. Auxiliary classes are helper classes that need to be loaded to\n   make the instrumentation work. Auxiliary classes are proxies such as the\n   @SuperCall classes.\n   2.\nYou can avoid using an instance of Qux but delegate to Qux as a class.\n   This way, it suffices to load the class Qux by the target VM as the\n   LoadedTypeInitializer does not need to be run (it is \"not alive\" in\n   Byte Buddy terminology.\n   3.\nYou can replace the interception API with the Advice instrumentation\n   which inlines the byte code of your methods into the class file. This way,\n   you can avoid changes to the class file altogether and you guarantee that\n   the class can be loaded directly. The downside of this API is that the\n   Advice component only allows for around advice. You still need to\n   disable self-initialization; you can call .disableClassFormatChanges().\nPS: Bootstrap injection is disabled by default, you do not need to call\nthe method in the above example.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/raphw/byte-buddy/issues/127#issuecomment-218335673\n. Sorry to open this one again.\n\nI went through your response one more time. The Byte Buddy framework is therefore needed in case of option 1 and 2, but if I get it right, when using Advice  component there's no need for Byte Buddy framework to be available on the JVM where the class is loaded, or am I wrong ?\nAre there any plans to support inlining the code in the the class file also without Advice component ? It would be great given this use case.\nThanks, Kuba\n. Hi,\nthanks! Just to clarify my understanding about the difference between option 1 and option 2 you mentioned in the first reply. Option 2 represents the case when we do delegation MethodDelegation.to(Foo.class), where Foo has static methods acting as interceptors, right ? Is in this case is Byte Buddy framework needed as well or  not and the instrumented class looks like:\n```\nclass Foo {\nString bar() {\n    return Interceptor.staticMethod()\n  }\n}\n```\nIf this is possible, than all what needs to be done is to send the interceptor class to the target JVM and load it there. Also Byte Buddy framework should not be needed in this case. Or am I wrong ?\nI've been playing with the solution using named field. I have really super simple transformer and interceptor for now.\nMy Transformer looks like\npublic class SimpleTransformer implements AgentBuilder.Transformer {\n    @Override\n    public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader) {\n        return builder.method(ElementMatchers.nameEndsWith(\"print\"))\n                .intercept(MethodDelegation.toInstanceField(SimpleInterceptor.class, \"interceptor\").andThen(SuperMethodCall.INSTANCE));\n    }\n}\nis the delegation toInstanceField what you meant by named field please ?\nThe Interceptor like \npublic class SimpleInterceptor {\n    public void print(){\n        System.out.println(\"Method print was instrumented \");\n    }\n}\nIf I understand it well the named field is static field in the instrumented class so in order to set it I could do in target machine: \nInstrumentedClass.namedField = new Interceptor(), or am I wrong ?\nThanks again!\n. Actually when thinking about it more I would need to make more types serialisable ( all not serialisable types depending used in TypeDescription) such as FilterableList too and so on, so I'm not sure whether this is still suitable change for you.\n. Sorry Rafael,\n I got sick and forgot to respond you since then.\nI have already found an easier workaround where I can use unchanged bytebuddy release.\nThanks for great help and effort.\nSorry again,\nJakub\n. Figured it out. I must have been blind :) dynamicType provides all the information.\n. ",
    "geld0r": "Can you be a bit more specific please?\nWhat exactly do I need to do differently in a test for my agent as opposed to the example tests?\nIs there any way at all to make sure that the agent is attached before the class is loaded?\nCurrently I am attaching the agent in the tests @Before method.\nAs far as I understood, this problem will not occur when actually using the agent with -javagent option, correct?\nIn case (Unit-)Testing this is not possible at all, how do you suggest to approach developing an agent?\n. Thank you for explanation.\nWhat I want to achieve is \"only\" to be notified whenever a FileInputStream (and potentially similar streams/files/handles) are opened and closed so that I can keep track of this (leak detection)\nGiven your explanation, this probably can't be achieved reliably with my current approach.\nIn that case I'll try out Advice, although I am not sure if I understood how to use that yet.\n. Thank you, this works fine and is exactly what I was looking for!\nI've run into another error though that I don't understand:\nI am getting a java.lang.NoClassDefFoundError when the Advice is executed and refers to any other class (e.g. logger or custom classes). When I comment this out, the error doesn't occur anymore.\nThis is the advice:\n@Advice.OnMethodExit\npublic static void exit(@Advice.Argument(0) File file)\n{\n    System.out.println(\"Advice out: \" +file);\n    RecordFactory.getInstance().create(file);\n}\nI'm using the following AgentBuilder:\nnew AgentBuilder.Default()\n                .disableClassFormatChanges()\n                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n                .with(new LoggingListener())\n                .type(ElementMatchers.isSubTypeOf(FileInputStream.class))\n                .transform(((builder, typeDescription, classLoader) ->                                               builder.visit(Advice.to(BeforeAdvice.class).on(matcher))))\n                .installOnByteBuddyAgent();\nI've already tried out the various intialization strategies without success.\n. I've tried the ByteBuddyAgent.getInstrumentation().appendToBootstrapSearch( ... ) approach. This really seems to rely on the code being present in the form of a jar file? At least when running from an IDE this is not the case. I've now tried to split the project into several modules so that I can load the relevant classes from a prebuilt jar.\nIs there any easier way to achieve this?\nI've not been able to get it running with the other approach.\n. ",
    "orange-buffalo": "Glad to hear that this is fixed! Thank you! \n. I've tested this on 1.4.2 - works like a charm. Besides, I've discovered significant performance boost - instrumentation takes 10% less time to execute now.\nThanks a lot for these changes! \n. As far as I understand, if I have the same matchers in on(..) for two advice adapters, the matchers' code will be executed twice for every transformed class. This influences performance when matchers are more or less complicated.\nAnother problem is that with advanced Advice configuration (like custom bindings) there will be code duplication and/or code readability will be reduced. \n. Super, thank you very much! \n. Cool, thank you! \n. Great, thanks a lot for such a prompt fix! \n. Recently I have discovered couple of more cases where this problem is reproduced, although most of such issues were fixed in latest versions.\nFor example, when using test code provided in issue description, instrumentation of  org.hsqldb.lib.LongDeque from \nxml\n    <dependency>\n      <groupId>org.hsqldb</groupId>\n      <artifactId>hsqldb</artifactId>\n      <version>2.3.4</version>\n    </dependency>\nfails with the same error message. \n. Thank you for explanation. I can imagine how many different variations exist for these cases and that covering them all is far not a simple task. \n. With this fix all the similar errors in my application are resolved. Thank you! \n. Setting this option solved the problem. Thank you! \n. I was also thinking that JRebel relies on specific patterns in class file. I disabled AspectJ plugin for JRebel (as class under the test in from AspectJ framework) - this should have prevented instrumentation. But the result was the same, although JRebel log stated plugin was disabled. We do not know how JRebel is implemented, maybe some other code of the tool instruments the class anyway. \nHere is a dumped class file.\nI believe there could be other instrumentation libraries that heavily rely on bytecode structure. Could it be possible to append the value returned from @OnMethodEnter to the end of local variables array to avoid shifting existing variables? With this approach risks of collisions probably would be minimized..\n. Actually, the problem comes from real application where transformer is a java-agent. I tried to apply JRebel agent after my custom one, but with no luck, result was the same.\nVerification error does not provide anything else but starcktrace to the place class is loaded and the message from issue description. \nI completely understand your concerns and agree with what you've said. As far as I know, JRebel uses Javassist, maybe there is an issue in the library or the way it is used. I will contact JRebel and ask them to shed some light on what they do with this class. \nThanks for your help! \n. Cool, thank you! I also provided JRebel team with details in related support request. \n. I checked it on master, the problem is fixed. Again, thank you for your help!\n. Great, glad to hear that this is considered. If you need help with migration to Lombok, I can prepare a pull request for this. . Super! Thanks for the quick merge and feedback! . @wltjr, it is very strange that one needs to package lombok anywhere, as it is an annotation processor library and should be used only during compilation of code it is processing. But anyway, as lombok has issues with the latest versions of java, then for sure it makes sense to remove it from the project. I am glad that the byte-buddy code is kept clean with the custom plugin that generates necessary boilerplate. . Thanks a lot! . Many thanks for the quick resolution!. ",
    "vlsi": "\nByte Buddy does voluntarily not add a built-in cache as I consider this pattern flawed\n\nYou'd better make that explicit then. You never say \"users should cache proxy classes on their own\".\nI've listened to your JFocus \"making java more dynamic\" and you suggest \"new ByteBuddy()...etc\" kind of stuff.\nProper caching is not something that can be added later as user realizes \"(s)he needs to cache that\".\nhttps://github.com/mockito/mockito/blob/9c51378cee8d9e5173355d59eae8b5fcc0b906d8/src/main/java/org/mockito/internal/creation/bytebuddy/CachingMockBytecodeGenerator.java#L25\nIs just plain old lock. It does not scale. Of course you could say Mockito does not need high performance from CachingMockBytecodeGenerator.get (I might agree), however, I would argue, it is not that easy to achieve read scalability & class unloading ability.\n\nFinally, I do not think such a benchmark would even make sense if there was something to compare. How many cache misses should I emulate? \n\nHere: https://youtu.be/80wCytGEY1g?t=2659 you compare \"good approach for one library vs bad approach for another one\". What sense does it make?\nCan you make that more like an apple vs apple comparison?\nWhat conclusion should regular user end up with after staring at that benchmark slide? I know you say something re 3b, but please refactor the slide.\n\nthe JVM would probably create a fast-path for reading the previously generated class and erasing all other paths with uncommon traps\n\nOf course there are unlimited number of benchmarks to make and unlimited amounts of paint to dry.\nHowever, a mere \"how fast does it take to create a single proxy bean\" would make a lot more sense than \"how long does it take to generate a class\".\nNote: you might even contrast that different libraries favor different approach, so \"in order to create that proxy, you need this piece of code for BB, that for CGlib, etc\".\n. > I agree that the Mockito solution can be improved but I do not have the time currently\nI wonder how other projects solve the problem.\n\nI agree that the slide could be explained in greater detail but in the reality of a conference talk, you do not always have the time for speaking out everything you try to say\n\nHave you considered splitting the slide into several ones?\nHaving several charts would help to understand the meaning and reduce the time you talk the info through at the same time.\n\nByte Buddy is much faster, especially the generated code when its runs.\n\nAh, that is the next comment: it would be great if you could add not just fact that \"one is slower\", but the justification on why is it slow. It would be great if that is inherent to API choices that cglib uses (e.g. idioms from the past that do not apply to modern world, yet you either support old APIs or make backward-incompatible change).\n\nI do not hear myself saying good approach for one library vs bad approach for another one in that video so I do not know what you mean by that.\n\nCglib had class cache for ages. What I did was just to make that cache scalable for read-heavy kind of workloads.\nLots of users adopted \"use new Enhancer()....create()\" as a factory. Note: I do not think many of them use cglib.Factory interface. They just rely on new Enhancer()....create() way to create objects.\nThe way you compare \"how log does it take to generate class\" is not fair from cglib's point of view. I mean lots of users would have .create() in mind as you mention cglib.\nWhile the wording on the slide is exact, it is misleading, as it just does not reflect typical cglib usage pattern.\nHere's how Spring Framework uses cglib: https://github.com/spring-projects/spring-framework/blob/183594207fbb447e1b59262b4469f2aefbb8a3ec/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java#L179-L203\nThey just leverage cglib's cache and it is good enough for them so they can skip implementing their own cache.\nThat is what I mean by \"you compare wrong cglib approach with good ByteBuddy approach\".\n. > if I wrote a migration guide, I would mention this but again I did not yet have the time, its a free time project\nI wonder if you are going to reuse the slides for your Jokerconf talk. If that is the case, please consider splitting the benchmark slide into several ones.\n. > Again, I sympathise that you want to see your caching solution excel here, but this is not the point of this benchmark.\nI'm afraid you don't get me. I don't say \"cglib all the things\".\nCurrently you claim \"cglib is just slow\" and use not that fair approach to compare.\nIt would be much better if you said \"cglib is for proxies and cache keys only\", and provided fair comparison for the cases you do compare.\n\na code generation library that does one thing and does it well. This is what the benchmark is for and nothing more\n\nThe problem is end users require not just code generation, but they need something more high level. For instance they might need to implement @Secure that adds a security check right into user-provided class/interface. That kind of benchmark (+analysis) makes more sense than the one that measures \"how fast can we call a method that always returns null\".\n. What if I want to debug a third-party application that uses bytebuddy? It is not always possible to modify source code just in order to insert \"save classes\" call.\n. That's a pity you mark debug-ability issue as wontfix.\nCurrently one can easily capture Spring's & Guice's generated classes via -Dcglib.debugLocation=/...\nIf they migrate to BB, class dump will be impossible.\n. Well, closing an unresolved issue that is likely to be resolved one day is something new for me in OSS development.\nTypically, they leave \"starter/for-newbies/easy\" kind of tickets open so those who want to contribute can pick something easy up.\n. @wltjr, ByteBuddy uses at least the following patterns \n@EqualsAndHashCode(callSuper = false)\n@EqualsAndHashCode(exclude = \"name\")\n@EqualsAndHashCode(callSuper = false, of = \"prefix\")\nAre you sure AutoValue provides exact match for that annotations?. ",
    "ChaosData": "I'm not sure that AgentBuilder, as used in your example, is able to find the classes I'm attempting to work with.\nIs there a way to pass the AgentBuilder API a ClassLoader or ClassFileLocator to search?\nAlternatively, is there a simple enough way to use the Advice API with the normal ByteBuddy API?\nFor reference, I'm attempting to use the following:\njava\n    new AgentBuilder.Default()\n        .disableClassFormatChanges()\n        .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n        .type(ElementMatchers.is(rmxb.getClass()))\n        .transform((builder, _cl, _td) -> builder.visit(Advice.to(MyAdvice.class).on(ElementMatchers.named(\"getInputArguments\"))))\n        .installOnByteBuddyAgent();\nBoth java.lang.management.ManagementFactory and sun.management.RuntimeImpl (which I'm looking to hook), are loaded from separate classloaders that are separate from the main chain accessible from premain.\n. Both of those work!\nGiven that I can get java.lang.BootstrapMethodError exceptions wrapping java.lang.NoClassDefFoundError when referencing things out of the Advice classes, they probably are loading in \"bootstrap\" class loaders. Though I can verify via Instrumentation.getInitiatedClasses that they're not in the \"normal\" bootstrap class loader, which is what threw me off.\nThanks!\n. Using AgentBuilder.Transformer.ForAdvice, the following reduced code fails to reference its own (public) outer class.\n```java\npublic class HttpServletRequestAlikeHook {\n  public static class GetRequestURIWrapper {\n@Advice.OnMethodExit(onThrowable = Exception.class)\nstatic void exit(@Advice.Return (readOnly = false) String value) {\n  try {\n    System.out.println(new HttpServletRequestAlikeHook());\n  } catch (Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    String st = sw.toString();\n\n    try {\n      Files.write(Paths.get(\"/tmp/error.log\"), st.getBytes());\n    } catch (Throwable tt) { }\n  }\n\n}\n\npublic void hook(Instrumentation inst) {\n  new AgentBuilder.Default()\n    .disableClassFormatChanges()\n    .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n    .ignore(ElementMatchers.none())\n    .type(getMatcher())\n    .transform(new AgentBuilder.Transformer.ForAdvice()\n      .include(HttpServletRequestAlikeHook.class.getClassLoader())\n      .advice(\n        ElementMatchers.named(\"getRequestURI\"),\n        GetRequestURIWrapper.class.getName()\n      )\n    )\n    .installOn(inst);\n}\n\nElementMatcher.Junction<TypeDescription> getMatcher() {\n  TypePool typePool = TypePool.Default.ofClassPath();\n  TypeDescription typeDescription = typePool.describe(\"javax.servlet.http.HttpServletRequest\").resolve();\n  return ElementMatchers.isSubTypeOf(typeDescription);\n}\n\n}\n}\n```\n/tmp/error.log ends up with the following (trimmed a bit):\njava.lang.NoClassDefFoundError: dynagent/hooks/HttpServletRequestAlikeHook\n  at org.eclipse.jetty.server.Request.getRequestURI(Request.java:1310)\n  ...\nThis is similar to the error I got when using the following alone instead of AgentBuilder.Transformer.ForAdvice (in this particular case, the inner class was the one that couldn't be found):\njava\n        .transform((builder, _cl, _td, _mod) -> builder.visit(Advice.to(this.getClass()).on(ElementMatchers.named(\"getRequestURI\"))))\nI was previously using the following to try and ensure that classes were loaded. However, this appears to load the classes separately/\"fresh\" such that any existing state on them (e.g. in static public fields) that I initialized are null. It's worth noting that I would get the above error if I didn't specifically load HttpServletRequestAlikeHook.\njava\n      Map<TypeDescription, byte[]> classes = new HashMap<>();\n      classes.put(\n          new TypeDescription.ForLoadedType(this.getClass()),\n          ClassFileLocator.ForClassLoader.read(this.getClass()).resolve()\n      );\n      classes.put(\n          new TypeDescription.ForLoadedType(HttpServletRequestAlikeHook.class),\n          ClassFileLocator.ForClassLoader.read(HttpServletRequestAlikeHook.class).resolve()\n      );\n...\n      File temp = null;\n      try {\n        temp = Files.createTempDirectory(\"dynagent\").toFile();\n      } catch (IOException e) { }\n      ClassInjector.UsingInstrumentation.of(temp, ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, inst).inject(classes);\nFor reference, the JAR containing HttpServletRequestAlikeHook is loaded via URLClassLoader from the agentmain(String,Instrumentation) JAR, which invokes the loaded child JAR via reflection. I'm currently bundling Byte Buddy 1.8.0 into the child JAR.\njava\n          URL path = new URL(\"file://\" + arg);\n          URLClassLoader child = new URLClassLoader(\n            new URL[]{path},\n            AgentMain.class.getClassLoader()\n          );\n...\n          Class<?> agentClass = Class.forName(\"dynagent.Agent\", true, child);\n          Method run = null;\n          for (Method m : agentClass.getDeclaredMethods()) {\n            if (\"run\".equals(m.getName())) {\n              run = m;\n              break;\n            }\n          }\n          run.invoke(null, inst, logger);. Is there a way to get a handle on the advice class that exists in the class loader of the instrumented class so that I can inject values into its static fields?. I went with the former, that seemed to work for that.\nNow I appear to be hitting a limitation(/design choice?) due to my attempt at loading/unloading URLClassLoaders. Because the code that sets up the instrumentation is within the classes I inject via the ClassInjector, this leads to an interesting quirk whereby subsequent loads of those classes from any JAR (after the initial one is close()-d) will use the injected class itself, which now either resides in the system classloader, or the bootstrap one (the null classloader) and therefore fails to resolve Byte Buddy itself. It's kind of funny actually.\nI'll try to refactor the code not to behave like that, but is there a (decent?) way to remove injected classes from either the system or bootstrap classloaders once one is \"done\" with them? Alternatively, do you recommend any ways to inject classes/JARs into arbitrary classloaders? I feel like I might have to go this route if I can't \"update\" those implementations after the initial injection anyway. Worse case, I was thinking of just doing some parent classloader switcheroo shenanigans to force them to resolve from within the classloader of the class being adviced.\n. I was able inject the class into the bootstrap classloader and then update it though retransformation it with the raw Instrumentation/ClassFileTransformer APIs. Obviously that limits the modifications that can be made, but it works well enough for now. Thanks!. So, my understanding is that in the rewriting of the original bytecode when an advice class is applied, parameter accesses should generally stay the same, instead of being re-written with local variables that shadow the method parameters. However, the insertion of such local variables occurs when @Advice.OnMethodExit advice is applied to a method. I've included a single-file reproduction below. It simply spits out the resulting bytecode to a file path specified by the first argument.\n```java\nimport net.bytebuddy.ByteBuddy;\nimport net.bytebuddy.asm.Advice;\nimport net.bytebuddy.asm.AsmVisitorWrapper;\nimport net.bytebuddy.implementation.attribute.AnnotationRetention;\nimport net.bytebuddy.dynamic.DynamicType;\nimport net.bytebuddy.dynamic.scaffold.InstrumentedType;\nimport net.bytebuddy.implementation.Implementation;\nimport net.bytebuddy.implementation.bytecode.assign.Assigner;\nimport java.lang.reflect.Method;\nimport java.io.FileOutputStream;\nimport static net.bytebuddy.matcher.ElementMatchers.*;\nclass Entry {\npublic static void main(String[] argv) {\n    DynamicType.Builder<?> dtb = new ByteBuddy()\n      .with(InstrumentedType.Factory.Default.FROZEN)\n      .with(Implementation.Context.Disabled.Factory.INSTANCE)\n      .with(AnnotationRetention.ENABLED)\n      .redefine(Advicee.class);\ndtb = dtb.visit(Advice.to(Advicer.class).on(isAnnotatedWith(Advice.OnMethodExit.class)));\n\nbyte[] alt_hook_bytes = dtb.make().getBytes();\n\ntry {\n  FileOutputStream stream = new FileOutputStream(argv[0]);\n  stream.write(alt_hook_bytes);\n} catch (Throwable t) {\n  t.printStackTrace();\n}\n\n}\nstatic class Advicee {\n@Advice.OnMethodExit(onThrowable = Exception.class)\nstatic void exit(@Advice.Origin Class c, @Advice.Origin Method m, @Advice.This Object self,\n                 @Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object ret) {\n  if (\"/test\".equals(ret)) {\n    ret = new String(\"/nottest\");\n  }\n}\n\n}\nstatic class Advicer {\n    @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)\n    static boolean exit_enter(@Advice.Origin Class<?> hook_class) {\n      System.out.println(\"Advicer::exit_enter: \" + hook_class.toString());\n      return false;\n    }\n// comment this out the second time\n@Advice.OnMethodExit\nstatic void exit_exit(@Advice.Origin Class<?> hook_class, @Advice.Enter boolean enter_skipped) {\n  System.out.println(\"Advicer::exit_exit: \" + hook_class.toString());\n}\n\n}\n}\n```\nWith both methods from the Advicer class applied, I get the following:\n```java\nimport net.bytebuddy.implementation.bytecode.assign.Assigner;\nimport java.lang.reflect.Method;\nimport net.bytebuddy.asm.Advice;\nstatic class Advicee\n{\n    Advicee() {\n        super();\n    }\n@Advice.OnMethodExit(onThrowable = Exception.class)\nstatic void exit(@Advice.Origin final Class clazz, @Advice.Origin final Method method, @Advice.This final Object o, @Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) final Object o2) {\n    System.out.println(\"Advicer::exit_enter: \" + Advicee.class.toString());\n    if (!false) {\n        if (\"/test\".equals(o2)) {\n            final Object ret = new String(\"/nottest\");\n        }\n    }\n    System.out.println(\"Advicer::exit_exit: \" + Advicee.class.toString());\n}\n\n}\n```\nbut with only the @Advice.OnMethodEnter method applied, I get this:\n```java\nimport net.bytebuddy.implementation.bytecode.assign.Assigner;\nimport java.lang.reflect.Method;\nimport net.bytebuddy.asm.Advice;\nstatic class Advicee\n{\n    Advicee() {\n        super();\n    }\n@Advice.OnMethodExit(onThrowable = Exception.class)\nstatic void exit(@Advice.Origin final Class c, @Advice.Origin final Method m, @Advice.This final Object self, @Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object ret) {\n    System.out.println(\"Advicer::exit_enter: \" + Advicee.class.toString());\n    if (false) {\n        return;\n    }\n    if (\"/test\".equals(ret)) {\n        ret = new String(\"/nottest\");\n    }\n}\n\n}\n```\nThe difference between these is that the former assigns to a never-again-used final Object ret local variable, while the latter assigns to the @Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object ret parameter. Is there any way to retain this structure/behavior when applying @Advice.OnMethodExit advice?\nWorse-case scenario, I can try to fiddle with the resulting bytecode with ASM, and using the annotation metadata and cross-referencing that against the added local variable to swap back in use of the parameter. However, it seems odd that this modification to add in the local variable is happening in the first place.. It was backupArguments: \"Doing so, parameter reassignments applied by the instrumented are not effective during the execution of the annotated exit advice. \"\nDisabling it yields the behavior I was looking for. Ahhh, the power of minimal test cases... :). ",
    "SergejIsbrecht": "Thank you @raphw, I had the same issue, because I was using the \"Stream\"-API in the Advice, which was currently not loaded by the bootstrapper. Removing the line helped a lot.. ",
    "odrotbohm": "Thanks Raphael, for looking into this so quickly. I'll check back, try a newer Eclipse distribution and report my findings.\n. I just downloaded a fresh STS based on the just released Eclipse Neon release and it fails with the same exception. I'll follow up with the STS team on that, but I don't think it tweaks the JDT compiler. One thing I observed though is that even if I compile the classes using Maven and then immediately run the tests, it fails, too.\nI've debugged a bit into it and I see ForTypeArgument.resolve(\u2026) being called with an annotated element with an actual type of sun.reflect.annotation.AnnotatedTypeFactory.AnnotatedTypeBaseImpl (for CrudRepository.delete(java.lang.Iterable)), which in fact doesn't implement AnnotatedParameterizedType on which the method is invoked here. Shouldn't ByteBuddy actually check whether the AnnotatedElement is of the needed type here or are you making sure that this always is the case in a step before?\n. Ha, my thought exactly. I just checked, discovered Eclipse using an old JDK 8 (because it resolves the symlinks to the JDK when setting it up). Tweaked it to use the latest one \u2014 test runs fine.\nThanks for your patience!\n. Looks like there are no snapshots available for 5.3.5. Is it worth fixing that so that we could run tests against the binaries before they're released?. Thanks, Guillaume, appreciated and builds updated. Looking good, no regressions found on our side.. ",
    "nitindandriyal": "I am getting same error with later version of Java, while running test on both Eclipse Neon and Oxygen:\n```\norg.mockito.exceptions.base.MockitoException: \nMockito cannot mock this class: \nMockito can only mock non-private & non-final classes.\nIf you're not sure why you're getting this error, please report to the mailing list.\nJava               : 1.8\nJVM vendor name    : Oracle Corporation\nJVM vendor version : 25.102-b14\nJVM name           : Java HotSpot(TM) 64-Bit Server VM\nJVM version        : 1.8.0_102-b14\nJVM info           : mixed mode\nOS name            : Windows 7\nOS version         : 6.1\nUnderlying exception : java.lang.IllegalArgumentException: Could not create type\n    at org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:42)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.lang.IllegalArgumentException: Could not create type\n    at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:140)\n    at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)\n    at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)\n    at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)\n    at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)\n    at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)\n    at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)\n    at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)\n    at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)\n    at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)\n    at org.mockito.Mockito.mock(Mockito.java:1729)\n    at org.mockito.internal.configuration.MockAnnotationProcessor.process(MockAnnotationProcessor.java:33)\n    at org.mockito.internal.configuration.MockAnnotationProcessor.process(MockAnnotationProcessor.java:16)\n    at org.mockito.internal.configuration.IndependentAnnotationEngine.createMockFor(IndependentAnnotationEngine.java:38)\n    at org.mockito.internal.configuration.IndependentAnnotationEngine.process(IndependentAnnotationEngine.java:62)\n    at org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(InjectingAnnotationEngine.java:57)\n    at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:41)\n    at org.mockito.MockitoAnnotations.initMocks(MockitoAnnotations.java:69)\n    ... 16 more\nCaused by: java.lang.NoSuchMethodError: net.bytebuddy.dynamic.DynamicType$Builder$MethodDefinition$ReceiverTypeDefinition.transform(Lnet/bytebuddy/dynamic/Transformer;)Lnet/bytebuddy/dynamic/DynamicType$Builder$MethodDefinition;\n    at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:66)\n    at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)\n    at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)\n    at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)\n    ... 33 more\n```. ",
    "madhavpandey33": "I am facing the exact same error as above and not able to find any solution for it.\n\nbyte-buddy - 1.7.4 jar\nbyte-buddy -agent-1.7.4.jar\nobjeneis 2.6 jar\nmcokito-core 1.10.0.jar\n\nI am running it on eclipse oxygen.. This is stack trace for the error I am getting:\n```\njava.lang.IllegalStateException: Could not initialize plugin: interface org.mockito.plugins.MockMaker\n    at org.mockito.internal.configuration.plugins.PluginLoader$1.invoke(PluginLoader.java:60)\n    at com.sun.proxy.$Proxy5.isTypeMockable(Unknown Source)\n    at org.mockito.internal.util.MockUtil.typeMockabilityOf(MockUtil.java:29)\n    at org.mockito.internal.util.MockCreationValidator.validateType(MockCreationValidator.java:22)\n    at org.mockito.internal.creation.MockSettingsImpl.validatedSettings(MockSettingsImpl.java:187)\n    at org.mockito.internal.creation.MockSettingsImpl.build(MockSettingsImpl.java:181)\n    at org.mockito.internal.MockitoCore.mock(MockitoCore.java:50)\n    at org.mockito.Mockito.mock(Mockito.java:1798)\n    at org.mockito.Mockito.mock(Mockito.java:1711)\n    at com.inmoment.intercept.repository.impl.InterceptLogDataRepositoryImpl_UT.setup(InterceptLogDataRepositoryImpl_UT.java:39)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n    at java.lang.reflect.Method.invoke(Unknown Source)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:539)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:761)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:461)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:207)\nCaused by: java.lang.IllegalStateException: Failed to load interface org.mockito.plugins.MockMaker implementation declared in sun.misc.CompoundEnumeration@32e6e9c3\n    at org.mockito.internal.configuration.plugins.PluginLoader.loadImpl(PluginLoader.java:94)\n    at org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(PluginLoader.java:48)\n    at org.mockito.internal.configuration.plugins.PluginRegistry.(PluginRegistry.java:20)\n    at org.mockito.internal.configuration.plugins.Plugins.(Plugins.java:18)\n    at org.mockito.internal.util.MockUtil.(MockUtil.java:24)\n    ... 30 more\nCaused by: org.mockito.exceptions.base.MockitoInitializationException: \nCould not initialize inline Byte Buddy mock maker. (This mock maker is not supported on Android.)\nJava               : 1.8\nJVM vendor name    : Oracle Corporation\nJVM vendor version : 25.144-b01\nJVM name           : Java HotSpot(TM) 64-Bit Server VM\nJVM version        : 1.8.0_144-b01\nJVM info           : mixed mode\nOS name            : Windows 7\nOS version         : 6.1\nat org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.<init>(InlineByteBuddyMockMaker.java:171)\nat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\nat sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source)\nat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source)\nat java.lang.reflect.Constructor.newInstance(Unknown Source)\nat java.lang.Class.newInstance(Unknown Source)\nat org.mockito.internal.configuration.plugins.PluginLoader.loadImpl(PluginLoader.java:89)\n... 34 more\n\nCaused by: java.lang.IllegalStateException: No compatible attachment provider is not available\n    at net.bytebuddy.agent.ByteBuddyAgent.install(ByteBuddyAgent.java:367)\n    at net.bytebuddy.agent.ByteBuddyAgent.install(ByteBuddyAgent.java:352)\n    at net.bytebuddy.agent.ByteBuddyAgent.install(ByteBuddyAgent.java:320)\n    at net.bytebuddy.agent.ByteBuddyAgent.install(ByteBuddyAgent.java:306)\n    at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.(InlineByteBuddyMockMaker.java:101)\n    ... 40 more\n```. ",
    "thalissondev-xx": "@madhavpaney33 Did you solve it? . ",
    "cortexcompiler": "I have seen this problem when using Eclipse and Gradle (version < 4.4) when something in your runtime classpath clashes with your test classpath.  This is an issue because Eclipse does not separate the classpaths.  If you can get your compile and testCompile versions to match and be compatible with Mockito then it should solve the Eclipse problem.  You can also update Eclipse and Gradle to support different classpaths between test and non-test runtime.. ",
    "erikhakansson": "Thank you! It works with TypeValidation.DISABLED.\nI did however find another issue, but I'll open a new one for that.\n. Ah, I see. So I suppose Weld is to blame. However, I suspect that lots of libraries exhibit the same behaviour, so right or wrong, I still need to consider the possibility. After blacklisting weld, I discovered that log4j does the same thing. The option to lazily resolve would be most welcome.\nBy the way, where would be the right place to ask general usage questions rather than issues? StackOverflow?\n. Sure I'll check it out as soon as I can!\n. The issue we are discussing on StackOverflow is sort of blocking me here. I don't know where that issue came from, but it happens earlier than the Weld initialization so I can't test that until I've figured out what I've done to introduce that problem. I promise I'll get back to this as soon as I can!\n. Okay, I'll let you know how it goes either case! Thanks for the help! Great support!\n. ",
    "johnlcox": "When I call resolve I get an IllegalStateException saying it can't find the type description. How would I properly create a TypePool for the bootstrap class loader that includes classes from my appended jar?\nI have tried:\n- TypePool.Default.of(Main.class.getClassLoader()) - I thought this would get the main class loader which would delegate up to system and bootstrap.\n- TypePool.Default.of(ClassFileLocator.ForClassLoader.of(null)) - The javadoc indicates this will use the system loader which I also thought would delegate up to the bootstrap loader.\n. Awesome. Using the loaded version is working now. I was still having an issue using the type pool as you had shown earlier. Thank you so much for your help.\nI'm running into some reflection problems now, so my ultimate goal still may not be possible, but I'm glad I was able to get the byte-buddy parts working with your help.\nEdit: Actually I think I should be good to go. I had forgotten how simple I had made my sample implementation. I believe I can get things working with my full implementation.\n. Is it possible for me to use the @This annotation in my delegate class and put the delegate's jar into the bootstrap loader?\n. Looks like I can use the @This annotation as long as I make sure byte-buddy is on the bootstrap classpath and that I don't load any byte-buddy classes elsewhere until I've updated the bootstrap classpath.\nWould it be possible in a future release to have a separate annotations module so that not all of byte-buddy needs to be included to use the annotations? If this is something you are open to, I could probably do a pull request.\n. I've got it working now with the type pool and with the @This annotation. I had only tried the type pool briefly yesterday, so I'm not sure what I was doing it wrong, but everything seems to be working great today.\nIf I can get more fine grained access check permissions working by interjecting custom setAccessible implementations I hope to write up a blog post about how it can be done using byte-buddy.\nThanks for your help.\n. For the security checks I think it can only be done through interjection. My plan is to replace to the setAccessible method to check the classloader of the object that setAccessible is being called on; if the classloade isr a custom sandboxed classloader that is also the same instance as the classloader of the caller, then it will completely replace the default logic to use a new custom permission instead of ReflectPermission(\"suppressAccessChecks\") whereas if the classloader is any other classloader or a different instance, then it will fallback to the standard implementation.\nUnless Advice allows conditionally not continuing to the original implementation, I think I need to replace the whole method.\n. MethodCall sounds like what I need. I'm not totally clear on how to use it. I tried transforming my SetAccessibleImplementation to use it like below, but I'm getting an error that it cannot see the private method. I have pushed this to my sample project as well.\n``` Java\nclass SetAccessibleImplementation {\nprivate static void setAccessible1(AccessibleObject ao, boolean flag){\n}\n}\n```\n``` Java\nString setAccessible0MethodName = \"setAccessible0\";\n    Class[] paramTypes = new Class[2];\n    paramTypes[0] = AccessibleObject.class;\n    paramTypes[1] = boolean.class;\n    Method setAccessible0Method = AccessibleObject.class.getDeclaredMethod(setAccessible0MethodName, paramTypes);\n// Previous code omitted\n.type(named(\"com.leacox.example.bytebuddy.instrument.java.lang.reflect.SetAccessibleImplementation\"))\n        .transform(new AgentBuilder.Transformer() {\n          @Override\n          public DynamicType.Builder<?> transform(\n              DynamicType.Builder<?> builder, TypeDescription typeDescription,\n              ClassLoader classLoader) {\n            return builder.method(named(\"setAccessible1\"))\n                .intercept(\n                    MethodCall.invoke(new MethodDescription.ForLoadedMethod(setAccessible0Method)).withAllArguments());\n          }\n        })\n``\n. Looking through a lot of the tests it looks likeMethodCallcan work for package private visibility but not fully private visibility. I also attempted to useFieldProxyandSuperCallbut both of those can't be used for re-transformations and it's basically guaranteed that theAccessibleObject` class will be loaded long before the transformation happens.\nThe override field on the AccessibleObject is package private, so in the meantime I can put my intercepting class in the java.lang.reflect package and directly set AccessibleObject.override. This isn't great though since the implementation of setAccessible0 may change in the future if a security bug is found in the JVM and it would be nice to get security fixes automatically by depending on that method. I realize that method could go away entirely or be renamed too, but at least then I'll some tests that will fail rather than an unknown missing security fix.\nHopefully I'm just missing something about how you are thinking I should use MethodCall because getting that to work does seem like the ideal solution.\n. Your assumption is correct; my interceptor implementation will throw a SecurityException if the security check fails. Chaining the calls as in your example does work. This didn't occur to me because I didn't realize that an exception would short-circuit the chaining; is this documented somewhere or can you point me to some lines of code where I can see this?\n. Got it. Thanks for all your help.\n. ",
    "wu-sheng": "I try to use lastest version 1.4.6 to fixed this issue.\nI get another exception, when the application uses log4j.(remove agent, everything is fine. )\nshell\nobjc[75496]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home/bin/java and /Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home/jre/lib/libinstrument.dylib. One of the two will be used. Which one is undefined.\nException in thread \"main\" java.lang.NoClassDefFoundError: sun/reflect/GeneratedMethodAccessor4\n    at sun.reflect.GeneratedMethodAccessor4.<clinit>(Unknown Source)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:408)\n    at java.lang.Class.newInstance(Class.java:438)\n    at sun.reflect.MethodAccessorGenerator$1.run(MethodAccessorGenerator.java:403)\n    at sun.reflect.MethodAccessorGenerator$1.run(MethodAccessorGenerator.java:394)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at sun.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:393)\n    at sun.reflect.MethodAccessorGenerator.generateMethod(MethodAccessorGenerator.java:75)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:53)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at org.apache.logging.log4j.status.StatusLogger$BoundedQueue.<clinit>(StatusLogger.java)\n    at org.apache.logging.log4j.status.StatusLogger.<init>(StatusLogger.java:75)\n    at org.apache.logging.log4j.status.StatusLogger.classInitializer$tFvp9PAT(StatusLogger.java:64)\n    at org.apache.logging.log4j.status.StatusLogger.<clinit>(StatusLogger.java)\n    at org.apache.logging.log4j.LogManager.classInitializer$2uwbj97q(LogManager.java:60)\n    at org.apache.logging.log4j.LogManager.<clinit>(LogManager.java)\n    at com.ai.cloud.skywalking.sample.util.DubboStart.classInitializer$oOb0838P(DubboStart.java:9)\n    at com.ai.cloud.skywalking.sample.util.DubboStart.<clinit>(DubboStart.java)\n    at java.lang.Class.forName0(Native Method)\n    at java.lang.Class.forName(Class.java:260)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:122)\nCaused by: java.lang.ClassNotFoundException: sun.reflect.GeneratedMethodAccessor4\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:372)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:360)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n    ... 25 more\n. I change my code like this.\n``` java\nnew AgentBuilder.Default().type(enhanceClassMatcher(pluginDefineCategory)).transform(new AgentBuilder.Transformer() {\n                public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader) {\n                    AbstractClassEnhancePluginDefine pluginDefine = pluginDefineCategory.findPluginDefine(typeDescription.getTypeName());\n                    return pluginDefine.define(typeDescription.getTypeName(), builder);\n                }\n            }).with(new AgentBuilder.Listener() {\n                @Override\n                public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module, DynamicType dynamicType) {\n            }\n\n            @Override\n            public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) {\n                logger.info(\"ignore to enhance class \" + typeDescription.getTypeName());\n            }\n\n            @Override\n            public void onError(String typeName, ClassLoader classLoader, JavaModule module, Throwable throwable) {\n                logger.error(\"Failed to enhance class \" + typeName, throwable);\n            }\n\n            @Override\n            public void onComplete(String typeName, ClassLoader classLoader, JavaModule module) {\n                logger.info(\"enhance class \" + typeName + \" complete.\");\n            }\n        }).installOn(instrumentation);\n\n```\nAnd I will test my project today, hope it will work as my wish.\n. What does active resolution mean?  I know 'Driver INSTANCE' need to be initialized after the class was initialized, but why TypeResolutionStrategy.ACTIVE can solve the problem? I can't fully understand the comments on 'TypeResolutionStrategy.ACTIVE' as following, it says initializers are executed before . initializers means class was initialized? I'm confused.\njava\n    /**\n     * A type resolution strategy that applies all {@link LoadedTypeInitializer} as a part of class loading using reflection. This implies that the initializers\n     * are executed <b>before</b> (as a first action of) a type initializer is executed.\n     */\n    enum Active implements TypeResolutionStrategy {\nI write this codes to intercept constructor or method. There are other ways to do this?\n. Thanks. I have understand the solution. My require is to intercept the Constructor, in order to get params. Is any other ways to do? \nIn my project, I can't know whether the target classes have a field of instance to itself, the only thing i can do is : add 'TypeResolutionStrategy.ACTIVE' to all target classes's builder.\nIs this the right thing to do? If yes, why this strategy is not default?\n. Ok, thanks. \n. How to add a static interceptor? I do not find the documents.\nI need to intercept constructor, instance method and static instance method In order to get method name and parameters.\nCan you give me a demonstration?  I can use static methods to intercept if necessary.\n. \ud83d\udc4d . Is there any demos for MethodCall.invoke(Constructor) or MethodCall.invoke(MethodDescription)?\nI only used method().intercept(), like this:\njava\nnewClassBuilder.method(matcher).intercept(MethodDelegation.to(classMethodInterceptor))\nMethodCall.anything is unfamiliar to me.. Unfortunate no :( ,  let's say like this:\nI have a class\njava\nClass A{\n     // 1st constructor\n     public A(int a){...}\n     // 2nd constructor\n     public A(String b){...}\n}\nI want to use different interceptors for 2 constructors, such as Class Interceptor1st for 1st constructor, Interceptor2nd for 2nd constructor.\nIs this clear enough?. Ohye, that is. thank you.. I inject my interceptor instance to target classloader, in order to make sure it will work.\nBut this is define for interceptor, I am not sure which is the right way.. This is the target class to intercept\n```java\n   public Jedis() {\n    super();\n  }\npublic Jedis(final String host) {\n    super(host);\n  }\npublic Jedis(final String host, final int port) {\n    super(host, port);\n  }\npublic Jedis(final String host, final int port, final int timeout) {\n    super(host, port, timeout);\n  }\npublic Jedis(final String host, final int port, final int connectionTimeout, final int soTimeout) {\n    super(host, port, connectionTimeout, soTimeout);\n  }\npublic Jedis(JedisShardInfo shardInfo) {\n    super(shardInfo);\n  }\npublic Jedis(URI uri) {\n    super(uri);\n  }\npublic Jedis(final URI uri, final int timeout) {\n    super(uri, timeout);\n  }\n``. Ohye, I like this solution.. Is any other way, if target a noexisted abstract class or interface?. What is.getTypes().asErasure()means?. Is any method like getType(), but get all parent abstract class, interface type,  maybe as a list?. BTW, @ascrutae. 1. Can you give me a quick start about retransform?\n1. What willdisableClassFormatChanges` disable? If I want to add a method interceptor? I see your doc said something about change class constructions. Can you give me a short list about what can be done when retransform.. I have a quick review about Stagemonitor. And find some very interested comments: https://github.com/stagemonitor/stagemonitor/blob/80793ac6c582944c9078b420138dda4d23517a69/stagemonitor-core/src/main/java/org/stagemonitor/core/instrument/AgentAttacher.java#L65-L66\nIs these comments correct? no need to add -javaagent? I glance at initInstrumentation method, it seems if I use a JDK rather than a JRE to run application, instrumentation can be done at any time.\njava\ninstrumentation = ByteBuddyAgent.install(\n    new ByteBuddyAgent.AttachmentProvider.Compound(\n        new EhCacheAttachmentProvider(),\n        ByteBuddyAgent.AttachmentProvider.DEFAULT));\nCan you explain these codes for me, about AttachmentProvider.Compound and ByteBuddyAgent.AttachmentProvider.DEFAULT. @raphw , I am interested in the same thing.\nIn my opinion, because of MyInterceptor.class used in BootstrapAgent.premain, at first, it's loaded in AppClassLoader; and then you inject it into the BootstrapClassLoader. \nSo there are two MyInterceptor.classs in two classloaders. And we want to keep it single instance, only exist in BootstrapClassLoader.\nOr, stead of that, dive into my final purpose. You give us a demo about, BootstrapClassLoader's MyInterceptor.class to call a class in AppClassLoader's scope, like clazzA.log(String).\nI can do that if I have the AppClassLoader instance ref, but because of two MyInterceptor.class, I can not obtain it, they are separated.. I think your API is better than the asm ^^. I prefer your mechanism rather than asm's. \nSo you have schedules to implement this, please, let me know. \nLooking forward.. It's just for my open source tracer project. It can wait, ha.. Can you give me a demo about TypeDescription.ForLoadedType? I have no idea how to use.. I am sure it is possible in theory. We can decompile the class file to the source code with line number, and these are line number in Exception. Also, I have seen using asm'svisitline(maybe this) in commercial product to get linenum, can not share it.\nI will explain why I need this.\nAs you known, I am APM product developer, I want to give serval snapshots to the thread, getting thread stacks by that. I want to match the stack element to the intercept point. In an intercept point, I known the class name and method signature, but in stack element, these is only method name and line number. By all these, still have a mismatch issue. This is background story. Hope you can help on this.. > Note that you need to explicitly install the Morph.Binder for the annotation to be available\nHow to install? I am hardly to find any document about how to useing @Morph. Just find a description before.\n\nsupplying the array to @Morph would work.\n\nHow to supply?\n@Morph annotation is also for a Callable argument? like @SuperCall Callable<?> zuper?. Here is my interceptor:\njava\n    @RuntimeType\n    public Object intercept(@This Object obj, @AllArguments Object[] allArguments, @Origin Method method,\n                            @Morph(defaultMethod = true) Callable<?> zuper\n                            ) throws Throwable {\n        System.out.println(\"entering intercept\");\n        allArguments[0] =  allArguments[0] + \"(be intercepted)\";\n        return zuper.call();\n    }. It doesn't work. This method doesn't invoke.. This works when facing methods. But today I run a test for change  arguments of constructor, it failed. How should I interceptor constructor and change the arguments\n\n\nThe Builder\njava\nbuilder = builder.constructor(ElementMatchers.<MethodDescription>any()).intercept(\n                MethodDelegation.withDefaultConfiguration().withBinders(\n                        Morph.Binder.install(Morpher.class),\n                        FieldProxy.Binder.install(FieldGetter.class, FieldSetter.class)\n                )\n                        .to(new PrintClassConstructorInterceptor()));\n\n\nThe PrintClassConstructorInterceptor\njava\npublic class PrintClassConstructorInterceptor {\n    @RuntimeType\n    public void intercept(@This Object obj,\n                          @FieldProxy(\"dynamicField\") FieldSetter accessor,\n                          @AllArguments Object[] allArguments,\n                          @Morph Morpher morpher) {\n        accessor.setValue(\"new field with value\");\n        morpher.invoke(allArguments);\n    }\n}\n\n\nThe Morph\njava\npublic interface Morpher {\n    Object invoke(Object[] args);\n}\n. Is this because super() must invoke first? Is there any chances to do such things?\n\n\nMy error is:\n```\nException in thread \"main\" java.lang.VerifyError: Bad type on operand stack\nException Details:\n  Location:\n    com/huawei/test/simple/print/PrintClass.()V @9: invokespecial\n  Reason:\n    Type uninitializedThis (current frame, stack[4]) is not assignable to 'com/huawei/test/simple/print/PrintClass'\n  Current Frame:\n    bci: @9\n    flags: { flagThisUninit }\n    locals: { uninitializedThis }\n    stack: { 'com/huawei/devcloud/tools/disgnosis/plugins/test/printclass/PrintClassConstructorInterceptor', uninitializedThis, uninitialized 4, uninitialized 4, uninitializedThis }\n  Bytecode:\n    0x0000000: b200 2a2a bb00 2c59 2ab7 002f 03bd 0004\n    0x0000010: bb00 3159 2ab7 0032 b600 38b1          \nat com.huawei.test.simple.print.Main.main(Main.java:8)\n\n``. I usedSuperMethodCall.INSTANCE` before, but in this scenario, I want to change the arguments rather than just access it.\nHow can I do this?. How to use Advice in byte-buddy? I didn't find the documents in http://bytebuddy.net/#/tutorial. Can you show me some codes or  a gist to do so?. I just found the advice on method, not constructor. And it didn't change the arguments.\nhttps://github.com/raphw/byte-buddy/blob/b521c38ddfb9b418f7cc1b691c707403569f7f23/byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java. I wrote codes like this:\njava\n        builder.visit(Advice.to(AdviceInterceptor.class).on(ElementMatchers.<MethodDescription>any()).readerFlags(ClassReader.SKIP_DEBUG));\nAnd trigger a compile error, jdk.internal.org.objectweb.asm not found in maven, why?\n[ERROR] /D:/IdeaProjects/AppDiagnosis/app-diagnosis-agent/src/main/java/com/huawei/devcloud/tools/disgnosis/plugins/test/printclass/PrintClassWeaver.java:[4,38] \u7a0b\u5e8f\u5305jdk.internal.org.objectweb.asm\u4e0d\u5b58\u5728\n[ERROR] /D:/IdeaProjects/AppDiagnosis/app-diagnosis-agent/src/main/java/com/huawei/devcloud/tools/disgnosis/plugins/test/printclass/PrintClassWeaver.java:[22,115] \u627e\u4e0d\u5230\u7b26\u53f7. And the annotation is not part of agent codes. How should I declear it? You teach me to implement an ElementMatcher for similar scenario in parameter type:\n```java\npublic class ArgumentTypeNameMatch implements ElementMatcher {\n    @Override\n    public boolean matches(MethodDescription target) {\n        ParameterList<?> parameters = target.getParameters();\n        if (parameters.size() > index) {\n            return parameters.get(index).getType().asErasure().getName().equals(argumentTypeName);\n        }\n    return false;\n}\n\n. Found a way out. Can you confirm is this the right way? @raphwjava\n        /\n         * alter class source code.\n\n         * new class need:\n         * 1.Add field, name {@link #CONTEXT_ATTR_NAME}.\n         * 2.Add a field accessor for this field.\n         \n         */\n        newClassBuilder = newClassBuilder.defineField(CONTEXT_ATTR_NAME, Object.class, ACC_PRIVATE)\n            .implement(EnhancedInstance.class)\n            .intercept(FieldAccessor.ofField(CONTEXT_ATTR_NAME));\n```. Here is I did for annotation match: \nhttps://github.com/wu-sheng/sky-walking/blob/feature/high-performance-agent/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/AnnotationMatch.java. I want to finish the interface match like this:\nhttps://github.com/wu-sheng/sky-walking/blob/feature/high-performance-agent/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/HierarchyMatch.java\nNo implementation yet, because can't build TypeDescription, :(. @raphw Great to have this. I will test this later.. Do I have a way to match a class when the class has a method with certain annotation?. How powerful..... How name suffix match? example?. Is name suffix or regax match popular?. Hi @raphw , this issue also comes from Skywalking APM team. Although the xmemcached team merged pr, but still many released versions have the same version. So, I sincerely hope you can provide a solution or patch to solve this. Thanks.. This is from google xmemcached client library team. IMO, even you.write such codes, compiler should remove that for you. But actually it did't. strange, right?. Hi @raphw , even I think this is not the right coding way. But I run a test, seem it is legal to do so.\nHere is my sample code:\n```\n    @RequestMapping(\"/serviceA/rest\")\n    @ResponseBody\n    String home() throws Exception, Exception {\n        logger.info(\"Business service log in SpringController.home().\");\n    FrontSiteBusinessLogic dom = new FrontSiteBusinessLogic();\n    return dom.callByOKHTTP3().toString();\n}\n\n}\n```\nAnd I run javap -v for this class, here is a result:\n```\n  java.lang.String home() throws java.lang.Exception, java.lang.Exception;\n    Code:\n       0: getstatic     #2                  // Field logger:Lorg/apache/log4j/Logger;\n       3: ldc           #3                  // String Business service log in SpringController.home().\n       5: invokevirtual #4                  // Method org/apache/log4j/Logger.info:(Ljava/lang/Object;)V\n       8: new           #5                  // class com/huawei/devcloud/demo/frontsite/FrontSiteBusinessLogic\n      11: dup\n      12: invokespecial #6                  // Method com/huawei/devcloud/demo/frontsite/FrontSiteBusinessLogic.\"\":()V\n      15: astore_1\n      16: aload_1\n      17: invokevirtual #7                  // Method com/xxx/yyyyy/demo/frontsite/FrontSiteBusinessLogic.callByOKHTTP3:()Ljava/lang/String;\n      20: invokevirtual #8                  // Method java/lang/String.toString:()Ljava/lang/String;\n      23: areturn\n```\nYou can see, compiler allowed duplicate exceptions in a singe method. So, IMHO, this should a bug. Can you fix this for us? Thanks.. If the parent class is a common one, like this, it works.\njava\npublic class TestService implements Service {\n}. pom\n        <dependency>\n            <groupId>net.bytebuddy</groupId>\n            <artifactId>byte-buddy</artifactId>\n            <version>1.7.6</version>\n        </dependency>\nAlso tested in 1.7.8, the last release, still fail.. thanks. i forget to run javap.. I am not sure how.to wrap the matcher to suppress the exception.Can you give me something more explicit or some examples?. I found ElementMatchers.failSafe(...), but how can I log the exception? Can't find the callback.. I think I get the point. . Implement my own FailSafeMatcher would help.. Thanks.. FYI @ascrutae. Do you have an example for a quick run? I want to prepare this feature. Never use advice and retransform before.\nNeed more helps.\ud83d\ude03. This class is loaded by bootstrap class loader. See Raphew' s example here: https://gist.github.com/raphw/34c0e2fffe2ee7b4f02f. Sure. Thanks anyway.. ",
    "liuchang0403": "wow, when can asm to be released ? it is so slowly. ha ha ha. yeah, i have see it, it have not update to maven repository. does asm can do this ?. i think it is not nesseray. byte buddy is a easy lib compare to ASM, i think it is enough now.. ",
    "tmurakami": "\nAre you using the latest version?\n\nYes. I'm using the latest android sdk.\nMy environment:\n- Ubuntu 16.04\n- OpenJdk 1.8.0_91\n- Android Studio 2.2 RC\n- Android SDK Tools 25.2.2\n\nIs it an empty array for A1[] value?\n\nYes. The length of this array is zero.\n\n. ByteBuddyAndroid-ClassCastException.zip\n. > This is required by the JLS but it seems like it returns true on your system.\nYes. A1[].class.isAnnotation() == true on Android...\nWill you support Android?\n\n. > I will try to make a release next week.\nThank you!\n\nPlease report this as a bug to Android, this is a really bad bug in their software.\n\nI have just reported.\nhttps://code.google.com/p/android/issues/detail?id=222104\n. > Did you encounter this problem when using Mockito on Android by any chance?\nI have not used mockito-android yet.\nHowever, I have encountered this when creating my DexMockito library that is an alternative to dexmaker-mockito.\n. @benmarten Is this what you want to create proxy?\nhttps://android.googlesource.com/platform/frameworks/base/+/master/core/java/com/android/internal/widget/ActionBarView.java#149\nIf so, I think that the class loader for originalOnClickListener is different from the argument given to load().\nIf the two class loaders are different, non-public proxies cannot be created.\n. ",
    "odbuser2": "Exactly right.  Also, thank you for pointing out the .with call.  I wasn't aware of that.\n. ",
    "ZachHerridge": "Has there been any progress on this feature? This is the main thing stopping us from upgrading from JavaAssist. . ",
    "yuwenhuisama": "Thank you, it's healpful for me to write the JIT on Andriod for my DSL!\n. ",
    "TimvdLippe": "Yes that could be true, since I am using the openjdk9 version available on the ppa: https://launchpad.net/~openjdk-r/+archive/ubuntu/ppa\nDo you maybe know how I can upgrade to a new version?\n. ",
    "originx": "Thank you for the fast reply I will look into it.\nI am doing the migration on a fork of JGiven library:\nhttps://github.com/originx/JGiven\nYou can reproduce the issue if you run ./gradlew :jgiven-core:test\nAlthough I am unsure it is run in a different class loader I have to check it.\n. Really nice, never saw a library dev so responsive. Kudos and thank you for quick assistance, works fine now.\n. You are right, closely inspecting it some strange gradle issue was happening, adding the dx on the compile path solved the issue.\nAlthough I got a different (unrelated) error now:\nadding empty constructors does not help.\njava.lang.RuntimeException: Error while trying to create an instance of class class com.tngtech.jgiven.android.example.ExampleInstrumentedTest$GivenSomeState\nat com.tngtech.jgiven.integration.android.AndroidScenarioExecutor.createStageClass(AndroidScenarioExecutor.java:46)\nat com.tngtech.jgiven.impl.StandaloneScenarioExecutor.addStage(StandaloneScenarioExecutor.java:235)\nat com.tngtech.jgiven.impl.Scenario.initialize(Scenario.java:98)\nat com.tngtech.jgiven.impl.ScenarioBase.performInitialization(ScenarioBase.java:91)\nat com.tngtech.jgiven.impl.ScenarioBase.startScenario(ScenarioBase.java:74)\nat com.tngtech.jgiven.junit.ScenarioExecutionRule.starting(ScenarioExecutionRule.java:124)\nat com.tngtech.jgiven.junit.ScenarioExecutionRule$1.evaluate(ScenarioExecutionRule.java:86)\nat android.support.test.internal.statement.UiThreadStatement.evaluate(UiThreadStatement.java:55)\nat android.support.test.internal.statement.UiThreadStatement.evaluate(UiThreadStatement.java:55)\nat android.support.test.rule.ActivityTestRule$ActivityStatement.evaluate(ActivityTestRule.java:270)\nat org.junit.rules.RunRules.evaluate(RunRules.java:20)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)\nat org.junit.rules.RunRules.evaluate(RunRules.java:20)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runners.Suite.runChild(Suite.java:128)\nat org.junit.runners.Suite.runChild(Suite.java:27)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:115)\nat android.support.test.internal.runner.TestExecutor.execute(TestExecutor.java:59)\nat android.support.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:262)\nat android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1584)\nCaused by: java.lang.InstantiationException: can't instantiate class com.tngtech.jgiven.android.example.ExampleInstrumentedTest$GivenSomeState$ByteBuddy$VF8nBNSh; no empty constructor\nat java.lang.Class.newInstanceImpl(Native Method)\nat java.lang.Class.newInstance(Class.java:1319)\nat com.tngtech.jgiven.integration.android.AndroidScenarioExecutor.createStageClass(AndroidScenarioExecutor.java:43)\nThis is my instance creation:\nmethodInterceptor.enableMethodHandling(true);\n            T result = new ByteBuddy()\n                    .subclass(stepsClass, ConstructorStrategy.Default.IMITATE_SUPER_CLASS)\n                    .method(any())\n                    .intercept(MethodDelegation.to(methodInterceptor))\n                    .make()\n                    .load(context.getClassLoader(),\n                            new  AndroidClassLoadingStrategy(ContextCompat.getCodeCacheDir(context)))\n                    .getLoaded()\n                    .newInstance();\nAnd this is the inner class bytebuddy is trying to initialize:\n```\npublic class GivenSomeState extends Stage {\n    public GivenSomeState some_state() {\n        return self();\n    }\n}\n\n```\nthanks for your time\n. ",
    "devcsrj": "\n..has started ignoring java.*... adding ignore(none()) to your above builder.\n\nThat did the trick! Above snippet works now with the latest (1.4.24).\n\ndisableClassFormatChanges()... is(System.class)\n\nMan, you're a life saver.\n\naccidentally instrumenting types from the bootstrap path\n\nI think I read somewhere that modifications to core classes (-Xbootclasspath) Oracle's License agreement. Does modification via instrumentation, like the one above, count?\n. ",
    "bitbrain": "\ud83d\ude2e \n. ",
    "csoroiu": "@raphw I know you shouldn't mess up with lambda's. I only take the generated bytecode to detect the signature of the method reference. I used it in some custom hamcrest based matcher for display purposes only and it is targeted only for unit tests.\nThanks\n. Also, the NoClassDefFoundError is more annoying than VerifyError because the class is already broken and one cannot recover from the issue.\n. Can you provide the openjdk bug url? I want to follow up on that.\n. Looks like is similar if not same as JDK-8145964 - NoClassDefFound error in transforming lambdas referred by stackoverflow question: Transforming lambdas in Java 8.\nSo, most likely, I need to wait for java 9 and #164 to get it working properly.\nThank you for looking into this issue!\n. ",
    "dzharikhin": "Wow!!!Cool!! \nIt seems it works!!! Thanks!!!\n. ",
    "horaciojcfilho": "@raphw Thanks a lot for the fast answer, but I was not able to catch any info regarding AOT compilation abandonment for future versions, can you send some link about that? \nThanks a lot :D\n. ",
    "peihe": "Thanks Rafael for the detailed response and suggestions.\nThat should work for us.\n(closing this PR). ",
    "benmarten": "Ok, finally got a sample project for you: https://github.com/benmarten/RecyclerViewAdapterTest/\nAppreciate your help! Thanks. Ok thanks for you help, I will see if i can write tests for this without it or open an issue with roboelectric. . Yep, proxyAdapter.newInstance() solved that problem! Thanks for the hint ;)\nRunning into this error now:\nE/AndroidRuntime: FATAL EXCEPTION: main\n                  Process: com.example.sashohadzhiev.recyclevievtest, PID: 7238\n                  java.lang.AbstractMethodError: abstract method \"int android.support.v7.widget.RecyclerView$Adapter.getItemCount()\"\n                      at android.support.v7.widget.RecyclerView.dispatchLayoutStep1(RecyclerView.java:3170)\n                      at android.support.v7.widget.RecyclerView.dispatchLayout(RecyclerView.java:3067)\n                      at android.support.v7.widget.RecyclerView.onLayout(RecyclerView.java:3518)\n                      at android.view.View.layout(View.java:17637)\n                      at android.view.ViewGroup.layout(ViewGroup.java:5575)\n                      at android.widget.RelativeLayout.onLayout(RelativeLayout.java:1079)\n                      at android.view.View.layout(View.java:17637)\n                      at android.view.ViewGroup.layout(ViewGroup.java:5575)\n                      at android.widget.FrameLayout.layoutChildren(FrameLayout.java:323)\n                      at android.widget.FrameLayout.onLayout(FrameLayout.java:261)\n                      at android.view.View.layout(View.java:17637)\n                      at android.view.ViewGroup.layout(ViewGroup.java:5575)\n                      at android.support.v7.widget.ActionBarOverlayLayout.onLayout(ActionBarOverlayLayout.java:435)\n                      at android.view.View.layout(View.java:17637)\n                      at android.view.ViewGroup.layout(ViewGroup.java:5575)\n                      at android.widget.FrameLayout.layoutChildren(FrameLayout.java:323)\n                      at android.widget.FrameLayout.onLayout(FrameLayout.java:261)\n                      at android.view.View.layout(View.java:17637)\n                      at android.view.ViewGroup.layout(ViewGroup.java:5575)\n                      at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1741)\n                      at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1585)\n                      at android.widget.LinearLayout.onLayout(LinearLayout.java:1494)\n                      at android.view.View.layout(View.java:17637)\n                      at android.view.ViewGroup.layout(ViewGroup.java:5575)\n                      at android.widget.FrameLayout.layoutChildren(FrameLayout.java:323)\n                      at android.widget.FrameLayout.onLayout(FrameLayout.java:261)\n                      at com.android.internal.policy.DecorView.onLayout(DecorView.java:726)\n                      at android.view.View.layout(View.java:17637)\n                      at android.view.ViewGroup.layout(ViewGroup.java:5575)\n                      at android.view.ViewRootImpl.performLayout(ViewRootImpl.java:2346)\n                      at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2068)\n                      at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1254)\n                      at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:6337)\n                      at android.view.Choreographer$CallbackRecord.run(Choreographer.java:874)\n                      at android.view.Choreographer.doCallbacks(Choreographer.java:686)\n                      at android.view.Choreographer.doFrame(Choreographer.java:621)\n                      at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:860)\n                      at android.os.Handler.handleCallback(Handler.java:751)\n                      at android.os.Handler.dispatchMessage(Handler.java:95)\n                      at android.os.Looper.loop(Looper.java:154)\n                      at android.app.ActivityThread.main(ActivityThread.java:6119)\n                      at java.lang.reflect.Method.invoke(Native Method)\n                      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886)\n                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776)\n\nAny ideas?\nIt appears right after I set the proxyAdapter:\nRecyclerView.Adapter proxyAdapter = null;\ntry {\n  proxyAdapter = (RecyclerView.Adapter) proxyAdapterClass.newInstance();\n} catch (InstantiationException e) {\n  Util.handleException(e);\n} catch (IllegalAccessException e) {\n  Util.handleException(e);\n}\n((RecyclerView)recyclerView).setAdapter(proxyAdapter);\n\nSeems its not implementing the abstract methods, do you know how to fix this?. Right, I got this error sorted out too, by giving it a concrete implementation of that abstract class.\nNow I'm having one last issue, though:\n    .subclass(LeanplumRecyclerViewAdapter.class)\n    .method(ElementMatchers.named(\"onBindViewHolder\"))\n    .intercept(MethodDelegation.to(interceptingAdapter))\n\nshould only intercept the onBindViewHolder method, but its also intercepting the other methods of the LeanplumRecyclerViewAdapter.class, e.g. getItemCount\nLeanplumRecyclerViewAdapter  is simply extending from RecyclerView.Adapter and implementing its methods... any ideas?\nAny ideas?. Just a quick feedback. Got this working now. Pretty much like in this example project: https://github.com/benmarten/RecyclerViewAdapterTest/. I think I'm running into a similar issue:\njava.lang.IllegalAccessError: Class com.leanplum.testproj.MessagesListActivity$1myAdapter extended by class com.leanplum.testproj.MessagesListActivity$1myAdapter$ByteBuddy$LXZEB1pL is inaccessible (declaration of 'com.leanplum.testproj.MessagesListActivity$1myAdapter$ByteBuddy$LXZEB1pL' appears in /data/data/com.leanplum.testproj/app_leanplumClassDir/odonpM2g.jar)\nIs this related, hence fixed on master?\nUPDATE: Moving the Adapter into a separate class fixes it... How can I make it work with an anonymous inner class?. Hm, I'm running into this issue now again, with 1.6.2 and 1.6.9:\nE/[ERROR] java.lang.IllegalAccessError: Class com.android.internal.widget.ActionBarView$2 extended by class com.android.internal.widget.ActionBarView$2$ByteBuddy$VrLPYyDu is inaccessible (declaration of 'com.android.internal.widget.ActionBarView$2$ByteBuddy$VrLPYyDu' appears in /data/user/0/com.leanplum.testproj/app_leanplumClassDir/vtMqN5RI.jar)\n  LeanplumOnClickListenerInterceptor interceptor = new LeanplumOnClickListenerInterceptor(\n      originalOnClickListener);\n  Class<?> proxyAdapterClass = new ByteBuddy(ClassFileVersion.JAVA_V6)\n      .subclass(originalOnClickListener.getClass())\n      .method(named(\"onClick\"))\n      .intercept(MethodDelegation.to(interceptor))\n      .make()\n      .load(activity.getClass().getClassLoader(), classLoadingStrategy)\n      .getLoaded();\n  onClickListener = (View.OnClickListener) UnsafeLoader\n      .allocateIdenticalInstance(proxyAdapterClass, originalOnClickListener);\n\nThe error is thrown at .load any idea whats wrong?\nEdit: I'm using the injection strategy, using wrapping strategy yields same result.... ",
    "bsideup": "@raphw thanks! Now I understand.... more or less :D \nHowever, Is it possible to use ByteBuddy's sexy \"no ByteBuddy-related classes in your file\" approach? \nI don't really like the AOP style :). @raphw FYI example with @Advice.Argument(value = 3, typing = Assigner.Typing.DYNAMIC) doesn't work. Tried the following:\n@Advice.OnMethodEnter\n    public static void doHandle(@Advice.Argument(value = 3, typing = Assigner.Typing.DYNAMIC) HttpServletResponse response) {\n        System.out.println(\"!!!!!!!!!!!\");\n        System.out.println(\"!!!!!!!!!!!\");\n        response.setHeader(\"X-My-Super-Header\", \"header value\");\n    }\nbut no instrumentation is performed.\nIs it possible to enable some debug logging to understand what's happening?. @raphw thanks! Now I see that it fails when I use @Advice.Argument(value = 3, typing = Assigner.Typing.DYNAMIC) with:\njava.lang.NoClassDefFoundError: javax/servlet/http/HttpServletResponse\nat java.lang.Class.getDeclaredMethods0(Native Method)\nat java.lang.Class.privateGetDeclaredMethods(Class.java:2701)\nat java.lang.Class.getDeclaredMethods(Class.java:1975)\nat com.exmaple.net.bytebuddy.description.method.MethodList$ForLoadedMethods.<init>\nat com.exmaple.net.bytebuddy.description.type.TypeDescription$ForLoadedType.getDeclaredMethods(TypeDescription.java:7824)\nat com.exmaple.net.bytebuddy.asm.Advice.to(Advice.java:302)\nat com.exmaple.net.bytebuddy.asm.Advice.to(Advice.java:289)\nat com.exmaple.net.bytebuddy.asm.Advice.to(Advice.java:266)\nat com.exmaple.net.bytebuddy.asm.Advice.to(Advice.java:255)\nat com.example.superagent.Agent$1.transform(Agent.java:39)\nLooks like the same issue.. Tried your example (had to change it a bit because it wasn't compiling, I guess you're using some not-yet-released code), but got the same issue with NoClassDefFoundError.\nI know how it sounds like, but..... I guess I'll keep Javassist for my simple example app, at least for now :D\nIt's way too complex, I like the ideas of ByteBuddy, but I already got lost, sorry :(. @raphw I'll take a look, thanks! . @raphw wow, great, thanks!I will check it :). yeah, already did, thanks to http://jitpack.io :). @raphw much better now:\nhttps://github.com/bsideup/javaagent-boilerplate/commit/8f05d4d9ef8428a10c1afce9495da21b9206bad0?diff=unified\nThanks!. ",
    "shelajev": "@raphw can you please edit the example code you gave, I think that didn't compile indeed. The differences are minor, but for the sake of completeness: \nbuilder = builder.transform((builder, typeDescription, classLoader) -> {\n  ClassFileLocator locator = new ClassFileLocator.Compound(\n                       ClassFileLocator.ForClassLoader.of(classLoader),\n                       ClassFileLocator.ForClassLoader.of(ByteBuddy.class.getClassLoader())\n                     );\n                     Advice advice = Advice.to(\n                     TypePool.Default.of(locator).describe(\"pkg.JettyHandlerAdvice\").resolve(),\n                       locator\n                     );\n  return builder.method(named(\"doHandle\")).intercept(advice);\n});. ",
    "mofleury": "Hello,\nSorry for digging up this old issue, but I stumbled upon it while trying to apply instrumentation on lambdas. I am not sure if I have the same error, but I also have a ClassNotFoundException.\nI noticed that the JDK bug seems to have been fixed in 2016, does that mean that lambda instrumentationis supposed to work with recent versions of Java 8?\nThanks :). Ok, too bad.\nThank you for the quick answer! I suppose I'll have to work around lambda instrumentation for my use case then.\nKeep up the good work!. ",
    "Jezza": "Could this include setting fields from MethodCalls?. As a side-note: I also can't work out how to set a field from a MethodCall.. Yeah, that's exactly how I worked around it.\n```\npublic static final class Serialiser {\n    public static void write(BaseInterface base, ObjectOutput out) throws IOException {\n        out.writeUTF(base.id());\n    }\npublic static void read(Setter setter, ObjectInput in) throws IOException, ClassNotFoundException {\n    setter.baseSet(assertRawBase(in.readUTF()));\n}\n\n}\n```\nThe only problem with that is the class's footprint is bigger than it would otherwise be.\nIt adds about 20 bytes, which, granted, isn't much, but I also wanted to avoid it given an option, hence the question.. \nThat's how I write the class, but ideally, I would want to generate a class that would be as if I had written the facade myself. (eg, don't need to delegate it off to another class)\n. Advice works nicely, so I've switched to it.\nThanks!\nWould still be nice if I had a bit more control over what the methods did.\n If I have time, I might even look into it myself, and submit a PR. :). Ok, so after some work, I've basically managed to work out that it's the Advice that's failing the check.\nI converted the field type to the service interface, as that does make sense.\nBut now, obviously, the advice doesn't work, as it's expecting more exact types.\nIs there a way around that?. Weirdly, even though the service interface extends RepoModule, ByteBuddy still complains that the types can't be used together.. Cannot assign interface de.bps.onyx.repo.interfaces.RepoModule to private transient de.bps.onyx.repo.services.LicenseModuleService de.bps.proxy.LicenseModuleServiceFacade$$roiG8ws2.root\nLicenseModuleService implements RepoModule.. Oh, wait, it's the other way around?\nit's trying to assign the RepoModule to the field...\nBut where?\nI commented out the internal code, just so it removes all of that stuff.\nAh, it definitely looks like it's trying to align the field type with the parameter type, as I told it to.\nThat makes sense.\nAnd it's failing.. So, after mucking around with this for an hour or so, I can safely say, the exception that was thrown makes sense.\nJust because I have RepoModule, it doesn't mean I have a LicenseModuleService.\nI ended up solving it doing a shitty reflection hack with a super class, but I think a better solution would be dynamic advice.\nOr something similar to it.\nI have the type of field at the time of construction, but I can't give the advice that information.\nIf I could do something like this, but instead of T, I could declare a placeholder that could be swapped out by ByteBuddy:\n\n. Hm, I don't think I quite understand how to get that working.\nI tried:\n\nBut that doesn't work.\nSo from what I could work out, I need to bind the first parameter's type to the type of the service AND I need to also bind it to the field.\nI just realised that using the FieldAccessor is incorrect.\nI don't know how to refer to the field that is inside of this class.. Using Assigner.Typing.DYNAMIC seems to have done the trick.\nThanks for the help.. ",
    "ascrutae": "Thanks for your advise.  I set an initial value using  the defineField API to set the field. but  the type of field is complex type. but I cannot found any API to set the value of complex type.  could you show some example?. oops, My byte buddy version: 1.5.7. Thanks for you response. it works. Thanks for your response. \nThere is NoSuchMethodException exception on my console when I interceptor the Controller class has one constructor with parameters.   The exception message show that spring framework cannot found the default constructor. I debug the spring framework code and found that the the return for the method org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors(Class, String)  contains three cases:\ncase 1. Constructors with annotation autowired type\ncase 2. The bean class only has one constructor with parameters\ncase 3. The bean has constructor without parameters\nbut the code intercepted constructor cannot in case 2, because the agent generate an new constructor.\nHere is the spring code snippet : go~\nSo I want to that  byte-buddy provide an way to not generate an new constructor. \nThanks \nXin\n. oh. I see.\nI found that the spring framework has consider a non-synthetic constructor for usage in the latest version when I read the spring framework source code. but it doesn't works in the current release  version.\nThanks for you response.\nXin. @xiaoxinba  you can add maven shade plugin like this: go ~. ",
    "michele-mancioppi": "For completenss, I have am trying to applying the agent code above to this trivial test app.\n\npackage test.app;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ThreadMain {\n\n    public static void main(String ... args) throws Exception {\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        final Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(500l);\n                } catch (final Exception e) {\n                    System.err.println(e);\n                } finally {\n                    latch.countDown();\n                }\n            }\n        });\n\n        thread.setName(\"TestThread\");\n\n        thread.start();\n        latch.await();\n        System.out.println(\"Job done!\");\n    }\n\n}\n\nThe expected output is:\n\nInstrumentation installed\nThread 'TestThread' started\nJob done!\n\nHowever, only   is printed to System.out.. For the next time someone tries and fails to instrument something like java.lang.Thread:\n\npackage test.agent;\n\nimport net.bytebuddy.agent.builder.AgentBuilder;\nimport net.bytebuddy.asm.Advice;\nimport net.bytebuddy.description.type.TypeDescription;\nimport net.bytebuddy.dynamic.DynamicType;\n\nimport java.io.File;\nimport java.lang.instrument.Instrumentation;\nimport java.nio.file.Files;\n\nimport static net.bytebuddy.matcher.ElementMatchers.is;\nimport static net.bytebuddy.matcher.ElementMatchers.named;\nimport static net.bytebuddy.matcher.ElementMatchers.noneOf;\n\npublic class Main {\n\n    public static void premain(final String args, final Instrumentation instrumentation) {\n        final File tempFolder;\n\n        try {\n            tempFolder= Files.createTempDirectory(\"agent-bootstrap\").toFile();\n        } catch (Exception e) {\n            System.err.println(\"Cannot create temp folder for bootstrap class instrumentation\");\n            e.printStackTrace(System.err);\n            return;\n        }\n\n        new AgentBuilder.Default() //\n            .disableClassFormatChanges() //\n            .ignore(noneOf(Thread.class)) //\n            .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE) //\n            .with(AgentBuilder.RedefinitionStrategy.REDEFINITION) //\n            .with(AgentBuilder.TypeStrategy.Default.REDEFINE) //\n            .enableBootstrapInjection(instrumentation, tempFolder) //\n            .type(is(Thread.class)) //\n            .transform(new AgentBuilder.Transformer() {\n                @Override\n                public DynamicType.Builder transform(DynamicType.Builder builder, TypeDescription typeDescription, ClassLoader classLoader) {\n                    return builder.visit(Advice.to(ThreadStartInterceptor.class).on(named(\"start\")));\n                }\n            }) //\n            .installOn(instrumentation);\n    }\n\n    public static void agentmain(String args, Instrumentation inst) {\n        premain(args, inst);\n    }\n\n    public static class ThreadStartInterceptor {\n\n        @Advice.OnMethodEnter\n        static void intercept() {\n            System.out.println(\"Thread '\" + Thread.currentThread().getName() + \"' started\");\n        }\n    }\n\n}\n\nAnd, by the way, the java.lang.Thread name that will be printed out is the one where start is invoked, not where the java.lang.Runnable#run() will be executed ;-). ",
    "Godin": "You're welcome!\nI added ByteBuddy to a page Projects that use JaCoCo \ud83d\ude09 . Two stars (**) not a mistake here, but a workaround for inconsistency between specification of includes/excludes for instrumentation and for report generation - https://github.com/jacoco/jacoco/issues/34 Maybe be better to add an explicit comment in code here.. ",
    "cemelo": "Thank you for this awesome library.. ",
    "t-tsutsumi": "I was able to get an artifact from Maven Central Repository.\nThank you for your response.. ",
    "wltjr": "Sorry @orange-buffalo I just saw this after my request for removal in #397 which it is now removed... I did not realize you had recently requested it be added. I hope it is acceptable it is now gone. Lombok is a very difficult package to package, thus my gripes.. @orange-buffalo I know about it being only needed at build/compile. On Gentoo things are built from source, even Java, as silly as it may sound. I am doing abnormal things. I tend to have to explain such often, no worries. I also ran into the lombok issues with latest Java. I am glad you on same page there. Along with keeping byte-buddy code clean. I just noticed this after lombok removal and just wanted to make sure it was ok. Thanks!. Sweet glad it is a possibility at least and you are receptive to such someday. I would like to see if Lombok could reduce its deps in pieces. Though they haven't been to receptive to some feedback. I believe it needs some eclipse stuff for like UI integration. Not sure what all eclipse libraries it needs for actual runtime usage. Like if you develop server side app using Lombok, do you need all 70+ eclipse deps.\nI haven't got a chance to mess with byte-buddy under Java 9 yet due to the lombok's own issue with Java 9. Which was not an issue at first. I have some 900+ packages building fine from source. I did have some issues with Netbeans but newer release addressed those. Now Lombok is blocking my progress on Netbeans as I need it for byte-buddy. Netbeans needs byte-buddy for Java editors deps etc. Originally I had lombok and byte-buddy for Spring 4.x. Though never finished packaging all of that, and need to move onto Spring 5. The new Kotlin deps, and Kotlin requiring bootstrap. Has me stalled on Spring 5. I cannot stand Java projects that bootstrap, and that Kotlin is new, is just bad.\nI haven't got a chance to play with 10 much but I have it. I built a few things with it, and did not see any issues. Just reverted back as I am not done with 9. Not sure what issues you have seen with 10. The biggest issue I see is removal of javah. Native classes now requiring annotations if not using native classes. I need to see about some stuff for jna there. Short of class removal or other changes. Not sure how many issues I will run into with 10. Once I get past the last remaining 9 issues I will be onto 10. I am eager to checkout 10, so I am not behind as I was on Java 9. Though seems most the Java world was behind for 9. Seems like 1.5 times again.\nI understand the legacy compliance. That is also an issue for Lombok and other stuff. I have been removing most all < Java 9 support from Lombok. I am not sure how things will work out going forward if there are such changes. I am essentially building and focused on a forward looking environment, presently 9+. The legacy java stuff kills me. While I have my own clients still using older code I cannot seem to motivate them to update. If it isn't broke... It costs money to update, and its hard to justify that on internal java changes vs application. Still in FOSS I rather see legacy stuff shed sooner than later.\nI am not sure how things like Lombok and others will be able to support older, current, and newer JDK versions. Seems to have worked out in the past, but not sure about going forward. Seems like will have to have different code bases and build based on that, like in this example Rather than runtime detection and switching there, like Lombok does. I guess I may have some of those same issues with byte-buddy. Hard to say, need to get Lombok out of the way so I can see what issues byte-buddy may have under 9 and 10.\nThe lombok Java 9 blocker is rather odd. A single method I cannot for the life of me override or add. Not sure why. I believe that is the last error to getting it to build... I spent a couple hours on it and got no where thus opened issue, and also this one.\n. @novaterata interesting, so your saying in deployment one does not need lombok.jar? My main concern is build time, as its build time dependencies for other stuff. Though if runtime dependencies are reduced, that does negate the admin headache of all the eclipse dependencies for lombok.. @novaterata I work with many annotation processors in Netbeans it relies on such heavily. But I do not have problems building most anything else. I am aware lombok benefits in code, seems kinda nifty. It is the packaging and building perspective I do not like. Its become a blocker to packaging other stuff. It does not seem like something i would use. Its literally blocked my progress on Java editor for Netbeans. Really just need byte-buddy, but I had to package lombok for byte-buddy for spring and now needed by Netbeans.\nI am not a fan of reducing programmers effort and time just to increase systems admin and others. I am not as annoyed by boilerplate code. I code in C and routine have such. Its life in coding. I do not see how Lombok benefits runtime really. It seems more like a RAD only tool.. If there is anything I can do to assist with this I am more than willing. I do not need lombok but I do need byte-buddy, its presently blocking the core Java stuff for my Netbeans 9 build from source under JDK9. Not sure Lombok will be fixed for Java 9 anytime soon. Thus since I am stalled there, I have time to help.. That is good to know, but dont use either, always been a Netbeaner. Likely could grab a Intellij binary or something. Maybe I can invoke via cli outside of IDE for same purposes. Though think I need a built and running lombok. I had a binary of that and byte-buddy, but all there deps were updated to 9. Not sure I can run or build those. I likely would have to under 1.8, and thus recompile any deps for lombok/byte-buddy. Not really an option long past that point. Seems lombok has run issues under 9 beyond build. Not sure about prebuilt older versions. \nThanks for the suggestion. I may look into that. Anxious to get around the blocker so I can complete my NB efforts. Netbeans already addressed their Java 9 issues, down to just dependencies. Curious if byte-buddy will have build and other issues. Won't know till I get past lombok.... It looks like the only use is of  lombok.EqualsAndHashCode. I think just need to find a replacement for that annotation, alternative library, custom annotation processor for such or something. Though looking at tests, before and after, may not be so simple. But at least does show the difference of delombok.. Seems Google Auto-Value provides the same function. I will experiment with replacement.. Retracted for now, jar was empty... need to look further into what happened.. Ok I am not crazy and looking to confirm again. I need to verify more via runtime and usage. I can submit PR if you like. Presently using the following sed. I had posted before and removed.\nTo make the change from lombok to auto-value\nbash\nfor f in $(grep -l -m1 lombok\\\\.EqualsAndHashCode -r *); do\n        sed -i -e \"s|lombok.EqualsAndHashCode|com.google.auto.value.AutoValue|\" \\\n                -e \"s|@EqualsAndHashCode.*|@AutoValue|g\" \\\n                \"${f}\" || die \"Failed to swap lombok for autovalve\"\ndone\nNot sure what went wrong before, passed compile, but no jar thus remove comment. I think I did not specify processor. Java 9 seems odd with processors, not picking it up from processor or source paths. Just classpath when using -processor argument. Passing those for netbeans as well. Seems they should be picked up via a path, processor or source.\njavac -processor com.google.auto.value.processor.AutoAnnotationProcessor ...\nBut it builds fine with switch from Lombok to Auto-Value. Now to see if other stuff builds against it and runs etc. Hopefully I can proceed with the blocked needed bits of Netbeans now.\n```\ndev ~\nunzip -l /usr/share/byte-buddy-dep/lib/byte-buddy-dep.jar\n....\n  5442958                     1928 files\ndev ~\ncat /usr/share/byte-buddy-dep/package.env\nDESCRIPTION=\"Runtime code generation for the Java virtual machine.\"\nSLOT=\"0\"\nCATEGORY=\"dev-java\"\nPVR=\"1.7.9\"\nCLASSPATH=\"/usr/share/byte-buddy-dep/lib/byte-buddy-dep.jar\"\nDEPEND=\"asm-6:auto-common:auto-value:guava-23:spotbugs-annotations\"\nVM=\">=virtual/jre-9\"\nRELEASE=\"9\"\nMERGE_VM=\"oracle-jdk-bin-9\"\n```\n. Not sure how to confirm runtime usage. But I am not getting any errors in Netbeans for byte-buddy-dep built with AutoValue vs Lombok. I will comment if I run into any. Aside from build issues in the PR. Seems the change is safe. Just one auto code generator for another. Seems AutoValue is a drop in replacement for the most part, less some configuration/customization.. @vlsi I am not sure on that stuff. I looked at AutoValue docs online and did not see equivalents, though I could be wrong. It may require some other changes to code to replicate such if AutoValue does not. Or have such added to newer version of AutoValue.\nI have to check on what Lombok does with each, but this maybe a replacement for @EqualsAndHashCode(exclude = \"name\") but requires changes to code. It cannot be done via annotations like Lombok.\nThe other question to ask is if AutoValue needs those things that Lombok did. It may work differently and not require such. I am not very familiar with code generators like Lombok and AutoValue. I just know Lombok is a pita to build from source for my needs and in my build env not using ant, etc.. @raphw thanks a lot!!! Your the man! Or one of them!. Initial attempt to update build system. Added to global pom.xml like the others lombok and findbugs. Not dropping lombok, since it maybe used in other parts I did not update. I can update those if needed. At this time I only care about byte-buddy-dep.\nAlso findbugs can likely be updated to spotbugs, the successor.. For Java 9+ build likely need to add\njavac -processor com.google.auto.value.processor.AutoAnnotationProcessor\nI have not had any luck with\n```\n  --processor-module-path \n        Specify a module path where to find annotation processors\n  --processor-path , -processorpath \n        Specify where to find annotation processors\n  --source-path , -sourcepath \n        Specify where to find input source files\n. Tried to fix tests/build without luck. Seems the auto stuff is >= Java 1.8, so will not work on 6 or 7 due to class issues. Unless another is made with an older bytecode, and uploaded to Maven. The errorOne @AutoValue class may not extend another``` I cannot explain as I do not see that and it compiles fine for me. But I am not using maven, just straight javac. Adding annotation processors to compiler plugin seems to break build of other stuff. Maybe need to add other processors or break those into individual project pom.xml.. @raphw no worries, I have it for my needs, and at least it was explored as a potential for the future. The other thing maybe to use something to inject the annotations import and annotation to the various classes as part of build based on jdk version. Fair amount of things generate Java code, so could be another option. I may play around with the build if you are open to that approach.\nbyte-buddy-dep itself seems good to go for Java 9+. I haven't built or tested under 10 yet, but no issues under 9. The issue was in building it, as I have to build dependencies. Some opt to use binaries in that process. Short of bootstrapping things like javacc, antlr, and others. I build everything from source including deps. Thus to build byte-buddy-dep I need to be able to build lombok.\nLombok presently cannot build under Java 9. I have modified Lombok heavily for building under Java 9. Basically dropping stuff for < 9 because it does not build under 9. Down to just 1 issue which I have filed with Lombok. Though I am not sure when that will be addressed. It seems rather odd, and I assume not so trivial to fix. I wasted more time on that one aspect than I did with switching byte-buddy-dep to autovalue.\nbyte-buddy-dep is the only package I have come across thus far that uses lombok. It seems rather troublesome for a few reasons as follows;\n\nNumber of dependenies to build Lombok, ~70 eclipse libraries (Issue #397)\nIssues building under various JDKs due to how its coupling with them and into the compiler. I had to fix at first for 1.8, not just 9\nCircular deps\nNumber of open bugs, seems pretty high\nUses dead? old packages itself to build...\n\nThe idea behind Lombok is interesting and nothing against its authors. Its codebase seems interesting and most issues are a result of supporting a range of JDK versions. It is my least favorite package, and spent a considerable time on just that not only in dependencies but its own build issues.\nThe only reason I ever needed it was for byte-buddy-dep. A dep of hibernate-core I haven't finished packaging. Then a blocker for my Netbeans 9 packaging as it is also a dep. But since switching byte-buddy-dep to AutoValue, I was able to proceed with Netbeans 9\nI am good for my needs now. Though going forward maybe interesting for Lombok and Java 9+. Thus when ever you get around to that maybe time to switch from that to AutoValue or other. Grabbing a pre-built binary to use from Maven or Gradle jar repo is very different to building everything from source with all being a given source/target/release. Like the Auto* being >=1.8. Those jars I build as 9, under 9, so newer than grabbed from Maven/Gradle. The entire stack is that way. I need to update a fair amount of packages from --release 8 to 9. That is another longer term issue requiring other changes not relevant here.. Ok cool, I just noticed the findbugs dep when messing with AutoValue replacing Lombok. I did not see spotbugs was already in use else where :). Seems like findbugs is still used for some annotation stuff? Not sure just saw it in there thus opened issue I have no needs there either way so pretty moot to me. Just like to always see things using the latest of other stuff.. Ah ok, not sure what to say about that stuff. AutoValue and AutoCommon seem to be >=1.8. Though I know a number of projects keep support for older JDKs. It is one thing that does cause issues for moving things in the other direction. Which is where my interest always lie. I care less about older JDKs. I guess I am on an indirect mission to get the Java world to update and kick legacy ways and habits. Not sure what things will be like when 10 comes out, and then 11, etc. How many previous versions they will keep supporting. Many are having to update some things due to dropping 1.5 support, even binaries no longer run. Finally some clients of my own will have to update... Legacy support seems to be the biggest issue with Lombok as well.\nI think maybe by the time 10 comes out, may be worth considering only >=1.8. It maybe a bit much to support 5 different versions. I think 3 tends to be most practical, which 6 would technically be the 4th with Java 9, 7th would be 3rd and oldest. I know its been a problem also for icedtea, as they spend most time backporting and fixing older jdk and little to no time for current or upcoming. I think Oracle is seeking to change all of this with 4 releases of Java per year, each quarter. Seems like at least 1 older version will be dropped per year or something.\nAnyway not sure how you want to handle this. Lombok seems to be troublesome for > 1.8. No clue when it will build under 9. It does have legacy support still. Other stuff Spotbugs, Auto*, etc seems to be requiring newer. Thus up to you on what all you want to support. I guess the build system will need to be modified for the various versions and switch dependencies or something. Not to mention handling that in the files themselves. Changing imports based on jdk and dependencies, I think is a bit much.\nIMHO I would suggest maybe with 1.8 release saying only >=1.8. The rest of the Java world is being forced to move forward either way. Anyone who needs to run under older JDK could just use an older byte-buddy, <=1.7.9 or something.\nEither way up to you. I will modify things for my needs. Just like to work with upstreams on moving stuff forward when I can. Though having just packaged Gradle. Its still using an ancient Guava, with stuff that's been in JDK since like 1.6... Really think all need to help get rid of legacy Java cruft. But thats my viewpoint. Having clients running older code I did in 1.4 years, I understand there is cost to updating. Not practical for all.. @raphw I think Oracle is seeking to change how the enterprise world operates. Plus all the growing interest around like OpenJDK, IBM releasing J9, for OpenJ9. All assumptions, but seems Oracle maybe looking to disrupt others legacy Java business and move everything to a newer different model. Not sure, they are donating Netbeans to Apache. Netbeans seems to be the official IDE for OpenJDK 8 per Wikipedia, not sure its relation to 9+ or if that is an accurate statement. Many still make money off supporting older Java, which includes Oracle but not limited to them. Seems like they may want to change that, IMHO.\nI am really not a fan of Lombok. I am actually quite impressed AutoValue thus far seems to be a drop in replacement for Lombok. I am using sed to make the change after unpack, before compile. That seems to be enough and builds fine, and other things that need it build against it. I haven't seen any runtime issues, or exceptions in Netbeans 9 thus far. Though I cannot confirm 100% if byte-buddy-dep is being used yet at runtime. Definitely in use at build time after having been built with AutoValue vs Lombok. AutoValue has considerable less dependencies, and no issues building.\nIn fact you could build the Auto* stuff for an older JDK I believe. It is just the binaries put on Maven and Gradle repos that were built with target 1.8, thus the byte code is to new for >= 1.8. If byte-buddy-dep say builds those from source. Then it could replace Lombok for older, I believe. I haven't built them under older so I cannot confirm. What ever supports annotation processing, so I think 1.6, or at least 1.7. I suspect 1.6 will be dropped sometime in 2018, from Java 11 or 12, not sure.\nLombok for sure does not build under Java 9. I can checkout from Git, but the file I have issues with has not changed since almost a year ago. It maybe useable as a binary but not from source. At least building Lombok under Java 9 for me fails. Nothing byte-buddy can do to fix upstream build issues with Lombok. Unless you know how to fix that issue.\nI have to double check, but I believe keeping Java 1.8 support for Lombok is problematic. I am removing support for that along with 6 and 7. Its just troublesome for me all around. byte-buddy-dep I haven't had any issues with thus far. It is just what I need to build it from source, and building those dependencies from source as well. Its a unique requirement.\nI think the entire Java community is going through growing pains with 9. IMHO that is a good thing, a much needed kick in the rear. I think all will need to start having better > support vs < than going forward. Only time will tell.... ",
    "sravanthy": "Can we add nested classes using byte buddy for java 8 version .. Hey can you please share any code snippet \nCurrently I'm able to generate a class with fields and methods using \nClass<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .method(named(\"toString\")).intercept(FixedValue.value(\"Hello World!\"))\n                .make();\n            .\n",
    "rajeshb26": "```\n@Test\n    public void testCreateInnerClass() throws Exception {\n        TypeDescription sampleInner = new TypeDescription.Latent(\"foo.Outer$Inner\", Opcodes.ACC_PUBLIC, TypeDescription.Generic.OBJECT) {\n            @Override\n            public String getSimpleName() {\n                return \"Inner\";\n            }\n        @Override\n        public boolean isAnonymousType() {\n            return false;\n        }\n\n        @Override\n        public boolean isMemberType() {\n            return true;\n        }\n    };\n\n    DynamicType.Unloaded<?> outerClazz = new ByteBuddy()\n            .subclass(Object.class)\n            .name(\"foo.Outer\")\n            .declaredTypes(sampleInner)\n            .make();\n\n    Class<?> outer = outerClazz.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST.opened()).getLoaded();\n\n    DynamicType.Unloaded<?> innerClazz = createPlainWithoutValidation()\n            .name(sampleInner.getName())\n            .innerTypeOf(outer).asMemberType()\n            .make();\n\n    Class<?> type = innerClazz.load((InjectionClassLoader) outer.getClassLoader(), InjectionClassLoader.Strategy.INSTANCE).getLoaded();\n\n    innerClazz.saveIn(new File(\"target/generated-sources\"));\n    outerClazz.saveIn(new File(\"target/generated-sources\"));\n    assertThat(type.isMemberClass(), is(true));\n}\n\n```\nWe can generate inner class with the above code, but only Outer.class file is getting saved in the given directory. why Outer$Inner.class is not getting saved?\nWhat is the best way to generate multiple static nested inner classes dynamically at runtime including Outer class?. @raphw Thanks for your response. My bad, i could see the generated Outer$Inner.class. It's working perfectly fine. All inner classes from my project were not shown in my workspace.\nI want to generate .class files directly using byte buddy like the way how java compiler generates .class files for below java code snippet. ( i will be getting the metadata like class name and its field's names from an api/database) \npublic class Outer {\n    private Inner1 inner1;\n    public static class Inner1 {\n        private Inner2 inner2;\n    }\n    public static class Inner2 {\n        private Inner3 inner3;\n    }\n    public static class Inner3 {\n    }\n}\n@raphw Can you please suggest Should i use the same approach as the above example (https://github.com/raphw/byte-buddy/issues/247#issuecomment-461634190). ",
    "Aleishus": "It's works, byte buddy is awesome!. Hi, I have another problem . How can  I modify the method's parameters  using inlined code.\ne.g.   \n        The original method is: \n                                    void execute(Runnable task){}\n\n                 After redefined:  \n                                    void execute(Runnable task){\n                                         task = myInterceptedWrapMethod(task)\n                                      ...\n                                     }\n\nI don't know how to make it !. Here is my code , is this right?\n          @Advice.OnMethodEnter\n          public static void before( @Advice.This(typing = Assigner.Typing.DYNAMIC) Object self,\n                 @Advice.AllArguments(typing = Assigner.Typing.DYNAMIC) Object[] originals,\n                 @Advice.AllArguments(readOnly = false) Object[] wraps ) . I see,thx! \ud83d\ude00. Thx!\n\nThis can work.\njava\nreturn new ByteBuddy().redefine(Bar.class).name(Foo.class.getName());\nBut I wish you to implement a new Implementation that can specify some  Bar's methods  to replace Foo's, if Foo and Bar are compatible.\n. ",
    "arjunsawhney": "MyAgent.java:\nreturn new AgentBuilder.Default().disableClassFormatChanges()\n                .ignore(ElementMatchers.none())\n                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n                .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)\n                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)\n                .type(ElementMatchers.named(\"java.util.logging.Logger\"))\n                .transform(new AgentBuilder.Transformer.ForAdvice().include(MyAgent.class.getClassLoader())\n                        .advice(ElementMatchers.nameEndsWith(\"log\"),\"ABC\"));\nABC.java:\n@Advice.OnMethodEnter\n    public static void enterFilter(@Advice.AllArguments(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object[] allArguments,\n                                   @Advice.Origin Method method)  {\n//EDITED allArguments[1] but NO CHANGE\n}\nPlease help, thank you.. I have specified the advice. I am able to instrument the log method of java.util.logging.Logger and read the argument but I am unable to change the value of the argument. . I have set it to false\n@Advice.AllArguments(readOnly = false)\nBut i am still not able to modify the value!\n. Step 1: \nI instrument the log method of the Logger.class in java.util.Logging which is the following method:\npublic void log(Level var1, String var2) {\n        if (this.isLoggable(var1)) {\n            LogRecord var3 = new LogRecord(var1, var2);\n            this.doLog(var3);\n        }\n    }\nStep 2:\nI instrument this method in my agent class Agent.java in this fashion:\nprivate static void install(Instrumentation instrumentation) {\n   logAdvice().installOn(instrumentation);\n}\nprivate static AgentBuilder logAdvice() {\nreturn new AgentBuilder.Default().disableClassFormatChanges()\n.ignore(ElementMatchers.none())\n.with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n.with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)\n.with(AgentBuilder.TypeStrategy.Default.REDEFINE)\n.type(ElementMatchers.named(\"java.util.logging.Logger\"))\n.transform(new AgentBuilder.Transformer.ForAdvice().include(MyAgent.class.getClassLoader())\n.advice(ElementMatchers.nameEndsWith(\"log\"),\"ABC\"));\n}\nStep 3:\nThis java agent is attached to an application that performs a log using java.util.logging.Logger in the following fashion:\nlog.info(\"12345\");\nThe agent is attached using java -javaagent\nStep 4:\nI am able to instrument the log method of java.util.logging.Logger and I am able to advice it in ABC.java\nThen inside ABC.java I perform the following:\n@Advice.OnMethodEnter\npublic static void enterFilter(@Advice.AllArguments(readOnly = false, typing=Assigner.Typing.DYNAMIC) Object[] allArguments, @Advice.Origin Method method) {\nString message = (String) allArguments[1];\nSystem.out.println(message); //o/p is 12345\nmessage=\"*\";\nSystem.out.println(message); //o/p is \nSystem.out.println(allArguments[1]); //o/p is 12345\nallArguments[1] = message;\nSystem.out.println(allArguments[1]); //o/p is still 12345\n// Expected o/p for last print statement is **\n}\nI hope this makes sense. Any help would be greatly appreciated, thank you.. I have done the required instrumentation.\nI build my jar and attach it to my spring boot application, and then I run it.\nAgent.java\nreturn new AgentBuilder.Default().disableClassFormatChanges()\n                .ignore(ElementMatchers.none())\n                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n                .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)\n                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)\n                .type(ElementMatchers.nameContainsIgnoreCase(\"java.lang.Runtime\"))\n                .transform(new AgentBuilder.Transformer.ForAdvice().include(MyAgent.class.getClassLoader())\n                        .advice(ElementMatchers.named(\"exec\"),\"XYZ\"));\nXYZ.java:\n@Advice.OnMethodEnter\n    public static void enterFilter(@Advice.AllArguments Object[] allArguments,\n                                   @Advice.Origin Method method) {\n       ABC abc = new ABC(); //this line gives me NoClassDefFoundError\n    }\nBut when I use the same instrumentation for a doFilter method and create an ABC object, I do not get NoClassDefFoundError. Okay, I understand.\nSo can you please tell me how to go about fixing this issue?. I tried doing that by getting the jar file and using instrumentation.appenToBootstrapClassLoaderSearch() but now I am getting a linkage error when I am creating a new AgentBuilder instance.\nAny help would be really appreciated. \n. I used  in manifest entries the pom to load the jar my agent and required java classes, and it worked. Thank you.. ",
    "karthikraobr": "Thanks for this amazing library. Just checking if this was implemented, since I too need something similar. TIA!. ",
    "dpsoft": "@CodingFabian thank you for your clear and helpful explanation!!!. Thanks for the explanation. So always is a good idea have a Resubmitter ;). thank you for your clear and helpful explanation!!!. Is it possible to use the following approach to caching proxy classes but using an Agent Builder?\njava\nTypeCache<Class<?>> typeCache = new TypeCache<>(TypeCache.Sort.SOFT);\nClass<?> proxyType = typeCache.findOrInsert(classLoader, SampleClass.class, () -> new ByteBuddy()\n  .subclass(SampleClass.class)\n  .method(ElementMatchers.named(\"test\"))\n  .intercept(MethodDelegation.to(SampleClassInterceptor.class))\n  .make()\n  .load(someClassLoader, ClassLoadingStrategy.UsingLookup.of(MethodHandles\n      .privateLookupIn(SampleClass.class, MethodHandles.lookup()))\n  .getLoaded()\n});\nThanks in advance.\n. Thanks a lot @raphw!. ",
    "cspinetta": "@CodingFabian when you say \"ByteBuddy is unable to resolve the class hierarchy properly\", what does it mean?\nI say, how does it possible that a class is not visible for ByteBuddy the first time and then it becomes visible?. Very good explanation, thanks!\nI still can not find an example in which this may be possible. Just to be more clear, can you tell me if the following is a possible case?\nA ClassFileTransformer is instrumenting a class method, adding a piece of bytecode with a super type call. In this case, the JVM is not be able to accept the new bytecode due to the super type is not still loaded?. Thank you very much for your time and this useful explanation!\nIt's very clear the motivation to introduce this feature.. ",
    "godlike110": "i have used you code,but there is still not work, the result run in IDEA is below, how to use StreamWriting\u3002\n\n. i have add the AgentBuilder.Listener.StreamWriting and see the error message below, how can i do with id. the SimpleController is the java class you have written before.\n`\n==============================agent start!======================================\n==============================agent end!======================================\nSampleController\n[Byte Buddy] ERROR com.gop.agent.statistics.utils.HelloMain$SampleController [sun.misc.Launcher$AppClassLoader@2f78743b, null, loaded=false]\njava.lang.IllegalArgumentException: None of [net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder$Record@4ec53efa] allows for delegation from public void com.gop.agent.statistics.utils.HelloMain$SampleController.foo()\n    at net.bytebuddy.implementation.bind.MethodDelegationBinder$Processor.bind(MethodDelegationBinder.java:827)\n    at net.bytebuddy.implementation.MethodDelegation$Appender.apply(MethodDelegation.java:1035)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyCode(TypeWriter.java:614)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyBody(TypeWriter.java:603)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining$RedefinitionClassVisitor$CodePreservingMethodVisitor.visitCode(TypeWriter.java:3899)\n    at net.bytebuddy.jar.asm.ClassReader.b(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2894)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1612)\n    at net.bytebuddy.dynamic.scaffold.inline.RebaseDynamicTypeBuilder.make(RebaseDynamicTypeBuilder.java:200)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:7700)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doTransform(AgentBuilder.java:8092)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:8055)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1400(AgentBuilder.java:7842)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:8401)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:8351)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:7981)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:424)\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:800)\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)\n    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:425)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:358)\n    at com.gop.agent.statistics.utils.HelloMain.main(HelloMain.java:27)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n[Byte Buddy] COMPLETE com.gop.agent.statistics.utils.HelloMain$SampleController [sun.misc.Launcher$AppClassLoader@2f78743b, null, loaded=false]\nfoo\nProcess finished with exit code 0\n`. my code is below, the Origin annotation is wrong ?:\n`\npackage com.gop.agent.statistics.interceptor;\nimport net.bytebuddy.asm.Advice;\nimport net.bytebuddy.implementation.bind.annotation.Origin;\nimport net.bytebuddy.implementation.bind.annotation.RuntimeType;\nimport net.bytebuddy.implementation.bind.annotation.SuperCall;\nimport net.bytebuddy.jar.asm.commons.Method;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.concurrent.Callable;\n/*\n * Created by wenzhiwei on 17/1/18.\n /\npublic class AccessInterceptor {\n@RuntimeType\npublic static Object intercept(@Origin Method method,\n                               @SuperCall Callable<?> callable) throws Exception {\n    Logger logger = LoggerFactory.getLogger(method.getName());\n    System.out.println(\"start!\");\n    logger.info(\"start!!\");\n    long start = System.currentTimeMillis();\n    try {\n        return callable.call();\n    } finally {\n        System.out.println(method + \" took \" + (System.currentTimeMillis() - start));\n        logger.info(method + \" took \" + (System.currentTimeMillis() - start));\n    }\n}\n\n}\n`. i have changed it, to the other annotation , but still has error below, i dont't know why.\n\n`\n==============================agent start!======================================\n==============================agent end!======================================\nSampleController\n[Byte Buddy] ERROR com.gop.agent.statistics.utils.HelloMain$SampleController [sun.misc.Launcher$AppClassLoader@2f78743b, null, loaded=false]\njava.lang.IllegalStateException: The net.bytebuddy.jar.asm.commons.Method arg0 method's 0 parameter is annotated with a Origin annotation with an argument not representing a Class, Method, Constructor, String, int, MethodType or MethodHandle type\n    at net.bytebuddy.implementation.bind.annotation.Origin$Binder.bind(Origin.java:121)\n    at net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder$DelegationProcessor$Handler$Bound.bind(TargetMethodAnnotationDrivenBinder.java:697)\n    at net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder$Record.bind(TargetMethodAnnotationDrivenBinder.java:119)\n    at net.bytebuddy.implementation.bind.MethodDelegationBinder$Processor.bind(MethodDelegationBinder.java:821)\n    at net.bytebuddy.implementation.MethodDelegation$Appender.apply(MethodDelegation.java:1035)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyCode(TypeWriter.java:614)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyBody(TypeWriter.java:603)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining$RedefinitionClassVisitor$CodePreservingMethodVisitor.visitCode(TypeWriter.java:3899)\n    at net.bytebuddy.jar.asm.ClassReader.b(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2894)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1612)\n    at net.bytebuddy.dynamic.scaffold.inline.RebaseDynamicTypeBuilder.make(RebaseDynamicTypeBuilder.java:200)\n`\n. got it ,thanks very much!  you are so kind.. i have dealed with it successful, thank you.. ",
    "liuxianbing": "sorry , here is the code\n```java\n final ByteBuddy byteBuddy =\n        new ByteBuddy().with(TypeValidation.of(ApmConfiguration.getInstance().debug));\n    // .with(MethodGraph.Empty.INSTANCE);\n    return new AgentBuilder.Default(byteBuddy).with(binaryLocator)\n        .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION).with(new AgentBuilder.Listener() {\n          @Override\n          public void onComplete(String arg0, ClassLoader arg1, JavaModule arg2) {\n            // System.out.println(\"onComplete:\" + arg0);\n          }\n      @Override\n      public void onError(String arg0, ClassLoader arg1, JavaModule arg2, Throwable arg3) {\n        System.out.println(arg3.getMessage() + \"onError:\" + arg0);\n        arg3.printStackTrace();\n      }\n\n      @Override\n      public void onIgnored(TypeDescription arg0, ClassLoader arg1, JavaModule arg2) {}\n\n      @Override\n      public void onTransformation(TypeDescription arg0, ClassLoader arg1, JavaModule arg2,\n          DynamicType arg3) {\n        System.out.println(\"onTransformation:\" + arg0.getName());\n      }\n    }).ignore(any(), timed(\"classloader\", \"bootstrap\", isBootstrapClassLoader()))\n    .or(any(), timed(\"classloader\", \"reflection\", isReflectionClassLoader()))\n    .or(any(),\n        timed(\"classloader\", \"apm-call-site\",\n            classLoaderWithName(\"org.codehaus.groovy.runtime.callsite.CallSiteClassLoader\")))\n    .or(any(), new IsIgnoredClassLoaderElementMatcher())\n    .or(timed(\"type\", \"global-exclude\",\n        nameStartsWith(\"java\").or(nameStartsWith(\"com.sun.\")).or(nameStartsWith(\"sun.\"))\n            .or(nameStartsWith(\"jdk.\")).or(nameStartsWith(\"org.aspectj.\"))\n            .or(nameStartsWith(\"org.groovy.\")).or(nameStartsWith(\"com.p6spy.\"))\n            .or(nameStartsWith(\"net.bytebuddy.\"))\n            .or(nameStartsWith(\"org.slf4j.\").and(not(nameStartsWith(\"org.slf4j.impl.\"))))\n            .or(nameContains(\"javassist\")).or(nameContains(\".asm.\"))\n            .or(nameStartsWith(\"com.github.apm\")\n                .and(not(nameContains(\"Test\").or(nameContains(\"benchmark\")))))))\n    .disableClassFormatChanges().type(ElementMatchers.nameStartsWith(\"com.jingoal.dc.koala.web.controller\"))\n    .transform(new AgentBuilder.Transformer() {\n      @Override\n      public Builder<?> transform(Builder<?> builder, TypeDescription typeDescription,\n          ClassLoader arg2) {\n        try {\n          return builder.visit(Advice.to(LoggingAdvice.class).on(nameStartsWith(\"do\")));\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        return null;\n      }\n    }).asDecorator();\n\n```\nAnd LoggingAdvice is\n```java\n@Advice.OnMethodEnter\n  public static long enter() {\n    return System.currentTimeMillis();\n  }\n@Advice.OnMethodExit(onThrowable = Throwable.class)\n  public static void exit(@Advice.Thrown Throwable t, @Advice.Origin(\"#m\") String methodName,\n      @Advice.Origin(\"#t\") String classType, @Advice.Origin(\"#s\") String signature,\n      @Advice.Enter long startTime,\n      @Advice.Return(typing = Assigner.Typing.DYNAMIC) Object returnObj) {\n    long spendTime = System.currentTimeMillis() - startTime;\n    System.out.println(classType + \"-\" + methodName + \"***\");\n    PrometheusMetricsModule.calLate(spendTime, classType, methodName, signature);\n    if (null != t) {\n      PrometheusMetricsModule.errorCounter(classType, methodName, signature, t);\n    }\n    if (slowTime > 0 && spendTime >= slowTime) {\n      writeSlowTime(classType, methodName, signature, returnObj.toString(), spendTime);\n    }\n  }\n```\nmy web application is using spring mvc,which is deployed into the tomcat server\nafter i startup the tomcat, i get the jvm pid, and then attach my agent app to the running jvm\nbellow is my web application\njava\npackage com.jingoal.dc.koala.web.controller;\n@Controller\n@SessionAttributes(\"login\")\n@RequestMapping(value = \"/login\")\npublic class LoginController{\n@RequestMapping(\"/doLogin\")\n  public String doLogin(@RequestParam(required = false) String inputId,\n      @RequestParam(required = false) String inputPassword, Model model) {\n....\n}\n}\nand after i attach the agent to the running application,my agent listener aslo print\njava\nonTransformation:com.jingoal.dc.koala.web.controller.LoginController\nis there someing different with the situation when came with spring web application?\nHope get some help, thanks!!!\nforgive my poor English. ",
    "MarcMagnin": "As well can you hook onto an interface?. Cheers! \nThanks for that quick reply. \nAbout the interface bit, I would like to instrument type that I don't know in advance (classes that would be implemented later on). How could I manage that?\nMany many thanks!. cheers,\nI've been able to transform within the following code but it fails with java.lang.NoClassDefFoundError: Could not initialize class io...Interceptor\nAm I forced to manually inject all classes that my code is depending on or there is another way of doing it?\nthe code:\n```java\nFile temp = null;\n        try {\n            temp = Files.createTempDirectory(\"tmp\").toFile();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    Map<TypeDescription.ForLoadedType, byte[]> m = new HashMap<>();\n    m.put(new TypeDescription.ForLoadedType(Interceptor.class),\n            ClassFileLocator.ForClassLoader.read(Interceptor.class).resolve());\n    ClassInjector.UsingInstrumentation.of(temp, ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, inst).inject(m);\n\n    ByteBuddy byteBuddy = new ByteBuddy().with(Implementation.Context.Disabled.Factory.INSTANCE);\n    new AgentBuilder.Default().with(byteBuddy)\n            .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n            .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)\n            .with(AgentBuilder.TypeStrategy.Default.REDEFINE)\n            .ignore(ElementMatchers.nameStartsWith(\"net.bytebuddy.\"))\n            .enableBootstrapInjection(inst, temp)\n            .type(ElementMatchers.is(DefaultMBeanServerInterceptor.class))\n            .transform((builder, typeDescription, classLoader, javaModule) -> builder.visit(Advice.to(ExitAdvice.class)\n                    .on(named(\"invoke\")\n                            .and(takesArguments(ObjectName.class, String.class, Object[].class, String[].class)\n                                    .and(returns(Object.class))))))\n            .installOn(inst);\n\n```\nthe advice:\njava\npublic static class ExitAdvice {\n        @Advice.OnMethodExit(onThrowable = Throwable.class)\n        public static void exit(@Advice.Argument(0) ObjectName objectName,\n                                @Advice.Argument(1) String operationName,\n                                @Advice.Argument(2) Object[] params,\n                                @Advice.Argument(3) String[] signature,\n                                @Advice.Thrown Throwable t,\n                                @Advice.Return Object returnObject) {\n            System.out.println(\"JMX interceptor: Notification received\");\n            Interceptor.doSomeThing();   // <----- it fails there\n        }\n    }\n. Works like a charm, Thanks!. ",
    "mches": "No prob. Thank you for Byte Buddy.. Happy to contribute.\nSo, AppVeyor CI provides Maven 3.3.9 currently, which is not Java 6-compatible. Travis CI provides 3.2.5 currently, but no doubt they will eventually upgrade to 3.3.  There are some methods of scripting that could install Maven, but it varies by CI platform. Maven Wrapper seems to be really popular. It's based on Gradle Wrapper which is practically a de facto standard. Jason van Zyl is key maintainer, so that helps its credibility quite a bit. Travis CI actually detects Maven Wrapper and uses it if you don't override the default scripts. Anyone who clones a repository with Maven Wrapper can run with the correct Maven version. Just replace mvn with ./mvnw.. After you enable AppVeyor CI, you'll have something like this: \n\n. ",
    "bill23-kim": "I got the following error stack trace through registering the listener.\nBut I still don't know why this errors are occur. What's wrong?\njava.lang.IllegalArgumentException: None of [net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder$Record@c2570922] allows for delegation from private java.lang.String com.test.Test.getId(org.joda.time.LocalDateTime)\n    at net.bytebuddy.implementation.bind.MethodDelegationBinder$Processor.bind(MethodDelegationBinder.java:827)\n    at net.bytebuddy.implementation.MethodDelegation$Appender.apply(MethodDelegation.java:1035)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyCode(TypeWriter.java:616)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody.applyBody(TypeWriter.java:605)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining$RedefinitionClassVisitor$CodePreservingMethodVisitor.visitCode(TypeWriter.java:3928)\n    at net.bytebuddy.jar.asm.ClassReader.b(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2910)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1628)\n    at net.bytebuddy.dynamic.scaffold.inline.RebaseDynamicTypeBuilder.make(RebaseDynamicTypeBuilder.java:200)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:8128)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doTransform(AgentBuilder.java:8520)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:8483)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1400(AgentBuilder.java:8270)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:8829)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:8779)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:8409)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n    at org.apache.catalina.loader.WebappClassLoaderBase.findClassInternal(WebappClassLoaderBase.java:2270)\n    at org.apache.catalina.loader.WebappClassLoaderBase.findClass(WebappClassLoaderBase.java:811)\n    at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1254)\n    at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1119)\n    at org.springframework.util.ClassUtils.forName(ClassUtils.java:257)\n    at org.springframework.beans.factory.support.AbstractBeanDefinition.resolveBeanClass(AbstractBeanDefinition.java:408)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doResolveBeanClass(AbstractBeanFactory.java:1271)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1242)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:576)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1319)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:315)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:394)\n    at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:594)\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:407)\n    at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:442)\n    at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:458)\n    at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:339)\n    at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:306)\n    at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:127)\n    at javax.servlet.GenericServlet.init(GenericServlet.java:158)\n    at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1183)\n    at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1099)\n    at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:989)\n    at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4913)\n    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5223)\n    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n    at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:724)\n    at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:700)\n    at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)\n    at org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1702)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300)\n    at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819)\n    at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)\n    at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:482)\n    at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:431)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300)\n    at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819)\n    at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)\n    at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1468)\n    at javax.management.remote.rmi.RMIConnectionImpl.access$300(RMIConnectionImpl.java:76)\n    at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1309)\n    at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1401)\n    at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:829)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:324)\n    at sun.rmi.transport.Transport$1.run(Transport.java:200)\n    at sun.rmi.transport.Transport$1.run(Transport.java:197)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at sun.rmi.transport.Transport.serviceCall(Transport.java:196)\n    at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:568)\n    at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:826)\n    at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:683)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:682)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745). It works well by changing to public class. Thank you very much!. ",
    "jujusharp": "Got it, Thanks!. ",
    "nickgrealy": "Thanks @raphw, I've had a play with the ElementMatchers, and updated the example to use Advice. I've now got the following code catching all(?) possible pointcuts - very nice \ud83c\udf7b ! (thanks)\nA few questions:\n\nIs the below code your preferred/suggested way of \"capturing all possible pointcuts\", or is there a better way?\nFurther to the original issue, I've found that if any Interceptor's method signatures don't match the targeted method 100%, bytebuddy is very unforgiving - it will log an error (only if configured), the error tends to be rather cryptic IMO (e.g. Cannot represent static ... as given method constant) and no interceptors will execute (even the correctly configured ones)\nis there a way to make bytebuddy still run the interceptors that do match?\nis there a way to make bytebuddy more lenient in it's method signature matching? (e.g. @Advice.This(optional = false) Object thiz still threw errors for the Static/Initializer/ConstructorInterceptors (error logged/thrown when thiz was used in the method - see stacktrace below))\n\n\n\nIdeally, I'd love to provide a single Interceptor method, and have only the parameters relevant to the method/constructor/static/initializer under advice, populated (non-relevant params are simply null).\nHere's the updated code:\n```Java\npublic static void main(String[] args) throws Exception {\n    premain(null, ByteBuddyAgent.install());\n    HttpURLConnection urlConnection = (HttpURLConnection) new URL(\"http://www.google.com\").openConnection();\n    System.out.println(urlConnection.getResponseCode());\n}\npublic static void premain(String arg, Instrumentation inst) throws Exception {\n    new AgentBuilder.Default()\n            // .with(AgentBuilder.Listener.StreamWriting.toSystemError())\n            .ignore(nameStartsWith(\"net.bytebuddy.\"))\n            .type(ElementMatchers.nameContains(\"java.net.\"))\n            .transform((builder, td, cl, m) -> builder.visit(Advice.to(MyGeneralInterceptor.class).on(not(isStatic()).and(not(isConstructor())))))\n            .transform((builder, td, cl, m) -> builder.visit(Advice.to(MyStaticInterceptor.class).on(isStatic().and(not(isTypeInitializer())).and(not(isConstructor())))))\n            .transform((builder, td, cl, m) -> builder.visit(Advice.to(MyInitializerInterceptor.class).on(isTypeInitializer())))\n            .transform((builder, td, cl, m) -> builder.visit(Advice.to(MyConstructorInterceptor.class).on(isConstructor())))\n            .installOn(inst);\n}\npublic static class MyGeneralInterceptor {\n    @Advice.OnMethodEnter\n    public static void enter(@Advice.Origin Method method, @Advice.This Object thiz) {\n        System.out.println(\"Intercepted Normal >> \" + method);\n    }\n}\npublic static class MyStaticInterceptor {\n    @Advice.OnMethodEnter\n    public static void enter(@Advice.Origin Method method) {\n        System.out.println(\"Intercepted Static >> \" + method);\n    }\n}\npublic static class MyInitializerInterceptor {\n    @Advice.OnMethodEnter\n    public static void enter(@Advice.Origin(\"#t.#m\") String method) {\n        System.out.println(\"Intercepted Initia >> \" + method);\n    }\n}\npublic static class MyConstructorInterceptor {\n    @Advice.OnMethodEnter\n    public static void enter(@Advice.Origin Constructor method) {\n        System.out.println(\"Intercepted Constr >> \" + method);\n    }\n}\n```\nError on optional thiz usage:\njava.lang.NullPointerException\n    at net.bytebuddy.implementation.bytecode.constant.DefaultValue.of(DefaultValue.java:66)\n    at net.bytebuddy.asm.Advice$Dispatcher$OffsetMapping$Target$ForDefaultValue.resolveRead(Advice.java:1742)\n    at net.bytebuddy.asm.Advice$Dispatcher$Inlining$CodeTranslationVisitor.visitVarInsn(Advice.java:5504)\n    at net.bytebuddy.jar.asm.MethodVisitor.visitVarInsn(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.a(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.b(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.asm.Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner.doApply(Advice.java:4764)\n    at net.bytebuddy.asm.Advice$Dispatcher$Inlining$Resolved$ForMethodEnter$AdviceMethodInliner.apply(Advice.java:5088)\n    at net.bytebuddy.asm.Advice$AdviceVisitor.onAfterExceptionTable(Advice.java:6545)\n    at net.bytebuddy.utility.visitor.ExceptionTableSensitiveMethodVisitor.considerEndOfExceptionTable(ExceptionTableSensitiveMethodVisitor.java:34)\n    at net.bytebuddy.utility.visitor.ExceptionTableSensitiveMethodVisitor.visitLabel(ExceptionTableSensitiveMethodVisitor.java:47)\n    at net.bytebuddy.jar.asm.ClassReader.a(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.b(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.jar.asm.ClassReader.accept(Unknown Source)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2910)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1628)\n    at net.bytebuddy.dynamic.scaffold.inline.RebaseDynamicTypeBuilder.make(RebaseDynamicTypeBuilder.java:200)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:8128)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doTransform(AgentBuilder.java:8520)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:8483)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1400(AgentBuilder.java:8270)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:8829)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:8779)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:8409)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at java.net.Socket.getInputStream(Socket.java:911)\n    at sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:642)\n    at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1535)\n    at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1440)\n    at java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:480) . I see you're using maven, and provided sounds like it's logically equivalent, but I'll share anyway...\nI was doing something similar, and I used compileOnly (Gradle) - and that worked for me. Dependencies weren't packaged in the end artifact, it relied on them being present in the \"host\" project.\ni.e.\ndependencies {\n    compileOnly \"org.springframework:spring-web:4.3.7.RELEASE\"\n}. ",
    "zhongl": "@nickgrealy thank you for sharing, but it didn't help.\nNormally, it works only if javaagent and spring classes shared the same ClassLoader. \nBut in my case,  a spring boot application will load class from a customized ClassLoader named LaunchedURLClassLoader in runtime. Without dependency of spring-web in the final jar, the ClassLoader of javaagent , which is SystemClassLoader, could not find the spring classes.. @raphw thanks for reply, it helps a lot. A new version of code is:\njava\npublic static void premain(String args, Instrumentation inst) {\n   new AgentBuilder.Default()\n           .disableClassFormatChanges()\n           .type(new RawMatcher() {\n               @Override\n               public boolean matches(TypeDescription td, ClassLoader cl, JavaModule m, Class<?> cbr, ProtectionDomain pd) {\n                   try {\n                       final String name = \"org.springframework.http.client.AbstractClientHttpRequest\";\n                       final Class<?> c = cl.loadClass(name);\n                       return isSubTypeOf(c).matches(td);\n                   } catch (Exception e) {\n                       return false;\n                   }\n               }\n           })\n           .transform(new ForAdvice().advice(named(\"executeInternal\"), Probe.class.getName()))\n           .installOn(inst);\n}\n\nHere is the more details.\n\nI'm not sure this is the best way to do that, but it works now.\nAs you see, i had wrote a new RawMatcher for matching sub type of AbstractClientHttpRequest. Is there another convenience for isSubTypeOf(\"org.springframework.http.client.AbstractClientHttpRequest\")?\n. Thank you so much.. ",
    "Simonfld": "the LogIntegerceptor  , cat not Sytem.out the log ,  and I use wrong??. please help me ..... thanks very much! I have resolevd it.   You're so kind.. ",
    "glamarre360": "In terms of code I have an agent builder that apply transformers like that:\njava\nagentBuilder = agentBuilder\n    .type(transformer.getMatcher())\n    .transform(transformer.getTransformer())\n    .asDecorator();\nand then install it on the instrumentation with agentBuilder.installOn(instrumentation);\nThe get transformer code look like that:\n```java\npublic AgentBuilder.Transformer getTransformer() {\n    return new AgentBuilder.Transformer() {\n    @Override\n    public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader) {\n        //This is where I need to change the modifiers of a specific method\n        return builder;\n    }\n};\n\n}\n```. I see that transformer can probably do what i want but how do I apply this transformer on a method because the agent builder apply it on a type.. I have found the way to apply it on a field but for a method it seems like I need to redefine it to ba able to apply a transformer to it. Am I correct?. I have seen the MethodVisitor but I dont quite understand how to change the modifiers with it.. The Method I want to intercept is Final and i want to remove that Final modifiers on it so I can redefine it in a class I generate at runtime. But any intercept on the method wont work because its final so i cant change the modifiers?. I've finally succeed in applying the #107 solution but in my use case my super call takes parameters and i don't see how to call the super with parameters in my interceptor.. ",
    "cliviu": "Thanks, I got now the trick with delegation to the field :-). Hi, thanks again for your hints. I have the changes that you have suggested and the performance improved but is still two times slower as by directly instantiating the objects. Can you please shortly look at https://github.com/serenity-bdd/serenity-core/blob/master/serenity-rest-assured/src/main/java/net/serenitybdd/rest/utils/RestSpecificationFactory.java to check is this is what you meant with your advices or if there is any other possible improvement that you see ?  Thanks a lot !. Thanks ! Reusing the constructors already brought some extra seconds. Unfortunately I was not able to follow you at avoiding the reflective call part. How should I bring the MethodCall in ? How to use MyFactory  to create new instances ?. Hi, Thanks for your answer. I've done the changes as you suggested but still no big improvement. Are there any performance penalties when invoking methods of instrumented objects ? \nRestSpecificationFactory.zip\nI attached the file with the changes. \nBy making a performance test, the test with the instrumented objects finished in 3 minutes 30 secs in comparison with the test without instrumentation which finished in 1 minute 50 secs.\n. I have found some problem somewhere else in the code by profiling. Nevertheless your performance improvements advices were very important and helped me a lot. Thank you very much for you support !  Byte Buddy rocks :-). ",
    "juaby": "maybe like javasist? CtMethod.make(methodSetDef.toString(), mCtc);\nbytebuddy how to use string join method body to load?. ",
    "LaughingVzr": "Thanks!I will try the first way.. I have use the different classloader solved this problem.. ",
    "gunlee01": "Hi. @raphw \nJava 9. It's very unhappy news. \nI saw your mail threads about lambda expression implementation.\nI think that java must provide useful way to instrument lambda expression.\nGood job.. ",
    "Kevin-Codes": "Hopefully this is sufficient, just say if u need more: \nMain class: https://gyazo.com/979b1b1d55d6fca6fe97b39844b89776\nManifest: https://gyazo.com/19e6619d6e2ac8db096556eb54bf46dd\nVM Arguments: https://gyazo.com/4621c1b44a5f527842a5dd8740be5144\nand its executed as HelloTimed.sayHello();\n. ",
    "basu76": "I also tried it using Advice (instead of Interceptor), but no luck. I get the same exception. \ntry {\n            new AgentBuilder.Default()\n                    .type(named(\"org.eclipse.jetty.servlet.ServletHandler\"))\n                    .transform(\n                    new AgentBuilder.Transformer.ForAdvice()\n                            .include(JettyHandlerAdvice.class.getClassLoader())\n                            .advice(named(\"addFilterWithMapping\"),JettyHandlerAdvice.class.getName())\n                    )\n                    .installOn(instrumentation);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\nAdvice \n```\npublic class JettyHandlerAdvice {\n@Advice.OnMethodEnter\nprivate static void before(@Advice.AllArguments Object[] args,  @Advice.Origin(\"#m\") String methodName, @Advice.This Object thiz) {\n    try {\n        Method filterWithMappingMethod = thiz.getClass().getMethod(\"addFilterWithMapping\", Class.class, String.class, EnumSet.class);\n        filterWithMappingMethod.invoke(thiz, XYZFilter.class, \"/*\", EnumSet.of(javax.servlet.DispatcherType.REQUEST));\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n\n}\n```\njava.lang.NoClassDefFoundError: javax/servlet/Filter. Hi Rafael,\nThank you. I figured a way to get around this, though not neat.  This is something related to class loading and I am not able to figure it out.\nGet this exception now. The reason I am suspecting this is wrt classloader is - this had worked with aspectj weaver in the past. I am looking at using byte-buddy as weaving is painful with OSGI\njava.lang.illegalstateexception com.foo.XYZFilter is not a javax.servlet.Filter. I have used this - new AgentBuilder.Transformer.ForAdvice() within transform call. Code pretty much looks like the one in the first post of this thread. \nI am unable to get full stack trace for this as the other code is just printing this one line. java.lang.IllegalStateException: class com.foo.XYZFilter is not a javax.servlet.Filter. \nHere is what I have observed, with multiple cases (tried other cases, which does not involve servlet filters).\nThe class file is accessible (for eg : javax.servlet.Filter to read and use methods.). If I want to create an instance based of it or want to create an instance of a concrete class, it throws java.lang.NoClassDefFoundError. Once I include the jar file ClassDefFoundError goes away , but the other one surfaces. Including the jar files won't be practical as there will be a lot of these. All of these are available to the JVM as it is part of the product base, I am instrumenting against.\nIn the Advice, I have methods that refer to this same class and print out values - it works perfectly fine, without including the jar file.\nOnce I want to create an instance of this class, then I get NoClassDefFoundError. What could I do to overcome this ?\nthank you. ",
    "GotoFinal": "After some small debug, seems that oracle blocked attach for this same VM by default.... and there need to be special flag to allow this.\nhttp://jigsaw-dev.1059479.n5.nabble.com/Disallowing-the-dynamic-loading-of-agents-by-default-revised-td5716181i20.html\n// class HotSpotVirtualMachine\n```java\n    private static final boolean ALLOW_ATTACH_SELF;\n// some code\n    static {\n        String s = VM.getSavedProperty(\"jdk.attach.allowAttachSelf\");\n        ALLOW_ATTACH_SELF = (s != null) && !\"false\".equals(s);\n    }\n    // some code\n// inside constructor\n    if (!ALLOW_ATTACH_SELF && (pid == 0 || pid == CURRENT_PID)) {\n        throw new IOException(\"Can not attach to current VM\");\n    }\n\n```\nWith dirty hack this can be resolved using unsafe hack to access this saved properties object in jdk.internal.misc.VM#savedProps\n```java\n    static\n    {\n            Constructor unsafeConstructor = Unsafe.class.getDeclaredConstructor();\n            unsafeConstructor.setAccessible(true);\n            unsafe = unsafeConstructor.newInstance();\n            constructorModifiers = Constructor.class.getDeclaredField(\"modifiers\");\n            constructorModifiersOffset = unsafe.objectFieldOffset(constructorModifiers);\n            methodModifiers = Method.class.getDeclaredField(\"modifiers\");\n            methodModifiersOffset = unsafe.objectFieldOffset(methodModifiers);\n            fieldModifiers = Field.class.getDeclaredField(\"modifiers\");\n            fieldModifiersOffset = unsafe.objectFieldOffset(fieldModifiers);\n            setAccessible = AccessibleObject.class.getDeclaredMethod(\"setAccessible0\", boolean.class);\n            setForceAccessible(setAccessible);\n    }\n    private static boolean setForceAccessible(AccessibleObject accessibleObject)\n    {\n        try\n        {\n            if (accessibleObject instanceof Constructor)\n            {\n                Constructor<?> object = (Constructor<?>) accessibleObject;\n                unsafe.getAndSetInt(object, constructorModifiersOffset, addPublicModifier(object.getModifiers()));\n                return true;\n            }\n            if (accessibleObject instanceof Method)\n            {\n                Method object = (Method) accessibleObject;\n                unsafe.getAndSetInt(object, methodModifiersOffset, addPublicModifier(object.getModifiers()));\n                return true;\n            }\n            if (accessibleObject instanceof Field)\n            {\n                Field object = (Field) accessibleObject;\n                unsafe.getAndSetInt(object, fieldModifiersOffset, addPublicModifier(object.getModifiers()));\n                return true;\n            }\n            return false;\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n            return false;\n        }\n    }\nprivate static int addPublicModifier(int mod)\n{\n    mod &= ~ (Modifier.PRIVATE);\n    mod &= ~ (Modifier.PROTECTED);\n    mod |= (Modifier.PUBLIC);\n    return mod;\n}\n\n```\nand setAccessible can be used to get access to any other place without access checks.\nBut this is very dirty hack... so probably people will just need to use that flag. Djdk.attach.allowAttachSelf=oracle likes to break stuff for us\nSo if you agree then you can just close issue.. @raphw \nbut this unsafe hack isn't perfect too, if other code will load HotSpotVirtualMachine before you will change this flag it will fail ;/\nYou might try to use other VM to attach agent and remove that check in HotSpotVirtualMachine so then you can again use it from this same VM. (I did not test if that will work). @raphw Windows 10. (Version 10.0.16299.19)\nAbout JRE, it should work fine on JRE I think, in JRE 8 you could run byte buddy agent with manually provided tools.jar and added attach.dll to command line or via reflections directly to class loader - ofc you need to choose valid lib/tools for each system etc, but it works fine. So something like this should be possible in JRE 9 too. By somehow loading jdk.attach.jmod (I think this is the only one missing from jre?) and that attach library, but not sure how to do that yet. (like I said, it works perfectly fine in JRE 8, you just need to add that libraries to your .jar or download them on startup). @raphw \n\"C:\\Program Files\\Java\\jdk-9\\bin\\java.exe\" -cp C:\\Users\\Admin\\AppData\\Local\\Temp\\byteBuddyAttacher13896466634965179790.jar net.bytebuddy.agent.Attacher com.sun.tools.attach.VirtualMachine 5488 C:\\Users\\Admin\\AppData\\Local\\Temp\\byteBuddyAgent11878628151824075180.jar\nAnd like I said, output is empty:\nhttps://i.imgur.com/eZ1wpeX.png\nhttps://github.com/raphw/byte-buddy/blob/master/byte-buddy-agent/src/main/java/net/bytebuddy/agent/Attacher.java#L56 ugh, that would explain empty output. @raphw  I think that it should still print that stractrace and bytebuddy should read it if process failed, as now it is just hard to debug.\noh...\nhttps://github.com/raphw/byte-buddy/blob/master/byte-buddy-agent/src/main/java/net/bytebuddy/agent/Attacher.java#L45\nhere\nThere are 3 arguments, vm attach class, process id and path, but it is trying to check 4th one.\njava.lang.ArrayIndexOutOfBoundsException: 3\n    at net.bytebuddy.agent.Attacher.main(Attacher.java:45)\nSo just bad args.length check, probably typo?. @raphw it does, as when 3 args are provided args.length < 3 -> 3 < 3 -> false, so it does second side of OR, and then it fails as it want to fetch 4th element: args[3]\n(args.length < 3 || args[3].isEmpty()). @raphw seems to works fine, returned instrumentation instance on jdk 9. @raphw also, maybe some argument can be used to provide information if stacktrace should be printed/ignored/saved to some .log file, it would make debugging simple while default behavior will be still this same.. @raphw \nAlso about\n\nIf it was possible to include the attachment module in a JRE, this would be possible but I have never tried that.\n\njava\n// this reflection hack can be replaced with -Djava.library.path starup argument\nSystem.setProperty(\"java.library.path\", System.getProperty(\"java.library.path\") + \";B:\\\\Java\\\\tools\\\\j8\"); // path to where attach.dll is\nField fieldSysPath = ClassLoader.class.getDeclaredField(\"sys_paths\");\nfieldSysPath.setAccessible(true);\nfieldSysPath.set(null, null);\nFile toolsJar = new File(\"B:\\\\Java\\\\tools\\\\j8\\\\tools-min.jar\");\nInstrumentation instrumentation = ByteBuddyAgent.install(\n    () -> {\n        try {\n            return Accessor.Simple.of(new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, ClassLoader.getSystemClassLoader()), toolsJar);\n        }\n        catch (MalformedURLException e) { throw new InternalError(\"Can't load tools\"); }\n    });\nSystem.out.println(instrumentation);\nAnd it works fine on JRE\nWhere tools.jar are by default in jdk8/bin/tools.jar and attach.dll (on windows) is in jdk8/jre/bin/attach.dll\nAlso tools.jar are pretty big 17MB, and different for each system, but they can be much smaller - as only sun\\tools\\attach\\ and com\\sun\\tools\\attach\\ packages are needed, and only one service: com.sun.tools.attach.spi.AttachProvider\nThen whole tools.jar is just 35KB, and some classes can be shared between systems too.\nSo something like this can be used to provide instrumentation on JRE - but for library it would require multiple versions for multiple JRE versions are systems. But it should be possible to use this same tools/attach lib for java 6/7/8, I didn't test that tho.\nBut I can't do this same for JRE 9 yet, as now there are that modules... and even if I try to run custom Attacher with manually provided modules for attach (only jdk.attach module should be needed, but it also depend on some jdk.internal.jvmstat module for unknown for me reason) then it fails with hash mismatch - so it should be possible if I would find a way to define module manually, but this is much more work to do, and probably some strong reflections/unsafe (should be possible to prepare that module once tho).\nThe problem is with AttacherProvider as no providers are added after loading all needed methods, probably because it is looking for them in different class loader, I was able to get implementation of it manually, but module rules are block usage of it.\nSo maybe you know something more about java 9 and how it can be done.\nAlso you can try to use that to provide additional attach metod in byte-buddy-agent that will be able to work even on JRE ;). ",
    "thekingnothing": "Thank you for good news. I'll start implement code transformers with using version from master. \nAbout call to mock repository. Here examples from current Javassist version\nReplacing call to constructor \n```\n    String code = \"Object instance =\" +\n                      MockGateway.class.getName() +\n                      \".newInstanceCall($type,$args,$sig);\" +\n                      \"if(instance != \" + MockGateway.class.getName() + \".PROCEED) {\" +\n                      \" if(instance instanceof java.lang.reflect.Constructor) {\"\n                      +\n                      \"     $_ = ($r) sun.reflect.ReflectionFactory.getReflectionFactory().newConstructorForSerialization($type, java.lang.Object.class.getDeclaredConstructor(null)).newInstance(null);\"\n\n```\nWhere \n$type- java.lang.Class represent result class after being instrumented\n$arg - array of actual method/constructor arguments \n$sig - array of java.lang.Class method/constructor parameters types. \nThese parameters are used to find mock object and mock invocation. \nAlso, in case of method return parameter is used to cast mock result to required class. \nfull source. I've faced with following issue: in old implementation  when a new constructor with specific parameters is added to a class, the constructor is called default constructor of a super class. If default constructor is not accessible, then a new constructor also is added to supper class recursively. \nI don't have idea how to implement this with ByteBuddy. \nI have chain of transformers, where each transformer is responsible for a small part of class instrument: remove modifier, set modifier, add constructor and so on. \nWhen class loader loads a class, then class loader looks for class description specific to framework (CtClass in Javassist case and TypeDescription) create wrapper (for ByteBuddy a new Builder is created) and send it to chain of transformer. \nJavassist allows to get super class when it's required and modify it. Whole classes hierarchy will be rebuilt later. As I understand, there is no way to do same thing with ByteBuddy. Any thoughts? . I think, better to add one more set of methods to ModifierAdjustment to enable working with constructor. Methods withMethodModifiers(...) ignore constructor, because matchers compare pattern with actual name. I found the following ways to change constructor modifier, when I don't have loaded class: \n- use ElementMatchers.any()\n- filter method typeDefinitions().getDeclaredMethods() to find constructor by internal name and use ElementMatchers.any()\n- implement custom ClassVisitor \n```\n    private static class ConstructorModifiersClassVisitor extends ClassVisitor {\n    private final Visibility visibility;\n\n    private ConstructorModifiersClassVisitor(final ClassVisitor classVisitor, final Visibility visibility) {\n        super(Opcodes.ASM5, classVisitor);\n        this.visibility = visibility;\n    }\n\n    @Override\n    public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, String signature, String[] exception) {\n        if (MethodDescription.CONSTRUCTOR_INTERNAL_NAME.equals(internalName)) {\n            modifiers = (modifiers & ~visibility.getRange()) | visibility.getMask();\n        }\n        return super.visitMethod(modifiers, internalName, descriptor, signature, exception);\n    }\n}\n\n```. \nNope, I missed this matcher. I'll use it.\nOn 1 May 2017, at 22:16, Rafael Winterhalter notifications@github.com<mailto:notifications@github.com> wrote:\nDid you look at the isConstructor() matcher for doing this? I will look into improving this!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHubhttps://github.com/raphw/byte-buddy/issues/299#issuecomment-298421039, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AMkKAIuzSBxv-O4uqQoNBXxo5FBMQuJkks5r1j2jgaJpZM4NIzQg.\n. I was looking for such kind of matcher, somehow I missed it. But I agree that, for Java is more conventional have separate methods in API for constructors and  methods. \nI'd like to suggest one more changes in API . As I see, now it possible only to set a modifiers for method/field/type. Sometime it's required to modify existed modifier. What do you think about this?  . I mean that if for example I'd like to remove final modifier from all fields then I have to write something like this\nnew ModifierAdjustment()\n    .withFieldModifiers(isTransient(), FieldManifestation.TRANSIENT)\n    .withFieldModifiers(isVolatile(), FieldManifestation.VOLATILE);\nMaybe, it will be better to write something like this \nnew ModifierAdjustment(). withFieldModifiers(new Resolver(){\n         public int resolve(int modifiers) {\n               return modifiers ^ FieldManifestation.FINAL.getMask();\n         }\n   });. But if this case all other modifier will be removed also and for example this test fails \n```\n@Test\n    public void should_remove_only_final_modifier_but_keep_transient() {\n    Class<? extends SupportClasses> aClass = new ByteBuddy()\n                                                 .redefine(SupportClasses.class)\n                                                 .visit(new ModifierAdjustment().withFieldModifiers(ElementMatchers.<InDefinedShape>isFinal(), FieldManifestation.PLAIN))\n                                                 .make()\n                                                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, Default.WRAPPER)\n                                                 .getLoaded();\n\n    Field finalTransientStaticField = WhiteboxImpl.getField(aClass, \"finalTransientField\");\n\n    assertThat(Modifier.isTransient(finalTransientStaticField.getModifiers())).isTrue();\n\n}\n\n```\n```\npublic static class SupportClasses {\n        private static final Object finalStaticField = new Object();\n        private transient final Object finalTransientField = new Object();\n  }\n```. \nAre you going to fix it in near future or better implement workaround on my side?\nOn 3 May 2017, at 12:53, Rafael Winterhalter notifications@github.com<mailto:notifications@github.com> wrote:\nThat is actually a bug in Byte Buddy where the transient modifier is wrongfully added to the final/volatile family. Normally, a ModifierContributor should describe what modifiers it conflicts with (a final volatile field is for example forbidden).\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHubhttps://github.com/raphw/byte-buddy/issues/299#issuecomment-298879466, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AMkKALTTu4IpvbASrnDZ5MVt5dwAerzIks5r2FyxgaJpZM4NIzQg.\n. > I will push it onto master tonight. I will release a new version once I implemented the mentioned support for MemberSubstitution.\nThank you for such quick fix! For me it's okay right now work with master.\n\nI did all other changes but I am still need to extend the API of the MemberSubstitution to allow replacing method calls with method consuming different arguments. I am still uncertain if I should go for an explicit API such as .replaceBy(method).replacedMethod().allArgumentsAsArray().this() or a target-site API where all parameters are annotated to indicate their value. Any thoughts?\n\nSorry, I misses it before. My thoughts that, for library developers, like me, better approach with allArgumentsAsArray() and have access to an array of arguments and method parameter types. \nBut for other developers, preferable way to have target-site API where all parameters are annotated like in Spring/Camel and other popular libraries.  \nBy the way, I have question about bridge methods and handling the following case in ByteBuddy. If in Javaasist I instrument SubClass and insert code at the beginning of SubClass.sayYes(SomeInterface s) then variable $sign contains [Object.class]. As result, mocking with Mockito matchers like when(subClass.sayYes(any(SomeInterface.class))).thenCallRealMethod(); is failed, because PowerMock cannot find suitable method with required signature.  Can ByteBuddy provide correct parameter type in this case? May it possible to provide link to original method? \n```\npublic class SuperClass {\n    public String sayYes(T o){\n        return \"Yes!\";\n    }\npublic Number calculate(Integer i){\n    return i + 10;\n}\n\n}\npublic class SubClass extends SuperClass{\n@Override\npublic String sayYes(SomeInterface s) {\n    return \"Yes, \" + s;\n}\n\n@Override\npublic Integer calculate(Integer i) {\n    return i + 10;\n}\n\n}\n``` . @raphw did you find a time to add API for removing annotation? . It doesn't work for me, either with rebase nor with redefine\nI tried the following: \n```\n    private ForDeclaredMethods instanceMethods() {\n        return Advice.withCustomMapping()\n                     .bind(MockMethodAdvice.Identifier.class, identifier)\n                     .to(MockMethodAdvice.class)\n                     .on(\n                         isMethod().and(\n                             not(\n                                 ElementMatchers.isStatic().or(ElementMatchers.isSynthetic())\n                             )\n                         )\n                     );\n    }\n```\nAnd a test is falling \n```\njava.lang.UnsatisfiedLinkError: powermock.test.support.MainMockTransformerTestSupport$NativeMethodsTestClass.nativeReturnMethod(Ljava/lang/String;)Ljava/lang/String;\nat powermock.test.support.MainMockTransformerTestSupport$NativeMethodsTestClass.nativeReturnMethod(Native Method)\n\n```\nI committed the code to branch 2.x/powermock-byte-buddy-native, so you may try to debug. \nTest: org.powermock.core.transformers.NativeMethodsMockTransformerTest \nClass: org.powermock.core.transformers.bytebuddy.MethodMockTransformer\nChange from rebase to redefine or vice verse you may in this method \norg.powermock.core.classloader.bytebuddy.ByteBuddyMockClassLoader#createByteBuddyBuilder. Hi, I have finally find a time to continue work on it. I replaced an advice to using .method(...).intercept(...). Now, tests are falling with java.lang.NoClassDefFoundError for auxiliary's classes in case if the class is loaded by PowerMockClassLoader when a native method is called with reflection. Could you guide me where to look? \n\nAlternatively, you can redefine the call sites of such methods. For this, I plan to extend the MemberSubstitution component for what I did not have the time yet.\n\nI was thinking about the approach. PowerMock mocks constructor in such way. But it will confuse users, instead preparing for test a class which you want to mock, you will have to prepare a class which is used. It's also not good, because a class under test will be modified. I want to minimise change in a class which is being tested. . Thank you for help. I guess the issue due to not standard using ByteBuddy. I use it as wrapper on ASM within class loading operation. I modify bytecode of a class and then I get bytes to define a new class in the class loader. I\u2019ll look at Injector\nBest regrads,\nArthur Zagretdinov\nOn 2 Dec 2017, at 20:33, Rafael Winterhalter notifications@github.com<mailto:notifications@github.com> wrote:\nAbout the auxiliary classes. Byte Buddy typically injects the auxiliary classes before the instrumented type to avoid exactly this. Byte Buddy offers an Injector to push a class file into some class loader. I assume that you have to do something in this direction, too?\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHubhttps://nam02.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fraphw%2Fbyte-buddy%2Fissues%2F358%23issuecomment-348714503&data=02%7C01%7Ca.zagretdinov%40outlook.com%7Caf5ff3384bcf402c0ddb08d539bb82a5%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636478399861413559&sdata=DBoxzEuidGufic2rqsBs%2Fq5f7TNbP7AdBtVnKffdw8E%3D&reserved=0, or mute the threadhttps://nam02.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAMkKAG6LUtSs6sTXyapwcaeLNNbEIGPjks5s8aXwgaJpZM4QCVu4&data=02%7C01%7Ca.zagretdinov%40outlook.com%7Caf5ff3384bcf402c0ddb08d539bb82a5%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636478399861413559&sdata=tek%2BF7wVyLlF5oZ8whbXY%2BedFKGJ05zXjfoD9frQ0kc%3D&reserved=0.\n. I resolved the issue with using ClassLoadingStrategy and defining all classes what have to be loaded. I'm only doubting that loading and the get byte to define a class is a good idea. It was done for comb ability with current solution with using Javassist.\nbytebuddyAfterTransformation\n                   .make()\n                   .load(this, new MockClassLoadingStrategy(protectionDomain))\n                   .getBytes()\n```\nprivate class MockClassLoadingStrategy implements ClassLoadingStrategy {\n        private final ProtectionDomain protectionDomain;\n    private MockClassLoadingStrategy(final ProtectionDomain protectionDomain) {\n        this.protectionDomain = protectionDomain;\n    }\n\n    @Override\n    public Map<TypeDescription, Class<?>> load(final ByteBuddyMockClassLoader classLoader,\n                                               final Map<TypeDescription, byte[]> types) {\n        final Map<TypeDescription, Class<?>> result = new HashMap<TypeDescription, Class<?>>();\n\n        for (Entry<TypeDescription, byte[]> entry : types.entrySet()) {\n            final TypeDescription typeDescription = entry.getKey();\n            final Class<?> loaded = defineClass(typeDescription.getName(), protectionDomain, entry.getValue());\n            result.put(typeDescription, loaded);\n        }\n\n        return result;\n    }\n}\n\n```. Yep, of course. In the example I have reproduced the issue and approach how it works in PowerMock.\n```\nBuilder builder = new ByteBuddy()\n        .rebase(\n        typeDefinition,\n        ForClassLoader.ofClassPath()\n        );\n    for (Transformer transformer : transformers) {\n    builder = transformer.transform(builder);\n    }\n\n```\nAll other transformation in chain works fine.\nBest Regards,\nArthur Zagretdinov\nOn 27 May 2018, at 15:10, Rafael Winterhalter notifications@github.com<mailto:notifications@github.com> wrote:\nThe builders are immutable, do you assign the builder to override the old reference in your code?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://nam01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fraphw%2Fbyte-buddy%2Fissues%2F478%23issuecomment-392333750&data=02%7C01%7C%7Cc742c0e839a74ad3b0dd08d5c3db9921%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636630270282217460&sdata=pDhkoFnH4I0Va75b%2FgFYd2rTCU0XyMcGxl3KTpbEmIc%3D&reserved=0, or mute the threadhttps://nam01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAMkKAIW_Fl_eYVYqRW0o1HJ64KtwWmc4ks5t2rPTgaJpZM4UO6JA&data=02%7C01%7C%7Cc742c0e839a74ad3b0dd08d5c3db9921%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636630270282217460&sdata=fdk6p6gUAqkLcr9jIW50wqDUmBNBuA4j4hFZY3qReA0%3D&reserved=0.\n. Thank you for clarification. Yeah, I agree that it's not behaviour that you expect, however, now I know about it and I will keep in mind. Anyway, I already implemented the approach that defer constructor is not created for a test class and modifier is not changed also. . ",
    "wreulicke": "Thanks, @raphw :). ",
    "roeltje25": "great. glad to have been of help. Any rough estimate on when the new release would come? I need to figure out if I should work around the issue or just wait for the new release. ",
    "sirvaulterscoff": "I've uploaded test cases here https://github.com/sirvaulterscoff/bytebuddy-301\nIm realy frustrated cause i failed to reproduce the problem inside unit tests. Though unit-test also produces an error. Any way:\nmvn install -Pagent creates agent jar and runs executable jar with agent. This clearly reproduces my case\nmvn test fails with java.lang.ClassFormatError: Illegal field modifiers . Thanks for commenting on issue, but i don't actualy see your point about StackOverflow - why endless-loop happening in my case. Moreover, if i remove Base from  Outer -> Inner -> Abstract -> Base hierarchy problem vanishes. To my mind,  Outer -> Inner -> Abstract  is more than enough to introduce enless-lopping if that was the case. Sorry, forgot to mention, that provided solution works perfectly, was interested in detailed problem description though.\nThank you for a very detailed description.. ",
    "rDarge": "I haven't tried that, but I have tried commenting out my new AgentBuilder() code just leaving my System.out.println call (with no method delegations) to ensure that the agent was loading, and I still get the same error. \nEdit: Changed my function to use Advice instead as shown below, still getting the same exception:\npublic static void premain(String arg, Instrumentation instrumentation) {\n        System.out.println(\"Test\");\n        new AgentBuilder.Default()\n                .type(ElementMatchers.isSubTypeOf(Game.class))\n                .transform((builder, typeDescription, classloader, module) -> builder.method(ElementMatchers.any())\n                        .intercept(Advice.to(GameInterceptor.class)))\n            .installOn(instrumentation);\n    }. I think I figured it out - I'm using the following gradle code to build my agent's JAR file:\n```\ntask fatJar(type: Jar) {\n    zip64 true\n    archiveName = \"${rootProject.name}-trace-agent.jar\"\n    manifest {\n        attributes(\n                'Premain-Class': 'com.adventureRancher.trace.TraceAgent',\n                'Boot-Class-Path': \"/apache-tomcat-8.5.11/bin/bootstrap.jar /apache-tomcat-8.5.11/bin/tomcat-juli.jar ${rootProject.name}-trace-agent.jar\",\n                'Can-Redefine-Classes': 'true',\n                'Can-Retransform-Classes': 'true',\n                'Can-Set-Native-Method-Prefix': 'true',\n                'Implementation-Title': \"ClassLogger\",\n                'Implementation-Version': rootProject.version\n        )\n    }\nfrom {\n\n//        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }\n    } with jar\n}\n```\nThe line I commented out was pulling in some necessary dependencies for my interceptor, particularly my Game class and my SLF4J libraries. Unfortunately, it also pulled in some of the Tomcat libraries including MBeanUtils, which is probably why Tomcat cannot resolve the ClassLoader normally in it's native code.\nI'm not sure how to pare down the configurations quite yet, but I'll be looking into that more next.. ",
    "DiabolusExMachina": "Yes this problem is gone. Thank you!\nHowever my build is still fails because some of the child projects do not have Unit Tests and I got this error: \n\n[ERROR] Failed to execute goal net.bytebuddy:byte-buddy-maven-plugin:1.7.1-SNAPSHOT:transform-test (default) on project oraserv_account: Target location does not exist or is no directory: path/to/non/existing/test-classes/folder/of/test-classes -> [Help 1]\n\nDo you think a warning that nothing can be transformed would be enough or do you want the build to break in such cases? . Great thanks again!. Yes. It works as expected! . So I had a look at the code and it' s not obvious for me how to implement this.  You really seem to like Enums btw. :wink:\nSo either I have to Copy Paste some code of the EntryPoint.Default Enum or I refactor the EntryPoint.Default Enum itself to use some kind of factory to create the ByteBuddy instance. And this factory would have a method do set the desired Java Version from outside. \nI like the second approach more but then the PR will affect the byte-buddy-dep module as well as the byte-buddy-maven-plugin. What is your opinion? \n. Sure. I will have a look. I've never used Gradle before but I found this \nhttps://stackoverflow.com/questions/28061044/how-to-check-java-version-when-running-gradle. I tried but it seems not to work for my usecase. I think the problem is that ${maven.compiler.target} is set in a somewhere in a parent of the project that uses the byte-buddy-maven-plugin. \nI will test more tomorrow and try to create a PR to fix this issue. \nBtw. I think instead of changing the API of EntryPoint we could also use a SPI https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html to change the default class version. What's your opinion on that? . Hello again. I have working solution. I will create a PR. \nBut it will break the ByteBuddyMojo Test and I'm currently not sure how to fix it. . I think the format should look ok now. . ",
    "joebandenburg": "Hi @raphw,\nThanks for the quick reply. I'm trying to understand your instructions for working around the problem. Could you provide a code example of what you are suggesting?\nThis is what I've got so far:\njava\nnew ByteBuddy()\n    .makeInterface()\n    .defineField(name + \"$field\", returnType, Visibility.PUBLIC, Ownership.STATIC, FieldManifestation.FINAL)\n        .initializer(Advice.of(...))\n    .defineMethod(name, returnType, Visibility.PUBLIC)\n        .intercept(FieldAccessor.ofField(name + \"$field\"));\n    .make();\nAfter reading the documentation for Advice, I'm not sure how to apply it to solve my problem. I'm also unsure of what you mean \"intercepting isTypeInitializer\".. ",
    "KnutHaraldR": "From what I remember, this was an issue with Powermock and using certain names like start/end, if you named your methods the same as internal Powermock names, it got this error.. ",
    "qdolan": "No problem.. saves me having to wait for another release before I can push my changes that use it.. ",
    "paulconnell": "javap -p Foo.class gives an entry like this:\nprivate static ? extends com.whatever.Foor$Bar lambda$0();\n. I don't understand why '? extends' is part of it. There's not inheritence, nor generics involved.\nAspectJ is certainly something I'm keeping in mind. Not sure how to prove/disprove that quite yet.. I just removed the 'compile with AspectJ' build step from this package. And now:\nprivate static com.whatever.Foo$Bar lambda$new$0();\nThe type now looks sane, and the lambda has a different name.\nAside from the possibility that this is a bug in AspectJ (it might just be a weird behavior as part of how it internally operates, I'm no expert on it!), can you imagine a scenario where - even without AspectJ - a class might have a method of the form:\nprivate static ? extends com.whatever.Foor$Bar lambda$0();\nWhat would cause that? Would it fall through the same code path and fail in the same way?. I have another possibly related example, where without AspectJ compilation I have a method with a name of the sort (from 'javap -p')\nprivate static java.lang.Object lambda$null$0(com.whatever.SomeSupplier, java.lang.String) throws java.lang.Exception;\nwhich after AspectJ compilation becomes:\nprivate static T lambda$0(com.whatever.SomeSupplier, java.lang.String) throws java.lang.Exception\nThe problem being the return type being a literal 'T'. The methods which resolve TypeDescriptions don't like that either. I think it dies in a different place than in the original issue I raised, but this looks like a family of problems.. This issue in the AspectJ tracker has some similar characteristics\nhttps://bugs.eclipse.org/bugs/show_bug.cgi?id=520135. I'm thinking along the same lines.\nI'm going to try and work on getting a repro case.\nLet's assume ByteBuddy is correct and AspectJ is doing something weird. Can you suggest a starting point for any workaround? Would it be possible to override the default MethodExtractor, and somehow detect these problematic signatures and fix/erase them? Something like that?. Fair point on the heuristic signature-fixer.\nSadly I cannot insist on my transformations taking priority over AspectJ - it is compile-time weaving, not runtime. AFAIK we compile with javac, and then re-compile the class files with ajc.\nWhat I now am starting to suspect is that there may be a mixture of the various parts of AspectJ (aspectjtools, aspectjweaver and whatever other jars comprise AspectJ). My theory is that somewhere there may be an older jar interfering with the build which may not be generics aware (pre Java 8).\nThe reason I say that is because if I do an isolated test, compiling a Foo.java with javac, and then transforming with a clean install of AspectJ, I can see none of the reported behaviors.\nThanks for all your suggestions and help.. I have discovered that we are using AspectJ 1.8.1 which is very old (the latest being 1.8.10)\nCompiling a trivial test case with this version of 'ajc' produces output from javap which appears problematic as per the above.\nI do not believe this is a bug in ByteBuddy, please close.\nHopefully the journey which got me to this conclusion will help someone one day when they find this issue on Google though!. ",
    "skapral": "Thank you \ud83d\udc4d . Thank you.. Hmm... Besides maven and gradle plugins there is also an agent builder, which uses Plugin instances. And it seems not right to apply this enhancement there, isn't it?. > the plugin can define a single argument constructor that accepts the Maven / Gradle logger.\nSome concerns actually:\n1. IMO injecting this stuff into a constructor is quite counterintuitive for implementors IMO.\n2. What if later there will be more stuff to add there?\nWe can, however, overcome these concerns by introducing and documenting some DI framework there, but I don't think it worth it.\nInstead, I thought of the following solution:\n1. Introduce some API named BuildContext or something. It will have one method <T> T obtain(Class<T> type), where T may be MavenLog, TypePool, etc. Implementors must give the requested item or fail fast if it is not known from the context.\n2. Add a new argument with type BuildContext to Plugin.\n3. Implement different BuildContextes for the Maven plugin, Gradle plugin, and agent builder.\nAlso, as an alternative:\n1. To introduce MavenBuildContext, GradleBuildContext, AgentBuildContext, each of them providing set of methods for gathering loggers, type pools, etc.\n2. To introduce MavenPlugin, GradlePlugin, AgentPlugin, providing the nesessary context to them.\n3. Leave Plugin as-is for backward compatibility and implement adapters from it to the newly introduced plugins.\nWhat do you think?. ",
    "diguage": "@raphw I used the HTTPS for the Chinese page, so the home page was changed to https://notes.diguage.com/byte-buddy-tutorial/. Please update the url.. ",
    "iibrahimhobekkaya": "The cause of the error is due to debug mode.. ",
    "geoand": "Thank you very much for the clarification!. You are welcome!\nOn Oct 28, 2017 23:31, \"Rafael Winterhalter\" notifications@github.com\nwrote:\nThat is so cool, thank you!\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/raphw/byte-buddy/pull/362#issuecomment-340217925, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AELBv68WBsVQJBEnQI3t_YDZaABrUM9gks5sw480gaJpZM4QJ4by\n.\n. ",
    "zliuva": "Hi @raphw, thank you very much for the fast reply and the suggestion to use a Listener.\nOutput from the Listener helped me find the real issue:\n[Byte Buddy] ERROR org.apache.http.impl.client.CloseableHttpClient [sun.misc.Launcher$AppClassLoader@18b4aac2, null, loaded=false]\njava.lang.IllegalStateException: Cannot call super (or default) method for public abstract org.apache.http.params.HttpParams org.apache.http.client.HttpClient.getParams()\n    at net.bytebuddy.implementation.SuperMethodCall$Appender.apply(SuperMethodCall.java:97)\n    at net.bytebuddy.implementation.bytecode.ByteCodeAppender$Compound.apply(ByteCodeAppender.java:134)\n...\nLike you suggested, an unrelated method getParams that was not implemented by this abstract class and the interface does not have a default method either. I guess this interrupted the process of transforming the target class before the intended target methods were transformed.\nThanks again for helping me figure this out, been bothering me for a whole day!. ",
    "IluckySi": "@raphw  If I use new ByteBuddy().with(TypeValidation.DISABLED). bytebuddy will skip validate\uff1f skip the following code\uff1fright\uff1f\n Set<TypeDescription.Generic> exceptionTypes = new HashSet<Generic>();\n                for (TypeDescription.Generic\n exceptionType : methodDescription.getExceptionTypes()) {\n                    if (!exceptionTypes.add(exceptionType)) {\n                        throw new IllegalStateException(\"Duplicate exception type \" + exceptionType + \" for \" + methodDescription);\n                    } else if (!exceptionType.accept(Generic.Visitor.Validator.EXCEPTION)) {\n                        throw new IllegalStateException(\"Illegal exception type \" + exceptionType + \" for \" + methodDescription);\n                    } else if (!exceptionType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {\n                        throw new IllegalStateException(\"Illegal type annotations on \" + exceptionType + \" for \" + methodDescription);\n                    } else if (!methodDescription.isSynthetic() && !exceptionType.asErasure().isVisibleTo(this)) {\n                        throw new IllegalStateException(\"Invisible exception type \" + exceptionType + \" for \" + methodDescription);\n                    }\n                }. OK, thank you very much, I will test it! @raphw . ",
    "henrik242": "@raphw Cool! Would you like me to create a test project, or are you good?. @raphw Here you go: https://github.com/henrik242/kotlin-bytebuddy-spock. @raphw  Any progress? :). ",
    "mibac138": "Kotlin issue for future reference. Why do you want to compare strings and then enums? I'm pretty sure comparing enums is faster.. I've now changed it so that annotations are read lazily.. ",
    "benwimpory": "Thanks for the fast feedback.  I am not redefining classes that are already loaded, I just want to add fields to classes from another module before they are loaded.\nAfter removing the disableClassFormatChanges() from the AgentBuilder I can now:\n\nDefine a field on an existing class (MyClass) with builder.defineField(\"x\", long.class)\nAdd a constructor interceptor on MyClass the that uses Field advice so I can set the new field value with: \n\npublic static class ConstructorInterceptor {\n    @Advice.OnMethodExit\n    public static void intercept(@Advice.This Object thiz, @Advice.FieldValue(value=\"x\",readOnly=false) long x) throws Exception {\n        x = 3;\n    }\n}\n\nAdd non-constructor interceptor to MyClass and access the field with:\n\n@Advice.OnMethodEnter\npublic static void intercept(@Advice.This Object thiz, @Advice.FieldValue(\"x\") long x) throws Exception {      \n        System.out.println(x);\n    }\nBUT....\n...these transforms only get applied by the agent if I transform a single type.\neg.\nThis works fine\n.type(nameEndsWith(\"MyClass\")\n .transform(....)  // define new field\n .transform(...)   // add interceptor\nbut adding a second type with transforms means it does not\n```\n  .type(nameEndsWith(\"AnotherClass\")\n  .transform(.....)\n.type(nameEndsWith(\"MyClass\")\n .transform(....)  // define new field\n .transform(...)   // add interceptor\n```\nQuestion\nWhy would a set of transforms work fine when applied in isolation, but not work if applied with other types ?  Re-ordering the transforms made no difference.\n. I have a listener registered for all events and see no errors at all.  I print a stack trace if there is an error and see nothing in the log,\nThe onTransformation() callbacks are logged and only show one class being transformed: AnotherClass.  I only apply method enter/exit advice to this class.\nWould the fact that AnotherClass creates instances of MyClass be an issue here ?  Could it be that the application of transforms to AnotherClass causes MyClass to be loaded and prevents the builder applying the transforms to MyClass as it has already been loaded ?\nTo re-iterate, both sets of types/transforms work fine if used in isolation.  It's chaining them across different types that causes an issue.\n. With both sets of type/transform applied, when I debug into the installOn() call at the very end, I can only see the last set of transforms and elementMatcher applied in the AgentBuilder$Default$Transforming transformer variable\nLooks like the first set of type/transforms are being lost by the builder before they are ever applied to the instrumenter.. I am not referencing / importing the problematic class in the interceptors or agent though so don\u2019t think my agent code is loading the type prematurely.\nEssentially I have application classes A and B and want to apply transforms to both.\nIs this supported in ByteBuddy if A depends on B ? eg. Imports it, creates an instance ?\nWill carry on debugging, but last point I got to was I could see both types and associated transforms being passed into the InstrumentationImpl class. So the AgentBuilder didn\u2019t look like it was dropping any info with the chaining.\nBen\n\nOn 4 Oct 2017, at 17:22, Rafael Winterhalter notifications@github.com wrote:\nYes, this might be an issue . If you load a type during a transformation, the type is not instrumented as it is already loaded. If you cannot see the type being logged at all, this is probably the case. What you can do would be to only reference a type within the method body which is loaded lazily. You can then use a generic type such as Object in combination with @DynamicType.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Ok great :-) I will create an example and post it for you to review.\n\nBen\n\nOn 4 Oct 2017, at 17:22, Rafael Winterhalter notifications@github.com wrote:\nYes, this might be an issue . If you load a type during a transformation, the type is not instrumented as it is already loaded. If you cannot see the type being logged at all, this is probably the case. What you can do would be to only reference a type within the method body which is loaded lazily. You can then use a generic type such as Object in combination with @DynamicType.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Ok, my bad.  I was referencing the uninstrumented class in the interceptor's method's argument - sorry!\n\n@Advice.OnMethodEnter\npublic static void entry(MyClass myclass)\n{\n    System.out.println(myClass.getMyField());\n}\nI have now removed this and replaced with Object and both classes are being transformed :-)\nI was able to use casting inside the method to still access the method as per below...\n@Advice.OnMethodEnter\npublic static void entry(Object object)\n{\n    MyClass myClass = (MyClass) object;\n    System.out.println(myClass.getMyField());\n}\nWhat does the @DynamicType add to this use case ?. Thanks for your help and quick responses. All working nicely for me now. Great library!. ",
    "albanf": "Hi, I am new to byte buddy, and I am trying to modify the value of an annotation in an agent.\nWhen you say\n\nFor now, using ASM is the easiest way of getting this done.\n\ndo you mean that it's possible to do this when transforming a class in an agent? I couldn't find any example of a transformer for that case.\nWhat I am trying to do is to transform:\n@MessageDriven(\n        activationConfig = {\n                @ActivationConfigProperty(\n                        propertyName = \"resourceAdapter\",\n                        propertyValue = \"jmsra\")\n        }\n)\npublic class MyClass {\n}\nand change the value of propertyValue\n@MessageDriven(\n        activationConfig = {\n                @ActivationConfigProperty(\n                        propertyName = \"resourceAdapter\",\n                        propertyValue = \"activemq-rar\")\n        }\n)\npublic class MyClass {\n}\nThe agent is correctly setup and processes the class:\nnew AgentBuilder.Default()\n                .type(ElementMatchers.<TypeDescription>isAnnotatedWith(MessageDriven.class))\n                .transform(new ChangeResourceAdapterTransformer())\n                .with(AgentBuilder.Listener.StreamWriting.toSystemOut())\n                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)\n                .installOn(inst);\nBut I don't know what to do in the transformer, since annotateType is creating a duplicate like mentioned before:\n```\npublic DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) {\n    return builder\n            .annotateType(AnnotationDescription.Builder.ofType(MessageDriven.class)\n                    .defineAnnotationArray(\"activationConfig\", new TypeDescription.ForLoadedType(ActivationConfigProperty.class),\n                            AnnotationDescription.Builder.ofType(ActivationConfigProperty.class)\n                                    .define(\"propertyName\", \"resourceAdapter\")\n                                    .define(\"propertyValue\", \"activemq-rar\")\n                                    .build())\n                    .build());\n}\n\n```\nThanks for your help!\n. Do you have an example of a visitor which would remove that annotation (or all annotations?). At least for some use case, where you can rebuild the whole annotation or set of annotations, that would work.. ",
    "sbabcoc": "The XML file in this PR resolves the dreaded \"Plugin execution not covered by lifecycle configuration\" error shown by M2Eclipse. See http://www.eclipse.org/m2e/documentation/m2e-execution-not-covered.html. Left unresolved, this error causes M2Eclipse to ignore the 'transform' and 'transform-test' goals, which means that classes will not get transformed when affected projects are built within Eclipse.. @CodingFabian : Thanks for the feedback, and you make an excellent point. Done!. I suppose it's possible that the 1.7.9 release is corrupted in our corporate Nexus. How would I figure this out, though? The archive itself appears to be undamaged, at least as far as 7-Zip is concerned. The 'jar' utility seems happy with it, too.. Ah! The real issue wasn't with the plugin... it was the main Byte Buddy JAR that was corrupted. I deleted this from my local repo, and everything is happy with the fresh copy Maven pulled down.. ",
    "tylerbenson": "Perhaps a suggestion then is to include some sort of notation in the javadocs to highlight when a particular matcher is expensive to make it easier to identify.\nThanks!. Ok, that's helpful, thanks.\nSemi related question... if a transformation doesn't modify the structure of the class, is there any benefit (performance or otherwise) in allowing the initial transform through without modification, adding it to a list for retransform, and modifying the class the next time it comes through?\nIt seems like this might be beneficial for matchers like hasSuperType or isAnnotatedWith where the classes to analyze are now loaded and easier to inspect.. To be clear, I'm working from the context of an AgentBuilder, so by forgoing class structure modifications the first time, I'm limited in what I can do in future retransformations. (This is something I'm ok with.) I believe I'm explicitly choosing this by defining my AgentBuilder like this:\njava\nnew AgentBuilder.Default().disableClassFormatChanges()\nCan you explain more about what you mean by a less intrusive method graph compiler?  How would I configure that?. Regarding that last point there navigate the entire type hierarchy what can be costly, does it make a difference in the speed if the class has already been loaded and thus each type is accessible from the classloader?. Cool.  Does the suppress = Throwable.class have to be added to each (enter and exit) @Advice annotation, or does registering an exception handler via withExceptionHandler on advice somehow change the default behavior?\nJust to be clear, I believe this will not cause any exception thrown by the original code to be caught, just the Advice code.. Perhaps something to do with net.bytebuddy.dynamic.loading.ClassInjector?. Is there a way for that to happen automatically, or do I need to inject each class individually?\nAre there any examples on how to do this?\nAlso, any suggestions for how to integrate this into the AgentBuilder/Advice flow?. Interesting theory.  It might be jacoco, the code coverage tool. I can try running without that next week and see if that makes a difference.. Enumerating the commands that run:\n```\n\ngradle :broken:test --dry-run\n:broken:compileJava SKIPPED\n:broken:compileGroovy SKIPPED\n:broken:processResources SKIPPED\n:broken:classes SKIPPED\n:broken:compileTestJava SKIPPED\n:broken:compileTestGroovy SKIPPED\n:broken:processTestResources SKIPPED\n:broken:testClasses SKIPPED\n:broken:test SKIPPED\n\nBUILD SUCCESSFUL in 1s\n```\nThere doesn't appear to be any code coverage tool running here.  In my main branch I have jacoco, but I removed that before submitting this issue, so no jacoco plugin here.  Maybe it's something that groovy itself is doing?. These are the classes that Intellij seems to think are on the classpath:\n\nSince this does seem isolated to a test environment, I don't mind if you want to just close this issue.  I just wasn't sure if this was indicative of a potentially thornier bug.. What is the best way to get the bytecode that you\u2019re looking for? Add an interceptor somewhere that writes it to a file?. @raphw Thanks for fixing this.  Sorry I never got around to providing the information you asked for.  This tab got lost and I forgot about it.  On the plus side, I haven't seen it since, so I think it is fixed.. Darn. Ok thanks for getting back to me.. I did not benchmark it.  I just discovered this while debugging a matching bug in my code. I understand your concern about not knowing the expense of the matcher.  I was looking at it from the perspective of isOverriddenFrom(Class<?> type) where the matcher is pretty trivial, so it seemed rather silly the way it is.  I hadn't considered more expensive cases.\nI will let you decide what should be done, and I'd be ok if you decide to just leave it as is.\nThanks for your consideration.. @raphw Is there anything else we can provide to help troubleshoot/fix this? Should we look into submitting a PR?. ",
    "lhunath": "Pretty sure I just got it off Android's SDK manager.. ",
    "uschindler": "This is the Solr workaround: https://issues.apache.org/jira/browse/SOLR-11606\nWe disable all tests using an assume if Mockito/ByteBuddy does not support the current runtime.. ",
    "huaxiaolin": "when i run your android example ,show this erro ,why ?  so i want you help me\njava.lang.NoClassDefFoundError: Failed resolution of: Lcom/android/dx/dex/DexOptions;\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at net.bytebuddy.android.AndroidClassLoadingStrategy$DexProcessor$ForSdkCompiler.makeDefault(AndroidClassLoadingStrategy.java:197)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at net.bytebuddy.android.AndroidClassLoadingStrategy$Wrapping.(AndroidClassLoadingStrategy.java:321)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at main.java.net.bytebuddy.android.test.TestActivity$StrategyCreator$Wrapping.make(TestActivity.java:183)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at main.java.net.bytebuddy.android.test.TestActivity$TestRun.onClick(TestActivity.java:135)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at android.view.View.performClick(View.java:5207)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at android.view.View$PerformClick.run(View.java:21177)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at android.os.Handler.handleCallback(Handler.java:742)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at android.os.Handler.dispatchMessage(Handler.java:95)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at android.os.Looper.loop(Looper.java:154)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at android.app.ActivityThread.main(ActivityThread.java:5527)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at java.lang.reflect.Method.invoke(Native Method)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:629)\n11-10 14:10:18.387: W/net.bytebuddy(16069): Caused by: java.lang.ClassNotFoundException: Didn't find class \"com.android.dx.dex.DexOptions\" on path: DexPathList[[zip file \"/data/app/net.bytebuddy.android.test-1/base.apk\"],nativeLibraryDirectories=[/data/app/net.bytebuddy.android.test-1/lib/arm64, /vendor/lib64, /system/lib64]]\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at java.lang.ClassLoader.loadClass(ClassLoader.java:511)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     at java.lang.ClassLoader.loadClass(ClassLoader.java:469)\n11-10 14:10:18.387: W/net.bytebuddy(16069):     ... 13 more\n11-10 14:10:18.387: W/net.bytebuddy(16069):     Suppressed: java.lang.ClassNotFoundException: com.android.dx.dex.DexOptions\n11-10 14:10:18.387: W/net.bytebuddy(16069):         at java.lang.Class.classForName(Native Method)\n11-10 14:10:18.387: W/net.bytebuddy(16069):         at java.lang.BootClassLoader.findClass(ClassLoader.java:781)\n11-10 14:10:18.387: W/net.bytebuddy(16069):         at java.lang.BootClassLoader.loadClass(ClassLoader.java:841)\n11-10 14:10:18.387: W/net.bytebuddy(16069):         at java.lang.ClassLoader.loadClass(ClassLoader.java:504)\n11-10 14:10:18.387: W/net.bytebuddy(16069):         ... 14 more\n11-10 14:10:18.387: W/net.bytebuddy(16069):     Caused by: java.lang.NoClassDefFoundError: Class not found using the boot class loader; no stack trace available. thanks ,i have resolve  this error  .. ",
    "paplorinc": "Related: http://mail.openjdk.java.net/pipermail/amber-spec-experts/2018-March/000320.html\n\nHistorically, this() or super() must be first in a constructor. This restriction was never popular, and perceived as arbitrary. There were a number of subtle reasons, including the verification of invokespecial, that contributed to this restriction.  Over the years, we've addressed these at the VM level, to the point where it becomes practical to consider lifting this restriction, not just for records, but for all constructors.. How difficult would it be to add the try-catch after the super/this calls?\nIn that case we would obviously miss the parent exceptions, but at least be able to intercept local ones.\n\nOr is it possible (as yet another backup) plan to instrument all catch blocks for exception type and walk the stack?. Hey @jpfourny, thanks, will investigate it.. @jpfourny, @raphw, thanks for the help, I've tried every combination I could think of / find, I still can't properly capture all constructor calls (e.g. new ArrayList<>()).\nHere's a simplified example:\nhttps://github.com/paplorinc/bb_examples/blob/instrument_bootstrap_constructors/src/main/java/lorinc/pap/agent/BootstrapAgent.java#L25\ni.e.\n```java\npublic static void premain(String arg, Instrumentation instrumentation) throws Exception {\n    Class interceptorClass = ConstructorInterceptor.class;\nFile temp = Files.createTempDirectory(\"tmp\").toFile();\nUsingInstrumentation.of(temp, BOOTSTRAP, instrumentation)\n    .inject(singletonMap(new ForLoadedType(interceptorClass), read(interceptorClass)));\n\nnew AgentBuilder.Default()\n    //.with(AgentBuilder.Listener.StreamWriting.toSystemError())\n    .enableBootstrapInjection(instrumentation, temp)\n    .ignore(none())\n    .type(any())\n    .transform((builder, t, c, m) -> builder.visit(to(interceptorClass).on(isConstructor())))\n    .installOn(instrumentation);\n\n}\npublic static class ConstructorInterceptor {\n    @OnMethodEnter\n    public static void enter(@Origin Executable executable) {\n        System.out.println(\"Enter \" + executable.getName());\n    }\n}\n```\nHappy new year, please let me know what else I should attempt. :)\nNote: tried https://github.com/google/allocation-instrumenter and it seems to capture everything from the boot classloader automatically, so it should at least theoretically be possible.. > There is another annotation for method delegation that would not work.\nYes, it was from Advice. Made it explicit now in https://github.com/paplorinc/bb_examples/blob/instrument_bootstrap_constructors/src/main/java/lorinc/pap/agent/BootstrapAgent.java#L69 \n\nYou can register a listener to the agent builder that prints any possible exception that might explain to you what the problem is. If you are using advice, the entire injection bit should be unnecessary.\n\nOther than the commented out //.with(AgentBuilder.Listener.StreamWriting.toSystemError()) above?\nThanks Rafael, this instrumentation business seems really difficult.... Hey @raphw,\nI've enabled retransformation, see https://github.com/paplorinc/bb_examples/blob/instrument_bootstrap_constructors/src/main/java/lorinc/pap/agent/BootstrapAgent.java#L1637, but the classes still don't show up. They don't show up in the listener either.. Thanks @raphw, I've tried with those:\njava\nnew AgentBuilder.Default()\n .disableClassFormatChanges()\n .with(AgentBuilder.Listener.StreamWriting.toSystemError())\n .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n .enableBootstrapInjection(instrumentation, temp)\n .ignore(none())\n .type(any())\n .transform((builder, t, c, m) -> builder.visit(Advice.to(ConstructorInterceptor.class).on(isConstructor())))\n .installOn(instrumentation);\n...\npublic static class ConstructorInterceptor {\n    @OnMethodEnter public static void enter(@Advice.Origin Executable executable) {\n        System.out.println(\"Enter \" + executable.getName());\n    }\n}\nNow I'm getting:\n[Byte Buddy] DISCOVERY java.util.ArrayList [null, null, loaded=true]\n[Byte Buddy] TRANSFORM java.util.ArrayList [null, null, loaded=true]\n[Byte Buddy] COMPLETE java.util.ArrayList [null, null, loaded=true]\nbut the interceptor is not called.\nWhat else should I do to enable retransformation of an already loaded type?. Wow, these are unexpected, but they seem to be working!\nThank you for your help, @raphw and @jpfourny!\nFor future reference, the code is the following:\n```java\npublic static void main(String[] args) throws Exception {\n    premain(null, ByteBuddyAgent.install());\nSystem.out.println(new ArrayList<>());\nSystem.out.println(new AbstractMap.SimpleImmutableEntry<>(\"Key\", \"Value\"));\n\n}\npublic static void premain(String arg, Instrumentation instrumentation) throws Exception {\n    Class interceptorClass = ConstructorInterceptor.class;\nFile temp = injectBootstrapClasses(instrumentation, interceptorClass);\n\nnew AgentBuilder.Default()\n    .disableClassFormatChanges()\n    //.with(Listener.StreamWriting.toSystemError())\n    .with(RedefinitionStrategy.RETRANSFORMATION)\n    .with(RedefinitionStrategy.DiscoveryStrategy.Reiterating.INSTANCE)\n    .with(InitializationStrategy.NoOp.INSTANCE)\n    .with(TypeStrategy.Default.REBASE)\n    .enableBootstrapInjection(instrumentation, temp)\n    .ignore(none())\n    .type(any())\n    .transform((builder, t, c, m) -> builder.visit(Advice.to(interceptorClass).on(isConstructor())))\n    .installOn(instrumentation);\n\ninstrumentation.retransformClasses(ArrayList.class, AbstractMap.SimpleImmutableEntry.class);\n\n}\npublic static class ConstructorInterceptor {\n    @OnMethodEnter(inline = false) public static void enter(@Advice.Origin Executable executable) {\n        if (executable.getName().startsWith(\"java.util.\")) {\n            System.out.println(\"Enter \" + executable.getName());\n        }\n    }\n}\nprivate static File injectBootstrapClasses(Instrumentation instrumentation, Class<?>... classes) throws IOException {\n    File temp = createTempDirectory(\"tmp\").toFile();\n    temp.deleteOnExit();\nMap<ForLoadedType, byte[]> types = stream(classes).collect(toMap(ForLoadedType::new, ClassFileLocator.ForClassLoader::read));\nUsingInstrumentation.of(temp, BOOTSTRAP, instrumentation).inject(types);\n\nreturn temp;\n\n}\n```. May be related to my question, too: https://github.com/raphw/byte-buddy/issues/577#issuecomment-450671944. Seems to be related to my question: https://github.com/raphw/byte-buddy/issues/577#issuecomment-450671944. ",
    "sormuras": "Build no 1 failed due to Windows \\ usages.\nBuild no 2 failed due to missing TARGET='-Pjava9'\nBuild no 3 is running.... Build no 3 failed with:\n[INFO] \n[INFO] --- findbugs-maven-plugin:3.0.5:findbugs (findbugs) @ byte-buddy-agent ---\n[INFO] Fork Value is true\n     [java] Picked up _JAVA_OPTIONS: -Xmx2048m -Xms512m\n     [java] WARNING: An illegal reflective access operation has occurred\n     [java] WARNING: Illegal reflective access by org.dom4j.io.SAXContentHandler (file:/home/travis/.m2/repository/dom4j/dom4j/1.6.1/dom4j-1.6.1.jar) to method com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser$LocatorProxy.getEncoding()\n     [java] WARNING: Please consider reporting this to the maintainers of org.dom4j.io.SAXContentHandler\n     [java] WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations\n     [java] WARNING: All illegal access operations will be denied in a future release\n     [java] Nov 16, 2017 10:00:35 AM java.util.prefs.FileSystemPreferences$1 run\n     [java] INFO: Created user preferences directory.\n     [java] Warning: Unknown version of Java\n     [java] edu.umd.cs.findbugs.JavaVersionException: Could not parse Java version string: 9. Disabling findbugs made the build no 4 \"green\". Going to cleanup the env section and shall I activate the jdk-10-ea build as well?. You're welcome!. Build fails on JDK 9 due to an error in the Byte Buddy (Gradle plugin) module:\n[...]\n[INFO] Byte Buddy (Gradle plugin) ......................... FAILURE [ 48.472 s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 02:07 min\n[INFO] Finished at: 2018-03-02T18:57:36+00:00\n[INFO] Final Memory: 75M/248M\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal codes.rafael.gradlemavenplugin:gradle-maven-plugin:1.0.10:invoke (gradle-build) on project byte-buddy-gradle-plugin: org.gradle.tooling.GradleConnectionException: Could not execute build using Gradle distribution 'file:/home/travis/build/raphw/byte-buddy/byte-buddy-gradle-plugin/gradle/4.5/gradle-4.5-bin.zip'. -> [Help 1]\n[...]. Disabled building of byte-buddy-gradle-plugin via command line option. Now, it builds on JDK 9, at least.. You're welcome!. ",
    "sdfelts": "findbugs is dead.  You will need to move to spotbugs 3.1.0 for JDK 10 support.\nThe SAXContentHandler warning is a known/tracked issue.. Better stack trace:\n                Caused by:\n                java.lang.NoSuchMethodException: sun.misc.Unsafe.defineClass(java.lang.String, [B, int, int, java.lang.C\nlassLoader, java.security.ProtectionDomain)\n                    at java.base/java.lang.Class.getMethod(Class.java:2067)\n                    at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe$Dispatcher$CreationAction.run(ClassInject\nor.java:1260)\n                    at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe$Dispatcher$CreationAction.run(ClassInject\nor.java:1248)\n                    at java.base/java.security.AccessController.doPrivileged(Native Method)\n                    at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe.(ClassInjector.java:1127)\n                    ... 27 more. This is failing in a nested call from Mockito.  I'm not sure what that code is doing.\n        at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4456)\n        at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.j\n\nava:94)\n            at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerato\nr.java:37)\n            at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerato\nr.java:34)\n            at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)\n            at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)\n            at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)\n            at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)\n            at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGener\nator.java:32)\n            at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMock\nMaker.java:71)\n            at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMake\nr.java:42)\n            at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)\n            at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)\n.... The current state is that byte-buddy doesn't work on JDK11 - there is no work-around because it's calling a method that doesn't exist.\nBy removing the JDK9 approach and using the pre-JDK9 code, the software works.\nEven if JDK11 were locked down, there would be a work-around by using JVM options to open packages.\nAt this time, that seems to be the best approach.. ",
    "natfitz": "Thanks for your quick response. We were able to work around the issue by capturing around the getInputStream, getOutputStream, and connect methods. As a result this also resolved a problem we were seeing with duplicating instrumentation on RestTemplate. . Interesting...I was able to get a decent reduction in overhead with removing some duplication of transformers like so\n```java\n   @Override\n    public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) {\n    return builder\n            .visit(Advice.to(HttpURLConnectionGetInputStreamAdvice.class)\n                    .on(ElementMatchers.named(\"getInputStream\")))\n            .visit(Advice.to(HttpURLConnectionConnectAdvice.class)\n                    .on(ElementMatchers.named(\"connect\")))\n            .visit(Advice.to(HttpURLConnectionGetOutputStreamAdvice.class)\n                    .on(ElementMatchers.named(\"getOutputStream\")));\n}\n\n``\nSo am I understanding correctly that the suggestion is to have one transformer that contains all of the.visit()` and I would reuse it across the agent builder like so\n``` java\n    AgentBuilder agentBuilder =\n            new AgentBuilder.Default()\n                .ignore(none())\n            .type(named(\"javax.servlet.http.HttpServlet\")).and(isPublic())\n                .transform(new UniversalTransformer(instrumentation))\n                .asDecorator()\n            .type(named(\"javax.servlet.RequestDispatcher\"))\n                .transform(new UniversalTransformer(instrumentation))\n                .asDecorator()\n\n```. Thanks for the help, with the changes in place I'm seeing reduction of at least 50% on start up time of my small test apps.. ",
    "theangrydev": "I was hoping there is a magic lazy TypeDefinition somewhere I could use that is interpreted as the class being built.. Thanks!. ",
    "flozano": "Ah... you are right. If I do the same by compiling java code, both methods are there. My apologies for opening this issue, many thanks for your explanation.. ",
    "SeriyBg": "I'm using java 1.8.0_112.\nYes, indeed as it's not static class, the first parameter in the constructor became the instance of the parent class.. ",
    "xiaoxinba": "If the method param include POJO class that some properties also the specific annotation, how can i get the properties' values ;\nfor example:\npublic class Person{\n    @annotation\n    private String uuid;\n    private STATE state;\n} \npublic void test\uff08Person person, @annotation String str){}\nhow can i get the method all annotation's values;\nI need invoke person class\u2018s GET method to get the annotation's value??\n. I fount that if not use ByteBuddy library, it can work well in tomcat. \nso i want to know if only ByteBuddy need bundle by Maven Shade plugin?. ",
    "julianrz": "My confusion was that this still makes T a class-level variable:\nnew ByteBuddy()\n  .makeInterface()\n  .defineMethod(\"m\", void.class, Visibility.PUBLIC)\n  .withoutCode()\n  .typeVariable(\"T\")\n  .make()\nFelt like after withoutCode we are still on method level, but apparently we are back to class level. ",
    "a1e1c1f5": "I really appreciate your help. Thank you \uff01. ",
    "KnutHR": "I haven't gotten it built, but a friend of mine said the call graph shows that the time is spent in String.format. At least usually I see that overhead is spread over the callers in the hierarchy\nEdit: I got it built with the change and now you can see the time is reduced from 1979ms  to 75ms.. ",
    "novaterata": "Just wanted to note that lombok is supposed to be a a compilerOnly dependency, so those other dependencies don't need to be part of your runtime package. Yes, lombok is an annotation processor, it makes Java code considerably\nless verbose and boiler plate by generating the verbose code at compile\ntime. An alternative would be to introduce kotlin or similar jvm language.\nOn Fri, Jan 19, 2018, 11:18 AM William L Thomson Jr \nnotifications@github.com wrote:\n\n@novaterata https://github.com/novaterata interesting, so your saying\nin deployment one does not need lombok.jar? My main concern is build time,\nas its build time dependencies for other stuff. Though if runtime\ndependencies are reduced, that does negate the admin headache of all the\neclipse dependencies for lombok.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/raphw/byte-buddy/issues/397#issuecomment-359014063,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABlGHdfbnSqd7UXDd3nvcnWQibdas-poks5tMMBKgaJpZM4Re0qM\n.\n. The lombok plugin for Intellij and maybe eclipse has a great delombok\nfeature that should make this easy\n\nOn Sat, Jan 20, 2018, 1:11 PM William L Thomson Jr notifications@github.com\nwrote:\n\nIf there is anything I can do to assist with this I am more than willing.\nI do not need lombok but I do need byte-buddy, its presently blocking the\ncore Java stuff for my Netbeans 9 build from source under JDK9. Not sure\nLombok will be fixed for Java 9 anytime soon. Thus since I am stalled\nthere, I have time to help.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/raphw/byte-buddy/issues/397#issuecomment-359190795,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABlGHdyWO01kI3uIXGR59mUmfL5fjZeTks5tMixJgaJpZM4Re0qM\n.\n. \n",
    "diegomtassis": "Fixed.\nI was using the annotations from net.bytebuddy.asm.Advice instead of net.bytebuddy.implementation.bind.annotation.. ",
    "zone1511": "@raphw If I have multiple method intercepted added to many classes, is there any possible to remove just some of them of I have to remove all and add back those I want to keep?. ",
    "kutschkem": "For the record, in commit db481c6bb6ba1eb58f3f7e5f554af11db18491e1. ",
    "cdancy": "@raphw thanks for the point in the right direction and the detailed response! Using your example above I put together this snippet:\ndef delegate = getDelegateClassFromCustomClassLoader()\n        new ByteBuddy()\n                .with(new PrefixingRandom(\"helloworld\"))\n                .subclass(delegate.getClass())\n                .method(ElementMatchers.any())\n                .intercept(InvocationHandlerAdapter.of(new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        if (\"onNext\" == method.name && args.length && args[0]) {\n                            def frame = args[0]\n                            switch (frame.streamType as String) {\n                                case \"STDOUT\":\n                                case \"RAW\":\n                                    logger.quiet(new String(frame.payload).replaceFirst(TRAILING_WHIESPACE, ''))\n                                    break\n                                case \"STDERR\":\n                                    logger.error(new String(frame.payload).replaceFirst(TRAILING_WHIESPACE, ''))\n                                    break\n                            }\n                        }\n                        try {\n                            method.invoke(delegate, args)\n                        } catch (InvocationTargetException e) {\n                            throw e.cause\n                        }\n                    }   \n                }))\n                .make()\n                .load(dockerClientClassLoader, Default.CHILD_FIRST)\n                .getLoaded()\n                .newInstance();\nThe whole idea here is to load this byte-buddy instance into our custom class-loader (using JCL which in turn has other java classes/libraries that we need to segregate from the greater code-base. However, and when using the example above, it appears that the class is not actually getting loaded into the class-loader. In putting together some test code I print out the entire contents of the classloader before and after and still the class is not found.\nAnother interesting point is the use of Default.CHILD_FIRST. Without this the process just fails complaining that it cant find the class (which makes sense because it's not in the class-loader so far as I can tell) yet when I add the child-first argument, the class is still not found, but the process is able to find the class ... that's a bit odd to me but OK.\nGoing further, and while things get off the ground, the entire process ultimately fails due to garbage collection/tenured space issues which I can't make head or tails of. Created a gist HERE with the stacktrace. As you are more an expert in this area do you think this may be more due to something I'm misconfiguring or the JCL library itself or something else? My hunch is that this is has something to do with the fact that the class can't be found in the classloader I just can't figure out why. The code in question, if you're up for taking a look, can be found HERE.. Very awesome and easy to understand and read. Thanks!. ",
    "carlvine500": "thanks ! . after supported ,  could you give a example to get following MyTypeAnnotation with bytebuddy ?\n```\npackage com.github;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedType;\nimport java.util.Arrays;\nimport java.util.concurrent.Callable;\nimport static java.lang.annotation.ElementType.TYPE_USE;\npublic class MyTest {\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(value = {TYPE_USE})\n    public @interface MyTypeAnnotation {\n    }\npublic static void main(String[] args) {\n    Callable<String> c = new @MyTypeAnnotation Callable<String>() {\n        @Override public String call() throws Exception {\n            return null;\n        }\n    };\n    AnnotatedType[] types = c.getClass().getAnnotatedInterfaces();\n    for (AnnotatedType annotatedType : types) {\n        // ==> out:[@com.github.MyTest$MyTypeAnnotation()]\n        System.out.println(\"out:\" + Arrays.toString(annotatedType.getAnnotations()));\n    }\n}\n\n}\n```\n. ",
    "bjchambers": "I'm not sure that works in all cases -- .andThen(...) only works for one layer of chaining. For instance:\nA.andThen(B) works if A is a Composable. But andThen(...) returns an Implementation not a Composable, so A.andThen(B).andThen(C) doesn't work.\nI have also observed that new Compound(A, B, C) doesn't work, because it doesn't change from A and B into the DROPPING termination handler.\nI think this could be improved if either the Composable interface was:\ninterface Composable {\n  // Returns a version of this Implementation that ignores the return value.\n  Implementation dropReturn();\n  Implementation andThen(Implementation implementation) {\n    return new Compound(dropReturn(), implementation);\n  }\nThen longer chain can be generated using new Compound(A.dropReturn(), B.dropReturn(), C). Alternatively, if it was possible for andThen to return Composable, it would allow for more convenient additional chaining.\n EDIT \nIt is possible to chain multiple things, but you must do so in a right-associative manner. Rather than A.andThen(B).andThen(C) you must do A.andThen(B.andThen(C)).\nThe above discussion would still simplify this use case. In the interim, I've created a simple helper like the following for my use case:\n```\n  private static Optional compose(List implementations) {\n    if (implementations.isEmpty()) {\n      return Optional.empty();\n    }\nImplementation result = implementations.get(implementations.size() - 1);\nfor (int i = implementations.size() - 2; i >= 0; i--) {\n  result = implementations.get(i).andThen(result);\n}\nreturn Optional.of(result);\n\n}\n```. ",
    "koradir": "Looks like you were right about the problem's lying with the code generation.\nCouldn't post more code because it's proprietary and frankly, too darn large. Didn't help that all the \"minimal working examples\" I tried to construct actually worked ...\nThe issue turned out to be disappointingly trivial: a string constant used dots instead of slashes to separate package names. Since that constant is used by ASM and looking for foo/bar/Baz is not the same as looking for foo.bar.Baz, it failed.\nYeah, really stupid.\nStill, thanks.\nAs for why I'm not using a dynamic type, it's that we already have ASM visitors that do part of the transformation required for the new class.\nThe bytebuddy tutorial, however, says\n\nif you really need to create byte code with jump instructions, make sure to add the correct stack map frames using ASM since Byte Buddy will not automatically include them for you.\n\nand quite frankly, that's too much of a hassle (and in my case actually bars me from using the ASM visitors we already have because they rely on the fact that stack frames are computed).\nIt's much more convenient to write something like\npublic class MethodAdder extends ClassVisitor implements Opcodes {\n    private MethodAdder(int api, ClassVisitor cv) {\n        super(api, cv);\n    }\n\n    public static byte[] instrument(byte[] rawByteCode){\n        ClassReader cr = new ClassReader(rawByteCode);\n        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n        FooTransformer ft = new FooTransformer(ASM5,cw);\n        BarTransformer bt = new BarTransformer(ASM5,ft);\n        MethodAdder ma = new MethodAdder(ASM5,bt);\n        cr.accept(ma, ClassReader.EXPAND_FRAMES);\n        return cw.toByteArray();\n    }\n\n    ...\n\n}\n\nand let ASM figure out the rest.. In that case, may I suggest adding this information to the tutorial? Because I read \"ByteBuddy will not\" as \"ByteBuddy refuses to\" and stopped considering ByteBuddy for transformations right then and there.. Can do, but it will take a while.\nI'll need to invest time into learning the \"how-to\" well enough to write anything useful. Time I currently just don't have. Should be able to tackle this in about two, three months or so.. ",
    "realark": "Thanks Raph, good to know. The TypeConstantAdjustment did the trick.. Just found this: https://assets.ctfassets.net/oxjq45e8ilak/7Me2OZM1y0IsmoAEeKgWaW/941b640ae7af83adb5c4733b566313bf/Making_Java_more_dynamic.pdf. Thank you!. ",
    "robross0606": "Nevermind, I think I figured this out.  Thanks!. Not sure how exactly this is the case when the \"agent\" is being injected at runtime by ByteBuddyAgent.  Everything is running from a single code base on a single project.  I am not even injecting the agent via a \"-javaagent\" CLI argument.  Any quick way you know of to debug this?. Yes, as I would expect to since the class loaders are clearly out of whack.  The question is why.  I used a short block of code in an entry point to my regular application where I know the full classpath is available to print the class loader chain:\n```\n\nsun.misc.Launcher$ExtClassLoader@7637f22\n--- delegation ---\nsun.misc.Launcher$AppClassLoader@18b4aac2 Current ClassLoader\n-----------------------------------------------------------------\nThen again I put the same block of code in the spot where the JVM complains that it does not not have the full class path.  The resulting output is:\n-----------------------------------------------------------------\nsun.misc.Launcher$ExtClassLoader@7637f22\n--- delegation ---\nsun.misc.Launcher$AppClassLoader@18b4aac2 Current ClassLoader\n-----------------------------------------------------------------\n```\nI'm wondering if there might be some type of bug with using ByteBuddyAgent to inject instrumentation into the same code base as the application from which the agent was injected.. Interesting.  So, the Thread's Context Class Loader always looks consistent across everything.  However, the individual Class's ClassLoaders seem to be different:\nJavaFX Application Thread---MainTabs---------------------------\nsun.misc.Launcher$ExtClassLoader@5c647e05\n--- delegation ---\nsun.misc.Launcher$AppClassLoader@6d06d69c **Current ClassLoader**\n-----------------------------------------------------------------\nvs\nJavaFX Application Thread---Content---------------------------\nsun.misc.Launcher$ExtClassLoader@5c647e05 **Current ClassLoader**\n-----------------------------------------------------------------. Given that this is indeed what appears to be happening, is there any way to change the classloader delegation chain for one or more classes?. Looks like maybe you covered this already in https://github.com/raphw/byte-buddy/issues/377?. The only solution I'm seeing is to manually inject each individual class as byte[] into the System classloader.  We have literally thousands of classes that build and interact off each other.  Having to manually hunt down and manually inject all the necessary ones could be a major PITA.  Is there any way to simply inject/change the classloader used by the transformed class(es)?. My issue is that, for reasons I can't really explain here, the application is self-instrumenting in order to hook into JavaFX methods that are poorly written.  So I'm not quite sure what \"JAR\" to append to the bootstrap classloader.. ",
    "paulgerlich-wf": "Thanks for the quick reply! \nWe just discovered the issue and it was unrelated to byte buddy, of course :)\nWe introduced a pretty aggressive system environment variable cleanup utility to assist with our testing process. That led to the JAVA_HOME and other variables getting cleaned up and is what we believe broke byte buddy's initialization logic.. ",
    "AlanBateman": "Unsafe.defineClass has been terminally deprecated since JDK 9.\nFor proxy classes, then maybe the user of Byte Buddy can get the class bytes and use Lookup.defineClass to inject the class (as that is the only supported API for injecting classes).. @raphw The OpenJDK mailing lists are the right place to bring up additional use-cases. The question of java agents instrumenting classes with references to auxiliary classes is something to bring to serviceability-dev as it's beyond the use-cases that the java.lang.instrument API was intended for. There may be a connection to the work in JEP 181 on nest based access control.. ",
    "mlchung": "I have created https://bugs.openjdk.java.net/browse/JDK-8200559 to provide a replacement API for Unsafe::defineClass for java instrumentation agent.. ",
    "olivierg13": "Thank you \ud83d\udc4d . ",
    "jackychee": "\n. Hi, i use AgentBuilder to transform class before jvm load it. In my project, i transformed log4j2\u2018s Logger class, that will cause bytebuddy consume too much time.. oh,  bytebuddy's version is 1.7.11. I'm confused about that the problem only occurred when i transformed log4j2' logger class. when i transformed other class, there no such problem.  by the way, if i register a noop method graph compiler, Can i get type and method info from TypeDescrition and MethodDescrition?. Yes, my agent dependent some artifact which will use SLF4J. Is there a way to check circularity? i want to have a try. Can you give me a demo of how to register a noop method graph compiler?. OK, i will rip out slf4j dependency and try again. And i will give you a demo which will reappear the problem i  encountered later.. Hi, raphw, here is my agent demo https://github.com/jackychee/agent. \nIn order to run the demo, you should package the project, set another project (for example B project)'s  -javaagent parameter with it, and run B project finally.\nIn Agent.class, if i don't comment  SLF4JLogger.printMsg(), that will cause B project start very slow, about 110s\u3002. Did you use my agent demo? 1. package my agent demo, you can find a agent-1.0.jar under target directory. 2. add -javaagent:path/to/agent-1.0.jar  to what ever java project's java command line.  3. start java project.. I updated bytebuddy's version to 1.8.3, and that make no changes. I will run my agent demo in other machine to see how it going. By the way, which log framework are you use? is log4j2?. \nI run agent-test project in ubuntu 16.04 LTS, java version \"1.8.0_112\", and agent-test start up 159s. In agent-test project, i use slf4j+log4j2 to log message.. I'm a little careless that i wan't give you my agent-test project, forgive me. here is my agent-test project https://github.com/jackychee/agent-test .. Thank @raphw @testn . Thanks for your expertise and lucid explanation of the cause, @raphw . ",
    "testn": "@raphw which version of JDK are you using? I can replicate the problem. @raphw what is the reason behind the use of Harmonized class. The implementation looks pretty inefficient and I don't seem to understand how it is used. . The impact is quite hard to identify as the memory allocation tends to cause additional GC pause which is hard to identify the actual overhead. However, this came up a lot in the memory and cpu profiling from assertj project.. Yes, it is. If possible, I actually want to refactor the entire library. It overuses ArrayList everywhere. If we make the library to use something similar to ImmutableList in Guava library, it will make the optimization much easier.. @raphw  you have a lot of wrapper class around List<XXX> which I finds it pretty useful to convert one type to another. However, when you use a wrapper around list, it seems to disable the optimizer to optimize away the iterator. In addition to that, sublist() seems to create ArrayList$SubList and wrapped behind another wrapper. This actually causes some performance problem when having to load a bunch of methods.. failed due to a findbug issue https://github.com/spotbugs/spotbugs/issues/500. I need to move everything into ForLoadedType as the inner class of an interface is loaded before the interface itself. After that, I alias everything back to TypeDefinition.XXXX to avoid backward compatibility problem. Introduce TypeCache nested class to break out of a recursive class loading problem.. @raphw I just wonder how I debug bytebuddy via intellij. It looks like it keeps trying to compile bytebuddy code without running it through bytebuddy-maven-plugin. @raphw  have you got a chance to take a look? I didn't replace all the new ForLoadedType usage. Just the necessary one.. With this change, SoftAssertionsPerfTest takes 4.5 seconds down from around 6 seconds. It seems to save over 200,000 allocations on that.. Sounds like Eclipse problem https://bugs.eclipse.org/bugs/show_bug.cgi?id=516833. sound like https://github.com/mockito/mockito/issues/922. Sure I will move it.. ",
    "PascalSchumacher": "I guess this should have 1.8.4 as milestone (as 1.8.3 was released on 31-Mar-2018)?. I guess this should have 1.8.4 as milestone (as 1.8.3 was released on 31-Mar-2018)?. I guess this should have 1.8.4 as milestone (as 1.8.3 was released on 31-Mar-2018)?. ",
    "ptseng": "@raphw Hi, just to confirm are you the copyright holder of this repository?  If so would it be fair to say that this codebase is copyright 2018 raphw?. @raphw Thank Rafael \ud83d\udc4d . ",
    "Speyns": "I validated the issue with the newer JDT from Eclipse Photon Milestone 6 (4.8.0M6)\nBuild id: 20180315-1217.\nJDT problem with lambda parameter names is resolved.\n. ",
    "TikhomirovSergey": "@raphw Thank you very much! \nI got my code working using both suggestions (just for the proof). If you are sure that there is nothing to do can I close it (or could you please close it on your own)?. ",
    "dsyer": "Thanks. I managed to get it to work. I can't say it was very obvious how to do it, even after reading all the javadocs. It's quite a big API. Maybe some more samples, or snippets in the README would help? I also had a lot of trouble working out how to select an existing constructor (for essentially the same reason). I feel dumb now that I couldn't do it quicker, but I did spend more than half a day thrashing around on this, not realizing why it wasn't working.\nMaybe some convenience implementations for static method calls and constructors (like MethodCall) would make it more obvious?. You are welcome.\nAnother source of GC pressure is the internal implementation of ParameterDescription.ForLoadedParameter.OfMethod. For instance getDeclaredAnnotations() re-parses the annotations of the whole method for every parameter, I think. And getType() clones the parameter types again. The former is definitely visible in the Flight Recorder as a creator of char[] in the ConstantPool, while the latter is not yet visible, but might surface if we are optimizing other things. I can open a separate issue about that if you prefer.. @gsmet Flight Recorder doesn't make it easy to copy complete stack traces. It comes from org.hibernate.proxy.pojo.bytebuddy.ByteBuddyProxyFactory.lambda$buildProxy$1(Class, Class[]). I can grab a stack from the debugger in the IDE, but it's possible this was a different code path than the one that slows us down with GC pressure:\nParameterList$ForLoadedExecutable$OfMethod.get(int) line: 320   \nParameterList$ForLoadedExecutable$OfMethod.get(int) line: 307   \nAbstractList$Itr.next() line: 358   \nTargetMethodAnnotationDrivenBinder.compile(MethodDescription) line: 64  \nMethodDelegation$ImplementationDelegate$ForStaticMethod.of(MethodList<?>, MethodDelegationBinder) line: 759 \nMethodDelegation$WithCustomProperties.to(TypeDescription) line: 1223    \nMethodDelegation$WithCustomProperties.to(Class<?>) line: 1204   \nMethodDelegation.to(Class<?>) line: 255 \nByteBuddyProxyFactory.lambda$buildProxy$1(Class, Class[]) line: 107 \n121483686.call() line: not available    \nTypeCache$WithInlineExpunction<S>(TypeCache<T>).findOrInsert(ClassLoader, T, Callable<Class<?>>) line: 137  \nTypeCache$WithInlineExpunction<S>.findOrInsert(ClassLoader, S, Callable<Class<?>>) line: 344    \nTypeCache$WithInlineExpunction<S>(TypeCache<T>).findOrInsert(ClassLoader, T, Callable<Class<?>>, Object) line: 159  \nTypeCache$WithInlineExpunction<S>.findOrInsert(ClassLoader, S, Callable<Class<?>>, Object) line: 353    \nByteBuddyProxyFactory.buildProxy(Class, Class[]) line: 100  \nByteBuddyProxyFactory.postInstantiate(String, Class, Set<Class>, Method, Method, CompositeType) line: 78    \nPojoEntityTuplizer$1.run() line: 167    \nPojoEntityTuplizer$1.run() line: 162    \nPojoEntityTuplizer.buildProxyFactory(PersistentClass, Getter, Setter) line: 186 \nPojoEntityTuplizer(AbstractEntityTuplizer).<init>(EntityMetamodel, PersistentClass) line: 156   \nPojoEntityTuplizer.<init>(EntityMetamodel, PersistentClass) line: 60    \nNativeConstructorAccessorImpl.newInstance0(Constructor<?>, Object[]) line: not available [native method]    \nNativeConstructorAccessorImpl.newInstance(Object[]) line: 62    \nDelegatingConstructorAccessorImpl.newInstance(Object[]) line: 45    \nConstructor<T>.newInstance(Object...) line: 423 \nEntityTuplizerFactory.constructTuplizer(Class<EntityTuplizer>, EntityMetamodel, PersistentClass) line: 88   \nEntityTuplizerFactory.constructDefaultTuplizer(EntityMode, EntityMetamodel, PersistentClass) line: 116  \nEntityMetamodel.<init>(PersistentClass, EntityPersister, SessionFactoryImplementor) line: 382   \nSingleTableEntityPersister(AbstractEntityPersister).<init>(PersistentClass, EntityDataAccess, NaturalIdDataAccess, PersisterCreationContext) line: 551  \nSingleTableEntityPersister.<init>(PersistentClass, EntityDataAccess, NaturalIdDataAccess, PersisterCreationContext) line: 124   \nNativeConstructorAccessorImpl.newInstance0(Constructor<?>, Object[]) line: not available [native method]    \nNativeConstructorAccessorImpl.newInstance(Object[]) line: 62    \nDelegatingConstructorAccessorImpl.newInstance(Object[]) line: 45    \nConstructor<T>.newInstance(Object...) line: 423 \nPersisterFactoryImpl.createEntityPersister(Class<EntityPersister>, PersistentClass, EntityDataAccess, NaturalIdDataAccess, PersisterCreationContext) line: 96   \nPersisterFactoryImpl.createEntityPersister(PersistentClass, EntityDataAccess, NaturalIdDataAccess, PersisterCreationContext) line: 77   \nMetamodelImpl.initialize(MetadataImplementor, JpaMetaModelPopulationSetting) line: 154  \nSessionFactoryImpl.<init>(BootstrapContext, MetadataImplementor, SessionFactoryOptions) line: 295   \nSessionFactoryBuilderImpl.build() line: 467 \nEntityManagerFactoryBuilderImpl.build() line: 939   \n...\nI am using Hibernate 5.3.3.. ",
    "hao117": "thank you very much!  It can work.\nI have another problem\uff0cI can't debug it in enter() .. I see. Thanks. thank you very much!. Thank you\uff01. I don't want the original code to execute.\n Is there another way?\nths!. I solved it\uff01 Thank you !\nmy code:\n```\n@Advice.OnMethodEnter(skipOn = Advice.OnDefaultValue.class)\npublic static boolean enter(@Advice.This Object ths){\n    return false;\n}\n@Advice.OnMethodExit()\npublic static void exit(@Advice.Return(readOnly = false) BufferedReader reader,\n                        @Advice.This Object ths){\n    //doOtherthing...\n    reader = new BufferedReader(...);\n}\n```\nThank you!. thank you!. ",
    "desger": "@raphw Sorry for bringing the confusion. My struggle is that I want to rebase System. currentTimeMillis so that I can call the original method in my override method. The \"redefine\" way is not suitable as I cannot call original method in this way. I tried to replace the above code with:\njava\n.with(AgentBuilder.TypeStrategy.Default.REBASE)\nBut it doesn't work. Can you please kindly share a \"rebase\" version against above code? Or is it possible to rebase that method? I've read bytebuddy docs and it seems not allowed to insert new methods (the original method is being inserted with a prefix name, correct?) in Java bootstrap classes.\nPS: Yes I've successfully tested the \"redefine\" version in Java agent mode.. I see. But what if I would consider to do some injection to the java rt.jar? I mean, if I use bytebuddy to rebase java.lang.System by modifying rt.jar by another Java program before starting the production system, will that be possible anyway?. Understood. I finally created a new class with a native method to get the real time. I wrote a simple C program to bind to the native method. And in the C program I just copied from Java's os_linux.cpp which calls system's function \"gettimeofday\". Indeed this way will bring os dependency while it meets my requirements as time being. I still use bytebuddy to take the redefine part. Thanks a lot for all suggestions. And appreciate for your owesome work in bytebuddy:). ",
    "marko-bekhta": "That was really helpful, thanks! Here are some additional comments and also a few code snippets (maybe somebody would find them useful when looking for similar solution).\n\nI think it's more about the enhancing the existing classes as I would like the validation to work without the user writing any additional code. And your explanation on Advice behavior cleared how the things work.\n\"Constructor problem\" seems to become obsolete when I actually moved the code to an agent. As in case of the agent I don't do subclassing.\njava\nnew AgentBuilder.Default()\n    .type( ElementMatchers.any() )\n    .transform( (builder, typeDescription, classLoader, module) -> builder\n            .visit( Advice\n                    .withCustomMapping().bind( Groups.ForGroups.Factory.INSTANCE )\n                    .to( ConstructorParametersValidationAdvice.class )\n                    .on( ElementMatchers.isConstructor()\n                            .and( ElementMatchers.hasParameters( ElementMatchers.any() ) )\n                            .and( ElementMatchers.isAnnotatedWith( Validate.class ) ) )\n            )\n            .visit( Advice\n                    .withCustomMapping().bind( Groups.ForGroups.Factory.INSTANCE )\n                    .to( ConstructorReturnValueValidationAdvice.class )\n                    .on( ElementMatchers.isConstructor()\n                            .and( ElementMatchers.isAnnotatedWith( Validate.class ) ) )\n            )\n            // .... other visitors \n    ).installOn( instrumentation );\n\nI followed your instructions and also checked how the @Advice.AllArguments mapping was implemented and created an OffsetMapping for the groups:\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@java.lang.annotation.Target(ElementType.PARAMETER)\npublic @interface Groups {\nclass ForGroups implements Advice.OffsetMapping {\n/**\n * The component target type.\n */\nprivate final TypeDescription.Generic target;\n\npublic ForGroups(TypeDescription.Generic target) {\n    this.target = target;\n}\n\n@Override\npublic Target resolve(TypeDescription instrumentedType,\n        MethodDescription instrumentedMethod,\n        Assigner assigner,\n        Advice.ArgumentHandler argumentHandler,\n        Sort sort) {\n    Class<?>[] groups = instrumentedMethod.getDeclaredAnnotations().ofType( Validate.class ).loadSilent().groups();\n\n    return new Target.ForArray.ReadOnly(\n            target,\n            Arrays.stream( groups )\n                    .map( group -> ClassConstant.of( TypeDescription.ForLoadedType.of( group ) ) )\n                    .collect( Collectors.toList() )\n    );\n}\n\n// code for Advice.OffsetMapping.Factory<Groups> ....\n\n}\nand then in the `Advice` I just annotate one of the parameters with this new `@Groups` annotation:java\npublic static class ConstructorParametersValidationAdvice {\n@Advice.OnMethodEnter\nprivate static void exit(\n        @Advice.AllArguments Object[] parameters,\n        @Advice.Origin Constructor<?> constructor,\n        @Groups Class<?>[] groups) {\n    ValidationEntryPoint.validateConstructorParameters( constructor, parameters, groups );\n}\n}\n```\nand it all seems to work nicely! Thanks again!\n. \n\n",
    "andrej-alac": "it is fixed, thank you.  \nregarding module-info generation, there are several possibilities, I personally currently using following concept based on maven-antrun-plugin and maven-install-plugin, both are executed in package phase.\nAs result the same jar as before plus additional jmod artifact are produced.  I guess this can be easily integrated into your /byte-buddy/pom.xml .\n<plugin>\n                <artifactId>maven-antrun-plugin</artifactId>\n                <version>1.8</version>\n                <executions>\n                    <execution>\n                        <id>jmod-package</id>\n                        <phase>package</phase>\n                        <configuration>\n                            <target>\n                                <property name=\"p.module.name\" value=\"net.bytebuddy\"/>\n                                <exec executable=\"${java.home}/bin/jdeps\" dir=\"target\" failonerror=\"true\">\n                                    <arg line=\"--generate-module-info . ${project.artifactId}-${project.version}.jar\"/>\n                                </exec>\n                                <unzip src=\"target/${project.artifactId}-${project.version}.jar\" dest=\"target/jmod/classes\"/>\n                                <delete dir=\"target/jmod/classes/META-INF\"/>\n                                <exec executable=\"${java.home}/bin/javac\" dir=\"target\" failonerror=\"true\">\n                                    <arg line=\"-p . -d jmod/classes ${p.module.name}/module-info.java\"/>\n                                </exec>          \n                                <exec executable=\"${java.home}/bin/jmod\" dir=\"target\" failonerror=\"true\">\n                                    <arg line=\"create --class-path jmod/classes jmod/${project.artifactId}-${project.version}.jmod\"/>\n                                </exec>\n                            </target>\n                        </configuration>\n                        <goals>\n                            <goal>run</goal>\n                        </goals>\n                    </execution>                       \n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-install-plugin</artifactId>\n                <version>2.5.2</version>\n                <configuration>\n                    <groupId>${project.groupId}</groupId>\n                    <artifactId>${project.artifactId}</artifactId>\n                    <version>${project.version}</version>\n                    <packaging>jmod</packaging>\n                    <file>target/jmod/${project.artifactId}-${project.version}.jmod</file>\n                </configuration>\n                <executions>\n                    <execution>\n                        <id>jmod-install</id>\n                        <goals>\n                            <goal>install-file</goal>\n                        </goals>\n                        <phase>package</phase>\n                    </execution>\n                </executions>\n            </plugin> \n        </plugins>\nIf you wish to manually create module-info.java and/or reduce visibility of exported packages, ant echo task will replace exec jdeps command. \n. ",
    "RocketRider": "I will try the master. Thank you for the very quick response!. I tried to compile byte-buddy but ran into some issue. So I will just wait for your next release.\n[ERROR] Failed to execute goal codes.rafael.gradlemavenplugin:gradle-maven-plugin:1.0.10:invoke (gradle-build) on project byte-buddy-gradle-plugin: org.gradle.tooling.BuildException: Could not execute build using Gradle distribution 'file:/C:/Users/Admin/Downloads/byte-buddy-master/byte-buddy-gradle-plugin/gradle/4.5/gradle-4.5-bin.zip'. -> [Help 1]\n. Still the same error with 1.8.11. Thank you!\nYes that is the issue. Updating test runner solved it.. ",
    "leadwire-apm": "Hi,\nHave you tried to do this with reflection?\njava\n@Advice.OnMethodEnter(inline = false)\npublic static void onEnterServletService(@Advice.Argument(0) HttpServletRequest request) {\n    Method aMethodgetRequestURL = request.getClass().getMethod(\"getRequestURL\");\n    aMethodgetRequestURL.setAccessible(Boolean.TRUE);\n    StringBuffer requestURL = (StringBuffer) aMethodgetRequestURL.invoke(request);\n    completeURL = requestURL.toString();\n    System.out.println(completeURL);\n}. ",
    "soberich": "@raphw \nJRE lunched ok, but currently I am experiencing troubles with matchers and API usage of AgentBuilder.\nYes, I am switching to matchers from directly querying Bean Validation framework, thank you.\n```java\n        val isNonGetter = hasParameters(any());\n    val hasConstraints = isAnnotatedWith(isAnnotatedWith(javax.validation.Constraint.class));\n\n    val hasConstrainedParameters = hasParameters(whereAny(hasConstraints));\n\n    val isForParameterValidation = isNonGetter.and( hasConstraints.or(hasConstrainedParameters) );\n\n    ByteBuddyAgent.install();\n    new AgentBuilder.Default()\n            .with(StreamWriting.toSystemOut().withTransformationsOnly())\n            .disableClassFormatChanges()\n            .with(RedefinitionStrategy.RETRANSFORMATION)\n            .type(isPublic().and(nameStartsWith(\"com.example\")).and(declaresMethod(isForParameterValidation)))\n            .transform(new Transformer.ForAdvice()\n                    .include(MethodArgsAdvice.class.getClassLoader())\n                    .advice(     isMethod().and(isForParameterValidation),      MethodArgsAdvice.class.getName())\n\n//  this does not work at all   .advice(isConstructor().and(isForParameterValidation), ConstructorArgsAdvice.class.getName())\n                )// this does not work as well\n                /*.transform(new Transformer.ForAdvice()\n                        .include(ConstructorArgsAdvice.class.getClassLoader())\n                        .advice(isConstructor().and(isForParameterValidation), ConstructorArgsAdvice.class.getName())\n            )*/.transform((builder, typeDescription, classLoader, module)\n                        ->\n                    builder.visit(\n                            new AsmVisitorWrapper.ForDeclaredMethods()\n                                    .writerFlags(ClassWriter.COMPUTE_FRAMES)\n                                    .method(isConstructor().and(isForParameterValidation), Advice.to(ConstructorArgsAdvice.class))\n                    )\n            ).installOnByteBuddyAgent();\n\n```\n\nSay, a class I target to tranform is Person.class Does declaring chained advice on Transformer.ForAdvice supposed to work? Sequentially? \nDeclaring .advice(isConstructor().and(isForParameterValidation), ConstructorArgsAdvice.class.getName())  in the listing above as a second advice, or as a second transformer (like .transform(new Transformer.ForAdvice().include(..).advice(..)) does not make constructor advice code to be injected / merged to targets, though Sysout log says that Person target class was transformed. \nIn each of the following cases Sysout log says TRANSFORMATION is done.\n\n\u21161 method transformation works as expected\njava\n .advice(     isMethod().and(isForParameterValidation),      MethodArgsAdvice.class.getName())\n\u21162 method transformation works as expected, constructor transformation did not happen\njava\n .advice(     isMethod().and(isForParameterValidation),      MethodArgsAdvice.class.getName())\n .advice(isConstructor().and(isForParameterValidation), ConstructorArgsAdvice.class.getName())\n\u21163 both does nothing \njava\n .advice(isConstructor().and(isForParameterValidation), ConstructorArgsAdvice.class.getName())\n .advice(     isMethod().and(isForParameterValidation),      MethodArgsAdvice.class.getName())\n\u21164 both does nothing \njava\n.transform(new Transformer.ForAdvice()\n        .include(MethodArgsAdvice.class.getClassLoader())\n        .advice(     isMethod().and(isForParameterValidation),      MethodArgsAdvice.class.getName())\n.transform(new Transformer.ForAdvice()\n        .include(ConstructorArgsAdvice.class.getClassLoader())\n        .advice(isConstructor().and(isForParameterValidation), ConstructorArgsAdvice.class.getName()))\n\u21165 works on both\njava\n.transform(new Transformer.ForAdvice()\n        .include(MethodArgsAdvice.class.getClassLoader())\n        .advice(isMethod().and(isForParameterValidation), MethodArgsAdvice.class.getName())\n.transform((builder, typeDescription, classLoader, module)\n                    ->\n                builder.visit(\n                        new AsmVisitorWrapper.ForDeclaredMethods()\n                                .writerFlags(ClassWriter.COMPUTE_FRAMES)\n                                .method(isConstructor().and(isForParameterValidation), Advice.to(ConstructorArgsAdvice.class))\n                )\n            )\nSo, as a result IF .advice(isMethod().and(isForParameterValidation),      MethodArgsAdvice.class.getName()) declaration is the first in the list - it works, as expected, but applying .advice(isConstructor().and(isForParameterValidation), ConstructorArgsAdvice.class.getName()) as the first advice for that transformer breaks transformation on both.. It is not made (log says it's done - but it does not work as if nothing happend). As well as supplying  ConstructorArgsAdvice as a second transformer breaks both (either with or without duplicating .type(isPublic().... signature for second added transformer.\n2. The working example for Constructors I found as listed in the last chain with new AsmVisitorWrapper.ForDeclaredMethods(). Why is that?? All other trials with .advice( and without direct call to builder.visit( simply results nothing is done to constructors (though logs says TRANSFORMED)\n~~3. Also, it's hard to predict behavior of matchers sometimes. For example, I have stub REST endpoint here like~~\njava\n@RequestScoped\n@Path(\"/test\")\n@Produces({ APPLICATION_JSON, TEXT_PLAIN })\n@Consumes({ APPLICATION_JSON, TEXT_PLAIN })\npublic class Endpoint {\n    @Path(\"/person\")\n    @POST\n    public String vadidate(@NotNull @Valid Person person) {\n        return person.toString();\n    }\n}\n~~so if I select types like .type(isPublic().and(nameStartsWith(\"com.example\"))), then Endpoint itself transformed, but if I specify .type(isPublic().and(nameStartsWith(\"com.example\")).and(declaresMethod(isForParameterValidation)))\nEndpoint it is avoided - which is what I need but why is it happening since there is @NotNull on the method?~~\nEdit 1\nLast one I can not reproduce now. . ",
    "httpdigest": "I also found this disabling of tests when being run under JDK 11: https://github.com/raphw/byte-buddy/blob/master/.travis.yml#L23\nand also this issue which seems to be related: https://github.com/raphw/byte-buddy/issues/428. ",
    "gsmet": "Thanks for the quick fix and release.. OK, cool, thanks for the quick answer.. I think it will be an issue because we generate the proxy entities in the same package as the original entity (we need that to support signed jars) and we don't really want to force the users to give these permissions to their own code as that would defeat the purpose of the security manager.\nCould we imagine being able to configure the calls made in the static initializer to redirect them to some Hibernate code that would expose a privileged getDeclaredMethod()? Pretty similar to what is done with Javassist, except we would provide it ourselves and pass it to ByteBuddy when creating the proxies.. @raphw I think you might be right, maybe it's not such a good idea to do it as Javassist does.\nTo be honest, what I would prefer is having only the HIbernate code able to do privileged operation and not the entities but I don't think it's doable if we generate the proxies in the same package as the original entities.. Hi @raphw ,\nI made some progress during the last 2 days, trying to clean up our ByteBuddy code and apply your suggested approach.\nThe calls don't get rewritten. I'm wondering if maybe I can't apply the rewrites directly to the current builder and need an intermediate representation?\nThe added calls are here: https://github.com/gsmet/hibernate-orm/blob/HHH-12857/hibernate-core/src/main/java/org/hibernate/bytecode/internal/bytebuddy/ByteBuddyState.java#L146 .\nOne other question I have is that we're supposed to change something like MyClass.class.getDeclaredMethod(...) by HibernateLookupDispatcher.getDeclaredMethod(MyClass.class, ...) and your substitution rule looks too simple to be true: it doesn't get the object and inject it in the parameters.\nMy current branch is here:\nhttps://github.com/gsmet/hibernate-orm/tree/HHH-12857\nClasses can be generated by simply using:\n./gradlew test --tests=org.hibernate.bytecode.internal.bytebuddy.GenerateProxiesTest\nThey are saved in the Java temp directory (so /tmp/ on Linux for instance) + /bytebuddy/org/hibernate/bytecode/internal/bytebuddy/. The class containing $HibernateBasicProxy$ in its name does contain the calls I want rewritten.\nAny help would be appreciated! Thanks!. @raphw yuk, thanks for pointing it out, sorry for the noise.\nIt nearly works, I still have a very specific issue with enhancement, which might be a ByteBuddy issue.\nIf I try to enhance the following class (the important part is the Pattern static initializer):\n```java\n@Entity(name = \"SimpleEntity\")\npublic class SimpleEntity {\nprivate static final Pattern PATTERN = Pattern.compile( \"whatever\" );\n\n@Id\n@GeneratedValue\nprivate Long id;\n\npublic Long getId() {\n    return id;\n}\n\npublic void setId(Long id) {\n    this.id = id;\n}\n\n}\n``\nusing theMemberSubstitution` visitors we discussed above, I end up with the following exception in ByteBuddy:\nCaused by: java.lang.IllegalStateException: Cannot resolve type description for java.util.regex.Pattern\n    at net.bytebuddy.pool.TypePool$Resolution$Illegal.resolve(TypePool.java:135)\n    at net.bytebuddy.pool.TypePool$Default$LazyTypeDescription$TokenizedGenericType.toErasure(TypePool.java:5842)\n    at net.bytebuddy.pool.TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$Raw$RawAnnotatedType.of(TypePool.java:3502)\n    at net.bytebuddy.pool.TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$Raw.resolveFieldType(TypePool.java:3394)\n    at net.bytebuddy.pool.TypePool$Default$LazyTypeDescription$LazyFieldDescription.getType(TypePool.java:6147)\n    at net.bytebuddy.description.field.FieldDescription$AbstractBase.getDescriptor(FieldDescription.java:101)\n    at net.bytebuddy.matcher.DescriptorMatcher.matches(DescriptorMatcher.java:30)\n    at net.bytebuddy.matcher.DescriptorMatcher.matches(DescriptorMatcher.java:11)\n    at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:101)\n    at net.bytebuddy.matcher.FilterableList$AbstractBase.filter(FilterableList.java:96)\n    at net.bytebuddy.asm.MemberSubstitution$SubstitutingMethodVisitor.visitFieldInsn(MemberSubstitution.java:1288)\n    at net.bytebuddy.jar.asm.MethodVisitor.visitFieldInsn(MethodVisitor.java:385)\n    at net.bytebuddy.jar.asm.ClassReader.readCode(ClassReader.java:2207)\n    at net.bytebuddy.jar.asm.ClassReader.readMethod(ClassReader.java:1274)\n    at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:679)\n    at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:391)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2880)\n    at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1653)\n    at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:180)\n    at net.bytebuddy.dynamic.scaffold.inline.AbstractInliningDynamicTypeBuilder.make(AbstractInliningDynamicTypeBuilder.java:94)\n    at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2669)\nNote that it's not specific to Pattern, I have the same issue with other classes from the JDK (at least String in one of our tests).\nIt's easily reproducible with my branch:\nhttps://github.com/gsmet/hibernate-orm/tree/HHH-12857\nand this command:\n./gradlew test --tests=org.hibernate.bytecode.internal.bytebuddy.GenerateProxiesTest\nHopefully, it won't be a rookie mistake this time.\nThanks for the help!. @raphw sorry for the late reply, got caught up by other things and was planning to get back to you during the week-end but you beat me to it.\nI applied your suggestion (2/) and it fixes my issue.\nI'll try to get our SM tests run on top of that next week and hopefully they will succeed.\nThanks for the help!. @felixbarny thanks, I looked in the open issues but not the closed one.\nEnabling the experimental features indeed allowed to run our tests.. @dsyer do you have the rest of the stacktrace, the Hibernate part?\nI concur with @raphw that we shouldn't do that anymore once the proxies are generated. And this should be done once and for all.\n@dsyer also interested in the ORM version used.\nThanks!. From what I can see, it's only used when initializing the proxy classes so it shouldn't be in the hot path, once started.\nWe could optimize things by making these MethodDelegation.of() elements static but, unfortunately, with the current architecture, these proxy factories are long lived and I'm not sure I would want to keep these objects around.\n@raphw do you know if these objects consumes a lot of memory?. @raphw btw, we had to do this optimization in Hibernate Validator too. We pass the Method.getParameters() result along with the executable in a couple of methods as calling getParameters() was too slow.\nI think it would be a nice thing to do anyway in ByteBuddy.. @raphw I think a good first step from the ByteBuddy POV is to avoid calling Method#getParameters() more than once per method.\nI'll change our implementation to avoid creating a new method delegation per proxy class.. @dsyer I pushed a commit to improve the situation on our end. It will be part of 5.3.5.Final I plan to release tomorrow afternoon.\nThanks for raising the issue.. @olivergierke publication of the 5.3.5-SNAPSHOT should be OK now.. Thanks Oliver. I started the release process.. Just so you know, we also applied changes to ORM to improve the situation a bit (https://github.com/hibernate/hibernate-orm/pull/2638) but the gist of it (~20 seconds on my laptop) is really in this internal BB call.. @raphw thanks a lot for the quick turnaround!. ",
    "eliasvasylenko": "A workaround is to create a new TypeDescription to pass into the AnnotationDescription.Builder.ofType() invocation, containing only the elements you wish to provide values for, rather than passing in the loaded class.. Sorry I'm probably missing something being unfamiliar with ByteBuddy and it's implementation/general philosophy, but I'm not seeing why it should matter that Java doesn't offer this API.\nUltimately from a user's perspective it looks like the bytecode should be generated from an AnnotationDescription not an annotation instance, and the user certainly feeds enough information into the builder to determine which values are explicit, so it's surprising to see that this information is discarded somewhere along the way.\nIs it that you're materialising the AnnotationDescription into an actual instance of an annotation first and then generating bytecode from that? Otherwise I don't see why the AnnotationDescription can't retain this extra information regardless of whether the Java reflection API does.\nThat said, for my purposes the SKIP_DEFAULTS filter should work great, so thanks for pointing me towards that!. Ah I understand, so it's about having parity between representations, that's reasonable. So the problem is the disparity between the things being represented. Do consider as another data point that the standard TypeMirror API for reflecting over unloaded types does give access to this information.. Sure I realise that, but an AnnotationDescription is also supposed to be able to represent a parsed annotation, no? I do get the value of an abstraction only implementing the intersection of the features of its different forms rather than the union, if you can get away with it, but in this case I think making a best-effort to provide the extra information where available could still make for a pretty seamless abstraction over the lot.\nAnyway I don't want to harp on about it, thanks for considering it for the future.. ",
    "oleksiyp": "So I have very similar Advice to the Mockito one. \nMy problem is that I'd like to catch overridden methods and correctly do \"callOriginal\" for spies. The plan is to skip all the overriding methods and calling super until the moment when an exact parent is called. There just call original code.\nSo I'm not sure I'm able to do so with generic MemberSubtitution (not yet read docs). Not exactly.\n```\nclass B {\n   public void blaBla() {\n       println(\"B\");\n   }\n}\nclass A extends B {\n    public void blaBla() {\n        println(\"A\");\n        super.blaBla();\n   }\n}\n```\n\nBoth methods instrumented \nA.blaBla is called\nIt is intercepted\nSpy require to call real method\nAgain A.blaBla() is called but without interception i.e. println + super call\nB.blaBla() is called and intercepted\nSpy require to call real method.\nBecause blaBla is virtual A.blaBla() called , but its advice just passes execution to B.blaBla() (here is what I need - super call from advice)\nB.blaBla is called, real method is executed. Running from IDE without code coverage. \n\nI don't think it should be affected by IDE as it seems a problem with the amount of generated synthetic methods by a Java Compiler and by ByteBuddy.\nNow I tried without IDE and it still reproducable:\n0 \u2713 oleksiyp@zen76:~/workspace/playground-kt13/out/production/classes$ /usr/lib/jvm/java-8-oracle/bin/java -cp /home/oleksiyp/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy/1.8.22/4d65fdf7d9755ef7c75f2213f356119d0e68c2cd/byte-buddy-1.8.22.jar:/home/oleksiyp/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy-agent/1.8.22/347d063fe292e406f6a71ff64dfd9e8d794f0aba/byte-buddy-agent-1.8.22.jar:. abc.B\nException in thread \"main\" java.lang.UnsupportedOperationException: class redefinition failed: attempted to add a method\n    at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)\n    at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)\n    at abc.B.main(B.java:68)\n1 \u2717 oleksiyp@zen76:~/workspace/playground-kt13/out/production/classes$ /usr/lib/jvm/java-8-oracle/bin/java -version\njava version \"1.8.0_191\"\nJava(TM) SE Runtime Environment (build 1.8.0_191-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode). Dug a little bit deeper.\nIn original B there are no synthetic methods at all.\nIn transformed B there is one more method which causes JVM to complain:\n\n. Hi @raphw, any updates regarding this issue?. No worries, 1.8.0_191, no IDE is needed. Hi @raphw, any updates regarding this issue?. sure, I suspected that this is some kind of optimization in the compiler or alike. Thanks. I see. Let me try decorate. Thanks for investigation and your effort. Opened ticket https://youtrack.jetbrains.com/issue/KT-29658. ",
    "Matthewacon": "Thanks for the reply! I've got three more questions, one related to type parameters, one related to setting access flags and one about default member values in annotations. Since I couldn't find anything, I felt it appropriate to post them here.\nFirst question: How would you define a method with type parameters. For example:\ninterface SomeInterface {\n <T extends SomeClass<T> & SomeInterface> myMethodStub();\n}\nSecond Question: Does ByteBuddy support directly modifying access flags like in asm? Given an example class, such as the following:\npublic class ExampleClass {\n public static final ExampleClass SOME_CONSTANT;\n}\nhow would I manually set the class access flags to ACC_PUBLIC and ACC_ENUM? Same for the field, ACC_PUBLIC, ACC_STATIC, ACC_FINAL and ACC_ENUM. To be clear, I do not want to simply define an enum, using new ByteBuddy().makeEnumeration(String...), I want to redefine a pre-existing class and convert it into an enum. \nThird Question: How would you set a default value for an annotation? For example:\npublic @interface ExampleAnnotation {\n String value() default \"This is a default value\";\n}. Thanks for all the help!. ~~In #402 you stated that a static initializer could be intercepted by builder.executable(ElementMatchers.isTypeInitializer()).intercept(...). Could you clarify which builder you were referencing in this issue?~~ \nGiven:\n```\npublic class Example {\n static {\n  System.out.println(\"Example sinit\");\n }\n}\npublic class SInitInterceptor {\n public static void intercept() {\n  System.out.println(\"Intercepted!\");\n }\n}\nI was able to intercept the static initializer in `Example` using\nDynamicType.Unloaded example = new ByteBuddy()\n .redefine(Example.class)\n .invokable(ElementMatchers.isTypeInitializer())\n .intercept(MethodDelegation.to(SInitInterceptor.class))\n .make();\nByteBuddyAgent.install();\nByteBuddyAgent\n .getInstrumentation()\n .redefineClasses(\n  new ClassDefinition(Example.class, example.getBytes())\n );\nOn the first reference to `Example` you'd expect that the intercepted static initializer would *only* execute the static method `SInitInterceptor#intercept`, given that \"Class initializers are in a way static 'methods' that return void\" as stated [here](https://groups.google.com/d/msg/byte-buddy/3AVqu1vfm7I/Anlj2RqYAQAJ), however referencing `Example`, either via instantiation or static reference, yields the following output:\nExample sinit\nIntercepted!\nRegular method delegation does not yield the same result, for example if the `Example` class was defined\npublic class Example {\n public static void someInit() {\n  System.out.println(\"Example initialized!\");\n }\n}\nthen the output would simply be:\nIntercepted!\n``\nIs this functionality intentional, and is there a way to prevent invocation of the original static initializer?. Is there, then, a way to control the order of invocation? For my purposes I require that the interceptor be invoked before the original initializer.. Apologies for the long gap in issue activity, I should've closed this issue a month ago. I found that, through theAdviceAPI, I was able to perform static initializer interception in the order that I required. That being said, I would like to make the last topic of this issue a feature request; would it be difficult to implement, in the high-level API, fine control over static initializers? Features such as execution order, similar to theAdvice` API but for existing static initializers, and suppression or redefinition, such as in the interception manor. And on a related note, when you stated \n\na skipped execution of the initializer can break a class\n\nwould that not be true for any form of interception, where the target method is replaced? What amplifies the severity of intercepting a static initializer and not invoking the original code as opposed to doing the same to a static or instance bound method? If it's a matter of implementation difficulty, then no worries, just curious.. I am using the AgentBuilder and Java Instrumentation APIs for several things in a Java Agent at the moment, however, it is not what I am looking for. I've solved my problem by implementing a classloader that accepts a set of byte[]s and recursively attempts to define them as classes, with a 3-pass tolerance. However, this approach is slow and does not scale well for large sets of classes. Further, it requires that all dependencies of said classes be either present on the classpath, or accessible from the classloader. Compounded with the restrictions imposed by the JVM, such as disallowing changes to the schema of a class, the resulting solution to my problem turned out to be horrifically slow and all but a dysfunctional mess. For these reasons, I asked if byte-buddy was able to instrument classes that are not defined on the target JVM instance but rather represented by a byte[] at runtime. Searching through the byte-buddy-dep and byte-buddy-agent libraries yielded no such results, and I imagine that for a library written solely in Java, this is not possible, but I thought I'd still ask here. \nDiverging from the initial question a bit: if it is the case that this isn't possible, I'm considering expanding my JNI module to allow unrestricted changes to classes, including retransformations to existing classes, so long as the changes produce a valid class. Would you have any suggestions or recommendations?\nAlso, since I was not the one to close this issue, I cannot reopen it.\nRegards,\nMatthewacon. ",
    "stefanorg": "Hi @raphw,\nin the startup configuration of jboss AS, i've provided the needed library and this is the startup output :\n```\njboss_1         | \njboss_1         |   JBoss Bootstrap Environment\njboss_1         | \njboss_1         |   JBOSS_HOME: /opt/jboss/jboss-as\njboss_1         | \njboss_1         |   JAVA: /usr/lib/jvm/java-1.7-openjdk/bin/java\njboss_1         | \njboss_1         |   JAVA_OPTS:  -server -XX:+UseCompressedOops -Xms1024m -Xmx1024m -XX:MaxPermSize=512m -Djava.net.preferIPv4Stack=true -Dorg.jboss.resolver.warning=true -Dsun.rmi.dgc.client.gcInterval=3600000 -Dsun.rmi.dgc.server.gcInterval=3600000 \n                    -Djboss.modules.system.pkgs=org.jboss.byteman,org.jboss.logmanager,org.slf4j,ch.qos.cal10n,ch.qos.logback,biz.paluch.logging,javax.servlet.api,it.mycomp.jagent \n                    -Djava.awt.headless=true -Djboss.server.default.config=standalone.xml -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=n \n                    -Duser.language=it -Duser.region=IT -Duser.timezone=Europe/Rome -Dfile.encoding=UTF-8 \n                    -Xbootclasspath/p:/opt/jboss/jboss-as/modules/org/jboss/logmanager/main/jboss-logmanager-1.3.2.Final.jar\n                            :/opt/jboss/jboss-as/modules/org/slf4j/main/slf4j-api-1.7.25.jar\n                            :/opt/jboss/jboss-as/modules/org/slf4j/main/slf4j-ext-1.7.25.jar\n                            :/opt/jboss/jboss-as/modules/ch/qos/logback/main/logback-core-1.1.9.jar\n                            :/opt/jboss/jboss-as/modules/ch/qos/logback/main/logback-classic-1.1.9.jar\n                            :/opt/jboss/jboss-as/modules/ch/qos/logback/main/logback-access-1.1.9.jar\n                            :/opt/jboss/jboss-as/modules/ch/qos/logback/main/logstash-logback-encoder-4.8.jar\n                            :/opt/jboss/jboss-as/modules/ch/qos/logback/main/jackson-core-2.6.5.jar\n                            :/opt/jboss/jboss-as/modules/ch/qos/logback/main/jackson-databind-2.6.5.jar\n                            :/opt/jboss/jboss-as/modules/ch/qos/logback/main/jackson-annotations-2.6.5.jar\n                            :/opt/jboss/jboss-as/modules/ch/qos/cal10n/main/cal10n-api-0.7.3.jar\n                            :/opt/jboss/jboss-as/modules/org/apache/httpcomponents/argo/httpclient-4.5.3.jar\n                            :/opt/jboss/jboss-as/modules/org/apache/httpcomponents/argo/httpcore-4.4.6.jar\n                            :/opt/jboss/jboss-as/modules/javax/servlet/api/main/jboss-servlet-api_3.0_spec-1.0.1.Final.jar\n                            :/opt/jboss/jboss-as/modules/biz/paluch/logging/main/logstash-gelf-1.11.1-SNAPSHOT.jar\n                            :/opt/jboss/jboss-as/modules/it/mycomp/jagent/main/simpleclient-0.4.0.jar\n                            :/opt/jboss/jboss-as/modules/it/mycomp/jagent/main/simpleclient_common-0.4.0.jar\n                            :/opt/jboss/jboss-as/modules/it/mycomp/jagent/main/simpleclient_hotspot-0.4.0.jar\njboss_1         |  -Dorg.jboss.logging.provider=slf4j -Djava.util.logging.manager=org.jboss.logmanager.LogManager -Dlogback.configurationFile=/opt/jboss/jboss-as/standalone/configuration/logback.xml -javaagent:/opt/jboss/jboss-as/modules/it/mycomp/jagent/main/jagent.jar\njboss_1         | \njboss_1         | =========================================================================\n```\nWith the -Djboss.modules.system.pkgs=org.jboss.byteman,org.jboss.logmanager,org.slf4j,ch.qos.cal10n,ch.qos.logback,biz.paluch.logging,javax.servlet.api,it.mycomp.jagent those modules/libraries should by visible to all classloader in the AS.\nWith the: -Xbootclasspath/p:.... i put the jar simpleclient-0.4.0.jar ... in the boot classpath.\nThe strange think that i've noticed is that the class HttpContext (is my own class in the it.mycomp namespace) is called correctly in the scope of Servlet just before the exception, as you can see in the log:\njboss_1         | 2018-06-15 16:41:25 DEBUG [,,,,] [http-/0.0.0.0:8080-1] it.mycomp.jagent.HttpContext:get:38 - Read key=it.mycomp.jagent.HttpContext$Key@2ac1f5d1\nThe injected code in the servlet, can read the key from it.mycomp.jagent.HttpContext but can't read the Counter from the io.prometheus package.. I'm not sure to understand what you meen with \"custom dispatcher and place the in som java. package\".\nAt the moment the only way i could find is to modify the module dependecies for the javax.servlet.api and add there the dependencies i need like this:\n```\n\n\n\n Insert resources here \n\n\n <--- this is the custom module with the needed library\n    \n\n```\nI don't like this solution very much, because it means that for each module i want to instrument i need to add that dependency manually.. Thanks for your response. Actually i did like you suggest.\nI've created a class in my ajent (that acts like a proxy) and in my advice's i call that proxy in the scope of the agent classloader, that was set in the bootstrap path.\n:+1: . ",
    "snazy": "Using -Dnet.bytebuddy.experimental=true (lets asm use ASM7_EXPERIMENTAL, which knows about nest-based access-control) helps a bit.\nBut as soon as code is generated via ClassWriter, it will fall, since net.bytebuddy.jar.asm.ClassWriter#ClassWriter(net.bytebuddy.jar.asm.ClassReader, int) will always use ASM6, and there's no way in asm to overwrite the API version for ClassWriter although both \"nest methods\" are implemented in ClassWriter. Also mockito isn't yet aware of ASM7_EXPERIMENTAL.. (see mockito PR). After broadening the catch clause to catch Exception, the same code runs fine.. If it helps, the failure happens with a code like \nByteBuddy()\n    .subclass(SomeClass.class)\n    .make()\n    .load(Thread.currentThread().getContextClassLoader(), ClassLoadingStrategy.Default.INJECTION)\n    .getLoaded(). Note: fixed with 1838799b47e4b4b5b84128884ac8a1ff86f5cf45\nWorks fine! Thanks!. ",
    "iaskwho": "when i added:\n .ignore(none())\nit works  but why........ thank you , but how to include matching @CodingFabian , e.g i just want to hook java.io.FileInputStream. i have put the interceptor into bootloader. is there any tutorial about Advice?. ",
    "kwart": "Great! Thanks @raphw for the explanation. We'll fix the usage on our side.. ",
    "ncomet": "Just to avoid duplicates, isn't this the same issue as https://github.com/raphw/byte-buddy/issues/391 ?. ",
    "hearbeathorror": "@raphw : I am sorry but can you please tell me what i should check and how to perform this check? Apologies for the late response i wasn't notified of any updates on this thread.. @raphw : powermock module agent jar has this VirtualMachine file. (not sure if i explained it well)\nthis is the function that is getting called, and the return value is null:\n```/\n    * \n    * Attaches to a Java virtual machine.\n    * \n    * \n    * This method obtains the list of attach providers by invoking the\n    * {@link com.sun.tools.attach.spi.AttachProvider#providers() AttachProvider.providers()} method.\n    * It then iterates overs the list and invokes each provider's {@link\n    * com.sun.tools.attach.spi.AttachProvider#attachVirtualMachine(java.lang.String)\n    * attachVirtualMachine} method in turn. If a provider successfully\n    * attaches then the iteration terminates, and the VirtualMachine created\n    * by the provider that successfully attached is returned by this method.\n    * If the {@code attachVirtualMachine} method of all providers throws\n    * {@link com.sun.tools.attach.AttachNotSupportedException AttachNotSupportedException}\n    * then this method also throws {@code AttachNotSupportedException}.\n    * This means that {@code AttachNotSupportedException} is thrown when\n    * the identifier provided to this method is invalid, or the identifier\n    * corresponds to a Java virtual machine that does not exist, or none\n    * of the providers can attach to it. This exception is also thrown if\n    * {@link com.sun.tools.attach.spi.AttachProvider#providers()\n    * AttachProvider.providers()} returns an empty list.\n    * \n\n    * @param id The abstract identifier that identifies the Java virtual machine.\n    * @return A VirtualMachine representing the target VM.\n    * @throws SecurityException           If a security manager has been installed and it denies\n    *                                     {@link com.sun.tools.attach.AttachPermission AttachPermission}\n    *                                     (\"attachVirtualMachine\"), or another permission\n    *                                     required by the implementation.\n    * @throws IOException                 If an I/O error occurs\n    /\n   public static VirtualMachine attach(String id) throws AttachNotSupportedException, IOException\n   {\n      List providers = AttachProvider.providers();\n      AttachNotSupportedException lastExc = null;\n  for (AttachProvider provider : providers) {\n     try {\n        return provider.attachVirtualMachine(id);\n     }\n     catch (AttachNotSupportedException x) {\n        lastExc = x;\n     }\n  }\n\n  throw lastExc;\n\n}```. I have no idea why my jvm reads: \nJVM name           : OpenJDK 64-Bit Server VM, when i have oracle's installed \nBut even shifting to mockk dependency for testing, it points to the virtual machine inside powermock's jar or something of the sort. @raphw , hope that helps. any idea when you might release 1.8.21 ? as i see this marked for the same release?. Yeah i guess so, this is what java -version returns to me:\n\nThis is what the error returns or prints:\n\n. Ideally yeah, you shud receive an empty list as per the code:\n\nI can confirm its providers with size 0, i debugged the same. @raphw . @raphw : And how do i check this :(. m not sure i know, can u please guide?. I however use the jdk path that is chosen by default in android studio. . This leads me to the system folder that just has library. That one has java but no bin folder and no tools.jar .. . @raphw : Hi, i changed the jdk location to a custom installed location and now using the jdk location studio uses by default. This new location has home and inside it lib and tools.jar. \nBut net buddy still gives me an issue.\ni dont know why getProperty(java.home) gives me /system\nwhile the env variable in mac os is: /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home\ndoes \"java.home\" refer to the same? \nBelow is the console that opens when tapping on java inside system preferences , can i change this? I am not able to edit it from the box .\n[\n\n]. @raphw : here is the path that android studio auto selects: \n/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home\nMeanwhile i will look for how to change jvm settings in android studio .. . @raphw : no, i dont think android studio is using this library path setup that i hve installed. . no, System.getProperty returns \"/system\" .. It has a java folder (default macos ) i think. I will send u the other file you are asking for .. output.txt\n. @raphw : yes true, i get :  System.getProperty(java.home) -> /system . Is there a way i can by pass this or modify it from studio or something of the sort? . System.getProperty() >>> java.io.tmpdir=/data/user/0/com.dhara.carmania/cache\nSystem.getProperty() >>> http.agent=Dalvik/2.1.0 (Linux; U; Android 8.1.0; Android SDK built for x86 Build/OPM1.171004.001)\nSystem.getProperty() >>> user.home=\nI just got this much, when i iterated thru System.getProperties. where do i add this? in the vm options? . /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/java -Didea.test.cyclic.buffer.size=1048576 -Didea.launcher.port=55367 \"-Didea.launcher.bin.path=/Applications/Android Studio.app/Contents/bin\" -Dfile.encoding=UTF-8 -classpath \"/Applications/Android Studio.app/Contents/lib/idea_rt.jar:/Applications/Android Studio.app/Contents/plugins/junit/lib/junit-rt.jar:/Applications/Android Studio.app/Contents/plugins/junit/lib/junit5-rt.jar:/Users/dharasandeeppravinch/Library/Android/sdk/platforms/android-27/data/res:/Users/dharasandeeppravinch/Documents/movieapp/app/build/intermediates/classes/test/debug:/Users/dharasandeeppravinch/Documents/movieapp/app/build/intermediates/classes/debug:/Users/dharasandeeppravinch/Documents/movieapp/app/build/tmp/kotlin-classes/debug:/Users/dharasandeeppravinch/Documents/movieapp/app/build/tmp/kapt3/classes/debug:/Users/dharasandeeppravinch/Documents/movieapp/app/build/generated/res/rs/debug:/Users/dharasandeeppravinch/Documents/movieapp/app/build/generated/res/resValues/debug:/Users/dharasandeeppravinch/Documents/movieapp/app/build/tmp/kotlin-classes/debugUnitTest:/Users/dharasandeeppravinch/Documents/movieapp/app/build/tmp/kapt3/classes/debugUnitTest:/Users/dharasandeeppravinch/Documents/movieapp/app/build/intermediates/sourceFolderJavaResources/test/debug:/Users/dharasandeeppravinch/Library/Android/sdk/extras/m2repository/com/android/support/constraint/constraint-layout-solver/1.0.2/constraint-layout-solver-1.0.2.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/transition-27.0.2.aar/d0e64e448c75e9ee4777aaa027c17ff8/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/transition-27.0.2.aar/d0e64e448c75e9ee4777aaa027c17ff8/res:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-classloading-xstream/2.0.0-beta.5/7967431c9254796e7a4b26163af98f2e93f1e165/powermock-classloading-xstream-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/espresso-idling-resource-2.2.2.aar/30fca4e6285b2d84ddeb18ab6e9c7e06/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/2.6/639033469776fd37c08358c6b92a4761feb2af4b/objenesis-2.6.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.2.61/5bc44acc4b3f0d19166ae3e50454b41e8ff29335/kotlin-stdlib-1.2.61.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/animated-vector-drawable-27.0.2.aar/341ac82ee9a02be15e8f8a097c2ea6b2/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/support-compat-27.0.2.aar/20fbb3976a74fea0cb088259143d6f21/res:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/support-compat-27.0.2.aar/20fbb3976a74fea0cb088259143d6f21/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/io.mockk/mockk-common/1.8.7/b4321b8ebedab43f98f63816406640f714db6cc/mockk-common-1.8.7.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.7/751f548c85fa49f330cecbb1875893f971b33c4e/gson-2.7.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/io.mockk/mockk-dsl-jvm/1.8.7/4a9859e8921cddec4ab98d49141099632e944550/mockk-dsl-jvm-1.8.7.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.google.dagger/dagger/2.11/95037eaee68aa48021511972e9db9ba29916e1c9/dagger-2.11.jar:/Users/dharasandeeppravinch/Documents/movieapp/app/build/intermediates/unmocked-androidapp.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.hamcrest/java-hamcrest/2.0.0.0/f1c8853ade0ecf707f5a261c830e98893983813/java-hamcrest-2.0.0.0.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-module-junit4-rule-agent/2.0.0-beta.5/65f0811f9f35212a9e40a800f66fced4e7d12f15/powermock-module-junit4-rule-agent-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/support-vector-drawable-27.0.2.aar/a0946da64cbb196be8e2a164dca5bf2c/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/support-core-utils-27.0.2.aar/e042b239a51e15ddcd73e182625f487b/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.jetbrains/annotations/13.0/919f0dfe192fb4e063e7dacadee7f8bb9a2672a9/annotations-13.0.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/xpp3/xpp3_min/1.1.4c/19d4e90b43059058f6e056f794f0ea4030d60b86/xpp3_min-1.1.4c.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-module-junit4-common/2.0.0-beta.5/cb845360267ab2dfac0ac1d59819501a66ccd139/powermock-module-junit4-common-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-reflect/1.2.61/6fd5bcfc9ffc446dd147ea006bee7ef5f0ad8ca4/kotlin-reflect-1.2.61.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/javax.inject/javax.inject/1/6975da39a7040257bd51d21a231b76c915872d38/javax.inject-1.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/FlowTextView-2.0.5.aar/1d43acb03039a028984a9e26148569b6/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.squareup.retrofit2/retrofit/2.3.0/bcacde6a8ccedcc56c127403d26b76072fe6214d/retrofit-2.3.0.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jdk7/1.2.61/bc77c34ff80df88b4d9b0418ea4ae758544573f3/kotlin-stdlib-jdk7-1.2.61.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.squareup.retrofit2/converter-gson/2.0.1/2780d858273ce1bb90f6b12e1ef0d40f7741fca/converter-gson-2.0.1.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/javax.annotation/jsr250-api/1.0/5025422767732a1ab45d93abfea846513d742dcf/jsr250-api-1.0.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/io.reactivex.rxjava2/rxjava/2.1.0/2fdf84dedcaaeabb9d70cde9dbb8aad4eccb80a1/rxjava-2.1.0.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/fontawesome-typeface-4.7.0.2.aar/80a1de4570dbd0041ae2753fd9b7c10f/res:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/fontawesome-typeface-4.7.0.2.aar/80a1de4570dbd0041ae2753fd9b7c10f/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.squareup.okhttp3/okhttp/3.8.0/5a11f020cce2d11eb71ba916700600e18c4547e7/okhttp-3.8.0.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/gifdecoder-4.6.1.aar/113cc4c67888ca422b1fc3a2e9deaa58/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.github.bumptech.glide/disklrucache/4.6.1/2f82d433b9dae134a9b32039a6b5b38abe8a1c46/disklrucache-4.6.1.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-api-support/2.0.0-beta.5/613616628925ecc461ed8b826e44b0c4928261e0/powermock-api-support-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-classloading-base/2.0.0-beta.5/cb04ff970ea19a8466ea6267b45d83b137d5326a/powermock-classloading-base-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-module-junit4/2.0.0-beta.5/4863d6a71361f1aaa7c162146646c50a47e97ee3/powermock-module-junit4-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.javassist/javassist/3.22.0-CR2/44eaf0990dea92f4bca4b9931b2239c0e8756ee7/javassist-3.22.0-CR2.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/support-v4-27.0.2.aar/de67e6fb5fb33ae7d3193be03692d7ab/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.nhaarman.mockitokotlin2/mockito-kotlin/2.0.0-RC1/e60845f90488ffda2ebe1de084ec1af615543940/mockito-kotlin-2.0.0-RC1.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/io.mockk/mockk-agent-common/1.8.7/89d6f678ee414963b87c586aca710b329c75d889/mockk-agent-common-1.8.7.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.thoughtworks.xstream/xstream/1.4.10/dfecae23647abc9d9fd0416629a4213a3882b101/xstream-1.4.10.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-core/2.0.0-beta.5/3e148ed3b247bc856e8e067349983bbd4f047698/powermock-core-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/io.mockk/mockk-agent-jvm/1.8.7/bd5d40b24f635d1736a731a751757fd8dada559c/mockk-agent-jvm-1.8.7.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-module-javaagent/2.0.0-beta.5/f0f3a1ace703bdfdd65f66de30e17476b95e39f2/powermock-module-javaagent-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-api-mockito2/2.0.0-beta.5/5aadd697a176794368d6750aafe6d7525ddbcef8/powermock-api-mockito2-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.squareup.okio/okio/1.13.0/a9283170b7305c8d92d25aff02a6ab7e45d06cbe/okio-1.13.0.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streams/1.0.0/14b8c877d98005ba3941c9257cfe09f6ed0e0d74/reactive-streams-1.0.0.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/2.21.0/cdd1d0d5b2edbd2a7040735ccf88318c031f458b/mockito-core-2.21.0.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/android.arch.core/common/1.0.0/a2d487452376193fc8c103dd2b9bd5f2b1b44563/common-1.0.0.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/recyclerview-v7-27.0.2.aar/2c7d60b8e21cd61058f074cfcd7982ac/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/recyclerview-v7-27.0.2.aar/2c7d60b8e21cd61058f074cfcd7982ac/res:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/glide-4.6.1.aar/d51db4e4ce5b419c3f99005f318cb51f/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/support-media-compat-27.0.2.aar/74cb3ebbfc887adccad27db14e4e674d/res:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/support-media-compat-27.0.2.aar/74cb3ebbfc887adccad27db14e4e674d/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/support-core-ui-27.0.2.aar/c802199f52f1956be81c09b15181603a/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/io.mockk/mockk-agent-api/1.8.7/3649e5c899ff965fe3280335ca861bdad309ac02/mockk-agent-api-1.8.7.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.github.bumptech.glide/annotations/4.6.1/278bafb890704b66a1d6a8a98d0790f940aa5a22/annotations-4.6.1.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.android.support/support-annotations/27.0.2/b9ef4342c934a1a8b107506273dc8061662a322/support-annotations-27.0.2.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/iconics-core-3.0.0.aar/6712b9ad6813ff7d193013bf0f47ade4/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/iconics-core-3.0.0.aar/6712b9ad6813ff7d193013bf0f47ade4/res:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/flexbox-0.3.2.aar/4636489e898af69d61f1e73224ab0929/res:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/flexbox-0.3.2.aar/4636489e898af69d61f1e73224ab0929/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-junit/2.0.0.0/221cf2b5aabedf8cd76534996caa21b283ea5d0/hamcrest-junit-2.0.0.0.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/support-fragment-27.0.2.aar/ffb48d997a54c5bbaa35c98a8602bfc5/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/rxandroid-2.0.1.aar/47c50c9202dd7894aa84344272332f2a/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/constraint-layout-1.0.2.aar/d567cef2b0046b6b3bcf15f465f4a8c4/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/constraint-layout-1.0.2.aar/d567cef2b0046b6b3bcf15f465f4a8c4/res:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/junit/junit/4.12/2973d150c0dc1fefe998f834810d68f278ea58ec/junit-4.12.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/design-27.0.2.aar/69b7f18e65c1b596a7adf976322bbcb3/res:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/design-27.0.2.aar/69b7f18e65c1b596a7adf976322bbcb3/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy/1.8.15/cb36fe3c70ead5fcd016856a7efff908402d86b8/byte-buddy-1.8.15.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/appcompat-v7-27.0.2.aar/24ef199235549deb501369df50ed9e9a/res:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/appcompat-v7-27.0.2.aar/24ef199235549deb501369df50ed9e9a/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy-agent/1.8.15/a2dbe3457401f65ad4022617fbb3fc0e5f427c7d/byte-buddy-agent-1.8.15.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/io.mockk/mockk-dsl/1.8.7/78783b4677170d0dc3f66ff8fc4faad2b8e198f3/mockk-dsl-1.8.7.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/com.squareup.retrofit2/adapter-rxjava2/2.3.0/f436637f9500ab5b8bc32afe556373180894b4a5/adapter-rxjava2-2.3.0.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.powermock/powermock-reflect/2.0.0-beta.5/4ea415348f15620783a1f26343d6732adfa86bc8/powermock-reflect-2.0.0-beta.5.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-common/1.2.61/772de03e12d932f489e41aef997d26c20a4ebee6/kotlin-stdlib-common-1.2.61.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/runtime-1.0.3.aar/0b2839a297936af1a68666ba8091ecdd/jars/classes.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/io.mockk/mockk/1.8.7/79c077c3704aa9e07605c70242a71d621b3a5f/mockk-1.8.7.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/xmlpull/xmlpull/1.1.3.1/2b8e230d2ab644e4ecaa94db7cdedbc40c805dfa/xmlpull-1.1.3.1.jar:/Users/dharasandeeppravinch/.gradle/caches/modules-2/files-2.1/android.arch.lifecycle/common/1.0.3/7d7f60c4783872861222166f6164215f8951c7b1/common-1.0.3.jar:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/iconics-views-3.0.0.aar/97ad0c77dad0854a4cd37727b5579e0d/res:/Users/dharasandeeppravinch/.gradle/caches/transforms-1/files-1.1/iconics-views-3.0.0.aar/97ad0c77dad0854a4cd37727b5579e0d/jars/classes.jar:/Users/dharasandeeppravinch/Documents/movieapp/app/build/intermediates/sourceFolderJavaResources/debug:/Users/dharasandeeppravinch/Documents/movieapp/app/build/generated/mockable-android-27.v3.jar\" com.intellij.rt.execution.application.AppMainV2 com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 com.test.movieapp.movie.home.model.MoviesModelAdapterImplTest\nis this any help? . Yes i have, i tried using the library location that i talked about earlier.  but still the same issue. . @raphw : Thanks alot for your assistance. I will try with the new update. And i will try and talk to the android team incase there is some issue with installation or something else altogether.\nThanks alot \ud83d\udc4d . Hi @raphw : I found out why it was running correctly. Default version was set to android sdk 27 in the configuration screen for running test cases. So when i manually changed it to 1.8 jre , it worked correctly.  (as in the image)\n\n. ",
    "RuslanYaniuk": "Thanks for your quick reply. \nSo, if I want to create a type based on the previously generated types it's important not to load and use them before I finish the creation of the final type, is it correct?. ",
    "adamjryan": "Thanks for the speedy response. I added the ClassLoadingStrategy.Default.INJECTION and now get:\nException in thread \"main\" java.lang.NoSuchMethodError: Scenario$NumberFactoryTemplate$1.<init>(LNewNumberFactory;)V\nI'm still a bit unclear on the cause of the issue as if the class is being cloned it shouldn't need access to anything from the original class, although I can see the need to link it with the package of the common interface.. Ah the goal was to generate a new inner class as well, I'll take a look at MemberSubstitution. Thanks.. ",
    "quarante-2": "Good! But I think it cannot be applied as closure (I haven't tested it however). Following the current dsl style, I think it should look like:\ngroovy\nbyteBuddy {\n    transformation {\n        plugin = 'FooPlugin'\n        argument { value = 'Foo' }\n        argument { index = 1; value = 'Bar' }\n        argument {\n            index = 2\n            value = 'Baz'\n        }\n    }\n}\nI think that this could be supported by adding a method, that takes a closure and adds the argument to the list, in the Transformation class. Similar to how it's done for the transformations in ByteBuddyExtension.\njava\n   // Note that the list must be initialized and both getter/setter must be declared for it.\n   public void argument(Closure<?> closure) {\n        PluginArgument argument = (PluginArgument) project.configure(new PluginArgument(), closure);\n        arguments.add(argument);\n    }\nNote that I'm not sure if that is the recommended way of doing this, I just looked at the transformation code.\nThanks!. It works - great! Note that direct assignments like arguments = [...] do not work anymore, but that's fine.. It's for a side project - so unfortunately I can't do it.\nBut I appreciate your work and look forward to improvements of the member substitution component.\nThanks a lot for the fix, all my tests passed!. ",
    "pdoro": "I'm trying to get the dump for the environment where the exception ocurred but it might not be possible due to security restrictions. Meanwhile I'll attach the dumps that ByteBuddy produce on my local env hoping the will help you.\nI don't get what you mean about the stack trace. Do you mean the stack trace of the thread that crashes? If so, the only stack I have is the one I posted before. If not, please explain me how I can get this stack trace.\ndump.zip. No, the crash only happens on the server but I might not be able to extract the dump for the server (k8s env with secured dockers) so I attached a dump from my local machine where it does run (maybe it shed some light). I guarantee you there is no external java agent weaving the code. The only bytecode generation apart from bytebuddy is the one performed by cglib and spring but that does not apply to RestTemplate. What does you mean by accident? You mean that the protected call should be performed on the subclass implementation rather than on the provided bean?. Ok, now I get it. Is it possible for ByteBuddy to throw an exception if you try to delegate protected invocations to an object if the strategy selected does not allow this behaviour or the package doesn't match the original one?. Ok then, thank you very much for your time and guidance. You can close the issue.\nPS: a safe practice would be to only proxy public methods of 3rd party classes?. The JVM version is:\n\njava version \"1.8.0_121\"\nJava(TM) SE Runtime Environment (build 1.8.0_121-b31)\nJava HotSpot(TM) 64-Bit Server VM (build 25.121-b31, mixed mode). \n",
    "liujoshua": "Thanks for the quick reply! Here's a stacktrace\n```\n* Exception is:\norg.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration$ArtifactResolveException: Could not resolve all files for configuration ':motor-control-module:debugUnitTestCompileClasspath'.\n        at org.gradle.api.internal.artifacts.configurations.DefaultConfiguration.rethrowFailure(DefaultConfiguration.java:1013)\n        at org.gradle.api.internal.artifacts.configurations.DefaultConfiguration.access$1700(DefaultConfiguration.java:123)\n        at org.gradle.api.internal.artifacts.configurations.DefaultConfiguration$ConfigurationFileCollection.getFiles(DefaultConfiguration.java:987)\n        at org.gradle.api.internal.file.AbstractFileCollection.iterator(AbstractFileCollection.java:76)\n        at org.gradle.api.internal.changedetection.state.AbstractFileCollectionSnapshotter$FileCollectionVisitorImpl.visitCollection(AbstractFileCollectionSnapshotter.java:72)\n        at org.gradle.api.internal.file.AbstractFileCollection.visitRootElements(AbstractFileCollection.java:282)\n        at org.gradle.api.internal.file.CompositeFileCollection.visitRootElements(CompositeFileCollection.java:206)\n        at org.gradle.api.internal.changedetection.state.AbstractFileCollectionSnapshotter.snapshot(AbstractFileCollectionSnapshotter.java:55)\n        at org.gradle.api.internal.changedetection.state.DefaultClasspathSnapshotter.snapshot(DefaultClasspathSnapshotter.java:42)\n        at org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository.snapshotTaskFiles(CacheBackedTaskHistoryRepository.java:334)\n        at org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository.createExecution(CacheBackedTaskHistoryRepository.java:156)\n        at org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository.access$100(CacheBackedTaskHistoryRepository.java:66)\n        at org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository$1.getCurrentExecution(CacheBackedTaskHistoryRepository.java:116)\n        at org.gradle.api.internal.changedetection.changes.DefaultTaskArtifactStateRepository$TaskArtifactStateImpl.calculateCacheKey(DefaultTaskArtifactStateRepository.java:129)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter.doResolve(ResolveBuildCacheKeyExecuter.java:106)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter.access$000(ResolveBuildCacheKeyExecuter.java:48)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter$1.run(ResolveBuildCacheKeyExecuter.java:90)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:317)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:309)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:185)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:97)\n        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter.resolve(ResolveBuildCacheKeyExecuter.java:87)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter.execute(ResolveBuildCacheKeyExecuter.java:65)\n        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)\n        at org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)\n        at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)\n        at org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)\n        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)\n        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)\n        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.run(EventFiringTaskExecuter.java:51)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:317)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:309)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:185)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:97)\n        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:46)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$ExecuteTaskAction.execute(DefaultTaskExecutionGraph.java:262)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$ExecuteTaskAction.execute(DefaultTaskExecutionGraph.java:246)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:136)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:130)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.execute(DefaultTaskPlanExecutor.java:201)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.executeWithTask(DefaultTaskPlanExecutor.java:192)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.run(DefaultTaskPlanExecutor.java:130)\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\n        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\n        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\nCause 1: org.gradle.api.artifacts.transform.ArtifactTransformException: Failed to transform file 'byte-buddy-1.9.0.jar' to match attributes {artifactType=jetified-jar} using transform JetifyTransform\n        at org.gradle.api.internal.artifacts.transform.UserCodeBackedTransformer.transform(UserCodeBackedTransformer.java:89)\n        at org.gradle.api.internal.artifacts.transform.ChainedTransformer.transform(ChainedTransformer.java:36)\n        at org.gradle.api.internal.artifacts.transform.TransformArtifactOperation.run(TransformArtifactOperation.java:41)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:317)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:309)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:185)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.access$900(DefaultBuildOperationExecutor.java:50)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$ParentPreservingQueueWorker.execute(DefaultBuildOperationExecutor.java:359)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runOperation(DefaultBuildOperationQueue.java:230)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.access$600(DefaultBuildOperationQueue.java:172)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.call(DefaultBuildOperationQueue.java:209)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.call(DefaultBuildOperationQueue.java:203)\n        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:152)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runBatch(DefaultBuildOperationQueue.java:202)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.run(DefaultBuildOperationQueue.java:177)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue.waitForCompletion(DefaultBuildOperationQueue.java:116)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.executeInParallel(DefaultBuildOperationExecutor.java:146)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.runAll(DefaultBuildOperationExecutor.java:117)\n        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.runAll(DelegatingBuildOperationExecutor.java:41)\n        at org.gradle.api.internal.artifacts.ivyservice.resolveengine.artifact.ParallelResolveArtifactSet$VisitingSet.visit(ParallelResolveArtifactSet.java:60)\n        at org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration.visitArtifacts(DefaultLenientConfiguration.java:255)\n        at org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration.access$500(DefaultLenientConfiguration.java:68)\n        at org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration$2.run(DefaultLenientConfiguration.java:230)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:317)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:309)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:185)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:97)\n        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)\n        at org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration.visitArtifactsWithBuildOperation(DefaultLenientConfiguration.java:227)\n        at org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration.access$200(DefaultLenientConfiguration.java:68)\n        at org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration$1.visitArtifacts(DefaultLenientConfiguration.java:132)\n        at org.gradle.api.internal.artifacts.configurations.DefaultConfiguration$ConfigurationFileCollection.getFiles(DefaultConfiguration.java:984)\n        at org.gradle.api.internal.file.AbstractFileCollection.iterator(AbstractFileCollection.java:76)\n        at org.gradle.api.internal.changedetection.state.AbstractFileCollectionSnapshotter$FileCollectionVisitorImpl.visitCollection(AbstractFileCollectionSnapshotter.java:72)\n        at org.gradle.api.internal.file.AbstractFileCollection.visitRootElements(AbstractFileCollection.java:282)\n        at org.gradle.api.internal.file.CompositeFileCollection.visitRootElements(CompositeFileCollection.java:206)\n        at org.gradle.api.internal.changedetection.state.AbstractFileCollectionSnapshotter.snapshot(AbstractFileCollectionSnapshotter.java:55)\n        at org.gradle.api.internal.changedetection.state.DefaultClasspathSnapshotter.snapshot(DefaultClasspathSnapshotter.java:42)\n        at org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository.snapshotTaskFiles(CacheBackedTaskHistoryRepository.java:334)\n        at org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository.createExecution(CacheBackedTaskHistoryRepository.java:156)\n        at org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository.access$100(CacheBackedTaskHistoryRepository.java:66)\n        at org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository$1.getCurrentExecution(CacheBackedTaskHistoryRepository.java:116)\n        at org.gradle.api.internal.changedetection.changes.DefaultTaskArtifactStateRepository$TaskArtifactStateImpl.calculateCacheKey(DefaultTaskArtifactStateRepository.java:129)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter.doResolve(ResolveBuildCacheKeyExecuter.java:106)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter.access$000(ResolveBuildCacheKeyExecuter.java:48)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter$1.run(ResolveBuildCacheKeyExecuter.java:90)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:317)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:309)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:185)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:97)\n        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter.resolve(ResolveBuildCacheKeyExecuter.java:87)\n        at org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter.execute(ResolveBuildCacheKeyExecuter.java:65)\n        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)\n        at org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)\n        at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)\n        at org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)\n        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)\n        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)\n        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.run(EventFiringTaskExecuter.java:51)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:317)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:309)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:185)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:97)\n        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:46)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$ExecuteTaskAction.execute(DefaultTaskExecutionGraph.java:262)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$ExecuteTaskAction.execute(DefaultTaskExecutionGraph.java:246)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:136)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:130)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.execute(DefaultTaskPlanExecutor.java:201)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.executeWithTask(DefaultTaskPlanExecutor.java:192)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.run(DefaultTaskPlanExecutor.java:130)\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\n        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\n        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\nCaused by: java.lang.RuntimeException: Failed to transform '\\home.gradle\\caches\\modules-2\\files-2.1\\net.bytebuddy\\byte-buddy\\1.9.0\\8cb0d5baae526c9df46ae17693bbba302640538b\\byte-buddy-1.9.0.jar' using Jetifier. Reason: The type does not support '.' as package separator!. (Run with --stacktrace for more details.) To disable Jetifier, set android.enableJetifier=false in your gradle.properties file.\n        at com.android.build.gradle.internal.dependency.JetifyTransform.transform(JetifyTransform.kt:204)\n        at org.gradle.api.internal.artifacts.transform.TransformArtifactsAction.apply(TransformArtifactsAction.java:44)\n        at org.gradle.api.internal.artifacts.transform.TransformArtifactsAction.apply(TransformArtifactsAction.java:29)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$TransformAction.execute(DefaultTransformedFileCache.java:224)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$TransformAction.execute(DefaultTransformedFileCache.java:211)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore$1.execute(DefaultPathKeyFileStore.java:91)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore$1.execute(DefaultPathKeyFileStore.java:87)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore.doAdd(DefaultPathKeyFileStore.java:137)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore.doAdd(DefaultPathKeyFileStore.java:127)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore.add(DefaultPathKeyFileStore.java:87)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore.add(DefaultPathKeyFileStore.java:50)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$1$1.create(DefaultTransformedFileCache.java:143)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$1$1.create(DefaultTransformedFileCache.java:122)\n        at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.withFileLock(LockOnDemandCrossProcessCacheAccess.java:89)\n        at org.gradle.cache.internal.DefaultCacheAccess.withFileLock(DefaultCacheAccess.java:193)\n        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.withFileLock(DefaultPersistentDirectoryStore.java:158)\n        at org.gradle.cache.internal.DefaultCacheFactory$ReferenceTrackingCache.withFileLock(DefaultCacheFactory.java:187)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$1.create(DefaultTransformedFileCache.java:122)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$1.create(DefaultTransformedFileCache.java:115)\n        at org.gradle.cache.internal.ProducerGuard$AdaptiveProducerGuard.guardByKey(ProducerGuard.java:97)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache.loadIntoCache(DefaultTransformedFileCache.java:115)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache.getResult(DefaultTransformedFileCache.java:107)\n        at org.gradle.api.internal.artifacts.transform.UserCodeBackedTransformer.transform(UserCodeBackedTransformer.java:87)\n        ... 78 more\nCaused by: java.lang.IllegalArgumentException: The type does not support '.' as package separator!\n        at com.android.tools.build.jetifier.core.type.JavaType.(JavaType.kt:28)\n        at com.android.tools.build.jetifier.processor.transform.bytecode.asm.CustomRemapper.map(CustomRemapper.kt:29)\n        at org.objectweb.asm.commons.Remapper.mapPackageName(Remapper.java:235)\n        at org.objectweb.asm.commons.ModuleRemapper.visitPackage(ModuleRemapper.java:61)\n        at org.objectweb.asm.ClassReader.readModule(ClassReader.java:744)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:632)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:500)\n        at com.android.tools.build.jetifier.processor.transform.bytecode.ByteCodeTransformer.runTransform(ByteCodeTransformer.kt:39)\n        at com.android.tools.build.jetifier.processor.Processor.visit(Processor.kt:328)\n        at com.android.tools.build.jetifier.processor.archive.ArchiveFile.accept(ArchiveFile.kt:41)\n        at com.android.tools.build.jetifier.processor.Processor.visit(Processor.kt:316)\n        at com.android.tools.build.jetifier.processor.archive.Archive.accept(Archive.kt:66)\n        at com.android.tools.build.jetifier.processor.Processor.transformLibrary(Processor.kt:312)\n        at com.android.tools.build.jetifier.processor.Processor.transform(Processor.kt:175)\n        at com.android.build.gradle.internal.dependency.JetifyTransform.transform(JetifyTransform.kt:199)\n        ... 100 more\nCause 2: org.gradle.api.artifacts.transform.ArtifactTransformException: Failed to transform file 'byte-buddy-agent-1.9.0.jar' to match attributes {artifactType=jetified-jar} using transform JetifyTransform\n        at org.gradle.api.internal.artifacts.transform.UserCodeBackedTransformer.transform(UserCodeBackedTransformer.java:89)\n        at org.gradle.api.internal.artifacts.transform.ChainedTransformer.transform(ChainedTransformer.java:36)\n        at org.gradle.api.internal.artifacts.transform.TransformArtifactOperation.run(TransformArtifactOperation.java:41)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:317)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:309)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:185)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.access$900(DefaultBuildOperationExecutor.java:50)\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor$ParentPreservingQueueWorker.execute(DefaultBuildOperationExecutor.java:359)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runOperation(DefaultBuildOperationQueue.java:230)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.access$600(DefaultBuildOperationQueue.java:172)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.call(DefaultBuildOperationQueue.java:209)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.call(DefaultBuildOperationQueue.java:203)\n        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:152)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runBatch(DefaultBuildOperationQueue.java:202)\n        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.run(DefaultBuildOperationQueue.java:177)\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\n        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\n        at java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.RuntimeException: Failed to transform '\\home.gradle\\caches\\modules-2\\files-2.1\\net.bytebuddy\\byte-buddy-agent\\1.9.0\\37b5703b4a6290be3fffc63ae9c6bcaaee0ff856\\byte-buddy-agent-1.9.0.jar' using Jetifier. Reason: The type does not support '.' as package separator!. (Run with --stacktrace for more details.) To disable Jetifier, set android.enableJetifier=false in your gradle.properties file.\n        at com.android.build.gradle.internal.dependency.JetifyTransform.transform(JetifyTransform.kt:204)\n        at org.gradle.api.internal.artifacts.transform.TransformArtifactsAction.apply(TransformArtifactsAction.java:44)\n        at org.gradle.api.internal.artifacts.transform.TransformArtifactsAction.apply(TransformArtifactsAction.java:29)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$TransformAction.execute(DefaultTransformedFileCache.java:224)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$TransformAction.execute(DefaultTransformedFileCache.java:211)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore$1.execute(DefaultPathKeyFileStore.java:91)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore$1.execute(DefaultPathKeyFileStore.java:87)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore.doAdd(DefaultPathKeyFileStore.java:137)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore.doAdd(DefaultPathKeyFileStore.java:127)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore.add(DefaultPathKeyFileStore.java:87)\n        at org.gradle.internal.resource.local.DefaultPathKeyFileStore.add(DefaultPathKeyFileStore.java:50)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$1$1.create(DefaultTransformedFileCache.java:143)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$1$1.create(DefaultTransformedFileCache.java:122)\n        at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.withFileLock(LockOnDemandCrossProcessCacheAccess.java:89)\n        at org.gradle.cache.internal.DefaultCacheAccess.withFileLock(DefaultCacheAccess.java:193)\n        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.withFileLock(DefaultPersistentDirectoryStore.java:158)\n        at org.gradle.cache.internal.DefaultCacheFactory$ReferenceTrackingCache.withFileLock(DefaultCacheFactory.java:187)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$1.create(DefaultTransformedFileCache.java:122)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache$1.create(DefaultTransformedFileCache.java:115)\n        at org.gradle.cache.internal.ProducerGuard$AdaptiveProducerGuard.guardByKey(ProducerGuard.java:97)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache.loadIntoCache(DefaultTransformedFileCache.java:115)\n        at org.gradle.api.internal.artifacts.transform.DefaultTransformedFileCache.getResult(DefaultTransformedFileCache.java:107)\n        at org.gradle.api.internal.artifacts.transform.UserCodeBackedTransformer.transform(UserCodeBackedTransformer.java:87)\n        ... 20 more\nCaused by: java.lang.IllegalArgumentException: The type does not support '.' as package separator!\n        at com.android.tools.build.jetifier.core.type.JavaType.(JavaType.kt:28)\n        at com.android.tools.build.jetifier.processor.transform.bytecode.asm.CustomRemapper.map(CustomRemapper.kt:29)\n        at org.objectweb.asm.commons.Remapper.mapPackageName(Remapper.java:235)\n        at org.objectweb.asm.commons.ModuleRemapper.visitPackage(ModuleRemapper.java:61)\n        at org.objectweb.asm.ClassReader.readModule(ClassReader.java:744)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:632)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:500)\n        at com.android.tools.build.jetifier.processor.transform.bytecode.ByteCodeTransformer.runTransform(ByteCodeTransformer.kt:39)\n        at com.android.tools.build.jetifier.processor.Processor.visit(Processor.kt:328)\n        at com.android.tools.build.jetifier.processor.archive.ArchiveFile.accept(ArchiveFile.kt:41)\n        at com.android.tools.build.jetifier.processor.Processor.visit(Processor.kt:316)\n        at com.android.tools.build.jetifier.processor.archive.Archive.accept(Archive.kt:66)\n        at com.android.tools.build.jetifier.processor.Processor.transformLibrary(Processor.kt:312)\n        at com.android.tools.build.jetifier.processor.Processor.transform(Processor.kt:175)\n        at com.android.build.gradle.internal.dependency.JetifyTransform.transform(JetifyTransform.kt:199). I haven't been able to find byte-buddy-1.8.23. Oddly, I don't see byte-buddy-1.9.0 in my gradle transitive dependency tree and am digging into this a bit more.. Got it working, thanks for the help! (Turns out I was looking at the dependencies for a different module). ",
    "martinbonnin": "I'm having a similar issue with Jetifier here (albeit with a different stacktrace). Tried to use version 1.9.0 and version 1.9.1 but still get the error:\nerror processing /home/martin/.gradle/caches/transforms-1/files-1.1/byte-buddy-1.9.1.jar/4495d00146ae35ef207d29081b237320/jetified-byte-buddy-1.9.1.jar\njava.lang.RuntimeException\nat org.objectweb.asm.ClassVisitor.visitModule(ClassVisitor.java:148)\nat org.objectweb.asm.ClassReader.readModule(ClassReader.java:731)\nat org.objectweb.asm.ClassReader.accept(ClassReader.java:632)\nat org.objectweb.asm.ClassReader.accept(ClassReader.java:500)\nat com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:144)\nat com.android.builder.desugaring.DesugaringClassAnalyzer.analyzeJar(DesugaringClassAnalyzer.java:92)\nat com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:63)\nat com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.lambda$getInitalGraphData$4(DesugarIncrementalTransformHelper.java:150)\nat java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1424)\nat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\nat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\nat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\nat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\n\n> Task :mobile-ui:transformClassesWithDexBuilderForDebugAndroidTest FAILED\njava.lang.RuntimeException: java.lang.RuntimeException\nat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\nat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\nat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\nat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\nat java.util.concurrent.ForkJoinTask.getThrowableException(ForkJoinTask.java:593)\nat java.util.concurrent.ForkJoinTask.reportException(ForkJoinTask.java:677)\nat java.util.concurrent.ForkJoinTask.join(ForkJoinTask.java:720)\nat com.android.ide.common.internal.WaitableExecutor.waitForTasksWithQuickFail(WaitableExecutor.java:146)\nat com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.getInitalGraphData(DesugarIncrementalTransformHelper.java:162)\nat com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.makeDesugaringGraph(DesugarIncrementalTransformHelper.java:130)\nat com.google.common.base.Suppliers$NonSerializableMemoizingSupplier.get(Suppliers.java:160)\nat com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.getDependenciesPaths(DesugarIncrementalTransformHelper.java:231)\nat com.android.build.gradle.internal.transforms.DexArchiveBuilderTransform.getD8DesugaringCacheInfo(DexArchiveBuilderTransform.java:461)\nat com.android.build.gradle.internal.transforms.DexArchiveBuilderTransform.transform(DexArchiveBuilderTransform.java:375)\nat com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:239)\nat com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:235)\nat com.android.builder.profile.ThreadRecorder.record(ThreadRecorder.java:102)\nat com.android.build.gradle.internal.pipeline.TransformTask.transform(TransformTask.java:230)\nat sun.reflect.GeneratedMethodAccessor509.invoke(Unknown Source)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)\nat org.gradle.api.internal.project.taskfactory.IncrementalTaskAction.doExecute(IncrementalTaskAction.java:50)\nat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)\nat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)\nat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:131)\nat org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:300)\nat org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:292)\nat org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:174)\nat org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:90)\nat org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)\nat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:120)\nat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:99)\nat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:77)\nat org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)\nat org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:59)\nat org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)\nat org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)\nat org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)\nat org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)\nat org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)\nat org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)\nat org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)\nat org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)\nat org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)\nat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.run(EventFiringTaskExecuter.java:51)\nat org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:300)\nat org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:292)\nat org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:174)\nat org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:90)\nat org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)\nat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:46)\nat org.gradle.execution.taskgraph.LocalTaskInfoExecutor.execute(LocalTaskInfoExecutor.java:42)\nat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareWorkItemExecutor.execute(DefaultTaskExecutionGraph.java:273)\nat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareWorkItemExecutor.execute(DefaultTaskExecutionGraph.java:258)\nat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:135)\nat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:130)\nat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker.execute(DefaultTaskPlanExecutor.java:200)\nat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker.executeWithWork(DefaultTaskPlanExecutor.java:191)\nat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker.run(DefaultTaskPlanExecutor.java:130)\nat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\nat org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\nat org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\nat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.RuntimeException\nat org.objectweb.asm.ClassVisitor.visitModule(ClassVisitor.java:148)\nat org.objectweb.asm.ClassReader.readModule(ClassReader.java:731)\nat org.objectweb.asm.ClassReader.accept(ClassReader.java:632)\nat org.objectweb.asm.ClassReader.accept(ClassReader.java:500)\nat com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:144)\nat com.android.builder.desugaring.DesugaringClassAnalyzer.analyzeJar(DesugaringClassAnalyzer.java:92)\nat com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:63)\nat com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.lambda$getInitalGraphData$4(DesugarIncrementalTransformHelper.java:150)\nat java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1424)\nat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\nat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\nat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\nat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\n. What would you recommend as a workaround ? I downgraded the mockito version for now but I'm not very happy with this solution.\n",
    "bio007": "Apparently it's not only affecting projects using jetifier. I've turned the jetifier off and still getting similar error during transformation step. (with Mockito  2.21.16 -> byte-buddy 1.9.7)\nthis is the error:\n```\nerror processing C:\\Users\\user.gradle\\caches\\modules-2\\files-2.1\\net.bytebuddy\\byte-buddy-agent\\1.9.7\\8e7d1b599f4943851ffea125fd9780e572727fc0\\byte-buddy-agent-1.9.7.jar\njava.lang.RuntimeException\n        at org.objectweb.asm.ClassVisitor.visitModule(ClassVisitor.java:148)\n        at org.objectweb.asm.ClassReader.readModule(ClassReader.java:731)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:632)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:500)\n        at com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:144)\n        at com.android.builder.desugaring.DesugaringClassAnalyzer.analyzeJar(DesugaringClassAnalyzer.java:92)\n        at com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:63)\n        at com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.lambda$getInitalGraphData$4(DesugarIncrementalTransformHelper.java:150)\n        at java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1424)\n        at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n        at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n        at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n        at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\n\nTask :sdk:transformClassesWithDexBuilderForFullDebugAndroidTest FAILED\njava.lang.RuntimeException: java.lang.RuntimeException\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n        at java.util.concurrent.ForkJoinTask.getThrowableException(ForkJoinTask.java:593)\n        at java.util.concurrent.ForkJoinTask.reportException(ForkJoinTask.java:677)\n        at java.util.concurrent.ForkJoinTask.join(ForkJoinTask.java:720)\n        at com.android.ide.common.internal.WaitableExecutor.waitForTasksWithQuickFail(WaitableExecutor.java:146)\n        at com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.getInitalGraphData(DesugarIncrementalTransformHelper.java:162)\n        at com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.makeDesugaringGraph(DesugarIncrementalTransformHelper.java:130)\n        at com.google.common.base.Suppliers$NonSerializableMemoizingSupplier.get(Suppliers.java:160)\n        at com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.getDependenciesPaths(DesugarIncrementalTransformHelper.java:231)\n        at com.android.build.gradle.internal.transforms.DexArchiveBuilderTransform.getD8DesugaringCacheInfo(DexArchiveBuilderTransform.java:461)\n        at com.android.build.gradle.internal.transforms.DexArchiveBuilderTransform.transform(DexArchiveBuilderTransform.java:375)\n        at com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:239)\n        at com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:235)\n        at com.android.builder.profile.ThreadRecorder.record(ThreadRecorder.java:102)\n        at com.android.build.gradle.internal.pipeline.TransformTask.transform(TransformTask.java:230)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)\n        at org.gradle.api.internal.project.taskfactory.IncrementalTaskAction.doExecute(IncrementalTaskAction.java:50)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:124)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:113)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:95)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:73)\n        at org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)\n        at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.ResolveTaskOutputCachingStateExecuter.execute(ResolveTaskOutputCachingStateExecuter.java:54)\n        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)\n        at org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)\n        at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)\n        at org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)\n        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)\n        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)\n        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)\n        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker$1.run(DefaultTaskGraphExecuter.java:256)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\n        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:249)\n        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:238)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.processTask(DefaultTaskPlanExecutor.java:123)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.access$200(DefaultTaskPlanExecutor.java:79)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:104)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:98)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.execute(DefaultTaskExecutionPlan.java:663)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.executeWithTask(DefaultTaskExecutionPlan.java:597)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.run(DefaultTaskPlanExecutor.java:98)\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\n        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\n        at java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.RuntimeException\n        at org.objectweb.asm.ClassVisitor.visitModule(ClassVisitor.java:148)\n        at org.objectweb.asm.ClassReader.readModule(ClassReader.java:731)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:632)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:500)\n        at com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:144)\n        at com.android.builder.desugaring.DesugaringClassAnalyzer.analyzeJar(DesugaringClassAnalyzer.java:92)\n        at com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:63)\n        at com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.lambda$getInitalGraphData$4(DesugarIncrementalTransformHelper.java:150)\n        at java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1424)\n        at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n        at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n        at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n        at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\n\nFAILURE: Build failed with an exception.\n\n\nWhat went wrong:\nExecution failed for task ':sdk:transformClassesWithDexBuilderForFullDebugAndroidTest'.\n\ncom.android.build.api.transform.TransformException: java.lang.RuntimeException: java.lang.RuntimeException\n\n\n\nTry:\nRun with --info or --debug option to get more log output. Run with --scan to get full insights.\n\n\nException is:\norg.gradle.api.tasks.TaskExecutionException: Execution failed for task ':sdk:transformClassesWithDexBuilderForFullDebugAndroidTest'.\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:103)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:73)\n        at org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)\n        at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.ResolveTaskOutputCachingStateExecuter.execute(ResolveTaskOutputCachingStateExecuter.java:54)\n        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)\n        at org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)\n        at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)\n        at org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)\n        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)\n        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)\n        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)\n        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)\n        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker$1.run(DefaultTaskGraphExecuter.java:256)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\n        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:249)\n        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:238)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.processTask(DefaultTaskPlanExecutor.java:123)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.access$200(DefaultTaskPlanExecutor.java:79)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:104)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:98)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.execute(DefaultTaskExecutionPlan.java:663)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.executeWithTask(DefaultTaskExecutionPlan.java:597)\n        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.run(DefaultTaskPlanExecutor.java:98)\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\n        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\n        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\nCaused by: java.lang.RuntimeException: com.android.build.api.transform.TransformException: java.lang.RuntimeException: java.lang.RuntimeException\n        at com.android.builder.profile.Recorder$Block.handleException(Recorder.java:55)\n        at com.android.builder.profile.ThreadRecorder.record(ThreadRecorder.java:104)\n        at com.android.build.gradle.internal.pipeline.TransformTask.transform(TransformTask.java:230)\n        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)\n        at org.gradle.api.internal.project.taskfactory.IncrementalTaskAction.doExecute(IncrementalTaskAction.java:50)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:124)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\n        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:113)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:95)\n        ... 30 more\nCaused by: com.android.build.api.transform.TransformException: java.lang.RuntimeException: java.lang.RuntimeException\n        at com.android.build.gradle.internal.transforms.DexArchiveBuilderTransform.transform(DexArchiveBuilderTransform.java:427)\n        at com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:239)\n        at com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:235)\n        at com.android.builder.profile.ThreadRecorder.record(ThreadRecorder.java:102)\n        ... 42 more\nCaused by: java.lang.RuntimeException: java.lang.RuntimeException\n        at com.android.ide.common.internal.WaitableExecutor.waitForTasksWithQuickFail(WaitableExecutor.java:146)\n        at com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.getInitalGraphData(DesugarIncrementalTransformHelper.java:162)\n        at com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.makeDesugaringGraph(DesugarIncrementalTransformHelper.java:130)\n        at com.google.common.base.Suppliers$NonSerializableMemoizingSupplier.get(Suppliers.java:160)\n        at com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.getDependenciesPaths(DesugarIncrementalTransformHelper.java:231)\n        at com.android.build.gradle.internal.transforms.DexArchiveBuilderTransform.getD8DesugaringCacheInfo(DexArchiveBuilderTransform.java:461)\n        at com.android.build.gradle.internal.transforms.DexArchiveBuilderTransform.transform(DexArchiveBuilderTransform.java:375)\n        ... 45 more\nCaused by: java.lang.RuntimeException\n        at org.objectweb.asm.ClassVisitor.visitModule(ClassVisitor.java:148)\n        at org.objectweb.asm.ClassReader.readModule(ClassReader.java:731)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:632)\n        at org.objectweb.asm.ClassReader.accept(ClassReader.java:500)\n        at com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:144)\n        at com.android.builder.desugaring.DesugaringClassAnalyzer.analyzeJar(DesugaringClassAnalyzer.java:92)\n        at com.android.builder.desugaring.DesugaringClassAnalyzer.analyze(DesugaringClassAnalyzer.java:63)\n        at com.android.build.gradle.internal.transforms.DesugarIncrementalTransformHelper.lambda$getInitalGraphData$4(DesugarIncrementalTransformHelper.java:150)\n```\n. \n\n",
    "menjoo": "I was able to solve this by adding the following in the root build.gradle (since i have a multi module project)\nsubprojects {\n    project.configurations.all {\n        resolutionStrategy.eachDependency { details ->\n            if (details.requested.group == 'net.bytebuddy') {\n                details.useVersion \"1.8.22\"\n            }\n        }\n    }\n}. ",
    "ni-ze": "thank you very mach, that's really very helpful.. thx,I figure it out by myself.I want to enhance a subclass which superclass has a annotation on method parameters.If  I do like this:\nnewClassBuilder.method(isDeclaredBy(typeDescription).and(...)).intercept(...)\nIt  will lost the superclass's method parameters annotation .\nIf I do like this:\nnewClassBuilder.method(isDeclaredBy(typeDescription) .and(...)) .intercept(...)\nI will lost superclass's method.\nIf ido like this:\nnewClassBuilder.method(...\n                            .intercept(...)\n                            .attribute(MethodAttributeAppender.ForInstrumentedMethod.EXCLUDING_RECEIVER)\nIt lead  duplicated annotation  when enhance declared method.\nAt last,I use it like this:\nnewClassBuilder.method(isDeclaredBy(typeDescription).and(...))\n                            .intercept(...)\n                            .method(not(isDeclaredBy(typeDescription)).and(...))\n                            .intercept(...)\n                            .attribute(MethodAttributeAppender.ForInstrumentedMethod.EXCLUDING_RECEIVER);\nIt will not lead duplicated annotation,and also can enhance superclass method which has a annotation on parameter correctly.\n. ",
    "AndreasMili": "\nWhat you can do is to use Advice.AllArguments and change only specific argument values programmatically depending on what method you run.\n\nWhat I basically need is to pass a list describing which parameters to change, like this:\n@Advice.OnMethodEnter\n    public static void onEnter(@Advice.This Object obj, @Advice.Origin String method,\n                               @Advice.AllArguments Object[] args, List<Integer> paramsToChange) {\n        paramsToChange.forEach(i -> {\n            // do something with args[i]\n        });\n    }\nSo this is possible with Advice.withCustomMapping().bind(...).to(MyAdvice.class)?\n. Thanks for your blazing fast answers. I'm trying to wrap my head around on how to the custom annotation has to look like.\nSo basically I can achieve this:\n```\nint[] paramsToChange = // read from file\nint[] paramsToChange2 = // read from file\nbuilder.visit(Advice.withCustomMapping().bind(MyAnnotation.class, paramsToChange)\n                   .to(MyAdvice.class).on(named(\"doSomething1\")))\n      .visit(Advice.withCustomMapping().bind(MyAnnotation.class, paramsToChange2)\n                   .to(MyAdvice.class).on(named(\"doSomething2\")));\n\n@Advice.OnMethodEnter\npublic static void onEnter(@Advice.This Object obj, @Advice.Origin String method,\n                           @Advice.AllArguments Object[] args, @MyAnnotation int[] params) {\n}\n```\nWith an annotation like that?\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@java.lang.annotation.Target(ElementType.PARAMETER)\npublic @interface MyAnnotation {\n// Use ArrayFactory here?\n}\nIf I'm on the right track, I'll try to figure it out and post an answer as soon as I got something working :)\n. Thanks, I'll try to add an example here as soon as I get it working.. Thank you, you can close the issue. I'm currently blocked and will add an example later.. ",
    "icanfly": "just what to set the field 'hello' with value 'world', so the instances have a default init value.. @raphw , I really want to get a default value for my generated class, If use your method, I have to set the value of the field value each time when I instantiate it.. ",
    "baifan": "So, When I use @AllArguments, there will have performance issues?\nThis is a lite version, in project, code is more complicated, and I need them all, the origin instance, all arguments, origin method, and delagation method.\n```java\n@RuntimeType\npublic Object enhance(@This Object obj,\n                      @AllArguments Object[] allArguments,\n                      @Origin Method method,\n                      @SuperCall Callable<?> zuper\n) throws Throwable {\nif (injector == null || !injector.onOffState()) {\n    return zuper.call();\n}\ninjector.beforeMethod(obj, method, allArguments, method.getParameterTypes());\nObject ret = null;\ntry {\n    ret = zuper.call();\n} catch (Throwable t) {\n    injector.handleMethodException(obj, method, allArguments, method.getParameterTypes(), t);\n    throw t;\n} finally {\n    ret = injector.afterMethod(obj, method, allArguments, method.getParameterTypes(), ret);\n}\nreturn ret;\n\n}\n. In addition. Use the code like below, but there is no improvement in performance.java\npublic class InstanceEnhancer {\nprivate HelloProxy injector;\n\npublic InstanceEnhancer() {\n    injector = new HelloProxy();\n}\n\n@RuntimeType\npublic Object enhance(@Argument(0) long allArgument) {\n    return injector.elapse(allArgument);\n}\n\n}\n```. Thasks.\nBut why box cost so long time?. :+1: \nOkay, thank you very much!. ",
    "mar-kolya": "After doing some digging it looks like the problem may be related to bridge methods being generated for anonymous class. It looks like somehow defineAnonymousClass doesn't like that - and this seems to result in its failure to define the lambda class.\nIt looks like that anything that gets those bridge methods not defined fixes at least first problem. For example I've tried adding && !methodDescription.isDefaultMethod() to line 489 of MethodRegistry.\nUnfortunately I do not quite understand what exactly is wrong with bridge methods in anonymous class:\npublic test.regex.Pattern$CharPredicate union(test.regex.Pattern$CharPredicate);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: invokespecial #32                 // InterfaceMethod test/regex/Pattern$BmpCharPredicate.union:(Ltest/regex/Pattern$CharPredicate;)Ltest/regex/Pattern$CharPredicate;\n       5: areturn\nso I'm not sure what is the correct fix for this at the moment.. I'm pretty sure this is not related to circularity for the following reasons:\n\nIf I make BmpCharPredicate public (and not package-private) things start to work\nIf I change byte-buddy to not inject bridge methods for default interface things start to work\nI've compared lambda class generated by byte-buddy and lambda class generated by 'stock' java lib - the only difference are those bridge methods.\n\nSo overall problem seems to be some weird interaction between bridge methods and Unsafe. defineAnonymousClass.. Please have a look here: https://github.com/mar-kolya/byte-buddy/commit/2b02266b53c3307f2ea3f0e77b1e43aed22a26e5 . I've added a test that demonstrates the problem - and even a commented out piece of code that seems to fix it.\n\nI find the error message strange about the indirect superinterface.\n\nAs I mentioned in my original bug report I cannot yet reproduce this in isolation from our whole project. But I have a feeling that first error there (java.lang.NoClassDefFoundError: test/regex/Pattern$$Lambda$ByteBuddy$1) is actually related, maybe its just a different manifestation of the same problem.\n\nI wonder if it would be sensible to just deactivate the bridge method generation for the lambda factory. \n\nThis is what java lib seems to be doing.\nIf I may make another suggestion here: I think it would be nice to make MetaFactoryRedirection(and AlternativeMetaFactoryRedirection) to fallback to 'standard' implementation if replacement one fails (i.e. throws exception when tries to create lambda class). The way things are currently means that using AgentBuilder.LambdaInstrumentationStrategy.ENABLED affects all lambdas - even ones we do not want to instrument in any sensible way. And this in turn opens potential for errors like this one - which otherwise would have been ignored because we have no interest in instrumenting pattern matching guts.. @raphw I've also pulled out a self contained example:\n```\nimport net.bytebuddy.agent.ByteBuddyAgent;\nimport net.bytebuddy.agent.builder.AgentBuilder;\npublic class Main {\npublic static class HiddenInterfaceTestClass {\n    @FunctionalInterface\n    interface HiddenInterface {\n        default boolean defaultMethod() {\n            return false;\n        }\n        boolean func();\n    }\n    public static HiddenInterface packagePrivateInterface() {\n        return () -> true;\n    }\n}\n\npublic static void main(String... args) {\n    ByteBuddyAgent.install();\n    new AgentBuilder.Default()\n            .with(AgentBuilder.LambdaInstrumentationStrategy.ENABLED)\n            .installOn(ByteBuddyAgent.getInstrumentation());\n\n    HiddenInterfaceTestClass.packagePrivateInterface();\n}\n\n}\n```\nThis blows up with:\nException in thread \"main\" java.lang.BootstrapMethodError: call site initialization exception\n    at java.lang.invoke.CallSite.makeSite(CallSite.java:341)\n    at java.lang.invoke.MethodHandleNatives.linkCallSiteImpl(MethodHandleNatives.java:307)\n    at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:297)\n    at Main$HiddenInterfaceTestClass.packagePrivateInterface(Main.java:15)\n    at Main.main(Main.java:25)\nCaused by: java.lang.NoClassDefFoundError: Main$HiddenInterfaceTestClass$$Lambda$ByteBuddy$1\n    at sun.misc.Unsafe.defineAnonymousClass(Native Method)\n    at java.lang.invoke.LambdaMetafactory.metafactory(LambdaMetafactory.java)\n    at java.lang.invoke.CallSite.makeSite(CallSite.java:302)\n    ... 4 more\nCaused by: java.lang.ClassNotFoundException: Main$HiddenInterfaceTestClass$$Lambda$ByteBuddy$1\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n    ... 7 more\nRemoving .with(AgentBuilder.LambdaInstrumentationStrategy.ENABLED) makes it not fail. This affects 1.9.4 as well.. ",
    "eolivelli": "In that code I have the second block with is chasing classes by name.\nIn my case I would like to transform org.junit.runner.Description.\nI did some debug and the ElementsMatch does not receive the Annotation[] array. I will add the listener and then I will be back with news.\nThanks for your quick reply. ",
    "JoeKerouac": "@raphw thx,Can this be done with some simple identification? For example, it is recognized from the class name. If the class name contains $Lambda$, it is considered to be a lambda expression. At this time, the internal internal conversion is called to call the MethodDelegation.to(hello, Interface.class) method,The Interface comes from the Class.getInterfaces() method, so that the user experience will be better.I think the user should not perceive this.. ",
    "Sanne": "Pasting a sample of the kind of matchers being pushed to helperMethods.filter(handledMethods)) :\n((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((true and not(is(public org.othertests.ThickEntity()))) and not(is(public java.lang.Long org.othertests.ThickEntity.getId()))) and not(is(public void org.othertests.ThickEntity.setId(java.lang.Long)))) and not(is(public java.lang.Long org.othertests.ThickEntity.getVersion()))) and not(is(public void org.othertests.ThickEntity.setVersion(java.lang.Long)))) and not(is(public java.util.Date org.othertests.ThickEntity.getCreateDate()))) and not(is(public void org.othertests.ThickEntity.setCreateDate(java.util.Date)))) and not(is(public java.lang.Long org.othertests.ThickEntity.getCreatedBy()))) and not(is(public void org.othertests.ThickEntity.setCreatedBy(java.lang.Long)))) and not(is(public java.util.Date org.othertests.ThickEntity.getLastUpdateDate()))) and not(is(public void org.othertests.ThickEntity.setLastUpdateDate(java.util.Date)))) and not(is(public java.lang.Long org.othertests.ThickEntity.getLastUpdateBy()))) and not(is(public void org.othertests.ThickEntity.setLastUpdateBy(java.lang.Long)))) and not(is(public java.util.Date org.othertests.ThickEntity.getDeleteDate()))) and not(is(public void org.othertests.ThickEntity.setDeleteDate(java.util.Date)))) and not(is(public java.lang.Long org.othertests.ThickEntity.getDeletedBy()))) and not(is(public void org.othertests.ThickEntity.setDeletedBy(java.lang.Long)))) and not(is(public boolean org.othertests.ThickEntity.isDeleted()))) and not(is(public void org.othertests.ThickEntity.setDeleted(boolean)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD0()))) and not(is(public void org.othertests.ThickEntity.setD0(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS0()))) and not(is(public void org.othertests.ThickEntity.setS0(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR0()))) and not(is(public void org.othertests.ThickEntity.setR0(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD1()))) and not(is(public void org.othertests.ThickEntity.setD1(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS1()))) and not(is(public void org.othertests.ThickEntity.setS1(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR1()))) and not(is(public void org.othertests.ThickEntity.setR1(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD2()))) and not(is(public void org.othertests.ThickEntity.setD2(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS2()))) and not(is(public void org.othertests.ThickEntity.setS2(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR2()))) and not(is(public void org.othertests.ThickEntity.setR2(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD3()))) and not(is(public void org.othertests.ThickEntity.setD3(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS3()))) and not(is(public void org.othertests.ThickEntity.setS3(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR3()))) and not(is(public void org.othertests.ThickEntity.setR3(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD4()))) and not(is(public void org.othertests.ThickEntity.setD4(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS4()))) and not(is(public void org.othertests.ThickEntity.setS4(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR4()))) and not(is(public void org.othertests.ThickEntity.setR4(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD5()))) and not(is(public void org.othertests.ThickEntity.setD5(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS5()))) and not(is(public void org.othertests.ThickEntity.setS5(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR5()))) and not(is(public void org.othertests.ThickEntity.setR5(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD6()))) and not(is(public void org.othertests.ThickEntity.setD6(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS6()))) and not(is(public void org.othertests.ThickEntity.setS6(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR6()))) and not(is(public void org.othertests.ThickEntity.setR6(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD7()))) and not(is(public void org.othertests.ThickEntity.setD7(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS7()))) and not(is(public void org.othertests.ThickEntity.setS7(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR7()))) and not(is(public void org.othertests.ThickEntity.setR7(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD8()))) and not(is(public void org.othertests.ThickEntity.setD8(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS8()))) and not(is(public void org.othertests.ThickEntity.setS8(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR8()))) and not(is(public void org.othertests.ThickEntity.setR8(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD9()))) and not(is(public void org.othertests.ThickEntity.setD9(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS9()))) and not(is(public void org.othertests.ThickEntity.setS9(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR9()))) and not(is(public void org.othertests.ThickEntity.setR9(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD10()))) and not(is(public void org.othertests.ThickEntity.setD10(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS10()))) and not(is(public void org.othertests.ThickEntity.setS10(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR10()))) and not(is(public void org.othertests.ThickEntity.setR10(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD11()))) and not(is(public void org.othertests.ThickEntity.setD11(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS11()))) and not(is(public void org.othertests.ThickEntity.setS11(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR11()))) and not(is(public void org.othertests.ThickEntity.setR11(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD12()))) and not(is(public void org.othertests.ThickEntity.setD12(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS12()))) and not(is(public void org.othertests.ThickEntity.setS12(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR12()))) and not(is(public void org.othertests.ThickEntity.setR12(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD13()))) and not(is(public void org.othertests.ThickEntity.setD13(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS13()))) and not(is(public void org.othertests.ThickEntity.setS13(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR13()))) and not(is(public void org.othertests.ThickEntity.setR13(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD14()))) and not(is(public void org.othertests.ThickEntity.setD14(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS14()))) and not(is(public void org.othertests.ThickEntity.setS14(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR14()))) and not(is(public void org.othertests.ThickEntity.setR14(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD15()))) and not(is(public void org.othertests.ThickEntity.setD15(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS15()))) and not(is(public void org.othertests.ThickEntity.setS15(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR15()))) and not(is(public void org.othertests.ThickEntity.setR15(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD16()))) and not(is(public void org.othertests.ThickEntity.setD16(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS16()))) and not(is(public void org.othertests.ThickEntity.setS16(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR16()))) and not(is(public void org.othertests.ThickEntity.setR16(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD17()))) and not(is(public void org.othertests.ThickEntity.setD17(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS17()))) and not(is(public void org.othertests.ThickEntity.setS17(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR17()))) and not(is(public void org.othertests.ThickEntity.setR17(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD18()))) and not(is(public void org.othertests.ThickEntity.setD18(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS18()))) and not(is(public void org.othertests.ThickEntity.setS18(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR18()))) and not(is(public void org.othertests.ThickEntity.setR18(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD19()))) and not(is(public void org.othertests.ThickEntity.setD19(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS19()))) and not(is(public void org.othertests.ThickEntity.setS19(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR19()))) and not(is(public void org.othertests.ThickEntity.setR19(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD20()))) and not(is(public void org.othertests.ThickEntity.setD20(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS20()))) and not(is(public void org.othertests.ThickEntity.setS20(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR20()))) and not(is(public void org.othertests.ThickEntity.setR20(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD21()))) and not(is(public void org.othertests.ThickEntity.setD21(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS21()))) and not(is(public void org.othertests.ThickEntity.setS21(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR21()))) and not(is(public void org.othertests.ThickEntity.setR21(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD22()))) and not(is(public void org.othertests.ThickEntity.setD22(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS22()))) and not(is(public void org.othertests.ThickEntity.setS22(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR22()))) and not(is(public void org.othertests.ThickEntity.setR22(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD23()))) and not(is(public void org.othertests.ThickEntity.setD23(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS23()))) and not(is(public void org.othertests.ThickEntity.setS23(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR23()))) and not(is(public void org.othertests.ThickEntity.setR23(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD24()))) and not(is(public void org.othertests.ThickEntity.setD24(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS24()))) and not(is(public void org.othertests.ThickEntity.setS24(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR24()))) and not(is(public void org.othertests.ThickEntity.setR24(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD25()))) and not(is(public void org.othertests.ThickEntity.setD25(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS25()))) and not(is(public void org.othertests.ThickEntity.setS25(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR25()))) and not(is(public void org.othertests.ThickEntity.setR25(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD26()))) and not(is(public void org.othertests.ThickEntity.setD26(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS26()))) and not(is(public void org.othertests.ThickEntity.setS26(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR26()))) and not(is(public void org.othertests.ThickEntity.setR26(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD27()))) and not(is(public void org.othertests.ThickEntity.setD27(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS27()))) and not(is(public void org.othertests.ThickEntity.setS27(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR27()))) and not(is(public void org.othertests.ThickEntity.setR27(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD28()))) and not(is(public void org.othertests.ThickEntity.setD28(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS28()))) and not(is(public void org.othertests.ThickEntity.setS28(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR28()))) and not(is(public void org.othertests.ThickEntity.setR28(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD29()))) and not(is(public void org.othertests.ThickEntity.setD29(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS29()))) and not(is(public void org.othertests.ThickEntity.setS29(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR29()))) and not(is(public void org.othertests.ThickEntity.setR29(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD30()))) and not(is(public void org.othertests.ThickEntity.setD30(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS30()))) and not(is(public void org.othertests.ThickEntity.setS30(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR30()))) and not(is(public void org.othertests.ThickEntity.setR30(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD31()))) and not(is(public void org.othertests.ThickEntity.setD31(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS31()))) and not(is(public void org.othertests.ThickEntity.setS31(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR31()))) and not(is(public void org.othertests.ThickEntity.setR31(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD32()))) and not(is(public void org.othertests.ThickEntity.setD32(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS32()))) and not(is(public void org.othertests.ThickEntity.setS32(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR32()))) and not(is(public void org.othertests.ThickEntity.setR32(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD33()))) and not(is(public void org.othertests.ThickEntity.setD33(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS33()))) and not(is(public void org.othertests.ThickEntity.setS33(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR33()))) and not(is(public void org.othertests.ThickEntity.setR33(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD34()))) and not(is(public void org.othertests.ThickEntity.setD34(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS34()))) and not(is(public void org.othertests.ThickEntity.setS34(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR34()))) and not(is(public void org.othertests.ThickEntity.setR34(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD35()))) and not(is(public void org.othertests.ThickEntity.setD35(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS35()))) and not(is(public void org.othertests.ThickEntity.setS35(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR35()))) and not(is(public void org.othertests.ThickEntity.setR35(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD36()))) and not(is(public void org.othertests.ThickEntity.setD36(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS36()))) and not(is(public void org.othertests.ThickEntity.setS36(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR36()))) and not(is(public void org.othertests.ThickEntity.setR36(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD37()))) and not(is(public void org.othertests.ThickEntity.setD37(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS37()))) and not(is(public void org.othertests.ThickEntity.setS37(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR37()))) and not(is(public void org.othertests.ThickEntity.setR37(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD38()))) and not(is(public void org.othertests.ThickEntity.setD38(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS38()))) and not(is(public void org.othertests.ThickEntity.setS38(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR38()))) and not(is(public void org.othertests.ThickEntity.setR38(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD39()))) and not(is(public void org.othertests.ThickEntity.setD39(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS39()))) and not(is(public void org.othertests.ThickEntity.setS39(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR39()))) and not(is(public void org.othertests.ThickEntity.setR39(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD40()))) and not(is(public void org.othertests.ThickEntity.setD40(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS40()))) and not(is(public void org.othertests.ThickEntity.setS40(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR40()))) and not(is(public void org.othertests.ThickEntity.setR40(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD41()))) and not(is(public void org.othertests.ThickEntity.setD41(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS41()))) and not(is(public void org.othertests.ThickEntity.setS41(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR41()))) and not(is(public void org.othertests.ThickEntity.setR41(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD42()))) and not(is(public void org.othertests.ThickEntity.setD42(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS42()))) and not(is(public void org.othertests.ThickEntity.setS42(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR42()))) and not(is(public void org.othertests.ThickEntity.setR42(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD43()))) and not(is(public void org.othertests.ThickEntity.setD43(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS43()))) and not(is(public void org.othertests.ThickEntity.setS43(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR43()))) and not(is(public void org.othertests.ThickEntity.setR43(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD44()))) and not(is(public void org.othertests.ThickEntity.setD44(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS44()))) and not(is(public void org.othertests.ThickEntity.setS44(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR44()))) and not(is(public void org.othertests.ThickEntity.setR44(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD45()))) and not(is(public void org.othertests.ThickEntity.setD45(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS45()))) and not(is(public void org.othertests.ThickEntity.setS45(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR45()))) and not(is(public void org.othertests.ThickEntity.setR45(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD46()))) and not(is(public void org.othertests.ThickEntity.setD46(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS46()))) and not(is(public void org.othertests.ThickEntity.setS46(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR46()))) and not(is(public void org.othertests.ThickEntity.setR46(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD47()))) and not(is(public void org.othertests.ThickEntity.setD47(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS47()))) and not(is(public void org.othertests.ThickEntity.setS47(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR47()))) and not(is(public void org.othertests.ThickEntity.setR47(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD48()))) and not(is(public void org.othertests.ThickEntity.setD48(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS48()))) and not(is(public void org.othertests.ThickEntity.setS48(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR48()))) and not(is(public void org.othertests.ThickEntity.setR48(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD49()))) and not(is(public void org.othertests.ThickEntity.setD49(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS49()))) and not(is(public void org.othertests.ThickEntity.setS49(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR49()))) and not(is(public void org.othertests.ThickEntity.setR49(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD50()))) and not(is(public void org.othertests.ThickEntity.setD50(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS50()))) and not(is(public void org.othertests.ThickEntity.setS50(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR50()))) and not(is(public void org.othertests.ThickEntity.setR50(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD51()))) and not(is(public void org.othertests.ThickEntity.setD51(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS51()))) and not(is(public void org.othertests.ThickEntity.setS51(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR51()))) and not(is(public void org.othertests.ThickEntity.setR51(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD52()))) and not(is(public void org.othertests.ThickEntity.setD52(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS52()))) and not(is(public void org.othertests.ThickEntity.setS52(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR52()))) and not(is(public void org.othertests.ThickEntity.setR52(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD53()))) and not(is(public void org.othertests.ThickEntity.setD53(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS53()))) and not(is(public void org.othertests.ThickEntity.setS53(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR53()))) and not(is(public void org.othertests.ThickEntity.setR53(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD54()))) and not(is(public void org.othertests.ThickEntity.setD54(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS54()))) and not(is(public void org.othertests.ThickEntity.setS54(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR54()))) and not(is(public void org.othertests.ThickEntity.setR54(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD55()))) and not(is(public void org.othertests.ThickEntity.setD55(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS55()))) and not(is(public void org.othertests.ThickEntity.setS55(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR55()))) and not(is(public void org.othertests.ThickEntity.setR55(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD56()))) and not(is(public void org.othertests.ThickEntity.setD56(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS56()))) and not(is(public void org.othertests.ThickEntity.setS56(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR56()))) and not(is(public void org.othertests.ThickEntity.setR56(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD57()))) and not(is(public void org.othertests.ThickEntity.setD57(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS57()))) and not(is(public void org.othertests.ThickEntity.setS57(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR57()))) and not(is(public void org.othertests.ThickEntity.setR57(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD58()))) and not(is(public void org.othertests.ThickEntity.setD58(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS58()))) and not(is(public void org.othertests.ThickEntity.setS58(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR58()))) and not(is(public void org.othertests.ThickEntity.setR58(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD59()))) and not(is(public void org.othertests.ThickEntity.setD59(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS59()))) and not(is(public void org.othertests.ThickEntity.setS59(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR59()))) and not(is(public void org.othertests.ThickEntity.setR59(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD60()))) and not(is(public void org.othertests.ThickEntity.setD60(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS60()))) and not(is(public void org.othertests.ThickEntity.setS60(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR60()))) and not(is(public void org.othertests.ThickEntity.setR60(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD61()))) and not(is(public void org.othertests.ThickEntity.setD61(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS61()))) and not(is(public void org.othertests.ThickEntity.setS61(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR61()))) and not(is(public void org.othertests.ThickEntity.setR61(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD62()))) and not(is(public void org.othertests.ThickEntity.setD62(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS62()))) and not(is(public void org.othertests.ThickEntity.setS62(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR62()))) and not(is(public void org.othertests.ThickEntity.setR62(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD63()))) and not(is(public void org.othertests.ThickEntity.setD63(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS63()))) and not(is(public void org.othertests.ThickEntity.setS63(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR63()))) and not(is(public void org.othertests.ThickEntity.setR63(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD64()))) and not(is(public void org.othertests.ThickEntity.setD64(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS64()))) and not(is(public void org.othertests.ThickEntity.setS64(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR64()))) and not(is(public void org.othertests.ThickEntity.setR64(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD65()))) and not(is(public void org.othertests.ThickEntity.setD65(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS65()))) and not(is(public void org.othertests.ThickEntity.setS65(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR65()))) and not(is(public void org.othertests.ThickEntity.setR65(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD66()))) and not(is(public void org.othertests.ThickEntity.setD66(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS66()))) and not(is(public void org.othertests.ThickEntity.setS66(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR66()))) and not(is(public void org.othertests.ThickEntity.setR66(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD67()))) and not(is(public void org.othertests.ThickEntity.setD67(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS67()))) and not(is(public void org.othertests.ThickEntity.setS67(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR67()))) and not(is(public void org.othertests.ThickEntity.setR67(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD68()))) and not(is(public void org.othertests.ThickEntity.setD68(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS68()))) and not(is(public void org.othertests.ThickEntity.setS68(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR68()))) and not(is(public void org.othertests.ThickEntity.setR68(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD69()))) and not(is(public void org.othertests.ThickEntity.setD69(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS69()))) and not(is(public void org.othertests.ThickEntity.setS69(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR69()))) and not(is(public void org.othertests.ThickEntity.setR69(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD70()))) and not(is(public void org.othertests.ThickEntity.setD70(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS70()))) and not(is(public void org.othertests.ThickEntity.setS70(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR70()))) and not(is(public void org.othertests.ThickEntity.setR70(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD71()))) and not(is(public void org.othertests.ThickEntity.setD71(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS71()))) and not(is(public void org.othertests.ThickEntity.setS71(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR71()))) and not(is(public void org.othertests.ThickEntity.setR71(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD72()))) and not(is(public void org.othertests.ThickEntity.setD72(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS72()))) and not(is(public void org.othertests.ThickEntity.setS72(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR72()))) and not(is(public void org.othertests.ThickEntity.setR72(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD73()))) and not(is(public void org.othertests.ThickEntity.setD73(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS73()))) and not(is(public void org.othertests.ThickEntity.setS73(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR73()))) and not(is(public void org.othertests.ThickEntity.setR73(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD74()))) and not(is(public void org.othertests.ThickEntity.setD74(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS74()))) and not(is(public void org.othertests.ThickEntity.setS74(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR74()))) and not(is(public void org.othertests.ThickEntity.setR74(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD75()))) and not(is(public void org.othertests.ThickEntity.setD75(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS75()))) and not(is(public void org.othertests.ThickEntity.setS75(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR75()))) and not(is(public void org.othertests.ThickEntity.setR75(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD76()))) and not(is(public void org.othertests.ThickEntity.setD76(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS76()))) and not(is(public void org.othertests.ThickEntity.setS76(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR76()))) and not(is(public void org.othertests.ThickEntity.setR76(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD77()))) and not(is(public void org.othertests.ThickEntity.setD77(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS77()))) and not(is(public void org.othertests.ThickEntity.setS77(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR77()))) and not(is(public void org.othertests.ThickEntity.setR77(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD78()))) and not(is(public void org.othertests.ThickEntity.setD78(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS78()))) and not(is(public void org.othertests.ThickEntity.setS78(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR78()))) and not(is(public void org.othertests.ThickEntity.setR78(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD79()))) and not(is(public void org.othertests.ThickEntity.setD79(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS79()))) and not(is(public void org.othertests.ThickEntity.setS79(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR79()))) and not(is(public void org.othertests.ThickEntity.setR79(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD80()))) and not(is(public void org.othertests.ThickEntity.setD80(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS80()))) and not(is(public void org.othertests.ThickEntity.setS80(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR80()))) and not(is(public void org.othertests.ThickEntity.setR80(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD81()))) and not(is(public void org.othertests.ThickEntity.setD81(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS81()))) and not(is(public void org.othertests.ThickEntity.setS81(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR81()))) and not(is(public void org.othertests.ThickEntity.setR81(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD82()))) and not(is(public void org.othertests.ThickEntity.setD82(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS82()))) and not(is(public void org.othertests.ThickEntity.setS82(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR82()))) and not(is(public void org.othertests.ThickEntity.setR82(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD83()))) and not(is(public void org.othertests.ThickEntity.setD83(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS83()))) and not(is(public void org.othertests.ThickEntity.setS83(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR83()))) and not(is(public void org.othertests.ThickEntity.setR83(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD84()))) and not(is(public void org.othertests.ThickEntity.setD84(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS84()))) and not(is(public void org.othertests.ThickEntity.setS84(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR84()))) and not(is(public void org.othertests.ThickEntity.setR84(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD85()))) and not(is(public void org.othertests.ThickEntity.setD85(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS85()))) and not(is(public void org.othertests.ThickEntity.setS85(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR85()))) and not(is(public void org.othertests.ThickEntity.setR85(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD86()))) and not(is(public void org.othertests.ThickEntity.setD86(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS86()))) and not(is(public void org.othertests.ThickEntity.setS86(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR86()))) and not(is(public void org.othertests.ThickEntity.setR86(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD87()))) and not(is(public void org.othertests.ThickEntity.setD87(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS87()))) and not(is(public void org.othertests.ThickEntity.setS87(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR87()))) and not(is(public void org.othertests.ThickEntity.setR87(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD88()))) and not(is(public void org.othertests.ThickEntity.setD88(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS88()))) and not(is(public void org.othertests.ThickEntity.setS88(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR88()))) and not(is(public void org.othertests.ThickEntity.setR88(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD89()))) and not(is(public void org.othertests.ThickEntity.setD89(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS89()))) and not(is(public void org.othertests.ThickEntity.setS89(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR89()))) and not(is(public void org.othertests.ThickEntity.setR89(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD90()))) and not(is(public void org.othertests.ThickEntity.setD90(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS90()))) and not(is(public void org.othertests.ThickEntity.setS90(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR90()))) and not(is(public void org.othertests.ThickEntity.setR90(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD91()))) and not(is(public void org.othertests.ThickEntity.setD91(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS91()))) and not(is(public void org.othertests.ThickEntity.setS91(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR91()))) and not(is(public void org.othertests.ThickEntity.setR91(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD92()))) and not(is(public void org.othertests.ThickEntity.setD92(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS92()))) and not(is(public void org.othertests.ThickEntity.setS92(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR92()))) and not(is(public void org.othertests.ThickEntity.setR92(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD93()))) and not(is(public void org.othertests.ThickEntity.setD93(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS93()))) and not(is(public void org.othertests.ThickEntity.setS93(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR93()))) and not(is(public void org.othertests.ThickEntity.setR93(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD94()))) and not(is(public void org.othertests.ThickEntity.setD94(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS94()))) and not(is(public void org.othertests.ThickEntity.setS94(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR94()))) and not(is(public void org.othertests.ThickEntity.setR94(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD95()))) and not(is(public void org.othertests.ThickEntity.setD95(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS95()))) and not(is(public void org.othertests.ThickEntity.setS95(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR95()))) and not(is(public void org.othertests.ThickEntity.setR95(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD96()))) and not(is(public void org.othertests.ThickEntity.setD96(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS96()))) and not(is(public void org.othertests.ThickEntity.setS96(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR96()))) and not(is(public void org.othertests.ThickEntity.setR96(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD97()))) and not(is(public void org.othertests.ThickEntity.setD97(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS97()))) and not(is(public void org.othertests.ThickEntity.setS97(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR97()))) and not(is(public void org.othertests.ThickEntity.setR97(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD98()))) and not(is(public void org.othertests.ThickEntity.setD98(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS98()))) and not(is(public void org.othertests.ThickEntity.setS98(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR98()))) and not(is(public void org.othertests.ThickEntity.setR98(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.getD99()))) and not(is(public void org.othertests.ThickEntity.setD99(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS99()))) and not(is(public void org.othertests.ThickEntity.setS99(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getR99()))) and not(is(public void org.othertests.ThickEntity.setR99(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getLob4()))) and not(is(public void org.othertests.ThickEntity.setLob4(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getS44444()))) and not(is(public void org.othertests.ThickEntity.setS44444(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getLob1()))) and not(is(public void org.othertests.ThickEntity.setLob1(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getLob2()))) and not(is(public void org.othertests.ThickEntity.setLob2(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.getLob3()))) and not(is(public void org.othertests.ThickEntity.setLob3(java.lang.String)))) and not(is(public java.lang.Object org.othertests.ThickEntity.$$_hibernate_getEntityInstance()))) and not(is(public org.hibernate.engine.spi.EntityEntry org.othertests.ThickEntity.$$_hibernate_getEntityEntry()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_setEntityEntry(org.hibernate.engine.spi.EntityEntry)))) and not(is(public org.hibernate.engine.spi.ManagedEntity org.othertests.ThickEntity.$$_hibernate_getPreviousManagedEntity()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_setPreviousManagedEntity(org.hibernate.engine.spi.ManagedEntity)))) and not(is(public org.hibernate.engine.spi.ManagedEntity org.othertests.ThickEntity.$$_hibernate_getNextManagedEntity()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_setNextManagedEntity(org.hibernate.engine.spi.ManagedEntity)))) and not(is(public org.hibernate.engine.spi.PersistentAttributeInterceptor org.othertests.ThickEntity.$$_hibernate_getInterceptor()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_setInterceptor(org.hibernate.engine.spi.PersistentAttributeInterceptor)))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_trackChange(java.lang.String)))) and not(is(public java.lang.String[] org.othertests.ThickEntity.$$_hibernate_getDirtyAttributes()))) and not(is(public boolean org.othertests.ThickEntity.$$_hibernate_hasDirtyAttributes()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_clearDirtyAttributes()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_suspendDirtyTracking(boolean)))) and not(is(public org.hibernate.bytecode.enhance.spi.CollectionTracker org.othertests.ThickEntity.$$_hibernate_getCollectionTracker()))) and not(is(public java.lang.Long org.othertests.ThickEntity.$$_hibernate_read_id()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_id(java.lang.Long)))) and not(is(public java.lang.Long org.othertests.ThickEntity.$$_hibernate_read_version()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_version(java.lang.Long)))) and not(is(public java.util.Date org.othertests.ThickEntity.$$_hibernate_read_createDate()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_createDate(java.util.Date)))) and not(is(public java.lang.Long org.othertests.ThickEntity.$$_hibernate_read_createdBy()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_createdBy(java.lang.Long)))) and not(is(public java.util.Date org.othertests.ThickEntity.$$_hibernate_read_lastUpdateDate()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_lastUpdateDate(java.util.Date)))) and not(is(public java.lang.Long org.othertests.ThickEntity.$$_hibernate_read_lastUpdateBy()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_lastUpdateBy(java.lang.Long)))) and not(is(public java.util.Date org.othertests.ThickEntity.$$_hibernate_read_deleteDate()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_deleteDate(java.util.Date)))) and not(is(public java.lang.Long org.othertests.ThickEntity.$$_hibernate_read_deletedBy()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_deletedBy(java.lang.Long)))) and not(is(public boolean org.othertests.ThickEntity.$$_hibernate_read_isDeleted()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_isDeleted(boolean)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d0()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d0(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s0()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s0(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r0()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r0(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d1()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d1(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s1()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s1(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r1()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r1(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d2()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d2(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s2()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s2(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r2()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r2(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d3()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d3(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s3()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s3(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r3()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r3(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d4()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d4(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s4()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s4(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r4()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r4(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d5()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d5(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s5()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s5(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r5()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r5(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d6()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d6(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s6()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s6(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r6()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r6(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d7()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d7(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s7()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s7(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r7()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r7(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d8()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d8(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s8()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s8(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r8()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r8(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d9()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d9(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s9()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s9(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r9()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r9(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d10()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d10(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s10()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s10(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r10()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r10(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d11()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d11(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s11()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s11(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r11()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r11(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d12()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d12(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s12()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s12(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r12()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r12(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d13()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d13(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s13()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s13(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r13()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r13(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d14()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d14(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s14()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s14(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r14()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r14(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d15()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d15(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s15()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s15(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r15()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r15(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d16()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d16(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s16()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s16(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r16()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r16(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d17()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d17(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s17()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s17(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r17()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r17(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d18()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d18(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s18()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s18(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r18()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r18(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d19()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d19(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s19()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s19(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r19()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r19(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d20()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d20(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s20()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s20(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r20()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r20(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d21()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d21(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s21()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s21(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r21()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r21(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d22()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d22(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s22()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s22(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r22()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r22(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d23()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d23(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s23()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s23(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r23()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r23(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d24()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d24(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s24()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s24(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r24()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r24(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d25()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d25(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s25()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s25(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r25()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r25(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d26()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d26(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s26()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s26(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r26()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r26(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d27()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d27(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s27()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s27(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r27()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r27(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d28()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d28(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s28()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s28(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r28()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r28(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d29()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d29(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s29()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s29(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r29()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r29(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d30()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d30(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s30()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s30(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r30()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r30(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d31()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d31(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s31()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s31(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r31()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r31(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d32()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d32(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s32()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s32(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r32()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r32(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d33()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d33(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s33()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s33(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r33()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r33(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d34()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d34(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s34()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s34(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r34()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r34(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d35()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d35(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s35()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s35(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r35()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r35(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d36()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d36(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s36()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s36(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r36()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r36(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d37()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d37(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s37()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s37(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r37()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r37(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d38()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d38(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s38()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s38(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r38()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r38(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d39()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d39(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s39()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s39(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r39()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r39(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d40()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d40(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s40()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s40(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r40()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r40(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d41()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d41(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s41()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s41(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r41()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r41(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d42()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d42(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s42()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s42(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r42()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r42(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d43()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d43(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s43()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s43(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r43()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r43(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d44()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d44(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s44()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s44(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r44()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r44(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d45()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d45(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s45()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s45(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r45()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r45(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d46()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d46(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s46()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s46(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r46()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r46(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d47()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d47(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s47()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s47(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r47()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r47(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d48()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d48(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s48()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s48(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r48()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r48(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d49()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d49(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s49()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s49(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r49()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r49(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d50()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d50(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s50()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s50(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r50()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r50(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d51()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d51(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s51()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s51(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r51()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r51(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d52()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d52(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s52()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s52(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r52()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r52(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d53()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d53(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s53()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s53(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r53()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r53(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d54()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d54(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s54()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s54(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r54()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r54(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d55()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d55(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s55()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s55(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r55()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r55(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d56()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d56(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s56()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s56(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r56()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r56(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d57()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d57(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s57()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s57(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r57()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r57(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d58()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d58(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s58()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s58(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r58()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r58(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d59()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d59(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s59()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s59(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r59()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r59(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d60()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d60(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s60()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s60(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r60()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r60(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d61()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d61(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s61()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s61(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r61()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r61(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d62()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d62(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s62()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s62(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r62()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r62(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d63()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d63(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s63()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s63(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r63()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r63(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d64()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d64(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s64()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s64(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r64()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r64(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d65()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d65(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s65()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s65(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r65()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r65(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d66()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d66(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s66()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s66(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r66()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r66(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d67()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d67(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s67()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s67(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r67()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r67(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d68()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d68(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s68()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s68(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r68()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r68(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d69()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d69(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s69()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s69(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r69()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r69(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d70()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d70(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s70()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s70(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r70()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r70(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d71()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d71(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s71()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s71(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r71()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r71(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d72()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d72(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s72()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s72(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r72()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r72(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d73()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d73(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s73()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s73(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r73()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r73(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d74()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d74(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s74()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s74(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r74()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r74(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d75()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d75(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s75()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s75(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r75()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r75(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d76()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d76(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s76()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s76(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r76()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r76(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d77()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d77(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s77()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s77(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r77()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r77(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d78()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d78(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s78()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s78(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r78()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r78(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d79()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d79(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s79()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s79(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r79()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r79(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d80()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d80(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s80()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s80(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r80()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r80(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d81()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d81(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s81()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s81(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r81()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r81(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d82()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d82(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s82()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s82(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r82()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r82(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d83()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d83(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s83()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s83(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r83()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r83(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d84()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d84(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s84()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s84(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r84()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r84(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d85()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d85(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s85()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s85(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r85()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r85(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d86()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d86(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s86()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s86(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r86()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r86(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d87()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d87(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s87()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s87(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r87()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r87(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d88()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d88(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s88()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s88(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r88()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r88(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d89()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d89(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s89()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s89(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r89()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r89(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d90()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d90(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s90()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s90(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r90()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r90(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d91()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d91(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s91()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s91(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r91()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r91(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d92()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d92(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s92()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s92(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r92()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r92(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d93()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d93(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s93()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s93(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r93()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r93(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d94()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d94(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s94()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s94(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r94()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r94(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d95()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d95(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s95()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s95(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r95()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r95(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d96()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d96(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s96()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s96(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r96()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r96(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d97()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d97(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s97()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s97(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r97()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r97(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d98()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d98(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s98()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s98(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r98()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r98(java.lang.String)))) and not(is(public java.math.BigDecimal org.othertests.ThickEntity.$$_hibernate_read_d99()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_d99(java.math.BigDecimal)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s99()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s99(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_r99()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_r99(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_lob4()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_lob4(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_s44444()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_s44444(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_lob1()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_lob1(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_lob2()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_lob2(java.lang.String)))) and not(is(public java.lang.String org.othertests.ThickEntity.$$_hibernate_read_lob3()))) and not(is(public void org.othertests.ThickEntity.$$_hibernate_write_lob3(java.lang.String)))). You're awesome! Testing... \n\nhttps://hibernate.atlassian.net/browse/HHH-13099. Thanks, that huge spike is gone. And I only updated Byte Buddy version so far, I'll see to apply your other suggestions now as well. @gsmet also has another collection of optimisations pending, this will get quite smooth :). thanks!. \n",
    "shuvigoss": "byte-buddy version 1.7.8. @raphw thx !. @raphw thx \n-parameters flag works fine because spring will use org.springframework.core.DefaultParameterNameDiscoverer to get param name,i think rebasing method should keep all  origin method info :). ",
    "honganan": "I think we can change the api in InstanceConstructorInterceptor from one methodonConstruct to two: beforeConstruct and afterConstruct. But I am not sure if this is suitable.. sorry for sending to the wrong page!. I noticed the Nexus can be disabled by setting system property. But my class enhancement seems not work after I disabled this.. Thank you for reply so fast. When I close this Nexus mechanism, I found my enhancements do not work, should I set something else?\nI am using version 1.7.9, and write as new AgentBuilder().Default().... Hi, I took many time on searching about this Nexus, in my understanding, when the origin type first created, the callback to LoadedTypeInitializer invoked, as we can't make sure when did a type created first so we make the Nexus to hold the initializers combine to ClassLoader so that the Nexus won't be collected. Am I right?\nAnd I have another two question\uff1a\n1\uff09Does the LoadedTypeInitializer exist for initializing the auxiliary types\uff1fIf this callback does not exist, the enhancement of the origin type will not work?\n2) As the Nexus reference to the classloader and the classloader will never been destroyed so Nexus can not be collected, then why it be defined as a WeakReference? Will NexusAccessor's clean method invoked after type initialized? Where did this invoke happened?\nByte buddy is really a nice project and designed very good. We are using it to build our apm system.\n. Thanks for your reply again!\nI have tried InitializationStrategy.Minimal but got java.lang.ClassNotFoundException of auxiliary type.  It seems that if I want this run on the PRODUCT environment, I should use the InitializationStrategy.SelfInjection and reduce the instrument class number.. Thank you! I may need more study on it's life cycle.. I just found this conflicts with another tool and feel doubt. For now it seems reasonable to redeclare methods to protect the super classes. If I use redefine or subClass will not have this problem, right?\nThank you for answer.. Ok I see. I have avoid this by some way. Thank you for answer me!. ",
    "yrodiere": "Changed the ticket description: as you may have noticed, the snippet of code was incorrect.. That was fast. Thanks a lot!. Thanks! This bug affects Hibernate ORM (HHH-13112) and, through it, Hibernate Search, whose integration tests don't pass anymore after upgrading to ORM 5.4.0.CR1.\nDo you think byte-buddy could get a new release soon, so that we can update our dependencies and have the fix in the next releases?. @raphw A release next week will do just fine. Thanks!. ",
    "jpfourny": "You need to make Bar static. Check this out:\nclass Foo {\n\n    public static void main(String[] args) throws IOException {\n        System.out.println(\">> ORIGINAL CLASS:\");\n        byte[] originalBytes = getClassBytes(Foo.Bar.class);\n        traceClass(originalBytes);\n\n        System.out.println(\">> REDEFINED CLASS:\");\n        byte[] transformedBytes = new ByteBuddy().redefine(Foo.Bar.class).make().getBytes();\n        traceClass(transformedBytes);\n    }\n\n    private static byte[] getClassBytes(Class<?> cls) throws IOException {\n        String path = cls.getName().replaceAll(\"\\\\.\", \"/\") + \".class\";\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buf = new byte[4096];\n\n        try (InputStream in = Foo.class.getClassLoader().getResourceAsStream(path)) {\n            while (true) {\n                int len = in.read(buf);\n                if (len == -1) {\n                    break;\n                }\n                out.write(buf, 0, len);\n            }\n            return out.toByteArray();\n        }\n    }\n\n    private static void traceClass(final byte[] bytes) {\n        ClassReader r = new ClassReader(bytes);\n        r.accept(new TraceClassVisitor(new PrintWriter(System.out)), 0);\n    }\n\n    static class Bar {\n\n    }\n\n}\n\nCompare the ORIGINAL vs REDEFINED trace. The redefined output is the same, except for the new \"OUTERCLASS Foo null\". If you run these bytes through javap, you will also see that an EnclosingMethod attribute was added. Here is the output from my system:\nclass Foo$Bar\n  minor version: 0\n  major version: 52\n  flags: ACC_SUPER\nConstant pool:\n   #1 = Class              #2             // Foo$Bar\n   #2 = Utf8               Foo$Bar\n   #3 = Class              #4             // java/lang/Object\n   #4 = Utf8               java/lang/Object\n   #5 = Utf8               <init>\n   #6 = Utf8               ()V\n   #7 = Utf8               Code\n   #8 = Methodref          #3.#9          // java/lang/Object.\"<init>\":()V\n   #9 = NameAndType        #5:#6          // \"<init>\":()V\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               LocalVariableTable\n  #12 = Utf8               this\n  #13 = Utf8               LFoo$Bar;\n  #14 = Utf8               SourceFile\n  #15 = Utf8               Foo.java\n  #16 = Utf8               InnerClasses\n  #17 = Class              #18            // Foo\n  #18 = Utf8               Foo\n  #19 = Utf8               Bar\n  #20 = Utf8               EnclosingMethod\n{\n  Foo$Bar();\n    descriptor: ()V\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #8                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 45: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   LFoo$Bar;\n}\nInnerClasses:\n     static #19= #1 of #17; //Bar=class Foo$Bar of class Foo\nEnclosingMethod: #17.#0                 // Foo\nSourceFile: \"Foo.java\"\n\n. Apologies - I should have mentioned that I am running with 1.8.20. I tried the test case again with 1.9.4 and the issue is not reproducible. It seems to be isolated to 1.8.x. I am glad to know that it is fixed! \nUnfortunately, Byte Buddy 1.9.x is not binary compatible with a 3rd party lib I am using (Stagemonitor). I have a private fork, so it can be done with some effort. . The agent is loaded by System class loader, so this limits what your advice can do. As soon as you instrument a class from bootstrap classpath, it cannot make references to your agent classes, nor ByteBuddy internals. For this to work, you must promote your agent classes to bootstrap. I know ByteBuddy has some facilities to do this for you ... but I am not very familiar with them, yet. I had a similar problem, and I solved it by re-packing a subset of my agent JAR into temp files and adding those files to bootstrap classpath via Instrumentation API. . I ended up packing the guts of my agent into separate JAR files as resources (ie: JAR inside a JAR). In the root JAR, I only have agent main/premain and some support classes to bootstrap startup, which includes extraction of temp JAR files and updating bootstrap classpath on Instrumentation. \nAttached, is an example utility to help extract JARs that are embedded into your agent JAR.\nBootstrapJars.txt\n. ",
    "mariusoe": "Hey, first of all thanks for the quick response! :)\nI don\u2019t get it completely. As far as I understand, one option would be to trigger the retransformation manually using retransformClasses and decide in the transformer what I want to do (do nothing, retransform or reset it). Did I get this right?\nAnother option would be to implement a mutable matcher and assign it to byte buddy. But in this case I also have to retrigger the analysis of the classes in some way when the matcher is changing, right? Or do you mean to use a mutable matcher in combination with manually triggering the instrumentation?\n. By the way, thanks for your help!. ",
    "jqno": "Ah, so indeed an incorrect expectation. I wasn't aware of @Inherited, so I learned something. Thank you!\nI tried it out with a different annotation (one that does have @Inherited), and then indeed it works completely as expected.. ",
    "eyalkoren": "Well, the class IS located afterwards when is searched by itself. So if class B depends on class A (in my case - has a method that returns A), then instrumentation of class B fails due to failure to find class A while resolving B. Afterwards BB succeeds resolving A itself.. I see. So one option is to not fail due to resolving of dependencies of bootstrap classes (can make this optional) and the other is to enable jar search only for bootclasspath jars.\nDo you see any of those interesting or do you want to close this issue? . > What do you mean by \"not fail\"? \nIn this case I only match for type name and method name, so I don't expect to check (and fail due to) anything other than that.. 2018-12-04 15:36:57.880 [default task-6] DEBUG co.elastic.apm.impl.ElasticApmTracer - startTransaction '' 00-9c53093e2fe9d9a4093a604c67700ae1-89c38846d64d055b-01 {\n2018-12-04 15:36:57.881 [default task-6] DEBUG co.elastic.apm.impl.ElasticApmTracer - Activating '' 00-9c53093e2fe9d9a4093a604c67700ae1-89c38846d64d055b-01 on thread 128\n2018-12-04 15:36:57.885 [default task-6] DEBUG co.elastic.apm.bci.ElasticApmAgent - Type match for advice StartTransactionInstrumentation: name(equals(co.elastic.apm.api.ElasticApm)) matches class co.elastic.apm.api.ElasticApm\n2018-12-04 15:36:57.885 [default task-6] DEBUG co.elastic.apm.bci.ElasticApmAgent - Type match for advice CurrentTransactionInstrumentation: name(equals(co.elastic.apm.api.ElasticApm)) matches class co.elastic.apm.api.ElasticApm\n2018-12-04 15:36:57.886 [default task-6] DEBUG co.elastic.apm.bci.ElasticApmAgent - Type match for advice CurrentSpanInstrumentation: name(equals(co.elastic.apm.api.ElasticApm)) matches class co.elastic.apm.api.ElasticApm\n2018-12-04 15:36:57.887 [default task-6] DEBUG co.elastic.apm.bci.ElasticApmAgent - Type match for advice CaptureExceptionInstrumentation: name(equals(co.elastic.apm.api.ElasticApm)) matches class co.elastic.apm.api.ElasticApm\n2018-12-04 15:36:57.901 [default task-6] WARN co.elastic.apm.bci.bytebuddy.ErrorLoggingListener - ERROR on transformation co.elastic.apm.api.ElasticApm\njava.lang.IllegalStateException: Cannot resolve type description for co.elastic.apm.api.Transaction\n    at co.elastic.apm.shaded.bytebuddy.pool.TypePool$Resolution$Illegal.resolve(TypePool.java:159)\n    at co.elastic.apm.shaded.bytebuddy.pool.TypePool$Default$WithLazyResolution$LazyTypeDescription.delegate(TypePool.java:1407)\n    at co.elastic.apm.shaded.bytebuddy.description.type.TypeDescription$AbstractBase$OfSimpleType$WithDelegation.getModifiers(TypeDescription.java:8115)\n    at co.elastic.apm.shaded.bytebuddy.description.ModifierReviewable$AbstractBase.matchesMask(ModifierReviewable.java:618)\n    at co.elastic.apm.shaded.bytebuddy.description.ModifierReviewable$AbstractBase.isPublic(ModifierReviewable.java:336)\n    at co.elastic.apm.shaded.bytebuddy.description.type.TypeDescription$AbstractBase.isVisibleTo(TypeDescription.java:7631)\n    at co.elastic.apm.shaded.bytebuddy.matcher.VisibilityMatcher.matches(VisibilityMatcher.java:48)\n    at co.elastic.apm.shaded.bytebuddy.matcher.VisibilityMatcher.matches(VisibilityMatcher.java:27)\n    at co.elastic.apm.shaded.bytebuddy.matcher.ErasureMatcher.matches(ErasureMatcher.java:50)\n    at co.elastic.apm.shaded.bytebuddy.matcher.ErasureMatcher.matches(ErasureMatcher.java:29)\n    at co.elastic.apm.shaded.bytebuddy.matcher.MethodReturnTypeMatcher.matches(MethodReturnTypeMatcher.java:48)\n    at co.elastic.apm.shaded.bytebuddy.matcher.MethodReturnTypeMatcher.matches(MethodReturnTypeMatcher.java:27)\n    at co.elastic.apm.shaded.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:122)\n    at co.elastic.apm.shaded.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:122)\n    at co.elastic.apm.shaded.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:122)\n    at co.elastic.apm.shaded.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:122)\n    at co.elastic.apm.shaded.bytebuddy.matcher.FilterableList$AbstractBase.filter(FilterableList.java:125)\n    at co.elastic.apm.shaded.bytebuddy.dynamic.scaffold.MethodRegistry$Default.prepare(MethodRegistry.java:496)\n    at co.elastic.apm.shaded.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:189)\n    at co.elastic.apm.shaded.bytebuddy.agent.builder.AgentBuilder$Default$Transformation$Simple$Resolution.apply(AgentBuilder.java:10050)\n    at co.elastic.apm.shaded.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doTransform(AgentBuilder.java:10469)\n    at co.elastic.apm.shaded.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:10432)\n    at co.elastic.apm.shaded.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1500(AgentBuilder.java:10198)\n    at co.elastic.apm.shaded.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:10807)\n    at co.elastic.apm.shaded.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher.run(AgentBuilder.java:10754)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at co.elastic.apm.shaded.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:10355)\n    at sun.instrument.TransformerManager.transform(TransformerManager.java:188)\n    at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)\n    at java.lang.ClassLoader.findBootstrapClass(Native Method)\n    at java.lang.ClassLoader.findBootstrapClassOrNull(ClassLoader.java:1015)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:413)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:411)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n    at org.jboss.modules.ConcurrentClassLoader.performLoadClass(ConcurrentClassLoader.java:386)\n    at org.jboss.modules.ConcurrentClassLoader.loadClass(ConcurrentClassLoader.java:134)\n    at co.elastic.webapp.TestServlet.doGet(TestServlet.java:51)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:687)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)\n    at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:86)\n    at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)\n.... OK, I will look into that. Thanks!. I set a breakpoint myself and tested it within our code, here is what I get when invoking Class.forName(\"java.lang.invoke.MethodHandles\").getMethod(\"lookup\").invoke(null):\nCaused by: java.lang.IllegalArgumentException: illegal lookupClass: class co.elastic.apm.agent.impl.ElasticApmTracer\n    at java.base/java.lang.invoke.MethodHandleStatics.newIllegalArgumentException(MethodHandleStatics.java:123)\n    at java.base/java.lang.invoke.MethodHandles.reflected$lookup(MethodHandles.java:117)\n    at co.elastic.apm.agent.impl.ElasticApmTracer.activate(ElasticApmTracer.java:408)\n    ...\nSo, when the java.lang.reflect.Method returned by Class.forName(\"java.lang.invoke.MethodHandles\").getMethod(\"lookup\") is invoked, what actually gets invoked is MethodHandles#reflected$lookup:\n/**\n     * This reflected$lookup method is the alternate implementation of\n     * the lookup method when being invoked by reflection.\n     */\n    @CallerSensitive\n    private static Lookup reflected$lookup() {\n        Class<?> caller = Reflection.getCallerClass();\n        if (caller.getClassLoader() == null) {\n            throw newIllegalArgumentException(\"illegal lookupClass: \"+caller);\n        }\n        return new Lookup(caller);\n    }\nIndeed in our case both this class I set the breakpoint at and the shaded ByteBuddy classes are loaded from the bootstrap class loader (hence caller.getClassLoader() == null).\nWhen I invoke the actual lookup method not through reflection from the same class, it works fine and returns a valid Lookup:\n\nSo I guess the easy solution is to determine the Java version in a different way, and call MethodHandles#lookup not though reflection, but just plain Java compiled in class that is not loaded unless the right Java version is used.. Note, this might be the same behaviour for openjdk 10 as well, where I see the same Javadoc for MethodHandles#reflected$lookup. What I suggested is to compile the code that has dependency on Java 7/8/whatever in a separate class and call that class through reflection only when running on the suitable Java version, so that it's safe enough.\nAnyway, if there's an easier/better way to overcome this- even better \ud83d\ude04 .\nThanks a lot!. ",
    "cngddflzw": "Finally I use advice to solve this problem. It works fine as @Advice will not add method or field to the class. The code something like:\n```java\npublic class Foo {\npublic String test(String name) {\n    return \"Hello \" + name;\n}\n\n}\npublic class ValueReplaceAdvisor {\n@Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)\npublic static Object shouldReplaceValue(@Advice.Argument(0) String name) {\n    if (name.equals(\"abc\")) {\n        return \"replace value\";\n    } else {\n        return null;\n    }\n}\n\n@Advice.OnMethodExit\npublic static Object replaceValue(\n        @Advice.Return(readOnly = false, typing = DYNAMIC) Object returned,\n        @Advice.Enter Object enter) {\n    if (enter != null) {\n        returned = enter;\n    }\n    return returned;\n}\n\n}\n```\nthis Advisor is not for WebappClassLoader,  but has almost the same effect -- it replaces the value when the name is \"abc\".\nand the configuration code is:\njava\n        final Extendable extendable = new AgentBuilder.Default()\n                .with(StreamWriting.toSystemOut().withErrorsOnly())\n                .with(StreamWriting.toSystemOut().withTransformationsOnly())\n                .with(Default.REDEFINE)\n                .with(RedefinitionStrategy.REDEFINITION) \n                .disableClassFormatChanges() \n                .ignore(none())\n                .type(is(Foo.class))\n                .transform(new Transformer() {\n                    public Builder<?> transform(Builder<?> builder, TypeDescription typeDescription,\n                            ClassLoader classLoader, JavaModule module) {\n                        return builder.visit(Advice.to(ValueReplaceAdvisor.class).on(ElementMatchers.named(\"test\")));\n                    }\n                }) . thanks @raphw, works fine now. hi @raphw , thanks for replying quickly. I've change the code as below, but it didn't work\njava\n            new AgentBuilder.Default()\n                    .with(StreamWriting.toSystemOut().withErrorsOnly())\n                    .with(StreamWriting.toSystemOut().withTransformationsOnly())\n                    .with(RedefinitionStrategy.RETRANSFORMATION)\n                    .with(Default.REDEFINE)\n                    .ignore(none())\n                    .enableBootstrapInjection(inst, temp)\n                    .disableClassFormatChanges()\n                    .type(is(Thread.class))\n                    .transform((builder, typeDescription, classLoader, module) ->\n                            builder.visit(Advice.to(ThreadAdvisor.class)\n                                    .on(ElementMatchers.named(\"getContextClassLoader\"))))\n                    .installOn(inst);\nMy debug env is:\nOS: MacOS High Sierra 10.13.6\nIDE: intellij idea 2018.3.1\nJDK: 1.8.0_111\nByteBuddy: 1.9.6\nalso, I really want to know what's the difference between redefine and retransform. I've read some post in stackoverflow, but someone says (from https://stackoverflow.com/questions/19009583/difference-between-redefine-and-retransform-in-javaagent):\n\nThey seem almost redundant in the functionality they offer us. The main difference seems to be that when we redefine a class, we supply a byte[] with the new definition out of the blue, whereas when we retransform, we get a byte[] containing the current definition via the same API, and we return a modified byte[].\n\nand from (http://mail.openjdk.java.net/pipermail/serviceability-dev/2008-May/000131.html)\n\nThe main recommendation is to use retransformClasses if you are doing \ninstrumentation. The redefineClasses method is more intended for \nfix-and-continue and other cases where the class definition needs to be \nreplaced. \nThe main motivation and benefit of retransformClasses is that it allows \nmultiple instrumentation agents to co-exist. Each agent's transformer \ngets to instrument the class in turn. Removing instrumentation becomes \nsignificantly easier as the retransformClasses starts with the initial \nbytes.\n\nI don't quite understand what is \"fix-and-continue\", but it seems like most of the time, they have nothing different, and it really does nothing different for me -- they all work. And also, I can instrument the same class multiple times with multiple Advisor using ByteBuddy, so I think \"redefinition\" is no problem with the thing \"multiple instrumentation agents to co-exist\"?. @raphw I'm not sure what do you mean by \"outside of an IDE\" as I don't know how to debug outside an IDE. What I can prove is that:\n\nIt works quite well in Running mode inside an IDE\nI think there is another agent indeed, because you should add a VM option \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005\" to the remote application if you want to do a remote debug. but I'm not sure what this agentlib actually do. I would dig it deeper about \"jdwp\" later, thanks\n\n. Update:\nI tried remote debug with \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005\", also works fine. Maybe there are something more in local debug mode in intellij idea.. @raphw do you have any idea about this problem I can try? I've post an issue on the intellij idea issue tracks. I will report here when I get any progress.. ok, thanks @raphw , close it for now, will report here when I get any progress. it could be resolved by a setting of Intellij Idea, see: https://youtrack.jetbrains.com/issue/IDEA-206160. ",
    "ndrez93": "It appears that the following injection solves my problem:\nClassInjector.UsingInstrumentation\n    .of(FileUtils.getTempDirectory(), ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, i)\n    .inject(Map.of(new TypeDescription.ForLoadedType(Stub.class), ClassFileLocator.ForClassLoader.read(Stub.class)));\nThe JAR file gets created and my class can be found by the bootstrap class loader. However, why didn't enableBootstrapInjection work?. ",
    "thecodewarrior": "It seems that one works because main is a static method. If I make an instance method and make main call that it breaks.\n```java\npublic class Sample {\npublic static void main(String[] args) {\n    new Sample().nonstaticMethod();\n}\n\nprivate void nonstaticMethod() {\n    TypeToken token = new TypeToken<@FuckingTypeAnnotation Object>() { };\n    TypeDescription td = TypePool.Default.ofSystemLoader().describe(token.getClass().getName()).resolve();\n    AnnotationDescription desc = td.getSuperClass().getTypeArguments().get(0).getDeclaredAnnotations().get(0);\n    System.out.println(desc);\n}\n\nstatic class TypeToken<T> { }\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE_USE)\n@interface FuckingTypeAnnotation { }\n\n}\n```. Well shoot. Thanks for the help and quick response though. I want to support Java 8, as one of the primary places I'm going to use this is a Minecraft mod, which generally use Java 8, so I'll just add it to the docs.. ",
    "dvelopp": "Updated the link to my agent. . Updated: https://github.com/dvelopp/agent_template/blob/master/src/main/java/com/dvelopp/agenttest/Main.java\nExcluded \"bytebuddy\". It seems that issue is in something else. The same problem still reproduces. . @raphw , added:\n.or(ElementMatchers.isSynthetic())\nhttps://github.com/dvelopp/agent_template/blob/master/src/main/java/com/dvelopp/agenttest/Main.java\nThe same problem persists. . ",
    "serkan-ozal": "Thanks for quick answer @raphw \nSo, what is the best way to get the MethodDescription of the intercepted method in my advice annotated with @Advice.OnMethodEnter?. Hi @raphw \nI am using ByteBuddy version 1.9.7. Sorry but I couldn't find what should I pass as to bind method as binding parameter? TypeDescription or MethodDescription? If so, how can I use them?\nAdditionally, I have seen this discussion on the similar subject. As far as I see it works through @Advice.DynamicValue but seems that it is not available for the version I am using.. By the way, I am using ForAdvice in the following way:\njava\n            for (Map.Entry<? extends ElementMatcher, String> entry : getTransformers().entrySet()) {\n                builder = builder\n                        .type(getTypeMatcher())\n                        .transform(\n                                new AgentBuilder.Transformer.ForAdvice(Advice.withCustomMapping())\n                                        .with(AgentBuilder.PoolStrategy.Default.EXTENDED)\n                                        .include(ByteBuddyTest.class.getClassLoader())\n                                        .advice(entry.getKey(), entry.getValue())\n                        );\n            }. Ok, thx. Now I am able to bind. But somehow, argument names are still like arg0, arg1, etc ... \nI had set pool strategy to Default.EXTENDED in the agent builder as mentioned above. When I decompile the class (or parse with Javassist), I can see the argument names but these are not available in the OffsetMapping somehow. Do I need to configure something more?. Ok, when I set pool strategy over AgentBuilder (not over AgentBuilder.Transformer.ForAdvice), it worked. . By the way, thanks for your help. \nEven though the question is not related with this issue but I want to ask you that where should I look/start to implement (and register) a custom callback which will be invoked at each line in the method body?. ",
    "AnEmortalKid": "Worked for me:\n```\n[INFO] --- maven-antrun-plugin:1.8:run (copy-jar) @ byte-buddy-gradle-plugin ---\n[INFO] Executing tasks\nmain:\n     [copy] Copying 1 file to /Users/jm034719/workspaces/byte-buddy/byte-buddy-gradle-plugin/target\n[INFO] Executed tasks\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary for Byte Buddy (parent) 1.9.10-SNAPSHOT:\n[INFO] \n[INFO] Byte Buddy (parent) ................................ SUCCESS [ 10.247 s]\n[INFO] Byte Buddy Java agent .............................. SUCCESS [ 18.109 s]\n[INFO] Byte Buddy (with dependencies) ..................... SUCCESS [ 59.955 s]\n[INFO] Byte Buddy (without dependencies) .................. SUCCESS [  4.170 s]\n[INFO] Byte Buddy benchmarks .............................. SUCCESS [  5.697 s]\n[INFO] Byte Buddy for Android ............................. SUCCESS [  4.367 s]\n[INFO] Byte Buddy (Maven plugin) .......................... SUCCESS [  8.026 s]\n[INFO] Byte Buddy (Gradle plugin) ......................... SUCCESS [ 42.035 s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  02:32 min\n[INFO] Finished at: 2019-02-05T13:33:40-06:00\n[INFO] ------------------------------------------------------------------------\n```\nBelow are tool versions (this might help us track it down)\nmvn -v\nApache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-24T13:41:47-05:00)\nMaven home: /usr/local/Cellar/maven/3.6.0/libexec\nJava version: 1.8.0_162, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre\njava -version\njava version \"1.8.0_162\"\nJava(TM) SE Runtime Environment (build 1.8.0_162-b12)\n```\ngradle -v\nWARNING: An illegal reflective access operation has occurred\nWARNING: Illegal reflective access by org.codehaus.groovy.reflection.CachedClass (file:/usr/local/Cellar/gradle/4.8.1/libexec/lib/groovy-all-2.4.12.jar) to method java.lang.Object.finalize()\nWARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.reflection.CachedClass\nWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations\nWARNING: All illegal access operations will be denied in a future release\n\nGradle 4.8.1\nBuild time:   2018-06-21 07:53:06 UTC\nRevision:     0abdea078047b12df42e7750ccba34d69b516a22\nGroovy:       2.4.12\nAnt:          Apache Ant(TM) version 1.9.11 compiled on March 23 2018\nJVM:          10 (\"Oracle Corporation\" 10+46)\nOS:           Mac OS X 10.13.6 x86_64\n```. ",
    "qwwdfsad": "Hi @raphw \nSome context: one of the methods (boolean cancel()) was deprecated and left for binary compatibility, marked as synthetic to be sure no one is able to invoke it.\nI assume this is a common technique in Kotlin to make ABI-compatible changes of the return type.\nWould it help ByteBuddy if we marked synthetic method with bridge modifier as well? It would be nice if we could avoid such problems in the future, but still be able to use this trick. ",
    "wwftw": "Problem solved~~ @raphw Thank you for kind suggestion and prompt response \ud83c\udf7a . ",
    "clankill3r": "I meant this with snippet:\n\nI just founded it, I was first looking here:\nhttps://bintray.com/raphw/maven\nBut it was hidden under the small geen arrow.\n. ",
    "CROSP": "@raphw Thank you so much for the instant response. Your code snippet works like a charm.\nAppreciate your help!. ",
    "rendaw": "Excuse me, I looked everywhere for \"javadoc\" or \"documentation\" but didn't expect the API link to go there.  Closing this.. To clarify, this ticket is about the error message being unclear rather than confusion about required libraries (although I didn't see anything regarding this in the documentation).  Here's the stack trace:\nException in thread \"main\" java.lang.IllegalStateException: No compatible attachment provider is available\n    at net.bytebuddy.agent/net.bytebuddy.agent.ByteBuddyAgent.install(ByteBuddyAgent.java:389)\n    at net.bytebuddy.agent/net.bytebuddy.agent.ByteBuddyAgent.install(ByteBuddyAgent.java:374)\n    at net.bytebuddy.agent/net.bytebuddy.agent.ByteBuddyAgent.install(ByteBuddyAgent.java:342)\n    at net.bytebuddy.agent/net.bytebuddy.agent.ByteBuddyAgent.install(ByteBuddyAgent.java:328)\n    at test2/test2.Main.main(Main.java:7). ",
    "suztomo": "Thank you for confirmation.. ",
    "fwbrasil": "Should this issue be fixed on 1.9.9? I getting the same error message:\n[error] Exception in thread \"Thread-2\" java.lang.NoClassDefFoundError: net/bytebuddy/jar/asm/commons/ModuleHashesAttribute\n[error]     at net.bytebuddy.jar.asm.commons.ClassRemapper.visitAttribute(ClassRemapper.java:120)\n[error]     at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:642)\n[error]     at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:391)\n[error]     at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:3393)\n[error]     at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1930)\n[error]     at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:217)\n[error]     at net.bytebuddy.dynamic.scaffold.inline.AbstractInliningDynamicTypeBuilder.make(AbstractInliningDynamicTypeBuilder.java:120)\n[error]     at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:3396)\n[error]     at kyo.Kyo$$anon$1.reload$1(Kyo.scala:317)\n[error]     at kyo.Kyo$$anon$1.run(Kyo.scala:321)\n[error] Caused by: java.lang.ClassNotFoundException: net.bytebuddy.jar.asm.commons.ModuleHashesAttribute\n[error]     at java.net.URLClassLoader.findClass(URLClassLoader.java:382)\n[error]     at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n[error]     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)\n[error]     at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n[error]     ... 10 more\nI'm using the library from Scala\n```scala\n        def reloadT, U =\n          (new ByteBuddy).redefine(t.runtimeClass).name(u.runtimeClass.getName).make().load(t.runtimeClass.getClassLoader, ClassReloadingStrategy.fromInstalledAgent())\n    ByteBuddyAgent.install\n\n    reload[UCFunction0, OCFunction0]\n    reload[UCFunction1, OCFunction1]\n    reload[UCFunction2, OCFunction2]\n    reload[Kyo.type, Kyo.type]\n\n```. ",
    "JonasKunz": "Perfect! Thanks for the fast response.. ",
    "Sam-Kruglov": "As I said, I use the exact same setup locally and in Jenkins and they use Open JDK 11.0.1. I also tried setting <maven.compiler.release>1.8</maven.compiler.release> but that didn't help.. My root problem is that I can't run my tests that are written using mockk library. So whenever a mock is created they call this ByteBuddyAgent.install(). Mockito however works fine because they use a different technique. see https://github.com/mockk/mockk/issues/254#issuecomment-463616911. @raphw thanks, I will try this right now!. @raphw now prints another error:\n```\njava.lang.IllegalStateException: Error during attachment using: net.bytebuddy.agent.ByteBuddyAgent$AttachmentProvider$Compound@5aebe890\nat MyTest.test(MyTest.java:8)\n\nCaused by: java.lang.reflect.InvocationTargetException\nat MyTest.test(MyTest.java:8)\n\nCaused by: java.io.IOException: Can not attach to current VM\nat MyTest.test(MyTest.java:8)\n\n```\nWhat do you mean by creating a process? . @raphw it is Amazon Linux 2. I tried including this dependency but it didn't change anything. \nI use the same JDK locally and it works. Also, note this happens inside Docker, maybe that has something to do with it. Although again, locally works in Docker too.. Also figured that using -Djdk.attach.allowAttachSelf=true build fails even locally. @raphw ForModularizedVm. @raphw JAVA_HOME is surely valid since I have the jdk installed inside docker. @raphw I have removed byte buddy from the project and placed new ProcessBuilder(\"echo\", \"hey\").start(); in the test. It passed on AWS. So the problem must be with the exact command we are trying to execute? \nprocessId is the current PID? I figured there is a one-liner since java 9 ProcessHandle.current().pid(). ",
    "xyzmonday": "I want to enhance sun.net.www.protocol.http.HttpURLConnection , and enable bootstrap injection in the agent builder API like :\nnew AgentBuilder.Default(byteBuddy)\n                .ignore(ElementMatchers.nameStartsWith(\"net.bytebuddy.\"))\n                .ignore(ElementMatchers.nameStartsWith(\"org.slf4j.\"))\n                .ignore(ElementMatchers.nameStartsWith(\"org.apache.logging.\"))\n                .ignore(ElementMatchers.nameStartsWith(\"org.groovy.\"))\n                .ignore(ElementMatchers.nameContains(\"javassist\"))\n                .ignore(ElementMatchers.nameContains(\".asm.\"))\n                .enableBootstrapInjection(instrumentation, new File(folder))\n                .type(PluginManager.buildMatch())\n                .transform(new Transformer())\n                .with(new Listener())\n                .installOn(instrumentation);\nbut, agent will throw exception:\n java.lang.NoClassDefFoundError: cn/touna/agent/core/plugin/interceptor/enhance/EnhancedInstance. ",
    "WellingtonCosta": "Yeah. I already using AgentBuilder.Default, matching all classes annotated with @Foo and defining the generated() method with defineMethod. But I don't know exactly how to use StackManipulation, FieldAccessor, MethodInvokation and TextConstant.\njava\npublic static void premain(String agentArgs, Instrumentation instrumentation) {\n        new AgentBuilder.Default()\n                .with(new AgentBuilder.InitializationStrategy.SelfInjection.Eager())\n                .type(isAnnotatedWith(Foo.class))\n                .transform(new AgentBuilder.Transformer() {\n                    @Override public DynamicType.Builder<?> transform(\n                        DynamicType.Builder<?> builder,\n                        TypeDescription typeDescription, \n                        ClassLoader classLoader, \n                        JavaModule javaModule\n                    ) {\n                        // how to proceed from here?\n                        return builder;\n                    }\n                })\n                .installOn(instrumentation);\n    }\n. Nice! Do you have some example about this?. ",
    "safasofuoglu": "Thanks @raphw. Is there a workaround you can suggest in the meantime? We are okay to move things around to get this working, if there's a way.. ",
    "Shaunwild97": "Link to documentation on stack manipulation? I can't find any on google?. ",
    "zheyiyi": "Insead of doing this in the program, \nExecutorService exec = Executors.newFixedThreadPool(2);\n\nRunnable runnable = TtlRunnable.get(new LiftOff());\nexec.execute(runnable);\n\nI want to do this in the program\nExecutorService exec = Executors.newFixedThreadPool(2);\nexec.execute(new LiftOff());\n\nAnd in this agent, \n    public class MultiThreadAdvice {\n    public static Logger logger = LoggerFactory.getLogger(MultiThreadAdvice.class);\n@Advice.OnMethodEnter\nprivate static Span before(@Advice.Argument(value = 1, readOnly = false) Runnable runnable, @Advice.Origin Method method) {\n    logger.info(method.toString() + \" start to run\");\n\n\n    runnable = TtlRunnable.get(runnable);\n\n    return TraceManager.executorIntercept(method, runnable);\n}\n}\n\nAnother questions is that what is value i should put it on @Advice.Argument(value = ?, readOnly=false)?. oh, I see if i have a funtion run(string a,int b),   @Advice.Argument(value = 0, readOnly=false) , the value 0 is related to string a, right?. Thanks, I got it worked.. ",
    "mpe85": "I messed it up to set the module path correctly in Gradle. Now I am able to compile my stuff. Sorry for that, it was my mistake.\nBut there's still another problem: I'm using eclipse 4.10 and it does not recognize the module-info.class inside META-INF/versions/9 thus displays an error saying 'net.bytebuddy' cannot be resolved to a module. If I repackage the jar and put module-info.class in the top-level directory, it gets recognized by eclipse and everything's fine. I guess eclipse does not (yet?) handle multi-release jars correctly. Are you aware of that? What IDE do you use?. I tried it with a 1.9.11 snapshot build as you suggested and eclipse discovers the module info correctly now.. "
}