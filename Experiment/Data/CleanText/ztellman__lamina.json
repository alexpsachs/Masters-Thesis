{
    "ztellman": "Thanks for such a detailed report.  That code was definitely the culprit, and I've checked in a fix to github and clojars.\n. Thanks! Just as a heads up, I'll be replacing 0.3.1-SNAPSHOT with a more or less from scratch reimplementation, located in the \"observable\" branch.  I've integrated your changes, but they won't survive for too long.  Since you're one of the few people who have delved into the internals, feel free to take a look at the new code and share your thoughts.\n. The current version of lamina uses refs from top to bottom.  This has a certain performance cost, and doesn't play well with work that's being done by some other people (namely on Ring).  This new version makes only the part that has transactional semantics (i.e. the queue) use transactions.  There are a few other changes, but that's the big one.\nI'd be interested to hear more about your use case for Aleph, if you're able to tell me about it.\n. Yeah, channels should be Counted.  I took this out because I was a little unhappy with contant-channels having a count of 1 if they have a value, which is only sort of true, but I think the utility overrides the squishy semantics.  Thanks for the patch.\n. Thanks for bringing this to my attention so quickly.  Looking at your test, I think I may know what the issue is, but I'll need to look at it in more detail.  A fix will be forthcoming soon.\n. I've fixed the hanging behavior, but your test didn't seem to be expecting the correct output.  I've changed it to \n[:done [2 1] [2 2] :done]\nsince we're getting :done from both channels, but please correct me if I've misunderstood your test and the fact that I needed to change this is itself a bug.\n. My intuitive feel for priority-compose-channels is a little weak, so maybe this is a bug in Lamina (I'll look at it more carefully), but I think it's just that it was hitting the terminal case before the messages could be siphoned into the output-channel.  \nAgain, thanks for uncovering this issue.  It would have taken a while for me to organically discover this myself.\n. This is a very clear improvement.  Thanks!\n. Thanks.\n. Thanks for jumping so deep into the code.  I'll take a look at your changes today.\n. I haven't forgotten about this, I've just been really busy.  I plan to give it one more look and hopefully integrate it before the end of the week.\n. Yes, you're right - persistent-connection isn't really using result-channels properly.  When a connection is lost, it should immediately put an unrealized result-channel, and return that so that consumers aren't spinning on the lost connection.\n. Yes, I noticed this recently.  A fix is already in the 'new' branch, and will get merged into master in the near future.\n. Thanks for catching this, there were a few functions that didn't have docstrings.  A fix for this has been pushed and can be found in the 'new' branch.\n. Merged into the clj-1.3 branch.\n. The receive return value is a regression I wasn't testing for.  Thanks for catching that.\n'receive' and 'receive-all' are equivalent for constant channels, but it's fine to use either.\nThe pipeline wiki needs to be reworked, I think.  With (async ...) to support the simpler workflows, I think it will be more targeted to people wanting a more specific or higher performance implementation.\nAnd the async programming wiki is just half-finished.  I'll get around to it soon.\n. What version are you using?\n. This shouldn't still be open.\n. Done.\n. Thanks for the report, looking at it now.\n. This has long since been fixed.\n. Merged with clj-1.3\n. You're correct, that's not how it should be working.  The issue was that '(:status response)' was evaluating to nil, because of an issue with s-exprs starting with a keyword.  \nI've fixed the issue and added a test, but this type of issue is why the (async ...) macro is still an experimental piece of functionality.  Thank you for the report, and please don't hesitate to ask if you have any other questions.\nZach\n. Thanks!\n. Specify a :name in the request, and it won't generate a new probe name each time.  This should be prominently documented, and probably default to not being traced in the case of standalone http-requests.  Leaving this open until we default to saner behavior.\n. This is not a problem in 0.5.0\n. If I'm understanding your explanation, would this be accurately described as a multiplexed client, where each request and response indicates which stream it belongs to?\n. I've been thinking about a related issue, lately.  Both server and pipelined-server assume in-order responses, which isn't necessary or useful for all protocols.  But while there are client duals for both of the existing servers, the hypothetical unordered-server doesn't have a matching client.\nIn the multiplexed stream case, you can actually just multiplex the channel itself (this will become easier in 0.5.0), but this case is a bit trickier.  I'm inclined not to include this in the 0.4.1 release, not because it's not useful, but because I want to just make sure I've got my head wrapped around a proper general solution.\nThank you, though, for both this and the pull request to Gloss.  If I can be of any help with your 9P implementation, let me know.\n. This isn't a particularly new change.  In 0.5.0 binding conveyance will be configurable and off by default, but this an intentional feature.\nAre you using a pipeline inside your request handler?  Where are the thread-local bindings being defined?\n. To give a little more explanation, this should only be happening if a pipeline is suspended within the scope of the binding.  So\nclj\n(with-db db\n  (run-pipeline req\n    make-a-long-http-request\n    ...))\nwill close over the database connection, because the pipeline isn't complete.  However, if you're not using a pipeline, and it just looks more like\nclj\n(with-db db\n  (query-db req))\nand query-db is a synchronous call, then there is a real issue that needs to tracked down.\n. Okay, I think I know what the problem is.  Try this:\nclj\n((wrap-aleph-handler (fn [ch req]\n                         (future (enqueue ch (with-db *db* (create-req req)))))\n                       req)))\nand let me know if that solves the issue.  I readily admit there's no reason you should have to make this change, this is really non-obvious.  In 0.5.0, when this binding conveyance mechanism is off by default, it won't be an issue anymore.\nIn answer to your second question, there's only one error-handler, and that is executed in the context of whatever stage created the error.  If there are nested pipelines and the error is not handled, all error-handlers will be executed in that same context.\n. I agree that explicit is better in this case, and I apologize for any contortions you have to do until that's the default.  For what it's worth, 0.5.0 will also provide an analogue to 'future' that allows this to be explicit (there's both 'task' and 'bound-task').\nI'm going to close this issue, but rest assured I'm as eager as anyone to get to a release of Aleph that uses the new Lamina.\n. It's a ways off, but will you be at EuroClojure? I always like to hear about real-world uses of Aleph that are different from mine, so I can see if I'm overfitting it to my own problems.\n. Aloha doesn't expose any asynchronous functionality, so might not be that great at long-polling (or at least no better than Jetty, et al).  My hope is that Aleph will get very close in terms of speed, making Aloha just a curiosity.  Issues like these, where the oddness of the asynchronous approach leaks out in to the rest of the code, are avoidable with (more) careful design.\n. Thanks!\n. I'm actually going to implement this a bit deeper in the code, but this is an important thing to fix.  I really appreciate the second pair of eyes on the 0.5.0 release, thank you.\n. Yeah, then we don't have to actually create a copy of the messages, we can just use the .size method on the ConcurrentLinkedQueue.\n. I think nil is the correct default, I'm not sure why I was using an empty map instead.\n. Hey Sidhant,\nThis is intended behavior, if you search for \"trailing nil\" in the wiki you'll see where it's described.  This wasn't, however, a particularly great bit of design.  The idea was that you read messages from a channel one by one, you should always be able to receive a message before finding that the channel is closed, but it's ended up causing a lot of confusion.\nThis is changed in the 0.5.0 release (the perf branch, 0.5.0-alpha1 in clojars), which you may just want to skip to right now if you're just playing with the library for fun.\n. Yeah, 0.5.0 is a from-scratch rewrite, and is a much better codebase to explore.  Make sure you have graphviz installed on your machine and use the lamina.viz namespace, I think (hope) it will be a good learning tool.\n. Object is implicit, I believe.\nThat let actually makes it so that we don't need to look up the volatile data a second time.  Accessing a volatile-mutable member isn't always cheap, I try to minimize how often that happens.\n. Yikes.  I realized that the code wasn't consistent w.r.t. unrolled maps, and since there's already some prior art on Aleph using whole maps, I decided to standardize on that.  Apparently didn't catch all of them, thanks.\n. Yeah, while you can ignore the success or error outcomes in on-realized by giving a nil callback, I decided I'd rather have people explicitly decide to ignore an outcome, rather than implicitly by using only on-success or on-error.\n. Thanks for catching this.\n. I can't reproduce this in 0.5.0-SNAPSHOT, which leads me to think that this has already been fixed.  Can you confirm on your end?\n. This actually ends up being a harmless bug, since I'm just using that construct to get the defn metadata collapsing, and the :name is being overriden below.  Regardless, thanks for catching this.  I'm not sure why it's failing in 1.5.0-master-SNAPSHOT, I'll investigate.\n. Actually, this appears to be unrelated to your change, since the existing repo is also failing in 1.5.0-master.  Something must have changed in the Clojure repository.  Merging.\n. This is fixed, but your first example won't work; you can't siphon a result-channel into a normal channel.  Try this:\nclj\n(def ch (distributor :name \n  (fn [facet ch] \n    (run-pipeline (reduce* conj [] ch)\n            prn))))\n(enqueue ch #{})\n(close ch)\n. Thanks for catching this, by the way.\n. Just to be clear, you should be able to call view-graph in isolation.  If you look at the implementation, render-graph is called by view-graph, you shouldn't have to call it yourself.  Is the actual problem that the doc-string is unclear?\n. I tried to reproduce this when I saw your issue, and was unable to.  My steps were as follows:\nOn OS X 10.8, within the lamina project directory:\n1. run lein repl\n2. Copy/paste the following lines:\nclj\n(use 'lamina.core 'lamina.viz)\n(def ch (channel))\n(map* inc ch)\n(map* dec ch)\n(enqueue ch 1 2 3)\n(view-graph ch)\nThe window appears as expected.  I was also able to reproduce this in a project that depends on Lamina.\nCan you confirm that the above does not work for you, and provide details about your environment?\n. Weird.  Do you need to run render-graph for each subsequent view-graph, or does a single render make all subsequent views work?\nAlso, can you run jstack on the process when it's hanging, and give me the call stack?\n. So what happens when you call view-graph? It returns, but no window appears?\n. Wow, this completely fell off my radar.  I'm flying out to the Conj today,\nso I can't promise a day's turnaround, but I'll have a fix in very soon.\n Sorry about that.\nOn Wed, Nov 14, 2012 at 6:22 AM, Moritz Heidkamp\nnotifications@github.comwrote:\n\nAny news on this one? :-)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ztellman/lamina/pull/45#issuecomment-10367497.\n. Hey, I've actually been looking at this, trying to understand where there's the possibility of an exception.  I found one in queue.clj, but not in the propagate method in node.clj.  Before making the inner loop that much more complicated, I want to understand what's happened.  \n\nJust out of curiosity, have you seen this again?\n. Were you calling Thread.stop()?\n. I'm confused by what you're suggesting here.  \nThe reason pipelines default to logging errors is that we can't be sure the result will be consumed by anything else (the pipeline may represent a side-effect), even if the pipeline is being run within the context of another pipeline.  Allowing them to fail silently is not, in my opinion, a valid option.  If someone wants to get rid of the logging, they simply need to add an empty :error-handler at the specified line.\nJust to be clear, having an :error-handler doesn't mean that the exception doesn't propagate, unless the error handler returns a redirect signal (restart, redirect, or complete).  Having an empty callback for the error only suppresses the logging; it doesn't affect any other behavior.\nCan you explain why you think removing the logging is a \"fix\" for anything?\n. The problem with making it manual is that if someone fails to log an error\nthat doesn't bubble out to an outer pipeline, the error is effectively\ninvisible.  Based on my own experiences this is a real problem, which is\nwhy pipelines now log by default.  It is very trivial, though, to write\nyour own silent-pipeline macro that just puts in an empty handler by\ndefault.  I've gone back and forth on whether I should provide one in\nLamina itself, but it hasn't seemed necessary so far.\nOn Wed, Jan 2, 2013 at 10:19 PM, Nimalan Mahendran <notifications@github.com\n\nwrote:\nThe problem I'm trying to solve is that if a result channel ends up being\nan error result and goes through a sequence of pipelines, every single\npipeline logs the same exception, which is repetitive. Having to add empty\nerror handlers to all the pipelines except the last one is repetitive in\nterms of code. I just wanted some way of not having either kind of\nrepetition. If there's a better solution to that than this diff, that would\nbe fine by me too.\nMy reasoning behind removing the logging is so that one could add the\nlogging of the error (manually) at the last pipeline in the sequence of\npipelines, or wherever they are actually interested in dealing with it and\nbe able to avoid having a single exception logged multiple times.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ztellman/lamina/pull/49#issuecomment-11835888.\n. I can't reproduce the parser error, maybe it's a url-encoding -> query-string issue?  We can follow up on that next week.\n\nThere is, however, an issue where filtering the output within a group-by can delay a message being sent for an arbitrarily long period, since message n relies on receiving the first facet for n+1.  The correct fix for this is probably making it so that a where operator after a periodic operator within a group-by emits some sort of false signal that resets the aggregation mechanism but isn't emitted.  That's a pretty gnarly special case, though, so I need to think if there's a cleaner way to approach this.\n. the configurable period has been in for a while, and I have a semi-reasonable workaround for the filtered group-by problem, so I'm calling this one closed\n. Huh, didn't know that existed.  Why is it in clojure.set?\n. Good catch, thank you.\n. There's actually a function called error-value which should be exposed in\nlamina.core, but isn't.  I'll remedy that now.\nOn Fri, Feb 8, 2013 at 4:35 AM, James Henderson notifications@github.comwrote:\n\nHi again,\nAfter a deeper look through the core docs, I've stumbled across\nlamina.core/drained-result, which is enough to solve my particular use\ncase (solution below, if anyone's interested!). I'll leave this issue open\nfor now though, just in case anyone else thinks it might be\nnecessary/useful, otherwise please feel free to close.\nJames\n(let [ch (l/channel)\n      res (l/drained-result ch)]\n(l/on-realized res\n                 (fn _)\n                 (fn e) ; prints \"Error'd an error\"\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ztellman/lamina/issues/56#issuecomment-13288575.\n. This is the second time this has happened, I've just pushed an 0.5.0-SNAPSHOT which targets the metrics-core snapshot.  Metrics-core is going to be removed as a dependency very soon, and I'll put out a formal release once that's done, please just use the snapshot for now.\n. This is an easy enough change, but it's not clear to me that specifying a timeout for wait-for-result suggests that the timeout should apply to anything other than the \"wait\".  As you point out, adding a timeout to read-channel causes the read itself to timeout.\n\nCould you expand on why you think this is not \"expected\" behavior?\n. I also use OS X, and it works for me.  One difference is that I don't use the homebrew installation of graphviz, because I've had issues with it in the past.  If you use the installer linked in the wiki instead, does that change anything?\n. Oh, I didn't notice the version of Lamina.  Can you use 0.5.0-beta16 and let me know if that changes the behavior?\nIf not, I'd like to see what dot-strings you're generating.  Unfortunately the functions are a bit too coupled right now, so you'll have to do something a little hokey:\n``` clj\n\n(alter-var-root #'lamina.viz.core/render-dot-string \n     (fn [f] \n       (fn [dot-string] \n         (println dot-string) \n         (f dot-string))))\n```\n\nand then try to run view-graph again.\n. This isn't ideal for every use case (in fact, every usage in Lamina itself relies on it waiting the full period before firing), so I've added an :immediate? option to periodically, which false by default.\n. No reason, go ahead and give me a pull request whenever you like.\n. Oh, ha.  Yeah, that's a perfectly good workaround, thanks for that.\n. Not built in, no.  Using something like core.async for this would be more appropriate.  If you have pre-existing functionality in Lamina, it's relatively easy to bridge between the two types of channels.  I can provide some guidance w.r.t. that if you like.\n. In order to make callbacks registered via receive cancelable, they're registered against a key.  If no key is given (which isn't possible via the public API, actually), then the callback is used as a key.  The second time the callback is registered, there's a collision, which throws the IllegalStateException.  Any var used as a callback in this way will cause the same exception.  (receive c #(println %)) will work around it, until I can fix this in the upcoming release.  Sorry for the implementation details leaking out.\n. Actually, once I think about it a bit more, there's no way to change the semantics of this without breaking the canceling mechanism.  I'm going to document this more clearly, though.\n. Yes, this is a clear oversight, I'll fix it and release a new version soon.\nOn Mon, Jan 27, 2014 at 9:27 AM, Drew Noakes notifications@github.comwrote:\n\nHere's a small snippet that reproduces the error:\n(defn chat ch request))\n(defroutes app-routes\n           (GET [\"/\"] {} (wrap-aleph-handler chat))\n           (route/not-found \"Page not found\"))\n(defn -main & args)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/ztellman/lamina/issues/81#issuecomment-33398775\n.\n. Sorry, coming to this late.  Is there any AOT compilation going on?\n. Are you using the latest potemkin?  There were some issues with\ndefinterface+, and it's possible you're not using the version that fixes\nit.  Targeting the latest Lamina (0.5.2) will bring the latest Potemkin\nalong with it.\n\nOn Mon, Feb 10, 2014 at 5:17 PM, coltnz notifications@github.com wrote:\n\nOk after a bunch of red herrings, I can confirm we did in fact have an AOT\ninternal library and once AOT-ed problem went away. Seems to be potemkin\nand clojure AOT bugs related (this one?\nhttp://dev.clojure.org/jira/browse/CLJ-1330).\n\nReply to this email directly or view it on GitHubhttps://github.com/ztellman/lamina/issues/82#issuecomment-34717503\n.\n. This is because Clojure creates a class file for each anonymous function, and Lamina creates an enormous number of anonymous functions.  I've often meant to climb down into Clojure's compiler and figure out if this overhead is necessary, but haven't gotten around to it.\n\nFor what it's worth, I've been working on a much more minimal library which doesn't have this (admittedly ridiculous) overhead.  It's still a work in progress, but can be found at https://github.com/ztellman/manifold.\n. This is due to a bad test, not a bug, thankfully.  Thanks for catching this.\n. ",
    "NicolasLambert": "Thanks for the fix. It works fine !\n. ",
    "pmoriarty": "Will do.  I'm using Aleph/Lamina in an asynchronous high volume transaction processing switch and so far it's been good to me.  I've very interested in seeing your latest work.  Seems like you may have been studying Rx?\nThanks for opening and sharing your work, I'd be happy to let you know what I think.\n. ",
    "senior": "Thanks for the quick fix, it works for me.  You found a bug in the test/priority-compose-channels (thanks!).  I actually didn't want a second :done flowing through, but that's easy to fix.\nOne question.  You moved the siphon to before the on-sealed.  The order of that seems important (if I move it back, I get unexpected results).  Is there a reason for different results based on where that line of code is?\n. ",
    "ogf": "Thanks. No need to hurry.\n. The problem is in line 51 of lamina/connections.clj. The result is reset to the ::close keyword. This causes problem when @result is accessed in the error-handler and so on. Wraping ::close in a success-result should fix the problem.\n. lamina-0.4.0-beta3, it should happen in master too. I'm sending you a pull-request.\n. I've indented with spaces so the diffs look pretty bad. Feel free to commit the changes yourself.\n. ",
    "pwinn": "Sorry, finally tracked it down. In my chat handler, I have two args, the first of which is the channel and the second of which contains the properties I was seeking. Doh!\n. ",
    "dajac": "Thank you! I really appreciate your help.\nLe 1 f\u00e9vr. 2012 \u00e0 22:50, Zach Tellmanreply@reply.github.com a \u00e9crit :\n\nSpecify a :name in the request, and it won't generate a new probe name each time.  This should be prominently documented, and probably default to not being traced in the case of standalone http-requests.  Leaving this open until this defaults to saner behavior.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ztellman/lamina/issues/26#issuecomment-3767902\n. \n",
    "trevorbernard": "diff --git a/src/lamina/core/channel.clj b/src/lamina/core/channel.clj\nindex 3a3d8ce..3bb2c97 100644\n--- a/src/lamina/core/channel.clj\n+++ b/src/lamina/core/channel.clj\n@@ -35,8 +35,7 @@\n   (withMeta _ meta))\n(defn channel\n-  \"Returns a channel that c\n  -ontains the specified messages.\"\n-  \"Returns a channel that contains the specified messages.\"\n  & messages)\n. ",
    "llasram": "Yes-ish. My immediate itch is using the aleph stack to implement the 9P protocol, in which each request/response pair is entirely separate.  Protocols which multiplex multiple actual streams (vs individual messages) over a single connection were an afterthought on my part, and the code as-is I admit may not be the best fit.\n. In fact, on reflection it makes much more sense to move the tagging/unwrapping logic off to pipelines feeding to/from the client.  Added a commit to so-modify the interface.\n. That makes sense.  I'll just keep tweaking my implementation in this branch for the time being.  I'll definitely ping you if I've got any questions, and please let me know if there's anything I can do once you've got a clearer idea how you'd like to see support for reordering protocols implemented.\n. ",
    "lnostdal": "Err, that didn't work. Perhaps this one will: https://gist.github.com/2037329\n. Something like:\n``` clj\n(defn my-handler [req]\n  ;; sometimes just:\n  (with-db db\n    (create-req req))\n  ;; other times:\n  ((wrap-aleph-handler (fn [ch req]\n                         (future (with-db db (enqueue ch (create-req req)))))\n                       req)))\n(start-http-server (wrap-ring-handler ... my-handler)))\n```\nNot sure that helps or whether I got this illustration right as is or when considering what I actually do. I'll try to backstep both aleph and lamina and see when things change exactly. This might be my fault also if I'm missing something here; perhaps the lamina I've been using for quite some time has been really old. \n. Perhaps unrelated question, but what happens on exceptions? Does the bindings \"undo\" from one conveyance to the previous in a sort of stack?\n. Sorry for the slow response. I think I understand what's going on; I'll go with a monkey patch for this until 0.5.0 as I also use other bindings in some places (not only DB stuff) which I guess might leak cross HTTP round-trips in similar ways to this. \nIt seems too brittle to e.g. manually filter things out or do similar back-flips for each case; I'd rather explicitly have to forward my bindings than have it happen \"magically\" in any way or form.\nNot related to lamina/aleph, but I think the whole implicit/automatic binding conveyance thing for agents/futures etc. in Clj 1.3+ is a huge mistake by the way.\n. Thanks for your work on all this by the way. The Netty, Aleph and Clojure combo is great stuff. We're building a real-time auction site on some of this; I'm very excited; it's going to be, well, as Rich says, \"awesome\". :)\n. Nope, not attending.\nAbout overfitting; I think your Aloha project is interesting too. I mean I'm not sure I actually need a whole lot of \"fancy stuff\" here besides support for very simple HTTP AJAX long polling and nothing else at this particular level.\nPerhaps I'll switch to Aloha for serving later, if needed, and use Lamina etc. for higher-level concerns. I don't know.\n. ",
    "mpenet": "You are welcome.\nI suspected it might belong at a lower level, it is going to be added on queues?\n. That makes sense. Thanks for the info.\n. Just wondering: is it intentional not to specify Object when implementing toString ? \n(ex here: https://github.com/ztellman/lamina/blob/perf/src/lamina/core/result.clj#L336 )\nIt seems to work fine without it, but I always assumed it was mandatory. \non the same code block there is also an unnecessary \"let\" it seems  \n(let [state state] \n ....\n. Ah good to know, thanks.\n. Also the doc doesn't show the lamina.core/success function anymore. \nIs this intentional (depreciation in favor of another fn maybe)?\n. That's unfortunate. \nLet me know if that's a blocker for you, I'd consider moving the lamina based async function to a separate namespace (at least if you don't use it you wouldnt encounter this issue).\n@ztellman the code in question is here https://github.com/mpenet/alia/blob/master/src/qbits/alia.clj#L253\n. @coltnz I looked into this, apparently it was caused by a typo and was fixed in  https://github.com/ztellman/lamina/pull/77 . I updated the dependency on alia, from my quick tests it seems to work now.\n. You can get the latest version with the update using cc.qbits/alia \"2.0.0-beta7\"\n. Works for me. \n; CIDER 0.5.0alpha (package: 20140114.202) (Clojure 1.5.1, nREPL 0.2.3)\nuser> (require '[qbits.alia :as alia] :reload)\nnil\nuser> (require '[qbits.alia :as alia] :reload-all)\nnil\nuser>\nAs @ztellman said, maybe it's related to aot, or conflicting dependencies. try lein clean and also lein deps :tree looking for an older lamina version maybe.\n. ",
    "grinnbearit": "Thanks was a little confused :)\nI have some fun ideas i'd like to try out but I'm also figuring out how its built. I'll check out the 0.5.0 release and continue.\n. That's brilliant! I've got to learn how to use graphviz, thanks Zach\n. ",
    "travisbot": "This pull request fails (merged f3538f2f into d8ddd61f).\n. This pull request fails (merged fac4cfa4 into d8ddd61f).\n. ",
    "DerGuteMoritz": "You're welcome! I just noticed it when skimming the code and thought it wouldn't hurt to report it :-) No idea either why it fails though.\n. Any news on this one? :-)\n. :alarm_clock: Another bi-monthly issue reminder  :-)\n. I don't think I've seen it again since then. One scenario which I think could cause this is when a thread is stopped while we're in propagate, throwing a java.lang.ThreadDeath and thus leaving the channel in an invalid state. What do you think?\n. Not explicitly but I might have been C-c C-cing my SLIME connection at some unfortunate point in time :-)\n. ",
    "yongqli": "Ah, that makes sense. Thanks.\n. ",
    "russellwhitaker": "Well, in that case, the doc string would be unclear, but it happens - for me at least - that calling view-graph in isolation results in an indefinite hang at the REPL, whereas a call to render-graph returns quickly, after which invoking view-graph promptly displays the rendering.\n. My own o/s is OS X 10.7.4, not 10.8; my java runtime:\n% java -version\njava version \"1.7.0_04\"\nJava(TM) SE Runtime Environment (build 1.7.0_04-b21)\nJava HotSpot(TM) 64-Bit Server VM (build 23.0-b21, mixed mode)\nClojure version:\nuser=> (clojure-version)\n\"1.4.0\"\nCopy/pasted lines in lein repl:\nuser=> (use 'lamina.core 'lamina.viz)\n(def ch (channel))\n(map* inc ch)\n(map* dec ch)\n(enqueue ch 1 2 3)\n(view-graph ch)nil\nuser=> #'gcom.core/ch\nuser=> <== [?]\nuser=> <== [?]\nuser=> :lamina/enqueued\nNo joy: window does not appear as expected on my side.\n. 1.) No: if render-graph is run once, view-graph can successfully be called any number of times.\n2.) The process never hangs; sorry I didn't make that clear in my example.\n. Yes, that's what happens; sorry I didn't make that clear.\n. ",
    "jheander": "Experimented some more with the code and this version of bound-task seems to work fine since the :name parameter get precedence.\nclojure\n(defmacro bound-task\n  \"Executes the body on a separate thread, returning an unrealized result representing the eventual\n   value or error.  Unlike 'task', thread-local bindings are preserved when evaluating the body.\"\n  [& body]\n  (let [explicit-name? (string? (first body))\n        name (if explicit-name? (first body) \"bound-task\")\n        body (if explicit-name? (rest body) body)]\n    `((lamina.trace/instrumented-fn\n        nil\n        {:with-bindings? true\n         :executor le/default-executor\n         :name ~name}\n        []\n        ~@body))))\n. Solution for issue #48 \n. Hi!\nLatest version still seems to be crashing when calling bound-task. Do you have any objections against the solution in this pull request?\n. ",
    "nybbles": "The problem I'm trying to solve is that if a result channel ends up being an error result and goes through a sequence of pipelines, every single pipeline logs the same exception, which is repetitive. Having to add empty error handlers to all the pipelines except the last one is repetitive in terms of code. I just wanted some way of not having either kind of repetition. If there's a better solution to that than this diff, that would be fine by me too.\nMy reasoning behind removing the logging is so that one could add the logging of the error (manually) at the last pipeline in the sequence of pipelines, or wherever they are actually interested in dealing with it and be able to avoid having a single exception logged multiple times.\n. ",
    "philipa": "Whoops - test failed.\n. ",
    "amalloy": "Probably some nonsense to do with the claim that clojure.set is for relational algebra, and maps are related to that? The contents of clojure.set are totally baffling for some reason, anyway.\n. I fixed this in e821aa4916. I'll check with @ztellman about getting this issue closed.\n. FWIW I think it makes more sense for read-channel to still consume the item. Your scenario is like \"Read the next item. If it finishes within the next 0 ms, let me know.\" The read is still pending.\n. Fixed in #70.\n. Fixed in 9007e506\n. ",
    "baltar": "I'm happy to contribute sth. to this great library :)\nOn 05.02.2013, at 23:39, Zach Tellman notifications@github.com wrote:\n\nGood catch, thank you.\n\u2014\nReply to this email directly or view it on GitHub.\n. I think you're right about this, I was confused as to how result channels are supposed to work (some doc would be great :) ). What I really want is wait-for-message. \n. \n",
    "jarohen": "Hi again,\nAfter a deeper look through the core docs, I've stumbled across lamina.core/drained-result, which is enough to solve my particular use case (solution below, if anyone's interested!). I'll leave this issue open for now though, just in case anyone else thinks it might be necessary/useful, otherwise please feel free to close.\nJames\n```\n(require '[lamina.core :as l])\n(let [ch (l/channel)\n      res (l/drained-result ch)]\n(l/on-realized res\n                 (fn [] (println \"Successfully drained\"))\n                 (fn [e] (println \"Error'd\" e)))\n  #(l/close ch) ; would print \"successfully drained\"  \n  (l/error ch \"an error\")) ; prints \"Error'd an error\"\n```\n. That's great, thanks!\n. ",
    "jennifersmith": "I am also experiencing the same issue. I am using the installer version of dotviz.\nI switched between 2.30 and 2.31 and get the same issue.\nThese are the two builds I tested with:\ndot - graphviz version 2.30.1 (20130221.2233)\ndot - graphviz version 2.31.20130117.0545 (20130117.0545)\n(on OSX 10.8)\nActually, if I call render-dot-string directly it works:\n``` clojure\n(render-dot-string \"digraph{}\") \n<BufferedImage BufferedImage@65dea9ea: type = 5 ColorModel: #pixelBits = 24 numComponents = 3 color space\n= java.awt.color.ICC_ColorSpace@6ee68413 transparency = 1 has alpha = false isAlphaPre = false ByteInterleavedRaster: width = 11 height = 11 #numDataElements 3 dataOff[0] = 2>\n```\nBut if I don't pass in a valid dot string, that fn returns nil.\nThanks\nJen\n. ",
    "markjfisher": "firstly, thanks for reformatting my question!\nI've uninstalled brew version of graphviz and gone for the 2.30.1 stable release from the wiki link (http://www.graphviz.org/Download_macos.php) but get the same error.\nupdate # 1:\nAs with comment from @jennifersmith I get the same behaviour, running render-dot-string directly is fine\nupdate # 2:\na little more investigation and I can manually create a graph fine, e.g.\nclj\n(def fr (gen-frame \"my-frame\"))\n(lamina.viz.core/view-image fr (render-dot-string \"digraph G {Hello->World}\"))\nbut as @jennifersmith said, if the render-dot-string is empty/not valid, I get the NPE again.\nupdate # 3:\nI tried downgrading to 2.28 (the version that linux is running) but Mountain Lion wouldn't play nicely, and it seems I can only install 2.30+\nWhat is the digraph that the enqueue 1 2 3 is generating and I'll test that directly to see if it's a graphviz version problem?\nupdate # 4:\ni upgraded my linux from 2.28 to 2.30.1 and get exactly the same NPE now. seems they changed something that's breaking lamina rendering.\n. With beta15 I get:\ndigraph {\ndpi=100, pad=0.25, rankdir=LR\nnode[shape=box, fontname=helvetica]\nedge[fontname=helvetica]\nnode9243[shape=Mrecord, fontname=helvetica, label=\"{3 | 2 | 1}\"]\nnode9244[width=0.25, label=\"\"]\nnode9244 -> node9243[arrowhead=dot]\n}\nI couldn't find a beta16 release, so I've cloned the repository and built a local jar from current head. (I notice there's no beta16 tag in there, have you only got that locally?)\nWith my local head version, it still errors, and i get the following:\nuser=> (view-graph ch)\ndigraph {\ndpi=100, pad=0.25, rankdir=LR\nnode[shape=box, fontname=helvetica]\nedge[fontname=helvetica]\nnode9433[shape=Mrecord, fontname=helvetica, label=\"{3 | 2 | 1}\"]\nnode9434[width=0.25, label=\"\"]\nnode9434 -> node9433[arrowhead=dot]\n}\n. ok, i played around with the output, and found in order to get it to work, i had to put \"graph [ ]\" around the options line, i.e.\ndigraph {\ngraph [ dpi=100, pad=0.25, rankdir=LR ]\nnode[shape=box, fontname=helvetica]\nedge[fontname=helvetica]\nnode9433[shape=Mrecord, fontname=helvetica, label=\"{3 | 2 | 1}\"]\nnode9434[width=0.25, label=\"\"]\nnode9434 -> node9433[arrowhead=dot]\n}\nWithout the graph syntax, dot returns an error:\nbash\n$ dot -Tpng dg.dot -o dg.png\nWarning: dg.dot:2: syntax error in line 2 near ','\n. ... err I clicked the close button by accident!\nHere's a very simplistic patch that makes it work in my local version:\npatch\ndiff --git a/src/lamina/viz/core.clj b/src/lamina/viz/core.clj\nindex 17f22e9..eaa4fc9 100644\n--- a/src/lamina/viz/core.clj\n+++ b/src/lamina/viz/core.clj\n@@ -137,7 +137,7 @@\n                 \"}\\n\"))]\n       (str \"digraph {\\n\"\n         (when-not (empty? options)\n-          (str (format-options \"\\n\" options) \"\\n\"))\n+          (str \"graph [\" (format-options \"\\n\" options) \"]\\n\"))\n         (when default-node\n           (str (format-node \"node\" default-node) \"\\n\"))\n         (when default-edge\n. ",
    "drewnoakes": "Thanks for the explanation.  The 'different callback' I mentioned was an anonymous lambda function as you describe. So sense and order are restored in my mind. If there's some way to make this clearer to others, that would be nice.\nThanks for the libraries by the way :)\n. Here's a small snippet that reproduces the error:\n```\n(defn chat [ch request]\n  (throw (RuntimeException. \"oh dear\")))\n(defroutes app-routes\n           (GET [\"/\"] {} (wrap-aleph-handler chat))\n           (route/not-found \"Page not found\"))\n(defn -main [& args]\n  (start-http-server (wrap-ring-handler app-routes)\n                     {:host \"localhost\" :port 8080 :websocket true}))\n```\n. ",
    "coltnz": "Yeah I thought that too but no...\n```\n\u279c  datastore-search git:(feature/alia-async) \u2717 lein repl\nRetrieving cc/qbits/alia/2.0.0-beta7/alia-2.0.0-beta7.pom from clojars\nRetrieving cc/qbits/alia/2.0.0-beta7/alia-2.0.0-beta7.jar from clojars\n.....\nuser=> (require '[qbits.alia :as alia] :reload)\nnil\nuser=> (require '[qbits.alia :as alia] :reload-all)\nCompilerException java.lang.ClassCastException: lamina.core.channel.Channel cannot be cast to lamina.core.channel.IChannel, compiling:(core.clj:181:20)\n```\n. Ok after a bunch of red herrings, I can confirm we did in fact have an AOT internal library and once AOT-ed problem went away. Seems to be potemkin and clojure AOT bugs related (this one? http://dev.clojure.org/jira/browse/CLJ-1330). \n. Yep. Got my dependency list down to:\n:dependencies [[org.clojure/clojure \"1.6.0-alpha3\"]\n                 [com.smxemail/smx-netty-clout \"1.0.10\"]\n                 [lamina \"0.5.2\"]])\nRemoved the AOT-ing of the main namespace in our SMX library and it's all good. So given that AOT and Clojure is busted, happy to close this ticket as resolved.\n. ",
    "aphyr": "zach this is important and you need to merge it\n. ",
    "dpom": "Actually the problem is that every 10 seconds there is a new message \"dpom-stream connected\" in log. Since the message is in the  on-connected callback does this  means that every 10 seconds the connection is restarted?\n. ",
    "neapel": "Related: they should also implement IBlockingDeref, currently @(success-result :x) works, but (deref (success-result :x) 10 :y) doesn't. And wait-for-result doesn't support default values.\n. Here's a patch: a4dddac942615ce05b53b97fd384a839e23397b2\n. ",
    "chiaolun": "I guess whether tap takes the emitter or the receiver might be a matter of convention. I came across this because I had expected close-on-idle when used on aleph websockets to  be a read-timeout, where currently it is a write-timeout.\n. I've worked around it by defining a tap that uses the emitter instead of the receiver\n``` clojure\n(ns project.utils.lamina\n  (:require\n   [lamina \n    [core :refer :all]]\n   [lamina.core\n    [channel :refer [split-receiver emitter-node receiver-node]]\n    [graph :as g]\n    [queue :as q]])\n  (:import\n   [lamina.core.channel Channel]))\n(defn tap-emitter [ch]\n  (let [description \"tap\"\n        sneaky? true\n        n (g/node identity)\n        populate #(when-let [q (-> ch emitter-node (g/queue false))]\n                    (q/append (g/queue n true) (q/messages q)))]\n    (if (split-receiver ch)\n      (g/join\n       (emitter-node ch)\n       (g/edge description n sneaky?)\n       #(when % (populate))\n       nil)\n      (do\n        (populate)\n        (when (closed? ch)\n          (g/close n false))\n        (let [error (g/error-value (receiver-node ch) ::none)]\n          (when-not (= ::none error)\n            (error n error false)))))\n    (Channel. n n nil)))\n```\n. Okay that was stupid. I'm using this now:\nclojure\n(defn tap-emitter [ch]\n  (if (instance? SplicedChannel ch)\n    (tap-emitter (.emitter ^SplicedChannel ch))\n    (tap ch)))\n. "
}