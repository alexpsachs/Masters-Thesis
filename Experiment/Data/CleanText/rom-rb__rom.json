{
    "solnic": "@senny thanks!\n. I'll sort it out when preparing for the release (tomorrow/Friday)\n. @greyblake I'm closing this one since ROM has been released and examples work\n. Haha prosz\u0119 bardzo ;)\n. Hey sorry for a late reply - ROM doesn't support relationship DSL but it does support joining relations. I will come up with some examples that will (hopefully) work so you should be able to judge yourself if it's good enough for you.\n. Oh wow that's great feedback thank you for this. I will take a closer look and get back to you asap.\n. Yeah that's my bad. I will fix the examples. Thanks for pointing this out.\nOn Thu, Aug 29, 2013 at 4:24 PM, Luke Imhoff notifications@github.com\nwrote:\n\n@solnic I wanted to make sure you noticed, but I had to make two non-obvious changes from the examples on rom-rb.org:\n1) I had to call session[:archtectures].track(seed) before I could call session[:architectures].save(seed).\n2) I had to use session.flush instead of session.commit.\nReply to this email directly or view it on GitHub:\nhttps://github.com/rom-rb/rom/issues/3#issuecomment-23493091\n. @limhoff-r7 I updated the example.\n\nYou can use a short-cut syntax to create new object and track it automatically via session[:architectures].new(seed).\nHow many objects do you have in that seed btw?\n. @limhoff-r7 can you see if it gets a bit faster when doing environment[:architectures].restrict(seed).count instead of using session?\nThe difference is that session sets up IdentityMap and state tracking and \"plain\" environment does not. You might get a perf boost. We also don't have an optimised #count yet so at the moment it loads all the objects matching criteria.\nIs this code publicly available? I could try it out locally and see how I could improve stuff :)\n. @limhoff-r7 oh and btw how many objects do you have there?\n. @limhoff-r7 ugh 16 objects? that's very weird. I need to try to reproduce this, something is wrong. I was expecting you'd say 16k objects or something heh\n. @limhoff-r7 thank you! I'll investigate during the weekend\n. @snusnu do you think it makes sense to show how you can set up joined relations? it would be pretty verbose and people might be confused by it (maybe?). wdyt?\n. @snusnu I wholeheartedly agree there\u2019s only one caveat right now - mappers don\u2019t support loading data from a joined relation\n. @snusnu you'd have to build your own mapper, there's no EV/EC concept in rom-mapper yet but we could probably easily add it\n. Who\u2019s talking about group/group? :) I\u2019m talking about mapping a bunch of attributes into an embedded object.\n. There will be a virtus plugin for ROM soon\n. I can fix things to make it work with postgres and sqlite but it will be only for reading stuff.\n. @trbrink we should introduce []= in other adapters instead of that check. That other change you made is required though, this is in axiom-do-adapter.\nPRs would be sweet :)\n. I'm gonna work on fixing it this week and push a release which will also require latest axiom and friends.\n. This is fixed via this commit. Just please note that it's just a very early read-only support for now. I can push new rom-* gems when latest axiom-* stuff is released too.\n. This is fixed now (not released yet though)\n. Not yet, I started working on it but hit some blockers. We need to update axiom so that it works with latest adamantium before fixing this one.\n. @emilesilvis this is fixed, I'll be pushing new rom soonish\n. Yeah, theoretically this separation is logical and correct but in practice it's been a pain to deal with those 3 repos from my point of view. Hence I'm starting the discussion.\nThanks for feedback!\n. @mbj yeah I like that you used the word \"stable\". it's a key word in this context - ROM is extremely unstable (in terms of API) so keeping things separate so prematurely is a big no-no for me and that's an opinion based on practical experience while working on those projects.\n. @mbj those are great examples of nice libs that were extracted from a living organism (axiom etc)\nHere the story is completely different. We don't know what's ROM. We will define it when we make it work according to our initial expectations (using axiom as the backend, mapping tuples into objects, session with UoW). When that happens it will become clear what we can extract.\nThere are cases that are very obvious (rarely) where you just know something should be a separate library - SQL is a good example. We need something that generates SQL and holds an AST representation of SQL. Simple, we need a library that will do just that. Re-usability of such library is also obvious.\n. @avdi that too :)\n. My intention is not to couple everything together, I just want to deal with one Gemfile and one gemspec and one gem push command. I want to keep things logically split in the repo. It's just way easier to work on stuff when you have it in one place. All those things integrate with each other that's why it's gonna simplify the development.\nI like the idea of explicit requires in specs. We can try doing that.\n. @lgierth we centralized issues in this repo some time ago already so it's not...an issue ;)\n. It's done. Closing. Thanks for the input everyone :heart: \n. Oh this is nothing new. I imported it from rom-mapper. Once it's ported to morpher it'll be ready for a review.\nOn Fri, Feb 7, 2014 at 6:13 AM, Dan Kubb notifications@github.com wrote:\n\n@solnic do you want me or anyone else to do a pass over this code?\nReply to this email directly or view it on GitHub:\nhttps://github.com/rom-rb/rom/pull/13#issuecomment-34404856\n. I'm starting with a clean slate in a new branch. This was too confusing for me.\n. I pushed the new branch here but I'm not opening a PR until its ready functionality-wise.\n\nThe initial ducktrap-based stuff broke too much and was too hard for me to wrap my head around the changes and port that to morpher so I started fresh.\nEventually this integration will clean up mapper DSL implementation too. I know there are some new ideas wrt how mapping should work (IIRC having 2 steps of mapping, first one on the schema level where we deal with attribute names and coercions and then on the object level where we build the objects using already prepared tuples) but this can be done later. I think having initial integration with morpher that uses existing code without making too many changes at once is beneficial (at least for me). So, here we go.\n. Thanks!\n. you'll be able to use virtus objects with rom, don't worry. I'm working on integrating morpher with rom which eventually became our mapping backend. Once that's done you'll be able to use virtus objects on top, however, morpher will take care of the mapping so virtus' attribute mapping will be redundant.\n. Currently the dsl to define wrapped or groupped relations is half-done. I can try to do it for 0.2.0 release though.\nOnce ready this is more or less how you'll be able to do that:\n``` ruby\nschema do\n  base_relation(:applications) do\n    repository :something\nattribute :uuid, String\nattribute :title, String\nattribute :slot_id, Integer # this is just my assumption\n\nend\nbase_relation(:slots) do\n      repository :something\n      attribute :id, Integer\n      attribute :name, String\n  # this means whenever fetching slots also join and group applications\n  group(:applications => applications)\n\nend\nend\nmapping do\n  relation(:applications) do\n    model Application\n    map :id, from: :uuid       # other key in json\n    map :name, from: :title  # other key in json\n  end\nrelation(:slots) do\n    model Slot\n    map :id, :name, :applications\n  end\nend\n```\nSettings this up like that sets up an aggregate though, if you want to have those models separate and group things on demand you can do that too via join/group operations.\n. ps. sorry I accidentally closed this issues and sent a half-written comment which I just edited and added the missing part :)\n. btw are you using ROM for something real or just playing with it?\n. @saratovsource I suppose this spec shows exactly how you could achieve what you need (it's the same as your case). This isn't using the schema/mapping DSL I showed you above though but that shouldn't matter much.\n. @saratovsource btw I'd really appreciate if you could try to use rom from master in your app and let me know if it works for you\n. @saratovsource thanks, I'm adding your example to rom-demo project just to see if it works :)\n. @saratovsource I'm not sure how closely it matches your case but here's an example using sqlite and slot/applications models loaded via join & group\n. @saratovsource sure, I just added \"wrap\" example here :)\n. Do you have your adapter on github?\n. btw wrap/group is designed for wrapping/grouping 2 relations. if your adapter returns a nested data structure like in this example than you might want to build a special mapper for it. I can show you how if that's the case.\n. @dnesteryuk gah sorry for getting back to you so late...here's a gist showing how to use standalone mappers\n. closing bkz it's too early. mighty morphin' power rangers won't help ;)\nI'll open a new PR in a week or so\n. Implementation details are less important now than proving that certain concepts make sense. It's awesome that @snusnu is verifying those concepts in a real-world application. This only makes me more confident.\nIn ROM we'll have the same concepts as this pastie shows so that's OK - mapping attributes and type definitions in the schema DSL + defining model mappings in the mapper DSL. This is a great idea especially that some adapters will need to enforce coercions when morphing tuples before they are passed to mappers.\nLooks like everything is settling down nicely :smile: \n. @snusnu merging in what exactly?\n. OK so first step of morpher integration is done. In a separate PR we're gonna add wrap/group support and a new schema/mapping DSL :smile: \n. I'm merging this in as lack of proper dump support in group/wrap is only needed for writing which is still in highly experimental/partially done phase so I don't want it to block further development. I left TODOs in the code about it.\n. This is fixed on edge, I'll be releasing a new version very soon.\u2014\nSent from Mailbox for iPad\nOn Sun, Mar 30, 2014 at 6:08 PM, DAZ notifications@github.com wrote:\n\nWhen I require the code from the example on the ReadMe page in IRB, I get the following error:\nNameError: undefined local variable or method `include_comparison_methods' for #Axiom::Equalizer:0x927235c\nDo I need to change anything?\nReply to this email directly or view it on GitHub:\nhttps://github.com/rom-rb/rom/issues/19\n. You need to grab rom from github, the rest can be grabbed from rubygems. I'm hoping to release it during next week. I've got to wrap up this PR and it's ready :smile: \n. @dkubb one bottleneck I found is Hash[]= which happens in Axiom::Relation#each which creates a temporary hash to lookup for tuples that were already yielded\n. @dkubb yeah...as an experiment I moved generating a unique set of tuples (already coerced) inside the constructor and using just that in #each and my benchmark suddenly became much master\n. So in the db you have :accountid but on the domain object level you want to use :id?\n. We changed things conceptually a little bit so now you define your schema and you can do renaming there, so something like that should work for you:\n\nruby\nschema do\n  base_relation(:users) do\n    # ...\n    attribute :accountid, Integer, rename: :id\n    # ...\n  end\nend\nThe reason for this change is quite simple - we want schema to define attribute mappings in the ruby land, doesn't matter if you're using axiom tuples or loaded domain objects, you should have a way to map attributes there already (the same will be done for coercions soon). Then, on the mapping layer, you are still able to map those attributes to something else using map :domain_attr_name, from: :schema_field_name syntax in the mapping DSL. That's just more flexibility.\nI hope this works for you :) \n. Wooohaaa :)\nOn Mon, Apr 7, 2014 at 3:32 PM, Dmitriy Nesteryuk\nnotifications@github.com wrote:\n\nClosed #21.\nReply to this email directly or view it on GitHub:\nhttps://github.com/rom-rb/rom/issues/21\n. We should raise though, I'll fix it in axiom-do-adapter\n. @jwright yes I'm planning an adapter matrix showing what's supported, sorry for the confusion\n. oh and thanks! :smile: \n. We're switching to Sequel as RDBMS backend so this will be supported really soon. It'll also be easy to contribute soon once I get the foundation ready.\n. Oh wow those are great questions. Let me try to give you some answers:\nAre we enforcing a style guide? I've seen and implemented a few projects that enforce style by having > Rubocop be part of the build.\n\nI'm planning to plug rubocop in at some point if I see the need. For now I'm fine with reviewing things manually and asking for some adjustments if something is really off\n\nAre there any licensing considerations to draw attention to?\n\nNot really. ROM is under MIT\n\nDo we recommend a single commit per pull request?\n\nNo, in fact I am against that. Reading commits is usually a good story and can tell you a lot.\n\nWhat are the responsibilities of those merging code?\n\nThe biggest responsibility is to make sure that a change makes sense. Sometimes people would like to implement a feature and they look at it only from their perspective without seeing the bigger picture. My biggest concern is to keep rom libraries small and focused. Thus a person who's responsible for merging needs to understand the scope of a given project and what kind of functionality should be there.\nApart from that - checking code style and applying post-merge style improvements should also be responsibility of a person who's merging a PR. I think for most of contributors it is often a major task to just make something work or fix a bug especially when they are new to the codebase. Overwhelming them with code style nit-picking in a PR is potentially harmful and may discourage them to contribute in the future. It's much harder to come up with a solution to a certain problem than it is to beautify the code later on once the hard part is done. That's why I'm perfectly fine with \"polishing\" things later once a PR is merged in.\nI can see this approach to become a problem when a project is really huge and receives hundreds of PRs on a regular basis but that's something we can improve using tools like rubocop. I definitely don't want to start with this though.\n\nWhat is the tone you are after? Exhaustive information? Light and brief?\n\nLight and straight to the point :)\n. Ah I'm glad you mentioned that @elskwid - even if somebody has commit access opening a PR is the recommended way.\n. Thanks @chastell I have a very limited experience with rubocop but I definitely see the value. We can plug it in sooner or later :)\n. OK so thanks to @chastell we have rubocop setup now. I guess code guidelines are not needed then. We should just mention that rubocop runs by default via guard and default rake task. Turned out it already has the auto_correct feature which makes it a no-brainer to use.\n. The project is being rebuilt from scratch so this no longer applies. Thanks anyway! :)\n. Thanks for the PR. Could you also add a spec for this behavior to spec/unit/rom/schema/builder/call_spec.rb?\n. I'm rebuilding rom from scratch. I'll make sure setting up repositories is better.\n. Thanks!\n. Thanks, again :)\n. There's no need to write something that's similar to Sequel. You just use redis-rb directly (take a look at axiom-redis-adapter for some inspiration.\nThe adapter could provide a convenient query DSL if you want or you could built the adapter on top of Ohm. You are free to do whatever you want. ROM's relations have access to whatever interface the adapter exposes. The only interface that's required is #each and yielding hash-like objects on the dataset object that's passed into ROM::Relation + it must support chaining like Sequel::Dataset which means that every operation must return an instance of the same kind, that's why for mongo adapter I had to create a custom dataset class.\nMy plan was to simply port axiom-redis-adapter to rom-redis-adapter for a good start and take it from there.\n. Yes, using Ohm would be like using ActiveRecord behind a ROM adapter which would be awkward. Maybe there's a piece in Ohm that you could use, I'm not sure, something that could be extracted from Ohm. Maybe we should talk to @soveran :)\n. This sounds like a good plan\n. @soveran thanks! This is a lot of useful information.\nROM will work with anything that provides an array of hash-like objects. That's the only true requirement. Everything else is just extra db-specific functionality. Maybe just using Ohm under the hood is a good idea as long as we can use it's lower level features and skip the actual hash->object mapping as that part is handled by ROM. This is pretty much how Sequel is used in ROM - its adapter exposes Sequel::Dataset interface and you do whatever you want with it.\nOne thing I need to make very clear is that ROM does not provide any abstract query interface, that's why writing adapters is very very simple. ROM relations give you access to the interface provided by the underlaying db library. I would expect this library to be redis-rb in case of redis adapter, but maybe it's too low level, I really don't know yet. An adapter can provide a decorator object that adds more convenient ways of working with a given database though but it will always be adapter-specific and there will never be any common abstract interface that every adapter must implement.\n. @bryanp hey! that's awesome news. I'm a total redis n00b so I can only help you with ROM-specific stuff.\nThe best starting point is to make it possible to configure a connection with default options and come up with a basic dataset class. If it can be an array-like object you can use a helper module like described in #86. If you can come up with some interface that connects to redis and returns dataset objects then you've got a working adapter done. The rest is just expanding the interface with features (like some query DSL, command objects etc.).\nPlease also remember that we are very open to improve adapter interface because the goal is to be able to really easily build any adapter. If you see something fishy please tell about it. If something feels too hard, tell about it too. We already managed to build basic functionality for sql, mongo and file-based (as we call them) adapters like csv and yaml. Redis is super important as it's a key-value store which is a different type of a database.\nI'm hanging out on gitter on a daily basis so ping me if you need some help or just report issues if something is not working for you.\n. Sounds like a good plan :)\n. @billywatson @bryanp would it be helpful if I started the project with some basic structure so that we have a redis connection setup in place?\n. OK I'll try to kick it off tomorrow :)\n. @billdueber @bryanp I just pushed rom-rb/rom-redis to github with some super basic stuff working. I've no idea what the strategy should be so I just did the simplest thing that could possibly work for a good start :)\noh and sorry it took so long...\n@soveran I would appreciate if you could take a look too :)\n. CUD is handled by commands and the interface is very simple, every adapter can provide Commands namespace with Create, Update and Delete classes that inherit from ROM::Commands::* base classes. You can take a look at memory adapter, this is really simple stuff. The only interface that's required is #execute which receives various args depending on the type of command.\n. It is getting more stable. Adding more adapters contributes to this process that's why it would be fantastic to get it working for redis too :)\n\nOn 23 Feb 2015, at 21:47, Billy Watson notifications@github.com wrote:\nI guess I misspoke. \"Well-defined\" clearly isn't right, but some of the docs said that CUD is \"in-flux\" or something of the sort. Is that not correct?\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes because this is still help-wanted :)\n. @artemeff hey :) we should support any format of course, I just started with JSON for a simple PoC version. I'm not a redis user so I don't know how this adapter should work, unfortunately :/\n. @snusnu any ideas where to put in-memory relations that can span multiple, different databases? I'd like to move them to a separate registry that's now simply called rom.relations and those are the \"public\" ones that should be used on the app level.\n\nEDIT: finished the comment after a pre-mature cmd-enter :)\n. @snusnu I'm thinking about having schema that only has base relations and then a separate registry for all the relations that an app would use. This is just a clean separation between defining what you have in your database(s) vs what you want to expose to your app.\nIf you want to combine data from multiple databases you just use a different interface where you have the RA ops available, see this spec. I'll tweak it to make it look similar to how you define public relations though.\n. This is done. Closing\n. @abernardes yes please it's all yours :)\n. @snusnu thanks. I'm currently thinking about adding a reader object that would receive a relation and have the ability to chain method calls. ie rom.users.active.from_country(\"PL\"). I still prefer scope-like behavior with chaining vs longish method names ;) Oh and mapping could be optional for example rom.users(mapping: false) or something like that.\n. This is done. Closing.\n. @abernardes that's awesome Andre. Give it a shot then :) I wanted to assign it to you but it seems like github doesn't allow that if you're not part of the organization. Anyhow, let me know if you need some info. Please open a PR as soon as you have something working so that we could discuss implementation details.\n. Awesome :)\n. Yeah exactly, that would be a good start. Registered relations in the schema have headers with information about the columns so that's all you need to generate a model class. There are some libraries we can use too so that you could choose what kind of a model you want to have, for example we could have an anima or virtus model builder or just a PORO with attr accessors.\n. @Olefine cool! thanks, just send a PR when you have something working and we can talk about details there :)\n. Initial version of this version is done. I will revisit it later once we can integrate with Morpher and I have a clear idea what to do with Virtus 2.0.\n. Thank you so much! <3\n. Sequel doesn't use DataObjects but it would be easy to add a super thin adapter that would directly talk to DO, if somebody needs it. I guess you could use sequel to generate sql and run queries via DO, not sure why you might want to do that though :)\n. turns out sequel actually has a dataobjects adapter so ROM supports it OOTB. To use it you just need to prefix scheme with \"do\", for instance ROM.setup(default: 'do:sqlite:://pathtodb')\n. That will be an interesting one. For now I'm just using...rails migrations. There's also sequel migrations plugin. For other adapters it's an unknown for me. We'll see what kind of adapters we have and which ones require a migration mechanism in the future.\n. Yes we can close this one\n. This is done via Adapter#extend_relation_class and Adapter#extend_relation_instance\n. @elskwid now we gotta do something with this one ha-ha ;)\n. Any idea what should be presented in Synopsis section? Right now it's rom-sql example which I don't like. Something in-memory should be enough. Question is: what should it be? /cc @aflatter @elskwid @kwando @splattael \n. I'm not familiar with entity framework from MS\n. I don't think README is a good place for such a huge piece of information, esp that you can use ROM in all sorts of ways.\n. Closing as the README is now nice-enough ;)\n. closing, changed my mind - relation#insert will return itself and there will be some higher-level thing for inserting tuples and getting them back for convenience\n. hey @Olefine thanks for this PR. I'll merge it in later this week. Just let me know if you can do that map_to_model => model rename. If you don't have time I'll just do it myself after merging :)\n. Thanks it's merged :) Re #52 I'm totally open for collaboration but I wanted to build the foundation myself first and then see what's missing\n. @Olefine of course! You could take a look at #37 (this is a really low-hanging fruit) or maybe #39 which should be fun to work on and would make it much simpler to get up and running with ROM :)\n. @snusnu psssst wdyt? :)\n. Yes I want explicit mapper definitions too. Even with chaining it is your job to provide mappers that will know how to load a specific relation.\nI'm still trying to come up with an interface for reading relations with mappers. I remember we talked about a \"reader\" objects or an explicit \"query\" interface where you basically make it clear that you want to read a specific relation using a specific mapper. Do you have any thoughts on that?\n. @snusnu yeah exactly reader sounds like a great place for that. I also have another reason to do this separation (read/command) and it's because I'm not planning to add support for commands on top of in-memory relations (stuff produced by ROM::RA ops). That's why I need a separate command interface which would only expose base relations.\n. @snusnu I'll resurrect rom-mapper at some point. I agree that it's a totally separate piece but for now it'll be part of rom as things are moving faster this way. I'm not sure if I want to make morpher the mapping backend, it can be an overkill in many cases.\n. @snusnu here's what I ended up with:\n``` ruby\nrom.relations do\n  users do\n    def with_tasks\n      RA.group(natural_join(tasks), tasks: [:title, :priority])\n    end\ndef sorted\n  order(:name)\nend\n\nend\nend\nrom.mappers do\n  users do\n    model name: 'User'\nwith_tasks do\n  model name: 'UserWithTasks', map: [:name, :email, :tasks]\n\n  group tasks: [:title, :priority]\nend\n\nend\nend\n```\nNotice that by default ROM would build anonymous entity classes but you can provide :name and a constant will be defined for you.\n. The only thing which completely sucks right now is how headers are being handled. I'm going to make it possible to simply ask a relation for its header. For now only base relations return correct headers but if you apply a RA operation on top of base relations then the header no longer reflects the actual state. It's a simple thing to improve though so I'm not overly worried ;)\n. The foundation for this is done and it's good enough so I'm closing this one. I'll add more detailed issues about specific features and enhancements.\n. @abernardes I got rid of type info on the schema for now. This basically means for now we just need to get a list of tables and plug them in :)\nThe code that infers types will be handy though, so it might be worth to keep it.\n. Re SERIAL yeah I noticed that too and wanted to change it so thanks for doing that for me :)\n. @abernardes this is lovely thank you! :heart: \n. That's great to know. Thank you :)\n\nOn 01 Nov 2014, at 14:40, Andre Bernardes notifications@github.com wrote:\nJust so you know, I had to do something very similar to what you described here in order to make my implementation of #37 testable. I guess you can consider the first two items \"in progress\" \n\u2014\nReply to this email directly or view it on GitHub.\n. That's how it used to work in previous version of ROM. IIRC we simply had a base adapter file (here it'd be something like rom-sequel-adapter.rb) that registers a new adapter class so that we could find it and by convention require rom/adapter/#{name} where #{name} can be figured out from the adapter class name. The only difference is that we no longer use DescendantTracker that could be used to automatically go through all ROM::Adapter descendants but I prefer not to use it and go with explicit registration this time.\n. I actually realized this auto-requiring is not really needed. We had it before but now I'm not sure why. We could simply not require anything and it is responsibility of a library user to require the adapters that are supposed to be used and that's it. Makes sense?\n. @abernardes I expressed my thoughts by merging it in :) closing this one too!\n. @abernardes yes that extra spec for postgres is not really that important, we just need a test that makes sure adapter inference works correctly. You can just remove this test and remove pg gem from Gemfile. BTW jruby require jruby-pg gem as pg has C extensions which are not supported by jruby. Just FYI :)\n. ^5 thanks! merging! :smile: \n. Thanks Adam. I'm working on a couple of refactorings which will reveal lower-level objects and their interfaces. More specifically #52 and #53. There will be a nice Header interface that will give all the information about attributes, their mappings, coercions and so on. This will be used by mapper and builders. I will also clean up this mess in current mapper builder and probably some smaller objects will come out of that.\n. The trick is to not think about queries and focus on relations. And relations are just...array of hashes, it's the data your application needs. What you do with those arrays is up to you - you can just live happily with hashes or map them to something more domain-specific if you will.\n\nActiveRecord is completely different even though you may see some similarities. With AR you think in terms of models giving you access to all your data through a leaky query interface. In AR you say \"I'm gonna find all the users, order them by name and paginate the collection\" and then use this to render, let's say, a user index web page. In ROM you say \"I use user index view relation to render index page\". It's a fundamental philosophical difference. Notice that it can be enforced via the interface by making certain things private (I will probably make it configurable as I don't like software that's too opinionated or even conservative).\nThere's actually much more to it but it's probably a good intro to the basic idea :) I'm going to describe those concepts in detail in a README or some documentation for 0.3.0 release (due this month).\n. Thanks Adam, this is fantastic feedback for me. I'm experimenting with the DSL that's why it's changing so often but I will definitely stick to define(:rel_name) for now. I think it's descriptive and it simplified the implementation too. I may do the same for relations DSL and go with register(:users) {} vs users {}.\nRegarding generated models - it's a very good point you made that it's not clear from the DSL that the class will be generated. I'll think about how to make this better. The only reason why I decided to introduce model class generators is because I'm using value objects in many places and I really don't want to write them manually all the time. Notice that ROM does support providing your own model classes via model(ClassConstant) syntax. In my current project I'm using Virtus models and just pass them in there (Virtus provides more advanced features like embedded objects which I need already, it'll be supported by ROM itself soon too).\nMapping to multiple classes - this is high on the priority list. This will be supported and is briefly described in #59. I'll introduce it in 0.4.0. As I mentioned already, you can workaround lack of this feature by simply using Virtus (or any attribute mapper that supports embedded objects).\n. this is done via transproc integration\n. Just realized this doesn't require any special behavior as you can simply do attribute :name, from: 'name' in the mapping definition. Closing.\n. done via 491a6c5af12f2291c55f1e7f6140efd9c5a84bbf where I referenced wrong issue by a mistake :(\n. This is now done as \"command api\"\n. This makes sense. Could you also add a test somewhere here that would exercise this behavior?\n. Thanks!\n. OK I'm going to close this one since now it's a WIP and we have the repo (:\n. We moved maetl's repo to the rom-rb org: https://github.com/rom-rb/rom-neo4j\n. Thanks for the feedback!\nYeah I think you're right and we need a step-by-step explanation of how things work and fit together.\nRegarding migrations - I can just replace sequel example with the memory adapter to simplify it. When it comes to SQL you can just use sequel-migrations or even AR migrations. I'm not planning to tackle this myself anytime soon to be honest. The downside is that without models (either Sequel or AR) you can't use fk-references in fixtures and short-syntax for defining fks in migration files. For me it's not a big deal though. Sooner or later we'll have some kind of a relationship API just to get the metadata about FK constraints to make things like building joins simpler and it will also be handy for migrations. For now it's gonna be a bit barebones.\n. @kwando hah :) adding it to rom-rails now, expect new releases soon\n. Thanks Ken :)\n. @kchien I almost forgot - I just invited you to core-contributors group. rom has a commit policy similar to rubinius, everybody who contributed gets commit access, even if it's a typo fix, everything matters and everything is important.\nThanks!\n. If you're using an SQL database the schema is inferred for you but I suspect it's not the case here :)\nSo, the answer is no, it's not supported but I can and will make it possible!\n. Oh it's fine for me to do it now especially that the code handling setup is still a bit messy and now I have even more motivation to clean it up and add support for multi-step schema definition. It'd be inline with relation and mapping definitions which is great too.\nI should be able to make it before xmas :santa: \n. @dnesteryuk urgent or not it's done and released :)\n. Thanks for that! I have warnings displayed in VIM but somehow this type of warning is skipped :(\n. @namusyaka my pleasure :)\nregarding padrino - there's an issue about rom support I may even give it a go since it shouldn't be a hard thing to do. Good to know you're a padrino user :)\n. I'd recommend checking out lotuskase which is based on dry-component to configure rom. It's a PoC and the component stuff is experimental so I'm very open to some feedback. The general goal of dry-component is to simplify managing object dependencies within a system (doesn't matter if it's sinatra, padrino, roda or even rails) by providing interfaces to load needed files in correct order, configuration, booting and resolving object dependencies automatically.\n. Thanks Piotr (: This is good to go I think. No need to squash or anything. Oh and please let's not make the build fail because somebody didn't align something \"properly\" :)\n. It should be 80 :)\n\nOn 20 Dec 2014, at 00:20, Piotr Szotkowski notifications@github.com wrote:\nJust let me know what would be your acceptable max line length \u2013 I\u2019m ok with any, including longer than the current max of 109; I won\u2019t tilt my \u2018it should be 80 characters\u2019 windmill today ;) \u2013 so I can make it so.\nI\u2019ll take the lessons from here and apply them to the other ROM repos. :)\n\u2014\nReply to this email directly or view it on GitHub.\n. Personally I prefer double-quotes but I use single ones because from what I've seen that's a more popular style. And in general I don't care about it. You can't use one or the other consistently that's why I simply do not care.\n. BTW please merge it in if you're done because there are things I'd like to do and this PR changes a lot of files so we're gonna have conflicts :)\n. Thanks :) I left a comment about code style. In general this whole builder is on my list of things to refactor. The way it should be done is to split it up in a builder that creates a constant and a one that doesn't using inheritance. We can also extend it further to support other types of models (like Virtus, Anima etc.).\n. attribute name should be a symbol and you can do from: 'role_name' - does this fix it?\n. also can you give me an example tuple?\n. A-ha, so roles are already grouped. Gotcha. I'm sorry I screwed up - I decided to move wrap/group processing out of relation layer and put them into mapping layer as part of transformation process. Now a mapper transforms a tuple based on group/wrap definition and then it gets loaded into a domain object. \n\nThis means that if you had a structure like that:\nruby\n[{name: 'Jane', role_name: 'Foo'}, { name: 'Jane', role_name: 'Bar' }]\nThen it would work. I totally understand why it doesn't work like you expect - group and wrap are transformations, I believe the only thing you need to do is to simply define attribute :roles, from: 'roles' in the mapping and skip the group part. Since you use virtus it will load domain objects from that array as I suspect you have something like attribute :roles, Array[Role] in your model.\n. @dnesteryuk ah right, you mean grabbing role_name from string-key and mapping to symbolized key, right?\n. What would you say about introducing an interface like that:\n``` ruby\nsetup.mappers do\n  define(:users) do\n      model name: 'User'\n  attribute :name\n  attribute :email\n\n  embed :roles, from: 'roles' do\n    attribute :role_name, from: 'role_name'\n  end\nend\n\nend\nend\n```\n??\n. OK great, I'll add it later today and push 0.5.0 :) Sorry, the API stabilizes but we may hit issues like that. That's why it's still < 1.0.0 but not for long. I'm already shifting focus from higher level integration specs to unit ones, polishing the API and specifying it in greater detail.\n. @dnesteryuk there you go: https://github.com/rom-rb/rom/blob/master/spec/integration/mappers/embedded_spec.rb#L21-L31\nI'm gonna clean up the code a bit and push a release later today :)\n. @dnesteryuk are you ok with running from master for a couple of days? I'd prefer to hold off with the release a little bit as it's 0.5.0 after all and I want to release new website and put together some release notes and announcements too :) Which means I need a bit more time\n. Could you try switching to master just to tell me if your specs are passing?\n. OK thank you!\n\nOn 24 Dec 2014, at 14:39, Dmitriy Nesteryuk notifications@github.com wrote:\nworks as expected, thank you.\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks for reporting. That's weird, reader is an enumerable and it implements each so I would expect this to work. I will look into it.\n. OK I guess I need to alias_method :to_ary, :to_a there. Fix, or rather new feature, is coming in...;)\n. @elskwid framework-agnostic would probably simply mean using test/unit. I think this is actually a high priority task. We need as many adapters as possible to prove that ROM's design isn't blocking anything and is flexible enough...\n. I think I'm gonna get this started today but my t/u fu sucks. You have been warned ;)\n. @elskwid how do I approach this must/should/may/must not concept using minitest?\n. ...I mean, must/must not are obvious but \"may\" and \"should\"??\n. @elskwid ah gotcha, I forgot that we talked about this, geez. I'll add a way to configure the test case class\n. isn't it done already?\n. This is a nasty gotcha where config-parsing class thinks \"database\" key means it's a hash coming from a database.yml file. This needs to be improved so that a user gets a nice error message that \"database\" is a reserved key.\n. @aflatter add ROM.setup('mysql://foo') to the list and then I can say \"yes, correct\" :)\n. This is now fixed along with a new syntax:\n\n``` ruby\nthis will work\nsetup = ROM.setup(database: [:sql, 'mysql2://localhost'])\n```\n. @splattael I love this idea. It's more flexible.\nLet me just show you why I did it like it is now, here's how I use commands:\n``` ruby\nclass CreateUser\n  attr_reader :users\ndef initialize(users)\n    @users = users\n  end\ndef call(input)\n     users.try { create(input) }\n  end\nend\ncreate_user = CreateUser.new(rom.command(:users))\ncreate_user.call(params[:user])\n```\nThere a couple of things here:\n- I don't use strong params\n- I use virtus params object to deal with input (that's set on the create command using input dsl)\n- I always pass input to the method so it's visible within the block\n- I never call anything inside the block except the commands\nHaving said that - it's just me. I can see how and why people would prefer to use it differently.\nI think yield_or_eval is a really simple and nice change so :+1: from me.\nThoughts? /cc @elskwid @adz \n. Yep totally, hence :+1: for this change from my side :smile: \n. Thanks. Looks great. In fact I wanted to do the same after the first pass but it was 4am ;) Merging!\n. I believe the most important thing from this list is ironing out a pattern for proxy (some data-pipe kind of a thing) and a common dataset superclass for adapters that happen to use enumerable datasets. This should make it much easier to write a new adapter that provides a dataset out-of-the-box. I also don't think that Charlatan is a good solution here, I've got a feeling we should have something more dedicated.\nThe rest feels more like nice-to-haves.\n. OK so now we have something like this:\n``` ruby\nclass AdapterDataset\n  include ArrayDataset\ndef self.row_proc\n    -> row { row.to_h }\n  end\nend\nconstructor accepts a data object\nds = AdapterDataset.new(some_hash_serializable_object_array)\nds.to_a # will run to_h on all entries\nds.find_all { |row| # here we also get entries processed via row_proc }\nall enumerable and array methods are available too\n```\nThis means if you're building an adapter that wraps some array-like object then this module is very handy. If the data object is not an array-like object but it implements enumerable interface then you can do include EnumerableDataset.\n. Do you think all adapters will always need a \"connection\" concept? So far it is true but maybe that's not a good assumption? Right now abstract adapter provides :connection reader and calls setup_connection hook in the constructor (which is a no-op by default, so it's not required to implement it). Nice thing about it is that a specialized adapter no longer has to override constructor to setup its connection but what if there's much more logic required to instantiate an adapter?\n. FYI I renamed setup_connection => setup which sounds more generic\n. With 16+ adapters built I think we did a good job :) Still more to do but I think we can close this issue. Re-open in case you disagree.\n. It's a method defined by rom-rails railtie. It defines it on ApplicationController\n. probably because bundler requires it anyway\n. I'm going to close this issue. If you see any weird behavior and think there's a bug please report it under rom-rails project.\n. Thanks. Could you also update Changelog that referencing an unknown method in command block will now raise ElementNotFoundError?\n. @splattael awesome thanks!\n. Soooo any objections or can I merge this in? /cc @elskwid \n. @aflatter just spent some time thinking about this and you're right, this would be a big assumption and even if we freeze them it might cause issues, so we would have to dup them before freezing, also we would have to deep-freeze them as we're talking about an option hash here, so, more complexity.\nI'll just remove equalizer (bye bye nice inspect ;))\n. @aflatter that won't work as equalizer defines hash method which is used internally in Hash#[] IIRC\n. I'm not sure yet :) So far all adapters need to set up some kind of a \"connection\".\n. @aflatter I followed up with connection-related discussion in #86 \n. since @elskwid started working on pure-ruby based linter, does it mean we should close this one?\n. Yep. Makes sense.\n. I feel like we need to encapsulate this in some support module\n. @aflatter IIRC this is fixed, right?\n. FYI I started working on this and in this branch it is already possible to do:\n``` ruby\nclass UserParams\n  include ROM::Model::Params\nattribute :name, String\n  attribute :email, String\nend\nclass UserValidator\n  include ROM::Model::Validator\nrelation :users\nvalidates :name, presence: true\n  validates :email, uniqueness: true\nend\n```\nIt is now limited to only work with rom-sql and uses global ROM env but it's fine since we're within rails context exclusively here.\nTo make this work with all adapters we would have to come up with a common interface for validation-related relations. Something like Relation#count_by(:attr_name) or something.\n. /cc @mcls (we moved all issues to main repo so I'm ccing you so you are subscribed again to the issue you originally reported)\n. This is now done and is supported by rom-sql and rom-rails. It'll be available in 0.6.0 of ROM and rails/sql updates.\n. This can be closed as rom-rails will ship with a fully AM-compatible Model::Form objects.\n. This is very simple to add. We just need to agree on the interface / options. How about this:\n``` ruby\nthis assumes file-name == dataset-name\nROM.setup(\"yaml://path/to/directory\", relation_per_file: true)\nor explicit settings dataset => file_name\nROM.setup(uri: 'yaml://path/to/directory', files: {\n  users: 'people.yml', tasks: 'todos.yml'\n})\n``\n. Right, sorry, I meant both would be available\n. @aflatter up to the adapter author\n. @aflatter some drivers support URI + extra options, so does ROM. IIRC sequel supports URI + options and moped (mongo) is the same\n. This is now available in rom-yaml 0.1.0\n. Yeah I like that. It's closer totrythat we already have.\n. Damn, this is nice too. Hmmmm\n. To establish conventional way of dealing with result objects. Notice that it wouldn't enforce the usage. You can still handle result as you like. This applies to commands themselves too. You can access them directly and call them and catch errors yourself and so on.\n. I don't think it'd work like you think - this is building an object that would execute individual blocks only for specific responses when you 'unwrap' a value from it. So.thenwould only be executed when response is a success, for an error response it would be a no-op.\n. IIRC we decided to go with something similar to Rust's Result - I really like it, looks like a great source of inspiration. Anybody would like to tackle this? Shall we have that as a last-minute 0.6.0 addition? :)\n. OK after all those months of ROM usage I realized we don't need to integrate with any external lib for command results. It's OK to addsuccess?andfailure?` methods as per #266 request and do whatever you want using whatever control-flow lib you like or plain ruby with conditional statements.\nHaving said that, I'm going to close this issue. Please tell me if you you disagree.\n. It was suggested that a virtual relation (which combines other relations and is not derived from a single base one) doesn't need a repository, which is absolutely true, so let's keep that in mind.\n. Indeed :) I introduced this concept because it made perfect sense when ROM was based on Axiom. Now it was just an overhead and additional complexity (same with header).\n. OK just realized that I don't see anything to add here. Let me know if you see something fishy. Otherwise I'd like to merge it in. I'll follow up with some small refactorings in Finalize in master before 0.6.0 release. For now I just want to get that into master.\n. In addition to supporting database.yml, right?\n. This sounds good\n. Any ideas on the structure of this file? Something like:\nyaml\nrepositories:\n  default:\n    adapter: postgres\n    database: rom_test\n  other:\n    adapter: yaml\n    database: locales\n??\n. OK this ain't gonna happen. You can easily configure ROM using its interface, no need for extra complexity that comes with parsing some yaml files.\nI feel very strong about this so I'm going to close this issue. If somebody can come up with good arguments why this is a good idea, please comment and we can discuss.\n. I'm working on it but it's tricky. Now we end up with Sequel error because we try to access a dataset immediately. I have some ideas how to fix it. I will send a PR because I don't feel strong about the solution :/\n. This was fixed via this commit in rom-sql\n. you can use thread_safe gem for that, it provides ThreadSafe::Hash\n. oh sorry, I just figured I should mention that :)\n. This looks great :+1: \n. Just to add more context - this was introduced to make it easier to access native interfaces exposed by adapters. It's been a workaround though as adapters should provide common interfaces to relation objects so accessing repositories is not a common thing to do\n. Please see my comments in the reverted commit\n. Si. I guess this needs some updates after repo/adapter changes.\n. I think now \"Adapter\" describes a library that provides support for a specific datastore. So, yes, this is still linting for adapters, more specifically lint tests for base adapter objects: Repository and Dataset\n. It would require a huge infrastructure, we could consider doing that at some point, right now it's not really feasible in my opinion. I would also argue if it should be part of ROM.\n. There are advanced projects for migrations out there :)\n\nOn 14 Jan 2015, at 22:45, Hannes Nevalainen notifications@github.com wrote:\nyeah, it is not a small project... just dreaming =)\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing this as we have a migration interface in rom-sql now added in this commit\n. This is done in rom-sql\n. I'm grabbing that one as it may introduce some challenges in rom core and sql adapter\n. it's done in rom-sql\n. Small note: this removed around 100LOC related to anemic repository object. Then @splattael added some stuff related to specs so original code-removal stats are not visible. Something to keep in mind :)\n. Right :)\n. w00t\n. ^5 @Hakon \n. Scheme registry won't be needed. We should consider having either a convention (:sql => ROM::SQL :memory => ROM::Memory etc.) and automatically infer constant from symbol or make it explicit using a map and registration mechanism (like with schema but using constant symbol identifiers)\n. @aflatter we can auto-require them (which is funny as it would go back to how it used to be in ROM hah)\n. :sql == require 'rom-sql' and ROM::SQL is expected to be defined afterwards\n. :+1: \n. Rubocop doesn't pass on master currently :)\n. I've given some second thoughts re adapter registration (esp after seeing #125 and issues we had in specs). Then I had third thoughts, and fourth too.\n\nEventually I realized that auto-registration:\n- introduces implicit behavior that may have \"unexpected\" side-effects causing \"wtf\" moments for library users and adapter creators\n- makes it hard to find constants based on symbol identifiers\n- makes our spec suite more complicated\nAll this in order to avoid having to write Repostiory.register(:sql, SQL) - so, I'd vote for bringing back explicit registration like it was before to simplify things.\n. Ugh, I confused two things: auto-registration (that is gone already here) and linking a symbol identifier to a constant - so, my point is: this should be done via explicit registration maybe something like ROM.register_adapter(:amazing_db, ROM::AmazingDbAdapter)\n. @aflatter I'm talking about registering an adapter namespace under a specific symbol so that we don't have to do any inference or pollute rom with symbol=>adapter maps\n. @aflatter yes, public, for adapter creators, to make things explicit, reduce complexity in rom and avoid wtfs.\nI also realized that it wouldn't help much with spec suite situation - we still need a way to unregister adapters when we dynamically create them for testing purposes, but I'd just have a private api for that in spec/support and call it a day\n. Just a heads-up that I'll wrap this up later today. Stay tuned.\n. I like it. My only concern is that \"Memory\" is such a generic word that it might be hard to figure out that it's actually an in-memory adapter. Hmmm\n. I wouldn't want to use Adapter (or Adapters) namespace for adapters, specific db support for ROM can include many things, I'm not even sure \"adapter\" is a good word here hah.\n. @aflatter after our recent discussion I believe I should revert it to the original idea of rom.read(:base_rel_name, mapper: :some_mapper). OK?\n. @aflatter one more thing - we talked about an alternative interface where you can use a block where you put together a relation and then tell which mapper should load it, IIRC something like:\nruby\nrom.map(:users, :mapper_name) { active.admins.by_id(1) }.one!\nRight?\n. Ah yeah that's better. So I guess for map to work we'd do something like if block_given? then super else mappers[mapper_name].process(relation).to_a } end. That block would be evaluated on some object that has access to relations (we could build it during setup to avoid method_missing). Hmmm\n. @aflatter I'd like to remove instance_exec and yield a relation to the block and then close this issue, so:\nruby\nrom.read(:users) { |users| users.by_name('Jade') }.map(:foobar)\nlemme know if that works for you, if not let's talk this through :) I'd like to close this chapter for 0.6.0\n. @aflatter we could do the trick with arity :)\n. that would couple relation with mapper :( suddenly it would know about its existence\n. BTW I should mention a couple of things just to clarify:\n- rom.relations are exposed because of a lack of certain interfaces; eventually I would like to have some higher-level interfaces exposed by env so that you don't have to access relations directly. For instance I can easily see a separate interface for aggregations (max, min, count etc.)\n- Reader object is a top-level interface for reading defined relations via mappers. It is an enumerable object that only exposes publicly available relations and excludes native query DSLs or any other interfaces provided by the adapter layer\nI have to admit this is my little experiment and maybe this approach will turn out to be too strict and not flexible enough (being enforced to specify relations for every part of your system that needs data can be annoying in very simple applications). So this is something that might be changed. Regardless - I like reader idea as a higher-level object used only for accessing relations, hence I'd like to have this feature to be part of the reader API, not relation. Especially that, like I already mentioned, Relation doesn't know about the mappers and I believe it should stay like that.\n. OK so now it's:\nruby\nrom.read(:users).with_mapper(:prefixer)\nHAPPY?!!??!?!?! ;)\n. :relieved: \n. I commented on #120 which is related to this PR too\n. We talked about this with @aflatter today and our consensus is that our official adapters would register themselves through a private API and the rest of the adapter world would require passing in an object to .setup as we don't want to make any assumptions about the object construction.\nThoughts?\n. I'm going to close this one since after #120 is merged this becomes obsolete\n. Haha unlucky\n. This will be tackled at some point but I must admit it's very very very low on my personal priority list. Happy to accept PRs of course. I don't have any concrete ideas wrt interfaces though.\nIn general I see it as an extension of the reader interface that would provide a way to translate incoming \"query\" object into a form that matches inverted mappings.\nI should probably mention that I'd like to build a query extension for ROM that would help in building complex queries.\nPlease also notice that in ROM a recommended way of reading relations is through custom methods, so rom.read(:users).by_name('Foo') rather than rom.relations.users.restrict(username: 'Foo') which would eliminate or at least reduce the need of 'inverted mappings' for querying relations.\n. Oh and regarding commands - similar story, we may introduce an interface to help with that.\n. This issue was moved to rom-rb/rom-mapper#12\n. How about this:\n``` ruby\nthis would build a composite command where tasks.create would know it should\nassociate task with a user by setting its FK\nthe try block gets back a command, calls it and rescues from any potential errors\nand returns Result object\nrom.commands.try {\n  users.create[name: 'Jane'] >> tasks.create[title: 'Jane']\n}\nfor better readability in sql world we could have it like that:\nrom.commands.try {\n  users.create[name: 'Jane'].associate(tasks.create[title: 'Jane'])\n}\n```\nNotice the [] that would be needed to auto-curry input and postpone execution, if we wanted to use () we'd have to put something in front of it...which is exactly why I added Evaluator but now I'm thinking it's an unneeded abstraction...with this approach we explicitly access commands and remove the need of having something extra on top of it. For me it'd be a win.\n. oh and here's an example of update and delete with this style:\n``` ruby\nrom.commands.try {\n  users.by_id(1).set(name: 'Foo')\n}\nrom.commands.try {\n  users.by_id(1).delete\n}\nOR to be consistent with [] used in \"create\" commands:\nrom.commands.try {\n  users.update[:by_id, 1].set(name: 'Foo')\n}\nrom.commands.try {\n  users.delete[:by_id, 1]\n}\n``\n. OK soEnv#try` feels wrong because you need to inject entire ROM env into objects that use commands, meh. So I will move it to command registry so that you can only inject command registries:\n``` ruby\nusers = rom.commands.users\ntasks = rom.commands.tasks\nusers.try { users.create[name: 'Jane'] >> tasks.create[title: 'Task One'] }\n```\nMakes sense?\n. I made a bunch of improvements in the composable-commands branch which is now merged into master, the API is way simpler now and allows explicitly calling command objects without the intermediate evaluator object. You can also simply refer to a specific relation on the command object (which transparently forwards to relation and returns a new command for a specific relation).\nIt's a really nice change IMO based on the feedback I've gathered so far. So, eventually it looks like this:\n``` ruby\nusers = rom.commands.users\ntasks = rom.commands.tasks\ncreate_user = users.create\ncreate_task = tasks.create\nusing try with a command object that you just call\nusers.try { create_user.call(name: 'Jane') }\ntasks.try { create_task.call(title: 'Do something') }\nyou can now compose two commands and call it eventually\nreturn value from the first is passed into the next\ncommand = create_user.curry(name: 'Jane') >> create_task.curry(title: 'Do something')\ncommand.call # now created user is passed to create_task#execute\nupdate and delete can access relations using a method call that looks like accessing a relation\nfollowing examples assume you have by_id and by_name relations defined on users base relation\nupdate_users = users.update\ndelete_users = users.delete\nupdate_users.by_id(1).set(name: 'Jade') # notice that \"set\" is just an alias for \"call\"\ndelete_users.call # deletes all the users\ndelete_users.by_name('Jade').call # delete users with name == 'Jade'\n```\nI believe that the only \"gotcha\" here is that commands are callable objects that don't do anything until they are called. This is a lovely foundation that can be used to build really complex scenarios, I'm sure rom-sql can benefit from this in the short term. There are a couple of features that could be added, like telling which values should be passed to a command when using composition, partial application with auto-curring via arity option that could be added etc. It will be more clear what's needed when working on rom-sql's specific commands for handling associations with FKs.\nOne more thing - I suspect that people might get confused when looking at code like rom.commands.users.create because it looks like if you try to create a user :) It'd be better (probably) to use [] to make it more clear that you are accessing a command object, so: rom.commands.users[:create] should read better.\n. @gotar w00t!\n. Right!!\n. I'm gonna take a stab at this and see how it \"feels\"...stay tuned\n. @aflatter @elskwid @splattael this is ready...mind taking a look at the insane DIFF?\n. OK sorry to say this but there's one more thing todo here...see PR's description. Damn...\n. FYI I updated my app without any problems. It works both with DSL-based setup and sub-classing. That's reassuring :)\n. OK that's it folks...please please take a look. I'd love to merge this in later today if you can give me :+1: \nIt was tested with my app too and rom-sql has been already updated (see rom-rb/rom-sql#9)\n. Params are designed to handle input sent from \"the outside\", if you need to build attributes based on params you need a separate object to do so (like your 'Video::FromYoutube). I see that in your case you construct attributes based on a url (that's your input) and then you pass in those attribute to the command. I would probably model it in a way where there's a form object with params having a url, validate that url and use it to build attributes for the command (there's no need to specify special command input class in this case IMO).\nSomething like that:\n``` ruby\nROM.commands(:videos) do\n  define(:create_from_youtube, type: :create) do\n    # if you don't trust your FromYoutube you can specify params and validator handlers\n    input Video::YoutubeParams # params that are constructed by FromYoutube\n    validator Video::YoutParamsValidator # dedicated validator for those params\nresult :one\n\nend\nend\nthen the VideoForm models the actual form which (as I understand it) sends a URL, which should be\nvalid so that FromYoutube can work with it\nclass VideoForm < ROM::Model::Form\n  inject_commands_for :videos\ninput do\n    set_model_name 'Video'\nattribute :url, String\n\nend\nvalidations do\n     validate :url, presence: true # probably more is needed\n  end\ndef commit!\n    attributes = FromYoutube.call(youtube_id)\nvideos.try { |command| command.create_from_youtube(attributes) }\n\nend\nend\n```\nThis assumes FromYoutube.call always returns a valid set of attributes and crashes with an exception that is handled outside of the scope of the form (some http errors and such). You could of course handle it in the form but there's no conventional interface for such errors (not yet at least).\nAs a general design principle Form objects must model the actual web forms. I's only responsibility is to define structure of input, validation rules and send it to the command. If actual attributes are different from the original input (as in this case) then it's totally fine to map them to something else using an external dependency (like FromYoutube) and send to command, notice that command's input/validators would be different from the form's input/validation.\nThe .[] is not virtus', it is ROM's Model::Params interface as that's the interface commands depend on.\nI think this use-case is a beautiful example how ROM pushes towards separation of concerns. It is probably harder to understand when we're so used to a single object (AR) that would handle ~90% of what's happening there. I believe it is only a matter of time to get used to this approach. We can come up with many conventional interfaces working on a high-level that are using small lower-level components (like Form already does) but once things get complicated you can easily break them down, re-use them in many places, test them separately etc. For me that's a huge benefit.\nI already used Form in my app and it feels as simple as when using AR, so I think we're getting there with the ease of usage too.\n. Yeah, it kinda sucks I have to admit. Form is built with the assumption that command will use input and validator handlers. Hmmm. I guess that's why I was reluctant to introducing form objects in general haha, it's assuming a lot. I need more time to think how to extend the interface so that we can model your use case better.\nThis is actually a pretty common thing to do - receive some input and map it to something that will be persisted. This means you need 2 validators, one for received input to make sure its structure matches requirements and another one for the actual attributes that will be send to the db.\nI've got a hunch that we could have an abstract object for handling a generic scenario raw input => mapped input => validation => custom action and derive Form from it. This way you could derive your own class from it too and simply use form instance inside of it as an external dependency. Something like that maybe:\n``` ruby\nclass CreateVideo < ROM::Model::SomeFancyAbstractInputValidationHandlerThingie\n  inject_commands_for :videos\nuses :video_form\ndef commit!\n    videos.try { |command|\n      command.create(video_form.attributes)\n    } \n  end\nclass VideoForm < ROM::Model::Form\n   # all the stuff\ndef attributes\n    validate!(input)\n  end\nprivate\ndef input\n    self.class.params[params]\n  end\ndef validate!(input)\n    self.class.validator.call(input)\n    input\n  end\nend\n``\n. Ah there's one detail I should mention: those fancy objects should also register commands so that you don't have to do it _unless_ you don't want them to in cases where you re-use \"raw\" commands in other places. This will be added soon and should simplify the setup a lot.\n. I'll be making some improvements in Form interface so I'll try to address this one too and make it better for you :)\n. This is resolved as now you need to pass in already coerced input usingForm#attributes` interface to the command. This means you control when and how input is processed.\n. OK I'm gonna do it, it's pretty important to get it done sooner than later\n. Auto-forwarding is already gone and most of the common dataset methods are now implemented. Closing.\n. @aflatter ugh of course :) thanks for the reminder, I updated todos\n. OK it feels like releasing beta versions of rom, rom-sql and rom-rails will be a good start. Beta or a RC (I consider APIs as frozen, the only thing I'd like to add is #155).\nDuring beta/rc phase people could try it out and some potential silly issues that we might've missed could be fixed. Then final version could be released.\nWith so many changes I think it's a good way to go. We could just tweet about beta/rc releases and ask people in the chat to try it out. Blog ann posts would be published for the final releases.\n. @cored this issue is just a todo list to prep the release. Any problems discovered should be reported as separate issues\n. Just a quick update: rom 0.6.0.beta2, rom-sql 0.4.0.beta1 and rom-rails 0.3.0.beta1 are released now. I haven't had the time to release other adapters though but they will be released along with final version of rom 0.6.0 so don't worry.\n. @aflatter dammit I forgot about this :D yeah dataset is much better and describes what it actually is...we should rename it\n. Fantastic!\n. Yep good idea to move it :+1: \n. Evaluator was removed eventually so this is obsolete :) Closing\n. Yeah I'm :+1: here esp after adding silly code that clears the descendants arrays in specs and rom-rails to_prepare.\nAs you point out this can be done automatically on an integration level with frameworks so it's fine. It would be worth to consider pulling that code into rom core though so that we don't have to do it all over again in every framework integration.\n\nOn 02 Feb 2015, at 21:50, Alexander Flatter notifications@github.com wrote:\nOpening an issue here to discuss the effects of descendants tracking and the removal thereof. Gerenally, I'd say that descendants tracking is undesirable because it's a class-level interface and hidden from the user. Currently it's used to populate the registries of relations, mappers and commands automagically.\nHere's a couple of points to discuss:\nIs it currently possible to require ROM objects before calling ROM.setup?\nWill issues arise when using multiple environments?\nWhat's the consequences for the way readers are currently working? AFAIK, a chain of calls to the Reader simply builds a path of said calls, e.g. users.with_posts.active, that is then used to retrieve the appropriate mapper.\nThe alternative to using descendants tracking is to make registry explicit. Note that this won't bother users of rom-rails or similar integration gems as they would ship with support and conventions for location and name of those classes.\nrequire 'my_app/relations/users'\nsetup = ROM.setup(...)\nsetup.register_relation(:users, MyApp::Relations::Users)\nThe advantages are the removal of a fragile technique, independence of load order and setup time, less hassle in the test suite and simplification of ROM core.\n/cc @elskwid @solnic @splattael: We already talked quite a bit about this. :)\n\u2014\nReply to this email directly or view it on GitHub.\n. @aflatter are you interested in making that change? I have other stuff on my plate that I need to do so this is a nice-to-have for me ;)\n. Move to 1.0.0 milestone then?\n. No pressure whatsoever but do you think you could wrap this up this week so that we can include it in 0.6.0?\n. Sorry to hear that. I'm struggling with an infection myself :/ Seems like we're gonna postpone 0.6.0 release a little bit.\n. The setup process is relatively complex but I wouldn't call it blackmagic. Descendants tracking is gone already but we still use inherited hook to register a class. That's an implicit behavior though and potentially can be confusing, otoh it's just part of the setup, this is not something that's happening at run-time after setup.\n\nCan you tell me which part got you confused wondering how on earth that works?\n. Yeah that's why I started with the DSL in the first place. Later on we discovered that it's easier to re-use inheritance mechanisms in ruby vs reinventing them for the DSL purposes.\nI believe DSL will stay, maybe it'll be extracted into a separate project (rom-micro? :)) but the class-based approach makes much more sense in bigger projects.\nRegarding your concern about defining classes but never having to instantiate them - I can understand the confusion. Fortunately it's easy to explain and we should definitely do a better job here in the documentation.\nWhat you see with the classes and then having all of those instantiated for you is a ROM environment, it's pretty much an object factory that's built into ROM. It simplifies your life as you don't have to deal with object instantiation yourself. I want to take this idea further and extend it with some DI mechanisms too that would work well with ROM core objects.\nKeep in mind that it's just a convention, ROM env is just a way to organize those objects, you can instantiate objects yourself if you want and organize them in a different way:\n``` ruby\nrequire 'rom/memory'\nmemory_repo = ROM::Memory::Repository.new\nuser_dataset = memory_repo.dataset(:users)\nclass Users < ROM::Relation[:memory]\nend\nclass UserMapper < ROM::Mapper\n  model name: 'UserEntity' # ROM supports generating model classes\n  attribute :name\nend\nuser_relation = Users.new(user_dataset)\nuser_mapper = UserMapper.build # using build injects default mapper processor\nuser_relation.insert(name: 'Jane')\nputs user_mapper.call(user_relation).to_a.inspect\n[#]\n```\nROM consists of really simple objects, the most complex part is the setup, as I mentioned, but as you can see those objects are dead simple to instantiate yourself. Also notice that in the example above I didn't use the setup at all.\n. Oh one more thing - ROM env object also exposes a higher-level interface for accessing relations and commands, it has access to all registries so we can have more convenient interfaces built on top of that.\n. Mapper class name is not used at all right now. We only infer dataset name from relation class name.\nRegarding inheritance - if you inherit from another mapper its whole header will be copied and then you can override specific attributes if you want.\n. Nah it is just a shortcut for ROM::Memory::Relation\nOn Fri 6 Mar 2015 at 22:15 muescha notifications@github.com wrote:\n\nhere is also blackmagic? this generates a relation for me magic?\nclass Users < ROM::Relation[:memory]end\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/142#issuecomment-77637075.\n. I hear you. This will soon be replaced by policy-over-configuration so\nthose things will be handled explicitly and you will be able to provide\nyour own policies too (see how it's done in yaks gem).\nOn Fri 6 Mar 2015 at 22:18 muescha notifications@github.com wrote:\ni mean it creates the :users for me as magic. in other classes i need\nregister_as - but here not\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/142#issuecomment-77637677.\n. So, this is finally addressed. We ended up with an optional plugin that enables auto-registration. Disabled by default, to enable you can do ROM.use :auto_registration.\n. We shouldn't include migration tasks by default. I'll fix that\n. We're not going to enable migrations in Rails by default, this is a highly experimental and fresh feature so needs more work.\n. For now I did this - lemme know what you think. I no longer feel super strong about removing inherited-hook \"magic\" anymore since descendants are part of the setup now.\n. @aflatter I'd like to close this one, :+1: or :-1: ?\n. I believe we gotta think about something more generic here. I see the need for a feature where ROM during setup exposes some interface for gathering information needed to finalize defined classes. I believe this would become even more important when we have some plugin interface in place too.\n\nMaybe we should gather information in a separate issue to see what is needed. The first one is obvious: a list of defined classes.\n. Yes, I love the policy idea. Would love to have something like that in ROM. Various objects could use different policies, policies could be configured using some top-level interface exposed by ROM\n. This is...obsolete. the main idea with explicit registration is still there, I'm gonna describe it in a new issue. Closing this one.\n. Merged :)\n. Can you show me how you got this error?\n. ...so, this is actually the expected behavior, when there are no mappers, then there are no readers, because readers are build to access mappers. The trick is (and that part can be confusing), that you don't define readers, you define mappers that's why you probably expected an error related to mapper.\nI'm not sure how to improve this to be honest. Readers are really handy and can be used to extend behavior of loaded relations. I guess it's a matter of documentation.\n. Reader is gone, so this is gone too.\n. Sounds like a good plan :)\n. True! Closing, thanks :heart: \n. Oh lovely! Could you also write an integration spec showing off how it looks? Maybe in spec/integration/commands/try_spec.rb?\n. I think option 2 looks good, it's explicit and doesn't require defining global functions. Auto-wrapping does feel like magic that's happening behind the scenes and when you look at and_then/or_else blocks it's not obvious that it's going to happen.\n. I like yielding result wrapper object to the block; definitely don't like exposing class methods (I'm anti-class interfaces in general).\nResult could be promoted to be more generic, not strictly related to commands, so that command API can use it, and users can use it too when handling their own error/success cases.\n. Closing in favor of #155 \n. Thanks @maetl for this. It's really nice to hear that you had fun time building an adapter for ROM despite lack of proper documentation :)\n. @maetl I gave you commit access to rom repo in case you'd like to work on some docs or improve some things, thanks for helping out :heart: \n. There are two factors here that make it hard to build complex mappings:\n- mappers and relations are disconnected, it means that a mapper expects a correct data structure to be sent and relations must provide that data structure, you build those data structures using query DSL provided by rom-sql relation. There's no declarative way to specify those structures, it's just based on building sql queries\n- handling name clashes in columns is semi-manual - when you use association_join under the hood we use graph interface from sequel that automatically qualifies conflicting column names, it's actually pretty messy because some columns get prefixed, some not. Then you need to know what was prefixed and set up a mapper properly. It's pretty brittle and annoying.\nTo improve this we need to make those things happen automatically, somehow. For instance we could have an interface in Relation that joins with another relation and by default prefix everything. In the mapper we use a convention that if we're mapping an aggregate then all attributes are prefixed. This would require extending Mapper DSL with sql-specific bits.\nI would imagine something like that to work:\n``` ruby\nclass Tasks < ROM::Relation[:sql]\n  def with_workers\n    # this qualifies all tasks columns and worker columns, just as a convention to simplify things\n    association_join(:workers)  \n  end\nend\nclass TaskMapper < ROM::Mapper[:sql]\n  attribute :id\n  attribute :title\nend\nexcuse the awful name\nclass TaskWithWorkersMapper < TaskMapper\n  # this incantation would rewrite all attributes to be prefixed and then do group :workers, prefix: :workers\n  association :workers\nend\n``\n. Just wanted to mention that with ROM 0.7.0 we havecombine` interface that issues multiple queries and allows simple mapping into aggregates w/o the need for prefixing columns etc.\nI'm keeping this issue open though as using joins is also useful and I think ROM should make it as easy as possible.\n. This is now scheduled for 1.0.0 and should be included in one of the 0.x.0 upgrades prior 1.0.0 final\n. With rom-repository building aggregates is trivial; hence this is finally not an issue. Closing :boom: \n. Here's the \"why\" part of this PR explained in a short example:\n``` ruby\nrequire 'rom'\nrequire 'virtus'\nROM.setup(:memory)\nclass User\n  include Virtus.model\n  attribute :first_name\n  attribute :last_name\nend\nclass UserPresenter < SimpleDelegator\n  def full_name\n    \"#{first_name} #{last_name}\"\n  end\nend\nclass Users < ROM::Relation[:memory]\nend\nclass UserMapper < ROM::Mapper\n  relation :users\nattribute :first_name\n  attribute :last_name\nend\nclass UserEntityMapper < UserMapper\n  register_as :entity\nmodel User\nend\nclass UserPresenterMapper < UserEntityMapper\n  register_as :presenter\nmodel UserPresenter\nend\nrom = ROM.finalize.env\nrom.relations.users << { first_name: 'Jane', last_name: 'Doe' }\nuser = rom.relation(:users).map_with(:entity, :presenter).first\nputs user.full_name\nJane Doe\n```\n. I'd like to merge this in tomorrow so yell at me if you think it's not a good idea :)\n. @maetl yeah, I think \"reading defined relations\" is a higher level concept that should be moved outside of ROM core and framework integration could leverage this feature somehow. I'm not sure about the implementation details yet.\nI'm glad you pointed out explicit materialization via rom.relation(:foo) {} block, it's kind of unclear when it happens in the reader :)\n. One thing that's lost here is one and one! interfaces. I should probably port them from Reader.\n. I also wonder if Relation::Loaded should map relation via default mapper or should it always be explicit via #map_with interface. So ie:\n``` ruby\nshould this map by default using rom.mappers[:users]?\nrom.relation(:users)\n...probably not, so should we have a shortcut explicit interface instead? maybe:\nrom.relation(:users).mapped # meh...\n...maybe we should have a nice naming convention for mappers so that\nthis would be possible:\ndoes rom.mappers[:users][:entities].call(rom.relations[:users])\nrom.relation(:users).as_entities\n# does rom.mappers[:users][:presenters].call(rom.relations[:users])\nrom.relation(:users).as_presenters\nit would of course work with a block\nrom.relation(:users) { |r| r.by_name('Jane') }.as_entities\n```\nThoughts?\n. @elskwid hmm good point, mappers could be registered under singular names, so how about:\n``` ruby\nrom.relation(:users).as(:presenter)\nor\nrom.relation(:users).with(:presenter)\n```\nthis way we'd avoid having to use meta-programming :) Not sure which one is more intention-revealing/clear to understand.\n. Not really - :presenter is the mapper name registered for :users relation :)\n\nOn 16 Feb 2015, at 22:03, Don Morrison notifications@github.com wrote:\n@solnic ewith that answer I think I see the idea. You are saying: \"since I'm not providing a mapper name, use the default registered under :presenter\". Does that sound right?\n\u2014\nReply to this email directly or view it on GitHub.\n. @muescha you could skip the attributes part in the mapper and only specify models; we can also generate mappers from model definitions. I call it \"convenience apis\" and those are still not high priority (at least not for me). It is still unknown what are the common use cases for ROM, once we have more experience with real world usage various \"convenience apis\" will come out of that. I would say that's food for 2.0.0 of ROM. Personally I'm much more interested in building a really solid foundation for ROM in 1.0.0, get a felling how it's like to use it in production systems and plan 2.0.0 based on that experience. If we start adding a lot of convenience-oritented APIs too early it may clutter the codebases and make it harder to solidify foundation. It doesn't change the fact people can build add-ons that could make things simpler and DRY up code already (ie I have a spike with rom-virtus.\n. With some conventions in place we could configure entire environment from a minimum set of classes. As I mentioned that's doable and will be done at some point in the future. Right now we need to explicitly define mapper classes.\n\nRe SimpleDelegator it's a class from ruby stdlib.\n. How about module Test;end in spec_helper and then just Test::Something = Class.new in specs??\n. :clap: \n. @mjtko we could add active_support to test group which includes dependencies used in tests\n. @cflipse yeah I agree, I'll wrap it up today and mark auto-currying as uber-experimental and it'll be ready to merge\n. @cflipse re Relation::Loaded - its mapping behavior becomes redundant now with Relation::Lazy. I'm gonna remove it (interface stays the same from the relation access pov, you can still do rom.relation(:users) {})\n. OK I consider this as ready-to-merge. Please take a look and lemme know what you think.\n. @cflipse how do you use your pagination shim?\n. @cflipse so you just do DatasetPagination.new(rom.relation(:foo).bar.baz))??\n. @cflipse you said \"good enough\" so I suspect you can imagine a nicer API for pagination, right? Any specific visions?\n. @cflipse right now the problem is that during data-pipelining the original relation gets lost in the process as mappers return arrays...that part is problematic :/ I want to experiment to see if we can maintain original relation in the loaded relation but it might be too complicated and error-prone. I just need to try out a couple of approaches and see if it's feasible.\n. @cflipse yeah as and map_with send relation through mappers so you end up with a mapped loaded relation and you no longer have access to methods defined on the relation\n. Thanks for the report - that's fixed on master already\n. Great job :clap: \n. I'm gonna hold off with this for now. I think it needs some discussion. ie maybe inheritance should be used here.\n. Closing as we now we have steps which can be used to accomplish the same goal\n. Yes, seems like transproc assumes it's a non-nil value. I'll fix it there. Thanks for the report.\n. FYI I fixed it in transproc, here's the output from the repro script in this issue:\nruby\n{:name=>\"Hannes\", :last_login=>{:time=>\"2015-03-13\", :ip=>\"127.0.0.1\"}}\n{:name=>\"Hannes\", :last_login=>{:time=>\"2015-03-13\", :ip=>\"127.0.0.1\"}}\n{:name=>\"Hannes\", :last_login=>{:time=>nil, :ip=>nil}}\n. yep the adapter is at rom-rb/rom-influxdb\n. I'm working on it, will push something tomorrow\n. The project has started under rom-rb/rom-lotus. Expect a release soon.\n. input is not for setting domain object models, it's for setting input sanitizer/coercer objects. Commands don't persist \"domain objects\", they persist data, we're dealing with hashes here exclusively (aka tuples). from/to works with hashes, the fact you provide input User doesn't mean the command persists a user. It just happens that your class responds to the expected interface (User[] and User#to_h).\nMakes sense?\n. seems like arity is -2 when there's an arg with a default value, we don't check that yet (we only bail when it's -1). easy fix, if anyone would like to tackle it.\n. it boils down to changing this to check for < 0 and adding a spec example with a default arg.\n. I'm definitely for using a 3rd party gem for this. I'll check out Unsound!\n. ps. I allowed myself to edit the PR description and link to unsound repo on github\n. Shall we move the discussion to an issue in unsound repo and talk about its interface etc. there? Once we have a nice interface in place (we may already have it!) we could come back here and integrate it with ROM.\n. ah, yeah I know why it happens, this makes me think that we do want an empty hash from nest instead of nil.\nmakes sense?\n. OK fixed in transproc 0.1.2\n. Yeah, I had second thoughts about this myself. We added strict mode by default but it's too aggressive. This is that moment where coercion and validation are really close to each other.\nI think you're right - we should turn strict mode off.\n. Actually I think the proper way of doing this is unwrapping the result and using whatever the command returned. We can wrap it up as an object too (this is a missing interface in Form though).\nSo, something like this would be much nicer:\n``` ruby\nform = NewDataForm.build(data_params).save\nif form.success?\n  data_object = form.something_that_returns_the_created_data_object\n  redirect_to data_path(object)\nelse\n  render :new, form: form\nend\n```\n...or we could make sure that to_key works with a saved form but that's even more mutability in the form object so meeeh.\n. Yep we should push 0.3.1 with those changes merged\nOn Tue 24 Mar 2015 at 15:14 Chris Flipse notifications@github.com wrote:\n\nThis looks like it'll blend in really well with #185\nhttps://github.com/rom-rb/rom/issues/185, once that's in place.\nAlthough I think getting something in place for a 0.3.1 release might\nstill be a good idea, even if it gets updated once rom-0.7.0 goes out.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/181#issuecomment-85512384.\n. with #187 merged in we could extend form dsl to support something like that:\n\n``` ruby\nclass CreateUserForm < ROM::Form\n  # this would make Form generate a command registry tailored\n  # to return entities using :entity mapper\n  commands users: :create, as: :entity\n# rest of the stuff\nend\n```\n. @cflipse yes, wrap things up before Thursday and release on Friday\n. yep makes sense to start as simple as possible :)\n. no, sorry this can't be done like that - first of all it requires model constants to be defined when commands are loaded, secondly it makes command know how to instantiate objects (which is not their responsibility), thirdly - I really don't like that syntax anymore, it can't be used consistently and requires more complexity, it's going away in virtus 2.0.\n. This is done in #187 - pls take a look, I'd like to merge it in :)\n. @cflipse @aflatter @splattael @gotar @elskwid thoughts? makes sense?\n. we can extend command class definitions so that you can specify which mapper should always be used; however, I'd like to try to get away without having that and simply do that in my code like that:\n``` ruby\nexcuse me lack of a nice DI :P\nclass SomeObjectThatPersistsUserDataAndReturnsEntity\n  def self.build\n    new(ROM.env.command(:users).as(:entity).create)\n  end\ndef initialize(command)\n    @command = command\n  end\ndef call(input)\n    command.call(input)\n  end\nend\n```\nIn general...that's how ROM is intended to be used, same applies to relations.\n. It's actually not strange, it's inline with relation mapping - you can grab command registry and every command that it returns will use the mapper vs setting mapper for each command separately. It's actually more convenient to use it like that.\n. One more thing - we could consider doing the result :one, as: :entity which would set mapper_name (or something) internally and then CommandRegistry could look if this option is set and automatically set that mapper for a particular command.\n. Note: this PR was made because it turned out that current implementation doesn't work with opal.rb\n...and now I'm wondering why on earth a require doesn't work in opal? Are we doing something odd?\n. The we just need to make sure ROM's inflector is configured when the lib is required\n. Yep it should be simplified; probably removing its laziness should help\n. I plan to add proper ROM configuration API with support for policy-over-configuration where you can inject custom objects that handle certain things like inferring dataset name from a relation class name etc. This means you'll be able to use whatever you want there but I think from a pragmatic POV we should, by default, use an inflector backed by either inflecto or AS::Inflector for policies that require some inflection logic. I agree that current implementation is a bit too complex. I'd say we should clean it up once configuration API is ready with policies. This will allow us to inject name-inference policies using a pre-configured ROM's inflector that is configured by default and doesn't use a lazy-require mechanism.\n. I'm gonna close this since we need #193 done first in order to make it prettier.\n. Kind-of. We have initial support for migrations but I'd like to improve it a bit before making it official.\n. Ah it's because those gems are not released yet and we generate links to API docs of released gems :/\n. So this is a rom-rails bug I suppose.\n. So here's a mystery - it works in tests, but not in console, I'm clueless.\n. We discussed this with @cflipse and agreed that constraint errors and db errors should be re-raised and should be handled by application's code. See recent changes in rom-sql. Closing this one.\n. exclude is needed when you inherit from another mapper and want to exclude some inherited attributes. But overall mappers do not reject keys, attribute dsl is only used for transformations and coercions. We need to figure out how to improve that, I can see that rejecting could be handy.\n. The thing is that a mapper becomes almost a no-op if there are no attributes specified, which makes it fast. I'd say we should have a way to tell the mapper to actually reject undefined attributes.\nA typical scenario is that a relation returns tuples that are already in the expected state and doing anything extra with that is just an overhead that you don't need. My point is that rejecting attributes could be considered as a special case. For instance if you don't want certain keys to be in a tuple then in many many cases your db supports that (ie projection in RDBMS through select foo, bar ...). Only if a given data backend is dumb and returns more data that you need and for some reason it's a problem for you then, and only then, you will need a key rejection mechanism in a mapper.\nFWIW I had this case only once when mapping to anima objects because anima raises an error when there are unexpected keys in a tuple.\nPlease remember that mapper layer should be used when your db is lacking functionality wrt data projections.\n. Welllllllll you can always do this:\n``` ruby\nrequire 'rom'\nROM.setup(:sql, ['sqlite::memory'])\nROM.boot.repositories[:default].connection.create_table(:users) do\n  primary_key :id\n  String :name\nend\nclass Users < ROM::Relation[:sql]\n  def by_id(id)\n    where(id: id)\n  end\ndef from_created(users)\n    by_id(users.map { |user| user[:id] })\n  end\nend\nclass CreateUser < ROM::Commands::Create[:sql]\n  relation :users\n  register_as :create\nend\nclass UserMapper < ROM::Mapper\n  relation :users\n  register_as :entity\n  model name: 'User'\n  attribute :id\n  attribute :name\nend\nrom = ROM.finalize.env\ncommand = rom.command(:users).create.with(id: 1, name: 'Jane')\ncommand >>= rom.relation(:users).from_created\ncommand >>= rom.mappers[:users].entity\nputs command.call.first.inspect\n\n```\n:smiley: \n. Great work. I'll try to port rom-sql plugins to this.\n. @cflipse can you remind me what we're missing to finish this? Specifically in terms of the missing interfaces?\n. @cflipse OK thanks. I'm gonna try to improve that and merge this in (: Sorry it's taking so long\n. Merged. I'll continue in master. Cheers (:\n. Nice catch. Thank you!\n. A dataset is an object that exposes \"native\" interface to access data. The only required interface is #each though but typically datasets provide quite powerful interfaces that a relation can use. There's a macro you can use to forward certain calls to the underlaying dataset and this will enable query chaining, ie:\nruby\nclass ROM::Rmp::Relation < ROM::Relation\n  forward :some, :methods, :exposed, :by, :dataset\nend\n. > ROM::Commands::Abstract#execute states that it should return an Array. Why not return a Dataset or a ROM::Relation::Loaded? Those both seem to work well and give more upstream information.\nA simple array can easily work with all adapters, datasets may not, since they are specific to a given adapter and may not have the same behavior that would make them work with the pipeline. And Relation::Loaded could be used but feels like an overhead for cases where you just simply want to map returned data into something else. I might be missing some use cases though so it's definitely something to discuss further.\n\nI thought we were supposed to be keeping write concerns separate from read concerns.\n\nCommands give a separate interface to handle writes but they use relations which provide basic CRUD interface (typically in most adapters). We don't have a strict separation here.\n\nWhat makes more sense to me is to send writes to the dataset directly from the command.\n\nYes, typically that's the way to go. in rom-sql we do that. Keep in mind that relation is needed at least to provide restricted relation views. (ie by_id etc.).\n\nThen we can add some sugar to the relation, allowing it to create commands on the fly.\n\nI don't like that to be honest. This would make relations know about commands, right now commands only know about specific relation interfaces and relations are injected, the coupling is very minimal and I'd prefer to keep it like that. And relations have no clue that commands exist.\n. > Maybe a silly question, but how is an Update command different from a relation#update method, as far as functionality and use cases go? Or are they just two different ways to update data?\nRelation#update is dumb and simply sends input to the storage through its dataset interface. Command is more sophisticated, it can check if count matches with the result setting (:one or :many), it can use an input handler to coerce some values into special types (ie an array into pg-array in rom-sql) and maybe more, depending on the adapter.\n\nWith loaded relations, is there a preferred way to apply a command to them? My use case is that I have a relation with loaded data, and I want to update all records in the relation without having to reload the relation (to get record_id's).\n\nWe didn't have a use case like that so far but a specific adapter could implement that, a loaded relation has a reference to its source relation so you have the pieces in place.\n. @aflatter that mapper dsl has access to all attributes so you can use that I suppose. It's a nested array like [[:id], [:email, from: :user_email]].\n. @aflatter we removed \"schema\" concept in 0.6.0 so I'm not sure how your adapter defines a schema. Now you need to define all attributes in your mappers.\n. @aflatter can we merge this in for a good start? We can add inferring key names later or tweak transproc to not require those keys, or whatever else that's needed. This PR starts to gather dust and I'm pushing now to release 0.7.0 in May :)\n. This is merged :tada: \n. Do you have a use-case like that? I must say I've never seen such a structure.\n. I copied this issue to rom-mapper repo https://github.com/rom-rb/rom-mapper/issues/11\n. This is basically an ungroup operation. We could consider adding it but just like you I don't see any use cases for that now.\n. Let's do it then. ROM must be the most advanced data mapper in Ruby after all \\o/\n. Shall we put nils before numbers?\n. I'm just wondering what the order should be, should it be nil, 0, 1 or 0, 1, nil :) Some dbs allow you to configure that behavior.\n. I agree with @cflipse - anybody up to fixing it? I'm planning to release 0.7.0 next Monday. I'm done with my tasks and won't have much time to do anything else.\n. Fixed via 74b74dc\n. This is a super important subject to discuss. My way of thinking about it initially was that we're gonna treat specific constraint violations as validation errors too that were raised by the db backend (sequel in our case). Then you are free to handle them however you want, ie you may re-raise the error if you want.\nI'm not sure what the problem is with re-rendering the form. What no method error for []? rom-rails should wrap those errors with whatever is needed so that they can be handled easily. I wouldn't go as far as trying to treat them as the same kind of a validation error form the ruby side (ie unique constraint validation vs ruby AM uniqueness validation), because semantics are different. But I think it should be possible to just handle constraint errors on the UI layer by simply showing an error message that it failed and please try again. We're talking about edge cases here but they happen, right.\nYour code can handle that error, you've got original error and you've got command error which wraps it. So it's a matter of handling it properly.\n. Yes that was my idea, not to choke on those errors and handle them gracefully and simply treat db constraints as your second defense against corrupted data.\n. What would it do specifically?\n. Ah OK so we're talking about a file-based adapter targeting json. Yes this\nsounds good. It would be very similar to yaml/csv adapters.\nOn Sat 18 Apr 2015 at 18:40 Drew Dara-Abrams notifications@github.com\nwrote:\n\nPersist object data to JSON files, as an alternative to YAML or CSV\nformats.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/205#issuecomment-94179659.\n. Yeah that is the plan actually. Think we're getting there with csv yaml and\nnow json adapters having so much in common.\n\nOn Fri 7 Aug 2015 at 12:10 Andy Holland notifications@github.com wrote:\n\nThink it would be better to have a rom-file adapter, then plugin an\nencoder/decoder each would take a string and convert to the required\nformat, kind of like how rom-http will work\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/205#issuecomment-128663845.\n. Closing this one as we have rom-json now :boom: \n. Thanks. I knew about it and it was mistake to use it in specs where order is significant of course.\n. Does it work when you use call instead of set?\n. OK the fix is simple, add set alias to Command::Composite but this makes me think we should always just use call/[] :/\n. I'd say we should deprecate aliases on commands and stick to #call and #[]. Thoughts? /cc @aflatter @splattael @maetl @cflipse \n. To make it feel less awkward. With the opposite result :)\n\nOn Wed, Apr 22, 2015 at 11:44 AM Mark Rickerby notifications@github.com\nwrote:\n\nI'd say we should deprecate aliases on commands and stick to #call and #[]\nWhat was the original purpose of the aliases? To make the API more\n\u2018verb-oriented\u2019 or something along those lines?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/209#issuecomment-95101900.\n. Hm are we sure we want to have that error defined here?\n. The only place where we have \"association\" concept is rom-sql at the moment. Hence my question.\n. For now you can use sequel's graph directly. We're missing support for many extra options that Sequel API has.\n. I'm not sure how to add additional ON criteria but I added support for :conditions and setting custom association name. See referenced commit.\n. OK now I know how to do it I just need to know what the interface should be. Any ideas?\n. I know how to do it. It's gonna be messy for many-to-many probably. Any idea how the interface should look like?\n\nruby\none_to_many :tasks, on: { title: 'Blah' }\n??\n. Done here\n. So, this is it, eager-loading. Thoughts? /cc @cflipse @aflatter @splattael @gotar @maetl \n. I should mention that this adds eager-loading only to relation API. Support for mapping eager-loaded relations will be added in a separate PR\n. Thanks @maetl for this awesome feedback. Let me try to reply:\n\nIs #eager_load the right name in the high level API? It describes what it is rather than what it does, and requires a bit of context around ORM patterns or experience with ActiveRecord to understand what it means, which feels a bit out of place with the rest of the API. A simple verb like #load, #fetch, #materialize, #embed, #combine, etc, might be more expressive.\n\nI used eager_load because that's how it's called in other Ruby ORMs although method names are different (AR's includes Sequel's eager). I'm absolutely happy to rename it to something shorter and more descriptive. Maybe combine would be good since we are combining results from multiple relations.\n\nUnlike the rest of the ROM::Relation interface, it\u2019s not immediately obvious at a glance what structure the results are returned as (nested objects? flat tuples? callable proc?)\n\nIt returns parent relation with children in nested arrays. ie: [users, [tasks, [tags]]]. So left is parent and right are children. Mappers will be able to collapse that into an aggregate.\nWhen I say \"it returns\" I mean that by calling it you get that result. This is a common pattern used for all ROM objects - they respond to call and also relations are coercible to arrays.\n\nThere\u2019s a bit of an inside/outside ambiguity with the relation style\u2014#eager_load is only available on the Lazy relation instance, which may confuse people who are drawn to trying to encapsulate these kinds of operations behind methods in the relation declaration itself. Some guidance around what does and doesn\u2019t go in the relation classes/DSL would be useful (something to consider for the docs I guess).\n\nYes this is something that must be documented. Lazy and friends are interfaces for composing relations and sending data through data-mapping pipeline whereas \"plain\" relations are meant to be simple data-access encapsulation layer and nothing more.\n. > Additionally, it might be good to be able to expand nodes in some way ... maybe Graph#eager_load which returns a new graph at the same level, with the additional ags appended to the node list? Allows for gradual construction, still.\nYep I was planning to add that later on, I want to tackle mapping part first though as it may influence Graph API (it probably won't, but who knows).\nFYI: compose has got 3 thumbs-up already (:\n. @cflipse @maetl thoughts? :)\n. OK let\u2019s fix remaining issues (or at least try) and push rom-rails next\nweek :)\nOn Sat, May 9, 2015 at 2:42 PM Chris Flipse notifications@github.com\nwrote:\n\nThis is fixed, but we'll want to cut a new release of rom-rails soon, to\nget this fix out in the wild.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/215#issuecomment-100474882.\n. :tada: :tada: :tada: \n\n/cc @cflipse @gotar @maetl @AMHOL \n. OK I also added support for collapsing array into a hash. I also checked it against rom-sql...works like a charm.\nSo, any thoughts? I'd like to merge this in :)\n. @cflipse my strategy has been:\n- get stuff working based on mapper integration test\n- test it out in the wild\n- move from integration down to unit/rom/process/transproc with more detailed specs and potentially simplify previous integration specs to only test the high level stuff with a happy-path scenario\nEventually mapper integration tests will be greatly simplified and complex logic will be tested in the unit tests. It's an ongoing process.\n. This is now merged. If you have any more comments please do let me know. I'll incorporate any feedback directly on master...now I just gotta move on due to my time constraints :(\n. What does this option do in AR? Runs validation on Tasks.user scope?\n. This is now done via rom-rb/rom-rails#36\n. Yes this is definitely a bug. When I added this feature we didn't have a way of setting up a custom dataset name. So, relation name was also dataset name. This must be taken into account now in both association DSL and then graph_join.\n. Not really, it's not a problem. Commands use relations but each relation exposes its dataset so a command could use dataset directly, in fact rom-sql does that in a couple of places.\n. Fixed via rom-sql#25\n. I'm leaning towards Datastore because it would play nice with Dataset. OTOH only exposes access to datasets, so hmmm maybe Gateway? As in a gateway to access datasets?\n. Yes that's the plan\nOn Sat 9 May 2015 at 08:54 Peter Suschlik notifications@github.com wrote:\n\nI like Gateway!\nShould we deprecate the usage of Repository somehow to make the\ntransition easier?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/219#issuecomment-100436987.\n. Yeah, like gateway to another realm, gateway to another dimension or just gateway to postgresql ;)\n\nAnyhow, do you think it's reasonable to schedule this change for 0.7.0? It's a massive rename + deprecate work but shouldn't be hard, just tedious. Hmm.\n. I was thinking about May 20ish as the release date. I have to admit that this change would be very low on my personal priority list so help would be appreciated.\n. Oh and regarding deprecations: no, we don't have anything in place yet. I think we should put something together as deprecations is not something we'll manage to avoid after all.\n. Can we shoot for 0.8.0 with this mass-rename/deprecation? I added Deprecations module to rom/support which can be used for this easily.\nAre we done deciding on the name? I'm good with Gateway :)\n. Source is a bit too vague, no?\n. That would be awesome. I actually start thinking about wrapping up 0.8.0 before RubyNation (June 12th). Stuff that's schedule for this release should not be very time consuming...guides on rom-rb.org come first though, that's my current focus.\n. Do you have a rails app where there's no :default repository and only custom one is set?\n. It's now fixed as we check if AR is present and only then we set default if it wasn't set already in an initializer.\n. Looks good to me, I believe this option is actually useful. Thoughts? /cc @cflipse \n. why did you close it?\n. Oops, seems like this also includes commit with order refactor in memory adapter :/\n. Frankly this is just one piece of the whole mapper/model setup puzzle. Things we should consider/discuss involves:\n- if attributes must be defined only in mappers then we need to integrate with libs like virtus or anima in order not to have to duplicate attribute names in 2 places (ie load attributes from a virtus attribute set). this could look like that:\n``` ruby\nclass Task\n  include Virtus.model(coerce: false) # no need to coerce\nattribute :id\n  attribute :title\nend\nclass User\n  include Virtus.model(coerce: false) # no need to coerce\nattribute :id\n  attribute :name\n  attribute :email\n  attribute :tasks\nend\nclass TaskMapper < ROM::Mapper\n  model Task # a plugin detects a virtus model and infers attributes\nend\nclass UserMapper < ROM::Mapper\n  model User # a plugin detects a virtus model and infers attributes\n# we override :tasks (that's brittle) or...\n  combine :tasks, mapper: TaskMapper\n# ... we could infer that from virtus attribute but that would require meta info on\n  # virtus side which would pollute model definitions with mapping-specific bits\n  # ie attribute :tasks, combine: true meh\nend\n```\n- start treating mappers as more lower-level interface hidden by ROM and infer entire mapping definitions from models automatically, this would require a ton of additional info on the model side though, with various ROM-specific extensions, it would pollute 3rd party libs and I'm not really sure it's a good idea. But needs a discussion nevertheless.\n- stop using models and create tiny data capsules and simply map to them, I'm leaning towards this more and more, this would mean dropping all model libs like virtus or anima and map to minimalistic objects where the only difference between hashes is having attr readers. This would obviously be extremely opinionated but we could easily have that as a promoted and recommended feature. Nobody stops you from mapping to your classes though but if we decide to make auto-generated classes a recommendation then we won't have to spend time figuring out how to integrate with 3rd party model libs\n. We need more time to figure this stuff out. I actually like clean entity definitions that simply list attribute names and embedded object types. Mapper definitions are much more complex. This makes me think it's not a good idea to treat mapper as a source of knowledge about the application data-structures. Not to mention that mappers are not part of the domain layer, entities are. So I dunno, a consensus here would be to turn it on by default but have a way of inferring attribute names from entity classes like I mentioned. Maybe we should try to do it now. Performance impact won't be huge I believe.\nAs you can see I'm bouncing back and forth with this :)\n. @cflipse yeah that's a good point, domain entity definitions should be separated and not concerned with mappers or anything rom-related\nI also like your argument about knowing what a mapper does by just looking at it. Making mapper reject keys by default would be an implicit behavior. I'm not sure why some people made the assumption it would do that. Probably because that's how attribute definitions work in libraries like virtus or anima.\nI really think now it's a matter of good documentation. There's a learning curve here and we won't be able to make ROM immediately obvious for everybody. What we can do is to minimize that learning curve of course but I believe we can't make everybody happy.\nThe interesting thing about using ROM is that you define your entities and value objects like you want them to look like and then implement relations and specify mappings so that you will get the expected result. I must admit it's such a significantly different workflow when compared to AR and documenting it is crucial.\n. Yep I guess we're reaching a consensus here that it should be disabled by default, right?\n. OK then, time to close this one. Thanks for your input!\n. OK awesome work. Please merge once travis is green.\n. This now doesn't merge because of a conflict with CHANGELOG + specs are failing :/\n. That's an interesting edge-case. The fix looks good. Merging in - thank you :)\n. ps. in the future pls pls create topic branches in the canonical repository\n. Perfect :)\n. as is an alias of  map_with and we still haven\u2019t decided which one is\nbetter :)\nOn Thu, May 21, 2015 at 4:32 PM Caleb Wright notifications@github.com\nwrote:\n\nI agree that documentation is immensely useful, but it's better when the\ncode is clear without it. Both are needed :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/235#issuecomment-104298857.\n. btw you can pass multiple mapper names there ie rom.relation(:users).map_with(:entity, :view_presenter) which for me is an awesome feature :D\n. me too, it reads nice imo just like you said. I guess we need to make a decision and stick to just one for 1.0.0 :)\n. Let's see what people prefer and decide for 1.0.0 how it should be named. Closing this for now.\n. a fix is as simple as adding alias_method :[], :call to ErrorWrapper, I think\n. Any ideas how to display the error so that it's relatively easy to figure out what went wrong?\n. This issue was moved to rom-rb/rom-mapper#17\n. We need a test showing expected behavior :)\n. yes please, in general no PR will be accepted without tests, even if a change is trivial in terms of implementation.\n. awesome @kwando :)\n. ugh, why have I missed that one? now it doesn't merge cleanly ;(\n. This issue was moved to rom-rb/rom-mapper#10\n. I believe it's a matter of defining Graph#combine which does self.class.new(root, nodes + *args) Will take a look tomorrow\n. @cflipse <3 that was a massive PR :)\n. @cflipse I just went through 90% of adapters and did the rename there, all went smooth!\n. Correction - 100% of adapters are updated now and roda/lotus/rails too\n\nOn Wed, May 27, 2015 at 1:45 PM Chris Flipse notifications@github.com\nwrote:\n\nExcellent. :D\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/pull/243#issuecomment-105880800.\n. Yeah this will be addressed prior 1.0.0 for sure. I'm reluctant when it comes to hooks too although I have to say that it's a pretty neat trick in this case ;)\n\nI guess having RelationInterface module ain't that bad huh?\n. This will work now starting from 0.9.0 as Lazy behavior was merged into Relation and adapter DSL is no longer hidden so we don't mess with method_added and exposed_relations is no longer needed.\nOne small caveat is that if you want auto_curry to work with methods included from a module you will have to manually call auto_curry name_of_the_method.\n. Yes all exceptions end with Error word. Would be good to stay consistent.\n. Hmm one more thing - it would be the same situation with group foo: [:bar, :baz] no? This one should also raise if somebody tries to set mapper there.\n. Thoughts? /cc @maetl @AMHOL @gotar @nepalez @cflipse \n. Hah awesome :) I'm gonna improve tests and merge it in tomorrow probably\n. lol wat :D. The reason why it happens is that lazy relation sets its internal mapper\nregistry to an emtpy hash by default. A simple fix is to replace it with\nMapperRegistry.new which raises an error when mapper is missing.\nOn Fri 29 May 2015 at 19:14 Carlisia Campos notifications@github.com\nwrote:\n\nWhen a mapper is missing from the registry, it should throw an error.\nInstead, it is returning nil.\n \u00bb 4.2.1@2.2.0\nOM::Datastore.relation(:widgets).as(:widgets).one\nNoMethodError: undefined method `call' for nil:NilClass\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/251.\n. wow you really got into the mapper didn't you? :)\n. Gah that's just...\n\nAnyway, that method_missing will be gone prior 1.0.0. Each relation will have its own lazy-class that will decorate relation's methods to provide autocurry mechanism and so on.\nNow you just gave me a reason to do it faster :)\n. Lazy with method_missing is gone so this is fixed too :)\n. @c0 when you say DSL - what do you mean exactly? Setup DSL (ROM.relation(:foo) {} etc.) or in general DSLs that come with core classes (Relation.gateway, Command.register_as etc.)??\n. Yeah I feel like the time is right already...I mean after 0.8.0 release. So 0.9.0 would be a huge release with gems split and lots of internal clean up and getting rid of global setup and implicit registration etc.\n. So, having second thoughts on rom-commands and rom-relation simply because those are abstract interfaces, practically speaking. Even though you can use ROM::Relation.new([]) it still doesn't seem to be useful enough to justify having a separate gem for that.\nMaybe we should have relation and commands part of rom-core as abstract interfaces required by adapters?\n. After some further chats I think this would make most sense:\n- rom-core - support libs, core APIs + environment + relation + command\n- rom-mapper - self explanatory\n- rom becomes rom-core + rom-mapper meta gem\n. \n. Done. we ended up with rom and rom-rb/rom-support and rom-rb/rom-mapper\n. This:\n``` ruby\ngroup :contacts do\n  attribute :address, from: :email\n  attribute :type\ngroup emails: [:address]\nend\n```\nis a weird way of defining mapping, makes me think we should remove this syntax, because it's the same as:\n``` ruby\ngroup :contacts do\n  attribute :type\ngroup :emails do\n    attribute :address, from: :email\n  end\nend\n```\nIn general if a nested transformation requires mapping individual keys then those should be defined within the block, not at the root level. If you want the mapper to move keys from root to a nested structure then this is how it should be expressed.\nI agree that this should work more consistently but we should probably think how to simplify the interface rather than making our lives harder by changing code so that some edge cases are covered while maintaining more complex interface.\nNesting should work consistently in multiple levels, that's of course something which must be addressed, but if group/wrap foo: [:bar] causes headaches - let's remove it, and only use block syntax.\n. Thanks this is wonderful. Could you update changelog in master?\n. Can you show me some code examples?\n. forms implement AM::Model interface so I'm lost right now\n. If you want to use a PORO then it must respond to AM stuff, there's no way around that, we just need to live with this\n. This issue was moved to rom-rb/rom-rails#47\n. Sorry you've been affected by this :) We're pushing 0.8.0 tomorrow (unless some unexpected blockers are found).\n. This one's tricky. I don't have time now but I'll take a look later today and try to figure it out :)\n. haha! I thought today \"well, we need to have a way to specify a sequence of transformations in a single mapper to avoid having to use multiple mappers\"\nso I guess we should just do it, question is: how the dsl should look like?\nruby\nclass SequenceMapper < ROM::Mapper\n  sequence do\n    # stuff defined here will be executed one-by-one\n  end\nend\n??\n. hmm yeah I think I like that\n. @dekz that would be awesome; it should be a simple addition as underlaying pieces are reusable. The contract should be that if there are steps, we only build up a mapper from those, if there are steps + top-level definition, we raise an error. step block would simply use AttributeDSL to gather attributes and store them in \"steps\" array and then you just build up each step using transproc compiler and compose into a single transformer and :tada: \n. I want to push 0.8.0 later today but I think I won\u2019t make it > - <. Steps\ncould be added in 0.8.1 or 0.8.0 if we can make it.\nOn Wed, Jun 3, 2015 at 10:09 AM Andrew Kozin notifications@github.com\nwrote:\n\n@solnic https://github.com/solnic should this step to be included to\nthe next release?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/263#issuecomment-108238159.\n. I agree. It's misleading because what it really is right now is a shortcut so that you don't have to write attribute :foo, from: \"foo\".\n\nMaybe we should make it so that it becomes a preprocessing step that symbolizes everything (deeply as a option)?\n. I need to think this through, definitely not something doable for 0.8.0 though.\n. This issue was moved to rom-rb/rom-mapper#9\n. This stuff ain't finished. We're looking at integration with Unsound gem from @pdswan\n. OK let's add those methods. Any volunteers? :)\n. This was done in #310 \n. How about assuming a mapper always has an array of transformers and then:\nruby\ndef call(relation)\n  transformers.reduce(relation.to_a) { |a, e| e.call(a) }\nend\n?\n. @nepalez I feel like a Step attribute is an overkill, it complicates header and introduces a new requirement for processors if they want to support step syntax. If we can simply gather steps in an array and call them one-by-one things stay much simpler. WDYT?\n. :boom: :boom: :boom: :boom: :boom: :boom: :boom: :boom: :boom: :boom: :tada: :tada: :tada: :tada: :tada: :tada: :tada: :tada: :tada: :tada: :tada: :tada: \n. Thanks awesome work (:\n. Yeah this makes sense\n. there's embedded which does exactly that:\nruby\nembedded :foo, type: :hash do\n  attribute :baz, from: :bar\nend\n. we do, right now we're riding on rspec-3-3 branch, I don't have a problem with using master. we can switch to the released version later :)\n. In rom-rails we just added it to ROM::Model::Attributes extension that works nicely with commands. You could do the same as @gotar suggests.\n. Actually, we can skip loading that acronym if rails is not new-enough. This shouldn't be something that prevents people from using ROM with Rails.\n. You could build a plugin which generates a UUID for commands.\n. Hah that's cool!\n. Maybe we're missing a require somewhere in ROM :/\n. @kchien actually, I think this won't work because adapter must be setup prior defining any rom components, make sure it is and this problem should be gone\n. Don't put them in test files, they are auto-loaded from app/commands\n. To be able to define ROM components (relations and commands) you need to make sure that ROM.setup was called before that. rom-rails loads initializer where you need to set up configuration, then it calls ROM.setup with provided config and then it loads components from app/#{relations,commands,mappers}.\nWe do, however, need to raise a meaningful error in cases like yours, which I'm going to fix :)\n. I just tried, reload! worked for me. Can we trigger reload after running generators?\n. This issue was moved to rom-rb/rom-rails#46\n. That's a bit tricky. Relation#unique? doesn't know if we're talking about an existing object or not. We also can't just assume id as the primary key. Maybe we could extend the validator so that we can configure different behavior for existing objects and new ones and set some defaults there.\n. This issue was moved to rom-rb/rom-rails#45\n. We now have a lazy-loaded env so this fixes it \\o/\n. Thanks <3\n. Technically speaking we don't support rails 3.0.x but if somebody can provide a patch for this I'm happy to merge\n. This issue was moved to rom-rb/rom-rails#44\n. rom.relations is a lower level sort-of private inferface. It returns barebone relation objects that are used by commands. Relations can implement full crud interface. Which happens in rom-sql but for cud commands should be used as it's the higher level interface of rom.\n. @tpitale gah, yeah I need to remove examples from that readme, they indeed can confuse people.\nYou can check out the new SQL guide.\n. :tired_face: \n. Sorry for not coming with any feedback for so long. rom-mapper was extracted already into a separate repo so I can't merge this here. But I gotta say I'm not sure if it's a good idea to refactor it now. We're still trying to figure out how the DSL should work exactly and also we need cleaner test coverage in rom-mapper before we can make a huge refactoring.\nLet's figure things out in rom-mapper repo :) Thanks for the PR, I hope you at least got some insights into how that part of ROM works.\n. Not really, rom-rails is not sql-specific so that would have to go to rom-sql gem.\n. This issue was moved to rom-rb/rom-rails#43\n. Maybe we should use existing mapper dsl:\n``` ruby\nsetup = ROM.setup(:memory)\nmodule MyCoercers\n  def self.to_batman(args)\n    Batman.new(args)\n  end\nend\nsetup.mappers do\n  coercers MyCoercers\nend\n```\nWe could also add support for instantiating structs through:\n``` ruby\nmodule Transproc::Coercions\n  def self.to_struct(model, args)\n    model.new(args)\n  end\nend\nclass MyMapper < ROM::Mapper\n  attribute :location, type: :struct, model: Location\nend\nmapper = MyMapper.build\nmapper.call [{ location: [123, 312] }] # would turn it into a location instance\n```\n. This would mean we have dependency on Transproc. But maybe that would not be a bad thing. Hmm.\n. @nepalez technically speaking ROM uses its default transformer compiler to turn a mapper header into transproc function, but it's not a real dependency, it is decoupled from the implementation pov\n. @nepalez I think it's nice to keep it separate and leave that option, who knows what people could come up with :) But I'm not 100% sure if it's worth the effort.\n. ...that's why I'm so eager to see how your abstract_mapper + faceter evolve. If we could establish a solid mapper AST that can be used to produce fast mappers then we could have compilers that turn that AST to whatever, be it a transproc function or something else. I also hope that optimizations could be really advanced so that we can keep things very fast.\n. This issue was moved to rom-rb/rom-mapper#8\n. Oh, thanks for reporting that - you are right of course, will fix :)\n. Trying to wrap my head around those changes. Overall looks like a really cool solution with the plugin.\nSo, one thing that looks weird is that we have now Environment which is mutable and then it ends up with @env being an instance of Env. Such environments.\nI'm wondering how to name those things so it's less confusing. We definitely need an IM, mutable object for gathering components etc. but what we want to end up with is a frozen registry of instantiated components.\n. @AMHOL since ROM::Environment is the registry of components (aka relation, mapper and command classes) and ROM::Env is the registry of component objects then I believe we definitely need to come up with better names for those :)\n. :+1: for ROM::Container\n. This issue was moved to rom-rb/rom-rails#42\n. :heart: \n. FWIW I'm working on a higher-level abstraction to simplify this kind of stuff for all the common use cases - it's called rom-repository. Feedback most welcome, will release first alpha in a couple of days.\n. If you already have a nested input there's no need to map it further. Just define a command that takes a client with nested address and that's it. Combine transformation is used to join parent and its child collections in memory using provided join keys. Typically you use it for eager-loading of associations.\nAnyhow, something like that should work:\n``` ruby\nclass CreateClient < ROM::Commands::Create[:sql]\n  relation :clients\n  result :one\nend\nclass CreateAddress < ROM::Commands::Create[:sql]\n  relation :clients\n  result :one\nassociates :client, key: [:client_id, :id]\nend\ncreate_client_with_address = rom.command([\n  { client: :clients }, [:create, [{ address: :addresses }, :create]]\n])\ncreate_client_with_address.call(\n  client: { name: 'a', identifier: 'b', address: { address: 'some address' } }\n)\n```\nLemme know if that works.\n. I would also recommend not using reject_keys since data are coming from your relations that you can trust.\nRegarding composed commands - the input needs to have :address in the root if you configured { address: :destination_address } as it means \"there will be :address key with its attributes and handle it use destination_address relation.\nThis is the latest addition to the API so as you can see error handling is pretty rough :) It's high on my priority list to improve it as I rely on it heavily already.\n. Yes, you need to wrap client inside address because the structure of the input defines hierarchy, so if client has an address it means it must be nested inside address hash.\nUnfortunately for now you need to explicitly define input for commands so that it will reject those extra keys coming from combine commands, I consider it a bug and will fix it soon, commands should skip those keys automatically, so for now do this:\n``` ruby\nclass CreateClient < ROM::Commands::Create[:sql]\n  class Attributes\n    include ROM::Model::Attributes # this comes from rom-rails\n    attribute :name\n    attribute :identifier\n    attribute :address_id\n  end\ninput Attributes\nrelation :destination_clients\n  register_as :create\nresult :one\nassociates :address, key: [:address_id, :id]\nend\n```\nThis will only accept specified keys, it's more like a workaround for now. I'll improve that in 0.8.2. Now I have even bigger motivation :)\n. Awesome to know it worked for you :) Sorry about the quirks, I'll be fixing / improving things in next releases.\nRegarding require issues - I gotta fix that, there's a big emphasis put in ROM on proper requires so that each component should be \"requireable\" separately.\nAs far as multi-step wrap goes, you only need wrap once, in the second step you can access wrapped address with embedded :address, type: :hash { attribute(:created_at) { Time.now } } BUT I would recommend setting default values inside commands as its closer to the database. Model::Attributes supports timestamps macro that will do it for you.\nAs a general rule I try to keep mappers only concerned about the structure of the output, setting values feels to close to the domain or db.\nI'm always happy to provide help, thanks for the kind words :)\n. ps. I reported #294 about that require problem in rom/model\n. I hope things are working well for you. Gonna close this one for now. Please report issues if you have trouble with anything.\n. This issue was moved to rom-rb/rom-rails#41\n. @gotar I would support it as a command plugin.\nWhat do you say?\n. @cflipse I want to experiment with validations that would play nice in rom-model :)\n. @cflipse been thinking about that validation pipelining, it actually makes a lot of sense, rather than having configuration layer for validators we use pipeline composition, it's more \"idiomatic rom\" (I love saying that lol) too.\nSpeaking of which, pipeline operator has been extracted into dry-pipeline gem. I was thinking about turning rom container into a generic container open for extensions. We could store validators there too. I also want to extend mappers to support >>.\n. Yes, unfortunately nobody has found the time to do that yet :) I can push what we have as 0.0.1. It probably needs a couple smaller updates but it shouldn't take too long.\nAre you a RethinkDB user? I've been reading about it and it seems pretty awesome. Would love to try it out.\n. @abernardes aah, I just updated it to ROM 0.9.0.beta in master and configured build on travis\nIt'd be awesome if you could add some features. We'll definitely push a release together with ROM 0.9.0.\n. The adapter has been released :)\n. This issue was moved to rom-rb/rom-mongo#9\n. This is fixed / improved via 176bcff991c9de71250c013dec454d4e737fd250 and 4d1bd2e99fb69b32233f34dd6fcedceb828fa2d7\n. This should raise a no-method error, we blindly forward method calls to relation which causes as() to be available on a command. The only methods that we should forward are relation-view methods, any built-in relation API shouldn't be forwarded.\n. Since we're planning a major cleanup in setup/finalize/env code so let's address it there. I'll close this one for now.\n. @Snuff we need to pin anima version to 0.2.0, looks like latest version requires ruby >= 2.1.0 :(\n. I merged it in, will take care of anima issue in master. Thanks for the PR :)\n. So, if I understand this correctly, the problem is that we don't support restricting relations of update and delete commands when using a command graph.\nThe only API we have to restrict them is proxying to relation and returning a new command with restricted relation like delete_user.by_id(1).call) and there is no way to do delete_user.call(:by_id, 1). I'm wondering if having that would help here somehow.\nRegarding update, there is no API for updating many tuples where each tuple would require restricting a relation, an update is applied to the whole relation, when an update command receives many tuples I'm actually not sure what's gonna happen now. In case of a graph with an update command that receives many tuples we simply cannot support that. Changing execute logic to make it loop through tuples and make assumptions about how a relation should be restricted would be a bit against the design.\nI feel like what we need is a way to configure graph to restrict commands and in case of many tuples it would loop through them and call a command separately. Maybe something like:\n``` ruby\nrom.command([\n  :users, [{ update: [:by_id, [:id]] }]\n])\nthen graph internally would do something like:\ninput = { users: [ { id: 1, name: \"Jane\" }, { id: 2, name: \"John\" } ] }\ninput[:users].each { |tuple| rom.command(:users).by_id(tuple[:id]).call(tuple) }\n``\n. ps. actually my idea applies to bothupdateanddelete` command types\n. Symbols are more concise and were sufficient until now :) We can come up with an API that can use curried commands instead, graph builder simply resolves commands from symbols so if it receives a command already it can just use that.\n. So how about:\nruby\nrom.command(\n  [{ users: :user }, [\n    { update: [:by_id, ['user.id']] },\n    [:tasks, [{ update: [:by_user_and_name, ['user.id', 'user.tasks.name']] }]\n  ]\n)\nWhere we have a structure [relation_name, { command_name: [relation_view, [paths_to_args_from_input]]. I believe this could work.\n. @cflipse I made your spec pass in #313 (with a couple of small corrections in the spec itself) :tada: \n. I wanted to stick to ast-like structure and using array/hash so that it's easy to build a DSL on top of it. I treat this interface as a lower-level thing. We could easily support procs too. I can experiment with this and see how it goes.\n. @cflipse ended up with proc-only approach, thanks for suggestion, could you test if it covers your use-cases? I'd like to refactor it and merge it in soon\n. @cflipse bump ;)\n. This is now fixed as you can pass procs that receive command + input so you can properly restrict the relations. There will also be a new DSL for building up a graph via #323 \n. I'm gonna wrap this up, a couple of use-cases are not supported yet and it needs way better spec coverage, I'll work on that and we should probably consider releasing 0.9.2 after it's merged.\nLemme know what you think\n. I merged this in even though I remember you had some use-case that is still not covered but...it's already a step forward so it's valuable to have that part done already. Please report an issue describing other use-cases that you like to have supported.\n. I think I know what's going on, you have stringified keys but you use symbol keys in your mapper, we should add support for symbolizing keys in lower-level adapter mapping in rom-json, like in rom-yaml, I think\n. Seems like this is an adapter-specific thingie, so closing it here.\n. FYI we have a schema interface in Relation now, you can use it to define all attributes along with types and its meta-data. This can be used as a foundation for inferring migrations, including an auto-migration system that we had in DataMapper.\n. Closing this one since we do have a separate project now, not released yet though.\n. yes, it's always needed :)\n. Thanks :) I'm sure my vim would format a couple of things differently but it's fine ;)\n. Actually let's keep those tests, it's somewhat important to have that code working until we reach 1.0.0 final :)\n. w00t, we killed some mutants, thanks :)\n. @cflipse check this out, thoughts?\n. Can I have some feedback on this? /cc @cflipse @AMHOL @nepalez @gotar @kwando @robinetmiller @endash\n. @endash the intention here is to have something as concise as possible because defining a more complex graph can be messy. additional receiver would add clutter but if people don't mind that I can change that to yield a receiver.\nAs far as \"english-language descriptions\" go:\n- create(:users, from: :user) >> create(:tasks) means a user tuple will be inserted into :users relation and the result will be passed to create(:tasks) command which will insert task tuples and associate them with the inserted user tuple. The final result is a user tuple with its task tuples\n- create(:users, from: :user) >> (create(:tasks) + create(:books)) means the same, except we're inserting tasks and books for the same user\n@kwando I thought about syntax that would describe input structure but it's a bit hard :) I actually think current syntax does express the structure\nI also thought about this:\nruby\ncreate(:users, from: :user, create(:task), create(:books))\nThis would pretty much boil down to a single function call to build the graph\n. @endash this looks nice, probably easier to grasp than my operator-based-kung-fu.\nNow, who wants to implement it? :joy: \n. @endash if you can change current Graph::DSL in a way that its call method returns the expected structures everything else will just work, so like you said - it should suffice :)\n. @endash looks good, one thing syntax-wise that should be different is c.create_user vs c.users(:create), I think this way it will be simpler to implement and nicer, basically the receiver would use method name as the rel name and its arg as the command name, so c.users(:create) means :users relation and its :create command. Those names correspond to register_as values of relation/command. WDYT?\n. @endash yeah this looks better :+1: \n. @robinetmiller I agree, although I just realised there's a small drawback - command graph supports passing procs for update/delete commands, and now we use blocks for building up the graph, so I dunno how to tackle it /cc @endash \n. Correct. The block receives the input of a particular node and its parent\nnode input if it's present so that you can restrict command's relation\nOn Sat, 17 Oct 2015 at 18:46, Christopher Swasey notifications@github.com\nwrote:\n\n@solnic https://github.com/solnic @robinetmiller\nhttps://github.com/robinetmiller I'm going to look at that more closely\ntoday. I've commented out the one test for procs, and made a note in the\ncommit. To make sure I understand: the procs limit the scope, correct? So\nthat\n{ user: :users },\n  [\n    { update: -> cmd, user { cmd.by_name(user[:name]) } },\nThe update gets applied to that subset of the relation?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/pull/323#issuecomment-148933480.\n. @endash I guess we could have something like:\n\nruby\nrom.command.update(:users, from: :user) do |user|\n  user.update(tasks: -> cmd, user, task { cmd.by_user(user).by_id(tasks[:id]) }).each do |task|\n    task.update(tags: -> cmd, task, tag { cmd.by_pk(task[:id], tag[:name]) })\n  end\nend\n. Hmm maybe s/match_records/restrict/ would be better?\n. @endash this looks cool!\n. This looks good. I'll make a couple of minor tweaks later in master. Thanks for the work @endash :)\n. Yes, it looks odd I know. The reason for this is that result can be set to either :one or :many which introduces complexity in the pipeline, that's why we need to wrap results inside arrays so that mappers can handle that.\n. I'm wondering if we could introduce this on the dataset level and create an extension for relation that would allow us to tell the dataset which gateway should be used. A gateway with multi-db setup could return this special dataset by default and inject all other gateways to it (also configured). This of course would require some tweaks in the rom setup code because right now setup asks each gateway for datasets so they don't have access to all other gateways, but this can be changed to support this feature.\n. @sagmor you're right, we could handle that easily from the Container#relation interface, we have all the things there but you will always get a vanilla dataset, so if that's acceptable it seems like we could easily support this feature like you suggest\n. Yeah I think we should remove global stuff completely (along with wisper stuff) for 1.0.0. Frameworks can automate registration in a simpler way. The downside is that we won't be able to have a simple way of setting up ROM \"standalone\", it will require config, manual registration, and finalization. This makes me think we could introduce a simple \"file loader\" that would infer component class names from paths and auto-register them. It would be 10 x simpler than inheritance hooks and wisper. It's something that was already proposed months ago.\n. Yes, this sounds like a use-case for a plugin interface.\n. I like the name, although I'm not sure if it should be an alias to to_a or to call.\n. Closing this since I don't think it's a good idea after all. one and one! has special meaning, as they raise errors, #many would be different as it would be a simple alias, so it makes no sense.. Shall we wrap it up for 2.0 release in June?\n. I'm closing this one as there was no activity for almost a year.\n. Closing this one since there was no follow-up for many months. Feel free to re-open if you'd like to work on it.\n. Does it work when you do relation(:plants) in the mapper class?\n. This is weird. I have a bunch of custom mappers and it works fine. Can you try w/o the block config?\n. This works correctly but the correct incantation is:\nruby\nrom.command(:sites).as(:api_mapper).create.call(name: 'HELLO WORLD')\n. no idea what's going on with travis build, but I merged it in nevertheless, let's see what'll happen on master build. thanks!\n. @rpelyush just fixed it on master, thanks for pointing this out\n. We're missing docs and a couple of convenient features (like command support for repos) but ROM is production ready in the sense that people are already using it on production.\nWhether it's too early for you or not, depends solely on your needs, expectations and your willingness to get involved in the project as a contributor. ROM is not ready for the mainstream, yet, due to the lack of some convenient APIs and lots of holes in the docs. It is the priority for this year to change this situation, though...\nFeature-wise it's already very powerful, but I would have to know what kind of project you'd like to use it for, which DB, framework etc. you're considering, in order to provide better feedback.\nRegarding Hanami's model layer - it's very young and @jodosha is still exploring how its API should look like, including experimenting with ROM to see if it could be used in Hanami's model.\n. Postgres support is pretty good (we use Sequel under the hood), so that shouldn't be a problem.\nI'll update rodakase-blog sample app soon and point you to some examples there. It's using my custom web-stack based on roda and dry-* gems which is a better environment for rom than rails.\n. @blelump I wouldn't recommend leaving Rails when you've got a project to deliver and not enough time to learn and experiment. ROM is not really ready for the so called mainstream usage. Like I said in the previous comment, if you're open to tinkering with stuff, collaborating and maybe even contributing, then it's probably the best moment, as we're still working on various core features, documentation etc. But if you've got a project to ship (esp if it's for a client) and facing some deadlines, then I'd say leave ROM for now and do it using technology that you feel comfortable with.\n. :+1: \n. Lemme know if you need help with coming up with a test case for that fix.\n. We should revisit this prior 2.0 release (scheduled for June). I'm gonna re-open.\n. This has been finally addressed in #354 \n. Are you able to load this enormous dataset using plain Sequel? Ie:\nruby\napples.dataset.where(conditions).to_a\nThis would use plain sequel dataset to load hash objects.\nI need to know if this happens inside rom or in some lower level, like rom-sql adapter backed by sequel datasets.\nIn general, you should really not try to load so many objects, it's gonna kill performance completely.\n. Does it work without a mapper then? ie apples.where(conditions).to_a?\n. what about apples.relation.where(conditions).to_a?\n. Could you narrow down the stacktrace to the portion which is related to rom-repository? Seems like it's happening somewhere there.\n. I'll try to reproduce it and get back to you. Thanks for reporting the issue.\n. Oh ok. What do you use as the model class?\n. Could you try with dry-types (ex dry-data)? If that doesn't help, could you try another class that simply accepts a hash in the constructor and see if that works?\n. @edward6882990 bump :) did you manage to test this with dry-types? is this still a problem? We're releasing rom 2.0 tomorrow so I'm trying to clean up Issues here\n. @edward6882990 OK thank you. I'll be investigating this, just need to generate 138706 records first :)\n. Thanks for this. The specs should be moved to rom-support. Here we could only verify if command-specific registry has correct behavior.\n. Could you rebase on top of master so that we can get a clean merge?\n. This expanded public API, please add a spec\n. Not going to address this after all. Custom mappers are advanced usage after all.. I've noticed that too, maybe we're not using the right option?\n. @flash-gordon impossible, inflecto doesn't have dependencies\n. @flash-gordon ugh sorry /me disappears from github\n. we should add a dependency on concurrent-ruby to gemspec\n. OK I'm in \"rom-rb mode\" again. How can I help with this?\n. Awesome work man! Please also update CHANGELOG in master :)\n. This issue was moved to rom-rb/rom-sql#72\n. Done in master. I thought this was addressing the namespace issue but it looks like it's a whole new feature :) I'm wondering though why and where do we need this?\n. > It was part of the problem @skrypalyk had with rom-rails yesterday, regarding already having a commands directory, plus I think it should be configurable anyway :p\nOh so having that configurable would fix something in rom-rails? I'm not against this feature, just wanted to know where and how it'd be used.\n\nWhat's the namespace issue BTW?\n\ndis one https://github.com/rom-rb/rom/pull/338\n. There's also #331 that wasn't finish, we could probably make it completely flexible by allowing passing a custom dir/constant resolver\n. Let's hold off with any further improvements until somebody asks for something more customized, then we can revisit.\n. > Should I move internal classes to separate files?\nYes please, esp when we add yard docs it's gonna get longer so a single file would be too big\n\nIs the strategy approach okay here?\n\nIt's perfect\n. Got it merged. Thanks :) I'll try to wrap up a release tomorrow, if I don't make, I'll get back to it next week.\n. We've fixed this in master, right @flash-gordon?\n. Is it still a problem?\n. Closing this since I'm pretty sure setting register_as solves this problem. You need either start setup prior requiring your relation classes, or at least require rom-sql manually yourself. Lemme know if that works. This should be better explained, probably a small standalone example would be best.\n. @alexandru-calinoiu I'll set it up for you in a couple hours\n. @alexandru-calinoiu yeah in 2.0.0 it needs (relations|commands|mappers)/**/*.rb structure, but in 2.0.1 it's gonna be more flexible and configurable (it's already done in master)\n. OK so I'm gonna close this one. I'll add a simple setup example to the docs along with a repo on github, this should help in cases like yours.\n. I'll investigate that prior 2.0.1 release. Optimistic scenario is that it turns out to be something simple to fix and it'll go into 2.0.1. If it's something that needs more changes, we may have to wait until 2.1.0 or even 3.0.0 (in case it'd require a breaking change). Thanks for feedback.\n. That's very likely, that's why I reported this issue about turning inference off by default, so that it's a conscious decision rather than a surprise :)\n. We can tweak commands in a way that if there's an input handler configured which is not the default proc, then we'll compose it with the schema handler. Would that work?\n. From @flash-gordon on November 4, 2016 18:57\nThis is possible to override Command.build method in this way\n``` ruby\n      class Commands::CreateCaseFromModel < ROM::Command::Create[:sql]\n        relation :hoi_cases\n        register_as :create_from_model\n    def self.build(relation, options = {})\n      # pass any input you want, you can access schema's input via relation.schema_hash\n      super(relation, options.merge(input: ...)) \n    end\n  end\n\n```\nThis will do the trick for now ^ But I agree we need to make it more user-friendly :)\nSee sources: https://github.com/rom-rb/rom/blob/master/lib/rom/plugins/command/schema.rb#L16\n. @Kukunin this has been fixed in rom 2.0.2, this illustrates how it works now:\n``` ruby\nrequire 'rom'\nrequire 'securerandom'\nconfig = ROM::Configuration.new(:sql, 'sqlite::memory')\nconfig.default.create_table :posts do\n  primary_key :id\n  column :title, String, null: false\n  column :uuid, String\nend\nconfig.relation(:posts) do\n  schema(infer: true)\nend\nclass CreatePost < ROM::Command::Create[:sql]\n  relation :posts\n  register_as :create\n  input -> tuple { tuple.key?(:uuid) ? tuple : tuple.merge(uuid: SecureRandom.uuid) }\nend\nconfig.register_command(CreatePost)\nrom = ROM.container(config)\nputs rom.commands[:posts][:create].call(title: \"Hello World\").inspect\n[{:id=>1, :title=>\"Hello World\", :uuid=>\"fd2eafb6-30c1-46aa-9a9d-770a90a30a2a\"}]\n```\nNow, schema hash is used as the second processing step, this means that your input handler is used first, and its result is passed to schema hash.\nIn example here we configure our schema with a constrained type for :uuid attribute:\n``` ruby\nrequire 'rom'\nrequire 'securerandom'\nconfig = ROM::Configuration.new(:sql, 'sqlite::memory')\nconfig.default.create_table :posts do\n  primary_key :id\n  column :title, String, null: false\n  column :uuid, String\nend\nconfig.relation(:posts) do\n  schema do\n    attribute :id, ROM::SQL::Types::Serial\n    attribute :title, ROM::SQL::Types::Strict::String\n    attribute :uuid, ROM::SQL::Types::Strict::String.constrained(format: /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)\n  end\nend\nclass CreatePost < ROM::Command::Create[:sql]\n  relation :posts\n  register_as :create\n  input -> tuple { tuple.key?(:uuid) ? tuple : tuple.merge(uuid: SecureRandom.uuid) }\nend\nconfig.register_command(CreatePost)\nrom = ROM.container(config)\nrom.commands[:posts][:create].call(title: \"Hello World\", uuid: 'not-uuid').inspect\n\"not-uuid\" (String) has invalid type for :uuid (Dry::Types::SchemaError)\n```\n. ooops, nice catch. I'll fix it quickly :) thanks for reporting <3\n. @Fire-Dragon-DoL no worries :) it's been fixed in 2.0.2 and released today\n. I wonder if this needs a 3.0.0 bump. Sorry, I wasn't specific enough - I was wondering if we're gonna need a 3.0.0 bump if we kill rom-support but I just checked and all APIs that will be gone are private internal stuff used by rom, so we're good. I hardly imagine anyone using stuff like ClassBuilder etc. because it happens that rom provided that via rom-support. Other stuff (AutoCurry, EnumerableDataset and Options) will be moved to rom core so it won't change at all.. Very good point :) Are you planning to move stuff from support to core too?. > I fell off my motorbike and got some spare time lol\nO_o glad it's nothing serious. OSS contributor - level hard ;). \u2764\ufe0f \ud83d\udc9a \ud83d\udc9c \ud83d\udc99 \ud83d\udc9b . > ROM::Options (I guess we can use dry-initializer, I'll give it a try)\nIn order to do that we must verify performance. Options are used literally everywhere and rom, as you know, creates new objects instead of changing them, so initializers must be fast :). @flash-gordon if you checked that already then it's fine :) unless you don't feel strong enough about it. > Well, it was a while ago, things have changed. Now dry-initializer is slower, but that's because of ... dry-types. This is only true when we check types, otherwise dry-initializer 2x-3x times faster than ROM\nThis is fine, and even if it turns out to be a problem we can tweak it.. Aah! Thanks for help @myabc \nI think you just want to add namespace: true because that will make auto-registration assume that the root dir of components is the namespace name. If you pass a namespace name explicitly (which must be a string as Alex mentioned) then auto-registration will load files from the path that you provided but it will not assume Relations and Mappers namespaces, so in this case LibraryApiClient::Books would be the expected relation class when you set namespace: \"LibraryApiClient\".\nAnyhow, just set namespace: true and it'll work (I checked).. using map_with (as is just an alias for that) discards auto-mapping in repositories, that's why this happens. We can probably fairly easily tweak this so it respects providing a model class along with any previously set mappers.\nThere's a related issue https://github.com/rom-rb/rom-repository/issues/12 where I was opposed to this feature, but now I'm on the fence, maybe we should allow it.. > I'm not sure what you mean by auto-mapping though\nauto-mapping in repository is one of its main features, it means that when you use repositories, mappers are generated automatically for you. In example converting results from relation graphs are automatic, and you get back aggregates; or converting relation tuples into custom models via as(MyModel)\n\nNot sure what you mean by \"setting model\" either\n\nSetting a model is a rom-mapper feature, it's just class UserMapper < ROM::Mapper; model User; end. This type of a mapper is created automatically for you under the hood when you use as(User) in repositories\n\nIf you decide not to add the above as a new feature, can we modify the behaviour so 'invalid' code like my original example fails noisily? Would reduce confusion.\n\nYes, that's why the original issue I linked to is still open. I'd like to discuss this with more people though, I'm not sure what we actually want to do :). > also we need to do something with dry-rb/dry-core#7\nI took care of this. Released dry-core v0.2.2 with ClassAttributes and rom core master uses it already. So, Option is the very last bit...:). @flash-gordon I rebased this on top of master and resolved conflicts. @flash-gordon great, I'm gonna check it out tomorrow (travelling today without my laptop). I pushed a cosmetic change before merging. Thanks @flash-gordon and @nepalez for helping with this, it's such a beautiful example of code reuse between dry/rom :). @timriley @flash-gordon any thoughts on this one?. @timriley cool, FWIW I wanted to do this in rom 2.0.0 but ran out of time O_o but now it's a must-have because repos need this badly. I should add that inferrer can be extended to infer :read types based on various criteria. Good example is jruby + sqlite which for some reason doesn't coerce date/time strings (as they are stored by sqlite) into date/time object, we can easily solve this kind of discrepancies between different rubies/dbs/drivers :) /cc @cflipse . I finalized this in master :). the inflector can't possibly know that vo should become VO so you need to configure it properly. I don't know if inflecto supports this to be honest, but if you're using ActiveSupport::Inflector then it can be done there.. What would that custom namespacing strategy do?. It'd be good to update docs with information about inflections. I think we don't need extra strategies or ability to define your own. If your setup is not typical you can always just go through your dirs and register components manually via Configuration#register_* methods.. @pnomolos looks like inflecto doesn't support registering custom acronyms :( I also looked into hanami inflector, but same problem there. So you either need to use AS::Inflector or just register your components manually. Thanks for reporting this. I'll fix it in next version. I'm curious to know how you ended up with this?. Hah fantastic :) I'll fix, thanks again. This now raises:\n/Users/solnic/Workspace/rom-rb/rom/lib/rom/relation/curried.rb:42:in `call': curried Tasks#for_user relation was called without any arguments (ArgumentError)\n        from /Users/solnic/Workspace/rom-rb/rom/lib/rom/relation/graph.rb:90:in `call'\n        from /Users/solnic/Workspace/rom-rb/rom/lib/rom/relation/composite.rb:21:in `call'\n        from /Users/solnic/Workspace/rom-rb/rom-repository/lib/rom/repository/relation_proxy.rb:51:in `call'\n        from /Users/solnic/Workspace/rom-rb/rom/lib/rom/relation/materializable.rb:20:in `to_a'\n        from tmp/repros/382.rb:82:in `with_tasks'. This will be auto-inferred in rom-sql 2.0 but for now you need to do:\nruby\nbelongs_to :users, as: :author, relation: :authors, foreign_key: :author_id\nThe reason why this is needed now is because when associations are defined we don't have relations yet.. I'm gonna close this one since it'll be improved in rom-sql 2.0 and it's on the roadmap. I don't know how this service works, but we do keep an up-to-date CHANGELOG all the time. So I'm not sure what we're supposed to do to make it work with sibbel. I like the idea so I'd appreciate any help with integrating.. OK I'll start including release notes in tag commit messages, this should do the trick. How's performance?. re schema caching, we need to do something smarter because input_schema needs to be recalculated when schema was projected in some way. Tests run for me almost 2 x slower. I think our ultimate solution for dry-initializer + rom-rb should be disabling undefined functionality, it adds complexity that isn't justified in any way. WDYT?. So, the PR on rom-mapper side looks good, so last thing to do is to update things here so the build can pass :). This is cool indeed. I wanted to add it too. So +1. > Gotta say the plugin infrastructure is a bit messy and I guess will require some refactoring before 4.0.\nYeah it should be improved in 4.0. @flash-gordon schema needs to be established already because it is needed in view DSL, so you can't postpone it until finalization :/. @flash-gordon hmm, right, view schemas are finalized here. I guess if you move things around so that schema dsl can be extended in the right moment, things will continue to work.. @flash-gordon sounds good!\nre bootstraping, it crossed my mind many times, but it's such a complex part of rom that I never had the energy to tackle it. There was also a long learning curve to understand what's involved in this process, and now we're in a much better position to come up with a nicer approach. We can try to do it in 4.0.. Well, this is pretty awesome. I've left a couple of comments (small things to address).. Looks like rom 4.0 will be more awesome than we thought ;). Resolved via #421 . Thanks for looking into this and opening PR. It's hard to make everybody happy, but that's why we have strategies to cover different use cases.\nAnyhow, re PR - will this continue to work like before, as in when you don't use component names inside namespaces, so ie My::Stuff::Users rather than My::Stuff::Relations::Users? I see you modified existing spec, so I'm not sure if it's a breaking change or not.. Thanks man, I'll check it out on Friday. It's merged. Thanks again!. Turned out yard doesn't support this. it's done. @kwngo hey, thank you :) it's definitely a good candidate, as it's mostly moving things from one place to another.. Cool, let me know if you have any questions.. @kwngo no pressure whatsoever but did you make any progress? We're trying to move fast and hit 4.0 beta in a couple weeks so if this doesn't feel like a good task for you after all, please let me know.. Yes, closing now via #426 . This is cool. I'll merge this in but there will be another small task related to this. I'll report it shortly.. Closing this as it isn't easily solvable at this point. I'll revisit it after 4.0.. > Oj gets a class by its name\nThen all it needs to do is stop doing that and use object.class instead, no?. I'm lost, how does it know which class to use for a particular json hash? This sounds like some kind of magic to me :(. I see, thanks. Well it can't work reliably, previously it worked by an accident. Structs are dynamic classes, we don't guarantee unique names. Maybe we could consider generating unique class names and then it could work, but I honestly can't think of any sensible naming strategy :/. Yeah, it really boils down to the fact Oj doesn't have first-class support for anonymous classes. As I said, it worked by an accident before :). In general I would recommend encapsulating json serialization/deserialization with your own APIs, instead of referring to 3rd party gems, ie Entities::User#to_json and Entities::User#from_json. This way you can at least easily tell that a given entity is used with JSON, and you also hide the details about how it's done exactly.\nI think we can close it?. I'm not sure if we want to support :view option along with wraps, because they use joins instead of composition so it's really hard to tell how such a custom view is supposed to be used. Good news is that in rom 4.0 wrap will be part of the core API (already in master) so that you'll be able to easily define your own relation view that uses wrap and do whatever you want there.\nI'll leave this open for further discussion.. @flash-gordon do you have any idea how this could be done?. @flash-gordon I'm not sure if I follow :). ah yeah, this makes sense. This issue was moved to rom-rb/rom-sql#251. @flash-gordon still WIP but please take a look if you can and let me know if this makes sense. Sorry but I'm going to close this. It seems like it's not worth the effort and creates too much indirection. We can revisit this later in 4.x or 5.0 and this PR can serve as a reference.. No more WIP?. Fantastic work \ud83d\udc4f \ud83d\udc4f \ud83d\udc4f . There's one more thing I should mention - a lot of people asked for a way to mimic polymorphic assocs from AR because they are working with legacy schemas. So, in rom-4 something like this should be possible:\nruby\nclass Admins < Users\n  dataset { where(type: 'Admin') }\nend\nNow, because this would be registered under :admins then Entities::Admin should be automatically inferred, and you can do Admin < User to share common behavior like in STI in AR.. @flash-gordon I'm aware of this, and I'd like to at least give it a shot (I know it won't work OOTB right now). Worst case people will have to define separate relations and configure schemas.. @flash-gordon I made inheritance work, but without schema inheritance as it's tricky as hell due to the fact schema is both get or set schema proc. Not sure how to solve this yet.. @flash-gordon not when you want to set a different relation alias :). if we separate schema reader from setter things should become simpler, we use instance schemas at runtime anyway so class-level schemas can be accessed using a different method. k this is done in master, I added deprecation warnings to rom-3 and rom-repository-1.3 so I'll push new releases soon.. @cflipse yes. > We just should offer them a before/after upgrade plan\nI'll write upgrade notes in the wiki, and this is as simple as:\n``` ruby\nbefore\nrom.relation(:users)\nafter\nrom.relations[:users].map_with(:users)\n```\nand so on, and if somebody is using custom mappers for basic stuff, then it's about removing mappers altogether, so I'm sure folks will appreciate this ;). This is done in master. Great to see this PR opened :) I noticed there's something wrong with code formatting (you can see this in the diff).. @kwngo ok looks good, could you also remove that .DS_Store file that got accidentally added to git?. This is merged, thank you! <3. We need a spec for this too :). @GustavoCaso IIRC we default to relation identifier when there's no register_as defined on a mapper class, which means we'll get an error saying that same mapper was registered more than once in a situation when there's more than one mapper class without register_as, so I'd say let's leave it as it is now.. Yes it's a good idea, I already had cases where I defined it yet-another-time but with a bug and things got broken, so it'd be good to have it solved once and for all.. > What should I do with Schema#with? It's marked as a public API but don't think anyone is going to miss it\nIt's fine if it's gone, just make sure it's deprecated in release-3.0 branch. @flash-gordon I believe we're masters of using yard features nobody knows about, so we can still document it :). @GustavoCaso cool. Let's start with relations then. We can then add more reserved names easily whenever we discover them.. Thanks for reporting this. I'll fix it in 1.x and port it to rom-rb/rom master.. @GustavoCaso it's all yours (:. I'd say we should raise an error if an attribute has whitespaces and no sensible alias was provided. We can't use attribute names with whitespaces because Ruby doesn't allow setting ivars with names containing ws :). Please ask for help on discourse.rom-rb.org. We're using issue tracker for bugs and tracking work on new features. See CONTRIBUTING guidelines too.. @opan no worries, we've changed the policy recently so folks need to learn about this.. Closing this in favor of https://github.com/rom-rb/rom/pull/450. Please rename Json to JSON. You need everything from master:\n``` ruby\ngem \"rom\", git: \"https://github.com/rom-rb/rom.git\", branch: \"master\" do\n  gem \"rom-core\"\n  gem \"rom-mapper\"\n  gem \"rom-repository\"\n  gem \"rom-changeset\"\nend\ngem \"rom-sql\", git: \"https://github.com/rom-rb/rom-sql\", branch: \"master\"\n```\nI had this problem too and I can confirm this is fixed in master. I'll release beta3 later today.. @dikond FYI I just pushed beta3. LGTM \ud83d\udc4d . Same here, please rename Json to JSON. Thanks man :). Unfortunately you're yet another \"victim\" of relation inference. This is a feature that was removed from rom 4.0.0 (still in beta), because it bites people like in your case. What's happening here is that you defined classes after finalizing rom setup, which means rom doesn't know about your relation classes but in 3.x rom infers relations from the database schema automatically but it can't infer associations. Anyway, relation inference is gone in rom 4.0, so this won't happen again.\nPlease check out explicit setup docs to learn how to register your classes manually or use auto-registration feature.. @simonc thanks for the feedback re docs, I totally agree with you. Before 4.0 final is released, we'll revamp the docs completely, it's one of the biggest tasks in this release, actually :). I merged this in already because it does fix the original #435 issue. I will refactor and improve command macros so that specific command types are handled in a better way. This should fix problems with relation views with -1 arity too.. Can this be closed?. Given that we're moving to setting attributes inside @attributes, we can simply introduce a get or read method for reading values and call it a day.. @timriley not really, feels too late. I'll remove it in rom-repo 3.0 and for now just remove it from docs and deprecate in rom-repo 2.1. Yes, starting with rom 4.0 we have Relation#changeset and Repository#changeset is gone. I'll be updating docs before final is released.. Thanks :). Hey, thanks for addressing this. I'm aware of \"the map problem\" unfortunately we can't fix it by including entire Enumerable there. If we do this, all relations, across all adapters, will have enumerable interface. It's something we may consider in rom 5.0.0 but now it's too late.\nWhat we could do instead, is defining our own #map in rom-sql. I'm going to close this because we can't do it as part of 4.0 release.. @flash-gordon could you take a look?. @cmavromoustakos btw this schema plugin only adds attributes, they do not set default values, I believe you wanted to have something that deals with actually setting timestamp values by default. If that's the case, Changeset + :add_timestamp and/or :touch is what you need.. Fixed via https://github.com/rom-rb/rom/pull/464/files. I believe this can be simply handled in Schema#finalize_attributes. Thanks! I'm gonna merge it in but then I'll follow up in master with some minor tweaks.. Hmm yeah, this LGTM. @flash-gordon ?. From @alexandru-calinoiu on April 23, 2017 15:37\nOne easy way to solve it is for the timestamp_column to have default values, but is not complete as one won't be able to configure them from a repo.. Ah, right. I'm sorry I forgot we didn't make timestamps plugin work with repos yet. This will be addressed in rom 4.0 as we need to improve plugin architecture first.. In order to make this work, we need to enable passing options for command plugins here and then refactor timestamp plugin, so that Timestamp is a Module subclass, and accepts options. Then based on these options we can automatically configure a command. I would also say that this plugin should be moved to core, as it is not sql-specific.. Done via https://github.com/rom-rb/rom/commit/962bb273931a7b224bfb0c4eb52e940f76af7e40. @abrthel good to know, thanks for letting us know :). @amarshall oh \ud83d\udca9 \ud83d\ude13 thanks for reporting this. I'll push new rom-repo today.. @amarshall I've released rom 4.1.1 which will pull in rom-repository 2.0.2, and this one supports plugins_options. You can read about it here. Also, please read CONTRIBUTING.md, we don't use issues on github for random questions.. Please post this question on discourse.rom-rb.org. To be honest, this should be adapter-specific. ie if a database supports default values, then it should be used. Using default values in structs that rom loads is a code smell for me.. @flash-gordon ah right, well, would be good to maintain treating nil as a trigger for default value. Otherwise we'd have to rewrite input hashes every time a command is applied, which may have negative performance impact.. It would be good to write a spec, so that nobody breaks it by an accident in the future.. Yes perfecto :) Thank you for addressing this! I'll push a bug-fix release tomorrow.. @alsemyonov looks like this broke spec/integration/setup_spec.rb :( could you take a look?. Thanks!. This is fixed in 4.2.0. This is clearly a bug. rom-sql assumes that the other schema must be qualified too. I'm not entirely sure how to solve it at the moment, but probably adding this interface to core wouldn't be such a bad idea. WDYT @flash-gordon ?. @flash-gordon I thought about it before 2.0 final was released, but I realized it would create an implicit requirement that associations can only work when relations are qualified, and you may end up with un-qualified attributes by a mistake...on the other hand, current auto-qualification in associations is...implicit behavior \ud83d\ude06 So, we could try removing it and test it out with real apps to make sure (at least we) don't have use cases where some code actually relies on auto-qualification in associations.. OK let's finally address it in 5.0 and rom-sql 3.0. ahh OK, could we push 0.4.1 with just this fix (or any other changes that are safe to have in this release)?. OK, so I guess this can wait for the 5.0 upgrade, unless somebody would like to fix it in dry-struct 0.4.x. we gotta push a new release with fixed version spec for dry-types :/. @flash-gordon we can't push a 4.x release that also upgrades dry-types/struct, because this would potentially break rom structs and/or custom types that people may have. So our only option, for now, is to push a 4.x release with dry-types/struct version specs updated to dry-types ~> 0.12.2 and dry-struct ~> 0.4.0.. We can introduce it before 5.0.0 if somebody is willing to work on a solution where we use DI via option in all places where we use the inflector. I'm gonna close this PR because we don't want to have global config (like Nikita mentioned already).. Thanks for this. Something we could do would be to cut off a stable 4.x branch from master for the ongoing maintenance, then continue in master with 5.x effort, and this PR could be the first step. We can even consider releasing a very early 5.0.0.alpha right away, for the impatient ones who would like to start using latest dry-types together with rom. WDYT @flash-gordon & @timriley?. This is intended behavior. We use Sequel but it's an implementation detail, you should not have any expectations based on what Sequel does. The reason why we don't auto-append columns from a joined relation is pretty simple - you may have conflicting column names, and on top of that, auto-appending columns would be implicit behavior, we're trying to avoid that in rom in general.. Use ROM::Transformer instead, this will be the default in ROM 5.0 and current DSL is going away exactly due to the type of issues you're having.. @v-kolesnikov the DSL is identical as in transproc's Transformer, this is much more straight-forward and predictable than ROM::Mapper's DSL, that's why we decided to use it instead. Changesets' map feature already uses transformer DSL.. I'll have time for rom during this month, and I plan to wrap up 5.0.0 quickly. We've decided to make 5.0.0 a much smaller release than initially planned. I'll publish a post about it on our forum with more info soon.. Here's info about updated 5.0.0 roadmap https://discourse.rom-rb.org/t/changed-5-0-0-roadmap/278. hey @nepalez why did this start breaking?. FYI I just pinged @nepalez on keybase. > I'm not sure what our policy with codeclimate issues is here\nIt's to use common sense \ud83d\ude04 . @flash-gordon it was disabled, I just enabled it. I\u2019m ok with a separate branch where this is configured, otherwise we will be waiting more time for CI to finish. I can give you access to the repo so that you could maintain this branch as long as it\u2019s experimental. Makes sense?. @deepj great, I just invited you to rom-rb/rom, so feel free to create a truffle branch and continue working there. I'll try to help whenever/however I can.. @deepj you want to ask @nepalez about that. @v-kolesnikov thanks, could you also add a deprecation warning that this method goes away to release-4.2 branch?. > The test for returning aliased attribute identified by canonincal name has\nbeen removed, because I think that, being now an option and not part of the\ntype, it makes no sense.\nCould you elaborate a bit more here?. > Well, I guess this test existed in order to be sure than aliasing an attribute didn't change the name in the meta of the type.\nThis test exists because it checks we can still access attributes using canonical names, and rename_spec doesn't cover this scenario, so it seems like we should not remove the test.. > Besides the points I mentioned in the first comment, we should also decide about the #inspect output for Attribute now that it has more options.\nWe could do:\nruby\ndef inspect\n  %(#<#{self.class}[#{type.name}] #{meta.merge(options).map { |k, v| \"#{k}=#{v.inspect}\" }.join(' ')}>)\nend. > I have redefined ROM::SQL::Function#name method in the repository\nintegration tests. This should be changed in rom-sql project. How would yo\ngo with it?\nPlease open a PR in rom-sql which changes this, preferably with tests. You could temporary target this branch in the rom-sql's Gemfile, once it's merged we can go back to depending on master.. > Looks like we should also move :name to be an attribute option?\nYes, this makes perfect sense. My understanding is that first and foremost we're moving attribute-related options to the new options hash, instead of type meta. So :name should be moved there too.. > Changing :name to be an option would make the attribute information extracted from the DSL to be always a Hash.\nNot sure if I follow, wdym by the attribute information extracted from the DSL?. > Besides any change required to the API or the implementation, it would just remain to be done moving other meta's to options, if we think it is a good idea.\nLet's move the rest in a separate PR. This is getting big enough already.. This should be a command plugin. In the future, commands will be decoupled from relations, and will work with datasets directly. Relation insert and update are meant to stay bare-bones, as they are simple building blocks for other APIs.. yeah I'll switch to the released version once I get wrap/unwrap working with no surprises :)\n. We could change this check to unless definition.repository because we simply expect it to be defined. If it's not a valid repo name it'll raise anyway. One thing we could consider doing is having a custom repository index class that raises a meaningful error when something is trying to fetch a repo that is not registered. It's a common pattern in ROM so it might even make sense to have a generic registry class that knows about type of objects that it has. We store relations, repositories and mappers currently.\n. you could simply do send(\"#{name}=\", value) here\n. it'd be nicer to just write Object.const_get(model_class)\n. I mean that there's no need for eval there. In fact you can just do @model_class = Object.const_set(model_class, domain_model)\n.  Could you rename map_to_model to just model? BTW #52 describes how I imagine mapping DSL\n. if you update this PR to latest code in master this can simply become [table, dataset(table), dataset(table).columns]\n. Please turn off docs coverage checking. We use inch for that.\n. :-1: reasoning: vim doesn't do it like that\n. When things don't fit I usually format the code differently to make it fit:\nruby\nraise(\n  NotImplementedError,\n  \"#{self.class}##{__method__} must be implemented\"\n)\n. This is one of the cases where I'd be fine with exceeding 80 col limit\n. ...or at least do this:\nruby\ninclude Equalizer.new(\n  :repositories, :schema, :relations, :mappers, :commands\n)\n. Could you change that to:\n``` ruby\nname = options[:name]\nif name\n...\n```\n?\nnot sure if our rubocop setup catches this now but we should have a rule that assigning in a conditional is not a good practice as it's error prone and actually harder to read (at least for me :)) /cc @chastell \n. Yes, I \"blame\" Sequel too (I borrowed \"dataset\" from it). In fact, those may not be tuples (like in CSV adapter) so we should come up with a better term here. I guess \"row\" would be OK since it's \"a row in a dataset\". This may or may not sound good in a particular adapter's case. For instance \"row\" works great for CSV obviously.\n. Ah, yes, CONSTANTS :P\n. @elskwid well, we will have to keep an eye on Enumerable and Array methods. we'll see how it goes. Auto-forwarding of all methods would require a more complicated implementation (mostly because of to_enum stuff, otherwise we'd break semantics of enumerable/array). I didn't have fun listing those methods manually trust me, but I think it's the right thing to do. Needs to be explicit otherwise you may get funny stuff going on in your code (for instance we do not want to always wrap response with a dataset object, sometimes we totally want a plain array back)\n. I changed it to any?. thanks :)\n. That's an interesting situation - this introduces a requirement that every relation must respond to count (provided by the adapter). Commands also require this interface but for simple read-only data sources an adapter wouldn't have to care about that. If we use count here we'd introduce a new required interface for all adapters. Hmmmm\n. IIRC using or here is more idiomatic\n. Defining the same relation twice is not supported and it should blow up. I'll improve it in a separate PR\n. DOOOOOH :stuck_out_tongue_winking_eye: \n. Definitely\n. Lovely!\n. I think we should just do ROM.const_get(Inflecto.classify(type).const_get('Repository') here and remove UMBRELLA_REPOSITORIES there's no need to have them listed here.\n. This is awesome :)\n. I guess it'd be nicer to have an explanation like Failed to load rom-foo adapter. This can happen when you simply forgot to add rom-foo to Gemfile etc.\n. Exactly the reason why I proposed explicit registration in the comment below\n. scheme-related checks can go away given that #120 removes it\n. I agree this needs some clean up. I'll add a TODO to this code and we could polish in master after it's merged in :)\n. Ah, gotcha. I'll use a local var to make it read better.\n. This should live in spec/unit/rom/setup_spec.rb\n. Yep this is what we want. This reminds me - could you also move Undefined to ROM::Undefined? We should use it in many places :)\n. ah, one small thing - could you move that to rom.rb? doesn't really deserve to be in a separate file (and requires are slow :))\n. :hand:  \"please install either inflecto or activesupport gem.\"\n. In such special cases I would recommend our own interface for requiring a lib and stubbing it for the test purposes ie expect(ROM::Inflector).to receive(:load_backend).and_raise(LoadError) or something like that. This interface could also be tested by simply checking that after doing ROM::Inflector.load_backend(:inflecto) correct inflection backend is configured.\nDoes this make sense?\n. Not really actually, if you're using Rails we want AS, you could have custom inflections configured etc.\n. Let me know if you need help with this. It'd be awesome to include that patch in 0.6.0 :)\n. I believe expect(api.inflector).to be(ActiveSupport::Inflector) is more idiomatic rspec\n. Hmm what's the intention of this test? I mean, BACKENDS is a super-duper private implementation detail, we should assume nothing will touch it.\n. This doesn't work on jruby with namespaced constants ;(\nirb(main):003:0> Object.const_get('::ActiveSupport::Inflector')\nNameError: wrong constant name ::ActiveSupport::Inflector\n. ...you could wrap those in procs:\n``` ruby\nBACKENDS = {\n  activesupport: ['active_support/inflector', proc { ActiveSupport::Inflector }],\n  inflecto: ['inflecto', proc { Inflecto }]\n}.freeze\nrequire BACKENDS[:activesupport].first\nBACKENDS[:activesupport].last.call # => ActiveSupport::Inflector\n``\n. Yeah that's tricky and not worth the effort IMO. I'd say we should drop this test.\n. I decided onto_lazybecause that's part of the relation interface which may conflict with app's code. ie somebody would like to defineUsers#lazyreturning all the lazy people from the database :)\n. Yep exactly :)\n. You can wrap it inTest::GlobalExtensionso that our rspec callbacks will clean it from the runtime\n. I just released transproc 0.1.3 withunwrapsupport so please remove this and update gemspec to specify transproc ~> 0.1, >= 0.1.3\n. Yep this could be safely removed, I'm keeping it for now as a reference for the further work in transproc/mapper.\n. Yeah definitely needs a spec with more than one tuple with nils.\n. Sorry, lemme clarify - a spec that tests a case where there are more than one tuple with more than one attribute with nil :) Makes sense?\n. I believe:coercershould take precedence here and we should clearly document it, maybe even raise when somebody tries to definetypeand at the same time provide a coercion block.\n. please no inlinedo .. end:)\n. the error should be raised in attribute dsl. ieraise ArgumentError, \"can't specify type and block at the same time\" if options[:type] && blockor something like that\n. Nah man, error should be raised inAttributeDSL#attributelike I mentioned (: Here it's too low-level and too defensive I think.\n. yes pls, rubocop would complain anyway\n. missingrin mapper class name :)\n. if we really need a private method please usecompare`.\n. We decided not to do that. Not sure why rubocop is still configured to report that as an offense\n. Add a commit to this one please\nOn Tue, May 26, 2015 at 2:57 PM Errin Larsen notifications@github.com\nwrote:\n\nIn benchmarks/setup.rb\nhttps://github.com/rom-rb/rom/pull/240#discussion_r31029638:\n\n@@ -39,7 +39,7 @@ def tags\ndef users_with_combined_tasks\n   @users_with_combined_tasks ||= rom.relation(:users).as(:user_with_combined_tasks)\n-    .combine(rom.relation(:tasks).for_users)\n-                                 .combine(rom.relation(:tasks).for_users)\n\nI can fix this, and update the rubocop config to stop reporting these\noffenses.\nWant me to create a new pull-request? add a commit to this one?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/pull/240/files#r31029638.\n. hmm I left a comment under a commit and it's not visible in this PR for some reason...so I'm gonna repeat myself:\n\nthis should be, conventionally, done like that:\nruby\ndef prefix(value = Undefined)\n  if value.equal?(Undefined)\n    @prefix\n  else\n    @prefix = value\n  end\nend\nwe could probably have that as a support extension and simply define those methods via some macro\n. ...oh and the advantage being that it works as a get-or-set method and would only change the value once\n. This assumes transformers respond to :+ I wonder if we could avoid that somehow\n. Hmm I think this should belong to Mapper::DSL::ClassMethods in this case as it's a higher level concept than AttributeDSL stuff\n. You have no idea how much I love this haha :)\n. This could just become ! success? :)\n. We should make sure that invalid state is not possible :)\n. result constructors make sure that the state won't be invalid, from what I see at least.\n. it would be nice to create an anonymous class and freeze it to make sure it simply returns the original one without changing it :)\n. This touches internals too much. We could have it like that instead:\n``` ruby\nnew_relation = relation.with(key: 'value')\nexpect(new_relation.dataset).to be(relation.dataset)\nexpect(new_relation.options).to include(key: 'value')\n```\n. Please define it in the test namespace which gets cleared automatically:\nruby\nclass Test::CustomGateway < ROM::Gateway\n  adapter :custom\nend\n...or just use an anonymous class instead\n. Please don't use anonymous subjects like that, subject is meant to be used to set \"object under test\". Here you set it to a method call. This should be:\n``` ruby\nsubject(:gateway) { ROM::CustomAdapter.new }\nand then\nit 'requires the adapter to be defined' do\n  expect { gateway.adapter }.to raise_error(ROM::MissingAdapterIdentifierError, /ROM::CustomAdapter/)\nend\n```\nI know we've been writing a ton of specs with implicit subjects and inlined examples but it's history, those specs were difficult to maintain and hard to understand and follow for people.\n. This can be changed to rom-rb/rom-support and branch master now\n. can't we just have return self if frozen? in finalize!?\n. This could simplified like that:\nruby\n    case namespace\n      when String\n          CustomNamespaceStrategy.new(namespace: namespace, file: file).call\n        when TrueClass\n          WithNamespaceStrategy.new(file: file, directory: directory).call\n        when FalseClass\n          NoNamespaceStrategy.new(file: file, directory: directory, entity: component_dirs.fetch(entity)).call\n        end\n. Seems like we could have an abstract strategy to reduce some level of duplication ie:\nruby\nclass Strategy\n  include Options\n  option :file, reader: true, type: String\nend\n. This should be allow: [...] instead of type:\n. Oh wait of you're right. Sorry, this is what happens when I read code at midnight on a Wednesday \ud83d\ude06 \n. Only procs are supported? Seems like an overhead. Well, that's pretty cool :). Any chance we could somehow encapsulate this in a single place?. yeah I know there are perf differences, I wanted to look into that closer but...you did that already, thank you :) we can tweak this in master now. Ahh good point. TBH I didn't pay much attention to method's visibility but I'll address this eventually.. Freezing what exactly?. Oh I didn't know we freeze command classes. IIRC I planned to add freezing them (same with mappers and relations).. I'm gonna remove this custom constructor as we can now use Registry#map to achieve the same thing (it's needed in FinalizeRelations. Ah OK :) yeah I do remember, I'll do it once I'm done with local caches refactor in #408 . @flash-gordon it did not work, hence this custom .new. the problematic part is that both elements and options are hashes, so when you don't pass anything, then default elements and options become a single hash, which ends up with an empty registry with options[:elements]. Maybe this helps.. Ah sorry my bad, I forgot about this when we talked on gitter :). Is concat safe here?. How come dataset can be a schema instance? Looks like a workaround of some problem?. ...ahh it's here...can we add set_schema!(schema) instead? This could be used in inherited hook too where we inherit schema from a parent class.. Thanks, I've changed it based on your feedback.. This could be encapsulated in the exception class itself. We must splat if this view's arity is > 1. You can check it via method(view_name).arity.. > Or is this comment targeted at: HashJson and JsonHash\nYes, that's what I had in mind. I'll wrap this up folks, it's pretty clear this is a bit more challenging to fix.. why does it require passing self in? I'd expect this type of info to be memoized at instance level, otherwise it's an overkill to process this every time options method is called.. Instead of doing this, it'd be better to tweak this line and do:\nruby\noptions = { __registry__: registry, mappers: mappers, schema: schema.with(relations: registry), **plugin_options }. To make this spec more robust, it'd be good to do:\nruby\nexpect(users_schema.relations[:users]).to eql(users_relation)\nexpect(users_schema.relations[:tasks]).to eql(tasks_relation). why was this added?. we shouldn't have this type of logic at run-time :/ How about we make these part of options instead? This way they can be maintained across instances.. So, I understand that this makes sure we have finalized registry accessible via schemas, but there's also this change related to primary keys, and I'm not sure how that's related. Can we / should we have a separate spec example that checks primary key methods? ie canonical vs projected?. there's a method called Command#with_input_tuples which yields hashes, IIRC it should be available in this context. Bummer. I\u2019d say it should be moved to rom-core then :). @cflipse gah right, well then we need something that does with_input_tuples + returns either one or many results :/ Remember when I said I regret adding result option to commands? :D This is precisely how it complicates commands.. was this spec ported from some other place or did you write it from scratch?. @v-kolesnikov OK cool. We gotta distribute these specs within core/repository/sql projects eventually, but it's not a blocker for this PR. We have a shortcut for this:\nruby\nwith(alias: name). Minor style issue: (meta.merge(options)).select .... This should be @return [Symbol, nil] (so use actual core ruby types). This should be constrained by type: Types::Strict::Symbol.optional. I believe this can be simplified like this:\nruby\n attr_class.new(attr[:type], attr.fetch(:options, EMPTY_HASH))\nWDYT?. @waiting-for-dev please copy the original yard docs for this method. :name is required, in case of functions it's just added later, because you create a function first, then you give it a name via #as, ie str::upper(:name).as(:first_name). This is not pretty from a design pov of course, because we should probably introduce an intermediate object that represents a wip-function, and its #as method would return the actual function. This is a refactoring that could be done later if we decide it's a good idea.. @waiting-for-dev hah good catch, let's just stick to this:\n# @example  \n    #   class Users < ROM::Relation[:memory]    \n    #     schema(:users) do \n    #       attribute :user_id, Types::Integer, alias: :id\n    #       attribute :email, Types::String\n    #     end   \n    #   end \n    #   \n    #   users[:user_id].name    \n    #   # => :user_id\n    #\n    #   users[:email].name  \n    #   # => :email. Schema.attributes is a private API, no need to worry about it. I agree this could be improved, let's keep this in mind for future development. Feel free to add a TODO comment about it \ud83d\ude04 . For now let's do this:\n``` ruby\nFIXME: refactor so that it returns an intermediate function representation which\nneeds to a name\n::ROM::SQL::Function.new(type, name: :anonymous, schema: schema)\n```\nI'll make sure this gets addressed before the release.. Oh damn :/ My bad, apologies, I didn't think this through. Could you try redefining option :name, optional: true, type: Types::Symbol and see if that works?. ",
    "greyblake": "Thanks!)\n. Dzi\u0119kujemy!\n. ",
    "mbj": "So ROM is a steganography project :D\n. @bimovidia We are currently writing a well tested SQL generator. https://github.com/dkubb/sql.\n. @solnic I'm agree. As long as we continue to factor out \"stable\" parts into separate gems/repos (like we did with adamantium, equalizer, anima) (that all had been part of a rom related repo once).\n. @solnic You agree stuff like sql, equalizer, adamantium, anima, ice_nine is exactly of the size and \"stable\"-state it deserves an own repo? - Than we are on the same page.\nsql is special, its under rapid development, but this gem has, by definition, a really narrow interface. So it must not be stable to fulfill the \"own repo\" requirements.\n. @snusnu I think there is no harm done. We can take stuff from both implementations.\n. @solnic I think we should use morpher releases. I use shifted semver below 1.0. And move quite fast on morpher master. So it should be more consistent to use the latest morpher release.\n. k, should we pair on wrap/unwrap?\n. ",
    "limhoff-r7": "No big rush, I tried using ROM with the axiom-memory-adapter and emulating ActiveRecord::Base.first_or_create! by using ROM::Relation#restrict in a spec and 6 examples took 71 seconds, so I'm not going with ROM for now and just manually optimizing searches with hashes, etc.\nIt appeared that doing the check for collisions with restrict was adding 60 seconds on top of just creating the rows.  Here's the code I was using.  If I'm doing something incredibly stupid please let me know as I'd much prefer to be able to use ROM and an AREL-like syntax than have to manually do the in-memory search when the user doesn't have a database and I can't use AREL.\n``` ruby\nBITS_PER_BYTE = 8\nRANDOM_ID_BYTES = 16\nRANDOM_ID_BITS = RANDOM_ID_BYTES * BITS_PER_BYTE\nRANDOM_ID_N = 2 ** RANDOM_ID_BITS\n\nMethods\n\nAn environment for in-memory models.\n\n@return [ROM::Environment] environment with schema and mapping already\ndeclared\ndef self.environment\n    environment = ROM::Environment.setup(\n            memory: 'memory://metasploit-framework'\n    )\nenvironment.schema do\n    base_relation :architectures do\n        repository :memory\n\n        attribute :id, Integer\n        attribute :abbreviation, String\n        attribute :bits, Integer\n        attribute :endianness, String\n        attribute :family, String\n        attribute :summary, String\n\n        key :id\n    end\nend\n\nenvironment.mapping do\n    architectures do\n        map :id,\n                :abbreviation,\n                :bits,\n                :endianness,\n                :family,\n                :summary\n\n        model Metasploit::Framework::Architecture\n    end\nend\n\nseed(environment)\n\nenvironment\n\nend\nGenerates a random ID with the same number of bits as\nSecureRandom.uuid\n\n@return [Integer]\n@see SecureRandom.random_number\ndef self.random_id\n    SecureRandom.random_number(RANDOM_ID_N)\nend\ndef self.seed(environment)\n    ROM::Session.start(environment) do |session|\n        Metasploit::Model::Architecture::SEED_ATTRIBUTES.each_with_index do |attributes, i|\n            relation = session[:architectures].restrict(attributes)\n        if relation.count == 0\n            seed = Metasploit::Framework::Architecture.new(attributes)\n            seed.id = random_id\n            seed.valid!\n\n            # XXX not sure why I need to manually call track since the\n            # rom-rb.org shows me just using save.\n            session[:architectures].track(seed)\n            session[:architectures].save(seed)\n        end\n    end\n\n    session.flush\nend\n\nend\n```\n. metasploit-framework used sqlite in the past, but metasploit-framework is threaded and sqlite kept having issues, so I was advised that it wasn't worth using sqlite @schmurfy.  Additionally, the full schema from metasploit_data_models using postgres only features like INET columns.\nmetasploit-framework needs to run on Windows and *nix-like systems (Linux and OSX mostly), so I can't depend on that behavior @mereghost.\n. @solnic I wanted to make sure you noticed, but I had to make two non-obvious changes from the examples on rom-rb.org:\n1) I had to call session[:archtectures].track(seed) before I could call session[:architectures].save(seed).\n2) I had to use session.flush instead of session.commit.\n. 16 objects when I did the test.\n. I wouldn't have used count if there was an exists? or exist? method.\n. I pushed up a branch with the specs running slow here: https://github.com/limhoff-r7/metasploit-framework/tree/feature/rom (so the feature/rom branch of my fork of metasploit-framework).\nsh\ngit clone git@github.com:limhoff-r7/metasploit-framework.git\ncd metasploit-framework\ngit checkout feature/rom\nrspec spec/app/models/metasploit/framework/memory_spec.rb\nThe specs as a whole will fail since this branch was cut off of feature/module-caching, which is under going major rework, so only run this one spec.\n. If you're not using an IDE like Rubymine that allows you to click-through to definition, it may not be obvious what the seed attributes actually are, so here's a direct link to them in metasploit-model: https://github.com/rapid7/metasploit-model/blob/feature/module-caching/lib/metasploit/model/architecture.rb#L51\n. ",
    "schmurfy": "while somewhat offtopic your can create an inmemory sqlite database: https://gist.github.com/schmurfy/6378497\n. That's funny because while looking at the example in the README I was wondering how was everything linked together ;)\nI don't like blackmagic much (but I still use it in some scenario) and that's one reason I would love to go away from activerecord, blackmagic is nice as long at the framework does what you want but as soon as you start doing \"out of scope\" things then the nightmare begins and you have to dig through piles of code (in activerecord case at least) to figure what the hell is happening and why.\nWill 0.6.0 be released with this change ?\n. When I spoke about blackmagic I was not specically refering to what is currently done in rom but that's more a fear about what happens in other projects ^^\nThis is not directly related to this issue but how the parts are linked to each other is not really intuitive for me, when looking at the current example in the README a bunch of class are defined but almost none of them are directly referenced afterwards and relations between them are defined inside the class declaration.\nFor example this:\n``` ruby\nclass UserMapper < ROM::Mapper\n  relation :users\n  register_as :entity\nmodel User\nattribute :name\n  attribute :age\nend\n```\ngot me scratching my head at first and while I think I understand what it does this is a rather unusual way  of doing things, you declare a class referencing other class/entities sometimes by name (:users) and by class (User) and the class itself is never used again directly but instead referenced by another name when doing:\nruby\nputs rom.relation(:users) { |r| r.by_name(\"Jane\").adults }.as(:entity).to_a.inspect\nSince we are not really defining classes I prefer the old notation (will both stay useable ?) with methods and blocks:\n``` ruby\nsetup.relation(:users) do\n  def by_name(name)\n    where { name == name }\n  end\ndef adults\n    where { age >= 18 }\n  end\nend\n```\nWhen I look a a this what I am really defining is clear, that's not a class and it does not pretends to be one.\nI like the project though, I have been watching it for a long time and it is nice to see that things are starting to take shape :)\n. Thanks for the explanations, that was just my first impression after coming back to the project after leaving it aside for some time (last time there only the DSL language, not the classes), I need to play more with it I think to see how things play.\nI did not thought about inheritance, does this means you could have a base mapper with specialized ones inheriting from it ?\nAnd since the name of the class means nothing, does it means the following will work the same for the mapper  ? or does the name still plays a role ?\n``` ruby\nclass PolarBearMapper < ROM::Mapper\n  relation :users\n  register_as :entity\nmodel User\nattribute :name\n  attribute :age\nend\n```\n. ",
    "mereghost": "If you are on *nix you can create the sqlite db on the /tmp folder, since\nit is RAM based.\nEm 29/08/2013 11:05, \"Julien Ammous\" notifications@github.com escreveu:\n\nwhile somewhat offtopic your can create an inmemory sqlite database:\nhttps://gist.github.com/schmurfy/6378497\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/rom-rb/rom/issues/3#issuecomment-23491614\n.\n. \n",
    "snusnu": "@solnic yes i think that makes sense, and i don't think that it's pretty verbose by the way. Imo we shouldn't only think of this as a relationship replacement, but as demonstrating a way to map SQL views (with the added benefit of being writable under a lot of circumstances). Furthermore, I have the feeling that apps developed with ROM will typically involve some mappings of this kind. I think that quite a few places will emerge, were modeling a specific set of data is more naturally expressed by means of (mapping) a view , than by (building new objects around) relationships.\n. @solnic oh heh, i forgot. Do EVs work already, or is it just ECs that don't work atm?\n. @solnic then i guess we should show an EV example with a simple custom mapper. For EC, i guess we'd either postpone it until group/ungroup lands in axiom at which point it will be trivial for rom-mapper. Or we try to come up with some intermediate solution that knows how to hand a set of flat tuples to a mapper instance for consumption. I'd hate to do that fwiw, and that's also the reason why I made a case for having group/ungroup support in axiom sooner rather than later. It's imo even more important than SQL write support, as i've said before.\n. @solnic our recent design change, resulting in mapper only ever seeing one tuple, makes group/ungroup even more important. \n. @solnic fwiw, that doesn't mean i'm against providing something that can be used in ROM::Relation#each and \"collapses\" the n flat tuples into one grouped tuple, sending that to mapper.load. But I'm afraid that we will need quite some infrastructure for that to work out reasonably well (and I haven't yet thought about write support). We'd need FK information in order to perform group properly ourselves. Unless I'm missing something, of course.\n. @solnic I'm afraid that hand rolling group/ungroup in rom-relation, will add tons of completely superfluous complexity, given that it will be replaced by something really trivial eventually. I'm totally not sure if that's worth it.\n. @solnic yeah, no problem for EV. but how to do EC without group/ungroup?\n. @solnic let's continue this in IRC (needn't be now)\n. @jeremyf thx!\n. @dnesteryuk yeah unfortunately sqlite is not yet supported. The only supported RDBMS atm is postgres.\n. thx!\n. Yeah, fine with me, a few things tho:\nWe should have an extraction in mind and not introduce dependencies were they shouldn't be (I'm talking about \"inter component\" dependencies here). I'm assuming we'd move the relevant code as it is below rom/lib/{mapper, relation, session}? We should keep it so the separate components are requirable on their own and pass their own \"isolated\" spec suites (subfolders). I'm already using parts of the stack in an app I'm developing, and I don't need rom-session so currently I don't require it. I can imagine various scenarios where rom-session won't be needed. In fact, I can imagine various scenarios where rom-relation won't be needed but only rom-mapper will be, which leads me to my next point.\nIt's funny, now that you mention combining all the repos into one for now, I have the feeling that we should maybe even (prepare to) split one more piece out of the stack: The DSL on top of morpher that makes it easy to map nested structures using #attribute, #wrap and #group, so basically the DSL currently present in rom-mapper/ducktrap. Such a thing could then be used by rom-mapper to integrate the mapping process with the rest of the stack.\nI can imagine various usecases for such a gem outside of the rom stack, in fact, my app could use such a piece already. When my app receives an HTTP request, there's a dedicated step that takes the various params coming in with that request (path, query and body params), deserializes them if necessary, and maps them to a Param object suitable for the specific endpoint that was invoked. Obviously no relations or sessions are involved. It's purely about rejecting structurally invalid input and mapping to a PORO encapsulating all passed in params. Fwiw, validation comes in a later step, so when i talk about structurally invalid, I'm talking about parameter sanitization, the domain morpher was originally designed for, and shines.\nI guess what I'm getting at, is that the current rom-mapper/ducktrap code could be the initial code for a gem that provides a morpher DSL targeted for mapping usecases.\n. Nice, that's almost like something we've been talking about for ages: http://espy.github.io/ubersicht/#rom-rb\n. It'd be awesome if it were possible to add repos that do not belong to the same organization tho. That's what we've been talking about all the time at least\n. @mbj @solnic @dkubb since i was mostly offline, i was doing my stuff in parallel to Piotr. Anyways, here it goes: https://github.com/snusnu/subway/commit/58b0e2cacd1b4fff8cefcfec169aa341342bc3be\nHave a look at http://pastie.org/8901939 for what it can do already ;)\n. @solnic wdyt about merging my stuff in? i can do it tomorrow if you want me to. also i'm fine with not doing it, if you have any reasons against it\n@mbj wdyt?\n. like we said in irc, i will look at it and see what parts make sense and what don't. we'll need to discuss a bit more ...\n. @jwright writing currently only works for the memory adapter. there's no SQL support for write ops as of now.\n. thx!\n. @solnic why do you want to have them in a separate registry?\nIn ramom, all relations are exposed within a (generated) subclass of BasicObject (see https://github.com/snusnu/ramom/blob/master/lib/ramom/schema.rb) where external relations get defined as public methods and internal relations as private methods.\nAlso, ramom doesn't really have a distinction between single and multi db relations. That's because there's only one type of relation that can be guaranteed to live within a single database: base relations. With virtual relations (relations resulting from any RA op(s) applied on top of base relations) you can't easily know which databases they belong to, and, for all rom should be concerned, you don't need to care.\n. For reference, that's the DSL i use to register virtual relations: https://github.com/snusnu/ramom/blob/master/spec/integration/schema_spec.rb#L176-L178\nramom doesn't currently expose any DSL for defining base relations, since it works on top of relations inferred from DM1 models. Once you guys come up with sequel base relation inference code, i might steal that for ramom ;)\n. @solnic hmm, base relations are the basic building block for all virtual relations you eventually want to build and expose to your app. I agree that there's probably little real life need to ever expose completely vanilla base relations to your app code, but in that case, you could just as well simply infer and register them as internal relations.\nI think that your distinction somehow matches my distinction between internal and external relations, but due to how i decided to access all relations (i expose them as methods), it's simply easier for me to have every relation accessible in the same \"scope\". This allows for true composability of all relations, they're all equal(ly accesible). \n. that's how i do it in ramom: https://github.com/snusnu/ramom/blob/master/spec/integration/schema_spec.rb#L172-L178\n. @solnic Looks good to me. ramom takes a slightly different approach (as you know) in that it only exposes relations (which means that only RA ops can be applied to them) and doesn't support chaining relations the way rom does. As a consequence, all virtual relation mappers need to be defined explicitly (base relations mappers are inferred automatically) and need to be given unique names (just as with relations). Where rom supports users.with_tasks, ramom supports exposing a users_with_tasks relation which can be hooked up with e.g. a user_with_tasks mapper. One thing ramom (specifically mom for that matter) is still missing, is a way to easily define virtual relation mappers without having to repeat attributes coming from respective base relations. \nIn relation to your DSL suggestion, this basically means that if I want a user and a user_with_tasks mapper, I currently have to list user attributes in addition to doing group :tasks in the user_with_tasks mapper definition. This is something I've been wanting to enhance for some time now, and maybe I find the time to do so soonish. Your DSL suggestion seems to solve that by allowing\nruby\n    with_tasks do\n      group tasks: [:title, :priority]\n    end\nFor mom, it seems that this would boil down to exposing wrap/unwrap and group/ungroup on mapper definitions. \n. i'd encourage you to read ramom's code starting with the integration spec and having a look at what gets used. regarding the reader, here's what ramom uses: https://github.com/snusnu/ramom/blob/master/lib/ramom/reader.rb ... it's true that i expose db interactions with either queries or commands (which incidentally provide a nice place to link a relation to its respective mapper).\n. i actually have quite a few local changes to ramom (mostly covering the commands tho, reading mostly stayed the same). it's a bit hard for me to push that stuff to github right now, for reasons best not explained here ;)\n. @solnic as a heads up, here's how i \"link\" relations and their mappers: https://github.com/snusnu/ramom/blob/master/spec/integration/schema_spec.rb#L268\n. as a side note, wdyt about using mom for the mapper component (well, maybe in the longterm at least). In my experience, the actual mapping is completely decoupled from a lib like rom. Mappers don't need to know anything database related, something which mom demonstrates nicely imo. ramom makes use of mom and extends it in a few places, but doing so needs no particular groundwork on moms side.\n. what is the motivation behind adding additional api to the result object? imo, as long as the result object encapsulates associated context (i.e. the value in case of success or an error object/symbol in case of failure), rom users are free to handle/integrate their error handling how they like\n. fair enough, i just wanted to question adding api that's not strictly necessary. fwiw, i think that if such api is added, it should help with dispatch, i.e. something like the suggested #then which yields the result value \"unconditionally\" wouldn't really help, would it? If you dispatch on success vs. error state tho, you save yourself a conditional in client code.\n. ",
    "dkubb": "FYI, Axiom::Relation now supports #group,#ungroup, #wrap and#unwrap. This should open up EC and EV support in ROM once the following is added:\n-ROM::Relation#group-ROM::Relation#ungroup-ROM::Relation#wrap-ROM::Relation#unwrap`\n. @valikos yes, for now you would define the in-memory store as well as the mapping to your objects.\nWe do think that at some point it will be possible to perform inference so that we can minimize the coupling between layers. I don't think we would be doing this implicitly though, it would probably be explicit.\nFor example, in theory if you were to define a model using virtus, along with a mapper, then there would probably be enough information for the in-memory schema to be defined.\nAn other idea, when it is ready, would be to infer the schema from an existing database. Aside from the obvious benefit of saving some typing to write the code for the schema, it should be possible to check the mapper against the schema and warn/raise if there are any mismatches. If there was a virtus model, we could probably take this further and assert all three layers are compatible. This way if there are incompatible changes at one of the layers we could know up-front rather than at runtime.\nFor now we're requiring that things be declared explicitly for now, but it should be possible to cut down on code in the future.\n. @dnesteryuk do things work with the memory adapter?\nruby\nenv = ROM::Environment.setup(memory: 'memory://test')\nI'll look at the database adapter issues you're having. The database adapters lag a bit behind the in-memory adapter, since it's the reference implementation that we work on first when adding new features and polishing things.\n. Yeah, the only reason the other adapters don't respond to #[]= is because the in-memory adapter kind of leads the way. Development happens with it first, and if things turn out right, then we update the other adapters to match. It's much easier to prototype things in-memory before going to all the trouble to hook into a real datastore.\nAt some point soon I will probably be making an abstract adapter with stub methods representing the interface that raise NotImplementedError. Every adapter will be required the minimal interface.\n. @valikos Can you test if this problem exists with axiom and equalizer from the git repos? If not then maybe I need to release one or more gems to fix this. As far as I know this works on edge fine.\n. I have an almost-fixed version in edge axiom. Just a few more tweaks to make CI happy, then I'll release some gems so that the git references won't be required. I just need to double check all the other dependencies against the gems before I do a gem release.\n. I'm fine with this as long as we keep following the conventions we've established so far:\n1. Things not strictly related to the gem are put in support/ and are decoupled from the rest of the code. They should be allowed to mature to the point where they can be extracted, as time allows.\n2. Make sure dependencies between the primary components are minimized as much as possible and try to isolate the spec suites (as @snusnu recommends).\nFor the second point, maybe we should have unit tests require just the class under test (and in limited cases required dependencies), and no longer rely on requiring the entire lib all at once in spec_helper.rb (?). This would allow us to run each unit test in isolation if we wish and naturally minimize dependencies.. and when there are dependencies, they'll be painfully obvious because the specs will have tons of require statements at the top pointing out the tight coupling.\n. @solnic do you want me or anyone else to do a pass over this code?\n. @solnic you mean the seen Hash here: https://github.com/dkubb/axiom/blob/master/lib/axiom/relation.rb#L122\nThe reason for that is to allow axiom to wrap non-set objects and make sure it's yielding unique tuples only. However, upon thinking about this a bit, I think this is flawed. I should just make it a requirement that we can only wrap sets.\nIf this policy becomes a problem I should have something else that can wrap non-sets, and perform this logic, keeping the main path in Axiom::Relation#each clear of such things.\n. ",
    "valikos": "Oh, that's great, thanks\nWhat about the schema if I understand correctly it is needed to describe the tuples for relational algebra\nWe have two definitions: attributes for schema and attributes name list from schema for model\nI correctly think?\n. @dkubb thanks a lot for the explanation\n. If I try to install axiom from rubygems I have this error\nNameError: undefined local variable or method `include_comparison_methods' for #<Axiom::Equalizer:0x000000027de6f8>\nfrom /home/valikos/.rbenv/versions/1.9.3-p484/gemsets/axitest/gems/axiom-0.1.1/lib/axiom/support/equalizer.rb:18:in `initialize'\nIf I try to install axiom from github source code then axiom successfully required in the console,\nBut then rom receive next error\nNameError: uninitialized constant Axiom::Relation::Operation::Order\n. Looks like it should be Axiom::Relation::Operation::Sorted I see commit for rename this class.\nThe problem is still present if I try install rom with clear gemset.\nRubygems shows 0.1.1 latest version for axiom, but releases on github shows only 0.1.0\n. ",
    "dnesteryuk": "It looks like postgres is not supported as well, because I see similar error:\nruby\n/home/dnesteryuk/.rvm/gems/ruby-1.9.3-p429/gems/rom-relation-0.1.2/lib/rom/repository.rb:56:in `[]=': undefined method `[]=' for #<Axiom::Adapter::Postgres:0x00000002caa768> (NoMethodError)\n    from /home/dnesteryuk/.rvm/gems/ruby-1.9.3-p429/gems/rom-relation-0.1.2/lib/rom/schema/definition.rb:38:in `base_relation'\n    from test.rb:8:in `block in <main>'\n    from /home/dnesteryuk/.rvm/gems/ruby-1.9.3-p429/gems/rom-relation-0.1.2/lib/rom/schema.rb:43:in `instance_eval'\n    from /home/dnesteryuk/.rvm/gems/ruby-1.9.3-p429/gems/rom-relation-0.1.2/lib/rom/schema.rb:43:in `call'\n    from /home/dnesteryuk/.rvm/gems/ruby-1.9.3-p429/gems/rom-relation-0.1.2/lib/rom/environment.rb:66:in `schema'\n    from test.rb:7:in `<main>'\n. ok, this issue is gone, but I have other problems which I will described in another issue. Thanks.\n. @solnic I played a bit with your solution (group and wrap methods), but it doesn't work for me :( Your example works well for relation DB, but for my custom storage it doesn't. Can you provide some example (it is better to have demo example) which will allow me to work with such response from Git API:\nhttps://developer.github.com/v3/repos/\njson\n[\n  {\n    \"id\": 1296269,\n    \"owner\": {\n      \"login\": \"octocat\",\n      \"id\": 1,\n      \"avatar_url\": \"https://github.com/images/error/octocat_happy.gif\",\n      \"gravatar_id\": \"somehexcode\",\n      \"url\": \"https://api.github.com/users/octocat\",\n      \"html_url\": \"https://github.com/octocat\",\n      \"followers_url\": \"https://api.github.com/users/octocat/followers\",\n      \"following_url\": \"https://api.github.com/users/octocat/following{/other_user}\",\n      \"gists_url\": \"https://api.github.com/users/octocat/gists{/gist_id}\",\n      \"starred_url\": \"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\n      \"subscriptions_url\": \"https://api.github.com/users/octocat/subscriptions\",\n      \"organizations_url\": \"https://api.github.com/users/octocat/orgs\",\n      \"repos_url\": \"https://api.github.com/users/octocat/repos\",\n      \"events_url\": \"https://api.github.com/users/octocat/events{/privacy}\",\n      \"received_events_url\": \"https://api.github.com/users/octocat/received_events\",\n      \"type\": \"User\",\n      \"site_admin\": false\n    },\n    \"name\": \"Hello-World\",\n    \"full_name\": \"octocat/Hello-World\",\n    \"description\": \"This your first repo!\",\n    \"private\": false,\n    \"fork\": true,\n    \"url\": \"https://api.github.com/repos/octocat/Hello-World\",\n    \"html_url\": \"https://github.com/octocat/Hello-World\",\n    \"clone_url\": \"https://github.com/octocat/Hello-World.git\",\n    \"git_url\": \"git://github.com/octocat/Hello-World.git\",\n    \"ssh_url\": \"git@github.com:octocat/Hello-World.git\",\n    \"svn_url\": \"https://svn.github.com/octocat/Hello-World\",\n    \"mirror_url\": \"git://git.example.com/octocat/Hello-World\",\n    \"homepage\": \"https://github.com\",\n    \"language\": null,\n    \"forks_count\": 9,\n    \"stargazers_count\": 80,\n    \"watchers_count\": 80,\n    \"size\": 108,\n    \"default_branch\": \"master\",\n    \"open_issues_count\": 0,\n    \"has_issues\": true,\n    \"has_wiki\": true,\n    \"has_downloads\": true,\n    \"pushed_at\": \"2011-01-26T19:06:43Z\",\n    \"created_at\": \"2011-01-26T19:01:12Z\",\n    \"updated_at\": \"2011-01-26T19:14:43Z\",\n    \"permissions\": {\n      \"admin\": false,\n      \"push\": false,\n      \"pull\": true\n    }\n  }\n]\nCurrent version of ROM works well with a simple data structure, but it doesn't when I have something more complicated. May be I didn't get something. Thank you!!!\n. @solnic it is exactly my point, I don't need any new relation, I just need to map a nested data. I would appreciate if you show me an example how to do that. Thanks.\n. @solnic yes, it is correct.\n. Awesome, it works. It can be closed.\n. It is not something urgent :). We use this gem for building our own library working with API of our services. So far it looks good (at least more flexible in comparison to the previous version of ROM). Thank you for your work!!!\n. Thank you!!!\n. are you looking for that?\n[{\"name\"=>\"Jane\", \"email\"=>\"jane@doe.org\", \"roles\"=>[{\"role_name\"=>\"Member\"}, {\"role_name\"=>\"Admin\"}]}]\nI just changed tests rom-yaml gem to simulate my case:\n``` ruby\nrequire 'spec_helper'\ndescribe 'YAML adapter' do\n  subject(:rom) { setup.finalize }\nlet(:root) { Pathname(FILE).dirname.join('..') }\nlet(:setup) { ROM.setup(\"yaml://#{root}/fixtures/test_db.yml\") }\nbefore do\n    setup.schema do\n      base_relation(:users) do\n        repository :default\n    attribute 'name'\n    attribute 'email'\n    attribute 'roles'\n  end\nend\n\nsetup.relation(:users) do\n  def by_name(name)\n    find_all { |user| user['name'] == name }\n  end\nend\n\nsetup.mappers do\n  define(:users) do\n    model name: 'User'\n\n    attribute :name, from: 'name'\n    attribute :email, from: 'email'\n\n    group 'roles' do\n      attribute :role_name, from: 'role_name'\n    end\n  end\nend\n\nend\ndescribe 'env#read' do\n    it 'returns mapped object' do\n      jane = rom.read(:users).by_name('Jane').to_a.first\n  expect(jane.name).to eql('Jane')\n  expect(jane.email).to eql('jane@doe.org')\n  expect(jane.roles.length).to eql(2)\nend\n\nend\nend\n```\n. If I do:\nruby\n  attribute :roles, from: 'roles'\nand remove group 'roles', I won't be able to use mapping. In our project we need to map even nested attributes. :(\n. New method will help here for sure!!! Thank you.\n. Thank you for your fast fix :+1:  but it wasn't urgent, we use ROM 0.4.1 now and it works fine for us. I added this issue because we could not upgrade our gem in the future. It was my concern. Take your time ;) and thank you for your hard work.\n. works as expected, thank you.\n. ",
    "AlbertGazizov": "I have the same problem with postgres, the in-memory adapter works well.\n. ",
    "bimovidia": "Is there any update on this? I am having the same problem with postgresql. \n. ",
    "trbrink": "@mbj I managed to get things woking with postgres.  To get rid of undefined method []= for #<Axiom::Adapter::Postgres:0x00000002caa768> (NoMethodError) I made the following change to lib/rom/repository.rb:56 in rom-relation:\nruby\ndiff --git a/lib/rom/repository.rb b/lib/rom/repository.rb\nindex 0fe3193..1a77aa6 100644\n--- a/lib/rom/repository.rb\n+++ b/lib/rom/repository.rb\n@@ -53,8 +53,12 @@ module ROM\n     #\n     # @api public\n     def []=(name, relation)\n-      adapter[name]   = relation\n-      relations[name] = adapter[name]\n+      if adapter.respond_to?(:[]=)\n+        adapter[name]   = relation\n+        relations[name] = adapter[name]\n+      else\n+        relations[name] = adapter.gateway(relation)\n+      end\n     end\nAfter that axiom-do-adapter gives this error NoMethodError: undefined method primitive for Axiom::Attribute::Integer:Class.  To reproduce this error you have to create the environment, schema, and mapping and then try to query the model like env[:users].restrict(name: 'test').one.  To fix it I made the following change to lib/axiom/adapter/data_objects/statement.rb:98:\nruby\ndiff --git a/lib/axiom/adapter/data_objects/statement.rb b/lib/axiom/adapter/data_objects/statement.rb\nindex 38b48b4..7161a59 100644\n--- a/lib/axiom/adapter/data_objects/statement.rb\n+++ b/lib/axiom/adapter/data_objects/statement.rb\n@@ -95,7 +95,7 @@ module Axiom\n         #\n         # @api private\n         def column_types\n-          @relation.header.map { |attribute| attribute.class.primitive }\n+          @relation.header.map { |attribute| attribute.type.primitive }\n         end\nIf you would like I can submit a pull request for these changes.\n. ",
    "plexus": "\\o/\nOn 20 Jan 2014 19:46, \"Piotr Solnica\" notifications@github.com wrote:\n\nClosed #10 https://github.com/rom-rb/rom/issues/10.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/rom-rb/rom/issues/10\n.\n. \n",
    "adam-e-trepanier": "I'm getting the same error here.\n. Hi notgary, the quickest thing I did was point my gems at the github master branch\ngem 'axiom', git: 'https://github.com/dkubb/axiom.git'\ngem 'axiom-memory-adapter', git: 'https://github.com/dkubb/axiom-memory-adapter.git'\ngem 'rom', git: 'https://github.com/rom-rb/rom.git'\ngem 'adamantium', git: 'https://github.com/dkubb/adamantium.git'\n. ",
    "ghost": "Is there a fix/workaround for this issue yet?\n. ",
    "emilesilvis": "@dkubb any update on this?\n. ",
    "tjstankus": ":+1: \n. ",
    "gerhard": "If it's a PITA, it's wrong. Good call, can definitely relate to it.\n. ",
    "avdi": "Since you can always generate multiple gems from a single repo, I don't see a downside...\n. ",
    "lgierth": "Throwing this in here half off topic: http://espy.github.io/ubersicht\n\nA dashboard for recent activity on all of a user's or organisation's repos\n\nRegarding the topic, I'm +1 with everything said.\n. ",
    "rrrene": "(facepalm) points to the correct URL now :no_mouth:\n. ",
    "coveralls": "\nCoverage increased (+0.02%) when pulling 2839a2dcadc5e7d367bf4a56a81c6ad254712622 on rrrene:patch-1 into 00767f12639aa3f19dbec81b95200b0f48327da8 on rom-rb:master.\n. \n\nChanges Unknown when pulling bd4757e26e69f20a7cb6dbc2832778e08c446990 on command-graph-builder into  on master.\n. ",
    "saratovsource": "@solnic it awesome gem! But how about Morpher? Now it fully integrated?\nI can not understand how the changed scheme and mapping in this case?\nI have:\n``` ruby\nclass Application\n  include ActiveModel.model\n  include Equalizer.new :id, :name\n  attr_accessor :id, :name\nend\nclass Slot\n  include ActiveModel::Model\n  include Equalizer.new(:id, :name, :applications)\n  attr_accessor :id, :name, :applications\nend\nmapping\n...\napplications do\n    model Application\n    map :id, from: :uuid       # other key in json\n    map :name, from: :title  # other key in json\n  end\nslots do\n    model Slot\n    map :id, :name, :applications\n  end\n```\nSlot has collection of Application\nHow to define simple schema and collection type? In Virtus is Array[Application], but it not working now with Morpher and Axiom attributes...\nThanks for the help.\n. Yep, I use ROM in real project for transfer data from different sources (eg. json api and other app clients through its gems). With base types and flatten types (not collections and hashes) it perfect work...\nFor example, applications are taken from the API, and slots - from gem.\n. I tried to do as you have shown, but the mapper can not dump the \"Applications\" (they are still objects, not tuples). \nI found your example in the tests (https://github.com/rom-rb/rom/blob/master/spec/integration/grouped_mappers_spec.rb) - is virtually a clone of my task. Could you add / edit the test to the group was in the scheme (as in the last example of this issue)? It possible? Thanks.\nI found cool spec) https://github.com/rom-rb/rom/blob/master/spec/integration/schema_definition_spec.rb\n. @solnic I will try it tomorrow and I will inform you about the results, of course )))\n. @solnic Many thanks for the example! I would be very happy if the same example was for wrap))\n. ",
    "Spaceghost": "Unrelated: Mighty morphin' power rangers!\n. This looks incorrect on the far right.\n. I don't think this is a lot more helpful to a user who doesn't know how to set a schema repository. Perhaps the string could be a bit more descriptive in to help combat that?\n. ",
    "daz4126": "Thanks Piotr! Do I install edge with gem install rom axiom-memory-adapter --pre or from a Github url?\n. ",
    "jwright": "@solnic That would be great. I would also suggest some sort of documentation that this is not supported yet in the README.\nI love the API. Keep up the great work. :thumbsup: \n. ",
    "kirs": "I'm really excited about ROM and writing on Postgres adapter is something I'd really need in my app.\nCan I help you with this feature?\n. That's a great news!\n. @solnic done!\n. ",
    "jeremyf": "What are the considerations for contributors?\n- Are we enforcing a style guide? I've seen and implemented a few projects that enforce style by having Rubocop be part of the build.\n- Are there any licensing considerations to draw attention to?\n- Do we recommend a single commit per pull request?\n- What are the responsibilities of those merging code?\n- What is the tone you are after? Exhaustive information? Light and brief?\nI have a handful of contributing information I could bring into the conversation.\n. ",
    "elskwid": "I second everything @solnic said and would add: \n- Larger ideas should be presented to everyone in a pull request, the earlier the better. We're all busy so using the PR mechanism is a good signal that something is changing. \nThank you for getting the conversation started @jeremyf.\n. :+1: nice work @Olefine. Thanks!\n. Great work @chastell! \n80 all the way.\n. Looks great @chastell. Really nice work. Thank you so much for taking the time to do this. It's a more substantial PR than I'd like to merge without a review from @solnic. If we're keeping score: :+1: \nThanks again!\n. Hooray!\nOn the question of quotes: I use double everywhere so I never have to think about interpolation. I will tend towards the project norms though.\n. Thanks @splattael!\n. active_model/lint is an example of one way to do this.\nI don't know how it should be used since it would be best to support any test framework. Probably be nice to have a linter that is framework agnostic as @solnic mentioned and include a couple of ways to aid in testing with rspec and minitest for example. The key here is, we know it won't be a lot of code but it will increase an adapter developer's confidence that what they're building will be compatible, and I feel like that may encourage more adapters to be written.\n. From our conversation yesterday, I'd like to see this part specification and part runnable spec. Basically, set it up so the comments/docs are like reading the specification for an adapter:\nI'd recommend we follow RFC 2119 for requirement key words:\n``` ruby\nadapter MUST provide foo\nadapter SHOULD provide bar\nadapter MAY provide baz\nadapter MUST NOT do mollusk\n...\n```\nFor each requirement we should have a runnable piece of code. I agree that test/unit would be nice since it ships with Ruby. \n. @solnic Off the top of my head: we would have tests for MUST and MUST NOT then if there are things that MAY and SHOULD be added this could be the configuration we discussed. For instance, an adapter MAY allow writing back to the underlying data store. Is there a test for when it can handle that? If so, then we somehow tell the tests that it's available for linking.\n. Very elegant solution to the problem. Thanks @splattael.\n. @solnic I only have two items which I believe rise to the level of objection. \n1. The explicit forwarding of all the enumerable methods frightens me. How hard will this be to maintain?\n2. The name tuple_proc isn't great at first glance. Perhaps I'm alone in not immediately thinking about tuples when I see the name dataset. I tend to think of 'rows' and 'columns'. I blame Sequel. In the commit I suggested row_proc but if we're talking tuples everywhere else then ... shrug\nOverall, it's grand. It took shape quite fast from my point of view. Did it help you flesh out how the adapters could be used and built at all? If so, then it was totally worth it. I'd like to add it to rom-yaml and rom-csv tomorrow morning. (and others?).\n. I like the Rust std::result more than I like on_error, or_else, and_then. Agreed that on_error feels more like standard callbacks, and or_/ and_ seems to denote an order of operation as opposed to simple error handling.\nIn the interest of listing options: Perhaps some of the Promise implementations can serve as inspiration:\nhttps://github.com/petkaantonov/bluebird\nhttps://github.com/tildeio/rsvp.js\n``` ruby\nresult = rom.command(:users).try { create(name: 'Jane'  }\nresult\n  .then { |user|\n    # user stuff\n  }\n  .then { |user|\n    # other user stuff\n  }\n  .catch { |err|\n    # handle error\n  }\n. Another take on the topic mentioned in chat: https://github.com/snusnu/orc\n. @solnic - this is a great bit of surgery. It really highlights how `schema` was no longer needed. From a pragmatic standpoint even if we find out we need schema later it would be better to add it then rather than keep it around when in doubt.\n. :tada: \n. @splattael as I mentioned in chat, this is going to require a helluva rebase. Are you okay with us losing some detail in the commits? With the Adapter removal it's going to be very difficult to keep it all straight.\n. @splattael and @solnic (@aflatter too) - this is ready for a good look-over. :eyes: \n. @aflatter I really like what you've done here. Nice work.\n. @solnic, @aflatter, @splattael - take a look and tell me your thoughts. The names and implementation are totally up for discussion. I really wanted to capture my idea while it was causing me pain.\n. Good catch @splattael. I totally missed that the auto-registration was gone in that PR. It would seem my pain will go away with #120. \n. Nice work @solnic! :clap: :clap: \n. ruby\nuser = rom.relation(:users).map_with(:entity, :presenter).first\n```\nI like this a lot. It is unsurprising and reads well.\nAs far as the default mapper, perhaps it's best we always use the explicit mapper until a common use-case emerges. I know you use rom way more than I do so perhaps the use-case is already there.\nFor specific feedback though, here are my thoughts:\n``` ruby\nshould this map by default using rom.mappers[:users]?\nrom.relation(:users)\n```\nHaving .relation(:users) be mapped would be kind of surprising.\n``` ruby\n...probably not, so should we have a shortcut explicit interface instead? maybe:\nrom.relation(:users).mapped # meh...\n```\nI'm with you. Kind of 'meh' but it does make it clear what has happened.\n``` ruby\n...maybe we should have a nice naming convention for mappers so that\nthis would be possible:\ndoes rom.mappers[:users][:entities].call(rom.relations[:users])\nrom.relation(:users).as_entities\n# does rom.mappers[:users][:presenters].call(rom.relations[:users])\nrom.relation(:users).as_presenters\nit would of course work with a block\nrom.relation(:users) { |r| r.by_name('Jane') }.as_entities\n```\nWhat about with_presenters / with_entities? Are these plural for another reason or is entities the name of a mapper? I would expect this to be with_entity or with_presenter based on the name of the defined mappers. \n. @solnic with that answer I think I see the idea. You are saying: \"since I'm not providing a mapper name, use the default registered under :presenter\". Does that sound right?\n. WELP. Shows what I know!\n. Emacs gets a little irritable as well.\n. @chastell It looks like you favored creating variables when lines got really long. That works fine for me. @solnic?\n. I hate it when code forces me to make these kinds of decisions. ;)\n. \n. @solnic \u2013 any feelings on the maintainability of this? (I am not suggesting we change it for this PR :grin: )\n. OH! I like that the proc can be injected or set in the class method.\n. You know this makes me happy. As I said yesterday, this is what I would expect: the proc applied to the tuple on demand rather than all at once. I suppose then it will play nice with usages like:\nruby\nmy_dataset.each.take(5) { |row| do_stuff }\nSo that the proc is only applied the 5 times it's needed.\n. I saw your changes to the constant. There's something else to keep in mind, Minitest 5 is Minitest::Test <- note the 't'. I believe v5.x includes an alias so MiniTest will still work.\n. This use of Trasproc here hints at some cool stuff ...\n. I'll just voice my opinion that the name tuple_proc doesn't do it for me. I do not have a better name in my head - maybe row_proc? Anyway, food for thought as we go forward.\n. @solnic the TestAdapter is precisely what we discussed. It's great. What a help to developers to be able to wire this up and see if their adapter meets the requirements.\n. We should document the :default repo functionality somewhere. It has already tripped a few people up when new to rom.\n. @solnic doc in ROM::Repository still refers to adapter. Would it be better to refer to repository or make it clear that an adapter is providing this repository?\n. Is the hash helping us translate from csv -> CSV and memory -> Memory since casing may differ?\n. Ah, nice. I went after this before(:all) in #125 as well.\n. :clap: :clap: \n. Good catch!\n. ",
    "chastell": "\nI'm planning to plug rubocop in at some point if I see the need\n\nLet me know if you do (disclaimer: I\u2019m not pushing for it, this is just in case you indeed see the need) \u2013 I like this kind of clean-up work; just did that for Reek. :)\n\nReading commits is usually a good story and can tell you a lot.\n\n:+1: \u2013 there\u2019s a difference between squashing two commits where one is clearly a fixup! for the other and killing a development story by squashing everything together. Git diff over a range of commits is trivial to generate, discerning a squashed commit much harder, and git bisect can pinpoint a culprit better when the commits are smaller.\n. :sparkles: I\u2019m still learning how to handle a certain new process at $HOME, so had to fall back a bit from development, but will follow up on my ROM & RuboCop adventures eventually. :)\n. (I\u2019m happy to reorder/squash related commits once it looks ok, or even squash the whole PR; not sure what ROM\u2019s practices are \u2013 I\u2019m a fan of keeping many small commits, but these might a bit be too small even for the biggest opponents of squashing.) :)\n. :sparkles:\nJust let me know what would be your acceptable max line length \u2013 I\u2019m ok with any, including longer than the current max of 109; I won\u2019t tilt my \u2018it should be 80 characters\u2019 windmill today ;) \u2013 so I can make it so.\nI\u2019ll take the lessons from here and apply them to the other ROM repos. :)\n. :heart: Took my line trimmer/wrapper for a ride, please review (some wrappings may be controversial).\n. Thanks for the kind words, @elskwid! I like consistent code and I enjoy such chores when my brain is too fried to do anything more creative. I don\u2019t mind preferences that differ from my own, but I do like consistency (something something hobgoblin something little minds, well, REPRESENT).\nThe only unopened can of worms is string quoting (\u2018double quotes all the time\u2019 vs \u2018single where possible\u2019 vs \u2018FFS just leave it the way the author felt like when they wrote it\u2019), but unless there\u2019s a preference I\u2019ll leave it at the \u2018shrug\u2019 setting. If you do have a preference I\u2019ll be happy to enforce it (and let RuboCop auto-fix it, either way). FWIW, going with \u2018single quotes where possible\u2019 would be 102 changes and with \u2018double quotes everywhere\u2019 would be 485 changes.\n. Oh, lovely! Merged. :)\n. Oh, cool. Turned off. :)\n. Good point. Turned off.\n. Ah, interesting \u2013 I actually initially had it wrapped to\nruby\nraise NotImplementedError, \n  \"#{self.class}##{__method__} must be implemented\"\nbut then thought \u2018if we\u2019re going to have two lines anyway, then extracting something is better than wrapping\u2019. It seems @solnic\u2019s preference is to have four lines instead (I\u2019m ok with it, just surprised a bit). :)\nThis is also why I most often extracted things in specs to turn\nruby\nexpect(a.very.long.call.chain)\n  .to match(something)\ninto\nruby\nresult = a.very.long.call.chain\nexpect(result).to match(something)\n(except cases where it wouldn\u2019t work/look good) \u2013 but I can gravitate towards wrapping rather than extracting in the future, no problem. :)\n. I think it does often suggest that the concerns of a class are on the border of being too wide (in general, not necessarily in this case). :) Lemme fix it (and the other one) real quick.\n. ",
    "lasseebert": "Np ;)\n. ",
    "abernardes": "I was looking into this issue, and it is showing itself more challenging than I thought. So I thought I should probably ask some clarification first :smile:.\nI have used Ohm as a Redis ORM and redis-rb to perform atomic operations. I don't know and haven't found any libraries that provide a query interface for storing/retrieving records from redis similar to Squeel or Moped. Are you aware of any? If not, I'll probably strip down Ohm and write one myself based on Ohm's code.\n. Thanks for the suggestion. I've been experimenting with Ohm, but since it is designed to be an ORM in itself, I kept running into awkward situations that required workarounds I was not happy with.\naxiom-redis-adapter seems simple enough, I'll go with that :smile: \n. I looked into it, Ohm is fairly simple (couldn't expect anything different from @soveran). My initial thought was to use Ohms code, removing the object mapping and adding a record-query interface. That would allow us to use it like a hash store, with all the mature indexing/searching features Ohm provides.\n. Thanks @soveran for taking the time to respond and for being so thorough!\nI'll take a proper look at Ohm's source tonight and see if I can use the low-level features as @solnic mentioned.\n. I could take a stab at this one too, if it's up for grabs.\n. If no one is working on this yet, I'd love to give it a shot.\n. Will do, thanks!\n. Oops, apparently there are conflicts to be solved. Working on it.\n. Anyway, there's a first draft for this feature. Please criticise as much as you like. You can even tell me to throw it out and start over (although I hope you don't) :stuck_out_tongue_winking_eye: \n. Alright, rebase is done.\nNow the code is initialising relations with a array of column names instead of a Header object.\nI also kept the code that infers database types, even thought it isn't being used.\nLMK what you think. :beer: \n. Just so you know, I had to do something very similar to what you described here in order to make my implementation of #37 testable. I guess you can consider the first two items \"in progress\" :smile: \n. So, there's an attempt to implement items 1 and 2 in #56. LMK what you think.\nI gave item 3 some thought, but I'm not 100% sure I understand what your line of thought is. If adapters are registering themselves, I understand I would have to load all adapters files and only then Adapter can figure out which one should be instantiated. And afaik, only after figuring out which adapter will be instantiated I would be able to require such file. It's like a chicken and egg situation :smile: \n. So, to be sure: you'd prefer to require all adapter code now and work with registration/lookup instead of loading adapter code dynamically?\n. Makes total sense. I added a commit to #56 that removes the loading of all adapters. LMK what you think! :wink: \n. Awesome! :D\nAndre Bernardes\nabernardes@gmail.com\nOn Sun, Nov 2, 2014 at 8:07 PM, Piotr Solnica notifications@github.com\nwrote:\n\nClosed #55.\nReply to this email directly or view it on GitHub:\nhttps://github.com/rom-rb/rom/issues/55#event-187119235\n. Just noticed the pg gem is failing to install on JRuby. Trying to figure out why.\n. OK, removed the Postgres test and now CI is passing. I think this PR is ready to be reviewed :smile_cat: \n\nThanks for the jruby-pg tip :wink: \n. ",
    "soveran": "Hello guys, I don't know exactly how an adapter should be in order to work with ROM, so what I'm writing is based on what I saw in axiom-redis-adapter. That said, I'm not even familiar with axiom, so take my comments with a hundred grains of salt.\nI think the approach in axiom-redis-adapter can be improved, but it's not trivial. It uses the KEYS command for building relations, but that command is pretty much forbidden for production environments. The recommended way to achieve that would be by using sets to build indices, and above all any update or delete should update both the records and the indices atomically. If the plan is to start from that library and build a ROM adapter, I would strongly suggest keeping those details in mind. Otherwise, the user will find out about his performance issues when it's too uncomfortable to change (that is, when the database grows to the point that executing KEYS creates a peformance penalty that causes other connections to timeout, or just to run very slowly).\nSomething I'm thinking could be of use is the Lua scripts used by Ohm in order to save and delete records. There are some Ohm ports that use those scripts, they have proved useful for making cross language compatible clients. You can find them here, and you can see how they are used in Ohm itself, but also in other clients like Gohm (Go), redis3m (C++), or Ohm.lua (Lua).\nEven though it looks like Ohm does a lot, it's very small (600 loc) and straightforward because of the extraction of those two operations. If you guys want to use them, or if you want more information about how that works, just let me know. I'm not sure if the documentation is clear enough, so if there's something missing I will be glad to update it. Even if you don't find a good use for those scripts or for Ohm itself in this context, I would still like to help you with this endeavor, so please feel free to ask me.\nLooking a bit more into the problem, I think Ohm could be used directly, as it provides easy access to low level features. I guess we can discuss that too if you guys agree.\n. ",
    "bryanp": "Hello, all! I'd like to jump in and help write a Redis adapter for ROM. It ties in with some things I've been working on, and while Ohm is fantastic I'd like to be able to use Redis via ROM.\nI've reviewed the existing adapters (primarily rom-sql) and have a decent handle on how to go about building a rom-redis adapter based on the information in this thread. I'd like to start down the path of building the adapter on redis-rb.\nAnything to discuss before I start slinging code?\n. We'll make a good team then! I'm a ROM noob but more experienced in Redis :)\nWill do some preliminary work in the next few days and shoot you a note when there's something to look at.\n. Hi @billywatson that would be awesome, actually. Haven't had a chance to do much the last little bit. I certainly want to help, but also don't want to be a blocker for anyone else.\n. @solnic That'd be great!\n. @billywatson have you started on an aspect of this? would be good to coordinate somehow.\nand thanks @solnic!\n. Same here, actually. I was looking to drive it based on needed features, which to start with would just be basic CRUD operations. That would likely descend into more complex queries.\n. Cool; I'll start with CR. Getting really close to needing this so I should start in the next couple days.\n. ",
    "billywatson": "Lemme know if you need any help on this, @bryanp or whoever else is working on this. I'm pretty experienced with Redis and I have a huge desire to get it put into ROM. \n. Sure, @solnic that'd be a huge help to a guy fairly new to ROM, like myself\n. Awesome, thanks!\n. I haven't started yet, no. I've been trying to finish the project that needs this without it so that I could see where it would fit in. Did you have a place to start?\n. Well it looks like from my previous research that the CUD portions aren't as well defined in ROM yet so I was planning on just sticking with implementing good read interfaces for now. What do you think?\n. I guess I misspoke. \"Well-defined\" clearly isn't right, but some of the docs said that CUD is \"in-flux\" or something of the sort. Is that not correct?\n. ",
    "gotar": "Redis adapter exists: https://github.com/rom-rb/rom-redis this issue should still be open?\n. Do we still need this ticket, we have basic migrations?\n. Will take care of it, or try ;] you can check progress: https://github.com/gotar/rom-sql/tree/%23130-migrations\n. i think we can close this ticket @solnic \n. Done in PR: https://github.com/rom-rb/rom/pull/139\n. +1\n. it looks like https://github.com/solnic/transproc bug not rom\n. basic gem if ready. Still a lot to add but I think we can close this\n. Hmm maybe you will provide more code, that not works for you, because I just test and all works\n. ``` ruby\nROM::SQL::Migration.create do\n  change do\n    run 'CREATE EXTENSION \"uuid-ossp\"'\ncreate_table(:users) do\n  column :id, :uuid, default: Sequel.function(:uuid_generate_v4), primary_key: true\n  String :email, null: false\n\n  index :email, unique: true\n  index :token, unique: true\nend\n\nend\nend\nROM::SQL::Migration.create do\n  change do\n    create_table(:vehicles) do\n      column :id, :uuid, default: Sequel.function(:uuid_generate_v4), primary_key: true\n      foreign_key :user_id, :users, type: :uuid\n      column :name, String\n    end\n  end\nend\nclass Users < ROM::Relation[:sql]\n  register_as :users\none_to_many :vehicles, key: :user_id\ndef with_vehicles\n    association_left_join(:vehicles, select: [:id, :name])\n  end\nend\ndescribe 'User with vehicles' do\n  let!(:user) { create_user }\nit {\n    3.times { ROM.env.commands.vehicles.create.call(user_id: user[:id], name: 'Foo') }\n    p ROM.env.relation(:users).with_vehicles.as(:users).to_a\n  }\nend\n[#, #, #], @id=\"23d01173-ee8d-4eff-be46-15e9e048e620\",  @email=\"example-73-96@example.com\">]\n``\n. I like it +1 its a little strange you call mapper before create command but can live with it +1\n.result :one, as: :entity- +1\n. romtry` do not catch no rom errors\n. exclude change nothing (not work)\n``` ruby\nrequire 'rom'\nROM.setup(:memory)\nclass Users < ROM::Relation[:memory]\nend\nclass UserMapper < ROM::Mapper\n  relation :users\n  register_as :entity\nattribute :name\n  attribute :age\n  exclude :phone\nend\nrom = ROM.finalize.env\nrom.relations.users << { name: 'Oskar', age: 31, phone: '123456' }\nuser = rom.relation(:users).map_with(:entity).first\np user #=> {:name=>\"Oskar\", :age=>31, :phone=>\"123456\"}\n```\n. the same without attributes at all\n``` ruby\nrequire 'rom'\nROM.setup(:memory)\nclass Users < ROM::Relation[:memory]\nend\nclass UserMapper < ROM::Mapper\n  relation :users\n  register_as :entity\nend\nrom = ROM.finalize.env\nrom.relations.users << { name: 'Oskar', age: 31, phone: '123456' }\nuser = rom.relation(:users).map_with(:entity).first\np user #=> {:name=>\"Oskar\", :age=>31, :phone=>\"123456\"}\n. As I know outside model (without model) `attribues` works only to transform, do not drop anything\n. yeap right now when we, from DB after create, got everything will be nice to have tool to easly map it to hash we like to have\n. Generally mapper for me should works like Virtus, if you don't specify any attribute then it return `{}`. You need to specify whole complex structure you want to have after transformation.\n. those `select ...` works ok for fetching data from DB, but problem I have is with data returned after `create command`. We don't have any control on db side what fields we will get, and then need mapper to fix that.\n. But maybe we try to fix it from wrong side and we should return nothing from create call (as CQRS said) then we will have normal db read call there or allow to inject call commands do after create\n. :mindblow: again I realize I'm still beginner in ROM universe\n. It's good repository we collect here all issue\n. Yeap, it works.\n. yeap those set was sth strange, different then we have in other places, using everywhere `#call` will be a lot better\n. +1\n. +1 :clap: \n. +1\n. For me it should be set in `input` part of Command\n. Yes if you insist on plugin. But probably input from command will overwrite it. \n. I use those validation everywhere. Very useful for me.\n. Then why not, fair enough.\n. +1 looks good for me, consistent and clean\n. what error you think we should put there? `ROM::Mapper::Error.new('You cannot specify type and use block in the same time!')`?\n. ruby\ndiff --git a/lib/rom/processor/transproc.rb b/lib/rom/processor/transproc.rb\nindex 6dbd17d..9b6d35f 100644\n--- a/lib/rom/processor/transproc.rb\n+++ b/lib/rom/processor/transproc.rb\n@@ -91,16 +91,21 @@ module ROM\n   # Visit plain attribute\n   #\n\n\n\nIt will call block transformation if its used\n\n\n\n# If it's a typed attribute a coercion transformation is added\n   #\n\n\nIt will raise error if block and type used in the same time\n\n\n\n# @param [Header::Attribute] attribute\n   #\n   # @api private\n   def visit_attribute(attribute)\n\nif attribute.typed?\nt(:map_value, attribute.name, t(:\"to_#{attribute.type}\"))\nelsif attribute.meta[:coercer]\nraise StandardError if attribute.meta[:coercer] && attribute.typed?\nif attribute.meta[:coercer]\n           t(:map_value, attribute.name, attribute.meta[:coercer])\nelsif attribute.typed?\nt(:map_value, attribute.name, t(:\"to_#{attribute.type}\"))\n         end\n       end\n``\n. i try{}` but it fails\n. i can change to: \n\n``` ruby\ndiff --git a/spec/integration/mappers/overwrite_attributes_value_spec.rb b/spec/integration/mappers/overwrite_attributes_value_spec.rb\nindex c453bf6..ab82c51 100644\n--- a/spec/integration/mappers/overwrite_attributes_value_spec.rb\n+++ b/spec/integration/mappers/overwrite_attributes_value_spec.rb\n@@ -13,9 +13,15 @@ describe 'Mappers / Attributes value' do\n       relation :users\n   attribute :id\n\n\nattribute :name, from: :first_name do 'John' end\nattribute :age do 9+9 end\nattribute :weight do |t| t+15 end\nattribute :name, from: :first_name do\n'John'\nend\nattribute :age do\n9+9\nend\nattribute :weight do |t|\nt+15\n\nend\n     end\nrom = setup.finalize\n```\n. done\n. \n\n",
    "artemeff": "@solnic hi! In current version you're implement storing data in JSON, but what if we will be store it as is? Just like array of values \u2013 user can choose right structure and we can respond it's relation as collection of simple values.\nAnd I can take this adapter, btw :)\n. ",
    "Olefine": "@solnic\nFor schema class, we may implement method like it\nruby\ndef map_to_model(*args)\nend\nArgs is array of symbols(database fields). Using this data, we can simple generate model for user it want. Also need to think about what if map_to_model not called, what fields we should include into model?\n. @solnic I can implement this feature a little bit later on this week\n. @solnick Ok :)\n. @solnic done!\n. @solnic will rename it today, planning work on https://github.com/rom-rb/rom/issues/52 if you allow me to help you :)\n. @solnic done\n. @solnic can i help with other issues?\n. np, will fix it\n. @solnic  What you mean? Avoid model_class instance? \n. @solnic oh, so sorry, forgot about what value returns from const_set\n. ",
    "cored": "Maybe I'm misunderstanding the idea but you guys can correct me. Aren't we\naiming to have something like entity framework from Microsoft?\nOn Jan 13, 2015 11:21 AM, \"Piotr Solnica\" notifications@github.com wrote:\n\nAny idea what should be presented in Synopsis section? Right now it's\nrom-sql example which I don't like. Something in-memory should be enough.\nQuestion is: what should it be? /cc @aflatter\nhttps://github.com/aflatter @elskwid https://github.com/elskwid\n@kwando https://github.com/kwando @splattael\nhttps://github.com/splattael\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/46#issuecomment-69771228.\n. They have an example building an app with it; so maybe the README could\nmake an example like this. Like with the in-memory adapter but showing the\nmodeling side of the entire process?\n\nOn 13 January 2015 at 11:29, Piotr Solnica notifications@github.com wrote:\n\nI'm not familiar with entity framework from MS\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/46#issuecomment-69772708.\n\n\nRafael George\n. @solnic isn't better for tracking to have the items as separate issues?\n. @solnic Is this still a thing needed? \n. @cflipse Just curious, would this snippet be clearer? \nruby\ntimestamps.merge(tuples) if tuples.respond_to?(:merge)\ntuples.map { |t| timestamps.merge(t) } if tuples.respond_to?(:map). ",
    "adz": "Thanks!\nIt's interesting to try and see your vision. I've used active record with\nmanual data mapping to poro's with service objects interacting with the\nporo's. I'll have to think about what it means to have queries represented\nas relations...\nThe data capsule 'generated classes' approach makes me feel like it's more\nlike active record but to relations rather than direct to table. So I'm\ntrying to imagine this different setup.\nOn 03/11/2014 6:43 PM, \"Piotr Solnica\" notifications@github.com wrote:\n\nThanks Adam. I'm working on a couple of refactorings which will reveal\nlower-level objects and their interfaces. More specifically #52\nhttps://github.com/rom-rb/rom/issues/52 and #53\nhttps://github.com/rom-rb/rom/issues/53. There will be a nice Header\ninterface that will give all the information about attributes, their\nmappings, coercions and so on. This will be used by mapper and builders. I\nwill also clean up this mess in current mapper builder and probably some\nsmaller objects will come out of that.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/pull/57#issuecomment-61448953.\n. Appreciate your time helping me with comprehension. I get the idea of data\nmappers in general, it's more so the specific roles at play.\n\nSometimes I use active record just to provide data to other poro classes,\nso in that case the relation is doing the same work. However,  I would\nvery much like the ability to contain the terrible plague of active\nrecord calls that can spread when you're not being careful (or inherit in\ntypical rails projects!).\nI think the way the mapper works with model classes, or possibly class\nbuilders took me a while to clear up in my mind. The recent syntax change\nto 'define' instead of blocks  provides more clarity. Good move!\nI'd like to be able to write custom mapping to map to possibly multiple\nclasses,  so unsure of if that fits in the design, or if you think it's a\nbad approach...\nAlso, I didn't think the models being mapped to would be generated. It was\nsurprising, and not obvious from the dsl. That part could be improved to be\nmore intention revealing?\nOn 03/11/2014 11:32 PM, \"Piotr Solnica\" notifications@github.com wrote:\n\nThe trick is to not think about queries and focus on relations. And\nrelations are just...array of hashes, it's the data your application needs.\nWhat you do with those arrays is up to you - you can just live happily with\nhashes or map them to something more domain-specific if you will.\nActiveRecord is completely different even though you may see some\nsimilarities. With AR you think in terms of models giving you access to all\nyour data through a leaky query interface. In AR you say \"I'm gonna find\nall the users, order them by name and paginate the collection\" and then use\nthis to render, let's say, a user index web page. In ROM you say \"I use\nuser index view relation to render index page\". It's a fundamental\nphilosophical difference. Notice that it can be enforced via the\ninterface by making certain things private (I will probably make it\nconfigurable as I don't like software that's too opinionated or even\nconservative).\nThere's actually much more to it but it's probably a good intro to the\nbasic idea :) I'm going to describe those concepts in detail in a README or\nsome documentation for 0.3.0 release (due this month).\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/pull/57#issuecomment-61474203.\n. Interestingly isn't the same... but possibly more correct. \nWhat if both are nil or both are present? \n. Good answer ;)\n. So looks like we'll only ever instantiate \"Success\" or \"Error\" classes, so you could check EITHER @value OR @error and it would be sufficient. Although nothing stops someone going Result.new and having both nil, it's pretty unrealistic usage!\n\n...it feels like a haskell GADT with a (not quite) unified object interface. In Haskell you would have a type that can be one or the other, and nothing else -- and you'd have to case-match on the type before being able to call \"value\" or \"error\".\nWDYT about going type-based and on what you initialized rather than trying to infer:\ndef success?\n  is_a?(Success)\nend\nI guess it depends on whether this is open for new classes to be built that inherit Result (oo style). Then this might be bad, but seems like this is going functional/type style (it's an Either).\nAnother alternative:\nclass Success\n  def success?\n    true\n  end\n...\nclass Error\n  def success?\n    false\n  end\n...\n. ",
    "lavriv92": "we can use https://github.com/triAGENS/ashikawa-core as most popular ruby driver for arangodb \n. ",
    "wafcio": "https://github.com/rom-rb/rom-rethinkdb\n. based on csv example:\nid;name;age\n1;Jane;24\n2;Joe;\nWe have nil age for Joe, of course we can put for example 0 or \" \" but it doesn't look good\n. good point, but i think we can nil treat like 0\n. Yes, you are right. I changed attribute name from symbol to string in mapper and it start working.\nAnd yes +1 for symbolizing keys\nThanks\n. You are right. I will extend rom-json by add options like in rom-csv\n. :+1: \n. ",
    "maetl": "Very rough initial sketch: https://github.com/maetl/rom-neo4j\nThis raises a few questions about how best to integrate the concept of traversals over a sub-graph with the existing concepts of datasets and relations.\n. :smile_cat:\n. One API quirk I\u2019ve noticed from usage of this is the following tends to pop up in a few places:\n``` ruby\nclass NamedCollection < ROM::Relation[:memory]\n  forward(:reverse)\ndef by_recent\n    order(:date_thing).reverse\n  end\nend\n```\n. > Deprecate usage of Reader\nThough I don\u2019t have a problem with the reader conceptually, I think this change makes sense because the usage of read is subtly harder to document than relation (in rewriting the Rails tutorial, I struggled to find a good way to avoid having to explain the distinction between relation and reader which wasn\u2019t important in that context). Not an issue for people who have used ROM a little bit, but for people getting started or trying to understand how it works, it\u2019s an asymmetric concept that they touch on straight away, and this makes it easier to understand.\nThe other thing is that Relation::Loaded helps explain something which I struggled with at first when building the Neo4j adapter\u2014how and where relations are materialized.\n. > I'd say we should deprecate aliases on commands and stick to #call and #[]\nWhat was the original purpose of the aliases? To make the API more \u2018verb-oriented\u2019 or something along those lines?\n. This is excellent.\nIt\u2019s surprisingly abstract, and I found it difficult to comment on or explain my ideas, so apologies if the following doesn\u2019t make much sense.\nThings I like:\n- Neat and concise layering/composition that leverages existing behaviour\n- Cohesive API symmetry/design patterns (sharing consistent method arguments and the left-right pipelining)\n- It requires a tiny amount of code\nAPI design considerations:\n- Is #eager_load the right name in the high level API? It describes what it is rather than what it does, and requires a bit of context around ORM patterns or experience with ActiveRecord to understand what it means, which feels a bit out of place with the rest of the API. A simple verb like #load, #fetch, #materialize, #embed, #combine, etc, might be more expressive.\n- Unlike the rest of the ROM::Relation interface, it\u2019s not immediately obvious at a glance what structure the results are returned as (nested objects? flat tuples? callable proc?)\n- There\u2019s a bit of an inside/outside ambiguity with the relation style\u2014#eager_load is only available on the Lazy relation instance, which may confuse people who are drawn to trying to encapsulate these kinds of operations behind methods in the relation declaration itself. Some guidance around what does and doesn\u2019t go in the relation classes/DSL would be useful (something to consider for the docs I guess).\n. Gateway is okay from my perspective.\n. Alternatives to ROM::Gateway I just thought of: ROM::Store or ROM::Source.\n. > I also like your argument about knowing what a mapper does by just looking at it. Making mapper reject keys by default would be an implicit behavior.\nI also agree with this. I\u2019ve always found the mappers to make sense intuitively with no implicit or default rules attached. I think of them as objects that represent a transformation, where the actual data structure morphing/transformations are declaratively specified. In my opinion, transformations like rejecting keys by default should be explicit rather than implicit, as that helps keep the actual implementation closer to the concept/role of the mapper classes.\n. I prefer as too. Having map_with there as an alias is okay from my perspective. It\u2019s potentially a more intricate API than it needs to be, but I can see uses of both for readability reasons, depending on the particular style of client code.\nFor example, Sequel aliases where and filter.\n. > rom.relations[:name] and rom.relation(:name) return the same thing\nThanks for resolving that.\n. Thanks for noting. This line was copy/pasted from the original commit message when this file was added.\n. Just noting here that there\u2019s quite a lot of setup logic, before we reach the first test expectation, which makes me wonder if the test is testing these :let blocks as much as the actual eager load results.\n. ",
    "jdickey": "That last tick-box is going to be the key, I think. I'd argue, not for a shorter synopsis, but for a more sequential, narrative one. Get the casual reader who's still on the fence about whether to use this or not to buy into the ideas: clean, SOLID design, separation of concerns, \"less magic\" as enabling better understanding, testability and reuse through a more visibly connected chain of parts, and so on.\nOne question that the README completely ignores that people coming from Rails are going to ask about is \"how do we handle evolution?\" Rails' migrations and seeding mechanism have their own (often steep) downsides but, once you understand the techniques, it's straightforward to understand how an app's database support evolves over time. How much thought has been put into that so far?\nA lot of people are going to look at that blob of inline table-creation SQL and ask \"shouldn't an ORM shield us from that, at least by default?\" That's a big part of the appeal of ActiveRecord; use a DSL to define creating and changing a table and let the library handle the gory details of Sqlite vs Postgres vs MySQL vs JoeBobBriggsAwesomeDatabase and the developer just gets on with it. That will come back to bite the developer as he maintains his code, but we still need to convince him to write it using ROM to begin with.\nJust what pops into my mind straightaway; I'll give this some thought (and keystrokes) as I get time over the next couple days.\n. ",
    "kwando": ":+1: \n. Woho! =D\n. Goodie =)\n. I would like to see something high level framework/API for migrations, where it would be possible to migrate multiple repositories (with different adapters) in the same migration script. Ofc the details would be adapter-specific.\n. yeah, it is not a small project... just dreaming =)\n. Oh, this would be awesome =)\nI usually define  a private base method that all other methods is using.\n``` ruby\nclass UsersRelation < ROM::Relation[:sql]\n  dataset(:users)\ndef active\n    base.where(active: :true)\n  end\nprivate\n  def base\n    select(:id, :username, :name).where(deleted: false)\n  end\nend\n```\nHaving something like you suggesting by default in ROM would be nice option.\n. Sorry, I missed the first line of the backtrace..\n/Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/hash.rb:12:in `dup': can't dup NilClass (TypeError)\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/hash.rb:12:in `block in <module:Transproc>'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `[]'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `call'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/hash.rb:21:in `block in <module:Transproc>'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `[]'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `call'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:16:in `block in compose'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `[]'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `call'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/array.rb:7:in `block (2 levels) in <module:Transproc>'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/array.rb:7:in `map!'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/array.rb:7:in `block in <module:Transproc>'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `[]'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `call'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/array.rb:3:in `block in <module:Transproc>'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `[]'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/transproc-0.1.0/lib/transproc/function.rb:11:in `call'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/rom-0.6.0.beta1/lib/rom/mapper.rb:86:in `call'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/rom-0.6.0.beta1/lib/rom/relation/composite.rb:47:in `call'\n    from /Users/kwando/.rbenv/versions/2.2.0/lib/ruby/gems/2.2.0/gems/rom-0.6.0.beta1/lib/rom/relation/composite.rb:63:in `to_a'\n    from /Users/kwando/projects/work/untitled/test.rb:33:in `puts'\n    from /Users/kwando/projects/work/untitled/test.rb:33:in `puts'\n    from /Users/kwando/projects/work/untitled/test.rb:33:in `<top (required)>'\n    from -e:1:in `load'\n    from -e:1:in `<main>'\n. No problemo, just stumbled onto it today =)\n. I know, but the error that is raised is a ROM::SQL::ConstraintError which inherits ROM::CommandError.\nThe problem with the form code is that the form expects the error to be a ValidationError (which also is kind_of?(ROM::CommandError).\n. You cannot use a module with a new method there, rom does a type check in the model method and it expects a Class.\n. In recent versions of ROM one can achieve the desired output with this mapper definition.\n``` ruby\n step{\n    wrap(:tags){\n      attribute('tag1')\n      attribute('tag2')\n    }\n  }\nstep{\n    attribute(:tags){ |h| h.values }\n  }\n. I'll do it then =)\n. Added a spec for the behavior.\n. It might not be very \"functional\" to have query those methods, but I often end up with \"if result.error\" code anyway\n. ruby\nenv = ROM::Environment.new\nenv.use(:auto_registration)\nrom = env.setup(:memory){\n  relation(:users)\n}\nrom.relation(:users)\n```\nTurns out I have to use the :auto_registration plugin. Feels kind of silly to have to use that with the setup DSL though.\n. @solnic I'd like something that communicates the structure of the input better. Something like this would be easy to read, not sure how feasible it would be to implement though.\nruby\nrom.command do\n  create(:users){\n    create(:tasks){\n      create(:tags)\n    }\n    create(:books){\n      create(:authors, from: :author)\n    }\n  }\nend\n@endash Apologies for the meta magic =P\n. @solnic Thanks for the clarifications ^^.  When I think about it, and with you clarifications above, you suggested API makes perfect sense.\nI was thinking about the execution order of the commands, and thought about it backwards.. i.e. create task then create user, but it ofc it has to be the other way around.\n. +1 xD\n. Will check tomorrow =)\n. Using 1.0.0.beta1 btw.\n. @solnic Changed the repro to this and it still blows up with a mapper missing.\n``` ruby\nrom = ROM.container(:sql, 'mysql2://root:root@127.0.0.1:3306/sms_test2'){ |config|\n  class Sites < ROM::Relation[:sql]\n    dataset(:plants)\n    register_as(:plants)\n  end\nclass TestMapper < ROM::Mapper\n    register_as(:api_mapper)\n    relation(:plants)\n  end\nclass CreateSite < ROM::Commands::Create[:sql]\n    register_as(:create)\n    relation(:plants)\n  end\nconfig.register_relation(Sites)\n  config.register_mapper(TestMapper)\n  config.register_command(CreateSite)\n}\nputs rom.relation(:plants).as(:api_mapper).to_a.inspect # => {id: 33, name: 'AWESOME SITE'}\nputs rom.command(:plants).create.call(name: 'HELLO WORLD').as(:api_mapper).to_a.inspect\n```\n. This is just a repro, I'm not using the block form in my \"real\" code.\n. Have you tried register relations manually?\nruby\nclass UsersRelation < ROM::Relation[:sql]\n  register_as(:users)\n  dataset(:UsersTable)\nend\n. Thanks a lot for the quick reply, that works like I want :). ",
    "kchien": "You're welcome.  Thanks for creating such a cool project!\n. @aflatter I started looking into this, but it appears that to use Rails::Application#config_for, you need an instance of the app.  Will some of the code that was removed in rom-rb/rom-rails@d00c4f4e0defd15fe2859a4394cfa7ce9e2c2389 have to be brought back?  Is there another way to pass the app to ActiveRecord::Configuration?\n. @cflipse Thanks! :+1: \n. Closing this issue since it's no longer a problem.  However, I made a similar fix in my fork that I didn't push to GitHub, which resulted in the error in issue #274 .\n. @solnic I tried requiring many files, but I couldn't get past this error.  On the other hand, does my test setup look correct? \n. @solnic Thanks for your help.  If I remove the lines:\n``` ruby\nmodule UserCommands\n  class Create < ROM::Commands::Create[:yaml]\n    relation :users\n    register_as :create\n    result :one\n# define a validator to use\n#     # validator TaskValidator\n\nend\nend\n```\nthen the test will pass.  However, being new to rom, I'm not quite sure when and where I should define my create command.  I tried placing it after rom.finalize but the problem still persisted.\n. Thanks! That fixed the problem. I believe I may have uncovered another undefined method error, so I'll create a new issue.\n. There appears to be a relationship between the the integer 1 here and on line 38, but would it be clearer to extract it to an explaining variable within this example?\n. Could this be refactored into a Hash lookup, so that the duplication could be removed? The keys would be the symbols (:create, :update, :delete) and perhaps the values could be a be a proc representing the code in the then clause. If the key isn't found, the error can still be raised.\n. ",
    "namusyaka": "No worries.\nBTW, thank you for the awesome project!\nI can't wait to support for ROM on Padrino.\n. Of course, I knew it. I've been developing Padrino as a committer.\nAnd I'm thinking of using ROM with my Padrino projects :) Maybe we will support for ROM before releasing 1.0.\n. ",
    "wikimatze": "Would like to work on the integration, any chance @namusyaka to do some pair programming? With vim and tmux?\n. ",
    "splattael": "We decided to define these extra deps in bundler group \"tools\". This group is skipped on Travis.\n. Hi @alpardal,\nactually, we could do both depending on the context:\nNo args provided -> instance_eval\nThe current behaviour.\nruby\nrom.command(:tasks).try { create(...) }\nArgs provided -> call with self\nruby\nrom.command(:tasks).try { |command| command.create(...) }\nOne possible implementation might be yield_or_eval.\nWDYT?\n. @alpardal Done. Mind trying master and give feedback? :smile: \n. @solnic I've squashed the commits. This PR is ready to merge.\n. @solnic Changelog updated :)\n. After fce713b running rake spec is flaky because there is no way to unregister adapters.\nThe error is:\n```\nFailures:\n1) ROM::Adapter::Memory setup\n     Failure/Error: assert_instance_of adapter, adapter_instance\n     Minitest::Assertion:\n       Expected #<#:0xa713a40 @uri=#, @options={}, @connection=#> to be an instance of ROM::Adapter::Memory, not #.\n     # /home/peter/.rvm/gems/ruby-2.1.5@pg/gems/minitest-5.5.0/lib/minitest/assertions.rb:130:in assert'\n     # /home/peter/.rvm/gems/ruby-2.1.5@pg/gems/minitest-5.5.0/lib/minitest/assertions.rb:208:inassert_instance_of'\n     # ./lib/rom/adapter/lint/common.rb:30:in `block in '\nFinished in 0.31096 seconds (files took 0.96244 seconds to load)\n192 examples, 1 failure\nFailed examples:\nrspec ./lib/rom/adapter/lint/common.rb:29 # ROM::Adapter::Memory setup\n```\n. Sure, closing.\n. @solnic That's my plan. I'm test-driving this right now :)\n. No need to sorry! \"Doppelt gemoppelt h\u00e4lt besser\" :dancer: \n. Just an idea. How about define lint methods like that:\nruby\nlint \"schemes returns any supported scheme\" do\n  assert \"#{adapter}#schemes must return at least one supported URI scheme\" do\n    adapter.schemes.any?\n  end\nend\nToo fancy?\n. I've merged with master. We can squash afterwards, right?\n. After the Adapter/Repository collapse: Are we still linting adapters; or now repositories? :dancers: \n. Merged with fast-moving master.\nI'm still not sure if I'm mistaken in 69e383b by ditching Adapter namespace.\n. @elskwid Sure, no problem. Squash it :)\n. Nicely done! :+1: \nAs long as rubocop passes :shipit: \n. @elskwid Interesting. How does your PR conflicts with #120. Do we still need scheme registration after #120 has been merged?\n. It is public. Since Ruby 2.1. Bad luck.\n. :+1: :green_heart: \n. @solnic I've rebased this PR against the latest master and squashed to one commit.\nCould you please review the benchmarks? \nI had to adjust Loading ONE task with its user and tags benchmark. Before it loaded all tasks instead of just one.\n. Merged in 2964177add1f8705d0e0cbdb88c38620700cf4a0\n. I like it! :+1:\n. @tylerhunt Thank you! :)\n. :+1: for call\n. I like Gateway!\nShould we deprecate the usage of Repository somehow to make the transition easier?\n. Thank you so much :+1: :green_heart: \n. :+1: :+1: Thank you!\n. You're right. Fixed and rebased.\n. @solnic \nWith minitest we can use assert_operator adapter.schemes.size, :>, 0.\nIt gives a nice error message IMHO.\nAlternatively, we could also use assert adapter.schemes.any? to match the assert message better?\n. schema is not used anymore.\n. .rb extension is not needed\nrequire 'rom/memory'\n. ",
    "aflatter": "@solnic: Please correct me if I'm wrong.\nROM::Config is being moved to rom-rails as part of rom-rb/rom-rails#16, so ROM will only support the following two formats:\nruby\nROM.setup(database: 'mysql2://foo')\nROM.setup(database: {uri: 'mysql2://foo', options: {foo: 'bar'}})\n:database will not be a reserved key after the change.\n. I'm for removing connection from the abstract adapter. Additionally, I'm still of the opinion that in case of this bug object identity would have been the better default, because that's what we expect. Equality on uri and options might shadow similar issues, e.g. hidden state in the adapter where ROM assume's there is none.\n+1 for not having to override #initialize.\n. You could use equalizer on object_id I guess ;-)\n. So we're not removing connection?\n.  Comment by aflatter\nWednesday Jan 07, 2015 at 18:41 GMT\n\nI guess in the preparation phase (before initializers run) we'd just not define a default repository. If initializers don't configure a repository at all, we should skip setup and warn. That way, you don't get a warning if you use neither AR nor rom-sql, but something else. How does that sound?\n.  Comment by solnic\nWednesday Jan 07, 2015 at 20:14 GMT\n\nYes that sounds correct\n.  Comment by solnic\nSunday Jan 11, 2015 at 11:32 GMT\n\nThat's why you have separate validator objects. It's not an optimal solution but I've found it to be a good fit in Rails context. Here's how you could do it now:\n``` ruby\nclass NewUserValidator\n  def self.call(params)\n    params.valid?\n    params.errors.add(:email, :taken) unless unique_email?(params.email)\n    params\n  end\ndef self.unique_email?(email)\n    ROM.env.relations.users.where(email: email).count.zero?\n  end\nend\n```\nPlease note that this is very ugly and verbose. I'm planning to add an interface for that so it will work without the need to write any custom code.\n.  Comment by mcls\nSunday Jan 11, 2015 at 11:45 GMT\n\nOk, that makes sense :smiley:  \nNow I'm confused about the ActiveModel::Validations being defined on the params/input object instead of the validator.\nIs that because it's easier to include the ActiveModel::Validations module there?\n.  Comment by solnic\nSunday Jan 11, 2015 at 11:50 GMT\n\nThe reason for that is to meet Rails expectations which as an object with attributes and errors :( This way it Just Works\u2122 with form helpers and libraries like simple_form.\nI agree, it is confusing. I would love to find a better solution to this problem that would also work with Rails assumptions. I believe it should be possible to mix ActiveModel::Validations into validator module and do some tricks to make it work with params injected into a validator instance. I haven't tried to do it yet so I'm just guessing :)\nPlease notice that we want to separate input params and validations eventually, so this would actually be inline with what we want to achieve.\n.  Comment by mcls\nSunday Jan 11, 2015 at 12:15 GMT\n\nOk, so I got this to work after accounting for a subtle issue.\nIn rails #valid? clear the errors first (see https://github.com/rails/rails/blob/v4.1.7.1/activemodel/lib/active_model/validations.rb#L314-L320). \nSo in order to add errors in the validator object I had to check for params.errors.blank? instead of params.valid? and then raise the ROM::Model::ValidationError.\nBasically the snippet became:\n``` ruby\nclass NewUserValidator\n  def self.call(params)\n    params.valid?\n    params.errors.add(:email, :taken) unless unique_email?(params.email)\n    unless params.errors.blank?\n      raise ROM::Model::ValidationError.new(params)\n    end\n  end\ndef self.unique_email?(email)\n    ROM.env.relations.users.where(email: email).count.zero?\n  end\nend\n```\n.  Comment by solnic\nSunday Jan 11, 2015 at 12:18 GMT\n\n@mcls oh sorry, totally forgot about raising the error part :) I reported a related issue which describes potential improvements => #15 \n.  Comment by stevehodgkiss\nSunday Jan 11, 2015 at 12:20 GMT\n\nThe way I see it is validation on input params should be context free. The validation for uniqueness (and other contextual validations) should live in the command object/use case that implements this behaviour.\nUniqueness validations have a race condition between the validation code running and the insert statement (assuming you have a unique index), where another request could take the username after another request has already validated that it's available. With ActiveRecord you'd catch the record not unique exception and retry so that validations would catch it that time around and display the appropriate message to the user. How would ROM commands handle this scenario?\nruby\nclass SignUp\n  def perform\n    retry_once ActiveRecord::RecordNotUnique do\n      validate!\n      create_user\n    end\n  end\n    # ...\nend\n.  Comment by solnic\nSunday Jan 11, 2015 at 12:26 GMT\n\n@stevehodgkiss yeah rom-sql command catches low-level constraint violations and return an error back for further handling in the application layer. See this spec\n.  Comment by solnic\nSunday Jan 11, 2015 at 12:28 GMT\n\nbtw that's why I started with validations on input params and a separate validator object for use-case specific validations (aka contextual). But it turned out to be too messy (at least when using AM stuff :()\n. What's supposed to go into URIs (and query parameters) and what should be part of the options hash?\n. @solnic so why do we have options at all?\n. I'd prefer the naming to not be callback-oriented. You try to run a command and you get back a result which is simply a value.\n. ``` ruby\nresult = rom.command(:users).try { create(name: 'Jane') }\nresult.or_else { |error| ... }\n      .and_then { |result| ... }\nresult.value # fails if command was not succesful\n``\n. Maybe Rust'sstd::resultcan serve as inspiration here: http://doc.rust-lang.org/0.11.0/std/result/type.Result.html\n. Yes. As I see it,config/rom.ymlwould be optional. You'd be free to define your repositories in an initializer if you like that better.config/rom.ymlwould have higher priority than deriving the default repo from ActiveRecord though.\n. This should be quite easy to implement, making it a good candidate forhelp-wanted!\n. @kchien I don't think you need touchActiveRecord::Configuration. Instead, you can check hook into the initizliation process [here](https://github.com/rom-rb/rom-rails/blob/master/lib/rom/rails/railtie.rb#L32) and construct aROM::Rails::Configuration` by reading from the YML file if it exists.\nActiveRecord::Configuration is just for reading the default connection hash directly from ActiveRecord and converting it to Sequel style. It shouldn't need to know anything about ROM.\nDoes that help? :+1: \n. And by \"now\", I mean after #106 was merged ;-)\n. Specs don't pass yet, as :adapter is not supported anymore.\n. @solnic think you asked about this on Gitter. \n. Right, but we'd need to also include the path to the repository in the map, plus we can't rely on the constant being defined. {sql: ['ROM::SQL::Repository', 'rom/sql']}\n. That is simple and would work with our repositories.\n. @solnic @elskwid @splattael so after a heavy rebase, I think this is ready to merge.\n. @solnic are you talking about repositories provided as part of the ROM project or 3rd-party/custom repositories or both?\n@elskwid :tada: \n. @solnic Yes, but would that be part of the public API or not? If yes, why?\n. I agree. Also, Lint is still in ROM::Adapter which is now the only thing using the word adapter.\n. @solnic ack.\n. I think our ideas were more like this:\n``` ruby\nOption 1\nrom.read(:mapper_name) { users.active.admins.by_id(1) }.one!\nOption 2\nrom.read { users.active.admins.by_id(1) }.map(:mapper_name).one!\n```\nNote that users and the rest of the relation are close together, whereas in your example it's somewhat disconnected. Not sure why the method is called map in your example, but I guess it has something to do with your concern about encapsulating data access.\n. It's a bit longer, but easy to understand. :+1: \n. Haha, let's go with that :+1: Thanks for explaining, you successfully managed to convince me not to :fire: reader. ;-)\n. :partly_sunny: \n. ruby\nrom.try { users.create(user_attrs) }\n  .and_then { |user| tasks.create(task_attrs.merge(user_id: user[:id])) }\n. (Changelogs need to be updated too)\n. @solnic probably a good time to rename base_name to dataset, wdyt?\n. Sure, I am, but can't give an ETA. :-(\n. I'll try, but I'm behind schedule as I got struck down by a flu. :-(\n. I'd say we'll leave it open for now.\n. We talked a little bit about this on Gitter and I think the preferred direction is to have integration gems like rom-rails to derive the defined classes from conventions (or policies in yaks speak), right?\n. Just some ideas.. The challenge is to come up with an API that doesn't feel too alien in the Ruby world.\n``` ruby\nOption 1\nresult.and_then do |value|\n  if value % 2 == 0\n    Error(\"An even number\")\n  else\n    Ok(value)\n  end\nend\nOption 2\nresult.and_then do |value, err, ok|\n  if value % 2 == 0\n    err[\"An even number\"]\n  else\n    ok[value]\n  end\nend\nOption 3\nresult.and_then do |value|\n  if value % 2 == 0\n    [:err, \"An even number\"]\n  else\n    [:ok, value]\n  end\nend\n``\n. This is not specific to ROM but to Rails - and it's [Getting Started guide](http://guides.rubyonrails.org/getting_started.html) requiresgem install rails`. I'm not sure why you want to work around that, maybe because your rubygems installation is wrecked or something, but you can probably create a Gemfile containing just:\n$ $EDITOR Gemfile\n$ cat Gemfile\nsource 'https://rubygems.org'\ngem 'rails', '4.2.0'\n$ bundle\n$ bundle exec rails new rom-todo-app -JTS -m http://rom-rb.org/tutorials/code/rom-todo-app-template.rb\nThen move rom-todo-app somewhere else and delete the current directory.\n. :clap: \n. Nice, thanks!\n. A pragmatic implementation of Option and Result would definitely be useful. :)\n. Yup, I hope so. :)\n. Yes and no. This PR fits the way ROM currently works, but I'm not sure what I think about specifying the same mappers over and over again for each query or command that you do. I'd vote for merging though because I do stuff like Foo.new(rom.command(:create).call(...)).\n. I'm planning to add support for unwrap(:user) to lift all keys before merging. Currently either a hash or block needs to be passed.\n. @solnic re supporting unwrap without explicitely specifying all keys: Would I have to rely on header here (my adapter currently does not define a header) or would it be okay to add another case here? Currently, I get an error when passing a Symbol and no block because attributes_from_hash tries to iterate over the first argument.\n. @solnic but then attributes have to be defined somewhere while I'd like to rely on the \"schema\" used by my adapter. Would you say that adding header support to my adapter is required here?\n. @solnic sure, go ahead. :+1: \n. @cflipse I ran into the same thing literally minutes ago. The :conditions option on the association class methods does not seem to have any effect.\n. For future reference: We discussed this on Gitter and we'll go with what we have right now, which means that #one and #one! currently require the relation to implement #count. In the future, we may provide a naive implementation using Enumerator#next (to check if there's more than one tuple in the relation) and the possibility to provide an implementation in the adapter in order to skip loading all records if it hurts performance.\n. I know it's not the scope of this PR, but I can use a relation name twice and it won't blow up?\n. ruby\nrepositories.each do |key, repository|\n  datasets[key] = repository.schema\nend\n. Let me open an issue for that so we don't forget.\n. Refactoring blindness :dart: \n. s/repository/Repository\n. @solnic all of these will turn into ROM.setup(:memory) which is probably a sign that the change is a good thing.\n. True! :+1: \n. @elskwid Yes, that's the reason. That's also why I don't think @solnic proposal works, though I'm not familar with Inflecto.\n. ",
    "alpardal": "@solnic I agree with your points, it's just that instance_eval breaks, IMO, the \"expected\" behavior, and may surprise new users.\n@splattael I like yield_or_eval: simple to change and doesn't break the current api.\n. @splattael Looking good, thank you :+1: \n. ",
    "chenge": "QUESTION is, remove the require, why the test passed?\nmodule RomTodoApp\n  class Application < Rails::Application\n    #require 'rom-rails'\n. ",
    "pointlessone": "Why don't we have both?\n``` ruby\nInferred file names (e.g. \"users.yml\" for users relation)\nROM.setup(uri: 'yaml://path/to/directory', files: true)\nExplicit file names\nROM.setup(uri: 'yaml://path/to/directory', files: {\n  users: 'people.yml', tasks: 'todos.yml'\n})\n```\n. ",
    "phlipper": "This is a really nice little changset, I'd only recommend adding some context to the README.\n. ",
    "mcls": "Thanks for explaining that :)\nIf I understand it correctly there will be two validation steps:\n1. Validate the form's inputs (url)\n2. Validate the params passed to the command (the data returned by FromYoutube)\nThis what I now have in my VideoForm#commit!:\n`` ruby\n  def commit!\n    videos.try { |command|\n      # Run form validations,#try` will catch the validation error\n      input = self.class.params[params]\n      self.class.validator.call(input)\n  model = Video::FromYoutube.call(input.youtube_id)\n  attrs = model.attributes.except(:id)\n  command.create(attrs)\n}\n\nend\n``\n. I have to call the validator insidecommit!now, \nbecause it's different from the one defined on the command.\n. I just noticed that theRelationAlreadyDefinedErroronly gets raised when using the setup DSL.\nShould I move that toROM::Setup::Finalize`?\nhttps://github.com/rom-rb/rom/blob/85226fae8624e278703175aa1c23ceabff2e9c74/lib/rom/setup_dsl/setup.rb#L21\n. On my rom-sql fork, remove the mapper here: https://github.com/mcls/rom-sql/blob/master/spec/integration/read_spec.rb#L83-L85\n. Ok, I'll update that\n. :+1: \n. ",
    "muescha": "here is also blackmagic? this generates a relation for me magic?\nruby\nclass Users < ROM::Relation[:memory]\nend\nwhich i can use later as:\nruby\nrelation :users\n. i mean it creates the :users for me as magic. in other classes i need register_as - but here not\n. is the first example code snippet not too much boilerplate code? too many repetitions? \n. @mjtko \ni commented out the repetitions:\n``` ruby\nrequire 'rom'\nrequire 'virtus'\nROM.setup(:memory)\nclass User\n  include Virtus.model\n  attribute :first_name\n  attribute :last_name\nend\nclass UserPresenter < SimpleDelegator\n  def full_name\n    \"#{first_name} #{last_name}\"\n  end\nend\nclass Users < ROM::Relation[:memory]\nend\n\nclass UserMapper < ROM::Mapper\nrelation :users\n\nattribute :first_name\nattribute :last_name\nend\n\nclass UserEntityMapper < UserMapper\nregister_as :entity\n\nmodel User\nend\n\nclass UserPresenterMapper < UserEntityMapper\nregister_as :presenter\n\nmodel UserPresenter\nend\nrom = ROM.finalize.env\nrom.relations.users << { first_name: 'Jane', last_name: 'Doe' }\nuser = rom.relation(:users).map_with(:entity, :presenter).first\nputs user.full_name\nJane Doe\n```\nbut: maybe i miss something behind this example or what this example should show - because i am not so familar with rom\n. should the SimpleDelegator not named as SimpleDecorator?\nruby\nclass UserPresenter < SimpleDelegator\n  def full_name\n    \"#{first_name} #{last_name}\"\n  end\nend\n. ok thx @all for clarification\n. Question: is :entity here a magic static keyword or an entity defined before?\n. how about a very basic default reflector (just add s like user -> users) \nand if some one need an advance reflector then he need to setup a reflection gem (or in case of rom-rails select the rails reflector)\n. ok - they are listet here with status invalid :(\nhttp://rom-rb.org/status/\n. FYI: the nepalez repo moved to: https://github.com/rom-rb/rom-migrator \n. or add both:\nregister_relation with one argument\nregister_relations with array argument & argument list\n. comnplies -> complies\n. ",
    "cflipse": "(also, I suspect that there's something off with a rake load path, that it's not finding the task it's depending on ...)\n. I'll pick this one up.\nAdjusting the Mapper and Relation generators to:\n- Produce the class version\n- use autoload-safe file names\n- accept an optional adapter argument\nAnd add a generator for Forms\n- optional adapter argument to generator\n- generate an integration spec/test for the form\n. Anything left on this?  Between rom-rb/rom-rails#30 and rom-rb/rom-rails#25  I think it's been covered?\n. SimpleDelegator is a stdlib ruby class.\nhttp://ruby-doc.org//stdlib-2.0/libdoc/delegate/rdoc/SimpleDelegator.html\n. Would it be possible to split this up a bit?\nI'm finding the current Relation::Loaded structure to be quite awkward -- hard to build up and reuse things; it breaks the \"drop to SQL\" efficencies of aggregate functions, etc. Migrating code from env.read to env.relation(){} feels like a step backwards in utility right now.  I'm fairly certain that the Lazy relations will address that; and I'd like to see that on Master soon.\nCurrying and composition are (extremely) nice to haves, but I don't think they should hold up the base case.\n. Outside of #first returning a tuple, rather than using the mapper (one or two spec failures there) it seems well.  My pagination shim works, so long as it's the last thing in the chain -- good enough for me, at the moment.\n. https://gist.github.com/cflipse/07beec78382b911ebd2b\n. Yep.\nDatasetPagination.new(rom.relation(:foo).bar.as(:foos)).page(2)\n. being less order dependant, for a start.\nRight now, if I were to do DatasetPagination.new(rom.relation(:foo)).bar.page(2) it would fail, because the return from bar skips charlatan wrapping. \nThis also means that, if I needed to do two such things, I'm pretty sure it would fail.\nAlso, for that matter, at present, I've still got to write a couple of methods in my relation.  They're not hard, by any means.\nMaybe an include in the relation, but it would be more or less up to the adapter to define appropriate pagination methods.  Maybe being able to add strategies in a chain of responsiblity to the relation.\nrom.relation(:foo).paged.page(1).by_bar(223).as(:foos)\nThe trick is, at the end of the day, that there's a need to be able to expose additional methods in the resulting object.  They don't have to be there by default, and a straight decorator can get very tricky to manage, but ...\nThe pagination methods are, in some part, basically just aggregate functions, asking for more data that we want to expose via the relation.  They're like count or sum(:bar_count) in that they're additional methods on the relation, that don't return a relation.  And the implementation of them is going to be adapter specific.\n. rom.relation(:foo).with(:pagination).with{|r| DataSummation.new(r, :bar_counts) }.page(1).as(:foo_reports)\nspitballing  a different structure, maybe\nI guess you'd have to register the :pagination key, with a callable in there.\naggreages[:pagination] = ->(relation) { DataPagination.new(relation) }\n. ah!  So, it's not wonky on ordering until I call as.  That's good to know; I thought I was misreading something in Charlatan\n. fixed in https://github.com/rom-rb/rom-rails/commit/6dd06dc4b280e991c27e1f152335bef6f0d74b7c\n. presently, I have to dig in for form.result.value[:id] to get the show-page redirect that's standard rails controller flow.\n. This looks like it'll blend in really well with #185, once that's in place.\nAlthough I think getting something in place for a 0.3.1 release might still be a good idea, even if it gets updated once rom-0.7.0 goes out.\n. Yup.  I'll work on wiring that up.\nSaw on gittr that you're hoping for a 0.6.1 release sometime this week?\n. work in progress:  https://github.com/cflipse/rom-rails/tree/result-data-object\nIn some sense, this feels a bit clunky to me, acutally poking through it.  The suggested API breaks, so I'm starting from a simpler point, and once the basics are down, I can try and shift up to it.  But in looking at it, I'm thinking it might be simpler and more consistent to do something more like:\nruby\n  result = form.save\n  object = result.as(:entity)\nbut that requires the result to know about the relation, and it's mapping, and that might be pushing information too far down.\nI'm pausing here because it's late and I'm tired; I won't likely get a chance to poke at this again until Thursday, late ... more likely Friday evening.\n. it's the registered name of a mapper.\n. Do the changes in rom-rb/rom-rails#35 address this?\n. starting some work on this.  You can look over my shoulder at https://github.com/rom-rb/rom/pull/195\n. If there are no attributes specified, what's the expected behavior?\nAnd how does this mesh with the exclude option?\n. Okay,  everything specified in #192  seems to be covered by this.\nCleanup, moving stuff around, and documentation still need to happen, but generally:  thoughts?\n. Just remembered, forgot to note this earlier:\nOne thing I had to do that I don't like,  demoed here:\nhttps://github.com/cflipse/rom/commit/d05afbefc967444b88730cdb132fc69af8a7a1ba#diff-e0b55668c593b9e34a8aad512e592a24R113\nUnless I'm missing something, I cannot access the adapter type within the class definition, so it has to be redundantly declared in the use call.  Is there some alternative to that?\n. functionally?  Nothing.  It could go in as-is, I think.\nI'm not thrilled with repeating the adapter specification, however.  It would be good if the DSL were to be able to know it was operating in the context of an :sql adapter, and check there automatically, rather than it being required to be specified in the use line.\nessentially, the use implementation should be able to check an adapter_type and use that, rather than requiring it to be specified.  This is complicated somewhat by the fact that the adapter types are registered, rather than hard-coded.  There's some reverse-lookup that can be done, I just havn't pulled on that thread.\n. not quite ... nil != 0, particularly if you include negative numbers in your sorting.\nNil values don't flow into the sort; the question is if they should lead or trail the sorted order.    Different RDBMS' have different opinions on if it goes first or last, so it's a judgement call, but they SHOULD NOT appear in the middle of the list.  Personally, I'd sort nil's to the end.\n. Test to reproduce is here:\nhttps://github.com/cflipse/rom-rails/commit/a17012030c046634fb34661ac68c5c1bb3b89a2f\n. So, I can make that specific error go away with a small code change, but\nHere's the thing:  ActiveRecord lets validation errors bubble all the way up, typically.  You violate a database constraint, it explodes immediately.  This is kind-of good, as you get an error close to the failure.  ROM swallows the constraint errors and return them in a failed command data object, and you check / verify a few lines down.\nUnfortunately, that error accessor is also the place where we put validation failures.  Same attribute, different APIs.  We can catch the constraint failure, and successfully report that the command has failed ... and rails will, in most cases, re-render the form, and attempt to display the validation error messages.  Which will explode with another no method error, this time for [].  And it'll be even further away from the source.\nIt kind of feels to me like the issue is that we conflate validation failures and persistence failures in the same spot, and the solution lies closer to CommandRegistry#try  .. I'm not entirely sure.  @solnic, thoughts?\n. in progress:  https://github.com/cflipse/rom-rails/tree/constraint-errors\nIf you pull that branch and run the specs, you'll get:  \n1) Form #errors recovers from database errors\n     Failure/Error: expect(result.errors[:email]).to eq []\n     NoMethodError:\n       undefined method `[]' for #<ROM::SQL::ConstraintError: ROM::SQL::ConstraintError>\nSo, on a failure, the form assigns and treats the error as the value coming back from command.try, which nests whatever real failure it got.  Sometimes, that's a validation error.  Sometimes, that's the database constraint.\nThe form is expecting the nested command error to conform to AM::Validations, which the constraint does not do, nor should it.  For those violations, I think all we've really got is a string message, and we can't assign it to the field or fields that triggered the violation.\nI suspect what we're looking at is more along the lines of having the forms using an error proxy, that can look at both \"types\" of failures,  and present them in a non-explody kind of way.  That might also clean up the 'pre-validation' error blocks that I had to do to make the forms render cleanly in the first place.\n. fixed in rom-rb/rom-rails/pull/35\n. I'm good with it.  I tend to prefer \"single entry\" command objects use call anyway, just for the proc compatibility\n. Unfortunately, where isn't the same as join ... on for outer join scenarios; there really does need to be a way of handling the on conditions specifically.\nselect * from users left join tasks on tasks.user_id = user.id and tasks.state = 'active' is different than\nselect * from users left join tasks on tasks.user_id = user.id where tasks.state = 'active' ... the former gives back all users, with their active tasks.  The latter gives back only users with active tasks.\nFrom what I can make out, additional join conditions could just  get added to the graph call here:\nhttps://github.com/rom-rb/rom-sql/blob/4a16c3c0553c1205c515f8a7f3f427236ad31660/lib/rom/sql/relation/associations.rb#L100 by having the join_keys include the additional criteria  (well, there and the other spots that graph is called)\n. That works for me.\nWe may or may not want to just let that completely subsume all of the FK/join key specification that exists currently; I'm not sure how nice it looks with both:\none_to_many :tasks, key: :user_id, on: { state: 'active' }\nvs\none_to_many  :tasks, on: { user_id: :id, state: 'active }\nI think I'm okay with either.  Maybe the mental gymnastics required to figure out which direction the keys go in one_to_many vs many_to_one argue for keeping the key paramter.  I wouldn't eliminate the on nest though, I think that clarity level is needed.\n. I like that; the graph structure looks quite useful, as I was considering that something simliar is needed for commands (create a user, stream it into several task creations, for example).\n#eager_load might do with some synonym poking ... I like combine,  possibly even merge though I'm not sure that's the right connotation.  nest might be overload with other mapper related methods and cause confusion, and tree is probably too implementation revealing.\nSomething to emphasize in the docs might be that the right side is a tree structure; and therefore eager_load can come in with multiple arguments ... I see it in the specs, but it's not called out in the YARD.\nAdditionally, it might be good to be able to expand nodes in some way ... maybe Graph#eager_load which returns a new graph at the same level, with the additional ags appended to the node list?  Allows for gradual construction, still.\n. Umm, seems localized to a specific app.  Still not sure what's going on, but at least it's not universal.\n. - it only occurs on one app\n- in that app, ONLY commands fail to reload\n- Setup#command_classes is empty\n- I checked, they're in the right directory\n  *they are reparsed each time reload is fired (a 'puts' does output)\n- adding output to Command.inherited only fires on on initial load, NOT on reload\n- calling ROM.register_command self in the command class does add it to the command_classes array\nSo .... it boils down to the 'inherited' hook not triggering, because ... reasons. I'm at a loss for why it wouldn't fire, but just for the commands.  Probably because the class isn't getting unloaded first, but ...\n. Down to:\nThe generators were producing commands under:  app/commands/users/create, but the class names were UserCommands::Create ... because of this difference, Rails did not recognize the commands as auto-loadable, and did not add them to the correct ActiveSupport::Dependencies array.\nWhen reloading, AS clears the contents of that array, undefining each constant.  ROM-reloads every file in it's directories on reload, so updates were being caught ... but the inherited hook was not triggering, because the class already existed; therefore the commands were not being registered in the new env.\nI've fixed the generator, but existing code will have to be dealt with; probably by being moved.  Sooner a new release happens, the better.\n. This is fixed, but we'll want to cut a new release of rom-rails soon, to get this fix out in the wild.\n. sounds good.\n. Looks good.\nOof, that's a lot of setup in the spec.  :)\n:+1: \n. It filters the query, so that it only considers records with the same value in the user field.\nif { name: \"Be Cool\", user: \"Joe\" , deadline: \"always\"} already eixsts, then\n{name: \"Be Cool\", user: \"Joe\", deadline: \"tomorrow\"} would be invalid, but\n{name: \"Be Cool\", user: \"Mark\", deadline: \"always\" } would validate.\nCurrently, both would fail validation.\n. Yeah -- Gateway is the name for a (family) of patterns that are basically thin access to an external system.  Provide a focused internal api around a RestClient library, that sort of thing.  It actually fits our usage really well here.\nI suspect it's reasonable to chase for 0.7.0, unless we're looking to release on Monday.  ;)\nTransitionally, we need to add Gateway to the various lookups, add deprication warnings (is there a standard way of doing that?) for Repository, and update the linters.\n. Just a bit.  :)\n0.8 sounds good; I'll work on this during the week\n. PR for this: #243\n. I'm not experiencing that; do we have reproduction steps?\n. Oh ... meaning nothing in the AR loaded configs.  No, I don't.  Misunderstood the description.  Carry on. :)\n. I'm inclined to not want my domain /model layer dependent on any non-model API externalities for its structure ... that includes ROM mappers, honestly. As I see it, mappers instructions for taking data from one place, and translating it into my domain models.\nIt's possible (maybe not wise) to take data from several different sources and represent them using the same domain model; keeping the structural definitions in the mappers alone makes that harder.\nI admit to only doing a shallow reading of this thread; I don't have a lot of focus this weekend.  My basic, least surprise idea would be that an empty mapper does nothing -- no key filters, no data translation, nothing gets dropped.  Any changes to the data have to be declaraed, so that I can read the mapper and know exactly what it's doing.\nThus, I'd prefer to see reject_keys false by default, and require the specific line to enable at.\n. eh, I actually prefer as ... I want to get the results of this relation as a  :user_with_tasks  ... makes plenty of sense.\n. Excellent.  :D\n. :+1:\n. The split makes sense to me; especially if it surfaces enough of an interface to be able to get a non-global ROM.env replacement.\n. :+1: Looks good to me.\nThough, I'll note with amusement that this means that the core of Ruby Object Mapper does not, in fact, contain a mapper.  :D \n. Oh, I think I see what the problem is:\nform_for calls to_model on each of the parameters in its sequence.   Ugh.\nI'm rather doubtful that we want to forcefully interact with the polymorphic URL and form resolvers; that way lies a particular breed of Cthulhu madness.\nMy best suggestion would be to wrap your product in an AM presenter, to expose the naming and other expected bits.\nWhich is a problem, because all the naming stuff is class based, so really, you have to wrangle something to replace this:\nhttps://github.com/rails/rails/blob/bbe170c90e7cf5a59ef3de8e246e78f50416a4cc/activemodel/lib/active_model/naming.rb#L235-L242\nIt might be worth providing some kind of base poro presenter for handling this; I've done a thing like this once or twice.  I'll try to see what I can extract.\n. @kchien should be fixed in 759d5eaa9a22889c84b14b7e4b47c40c26e46b68\n. For context, so I'll remember:\non a freshly generated rails4 app, after generating relations and commands, if you fire up a rails console, ROM.env.commands will be empty after a reload!\nRemoving Spring restores expected behavior.  It's probably something to do with spring naming, and load paths, or, mumble ... I don't use spring, so hadn't tripped across this before.  We'll want to fix it, though, or rom appears broken out of the box.\n. Set about reproducing this locally.\nI can get the bad behaviour, but it goes away once you restart spring\nThe problem is, like all things with spring, that you get completely confusing behaviour until you realize it's running, and kick it over, then all is fine.\nStrangely, relations and mappers seem to work fine here.  I have to wonder if the problem here (other than \"using spring\") is down to the commands being in a namespace module, rather than in the flat global namespace, like all-else in a rails app\n. forgot to leave further notes:\nI've got a better idea where the problem is coming from, and it's tied in with the AS::Dependencies autoloading; I just need to figure out how to make sure everything gets registered in the right place.\nIt only occurs if you start rails before creating a mapper, relation or command.  If one already exists, it'll make it into the autoloaders correctly.\n. That ... might work.\nin all honesty, I'm coming up against a slightly different situation.  I want to be able to validate uniquness for only a subset of actions, and I'm starting to think the \"easiest\" way might be to inject the relation (it's currently directly inferred, and so can only operate on the base)\nThink:  A shopping list.  I want to guard against double adding milk if it's \"to get\" or \"in cart\", but I don't care about duplication in \"already purchased\"\nGetting the base_dataset from #154 would do this, because I could just build a relation of \"active\" cart items (but would not help with the subject of this ticket) ... other option is back to the buliding-block approach, and the validation becomes:\nruby\nvalidates :name, uniqueness: { \n  relation: rom.relations(:cart_items).active.exclude(id: :id).active, \n  message: \"Already added #{name}\"\n}\n. Validations take place in the context of a command, not a form.  ROM-rails imports validations from rails, and builds up some nicities around the definition, but core rom has a validation concept.\nWhat you suggest could work, except that there are some holes in both suggested structures, around correctly filling in data from runtime (ie, that id: :id bit isn't actually valid, and shouldn't really be so).\nSetting a global relation for the uniqueness guard works is most cases, but breaks down when I want to have two uniqueness validations with different scopes:  a task_name that's unique to the user_id, but a guid that's globally unique, for example.  You'll still need to be able to specify a relation in the validation itself, in that case.  Which is, generally, what scope does, but I need a little more than that still\n. (and, note that what I'm considering a need for there is beyond what rails uniquness validation usually covers, so ...)\n. It does.\nHow are you currently triggering?  Should be fairly easy to throw into the railtie.\n. Hrm.  Pointing that out, this actually seems like it's something that should apply to most adapters.  Otherwise, you're mixing data from a *-sql adapter in Eastern, a Mongo adapter in UTC, and a web service in Pacific time ... and that could go Poorly.\n. No, it's not good to be tied to a specific (single) mapper:\nthat means, either I have to base-class all my internal mappers, or I have to redo the corecer for every  mapper that happens to use that type.  Since one of the compelling things about value objects is that they can be freely scattered everywhere needed, that could be a lot of mappers.\n. I'm fine with base mapper, if that implied dependency is good with others\n. Yeah, I think they should be moved out of the command.\nIt's a bit too opaque and magical and, as solnic says, it leads to issues with chained commands, and to things like: https://github.com/rom-rb/rom-rails/issues/42\nAn interesting structure might be to be able to throw a validator in front of a command chain?\ncommand =   rom.validation(:new_task).unscheduled_task >> rom.command(:user).find_or_create >> rom.command(:tasks).create\n  command.call(input_data)\n  # => returns with result\nTrick is probably that validations will likely depend a lot on the existing data / state of a structure, that might not be in the update data, so that validation interface isn't really that simple either. :/\n. starting https://github.com/rom-rb/rom-model/pull/2; PR for commentary\n. maybe something like that, yes.  Though I can see cases where it gets really wonky, because you need to restrict by data from both the parent relation, and within the sub relation ... [:tasks, {by_user_id: :user_id, by_id: :id }] ... :/\nAt that point though ... meh.  Is there a  reason to have symbols for the command, rather than a curried   command?  I guess that fails because you may need to feed input into different points along the command chain.  :/  command(:tasks).update.for_user.by_name  doesn't actually work out.\n. I start worrying when I see method paths encoded as strings.\nIs that really better than\nrom.command(\n  [{ users: :user }, [\n    { update: ->(r, user) { r.by_id(user[:id]) } },\n    [ :tasks, [{ update: ->(r, user, task) { r.by_user_and_name(user[:id], task[:name]) }] }]\n  ]\n)\nI'm not sure that's great either.  Mostly at this point, I'm kind of afraid that the syntax we're coming up with is just this side of impenetrable.\n. Sure, will take a look\n. Sorry, been at a conference all weekend.  I'll check this first thing in the morning.\n. Ugh; I'm having the damndest time even getting a simple case to work, at the moment.  Going crosseyed on brackets and braces I think.  Am looking though\n. yep, looks good\n. The default given in the schema/dsl initializer is more or less irreleveant, as the key is always provided in production code.  The place too look is more likely in the inheritance hooks for ROM::Relation. Does this leave, eg container.relations[:users] ?. it appears that the error comes in the apply_hooks method https://github.com/rom-rb/rom/blob/master/core/lib/rom/command.rb#L276-L278\nThe command call returns a merged tuple with timestamps set; the changeset returns nil. Naming convention from Enumerable suggests that a simple #lazy here would suffice.  Or at least as an alias.\n. Ah,  okay, makes sense ... and since lazy is default return, user really isn't expected to call that.  And a relation is not an Enumerable, I see.  Seems fair.  :)\n. Instead of all this; consider partitioning by nil? and sorting the remainder normally; then (ap|pre)pend the nil values\n. For that matter, I think a spec for ordering by multiple keys is missing. \n. I'd like to see a non-nil secondary value sort in these example, to make sure that that's getting ordered as well.\nSo, maybe another:  { name: 'James', age: 11, email: 'james@doe.org' } thrown into the mix, to make sure that the secondary key sorts, beyond just partitioning on nil\n. Nice use of xor.  :)\n. may or may not be clearer:\n.detect(&:nonzero?) || 0\n. I was going to say that detect provides an if-none argument, but that argument is called, and I think that:\n.detect(->{0}, &:nonzero?) probably fails a clarity check. :)\n. attribute :foo { 1+1 } fails because the braces bind much tighter than do/end -- ruby attempts to send the block to :foo, not to attribute\nTo work inline, you have to do attribute(:foo) { 1 + 1 }\n. I don't think this works well on windows; have to use File.join or something else that chooses the correct path separator\n. Though, that's a note that's not isolated here, I think ...\n. responding to one or the other method are not mutually exclusive.. Just did a trial run of yanking that over.\nOne downside:  The method as-is transforms a single-hash tuple into an array of tuples ... which breaks a few specs, because they (rightly) assume the airity of the tuples remains consistant\nan example that breaks:\n```ruby\n      define :create_with_task, type: :create do\n        result :one\n        use :timestamps\n        timestamp :updated_at, :created_at\n    before :assign_task\n    def assign_task(tuple, task)\n      tuple.merge(task_id: task[:id])\n    end\n  end\n\n```\ntimestamps plugin, using with_input_tuples, translates the single input tuple into an array of tuples.  the assign_task filter assumes that there's a single hash as input, and ... kaboom.\nI suspect that this would end up breaking any currently existing code in the wild that makes similar assumptions.. it's worse than that, actually:\nthe mapping / result needs to agree with it's argument.  update  command,  for example can generally be considered to return :many but may only be called with a single input tuple.\nI can get specs to pass by checking on the hashiness of the input tuple, but I suspect this might end up causing problems with pipelines ... though maybe those are supposed to be treated as more array-like anyway?. Aaaand, I can't use the with_input_tuples name because rom-sql has already internalized the idea that it always returns an array, and so it breaks multi-insert.  \nmap_input_tuples it is.. ",
    "pdswan": "Sure thing! Will do that today.\nCan use examples to highlight what happens if your block doesn't return a Result as well =)\n. Writing the integration specs made it very clear that not doing something about the return values of the blocks passed to and_then and or_else makes for a pretty poor API.\nFor now I combined the functionality of Rusts and_then with map and or_else with map_error; i.e. if the block returns something that is not of type ROM::Command::Result it is automatically wrapped in one.\nI'm not a huge fan of the magic of this and I'm sure there are some issues with implementing monadic bind and map as the same function, but I can't think of any right now and I like this better than having to construct a ROM::Command::Result every time you use want to use #and_then. \n. Ok, I implemented something close to number 2 but hung both #success and #failure off of a single passed in dependency:\nruby\nresult.and_then do |value, r|\n  if value % 2 == 0\n    r.failure \"An even number\"\n  else\n    r.success value\n  end\nend\nCurrently, r is just ROM::Commands::Result to which I've added .success and .failure.\nFor kicks, I added a spec for how this affects the implementation's adherence to the monad laws.\nIt's an easy step away from 2, but now I'm tempted to go all the way and just require folks to do:\nruby\nresult.and_then do |value|\n  if value % 2 == 0\n    ROM::Commands::Result.failure \"An even number\"\n  else\n    ROM::Commands::Result.success value\n  end\nend\nIf we couple this with a runtime error that checks the return value of the block passed to and_then or or_else we should end up with something pretty user friendly.\nBut...as I look at this more I think that with Rust as the example map and map_error may be better for the use case described in #104, especially since I'm a little fuzzy as to whether a ROM::Commands::Result::Failure is intended to be manually instantiated without a corresponding ROM::CommandError.\nI fear I may be in over my head at this point, but I'm happy to continue plugging away/experimenting if you all think it's moving in a valuable direction @solnic @aflatter.\nThanks for entertaining the pull request, very excited about this project!\n. I'm certainly up for that.\n. @solnic @aflatter opened for discussion\n. My assumption was that all adapters (sql, mongo, yaml, redis, etc) support associations so all adapters may raise this error. If that's the case I thought it made sense for the error to live with the other top-level errors, but maybe that's incorrect?\n. ok, cool. i'll move it over there.\n. ",
    "mjtko": "@muescha Can you expand on where you think there are too many repetitions?  I only see repetition between the attributes specified within the domain model and the mapper, and I don't think that's unexpected.\n. Ah, yeah -- you've commented out some fairly critical pieces there!  You need the Relation to let ROM know where the data comes from and you need the Mapper(s) to let ROM know how to convert the data from the relation into domain models.\nThe example is showing a proposal for a new way of handling the Mappers which allows them to be used as a pipeline.\nHTH!\n. I've had a go at this in #158 -- I'll look at making the couple of required changes to rom-sql after the result of any discussion/iteration on the PR.\n. Urgh, I have the benchmarks group installed locally so the ActiveRecord-related specs passed.  Two options as I see it:\n1. remove the ActiveSupport-related specs\n2. add activesupport to development dependencies in the gemspec\nThoughts?\n. Ok, I've gone for adding it to the test group in the Gemfile.  Let's see what Travis has to say now! :)\n. I've reworked things slightly - detection of the inflector backend is now not performed until the first time the inflector API is used which makes the code slightly neater at the cost of failing fast.  Tests are less strange now - we stub the BACKENDS constant to test what happens when a library cannot be found.\nOf course, I'm open to suggestions on how to clean this up further.\n. Sigh at jruby.  Ok, procs it is then! :-)\n. Yeah, that sounds like a nicer approach.  I'll work something up, thanks!\n. Hehe, fair enough!  Do you think we should prioritise inflecto in the load ordering too?  I don't much mind either way! :smiley_cat: \n. That was there out of force of habit I guess!  I'll drop the leading ::.  Seeing as we're going from Object that should be fine anyway.\n. Urgh, yup, not quite sure what I was thinking there.  Will sort that.\n. Just wanting to test that if neither activesupport or inflecto are available, we get an error raised.  We could bin or change this test to operate differently though.  Testing the result yielded by the presence/absence of libraries that are already present in the test environment is somewhat tricky.\nJust drop it?\n. Yup, sure, fine by me.\n. ",
    "KamilLelonek": "OK, that should be enough for me. And it sounds like a good documentation ;)\n. ",
    "AMHOL": "Wondering about Virtus attribute style syntax for this, i.e.\nruby\nclass CreateUser < ROM::Commands::Create[:memory]\n  register_as :create\n  relation :users\n  result Array[User]\nend\nclass CreateUser < ROM::Commands::Create[:memory]\n  register_as :create\n  relation :users\n  result User\nend\n. Yeah, thought about it when I went to bed last night, realise why you mentioned some kind of DI container as this method relies on constructor mass-assignment.\n. Nice, looks good\n. @schwern can you please expand on \"wrong repository\", when @gotar said we use this repository to collect all issues, he meant ROM issues, and probably assumed you intended to report this in the rom-rb/rom-sql repository, is that the case? This project is not affiliated with Sequel, it's just a dependency.\n. Think it would be better to have a rom-file adapter, then plugin an encoder/decoder each would take a string and convert to the required format, kind of like how rom-http will work\n. This is due to the use of Module.method_added to expose relation methods in Relation, and when you include a module it doesn't actually define the methods on the including class, it just adds the module to the hierarchy to search when methods are invoked.\nYou can work around this with something like:\n``` ruby\nrequire 'rom'\nsetup = ROM.setup(:memory)\nmodule RelationInterface\n  def included(base)\n    base.exposed_relations.merge(instance_methods)\n  end\nend\nmodule SelectActive\n  extend RelationInterface\ndef active\n    restrict { |row| row[:active] }\n  end\nend\nsetup.relation(:users) do\n  include SelectActive\nend\nsetup.commands(:users) do\n  define(:create)\nend\nrom = setup.finalize\nUserCommands = rom.command(:users)\nUserCommands.create.call(name: 'Nisse', active: true)\nUserCommands.create.call(name: 'Hannes', active: true)\nUserCommands.create.call(name: 'Bj\u00f6rn', active: false)\nrom.relation(:users).active.to_a\n  # => [{:name=>\"Nisse\", :active=>true}, {:name=>\"Hannes\", :active=>true}]\n```\nI'm all for :fire: all t3h h00ks myself, but granted, it either needs to be better documented or implemented differently, perhaps it would be good to have something like RelationInterface in ROM?\n. Yeah, think the RelationInterface  makes it a little nicer, Githubs stupid editor won't let me edit the comment above for some reason (it blanks out the text box), but that should be public_instance_methods rather than instance_methods\n. :+1: nice work\n. Defo :+1: for this, rom-mapper will be particularly useful stand-alone\n. https://www.youtube.com/watch?v=ggV6LoYaQmg\n. Added @private to Types & changed Types to TYPE_MAP\n. :+1: I've thought about this before too\n. Yep, looks like the acronym inflection configuration support was only added in ActiveSupport 3.2.5, could you try adding:\nruby\ngem 'activesupport', '>= 3.2.5'\nTo your Gemfile, best solution for this is probably just updating the dependency to fit.\n. I did it like this: https://github.com/AMHOL/rom-playground/blob/master/lib/core/commands/create_user.rb\n. @ThijsWouters there is no database with the in-memory adapter\n. Please don't add any more register_as :(\n. It makes me sad to see state held on a class level like that\n. Also, Transproc is an optional dependency, and ROM has an adapter between mappers and Transproc, so I think extending Transproc::Registry in a ROM core component is a no-go\n. I think the beauty of swappable dependencies, is swappable behaviour, who knows what you could twist and bend ROM to do if you were to replace the transproc dependency, but without the option, we end up with a monkey-patch it and run philosophy that I would avoid at all costs. Middleman adapters FTW IMO.\n. ~~Been messing about with this and I think it kills the ROM::Relation[:memory] syntax entirely~~\n. ~~Alternative would be to keep the adapter and plugin registries global (on the ROM module) and move everything else, or deprecate and get everyone to move to Users < ROM::Memory::Relation syntax~~\n. This now means people will need to call ROM.use :auto_registration to maintain current interface\n. Yeah, it doesn't really change much, just rather than ROM being a registry for relations, commands and mappers, ROM::Environment is now the registry, ROM::Environment#finalize and ROM::Environment#env just do the same as ROM.finalize and ROM.env before\n. I like ROM::Environment personally, it reads well, i.e.\nruby\nrom = ROM::Environment.new # make a new ROM environment\nAgree that ROM::Env could change, sth like ROM::GlobalRegistry or ROM::Container?\n. @cflipse @solnic please check this out when you get a chance, let me know what you think so I can merge into the other branch/delete or whatever.\n. Merging this into feature/remove-rom-global\n. :+1: Looks good to me\n. Thanks @zavan \n. This could be fixed by passing symbolize_names: true to https://github.com/rom-rb/rom-json/blob/master/lib/rom/json/gateway.rb#L73 and removing https://github.com/rom-rb/rom-json/blob/master/lib/rom/json/dataset.rb#L9-L15 as far as I can tell\n. Could add it as a plugin?\n. Any chance we could remove references to Wisper and use something in rom-support like this?\n. Nice one @kwando \n. It was part of the problem @skrypalyk had with rom-rails yesterday, regarding already having a commands directory, plus I think it should be configurable anyway :p \n. What's the namespace issue BTW?\n. NP, still needs an update in rom-rails after merge\n. Does the exclusive or here mean nils will be ordered using the normal natural order sort when only one value is nil? I think the partition and append/prepend method would be much cleaner?\n// EDIT:\nThinking about that, I'm not sure with multiple keys to sort on, a comment or two here could be useful\n. @dekz think we need to go down a different path with this, there shouldn't be any references to Transproc in this file, the idea is that you should be able to configure the processor that ROM uses.\n. \n. Would use more descriptive variable names in the block here\n. Fair enough\n. Seems strange to new up an instance of self each time just to get its first transformer? Wouldn't processor.build(step_header) work here?\n. ",
    "krainboltgreene": "It's a dynamic require. Can't require something when everything's already been transpiled.\n. I still think that the wrapper is way more complex than actually needed.\n. Totally agree.\n. :+1:\n. ",
    "hecrj": "This becomes useful when you want to empty all the relations that have a delete command when testing, for example.\n. This is an issue related with rom-sql (https://github.com/rom-rb/rom-sql/blob/master/lib/rom/sql/relation.rb#L39).\nThe solution is to declare your dataset explicitly in the relation of your command. Try something like this:\nruby\nclass MyRelation < ROM::Relation[:sql]\n  dataset { order(:my_column) }\nend\n. ",
    "ginjo": "Back from a long hiatus building & maintaining servers...\nThanks for the tips above. I've tried rebuilding the adapter a few times now, starting with the examples from the adapter guides. I can get simple calls to the database server working with those examples. However I had to add a layer of query storage & management to the dataset to have lazy chained relations. It works, but I feel like I may not have designed it in the most 'rom' kind of way.\nI'm still kind of fuzzy on the expectations & requirements of relations & datasets, and what responsibilities are where. For example, are lazy chained relations supposed to be handled by existing rom features? Or is it the adapter's responsibility to provide that functionality? Or a little of both?\nThe guides are shaping up and have been really helpful, but I'd like to see more details on the various adapter classes & methods, their purpose & expectations, and how to construct them to take full advantage of rom.\nBTW, 0.9.1 is working really well - thanks for all the hard work!\n. @nepalez, thanks for the detailed overview. I think my dataset structure is somewhat similar to yours but with differences in the details. I have tried some different variations on the relation-dataset-command interaction. They all work, more or less, but I'm not sure which one is the \"right\" way to structure it. Here are some questions I'm trying to answer.\n- ROM::Commands::Abstract#execute states that it should return an Array. Why not return a Dataset or a ROM::Relation::Loaded? Those both seem to work well and give more upstream information. \n- The examples in the adapter guide suggest to pipe commands thru the relation.\n```\nclass UsersRelation < ROM::Relation\n  forward :update, :create, :delete, ...\nend\nclass UpdateUsers < ROM::Commands::Update[:fmp]\n  def execute(attributes={})\n    relation.update(attributes)\n  end\nend\n```\nI thought we were supposed to be keeping write concerns separate from read concerns. What makes more sense to me is to send writes to the dataset directly from the command.\nclass UpdateUsers < ROM::Commands::Update[:fmp]\n  def execute(attributes={})\n    relation.dataset.update(attributes)\n  end\nend\nThen we can add some sugar to the relation, allowing it to create commands on the fly.\nclass UsersRelation < ROM::Relation\n  def update\n    Commands::Update.new(self)\n  end\nend\nAre any of these right or wrong, or are they all acceptable structures?\n. Super helpful comments @solnic, thanks!   So, here are some highlights, as I understand:\n- Relations don't know about commands, but commands can know about relations, minimally.\n- It is ok for a relation to have a method that writes data, thru the dataset & adapter.\n- A command can use a relation method to write data, but it doesn't have to.\n- A command will need a relation, at the very least, to specify what record(s) are operated on.\nMaybe a silly question, but how is an Update command different from a relation#update method, as far as functionality and use cases go? Or are they just two different ways to update data?\nWith loaded relations, is there a preferred way to apply a command to them? My use case is that I have a relation with loaded data, and I want to update all records in the relation without having to reload the relation (to get record_id's).\n. Thanks @solnic & @nepalez... again, really helpful.\nI have another related, but possibly tangential, question about models & persistence. Not sure if this is the best place to ask, so I think I'll move it over to gitter...\n. I'm also running up against this exception. I have a ROM::Configuration object with relations containing schemas - this is used to build my base ROM::Container. Elsewhere in my project I take the rom config object, add to it, and try to create a new container. I get pretty much the exact same error as above.\nMy current workaround is to build the base config object on-the-fly with a method, which allows me to create additional \"fresh\" config objects on demand. It seems to work, but I haven't tested it thoroughly yet. \n. Edit: I realize that subclassing a relation class will lose the schema definition. Fair enough. But cloning it does not lose the schema.\n. Hmmm... well I am not able to reproduce the issue with the above example. So there must be something about my project that is interfering with functionality of schema types.\nOne thing I have noticed is that ROM containers are not isolated: Two separate ROM containers in my project are showing relations from each other. When they are set up, they don't reference each other at all, yet somehow the relations are bleeding into each other. Maybe this is related to the other issue I'm having?\n. @solnic, thanks for the consideration. I'm going to let this go and close it out. I'm almost certain it's something on my side breaking the schema or dry-types. I tried several other fresh examples of increasing complexity and still couldn't reproduce the issue - which is good! :smile:  I think I was getting tripped up by the automatic relation inference in rom-sql https://github.com/rom-rb/rom-sql/issues/96  at one point and ultimately went looking down the wrong road.\n. ",
    "nepalez": "@ginjo Working on cassandra and kafka adapters i used the following rules for gateway - (connection) - dataset - relation - command:\n1. Gateway (subclass of ROM::Gateway) is a:\n- registry of datasets\n- storage of settings (like hosts, port, login, password) that are necessary to access the data\n  It is mutable for adding datasets.\n1. Connection is the wrapper around the external driver(s) that provides the access\n- hides the specifics of external library from the rest of the adapter\n- adopts APIs of gateway/dataset to the external driver\n  It is mutable because the connection can have an internal state storing the history of data access (like the current log offset of Kafka messages being read).\nDepending on the concrete driver, you can use either the same connection for reading/writing etc., or several types (like in Kafka, where messages producer and consumer connect to server slightly different). The connection can be instantiated and stored either by gateway or dataset (I'll read about this later).\n1. Dataset - models the top level of the \"database\" structure. It can be table in SQL, topic in Kafka, table/columns_family in Cassandra etc.\nFor example, in Kafka data are organized into topics/partitions. Because it is the Kafka itself who decided what partition of the topic to store data to, I allow adapter to access the topic (w/o any partition) for writing. I model it with a dataset. From the other side, the consumer access data via concrete partition. I do this by setting default partition (0) and allow user to modify it via special method (#from(number), or I could do this via #where(partition: ?)).\nSo, while Kafka dataset models the topic (for writing), it can be additionally tuned with :partition options to describe topic + partition (for reading).\nIn Cassandra it is done slightly different. Cassandra models data via keyspace and table (columns_family). Because the official docs recommend using keyspace for domain model, I model the whole keyspace with gateway. If the user need to access various keyspaces, it should instantiate multi-gateway adapter. Here dataset models the table (not the top level of Cassandra whole data structure, but the top layer inside the gateway keyspace).\nDataset does 3 things:\n- writes data via some connection\n- reads data via some connection lazily. (implementing the Enumerable interface around the connection with #each method defined).\n- stores specific settings to provide reads/writes (that can be modified from relation/command)\nCouple of words about lazy reading. Look at how this is made in Kafka. Two points here:\n- driver fetches data from server by chunks of some length, but connection hides this from the dataset - it authomatically fetches the next chunk when it is required by the dataset\n- connection still iterates via all the data, but the dataset #each allows to stop iteration when user sets some limit.\nAnd the last bit of puzzle is about where to instantiate connections. Kafka is a good example, because here is two types of connections (in many other cases there is one): for consumer and producer. \n- Because producer connection is topic/partition agnostic, I instantiate and store \"writer's connection\" immeadiately inside the gateway. Then this connection can be reused by all datasets. I think this is a standard way of dealing, when gateway not only stores settings for connection, but connects by itself.\n- From the other hand, the consumer in Kafka is topic/partition/offset - dependent. That's why \"reader's connection\" instantiates by the dataset. And every time, when relation reloads the dataset with new options, I need to reconnect. It is slower then writing, but is a pay for customization.\nI won't write about relation and command - they are too simple, but will be happy to answer if you have any question about them.\n. @ginjo Concerning strict separation of relations and commands you can look at how this is done for Cassandra. I don't know if this is an ideal solution, but \"it works\".\nDataset provides all the methods #get, #create, #update, #delete (all 3 via method missing), and #batch. Every method just returns a new dataset, carrying a corresponding lazy query (to be modified and executed later).\nRelation stores its dataset argument as a @source and then redefines @dataset by applying #get method. So all relation's methods are forwarded not to the source dataset, but to the dataset, restricted for reading only.\nJust in the same way every command is initialized with pre-updated relation, wrapped around resticted dataset (restriction is just applying the command-specific method, like :create for create command etc.).\nThis is one of possible solutions to provide stricter separation, than defining command's methods in a relation.\n. I like this syntax. But there is some edge cases\n1) What would be the proper behaviour by default without a block:\nattribute :d, from: [:a, :b, :c]\nWith the data: { a: 1, b: 2, c: [3] }\nShould it be: { d: [1, 2, 3] } or { d: [1, 2, [3]] }?\n2) How this syntax should be expanded to unwrap, ungroup, unfold:\nThe trick is the syntax becomes ungroup f: [:a, :b], from: [:c, :d].\nAnd now the data: [{ c: [{ a: 1, b: 2, e: 3 }], d: [{ a: 4, b: 5, e: 6 }] }]\nHow to process this at all (notice :e should be left grouped)?\n3) following the business case, don't we need to support some sort of uniqueness. When there is one source array we can expect the data are prepared as either unique or not, and we should't change this at the mapper level, only rearrange. But with 3 sources this question arises.\nAnd I think this is a Pandora's box of sorts.\n4) This leads to the most tough question for me: doesn't this sort of transformation be done at the relation, not a mapper?\nWhy don't union of those data at the query level, made them unique etc.? I see here is no strict border, but...\nNot so simple\n. @c0 I don't think your solution to be a hack. I agree to @AMHOL the domain model is a right place to do this transformation.\nHowever I like your syntax in principle. In a couple of days I'll implement it in the faceter's create command. Then we could look at it and decide whether it could/would/should be translated to rom mappers.\n. Ah, yes. Maybe you'd better do it a module utility method, because you don't need to instantiate an object of your class. All in all this is a domain layer, not the datastore.\n. I know the use case. It is for requesting denormalized data from non-sql (cassandra, mongo etc.) datastore that supports collections, normalizing them via mapper and moving to sql datastore via command.\nPretty weird case, but existing\nIt could be unfold :)\n. Will do it the next week\n. Transformation is implemented as unfold:\nruby\nclass UserMapper < ROM::Mapper\n  unfold :tag, from: :tags\nend\n. Obviously, here is two options:\nThe first one - use names of datasets in associations DSL\n``` ruby\nROM::SQL.migration do\n  change do\n    create_table :mygem_users do\n      primary_key :id, null: false\n      # ...\n    end\n  end\nend\nROM::SQL.migration do\n  change do\n    create_table :mygem_tasks do\n      foreign_key :user_id, :mygem_users\n      # ...\n    end\n  end\nend\nRelation for tasks is not necessary\nclass Users < ROM::Relation[:sql]\n  register_as :users\n  dataset :mygem_users\none_to_many :mygem_tasks, key: :user_id            # uses the name of dataset\ndef with_tasks\n    association_join :mygem_tasks, select: %i(title) # uses the name of dataset\n  end\nend\n```\nAnother option is to use names of relations in associations:\n``` ruby\nROM::SQL.migration do\n  change do\n    create_table :mygem_users do\n      primary_key :id, null: false\n      # ...\n    end\n  end\nend\nROM::SQL.migration do\n  change do\n    create_table :mygem_tasks do\n      foreign_key :user_id, :mygem_users\n      # ...\n    end\n  end\nend\nThis declaration is necessary for users to have a relation to be associated to\nclass Tasks < ROM::Relation[:sql]\n  register_as :tasks\n  dataset :mygem_tasks\nend\nclass Users < ROM::Relation[:sql]\n  register_as :users\n  dataset :mygem_users\none_to_many :tasks, key: :user_id            # uses the name of the relation\ndef with_tasks\n    association_join :tasks, select: %i(title) # uses the name of the relation\n  end\nend\n```\nFrom the one hand, I'd prefer the first option because it doesn't need the relation to be provided for mygem_tasks dataset. But such a decision would require deeper changes - with it both the ROM::Env and ROM.finalize should operate with datasets as well.\n. I'm afraid, there is a deeper problem that appears here.\nAs it stated in overview, the commands and relations are expected to be separate.\nBut the implementaion differs: commands back on relations, not \"pure\" datasets.\n``` ruby\nclass CreateUser < ROM::Commands::Create[:sql]\nrelation :users  # command depends on relation\n                   # that mediates its access to datastore\nend\n```\nFollowing overview, I'd expect the syntax to be something like this:\n``` ruby\nclass CreateUser < ROM::Commands::Create[:sql]\nrepository :default  # just the same as for the relation\n  dataset :mygem_users # uses the dataset (db table etc.), not the relation,\n                       # because commands know nothing about relations\nend\n```\nIt is the example that would be consistent to the first option in my previous comment. But, well, I understand it could be too late for such a velleity...\n. Of course, you're right: the dataset is accessible.\nIMHO the problem is that a Sequel knows nothing about relations, and with it we HAVE TO use datasets. At the same way in association we refer to relations, which is a bit perplexing.\nFor example, to fix the bug, I forked the repo and changed integration spec by renaming the tasks repository to goals (the Task model to Goal etc.). And then added the small patch to #graph_join that solves the problem.\nWell, it works.\nBut, as I mentioned above, despite the fact the relation name goals is used in associations, I still have to use the table name tasks in grouping because this is the Sequel's context, not the ROM's.\n. I like both the ROM::Gateway and ROM::Source\n. The fold mapper operation added to v0.7.1\n. Just understood #220 is a special case of this issue in a sense they are both coersions of grouping.\nMaybe the better (more general) way is to coerce any results of grouping\n(wrapping etc.)\nruby\nclass UserMapper < ROM::Mapper[:memory]\n  group :logs do\n    coerce { compact } # the block to be evaluated in the scope of the result\n  end\nend\nAlso think this feature could serve as more general way for mapping\nwithout the necessity to use model.\nGenerally, I'd prefer (surely this is up to my app) to map tuples not to model, but to pure hash. It is the model, that is responcible for mapping hash to its objects - whoever provides the hash (either ROM,\nor, say, the Rails controller). Like this:\nadapter --> repository --[tuples]--> mapper --[hash]-- controller <-- user\n                                                |\n                                                v\n                                          model/entity\nBut what I really need for this approach is the mapper that adopts tuples precisely to the\ninterface of my model. That's why I think it need a coercer as a fine-tuning tool.\n. damn! need to change options to conform to older jruby\n. Will send another PR after merging commits into the one\n. By mistake. I've got confused with those requests I made (by my own mistake) to master. Instead in a minute I'll send them to different branches\n. The main reason why I'd prefer default value reject_keys true is that it makes the mapper interface non-intiutive and adds some use cases, the end-up user should take into account.\nExpectations\nLet the relation users contains 3 keys:\n``` ruby\nusers.first\n{ id: 1, name: \"jane\", email: \"jane@doo.com\" }\n```\nAs a user that asks for intuitive API, I'd like the rule: \"Just define the model and its attributes\".\n``` ruby\nclass UserMapper < ROM::Mapper\n  register_as :entity\n  relation :users\nmodel OpenStruct\n  attribute :id\n  attribute :name\nend\nuser.as(:entity)\n#\n```\nPretty intuitive, innit?\nReality\nWith reject_keys false instead of the one intuitive interface (see above), I have to select from two different interfaces.\nFor the case the relation has no unusable attributes:\nruby\nclass User\n  model OpenStruct\nend\nThe fist thing I should notice is the attribute here is not necessary at all.\nAnother one is the semantics of the method attribute slightly differs: it needed not for defining model attribute, but for key manipulation (renaming etc.).\nruby\nclass User\n  model OpenStruct\n  attribute :first_name, from: :name\nend\nFor the case some attribute should be filtered I have to use quite a different interface:\nruby\nclass User\n  model OpenStruct\n  reject_keys\n  attribute :id\n  attribute :name\nend\nThis means minor change in external data (relation) causes big change in the (mapper) interface.\nThis \"interface instability\" (from the end-up user's point of view) is what I'd like to avoid with reject_keys true by default.\n. I would vote for the last option as well.\nThe main reason is that the first two options back on domain classes that are external to ROM.\nI'd prefer to avoid such a dependency and shift responcibility for instantiating models to domain entities.\nFrom the other hand, I see ROM mapper has a \"sleeping potential\" for expanding to further integration to models - in just the opposite direction.\nBut evei if the ROM will evolve to not mapping to models (and my examples above will sink into oblivion), I think we still should explore whether reject_keys false adds complexity of described sort to mapper interface.\nIt seems to me, that this option is not an ordinary feature, but has deeper impact on how users will perceive mappers:\n- in case of reject_keys true the mapper is a tool to construct its output with a clean state, using relation-provided data as a source of raw data. The attribute becomes basic element for such a construction.\n- in case of reject_keys false the mapper is a tool to adopt relation to the domain interface. I think in this case not an attribute, but a sort of a filter seems more natural. User needs not to include something to output, but exclude it from the source instead.\n. Yes, I think so\n. D'oh! Will see it\n. @co, actually the mapper can map data without any model at all -- to pure hash. That's why naming it after the model is not a good idea. Instead, you can explicitly define the name of the mapper:\nruby\nclass TaskMapper < ROM::Mapper\n  relation :tasks\n  register_as :mapper_name\n  model Task\nend\nthen\nruby\nrom.relation(:tasks).as(:mapper_name)\n. I see. As for me, I feel conformed with as, but maybe you're right.\nI think the substantial part of the confusion is a lack of documentation. Feel it as a stimulus for myself to write it faster :)\n. yes, like it too\n. Think, you're right about the DSL.\nThis task can be closed, because its 1st part not necessary, 2nd is done by #264 , the third one requires some refactoring, but doesn't worth discussion\n. sure\n. :+1: \n. In 0.8.0 to convert tuple:\nruby\n{\n  task_list: 1,\n  tasks: [\n    { user: 'jacob', task_id: 1, title: 'do something' },\n    { user: 'jacob', task_id: 2, title: 'do something else' },\n  ]\n}\ninto the output:\nruby\n{\n  id: 1,\n  user: {\n    name:  \"jacob\",\n    tasks: [\n      { title: \"do something\",      id: 1 },\n      { title: \"do something else\", id: 2 }\n    ]\n  }\n}\nyou could do this mapper:\n``` ruby\nclass UserMapper < ROM::Mapper\n  relation :users\n  register_as :users\nattribute :id, from: :task_list\nwrap :user do\n    attribute :name, from: :user\n    group :tasks do\n      attribute :id, from: :task_id\n      attribute :title\n    end\n  end\nend\n```\nThe only difference from your example is that while grouping into tasks, the mapper will extract the :user from the list.\nThis is not a bug, but a sort of a policy IMHO. ROM mapper neither creates, nor duplicates the data, only rearranges the existing ones.\nI think, populating tasks with the name of a user they relates to could be the responsibility of your domain model, not the ROM.\nUPD: If you need conversion to the model, you could add model User to :user group and then in the User initializer create the array of Task-s from the array of :tasks.\nPersonally I think the model to be sort of overloading in mapper, I'd prefer not to initialize domain models inside ROM at all, but leave it to domain. IMHO. With this approach all you need is to adopt mapper output to the domain interface.\n. D'oh, sorry, this was my fault. I turn you to the wrong path.\nThe problem is that there's no way to group users after wrapping, because it groups mapped items, that are already different. Yes, this is tricky, i need some time to sort it out.\n. @dekz This would work:\n``` ruby\nrequire \"rom\"\nROM.setup :memory\nclass Users < ROM::Relation[:memory]\n  dataset :users\n  register_as :users\nend\nclass FirstMapper < ROM::Mapper\n  register_as :first\n  relation :users\nattribute :id, from: :task_list\n  unfold :tasks\nend\nclass SecondMapper < ROM::Mapper\n  register_as :second\n  relation :users\nattribute :id\n  unwrap :tasks do\n    attribute :user\n    attribute :task_id\n    attribute :title\n  end\nend\nclass ThirdMapper < ROM::Mapper\n  register_as :third\n  relation :users\ngroup :tasks do\n    attribute :id, from: :task_id\n    attribute :title\n  end\nend\nclass ForthMapper < ROM::Mapper\n  register_as :forth\n  relation :users\nwrap :user do\n    attribute :name, from: :user\n    attribute :tasks\n  end\nend\nrom = ROM.finalize.env\nrom.relations.users.insert(\n  task_list: 1,\n  tasks: [\n    { user: 'jacob', task_id: 1, title: 'do something'      },\n    { user: 'jacob', task_id: 2, title: 'do something else' }\n  ]\n)\nrom.relation(:users).as(:first, :second, :third, :forth).to_a\n```\nResults step-by-step:\n``` ruby\nrom.relation(:users).as(:first).to_a\n=> [{:tasks=>{:user=>\"jacob\", :task_id=>1, :title=>\"do something\"}, :id=>1}, {:tasks=>{:user=>\"jacob\", :task_id=>2, :title=>\"do something else\"}, :id=>1}]\nrom.relation(:users).as(:first, :second).to_a\n=> [{:id=>1, :user=>\"jacob\", :task_id=>1, :title=>\"do something\"}, {:id=>1, :user=>\"jacob\", :task_id=>2, :title=>\"do something else\"}]\nrom.relation(:users).as(:first, :second, :third).to_a\n=> [{:id=>1, :user=>\"jacob\", :tasks=>[{:id=>1, :title=>\"do something\"}, {:id=>2, :title=>\"do something else\"}]}]\nrom.relation(:users).as(:first, :second, :third, :forth).to_a\n=> [{:id=>1, :user=>{:name=>\"jacob\", :tasks=>[{:id=>1, :title=>\"do something\"}, {:id=>2, :title=>\"do something else\"}]}}]\n```\n. @solnic In the example above we could not use 4 (!) mappers. Instead we could use a sequence of commands within the only mapper:\n``` ruby\nclass FirstMapper < ROM::Mapper\n  register_as :first\n  relation :users\nattribute :id, from: :task_list\nunfold :tasks\nunwrap :tasks do\n    attribute :user\n    attribute :task_id\n    attribute :title\n  end\ngroup :tasks do\n    attribute :id, from: :task_id\n    attribute :title\n  end\nwrap :user do\n    attribute :name, from: :user\n    attribute :tasks\n  end\nend\n```\nThe only problem why this doesn't work is that mappers are too lazy. This one doesn't remember that attributes were renamed on earlier steps. I wonder, whether we could do something here?\n. The wonderful part of all of this is my last example works (well, except for renaming attributes).\n. Maybe this would be more \"natural\":\n``` ruby\nclass FirstMapper < ROM::Mapper\n  register_as :first\n  relation :users\nstep do\n    attribute :id, from: :task_list\n    unfold :tasks\n  end\nstep do\n    unwrap :tasks do\n      attribute :user\n      attribute :task_id\n      attribute :title\n    end\n  end\nstep do\n    group :tasks do\n      attribute :id, from: :task_id\n      attribute :title\n    end\n  end\nstep do\n    wrap :user do\n      attribute :name, from: :user\n      attribute :tasks\n    end\n  end\nend\n```\nOn every step the sequence compose --> preprocess --> process primitives --> postprocess would be done, so at the first of the next step we could do the same data as it were mapped before.\n. @solnic should this step to be included to the next release?\n. I think the consistent behaviour should follow 2 simple rules:\n1) If the attibute is set as a string it takes key from string (:from setting by default)\nAll the examples below should be synonyms:\nruby\nattribute 'user_name'\nruby\nattribute 'user_name', from: 'user_name'\nruby\nprefix 'name'\nattribute 'user'\nruby\nprefix :name\nattribute 'user'\nIn the last case ^ the attribute is a string, so its source is a string too whatever prefix is.\nMutatis mutandis for symbols.\n2) If the symbolize_keys is set, it should convert source keys to SYMBOLS instead of strings. This is a backward-incompatible change.\nThis should be ok\nruby\nsymbolize_keys\nattribute :user_name # from: :user_name\nThis shouldn't return the name because after symbolize_keys the 'user_name' key is absent, only :user_name is.\nruby\nsymbolize_keys\nattribute 'user_name' # from: 'user_name'\nMutatis mutandis for stringify_keys.\n\nAs a bonus, this makes all 3 methods: reject_keys, symbolize_keys, stringify_keys being referred to source keys. For now \"symbolize\" in symbolize_keys refers to output that is confusing.\nAs the next bonus we could do symbolize_keys and stringify_keys working in the same manner as prefix and prefix_separator. Namely, they could affect only following attributes in a current block's scope:\n``` ruby\nclass UserMapper < ROM::Mapper\n  symbolize_keys # <-- will affect :contact, :id and :name\nwrap :contact do\n    stringify_keys # <-- this is applied inside the block to following attributes (including nesting)\nattribute 'email'\nattribute 'skype'\n\nend\nattribute :id    # <-- those are outside of a block, so symbolize_keys keeps applicable\n  attribute :name\nend\nusers.to_a\n[{ 'id' => 1, 'name' => 'jane', email: 'jane@doe.com', skype: 'jane' }]\nusers.as(:user).to_a\n[{ contact: { 'email' => 'jane@doe.com', skype => 'jane' }, id: 1, name: 'jane' }]\n```\nWhy such a weird case? Because:\n- this makes DSL more regular and following the principle of least surprise\n- who knows what a user will want to do with his/her/its data: \"the night is dark and full of horror\".\n. I don't think we should include keys transformation to special preprocessing.\nI like the current mechanism because it potentially (while the implementation is trivial) allows multiple switching from stringify_keys to symbolize_keys \"there and back again\" when necessary (see the latest example above).\n. I agree.\nWhile the implementation is trivial, the deprecation needed for switching symbolize_keys to the opposite behaviour. It couldn't be included to 0.8 even if we wanted.\n. Ah. I've also started step locally.\n. What i'm doing is defining a new Step attribute and visit_step method that simply composes attributes from its header. I don't think we should define a new thing such as steps in AttributeDSL.\nstep is just a carrier of the header, nothing more.\nruby\ndef visit_step(attribute)\n  self.class.build attribute.header\nend\n. Well, the complication of Header exists, of course. But the complication is the additional type of attribute, following the existing convention. And a Processor::Transproc receives one regular visitor method visit_step that also conventional.\nYes, we made processing one level deeper, but we should do this in any way.\ntbh I haven't got a solution that doesn't break my specs. Let's discuss it a bit later.\nUPD: One more thing. I think we should support edge cases like this:\n``` ruby\nclass UserMapper < ROM::Mapper\n  reject_keys true\n  symbolize_keys true\n  prefix 'user'\n  prefix_separator '.'\nstep do\n    # ...whatever\n  end\nend\n```\nI mean, symbolize_keys, prefix, prefix_separator, reject_keys can be set for all steps at once, because why not? With the step being a regular attribute we have such a support out of the box.\nUPD2. Ha! Writing the upd. above, I recognized why we should redefine reject_keys in the same way as prefix and prefix_separator. We could switch it on an off between steps, so that it affect following steps until the next switch :)\n. Included this to guides\n. What I'd propose is the following approach (maybe this should be applied outside of ROM at all as an external mapper)\n1) Every DSL leaf method is NOT a description of the result, but a description of transformation:\nrename :foo, to: :bar instead of attribute :bar, from: :foo\nwrap :foo, to: :bar instead of wrap bar: [:foo]\nunwrap :foo, from: :bar instead of unwrap bar: [:foo]\netc.\nOne transformation per step. No nested transformations at all\n2) Use attribute and array with a block to access nested values:\n``` ruby\narray do\n  attribute :foo do\n    array do\n      rename :bar, to: :baz\n    end\n  end\nend\nfrom\n[{ foo: [{ bar: 1 }, { bar: 2 }] }]\ninto\n[{ foo: [{ baz: 1 }, { baz: 2 }] }]\n```\nHere we doesn't nest transformations (they are already leaf), but data structure to access the level to apply a transformation.\n3) Then we'll need only those types of transformations\n- rename keys (see above)\n- remove keys\nruby\n[{ foo: 1, bar: 2 }]\nruby\narray\n  remove :foo\nend\nruby\n[{ bar: 2 }]\n- create new values from the existing ones with block\nruby\n[{ foo: 1, bar: 2 }]\nruby\narray\n  create :qux, from: [:foo, :bar] do |foo, bar|\n    foo + bar\n  end\n  remove :bar\nend\nruby\n[{ foo: 1, qux: 3 }]\n- wrap/unwrap values applied to any level:\nruby\n[{ foo: [{ bar: 1, baz: 2 }] }]\n``` ruby\narray do\n  attribute :foo\n    wrap :qux # means 'wrap value of [{ foo: ? }]' to qux\n  end\nend\n[{ foo: { qux: [{ bar: 1, baz: 2 }] } }]\n```\n``` ruby\narray do\n  attribute :foo\n    array do\n      wrap :qux # means 'wrap each tuple of [{ foo: [?] }]' to qux\n    end\n  end\nend\n[{ foo: [{ qux: { bar: 1, baz: 2 } }] }]\n```\n- group/ungroup lists also applied to any level:\n``` ruby\n[{ foo: [{ bar: 1, baz: 2 }, { bar: 1, baz: 3 }] }]\n```\nruby\narray do\n  attribute :foo\n    array\n      group :baz, to: :qux\n    end\n  end\nend\n``` ruby\n[{ foo: [{ bar: 1, qux: [{ baz: 2 }, { baz: 3 }] }] }]\n``\n. Ahh! Need to document this\n. Mentioned embedded in mappers guide.\n. D'you mean \"doesn't set it authomatically\"? It shouldn't\n. @ThijsWouters you have to look at the [rom-sql](https://github.com/rom-rb/rom-sql), that is wrapped around theSequel. UsingSequel` scheme you can define primary key, foreign key etc.\nThe rom/memory is a simple in-memory storage. There is no concept of primary key. As @AMHOL noticed above, you can provide your own, but this is totally up to you.\n. No, I think adding the uuid as @AMHOL proposed is a sort of golden standard for rom/memory.\n. @c0 I don't think this should be class, because there is nothing to instantiate\n``` ruby\nmodule ISBNCoercer\n  extend ROM::Coercer\n  register_as :isbn\nimport :camelize, from: Inflecto, as: :camel_case\ndef self.call(value)\n    t(:camel_case)[value.to_s]\n  end\nend\n```\nHere ROM::Coercer could in turn\n- extend Transproc::Registry (allowing to import external modules and/or their singleton methods),\n- define register_as method for ROM env\n(Camelized isbn is a know-how ;)\n. @AMHOL (1) why? (2) if so, we can simply go with Transproc::Registry\n. @AMHOL  \"Don\u2019t be sad\" (c) Magical Deer\nAhh, yes you're right about dependency. Then registering a coerser is no-go.\nBut I wonder if the whole idea of coercer is coupled to specific mapper. If so, we could mix transproc to mappers and use mappers as local registries except for global one.\n. @cflipse What about base ROM::Mapper?\nWe could extend it by Transproc::Registry and then add shortcuts #[] (aliased as #t) to access its singleton methods from every mapper instance, not to mention mapper classes.\nThis is still decoupled from global env, against which @AMHOL argued above\n. @solnic Well, in ROM::Mapper we have that dependency.\nWe could (as @AMHOL pointed, if I understood it correctly) use other mapper engine, and this make global ROM dependency from transproc no-go.\n. Ahh, i see. But this make me curious whether we really expect somebody some time decide to write its own compiler to substitute Transproc? I'd rather expect somebody to write another mapper based on the same transformer :)\n. ...I'm trying to faster the process by reading Dragon Book. Seems like this was not a cute idea.\n. @waiting-for-dev Concerning your last update.\nThe problem is that wrap operation removes from root those attributes, that have been wrapped. There is no way to wrap attributes and add their substitutes (under the same name) at once (in one step).\nAs a solution I'd propose doing this in 2 steps (though it is ~2 times slower):\n``` ruby\nclass Client < ROM::Mapper\n  register_as :client\n  relation :origin_clients\nreject_keys true\n  symbolize_keys\nstep do\n    attribute :name\n    attribute :identifier\nwrap :address do\n  attribute :address\n  attribute :zip\n  attribute :town\n  attribute :region\n  attribute(:created_at) { Time.now } # this will remove `:created_at` from root\n  attribute(:updated_at) { Time.now }\nend\n\nend\nstep do\n    attribute(:created_at) { Time.now }  # now we restore them at the root\n    attribute(:updated_at) { Time.now }\n  end\nend\n```\n. Like it\n. \u0441\u0431, 31 \u0434\u0435\u043a. 2016 \u0433. \u0432 14:24, Nikita Shilnikov notifications@github.com:\n\n@flash-gordon commented on this pull request.\nAhh, I see. But your solution requires deep analysis of whether a value is\nfrozen to the guts. Shallow freezing isn't enought. This in turn require\nmore dependencies (more than zero which means infinitely more), or more\ncode and more overhead. Tbh defaults are overhead by themselves, but we\nlove them ;)\nThat's why I'm strongly against this kind of interface simplification\n(Actually I've made a same try in May, not via analyzis of freezing, but\nvalue dup-ing under the hood. That turns out to became a disaster, and I've\ncut and burn it eventually)\n\nIn lib/rom/command.rb https://github.com/rom-rb/rom/pull/372:\n\n option :input, reader: true\n\n\n\n\noption :curry_args, type: Array, reader: true, default: EMPTY_ARRAY\n\n\noption :curry_args, reader: true, default: -> _ { EMPTY_ARRAY }\n\n\nI agree with this, but I meant something different:\nerror, use procs\nparam :foo, default: 'bar'\nworks fine, doesn't raise an error if an object was frozen,\nwraps it with a proc internally\nparam :foo, default: 'bar'.freeze\nworks fine, booleans are frozen\nparam :foo, default: true\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/rom-rb/rom/pull/372, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABdLZHqNAhE-zoYYxZlCOTtQT6mZRe_mks5rNjtWgaJpZM4LYC5U\n.\n. @solnic Sorry, but I can do nothing for now because I\u2019m on vacation without any notebook. I could look at it only in a week. It\u2019s sad, but the only proposal from me for now is locking the dependency at 2.5.0. Hi @timriley \nYes, I could send it you via keybase.io (nepalez as usual). Bingo! I\u2019ve sent you the creds. @timriley done. @solnic I\u2019ve sent the creds to you on the keybase. Cannot understand howto do it for ordering by multiple names. Need to think.\n. Definitely makes. Thanks to our new guest, John, I've recognized that i've missed differencies between minor fields. Need to polish it off for some time\n. <=> (and __compare) returns nil when a[n] and b[n] are incomparable (against my expectation that they should be as values from the same field). In that case the whole ordering should report incompatibility. If I'd applied nil.nonzero? it would raise NoMethodError instead.\n\nMaybe this edge case should be covered too. Mea culpa.\nAnd wow! I tried .detect(0) { ... } and couldn't understand why it failed. I sooo like .detect(->{0}) { ... }!\n. One more interesting question. How order should behave in case some values cannot be ordered?\nruby\n[\n  { name: \"Alice\", age: 7 },\n  { name: \"Knave\", age: '1@2'.to_c }\n]\nIt could either raise, or remain data unsorted. This needs a decision, I think\n. Changed\n. Ah, I've got it. Will change both methods in a minute\n. This one is rubocop-inspired\nhttps://github.com/bbatsov/ruby-style-guide/issues/196\n. Yes, it would be. I cannot change this PR, because it it the @dekz who owns it. Can only update after the merge\n``` ruby\n    # Prepares an array of headers for a potentially multistep mapper\n    #\n    # @return [Array]\n    #\n    # @api private\n    def self.headers(header)\n      return [header] if steps.empty?\n      return steps.map(&:header) if attributes.empty?\n      raise(MapperMisconfiguredError, \"cannot mix outer attributes and steps\")\n    end\n# Build a mapper using provided processor type\n#\n# @return [Mapper]\n#\n# @api private\ndef self.build(header = self.header, processor = :transproc)\n  processor = Mapper.processors.fetch(processor)\n  transformers = headers(header).map(&processor.method(:build))\n  new(transformers, header)\nend\n\n``\n. Ok, I'll correct this soon. (I just used tosubject` as \"subject under test\", but you're right - specs should be written in a consistent style)\n. Yes, only procs are allowed by design\nThis was done by 2 reasons\nThe main one is that this way we prevent mutation of default values an instance was initialized with\nThe minor reason is that using procs, evaluated in new instance's scope allows setting defaults depending on other arguments. Nope, freezing provides too strong limitation.\nActually what we do wanted is not avoiding mutation per se. It can be useful in many cases like one-off service objects. Freezing would break that cases totally. We wanted to prevent leeking mutations via defaults between various instances.\nIn february @marshall-lee convinced me to use procs by this simple example:\n```ruby\nrequire 'dry/initializer'\nclass A\n  extend Dry::Initializer::Mixin\nparam :name, default: proc { '...' }\ndef call\n    name << 'HAHA'\n  end\nend\n3.times { puts A.new.call }\n=> '...HAHA'\n=> '...HAHA'\n=> '...HAHA'\n```\nIn case of no-proc instantiation (was implemented from the beginning, but removed now) this would provide something like:\n```ruby\nclass B\n  extend Dry::Initializer::Mixin\nparam :name, default: '...'\ndef call\n    name << 'HAHA'\n  end\nend\n3.times { puts B.new.call }\n=> '...HAHA'\n=> '...HAHAHAHA'\n=> '...HAHAHAHAHAHA'\n```\nWith a proc we do mutation after instantiation, but prevent leaking it outside (through a single object used as default value). Now all defaults are different objects, so various instances of A become independent from each other.\n. Ahh, I see. But your solution requires deep analysis of whether a value is frozen to the guts. Shallow freezing isn't enought. This in turn require more dependencies (more than zero which means infinitely more), or more code and more overhead. Tbh defaults are overhead by themselves, but we love them ;)\nThat's why I'm strongly against this kind of interface simplification\n(Actually I've made a same try in May, not via analyzis of freezing, but value dup-ing under the hood. That turns out to became a disaster, and I've cut and burn it eventually). @solnic just for the clearance: you could use a \"simplified\" syntax with second argument for type as well (I added it some time ago for compatibility to reform etc.)\nruby\noption :directory, PathnameType, reader: true. ",
    "c0": "My personal use-case:\nI'm creating an aggregate object. It's one tuple b/c it's a join of 3 postgres tables (using rom-sql's association_left_join). Each relation/table has an array of amenities. The aggregate needs to combine the three arrays into one.\nOne simple way may be to provide multiple keys in the from:. For example \u2014\nruby\nattribute :d, from: [:a, :b, :c] do |a, b, c|\n  a + b + c\nend\n. @nepalez Yeah, I was afraid it'd create oddities and do more harm than good :(\nAs a \"solution\", I ended up using the model method (since it receives the entire tuple). This is very much a hack and I would not recommend it, but wanted to throw it out there in case there's a better way.\n``` ruby\nclass FooBarBazMerger\n  def self.new(tuple)\n    tuple.merge({\n      name: tuple[:foo] || tuple[:bar] || tuple[:baz]\n    })\n  end\nend\ninside the mapper\nmodel FooBarBazMerger\n```\n. @nepalez cool. I'm interested to see how it plays out.\nThe part that feels like a hack to me is where .new is overwritten and returns tuple, rather than an instance of the class. This goes against expectations.\n. @nepalez I don't think the confusion is in the naming of the mapper, but that #as does not have any indication that it's using a mapper.\n``` ruby\nrom.relation(:tasks).as(:tasks)\nas opposed to\nrom.relation(:tasks).map_to(:tasks)\nor even\nrom.relation(:tasks).mapper(:tasks)\n``\n. I agree that documentation is immensely useful, but it's better when the code is clear without it. Both are needed :smile:\n. @solnic good to know. I personally like#map_with. The way I readasis that it's expecting a _noun_. i.e. the object/model you'll end up with. I see mappers more as _verbs_ and transformative rather than an end result. So something likerom.relation(:users).through(:entity, :view_presenter)` makes more sense.\nAt the end of the day, I'll follow the consensus. I've been a ruby dev for a number of years, but am new to rom-rb and just wanted to surface some things that may be difficult for newcomers :)\n. Sounds like a plan. Thanks everyone for the feedback!\n. I like the idea of pulling these apart. It gives us an opportunity to show how to use the classes on their own without the DSL.\nWhat do you think about pulling the DSL together in either rom or rom-dsl? (If it's possible). Or would this be covered by rom-env?\n. Sorry, DSL isn't the right word.\nI was wondering what it would look like to separate the pipeline/lazy API from instantiating the classes directly. (Mapper.build etc).\nThis may be implied by the list you have or it may be something not practical. :)\n. A lot of the API style is to create a subclass which registers itself. What are your thoughts on:\n``` ruby\nclass ISBNCoercer < ROM::Coercer\n  register_as :isbn\ndef self.call(value)\n    value.to_s\n  end\nend\n```\nAlso, the concept of prefixing with to_ feels too indirect and requires familiarity with transproc.\n. @AMHOL I'm with you and am all for removing state. I pointed it out because it would be consistent with the rest of the API.\n. ",
    "schwern": "Sorry, I somehow posted this to the wrong repository.\n. I'll reopen it then.\n. In a related issue, @jeremyevans said no to the idea.  Or rather the impression I got was transparent PG<->Ruby array translation has to work everywhere or nowhere.\n. Exactly, I meant to report this to Sequel.  I'm not sure how I landed here.\n. ",
    "drewda": "Persist object data to JSON files, as an alternative to YAML or CSV formats.\n. Great, thank you for considering this.\n. ",
    "lukeses": "I will work on this issue.\n. ",
    "rolfb": "@lukeses I've done some initial work in https://github.com/rom-rb/rom-json, but writing is still missing. Is that something you'd care to look into?\n. ",
    "carlisia": "I personally like register_as :widget_model better.\n. Not a bug.\n. ...aaaand it was my mistake, no bug here, moving along...\n. ",
    "vrish88": "@errinlarsen do you mind fixing up the conflicts? If not I've got some time this week and I could fix it up.\n. @nepalez & @solnic anything else that needs to be addressed in this pr?\n. @solnic @nepalez Ok, I finally got a chance to fix the implicit exception reference and I've applied the same check to group. In the process though I did a rebase from rom/master and needless to say I force pushed and lost some previous comments.\nAnyways, lemme know what you think now.\n. All of this AM craziness is related to figuring out the model name and the url for the record. If you provide the :url and :as options you can pass a PORO right into form_for.\nruby\nform_for option, as: :option, url: admin_product_option_path #...\nGoing forward though, I don't know we could communicate that they can do this with POROs.\n. What about something like validates :name, uniqueness: {primary_key: :id}?\n. I'm kinda still new to this so lemme know if I'm way off base... So validations in ROM are only done in the context of a Form right? So could we modify the form so that validations block could take a relation object as well as the name of a relation?\n``` ruby\nclass TaskForm < ROM::Model::Form\n  validations do\n    relation rom.relations(:cart_items).active.exclude(id: :id).active\nvalidates :name, uniqueness: { message: \"Already added #{name}\" }\n\nend\nend\n```\n. ",
    "errinlarsen": "yup. I'll get it fixed up today.\n. Closing this pull-request; merge conflicts are fixed in #278.\n. I like the proposed split (rom-core, rom-relation, rom-mapper, and rom-command, with a 'rom' meta gem for delivering a default stack). I think rom-env needs some work. It feels like there are a couple pieces tied together in ROM::Env; namely, the registries and the setup DSL.\nWhat if I want to implement my own mapper DSL, use the provided relation DSL, write my own setup DSL, and I already have some global-level registry solution that I'd like to add ROM components to?\n. I can fix this, and update the rubocop config to stop reporting these offenses.\nWant me to create a new pull-request? add a commit to this one?\n. ",
    "flash-gordon": "O_o\nOn Fri, 10 Feb 2017 at 13:41, Coveralls notifications@github.com wrote:\n\n[image: Coverage Status] https://coveralls.io/builds/10090602\nChanges Unknown when pulling bd4757e\nhttps://github.com/rom-rb/rom/commit/bd4757e26e69f20a7cb6dbc2832778e08c446990\non command-graph-builder into  on master.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rom-rb/rom/pull/247#issuecomment-278912466, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAw-tqKqMZ1empB2n6jZBZuUF10GhRzPks5rbD7xgaJpZM4EvCOU\n.\n. Like that?\n\n``` ruby\nmodule CommandPlugins\n  module ActiveRecordTimestamps\n    class HashWithTimestamps\n      def self.\n        tuple = Hash[*args]\n    now = Time.zone.now\n\n    if tuple[:created_at]\n      tuple.merge(updated_at: now)\n    else\n      tuple.merge(created_at: now, updated_at: now)\n    end\n  end\nend\n\ndef self.included(base)\n  super\n\n  base.input HashWithTimestamps\nend\n\nend\nend\n``\n. Ok, I'll keep it in mind. Also my implementation changes behavior ofinput#[]` so it's not a pure function anymore.\nThank you!\n. Wow, right in time (=\n. Looking on Travis I wonder why bundler tries to install activerecord even if it was told not to install benchmarks section. Strange.\n. I don't know, I guess it can be caused by using custom script option. Don't worry, I'll figure that out tonight :)\n. @solnic ahahah, we depends on activesupport here \u00af_(\u30c4)/\u00af\nI'll try to remove it...\n. @solnic haha, 18th line was removed :) https://github.com/rom-rb/rom/commit/c66b6ecedf9122d386088120a7c5a544bede61df\n. OK, done, I added the same version as in dry-t\n. @solnic this now spread across four PRs (fresh one is https://github.com/rom-rb/rom-support/pull/7). And this works basically :) It's a weekend here so I'm going to add specs/docs today and besides it you're free to review these PRs so we could merge them into master one day :)\nApart from it, it would be great to add support for alias syntax for associations like belongs :users, as: :author but it can be postponed until we get this merged.\n. Will do!\n. @solnic is it fine?\n. Hey, @alderion, I moved this to https://github.com/rom-rb/rom-sql/issues/92, check it out\n. @solnic I think so https://github.com/rom-rb/rom/blob/master/lib/rom/schema.rb#L81\n@cflipse could you check it against master branch? If it works, we should release a fix\n. Dunno, if you do not require rom/support/constants it's more or less backward compatible. Keep in mind that _at this point we didn't touch rom-support (the only exception), so anyone is free to use it, i.e. he/she can require 'rom/support/class_builder' or something, and it won't affect ROM itself.. Exactly, this is the next part. I'm going to work on this on the next week (I fell off my motorbike and got some spare time lol, nothing serious, just won't swim for a week or so).. @solnic any comments?. I won't forget to update the changelog this time, I promise. Yeah, I checked that once, it was faster than ROM::Options. Anyway I'll benchmark that again. Well, it was a while ago, things have changed. Now dry-initializer is slower, but that's because of ... dry-types. This is only true when we check types, otherwise dry-initializer 2x-3x times faster than ROM\n```\nbundle exec ruby ./benchmarks/with_types.rb\nBenchmark for instantiation with type constraints\nWarming up --------------------------------------\n          plain Ruby    51.900k i/100ms\n     dry-initializer     8.668k i/100ms\n              virtus    11.401k i/100ms\n     fast_attributes    35.387k i/100ms\n                 rom    11.148k i/100ms\nCalculating -------------------------------------\n          plain Ruby    592.015k (\u00b1 5.9%) i/s -      8.875M in  15.042768s\n     dry-initializer     86.834k (\u00b1 4.4%) i/s -      1.300M in  15.002131s\n              virtus    113.951k (\u00b1 5.2%) i/s -      1.710M in  15.051657s\n     fast_attributes    406.862k (\u00b1 4.9%) i/s -      6.122M in  15.084655s\n                 rom    117.224k (\u00b1 5.2%) i/s -      1.761M in  15.068541s\nComparison:\n          plain Ruby:   592015.3 i/s\n     fast_attributes:   406861.9 i/s - 1.46x  slower\n                 rom:   117224.3 i/s - 5.05x  slower\n              virtus:   113951.2 i/s - 5.20x  slower\n     dry-initializer:    86834.4 i/s - 6.82x  slower\n```\n```ruby\nBundler.require(:benchmarks)\nclass PlainRubyTest\n  attr_reader :foo, :bar\ndef initialize(foo:, bar:)\n    @foo = foo\n    @bar = bar\n    fail TypeError unless String === @foo\n    fail TypeError unless String === @bar\n  end\nend\nrequire \"dry-initializer\"\nrequire 'dry-types'\nrequire \"dry/initializer/types\"\nclass DryTest\n  extend Dry::Initializer::Mixin\n  # extend Dry::Initializer::Types\noption :foo, type: Dry::Types['strict.string']\n  option :bar, type: Dry::Types['strict.string']\nend\nrequire \"virtus\"\nclass VirtusTest\n  include Virtus.model\nattribute :foo, String\n  attribute :bar, String\nend\nrequire \"fast_attributes\"\nclass FastAttributesTest\n  extend FastAttributes\ndefine_attributes initialize: true do\n    attribute :foo, String\n    attribute :bar, String\n  end\nend\nrequire 'rom/support/options'\nclass ROMTest\n  include ROM::Options\noption :foo, reader: true, type: String\n  option :bar, reader: true, type: String\nend\nputs \"Benchmark for instantiation with type constraints\"\nBenchmark.ips do |x|\n  x.config time: 15, warmup: 10\nx.report(\"plain Ruby\") do\n    PlainRubyTest.new foo: \"FOO\", bar: \"BAR\"\n  end\nx.report(\"dry-initializer\") do\n    DryTest.new foo: \"FOO\", bar: \"BAR\"\n  end\nx.report(\"virtus\") do\n    VirtusTest.new foo: \"FOO\", bar: \"BAR\"\n  end\nx.report(\"fast_attributes\") do\n    FastAttributesTest.new foo: \"FOO\", bar: \"BAR\"\n  end\nx.report(\"rom\") do\n    ROMTest.new foo: \"FOO\", bar: \"BAR\"\n  end\nx.compare!\nend\n```. also we need to do something with https://github.com/dry-rb/dry-core/pull/7. @solnic this is ready to go, I'll send PRs to rom-sql and rom-repository in the next year ;). +1 for that, this is gonna make things much more easier in complex cases.\nOn Thu, 5 Jan 2017 at 19:09, Piotr Solnica notifications@github.com wrote:\n\n@timriley https://github.com/timriley cool, FWIW I wanted to do this in\nrom 2.0.0 but ran out of time O_o but now it's a must-have because repos\nneed this badly\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/rom-rb/rom/pull/374#issuecomment-270630288, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAw-tuJFjAZESbWwhsPINwUebiW5djS1ks5rPN1ogaJpZM4LbnMq\n.\n. https://github.com/rom-rb/rom-sql/pull/128. Probably having an alias for VO, like Vo = VO, is also an option.. re performance didn't test, was going to ask you haha. I mean what should I benchmark?. ref https://github.com/dry-rb/dry-initializer/issues/25. @solnic it's kinda hardwired inside the gem atm, we could have our own getters though, I'll give it a try. @solnic dry-initializer now has the undefined: false option that we use to disable UNDEFINED in instance variables,\n\nruby\n2.4.0 :006 > require 'dry-initializer'\n => true\n2.4.0 :007 > Dry::Initializer\n => Dry::Initializer\n2.4.0 :008 > class Foo\n2.4.0 :009?>   extend Dry::Initializer[undefined: false]\n2.4.0 :010?>   option :foo, optional: true\n2.4.0 :011?>   end\n => #<Module:0x007ff24e116b90>\n2.4.0 :012 > Foo.new\n => #<Foo:0x007ff24e105d90 @__options__={}, @foo=nil>\nResolved default values stored in @__options__:\nruby\n2.4.0 :002 > class Bar\n2.4.0 :003?>\n2.4.0 :004 >     extend Dry::Initializer[undefined: false]\n2.4.0 :005?>   option :bar, default: -> { 1 }\n2.4.0 :006?>   end\n => #<Module:0x007fb0c50145a0>\n2.4.0 :007 > Bar.new\n => #<Bar:0x007fb0c4835690 @__options__={:bar=>1}, @bar=1>\nI'm merging this, kudos to @nepalez for helping with this\nP.S. Specs are still slower than with 0.11, but that's because of class-level code evaluated on subclassing Relation and/or Command, this won't affect the run-time performance.. I added an adapter check to the gateway linter, so that now having this required for all adapters. \nrom-sql updated in https://github.com/rom-rb/rom-sql/commit/aeda48f5342827f47b95a65cb478e79a06202ddc. I've found this would be a really nice addition, this will reduce the boilerplate on defining schemas significantly and will allow to add some cool stuff to rom-sql. Specifically I want to have auto-index attributes in schemas because you normally want to have all the FKs to be indexed.. @solnic glad to see you :) I'm gonna make it work with relation finalizers today/tomorrow so that it will be possible to load plugins globally, then this will be ready for going in master. Gotta say the plugin infrastructure is a bit messy and I guess will require some refactoring before 4.0. . @solnic so... it turned to be not that easy, I can't extend the schema DSL because it is used before finalization, at the class level. Do you know any reason why we can't move it to the finalization step?. we infer schemas at the finalization step thus viewDSL cannot depend on it without having corner cases where view syntax breaks for unclear reasons. > we infer schemas at the finalization step thus viewDSL cannot depend on it without having corner cases where view syntax breaks for unclear reasons\nI actually saw those errors, now just things clicked in place :). @solnic phew! I store an unresolved schema in @schema_proc of a relation class. Overall, postponing schema initialization wasn't hard, in Relation.view I've changed schema.project(*args[1]) to -> _ { schema.project(*args[1]) }\nThere is a bunch of related changes in rom-sql and I'll push them later today. While I was working on this I realized how hardly we need some sort of bootstrapping pipeline with events, callbacks and things like that. It's very tough to learn how every single hook in rom works because they works differently. \nI wish it would be \nruby\nROM::Bootstrap.before(:schema_load, relation: :users) do |container, schema_dsl: , **other_stuff|\n  schema_dsl.extend(Timestamps::SchemaDSL)\nend\n^just a sketch, but wdyt?. @solnic done. I actually removed setting a schema in the inherited hook because it's not defined when the hook gets called.. Thanks for reporting this, that's probably because I didn't add respond_to_missing? \ud83d\ude48 , I'll have a look.. Aha, that's because ROM now has named structs, this shouldn't break anything but as we see it did. However, I'd say ROM works fine and this behavior won't change. Oj gets a class by its name but we generate classes dynamically and all of them share the same name. When Oj accesses ROM::Struct::Employee it gets the parent class for all other Employee classes. The class it gets doesn't have any attribute in its definition, that's why it silently skips all data that comes from Oj.load and returns you a useless empty struct.\nSince all auto-structs are anonymous I don't think it is possible to serialize/deserialize them in a nice manner. E.g. what if you loaded an aggregate \nruby\nuser = user_repo.aggregate(:posts).by_pk(id).one!\nand then you serialized it with Oj (or whatever) and try to load in another process, which just doesn't have such a class yet (because no-one tried to build an aggregate like that)?\nThe only way to make sure you load data back is to use your own named classes instead of auto-structs.\nIf you're OK with dumping/loading hashes you can explicitly call .to_hash on structs before serializing them, this works as before. Another option is defining to_json and using Oj.to_json:\n```ruby\nclass ROM::Struct::User < ROM::Struct\n  def to_json\n    to_hash.to_json\n  end\nend\nOj.to_json(repo.users.first) # => \"{\\\"id\\\":1,\\\"name\\\":\\\"Jane\\\"}\"\nOj.load(Oj.to_json(repo.users.first, mode: :compat)) # => {\"id\"=>1, \"name\"=>\"Jane\"}\n```\n@solnic I wonder if you have any thoughts on this, or you just should know about the corner case we have here. @solnic how so? It dumps things to a string, ofc it can dump a class to #<Class:0x007fe730250020> but this is pretty dumb because this works only in one process and in one process you do not need to serialize anything. Ha, sorry about that :)\nruby\n[3] pry(main)> Oj.dump(repo.users.first)\n=> \"{\\\"^o\\\":\\\"ROM::Struct::User\\\",\\\"id\\\":1,\\\"name\\\":\\\"Jane\\\"}\". then it calls ROM::Struct::User.new(id :1, name: \"Jane\") and ROM::Struct::User.new swallows the args because the class doesn't have attributes. @solnic keep in mind also that the class you want to deserialize to have to exist at the time you call Oj.load and we can't guarantee that, even with unique names. Please update rom-sql https://github.com/rom-rb/rom-sql/blob/master/CHANGELOG.md#v132-2017-05-13. \ud83e\udd14 \n@solnic what if we join base relations by default? I.e. users has many visible_comments, where visible_comments is a view defined to comments, then we just do join on users.id = comments.user_id, no matter how visible_comments is defined (user_id might not present in visible_comments we should raise an error in this case, I think it's fine for now). And in other cases we could leverage the block syntax you proposed in the chat. @solnic lol, let's put it in another form, what's the problem with joining a view? RDMS has a similar concept of a \"database view\" and it's absolutely legal to join a view. We can do something very similar by, say, joining a subquery. WDYT?. @solnic that's pretty much it, I'll add some specs and tweak things a bit but overall it's complete. No more, I'll push specs to master and this can me merged now.. This sounds \ud83d\udcaf reasonable, I can confirm there are no obstacles to support this as described. @solnic I'm not sure if inheritance in relations is going to work well\nOn Tue, 13 Jun 2017 at 08:54, Piotr Solnica notifications@github.com\nwrote:\n\nThere's one more thing I should mention - a lot of people asked for a way\nto mimic polymorphic assocs from AR because they are working with legacy\nschemas. So, in rom-4 something like this should be possible:\nclass Admins < Users\n  dataset { where(type: 'Admin') }end\nNow, because this would be registered under :admins then Entities::Admin\nshould be automatically inferred, and you can do Admin < User to share\ncommon behavior like in STI in AR.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/rom-rb/rom/issues/413#issuecomment-308014266, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAw-ttYC5yhvnHGqPLcFIkJopeAH8ofvks5sDiQHgaJpZM4N3wrX\n.\n. @solnic mb copying @schema_proc is enough. ahh, right, actually I tried to \"fix\" that inheritance thing but gave up quickly. \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 . I completely forgot this works this way. And I agree now it looks alien to the features we have. This probably will break some code of people who still use ROM from the pre-1 era but it's unlikely they prefer these methods over auto-*s. We just should offer them a before/after upgrade plan. What should I do with Schema#with? It's marked as a public API but don't think anyone is going to miss it. @solnic I meant the doc is gone, the method is still there, now auto-generated \ud83d\ude2c . ah, thanks!. Thanks!. This should be fixed in master, you can check it with\n\ngem 'rom', git: 'https://github.com/rom-rb/rom', branch: 'master' do\n  gem 'rom-core'\nend. @solnic this can go to master. Say we have a base class for user structs\nruby\nmodule Entities\n  class User < ROM::Struct\n    def age\n      \"#{ super } years old\"\n    end\n  end\nend\nWe want that Entities::User#age method defined on top of attribute readers. We need to put readers in a module then and include it in Entities::User. So far so good, but there is a downside, all the readers will be available in the base class including ones defined for aggregates which is not ideal.\nWe can rebind the methods defined in Entities::User to all its successors, fortunately, Ruby allows this trick\nruby\nclass AutogeneratedUserClass < Entities::User\n  define_method(:age, superclass.instance_method(:age))\nend\nIt works like this\n```ruby\nclass A\n  def age\n    30\n  end\nend\nclass B < A\n  def age\n    \"#{ super } years old\"\n  end\nend\nclass C < B\n  define_method(:age, superclass.instance_method(:age))\nend\nputs C.new.age #=> 30 years old years old\n```\nCombined with attribute readers defined in a separate module we'll be able you call attributes via super.\nThings are becoming much more complex when inheritance comes into play. What if Entites::User wasn't a direct descendant of ROM::Struct? TL;DR I suggest to prohibit indirect inheritance and use modules instead in such cases. In contrast to inheritance, we can easily track modules inclusion with a simple overloading of the include method and include them only in subclasses.\nIn practice, this means a custom struct class becomes an outline of a real class, all instance methods will be rebound to a subclass and all modules will be included/prepended in a subclass. \nInitially, this all looked like a mess to me, then I gave it another thought. \nYou can check out the PoC https://github.com/rom-rb/rom/compare/rom-struct-overridden-attribute-defects-fix?expand=1. @solnic dunno, it doesn't look we're going to do something with this yet. @solnic for now, we could add an alias alias_method :combine, :aggregate. Fixing this requires applying https://github.com/rom-rb/rom/commit/cb838f49d5d045e2e8ab0bbab48ef80c3b4b1108 to the release-3.0 branch, can't do it right now. If anyone wants to help with this it would be great. @graywolf @AlexanderMint 3.3.3 with the fix is on rubygems \ud83c\udf89 . Thank you!. Hi @artps,\nThe good news is that we already have similar behavior in master of dry-struct. There is an issue related to these changes which I tried to solve in https://github.com/rom-rb/rom/pull/463. I'm gonna merge it tomorrow and then release dry-struct 0.4 in a day or so. Note that we don't plan to have a different behavior for #[] compared to normal method calls, this way we keep the interface of structs identical to plain hashes, for accessing raw values you should use instance variables.. UPD dry-struct 0.4.0 is on rubygems, check it out. I recommend to use it with the latest rom release (rom-mapper >= 1.0.2 specifically), otherwise you might get into trouble on hitting missing methods.. cool, thank you!. @solnic @GustavoCaso I force-pushed the branch, I made it take PK names from canonical schema, I think this should be fine for now. hey, @VitaliyKovtun pls post questions to https://discourse.rom-rb.org/\nAs for callbacks we discourage from using them for business logic, if you have a different case for them pls post it to discourse so we can discuss it there. @solnic it's more about input schemas that inject a default value on nil. I would argue they should do it on missing key instead. . @solnic hm, actually, I can't see what's the difference between these approaches, even nils have to be overridden with default values, hashes will be rewritten in both cases. I had some failures on jRuby. Initially, I tried to bump its version but it doesn't work well because of I tried https://github.com/jruby/jruby/issues/4895. Then I updated specs to forcefully \"unload\" constants in https://github.com/rom-rb/rom/pull/479/commits/bad37407616e3d394335b823f06807741a1099ca, this slowed down specs by 0.5s (2.2 -> 2.7) or so but I believe a clean environment is better than speed here, we can tag these specs as slow if needed.. @solnic but we qualified schemas in rom-sql 2.0, I believe those .qualified calls aren't even needed. Specs from rom-sql and rom/repo passing. @cgeorgii thanks, looking \u2764\ufe0f . Hi, please forward your questions to https://discourse.rom-rb.org/ as mentioned in our contribution guidelines, we'll sort it out there. Thanks!. This is a bug in dry-struct. https://github.com/dry-rb/dry-struct/blob/v0.4.0/lib/dry/struct/class_interface.rb#L73\nIt is fixed in master but rom isn't compatible with it. We could cut a branch from v0.4.0 if needed. we could, this will be a separate fix though since we don't have this problem in master as we don't have that code at all :). rom 4 isn't compatible with the recent dry-types/dry-struct releases, there's a branch which nearly works https://github.com/rom-rb/rom/pull/478 but atm this has a breaking change. @solnic we first need to discuss the plan in https://github.com/rom-rb/rom/pull/478#issuecomment-384019000 If we fix the spec it will be a breaking change so we can't do it. Instead, we can mimic the current behavior in 4.0 but change it in 5.0, or leave it as it is (inconsistent with current dry-struct behavior).. 4.2.1 pushed to rubygems. hmm, we don't like global state => we'll have an injectable inflector in 5.0, I wonder if we need something in between in 4.0 @solnic . @ianks see how cache passed around https://github.com/rom-rb/rom/search?utf8=%E2%9C%93&q=cache&type=. @radar no, it's wrong, I wonder why our tests are even passing \ud83d\ude1f \nThe idea is to use user-provided structs as base classes, whereas your changes modify the base class itself. In a real-world application rom creates more than one subclass and defines required attributes in every one of them. With your changes, it will try to define them all in a single struct class, this will end up with an error.\nWe need to improve our test suite.. This sounds good to me, I think I'll do it next week.. I cherry-picked almost all of the commits, thanks!. @gingerhendrix thanks for reporting. okay, thanks!\n@solnic don't we have Travis configured for running PR builds? \ud83e\udd14 . sure, done\n. yes, only procs. I think, that's because of how the plugin system is implemented /cc @nepalez . yep, that's why this is WIP :P Just wanted to make it work. I think, I'll wrap initializer mixin with a module which includes instance methods, #options specifically. we could wrap plain values with proc automatically. Mutation concerns can be addressed with .frozen? check, WDYT?. I agree with this, but I meant something different:\n```ruby\nerror, use procs\nparam :foo, default: 'bar'\nworks fine, doesn't raise an error if an object was frozen,\nwraps it with a proc internally\nparam :foo, default: 'bar'.freeze\nworks fine, booleans are frozen\nparam :foo, default: true\n. I'd not go with a deep analysis, because no one stops you from doing like thisruby\ncache = {}\nparam :cache, default: proc { cache }\nFrom my point of view checking `.frozen?` is just enough to be sure that the user knows what he or she is doing. \nJust my thoughts, I don't insist on any changes :). Ha! :+1: . so you doruby\napply_hooks(before_hooks, curry_args, args)\nand thenruby\nexecute((curry_args + args), &block)\n``\nI was curious which one is faster and found that(a + b)is faster thana, bby ~20 percent in all the cases. :chart_with_upwards_trend: . As we saw recently,flatten(1)is more predictable, it's also 20% faster! :grimacing: . \\>.< thanks!. reader is:publicby default\nhttps://github.com/dry-rb/dry-initializer/blob/0d2fa01b11a0669c61eddd0fbc4e18d7aa4094a8/lib/dry/initializer/attribute.rb#L48. @solnic didn't we losefreezesomewhere?. the command class :). remember this https://github.com/hanami/model/pull/405. @solnic I just wanted to know if you still remember it :). I wonder if we really need this, dry-initializer should work fine with inheritance, so perhaps we might removeparam :elementsfrom the descendants instead. Not sure though. \ud83d\udc4d . yeah, I guess there's _a reason_ \ud83d\ude04  I'll have a look later. oh wow. @solnic fyi I had to add:primary_keyand:sourcebecause of https://github.com/rom-rb/rom/blob/8aa0b411e3c4561e850459812b0723b60f692a31/repository/lib/rom/repository/changeset/associated.rb#L28-L38. yeah, this is what we need, add attributes to an existing schema before it gets frozen but without using the dsl. \ud83d\udc4d  sure, will do. technically, you don't need this line,updatereturns the updated hash anyway, otherwise, I'd prefer to go withoptions[:name] = target.relationbecause this won't allocate an intermediate hash instance{ name: target.relation }. I don't think we need this check in ROM 4.0,value` is expected to string and we don't process it twice. I hope \ud83d\ude2c However, in 3.0 it's required for rom-repo. couldn't we just memoize them instead? Passing them as options is also not required, strictly speaking, because they are not always needed. And yes, either memoization or passing them with options is better than using ivars. ",
    "pnomolos": "``` ruby\nproduct_options.controller.rb\ndef new\n  render :new, locals: { product: product, option: NewProductOptionForm.build }\nend\n```\nhaml\n-# new.html.haml\n= form_for [:admin, product, option] do |f|\n    = render 'form', form: f\nBlows up with undefined method 'to_model' for #<Product:0x007fe5584c7c10>\n. I fully understand why it's blowing up, I'm wondering what the best way to solve this \"Railism\" is going to be.\n. @solnic Only option is a Form, product is just an instance of my Product model (which is just a PORO).  I'm wondering if there is an easy way around this beyond creating an additional Form object for the product.\n. What if there was a ROM::Rails::Namer (for lack of a better descriptor) instance that all the AM nonsense got delegated to, with the instance passed in as well?  So product.to_model would return rom_rails_namer.to_model(product) ?\n. Oh I know (and that's ultimately what I did) - the problem is that some\ngems people use are going to depend on the AMness and there won't be any\ngetting around these sorts of things :(\nWe definitely need a (hopefully not too large) HOWTO on just dealing with\nRailsisms\nOn Mon, Jun 15, 2015 at 8:17 AM Michael Lavrisha notifications@github.com\nwrote:\n\nAll of this AM craziness is related to figuring out the model name and the\nurl for the record. If you provide the :url and :as options you can pass\na PORO right into form_for.\nform_for option, as: :option, url: admin_product_option_path #...\nGoing forward though, I don't know we could communicate that they can do\nthis with POROs.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rom-rb/rom/issues/262#issuecomment-112103942.\n. Yeah, I realized that the inflector has no way of knowing.  I'm not using AS so I'll see if Inflecto can be configured to do that.  Forgot about doing it that way.  This can be closed now, unless you want to explore the possibility of registering a custom namespacing strategies.. The same thing that say AutoRegistrationStrategies::CustomNamespace does, but the logic can be defined to whatever you want if you have some weird requirements.  I don't know if the ability to do that is worth the added complexity, though.\n\nBasically load_entities(entity) would call MyCustomStrategy.call(file: file, directory: directory, entity: component_dirs.fetch(entity) if you had requested that strategy be used to resolve things.. @flash-gordon Yep that's true.  I just ran into the \"issue\" and brought it up in case it may be something that could be improved.  Again, not sure if the ability to do this is worth the trade-off.  It's unlikely you'll be needing to pull in a legacy file structure to ROM ;). ",
    "dekz": "Ugh, silly me. Looks like this was fixed in 911c190bba710901e87e04485a91d0e485da8ae5\n. No worries, cheers for that!\n. I do have a quick question @solnic if you have a spare second. I'm trying to grok the usage of Mapping and how they relate to, well, Relations. \nI will try and use the examples from the tests that I have been seeing lately, and maybe once I figure it out I'll write up a quick wiki on this repo to help explain it to the next person.\nLet's say I have a list like this:\nruby\nresponse = {\n  task_list: 1,\n  tasks: [\n    { user: 'jacob', task_id: 1, title: 'do something' },\n    { user: 'jacob', task_id: 2, title: 'do something else' },\n] }\nI want to map the data in a way that isn't a 1:1 translation of Hash into ruby models. Let's say this is a legacy mapping of data and translated into the Model of Users and Tasks.\n``` ruby\nModels\nclass TaskList\n  attribute :id\n  attribute :user\nend\nclass User\n  attribute :name\n  attribute :tasks\nend\nclass Task\n  attribute :user\n  attribute :title\n  attribute :id\nend\n```\n``` ruby\nclass TaskListMapper < ROM::Mapper\n  model TaskList\n  register_as :task_list # Not 100% sure what this does as it isn't listed in the generators?\nattribute :id, from: :task_list\n  embedded :user, from: :tasks do\n    model User\n    attribute :name, from: :user\n    group :tasks, on: { name: :name } do\n      attribute :title\n      attribute :user, from: :name\n    end\n  end\nend\n```\nExpected output (if it were a hash):\n``` ruby\n{:id=>1,\n :user=>\n  {:name=>\"jacob\",\n   :tasks=>\n    [{:user=>\"jacob\", :title=>\"do something\", :id=>1},\n     {:user=>\"jacob\", :title=>\"do something else\", :id=>2}]}}\n```\nI am calling this from building the mapper directly and passing in the response:\n``` ruby\nmapper = TaskListMapper.build\nresponse = {\n  task_list: 1,\n  tasks: [\n    { user: 'jacob', task_id: 1, task: 'do something' },\n    { user: 'jacob', task_id: 2, task: 'do something else' },\n] }\nprop = mapper.call [ response ]\n```\nI'm missing something that helps me grok all this together, any chance you could push me in the right direction?\n. Thanks for the reply @nepalez, the requirement of having user duplicated is unnecessary and I guess I understand the principle of never duplicating data.\nI did try your example on 0.8.0 and it doesn't seem to be able to infer the grouping on users.\n``` ruby\nrequire 'rom'\nrequire 'virtus'\nEntity = Virtus.model(coerce: false)\nclass User\n  include Entity\nattribute :id\n  attribute :name\n  attribute :tasks\nend\nclass Task\n  include Entity\nattribute :id\n  attribute :name\n  attribute :user\nend\nclass UserMapper < ROM::Mapper\n  relation :users\n  register_as :users\nattribute :id, from: :task_list\nwrap :user do\n    attribute :name, from: :user\n    group :tasks do\n      attribute :id, from: :task_id\n      attribute :title, from: :task\n    end\n  end\nend\nresponse = {\n  task_list: 1,\n  tasks: [\n    { user: 'jacob', task_id: 1, task: 'do something' },\n    { user: 'jacob', task_id: 2, task: 'do something else' },\n    { user: 'steve', task_id: 2, task: 'do something else' },\n    { user: 'steve', task_id: 1, task: 'do something' },\n] }\nmapper = UserMapper.build\nprop = mapper.call [ response ]\n=> [{:tasks=>\n[{:user=>\"jacob\", :task_id=>1, :task=>\"do something\"},\n{:user=>\"jacob\", :task_id=>2, :task=>\"do something else\"},\n{:user=>\"steve\", :task_id=>2, :task=>\"do something else\"},\n{:user=>\"steve\", :task_id=>1, :task=>\"do something\"}],\n:id=>1,\n:user=>{:name=>nil, :tasks=>[]}}]\n```\nIs the syntax missing a parameter that tells ROM how or what to group on?\n. @nepalez thanks for that mate, it looks really good. Having those steps or sequences would also be a really good idea I feel. I am willing to try and help implement this if you like.\n. It is a little weird that attribute block is different from everything else. Maybe coercion syntax should change and attribute can be consistent regarding the blocks.\n. Being able to reach down into nested structures to map at that level is definitely something we need to consider.\nMy current workaround is to apply a mapper at that level using the attribute coercion, ie:\nruby\nattribute :foo do |f|\n  #[{ bar: 1 }, { bar: 2 }]\n  BarMapper.build.call(f)\nend\nThis workaround is not something that feels great.\n. Yeah good point, maybe I can make the assumption that transformers must have an interface for composition of :+.\n. ",
    "Snuff": "@solnic Hi! I can do it) I'm trying to use ROM in my project and I need use this feature:) I think I can realize it in 1 week.\n. Sorry for delay, I had a deadline on my work, I'm working on this issue.\n. Hey @solnic, I refactored it. But we have error in jruby build. CI can't install gem anima, could you look?\n. ",
    "ThijsWouters": "@nepalez When I create an entity, I want to omit the id. So that in the real system the id is assigned by the database.\n@AMHOL That looks like it is a possibility. But, how would I let the database choose the primary key?\n. @nepalez I know about that gem. But my project is still very new, and I don't want to pin myself to an implementation of a data source just yet. I will go with @AMHOL's solution for now.\nIs this something that can be added? \n. I created a plugin that does exactly this: https://github.com/ThijsWouters/rom-generated_id\n. ",
    "djbender": "thank you Piotr! :100: \n. ",
    "tpitale": "The answer may very well be \"just use commands everywhere\".\n. May be something worth mentioning in the rom-sql docs \u2026 as I was trying to use what it says in the README there, and those are very similar (all coming from env). I wouldn't be surprised if that's confusing to others.\nOr maybe it'll just be in a later rom-sql guide on using the commands they have built in to that gem?\nClosing for now, let me know if you want me to do anything on this re: documentation.\n. ",
    "xaviershay": "Pretty sure you need a for_orders method on the Items relation. You'd then do combine(items.for_orders).\nSee the example in \"Combining Tuples from Several Relations\" at http://rom-rb.org/guides/basics/mappers/\n. ",
    "hotarubi": "Thanks @xaviershay : )\n. ",
    "waiting-for-dev": "Many thanks for your response.\nI was begining to smell redundance in that second mapper :) Anyway, for someone who could be interested in mapping from a nested hash, embedded did the trick.\nSo, just out of curiosity, is combined in mapper API tied to relational databases?\nNow, about my problem. First, just a detail, my foreign key is in client and not in address, because there is another model which can share addresses with clients.\nSo, following your advice, here they are my commands:\n``` ruby\nclass CreateAddress < ROM::Commands::Create[:sql]\n  relation :destination_addresses\n  register_as :create\nresult :one\nend\nclass CreateClient < ROM::Commands::Create[:sql]\n  relation :destination_clients\n  register_as :create\nresult :one\nassociates :address, key: [:address_id, :id]\nend\n```\nAnd here it is how I'm trying to do:\nruby\nclients_data = rom.relation(:origin_clients).as(:client).to_a\ncreate_client_with_address = rom.command([\n  { address: :destination_addresses }, [:create, [{ client: :destination_clients }, :create]]\n])\nclients_data.each do |data|\n  # One example data:\n  #\n  # {:name=>\"Some dummy name\", :identifier=>1, :address=>{:address=>\"Some dummy address\", :zip=>\"A_zip\", :town=>\"A town\", :region=>\"A region\", :created_at=>2015-07-31 10:41:08 +0200, :updated_at=>2015-07-31 10:41:08 +0200}}\n  create_client_with_address.call(client: data)\nend\n(Later I'll try to do it in one step, instead of iterating, but now I'm not worrying about it).\nBut I'm getting this error, complaining about missing address key:\nruby\nROM::CommandFailure: command: #<ROM::Commands::Lazy:0xb1e0683c @command=#<RagasMigration::Commands::CreateAddress relation=#<RagasMigration$\n:Relations::Destination::Addresses dataset=#<Sequel::Postgres::Dataset: \"SELECT * FROM \\\"addresses\\\"\">> options={:input=>Hash, :validator=>$\n<Proc:0xb9a1287c@/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/command.rb:15>, :result=>:one, :curry_args=>[]}>, @evaluator=#<Proc:0xb1$\n06878@/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/commands/graph/class_interface.rb:38 (lambda)>>; original message: command: #<ROM::$\nommands::Lazy:0xb1e0683c @command=#<RagasMigration::Commands::CreateAddress relation=#<RagasMigration::Relations::Destination::Addresses da$\naset=#<Sequel::Postgres::Dataset: \"SELECT * FROM \\\"addresses\\\"\">> options={:input=>Hash, :validator=>#<Proc:0xb9a1287c@/home/marc/.gem/ruby$\n2.2.2/gems/rom-0.8.1/lib/rom/command.rb:15>, :result=>:one, :curry_args=>[]}>, @evaluator=#<Proc:0xb1e06878@/home/marc/.gem/ruby/2.2.2/gems$\nrom-0.8.1/lib/rom/commands/graph/class_interface.rb:38 (lambda)>>; original message: key not found: :address\n/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/commands/graph/class_interface.rb:47:in `fetch'\n/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/commands/graph/class_interface.rb:47:in `block (2 levels) in build_command'\n/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/commands/graph/class_interface.rb:47:in `each'\n/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/commands/graph/class_interface.rb:47:in `reduce'\n/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/commands/graph/class_interface.rb:47:in `block in build_command'\n/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/commands/lazy.rb:37:in `[]'\n/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/commands/lazy.rb:37:in `call'\n/home/marc/.gem/ruby/2.2.2/gems/rom-0.8.1/lib/rom/commands/graph.rb:54:in `call'\n/home/marc/projects/clients_webs/ragas_migration/Rakefile:18:in `block (4 levels) in <top (required)>'\n/home/marc/projects/clients_webs/ragas_migration/Rakefile:17:in `each'\n/home/marc/projects/clients_webs/ragas_migration/Rakefile:17:in `block (3 levels) in <top (required)>'\nBonus: In fact I have two problems, because it seems that attribues inside a wrap block override and let without effect attributes with the same name outside the wrap block. I state this here because maybe it is just a silly thing done by me, but if it is an unrelated bug tell me and I'll open another separated issue.\nMy mapper is:\n``` ruby\nclass Client < ROM::Mapper\n    register_as :client\n    relation :origin_clients\nreject_keys true\nsymbolize_keys\n\nattribute :name\nattribute :identifier\nattribute(:created_at) { Time.now }\nattribute(:updated_at) { Time.now }\n\nwrap :address do\n  attribute :address\n  attribute :zip\n  attribute :town\n  attribute :region\n  attribute(:created_at) { Time.now }\n  attribute(:updated_at) { Time.now }\nend\n\nend\nend\n```\nBut as you can see I'm not getting top level created_at and updated_at, but just the ones inside address wrap:\n{:name=>\"Some dummy name\", :identifier=>1, :address=>{:address=>\"Some dummy address\", :zip=>\"A_zip\", :town=>\"A town\", :region=>\"A region\", :created_at=>2015-07-31 10:41:08 +0200, :updated_at=>2015-07-31 10:41:08 +0200}}\nAgain, many thanks for your help. If it is getting a thing to be discussed outside github issues, please tell me how I can reach you.\n. Thanks a lot both for your help.\nAbout wrap option. Do you think that this should be the behaviour? I understand the logic about removing it from top level and nesting it, but I think it is not a too weird use case willing to have two attributes with the same name in both levels, even if one of them is not actually mapped but generated on-the-fly.\nAbout my problem... I changed my mapper to wrap both address and client in order to have both at top level (by the way, doing so I can have both created_at attributes):\n``` ruby\nclass Client < ROM::Mapper\n  register_as :client\n  relation :origin_clients\nsymbolize_keys\nwrap :client do\n    attribute :name\n    attribute :identifier\n    attribute(:created_at) { Time.now }\n    attribute(:updated_at) { Time.now }\n  end\nwrap :address do\n    attribute :address\n    attribute :zip\n    attribute :town\n    attribute :region\n    attribute(:created_at) { Time.now }\n    attribute(:updated_at) { Time.now }\n  end\nend\n```\nNow, command:\nruby\nrom.command([\n    { address: :destination_addresses }, [:create, [{ client: :destination_clients }, :create]]\n    ])\nsuccessfully creates first address but then it fails with KeyError: key not found: :client.\nDoes that syntax in command mean that client key must be nested within address? I have tried this, but then sql statement fails with underfined column client for addresses table.\nMany thanks.\n. Hey, many, many thanks again :)\nNow, it is working :D\nJust two considerations to let you know:\n- I know that having Model in rom-rails gem is temporary, but, for the sake of information, I have had to also add activemodel in my gemspec file and require it just before rails/model.\n- Finally, I have to use two step in my model (are you still sure that this shouldn't be considered a bug or feature request? :D). Also, I can't get a hash like { address: ... {client: ...} }, because then my mapper should have:\n``` ruby\nstep do\n  wrap(:address) do\n    attribute :address\nwrap(:client) do\n  attribute :address\n  attribute(:created_at) { Time.now }\nend\n\nend\nend\nstep do\n  wrap(:address) do\n    attribute(:created_at) { Time.now }\n  end\nend\n```\nwhich would result in address attribute for address key being nil. So I had to ride off top wrap and add it in my command call:\nruby\ncreate_client_with_address.call(address: data)\nAgain, many thanks. I'm very grateful of \"top names\" like you not being vain and helping less experienced developers. I have been waiting for rom for a long time, I think it is one of the best things that can happen to ruby right now (it needs it, mainly rails).\n. Ok, thanks about the embedded tip, I'll do it. Also I'll check about setting default values in the commands, I have to look closer to the commands API. But it makes all the sense :)\n. > > The test for returning aliased attribute identified by canonincal name has\n\n\nbeen removed, because I think that, being now an option and not part of the\ntype, it makes no sense.\n\nCould you elaborate a bit more here?\n\nWell, I guess this test existed in order to be sure than aliasing an attribute didn't change the name in the meta of the type. But now they are two different concepts. One thing is the type of an attribute and another thing are their options (like alias:). So, I think it makes no sense to test that the change in the type doesn't affect the options... why should it? I think that keeping the test just reflects the development history (the fact that the alias was part of the type before). Furthermore, rename seems very well tested in rename_spec file.\nBut maybe I'm missing something :slightly_smiling_face: . Makes sense. I readded the test, fixed rubocop issues and forced the push rebasing from master.\nThere is still more to review, however. Besides the points I mentioned in the first comment, we should also decide about the #inspect output for Attribute now that it has more options.. I added a commit for each change. We can squash them later if needed.\n\n\nBesides the points I mentioned in the first comment, we should also decide about the #inspect output for Attribute now that it has more options.\n\nWe could do:\nruby\ndef inspect\n  %(#<#{self.class}[#{type.name}] #{meta.merge(options).map { |k, v| \"#{k}=#{v.inspect}\" }.join(' ')}>)\nend\n\nAs with attribute ast, inspect will always include alias: key even when the value is nil. Personally I prefer being explicit in these situations, but, anyway, I guess we must be consistent with the behaviour for meta keys (if there is still any at the end of the work in this PR).. > Please open a PR in rom-sql which changes this, preferably with tests. You could temporary target this branch in the rom-sql's Gemfile, once it's merged we can go back to depending on master.\nBefore I needed to push here the update to the schema DSL. I added some comments to the code to make it clear some intentions.. I'm stuck with the last change needed in order to have the new feature available.\nWe need the following to work:\nruby\nschema(infer: true) do\n  attribute :first_name, alias: :name\nend\nAttribute inferrer checks whether an attribute has been already defined by the user comparing names. However, :name is an option in meta, which is something related with the type, and with this new DSL feature we would be defining the attribute options but not the type. Looks like we should also move :name to be an attribute option?. https://github.com/rom-rb/rom/blob/a9a9f2d1676e2a48a1ec94c8b85e97c9c162793d/core/lib/rom/schema.rb#L140-L148\nDo you think that backward compatibility issues with plugins could arise? Changing :name to be an option would make the attribute information extracted from the DSL to be always a Hash.. > Not sure if I follow, wdym by the attribute information extracted from the DSL?\nI pushed a commit with the changes. I'll try to explain it in a review, alongside other comments.\n\nMy understanding is that first and foremost we're moving attribute-related options to the new options hash, instead of type meta.\n\nSo, do you think we should move everything from meta to options? :primary_key, :source.... The previous commit added the end goal feature of being able to do:\nruby\nschema(infer: true) do\n  attribute :name, alias: :username\nend\nBesides any change required to the API or the implementation, it would just remain to be done moving other meta's to options, if we think it is a good idea.. Ok, I re-adapted rom-sql to work with :name being an (optional) option (pending refactor here about functions being created without a name).\nTell me if you want some other codeclimate offense to be addressed. About the merge_attributes method, I tried to optimize its performance so it is a bit obscure, but I think it pays off. However, one option to simplify it would be moving the type_lookup method as a helper class method in Attribute or Schema.\nAlso in this method and in general for all rom and rom-sql, I think that a very nice refactor would be to create an equivalent method to Attribute#with but working with params (type in this case). A lot of errors re-adapting for the changes aroused from calling #new to Attribute without copying both params and options. Even better, I think that #with and the new method should be created in dry-initializer.\nBesides any other more than welcome code review, I think this PR is ready to go :smile: . I have given it a second thought. Maybe instead of a command plugin, it would make more sense for it to be a relation command overloading insert, update relation methods if they are present in the adapter. I guess that commands are calling them internally, and it seems the actual application/database layer boundary.. If I'm not wrong, if we want to be backward compatible with plugins, I can't just change here to use always a Hash. Instead, I'm allowing the type information to be still just the type itself.. In order to be backward compatible with plugins redefining #build_type, I take an intermediate step here which forwards to #build_type and takes the options.. Sure, much nicer. Done!. I moved all the rom-sql overrides needed for testing to a single file. Once rom-sql has been adapted we just need to delete it and the lines requiring it.. Being an option, #name method is no longer needed.. I think it makes sense to keep giving a special treatment to name in the #inspect option.. I'll try to explain here the issue with backward compatibility. The DSL is calling Schema.define, which in turn is calling Schema.attributes. Before these changes, latter expected the attributes to be an array of types. Now it expects it to be an array of hashes :type/:options. Not sure if it could be an issue with existent schema plugins or something.. Defining this method here, because it seems that the attribute class is decoupled from the attribute representation (Schema.define accepts the attribute class as argument). Otherwise, maybe we could work with Attribute#ast, which would be neater.. There are lots of places in the test suite where define_attribute helper could be used. However, it is not flexible enough to accept some scenarios, like a type with call to .optional, or a type under ROM::Memory namespace. Maybe a nice refactor for consistency would be whether make it more flexible or get rid off it.. To be honest, not sure what is happening here. But seems that name: is not needed at all.. I'm specially interested in this line. I'm trying to adapt rom-sql to the new changes, and I see that attributes without a name are created in a lot of places. So, should we make :name optional?. I see. I guess that in the meantime, before facing that refactor, the only possibility is to have :name as optional in its dry-initializer definition.. Ok, I thought that maybe it was too much for an attribute. But you are right, in fact it makes no difference whether it is an attribute or a method. However, now that I give it a second view, I think the example given is incorrect:\nruby\n    # @example  \n    #   class Tasks < ROM::Relation[:memory]    \n    #     schema do \n    #       attribute :user_id, Types::Integer.meta(alias: :id) \n    #       attribute :name, Types::String  \n    #     end   \n    #   end \n    #   \n    #   Users.schema[:id].name  \n    #   # => :id    \n    #   \n    #   Users.schema[:user_id].name \n    #   # => :user_id\n:id attribute is not defined in the schema, and :user_id name should return :id, isn't it? Maybe  should we just change it to:\nruby\n  # Users.schema[:name].name\n  # # => :name\n  #\n  # Users.schema[:id].name\n  # # => :id\n?. @solnic I was now re-adapting rom-sql to new changes, and I was adding name: :__anonymous everywhere a function is created without name. The problem is that AS \"__anonymous__\" gets added to a lot of resulting SQL queries.\nMaybe we should tackle that refactor first... or just stick with nil names in the meanwhile.. ",
    "angeloashmore": "I used RethinkDB a bit several months back just to try it out. It's a cool and definitely well thought out system. I'm looking at using it for a new project where realtime streams would be beneficial.\nI just converted some of my codebase from rom-sql to rom-rethinkdb (it's amazing how easy it is with ROM) and was met with some limitations in the rom-rethinkdb gem. I forked it so I'll try to add some functionality.\n. ",
    "eduardodeoh": ":+1: \n. ",
    "dcarral": "Way better this way, thanks!\n. Thanks for the feedback Piotr ;)\nFwiw, I had to use 'mappers' instead of 'key' since it was the single option allowed by the Relation model.\n. ",
    "asaaki": ":heart_eyes_cat: \n. ",
    "endash": "Thumbs down on instance_exec. I know this is turning into a hobby horse \ud83d\udc34of mine but using instance_exec/DSL-like method calling really shouldn't be encouraged if an explicit block parameter would suffice. The only appropriate use-case for using a DSL like this IMO is if the DSL operates \"in its own country\", not in regular ruby-land. As in, it should present as its own language and not ersatz-ruby. A decent example is configuring a table schema\u2014not something you necessarily want/need explicit receivers for, but also not something that you'd do inline in your regular app code. I'm generally wary of unnecessary metaprogramming that monkeys with scope and whatnot. Especially as multiple DSLs start to get used side-by-side with different semantics and tons of method calls that don't seem to actually be in scope... it makes my brain hurt. And, importantly, if this syntax is useful as a \"DSL\" it's also useful as a regular API and could just be exposed that way for non-magic-practitioners. (I won't harp on this much more past this ticket but reserve the right to recast DSL syntax into API syntax as I give feedback on other proposals in the future :P)\nMore substantive feedback: I'm not sure if this clears up much confusion or merely swaps some tokens for others. The \"+\" for instance, at first blush I'm not sure what it's supposed to mean semantically in the API or what it translates into behind the scenes. The pipeline operator I know is used elsewhere, but if the point is an easy-to-use-and-read syntax, then semantically named methods might be a better way to go. I'll offer some suggestions on that, once I nail down what these commands are actually doing. (I'm in both a good and bad position to make these judgments because I know enough about command graphs to have a vague idea of what they're supposed to be capable of, but not enough to intuitively read these as a seasoned pro).\nPart of the problem for me is just looking at the current hash-bashed commands and then looking at the samples neither one tells me anything about what they actually do. I'd have to open up the guides and puzzle through them one-by-one to figure that out in either case. @solnic could you add english-language descriptions of the resulting operation to help in that regard?\n. @solnic Well, the hash syntax is as concise as possible. Any sort of friendly API is necessarily going to add bulk, not remove it. The goal then should be clarity, rather than swapping method calls in for nested hashes. That said, we can't just add an explicit receiver to the current syntax designed without one in mind and then call it a day when it doesn't work well.\nMy proposal below structures the commands as a series of nested steps each with an explicit receiver, the result of the parent step. Pipelining is removed in favor of the more semantic block syntax. + is unnecessary, since the dev could just continue to call additional methods on the block param. Use of method_missing allows for natural language method names, and each makes it clear when a step is going to occur multiple times for each item in an array.\n``` ruby\n{ user: { name: \"Jane\"}}\nrom.command do |c|\n  c.create_user\nend\n{ admin: { name: \"Jane\"}}\nrom.command do |c|\n  c.create_user(:admin)\nend\n{ user: { name: \"Jane\", task: { title: \"Task\" }  } }\nrom.command do |c|\n  c.create_user do |user|\n    user.create_task\n  end\nend\n{ user: { name: \"Jane\", tasks: [{ title: \"Task One\" }, { title: \"Task Two\" }] } }\nrom.command do |c|\n  c.create_user do |user|\n    user.create_tasks\n  end\nend\n{\nuser: {\nname: \"Jane\",\ntasks: [\n{ title: \"Task One\", tags: [{ name: \"Red\"}] },\n{ title: \"Task Two\", tags: [{ name: \"Blue\" }] }\n]\n}\n}\nrom.command do |c|\n  c.create_user do |user|\n    user.create_tasks.each do |task|\n      task.create_tags\n    end\n  end\nend\n{\nuser: {\nname: \"Jane\",\ntasks: [\n{ title: \"Task One\", tags: [{ name: \"Red\"}] },\n{ title: \"Task Two\", tags: [{ name: \"Blue\" }] }\n],\nbooks: [\n{ title: \"Foo\", writteb_by: { name: \"Jade\" } },\n{ title: \"Bar\", written_by: { name: \"Joe\" } }\n]\n}\n}\nrom.command do |c|\n  c.create_user do |user|\n    user.create_tasks.each do |task|\n      task.create_tags\n    end\n    user.create_books.each do |book|\n      book.create_author(:written_by)\n    end\n  end\nend\n```\n. @solnic I can write the classes that will take my syntax and turn it into the current hash syntax, which should suffice for a first step.\n. @Solnic Can you verify these reference hashes for the current syntax:\n(In the same order as in my previous comment)\n```\n[{user: :users}]\n[{admin: :users}]\n[{user: :users, [:create, [:tasks, [:create]]]}]\n[{user: :users}, [:create, [:tasks. [:create, [:tags, [:create]]]]]]\n{user: :users}, [:create,[:tasks, [:create, [:tags, [:create]]]], [:books, [:create, [{written_by: :authors}, [:create]]]]]\n``\n. @solnic I would actually go with that, but flip it into.create(:tags). The main reasons for me is that trying to determine the relation (setting aside the command/relation combo) from either a singular or plural form is not trivial, so being explicit about relations is ideal.  If the API is providing a facade over the actual graph, thencreateas a method and the relation as an argument makes perfect sense, thinking in terms of processes rather than syntax trees. Methods are actions. Plus, it reads naturally, and a relation name => hash key mapping pairs well when needed. Argument-before-method is idiosyncratic and brings it back a bit towards just being a thin sugaring of[:tags, [:create]]`, IMO.\nFor comparison, my original suggestion, your suggested change, and my amended suggestion in response:\n```\n@endash original\ncreate_user do |user|\n  user.create_tasks.each do |task|\n    task.create_tags\n  end\n  user.create_books.each do |book|\n    book.create_author(:written_by)\n  end\nend\n@solnic suggestion\nusers(create: :user) do |user|\n  user.tasks(:create).each do |task|\n    task.tags(:create)\n  end\n  user.books(:create).each do |book|\n    book.authors(create: :written_by)\n  end\nend\nupdated @endash\ncreate(users: :user) do |user|\n  user.create(:tasks).each do |task|\n    task.create(:tags)\n  end\n  user.create(:books).each do |book|\n    book.create(authors: :written_by)\n  end\nend\n```\n. @solnic @robinetmiller I'm going to look at that more closely today. I've commented out the one test for procs, and made a note in the commit. To make sure I understand: the procs limit the scope, correct? So that \n{ user: :users },\n      [\n        { update: -> cmd, user { cmd.by_name(user[:name]) } },\nThe update gets applied to that subset of the relation? \n. I was thinking something like...\nrom.command.update(:users) do |user|\n    user.update(:tasks).match_records { |relation, user, task| relation.by_user(user).by_id(task[:id]) }.each do |task|\n        task.update(:tags).match_records { |relation, task, tag| relation.by_pk(task[:id], tag[:name] }\n    end\nend\n. If we generalize the Node a bit more, we can use context to allow for something even more expressive:\nrom.command.update(:users) do |user|\n  tasks = user.restrict(:tasks) { |tasks, user, task| tasks.by_user(user).by_id(task[:id]) }\n  user.update(tasks).each do |task|\n    tags = task.restrict(:tags) { |tags, task, tag| tags.by_pk(task[:id], tag[:name]) }\n    task.update(tags)\n  end\nend\nThe relation comes through from the restrict call, and we can still map keys to relations/restricted relations. It might make sense to swap the key/relation order for when the user specifies both. Instead of:\nuser.update(tasks: :jobs_is_a_key)\nIt would be:\nuser.update(jobs_is_a_key: :tasks)\nThen we can do\ntags = task.restrict(:tags) { |tags, task, tag| tags.by_pk(task[:id], tag[:name]) }\n  task.update(tags_key: tags)\nfor a restriction, or just\ntask.update(tags_key: :tags)\n. One drawback of the new proc syntax is performing a restriction at the root level:\nusers = rom.command.restrict(:users, &users_proc)\n    command = rom.command.update(user: users) do |user|\n      tasks = user.restrict(:tasks, &tasks_proc)\n      user.update(tasks)\n    end\nA possible refinement might allow something more like\ncommand = rom.command.restrict(:users, &users_proc).update do |user|\n      tasks = user.restrict(:tasks, &tasks_proc)\n      user.update(tasks)\n    end\nThat would also work as a nested restriction\ncommand = rom.command.restrict(:users, &users_proc).update do |user|\n      user.restrict(:tasks, &tasks_proc).update(from: :users_tasks)\n    end\nWhich could be expanded with the inline block, although it gets a bit dense:\ncommand = rom.command.restrict(:users, &users_proc).update do |user|\n      user.restrict(:tasks) { |tasks, user, task| tasks.by_user_and_title(user[:name], task[:title]) }.update(from: :users_tasks)\n    end\nNote the explicit from: to avoid overloading the meaning of a standalone symbol being passed to update. If from is the key then the user would have to use {from: :from, relation: :contact} to disambiguate.\n. I've made those changes so that\ncommand = rom.command.restrict(:users, &users_proc).update do |user|\n      user.restrict(:tasks) { |tasks, user, task| tasks.by_user_and_title(user[:name], task[:title]) }.update(from: :users_tasks)\n    end\nis now valid syntax.\n. PR broken out into 4 commits which can be applied in sequence with passing tests each time:\n1.  basic refactor, minimal renaming/changes only as necessary outside of the core classes being touched\n2.  refactor SetupDSL to clean that up\n3.  add the global shim/loader\n4.  the least essential change, making auto_registration retroactive now that use(:auto_registration) can't be called at require-time.\n. Hopefully we'll just remove most of it entirely, since it supports the legacy global stuff. I'm not sure if we have a final decision on that yet. /cc @solnic \nThe auto_registration plugin uses Wisper.subscribe (entirely in theory) to allow for disposal of subscribers. In practice, that'd only be useful in tests, to clean up that unfortunate bit of global state. In reality, the current release version of Wisper doesn't even support that yet so... yeah it could be removed (replaced by klass.on), especially if the globals stuff is cut out as well.\n. For now I've just removed the optional global support. Rom-sql will need another way to find a gateway to use for migrations, but that should be simple enough to do in its own gateway class. Rom-rails should be ok.\n. It seems odd to have a separate gem for migrations but then to still have code in core that is specific to migrations support.\nOne alternative is an idea I was briefly kicking around this past weekend, which is to have a system-level plugin type. Then, Gateway inherited could be trapped just like Relation, et all, and have a module injected by the migrations plugin.\n. This was originally a convenience for internal/spec use... but clearly has broader applicability. I'm divided on a rename since register_relations might (1) encourage mistaken use of an array rather than argument list (2) on the flip side, looks weird with just one argument. \n. Travis is erroring because of gem trubs. I just commented out the mutant stuff locally to get the specs to run. Not sure what to do as a universal solution.\n. ",
    "robinetmiller": "Late to the party, but FWIW, I completely agree with the last iteration there.  Speaking as a very inexperienced ROMmer, it's far easier for me to read and interpret. I think it's mostly due to being more ruby-ish and leveraging blocks for their strength - injecting logic to be run as part of the receiver. Having additional logic to run after is a perfect fit for that mechanism.  \nI don't know what I'm adding here beyond reassurance that this is the best choice, so I'll stop here. \n. Why not accept an array as well and convert it? Both make sense to pass in. \n. ",
    "kelvinst": ":+1:\n. ",
    "sagmor": "I'm liking the simplicity of this approach.\nRight now I'm testing something like:\n``` ruby\nclass Tenant\n  attr_reader :rom, :gateway\ndef repository(name)\n    rom.repository(name).from(gateway)\n  end\nend\ntenant = Tenant.new(rom, gateway)\npost_repo = PostRepository.new(tenant)\nAnd now every post is fetched from the defined gateway\n```\nMaybe just a ROM::Container proxy could do all the trick and leave everything else untouched.\nFor a slave configuration you could have something like:\n``` ruby\n...\nmaster = ROM.finalize.env\nslave = Slave.new(master, options)\nNow, from the app's perspective they are interchangeable\nFetch from slave\nPostRepository.new(slave)\nOr fetch from master\nPostRepository.new(master)\n```\n. Definitely acceptable :+1:\nWhat is better? I add this on another gem? since it's kinda specific :smile: \nName idea?\n. Ok, will play around with the idea on sagmor/rom-sharding and circle back if I get something :wink: \n. ",
    "zekefast": "@solnic by analogy with #one and #one! it should be alias for #to_a, because first two force lazy relations to be resolved, so #many should also. IMO\n. ",
    "rpelyush": "Seems like this commit has broken AutoRegistration#initialize. Now this line directory.join(\"#{name}/**/*.rb\") produces the following error: NoMethodError: undefined methodjoin' for \"\":String. I suppose@directoryshould be used in scope of #initialize not adirectory` argument.\nruby\ndef initialize(directory, options = EMPTY_HASH)\n      super\n      @directory = Pathname(directory)\n      @globs = Hash[[:relations, :commands, :mappers].map { |name|\n        [name, @directory.join(\"#{name}/**/*.rb\")]\n      }]\n    end\n. ",
    "jonahx": "Thanks for the reply.  It sounds like I could use it, and I'm willing to get involved and \"ready for the mainstream\" isn't a hard requirement.  I'll be using postgres, and my application needs are pretty standard.  My primary reason for using rom would be for a clean separation between my domain models and my persistence layer.\nThe main thing I'm struggling with is simply finding full worked examples within the context of a simple application (the kind of thing that will probably be in your upcoming book).  But really, I can probably get most of what I need from just a few examples (including saving a model to persistence) -- can you point me to any?  Btw, I emailed you on your website re: consulting, as I'm happy to pay for your time getting answers to some of these questions -- I know you're busy.\n. ",
    "blelump": "Hi @solnic ! \nI am in the similar situation I'd say. I mean I really believe in the whole ROM concept, but on the other hand, there're doubts. I mean, the delivery time is coming quickly, whereas I am still explorling possible edge cases and I'm sure the unforeseens are still ahead of me, e.g. right now I'm looking for possible authentication and authorization mechanisms under the ROM control (no success yet). \nThe deal is whether to stay with warm and sweet Rails ecosystem or abandon it and start exploring, with the possibility that the delivery time would be exceeded. What would you say from your perspective?\n. ",
    "tristil": "Actually, I see that this is just reverting a previous intentional change. I still think that the implementation that the doc example describes makes more sense. I have a project lib/minder/database/{relations,commands,mappers} where the top-level namespace is Minder and there is a Minder::Database namespace under that. With the current implementation if I point the path to lib/minder/database then it will look for Database::Relations::Periods, which fails.\n. ",
    "edwardlftam": "Thanks!\n. Thanks for your reply. Loading from plain Sequel seems to work.\nI don't load so many rows normally, but there is a edge use case that I need to do so. I need to compare the data in my database with the data pulled from a third party API to figure out if anything was deleted remotely, and this only gets run once a day handled in the background.\n. apples.where(conditions).to_a causes the SystemStackError exception as well\n. apples.relation.where(conditions).to_a seemed to work \n. When I byebug into it, seems to me that the exception is raised from here:\n[15, 24] in /Users/adknowledge/.rbenv/versions/2.1.5/lib/ruby/gems/2.1.0/gems/rom-1.0.0/lib/rom/relation/materializable.rb\n   15:       #\n   16:       # @return [Array]\n   17:       #\n   18:       # @api public\n   19:       def to_a\n=> 20:         call.to_a\n   21:       end\n   22:       alias_method :to_ary, :to_a\n   23:\n   24:       # Yield relation tuples\n. Thanks. I think the one step before might be helpful too:\n[43, 52] in /Users/adknowledge/.rbenv/versions/2.1.5/lib/ruby/gems/2.1.0/gems/rom-repository-0.2.0/lib/rom/repository/loading_proxy.rb\n   43:       # Map this relation with other mappers too\n   44:       #\n   45:       # @api public\n   46:       def map_with(*names)\n   47:         if names.size == 1 && names[0].is_a?(Class)\n=> 48:           with(meta: meta.merge(model: names[0]))\n   49:         else\n   50:           mappers = [mapper]+names.map { |name| relation.mappers[name] }\n   51:           mappers.reduce(self) { |a, e| a >> e }\n   52:         end\n. I used dry-data 0.5.1, if you are referring to the mappers. \nUpdate: to be exact, inherited from Dry::Data::Value\n. Sure I can try that\n. I tried try-types and still ran into the same issue. Great to hear 2.0 is coming up soon, I will try again after upgrading\n. ",
    "thiagoa": "@solnic Thanks. I've just updated this pull request with the removal of the registry spec file, and the rom-support pull request was updated with the same spec file which was moved over from here.\n. @solnic All done\n. ",
    "denysmedynskyi": "Thank you for doing this @AMHOL! I really appreciate it.\n. ",
    "janjiss": "@solnic Wondering about the api for custom dir/constant resolver. Do you think we should add another parameter or change existing one :namespace to allow custom resolver? If we use the same parameter name, can we have some kind of type that has to inherit from base strategy?\n. @solnic Updated according to comments \n. @solnic It seems not to work that way. \nROM::Options::InvalidOptionValueError:\n        :namespace:true has incorrect value.\n      # ./lib/rom/setup/auto_registration.rb:23:in `initialize'\n      # ./lib/rom/setup.rb:49:in `new'\n      # ./lib/rom/setup.rb:49:in `auto_registration'\n      # ./spec/unit/rom/auto_registration_spec.rb:60:in `block (4 levels) in <top (required)>'\n      # ./spec/support/constant_leak_finder.rb:6:in `find'\n      # ./spec/spec_helper.rb:49:in `block (2 levels) in <top (required)>'\n. ",
    "wmaciejak": "Hi @solnic !\nI wrote some months ago about my case on gitter. I don't like classic separation components by type (f.e. directories app/relations/users.rb, analogical mappers and commands) because IMO better, more efficient way is separation by business feature(f.e. app/contexts/user/relation.rb, app/contexts/post/relation.rb). I created one, quite big project with that approach and it saved my life(and common sense :D ). I used ROM v1, and created a custom registration of components cause that kind of directories configuration was unsupported.\nI wonder if there is a way to smart auto-register components in that configuration or maybe it's so significant difference between approaches?. ",
    "alderion": "sorry, github ate the \\ escape char in my second example: pass\\:word\n. ",
    "Reinkaos": "Oh na I didn't see that you could do that :). I will give that a go, thanks!\n. ",
    "alexandru-calinoiu": "I still can't get it working, maybe I don't understand the role of relations. I've pushed the project I am working on here https://github.com/alexandru-calinoiu/rom-test\nI am basically trying to get https://github.com/alexandru-calinoiu/rom-test/blob/master/spec/rom/test/repositories/posts_repo_spec.rb this spec to pass or at least run.\n. I guess what I am trying to achive is this part of the relations docs:\nYou can put them in separate files, namespace them or not, and configure them when it's needed\n. Found config.auto_registration in ROM::Configuration and tried to use that now the error is ROM::Registry::ElementNotFoundError: :posts doesn't exist in ROM::RelationRegistry registry it still seems that he relation does not get picked up :(\n. Later ...\nI finally figured this out, turns out the auto_registration has some dirs that it searches for relations in.\nOpened a pr to sequel in the mean time also https://github.com/jeremyevans/sequel/pull/1250 :)\nIt still does not feel right improvements are welcomed.\n. Thanks, I believe that a slight improvement on this part of the docs will help a lot.\n. Looking forward to the release for this one.. ",
    "mihairadulescu": "i had a similar issue like you @alexandru-calinoiu  and i added in my repository \nrelations :pots. ",
    "Kukunin": "Thanks a lot!\n. oh. it affected me as well. Currently I don't have a better solution than put Vo namespace for you, \nbut in case you want to spend more time with this issue, you can take a look into implementation.\nhttps://github.com/rom-rb/rom/blob/master/lib/rom/setup/auto_registration.rb#L50\nMain problem that it's looking for all files via glob, and tries to guess their namespace, which is inaccurate. ",
    "Fire-Dragon-DoL": "No problem, sorry for not submitting a PR @solnic , I was really in hurry\n. Damn I solved this, kept trying. Looks like there were two problems:\n1) If you use do/end syntax, ruby thinks the block is for attribute, not constructor\n2) You must manually call Sequel.pg_array to make sure the object is converted to the correct format\nEnded up with something like\nruby\n      attribute :tags,               pgtypes::Array.constructor(\n        ->(input) { Sequel.pg_array(input.map(&:to_s), :text) }\n      )\n. ",
    "myabc": "@julienXX the namespace: option should be passed a String and not a class. e.g.\nruby\nconfiguration.auto_registration(File.join(__dir__, 'library_api_client'), namespace: 'LibraryApiClient')\n(fwiw this results in the same error on CRuby and JRuby). @julienXX btw I had to make various other fixes (missing requires, removal of Relations, Mappers) to the example project you posted. See here:\nhttps://github.com/myabc/jruby_rom_repro/commit/18998eaa53bd0fdfc3ffde0cabea7ca017830c43. ",
    "julienXX": "Thanks a lot @myabc & @solnic :). ",
    "georgemillo": "Over on gitter @solnic has informed me that there's a much simpler way to rename columns like this:\n```ruby\nrequire 'rom'\nrequire 'rom-repository'\nrequire 'rom-sql'\nrom = ROM.container(:sql, 'sqlite::memory') do |conf|\n  conf.default.create_table(:people) do\n    primary_key :id\n    column :email, String, null: false\n  end\nconf.relation(:people) do\n    schema(infer: true)\n  end\nend\nclass PersonRepo < ROM::Repository[:people]\n  commands :create\ndef renamed_keys\n    # note the triple underscore, which is basically an SQL AS:\n    people.select(:email___primary_email).first\n  end\nend\nrepo = PersonRepo.new(rom)\nrepo.create(email: \"hello@example.com\")\nputs repo.renamed_keys.primary_email\n=> \"hello@example.com\"\nyay!\n```\nBut my question about whether it's correct for map_with to return a hash still stands ;). Ohhhhh I didn't realise that as and map_with are the same thing. I'm not sure what you mean by auto-mapping though? Not sure what you mean by \"setting model\" either (in the rom-repo issue you linked to), I had a quick skim through the guides and couldn't see anything about a method with that name.\nIf you decide not to add the above as a new feature, can we modify the behaviour so 'invalid' code like my original example fails noisily? Would reduce confusion.. Got it, thanks \ud83d\udc4d . (My original questions are resolved so this issue can probably be closed since there's already an issue about the same-ish problem). ",
    "timriley": "As @flash-gordon summed up:\n\nactually not, ~> 0.8 is compatible with 0.9.X. ~> 0.8 is the same as >= 0.8, < 1.0. It's really easy to get confused because ~> 0.8.0 means the very different thing: >= 0.8.0, < 0.9\n\n\ud83d\ude2c . From your description, this sounds really good. Having to override execute is user-unfriendly and inflexible. I like the ability to extend a command with hooks at runtime too. \n\nOn 5 Jan 2017, at 10:57 pm, Piotr Solnica notifications@github.com wrote:\n@timriley @flash-gordon any thoughts on this one?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Pinging @flash-gordon on this one, on @solnic's suggestion ). @solnic reckon this is worth getting done before 4.0.0?. @nepalez is there any way you could eg. change your rubygems.org password, from your phone, then privately share it with one of us so that we could log in, grant access to the gem to the rest of the core team, and then we can coordinate the gem yanking/republishing from there?\n\nI imagine this could be done without your laptop?. @nepalez Great, thank you! I just followed you on key base. tbh I'm not 100% sure how it's meant to work but I am ready to receive your login details.. @nepalez Mind checking key base again and letting me into the chat? I had problems with my account and had to reset things \ud83d\ude44. @nepalez I'm sorry mate, I seriously can't seem to get keybase to work. Your earlier messages show errors for me and new chat lines I initiate all fail. Can you send me the password in some other way? (at worst, you can use the email listed on my GitHub profile). Or maybe you could try the standard keybase plain message encryption: https://keybase.io/encrypt. @nepalez You may need to \"refresh\" my profile on keybase since I set it up with a new key/proof earlier.. @nepalez I have to go to sleep now. Can you please coordinate the password exchange with @solnic or @flash-gordon? It'd be good to get this resolved properly today.. I've yanked dry-initializer 2.6.0 and have updated its CHANGELOG accordingly.\nI'll open another issue on dry-initializer to start discussion around the best way to release the breaking change.. I'm not sure what our policy with codeclimate issues is here, but I'd be happy to shorten those yardoc lines \ud83e\udd37\u200d\u2642\ufe0f . This looks good to me, thanks @v-kolesnikov. I'll let @solnic or @flash-gordon have final say before merging in this case, though.\nIf I could offer any suggestion here, it's that I'd want to put a description for the empty it example inside the \"with nested nodes\" spec example, just for consistency :). ",
    "backus": "I was running mutest on my Repository and noticed saw that it let me drop the argument. Didn't intend to actually use it this way. ",
    "zavan": "@solnic Sibbel and other services read it from GitHub's release notes. \nIt's basically step 6 of this guide: https://help.github.com/articles/creating-releases/\n\nSince you already keep a CHANGELOG, you can simply copy the entry from the CHANGELOG to the GitHub release when creating the release tag (although it may not be so simple if your release process is automated).\n. ",
    "GustavoCaso": "@Kukunin I'm trying to reproduce the unwanted behavior and it looks like from the code that it can not happen.\nhttps://github.com/rom-rb/rom/blob/master/core/lib/rom/setup/finalize/finalize_mappers.rb#L13-L16\nAs you can see when registering the mappers, there is a uniq and the last line each_with_object({}) { |n, h| h[n] = {} } even if we remove the uniq it can not happen since hashes can only have on identical key, it will not be possible for registering twice the same mapper.\nIf that's ok with you @Kukunin and @solnic we can close this ticket, or if we really want to raise and exception letting it know to the user. I can modify the code so it will alert the user\n. After talking with @solnic we decided that the best opinion is to raise an exception to alert the user. I will update the code accordingly . Can we close this one? @solnic . I can help with this one . @solnic maybe we can discuss this one when you have some time.. @solnic after adding the specs I realize something, correct if I'm wrong, what happens if a user instead of registering a mapper with the mapper DSL instead he creates a custom Mapper class and forget to add the register_as since we no control that registration process we maybe need to raise an error indicating to the user that they are missing the register_as. What do you think?. @solnic I'm happy to help with this one . I would like to help with this one . @solnic sorry for the delay. Hope this is better now \ud83d\ude04 . This is the different configurations I used to reproduce the error\n```ruby\nconfig = ROM::Configuration.new(:sql, \"postgresql://localhost/whitespace\")\nclass Bugs < ROM::Relation[:sql]\n  schema(infer: true)\nend\nclass BugsRepository < ROM::Repository[:bugs]\nend\nconfig.register_relation Bugs\ncontainer = ROM.container(config)\nconnection = container.gateways[:default].connection\nconnection.execute \"DELETE FROM bugs\"\nconnection.execute \"INSERT INTO bugs VALUES (1, 'WTF')\"\nrepo = BugsRepository.new(container)\nputs repo.bugs.to_a\n```\n```ruby\ncontainer = ROM.container(:sql, \"postgresql://localhost/whitespace\") do |config|\n  config.relation(:bugs)\nend\nclass BugsRepository < ROM::Repository[:bugs]\nend\ncontainer.relations[:bugs].delete\ncontainer.relations[:bugs].insert(\"id\" => 1, \"white space\" => \"WTF\")\nBugsRepository.new(container).bugs.to_a\n```. You are right, after getting my hand in the finalize process and got to the same conclusion.\nI will update the code.\nThanks for the hint.. @solnic after checking the code and making the test pass. I'm thinking maybe we could move the check to Inferrer#call https://github.com/rom-rb/rom/blob/master/core/lib/rom/schema/inferrer.rb#L48 so we remove the if from the code, also since rom-sql also use this method https://github.com/rom-rb/rom-sql/blob/master/lib/rom/sql/schema/inferrer.rb#L33 it will still work. . @solnic do you like this approach better?\n. @solnic the work that is missing is related to users using alias?. @solnic should we continue working on this one? If you point me to the work that is missing I would love to finish with it.. @solnic I would love to help with this one . Totally right \ud83d\ude04 \n. After some investigation and trial error, relaying in the arity is not going to be that simple.\nTrying to access the arity value from method(view_name).arity since view is AutoCurry the arity is always -1 .\nPlaying a little bit more I found a way to access the arity through out Rom::Relation::Curried\nHow I get the Curried Relation by executing this line:\nroot.command(type, **opts).public_send(view_name)\nI get a Curried Relation, which happens to have an arity public API.\nBut I notice a strange behavior if the custom method from the relation have default values like this:\nruby\ndef expired(expiration_time=Time.now)\n  where{ created_at < expiration_time }\nend\nInstead of returning a  Rom::Relation::Curried I get a ROM::Commands::Composite which do not have a public api for arity\n@solnic is there something I'm missing?\nAlso just for fun I played a bit with arity from ruby\n```ruby\nclass C\n def one;    end\n def two(a); end\n def three(a=1); end\n def four(a);  end\n def five(a, b); end\n def six(a, b, c);    end\n def seven(a, b, *c, &d); end\nend\nc = C.new\nc.method(:one).arity\n=> 0\nc.method(:two).arity\n=> 1\nc.method(:three).arity\n=> -1\nc.method(:four).arity\n=> -1\nc.method(:five).arity\n=> 2\nc.method(:six).arity\n=> -3\nc.method(:seven).arity\n=> -3\n``\n. Thanks @solnic I'm intrigued actually . @solnic looks like afterschema.with(relations: registry)the schema it returns have not initializedprimary_keys_names` and we were getting some errors in different parts of the specs, maybe the problem does not lie in the schema initialize method but in another part of the code.\nruby\nROM::SQL::MissingPrimaryKeyError:\n        Missing primary key for :users\nOnce I added that line the build looks like its working, but maybe there is something else that I'm missing. I happy will keep looking for other solution.. ",
    "Krule": "The modification in specs was adding new use cases, leaving old ones unchanged (other than putting them in context). So, old behaviour should remain unchanged provided constant exists.\nLooking at code now, I realise I have not provided anything happening if fragments are exhausted without actually finding the constant (when it's something else). I think the current implementation would throw NameErorr. This I would like to replace with a more descriptive error.\nI will make some more modifications soon and then ask for review \ud83d\ude04 . Updated the code, limiting the search to directory and providing more helpful error message.. Ah yes, to clarify. This is should not be a breaking change.. Also, if there is something wrong with the approach I have used, pointers would be appreciated. \ud83d\ude04 . @flash-gordon So, maybe a different PR for 4.0 and getting this one into 3.X?. Here it is: https://github.com/rom-rb/rom/pull/446. @solnic It is actually JSON in code if this is what you have meant. Although, PR description stated otherwise. Or is this comment targeted at: HashJson and JsonHash?. ",
    "maximderbin": "\u2764\ufe0f . ",
    "kwngo": "Hey! New to contributing to rom but I've been using gem for a while. Would love to help with this, and sounds like a good first PR?. Awesome! I'll take a look at the structure of the other directories and get started... @solnic Good catch, I think I fixed them.. ",
    "mrship": "Thanks for the detailed review. In line with your suggestion, we are OK with using hashes, we've changed the serialisation to use: \nruby\nOj.load(Oj.dump(employee, mode: :compat)) \nwhich gets us the raw attributes back out. We do then consume these in custom entity classes (based on Dry::Struct) so that works as a deserialisation approach.. Yes, we can close this. Thanks again for the time and effort in reviewing.. ",
    "opan": "@solnic Ah okay, thank you and sorry for this.. ",
    "dikond": "I've updated my Gemfile as you showed, but now I am getting\n\nLoadError: cannot load such file -- rom/attribute\n\nOn the line when I'm trying to require it\nApp::Container.finalize(:rom) do |container|\n  require 'rom'\nAny hints?). Awesome, thank you!. ",
    "simonc": "@solnic Ok I see, I've been looking for this indication but sadly I skipped the explicit setup part thinking the info wouldn't appear in the \"setup\" part.\nI think the Relations doc should include this line in at least one example. As of today it assumes that all the previous pages have been read and it rarely is the case. Devs have a tendency to muddle through things in my XP so it would make sense to hint here and there about registration, even if it means repeating the info. (DRY does not apply to docs \ud83d\ude42)\nMaybe you already addressed this issue in the 4.0.0. Otherwise I'm willing to open a PR in this direction.\nCheers \u2764\ufe0f. @solnic awesome \ud83d\ude0a. ",
    "AlexanderMint": "Same problem\nruby 2.4.2p198 (2017-09-14 revision 59899) [x86_64-darwin16]. ",
    "graywolf": "                                                                                  Will do later today.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        From: Nikita ShilnikovSent: Tuesday, October 17, 2017 10:32To: rom-rb/romReply To: rom-rb/romCc: W.; AuthorSubject: Re: [rom-rb/rom] Warnings during startup (#457)Fixing this requires applying cb838f4 to the release-3.0 branch, can't do it right now. If anyone wants to help with this it would be great\n\n\u2014You are receiving this because you authored the thread.Reply to this email directly, view it on GitHub, or mute the thread.\n{\"api_version\":\"1.0\",\"publisher\":{\"api_key\":\"05dde50f1d1a384dd78767c55493e4bb\",\"name\":\"GitHub\"},\"entity\":{\"external_key\":\"github/rom-rb/rom\",\"title\":\"rom-rb/rom\",\"subtitle\":\"GitHub repository\",\"main_image_url\":\"https://cloud.githubusercontent.com/assets/143418/17495839/a5054eac-5d88-11e6-95fc-7290892c7bb5.png\",\"avatar_image_url\":\"https://cloud.githubusercontent.com/assets/143418/15842166/7c72db34-2c0b-11e6-9aed-b52498112777.png\",\"action\":{\"name\":\"Open in GitHub\",\"url\":\"https://github.com/rom-rb/rom\"}},\"updates\":{\"snippets\":[{\"icon\":\"PERSON\",\"message\":\"@flash-gordon in #457: Fixing this requires applying https://github.com/rom-rb/rom/commit/cb838f49d5d045e2e8ab0bbab48ef80c3b4b1108 to the release-3.0 branch, can't do it right now. If anyone wants to help with this it would be great\"}],\"action\":{\"name\":\"View Issue\",\"url\":\"https://github.com/rom-rb/rom/issues/457#issuecomment-337158227\"}}}. @flash-gordon thank you for the quick release :) Can confirm the warnings are not printed anymore.. ",
    "reedlaw": "Thanks, this clears things up a lot!. ",
    "v-kolesnikov": "I can assume that it happened here: https://github.com/rom-rb/rom/commit/c7518fc28#diff-3ac454f9c196d0f7c33922c20f51583cL117\nattr_class must be passed to schema constructor, otherwise schema will be initialized with ROM::Attribute which has not indexed? method.\n@flash-gordon What do you think?. @solnic OK. Thank you for your answer! I actually have resolved my problem with a couple of workarounds. I will look more at ROM::Transformer as well.. @timriley Thank you for the review!. > @v-kolesnikov thanks, could you also add a deprecation warning that this method goes away to release-4.2 branch?\n\ud83d\udc4c. Yes, it was ported from repository/spec/integration/repository/aggregate_spec.rb https://github.com/rom-rb/rom/pull/510/files#diff-c2d607da524fcf9a023a690743348d4cL52\nIs something wrong with it?. ",
    "artps": "Great to know, looking good. Thanks @flash-gordon ! Looking forward to get rid of dirty hacks we do in our system.. ",
    "abrthel": "A bit late but thank you. This solved a really weird bug I was having in a side project.. If I remember right, Command#with_input_tuples is a private method defined inside the create & update commands in rom-sql.. \ud83d\udc4d plus it has the added benefit of removing the duplication between the rom-sql create and update commands.. ",
    "amarshall": "This was released in rom v4.1.0 and rom-sql 2.3.0 on 2017-11-17, however, it is broken as rom-repository did not receive a new release with its changes from this patch, resulting in plugins_options not being passed through when using the released versions.\nIt seems rom-repository release on that date was missed\u2014would it be possible to get a release of rom-repository with these changes?. ",
    "alsemyonov": "@solnic, please check the spec. Is it good enough?. Cool! Thank you.. ",
    "cutalion": "I'm not sure it would make sense for other gateways/adapters (how do call all rom-whatever gems?)\nWhat if we qualify schema right before calling it. In the ROM::SQL::Schema#call method?. ",
    "ianks": "We ran into this issue as well. Kind of a bummer and now we are just going to move the yaml relation to sql. @solnic Can you further specify the interface you would like to see for this? I'm happy to help but want to make sure I'm clear as to exactly what you want.. ",
    "joelvh": "Sorry I missed that guideline. Posted here: https://discourse.rom-rb.org/t/mapping-nested-entities/223. Posted to Discourse: https://discourse.rom-rb.org/t/instantiating-a-custom-struct-instance/224/1. Posted to Discourse: https://discourse.rom-rb.org/t/changeset-create-command-with-aliased-pk-doesnt-seem-to-map-back-to-database-column/225/1. ",
    "radar": "@solnic Am I on the right track to solving this problem here? I just ran into it again today.. ",
    "david-pm": "Was seeing errors:\n[9] pry(main)> project.persisted?\nROM::Struct::MissingAttribute: undefined method `persisted?' for #<Projects::Project id=1 name=\"test project\"> (attribute not loaded?)\nfrom /.rvm/gems/ruby-2.5.1/gems/rom-mapper-1.2.1/lib/rom/struct.rb:112:in `rescue in method_missing'\nAdding this branch to my Gemfile fixed the issue but seems like it will not be the longterm solution \ud83d\ude22 \ngem 'rom-mapper', github: 'radar/rom', branch: 'build-once'. ",
    "bigforcegun": "Read https://github.com/rom-rb/rom/issues/494\nCool.\nPlease close.\nI'l see dry-rb respects semver.. ",
    "DamirSvrtan": "Thank you for keeping nice Changelogs on both dry-rb and rom-rb repos!\nDowngrading dry-validation did the fix, however as much as I understand, upgrading rom gems to the new dry-types API (Integer vs Int) is an ongoing effort. \nThank you for your work!. ",
    "gogovan-victorlam": "Any plan to make a new release?\nI am using dry-system and dry-validation and got the same issue\nAnd I found that master branch already revised to depends on dry-types (~> 0.13.0)\nI would like to wait for the new release so that I don't have to downgrade both gems\nThanks!. ",
    "Cervajz": "Same over here :/. ",
    "deepj": "@solnic yes, it does make sense. In fact, I would like to see dry-rb/rom to be supported by TruffleRuby very soon. There are many interesting things in this area. Unfortunately, there are some issues with current TruffleRuby and dry-rb stuff (https://github.com/oracle/truffleruby/issues/1462 or https://github.com/oracle/truffleruby/issues/1469)\nIf I can help, I'm glad to do it.. Thx, I'll make it tonight.. @solnic Hm, there is one thing if you would interest in to help. It's also one of dependencies of ROM. dry-initializer causes problems such as\n```\nFailure/Error: option :bar, proc(&:to_s),    optional: true\nArgumentError:\n  wrong number of arguments (given 1, expected 0)\n./spec/several_assignments_spec.rb:6:in `to_s'\n./spec/several_assignments_spec.rb:6:in `to_s'\n(eval):6:in `call'\n(eval):6:in `dry_initializer_initialize'\n./lib/dry/initializer/mixin/root.rb:7:in `initialize'\n./spec/several_assignments_spec.rb:22:in `new'\n./spec/several_assignments_spec.rb:22:in `subject'\n./spec/several_assignments_spec.rb:25:in `block (3 levels) in '\n./spec/spec_helper.rb:16:in `block (2 levels) in '\n```\nThe problem lies in Dry::Initializer::Mixin. Unfortunately, I don't fully understand the construct and a purpose behind of it. If there was a change to isolate a root problem, it could help to TruffleRuby's developer to fix it quickly.\nSee https://github.com/oracle/truffleruby/issues/1462. ",
    "artofhuman": "typo private. ",
    "daniels": "What is the API for calling the command if the view has arity > 1? (There aren't any specs for such calls as far as I can see.)\nShould the view args be wrapped in an array like so?:\nruby\nrepo.update_by_arity2_restriction([view_arg1, view_arg2], input)\n(If it's not wrapped, I guess it would be splatted into input rather than the view_arg at the beginning of the defined command method?)\nIf it should be wrapped, could you maybe just wrap any non-array object in an array before splatting? Checking either by #is_a?(Array) or #responds_to?(:to_ary):\nruby\nview_args = [view_args] unless view_args.responds_to?(:to_ary)\nroot.command(type, **opts).public_send(view_name, *view_args).call(*input)\nOr even just by doing a splat reassignment:\nruby\n*view_args = view_args\nroot.command(type, **opts).public_send(view_name, *view_args).call(*input)\n(Splat assignment only tries implicit conversion (#to_ary) and doesn't call #to_a, in contrast to the splatting of the argument on the next line which calls #to_a on view_args if #to_ary is not defined. But maybe this is too obscure to make the reason behind the code above clear.)\n. To avoid the reassignment you could even do the splatting in the original assignment like so:\nruby\ndefine_method(meth_name) do |(*view_args), *input|\n  # ...\nend\n(Edit: Moved the assignment of view_args and input to the block parameters, which at least made it a bit clearer to me. With this \"block signature\" there is some indication on what this method will expect as parameters.). "
}