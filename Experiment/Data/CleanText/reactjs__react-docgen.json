{
    "fkling": "Thanks! Released as v1.0.2. I also added test cases for the CLI in 68526e8e938b1fab77fa832109809acd4bc0e32d and found another issue through that.\n. :( it worked fine for me when I ran the tests... will look into it. Thanks!\n. I ran the tests again and I don't get the errors you mentioned, even on a fresh checkout. Which node version are you running this on?\n. Ah, I didn't even try to run it with Node 0.12 because of the known issues with jest.\n. OK. I'm not saying it's a jest issue (because the error is actually in the test itself), but jest still has issues with v0.12: facebook/jest#262\n. Actually my statement was not correct. Jest seems to be able to work with Node v0.12, but its own tests cannot be run in v0.12.\nFixing the issue you mentioned is easy, I should just pass an empty array to spawn, not null.\nTo clarify again: This is only an issue with the test setup, not with the functionality of the tool.\n. Merged with 17f7376b445da77cc1b919e1de69a94ad4100e84.\n. I'm not sure what exactly you are asking for. If I misunderstood anything, please let me know.\nreact-docgen doesn't have any opinions about doclets. It will return any prop type or component docblock as is. I.e. if you your component is \njs\n/**\n * Some description\n * @example Foo.js\n */\nvar Component  = React.createClass(...);\nyou get something like \njs\n{\n  \"description\": \"Some description\\n@example Foo.js\",\n  \"props\": {}\n}\nand you can post-process description to extract any information you want. In fact, react-docgen provides a helper method to extract tags, but you can use any other library of course:\njs\nvar docgen = require('react-docgen');\nvar docs = docgen.parse(source);\ndocs.example = docgen.utils.docblock.getDoclets(docs.description).example;\n. I really appreciate all the feedback and ideas! \n\n\nSo we can use it is like this\n\nYou could, but there isn't really a reason to use a custom handler here, since you are not accessing the AST. Post-processing the JS object would be easier.\n\n_.forIn(doc['$Documentation_props'], ...)\n\nWhile that may work, it assumes specific internal structure of the documentation object. We could add an API that allows to traverse all found props in the documentation object, but I still think that this is better done in a post processing step.\nI'm started working on a proposal to make post processing via the CLI easier (that's really WIP, the test cases don't even work/pass). The idea is to simply specific a module which gets passed the resulting JS object.\n\nHowever, with this version, we have to put the default resolver and default handlers manually.\n\nYou can actually pass null as second argument and it will use the default resolver. Regarding the handlers, yeah, maybe we should expose them as an array as well, e.g. docgen.defaultHandlers.\n\nAnd for the custom handler, could we use --handler option to append something to the default handlers?\n\nYes, I was thinking about a way to specify handlers from the command line. Maybe with an additional option like --includeDefaultHandlers (but shorter ;)).\n\nIf someone use ES6 module, the two default resolvers will not working\n\nYes, ES6 specificities is not really supported currently. I opened #6 for this particular issue.\n\nI'm not sure can understand the way to define it clearly. is there more details about it ?\n\nNot more than what is written in the readme and the source of the default resolvers. However, I can provide an example. A custom resolver that supports export default .... declarations would look like this:\n``` js\nvar resolveToValue = require('../utils/resolveToValue');\nfunction findDefaultExport(ast, recast) {\n  var definition;\n  recast.visit(ast, {\n    visitExportDeclaration: function(path) {\n      if (path.node.default) {\n        path = resolveToValue(path.get('declaration'));\n        if (!isReactCreateClassCall(path)) {\n          return false;\n        }\n        var resolvedPath = resolveToValue(path.get('arguments', 0));\n        if (types.ObjectExpression.check(resolvedPath.node)) {\n          definition = resolvedPath;\n        }\n        this.abort();\n      }\n    }\n  return definition;\n}\nmodule.exports = findDefaultExport;\n```\nWriting custom handlers requires knowledge of recast (or ast-types) and of course about the AST as generated by esprima. I built a web based tool that helps inspecting an AST.\nBut as I already mentioned, this should be supported by default.\n. As of v1.1.0, the module now exposes defaultHandlers which, as the name implies, is an array with the default handlers.\n. Closing this since  this was partly addressed and/or farmed out to other issues.\n. I haven't started yet. If you want to take a stab on it, I'd appreciate it!\n. @banderson: Did you make any progress with this? What's the status?\n. Great, thanks! Feel free to make a PR for the things that are working. The destructuring assignment case should already be covered with 25399598ed3d5ebbdb13ed3707183751f257ccd3.\n. This should work as of 623c1923a89329ede0cad138333fc3c481158492, release with v1.3.0\n. I'm not familiar with Sphinx, but at a first glance, you might want to look at the \"JavaScript domain\".\nInstead of e.g. generating markdown from the result JSON/JS object (as shown in the example), you would generate an output that conforms to that syntax and then feed it to Sphinx.\nIf someone more familiar with Sphinx wants to provide a generator that does that, I'm more than happy to link to it in the wiki*.\n\n*: We could have a wiki page that links to tools which can consume the output of react-docgen.\n. Awesome :+1: \nI'm not familiar with reStructuredText either, but yes, if Sphinx can work with any reStructuredText, that would work as well!\nAlso keep in mind that you can use any \"markup\" language in the component and prop types comments as long as your conversion process understands it.\n\nIn general, I think it's more useful if any step produces a rather generic intermediated format that can be consumed by other tools. That's why react-docgen produces JSON and not markdown for example. Similar here, if one creates a converter to reStructuredText, any tool that can consume reStructuredText can be used, not just Sphinx.\n. Did you make any progress with this?\n. @pwexler: That's awesome! I created https://github.com/reactjs/react-docgen/wiki/Markup-generators to list and promote tools like yours.\n. The relaxation was implemented in v1.1.0.\n. I will take take care of this after I'm back from vacation. My current plan is to change the structure of he value that is passed from the resolvers to the handlers, which will make it easier to add this feature.\n. As a heads up, I'm planning to have this ready by the end of this week!\n. @jherr: :) I actually answered your email, but it seems it couldn't be delivered due to security checks. It contained the same info though ;)\n. I pushed all changes to master. I will run one more test tomorrow and release a new version if everything goes well.\n. Alright, published as v2.0, since it potentially breaks custom handlers (if someone does that). Please try it and let me know about any issues!\n. Mmh, I can't repro. I ran react-docgen with just the source of Fauxbox.jsx and the output includes the description.\nI also cloned your repo and ran npm run docs and I can also see the description.\nDid you try to delete node_modules and npm install again?\n. Are there any errors, other than\nError with path \"dist/Components/App.js\": Error: No suitable component definition found.\n?\n. The only thing I could think of is that the comments are stripped somehow. But in that case it shouldn't work for me either.\n. Could you provide some infos about your system? Which Node version, npm version, OS, shell, etc.\nJust in case.\n. Glad you found the issue/solution! I think this line is responsible: https://github.com/reactjs/react-docgen/blob/master/src/utils/docblock.js#L37.\nI guess we could support Windows line endings? Feel free to open a new issue for that if you feel strongly about it.\n. Yes. The /*, */ are already stripped by the parser, since they are delimiters of the comment. So, my way of determining whether a comment is a docblock comment, is to look for *<line break> at the beginning.\nI think we should actually consider any line terminator that the ECMAScript spec considers as valid.\n. Yep, that looks like it should suffice, although I would write as\n/^\\*(\\u000A|\\u000D|\\u2028|\\u2029)/.test(comment.value)\n. No worries, I appreciate the help!\n. @gonzochic: Thanks for brining this up again. I haven't implemented the changes yet but I will take care of it now!\n. It turns out that this is not a problem with react-docgen but with recast. I will create a PR there.\nTo expand a little: It seems that recast (or something) normalizes comments to use \\n as line terminator. That's why all we need to do in order to fix this is to make sure recast understands the different line terminators.\n. This was fixed in recast in v0.10.31. I added a (now passing) test that that I believe suffices to verify that this issue is fixed.\nI'm not publishing a new version for this. If you reinstall react-docgen you should get the latest version of recast. Please give it a try and let me know!\n. @gonzochic: Mmh, your example works for me, but I guess the line terminators you are using might get lost somehow along the way. Not really sure what to do :-/\n. Closing this because I cannot repro. If someone still experiences this issue, please reopen.\n. Sweet! I will take a close look later today. Thank you for this!\n. It doesn't seem like this would support support\njs\nexport {\n  comeponent,\n  something else\n};\nor does it?\n\nShould we support this?\nimport React, { createClass } from 'react';\nexport default createClass(...);\n\nNot sure. I think if the need arises we can still that.\n\nAnd not sure, is it ok, to support ES6 module and CommonJS in one handler.\n\nSeems fine to me.\n. Sorry for the late response! I included your changes in 55c1511cdd192f51f7183ed7ddc604ba7e86a68e and 9e8670c7b8197d7be98af8bf1d2b21d2763fced3 (I squashed the third one).\nI also built on top of your changes and added support for the remaining import and export variations.\nAll these changes are release with v1.3.0.\nThanks for your help!\n. I assume that whatever renders the docs is not set up to render unions. The output from react-docgen should be something like\njs\n    \"transform\": {\n      \"type\": {\n        \"name\": \"arrayOf\",\n        \"value\": {\n          \"name\": \"union\",\n          \"value\": [\n            {\n              \"name\": \"shape\",\n              \"value\": {\n                \"rotation\": {\n                  \"name\": \"number\"\n                }\n              }\n            },\n            {\n              \"name\": \"shape\",\n              \"value\": {\n                \"scaleX\": {\n                  \"name\": \"number\"\n                }\n              }\n            },\n            {\n              \"name\": \"shape\",\n              \"value\": {\n                \"scaleY\": {\n                  \"name\": \"number\"\n                }\n              }\n            },\n            {\n              \"name\": \"shape\",\n              \"value\": {\n                \"translateX\": {\n                  \"name\": \"number\"\n                }\n              }\n            },\n            {\n              \"name\": \"shape\",\n              \"value\": {\n                \"translateY\": {\n                  \"name\": \"number\"\n                }\n              }\n            }\n          ]\n        }\n      },\n      \"required\": false,\n      \"description\": \"\"\n    }\n  }\nSo all you have to do is iterate over value and build the output you want.\n. Awesome! \n. Thanks for the info! I'm closing this since there is nothing actionable here.\n. Yes, that should be easy to do. You could write your own handler if you need it quickly, but I'll include it in the next release.\n. I assume you mean, given\njs\nclass Editor extends React.Component {\n /**\n  * Get the value of the editor\n  */\n getValue() {}\n}\nit would extract getValue and its docblock so that it's clear that given a ref to the component, one can call getValue on it?\n. Sounds reasonable to me. I think it is common to prefix internal methods with an underscore _, so I think it makes sense to only look for methods that are not prefixed as such.\nOf course this could still extract data that is not needed, but then again, it can also just be ignored when generating the actual documentation.\n. @scvnc: I don't see why not!\n. @Aweary: Sorry, I just didn't have the capacities so far to work on this. I might be able to get to it soon, otherwise PR's are always welcome!\n. Thanks for the report! My first guess would be that the comment might be attached to a different node. I will investigate.\n. Yes, it currently expects a line break after /**. I guess we could change that :)\n. Supported as of v2.1.0.\n. Supported as of v2.1.0.\n. Actually, I missed the \"required\" part. Will take care of this soon.\n. Fixed in 3518f672b913e2b9e0bb00c121723e601f4aec6d.\n. react-native uses a custom setup to parse modules that export object literals. In v2, react-docgen split the prop types and composes logic into two handlers. All that needs to be done should be adding docgen.handlers.propTypeCompositionHandler to here.\n. @browniefed: No worries, it's not that obvious what's wrong if you are not very familiar with the tool :)\n. Sorry for the late reply. Just to clarify, all your examples would work on objects that are not React.PropTypes and have arbitrary methods. E.g.\n``` javascript\nstatic propTypes = {\n  prop: Types.validationFunction\n}\n// yields {type: {name: 'validationFunction'}}\n```\ncorrect?\nIf so, yes, that would be great! Thank for you for the detailed list, that makes a lot of sense to me.\n. How would you resolve a.very.long.member.access.chain? Would you just look at the last property? Overall this looks very reasonable to me and I will gladly accept a PR for this :)\nI believe it wouldn't even be too much effort to implement it with the utility functions that react-docgen has.\n. Looking at the current implementation would be a good start: https://github.com/reactjs/react-docgen/blob/master/src/utils/getPropType.js\n. Where/when are you using getDoclets? react-docgen itself doesn't actually try to parse the doclets because there are other tools out there that do a better job (as you noticed :) ).\nI think getDoclets exists only for legacy reasons... you are free to use any other tool that exists if getDoclets doesn't work for you.\nI don't see why react-docgen should depend on an external tool if it doesn't use it itself though...\n. Ah I see, fair enough :)\n. Mmh. Overall I would agree, but the added value doesn't really justify a breaking change. I'll leave this open for the next major version.\n. Looking back at this, I don't think that a minor improvement in code aesthetics justifies a breaking change. You can always renamed the property yourself before you process it further.\nI'm going to close this for now. If anybody feels really strongly about this, please let me know.\n. Nice, thank you!\n. I attribute it to bad design decisions at the beginning ;) Everything kind of expects that the result of the resolver is a single AST node and extracts data from there.\nI guess we could introduce some new interface, ResolverResult, and have implementations for class, object literals (React.createClass) and stateless functions, to abstract from the different representations. Could be quite some work though.\nHandlers shouldn't necessarily what kind of definition they are dealing with. That custom logic could be implemented in the getMemberValuePath method though, which already takes care of the differences between class declarations and object literals (React.class).\n. > All of my API transformation projects have terrible design decisions. And be \u201cterrible\u201d I mean \u201cno\u201d.\n:)\n. This is pretty awesome work, thank you so much! Regarding priorities:\n\nisStatelessComponent is too loose in saying true. Should scope this better (high priority)\n\nDefinitely that one. Not sure how tricky this one is though. \n\nhash of components (low/no priority)\n\nI wonder what the use cases are for doing something like this. This would be covered by finding all component definitions anyway though, wouldn't it?\n\nI was wondering about this following case:\n``` javascript\nfunction Foo() {\n  return ;\n}\nObject.assign(Foo, {\n  displayName: 'Foo',\n  propTypes: { ... }\n});\n```\nDo you think that would be a common use case? Or are propTypes and displayName the only properties one would add to stateless components? I guess defaultProps too. Maybe this is a \"nice to have\".\n. In the worst case we can also introduce a doclet, like @react or @react-component to mark functions as React components that would be hard to identify otherwise.\n. @iamdustan: I'll try to get to it tomorrow or Wednesday!\n. > do we even want to support all the possible ways to do stateless components for this?\nYep, good point. My answer to this is: no. We probably already don't support every possible way to create a React component and that's OK IMO.\nA side effect of this project is that people have to follow certain guidelines to make it work, which in turn hopefully positively impacts consistency / familiarity across different projects / code bases.\nNot sure I can get to it this week (will be away tomorrow for the rest of the week) and there is another issue I'd like to address before releasing a new major release (and I think this should be a major release because it could pickup components that haven't been considered as such).\n. Sorry, I thought I would be able to get something else in, but don't really have much time. I'm not so sure anymore this requires a major version bump. In the worst case it just finds more components.\nA minor version bumpv should suffice an which case I can get this in now. What do you think?\n. Merged in 9f27006d297f2184403e8bf5842dd64da99e632b and released as v2.4.\nThank you so much for this!\n. You could either create your own resolver with the utility functions that react-docgen provides, or you could use the findAllReactComponents resolver.\nHowever, I do think this use case is not uncommon and it might be worth it to have better support for this by default.\n. https://github.com/reactjs/react-docgen/blob/master/src/resolver/findAllComponentDefinitions.js is what I mean.\n. You mean why it isn't listed in the README? Probably just an oversight from my side.\n. We do have https://github.com/reactjs/react-docgen/blob/master/src/handlers/displayNameHandler.js though.\n. I can't repro this btw. The displayName shows up in the result. What does your ./my-component.js look like?\n. Oh, the displayName handler only looks for explicit displayName properties. You want it to also return the inferred name from the class or function name, right?\n. I don't know, will have to look into this. Seems reasonable to me though. PRs are also welcome ;)\n. Last I heard is that function binding might not advance to the next stage in its current form, but there is no reason why react-docgen should have an opinion on this.\nThanks!\n. I guess we could do this for simple cases, where a variable is spread into propTypes (i.e. ...foo, but not ..foo.bar) and that variable resolves to a module import.\nI didn't want to make react-docgen make any assumptions about how module identifiers are resolved, but I guess it's fair to assume that it will be CommonJS compatible (i.e. module identifiers refer to npm modules or local files).\nThen we could inspect the other file and if it returns an object literal, inspect and merge it as well.\n. @asis: They are not ignored: https://github.com/reactjs/react-docgen/blob/00f2d2d62d93b9243157c4cea19cf241121a7721/src/handlers/tests/propTypeCompositionHandler-test.js, but they are stored separately from normal props.. @RIP21 \nThe recommended approach (which is also what we do at Facebook), is to merge the docs yourself. I.e. since you know that this component composes semantic-ui-react, you can look up the documentation for the imported component.\nI guess in your specific case we would also have to record which export you are importing (Button).. @RIP21: Have you tried using @pasupuletics' custom handler?\n\nCan somebody integrate such finally :(\n\nSupporting dependency resolution in such a way that it works reliably in various environments is not trivial. That's why I'm suggesting that you are using a custom handler that works specifically for your environment.\nOf course someone could write a reusable handler that works with plain CommonJS, someone else could provide one that understands with webpack, etc.\nI don't have the bandwidth to build and support all this.. Do you mean general tools for inspecting JSON or something that converts this specific JSON result to something renderable?\nThere is an example in https://github.com/reactjs/react-docgen/tree/master/example to convert the output to Markdown. There is also a docutils extension to convert it to reStructuredText: https://github.com/reactjs/react-docgen/wiki/Markup-generators\n. I would certainly be happy about more examples as well though ;)\n. There is a description of the output in the README: https://github.com/reactjs/react-docgen#result-data-structure (though granted it doesn't cover possible value types for props).\nThe second issue you linked to seems to be a bug in react-docgen. value should be empty in that case (raw should be set instead).\n. Well, it could be more extensive maybe :)\nI'd appreciate it if you could file a bug for the second issue you mentioned!\n. Thinking about it more, I will have to check again if it is really a bug. It might also be that the computed: true field should indicate that value is the source instead of the real value.\nBut even then, it's probably better to leave value empty and have the source in raw.\n. Since the output is JSON, you can process the JSON in any way you want. E.g. you could pass it to your favorite HTML template engine or build the HTML manually.\nIn example/ you will find some code that converts the JSON blob to Markdown (which in turn can be converted to HTML).\n. Sorry for the late reply. In this case you have to pass the findAllComponentDefinitions resolver to reactDocgen.parse or write your own. \nI should make this a command line option really.\n. I'm closing this for now since I do see any actionable item here. If you think there is something to do here, please reopen.\n. What's the issue you have in the browser? It shouldn't make a difference.\n. Yeah, parse is a named export, so you need to do import {parse} from 'react-docgen'; or something like import * as reactDocgen from 'react-docgen'; .\n. > I tried to do it\nWhat exactly did you try?\n\ni had problem with npm test\n\nI fixed the test setup in 546635c8c6e76aa70eb08e9f567652d67931fe5d .\n. Closing this, since I haven't heard back. I'm also not sure if we can do much here, since, in general, the shape of transpiled code is unknown and there may not be enough information to find the information we we want.\n. @just-boris, why do you run react-docgen on compiled code? In general I don't think it makes sense to try to fix this since Babel removes a lot of the syntax that react-docgen uses to extract information. Just think about what classes are compiled to:\njs\nclass Foo extends React.Component {\n propTypes = {\n   bar: React.PropTypes.string,\n };\n}\nbecomes\n```js\n\"use strict\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.proto = superClass; }\nvar Foo = function (_React$Component) {\n  _inherits(Foo, _React$Component);\nfunction Foo() {\n    var _ref;\nvar _temp, _this, _ret;\n\n_classCallCheck(this, Foo);\n\nfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n  args[_key] = arguments[_key];\n}\n\nreturn _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Foo.__proto__ || Object.getPrototypeOf(Foo)).call.apply(_ref, [this].concat(args))), _this), _this.propTypes = {\n  bar: React.PropTypes.string\n}, _temp), _possibleConstructorReturn(_this, _ret);\n\n}\nreturn Foo;\n}(React.Component);\n```\nI'd think this becomes impossible to reliably extract information from.. Seems to look good for me: https://travis-ci.org/reactjs/react-docgen/builds/88383861 . What exactly are you referring to?\n. Maybe you meant that test are failing if you run them locally? I just fixed that with 546635c8c6e76aa70eb08e9f567652d67931fe5d .\n. Yep, that's because it was running in Node v5, hence I was only testing in v4 afterwards: https://travis-ci.org/reactjs/react-docgen/builds/88383861 . Either way, doesn't matter anymore. It was an issue with the test setup which is now fixed.\n. Regarding travis passing, I'm not sure why. I guess it has something to do with how the tests are failing.\n. #44 was merged!\n. Fixed with 27c9ec2fb4452a124502c7d2e3fb3d360ce58ef0 and published with v2.5.0\n. Given that the test fails, it seems that defaultProps is not resolved to its value?\n. I fixed the issue locally and simply changed the existing tests to use referenced propTypes and defaultProps, instead of adding your additional test.\nI hope that's fine with you, thank you very much for noticing this issue!\n. What is the Babylon version you are using here? This rather seems to be a configuration error or an inconsistent state of your nodes_module folder. Sure, we could upgrade to a newer version of Babylon, but that shouldn't be necessary. Whatever Babel version you are using shouldn't impact react-docgen and vice versa.\n. @yrashk: There is no plan to upgrade babylon atm. Can you share information about your setup? You have to think of react-docgen as a standalone tool / library (just like eslint). Whatever setup you have shouldn't impact it, and there shouldn't be anything you have to configure differently.\nHowever, there could be an issue when npm didn't install the correct dependencies. I guess one solution to avoid these issues could be to use bundledDependencies. \n. Nice, thank you! TBH, I had something different in mind with flow type support. I thought we could run flow directly and query it to get type information (though I don't know how much information we can get).\nHowever, if we can do it this way and get equally good results, that's great!\n. > I tried flow itself before, but the ast it delivers is nearly the same as the one from babylon.\nI was thinking that flow can return us the type information already parsed, but since I haven't worked with it yet, I might be wrong.\nEither way, I am really happy about this :) When you are done, I'd appreciate it if you could squash everything into a single commit.\n. Mmh, not sure, what would you prefer? Would it make sense to have a --flow option on the CLI which will use flow handlers, instead of standard ones, if they exist.\n. > The only \"problem\" that could arise is if people use both propTypes and flow in their components. \nRight. I think (hope?) that this is not very common. What's more interesting is how often people use flow type annotation and propTypes in the same code base (in different components)(which would be the case for Facebook). Those might want to have both handlers enabled.\nHowever, I think it would fine to have this option first (no major update needed) and then see if others need a more flexible setup.\n. Actually, here might be a better idea:\nLets simply add the flow prop types to a new key, e.g. flowProps, and add the handlers to the defaults. This way there won't be any conflicts and both annotations can be used (for static and runtime checks).\nHow does that sound?\n. > Having the flow type under flowType inside the props object, next to type. \nSeems fine too.\n\nThe only question then is what to do about the description, maybe flowDescription although that sounds confusing to me.\n\nDo you think people would add a description to both, the propTypes and the flow types in the same component? I think it's fine to assume that only one of them will be annotated. We could make it so that either the flow type description handler or the propType description handler doesn't set a description if there already is one set.\n. Two comments inside (somehow I'm always adding the comments so that GH doesn't show them inline, but whatever).\nIf that's clarified I think we are good to go! Really awesome work, I'm sure lots of people will be happy about this, I certainly am :) Thank you!\n. > Do you think it is worth adding a check if the other handler already added the required field?\nI think its fine for now. If we encounter any problems, we can always update later. Everything looks really great! I'm only a little concerned regarding the warnings, since there is no way to disable them. This might be surprising if react-docgen is used as a module instead of the CLI.\nOTOH, I think it would be valuable if there was some information about unresolved types. But I also don't want to block this on implementing a proper error handling feature.\nShould we just omit the warnings for now?\n. Thank you! I'm going to merge this now, and release a new version later today.\nAlso thank you for your patience for my many questions and requests, and again, for implementing this feature!\n. There have been some changes around how decorators are printed. I guess it may also have impacted comment attachment. Whether that's a bug or intended I don't know.\n. Looks like a bug to me: The comments property contains the decorator comment, the leadingComments property contains the component comment: http://astexplorer.net/#/lBRfRefMun .\nCould probably still fix this from my side.\n. I fixed the test if you want to rebase!\n. Thanks for reporting! Fixed and released with v2.6.2.\n. Nope. Just an oversight when the function was added. Feel free to send a PR if you get to before me :)\n. Yes. react-docgen will extract information about React components from your source files and give you a JSON blob, from which you can generate human readable information in any format you like. Have a look at the example that generates Markdown.\n. Unless of course you mean generating documentation for React itself, in which case the answer is no.\n. Makes sense. I think if we run into problems with nomnom, we should do this.\n. Mmh, good question. I think the way it is now is how I originally intended it to be (because I imagined the values would be rendered somewhere and as such you want to represent a string with quotes).\nNow however I think there are better ways to handle this. I could imagine that value really holds the corresponding JavaScript value (like you expected it), if the value can be resolved) and raw would contain the source (i.e. \"'shy'\").\nThis would be a breaking change though. I'd be happy to have a discussion around revisiting the data structure in general and around propTypes in particular.\n. @nikgraf: Unfortunately I'm not adding the React Conf. But I hope we find other ways to discuss :)\n\nI wonder how valuable a big time investment into propTypes is as the React core team announced to move more into the Flow direction\n\nI still think code using propTypes will be there for a while, at least at Facebook. I agree though that we don't need to come up with the perfect solution. Because react-docgen evolved over time (we used an early version of this internally for a while), I think I first want to get a good overview again about how all possible types are encoded and what information / fields are available (which is basically #55 ).\nThen we should deal with inconsistencies and surprises.\n. Mmh, I see. I guess the issue is with how we resolve the identifiers to values. I guess we should be able to detect that there is only a single assignment to the variable (in the top level scope) (React and Component) and use that value then.\n. Well, if this is the only exported component, you shouldn't have to write your own resolver, we just need to fix the default one :)\nAs a workaround, if this is the only React component in the file anyway, you can use the findAllComponentDefinitions resolver:\nreact-docgen --resolver findAllComponentDefinitions src/\n. Thanks for working on this! I will add some comments inline.\n. > Would breaking resolveName into separate file be cool?\nSure! Can you also update the tests to verify whether these cases are covered?\n- Function expression: (function Component() {})\n- Named exports:\n  - export var Component = function() {}\n  - exports.Component = function() {}\nIt was also be great to get some test coverage for React.class(...) component definitions. This might require some changes to the way the tests are set up. Have a look at https://github.com/reactjs/react-docgen/blob/master/src/handlers/tests/componentDocblockHandler-test.js for how different component definitions could be tested easily.\n. Yes.\n. After looking at the AST, it seems named exports should actually be covered by variable declarations, no?\nRegarding exports.name = ... it seems you would need to look whether the parent is an assignment expression to exports.X and grab the property name.\ngetMemberValuePath is for getting keys from the component definition (i.e. propTypes, defaultProps, etc), it wouldn't help you finding information \"outside\" the component definition.\nIf you have something new to share, I'm happy to take a look.\n. I'll take a closer look again today, thanks!\n. We can at least give it a try yes!\n. >  I'd probably just go ahead and create an npm package for this.\nyeah, that would be the best solution for now. I'm happy to merge any fixes that would need to be done to core utilities though.\n. In general I hope people add their environment specific configuration to their global or user .gitignore file, but why not :)\n. > If Im reading the docs right, this is simply a new resolver and the existing handlers can be reused?\nNot quite. Resolvers just find component definitions. They don't extract any information. Handlers are functions which get passed the found component definitions and extract the information.\nBut also here, we tried to make everything transparent so that handlers don't have to care what kind of component definitions they get (class, stateless, etc).\nHowever, looking at the code, this should already work for, for defaultProps at least. displayName needs to be updated to look into functions.\n. Ha, I didn't know that, thank you! Could you squash the commits into one?\n. > So the type of React.PropTypes.shape sub properties is not determined.\nI'll take a look at that, thanks!\n. I know this is old. The markdown script is more of a proof of concept example and not necessarily correct.\nI appreciate it if someone wants to submit a PR to improve it though.\nHowever, I believe there might already be better Markdown implementations available anyway.. There is https://www.npmjs.com/package/react-docgen-markdown-renderer, but I have no experience with it. I added it to the wiki.. Can you elaborate? What exactly is the problem? Do you get an error? Do you get unexpected output? What is the output your get and what is the output you would want to get?\n. This should be fixed with d3dbb2e0214c8d5e84089c25a970479186e95383 which is included in the v2.12.0 release.\n. @leepowellcouk: No, react-docgen doesn't resolve dependencies.. This is awesome! I looked over the code and it looks great.\nI'm not such a big fan of making assumptions and parse the docblock with doctrine, but then again, this is probably the most common use case (having jsdoc-like docblocks), so including these bells and whistles will probably be a good thing?\nThoughts?\n. Thanks for all the work and thought you put into this. And thanks for the fruitful discussion!\n. @janicduplessis: Done! (2.8.1 because I messed up the npm publish process). If you have a small input/output example handy, I can update the release notes with it :)\n. Yeah, react-docgen doesn't work with generated code. I don't think is there anything we can do about it, since generated / transpiled code can be quite arbitrary and have helpers that make analysis more difficult.\nRegarding TypeScript: I don't think the libraries that react-docgen builds upon will be handle to deal with TypeScript. However, if there is a way to convert a TypeScript AST into an equivalent JavaScraipt / Babylon AST, I'm happy to look into it. That said, I could imagine that there already is a documentation generation tool for TypeScript which likely would work fine for your use case as well.\nI'm closing this for now since I don't think there is anything else I can do here.\n. > interesting thing here was on ASTExplorer the outputted structure was the same - which makes me think I'm probably missing something trivial\nThe ASTs are probably the same, but the NodePath's may not?\n\nIs there something I'm missing with the paths provided by babel-traverse that would make them work with recast or are they fundamentally different api's meaning they would need some sort of conversion step?\n\nI don't know that much about the NodePath implement babel-traverse. But from writing a custom Babel plugin I can say that they appear to be very different than recast's NodePaths.\n\nAlso, out of interest, wondering how the decision is made to use something like recast over babel-traverse (considering babylon is already used as the parser)? Guess this may be a timing thing when work was actually started on this!\n\nPretty much, yes. I actually wrote jscodeshift two years ago. Babel didn't exist back than.\n\nAlso, is it maybe the plan to move to babel (making assumptions since it's FB managed now)?\n\nI don't have any plans in this direction. recast works well for us as it is and I believe that a conversion is worth the effort (not enough gain).\n\nI'm looking to re-use a bunch of logic I've already written as babel based traversals and am desperately hoping I can take advantage of docgen in the least ugliest manner possible.\n\ndocgen uses babylon v5. If you are using v6, then that could explain some of the differences. But aside that, there shouldn't be an issue using a babylon AST with docgen/recast. I'm happy to provide an API that accepts an AST (instead of code).\nMaybe if you provide concrete examples which cause issues, we can solve them?\n. I'm closing this since I guess there doesn't seem to be anything actionable here.\n. It's not implemented, but it's possible to implement it if that's what you mean. It should probably be in its own handler.\n. I'd be happy about more heuristics :)\n. @pdfabbro: This doesn't seem to have anything to do with the original question.\nAnd it also doesn't seem to be an actual issue. If you are talking about docGenTest, then that's not method. It's a local variable. There is no reason why react-docgen should do anything with it.. react-docgen doesn't implement any dependency resolution, so it doesn't know how to load ./AnyComponent or even what it is.\nThe problem is that we have a different module system at Facebook, so a solution to this problem would require a way to specify how modules are resolved (maybe parts of jest can be reused). I don't think I have time to look into this, but if somebody else wants to, I'm happy to help.\n. I'm not sure it makes sense to integrate this directly into react-docgen, but it shouldn't be too difficult to write your own handler that understands these constructs. Have a look at https://github.com/reactjs/react-docgen/blob/master/src/handlers/propTypeHandler.js as a start. We might need to tweak some APIs to make it easier to generate correct output.\n. Thanks for catching that! I will look into the Node6 issues...\n. Merged with bfd4da6b51939c39e9c56da1e11c5167220e2c69 .\n. @rtsao:\n\nI've added support for single unary higher-order-components in my personal fork\n\nThat seems very reasonable to me, and I think it would even make sense to expand this to non-unary functions. The other arguments could be included in the output as well, as far as possible. Happy to review that PR :)\n@maximelebastard\nAs an intermediate solution, if you can use the findAllComponentDefinitions resolver, which looks for all component definitions, not just the exported ones.\n. Thanks for all your help and sorry for neglecting rect-docgen recently. I'm really swamped with other stuff... lets see how quickly there will be a new jest version.\n. The tests still fail for Node v4 in Travis CI. Seems to be only a timeout error though. It seems to pass fine locally. Could you try updating the timeout to 30 sec?\n. Oh, I thought they would have released one by now :(\nI just realized that I already updated jscodeshift to work with jasmine2. There I am using\njasmine.DEFAULT_TIMEOUT_INTERVAL = 30000;\nThat should work.\n. oh my :-/ Thank you!\n. Merged with 6a655bd613109c622900c8c7af81397db2347dcf .\n. Tests still fail for Node v4 from time to time, but they work fine locally so \u00af_(\u30c4)_/\u00af.\n. This should be possible. You can define your own handler which traverse the AST of the render (and any other method you are interested in) and look for JSX elements.\nDo you have a more specific about that?\n. Yes. This is populated with the component names when you do\npropTypes: {\n   ...SomeOtherComponent.propTypes,\n}\nBut if you want to add to that from your own handler, that's fine I guess. It's your code after all :)\n. Yeah, you need to rebase your changes on top of current master. But I can probably do this too if you don't get the chance.\nIt's hard to review your changes this way...\n. I think you mean this line: https://github.com/reactjs/react-docgen/blob/dca8ec9d57b4833f7ddb3164bedf4d74578eee1e/src/utils/getPropType.js#L71 :) Good catch! Feel free to make a PR if you want.\n. Thanks!\n. Yeah, at the very least it should give you access to the string representation of the value, i.e. Child.propTpyes.\n. Now you will be getting \njs\n\"type\": {\n  \"name\": \"shape\",\n  \"value\": \"Child.propTypes\",\n  \"computed\": true\n}\nwhich is more in line with how the other types work. We may change the structure in the future, but that's still a bit out (if we do it at all).\nI don't know yet when I'm going to release the next version.\n. Does that site even use react-docgen? react-docgen is a command line tool. If someone runs it in the browser, they have to make sure the environment is compatible. find is easily to polyfill.\n. Oh ok. Yeah, there is nothing that should prevent react-docgen from running in the browser, but it's not specifically designed for that. In other words, we are not going to not use any features only because browsers do not support it.\n. Great, thank you!\n. Did you try to add execution permissions, i.e. chmod +x buildDocs.sh?\n. @kevinSuttle: See https://github.com/reactjs/react-docgen/issues/94 .\n. Uh ok, will take a look. Thank you for the report!\n. So it says resolver is not a function? Or which line are you referring to?\n. Oh. That's because you are using require to load the resolver. findAllComponentDefinitions has a default export, which Babel exports with the default key. So you'd have to pass findAllComponentDefinitions.default instead.\nHowever, the standard resolvers are also exported from the index file, so you could just do\njs\nimport * as docgen from \"react-docgen\"\nconsole.log(docgen.parse(fileSouceFromAbove, docgen.resolver.findAllComponentDefinitions));\nDoes that solve the issue?\nI think I also know why it worked before: 6a655bd613109c622900c8c7af81397db2347dcf updated from Babel5 to Babel6 which changed that behavior I was mentioning (exporting the default export with the key default).\n. Nice, I like it :)\n. https://github.com/reactjs/react-docgen/tree/master/example shows an example how one could generate markdown (and therefore HTML) from the JSON. There are also site generators that use react-docgen. \n. So, what would be the difference between composes and dependencies now?\nDo you think this handler needs to be part of react-docgen core? I'm hesitant to include any more handlers. I think this could every well be a plugin that people can use if they want to. I think we'd only need to make it easier to include handlers via the command line. What do you think?\n. You probably don't need this anymore but I update resolveToModule in 2c6e55aa838c1cb9a6755711a17ca4f108cbdf13 \ud83d\ude09 . Mmh... I understand, but I'd argue that it's very uncommon that only a single file is passed to react-docgen. That's a deliberate decision, so I would assume the user only wants to get the docs for that specific component. Also note that ./buildDocs.sh is really just an example, not necessarily something you should use in production as it is.\nIf a directory is passed or multiple files are passed, you will always get the second output, even if only one component is found.\nDoes that make sense?\n. I see... I'm usually not a fan of something like this either.\n. Sorry, I've been on vacation for exactly two weeks :)\n. Sorry for the slow progress here, the last couple of weeks just had been really busy (I was traveling most of the time).\nIf we want to stay compatible with flow types, I think * should be mapped to mixed or any.\n. We could add a configuration option that lets you specify the module name(s) to validate against. Maybe we should add support for configuration files in the future if the configuration options keep increasing.\n. This seems interesting. You could build your own handler (and publish it as an npm module) to enable such behavior.\nI'm going to think about a bit more this week how we can make it easier to use custom handlers. I don't think it is sustainable in the long run to add more and more features to the core.\nBut something like this could definitely be a plugin.\n.  @GrumpyPants, yes, if you look at this example (http://astexplorer.net/#/9vemjTFqdt) and select babel5 in the recast parser settings, you can see how to comment is attached to the property (it's in the comment property on the Property node), so it would absolutely possible to write a custom handler for that.\n. yeah, this looks good to me. I was wondering if it makes sense to include some additional information about the origin of the value (e.g. that it is the default import of the ./ImportedComponent module), but I'm not sure where / how.\n. > Are you looking to provide information from the imported module itself? \nNo. This has come up a few times and maybe we are able to resolve and inspect dependencies at some point, but I was only thinking about the import statements itself.\nIn particular, if someone generates the docs, I can imagine they might want to link the source of the module or some other part of the page that provides more detailed information about ImportedComponent, and for that they probably need the path at least.\n. @levithomason, sure! I will try to release a new version today or tomorrow.\n. Seems reasonable to me. @danez ?\n. That's great, thank you! Yeah, I think we should leave the default empty, otherwise this would be a breaking change.\n. @dptoot , @wallaroo just needs to remove the default value and this should be good to go \ud83d\ude03 \n. Sorry, I thought I commented on this one.\nI think you are comparing two different things here. The outer object is actually a prop. A prop has a type, description and can be mandatory. The type itself can contain subtypes but because types are types, they don't need a type field.\nBut I certainly think that this is a bit confusing and might need some restructuring. At the end of the day, it's important that the structure is easy to process.\n. \ud83d\ude1e \n. I guess I'll have to investigate a bit \ud83d\udd0d  ...\n. Would this also supersede #97 ?\n. Thanks @danez!\n. Yep, that should definitely work.\n. Thanks @dptoot! Yeah, we \"just\" have update the heuristic to account for these cases. https://github.com/reactjs/react-docgen/blob/master/src/utils/isStatelessComponent.js is the file if anyone wants to take a stab at it.\n. @khankuan: Seems reasonable to me. I'd still keep the current heuristic and fall back to that if the propTypes check comes back negative.\n. Yeah, I think this is good to go, just needs to be rebased.\n. Merged! Though I don't know when we are going to release a new version yet (I just released one, I guess I should have waited \ud83d\ude1b  ).\n. I'll get something out within the next two days! (just came back from vacation)\n. Thank you so much for looking into this. We can definitely set sudo: required and rerun the checks on all outstanding PRs.\n. Can't believe how this wasn't noticed earlier. Thank you!!\n. Any thoughts about my comment @ZauberNerd ?\n. Lets merge this and see how things work out \ud83d\ude04 \n. This is great, thank you! I was just thinking about this the other day.\n. > I didn't create PRs for them but will extract them into their own npm modules to allow others to use them too.\nThat's perfect. I will actually post something very soon about how I see react-docgen moving forward, and that's exactly what I had in mind!\n. Could you export this handler from src/resolver/index.js as well?\n. Thanks for the feedback and input @ZauberNerd, that's really valuable! I also like the idea of moving each handler into the own package. Some of the handlers could still be loaded by default though, at least for the time being. \n. @levithomason: Definitely.\nCurrently most of the logic is contained in utility methods which is used by handlers, but of course handlers can contain arbitrarily complex logic. Handlers get passed a reference to the AST node that represents the component definition and they can do whatever they want with that.\nIdeally, useful and reusable functions would be incorporated back into the core.\n. This is strange. I could image that react-docgen tries to include the raw source of import noop ... line, but looking through the ast-types definitions, ImportDefaultSpecifier inherits from Printable.\nWe will have to investigate where the issue is in ast-types / recast or work around it.\n. Just release v2.10.0!\n. Thanks! This is a known problem and will be fixed with #97 . cc @danez, @palange\n. This was fixed in #118 . Did you imagine any other solution for this or can this be closed?\n. @stepankuzmin I think this issue was only about getting an error, not about being able to process imported types. react-docgen doesn't do that.. Thanks for that! I added two comments which I guess don't show in here because the branch got deleted. But they should be visible when you click on \"Files\".\n. Whoops.... thank you \ud83d\ude03 \n. This is awesome!\nI'm a little bit worried about the fact that resolveToValue used to simply return the MemberExpression if you passed one and now it tries to resolve it. While that behavior is certainly better, it changed.\nSince we might update the parser to flow anyway, maybe well just make this part of a breaking change release.\nThis would fix #65 btw.\n. > Using flow as parser sounds very interesting, is this being done in the open and has work on it already started?\n@wbinnssmith started to look into this. In the best case, we literally can just change the line\njs\nvar ast = recast.parse(src, {esprima: babylon});\nto\njs\nvar ast = recast.parse(src, {esprima: flow});\nand everything still works the same.\n. I will resolve the conflict and merge this. I don't think there will be any issues that resolveToValue changed slightly.\n. Merged with d3dbb2e0214c8d5e84089c25a970479186e95383 .\n. > but I'm not sure why it isn't show up here\nThe reactjs org is not managed by Facebook anymore afaik.\n. Yeah, looks good to me, I think we can always iterate on it and improve it if necessary. Would be cool to document this behavior though.\n. Yeah, I think we should simply use the flow parser since it's more ESTree-compatible than babylon 6.\n. There is JS version of the flow parser available: https://www.npmjs.com/package/flow-parser . I'd rather use flow since I know they are trying to stay close to the ESTree spec.\n. The tests are passing, so I'd say yes. Can you provide more details to reproduce the issue?\n. @n1313: Specifying -e multiple times should work:\nsh\nreact-docgen src --pretty -e foo.js -e bar.js -o output.json\n@awesomejerry: You partly using the API incorrectly (I think) and it's partly an issue with react-docgen. To ignore directories you should do\nsh\nreact-docgen src --pretty --ignore styles\ni.e. omit the brackets.\nProviding regular expressions as patterns for --exclude doesn't seem to currently work since we are not converting the provided parameters to regular expressions. I'd appreciate it if you open PR to fix it.\n. > Only parse files that define components.\nWell, we have to parse the file in order to know whether it defines components or not. However, maybe we should create a friendlier output that simply lists in which files it didn't find component definitions (and provide a CLI option to suppress that information).\n. > Instead of doing this draining logic, I would more lean to remove process.exit() from line 98 and 110 and replace the first one with process.exitCode = 1;.\nIf that works, I'm all for it since it's the simpler solution. However, we are invoking exitWithError in  line 142 which is the async directory traversal process. Maybe we can just return there instead?\n. Thanks for this! I'll release a new version shortly.\n. This is a know limitation and has been addressed before ( #80 ) and has been implemented in  #124 , we just haven't released a new version yet. I can do that now though. I'll update the thread when I did that.\n. Published! https://github.com/reactjs/react-docgen/releases/tag/v2.11.0\n. Sorry for not commenting on this earlier. This seems reasonable to me, but could you please provide tests for the new handlers as well? Or at least a snapshot test in src/__tests__/fixtures? \nThank you!\n. Thanks, I'll look into it! cc @CompuIves \n. This should be fixed with v2.12.1!\n. Sweet, thank you for the quick fix!\n. Uh, thanks for that! I believe there are other cases whether this would be an issue, e.g.\njs\nreturn {}.foo()\nIt seems like what this is doing is unrolling bested _MemberExpression_s. So maybe the loop condition should rather be\njs\nwhile (calleeValue.get('object').node.type === 'MemberExpression')\n?\ncc @iamdustan who wrote this code. Maybe adding a comment about what exactly this does would be useful \ud83d\ude09 \n. @rtsao, what's the progress or your thoughts on this?\n. Seems reasonable, thank you!\n. Thanks! This will be resolved with #134 .\n. Thank you! This will fix #125 .\n. Good point @danez, I haven't thought about that. However, babylon 6 deviates from the estree spec which also isn't great.\nI'd be curious how much the early proposals are actually used.\n. @danez Any update on that? I started looking into supporting both, babylon and flow, but it's a bit of work. Having babylon produce an estree compliant AST would certainly make this a lot easier \ud83d\ude09 . @danez This looks certainly better than what I currently have to do to make react-docgen work. Thank you!. Sorry for the long wait!. react-docgen doesn't apply any specific treatment to the docblock of propTypes. The raw content is in the description field. You can use any tool of your choice to extract additional information from that.. Yeah, that seems the most reasonable thing to do. Listing every expression that is valid inside a MemberExpression seems cumbersome. I'll merge the PRs one by one to preserve contributions.\nThank you!. Thank you!. Thank you @oliviertassinari! We are waiting until the estree plugin for babylon is ready, then we are going to upgrade to it with the option to use the flow parser as well.. react-docgen completely supports ES6. However it doesn't support many of the newer experimental proposals, such as public class fields, which is what you might be using? Can you please clarify your post?\nAlso see #137 which would solve that problem.. If by support you mean \"can react-docgen parse code that uses arrow functions\", the answer is yes.. That's what I meant when I mentioned in an earlier post\n\nreact-docgen completely supports ES6. However it doesn't support many of the newer experimental proposals, such as public class fields, which is what you might be using?\n\nThis is an example of a public class field, so it wasn't supported.\nHowever, since then we have released v3.0.0-beta which uses Babylon7, which should be able to handle this case! You can install it via npm install react-docgen@next.. In general we don't want to add new handlers that do not cover a core React feature.\nBut that doesn't mean you have to go without such a feature! react-docgen is extensible, so you can build your own handler that provides this functionality.\nHave a look at the current prop doc handler and react-docgen-displayname-handler for an example of an external handler.\nLet me know if you have any questions about it!. > I don't understand what the reasoning is for that\nreact-docgen's purpose is to extract information for documentation purposes. To make it easier to show a representation of the default value, value contains the raw representation. Besides that, react-docgen generates JSON and not every JavaScript value can be encoded as JSON (e.g. functions).\n\nI don't understand how we're supposed to cleanly convert from the \"stringified\" value to a usable one\n\nWhat are you trying to do with that?. I'm closing this since there are no plans to change this behavior in the near future. We might reconsider this in the future.. Sorry, I completely missed that issue. This seems to be a problem with recast. I will see if this can be worked around on our side.. I guess we could special case Object.assign, but a quick solution would be to use:\njs\nParentComponent.propTypes = {\n  ...ChildComponent.propTypes,\n  parentPropA: React.PropTypes.string,\n};\nwhich react-docgen understands (and which is exactly the same).. @bsmith-cycorp: Sorry for not have followed up on this! You are right, static get propTypes() doesn't work but it definitely should. Feel free to open a new issue about this.. Can you give a concrete example and the result you expect? We could certainly special case Object.keys, but only if the passed value can also be statically resolved to an object literal.. react-docgen doesn't analyze code across files... however, depending on what exactly you are doing with react-docgen, you could get the list of keys in a different way (e.g. by actually loading that file) and insert the values into the documentation object that react-docgen produces.. Yeah, that's what I meant when I said that we could special case Object.keys(<resolves to object literal>) being passed to .oneOf.. Sorry for the late response! This is an interesting situation. Since Object.create(null) is used it is not necessary to call obj.hasOwnProperty().\nI think that this is better solved in React Styleguidist by using something like Object.prototype.hasOwnProperty.call(obj, ...).\n\nIn my understanding Object.create(null) is unnecessary here and just {} would work fine but I may miss something.\n\nThe point of this is to create a completely empty object that doesn't contain any other properties (e.g. toString etc) and that isn't impacted by possible modifications of Object.prototype.. Ah sorry, got confused about where the problem is. But yes, to-ast would be better off changing this because :\n\nOther input passed to to-ast might cause the same issue\nIn theory, hasOwnProperty can be overwritten, so accessing hasOwnProperty directly is not considered the best practice\n\nObject.create(null) and the hasOwnProperty check in the loop kind of try to solve the same problem, but on different sides (producer vs consumer).. Closing this since this should be fixed upstream.. Thanks @AoDev! However, I think this is better solved in styleguidist by using something like Object.prototype.hasOwnProperty.call(obj, ...).. > It does not break in styleguidist but rather in a third party dependency on\nwhich one may or may not have control.\nYeah, I realized that now (see the issue).\n\nWouldn't this break a lot of code relying on this, although valid?\n\nProbably yes. I think this is a funny situation though: One could argue that the whole hasOwnProperty check is already a workaround for exactly the problem that Object.create(null) solves: Avoiding that properties \"bleed through\" the prototype chain. In a perfect world there would be no need to use hasOwnProperty in this situation.\nHowever, the best solution, on our side, would probably be to use Map instead.\n\ninstead of checking for hasOwnProperty now, should everyone starts checking if the object has a prototype although it's perfectly valid.\n\nNo, I think fewer assumptions need to be made about objects. Ideally hasOwnProperty would be moved the Object or Reflect, but it should also be used sparingly. Looking at the prototype (chain) or making any assumption about the prototype chain defeats its purpose IMO (i.e. the consumer should only care about what properties an object has but not how it provides them).. Awesome! Yes, making the parser configurable was the idea because flow doesn't support everything that babylon supports. However, we could probably also just merge this PR to finally get support for new flow types.\nHow does prettier let you specify parsers?. Ah I see. Yeah, that's exactly what I had in mind (we do pretty much the same thing in jscodeshift).\nThank you for this!. So, it's not coming in v6.16.0?. Should we just merge this? I have no problem using a beta version. We could release it as a beta/next version as well, so people could start testing it.. I merged this into the v3-dev branch and will release react-docgen@next shortly. Even though switching to v7 shouldn't break anything, it's a big enough change that a major version bump seems appropriate.. Looks fine to me!. We do have the findAllExportedComponentDefinitions resolver. Doesn't that work for your use case?. @redak105, react-docgen only focuses on React components. If you want generic documentation for functions or classes you have to use another documentation generation tool.. Closing this since there hasn't been any activity.. I assume this is also an issue with the parser version we are using. Hopefully this will be fixed once we can merge #158 .. Yes, this is a known issue. The parser that react-docgen is using doesn't currently support newer flow syntax. See #125, #137 and #158. A fix for this coming closer and closer.. Thank you for that! Overall I'm not very happy with the current solution, but I cannot think of an elegant alternative. The ideas that I had were to either add parameter that disables the \"module origin\" check or that allows you to define the \"React\" module(s). While that's flexible its also kind of annoying to have to pass such an option.\nMaybe having a configuration file for react-docgen would make this less of an issue.\nIf you have a suggestion I'm happy to hear about it. For now, we'll stick with what we have \ud83d\ude09 . Yeah, this is available in the beta version. See https://github.com/reactjs/react-docgen/releases/tag/v3.0.0-beta1. I will look at it over the weekend!. Merged as d9782c8a5d6750e35a8fc665bc446c02c9e027c7 . Will release a new version soon.. Released v2.16.0! v3 beta will follow.. Thanks!. We are simply not recognizing React.Children.only. In that case, there is no workaround, sorry \ud83d\ude15 \nThe quickest way to get this fixed would be open a PR that adds a check for React.Children.only here: https://github.com/reactjs/react-docgen/blob/61a3c1c02a20855ba4bac578ca02ad1986d5e1a9/src/utils/isStatelessComponent.js#L35 \ud83d\ude09 \nSolving #107 needs some more work though.... Fixed via 34ab2aef215e2c557a25e952540ed868334dd349 and released as part of v2.14.0 and v3.0.0-beta3.. Nope, everything looks good, just didn't get the time to publish a new release. Doing it now \ud83d\ude03 Thank you!. Publish in v2.14.0 and v3.0.0-beta3.. Thank you!. Publish in v2.14.0 and v3.0.0-beta3.. Have you tried using the v3 beta (might not work, just curious)?. da97fc6973d9cea1f52f7b334f82f1501997b886 made a change to use preset-env with Node v4 as target (instead preset-es2015). Sorry for that! We could switch back, but of course we to transpile as few code as possible. Usually I would recommend to perform your own transpilation if you need to run it in an unsupported environment.\ncc @danez . I released v2.14.1 with @danez' changes. Let me know if that works for you!. Thank you!. That seems reasonable to me!. @KamranAsif, just lack of time! Will get to it tomorrow.. react-docgen only looks at files in isolation. It doesn't know that Button inside hello-button.js is a React component.\nWhat would you expect the result for hello-button.js to be? It shouldn't be difficult to write a custom resolver that finds connect calls.. @threehams: Yeah, I just recently thought about that too. Do you have something concrete in mind?. @FezVrasta: Maybe https://github.com/Jmeyering/react-docgen-annotation-resolver helps you.\nThe general problem is that there is no standard format for HOCs. A possible solution is to write custom resolvers and handlers for specific types of HOCs, but these have to come from the community.\nIf you are interested in doing that for recompose, have a look at the default resolvers and handlers, and how they work. I'm also happy to answer any questions regarding this.. @FezVrasta: The resolver I linked to allows you to do that.. I just restarted the CI build. I failed with a call stack size error, but I don't see why it would.... Published as v2.15.0 and v3.0.0-beta4. Thank you!. react-docgen only looks at files in isolation since it doesn't know how to resolve dependencies. This is basically a duplicate of #33.\nA typical workaround is to process the type definition file separately to extract the type information and join the data yourself.\nThat said, I'm open to suggestions how we could solve this, bearing in mind that the module identifier resolution process must be pluggable/exchangeable.. Which version of react-docgen are you using?. Ah... v2 uses an old Babel version that doesn't understand new flow type annotations. Give the v3 beta version a try!. Can you provide an example of the code, the output you are getting and the output your are expecting?\nI suspect this is a duplicate of #147 .. Thank you for the info! So you expect those public fields to be listed in methods? That's indeed a different issue. I guess we could detect whether the value resolves to a function and include it if it is.. @lensbart , @danez , I think it would be worth opening a new issue for that.\n@jesseko, Thank you for working on this! I have since then worked on fixing this as well. Maybe you can try it when the new version is released and see if you also get call stack errors. If this is the same issue as @lensbart's, please consider opening a new issue and provide information to reproduce the issue, such as component definitions for which it fails.. @lensbart , @danez: Potentially the same issue as #203 ?. I'm not sure what it is exactly that we are supposed to do here. Can you clarify?. @sonsoleslp: You can already do that. The full description is preserved. You can extract the different languages and generate the documentation you want from it.\nI don't see why there has to be support for this from react-docgen, especially since there is probably no standard way to to define the translations.. react-docgen does not follow dependencies. See #33, #73, #180 for similar issues. If you want to get the documentation for SimpleButton, you should pass the file where the Buttons module is defined.. I should probably put this in the readme: You can use the beta version that uses a newer version of babylon which understands the newer flow type annotations. https://github.com/reactjs/react-docgen/releases/tag/v3.0.0-beta4. Hey Nick!\nI don't think it would beneficial to include this into the core. I wouldn't have the capacity to maintain it and it would make it harder for others (you I guess) to maintain it.\nreact-docgen was built with custom extensions in mind, so I think an external package would make more sense, but I'd be happy to make changes to core as necessary to support this case.. That's great @Jmeyering! getMemberValuePath is supposed find specific \"members\" of a component, e.g. propTypes.\nGiven a component such as \njs\nconst GreenButton = styled.p`\n  color: green;\n`;\nit's only possible to add additional propTypes by doing\njs\nGreenButton.propTypes = ...;\n(whether or not that is something that is usually done is irrelevant for this discussion)\nMaybe it would make sense to default any unknown expression to getMemberExpressionValuePath (which would have to be updated to support arbitrary expressions as well) ?. Which version are you using? If you are using the latest public release, try the beta version instead. It uses a newer version of the babylon parser.. OK, I have to spend some time again to see if we can release v3.. Duplicate of #182 actually.. You can take a look at src/handlers/ and src/resolver/ to learn what kind of functions are accept.\nResolvers are functions that take the root of the AST as input and return one or more AST nodes that represent component definitions.\nHandlers are functions that extract information from component definition nodes.\nBoth are briefly explained here: https://github.com/reactjs/react-docgen#parsesource--resolver--handlers .. Merged with fe554856c9cf3250efd450a2fb4a155f69bb5600 .. Thank for this! I think this is fine overall, but please add a test.\nIt might also be worth to add a comment why this was added and maybe add a link to your resolver.\nOnce this all works together, we should list your resolver somewhere, maybe in the wiki.. Sorry for letting this sit for so long (I also was away in between)....\nRegarding testing, you could start by adding tests to getMemberExpressionValuePath-test.js and getMemberValuePath-test.js. Something like\n``js\n describe('TaggedTemplateLiteral', () => {\n    it('finds \"normal\" property definitions', () => {\n      var def = statement(\n        var Foo = foo`bar`\n        Foo.propTypes = {};\n      `);\n  expect(getMemberExpressionValuePath(def, 'propTypes'))\n    .toBe(def.parent.get('body', 1, 'expression', 'right'));\n});\n\n});\n```\nand\n`js\n  it('handles TaggedTemplateLiterals', () => {\n    var path = expression('foo');\ngetMemberValuePath(path, 'foo');\nexpect(getPropertyValuePath).toBeCalledWith(path, 'foo');\n\n});\n```. So, the type is not picked up? Can you provide a complete example please? Which version are you using?. Thank you! I'll take a look.. You have a typo in your code.\njs\nTest.propsTypes\nshould be\njs\nTest.propTypes\n//      ^^ no s\n\ud83d\ude09 . Which version are you using?. Could you try the v3 beta version and see if that solves the problem for you?. OK, seems to be a mismatch with the parser and recast then.. Actually, after seeing the stack trace, it's an issue in our own getParameterName method. Easy fix!. Sorry for letting this sit for so long. This is great, thank you! \ud83d\ude03 . > Would you consider this is as a bug?\nGood question, idk. Consistency in the output is certainly important. However would it feel strange if the path was using / on Windows?\nI'm not using Windows, so I can't tell if someone would be bothered by this. Ideally, people who use Windows good provide their point of view here.. It's not clear to me what exactly you want. Could you provide an example?. Seems like a duplicate of #107 anyway. Thanks for reporting though!. >  Does the component class need to be exported for the parser to find it?\nIn the default configuration yes. However, we have multiple resolvers that you can use to e.g. find all components defined in a file.. @deedubbu, you could also try https://github.com/Jmeyering/react-docgen-annotation-resolver .. > Are functions that return components (HOCs) not supported at all? \nThey are not, at least not by default. The problem is that there are too many ways to define HOCs.\nHowever, there is also nothing stopping anybody to write specific resolvers and handlers for specific HOCs \ud83d\ude09 . Do you have a stack trace?. You definitely have to use v3-dev, which uses the latest version of babel, otherwise the syntax is not recognized at all. However, that still won't work because react-docgen expects every argument to have a name. I will fix that.. This is fixed in v3.0.0-beta8 now!. That's an easy fix. https://github.com/reactjs/react-docgen/blob/760c426475e21d62f696251775b7f577aef3f349/src/utils/getFlowTypeFromReactComponent.js#L35\nshould be instead\njs\ntypePath = superTypes.get('params').get(0);\nThank you for opening the issue!. Since you know about src/resolver/findAllExportedComponentDefinitions.js now, I guess we can close this?. No worries!. Thank you! Yeah, I can imagine that we have not accounted for such a case.. It looks like we don't support any of the React.* types. We probably have to special case them (cc @danez).\nWhat else do we need to support besides React.Node ?. Mmh, it should: https://github.com/reactjs/react-docgen/commit/d19d73d064cfa804157aa5afe979ba9e1ef8f6cb . This works for me: \nInput\n```js\nimport PropTypes from 'prop-types';\nexport class Greeting extends React.Component {\n  render() {\n    return (\n      Hello, {this.props.name}\n    );\n  }\n}\nGreeting.propTypes = {\n  name: PropTypes.string\n};\n```\nOutput:\n{\n  \"description\": \"\",\n  \"methods\": [],\n  \"props\": {\n    \"name\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"\"\n    }\n  }\n}. Great, thank you all!. How does flow behave when type checking this component? Does it take default props into account?. OK.... the output doesn't tell me much but I tried it on https://flow.org/try and flow doesn't complain about missing props when they have default values, so yeah, we should mark them as optional.. We could check whether a function has children or ...props as destructured parameter. Maybe that helps?. Do you have a suggestion for how we should represent destructured parameters in the JSON output?. Could you provide a complete code example and the output of running react-docgen? Which tool are you using here?. Not needed anymore, right?. If this is about to level unions (which I think the original post is):\nWe have talked about this internally, but it's not clear how exactly we would represent this in the output. Should props be an array instead then? What if flow type annotation and PropTypes are used (the latter not being able to describe unions).\nIf this is about prop-level unions: We should support this if we don't.. Maybe this should be raised with react-styleguide. We could certainly add a silent mode, but it would still be on react-styleguide to enable that mode. Or they should not apply react-docgen to things that are not react components.. Well, the function returned by the module is not a React component. It's a function that returns a React component. Did you expect Button to be documented found by react-docgen?. react-docgen is not meant to run on transpiled code.. Yeah, react-docgen doesn't detect HOCs themselves, it would only be able to detect the component you pass to the HOC. But since you are not passing an actual component, it finds nothing.\nAm I right in assuming that you would want react-docgen to pickup the component returned by wrap?\nI think sometimes people want documentation for the component passed to the HOC, sometimes they want documentation for the HOC itself.\nNot sure how to solve this problem but worth revisiting.. Thank you for working on this! \ud83d\ude03 . Any help is certainly appreciated @jquense!. This is amazing! I love it \u2764\ufe0f \nShould I turn on GitHub pages for the master branch?. OK, I read https://docs.travis-ci.com/user/deployment/pages/ \ud83d\ude09 . Looks like we need to create an new gh-pages branch first, otherwise I cannot enable it for that branch.\nAlso, regarding the personal access token: It doesn't look like you can restrict a token to a specific repository, and I don't really want to create one for my personal account and add it to a travis config that can be accessed by other people.\nIs the only solution to create a new user?. Ah I didn't see the token. Makes sense! Looks like gh-pages is activated in the settings, but http://reactcommunity.org/react-docgen doesn't work.. Switching to master and back to gh-pages seems to have worked!. I'm all for reducing the number of dependencies, but we also use recast's ability to resolve identifiers to their value expressions, i.e.\nhttps://github.com/reactjs/react-docgen/blob/master/src/utils/resolveToValue.js#L156\nIt would be good to compare the differences between the Typescript and Flow ASTs. I'd assume that recast provides some abstraction over them, but not sure.. Thank you!\nI would slightly tweak the statement to something like\n\nBuilt-in resolvers are available....\n\nThe function can (and should) be used with custom resolvers. I don't want to create the impression that only resolvers shipped with react-docgen can be used.. There is no error when I paste the code here: http://reactcommunity.org/react-docgen/ .. Since those are just simple functions, you could likely just use jsdoc to generate documentation for them.\nNot sure whether this needs to be included in react-docgen itself.... So, I figured out what the issue is: The CI environment has a babel config file in its root that gets picked up. However, the necessary packages are not installed (and I can't get them to).\nI'd like to disable loading the babel config file from the file system and I thought babelrc: false would do that, but it doesn't seem to work? Am I missing something here?. Thanks, I have figured that out now as well \ud83e\udd23  So many options.... Not sure if ignoring local config files is a common enough issue to have a command line flag for.... We may have a different understanding of what \"parsed\" means here. When I create a component with that method in http://reactcommunity.org/react-docgen/, it parses just fine. E.g. try this:\n```js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nvar foo = {\n  bar: PropTypes.number,\n};\nexport class Tiger extends Component {\n  static get propTypes() {\n    return {\n      ...foo,\n      name: PropTypes.string,\n    }\n  }\n  render() {}\n}\n```\nHowever, react-docgen does not resolve dependencies.. That's because Test doesn't pass the heuristic used to determine whether a function is a React component or not. A quick workaround would be to use \nreturn <>{props.children}</>;\n\n@danez, any thoughts on extending the heuristic? Test.contextType is a give-away, but it may not always exist. Should we actually add support for marking functions as react components via a tag (i.e. @react or something), to have a simple escape hatch?. Mmh, do we have to introduce resolveToCallExpression? My approach would have been to just extract the path from ExportDeclaration that we are interested in, and run resolveToValue on that. \nThoughts?\n. Looks good so far. One remark is actually covered by a typo in this test :D (note the missing e in React.creatElement.\nSeems like it accepts any function which calls another function as react component.\n. See above, that would consider any function that calls another function as component. Is that intentional?\n. We wouldn't need to traverse deeper if we already found our answer. You could just return false; to indicate that the traversal is done for this node.\n. Mmh, that would also consider foo in \njavascript\nfunction foo() {\n  return function bar() {\n    return <div />;\n  }\n}\nas React component, i.e. any function that contains JSX is considered to be a React component. I wonder if we can narrow this down more.\n. In your test? You'd also have to add var React = require('react'); to the test code.\n. :+1: Really appreciate your effort :)\n. I don't think we need this, do we? What case does this capture which isn't captured otherwise?\n. I think this should be handled by the other visitors since methods are just represented as function expressions in the AST.\nOn Oct 7, 2015, at 12:51 PM, Dustan Kasten notifications@github.com<mailto:notifications@github.com> wrote:\nIn src/resolver/findAllComponentDefinitions.jshttps://github.com/reactjs/react-docgen/pull/28#discussion_r41437429:\n\nrecast.visit(ast, {\n-    visitFunctionDeclaration: statelessVisitor,\n-    visitFunctionExpression: statelessVisitor,\n-    visitProperty: statelessVisitor,\n\nI added this as part of supporting some of the permutations also being added to gaearon/babel-plugin-react-transform; namely this format: https://github.com/gaearon/babel-plugin-react-transform/pull/34/files#diff-9d6f6ff3fa6b5b63c09190bd7a2efb95R15\nHonestly I\u2019m not sure if that is captured or handled correctly yet. [:innocent:]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/reactjs/react-docgen/pull/28/files#r41437429.\n. This is done right? (because we use a different way to resolve this information)\n. Unfortunately this is not useful test, because the displayNameHandler function will never be passed a VariableDeclaration.\nIf you look at getMemberValuePath, you can see the node types which represent component definitions:\n```\nvar LOOKUP_METHOD = {\n};\n```\nFor some of them, inferring the name is easy: You can simple take the id of named classes and functions.\nFor all others, you need to traverse up the tree to find and assignment or export and inspect that one to get the name.\nHere is how getMemberExpressionValuePath does it: https://github.com/reactjs/react-docgen/blob/9042c91d6b9e787f4fa49a96b7be0babb256fd3c/src/utils/getMemberExpressionValuePath.js#L36-L45\n. See my comment above :) (which should make this a non-issue)\n. I guess this should be \"dispayNameHandler\".\n. Ah, I think this should be return false;, but it's too late now anyway since I already published a new release :D\n. option: getOptional(tag) will add the property anyway. I mean, the property will disappear when converted to JSON, but it will still be on the JS object.\n. I'm wondering if this shouldn't rather be something like {name: 'union', value: ['string', 'Object']}. What do you think @janicduplessis?\n. Seems like you need to change this type annotation to Array<NodePath>.\n. Shouldn't this not throw as well?\n. What would we have to do to make this work?\n. Overall I like it, but this, which I guess is what you were referring to, worries me a bit. This almost seems like too much magic (no pun intended wrt to your user name ;) )here.\nIn general I think the handler should be able to detect these cases:\n``` js\n// Assignment to variable\nvar foo = ;\nfoo.propTypes = ...;\n// Assignment to property\nfoo.bar = ;\nfoo.bar.propTypes = ...;\n// In both cases we should be able to detect aliasing\nvar bar = foo; // = foo.bar;\nbar.propTypes = ...;\nsomething.else = foo; // = foo.bar;\nsomething.else.propTypes = ...;\n```\nThis is going to be a bit more elaborate I think. It basically requires us to \n- remember in which scope a component was defined\n- look for assignments of the variable or member expression to another variable / member expression in that scope\n- look for assignments to member expressions where the object is either the original variable / member expression or one of its aliases.\n. Couldn't we just call process.exit(1) here?\n. Well, that rule is more targeted towards arbitrary modules. From the docs:\n\nThis is a dangerous operation because it can occur in any method at any point in time, potentially stopping a Node.js application completely when an error occurs. \n\nSo, using it in the executable file itself is completely valid :)\n. You can always disable the rule for just that one line ;)\nBut yeah, I guess this is OK.\n. Tiny typo here SpreadElements. This might actually be the culprit. The value of callee for the CallExpression is Identifier, which doesn't have an object field: http://astexplorer.net/#/gist/2830b1b852ac298dab2f18802133afdf/ec06e05ba93e93903bb7c85a1bd6a12622d41918 .\nI think you can do resolveToModule(path) here, that should solve the issue.. The pattern should be anchored: \n/^\\/(.*)\\/([igymu]{0,5})$/;\n\nOtherwise it looks fine to me!. Doing this here seems weird to me. I wouldn't expect getNameOrValue to be called with with a type annotation (but who knows...). It's also not quite right, since some FunctionTypeParam do have a name.\nPersonally I feel it makes more sense to fix this in getFlowType. If the name of the FunctionTypeParam is null, assign an empty string instead. Something like\nname: param.node.name ? param.node.name.name || '';\n\n@danez , why does this use getProperty to extract the name at the moment? Shouldn't it directly by getNameOrValue(param.get('name')) or just param.node.name.name? \nAm I looking at the wrong syntax tree or am I missing a case here?. So this takes the variable name used in the spread syntax, right? Did we plan to use the module name instead at some point? I can't remember.. Alright. @danez: I originally thought that anything that's local wouldn't be of interest to someone reading the documentation. But who knows, maybe it's useful for the person that generates the documentation.. I wonder if we can consolidate this even more since I guess nodes of type ObjectExpression and ObjectTypeAnnotation are very similar. At the very least, can we extract an array of key names for them and process that?. Does the file name have an erroneous space between the . and the rest of the name?. ",
    "wincent": "@fkling: Note I actually lied about everything passing. The new file you added has some failures, but they're unrelated (I didn't touch that file) and they already use arrow functions:\n```\n FAIL  bin/tests/react-docgen-test.js (6.84s)\n\u25cf react-docgen CLI \u203a it reads from stdin\n  - TypeError: Incorrect value of args option\n      at normalizeSpawnArguments (child_process.js:952:11)\n      at Object.exports.spawn (child_process.js:984:38)\n      at Spec. (/Users/glh/code/react-docgen/node_modules/jest-cli/node_modules/jasmine-pit/index.js:32:38)\n      at Timer.listOnTimeout (timers.js:110:15)\n\u25cf react-docgen CLI \u203a it writes to stdout\n  - TypeError: Incorrect value of args option\n      at normalizeSpawnArguments (child_process.js:952:11)\n      at Object.exports.spawn (child_process.js:984:38)\n      at Spec. (/Users/glh/code/react-docgen/node_modules/jest-cli/node_modules/jasmine-pit/index.js:32:38)\n      at Timer.listOnTimeout (timers.js:110:15)\n\u25cf react-docgen CLI \u203a it writes to stderr\n  - TypeError: Incorrect value of args option\n      at normalizeSpawnArguments (child_process.js:952:11)\n      at Object.exports.spawn (child_process.js:984:38)\n      at Spec. (/Users/glh/code/react-docgen/node_modules/jest-cli/node_modules/jasmine-pit/index.js:32:38)\n      at Timer.listOnTimeout (timers.js:110:15)\n```\n. Yep, this is Node v0.12.0; to be honest I hadn't even considered the version (I'm just using what Homebrew gave me).\n. ",
    "morlay": "I got the same error on Node 0.12, seems just the issue of Jest. on 0.10 it works well.\n. @wincent So you need the https://github.com/creationix/nvm\n. Thanks, @fkling.\nThat is cool.\n``` javascript\nimport docgen, { resolver , handlers } from 'react-docgen';\nimport _ from 'lodash';\nimport fs from 'fs';\nconst src = fs.readFileSync(__dirname + 'example/components/Component.js');\nconst defaultResolver = resolver.findExportedReactCreateClassCall;\nconst handlers = [\n    handlers.propTypeHandler,\n    handlers.propDocBlockHandler,\n    handlers.defaultPropsHandler,\n    handlers.componentDocblockHandler,\n    (doc) => {\n         // custom handler\n        .forIn(doc['$Documentation_props'], (propObj, propKey)=>{\n            .merge(propObj, docgen.utils.docblock.getDoclets(propObj.description))\n        })\n    }\n];\nconst docs = docgen.parse(src, defaultResolver,  handlers)\n```\nSo we can use it is like this  ( it is not easy to find the use case without reading the source code. :-) )\nHowever, with this version,  we have to put the default resolver and default handlers manually.\nAnd for the custom handler, could we use --handler option to append something to the default handlers?\nThen, one more question,  for custom resolver. If someone use ES6 module,  the two default resolvers will not working. I'm not sure can understand the way to define it clearly. is there more details about it ?\nThanks again. \n. This is so cool. ( And the AST is really new for me ).\nA wonderful way to pick doc information from code. \nThanks. \n. Cool. I feel we are not necessary to write like that.\nWith react-docgen's help, we can get docs so easy, in my last projects. \nSo I put the docs tool in my testing repo (preview)\nRecently, we need to update to ES6, that why I try to make the update for react-docgen. \n. Sure, seems we can change here with \njs\npath = resolveToValue(path.get('declaration'));\nand add the conditions to resolveToValue\njs\nif (types.VariableDeclaration.check(node)) {\n    return resolveToValue(path.get('declarations', 0))\n  } else if (types.VariableDeclarator.check(node)) {\n     if (node.init) {\n       return resolveToValue(path.get('init'));\n     }\n  }\nI will push another commit to update the change. \nhowever, I feel the resolveToValue need to do some refact when we added a lot of conditions.\nThanks.\n. ",
    "banderson": "@fkling Is this something that's already underway? I can lend a hand if needed, this would be huge for me.\n. Ok, great, I'll see what I can do.\nFor those who need this ASAP and want a clue of where to start, I spiked out the minimal functionality I needed here. This just covers allowing ES6 style imports and default exports. Hopefully I can eventually flesh out the remaining details and get it merged in here.\n. @fkling I got React.createClass recognition for ES6 default exports and ID'ing React in ES6 import statements in just that small change linked above. This works well for my use cases. Now I'm working on PropTypes recognition for using named imports (e.g. import React, {PropTypes} from 'React';) and in restructured assignment (let {PropTypes} = React;).\nBefore this is done, we'd need to ensure all import export cases are covered, and tests for all the existing cases :/ Glad to help out as much as I can, would welcome help from anyone else that knows more use cases if they exist :)\n. ",
    "woodb": "Ah sweet! I didn't see the markdown generator. Sphinx prefers reStructuredText, so maybe the most reasonable way to implement this would be to simply make a generator that produces rST... I'll try my hand at it and keep you apprised, thanks.\n. Thanks @fkling, closing this one following the creation #8.\n. Super cool @pwexler! Wish it was on GitHub though :) I'll definitely check this out, I think we can close this issue @fkling in light of @pwexler's project...\n. ",
    "pwexler": "shameless plug:\nYou might consider using docutils_react_docgen\nhttps://pypi.python.org/pypi/docutils_react_docgen\nnew version  0.1.0 coming today or tomorrow with ability to\nInfer CommonJS module name if bower.json or package.json is available\n. thanks for your support.  just released 0.1.0 - with CommonJS module name support.\n. ",
    "pvolok": "Babel also supports this:\njs\nclass Foo extends React.Component {\n  static propTypes = { ... }\n}\n. ",
    "theogravity": "+1\n. You are the man! :D\n. Yay, thank you! Will try over the weekend\n. Confirmed working! Thank you!\n. Sorry, just read through the entire project README. Looks like support is there to extend docgen to support this use case, just need to build the resolver for it. \n. Thank you :D\n(Hope you've checked out the react-styleguide-generator issue I have, it has screenshots of what I'm trying to do with react-docgen!)\n. Thank you so much, was able to obtain the displayName\n. Thanks for the prompt response!\n. Thanks!\n. Thanks!\n. ",
    "jherr": "+1\n. Is there an option for +10,000? ;-) Thanks Felix!\n. Weird, though sadly not surprising.\n. Works great! Thanks!\n. Yes. :-) Thanks for a much better bug report.\n. We do the _ as private thing, but I'd be happy to just write the ignore code on the consumption side. Or you could have an option for ignoreUnderscoreMethods or something. Your code, your call. \n. :+1:\n. ",
    "silentrob": "+1\n. ",
    "mfunkie": "npm install after deleting node_modules/ didn't work, and I even checked to see if my react-docgen global was out of date just in case the npm script was not using the local node_modules/.bin to no dice.  After that I tried deleting the repo and re-cloning which still did not work.\nI suppose if you cannot reproduce, it's fine to close this bug, but I just cannot get the docs task to fill out the description.\n. That's the only one I'm getting when running the task.  I know it's at least successfully completing because deleting docs/docs.json and re-running gets me all of the Components, just none of the descriptions.\n. Node version: v0.10.29 (Note: Just upgraded to 0.12.2 and tried to no luck)\nnpm version: 2.7.0 (Note: Just upgraded to 2.7.4 to no luck)\nOS: OS X Yosemite.3\nShell: fish (Note: I switched to bash and tried to no luck)\n. Found the issue that updating caused a fix.  My line endings were set to Windows for some reason, and changing them to Unix style started letting Descriptions funnel through.\n. Yeah that looks like the one.  When you're checking for *\\n, does that first asterisk come from the second * in /** ?\n. So maybe something like \ncomment.value.match(/^\\*(\\r|\\n)/).length\ninstead?\nI'm sure there's a way to match unicode in regex, I just haven't done it in a long while.\nEdit: from what I understand, it might look like\ncomment.value.match(/^\\*(\\u000A|\\u000D|\\u2028|\\u2029)/).length\n. Yup, that sounds better.  I'm running into node issues when testing, so it may be a while before I can get in a pull request on that running.\n. It worked pretty well when I ran the code change locally, I just couldn't get testing to run properly on my machine so I put it on the back burner and made sure all my line-endings were Unix.  Would love to see it make it in though.\n. ",
    "gonzochic": "Hi,\nim using react-docgen on Windows and I am not able to get the prop type description in. It seems that the changes mentioned by @fkling and @mfunkie have not been implemented in the code. Have there been any issues with the implementation? \n. Ok i will try! Thanks a lot.\n. Hi, \nfor me it is still not working (i updated it to recast 0.10.32). Maybe it is because of the ES2015 Syntax? \nHere is my example code:\n``` js\nimport React from 'react';\n/*\n * General component description.\n /\nexport default class DocTest extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return null;\n  }\n}\nDocTest.propTypes = {\n  /*\n     * Description of prop \"prop1\".\n /\n  prop1: React.PropTypes.string.isRequired\n};\nDocTest.defaultProps = {\n  prop1: 'default'\n};\n```\nand as a result of the react-docgen script i get:\njson\n{\n  \"description\": \"\",\n  \"props\": {\n    \"prop1\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": true,\n      \"description\": \"\",\n      \"defaultValue\": {\n        \"value\": \"'default'\",\n        \"computed\": false\n      }\n    }\n  }\n}\nAs you can see the description is not taken from the React Component. Do you have any hints on this issue?\n. ",
    "facebook-github-bot": "Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n. Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n. Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n. ",
    "brentvatne": "Thanks! Fixed here: https://github.com/facebook/react-native/pull/1181\n. ",
    "mikeaustin": "I'm using styleguidist which uses react-docgen, but it still outputs \"union\" for Flow types such as (\"foo\" | \"bar\"). Is there a plugin or patch or something to make it list the union types?\nI realize this in an old thread, but if there is an answer, I assume it would be useful to others.. ",
    "scvnc": "Should this feature request include static methods as well?\n. ",
    "aweary": "@fkling any status update on this?\n. ",
    "janicduplessis": "Working on this for the RN website, I'll submit a PR when I get it working there.\n. That's great, I got it to work for React.createClass yesterday also using a mix of reading jsdoc and flow types. I'll probably use your implementation as a base as mine was done using a custom handler directly in the RN website.\nI think the logic for choosing which methods are included should be left to the clients so they can choose their own rules. We just provide all the info they can need (method name, access modifiers from jsdocs). We can just filter react methods.\n. I used tj/dox which does pretty much the same but doctrine seems better as it's doing only what we need and dox is a lot bigger.\n. Submitted the PR! #66 \n. I think that as long as it doesn't break with other docblock styles than jsdoc (does that even exists) it is fine.\nWe could always just return the raw docblock and leave the parsing to clients but I think the flow/jsdoc setup is common enough to parse it by default and adds a lot of useful info like description for each parameter.\n. Good point about annotations, we should definitely return the raw docblock so additional parsing can be done. I think we should still keep the description as it is now to avoid having to remove jsdoc tags that we don't want to show in the documentation.\n. Actually I think I should move all the JSDoc stuff in a separate handler and only extract the docblock in componentMethodsHandler. Then I can make a jsDocMethodsHandler that parses the docblock and add type, return and params info so the most common case works well out of the box and users can implement other handlers that parses the docblock again to add their specific use cases. What do you think about that?\n. @danez I think I addressed most of the things you pointed out.\n- Separated the methods extraction and jsdoc parsing in 2 handlers.\n- I'll leave printing the function declaration in another PR later to add more functionality like default values and optionals.\n- The jsdoc types are now used if there are no flow types.\n- Added support for @return and @returns.\n- Added a raw docblock prop.\n- Removed the visibility prop as I think it's not as commonly used and we can have users parse it from the raw docblock.\n. @fkling Could you make a new version on NPM? I'd like to start integrating this on the react-native website :)\n. Thanks @fkling! I just submitted a PR (#72) to address some minor issues I found when integrating it with the RN website. 2.8.2 maybe? :)\n. It should be possible to get the name of the type Identifier before resolving the flow type. Here's the relevent code for params and return value\nHere's what the ast should look like https://astexplorer.net/#/SSIvYwuj5V. We can probably look for GenericTypeAnnotation and then get it's Identifier name and add this to the returned type object.\nLet me know if that makes sense :)\n. I think we should keep name as it is and add this as another property like alias or whatever name makes more sense :)\n. Looks good to me, there is an issue with the PR though, it includes a bunch of unrelated commits.\n. @fkling Good writeup! \nIf you want to go the keep it small route and extract out component method docs into a separate package I can take care of it. I'd also like to help out but I don't have much time at the moment :(.\n. constructor is removed here https://github.com/reactjs/react-docgen/pull/66/files#diff-04ad70c13ed9a5e61df9714b19011b37R51\n. I agree, the gist you linked supported that. I'll add it.\n. Good idea, will add.\n. This would be nice but like you said it could be in another PR to keep this one reasonable in size. I actually haven't tested destructuring in parameters, I'll see what it does at the moment.\n. I agree we should keep this as an object since it's easier to use after. We should try to have a similar output object as the flow type definitions.\njs\n/**\n * @param test Test\n */\nfunction (test: string | Object) {}\nand\njs\n/**\n * @param {string | Object} test Test\n */\nfunction (test) {}\nshould result in the same thing.\nYou could take a look at what the object we return for flow types look like and return something similar.\n. ",
    "danez": "I have a working version for es6 classes, although I think it is not ready to integrate, because it is a mix between reading jsdoc and flowtype.\nWe also use jsdoc annotations to see if the method should be included in the docs (@api present, and not @private or @protected) and not start with _.\nhttps://gist.github.com/danez/ed81356bc04dc60a59b4\n. In the gist the parsing of jsdoc is missing i noticed, but basically it just uses eslint/doctrine to parse the docblock.\n. Cool, I have a look starting next week, when I'm back in town.\n. The same idea would also apply to flow types, as they can be also imported. So maybe this \"import something\" could be abstracted in a way so it makes imported propTypes and flowTypes possible.\n. react-docgen@v2 uses babylon 5 and that will not change. We also have a beta version v3.0.0 which uses babylon 7, you can try that.. just install with npm the latest beta\nnpm install react-docgen@next\nInstalling the branch directly won't work, as there are build steps involved when releasing.. I tried flow itself before, but the ast it delivers is nearly the same as the one from babylon. The only current drawback with babylon is that imported/required types or types which are defined as libs for flow, cannot be resolved. But I also don't know how one would do that with flow. That might be a future addition if someone finds a way to do that.\nI'm nearly done with all the codechanges. I probably might refactor smaller pieces, but I think there wont be large changes anymore.\nI will now start updating the readme and add a section about flow, and what are the differences to propTypes. As flow offers more granular types, the results (except primitive types) are a little bit different.\n. Yes squashing everything was the plan. :)\n. Do you think that the flowHandler should be part of the default handlers?\n. Ok I am done from my side, as far as I can see.\nThe only remaining question is if the flowTypeHandler should be part of the default handlers (currently it is)? This probably depends on how you want to release this feature: With this enabled by default I would think it is more a 3.0 version (as it could generate different output than before for people), whereas if it is not enabled by default, then it could be 2.7. But thats up to you @fkling .\nIf you want me to change things pls tell me.\n. First of all flow- and propType-handlers don't conflict with eachother. Having both active is not a problem. The only \"problem\" that could arise is if people use both propTypes and flow in their components. In that case one of the handlers (depending on the order) would overwrite the other one.\nBut even if they don't conflict, I like the idea of having a --flow option in the cli, which adds the flow handler to the defaultHandlers if set and disables the propType handlers.\nFor the api people can build their desired set of handlers anyway on their own.\nIf thats all okay, I add that?\n. Okay I added the cli option.\n. But then you end up having defaultValues under props and the types + description under flowProps which to me is a little bit counterintuitive.\nI was thinking about something similar: Having the flow type under flowType inside the props object, next to type. The only question then is what to do about the description, maybe flowDescription although that sounds confusing to me.\n. That seems a reasonable approach. React-docgen could also warn if there are multiple descriptions found.\n. Ok i changed the flowType from type to flowType.\nAnd both docgen handlers respect each other and don't update the description if already set, but trigger a warning.\nI removed the cli option again and added flowTypeHandler and flowTypeDocHandler to defaultHandlers.\n. You were right about the type<->flowType thing in the readme, I did not regenerate it with the latest changes. Done now.\n. And yes you are right, the required field is also set by the flowTypeHandler, although I think this is less critical than the type itself i would say. \nIn case someone really uses both propTypes and flow, the type can be completely different, but the required field should be the same, And I think it would count as a bug in the components if you specify a prop as required with propTypes but not with flow or the other way around.\nDo you think it is worth adding a check if the other handler already added the required field?\n. Thats true. There is also a note in the readme about this unresolvable types.\n. Okay I removed them now.\n. @fkling If there are bugs coming in, feel free to ping me.\n. Ok I rebased, thanks\n. :+1: \n. I haven't tested it yet, but looked through it and added some comments. \nOn thing I noticed is that annotations which are not evaluated in the handlers are completely swallowed right now (for example we use a lot @example), and as the raw docblock is also not there, one would currently need to parse the file again, to get the remaining jsdoc-annotations. But providing them in an array would even more lock-in react-docgen to jsdoc and the format that doctrine uses, so I wouldn't do that. For consistency with the react-compnent I would say to have the raw description in there is probably the best, so one doesn't endup parsing the file a second time.\nBut the @param and @return tag still add a lot of good information to params, so maybe we could  also leave this parts in there, but just change the description to be the raw description?\n. That sounds like a good plan. :+1: \n. Awesome, looks good to me. I hope I have time next week to try it out. I can then also make additional PR to add missing edge cases if I ran into any.\n. Closing as react dom factories are not supported anymore.. I'm currently out of town for 2 weeks, but will have a look as soon as I'm back and fix the exception.\nProbably react-docgen won't be able to extract the correct types in this case, as parts of them are imported.\n. Travis is too slow to run the tests for the cli and jest does not forward the test timeout currently. Waiting for an answer here facebook/jest#1090\n. There is still no new version of jest, and I couldn't figure out how to change the timeout without the fix.\n. I increased the timeout now to 120s as everything (well 30s and 60s) below was not working. The tests with node4 and npm2 are terrible slow on travis.\n. Yeah I really can't figure out why the tests should be 100 times slower than node 5 or npm3. If i use npm 2 locally it is a little bit slower, but not thaaat slow.\n. Yes the tests are currently failing on node 6. #81 will fix that\n. \ud83d\udc4d \n. This has been merged with #118.\nThanks a lot.\n. I thought I fixed that in #78, at least intersection and union types, which is used here in the test. It might still fail if one does type Props = string;. \nGive me a minute.\n. I created a new PR that generalizes the fix done in #78 so it can also be applied to the flowTypeDocBlockHandler.\n78 was only fixing the flowTypeHandler, either I forgot the other handler or it was added afterwards.\n. Dang, didn't see there is already a PR for this (#106). Seems the tests on npm@2 sometimes fail, because they take too long. I was wondering if jest is maybe compiling the node_modules, but they should be ignored by default. So its probably babel that is slow on npm@2 and makes the worker crash/timeout.\n. this was fixed with #106\n. damn, I should really look at other commits before creating a new one.\nActually I like #97 better. Gonna add some comments to it and close this one.\n. @mike-robertson Yes, nothing happened here since it was opened. We are all a little bit short on time. If you want feel free to open a PR.. fixed in 3.0.0. With which node version do you have the problem? As far as I see it was fixed in node 0.12.\n. Thanks, yes I can reproduce this.\nReading more about writing to stdout I found this in the docs:\n\nThe process.stderr and process.stdout streams are blocking when outputting to TTYs (terminals) on OS X as a workaround for the operating system's small, 1kb buffer size. This is to prevent interleaving between stdout and stderr.\nTo check if Node.js is being run in a TTY context, check the isTTY property on process.stderr, process.stdout, or process.stdin.\nFor instance:\n$ node -p \"Boolean(process.stdin.isTTY)\"\ntrue\n$ echo \"foo\" | node -p \"Boolean(process.stdin.isTTY)\"\nfalse\n\nSo as you are piping we are not in a tty anymore which makes the stream write non-blocking and the process.exit() immediately afterwards might interrupt the writing.\nInstead of doing this draining logic, I would more lean to remove process.exit() from line 98 and 110 and replace the first one with process.exitCode = 1;. The process is ending after the output anyway, I don't see a need to manually do the exit call.\n@fkling What do you think?\n. Integrated in #260.\nThanks for your work.. But with this we will loose the ability to parse early stage proposals, which babylon supports, so babylon 6 could be a valid alternative here.\n. @MoOx react-docgen is using babylon 5 which does not support newer flow features.. What we were also discussing some time ago in the babel slack, if it would make sense to have an option to create estree compatible output (at least for stage-4 syntax) from babylon. This could then at least help the effort to have exchangeable parsers in react-docgen and one of them being babylon6.. Yes I started on that already, but will need more time babel/babylon#277. Yes you can try install react-docgen v3.0.0-beta5 which includes the latest babylon version.. I close that for now, we can get back to this if we want to have exchangeable parsers.. Thank you.. What if we just simply do:\ndiff\n@@ -102,7 +102,7 @@ function returnsJSXElementOrReactCreateElementCall(path) {\n             resolvedValue = resolveToValue(calleeValue.get('object'));\n           }\n           else {\n-            while (calleeValue.get('object').node.type !== 'Identifier') {\n+            while (calleeValue.node.object) {\n               calleeValue = calleeValue.get('object');\n               namesToResolve.unshift(calleeValue.get('property'));\n             }\nAll tests (including the ones from this PR) are all working, and not hanging.\nI'm not 100% sure about if the logic is then still correct, but I hope this is tested properly.. I created a new PR with your commits, plus some changes that it exits the loop as soon as it hits a non-MemberExpression node. What do you think?. Thank you so much for doing this :). I'm not sure when the exponential operator was introduced in babylon, but it might be that babylon 5 has not support for it. This is one more reason to decide for a solution on this: #137 . This is expected right now, afaik. value always contains the raw value, if it is a string also with quotes, bool will be a string containing true, number a string with the number 1,...\nAlso if you look at the Readme the structure says that defaultValue->value is always a string.\n. We probably want to merge this with #137 and make the parser configurable (Maybe similar to prettier)? I think @fkling had already plans for this.\nCan also work on this if we can agree how it should work.\n//cc @wbinnssmith. Prettier has this file: https://github.com/prettier/prettier/blob/master/src/parser.js\nand in the options it can be specified which parser to use. So still limited to flow/babylon, but one can choose between those two. They probably did this, because babylon (still) does not understand all flow features.\nI would wait with merging till the next 6.x release is out (today/tomorrow), which has the same estree functionality as this beta version. (https://github.com/babel/babylon/blob/changelog-6.16/CHANGELOG.md). The problem is, that babylon 6 also renamed some flow nodes for some odd reason. We now renamed them back to the same names that the flow-parser uses, but this change will only land in 7.0. Cool thanks. This should be fixed in 3.0. This will be in 3.0.0. Duplicate of #33 . Uppss, I thought react docgen was already requiring node4 at least. I go ahead and revert the breaking change for 2.x. but I would leave it for 3.x. Duplicate of #33. @lensbart Thanks for the investigation. Which version of react-docgen are you using? 2.x or 3.0-beta?. Thanks. react-docgen right now can only parse javascript and not typescript. There might be a way in the future as babylon - our parser - is getting typescript support, but right now there is nothing we can do here.. I this still a problem, I'm not able to reproduce this anymore with the latest version.. How do you run react-docgen? When I try this example it works just fine. Maybe react-styleguidist is doing some magic there?. Feel free to make a PR.\nWe should also make sure it works also with old and new flow versions.\nsomething like this.\njs\nconst params = superTypes.get('params');\nif (params.value.length === 3) {\n  typePath = params.get(1);\n} else {\n typePath = params.get(0);\n}. I created a PR which fixes this #209. It is released now as 2.18.0. Do you have an error? Or are the docs incorrect?. Babylon 5 - which is used by react-docgen v2 - does not support * (The flow infere operator, or whatever it is called :) ). You will want to use react-docgen v3-beta, but I haven't released a new version of react-docgen v3-beta with the flow-react fix yet as I had some test issues. I wanted to investigate later.. Thanks for the PR.\nYou could probably solve your problem by using one of the other resolvers react-docgen ships with:\nhttps://github.com/reactjs/react-docgen/tree/master/src/resolver\nAlso described in the CLI docs: https://github.com/reactjs/react-docgen#cli. This was already fixed.. I added a PR for this, it was fairly easy to add.. Thanks again, I add nullishCoalescingOperator and pipelineOperator as I finally managed to update babylon.. This was done in #227 . The first parameter to the parse function is the sourcecode and not a path.\nYou would need to do something like this:\nparse(fs.readFileSync('./src/Table/Table.js'));. Sorry for the late reply, this looks overall good, to me. The only thing I'm not sure is that this right now would hardcode the behaviour. I don't see a reason why anyone would not want to have this, but who knows. So maybe it would be better to make it a prober handler and add it as the last one. I guess that should work too?\nSome tests would be necessary.\nAnd targetting the master branch is totally fine, I can pick stuff to the v3 branch after it is merged as long as there are tests that verify it works. :)\nNice work.\n  . I merge this now as is, I think having it hardcoded is okay for now. We will see if someone complains about wanting to disable this behaviour. If so we can still convert it to a handler without having todo a major version.\nThanks for your work.. I posted already in #227, seems this fixes some printing for casts too though. #227 has been merged and I picked the other changes here: a893dec3ea9ef565a029357d70e7cc496d0cb77c. Yes right now we rely on the fact that a component returns jsx. Because we only want to generate documentation for react components and not for helpers , utils or code only containing business logic.\nWe need to figure out a better algorithm to detect react components, especially stateless.. I cannot reproduce this. Which version are you using? Are you sure this error comes from react-docgen? How do you use react-docgen?. We have tests that verify that this works. https://github.com/reactjs/react-docgen/blob/55bbefed8321d535e53786b684708bd618cc15fb/src/utils/tests/getPropType-test.js#L74\nSo not sure why this does not work in your case. Do you have a complete repro case?. Please try using react-docgen@v3.0.0-beta. It should fix the issue.\nversion 2 uses an outdated parser that does not understand this syntax.. Thank you very much. lgtm. I merged #240, could you please rebase?. Why did you decide to do it in 2 different ways? Once with inheritedProps and once with a inherited flag?. Looks good to me now. So you now changed it to use composes? That sounds really good to me. Should we try to align the other PR? composes and importedProperties... or do you think this are different usecases?. Okay I can also otherwise merge it . Sorry for the delay I'm really busy lately, but now off work for this week, so have more time. . This is fixed in c81a4bc98cb5dff48da0dc2e300270f2bd178586\nWill make a new release soon.. Thanks for reporting this. I was easily able to reproduce and fixed the issue in #251 and #252.\nWill release a new version soon.. Please try using latest beta version of 3.0.0 which should support the new syntax.. You have to do \njs\nimport { parse } from \"react-docgen\";\n...\nparse(src). Thank you. Thanks. Can you please be more specific what \"doesn't recognize\" means? \nYou get a parser error? If so can you please add the error message.\nOr do you receive an output that you would not expect? Then please add the output of react-docgen that you think is wrong.. Thank you very much.. Which version react-docgen are you using? I just tried to reproduce but all of these examples work for me on the latest v3 beta version.. Please try using v3.0.0-beta. I could not reproduce the error with the latest beta. I also added a test to ensure it works.. I guess if the cli keeps working as it is right now, abstracting more stuff out into reusable parts is very good.\nThanks for the effort \ud83d\udc4d\n. dogeData: PropTypes.arrayOf(PropTypes.shape({\n    /**\n     *  The dataKey will pull out the number from this key\n     *  and the number will be summed according to it's key, \n     *  then divided by the largest keyed sum from the data array.\n     */\n    [PropTypes.string]: PropTypes.number,\n  }).isRequired,\nI'm not sure, but I have never seen this construct before. Are you sure this works correctly?\nAlso briefly looking at the source of the prop-types package does not reveal that computed object keys will work.. Yeah it probably does not happen in v2 but does happen in the v3 beta. But good to have the check anyway.\nThank you very much.. Oh sorry. I think the next version will be the final 3.0 anyway.. This should work as of 3.0.0-beta10. Which version of react-docgen are you using?. Can you provide a complete example of the file? I tried recreating the issue but when I add any of the methods you provided to to a react class it works fine.. Can you please provide an example and a full stacktrace? Otherwise there is no way we can help.. Thanks for the example, I fixed the issue in #286. {[type]} was not supported.. Thanks for reporting this. I'm on your side and think that running the parser on different OS should trigger the same output.\nI will have a look. It might be that this a bug in the Parser we use. Will keep you posted.. > I also noticed that the handleKeysHelper was resolving this to a union:\n\nconst obj = { a: 'a', b: 'b' }\nconst test: $Keys<obj> = 'a'\nWhich I don't believe is correct. See this example on the flow online repl. I removed this functionality and the associated test.\n\nSorry for the late reply. Thanks for working on this.\nI think we should leave the resolving of simple Identifiers in, as for example this could work:\njs\nconst obj = { a: 'a', b: 'b' }\ntype A = typeof obj;\nconst test: $Keys<A> = 'a'\nThis should resolve correctly to the same result as if doing an inline ObjectExpression, but currently returns unknown. But this is an other problem we can fix separately, but let's leave the resolving of $Keys<A> in for now and it's test. Other than that looks good to me, ready to merge.\n. Thank you very much.. can you please try version 3.0.0-rc.1. It includes #286 which fixed a problem with jsdoc stuff.. Thank you. Thanks for your PR.\nIn my last job we did exactly the same and did tag our components. :)\nI think it is a really nice feature, but I wouldn't include it in the core of react-docgen. You could create a separate repository and publish it to npm similar to for example: https://github.com/siddharthkp/react-docgen-external-proptypes-handler.. Thanks. Thank you very much for this. This looks great. Feel free to create more PRs :). PropTypes.shape is supported. What might not be supported is importing proptypes. You might want to look at https://github.com/siddharthkp/react-docgen-external-proptypes-handler which might solve your problem.. please add an example. hmmm I'm not able to reproduce this. I tried the example on latest master and on rc.1 and both parse successfully.\nThis is what I tested:\n```js\nimport React from 'react';\nexport default function Spinner({ className, ...props }) {\n  return ;\n}\n```. We released 3.0.0-rc.2, it has the latest version of recast and babel and some fixes. Let me know if that makes it any better.. Thanks. Thanks. It seems we do not support this yet. PRs welcome.. Fixed by #318 . I think there is no reason behind this. Maybe it did not exist when PropTypes were implemented here.\nFeel free to create PR and add it, as you say it should be straight forward to do, as it is similar to shape.. Added in 52ae1f4. Thanks. Thank you.. This was fixed in #311 and 3.0.0-rc.2. Can you try with this version?. Thanks. The best option would be to use \nrequire('@babel/core').parse(...)\nAs this will pickup the babel configuration that is present in the project. With some sane fallback config (basically what we have right now).\nExposing the config would be good I guess, I think I already do it for the decorators plugin.\nTypescript support would be awesome.. @jquense I agree with @fkling and you do not necessarily need commit access to start working on new stuff. I'm not sure what Felix thinks, but I think we are pretty much open to most changes that can be considered generic core functionality and help the community. \nAnd introducing typescript support would be a huge win and I'm happy to help with reviewing or answering questions. You can usually always find me in the babel slack https://babeljs.slack.com/. Would you consider this is a non breaking change? I wonder if I should create new branch for 4.x and merge that in there or if it is fine to be in the next release as new feature.\nI can see that it might break for people that have their config not setup correctly and suddenly certain parser plugins are not active anymore. But I do not think this should be a common case.. \ud83d\udc4d. Yeah, we could create a a parserOptions flag that contains whatever the parser accepts. and we supply that to the parse function.\nI'm not sure what babel would do internally, but I think it will merge config files with the supplied options where as programmatic options take precedence.. After thinking more about it, I think I would do the next version with this PR as 4.0. I ran into breaking changes myself while building the website (https://reactcommunity.org/react-docgen/). I started creating it before this PR and then merged it afterwards which broke the webpack build because @babel/core uses fs which needs to be mocked away for browser builds. This wasn't the case before as @babel/parser has no dependencies.\nAnyway I guess it is not a big deal to do a major version and then we are on the safe side even though for most users it shouldn't be a breaking change.. Which version of react-docgen are you using?. Thanks for reporting I was able to reproduce this.. After inspecting, there is not really a problem. The confusion with the example comes because foo in that example has a default value. Props with a default value are never required even if isRequired is set. The problem is more, that the definition of the component is wrong. One should not use isRequired and then define a defaultValue.\nI will fix the example.. Travis will create the branch on the first deployment I think. \nI already added the token to travis, it is not visible to anyone. I also don't know the token anymore, after adding it all I can do is remove it, but never view it.\nLet me fix that file. I can merge afterwards.. I created the gh-pages branch myself so it should be able to activate. The deployment does not yet work. Seems the changes to master since I branched for this PR make the build fail.\nI will investigate.. Maybe it takes some time?\nDoes it look like that? This is for react-tabs which is setup exactly like here.\n\n. Ah I think I remember. It only gets published once there is a new push event on the branch, let my quickly commit something.. Hmm not sure why it isn't published. Maybe this could help: https://webapps.stackexchange.com/a/104559 Basically it suggest to switch to master and then back to gh-pages.\nOr cloudflare which seems to be setup for reactcommunity.org caches 404s. In that case we just have to wait till the cache expires i guess.. I can do it tomorrow. . Okay I released it a 4.0.0.. Maybe it would also be possible to remove recast all together. The only reason why we use recast I guess is because we print some of the input code into the raw fields. see also #237.\nBut anyway typescript support would be nice and I think @jquense wanted/is working on that.. If you add a dependency in your project you cannot simply call its binary in the library from your commandline. If you install it globally it should work if everything is setup correctly https://yarnpkg.com/lang/en/docs/cli/global/#adding-the-install-location-to-your-path.\nIf you installed the dependency in the project this is what you can do to run it:\n\nYou can use yarn react-docgen --help to run the cli\nYou could directly call the cli from its location ./node_modules/.bin/react-docgen --help\nIn your package.json scripts you can directly use the binary because yarn/npm do correctly resolve them, for example:\n\njs\n{\n  ...\n  \"scripts\": {\n    \"docu\": \"react-docgen --help\"\n  }\n  ...\n}. Thanks.. react-docgen in 3.0.0 changed to use the new decorators proposal be default. Which in retrospect was a big mistake as it is already abandoned and a complete new specification exists.\ud83d\ude44\nBut anyway, in order to fix this issue you are having, you probably will have to wait till https://github.com/styleguidist/react-styleguidist/pull/1288 is merged and released. In the latest version of react-docgen we now correctly read babel configs, which in your case would enable the decorators-legacy support in your project instead of the \"new-yet-abandonend\" decorators proposal.\nI'm sorry for the inconvenience.. maybe this will also help @fkling with this problem https://github.com/reactjs/react-docgen/commit/60196fc30f6ed9ff79e0c241edc10ba4fc4758cc#comments?. > Project-wide configs can also be disabled by setting \"configFile\" to false.\nIf you use babel.config.js this applies.\nhttps://babeljs.io/docs/en/config-files. I think this should be (tag.title === 'returns' || tag.title === 'return') as 'return' is the synonym.\n. maybe we could add here type = type || returnTag.type? Then the type from the tag yould be used if no flowType is there and the type is specified in the tag.\n. Same here, maybe us the type from the tag.\n. We could add that later, but for the usecase we have we would also need a flag requiredand the defaultValue. This should not be too hard... but when I think more about it, this could get tricky with parameter destructuring and/or rest parameters. But that could be an additional PR.\n. Not really necessary, but a raw representation of the method declaration might be a nice to have, because if you want to display it in the documentation it is probably kinda hard to reconstruct from all the different properties.\n. Should we add constructor here? Not sure if there is a case where the constructor could be needed in the documentation.\n. I'm not sure if that is always a wanted behavior. If you have code that looks like this:\n```\n       class Foo {\n          foo(bar: StatusBarStyle) {}\n        }\n    type StatusBarStyle = Array<{blub:string}>\n\n```\nYou might want to know that the type is Array and not StatusBarStyle. Even with $Enum I might tend to say that $Enum is the type-name and not the title of the alias.\nBut it would be really cool (in the case of aliased types) to always have both names, the alias and the resulting type in the doc. Because both might be super useful to display.\nThe current changes would also be breaking ones.\n. I agree now, that generating props from union types is more tricky and a bad idea like it was before, but imho it would be better to just ignore the type instead of throwing an exception. People should not be forced to restructure their code just to get the docs working. If I think of my companies huge codebase, this might break the complete docs even if it's just one component that has an union type.\n. I think most of this imports above are unused.\n. good catch. The test wasn't executed because of wrong nesting. Fixed it.\n. This depends on how exactly we want to go for this. Quoting the flow docs:\n\nA union type requires for a value to be one of the input types.\njs\n/* @flow */\ntype U = number | string;\nvar x: U = 1;\nx = \"two\";\nAn intersection type requires a value to be all of the input types:\njs\n/* @flow */\ntype I = {a: number} & {b: number};\nvar x: I = {a: 1, b: 2};\nx = {a: 1, b: 2, c: \"three\"};\n\nSo intersection was quite straight forward, just merge all objects and the result is the object with all possible props.\nWith union this is more complex. In this example, one can see that when using union for prop-types it is one of the objects to be \"unioned\" (with additional properties allowed).\nSo in the simple case of \ntype U = {a: number} | {a: string, b: string};\nThe resulting docs would need to be: \"prop a is required and needs to be a number, or it is a string but then also b is required and needs to be a string\"\nThis might make sense in some react components, but I'm not sure yet how we would document this cases. We maybe could only add the raw value.\nP.S.: I might be mistaken here, but I think it should be correct. Never used union and intersect in these cases myself. :)\n. This message is not there anymore and I think it is nice to have.. path was not an option but an argument\nfrom the help with nomnom:\nUsage: react-docgen [path]... [options]\nSo this option would be new, and is also unused.\nseems that [FILES] is the equivalent to [path]. As mentioned above this probable can be [path]. What do you think about instead of using '_' setting the field to null? It seems clearer to me that a consumer of react-docgen checks if the name === null instead of a \"random\" string name === '_'. Hmm yes seems it is used quite a bit. We could maybe return an empty string? Then !name would work in the resulting documentation.\nMy intention is just that we should return something else than a non-empty string, because in the '_' case you would not be able to differ if the variable name was _ or empty.\nAnd consumers could still default to _ in the empty case, if the do not display shorthands.. Good question, I have no idea :) But seems unnecessary as it can never be computed or be a literal. \nDoing name: param.node.name ? param.node.name.name || ''; should be correct in getFlowType unless the tests disagree.\n. Out of curiosity: What is this doing?. I think it is not really clear what this is just from the json alone. It could be also interpreted as \njs\ntype a = { OtherProps: OtherProps };\nWhat i would try to do is resolve OtherProps and if it resolves to an other ObjectType within the same file then I would just inline this in the result. We do the same when resolving stuff here https://github.com/reactjs/react-docgen/blob/master/src/utils/resolveObjectKeysToArray.js#L59..L67\nIn the case when it cannot be resolved I'm not sure what the best approach is. We could either ignore the spread completely then, which we currently do for regular non-type ObjectSpread. Or somehow add a special field in the output aka \"inherits\" (or some better name) which just contains the names of the Type that was spreaded into the object. If I think about it spreading types is just some kind of multi inheritance and it is probably interesting to know. \njs\n{\n  name: 'signature',\n  type: 'object',\n  includes/inherits/implements/??: [ 'OtherProps' ],\n  signature: {\n    properties: [\n      { key: 'a', value: { name: 'string', required: true } },\n    ]\n  }\n}\nNot sure if that makes sense though.\n  . I see, thanks for explaining.\nYeah in my company we also dropped flow, because it was too hard to keep up and we had to add lots of workarounds and rewrite code just to make flow happy\n  . I like that. Not sure if the local identifier is worth having in here too, \njs\n{ \nmodule: 'bar',\nname: 'BarType',\nlocal: 'Foo'\n}. That makes sense, because the ultimate goal of react-docgen is to describe the props of react components and not the complete AST of js files. So as long as we have all the information we should add them to properties I think.. or compose like in the flow PR? From a purely react perspective, I think composes makes a lot of sense. When describing the props it could (very unlikely) also be a global that gets spread into the props, where this name then does not make sense. (Btw we should add a test for spreading a global variable, which has no declaration in the scope). Can you elaborate in which example exactly it is not adding the required field? Because in this example it is now twice, because we already add the required field in the prop object. see line 82.. I guess this function must not necessarily be exported?. can you now please change this to ^7.0.0. Is that on purpose?. opppss. Can we escape the pipe in the union somehow or use an escape sequence?\nIt is currently treated as table separator.. ",
    "levithomason": "Would love to see this as well.  As a temporary work around, you can place the decorator above the docblock:\n``` jsx\nimport {Component} from 'react';\nimport Radium from 'radium';\n@Radium\n/*\n * This is a box for checking.\n /\nclass Checkbox extends Component {\n  //...\n}\n```\nRadium continues to work in the component and the generated doc json contains the docblock description. This was tested using webpack and babel.\n. Ditto.  I'm also wondering if this may actually become a plugin in light of #115.\n. If it is of any interest, there are some jsdoc parsers out in the wild that may save duplication of effort.  \nEslint built doctrine for the valid-jsdoc and require-jsdoc rules.  I tried the demo with the multiple example above and got:\njson\n{\n    \"description\": \"\",\n    \"tags\": [\n        {\n            \"title\": \"example\",\n            \"description\": \"Some instructions.\"\n        },\n        {\n            \"title\": \"example\",\n            \"description\": \"Some other instructions.\"\n        }\n    ]\n}\nThere are others as well, though in my estimation doctrine is the best and most maintained.  Cheers!\n. > When/where...\nA gulp plugin.\n\nI don't see why react-docgen should depend on an external tool...\n\nI originally followed this comment on #5.\nThanks for clarifying the purpose of getDoclets.  Hindsight from here is clear, I'll use something like doctrine instead.\n. :+1:\n. @mik01aj Thanks for the suggestion.  I ended writing a gulp plugin that leverages react-docgen and eslint/doctrine for docblock parsing.\nAs for examples, we're writing and rendering our examples as regular React components.  For the code snippet, we use webpack's raw-loader to read the text and highlight it with react-highlightjs.  This is working pretty well for us so far.\nEDIT\nThis is great because the example code snippets are written in their native format (rather than a doc string, or markdown).  What is rendered is exactly what the consumer will use, including import statements since each example is it's own module.\nYou can see this result on the doc site for TechnologyAdvice/stardust.\n. While is it slightly more concise in terms of line count, it does have some down sides.  It requires duplicating prop names and keeping those in sync.  It also moves the descriptions further away from the actual code.  A plugin does make sense.\n. @fkling any way we can get this merged for now?  possibly add more info about the module later?  It is currently breaking our doc build.\n. Super fast, thanks much!\n. This would be great.  Would love to see a plugin oriented ecosystem around react-docgen.  Would these plugins (handlers?) allow someone to write something to resolve imported props as in #33?\n. I'm also getting does not match type Printable errors.  Seems the cause is using a function as a defaultProp value:\n``` jsx\n// import { Modal } from 'src/modules'\nConfirm.defaultProps = {\n  as: Modal,\n  cancelButton: 'Cancel',\n  confirmButton: 'OK',\n  content: 'Are you sure?',\n}\n```\nWhere as is a Modal stateless functional component.  Prior to adding this defaultProp, we had no react-docgen errors.\n. OK, it is actually due to using an imported value in default props.  This PR fixes it https://github.com/reactjs/react-docgen/pull/99.\n. @ritz078 this issue should be resolved now that #99 is merged, albeit waiting for a release.\n. Nice!  Testing :D\n. Confirming imported defaults now work, very much appreciated @fkling.\n``` jsx\nimport { Checkbox } from '../../modules'\nRadio.defaultProps = {\n  as: Checkbox,\n}\n```\n. ",
    "browniefed": "@fkling thanks for looking into that, I couldn't figure it out, sorry about the mis-logged issue.\n. ",
    "chrisui": "To clarify here are a few examples:\nEx 1. Firstly the destructuring pattern should be supported.\n``` javascript\nstatic propTypes = {\n  prop: PropTypes.string\n}\n// yields {type: {name: 'string'}}\n```\nEx 2. With the above the [x].isRequired would be a common pattern we can extract.\n``` javascript\nstatic propTypes = {\n  prop: PropTypes.string.isRequired\n}\n// yields {type: {name: 'string'}, required: true}\n```\nEx 3. Custom function prop-types should be supported.\n``` javascript\nstatic propTypes = {\n  prop: PropTypes.record(User)\n}\n// yields {type: {name: 'record', value: 'User'}}\n```\nEx 4. Again, .isRequired pattern should be honoured.\n``` javascript\nstatic propTypes = {\n  prop: PropTypes.record(User).isRequired\n}\n// yields {type: {name: 'record', value: 'User'}, isRequired: true}\n```\nEx 5. Function pattern will support nested types.\n``` javascript\nstatic propTypes = {\n  prop: PropTypes.iterableOf(PropTypes.record(User))\n}\n// yields {type: {name: 'iterableOf', value: {name: 'record', value: 'User'}}}\n```\nEx 6. To confirm, these custom props can be used deeply.\n``` javascript\nstatic propTypes = {\n  prop: PropTypes.iterableOf(PropTypes.oneOf([PropTypes.record(User), PropTypes.bool])\n}\n// yields {type: {name: 'iterableOf', value: {name: 'enum', values: [{name: 'record', value: 'User'}, ...]}}}\n```\nNotes/thoughts:\n- Custom enum syntax is not needed as standard oneOf covers any possible usage of this.\n- .raw should still be present on the type object\n- This output implements a breaking change now that name: 'custom' has gone.\n  - Can't see this as being an issue as .raw still exists and consumers can still do the same stuff\n  - If this is an issue we could just have a new .customName property.\n. That is correct.\nIf you agree also:\nWe would also accept a single variable/method reference. Ie.\n``` javascript\nstatic propTypes = {\n  prop: validationFunction\n  // or\n  prop: validationFunction(props, propName, ...) {}\n}\n// yields {type: {name: 'validationFunction'}}\n```\nisRequired is the only special case property name where we stop looking further I think. Which results in the following behaviour:\n``` javascript\nstatic propTypes = {\n  prop: Types.isRequired\n}\n// yields {type: {name: 'Types'}}\n```\n. My last comment may be a second iteration though looking at the time I have available ;)\n. This was exactly what I was just thinking of as well. Not unreasonable to expect users may want to have more granular namespacing\nI think we take the last property of the chain for now and we can see what use cases come up. .raw will always be there for manual inspection anyway.\nI'll get to work!\n. Any quick pointers to get me going quicker will be appreciated :P\n. ",
    "mik01aj": "@Chrisui this is a great spec, thank you! Do you have any progress on this?\n. @levithomason maybe you would consider using a tool like react-styleguidist that reads your examples from Markdown files? I personally like this approach more. Otherwise you might end up with huge comments in your source code, like here...\n. @fkling, yes! (I know the question wasn't to me, but I'd love to have it this way :))\n. Maybe you could just use this plugin: https://github.com/gajus/babel-plugin-react-display-name\n. @fkling thanks, I missed this description, sorry!\n. About extensiveness: I think JSON schema could help. Then you would be able to verify that the JSON you return is really what you specified, and tool debelopers could use json-schema-random to generate examples and thus make them more reliable.\n. ",
    "chaseadamsio": ":+1:  thank you. This is an awesome project.\n. ",
    "iamdustan": "I notice you have class components normalize to static propTypes rather than <ES6-style properties. I suspect I\u2019ll need to the propTypeHandler to also read from <ES6-style properties for stateless components unless you have any other ideas.\n```\nfunction Component (props) {\n  return ;\n}\nComponent.propTypes = {};\n``\n. I\u2019m currently working on extending thegetMemberValuePathto alsogetMemberExpressionValuePath` and see how far that takes me. I think it\u2019ll only need to handle variable declarations, function expressions, and function declarations. This should avoid needing an new interface and will continue building on the early design decisions :)\nAll of my API transformation projects have terrible design decisions. And be \u201cterrible\u201d I mean \u201cno\u201d.\n. Well....I think this is actually working now.. :open_mouth: \n. hmmm....not quite working, but close.\n. Alright, fixed my final commit. This is now working for stateless function components in my current codebase as expected :)\n.  @fkling I probably have until EOD to finish this up then will have to bow out for a while. I want to prioritize supported use cases versus not supported use cases. This is the known issues ordered by what I think the priority should be. What do you think?\n- isStatelessComponent is too loose in saying true. Should scope this better (high priority)\n``` js\nconst NotAComponent = () => {\n  const Component = () => React.createElement('div', null);\n  const AlsoAComponent = () => React.createElement('div', null);\nreturn {Component, AlsoAComponent};\n}\n```\n- hash of components (low/no priority)\n``` js\nconst bag = {\n  Component() { return React.createElement('div', null); },\n  AlsoAComponent() { return React.createElement('div', null); }\n};\nbag.Components.propTypes = {\n  /*\n   * Hey I'm a string\n   /\n  foo: PropTypes.string.isRequired\n};\n``\n. Also e4c867ce1524222734ef0a9daa4a01623f8caee4 is of note for theintegration`-style test proving that is indeed working correctly. :)\n. > isStatelessComponent is too loose in saying true. Should scope this better (high priority)\nI have a couple ideas to try. The first is just to filter on all ReturnStatement\u2019s in the body of a possible stateless component and detect if it\u2019s a ReactElement. Though I\u2019m not certain if these will be considered valid components off-hand. +@spicyj if I need to account for those. I don\u2019t think they are at current..\njs\nconst IsThisAComponent => null;\nconst IsThisAComponent => 'string';\nconst IsThisAComponent => 7;\nconst IsThisAComponent => [<div key=\"first\" />, <div key=\"last\" />];\nThe weakness is this will definitely fail for the following permutations:\n``` js\nconst Component(props) {\n  if (Math.random() > 0.5) return ;\n  else return ;\n}\nconst Component(props) {\n  return (Math.random() > 0.5) ?  : ;\n}\n```\nAlternatively I could do some scope crawling and ensure that JSXElement and React.createElement are in not in a nested scope. This would handle the following case:\njs\nvar HOC = (options) => {\n  const Component = (props) => <div />\n  Component.propTypes = {};\n  return {Component};\n}\nSadly, I think that to be totally accurate we\u2019ll need to track all possible return values and ensure each is a JSXElement or React.createElement. E.g. lookup return values for both truthyFunc and falsyFunc in the following example:\njs\nconst truthyFunc = () => <div />;\nconst falsyFunc = () => <span />;\nconst Component = (props) => props ? truthyFunc() : falsyFunc();\n. thanks @spicyj. I\u2019ll punt that until 0.15 :)\n. @fkling this now supports a pretty wide array of use cases. It\u2019s not quite as bullet proof as I\u2019d like, but this is all I have within me for now. Let me know what you think and if you want to block on anything.\n. @fkling I\u2019m good here unless you come up with additional code examples that fail. A thorough review to undo the cobwebs I\u2019ve created over the past week could likely help clean up the code in here.\n. Another thought I had while adding so many use cases was: do we even want to support all the possible ways to do stateless components for this? The idea of these stateless function components is for simplicity. Documenting only a subset of these could help encourage folks to keep things simple.\n. :thumbsup: can\u2019t slow me down! https://github.com/iamdustan/react-docgen/tree/stateless-components-dist :)\n. Friendly ping for review. \n. I\u2019ve been using it without issues since the PR was opened so it feels generally safe to me. It shouldn\u2019t cause any regressions on createClass or extends React.Component so it should be fine with just a minor, IMO.\n. Woohoo! Made it. Thanks!\n. wait. does the displayName already appear in there?\n. I don\u2019t think it does... this is the result of console.logging\ndocgen.parse(fs.readFileSync('./my-component.js'))\n{ description: '@private',\n  props:\n   { to: { type: [Object], required: true, description: '' },\n     name: { type: [Object], required: true, description: '' } } }\n. Hmm..\nso I have stateless components not getting a displayName as well as\n```\nimport React, {PropTypes, Component} from 'react';\nclass Tabs extends Component {\n  ....\n}\nexport default Tabs;\n```\n. :+1:\n...does babel still follow that approach for displayName handling?\n. I vote @mik01aj for those one :)\n. Wahoooooo! Thanks @danez and @fkling!\n. Huge :thumbsup: to both proposal ideas, @fkling. I\u2019m not certain what you would want or expect from me, but I\u2019m on board for helping share the load a bit more on this. For getting the ball rolling I suspect we should work with #93 and #98 to move these out to individual handlers.\nIf we created a good workflow and documentation for plugin developers through that process I think the biggest bottleneck would be removed. Then a few of us will just need to watch the repo to help triage and point issues in the correct direction.\nMany FB-led projects are driven by FB needs. How much will FBs internal approaches influence this that additional maintainers may not be aware of?\n. Hey, this was a long time ago :innocent:\nI was out of town last week and only have a couple days around this week and next week; so it\u2019ll probably be 3 weeks before I will have time to get my brain back into this for realsies.\n. After looking through both of these a bit more I am pretty sure that PR #139 that @tchon just opened is the more robust fix to this.. @flut1 could you include a code sample we could add to the test showing that?. ha, well, the issue is that I accidentally deleted the check to ensure that I was calling createElement in the visitor below so basically everything is matched :innocent: \nI\u2019ve gotten a bit stuck on trying to duplicate isReactCreateClassCall to isReactCreateElementCall which handles ensuring the correct createElement method is called and it looks up to the root import React bit to ensure it\u2019s the real react.\nin src/utils/resolveToValue.js path.scope.lookup(node.name) is always returning undefined.\n. Yeah, I\u2019ve done that to each...well, technically I\u2019ve done import React from 'react'; or import R from 'react';.\nI\u2019m bouncing for dinner, but should have the next push sometime tomorrow with the next set of questions :)\n. Oh! Found my sticking point. Since I\u2019m calling recast.visit(node, {}) in the lcontainsJSXElementOrReactCreateElementCall function I\u2019m losing all of recasts internal state\n. Managed to get through this. Passing the root path instead of path.node didn\u2019t lose state.\n. Yeah, I\u2019ve thought of this as well. After I get through the current cases with detecting propTypes (last step I believe) then I\u2019ll look into maybe doing something like a return value lookup of each function rather than the current heuristic of \u201ccontains JSX or React.createElement\u201d. I suspect this could get a bit tricky or annoying or untenable if return value is something imported from another module, though. I intend on not supporting that :)\n. I added this as part of supporting some of the permutations also being added to gaearon/babel-plugin-react-transform; namely this format: https://github.com/gaearon/babel-plugin-react-transform/pull/34/files#diff-9d6f6ff3fa6b5b63c09190bd7a2efb95R15\nHonestly I\u2019m not sure if that is captured or handled correctly yet. :innocent: \n. This function for this isn\u2019t quite recursive enough. While all of these resolve as expected, the following two cases do not resolve correctly yet:\nconst ComponentG = function(props) {\n  var nested = {\n    helpers: {\n      comp() { return <div>{props.children}</div>; }\n    }\n  };\n  return nested.helpers.comp();\n};\nconst ComponentF = function(props) {\n  var other = () => <div>{props.children}</div>;\n  var helpers = {\n    comp: other\n  };\n  return helpers.comp();\n};\n. Here is my failing test case for the bag of Components. I\u2019m not terribly worried about this right now, personally.\nxdescribe('Stateless Component definition: in an Object', () => {\n    test(`\n      import React, {PropTypes} from \"React\";\n      /**\n      * Example component description\n      */\n      let components = {\n        Component(props) {\n          return <div />;\n        }\n      };\n      components.Component.displayName = 'ABC';\n      components.Component.defaultProps = {\n          foo: true\n      };\n      components.Component.propTypes = {\n        /**\n        * Example prop description\n        */\n        foo: PropTypes.bool\n      };\n      export default components.Component;\n    `);\n  });\n. the bag of components still fails. I\u2019m personally okay with this for a first iteration and if folks open an issue about it then it can be tackled.\n. This works like a champ.\n. Why yes I do believe it is!\n. ",
    "sophiebits": "@iamdustan Those aren't currently valid components but will be (at least the one with null) in 0.15.\n. (FB-only context for why I ended up looking at this: https://fburl.com/zbfp3cl0.). ",
    "bartvde": "@fkling where do I find the findAllReactComponents resolver?\n. Ah thanks, a github search did not find this one, probably because I searched for findAllReactComponents.\n. Thanks I managed to resolve my issue per your suggestion.\n. @tizmagik I'm using a small script, here is the code snippet:\n```\nvar reactDocs = require('react-docgen');\nvar fs = require('fs');\nvar path = require('path');\nvar generateMarkdown = require('./generateMarkdown');\nvar dir = 'js/components/';\nvar output = 'docs/api/';\nfs.readdir(dir, function(err, files) {\n  if (err) {\n    throw err;\n  }\n  files.forEach(function(file) {\n    if (path.extname(file) === '.js' || path.extname(file) === '.jsx') {\n      fs.readFile(dir + file, 'utf-8', function(err,src) {\n        if (err) {\n          throw err;\n        }\n        var componentInfo;\n        try {\n          componentInfo = reactDocs.parse(src, reactDocs.resolver.findAllComponentDefinitions);\n        } catch(e) {\n        }\n        if (componentInfo  && componentInfo[0].description !== '') {\n          var name = file.split('.')[0];\n          var markdown = generateMarkdown(name, componentInfo[0]);\n          fs.writeFileSync(output + name + '.md', markdown);\n        }\n      });\n    }\n  });\n});\n```\n. Ah thanks, that's what I meant, what tools do people use to render this specific JSON structure.\n. Ah I guess this is an issue in the generate markdown script instead\n{ name: 'arrayOf', value: { name: 'number' } }\n. I made a small change to the generate markdown script, can supply a PR if needed\n\n. There is an issue though that is in react-docgen, this \nbookmarks: React.PropTypes.arrayOf(React.PropTypes.shape({\n    name: React.PropTypes.string.isRequired,\n    description: React.PropTypes.string.isRequired,\n    extent: React.PropTypes.arrayOf(React.PropTypes.number).isRequired\n  })).isRequired,\nwill result in:\n{ name: 'arrayOf',\n  value: \n   { name: 'shape',\n     value: { name: [Object], description: [Object], extent: [Object] } } }\nSo the type of React.PropTypes.shape sub properties is not determined.\n. @fkling can you point to any of the other markdown implementations that you know of?. ",
    "tizmagik": "@bartvde do you mind sharing where you landed with this? I'm having a similar issue and can't seem to use the component found by findAllComponentDefinitions()\n. @rtsao that looks very useful! Was a PR ever submitted for this?\n\nTo support multiple (or an arbitrary number of) call expressions or arguments it seems like one would need to go down a rabbit hole.\n\nMaybe naive, but would it be possible to recursively resolve the \"right\" hand side expression until you reach a React class or undefined? \n. ",
    "AlanFoster": "Babel will generate the display name for you when it is not supplied explicitly. \n:+1: to implementing a similar inferrance rule to react-docgen\n. @iamdustan Would this be something that is feasible to implement?\n. ",
    "NogsMPLS": "I would love for react-docgen to be able to infer the name of a component based on the Component.name.\nBabel only creates a displayName for the .createClass() convention, not for the es6 classes or stateless functional components.\nI'll dig around react-docgen today and see if I can figure out a PR that might accomplish this.\n. blah, fail test. ill check.\nedit: ah, okay, test is doing commonjs require, so really just wants one export per file. Makes sense.\nWould breaking resolveName into separate file be cool?\nedit2: I can add some tests around this too if this is considered an okay approach\n. You're talking about mainly updating the displayNameHandler-test.js to handle those use cases right? \n. Almost got this, named exports giving me a little trouble, but I think I should have something tomorrow.\n. The biggest issue I'm running into with Named Exports has to do with Node vs. NodePath.\nBasically, inside getMemberValuePath.js I can get the declaration of the export (i.e. VariableDeclartion/ClassDeclaration/FunctionDeclaration) by doing something like:\njavascript\n//checks if named export, then redefines the componentDefinition to be the export's declaration\n  if (componentDefinition.node.type === types.ExportNamedDeclaration.name) {\n    componentDefinition = componentDefinition.get('declaration').value;\n}\nHowever, once I grab it and redefine componentDefinition to the new declaration, componentDefinition stops being a NodePath and starts being a Node, which screws with about 4 other files that end up using path.node, which, as far as I can tell, only exists for NodePath type.\nI think I can make it work all around, but it's gonna be a bigger refactor than just 1 file.\n. Oh neat, didn't know that ast tool existed. (I'm still pretty new to parsing the AST)\nwell, so, first thing I did was just add a test to displayNamedHandler-test.js, that was simply:\njavascript\nit('infers the displayName with named export', () => {\n    var definition = statement(`\n      export var Foo = function() {}\n    `);\n    displayNameHandler(documentation, definition);\n    expect(documentation.displayName).toBe('Foo');\n  });\nBut of course, that throws an error because the definition type is ExportNamedDeclaration, which getmemberValuePath.js doesn't like.\nSo my line of reasoning was to go one level deeper into the ExportNamedDeclaration AST object where things like VariableDeclaration are defined and use that, but I'm ran into path.node not existing issues.\n. i expect this latest to trip travis-ci. just pushing so i have it up there for now.\n. Was able to get infer name on es6 exports to work on classes, function expressions and variable declarations. (though I had to do some stuff that feels very clunky for variable declaration)\nnow to get exports.name working and we should be there\n. Got a version of infering displayName on commonJS exports working.\nNot sure if I like the solution right now.\nNeed to add more tests around exports and attaching displayName vs. inferring it and make sure the more explicit attaching of displayName takes precedent.\n. Looking at stuff over again today, I decided it's probably best to keep current behavior in regards to an example like:\njavascript\nexport class Foo {\n   static displayName = foo.bar;\n}\nInitially, I was going to try and have it infer the class name as the displayName in that case, but I think the better behavior might be to keep it empty returning as it currently is.\nAll tests are passing, would like a review, especially on how I'm handling immediately exported variable declarations.\nOther than that though, I think this satisfies #30 as far as I can tell.\n. hmmm....tests passed on stable and node 5 but failed on node 4\nIt passes locally for me on Node 4.\nCI looks like it's failing on a file this pull request doesn't touch. Seems like it's maybe a fluke fail?\n. looks like this is what is keeping #97 from passing as well.\nI did a bit of digging and found a jest issue mentioning this:\nhttps://github.com/facebook/jest/issues/595\nThis seems to be an intermittent fail from what I can tell.\nperhaps updating jest from ^12.1.1 to ^14.0.1 might fix, but going up 2 majors should probably be its own pull request.\nIf you think getting jest updated is important, I can work and get a PR in for that.\n. Oh also, I 100% completely understand if this branch/feature isn't something you'd want merged into the main trunk. It solves a problem for my purposes though, so I've been linking to a fork of this for my projects.\nAlong those lines, I'd like to ask your permission for me to create a npm package with this feature included in it so I can stop linking directly to github in a few of my projects.\n. Ah, interesting, I didn't see that post about future of react-docgen.\nyeah I can look into making this into a custom handler. \n. @ZauberNerd nice! Ill check it out sometime this week and let you know\n. @danny-andrews I believe the display-name-handler that @ZauberNerd created does a decent job of covering what this PR was meant to do.\nI know of at least 1 pretty popular repo that is using that display-name-handler plugin: https://github.com/styleguidist/react-styleguidist\nI am going to go ahead and close this PR with the advice that people look into using that plugin instead of anything in this PR specifically.. :tada: :notes: :trumpet: :notes: :tada: \n. squashed and pushed!\n. Hopefully this also fixes https://github.com/reactjs/react-docgen/pull/59#issuecomment-236194249\n\ud83d\ude4f \n. \ud83d\ude2d \ud83d\ude2d \ud83d\ude2d \ud83d\ude2d \nnode 4 env failed, just like the other PRs.\nhard to tell if this is a jest issue or a dependency issue right now. the dependency throwing the error from what I can tell is worker-farm. But that hasn't been updated in like a year, so i can't imagine this has been an issue for that long.\n. Would like a second pair of eyes on this, specifically around path.node.declarations[0].id.name. I'm not sure if I like it.\n. Okay so, I still want to be able to infer the name and assign them as the displayName of stateless functional components.\nWhat would you think about exporting resolveName() from /getMemberExpressionValuePath.js, importing it into displayNameHandler and using that to grab the variable declaration display names?\n. I don't really like this solution, but I'm not sure of how else to get this value while keeping 'NodePath' type intact.\n. ",
    "frontendphil": "+1 :)\n. ",
    "oliviertassinari": "That would be a great feature \n. I had an undefined error when doing\n``` js\nimport reactDocs from 'react-docgen';\nreactDocs.parse(''); // Uncaught TypeError: Cannot read property 'parse' of undefined\n```\nIs this usage valid?\n(I'm using webpack and babel)\n. I will try import {parse} from 'react-docgen'; tomorrow. \n. Alright, sorry for the noise! \n. Thanks.\n. Exactly. \n. > Whatever Babel version you are using shouldn't impact react-docgen and vice versa.\nThat's what I though, I'm gonna investigate more on this. \n\nWhat is the Babylon version you are using here?\n\nI'm using the latest release of react-docgen. I'm not using directly babylon.\n. @fkling Thanks for your help! It was indend an issue with my dependences. I had two version of babylon (v5, v6), and my webpack config wasn't resolving the good one :grin:.\n. @danez Material-UI has been relying on the v3.0.0 beta for months now. It's working great.. I guess that upgrading to Babylon 6 isn't straightforward. Thanks for the answer.. I'm closing that PR, I don't need it open. I have made my point.. Material-UI project is looking forward seeing this PR released.\n@danez Thanks for working on it!. @rosskevin I have been applying the fix locally with success. (a week ago with flow 0.53 no 0.54).. ",
    "thebuilder": "I've got a similar usecase, but not using spread when injecting the props.\n``` javascript\n// ILink.js\nimport {PropTypes} from 'react';\nexport default PropTypes.shape({\n  url: PropTypes.string.isRequired,\n  selected: PropTypes.bool,\n  target: PropTypes.string,\n  title: PropTypes.string.isRequired\n});\n```\n``` javascript\n// MyComponent.jsx\nimport { Component } from 'react';\nimport ILink from './ILink.js';\nimport otherPropTypes './otherPropTypes.js';\nexport default class MyComponent extends Component {\n    static propTypes = {\n        link: ILink\n    }\n    // etc...\n}\n```\n. ",
    "pasupuletics": "Even we stuck with similar use case, any plans to add support for external imports of propTypes, below is our use case.\nconstants.js\njavascript\nconst BUTTON_STYLES = ['A', 'B', 'C', 'D'];\nexport default BUTTON_STYLES;\ncomponent.js\n```javascript\nimport BUTTON_STYLES from 'constants';\npropTypes = {\nkind: PropTypes.oneOf(constants),\n}\nclass SomeComp extends React.Component{\nstatic propTypes = propTypes;\n}\nexport default SomeComp;\n```\nGenerated AST:\njavascript\n'kind': {\n            'type': {\n                'name': 'enum',\n                'computed': true,\n                'value': 'BUTTON_STYLES'\n            },\n            'required': false,\n            'description': 'some description',\n            'defaultValue': {\n                'value': 'A',\n                'computed': false\n            }\n        },\nExpected AST:\nvalue of AST should be as below(which is working fine when BUTTON_STYLES are in same file, but not with import)\njavascript\n'kind': {\n            'type': {\n                'name': 'enum',\n                'value': [\n                    {\n                        'value': 'A',\n                        'computed': false\n                    },\n                    {\n                        'value': 'B',\n                        'computed': false\n                    },\n                    {\n                        'value': 'C',\n                        'computed': false\n                    },\n                    {\n                        'value': 'D',\n                        'computed': false\n                    }\n                ]\n            },\n            'required': false,\n            'description': 'Button has a a different set of `kinds`',\n            'defaultValue': {\n                'value': 'A',\n                'computed': false\n            }\n        }. I have over come this limitation by writing my own custom handler, And would like to thank @benjamn for providing such a wonderful library called recast, which makes my life easy while dealing with AST. And big thanks to react-docgen too.. @reintroducing , Unfortunately I can't share it now, If possible will publish here for sure. . @workjalexanderfox , Here you go https://github.com/pasupuletics/learning/blob/master/react-docgen-external-proptypes-handler.js\nJust go through react-docgen custom handler documentation to configure.. @siddharthkp , Thats really awesome. No issues. Glad to see my name in repo.. @benwiley4000  , It should work for both. If you never mind, can you please share your project config.. @benwiley4000 seems above URLs are broken.\n. @intelcoder, is your import and docgen.parse in same file? If yes doc gen doesn't understad this. Src value must be string.. @peterjwlee , Sharing your example can help quickly look into the issue.. ",
    "asis": "What do you think about a simpler approach? In our case, it would be enough to document our components with a generic message whenever a spread is found.\nSo, for a component like this one:\n```js\nMyComponent.propTypes = {\n  /\n    * Component Foo proptypes\n    */\n  ...Foo.propTypes,\n  /\n    * Some other proptypes\n    /\n  ...propTypes,\n  /\n    * Unhandled spread\n    /\n  ...{\n    bar: Prop.bool,\n  }\n};\n```\nWe would like to get the following descriptors:\njs\n{\n  \"...Foo.propTypes\": {\n    \"description\": \"Component Foo proptypes\"\n  },\n  \"...propTypes\": {\n    \"description\": \"Some other proptypes\"\n  }\n}\nRight now, these proptypes are just ignored, resulting in incomplete docs :(\nWe have got a proof of concept fork which adds support for Identifier or MemberExpression spreads, ignoring other spread expressions.\nI can create a PR if you think this approach is worth it :). Oh, sorry! I was focused on extracting docs from the props declaration, so when I saw https://github.com/reactjs/react-docgen/blob/00f2d2d62d93b9243157c4cea19cf241121a7721/src/handlers/tests/propDocblockHandler-test.js#L127 I thought spread props were just being ignored altogether \ud83d\ude0a\nThanks for the quick response!. We just used the list of \"composed props\" to infer the source files where they were defined. To solve the problem in styleguidist/react-styleguidist#548, we use a custom propsParser which turns each composed props reference into a \"custom\" prop, with a description containg a link to the relevant section of our docs. It is brittle... but it works.. ",
    "RIP21": "+1 \nHave same use case as @asis  We have our wrappers around semantic-ui components very often, and I try to spread their propTypes to have their props documented as well as ours but got nothing.\nJust wrote some makes-no-sense component for test and parse it and got:\njson\n{\n  \"description\": \"Our wrapper component around semantic-ui button\\r\\nFor more props visit\\r\\n[semantic-ui-button](https://react.semantic-ui.com/elements/button#button-example-button)\",\n  \"methods\": [],\n  \"props\": {\n    \"children\": {\n      \"type\": {\n        \"name\": \"any\"\n      },\n      \"required\": false,\n      \"description\": \"Button label\"\n    }\n  },\n  \"composes\": [\n    \"semantic-ui-react\"\n  ]\n}\nCode:\n```javascript\nimport React from \"react\";\nimport PT from \"prop-types\";\nimport { Button as SButton } from \"semantic-ui-react\";\n/*\n * Our wrapper component around semantic-ui button\n * For more props visit\n * semantic-ui-button\n/\nconst Button = ({ children, ...rest }) =>\n  {children};\nButton.propTypes = {\n  /* Button label /\n  children: PT.any,\n  ...SButton.propTypes\n};\nexport default Button;\n```\nWill be awesome to have this with comments that propTypes of the imported component have. Since all semantic and our components are react-docgen documented.. This feature is really vital, especially for styleguides etc. Can somebody integrate such finally :(. ",
    "reintroducing": "I'm running into the same thing while using either propTypes = CustomPropTypes; or trying to destructure as propTypes = {...CustomPropTypes};. Is there any work around currently or is this still being discussed? I apologize but reading through the comments here it was not clear to me what the proposed solution is.. Would you mind sharing your handler?. @benjroy Thanks for doing this. I'm unclear what the differences between your solution and this one is, however. Also, I think it would be good to show how this is used in the confines of react-styleguidist which is I think where all this originated, if possible. I'm also not able to see clearly how to use it there from your example.. ",
    "workjalexanderfox": "@pasupuletics, how about now? Care to share your custom handler?. ",
    "selrond": "So this is still not a thing? . Same issue here, using react-styleguidist with styled-system & system-components\n```js\nimport system from 'system-components'\nimport { themeGet } from 'styled-system'\nconst Box = system(\n    {\n        blacklist: ['round'],\n    },\n    'space',\n    'width',\n    'fontSize',\n    'textColor',\n    'bgColor',\n    'color',\n    // typography\n    'fontFamily',\n    'textAlign',\n    'lineHeight',\n    'fontWeight',\n    'letterSpacing',\n    // layout\n    'display',\n    'maxWidth',\n    'minWidth',\n    'height',\n    'maxHeight',\n    'minHeight',\n    'size',\n    'ratio',\n    'border',\n    'borderTop',\n    'borderRight',\n    'borderBottom',\n    'borderLeft',\n    'borders',\n    'borderColor',\n    // position\n    'position',\n    'zIndex',\n    'top',\n    'right',\n    'bottom',\n    'left',\n    props => ({\n        borderRadius: props.round ? ${themeGet('radii.1')(props)}px : 0,\n        boxShadow: props.shadow ? themeGet('shadows.1')(props) : 'none',\n    }),\n)\n/* @component /\nexport default Box\n```\nGetting \n```\nWarning: Cannot parse src/components/atoms/Grid/Box.js: TypeError: Got unsupported definition type. Definition must be one of ObjectExpression, ClassDeclaration, ClassExpression,VariableDeclaration, ArrowFunctionExpression, FunctionExpression, TaggedTemplateExpression or FunctionDeclaration. Got \"CallExpression\"instead.\nIt usually means that react-docgen does not understand your source code, try to file an issue here:\nhttps://github.com/reactjs/react-docgen/issues\n```. ",
    "SimeonC": "@pasupuletics That's awesome!!! Works a treat, thanks!. ",
    "Hypnosphi": "@pasupuletics can you please add some license to your repo? \n\nIf you find software that doesn\u2019t have a license, that generally means you have no permission from the creators of the software to use, modify, or share the software. Although a code host such as GitHub may allow you to view and fork the code, this does not imply that you are permitted to use, modify, or share the software for any purpose.\n\nhttps://choosealicense.com/no-permission/\nYou've added UNLICENSED to your package.json, but that's probably not what you actually want:\n\nFinally, if you do not wish to grant others the right to use a private or unpublished package under any terms:\n{ \"license\": \"UNLICENSED\" }\n\nhttps://docs.npmjs.com/files/package.json#license. ",
    "siddharthkp": "@pasupuletics I hope you don't mind, I published the handler on npm and documented it: https://github.com/siddharthkp/react-docgen-external-proptypes-handler. @benjroy That's brilliant!\nIf it works nicely, I don't mind deprecating my package. I'm not actively maintaining it anyways.\nYou can add @pasupuletics and me as maintainers if you like.. ",
    "JuhQ": "This issue has been opened in 2015 and still open. Any progress on fixing this?. ",
    "danm": "I'm here as I'm using docz which uses docgen in its pipeline. Each of my components have their own directory with several files at the root which abstracted from the main component, one of those is a Flow file which annotates the component and imports its types. Because docgen can't read this file, none of my props generate for the prop table. \n@danez you mentioned this earlier and looks still to be an issue. Any ideas where could get started on this to create a PR?. ",
    "benwiley4000": "@pasupuletics @siddharthkp If I understand correctly (I have downloaded and tried this handler in my project), that handler only works for imported constants but not for actual imported propTypes? I have entire propTypes declared in external files which I would like to use.. @pasupuletics thanks for following up! here's my styleguidist config which specifies the docgen handlers. https://github.com/benwiley4000/cassette/blob/48ab0a5ea187d4458df6933927b6cc1522cc1469/styleguide.config.js#L180\nIn particular I'm wanting this propType (repeatStrategy) to show up as an enum which should be one of \"none\", \"playlist\" or \"track\" as specified here.. @pasupuletics sorry I corrected the links now.. @benjroy thank you for sharing this! I have tried setting it up in my project and I ran into some issues that are keeping me from building my docs with this setup.\nDo you have an example of how you've integrated the package in your own project?. ",
    "benjroy": "@pasupuletics and @siddharthkp got me inspired with their implementations.  I forked their repo and expanded the functionality, wrote a whole lot of snapshot tests, and in the end mostly tweaked some code related to resolveToValue.\nI'd like to offer this up in hopes that it will help others:  https://github.com/benjroy/react-docgen-imported-proptype-handler\nnpm install react-docgen-imported-proptype-handler --save-dev\nSetup is pretty much the same as react-docgen-external-proptypes-handler\nThe test fixtures exercise the expanded capabilities:  https://github.com/benjroy/react-docgen-imported-proptype-handler/tree/master/src/handlers/tests/fixtures/components\nAnd there is nothing computed in the final snapshot: https://github.com/benjroy/react-docgen-imported-proptype-handler/blob/master/src/handlers/tests/snapshots/importedPropTypeHandler-test.js.snap\nit works well following imports of files in your repo.\nfollowing imports from node_modules:  there is some basic path resolution and an implementation exercising it to make sure it won't throw, but I didn't write any logic to be able to read babel processed files from external dependencies. @benwiley4000 thank you for trying it out!  I forgot to ship @babel/runtime.  Just published v1.0.1 for the fix.\nAdditionally, here is a repo with basic example usage:\nhttps://github.com/benjroy/react-docgen-imported-proptype-handler-example\nAnd the script itself:\nhttps://github.com/benjroy/react-docgen-imported-proptype-handler-example/blob/master/scripts/docgen.js. @nemoDreamer yea, I think this handler I wrote would be better implemented as a PR into react-docgen (the meat of the changes is slight tweaks to some of the utility methods to pass a filepath around).\nYour problem specifically is that react-docgen v3 doesn't ship the babylon parser.\nI noticed too late when i was working on the handler that react-docgen was in alpha for major version 3.0.0, but tl;dr;:\nthis handler was only tested with react-docgen ^2.x.x\n- you will get bit by the babel-plugin-react-docgen shipping docgen v3\n- you will probably get bit by recast (this bit me because there were two competing versions of recast in my node deps tree.  In order for the handler to work, docgen and this handler MUST be pointing to the exact same recast dependency in node-modules\nReworking this for react-docgen v3.0.0 will probably require a bit more work because of the dropped babylon dep, and at that point the effort would be much better spent working this directly into react-docgen itself. ",
    "nemoDreamer": "@pasupuletics @siddharthkp and @benjroy , thanks for the great work!\nI'm trying react-docgen-imported-proptype-handler as it has the most robust set of supported cases and fixtures, but I'm getting the following when doing this:\n```jsx\nimport BaseComponent from './BaseComponent';\n// ...\nMyComponent.propTypes = {\n  ...BaseComponent.propTypes,\n  // ... more\n}\nMyComponent.defaultProps = {\n  ...BaseComponent.defaultProps,\n  // ... more\n}\nexport default MyComponent;\n```\nError:\nCannot find module 'react-docgen/dist/babylon' from 'resolveImportedNamespace.js'\n  at Resolver.resolveModule (node_modules/jest-resolve/build/index.js:221:17)\n  at Object.<anonymous> (node_modules/react-docgen-imported-proptype-handler/dist/utils/resolveImportedNamespace.js:24:39)\nSince there is not error without your handler, and all the Babel stuff works nicely, I'm a bit stumped.\nreact-docgen and react-docgen-imported-proptype-handler both use recast@0.16.1, but I've got a different react-docgen version floating around from babel-plugin-react-docgen:\n```bash\n$ yarn list --pattern react-docgen\nyarn list v1.13.0\n\u251c\u2500 babel-plugin-react-docgen@2.0.0\n\u2502  \u2514\u2500 react-docgen@3.0.0-rc.2\n\u251c\u2500 react-docgen-external-proptypes-handler@1.0.2\n\u251c\u2500 react-docgen-imported-proptype-handler@1.0.4\n\u2514\u2500 react-docgen@3.0.0\n``. It seems that these issues could be side-stepped if this handler were simply a pull-request agains the officialreact-docgenrepo, no? You're already copy/pasting a bunch ofutils/over, and the demand for this handler is so great that I'd be surprized if it didn't get accepted, right @fkling ?. It could be very similar to the FlowType output, w/signature` etc.. ",
    "albertoblaz": "Haven't tried your package yet @benjroy but if it fixes the problem, it'd be awesome to see it merged into react-docgen because a lot of people seem to have the same issue and it's been 3 years since it was created. ",
    "mighty-titan": "Can this also solve the same problem with imported flow types? . ",
    "joaomilho": "I have the same problem, although my example is simpler. Given the following code:\n``` js\nexport default function Tooltip () { ... }\nTooltip.arrows = ['up', 'down', 'left', ...];\nTooltip.propTypes = {\n  arrow: PropTypes.oneOf(Tooltip.arrows)\n};\n```\nAnd this generates the following JSON:\njs\n{\n  arrow:\n   { type: { name: 'enum', computed: true, value: 'Tooltip.arrows' },\n     required: false,\n     description: '' }\n}\n. ",
    "joshfarrant": "Any further thoughts on this? I've recently run into the same problem with the following:\n```js\nconst KIND = {\n  PRIMARY: 'primary',\n  SECONDARY: 'secondary'\n};\n// ...\nstatic propTypes = {\n  kind: PropTypes.oneOf(Object.values(KIND))\n};\n```\nI'd expect this:\njson\n{\n  \"kind\": {\n    \"type\": {\n      \"name\": \"enum\",\n      \"value\": [{\n        \"value\": \"'primary'\",\n        \"computed\": false\n      }, {\n        \"value\": \"'secondary'\",\n        \"computed\": false\n      }]\n    },\n    \"required\": false,\n    \"description\": \"\",\n    \"defaultValue\": {\n      \"value\": \"'primary'\",\n      \"computed\": false\n    }\n  }\n}\nHowever I'm getting this:\njson\n{\n  \"kind\": {\n    \"type\": {\n    \"name\": \"enum\",\n    \"computed\": true,\n    \"value\": \"Object.values(KIND)\"\n  },\n    \"required\": false,\n    \"description\": \"\",\n    \"defaultValue\": {\n      \"value\": \"'default'\",\n      \"computed\": false\n    }\n  }\n}\nIs there a workaround for this, or a fix in the works? If not, I'd be happy to look at submitting a PR to address this, if you could point me in the right direction.. ",
    "dmitry-zaets": "related to https://github.com/reactjs/react-docgen/issues/153 and https://github.com/reactjs/react-docgen/pull/122. Related to https://github.com/reactjs/react-docgen/pull/122. ",
    "just-boris": "Hello!\nI have also tried to gather documentation for sources after Babel.\nCurrently, there is now a problem with _interopRequireDefault function:\nGiven the following code\n```js\n'use strict';\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\nvar React = _interopDefault(require('react'));\nfunction MyComponent(_ref) {\n    var className = _ref.className,\n        children = _ref.children,\n        style = _ref.style;\nreturn React.createElement(\n    'button',\n    { className: className, style: style },\n    children\n);\n\n}\nmodule.exports = MyComponent;\n```\nThe problem here is that React identifier is recognized as a result of unknown _interopDefault function. I think it makes sense to check the arguments of the call, whether there is a require or not.\nWhen I added there also a check for arguments, it worked fine.\nWhat do you think about fixing this?. Well, of course, if I could run Docgen on top of source code, I did it... \nIn my case, the problem is that build process for files is a bit complex. I am trying to build documentation using React-styleguidist, it requires me to use Webpack, but the project is built with Rollup, so I have to either, maintain the second version of configuration with Webpack loaders, or just generate documentation based on built files.\nAlso, to define propTypes, you need to add as static property, and then Babel will write it like \n```js\nvar Foo = function (_React$Component) {\n  _inherits(Foo, _React$Component);\nfunction Foo() {\n    _classCallCheck(this, Foo);\nreturn _possibleConstructorReturn(this, (Foo.__proto__ || Object.getPrototypeOf(Foo)).apply(this, arguments));\n\n}\nreturn Foo;\n}(React.Component);\nFoo.propTypes = {\n  bar: React.PropTypes.string\n};\n```\nWhich is recongizable by React-docgen right now.\nI have already built a styleguide with modified version of React-docgen, and the only problem, that I have found was about unrecognized React require.. ",
    "ondrejbartas": "I am reffering to: https://travis-ci.org/reactjs/react-docgen/builds/88382618 when you look at log you will see that tests failed but travis passed \n. nice :+1: \n. \ud83d\udc4d \n. ",
    "vieron": "+1\n. ",
    "donnieberg": "@oliviertassinari +1 on this bug with ES6.\nMyComponent.defaultProps = { propName: \"propVal\" };\n. @fkling Thanks for brining this to their attention. I'm using ES6 classes and am experiencing the same problem with getting defaultProps documentation from my components.\n. ",
    "yrashk": "Is there any ETA for the Babel 6 upgrade? I am running into the same issue and ideally I'd rather avoid playing with module resolution in web pack.\n. ",
    "neutraali": "Experiencing something similar to this... I can run react-docgen fine from the CLI interface, but trying to run it via code (webpack + dev-server) triggers the error. The actual error is:\nTypeError: pluginList.indexOf is not a function at Parser.loadPlugins (index.js:1620)\nAs @oliviertassinari described originally, the pluginList -parameter is { jsx: true, flow: true } - Which is apparently gotten from babylon. Obviously said parameter is an object, not an array, which causes the indexOf -check to fail.\nI've tried upgrading all my prop-types and babel -related packages to their latest versions, but that didn't help. npm list babylon version reveals that I have babylon@6.18.0 everywhere else, except react-docgen still has it as babylon@5.8.38. Could this be the issue?\n. @danez tried v3-dev - But it seems that branch only has the CLI interface available (at least when installing via NPM)? Anyway I moved on to making a CLI workaround since the NodeJS API is going nowhere.. Can you make react-docgen assume that prop-types is always present instead of having to import it into every file? We use Webpack with global definitions for react, react-DOM, prop-types etc.\nEDIT: The main README also still refers to older versions of React when PropTypes was still bundled into React.. ",
    "phpnode": "This is fantastic, very much looking forward to using it. Is there anything I can help with to get this landed sooner?\n. ",
    "benjamn": "Looking forward to that ast-types PR :)\n. ",
    "davidtheclark": "Excellent, thanks!\nOn Tue, Jan 19, 2016 at 9:46 AM, Felix Kling notifications@github.com\nwrote:\n\nThanks for reporting! Fixed and released with v2.5.2.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/reactjs/react-docgen/issues/51#issuecomment-172913487\n.\n. \n",
    "vjeux": "Actually, this pull request is not needed. I just had to add docgen.handlers.propDocBlockHandler to the handler list :)\n. That's going to make the react native docs so much better thanks! (I haven't written a single line in this codebase so I'm not a good reviewer)\n. ",
    "nikgraf": "Sound pretty good. I wonder how valuable a big time investment into propTypes is as the React core team announced to move more into the Flow direction (which I'm personally happy about). see https://github.com/facebook/react/issues/1833#issuecomment-148297807\n@fkling totally makes sense regarding the current wrapping of value. In our case we right now try to come up with a normalized structure that suites Flow & PropTypes. That might result in some interesting insight, but right now it's still an exploration phase. see https://github.com/pure-ui/styleguide/blob/master/plugin/normalize-meta-info.js\nbtw will you be at the React Conf? I'm happy to meet & discuss it in person as well\n. ",
    "abejfehr": "Forgive my potential ignorance, but would I be able to write a custom resolver that would (forgive the pun) resolve this issue?\n. ",
    "ZauberNerd": "@NogsMPLS I'm also very interested in using this. If it is not going into upstream, could you create a separate npm package for this handler?\nI documented a little bit how I created a custom handler in this issue: https://github.com/reactjs/react-docgen/issues/115 \nAs an example you could take a look at these two packages: nerdlabs/react-docgen-imports-handler and nerdlabs/react-docgen-exports-handler\nAs Felix seems to be very busy at the moment (see linked issue above) I'd probably just go ahead and create an npm package for this. And if this should be in upstream at a later stage you could still open a new PR and deprecate your package?\n. @NogsMPLS So, I've had some spare time and went ahead and created a displayName handler. Would that be covering all of your use cases too? https://github.com/nerdlabs/react-docgen-displayname-handler\n. Hey @fkling, yes and thank you for the comment, that's really valuable feedback and I agree, that the proposed solution is a  bit error prone. This is not a pressing issue for me at the moment, so I put the other issues before it, but I'll try to look into this again when I have some more time.\n. Ah, great. Glad to see things go into upstream :)\nI'm currently re-thinking my approach to a living style guide generator for react components (https://github.com/nerdlabs/schaufenster) and I think I'll just go with react-docgen and a bunch of custom handlers instead. I started writing a couple of them already here for file-based dependencies and here for the export of the component but those are not really related to this project, so I didn't create PRs for them but will extract them into their own npm modules to allow others to use them too.\n. I just published a custom handler which we could use as a testbed: react-docgen-imports-handler\nA couple of things I noticed while publishing this:\n- The Documentation is not exported. It is possible to import it via import Documentation from 'react-docgen/dist/Documentation'; but that would mean that the dist/ part becomes part of the public API.\n  This is being used in the test file for the handler\n- The babylon wrapper is not exported and also has to be accessed via dist/ or packages need to implement it themselves. For the initial version I went with the first approach but I'm not sure yet which approach is better.\n  This is being used for the tests/utils.js (similar to the file in this repo).\n- flow-type definitions have to be manually created for now. But it seems to be possible to avoid this step if we would copy all source files into dist/ with their extensions renamed from .js to .js.flow. Other people seem to do it that way.\n- By renaming the flow/ folder to flow-types/ we don't need to reference it in the [libs] section of the .flowconfig anymore.\n- I kept the .babelrc, .eslintrc and .travis.yml, added some other files (editorconfig, eslintignore, npmrc, etc).\n- I switched from jest to ava to be able to write tests in ES6.\nIn regards to the flow-types: Maybe it will be enough to contribute type definitions of the public API of react-docgen to the flow-typed repository and use them in custom handlers (if they want to use flow).\nOther than that it was pretty straight forward to create this module.\n. Sorry for hijacking this thread. Back to the original topic: \nI think it would be good to focus on both options (adding more maintainers and keeping the core small). Just to throw a crazy idea in here: http://openopensource.org/\nAdding more maintainers could help:\n- reduce the bus factor\n- resolve issues and PRs in less time\nI like the idea of keeping the core small or even going one step further (like babel) and having this project provide only the infrastructure (resolver and utilities) for other handlers (meaning: taking method, propTypes and displayName handler out of the core). These handlers could still be \"core handlers\" and be versioned in this repository, but are not automatically included. I think that would help to make the scope clearer on what goes into the core and what stays outside of it.\nCons of that approach could be the overhead of maintaining all these \"core handlers\" in isolation, maybe even chasing bugs that only occur in special combinations of handlers, confused or overwhelmed users because moving all the handlers out of the core could put more complexity in their projects.\nBut in any case, I agree that we first need to document and provide examples for how to create and publish custom handlers and figure out a way to make them accessible from the CLI.\n. Yes I think resolveToValue has been named a bit misleading and maybe there should be two methods: resolveToInitialization (or declaration) and resolveToValue.\nThe former would traverse the scope chain and find module imports or other variable declarations, while the latter would try to find the actual value ((re)assignment of a literal value, which might involve traversing through function return values or aliasing). That would of course not always be possible or maybe not very correct, but could be helpful in some cases.\nUsing flow as parser sounds very interesting, is this being done in the open and has work on it already started?\n. I tried changing it yesterday and got different errors. I'll look into it when I have a bit more time.\n. What about isReactComponentClass and isStatelessComponent?\n. Inspecting only the rightmost argument may not work for all cases.\nOne common case is for example Relay, where the component will be the first argument.\nAlso it might be interesting to investigate connect() of react-redux and recompose, as a baseline for example usage of HoCs.\n. ",
    "danny-andrews": "Is this PR died? It would be really nice to have this feature! @NogsMPLS. Thanks!. ",
    "sapegin": "Yeah, we\u2019re using display-name-handler in React Styleguidist and it works perfectly!. react-docgen-typescript may be useful for some use cases.. @fkling Could you please review this pull request?\n. Looks similar to #136.. @fkling Could you please take a look at this? Could be a one-line PR if you agree that this should be fixed in react-docgen.. Right now we\u2019re doing Object.assign before passing the object to to-ast. So if it\u2019s by design in react-docgen, we\u2019ll either continue using Object.assign or send a PR to to-ast with Object.prototype.hasOwnProperty.call if they accept it. Thank you for clarification anyway!. @fkling Could you please merge it and publish a new release? . @fkling Could you please take a look at this?. Looks like with system-components 3.x the error is a bit different:\n\nTypeError: Got unsupported definition type. Definition must be one of ObjectExpression, ClassDeclaration, ClassExpression,VariableDeclaration, ArrowFunctionExpression, FunctionExpression, TaggedTemplateExpression or FunctionDeclaration. Got \"Literal\"instead.\n\nLiteral\u00a0instead of CallExpression.. Nope, it's not because of system-components 3.x, it's because https://github.com/Jmeyering/react-docgen-annotation-resolver/pull/3. ",
    "chrisege": "It's not ideal, but as a workaround, something like this will prevent a failure:\njavascript\nconst DefaultChild = props => <DefaultChildComponent {...props} />\nand then:\njavascript\n getDefaultProps() {\n    return {\n      ChildComponent: DefaultChild\n    }\n  },\n. ",
    "khankuan": "sample snippet\n```\nconst types = ['dark', 'light'];\n...\nstatic propTypes = {\n  types: React.PropTypes.oneOf(types)\n}\n```\nThis resulted in the value being 'types' as a string. It would be nice if we can replace it with the variable value instead of the variable name.\n. Ic. I saw that there is the composes key in the output. Is that in used at the moment?\n. I feel that composes feels like it is targeted for the case:\n<div>\n  <A { ...propsA } />\n  <B { ...propsB } />\n</div>\nWhereas dependencies does not really imply any propTypes and focus on the components that are referenced in the render method. I felt that it is unnecessary to enforce that composition is done via propTypes with the spread operator. In some cases, there is no need to declare the propTypes as well such as:\n<div>\n  My Content\n  <Divider />\n  My Second Content\n</div>\nAlso, the proposed method also includes native tags that can be useful as well.\nI thought that the composition is one of the fundamental strengths of React and documenting component dependencies is an obvious benefit to be included by default. I would think that dependencies might be more useful than composes for beginners. Is there a list of plugins that are build on top of react-docgen? Personally, I would like having the handler here with all the build and test processes already well crafted and we have more radar on future regressions.\nAnother consideration is to combine composes and dependencies but it might dilute the meaning of composes for devs that are already using it.\nCheers :)\n. Hey, wondered if the PR could be reconsidered. Otherwise, would it be possible to cherry pick just the changes on this file: https://github.com/khankuan/react-docgen/blob/4dfb0fbc5d9ff43df9fdc5f1dfd9f6797f129728/src/utils/resolveToModule.js\n. @fkling Proposing that we use propTypes to guess since a function can literally do anything such as calling an imported module. But in most cases propTypes should be defined (or worst case we can define an empty object). Thoughts?\n. @fkling i intend to add detection via propTypes and defaultProps but couldn't figure what's the best way to traverse the given path and grab it's object properties to inspect. Could you give a little hint on any examples that are similar? Thanks :). @fkling agreed. I just changed the strategy for #93 entirely and that really mean that these custom handlers can be unstable. Having them as plugins would probably be most ideal for development. However, I really would like to use the utils and tests setup that the repo already had. Those would reduce the overhead of splitting custom functionality into multiple repos.\nCheers! :)\n. ",
    "leepowellcouk": "Sorry to raise an old issue, but should this work if the values are kept in an imported file?\nimport { types } from './types';\n...\nstatic propTypes = {\n  types: React.PropTypes.oneOf(types)\n}. ",
    "caabernathy": "Hey @janicduplessis, I chatted with @fkling who suggested I post here with regards to a question I had around improving RN docs. I was exploring whether we could tease out the type definitions, ex: https://github.com/facebook/react-native/blob/master/Libraries/Components/StatusBar/StatusBar.js we have one called StatusBarAnimation that I'd like to list separately with perhaps the option of adding more comments around it.\nSo the method signature code snippet\nsetHidden(hidden: boolean, animation?: StatusBarAnimation)\nGets turned into\nstatic setHidden(hidden: boolean, animation: 'none' | 'fade' | 'slide')\nThe JSON output of parsing doesn't contain any mention of StatusBarAnimation so we could perhaps list it in the doc. A part of it looks like this:\n{\n  \"name\": \"setHidden\",\n  \"docblock\": null,\n  \"modifiers\": [\n    \"static\"\n  ],\n  \"params\": [\n    {\n      \"name\": \"hidden\",\n      \"type\": {\n        \"name\": \"boolean\"\n      }\n    },\n    {\n      \"name\": \"animation\",\n      \"type\": {\n        \"name\": \"$Enum\",\n        \"elements\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"object\",\n            \"raw\": \"{\\n  'none': string,\\n  'fade': string,\\n  'slide': string,\\n}\",\n            \"signature\": {\n              \"properties\": [\n                {\n                  \"key\": \"none\",\n                  \"value\": {\n                    \"name\": \"string\",\n                    \"required\": true\n                  }\n                },\n                {\n                  \"key\": \"fade\",\n                  \"value\": {\n                    \"name\": \"string\",\n                    \"required\": true\n                  }\n                },\nSo the question is, any idea on how we could bring out the custom type name into the returned JSON, StatusBarAnimation in this example?\n. @janicduplessis thanks for the pointer. I tried it out by making the following change in getMethodDocumentation.js\nconst {types: {namedTypes: types}} = recast;\n...\nfunction getMethodParamsDoc(methodPath, jsDoc) {\n    ...\n    if (typePath) {\n        type = getFlowType(typePath);\n        if (types.GenericTypeAnnotation.check(typePath.node)) {\n            type.name = typePath.node.id.name;\n        }\n    }\n    ...\nIt seems to spit out the right stuff. Is that what you were pointing me towards?\n. FYI, I see the same Travis CI failures when I run tests with node v6.2.1 and un-changed code from master. So I don't believe my changes introduced any new errors.\n. @janicduplessis or @fkling thoughts on this PR? I was looking for guidance in light of a React Native doc lockdown scheduled for next week.\n. Great idea, I was thinking the same but wasn't sure. I'll make that change.\n. I'd appreciate another look @janicduplessis and @fkling.\n. Ok, rebased.\n. Actually I intentionally return undefined (a little hacky) because I didn't want to always add the property and so as not to break existing tests. \n. ",
    "Guria": "Not sure if Typescript AST can be easy converted to Babylon one. Here is an example of parsing Typescript one: https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#traversing-the-ast-with-a-little-linter\n. ",
    "StJohn3D": "For anyone still finding this, I ended up going with documentalist - it parses typescript as well as markdown and similarly spits out splendid json. It's not built specifically for react components - which can be a good thing - so you'll need to write a little bit of logic to aggregate a component's data to it's props (it's really not that bad though. I might even share a gist when I'm done doing this myself.) So it's closer to something like typedoc - however it's JSON output is nicely documented and (IMHO) much easier to make sense of.. @sophieH29 so for my needs I ended up not aggregating the data as it allows me to be more flexible in my documentation workflow to just call a function and pass in the name of the export I'm looking for. \nThat said, when you run documentalist and inspect the json output you should find something like this.\nAssuming an index.ts which exports the following:\nexport interface IMyClassProps ...\nexport class MyClass extends React.Component<IMyClassProps , IMyClassState>...\njson\n{\n  \"typescript\": {\n    \"MyClass\": {\n      \"kind\": \"class\",\n      \"extends\": [\n        \"Component<IMyClassProps, IMyClassState>\"\n      ],\n    },\n    \"IMyClassProps\": {\n      \"kind\": \"interface\",\n      \"properties\": [\n        {\n          \"fileName\": \"src/myClass.tsx\",\n          \"flags\": {\n            \"isExported\": true,\n            \"isExternal\": false,\n            \"isOptional\": true,\n            \"isPrivate\": false,\n            \"isProtected\": false,\n            \"isPublic\": false,\n            \"isStatic\": false\n          },\n          \"kind\": \"property\",\n          \"name\": \"headerText\",\n          \"sourceUrl\": \"https://github.com/redacted/src/myClass.tsx#L7\",\n          \"type\": \"undefined | string\"\n        }\n      ]\n    }\n  }\n}\nThere's actually WAY more data that you'll get than this but I'm highlighting the relevant bits for brevity.\nWith that json youtput you could use a regex to find each class' properties...\nAssuming you import that json to a variable and then call the following function with that object.\njs\nconst getData = (docs) => {\n  const result = []\n  for (key in docs.typescript) {\n    const data = docs.typescript[key]\n    if (data.kind === \"class\") {\n      const propsInterfaceName = data.extends[0].match(extendsRegex)[1]\n      const propsData = docs.typescript[propsInterfaceName]\n      data.properties = propsData.properties\n      result.push(data)\n    }\n  }\n  return result\n}\nObviously that function is not production ready - there's no error catching - it's just assuming everything will be there. But the point is to show how easy it would be to aggregate the data.\nThe output of that function would be an array of all of your exported classes. And each object in that array would also contain a propterties key with all of the aggregated props information from it's associated exported props interface.\nHope that helps!\nFor my purposes I'm using documentalist to parse both typescript and markdown.\nIn my markdown I just put comments for where I want to insert data. e.g. <!-- props IMyClassProps --> and then I've written custom regex patterns and logic to parse the markdown objects and replace those comments with the data from typescript. So it's not something easy to share and very specific to my repo but the examples above should help get the wheels turning :)\njsbin link. ",
    "sophieH29": "@StJohn3D Please, do share the gist!. @StJohn3D thank you! I'll take a look on that. ",
    "rtsao": "Great, I'll get started on implementing this.\n. I've run into this issue as well. I've added support for single unary higher-order-components in my personal fork. This is the relevant commit here: https://github.com/rtsao/react-docgen/commit/9ca812707b9caea568b8e57ce736a481ed4467e4\nYou can turn your code to use a single unary higher-order component like so:\n``` js\nconst Contributors = React.createClass({...});\nconst mapStateToProps = (state) => {\n  return { contributors: state.contributors }\n}\nconst hoc = (Component) => connect(mapStateToProps)(Component);\nexport default hoc(Contributors);\n```\nThe above code will work with my fork.\nIf multiple higher order components are needed, you can use recompose's compose helper.\nI think only supporting a single unary higher-order component seems like a reasonable compromise, since basically you can convert all forms of higher-order component composition into that form. To support multiple (or an arbitrary number of) call expressions or arguments it seems like one would need to go down a rabbit hole.\nI'd be happy to create a PR if @fkling thinks my approach is reasonable. I haven't yet done so already because I worry I might have broken some existing code structure conventions (by requiring '../utils/match' and 'recast' directly within a resolver), but that's probably a straightforward refactor.\n. Yeah, actually I think this should be very doable.\n``` js\nexport default hoc1(Component);\nexport default hoc1(arg1a, arg1b)(Component);\nexport default hoc2(arg2b, arg2b)(\n  hoc1(arg1a, arg2a)(Component)\n);\nexport default hoc3(arg3a, arg3b)(\n  hoc2(arg2b, arg2b)(\n    hoc1(arg1a, arg2a)(Component)\n  )\n);\n// etc...\n```\nWhen I get a chance I'll give it a go and submit a PR\n. I've implemented this here: https://github.com/reactjs/react-docgen/pull/124\n. If you're just using JSDoc syntax you might not need react-docgen and can use Babylon to extract comment blocks and parse them with https://github.com/eslint/doctrine directly\n. FWIW I've signed the CLA (as seen on https://github.com/reactjs/react-docgen/pull/71) but I'm not sure why it isn't showing up here\n. The infinite loop occurs in this while expression: https://github.com/reactjs/react-docgen/blob/6f7368658ddda6f7cdb03d62c0a59b065bdd42fe/src/utils/isStatelessComponent.js#L95\nI'll see if I can fix this\n. I've added a really basic fix. I think array literal usage is the corner case here so a simple check should suffice. It doesn't seem to me a loop would occur in any other case.\n. I've been using my fork with this patch without any issue (I think call expressions with object literals is pretty rare).\nI'd be happy to refactor this to make the fix more robust (maybe explore the alternate while condition described above) but probably won't get a chance to in the near term.\n. Agreed, closing in favor of https://github.com/reactjs/react-docgen/pull/139. React Classes and stateless functional components are not call expressions, but React.createClass() is.\n. That's interesting that Relay doesn't follow the convention I've seen for every other HOC, which is to take only one argument (the component) or have the component be the rightmost argument. Recompose follows this convention.\nBut as discussed in https://github.com/reactjs/react-docgen/issues/80 you can easily turn any HOC into a HOC that takes a component as its only or rightmost argument.\n. ",
    "alexsasharegan": "I agree. +1  if docGen could parse this vanilla way of authoring components.\n```js\nimport { createElement as h } from \"react\"\nexport default function Button(props) {\n  return h('button', props)\n}\n```. ",
    "ghost": "Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n. Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n. ",
    "roychoo": "@fkling I wouldn't mind investigating this. Do you have any pointers/examples that could help me to kickstart this. ",
    "iamstarkov": "@fkling  can https://www.npmjs.com/package/babel-plugin-preval/ help with that?. ",
    "stepancar": "@fkling solution here https://github.com/alfa-laboratory/library-utils/blob/master/react-doc/create-resolver.js\nto use it:\n1) npm i library-utils\n// import \n2) const reactDoc = require('library-utils/react-doc');\n// pass file path\nconsole.log(reactDoc(filePath));\n . @danez . @danez I think, we can close this issue\n. ",
    "MoOx": "It got this issue via react-styleguidist\n. Thanks for letting me know. No rush. Enjoy your time.\n. I am having issue with react-styleguidist when trying to make my files using this kind of syntax: name?: value. babylon fails on ?. But not sure why since for my app I don't have any issue and babylon parse this correctly as babel transforms this like a charm.. Oh! Make sense then. Thanks for the comment :). Maybe better than nothing. Cause this hanging are a pain to debug sometimes.... This code seems enough\n```js\nconst something = () => {\n  return a().b()\n}\nexport default something\n```\nBut this don't create the issue\n```js\nconst something = () => a().b()\nexport default something\n```. More diff\nissue\n```js\nconst something = () => {\n  const x = wat().then()\n  return x\n}\nexport default something\n```\nno issue\n```js\nconst something = () => {\n  const x = wat()\n  const y = x.then()\n  return y\n}\nexport default something\n```. Yeah dup indeed.. Amazing. Looking forward to get this!. ",
    "fab1an": "86\n. I would be great if one could just augment the default getPropType function and pass it to the handler. That way I could implement my custom props that I need.\n. ",
    "vizath": "It is probably related to https://github.com/reactjs/react-docgen/pull/39 (oliviertassinari works on MUI), where there is no mention that react-docgen shouldn't work on browser.\nThey do use it this way:\nhttps://github.com/callemall/material-ui/blob/78beb5455d2fa37894d507b301ba161c46a10ab0/docs/src/app/components/CodeExample/index.js#L2\nwhere this.props.code would come from https://github.com/callemall/material-ui/blob/78beb5455d2fa37894d507b301ba161c46a10ab0/docs/src/app/components/pages/components/AppBar/Page.js#L10\nI'll open a PR in MUI to add this polyfill tomorrow then.\n. ",
    "kevinSuttle": "I just ran ./buildDocs.sh and it never completes. OSX 10.11.5 (15F34)\n. Thanks.\n. ```\n~/Code/react-docgen-master/example\n\u276f react-docgen components/* | ./buildDocs.sh\nError with path \"components/NoComponent.js\": Error: No suitable component definition found.\nError: No suitable component definition found.\n    at parse (/Users/kevinSuttle/.nvm/versions/node/v6.2.2/lib/node_modules/react-docgen/dist/parse.js:78:9)\n    at Object.defaultParse [as parse] (/Users/kevinSuttle/.nvm/versions/node/v6.2.2/lib/node_modules/react-docgen/dist/main.js:66:30)\n    at parse (/Users/kevinSuttle/.nvm/versions/node/v6.2.2/lib/node_modules/react-docgen/bin/react-docgen.js:83:17)\n    at /Users/kevinSuttle/.nvm/versions/node/v6.2.2/lib/node_modules/react-docgen/bin/react-docgen.js:178:30\n    at FSReqWrap.oncomplete (fs.js:117:15)\ncomponents/Component.js -> Component.md\n~/Code/react-docgen-master/example\n\u276f react-docgen components/Component.js | ./buildDocs.sh\n/Users/kevinSuttle/Code/react-docgen-master/example/generateMarkdown.js:65\n    Object.keys(props).sort().map(function(propName) {\n           ^\nTypeError: Cannot convert undefined or null to object\n    at generateProps (/Users/kevinSuttle/Code/react-docgen-master/example/generateMarkdown.js:65:12)\n    at generateMarkdown (/Users/kevinSuttle/Code/react-docgen-master/example/generateMarkdown.js:75:5)\n    at buildDocs (/Users/kevinSuttle/Code/react-docgen-master/example/buildDocs.sh:29:20)\n    at Socket. (/Users/kevinSuttle/Code/react-docgen-master/example/buildDocs.sh:22:3)\n    at emitNone (events.js:91:20)\n    at Socket.emit (events.js:185:7)\n    at endReadableNT (_stream_readable.js:934:12)\n    at _combinedTickCallback (internal/process/next_tick.js:74:11)\n    at process._tickCallback (internal/process/next_tick.js:98:9)\n```\nNote that I had to install react-docgen globally first...\n. ",
    "i-a-n": "@kevinSuttle - buildDocs.sh expects JSON input, it doesn't run independently. Try this:\n$ react-docgen components/* | ./buildDocs.sh\n...Replacing components/* with the path to your components directory.\n. Yep, makes sense, thanks for the reply!\nI personally don't think it's great software design to do that (my real-world problem has to do with regenerating documentation only for components being updated, which is sometimes just one component, breaking my doc builder), but obviously there are many ways around it and maybe my usage pattern wasn't great to start off with.\nThanks again!\n. ",
    "episodeyang": "Thanks! Here is the line where the error pops up:\n\n. Yes! but the resolver I'm passing in is defined. Let me update the usage.\n. Just updated the usage in the example. If you use the findAllCompoentDefinitions resolver it breaks.\n. Thanks @fkling for responding! I just setup a new webpack loader and it now works with this version. You can see that here I just used the default resolver so it is all good. \nhttps://www.npmjs.com/package/react-docgen-loader\nAlso, this loader is now used in this template \nhttp://www.episodeyang.com/react-es6-template/\n:P\n. Here is a screenshot!\n\n. ",
    "jackyon": "@fkling,\nI have tried the example cli \"react-docgen components/* | buildDocs.sh\",\nit reminds me \"-bash: buildDocs.sh: command not found\"\nif I copied that two files to my project folder, it works, but looks like the REAME.md create the wrong format of markdown, it still json file:\n{\n  \"app/components/Header/index.js\": {\n    \"description\": \"General component description.\",\n    \"methods\": []\n  }\n}\nplz advise.\n. ",
    "dickeylth": "Two weeks gone, is there anyone maintaining this package's upgrade? Need this pr to be merged badly!\n. Another week gone, so when will this to be merged and when will next version to be published? \n. OK, thank you for your suggestion, I've updated the commit~\n. OK, I'll update the commit soon. \n. ",
    "palange": "Updated commit to fix lint errors\n. ",
    "sigurdsvela": "Mostly, I'm thinking that this would be a valuable feature for a react specific documentation tool, as the syntax is arguably cleaner in cases where you have 1 to 10-ish props(Which is the majority of components I run into).\nAlthough, addressing your comment; I could have,\nBut I am very dependent on having the option to document props right above their declaration.\nI would also like, in the future, to be able to 'deprecate' and give other meta data to specific props, which is much easier to define the syntax for if you allow for docblocks above the props declaration.\nWhich means that if I create something myself, I would probably have to reimplement a lot of what you guys have done here when that feature is needed.\n. ",
    "davidlivingrooms": "@fkling That's really cool that you can supply your own custom handler! I haven't tried myself but I may give this a shot. I agree that the block comments are a little verbose in the majority of cases (at least for me). Most of the components I write tend to have a small number of props with single line comments. For example: \nstatic propTypes = {\n        foo: PropTypes.string, // Does things that only a foo can\n        bar: PropTypes.string, // Does things that only a bar can\n}\nI like how this looks and it makes me feel good :smiley:. I understand that sometimes you may need a multi-line comment too though. It would be nice to have a custom handler that figures out what kind of comment you are using on a per prop basis. For example:\n```\nstatic propTypes = {\n        foo: PropTypes.string, // Does things that only a foo can\n    bar: PropTypes.string, // Does things that only a bar can\n\n    /** Does things that only a foobar can */\n    foobar: PropTypes.shape({\n        /**\n         * Some properties will have a longer description that require them to be\n         * on multiple lines\n         */\n        foo: PropTypes.string,\n        bar: PropTypes.string, // Does things that only a bar can \n    })\n\n}\n```\nSo, if there's a single line comment on the same line as the prop type declaration, use it. Otherwise, use the block comment above like normal.\nIn my opinion, the types of comments that can be detected should be as flexible as possible so more people can easily use react-docgen (since it is so awesome). \nThoughts? Do you guys think something like this would be possible through a custom handler?\n. ",
    "brentschroeter": "+1: Code looks good. I've been including a similar handler manually in my application and would love to see Nathan's fix made standard.\n. ",
    "nathanmarks": "@fkling We can definitely provide some more information.\nWe know whether it was a default or a named import, and we know the require path.\nAre you looking to provide information from the imported module itself? Or are you looking for something more specific about the import statement, ie: ImportedComponent - default export from module './ImportedComponent, NamedExport - export from module './ImportedComponent'?\n. We can provide some additional information in the returned object.\nLet me know exactly what you'd like to see, and I'll fix it up.\n. ",
    "dptoot": "Definitely looking forward to this being added.  Any chance this can get added into the next release?\n. +1\nThis is also applicable to the the ternary short hand \njavascript\nexport default function Button(props) {\n  const button = <input type=\"button\" />;\n  return props.show && (\n    <div id=\"next\">{button}</div>\n  );\n}\n. Don't want to lump on more grief but just informing if it may assist in debugging...\nI am also seeing the issue if the return value is a React API method\n``` javascript\nfunction Popup({url, width, height, children, ...rest}) {\nconst handleOnClick = () => {\n    window.open(url, 'popup', `height=${height},width=${width},scrollbars=yes`, false);\n};\n\nreturn (\n    React.cloneElement(children, {\n        onClick: createChainedFunction(handleOnClick, children.props.onClick)\n    })\n);\n\n}\n```\n. ",
    "wallaroo": "sorry for the late React...ion  ;-)\n. ",
    "mike-robertson": "Does this issue still need a fix? I still see issues if I do a ternary or bool && <div />.. ",
    "pke": "It seems the eslint react plugin does a pretty good job on detecting stateless components. ~~Maybe we should see how they do it~~? Because it does not complain about this perfectly valid stateless component described in #232 \nedit: They seem to have to https://github.com/yannickcr/eslint-plugin-react/blob/master/lib/util/Components.js#L313. @lensbart this doesn't seem to be a right solution for a parser problem? How can the package manager fix such issue?. @danez yes it is. I just ran into this. \nes6\nconst PhoneNumber = ({ number, children = number }) => (\n  <PhoneNumberLink href={phoneUrl(number)}>{children}</PhoneNumberLink>\n)\nPhoneNumber.propTypes = PROPTYPES\nexport default PhoneNumber\nleeds to Maximum call stack size exceeded \n+-- react-styleguidist@6.0.33\n| `-- react-docgen@3.0.0-beta9. edit: A complete reinstall of all packages solved this.\nFor the next time is there a way to actually see a more detailed stack trace output of npm run tasks to locate why this recursion is happening? Like which packages are required from where?\n@danez it seems it just keeps going:\n```\n$ npm run react-docgen -- src/components/PhoneNumber.js\n\nxxx@7.1.0 react-docgen C:\\dev\\projects\\evopark\\app\nnpm run react-docgen \"src/components/PhoneNumber.js\"\nxxx@7.1.0 react-docgen C:\\dev\\projects\\evopark\\app\nnpm run react-docgen \"src/components/PhoneNumber.js\"\nxxx@7.1.0 react-docgen C:\\dev\\projects\\evopark\\app\nnpm run react-docgen \"src/components/PhoneNumber.js\"\n\n```\nUntil I press CTRL+C\n```es6\nimport React from \"react\"\nimport PropTypes from \"prop-types\"\nimport styled from \"styled-components\"\n/* A phone number is a string /\nexport const PhoneNumberType = React.PropTypes.string\nconst PROPTYPES = {\n  / The number as a string. It will be normalised */\n  number: PhoneNumberType.isRequired,\n  / The content to display instead of the number */\n  children: PropTypes.node,\n}\nconst PhoneNumberLink = styled.awhite-space: nowrap;\n// https://trello.com/c/rduUgl0w/1120-normalize-telephone-numbers\nexport const normalizePhoneNumber = number => (\n  number.toString().replace(/[.- ()/]|(?:(0))/g, \"\")\n)\nexport const phoneUrl = number => tel:${normalizePhoneNumber(number)}\n/\n * A link <a> to a phone URL (tel:)\n \n * Activating this link will launch the mobile devices phone app or on the\n * desktop most likely Skype.\n \n * You should always provide a valid international phone number (ie: +49-221-433433).\n * This way your users can call the number from anywhere on the world and not\n * only when they are local to the phone number.\n */\nconst PhoneNumber = ({ number, children = number }) => (\n  {children}\n)\nPhoneNumber.propTypes = PROPTYPES\nexport default PhoneNumber\n```\nThe thing is, it worked yesterday but to a mistake I cleared my stash :(. @danez eslint-plugin-react uses a very good component detection algo. Maybe you could borrow that?\nhttps://github.com/yannickcr/eslint-plugin-react/blob/master/lib/util/Components.js\nMaybe isReturningJSX is all you'd need?. Interesting. Then maybe its a bug in how react-styleguidist works with the react-docgen ouput. I'll verify and re-open here if necessary.. ",
    "caseycallow": "Ran into this earlier. Converting to an if statement fixes it temporarily. Would really like to be able to use ternary statements with SFCs though.\nWorks:\n```\nconst Heading = ({ element: Element, children }) => {\nconst heroMarkup = {children};\n  const headingMarkup = {children};\nif (Element === \"hero\") return heroMarkup;\n  return headingMarkup;\n};\nDoesn't work but should:\nconst Heading = ({ element: Element, children }) => {\nconst heroMarkup = {children};\n  const headingMarkup = {children};\nreturn Element === \"hero\" ? heroMarkup : headingMarkup;\n};\n. @bregenspan Looks like it's fixed on our end, thanks!. ",
    "bregenspan": "This appears to have been fixed in https://github.com/reactjs/react-docgen/commit/d2c096f2e4212606fe6f283f740ab0d74e77c103 - @caseycallow @0xR can you confirm?. ",
    "CompuIves": "Ah, I just read that it probably should in a seperate handler @fkling. If you still have this opinion I can move it to a seperate handler.\n. Rebased!\n. ",
    "eisisig": "Any idea of a new version? I need this :)\n. Looking forward to it! Hope you had a good one\n. ",
    "ritz078": "same. waiting for the release.\n. ",
    "hramos": "This can be closed. Thanks!\n. ",
    "stepankuzmin": "Hi everyone! It seems that it is still an issue.\nConsider example:\n```js\n// @flow\nimport type { GeoJSONSourceSpecification } from 'mapbox-gl/src/style-spec/types';\ntype Props = GeoJSONSourceSpecification & { id: string };\nclass GeoJSONSource extends PureComponent {\n  ...\n}\n```\nWhen I run \nshell\nreact-docgen src/components/GeoJSONSource/index.js\nI'm getting \njson\n{\n  \"description\": \"\",\n  \"displayName\": \"GeoJSONSource\",\n  \"methods\": [],\n  \"props\": {\n    \"id\": {\n      \"required\": true,\n      \"flowType\": {\n        \"name\": \"string\"\n      },\n      \"description\": \"\"\n    }\n  }\n}\nHowever, GeoJSONSourceSpecification type is exported successfully\n\nAm I missing something?. Oh, I see. Thanks for reply @fkling. Maybe I will create PR for this.. ",
    "aaronjensen": "babylon 6 can handle all of these though, right? Is it just a version issue?\nThe flow parser is ocaml, so I'm not sure it could be used here.\n. I wonder if going the route of eslint and having pluggable parsers is the right way. It's too bad we can't just have one \ud83d\ude04 . ",
    "awesomejerry": "I initialized a new and simple project:\n{\n  \"name\": \"react-docgen-test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"docgen\": \"react-docgen src --pretty\",\n    \"docgen-resolver\": \"react-docgen src --pretty --resolver findExportedComponentDefinition\",\n    \"docgen-ignore\": \"react-docgen src --pretty --ignore [styles]\",\n    \"docgen-exclude\": \"react-docgen src --pretty --exclude ['/^(style)/g']\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"react-docgen\": \"^2.10.0\"\n  }\n}\nwith following files:\n\nand those files are simple:\nComponent.js:\n```\nimport React, { Component } from 'react';\n/*\n   * This is a simple component\n   /\nclass MyComponent extends Component {\n  render() {\n    return (\n      123\n    );\n  }\n}\nexport default MyComponent;\n```\nstyle.js:\nexport default {\n  title: 'This shouldn\\'t be parsed by react-docgen',\n};\nNo matter which script I run, the error is the same:\n\nI thought the default behavior is that react-docgen only parse react component files. However the cli options seem not working either.\n. The -e style.js part works, but it's very trivial to exclude every kind of files. The better way is what it's already listed in README this will look for the exported component created through React.createClass or a class definition in the provided source. Only parse files that define components.\nI'm not sure if it's currently working or should I put some configs in the command.\n. ",
    "n1313": "I have spent a couple of hours trying to exclude some files and after digging into sources of node-dir (see 1, 2) managed to do it. \nThis command will recursively consume src, exclude every file named index.js and output the result into a file:\n    react-docgen src --pretty -e index.js -o output.json\nSo it seems that CLI options are working. I wasn't able to make CLI exclude an array though, the --exclude parameter is always passed to node-dir as a string. I don't think there's a test here covering this case.\n. I'm having the same problem: I have a bunch of string constants shared across many files and docgen (understandably) does not pick up their values when I use them in propType declarations. I think this use case is simpler than #33 and could probably be fixed by supplying docgen with a map of constants and doing a search-replace for them in AST data before emitting it. . ",
    "Kryten0807": "The documentation for the exclude option says \"Filename pattern to exclude\" - I'm reading that to mean that it will match a pattern and exclude those files. But I can't find a way to specify a pattern that works.\nI can explicitly exclude files by specifying the full file name, but cannot exclude files by pattern. For example, I'm trying:\nreact-docgen src/components/ -o test.json -e *.spec.js\n\nAnd getting a whole bunch of \"No suitable component definition found\" errors.\nI've tried a number of different ways of specifying that pattern:\n# try * wildcards?\nreact-docgen src/components/ -o test.json -e *.spec.js\nreact-docgen src/components/ -o test.json -e **/*.spec.js\nreact-docgen src/components/ -o test.json -e src/components/*.spec.js\nreact-docgen src/components/ -o test.json -e src/components/**/*.spec.js\n\n# maybe a regex?\nreact-docgen src/components/ -o test.json -e '/.*.spec.js/'\nreact-docgen src/components/ -o test.json -e '.*.spec.js'\nreact-docgen src/components/ -o test.json -e .*.spec.js\n\nEDIT\nA little more digging reveals that the problem is with the node-dir package. In short, this package always assumes you want to build an array of \"excludes\" and passes that to node-dir. However, node-dir either accepts a regular expression or an array of strings, but not both.\nIdeally, I think the fix should be with node-dir - it should probably be a little more \"open minded\" about the list of exclusions it receives and be able to handle an array of regular expressions and strings.\n. ",
    "mmeineke": "I tried it with node 4 and 6. Was wondering as well why I ran into this issue\n. I will provide you with an example\n. I created 2 examples which uses exactly the same code as in the examples in this repo beside the amount of props. The first example with a component with 100 props and the second with 1000 props. Please try if the second one fails for you as well.\nhttps://github.com/mmeineke/react-docgen-test\n. Hey, I removed the process.exit completely now.\n- renamed exitWithResult to writeResult\n- removed exitWithError (added process.exitCode = 1; instead)\n- traverseDir throws an error now which gets catched\nWhat I don't like and hopefully you have a better idea is line 153:\nif (process.exitCode !== 1) {\nWhich I needed to implement because of the removed exitWithResult in line 91/95\n. @danez , @fkling what do you think?\n. I replaced the writeError+ process.exit with an errorMessage which could be used for other error messages in the future as well.\nThis errorMessage gets written below with the process.exit.\nWould be fine for me now.\n. @danez Hey, could we merge the PR now?\n. @danez thanks a lot :)\n. Actually yes, but I wanted to get rid of the eslint no-process-exit: 0 line :D\nI would say you should only disable a linting rule if there is no other way.\n. Seems legit. But disabling this rule could lead to the same problem in the future.\nSo I would prefer to have this rule enabled also here. Are the new changes ok for you?\n. ",
    "aweber1": "Ah! I did see that issue and the PR before I posted, just thought it had already been released and that I was doing something unexpected :) Thanks!\n. ",
    "andyearnshaw": "@coot are you planning on adding the tests @fkling asked for soon? I'd certainly appreciate having this functionality :smile:.. Sure! I will try to make time over the next week.. ",
    "coot": "@andyearnshaw - it might take me a while to do that, do you fancy adding them?. ",
    "arunoda": "This is pretty fast guys. Awesome. \n. ",
    "tchon": "@fkling It looks like https://github.com/reactjs/react-docgen/pull/134 will not address the hanging on chained methods. See improved PR here: https://github.com/reactjs/react-docgen/pull/139. @flut1 I've added the TemplateLiteral to list of invalid callee types.  If you can provide a code example, then I can also add it to the spec fixtures. Thanks!. \ud83d\udc4d thanks @fkling @danez . ",
    "wbinnssmith": "cc @mroch @gabelevi on the Flow issues, not sure how much a priority (arguably deprecated) decorators are, but I imagine that failing test case might help with facebook/flow#2741\n. ",
    "jribeiro": "@danez I see the your feature babel/babylon#277 was merged but this PR is still opened. Do you know if this is this still an issue?. Great @danez, will do. Thanks a lot. ",
    "flut1": "I recently had the hanging issue on a template literal, even after applying this PR. After adding the type TemplateLiteral to the list of types in isValidCalleeType the issue was resolved. @tchon \nexport function templateLiteral() {\n  return `foo bar`.split(' ');\n}. ",
    "rhalff": "Experiencing the same issue and glad to find there is already a pull request to solve this issue, however it does not seem to cover all cases.\nA (mixin) declaration like this will also hang:\njs\nexport default function withThis() {\n  return this.foo();\n}\nThe contents of calleeValue within https://github.com/reactjs/react-docgen/blob/master/src/utils/isStatelessComponent.js#L96 will continuously be:\njs\nNodePath {\n  value: undefined,\n  parentPath: \n   NodePath {\n     value: undefined,\n     parentPath: \n      NodePath {\n        value: undefined,\n        parentPath: [Object],\n        name: 'object',\n        __childCache: [Object] },\n     name: 'object',\n     __childCache: { property: [Circular] } },\n  name: 'property',\n  __childCache: null }\nUpdate:\n Adding 'ThisExpression' to the list will probably solve it.\nTo be safe perhaps the check should include the valid ones instead of checking for !== 'Identifier'.. Agreed, in which case I'm just suggesting to also add the 'ThisExpression' to the invalid types.. ",
    "johhansantana": "ah alright, thanks!. ",
    "withinboredom": "@danez I've addressed those issues if you'd like to take another look. No problem, glad to be of service \ud83d\udc4d . Oh, my mistake. Will fix asap.. Added back :). ",
    "redak105": "Thanks for your reply.\nI'm specifically interested in fat arrows functions. Are these supported?. Sorry for my late response. \nI have this testing class. I run react-docgen. But I didn't get show method in my output.\n`\n/*\n * Test class\n /\nexport default class TestClass extends Component {\n/**\n * Constructor\n * @property props\n */\nconstructor(props) {\n    super(props);\n\n    this.opacity = 0;\n};\n\n/**\n * show row\n */\nshow = () => {\n    opacity = 1;\n};\n\n/**\n * Render\n */\nrender() {\n    return (\n        <View style={[styles.viewRow, {opacity}]}>\n    <Text style={styles.textVideoName}>\n      {this.props.title}\n    </Text>\n        </View>\n    );\n}\n\n}\nTestClass.propTypes = {\n    /*\n     * title\n     * @type {String}\n     /\n    title: PropTypes.string.isRequired,\n};\n`. I have same problem with redux. I have JS files with only functions, because redux definition of actions and reducers. Is there possibility to export this files in your framework?  findAllExportedComponentDefinitions didn't works.\nexample:\n```js\n/\n * action types\n /\nexport const ADD_TODO = 'ADD_TODO'\nexport const TOGGLE_TODO = 'TOGGLE_TODO'\nexport const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'\n/\n * action creators\n /\nexport function addTodo(text) {\n  return { \n     type: ADD_TODO, text\n   }\n}\nexport function toggleTodo(index) {\n  return { \n      type: TOGGLE_TODO, index \n  }\n}\n```. ",
    "DanielRamosAcosta": "@fkling I'm having errors with arrow functions in class methods as the render method... I have a component like this:\n```jsx\nclass Foo extends Component {\n  (...)\nrender = () =>\n    \n      Foo!\n    \n}\n```\nBut it throws to me No suitable component definition found.... is there any solution to this? Maybe a handler?. I'll give it a shot, thanks for your work!. ",
    "bsmith-cycorp": "I don't understand what the reasoning is for that, but more importantly I don't understand how we're supposed to cleanly convert from the \"stringified\" value to a usable one.. I guess the function example is a valid use case.\nI'm using the json output as a React prop passed into a documentation app, which uses it to render all the documentation in a nice view. I ran into trouble when trying to set up demo instances of each documented component, preconfigured with their default properties. I ended up having to do this to get the \"true\" string value:\nvar defaultValue = prop.defaultValue.value;\nif(prop.type.name === 'string') {\n    defaultValue = defaultValue.substr(1, defaultValue.length - 2);\n}\nwhich works, but is pretty hacky. With the new push for ES6 class syntax over the now-deprecated React.createClass(), this issue has become a little bit more prevalent. ES6 classes don't (yet) support static data members without a MyClass.myProp = ... outside of the main class definition. They do, however, support static getters, but that would mean returning something like propTypes from a function.\nFull example:\n```\nclass MyComponent extends React.Component {\nstatic get propTypes() {\n    return {\n      ...\n    }\n  }\n}\nvs.\nclass MyComponent extends React.Component {\n}\nMyComponent.propTypes = {\n}\n```\nIt would be really nice to be able to declare propTypes inside the ES6 class body and still have them be detected by react-docgen, although I still wouldn't call it absolutely essential.. Full log:\n0 info it worked if it ends with ok\n1 verbose cli [ '/usr/local/Cellar/node/7.1.0/bin/node',\n1 verbose cli   '/usr/local/bin/npm',\n1 verbose cli   'run',\n1 verbose cli   'build:doc' ]\n2 info using npm@5.3.0\n3 info using node@v7.1.0\n4 verbose run-script [ 'prebuild:doc', 'build:doc', 'postbuild:doc' ]\n5 info lifecycle component-documentation@1.0.0~prebuild:doc: component-documentation@1.0.0\n6 info lifecycle component-documentation@1.0.0~build:doc: component-documentation@1.0.0\n7 verbose lifecycle component-documentation@1.0.0~build:doc: unsafe-perm in lifecycle true\n8 verbose lifecycle component-documentation@1.0.0~build:doc: PATH: /usr/local/lib/node_modules/npm/bin/node-gyp-bin:/Users/bsmith/svn/cyc/doc/app/src/cyc-ui/src/projects/component-documentation/node_modules/.bin:/Users/bsmith/bin:/Users/bsmith/.npm_global/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin\n9 verbose lifecycle component-documentation@1.0.0~build:doc: CWD: /Users/bsmith/svn/cyc/doc/app/src/cyc-ui/src/projects/component-documentation\n10 silly lifecycle component-documentation@1.0.0~build:doc: Args: [ '-c',\n10 silly lifecycle   'react-docgen ../../lib/components/*/*.react.js --pretty -e index.js --resolver findAllComponentDefinitions -o ./documentation-data.json' ]\n11 silly lifecycle component-documentation@1.0.0~build:doc: Returned: code: 1  signal: null\n12 info lifecycle component-documentation@1.0.0~build:doc: Failed to exec build:doc script\n13 verbose stack Error: component-documentation@1.0.0 build:doc: `react-docgen ../../lib/components/*/*.react.js --pretty -e index.js --resolver findAllComponentDefinitions -o ./documentation-data.json`\n13 verbose stack Exit status 1\n13 verbose stack     at EventEmitter.<anonymous> (/usr/local/lib/node_modules/npm/lib/utils/lifecycle.js:289:16)\n13 verbose stack     at emitTwo (events.js:106:13)\n13 verbose stack     at EventEmitter.emit (events.js:191:7)\n13 verbose stack     at ChildProcess.<anonymous> (/usr/local/lib/node_modules/npm/lib/utils/spawn.js:40:14)\n13 verbose stack     at emitTwo (events.js:106:13)\n13 verbose stack     at ChildProcess.emit (events.js:191:7)\n13 verbose stack     at maybeClose (internal/child_process.js:885:16)\n13 verbose stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:226:5)\n14 verbose pkgid component-documentation@1.0.0\n15 verbose cwd /Users/bsmith/svn/cyc/doc/app/src/cyc-ui/src/projects/component-documentation\n16 verbose Darwin 16.7.0\n17 verbose argv \"/usr/local/Cellar/node/7.1.0/bin/node\" \"/usr/local/bin/npm\" \"run\" \"build:doc\"\n18 verbose node v7.1.0\n19 verbose npm  v5.3.0\n20 error code ELIFECYCLE\n21 error errno 1\n22 error component-documentation@1.0.0 build:doc: `react-docgen ../../lib/components/*/*.react.js --pretty -e index.js --resolver findAllComponentDefinitions -o ./documentation-data.json`\n22 error Exit status 1\n23 error Failed at the component-documentation@1.0.0 build:doc script.\n23 error This is probably not a problem with npm. There is likely additional logging output above.\n24 verbose exit [ 1, true ]. Apologies- something weird was happening and even though I deleted my node_modules, it was still installing v2.18.0.. ",
    "dgarofalo": "I had the same problem important constants from an npm package.\n// Constants.js\nmodule.exports = {\n    FOO: 'bar',\n    OTHER_FOO: 'bar'\n};\nImporting the constants as named imports only worked if I imported one thing. I updated the syntax to use a default import, and then destructured it like so:\n```\nimport Constants from './Constants';\nconst {\n    START_DATE,\n    ANCHOR_LEFT,\n    ANCHOR_RIGHT\n} = Constants;\n```. ",
    "jboelen": "Had to do the same as @dgarofalo to get past this issue.\njsx\nimport * as Constants from './constants';\nconst { VIEW, EDIT, DELETE } = Constants;. ",
    "danielgefen": "Thanks! I believe that this is my most common case, then this solution should do.. ",
    "michalstocki": "Unfortunately the the following syntax doesn't work:\n```javascript\nimport genericButtonProps from '../../common/buttons/genericButtonProps';\n// ...\nconst buttonSpecificProps = {\n  onClick: PropTypes.func,\n  trigger: PropTypes.object,\n  type: PropTypes.oneOf(['submit', 'reset', 'button', 'menu']),\n};\nButton.propTypes = { ...genericButtonProps, ...buttonSpecificProps };\n``\nOnly properties defined inbuttonSpecificPropsare serialized. Of course I've tried the approach withObject.assign` but it doesn't work too. It would be really nice if I could import props from another file.. ",
    "dan-kez": "I also have hit this snag. It would be great if we could merge proptypes with spread operators / Object.assign. ",
    "carrickjason": "Does anyone know if anything has come of this?  This would be an incredible feature.. ",
    "jadengore": "Bump on this, any plans to support it?. ",
    "chrisdrackett": "sure, this is what I'm doing:\nIn an external file that is shared by a couple components:\n```\nconst status = {\n  info: {\n    color: 'gray',\n    icon: 'info',\n  },\n  normal: {\n    color: 'green',\n    icon: 'check',\n  },\n  warning: {\n    color: 'orange',\n    icon: 'warning',\n  },\n  error: {\n    color: 'red',\n    icon: 'x',\n  },\n}\nconst statusValues = Object.keys(status)\n```\nIn a component that accepts one of the statuses listed above:\nstatus: PropTypes.oneOf(statusValues)\nI'm looking for the list ['info', 'normal', 'warning', 'error']. ok, I'm using react-styleguidist which uses docgen. I'll see if I can figure out another method (or just write them by hand again). also, of note, I did just try and do this with an object in the same file and I still get this output. So while this might not ever work for an object from an external file it might still be nice for something within the same file.. ah, right, I have the memory of a goldfish. carry on!. ",
    "motleydev": "I would like this as well. Seems that variables should be evaluated before the docs get \"scraped\" from the file.. ",
    "MaxInMoon": "+1. ",
    "AoDev": "It does not break in styleguidist but rather in a third party dependency on\nwhich one may or may not have control.\nI understand the situation, and that you prefer to have \"clean\" key value\nstore. So, more as a personal curiosity. What do you think would happen if\neverybody started to create objects randomly this way? Wouldn't this break\na lot of code relying on this, although valid?\nI understand the object is not \"owned\" by us, but then instead of checking\nfor hasOwnProperty now, should everyone starts checking if the object has a\nprototype although it's perfectly valid. What do you think?\nOn Mon, Feb 13, 2017, 17:56 Felix Kling notifications@github.com wrote:\n\nThanks @AoDev https://github.com/AoDev! However, I think this is better\nsolved in styleguidist by using something like Object.prototype.hasOwnProperty.call(obj,\n...).\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/reactjs/react-docgen/pull/156#issuecomment-279452088,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABdJhgV_3vU8E94rNAOwI8GHaOIcDMwfks5rcItHgaJpZM4L_DGq\n.\n. I was reading the Map docs on the Mozilla site when I answered. Obviously it's a problem because of the language.\n\nWhat brings my attention on their site is:\nAn Object has a prototype, so there are default keys in the map that could\ncollide with your keys if you're not careful. This could be bypassed \nby using map = Object.create(null) since ES5, but was seldom done.\nI think that my personal practice on this is will be to avoid using Object.create(null) mainly because of a legacy usage of the JS language, although valid, unless I use Map. \n. But, anyway, I think you can close this PR unless you decide to accept the change. Thank you for your answers : ). ",
    "pascalduez": "This should allow us the use common imports for modules and types, which currently crashes:\njs\nimport { myModule, type myType } from 'my-module';\n. ",
    "developit": "This is great. Would love to recommend react-docgen as a documentation solution that works out-of-the-box with preact :). ",
    "eduardoboucas": "Just checking if this has been merged to npm so I can go back to using the main package instead of my fork.\nThanks! \ud83e\udd13 . ",
    "alexyork": "Today I discovered I need this feature, also. Can someone on the react-docgen team merge this into master and ship a new version?\nMy usecase is this: I want to point to a /components folder and create docs for my components but exclude all files that match the pattern *.example.js. Currently -e *.example.js sends in ['*.example.js'] as a string, not a RegEx, so I cannot achieve what I want via the CLI.\nI tried this PR and passed in -e /.example.js/ and it worked as expected.\nI would love it if this got merged in :-). ",
    "damian": "Is there anything stopping this getting looked at?. Excellent - thank you!. ",
    "dotcs": "May be related to this issue: https://github.com/reactjs/react-docgen/issues/33. ",
    "Palid": "+1, this breaks rendering in react-styleguidist too :(. ",
    "kazazor": "We're also seeing issues due to that. For example we're now getting this output:\nprop | type | default | required | description\n---- | :----: | :-------: | :--------: | -----------\nchildren | (custom validator) |  | :x: | The components's children\nclassName | (custom validator) |  | :x: | A custom CSS class name\ndisabled | (custom validator) |  | :x: | Whether the anchor is clickable or not\nhovered | (custom validator) |  | :x: | Whether the button is in hover state\nonClick | (custom validator) |  | :x: | A callback function for click event\nWhile we used to get:\nprop | type | default | required | description\n---- | :----: | :-------: | :--------: | -----------\nchildren | ReactNode |  | :white_check_mark: | The components's children\nclassName | String |  | :x: | A custom CSS class name\ndisabled | Boolean |  | :x: | Whether the anchor is clickable or not\nhovered | Boolean |  | :x: | Whether the button is in hover state\nonClick | Function |  | :x: | A callback function for click event\nSo it's the Required & the type that does not work.. ",
    "joris974": "It is working well with v3 beta. It makes sense, babylon supports flow exact object notation starting at 6.10.0 and react-docgen@2.14.0 uses babylon@5.8.38. The beta v3 uses babylon@7.0.0-beta.8.\nI guess I will just wait a bit for stable v3.\nThank you for your help @fkling.. ",
    "kevinbarabash": "Although upgrading the parser will support the basic notation, often times you'll want to combine types using spread notation which means code changes are necessary for full support.  Here's an example:\ntype Foo = {|foo: string|};\ntype Bar = {|bar: number|};\ntype FooBar = {|\n   ...Foo,\n   ...Bar,\n|};  // same as {|foo: string, bar: number|}. ",
    "ryanthemanuel": "I just tested the 2.14.1 release and it works for us.  Thanks!. ",
    "KamranAsif": "Anything blocking this @fkling?. ",
    "wcjordan": "We know that feeling.  Thanks for your hard work on the library; let me know if you have any recommended changes for the PR.. Weird.  I'm able to reproduce locally though, so I can dig in.. I believe the issue is that this is very promiscuous\nif (!match(path.node, {type: 'CallExpression'})) {\n  return false;\n}\nvar module = resolveToModule(path.get('callee', 'object'));\nOne heuristic I could take would be to assume the method will be named createReactClass e.g. import createReactClass from 'create-react-class'; or const createReactClass = require('create-react-class');.\nAnother alternative might be to make a lighter weight version of resolveToModule which doesn't follow MemberExpressions or VariableDeclarators e.g. assume we're importing directly into the variable as which we use createReactClass.\nThoughts?  Also I'd like to write some tests for these cases.  Would it be best to imitate something like isReactComponentClass-test.js?. Your tip worked like a charm.  Thanks!\nAlso I've added tests for existing and new functionality as well as a new snapshot.\nI've also verified it works for fixed-data-table-2's usage.\nI'm feeling much better about things now.  Let me know if you have any additional suggestions.. ",
    "blakcap": "Ah, that makes more sense! I thought it did (or was supposed to do) cross-file resolution too.\nWriting a resolver that finds connect calls might not be too difficult...I'm honestly just hoping to find a documentation-generation tool that can parse my React/Flow code. Basically, just JSDoc + React/Flow parsing.\nThanks for the clarification :). ",
    "threehams": "I'm having the same issue with a different type of HOC. Is there a way we could manually hint to the parser (through comment or code) that something returns a React component? Making exceptions for specific ones probably isn't sustainable, given the number of them out there (Radium, Aphrodite, Relay, recompose, react-redux, ...rest).\n```\nimport { compose, withState, withHandlers } from \"recompose\";\nconst FixedComponent: Class> = compose(\n  withState(\"fixed\", \"setFixed\", false),\n  withHandlers({\n    onEnter: props => () => props.setFixed(false),\n    onLeave: props => () => props.setFixed(true),\n  }),\n)(Component);\n``. Could use jsdoc's@type`. I'd be a little concerned about piggybacking on existing tags - would there be cases that work now, but would break with something like this? (I have very little experience with jsdoc so I'm not sure if there are major downsides here.)\n/**\n * Fixes the component to the top of the page after scrolling past it.\n * @type React.Component\n * or\n * @type Component\n */\nconst FixedComponent: Class<Component<Props, null, null>> = compose(\n// etc\nIt feels a bit strange to have to add a jsdoc tag when using Flow, but typing HOCs is very experimental right now.. ",
    "FezVrasta": "Hi, looks like this is a deal breaker for people using recompose to create their components.\nIs there any progress on this front?. Isn't there any way to manually mark a function as \"component\"? Maybe with a comment, or a regex?\nIn my case I only export default components, so I would just like react-docgen to use them all... To me it would be enough even to simply support something like // @component<Props> or similar anyway.. ",
    "janzenz": "Solved the issue after upgrading to 2.14.0. ",
    "rosskevin": "At the root, this does look like a duplicate of #33.\nRegarding module resolution, I suspect it will have to be rather smart or reuse something from node or flow.  I am unfamiliar with the code here, so not sure about the challenges, but let me just add some pertinent details.\nFlow types are available from:\n1. libdefs - as set by the [libs] in the .flowconfig\n2. libdefs - as available in the <PROJECT_ROOT>/flow-typed directory\n3. shadow files - as available in any node_modules/* as *.js.flow files.  e.g. flow-source-copy is script that helps distribute flow types with a package.\n4. localized in a single file in the project\n5. imported by a project file\nlibdefs are globally available or bound to a module namespace, whereas import type works just as you would import any other js function etc (either from a node_module or local file).. I'm trying to venture down this path but I'm afraid I know little about this toolset.\nI presume I would:\n1. Determine import type statements\n2. Gather exported flow types\n3. Recurse over all files found in number 1, until no more import type declarations found\n4. Do a normal parse\n5. Merge flow type definitions \nFirst thing is to discover the types imported and from where.  I determined how to get the information but not how to return it through the resolver/handler.  I unclear if I'm on the right track or even using the full capability of this toolset.\nCalled from our api-docs/index.js\njavascript\nreactDocgen.parse(src, findFlowTypeImportDefinitions)\n```javascript\n// @flow\nimport { utils } from 'react-docgen';\nimport type { NodePath } from './types';\n/*\n * Given an AST, this function tries to find the exported flow type definition.\n /\nexport default function findFlowTypeImportDefinitions(\n  ast: ASTNode,\n  recast: Object,\n): ?NodePath {\nfunction importTypeDeclaration(path: NodePath) {\n    let definition\n    if (path.node.importKind === 'type') {\n      if (path.node.specifiers) {\n    // to be done in the handler?\n    //const specifiers = path.get('specifiers');\n    //specifiers.each(\n    //  (specifier) => {\n    //    const local = specifier.get('local');\n    //    types.push(local.value.name);\n    //  },\n    //);\n    // structure return representing types import?\n    //return {\n    //  module: path.node.source.raw,\n    //  types: types,\n    //};\n\n\n    definition = path;\n  }\n}\n\n//    if(!definition) {\n//      return false;\n//    }\n    return false;\n  }\nrecast.visit(ast, {\n    visitImportDeclaration: importTypeDeclaration\n  });\n}\n```\nI've got a branch started with these experiments.\nAny guidance is appreciated.  We need to solve this before our next major release.. It seems that a new plugin inline's the flow types, this might solve this problem for me altogether.\nhttps://twitter.com/thejameskyle/status/870764494917582850\nhttps://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types. react-docgen@2.14.1. 3.0.0.beta4 worked, thanks!. Please change the title to something referencing Flow 53, hopefully this will get everyone's attention. I'm trying out 2.18.0 on material-ui/v1-beta and it is still failing to parse the first file.  I'm trying to isolate where it is, but I do know it is falling through in the flowParsePrimaryType.  If others are having problems or finding quirks, please let us know.\nI'll see if I can get an isolated test case figured out.. I have an error, it is failing on a stateless function.  @oliviertassinari good to know, I'm using 2.18.0 release on the tip of v1-beta.\nLooking at the package to see if the change made it.. This failure originates in react-docgen's babylon at flowParsePrimaryType.  Versioning issue?\n```javascript\n$ rimraf pages/api/* && babel-node ./docs/scripts/buildApi.js\nError parsing src for /Users/kross/projects/material-ui/src/Avatar/Avatar.js\n/Users/kross/projects/material-ui/docs/scripts/buildApi.js:87\n    throw err;\n    ^\nSyntaxError: Unexpected token (53:21)\n    at Parser.pp.raise (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/parser/location.js:24:13)\n    at Parser.pp.unexpected (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/parser/util.js:82:8)\n    at Parser.pp.flowParsePrimaryType (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:552:8)\n    at Parser.pp.flowParsePostfixType (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:557:38)\n    at Parser.pp.flowParsePrefixType (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:573:17)\n    at Parser.pp.flowParseIntersectionType (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:579:19)\n    at Parser.pp.flowParseUnionType (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:589:19)\n    at Parser.pp.flowParseType (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:600:19)\n    at Parser.pp.flowParseTypeParameterInstantiation (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:217:27)\n    at Parser.pp.flowParseGenericType (/Users/kross/projects/material-ui/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:364:32)\nerror Command failed with exit code 1.\n```\nyarn list babylon\nyarn list v0.27.5\n\u251c\u2500 babylon@6.18.0\n\u251c\u2500 react-docgen@2.18.0\n\u2502  \u2514\u2500 babylon@5.8.38\n\u2514\u2500 styled-jsx@1.0.10\n   \u251c\u2500 babel-traverse@6.21.0\n   \u2502  \u2514\u2500 babylon@6.18.0\n   \u2514\u2500 babylon@6.14.1\nyarn why babylon\nyarn why v0.27.5\n[1/4] Why do we have the module \"babylon\"...?\n[2/4] Initialising dependency graph...\n[3/4] Finding dependency...\n[4/4] Calculating file sizes...\ninfo Has been hoisted to \"babylon\"\ninfo Reasons this module exists\n   - \"babel-core\" depends on it\n   - \"babel-eslint\" depends on it\n   - \"babel-plugin-preval\" depends on it\n   - \"next#babel-core\" depends on it\n   - \"next#styled-jsx#babel-traverse\" depends on it. Failure is on children?: Element<*>, I also have component?: string | ComponentType<*> but I commented it out on the hunch that the Element inference was breaking it.. I'm going to pull and add some children test cases instead of working from the outside.. @adityavohra7 is this still a WIP or is it good to use/merge?\n@danez #221 is a huge problem for material-ui docs - if you could take a look and let us know if this direction is good, we need to get our docs generating correctly again.  \nThanks to you both!. I just noticed that this is for master and we are already dependent on the 3.0-dev releases.  I'm going to try and work this code into that branch and see if I can get material-ui running again.. Hold, I have a bug to work out.. Ok, this is good to go and passes with the material-ui codebase.  I have added every case that broke to component_11.. Casting to ElementType to avoid other flow errors and avoid typing all default props. Just one alternative.  BTW We have since removed flow from our codebase.. ",
    "daoanhnhat1995": "@fkling I was tracing #147 and #137, and tried with installing react-docgen@next. However, results still didn't include my arrow functions. \n```javascript\nimport React, { Component } from 'react';\nimport styled from 'styled-components';\n/*\n * React component that display current time at current location.\n /\nclass Clock extends Component {\nconstructor(props){\n    super(props);\n    const currentTime = new Date();\n    this.state = this.getTime();\n}\n\ncomponentDidMount() {\n    this.setTimer();\n}\n\ncomponentWillUnmount(){\n    // Avoiding timeout still runs when component is unmounted\n    if (this.timeOut) {\n        clearTimeout(this.timeOut);\n    }\n}\n\n/**\n * Update clock state with new time\n *\n */\nupdateClock = () => {\n    const currentTime = this.getTime();\n    this.setState(currentTime);\n    this.setTimer();\n}\n\n/**\n * Parse current Date object\n *\n * @returns {Object} currentTime\n *  @returns {int} currentTime.hour\n *  @returns {int} currentTime.minutes\n *  @returns {string} currentTime.ampm \"am\" or \"pm\"\n *  @returns {string} currentTime.dayOfWeek \n *  @returns {string} currentTime.month\n *  @returns {int} currentTime.date\n */\ngetTime = () => {\n    const dateObject = new Date();\n    const dateString = dateObject.toDateString().split(\" \");\n    const currentTime = {\n        hours: dateObject.getHours(),\n        minutes: dateObject.getMinutes(),\n        seconds: dateObject.getSeconds(),\n        ampm: dateObject.getHours() >= 12 ? 'pm' : 'am',\n        dayOfWeek: dateString[0],\n        month: dateString[1],\n        date: dateString[2]\n    };\n\n    return currentTime;\n}\n\n/**\n * Update current clock for every 1 second\n *\n */\nsetTimer = () => {\n    this.timeOut = setTimeout(()=> {\n        this.updateClock() \n    }, 1000);\n}\n\nrender(){\n    const {\n        hours,\n        minutes,\n        seconds,\n        ampm,\n        dayOfWeek,\n        month,\n        date\n    } = this.state;\n\n    const ClockContainer = styled.div`\n        color: #fff;\n        font-size: xx-large;\n        float: right;\n        top: 1em; \n        position: relative;\n    `;\n\n    return(\n        <ClockContainer>\n            { this.props.title } <br />\n            { dayOfWeek }, { month } { date } <br/> \n            {\n                hours == 0 ? 12 :\n                    (hours >12) ? hours - 12 : hours\n            }: {\n                minutes > 9 ? minutes: `0${minutes}`\n            }: {\n                seconds > 9 ? seconds: `0${seconds}`\n            } {ampm} <br/>\n\n        </ClockContainer>\n    );\n}\n\n}\nClock.propTypes = {\n    /* A text display current's user identity,\n     *  \"Nobody\" if no one is detected in the background,\n     *  \"Hi, ..name\" if an user is detected \n     /\n    title: React.PropTypes.string\n}\nexport default Clock;\n```\nResult from this doesn't include my functions above:\njson\n{\n  \"description\": \"React component that display current time at current location.\",\n  \"methods\": [],\n  \"props\": {\n    \"title\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"A text display current's user identity,\\n \\\"Nobody\\\" if no one is detected in the background,\\n \\\"Hi, ..name\\\" if an user is detected\"\n    }\n  }\n}\nHowever, if i change all arrow functions to regular functions, results are expected:\njson\n{\n  \"description\": \"React component that display current time at current location.\\nBy parsing new Date() from browser.\",\n  \"methods\": [\n    {\n      \"name\": \"updateClock\",\n      \"docblock\": \"Update clock state with new time\",\n      \"modifiers\": [],\n      \"params\": [],\n      \"returns\": null,\n      \"description\": \"Update clock state with new time\"\n    },\n    {\n      \"name\": \"getTime\",\n      \"docblock\": \"Parse current Date object\\n\\n@return {Object} currentTime\\n@return {int} currentTime.hour\\n@return {int} currentTime.minutes\\n@return {string} currentTime.ampm \\\"am\\\" or \\\"pm\\\"\\n@return {string} currentTime.dayOfWeek \\n@return {string} currentTime.month\\n@return {int} currentTime.date\",\n      \"modifiers\": [],\n      \"params\": [],\n      \"returns\": {\n        \"description\": \"currentTime\",\n        \"type\": {\n          \"name\": \"Object\"\n        }\n      },\n      \"description\": \"Parse current Date object\"\n    },\n    {\n      \"name\": \"setTimer\",\n      \"docblock\": \"Update current clock for every 1 second\",\n      \"modifiers\": [],\n      \"params\": [],\n      \"returns\": null,\n      \"description\": \"Update current clock for every 1 second\"\n    }\n  ],\n  \"props\": {\n    \"title\": {\n      \"type\": {\n        \"name\": \"string\"\n      },\n      \"required\": false,\n      \"description\": \"A text display current's user identity,\\n \\\"Nobody\\\" if no one is detected in the background,\\n \\\"Hi, ..name\\\" if an user is detected\"\n    }\n  }\n}. ",
    "ycmjason": "Totally agree.. ",
    "jesseko": "Hi all, I wrote an attempt at this.\nIt works for me, but then we tried on a colleague's machine and we're getting \"Maximum call stack size exceeded\" errors that seem to just be deep in the guts of react-docgen.  Can you take a look and let me know if you have any thoughts on how to debug or fix this?  I wrote this and two other custom handlers and am having this problem with all of them -- would really appreciate some help.\nYou're welcome to adapt this code back into react-docgen (once it's more stable)\nFirst the error: \nRangeError: Maximum call stack size exceeded\n    at Type.value (/Volumes/code/main/node_modules/ast-types/lib/types.js:41:40)\n    at Field.Fp.getValue (/Volumes/code/main/node_modules/ast-types/lib/types.js:255:26)\n    at Object.getFieldValue (/Volumes/code/main/node_modules/ast-types/lib/types.js:680:30)\n    at NodePath.NPp.getValueProperty (/Volumes/code/main/node_modules/ast-types/lib/node-path.js:124:22)\n    at getChildPath (/Volumes/code/main/node_modules/ast-types/lib/path.js:52:37)\n    at NodePath.get (/Volumes/code/main/node_modules/ast-types/lib/path.js:76:20)\n    at visitChildren (/Volumes/code/main/node_modules/ast-types/lib/path-visitor.js:242:38)\n    at Visitor.PVp.visitWithoutReset (/Volumes/code/main/node_modules/ast-types/lib/path-visitor.js:204:20)\n    at NodePath.each (/Volumes/code/main/node_modules/ast-types/lib/path.js:101:26)\n    at visitChildren (/Volumes/code/main/node_modules/ast-types/lib/path-visitor.js:219:18)\nfile attached (it's JS of course, but had to use \".txt\" for github to let me attach)\nreact-docgen-staticPropsHandler.txt\n. FYI, here's how I'm running the code above.  Should be very easy to duplicate this in any existing app.  I'm definitely curious whether the error will repro or whether it will just work for you:\nlet staticProptypesHandler = require('./react-docgen-staticPropsHandler').default;\n...\nlet reactInfo;\ntry {\n    const docHandlers = reactDocs.defaultHandlers.concat( [staticProptypesHandler] );\n    const resolver = reactDocs.resolver.findExportedComponentDefinition;\n    reactInfo = reactDocs.parse(contents, resolver, docHandlers);\n} catch (e){\n    console.log(e); //this is where I'm seeing the error I posted above\n}. We've tested on a few more computers here -- working on some, not on others.  Not sure why the \"Maximum call stack size exceeded\" errors are inconsistent between machines, but in any case, we're hoping you all might be able to spot something bad I'm doing in the code, or just write a better handler for ES6 static proptypes.  Thanks.. Thanks @kabbi \nWe took a look across our machines and the ast-types are consistent, but the trees under react-docgen are different. \nHere's mine, which are working, no errors:\n\u251c\u2500\u252c react-docgen@2.17.0\n\u2502 \u251c\u2500\u2500 async@2.5.0\n\u2502 \u251c\u2500\u2500 babylon@5.8.38\n\u2502 \u251c\u2500\u2500 commander@2.11.0\n\u2502 \u251c\u2500\u252c doctrine@2.0.0\n\u2502 \u2502 \u2514\u2500\u2500 isarray@1.0.0\n\u2502 \u251c\u2500\u2500 node-dir@0.1.17\n\u2502 \u2514\u2500\u252c recast@0.12.6\n\u2502   \u251c\u2500\u2500 ast-types@0.9.11\n\u2502   \u2514\u2500\u2500 esprima@4.0.0\nHere's my colleage Eric's tree (he's getting the Maximum call stack size exceeded error):\n\u251c\u2500\u252c react-docgen@2.17.0\n\u2502 \u251c\u2500\u252c async@2.5.0\n\u2502 \u2502 \u2514\u2500\u2500 lodash@4.17.4\n\u2502 \u251c\u2500\u252c babel-runtime@6.25.0\n\u2502 \u2502 \u251c\u2500\u2500 core-js@2.5.0\n\u2502 \u2502 \u2514\u2500\u2500 regenerator-runtime@0.10.5\n\u2502 \u251c\u2500\u2500 babylon@5.8.38\n\u2502 \u251c\u2500\u2500 commander@2.11.0\n\u2502 \u251c\u2500\u252c doctrine@2.0.0\n\u2502 \u2502 \u251c\u2500\u2500 esutils@2.0.2\n\u2502 \u2502 \u2514\u2500\u2500 isarray@1.0.0\n\u2502 \u251c\u2500\u252c node-dir@0.1.17\n\u2502 \u2502 \u2514\u2500\u252c minimatch@3.0.4\n\u2502 \u2502   \u2514\u2500\u252c brace-expansion@1.1.8\n\u2502 \u2502     \u251c\u2500\u2500 balanced-match@1.0.0\n\u2502 \u2502     \u2514\u2500\u2500 concat-map@0.0.1\n\u2502 \u2514\u2500\u252c recast@0.12.6\n\u2502   \u251c\u2500\u2500 ast-types@0.9.11\n\u2502   \u251c\u2500\u2500 esprima@4.0.0\n\u2502   \u251c\u2500\u2500 private@0.1.7\n\u2502   \u2514\u2500\u2500 source-map@0.5.6\nAny more ideas?  . I can work on this more if you all can help me get unstuck.\nI don't see any loops in the error call stack (posted above)\nDon't know how to gain any more insight into what's failing on some machines.\nI could dig into react docgen code and add some logging to try to show something about what's running differently between machines.  Does that seem like a good idea?  Any ideas where/what to look for?  Or could do that in the ast-types code if that seems more likely?\n...or if one of you is going to write a better fix for this ticket soon then I can just wait for that.\nPlease advise. ",
    "kabbi": "In my experience, Maximum call stack size exceeded error happens sometimes when there are multiple ast-types dependencies present, and react-docgen uses the wrong one, which causes infinite loops. Verify that dependency trees are the same on different machines (you can use npm ls). It would be helpful for me if you provide any feedback on this.. ",
    "lensbart": "For what's it worth, I'm getting the same RangeError: Maximum call stack size exceeded for all my components that are written as (pure) functions. I'm using react-docgen as part of react-styleguidist, and everything was working fine when all components were defined as classes, before applying the react/prefer-stateless-function rule of ESLint. Will update here if and when I found the cause.. Found it. Apparently this doesn't work:\nimport React from 'react'\nexport default function Blockquote(props) {\n  return (\n    <blockquote>\n      {props.children}\n    </blockquote>\n  )\n}\nBut this does:\nimport React from 'react'\nmodule.exports = function Blockquote(props) {\n  return (\n    <blockquote>\n      {props.children}\n    </blockquote>\n  )\n}\nHope this helps!. I'm using react-docgen as part of react-styleguidist (v6.0.27), its package.json says that version 3.0.0-beta7 is used.. My issue was solved after switching from npm to yarn.. It does seem strange, but I thought it could be due to some dependency incompatibility which got resolved by yarn (I didn't look much further into it). ",
    "janryWang": "I hope that the document can support the automated generation of multi-language versions. ",
    "sonsoleslp": "I also think this would be a neat feature: being able to describe the same proptype in several languages in order to automatically generate docs in several languages.\nSomething like:\nMyComponent.propTypes = {\n    /**\n    * @es Indica si el componente est\u00e1 oculto\n    * @en Indicates whether the component is hidden or not\n    */\n    disabled: PropTypes.boolean,\n  };. ",
    "intelcoder": "So only way it can parse the component is that receiving path name?\nWhat I can do is like below ?\nconst json = docGen.parse(Path, resolver);. ",
    "nickbreaton": "@fkling Thanks for getting back to me! I will go the route of trying to build out an extension. . ",
    "Jmeyering": "@fkling \nI've gone ahead and created a custom resolver which allows for annotated export declarations to be added to a definitions list. I've used this format.\n```\nconst MyComponent = () => (\n  \n);\n// @component\nexport default MyComponent;\n```\nhttps://github.com/jmeyering/react-docgen-annotation-resolver\nIdeally this would solve this styled-components issue and allow users to annotate their exported styled-components\nThe issue I'm running into is that react-docgen validates the types of definitions that are passed to the  getMemberValuePath.js function and limits them to a list which does not include TaggedTemplateExpression.\nI'm willing to create a lookup method for TaggedTemplateExpression but was wondering if there was any information I should know before I went down that road too far.. Just submitted PR which uses getMemberValuePath when no other lookupMethod is available, it still does a type check, but I added TaggedTemplateExpression to be a valid type.\nLet me know if this isn't at all what you had in mind, but in my testing, it works great for styled-components.. @fkling Any idea if this approach is viable? If not I'm willing to try a more acceptable approach.. @fkling Any direction on how to add a test? The test suite by default uses the built in resolvers, which do not include tagged template literals in their set of definitions.\nI don't see any place where I can unit test the individual methods that I changed. I will gladly add a comment to my changes.. @fkling \nA couple things\n\nI checked react-styleguidist and it looks as though they are locked to v3-dev for their dep on react-docgen As that is the primary use case that I am aware of at this time, I have made a new PR for the v3-dev branch #198. Should we close this PR and only work on this as a v3-dev feature?\nI've added inline documentation for my changes in #198.\nTesting is still confusing me a bit. Any direction would be greatly appreciated. @fkling Is there any one who could provide some direction on getting testing implemented? As I've commented before it doesn't seem to me that there are any unit tests explicitly covering the methods that I have altered.  Fixtures are used to test most of the functionality of react-docgen. But as the library itself does not have any way to resolve a TaggedTemplateLiteral as a component, I'm a bit stuck. \n\nThanks so much for your time.. Closing this as it's merged into v3-dev. @fkling \nI added the test into this PR. I think we can drop the PR into master and keep this a v3 feature?\nLet me know if there is anything I can improve upon.. @fkling \nLet me know if there is anything else I can do to move this along. If the tests aren't up to spec I'm willing to do more to get this acceptable.. ",
    "ambidexterich": "I am using 2.15.0, I will check out the beta and l let you know.. It works properly with v3.0.0-beta4. ",
    "birjolaxew": "The AST for such a property is:\njson\n{\n    \"type\": \"ClassProperty\",\n    \"start\": 0, \"end\": 0,\n    \"loc\": { },\n    \"computed\": false,\n    \"key\": {\n        \"type\": \"Identifier\",\n        \"start\": 0, \"end\": 0,\n        \"loc\": { },\n        \"name\": \"render\"\n    },\n    \"static\": false,\n    \"value\": {\n        \"type\": \"Identifier\",\n        \"start\": 0, \"end\": 0,\n        \"loc\": { },\n        \"name\": \"view\"\n    }\n}. ",
    "sundyxfan": "complete example:\n```\nimport React, { PropTypes } from 'react';\nclass Test extends React.Component {\n    constructor(props) {\n        super(props);\n    }\nrender() {\n    return (\n        <div>demo</div>\n    );\n}\n\n}\nTest.propsTypes = {\n    aa: PropTypes.number,\n    bb: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.string\n    ]),\n    cc: PropTypes.bool,\n    dd: PropTypes.bool,\n    ee: PropTypes.bool,\n    rr: PropTypes.number,\n    tt: PropTypes.func,\n    yy: PropTypes.func,\n    uu: PropTypes.array.isRequired,\n    ii: PropTypes.func,\n    kk: PropTypes.object\n}\nTest.defaultProps = {\n    aa: 1000,\n    bb: 640,\n    cc: false,\n    dd: true,\n    ee: true,\n    rr: 0,\n    uu: []\n}\nexport default Test;\n```\n1\u3001required and description is not picked up\n2\u3001react-docgen version 2.16.0\n@fkling . ",
    "hlynurf": "2.16.0\nSorry, forgot to mention that.. Tried the 3.0.0-beta5 and I get the same error. ",
    "j2l": "Hi,\nMay I ask you @chaliy how you got react-docgen --pretty -o lib/metadata.json src/components working on Windows? I get \"unknown command'\nI also tried npm run react-docgen --pretty -o lib/metadata.json src/components without luck (missing component).. @chaliy you are right, I didn't, thanks for pointing it out. My bad.. ",
    "chaliy": "@j2l , do you have it installed globally? Something like npm install react-docgen -g?. ",
    "Xtrazyx": "It is not a bug per say but this inconsistency is annoying. When developing alternatively on windows and on mac OS, which is my case, you will have some issue exploiting the generated path.\nTo go further on this, the linux/macOS way of labeling the paths works on most windows shells  mypath/tatata/coco.js \nbut not the other way around. \nSo yeah it would be nice to have always the same method, the linux way.. ",
    "konojunya": "I agree.\nthanks :). ",
    "jeffkamo": "Any movement on this?\nReinstalling packages did fix components with implicit returns, but components with explicit returns are still broken.\n```jsx\n// This works\nconst Button = ({children}) => (\n    {children}\n)\n// This does not work\nconst Button = ({children}) => {\n    return (\n        {children}\n    )\n}\n```\nSee it in action:\n\nedit\nI am using the react-docgen through the latest version of react-styleguidist:\n\u251c\u2500 react-styleguidist@6.2.0\n\u2502  \u251c\u2500 react-docgen-annotation-resolver@^1.0.0\n\u2502  \u251c\u2500 react-docgen-displayname-handler@^1.0.1\n\u2502  \u251c\u2500 react-docgen@^3.0.0-beta9\n\u2502  \u251c\u2500 react-docgen@3.0.0-beta9\n\u2502  \u2502  \u251c\u2500 async@^2.1.4\n\u2502  \u2502  \u251c\u2500 babel-runtime@^6.9.2\n\u2502  \u2502  \u251c\u2500 babylon@7.0.0-beta.31\n\u2502  \u2502  \u251c\u2500 commander@^2.9.0\n\u2502  \u2502  \u251c\u2500 doctrine@^2.0.0\n\u2502  \u2502  \u251c\u2500 node-dir@^0.1.10\n\u2502  \u2502  \u2514\u2500 recast@^0.12.6. Update\nTurns out my project was depending on an outdated version of react-docgen (on top of the one used by react-styleguidist). Updating to the latest version did the trick.\nSpecifically, we are pulling in docgen in order to supply a resolver in our styleguidist config.\n```js\nconst DocGen = require('react-docgen') // <-- was v2.15.0, should be 3.x\n// ...\nmodule.exports = {\n    // ...\n    resolver: DocGen.resolver.findAllComponentDefinitions, // <--\n    // ...\n}\n```\nSo all is well once again, at least for my team!. ",
    "troynguyen8": "I was able to resolve this issue by adding another wrapping div:\nreturn (\n  <div>\n    {(props.shouldBeWrapped) ? <div>{baseComponent}</div> : baseComponent}\n  </div>\n);. Still an issue potentially worth addressing, but I'm closing this issue now.. ",
    "deedubbu": "I am running into the same situation. I've tried using the findAllComponentDefinitions.js resolver but it it still failing to identify the properties of the HOC. @rsouthgate Were you successful using an alternate resolver?. ",
    "joaovieira": "Been having troubles with HOC as well. Boiling it down to the minimum, consider:\njsx\nimport React from 'react';\nconst enhanced = () => () => <div />;\nexport default enhanced;\nI get:\nError: No suitable component definition found.\nAre functions that return components (HOCs) not supported at all? Tried all the resolvers without success.\nThough the end goal would be to pick up the propTypes definitions from the inner component as well.. Cool. Will have a look at that. Thanks for the quick reply \ud83d\udc4d . ",
    "davidungio": "I couldn't get the https://github.com/Jmeyering/react-docgen-annotation-resolver to work with my HOC which is a function as well. Would love some direction on how to go about writing a custom one. Thanks!. ",
    "mmsbrggr": "@fkling:\nError with path \"Option.js\": SyntaxError: Unexpected token =>. It looks like you are trying to write a function type, but you ended up writing a grouped type followed by an =>, which is a syntax error. Remember, function type parameters are named so function types look like (name1: type1, name2: type2) => returnType. You probably wrote (type1) => returnType (1:NaN)\nSyntaxError: Unexpected token =>. It looks like you are trying to write a function type, but you ended up writing a grouped type followed by an =>, which is a syntax error. Remember, function type parameters are named so function types look like (name1: type1, name2: type2) => returnType. You probably wrote (type1) => returnType (1:NaN)\n    at Parser.pp.raise (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/parser/location.js:24:13)\n    at Parser.pp.flowParsePrimaryType (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:500:16)\n    at Parser.pp.flowParsePostfixType (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:557:38)\n    at Parser.pp.flowParsePrefixType (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:573:17)\n    at Parser.pp.flowParseIntersectionType (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:579:19)\n    at Parser.pp.flowParseUnionType (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:589:19)\n    at Parser.pp.flowParseType (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:600:19)\n    at Parser.pp.flowParseTypeInitialiser (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:20:19)\n    at Parser.pp.flowParseObjectType (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:330:27)\n    at Parser.pp.flowParsePrimaryType (/usr/lib/node_modules/react-docgen/node_modules/babylon/lib/plugins/flow.js:459:19). @fkling Is there anything planed to resolve this issue?. ",
    "odinuge": "This should be solved in #218.. Hi @fkling,\nAfter looking further into getFlowType, it makes more sense to do it your way with a simple inline ternary operator, instead of using the getNameOrValue. Updated the PR, and the tests still works as expected. :smile: . Hi @danez,\nGot the inspiration from a flow-addon for atom (see screenshot). But I agree that null would be a better and cleaner value for working with the data afterwards. Will update the PR.\n. Edit: getNameOrValue returns a string value, and therefore null would break flow. What do you think @danez?. Updated the PR setting the name to an empty string now.. ",
    "danrot": "@rosskevin Changed it, but I doubt that this helps.... Do you want me to fix it, or do you do it on your own?. Thanks a lot! Any idea when will this be released?. ",
    "romanlex": "Hello, anybody can merge this pr to v3-dev branch?. ",
    "stonebk": "It would be great if this could be done for Object.values() as well as @danez mentioned.. ",
    "konsumer": "Yep, looks like I need to work on the babel-loader, and set it up to use findAllExportedComponentDefinitions. Sorry for the noise.. Ah, yes, I like this a lot better. Maybe I should try to get storybook to use a different-than-default resolver. Feel free to close this, sorry for the noise.. ",
    "vlad-zhukov": "@danez  Thanks! Could you please release a new beta with these changes?. ",
    "magicmark": "@fkling flow (0.56.0) shows the following \n```\n$ node_modules/.bin/flow gen-flow-files Foo.js\n// @flow\nimport React from \"react\";\ndeclare export default function(props: {a: string, b: string}): $Exact<{+key: string | number | null, +props: mixed / UNEXPECTED TYPE: EvalT /, +ref: any, +type: ElementType}>;\n```\nThis problem shows up when we show our component on styleguidist (which uses react-docgen): https://i.imgur.com/6u1GrRR.png . ",
    "adityavohra7": "@fkling, given that the handlers listed here run independently of each other, would it make sense to have a handler that runs last that \"combines\" the effects on the documentation object produced by all the previous handlers? This handler could be used for things like documentation validation, or \"inference\" type documentation (ex. if we have a prop which has a defaultProp defined, and its Flow type is a required type, the documentation should reflect that the prop is optional, to be in accordance with Flow's inference).\nAnd on a somewhat related note, what is the expected behavior of react-docgen if, for some reason, a component has both prop type and flow type definitions, and they happen to conflict? The order in which these handlers run would start to matter then right?. Looking into the test failures!\nEdit: Fixed. Had to update a snapshot, and account for cases wherein props isn't defined.. Friendly bump! Let me know if you think we should take some other approach here!. @rosskevin, the PR definitely needs a couple of tests. I was waiting for any maintainer to look it over though to confirm they agreed with the approach the PR takes. Majority of the doc generation is \"independent\" (handlers are unaware of each other), but this approach sort of \"combines\" the documentation that each handler creates. . Friendly bump! Any input by other contributors/maintainers would be appreciated!. Hi @danez! Thanks for the review! I've rebased on master and added a simple test case for a component with defaultProps and flow type annotations for props.\nThe only reason I didn't add the \"combining of defaultProps and flow types\" behavior in the form of a handler is that there'd be an implicit requirement for this handler to run last (because it depends on the results of the props and flow handlers), whereas all the current handlers are pretty much independent of each other? If we prefer that, I don't mind changing the current post-processing step to a handler!. Friendly bump! @danez, what do you think about the updated PR? \ud83d\ude0a. ",
    "kamyzd": "Thank you so much!!   @danez. ",
    "LukeChannings": "+1\nI have a somewhat simple higher-order stateless component that relies on React 16's change that allows a component to return a list of components.\njs\nconst InsertBetween = ({ children, Component, ...props }) =>\n  children.reduce(\n    (a, b) => (!a.length ? [a, b] : [...a, <Component {...props} />, b]),\n    []\n  )\nUsed like:\n```js\nconst Hr = () => \n\nHello world!\nGonna have an hr between us!\n\n```\ndocgen errors on this sort of component with \"Error: No suitable component definition found.\".\n*not actually tested this, but it's something like a component I've built.. ",
    "dickson-tong": "sorry mistake. wrong repo. ",
    "sylvainar": "We're actually using react-styleguidist, the error seems to come from docgen actually.. We find out the problem, it was because of the fact that we tried to use beta9 on styleguidist, and some functions of it were still using beta8 involving with weird behavior including this one.\nI'm closing this issue!. ",
    "PDarkTemplar": "That's helped, thanks.. ",
    "ryanpcmcquen": "@fkling, you can do a npm install && npm run styleguide here to see the errors:\nhttps://github.com/ryanpcmcquen/ui-sources-builder-prototype. ",
    "okonet": "Same here when trying to document components written with https://github.com/jxnblk/styled-system/tree/master/system-components\n```js\nimport system from 'system-components'\n// creates a Box with default props tied to your theme\nconst Box = system({\n  p: 2,\n  bg: 'blue'\n})\n```. That\u2019s amazing! Thanks Artem!!!. ",
    "flybayer": "Has anyone found a solution to this (using system-components with react-styleguidist)?. ",
    "jamesmfriedman": "I need the exact same thing, but for me it's my own personally defined factory functions. \n``jsx\n/**\n * The Elevation Component\n */\nexport const Elevation: React.ComponentType<ElevationPropsT> = simpleTag({\n  displayName: 'Elevation',\n  defaultProps: {\n    z: 0\n  },\n  tag: 'div',\n  classNames: (props: ElevationPropsT) => [mdc-elevation--z${props.z}`,\n    { 'mdc-elevation-transition': props.transition }\n  ],\n  consumeProps: ['z', 'transition']\n});\nexport default Elevation;\n```\nBasically I need this to resolve my cast expression React.ComponentType<ElevationPropsT> with Flow.. ",
    "yungsters": "Oops, did not mean to mess around with the reviewer, lol.. ",
    "TheSavior": "It seems like we should change the getFlowType function to return something special for ObjectTypeSpread. . Rebased. The right approach for this PR was a little less obvious to me. I tried to follow the algorithm conventions that existed but I'm not sure if the output of the spread type is what it actually should be. I would appreciate a bit closer review of those pieces.\n  . @danez, do you have any more thoughts on these open questions?\n. I'm thinking that we want to distinguish between the spread properties and the normal ones. Also, since we want to resolve local types and possibly at some point have a way to reference where the definition originally comes from, we want the inherited list to be objects instead of plain strings.\nI'm thinking this structure:\n``\n it('handles ObjectTypeSpreadProperty', () => {\n    var typePath = statement(\n      var x: { ...OtherProps, ...MyType, a: string };\n  type MyType = { myString: string };\n`).get('declarations', 0).get('id').get('typeAnnotation').get('typeAnnotation');\n\nexpect(getFlowType(typePath)).toEqual({\n  name: 'signature',\n  type: 'object',\n  signature: {\n    inheritedProperties: [\n      { name: 'OtherProps', value: { name: 'OtherProps' } },\n      { name: 'MyType',\n        value: {\n          name: 'signature',\n          type: 'object',\n          signature: {\n            properties: [\n              { key: 'myString', value: { name: 'string', required: true } },\n            ],\n          },\n          raw: '{ myString: string }',\n        },\n      },\n    ],\n    properties: [\n      { key: 'a', value: { name: 'string', required: true } },\n    ],\n  },\n  raw: '{ ...OtherProps, ...MyType, a: string }'});\n\n});\n```\n  . Alright, I think this is good to go now. I broke this into two separate PRs to make it easier to review.. @danez, kind bump. @fkling is on vacation so I can't bug him internally to get this merged and released. :)\nOther people on my team like @yungsters, have merge permissions here but only you and felix can publish a new version. If you'd like to add the facebook npm user to have publish permissions: https://www.npmjs.com/~fb, then we can take care of it.. I could have gone either way, I actually initially had them both as a separate inherited object. The reason I didn't was partly because the code necessary to add inherited props to a new inheritedProps field in the documentation class is pretty hairy. Adding an inherited flag there was the simplest thing to do and required the most surface level changes that would be most likely to be merged. I figured if we wanted to split them out later it would be easier going this direction than the other direction.\nThere are a few different reasons I made getFlowType have a separate inheritedProperties. Fundamentally, the output from this function seems different than the component documentation output. One is describing the props, one is describing the type of a generic variable in JavaScript. The properties array also had key whereas the key of an inherited property doesn't actually make sense so inheritedProperties use name. \nAll in all, I don't feel strongly either direction. I'm happy to change approach if someone with more context has a preference. I mostly just want to get Facebook's UIDocs to stop blowing up on these new flow types. Perhaps we can merge and ship a PR that does that and then we can figure out the best output for these additional types.. I think the other one needs a bit more work still. All of the inline comments I left were from doing an in person code review with @fkling. This PR should be good to go though. I\u2019ll try to get Felix to review it closer today. :-). cc @danez . Correct. . The logic for resolving the local types is already being done. You can see it in action in the component snapshot test, prop OtherLocalProps.\nYeah, the real question is what to do when the type is imported from another file, 90% of our use case internally. We definitely don't want to ignore the spread. I think for us at least, saying what the types are is pretty explanatory. It's typically things like ...AccessibilityProps. \nAn explicit inherits field is interesting. I am not familiar enough with this project and how we consume the output to know what is ideal here. I think I defer to you.. It seems like this could be confused with a prop called OtherLocalProps that has these specific keys. However, since it is being spread in, the properties of OtherLocalProps should probably be flattened into the top level props? Is that correct?. This is an example of a component where we type spread props in and how we'd probably expect them to show up in docs. https://facebook.github.io/react-native/docs/touchableopacity.html#props. These have a flag for whether it is inherited. This was cleaner than adding a new top level key to the output documentation.. This should be inlined.. import type { BarType as Foo } from 'bar';\n{ ...Foo }\n{ \nmodule: 'bar',\nname: 'BarType'\n}\n\nimport type URI from 'URI';\n{ ...URI }\n{ \nmodule: 'URI',\nname: 'default'\n}\n. importedProperties. Move this to composes\n\"NonExistentFile.OtherCommmponentProps\"\nif default\nthen \"URI\". Inline this into props.. Add a comment to this.. This is wrong. Not spread in far enough.. Add and pull in a docblock comment here.. I think where it ended up was that it was too difficult to make something meaningful here.\n```\nimport type { MyType } from 'MyFile';\ntype MyFileMyProperty = $PropertyType;\ntype Props = {|\n  ...MyFileMyProperty\n|}\n```\nIt doesn't make sense to say that it composes MyFile.MyFileMyProperty, in this case it would be MyFile.MyType.myProperty but the logic can get exceedingly complicated and it doesn't make sense for us to try to understand it statically. I think where we landed was to just use the alias, if they want it to be more explicit in the generated docs they can use a more explicit alias. \nThis still leaves us open to improving it at a future point though.. We are going to have the same problem as we had with trying to resolve the module and export from the props: https://github.com/reactjs/react-docgen/pull/241#discussion_r163030209\nSo it probably will either need to stay like it is now, or  be an even simpler array of strings of the inheritedProperties or composes.. ",
    "saoirse-zee": "Hi @acondiff -- I had the same issue, and had to dig around in the source code to find something that worked. \nThe resolvers are exposed on a property called \"resolver\":\nconst reactDocs = require('react-docgen')\nconst resolvers = reactDocs.resolver\nI think you can get your stuff working if you change your first line to this:\nconst componentAPI = reactDocs.parse(data, reactDocs.resolver.findAllComponentDefinitions)\n. ",
    "maciej-gurban": "Thanks a bunch for this. Made a PR to update the docs with this info (and fix the broken description in the table): https://github.com/reactjs/react-docgen/pull/328. ",
    "matheussampaio": "I also have this problem. It would be really nice if we use the variable name as displayName.. ",
    "matthew-dean": "This issue still occurs for me after updating react-styleguidist to version 7.3.9.. Important note, react-styleguidist works with react-docgen 3.0.0-beta12, BUT react-docgen 3.0.0-beta6 AND react-docgen 3.0.0-rc.1 fail in the same way. \nThat is, I get the error:\n```\nWarning: Cannot parse src/common/presentation/elements/Anchor/Anchor.js: RangeError: Maximum call stack size exceeded\nIt usually means that react-docgen does not understand your source code, try to file an issue here:\nhttps://github.com/reactjs/react-docgen/issues\nWarning: Cannot parse src/common/presentation/elements/Avatar/Avatar.js: RangeError: Maximum call stack size exceeded\nIt usually means that react-docgen does not understand your source code, try to file an issue here:\nhttps://github.com/reactjs/react-docgen/issues\n```. ",
    "SavePointSam": "I've also been experiencing it. It was never working correctly for me.. ",
    "penx": "Would still be useful to have parse as the default es6 export for anyone trying this in the future . Related:\nhttps://github.com/reactjs/react-docgen/issues/70\nhttps://github.com/reactjs/react-docgen/issues/177\nhttps://github.com/reactjs/react-docgen/issues/187\nhttps://github.com/reactjs/react-docgen/pull/195\nhttps://github.com/reactjs/react-docgen/commit/f847bd7f922f392a89aa331e46a7ada0a76cd132. ",
    "chpeters": "I am seeing this issue as well using styled-components (through styled-system's system function).. ",
    "ckihneman": "Ran into this issue with the Storybook Info Addon. Tracked it down to this function in their code, which made me realize it is an issue with react-docgen parsing styled-components, this information brought me here - noting for others.\nThis is what react-docgen is able to get from the styled-component with a docgen style description on the prop:\njson\n{\n  \"property\": \"children\",\n  \"propType\": \"node\",\n  \"required\": true,\n  \"description\": null\n}\nWhen other react components look like:\njson\n{\n  \"property\": \"children\",\n  \"propType\": {\n    \"name\": \"node\"\n  },\n  \"required\": true,\n  \"description\": \"Heading text or node\"\n}. ",
    "jquense": "if anyone is interested this is what we came up with for css-literal-loader, but the syntax is the same for styled components or emotion, so this should work for them as well:\nhttps://gist.github.com/jquense/c2a92f1c909552f295bb7953fcd2ce4d. I wrote the test in a way the works in v1. I realized that i've not noticed this before because it seems like bablyon has only recently started making these ClassDeclarations, in the past they were expressions. I've been working on updating gatsby-transformer-react-docgen to babel 7 by implementing our own parser over recdocgen, but it seems like bable7 somewhere changes Property to ObjectProperty for property types, which breaks the proptypes handler...i'm a bit confused why its not breaking here tho.... The loop seems to be isolated to function components, but the below isn't working with rc.1 with all exported components resolver\njs\nexport default function Spinner({ className, ...props }) {\n  return <svg viewBox=\"0 0 34 34\" {...props} />;\n}. looks like the problem is in IsStatelessComponent, perhaps a babel type changed or something that isn't ever breaking the recursion?. it appears that https://github.com/reactjs/react-docgen/blob/master/src/utils/isStatelessComponent.js#L149 is always hit (scopes are never equal) and it just vists this node forever, which seems like an odd recast behavior?. maybe: https://github.com/benjamn/recast/issues/374 ?. Technically I already have commit access :P as a general member of the reactjs org. And yeah this was less a commit bit request and more a inquiry into wether y'all are open to taking larger, maybe more opinionated, PRs so as not to be presumptuous. Seems like yeah. I'll send some over :). yeah, I mean i'd say its technically probably a breaking change, but pretty unlikely to actually break anyone. I'd be tempted to say that any breakage would be positive too since it's likely surfacing a misconfiguration somewhere.. \ud83c\udf89 . it occurs to me that we should still add an ability to manually pass through parser options for tool chains that don't depend on a babelrc on disk, like gatsby, which will do something similar to to this, defaulting basic options if there is no local config. It'd be nice if react-docgen could still work using those settings. All good with me \ud83d\udc4d integers are cheap. what do you think about putting out a release with this? I know there is the babel config stuff to work around :/. Recast traditional my makes stuff like resolveToValue easier than straight Babel, but the current babel API is better nowadays. Nodes have a .resolve that do the heavy lifting of binding traversal. And even without it I've written pure Babel versions a few times so I'd be happy to help there.\nHonestly I'd like to remove recast, if only because it avoids a context shift between AST tools I use regularly :P\nAs for typescript I do think recast is probably abstracting the differences, the plain AST from babel attempts to match the actual typescript AST nodes for annotations which are fairly different from flows . for npm client users npx react-docgen will also work for using the local binary. ok readme fixed \ud83d\udc4d . nope! fixed. bah sorry not sure what's happening thing, maybe prettier being over zealous...i'll fix. ",
    "yis4yimmy": "Did some more digging and realized that I can use docgen-loader or react-docgen-loader. ",
    "Happy-Ferret": "I'd assume OP is talking about missing descriptions.\nWith\njs       \ntype: PropTypes.oneOf([\n            'animal',\n            'bacon',\n            'beard',\n            'bear',\n            'cat',\n            'food',\n            'city',\n            'nature',\n            'people',\nI automatically receive a description containing all possible enum values.\nWith FlowType and its unions (i e type?: \"animal\" | \"bacon\", no such description is generated.\nI'm using react styleguidist, btw.. ",
    "emilyhorsman": "I'm considering using react-docgen in a Language Server Protocol instance, but the lack of this feature would be a blocker.. ",
    "indexzero": "Would be great to see this get merged. . Bump @danez @fkling \u2013\u00a0would really appreciate your thoughts before continuing the refactor. Alternatively I could release the refactored code as a separate module and then consume it in this PR if that's preferable. . Rad thanks for the input @danez \u2013\u00a0have a busy week next week, but after that I'll take another pass at this and get the tests cleaned up. . Could use .find here fwiw, which would let you make this a one liner\n``` js \nvar classDeclaration = Array.isArray(path.parentPath.value)\n  ? path.parentPath.value.find(function(declaration) { return declaration.type === 'ClassDeclaration' });\n  : path.parentPath.value. Could tighten this up a bit more:\n``` js\nif (!classDeclaration || !classDeclaration.leadingComments) {\n  return false;\n}\nreturn classDeclaration.leadingComments.some(function (comment) {\n  return /@extends\\s+React.Component/.test(comment.value);\n});\n```. ",
    "glebez": "Hey! The tiny little thing is fixed now. And thanks everyone for your patience.. ",
    "NikhilVerma": "@danez  Good point, I'll have a look why it needs to be duplicated.. if (propInfo.defaultValue) {\n      propInfo.required = false;\n    }\n@danez  Sorry I'll close this PR, seems like this is by design. If a propType has a default value it can't be forced as required. Which I guess makes sense, I'll update our doc generator to keep this in mind.. ",
    "dustinsavery": "Ping @danez @fkling. Would appreciate your help reviewing this feature so that we can resume using the mainline of react-docgen.. Whoops, should've been (path.parentPath&& path.parentPath.value). Excellent points, getting all of that integrated.. Nice! So much cleaner.. I don't think we could do this. \nif (!classDeclaration || !classDeclaration.leadingComments) {\n  return false;\n}\n^ This would cause an early return. We still need to check to see if the component directly extends from React.Component.. ",
    "oktak": "Hello, \nWill this migration would support dynamic import() ?\nIssue:\nI've got SyntaxError: 'import' and 'export' may only appear at the top level when I use import() within the React Component class definition.\nI've seen that the error is raised from babylon\\lib\\parser\\statement.js\nAnd I see that there is similar error message in babel-parser too:\nhttps://github.com/babel/babel/blob/master/packages/babel-parser/src/parser/statement.js#L151\nI would like to ask if React-docgen could add the options for Parser that allowImportExportEverywhere could set to the value that would eliminate the SyntaxError mentioned above.\nThank you!\nVersion and Platform:\n- react-docgen: 2.21.0 (npm view react-docgen version)\n- node v8.9.4\n- npm v5.6.0\n- windows 7 64bit\n. ",
    "greypants": "Woo! Just tried out the 3.0.0 RC and it works great. Thanks!. ",
    "robinwkurtz": "2.21.0 which I'm now seeing is old. I'm dealing with react-doc-generator which hasn't been updated in a little while.\nI've manually upgraded to 3.0.0-rc.0 and I get the same results.\nThanks!. Sorry for the lateness... The following is a full example that gives me the above results if a toggle the handleThings handler.\n```\n// @flow\nimport React from 'react';\nexport class TestPage extends React.PureComponent {\n// Working\nhandleThings = (id: number, active: boolean) => () => console.log(`handleThings: Works! ${id}, ${active}`);\n// No Working\n// handleThings = (id: number, active?: boolean) => () => console.log(`handleThings: Works! ${id}, ${active}`);\n// handleThings = (id: number, active: boolean = false) => () => console.log(`handleThings: Works! ${id}, ${active}`);\n\nrender() {\n    return (\n        <button type=\"button\" onClick={this.handleThings(1, true)}>\n            [Button]\n        </button>\n    );\n}\n\n}\nexport default TestPage;\n```\nThanks!. Just a bump here @danez, can I provide more information?. ",
    "duckscofield": "OK, I give some codes as belows:\n/**\n   * handle input value when typing\n   * @param  {[type]} event [description]\n   * @return {[type]}       [description]\n   */\n  handleInput = (event) => {\n    const { value } = event.target;\n    this.foundation_.handleInput_(value);\n  }\n```\n/*\n  * get the name\n  /\nget name() {\n  return this.name;\n}\n```\nif I use the arrow function or use static/get/set function, add comments, it will fail to parse. ",
    "trevordmiller": "It would be helpful for \"react-docgen to pickup the component returned by wrap\" IMO. I tried using different resolvers like this without luck:\njavascript\n      reactDocgen.parse(\n        entryFileString,\n        reactDocgen.resolver.findAllExportedComponentDefinitions\n      ). @fkling do you know if this is possible / how I could do it? Any help would be much appreciated. Thanks so much for the great tool! It is working very well for our single layer / single export components.. @darcyturk Thanks for the info, but I don't feel comfortable changing all my proptypes to the custom assignPropTypes of a less popular/stable library, I'd like to stick with the main react-docgen library :). Although I think it would be cool to have built-in support for this, we were able to get around it for now with a node script and specific component structure (using lerna with packages/). Then after running this script, we consume the data in our living style guide / API docs UI. Here are some relevant pieces (specific to our project) if anyone is interested:\n```node\n!/usr/bin/env node\nconst { readFileSync, writeFileSync, lstatSync, readdirSync } = require(\"fs\");\nconst { join } = require(\"path\");\nconst changeCase = require(\"change-case\");\nconst reactDocgen = require(\"react-docgen\");\nconst { format } = require(\"prettier\");\nconst buildFilePropsData = file => {\n  let filePropsData;\ntry {\n    const fileString = readFileSync(file, \"utf8\");\n    const reactDocgenData = reactDocgen.parse(fileString);\nif (reactDocgenData.props) {\n  filePropsData = {\n    displayName: reactDocgenData.displayName,\n    data: reactDocgenData.props\n  };\n} else {\n  filePropsData = null;\n}\n\n} catch (e) {\n    console.warn(Can't extract props data from file ${file}: ${e.message});\nfilePropsData = null;\n\n}\nreturn filePropsData || null;\n};\nconst buildComponentPropsData = componentName => {\n  const entryFile = packages/${componentName}/src/index.js;\nconst entryFileString = readFileSync(entryFile, \"utf8\");\nconst multiComponentsRelativePathsPattern = /export { default as.from \".\\/(.)\";/g;\nconst multiComponentsRelativePaths = [];\nlet match = multiComponentsRelativePathsPattern.exec(entryFileString);\nwhile (match != null) {\n    const firstCapturingGroup = match[1];\n    multiComponentsRelativePaths.push(firstCapturingGroup);\n    match = multiComponentsRelativePathsPattern.exec(entryFileString);\n  }\nconst multiComponentsFiles = multiComponentsRelativePaths\n    ? multiComponentsRelativePaths.map(\n        multiComponentRelativePath =>\n          packages/${componentName}/src/${multiComponentRelativePath}.js\n      )\n    : [];\nconst filesToCheck = [entryFile, ...multiComponentsFiles];\nconst componentPropsData = filesToCheck\n    .map(file => buildFilePropsData(file))\n    .filter(filePropsData => filePropsData);\nconst hasPropsData = componentPropsData.length > 0;\nreturn hasPropsData ? componentPropsData : null;\n};\nconst getComponentNames = () => {\n  const isDirectory = source => lstatSync(source).isDirectory();\n  const getDirectories = source =>\n    readdirSync(source)\n      .map(name => join(source, name))\n      .filter(isDirectory);\nconst componentPaths = getDirectories(\"./packages/\");\nconst componentNames = componentPaths.map(\n    componentPath => componentPath.split(\"/\")[1]\n  );\nreturn componentNames;\n};\nconst componentNames = getComponentNames();\nconst componentDataObjectsText = componentNames.reduce(\n  (memo, componentName) => {\n    const componentNameUpper = changeCase.pascalCase(componentName);\n    const nameValue = ${componentName};\nreturn `\n  ${memo}\n  {\n    name: \"${nameValue}\",\n    propsData: ${JSON.stringify(buildComponentPropsData(componentName))}\n  },\n`;\n\n},\n  \"\"\n);\nconst componentDataFileStringUnformatted = `// DO NOT EDIT THIS FILE BECAUSE IT IS GENERATED AUTOMATICALLY\nconst componentData = [\n  ${componentDataObjectsText}\n];\nexport default componentData;\n`;\nconst componentDataFileStringFormatted = format(\n  componentDataFileStringUnformatted,\n  {\n    parser: \"babylon\"\n  }\n);\ntry {\n  writeFileSync(\n    \"src/stories/componentData.js\",\n    componentDataFileStringFormatted\n  );\n  console.log(\"Component data file output to src/stories/componentData.js\")\n} catch (e) {\n  console.error(\"Error generating component data file for src/stories/componentData.js\")\n}\n```. ",
    "adeelibr": "any update on this? :) @danez . ",
    "jackaldridge": "Refactored it a bit to use existing util function getPropertyName. @fkling I updated resolveObjectExpressionToNameArray in utils/resolveObjectKeysToArray.js, so that it handles ObjectExpressions and ObjectTypeAnnotations.\nI also noticed that the handleKeysHelper was resolving this to a union:\nconst obj = { a: 'a', b: 'b' }\nconst test: $Keys<obj> = 'a'\nWhich I don't believe is correct. See this example on the flow online repl. I removed this functionality and the associated test.. Any other changes needed here?. @danez for sure, just pushed those changes.. ",
    "tbarbugli": "I just realized this is supported on the upcoming v3 release. ",
    "pksunkara": "@danez Can we please get this merged and a new release be done? This kinda blocks the whole toolchain from being used because of licensing issues in babel beta.. @layershifter You can do ^7.1.0 now. Let's use @babel/runtime and change it to v7.. ",
    "mirzapourh": "I have just come across the same issue - would love to use this tool over jsdoc but it has no support for multiple exports, which all my files have.. ",
    "darcyturk": "@trevordmiller i came across https://github.com/chloeandisabel/doc-prop-types. which may be beneficial for you to check out!. ",
    "kevinparkerson": "Apparently this was fixed, but without updating our project's react-docgen version I've found <React.Fragment>...</React.Fragment> works just fine. ",
    "cangoektas": "Sorry for the vague description! Just updated the issue with an example. \ud83d\udc4d . @danez nice, thanks a lot! Is there also a chance to get this released soon? \ud83d\ude04 . ",
    "jtomaszewski": "OK, will do that! Give me a couple of days and I'll submit it.. ",
    "codylawson": "@danez Confirmed to fix the issue I was seeing. This can be closed.\nTo followup though, it looks like the fix required a special handler for forwardRef as a known hoc. Does that mean all hoc's would need to be handled specially? Are custom hoc's not supported? . ",
    "eps1lon": "@codylawson forwardRef is not a HOC but a \"normal\" component. The issue was that forwardRef was not considered a component and therefore not eligible for HOC wrapping. \n@danez It doesn't seem like #311 is included in 3.0.0-rc.2 which was merged with b048d58b934639afcc4baf5eb6b8970f0d32e5c6 into master. Any chance you can cut a release?. ",
    "wwsun": "any solutions?. ",
    "gatsbimantico": "@danez Seems like VSCode and Travis are disagreeing on some prettier rules. ",
    "micahstubbs": "@fkling would be could to add a couple new maintainers with commit access so that the issue queue could get some love.  \nhere's a vote for adding @jquense as a maintainer with commit access to this repo, so that he can triage issues and review pull requests.. ",
    "davidfirst": "The latest. 3.0.0.\nThe code I used is from the readme. (which by the way threw an error, until I replaced render: function() { with render: () => { ).. ",
    "rolandjitsu": "@fkling I actually tried to use jsdoc-to-markdown, but the generated content does not really align with the content this lib generates.\nI'm also not sure if this lib should generate the docs for a hook fn, but it would definitely make some ppl happy if it did.. ",
    "helfi92": "Thank you for the quick response. No worries, there's no rush from my end :). ",
    "decompil3d": "Why the doubled-up check?. Be more defensive and add a check for whether classDeclaration is truthy:\njs\nif (classDeclaration && classDeclaration.leadingComments && classDeclaration.leadingComments.length) {\n(Note that checking the truthiness of length is sufficient rather than doing the explicit > 0). A few issues:\n\nNo need to wrap the inside of the RegExp with parentheses, since you're not using the capture for anything\nThe . character in your RegExp will match anything -- you need to escape it to check for a literal period. Also, some people might indent the JSDoc field and value differently, so best to be lenient for that:\n\njs\n/@extends\\s+React\\.Component/\n\nNo need to check through all of the comment lines -- you just need to find one that matches. So you can use Array.prototype.some to your advantage:\n\njs\nif (classDeclaration.leadingComments.some(function (comment) {\n  return /@extends\\s+React\\.Component/.test(comment.value);\n})) {\n  return true;\n}. No need for the length check, since some will handle an empty array just fine.. Indent this line.. ",
    "layershifter": "Oops, will do!. "
}