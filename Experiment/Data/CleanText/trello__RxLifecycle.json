{
    "hamidp": "No labels on repo so here goes: :+1: \n. :+1: \n. :+1: \n. :+1: \n. Since this is being pulled out of RxAndroid maybe useful to call it RxLifecycleActivity\n. :+1: \n. ",
    "aguynamedrich": ":+1: \n. :+1: \n. ",
    "dlew": ":+1: \n. Actually, I've decided that it might be better to just make lifecycle() final. I can't figure out why someone would want to override these methods.\n. That's not planned but it could eventually be added.\nI imagine it'd have to be a store of Observable<T> that is stored via key and could be re-subscribed on rotation. We'd have to think a fair amount about the best API - would it be best to have it just be a dumb HashMap? Or should we control subscribe() so that we can automatically unsub/resub on rotation?\n. @hannesstruss On the one hand I agree about it being very framework-y. On the other hand it is a common lifecycle problem people have, and this particular library is about solving common problems around the lifecycle. Plus, putting it into a library that already has to extend Activity and Fragment is a decent place for it.\nI agree that automatic resub is too complex. Here's a simpler idea (though I'm very much so shooting from the hip here): \n``` java\npublic interface ObservableLoader {\n// Must implement this to return whatever Observables desired\n   Observable createObservable(int key);\n// Developer can use these and the Observable will be maintained on config change\n   Subscription subscribe(int key, Action1 onNext);\n Subscription subscribe(int key, Action1 onNext, Action1 onError);\n Subscription subscribe(int key, Action1 onNext, Action1 onError, Action0 onCompleted);\n// ...etc... for the other subscribe() methods\n}\n```\nSo it's not automatic resubscription, it's just automatic storage of Observable<T>. What you do with it is up to you.\n. I'm going to close this for now; I'm not convinced it's something this library (in particular) needs to solve.\n. Was this mostly taken from the old RxAndroid repo?\nI think it looks good, but I'd like to take it a slightly different direction (implementation-wise). Right now it's lacking a bit in two ways:\n1. We have ViewEvent.ATTACH but never actually emit it.\n2. Our OnSubscribe has a bunch of logic in it that can be replicated from other operators.\nI'd like it if we had a solution that's composed of two steps:\n1. An RxBinding-esque way to get Observable<ViewEvent> from a View, completely separate from anything else. (Perhaps maybe even just in RxBinding itself, then we can make this depend on that library).\n2. Combine that with takeUntil to automatically unsubscribe after detachment.\n. I don't mind depending on RxBinding for now. Worst-case scenario we could always spit it out as another module later. But honestly I think most people using RxAndroid will want RxBinding anyways.\n. Whatever you want to do. It doesn't much matter to me.\n. Now that there's a new version of RxBinding out, would this be possible to do?\n. We should add a sample at some point, doesn't have to be here, but if not here then we'll create an issue to track.\n. The main reason is eventually (someday) support easier Activity binding using ActivityLifecycleCallbacks.\nWe could lower it to 14, but that would be pointless (since the difference in users between 14 and 15 is nonexistant). But if it would make people happier I can do that.\n. Why are you on 14 instead of 15? Do you seriously have any users on 14?\n. The chart shown does not differentiate between 4.0 (14) and 4.0.3 (15). If you consider that all their 4.0 is actually 4.0.3 then their chart is roughly in line with what Android currently projects: https://developer.android.com/about/dashboards/index.html\nThat said, I'm going to bump it down to 14 anyways just so that I don't have to keep fielding this question (since I anticipate seeing it a lot otherwise). It won't make any difference regardless.\n. Because those are ancient and no one should have to support them.\n. For future reference - since I forgot where this change originated from - here's the original issue: https://github.com/ReactiveX/RxAndroid/pull/168\n. @major-laslo Please read the linked #13.\n. This is a known problem - OperatorSubscribeUntil has a chance of leaking events based on where in the chain it's located. For more discussion, see https://github.com/ReactiveX/RxAndroid/pull/168\nThis should be solved by https://github.com/trello/RxLifecycle/pull/14. I'll work on getting a release out soon since I'd like to see how people react to the new behavior.\nI'll leave this open until the next version is released so you can try it out and confirm it's been fixed.\n. I've pushed 0.2.0 to maven central - it should show up in a few hours. Let me know if that fixes the problem.\n. You will receive onCompleted. It's a change but it's necessary; there's no other way to solve this bug.\nThe alternative would be a complete rework of the system such that you subscribe in a special manner... which seems much less palatable. Most of the time getting onCompleted is not a big deal.\n. There is no equivalent. bindActivity and bindFragment are not part of this library because they were ill-conceived and didn't really do what you'd expect. For example you could use it and your Observable might never end if it didn't emit at least one item after finishing.\n. You can use RxLifecycle to get automatic closing and should use observeOn(AndroidSchedulers.mainThread()) for the scheduling.\n. This is a problem with the core RxJava project itself. Please refer to https://github.com/ReactiveX/RxJava/issues/3097.\n. This is not an issue with RxLifecycle, but with proguard + RxJava: https://github.com/ReactiveX/RxJava/issues/3097\n. I will not allow this; + is the source of many broken builds.\nIf you want to upgrade its dependencies, all you need to do is define those yourself.  E.g., you could say:\ngradle\ncompile 'com.trello:rxlifecycle:0.2.0'\ncompile 'io.reactivex:rxjava:1.0.25'\n(Note, not a real version number in RxJava... yet.)\nAnyways, by doing that, you end up with the latest RxJava without having to update RxLifecycle.\nRxAndroid explicitly notes this in the usage: https://github.com/ReactiveX/RxAndroid#binaries\n. I don't understand. How did it trip you up?\nIf you include your own appcompat, you can specify which version you want to use.\n. What issues did you run into?\n. It looks like the app is compiled against the highest compileSdkVersion (instead of compiling each against their own individual compileSdkVersion).\nThat said - there's no reason not to use the latest compileSdkVersion. minSdkVersion/targetSdkVersion have an effect on behavior but compileSdkVersion should not.\n. No. There is no reason not to use compileSdkVersion 23 though.\n. The reason is because 10 is ancient and not worth supporting.\n. Are you compiling using Java 7 (or lower)? If so, you might need to include the type, like so:\njava\npubTest.compose(this.<TestModel>bindToLifecycle()).subscribe(testNotify);\n. Seems reasonable to me.\nBTW, you know that you misspelled \"boycott\", right?\n. After pondering this for a while, it seems to me that instead of having two different versions - one for Single and another for Observable - that people should just use Single.toObservable() once they want to use compose(RxLifecycle) on a sequence.\nJustifications:\n1. Single.toObservable() is simple and doesn't have any negative side effects.\n2. Often times you'll end up using compose(RxLifecycle) near the end of your chain, at which point it probably would've turned into an Observable by then anyways.\n3. Supporting both means two different method names for each, which will be confusing.\n4. The lack of takeUntil support in Single seems to be an oversight IMO. That indicates to me that Single isn't fully supported yet.\nAny counterarguments?\n. @phajduk If a Single has a significantly delayed emission (as is the case with a network call) then you could takeUntil zero values have been emitted (which is essentially what this library does).\n. Awesome, we'll get those integrated once they're released.\n. What'd be really nice is if  Observable.Transformer, Single.Transformer and Completable.CompletableTransformer didn't exist at all, and instead the method signature just used Func1<T, T> where T == Observable, Single or Completable. Then one could write a transformer for all three that can be input into any of them.\nI don't think we can get away with that with the current type system (though we could simplify our own implementation by having a single class that implements all three interfaces).\nI'll be thinking on this for a bit. I don't have any qualms with changing method signatures, TBH, we'll just deprecate/warn again. But it still seems like that route would create a method explosion. C seems like the most reasonable route to me so far, since we can guarantee our own type safety.\n. You'd have to cast in the compose() method for that to work, unfortunately.\n. After thinking on it for a while, I think I'd prefer option C. Mainly because there's a combinatorial explosion that'll happen each time we add a new method (if we duplicate methods for each type).\nI'm thinking that we'd still default to Observable for the base methods (at least for now), but then provide a second way to do it for any type. If someone ends up using it a lot they could always write their own wrapper for a particular method.\n. This seems to work for me:\njava\npublic static <T, R> T bind(Observable<R> lifecycle, Class<T> transformerType) {\n  // Implement here\n}\n. Ah, yeah, I do get that. That's because you can't define the generic type of the returned Transformer - e.g. it's returning Transformer instead of Transformer<T, T>.\nI played around with it a bit and got a little further, but haven't quite solved it yet. You can do this:\njava\npublic static <T extends Func1<R, R>, R> T basicTransformer() {\n  // Do whatever here\n}\nThen you can do this:\njava\nObservable.Transformer<String, String> transformer = basicTransformer();\nAnd it doesn't complain. But if you try to use basicTransformer() inside of compose() it doesn't figure it out.\n. It's stalled out due to soul searching.\nThe way the API is would need to be setup means that supporting Single and Completable would increase the complexity. A small complexity increase is alright, but this seems to go beyond that since we'd need 3x of every method. Maintenance would become more difficult as well, as we'd essentially be maintaining three separate code paths (even though they all fundamentally do exactly the same thing).\nI feel like this is going to be a problem for any library built on top of RxJava, so I'm a bit frustrated with how the design shook out.\nAs a result, what I've been considering is simply not supporting Single and Completable. One can still use toX() to add Single and Completable support as necessary without making this library significantly more complex.\n. That's an interesting solution! It looks like a decent mixture of common case/back-compat support but also being able to support the other types. I think I'll explore that sometime this week.\n. D'oh. Will fix.\n. Excellent, thanks!\n. ...Does this really matter? It's a sample.\n. Eh, whatever. Doesn't hurt, probably avoids a lint check.\n. The expected behavior of RxLifecycle is to call onCompleted when it terminates a subscription.\nI suggest moving openHomeScreen() to onNext(), especially since it looks like you're only planning on getting one item emitted.\n. If you call unsubscribe() then it will not call onCompleted().\nPrevious versions of RxLifecycle attempted to unsubscribe rather than complete (for this exact reason), but that led to a whole class of bugs that were unfixable. The current solution is a trade-off: In most cases it's fine, and when you do actually need the behavior of unsubscribe() then you can still do it yourself manually.\n. Yeah, the docs are out of date. I'll fix them up soon.\n. What do people think of the new explanation in #43?\n. I wrote a sample app that should help clear up your confusion: https://github.com/dlew/android-subscription-leaks\n. I've not been using Kotlin myself, but if you submit a pull request I'll gladly take it.\n. Your boycotting comes off as \"I don't want to do the work myself.\"\n. You're not boycotting GitHub if you're just getting other people to make changes for you. You're submitting changes by proxy.\n. ...Not to mention the obvious, which is that the existence of this issue calls into question whether this is a boycott or a dodge for doing work.\n. This looks good, thanks. Could you rebase/squash?\n. My preferred command is git rebase -i master, then replace \"pick\" with \"squash\" (or \"fixup\").\n. Whoa, I see 10 commits.\nYou might want to read a tutorial on rebasing: https://git-scm.com/book/en/v2/Git-Branching-Rebasing\nIn the meantime, if you get your branch back to where it originally was, I can fix it up.\n. Thanks! Also, if you want to submit a PR to upgrade onAttach() I'd take it, too. (I can do it myself, too.)\n. Yeah, back-compat can be tricky. I doubt that it's strictly necessary here, but for correctness' sake probably worth it. I'll make an issue.\n. You could write a wrapper around the current RxLifecycle that uses <T, T>.\n. Another fix is to use the Java 8 compiler, since it can infer the types correctly.\nIt's perfectly safe to use Java 8 on Android (just avoid using any newer constructs like lambdas unless you're using something like retrolambda).\n. I've made #58 to discuss this further, instead of polluting an old PR.\n. I think it's fine to just depend on the back-compat call for a while.\n. I think this is out of scope for the library (as it stands right now) - it's primarily for limiting subscriptions to the lifecycle.\nIt's an effort that I'm wanting to see happen more, though. I think we ultimately need a pluggable Activity out there somewhere.\n. I've been working on https://github.com/trello/navi/, which includes this capability.\nAs a result, this is now even further out of scope, so I'm closing this.\n. Doesn't the whole thing use Observable.Transformer<? super T, ? extends T>?\nYou're going to have to be a bit more specific what you think is wrong.\n. I'm not particularly familiar with service lifecycle either. Maybe some of your coworkers can pitch in thoughts?\n. I'm a bit worried that this is not making much sense. It seems like Services are more complex than Activity or Fragment in terms of lifecycle.\n. This has been open a bit too long; if we want to re-examine this we can come back to it later.\n. I think that's out of the scope of this library, sorry.\nFor the most part this library is focused on subscription management.\n. I'm working on another lib right now that should invalidate this need (if it works out). It has a lot more listeners in general which would let you hook into save instance state. \nI'm going to wait on that until I see if the other lib is viable, especially since if it does work out this library would simply build on top of it (or maybe even be completely invalidated).\n. See: https://github.com/trello/navi/\n. Is it just that you want https://github.com/trello/RxLifecycle/commit/43f052acd32ad44102e62aaf53501c2e14f8f5dd?\n. It's been a busy week (and now it's Thanksgiving) but I'll try to get a 0.3.1 out soon (since there is some demand for it).\n. 0.3.1 has been pushed to maven central; it should be out there soon.\n. Thanks!\n. Not at the moment - there's a possible rewrite that's going to happen based on some new developments. (API will remain the same but internals would change.)\n. I just took a deeper look at the code and we don't actually use targetSdkVersion except for the sample.\n. We're not voting, we're discussing. :)\nOne other possibility is to try to figure out if we can use some halfway-solution that allows for full inference on both Kotlin and Java, e.g. <? super T, T> or <T, ? extends T>.\n. For anyone arriving here because of problems: there is no harm in remaining w/ 0.3.0 while we suss this out. There are no changes besides the method signature.\n. Some more research notes:\nJava8 isn't a good solution because it requires lambdas the entire way. If you use compose(bindToLifecycle()).subscribe(n -> ...) then it works (whereas actually supplying an Action1<Type> does not). But we can't require retrolambda for people using this lib.\nI'm hoping to find a kotlin expert who can tell me why <T, T> can't be inferred. But generally speaking the problem with Java is what @tbsandee found out: it infers Object instead of T.\n. I went onto the kotlin Slack and asked about it. It may be something that the kotlin compiler can fix. I've reported an issue, we'll see how it goes: https://youtrack.jetbrains.com/issue/KT-10250\nIn the meantime I'm heavily leaning towards reverting to <T, T> since most people will be using this library w/ Java.\n. It seems like the problem is in Kotlin itself and some bugs in its type inference. I reported on it and it was recently marked as obsolete, so I assume there has been some improvements made there: https://youtrack.jetbrains.com/issue/KT-10250\nRegarding function extensions - that seems orthogonal to this problem. It seems like a neat idea though.\n. Duplicate of #58\n. Duplicate of #58, it's been reverted for the next release (whenever that happens, probably soon).\nUsing 0.3.0 in the meantime fine, since the generics is all that changed.\n. The reason it's final is that ActivityLifecycleProvider is an interface, so it should be mockable if you need to override its behavior for tests. Outside of tests there's pretty much no reason to override it (that I know of).\nI don't agree with how RxIdlingResource works: a subscription isn't an indicator of background activity! There are plenty of other cases, for example if you're using a subscription detect changes in an EditText, or a subscription for when a button is clicked, or..., or... that's the point of Rx.\nI think you need to be a lot more specific about which subscriptions should cause idling, rather than just tracking all of them.\n. Alternatively, we could make RxBinding an optional dependency such that that method only works if you have actually provided RxBinding.\n. Question: How many people use RxLifecycle but not RxBinding?\n. I'm comfortable with depending on RxBinding for this library. If you're using this lib, you're (at least) using an Activity already, which implies Views, in which case RxBinding seems like a natural fit regardless.\n. How is observable.bindToLifecycle(customTransformer) different from observable.bindToLifecycle().compose(customTransformer)?\n. So there is no difference?\nIf you only want a single compose() you can combine the two transformers into one.\n. I'm kind of two minds on this one. It would be easy to add ListFragment support... but where does this end? There are (by a quick count) over 20 fragments in the Android library. Plus, the library was purposefully setup with interfaces so that you can supply your own implementations (since there are so many potential base classes out there).\nOn the other hand, I know how this will save a bit of work.\nCan you make an argument for why ListFragment should be one of the officially endorsed base classes? To me, it seems to fall below the threshold of necessity since you can fairly easily reproduce much of its capabilities without using it.\n. I've slept on it and I think I'm going to say \"no\" on this one for a couple reasons (in addition to the ones above):\n- I've felt for a while that both ListActivity and ListFragment are too specific - they work in some very broad circumstances but are otherwise inflexible.\n- If this was considered a core Fragment, then there would be a RecyclerFragment, but there isn't one.\nIt shouldn't be too hard to write your own RxListFragment, though - just copy the RxFragment code and extend from a different class. :)\n. Switching to 2.0.0 necessitates everyone uses Android Studio 2.0, right? I could be wrong, I haven't been using it...\nIf that is the case, though, I'm not sure I'm comfortable with that.\n. I don't like canary builds because they tend to break a lot.\n. I don't want to add another dependency if we can avoid it, and the use of Subjects are entirely internal.\n. I'm always hesitant to open things up, since I've always considered that more of an implementation detail, especially bind().\nWould using takeUntil + Navi help out? Navi is better designed for generic inputs.\n. I have separate thoughts on bindUntilEvent() and bind().\nLooking on it now, it seems like we shouldn't even have bindUntilFragmentEvent() and bindUntilActiviyEvent(). bindUntilEvent() can use generics to figure out the difference. I think we can open that up and deprecate the first two (or even just remove them entirely).\nRegarding bind() though (and really, your entire original problem). Suppose we open up bind(). Then we also have to open up ACTIVITY_LIFECYCLE and FRAGMENT_LIFECYCLE, since those are the inputs. And your implementation would have to know which one to pass in. I'm not sure how that saves you any effort, generically speaking, since you still have to know whether you're working with Activities or Fragments. The same applies to bindUntilEvent() since you'd have to know which you're targeting.\n. I see your point. I'll think about it.\nIt almost seems like this could lead to a split in the library, where RxLifecycle is all about binding generic subscriptions to any given lifecycle and RxAndroidLifecycle could be about binding specifically to Android lifecycles.\n. Both Observer and Subscriber create subscriptions after subscribing, so the question makes no sense. RxLifecycle can be used with either.\nRegardless, this is an tracker for RxLifecycle's bugs and features. If you have questions about usage please check elsewhere, like stackoverflow.com.\n. Thanks!\n. It hasn't been uploaded yet, the docs are a bit ahead of the releases.\nI'm working on getting the next update out this weekend so it'll work soon!\n. Some more recent thoughts - we could do something akin to how the Navi version of RxLifecycle works. Provide a method which turns Activity -> ActivityLifecycleProvider.\nI'm still a bit stuck on the unregistering part, unless we use one global callback.\n. There are now FragmentLifecycleCallbacks so it may be possible to look into this again.. Already integrated: #215 . The reason BehaviorSubject was chosen is so that the automatic binder can figure out where (in the lifecycle) we currently are. E.g., if you're in onCreate(), then the library can detect that CREATE has been called and automatically bind until DESTROY.\nWhat I don't quite understand about your scenario is the \"resurrecting FragmentA\" part. The intention is that you bind an Observable that is inside of FragmentA to FragmentA's lifecycle. If you do it that way, then (as long as you're inside of the lifecycle) everything should work out, since (for example) the FragmentEvent.ATTACH should be called before anything else.\nIf you're trying to bind an Observable outside of FragmentA to FragmentA then you lose a lot of control over whether that makes any sense, since who knows what state FragmentA is in?\n. When are you rebinding? It sounds like this is what's happening:\n1. Fragment initialized.\n2. Fragment.onCreateView() called.\n3. Fragment subscribes to data stream, binds to its lifecycle.\n4. Fragment is removed from FragmentManager.\n5. Fragment.onDestroyView() called, which ends the data stream subscription.\n6. Fragment subscribes to data stream, binds to its lifecycle.\nIt seems like there's a step missing before the bolded one - that is, Fragment.onCreateView() being called again.\n. Thanks, though could you undo the change to the last line?\n. I just don't want unnecessary changes in a PR is all.\n. Does this actually need to be part of the rxlifecycle project, or could it be its own separate project?\nThe reason I ask is because I'm not particularly interested in maintaining such a lint check, so I'm afraid of this aspect of the code going stale.\n. The popularity of the lint check is not a high priority for this project. Much higher up is quality and maintainability, which I think will be better served by this lint check being in its own separate lib with its own maintainers, instead of adding more to the workload for RxLifecycle.\nWe can certainly link to it in the README from here, though.\n. Awesome. I'll put a reference to it in the README.\n. This inspired me to make #99, so I can test things Kotlin in action (since I don't normally use Kotlin for Android dev).\nI wasn't able to reproduce your issue at all though. Are you sure there isn't something else going on? E.g., are you sure this is the Activity?\n. Maybe a clean build is what it took? Or maybe it's an instant run problem? \nRegardless, good to have this sample around now for cases like this.\n. We already have a hard dependency on RxAndroid via RxBinding, so that's not a problem.\nI'll have to look into it but it seems reasonable to call subscribeOn(AndroidSchedulers.mainThread()). RxView.detaches() has the expectation of being run on the main thread (see here).\n. So of course, after I play around with a solution, I try to verify that it works and I can't reproduce your original problem.\nI tried quite a few things, but I couldn't get it to crash in the way you describe. For example, see this:\n``` java\nObservable.create(new AsyncOnSubscribe() {\n    @Override\n    protected Integer generateState() {\n        return 0;\n    }\n@Override\nprotected Integer next(final Integer state, final long requested,\n                       final Observer<Observable<? extends String>> observer) {\n    if (state < 100) {\n        observer.onNext(Observable.just(\"Hello, \" + state));\n    }\n    else {\n        observer.onCompleted();\n    }\n    return state + 1;\n}\n\n})\n    .subscribeOn(Schedulers.io())\n    .compose(RxLifecycle.bindView(view))\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Action1() {\n        @Override\n        public void call(final Object o) {\n            Log.e(TAG, \"Got object! \" + o);\n        }\n    });\n```\nI'm calling it on the main thread - maybe your subscription isn't actually starting there?\n. Did you take a look at the PR? What about that solution is problematic?\nI've just now updated it with a test now to confirm that it fixes this problem in particular.\n. I don't think there's any solution to the post-after-detach problem besides subscribing on the main thread.\nI wonder if that means we should just let this keep crashing, since if you do use subscribeOn you're opening yourself up for subtle timing bugs. It would force people to code around this problem correctly.\n. #106 has convinced me that my PR is not the right solution because it can severely delay the incoming notifications. I think it'll be best to just put a warning on the documentation about this problem.\n. I decided to just add the warning and allow bindView() to continue to crash if called off the main thread. The effects of using a scheduler are too dangerous otherwise.\n. This is a duplicate of #93 - reasons for not engaging yet are explained there. I'll put some more current thoughts there as well.\n. Where are you calling this code? If it's in onResume() then it'll unsubscribe in onPause(), which is expected behavior.\n. I dug into this and found the issue. You shouldn't be calling subscribeOn(AndroidSchedulers.mainThread()). It's not really necessary at all. More importantly, it causes the timing of the subscription to shift until after onResume(), which bindToLifecycle() then appropriately cancels in onPause().\n. Whoops, thanks for the catch!\n. I can't read Chinese, sorry.\n. Terminating the sequence is equivalent to unsubscribing for purposes of preventing memory leaks.\nThe docs are there to (try to) make it clear that the behavior of RxLifecycle is different from calling Subscription.unsubscribe(). When you do unsubscribe(), all emissions end. With RxLifecycle it calls a terminal event.\n. You need to update your Android SDK repositories with the latest app compat/support annotations libraries.\n. This issue seems to have nothing to do with RxLifecycle.\n. Yes, it's possible. All that RxLifecycle requires is an Observable<Event> of some kind. If you implement your own lifecycle Observable then you can plug it in here.\nOne good way to do that is to implement ActivityLifecycleProvider or FragmentLifecycleProvider. That's essentially all that RxAppCompatActivity is doing.\n. Closing this due to inactivity.\n. You should strive to call compose(bindToLifecycle()) as late as possible - after observeOn if possible.\nRegardless, the issue tracker is for problems with the library itself. General usage questions should go to other forums, such as stackoverflow.com.\n. I feel like there's something missing from your sample. Either you're compiling with Java 8 (and the type information will propagate correctly) or you're compiling with Java 7 (and you need to explicitly cast the bindToLifecycle() call), like so:\nObservable.just(1).compose(this.<Integer>bindToLifecycle()).subscribe(/*int*/)\nSingle.just(1).compose(this.<Integer>bindToLifecycle().forSingle()).subscribe(/*int*/)\nIn other words: If you were on Java 8, both would work. If you were on Java 7, neither would work.\n. Hmm, I checked it out on Java 8 and you're right, it's not working there.\nIt may be a limitation of Java's type inference. I'll have to look deeper.\n. Just a warning, this is fairly low on my priority queue right now because A. I don't use Single that often myself and B. there's a clear workaround (using this.<Integer>).\n. Done in #143 \n. Sorry for the slow reply, been on vacation for the past week.\nonViewCreated() was originally chosen because the common pattern is that Fragments implementing onCreateView() won't call super, since Fragment.onCreateView() normally does nothing and returns null. If super is never called then RxLifecycle can't do its work properly.\nI searched around the internet for a bit to find examples of how people actually use Fragments and all samples I found do not call super. The documentation examples don't call super. Even Google's own Android architecture example, which just was released a couple of months ago, don't call super.onCreateView() (example).\nI am sympathetic to the problem - it does seem like something we should fix! However, simply switching to using onCreateView() will actually hurt more than help since few people call super. Got any other ideas?\n. Also, unfortunately, it seems that Fragment is not annotated with @CallSuper at all, so there's no expectations setup for which lifecycle methods are expected to have super called on them.\n(I know our subclasses define @CallSuper but a lint check is not a strong enough guarantee that people will use RxLifecycle correctly.)\n. Renaming it would solve any confusion around people using it directly, but it wouldn't solve the overall problem of the expectation of binding in onCreateView() being unbound in onDestroyView().\n. Call super.onCreateView(), ignore results.. See discussion here: https://github.com/trello/RxLifecycle/issues/131#issuecomment-229959884\n. Closing this due to inactivity.\n. I'm a bit confused by your question, since the point of RxLifecycle is to prevent leaks/crashes with long-lived Observables. If you're getting those, that may indicate a problem with RxLifecycle.\nThe reason we don't just track subscriptions is twofold:\n1. There's already CompositeSubscription in the RxJava library which does a good enough job of it already, if you need it in some circumstance. (It's legitimate to run RxLifecycle alongside CompositeSubscription, depending on needs.)\n2. Wrapping is less friendly than just calling compose().\nAn early version of RxLifecycle did just track subscriptions but it was harder to use.\n. I think there's some fundamental misunderstanding here. bindToLifecycle() should take care of ending the sequence. While it's not technically the same as unsubscribing, it has the same overall result in terms of cleaning up memory leaks.\nHave you taken a look at the sample? It shows how the Observables terminate using RxLifecycle.\nCompositeSubscription helps in situations where you have multiple Subscriptions and want to cancel them all at once. If you've only got one Subscription then it doesn't matter, I was just guessing you had multiple because that's usually when people start looking into using RxLifecycle.\n. Yes, it should work when you subscribe to an Observable. That's what RxLifecycle is for.\n. I don't understand what you want. Could you elaborate what sort of API you're interested in having?\n. RxFragment extends Fragment, so anything that's available in Fragment (including requestPermissions()) should be available.\nI just tested it out with the sample project and the IDE detects requestPermissions() just fine.\nIf you could provide a reproduction in a project then I could look further into it.\n. Thanks!\n. That sounds reasonable to me. We can work it into the next release.\n. #138 is a good start. I'm keeping this open because I want to investigate if we should just get rid of FragmentLifecycleProvider and ActivityLifecycleProvider altogether. The only APIs using them are more internal than anything else (except Navi, but that's so experimental I don't mind making people change their code to adapt).\n. Hah, this is great. You can tell exactly how unnecessary the previous code was because it just defines a generic now.\nMakes me think we ought to deprecate (or remove) the old providers. I'll look into that.\n. I have only the vaguest idea of what you're asking for, so here goes...\nOur dependencies are defined here: https://github.com/trello/RxLifecycle/blob/master/build.gradle\n. Your build should use whatever is the highest version for support library. It doesn't matter so much what is defined in this library as a result.\n. How are you using RxLifecycle in this context? Are you using the Observable<ActivityEvent> to listen for ActivityEvent.RESUME, and then posting fragment transactions in there? Or are you just wanting to bind to a different event?\n. That's not really the general use case for RxLifecycle. That's why we created navi which has a lot more callbacks from the lifecycle.\nThat also doesn't have onResumeFragments() but that could easily be added there.\n. If myObservable emits onCompleted then the stream ends as well.\nInternally, RxLifecycle uses the takeUntil() operator, so you can think of its behavior in the same way.\n. I don't understand your question. What is a BehaviorSubscription?\n. Yes, that's because it runs the lifecycle. It's what's feeding the events to takeUntil.\nBasically - what you want to do is fine and the expected behavior of RxLifecycle. If you have deeper questions about how RxLifecycle works, I invite you to explore the source code.\n. I've heard that the Android SDK repos are having troubles today.\nDoes the error happen when using the library, or just when compiling it?\n. The original error quoted, yeah.\nI suppose the reason I'm not getting the error is because I was running an older version of Android Studio.\n. Thanks!\n. Definitely! When is a bigger question; I haven't had a chance to even look at RxJava 2 yet, but since the first RC is out...\n. I'll start working on a side branch for RxJava 2 soon (as in next week). People are demanding it so it must happen, even if it's sooner than I want.\nI'll look into the possibility of the two existing side-by-side. One problem with that is adding to the method limit. Another is signing us up for long-term support of RxJava 1 (that I probably don't want to do). But maybe it won't be so bad.\n. You can check out the current code for how it handles Completable. Basically it ends with onCompleted() via amb(). I'm not sure that's the correct behavior but it seems better than ending with onError.\nAnd yes, you are correct. The problem with calling unsubscribe is that it actually is not guaranteed to work, depending on how operators are setup. It is abnormal for an operator to call unsubscribe, in other words. It'll work going upstream but not necessarily downstream.\n. @huseyinozer https://github.com/blog/2119-add-reactions-to-pull-requests-issues-and-comments\n. I've been working on RxLifecycle v2 which supports RxJava 2. A snapshot release is now available on the Sonatype snapshots repository: https://github.com/trello/RxLifecycle/tree/2.x#installation\nYou can read up on what's changed (so far) here: https://github.com/trello/RxLifecycle/blob/2.x/CHANGELOG.md#20-unreleased\nI'm going to be letting this (and Navi) sit for a week so people can review/test it out. Then I'll push an official 2.0 next week.\n. What goes wrong when it's called before map()?\n. Sorry for dropping the ball on this one, forgot to follow up.\nI've been trying to reproduce this on my end but I cannot.\nI'm going to close this for now unless you have a more full sample demonstrating the issue, but as far as I can tell it's working correctly right now.\n. Oh neat, so there's no way for the library to be backwards compatible. :P\n. I know, I think I've learned a lesson here not to support experimental APIs in a more stable lib.\nThe problem is that people wanted support for completable/etc...\n. I'm not 100% sure, but I think that even if you're not using Completable.Transformer it's used in the source code of RxLifecycle. So unless you're proguarding all that stuff out, the compiler will complain that RxLifecycle is referencing classes that don't exist.\n. You'll have to include the right JSR in testCompile to get it working.\n. It's not worth the time to support that far back.\n. Looks good to me, thanks.\n. It looks like it won't be such a simple upgrade. Want to look into why the tests are failing?\n. I've pushed a version of this that works with RxJava 1.2.1 in #159.\nFor the record, the actual way RxLifecycle works is fine. The tests were just written on incorrect assumptions.\n. Welp, it's kind of hard to figure out what's going wrong due to https://twitter.com/traviscistatus/status/793515766159020032\n. Hmm, I knew I must've forgotten something. Time to fix more tests.\n. You'll need to compile all your sources with a specific version of com.google.code.findbugs:jsr305 so that they don't conflict in the test app.\n. RxLifecycle only handles unsubscription at this point. I've mused on the idea of automatically starting a subscription based on a lifecycle event but that would definitely increase the complexity of this.. Ah, that's a problem. I can fix that up quickly.. Fixed.\nI'm going to wait a day or two before releasing 2.0.1, to see if anything else comes up.. Yes, the first two are the same thing.\nAnd yes, the second one terminates the moment any event occurs. It's used internally for everything and has had one or two helpful applications outside of the library itself.. Are you sure you're not still using 2.0? I just ran your test and it works fine for me.. You need to go to the 2.x branch: https://github.com/trello/RxLifecycle/tree/2.x. Dialog can be wrapped with DialogFragment which is already supported.\nI'm not sure how we would support PopupWindow. What events would it track?. Unlikely. I view ListFragment as wholly unnecessary. I think it's generally better to just include your own ListView in the layout and bind to it.. Services are a little more weird because their lifecycle isn't so cut and dry. If someone can propose how it'd work then we could do it, but they aren't the same \"power up, then power down\" lifecycle that Activity has.. There's already View support: https://github.com/trello/RxLifecycle/blob/1.x/rxlifecycle-android/src/main/java/com/trello/rxlifecycle/android/RxLifecycleAndroid.java#L98\nAs for adapter items, what sort of lifecycle do they have?. I think at this point I'm not going to be supporting any more components explicitly.. I actually prefer onCompleted. I couldn't come up with a better solution for Single and Completable because there's no proper terminal in either case.\nThe same case of using onCompleted for a sequence being complete could be made for onError meaning a sequence had an error. It's not an error if it completes early IMO.\nGenerally speaking, you should be using onNext for your processing of data.. I still disagree, but it's sort of a moot point because I'm not going to change it to onError as it would disrupt too many people's code.\nThe number of times I've used onCompleted is... almost zero. I actually have trouble remembering when I have used it. It was more tempting to use when I first started RxJava but over time you start representing all data as streams and the fact that the stream has completed is usually not important.. RxLifecycle, at its core, is just a fancy wrapper around takeUntil. And the behavior of takeUntil with Observable is to emit onCompleted.\nI'm going to stick with that for two reasons: I don't agree that the change is necessary and I believe in keeping libraries as simple as possible.. It's still in the readme: https://github.com/trello/RxLifecycle/tree/2.x#unsubscription. VerifyError is most likely a build problem on your end. If you can create a sample that reproduces it then I'll look into it.. It is not intended to survive Activity rotation. I don't know of any good samples out there, but this issue tracker is not the place to find it.. If you're using Java 7 for compilation then you may need to include hints for the generics, like so:\njava\nObservable.just(1).\n  compose(RxLifecycle.<Integer, ActivityEvent>bindUntilEvent(lifecycle(), ActivityEvent.DESTROY)). No thanks. I'd rather stick with enums.. AFAIK there shouldn't be any special proguarding setup for RxLifecycle. It doesn't use reflection or anything else that would throw Proguard off.. Yup! Already supported.\nI'm going to make a note to update the 1.x readme so that it points people towards the 2.x branch if they want it.. See: https://github.com/trello/RxLifecycle#unsubscription\nThere's no way to actually do what you're asking for via compose() for Single, so we make a best effort here. If you need the behavior to be unsubscription, then you will have to do it manually.. RxLifecycle used to do something very similar to that but it was pointed out to be inherently unsafe: https://github.com/ReactiveX/RxAndroid/pull/168#issuecomment-108901444\nYou can read more about it here: https://github.com/trello/RxLifecycle/blob/1.x/CHANGELOG.md#020. To be honest, this stuff makes my head spin, so I sort of defer to Karnok on matters like this.. You could, but then you'd be coupling the Subscriber directly to the Activity. Right now it works with any generic lifecycle stream (which in many cases is provided by the Activity but does not have to be).. VerifyError is most likely a build problem on your end. If you can create a sample that reproduces it then I'll look into it.. I do not want to remove the RxBinding dependency. More on why here: https://github.com/trello/RxLifecycle/issues/66#issuecomment-163650582\nIn addition, 1.x is in maintenance mode and will only accept PRs that fix bugs.. If you're concerned about method count you should already be using proguard, and RxBinding proguards very well.. > Is there a document somewhere that explains?\nThere is a README.md that gives an overview of the library.\n\nWhat's the secret handshake?\n\nThe issue tracker is for bugs and feature requests with the library. If you have questions about RxJava, I suggest Stack Overflow.. I don't understand your use case. It seems like you want an Observable subscription to not be canceled in the case that the Activity was destroyed (but not finished)?\nI would argue that you should unsubscribe from observables in onDestroy() regardless of whether it's finishing or not. If the Activity is being recreated then you actually get a new instance of Activity and it would be detrimental to hold onto subscriptions referencing the old Activity.. Yes, this library terminates sequences. It does not technically unsubscribe. I use the term \"unsubscribe\" anyways because that's how most people understand what it's doing (and it's basically trying to mimic that behavior in a safe way).\n\nOn to your actual question. If the Subscription lives beyond the lifecycle of a single Activity then this library does not apply to it. That said, it's possible to unsubscribe from an Observable without terminating the Observable itself. The way I use it, the Observable lives on between Activities but each individual Activity unsubscribes/resubscribes as necessary.\nThat may not line up with your presenter-based setup.. Yeah, that's fine.. Thanks for reporting. It is indeed related to that PR.\nFixing it only involved modifying tests, so I'm not going to release a new version of RxLifecycle; the internals of the library are still sound.. This is how RxLifecycle works for Single and Completable. Read more here: https://github.com/trello/RxLifecycle/tree/2.x#unsubscription. If you need to avoid the exception, don't use RxLifecycle (and instead manually call unsubscribe() on the subscriber).. Please see the linked information for what's going on: https://sites.google.com/a/android.com/tools/tech-docs/new-build-system/user-guide#TOC-Resolving-conflicts-between-main-and-test-APK. Because that won't work. You can't unsubscribe downstream subscribers from upstream. You can only emit notifications downstream, and the only alternative notifications that Single and Completable allow for are onError.. IIRC, doOnSubscribe() does not pass you the same disposable as you'd get if you grabbed the one at the end - it just wraps the disposable for the next operator. In your example those are the same (since doOnSubscribe() is called right before subscribe()) but if there are more operators below the chain then those wouldn't be unsubscribed.\nI just need to sticky this somewhere because someone asks this question about once a month: https://github.com/trello/RxLifecycle/issues/196#issuecomment-271076219\nIf you don't like how RxLifecycle works, try out AutoDispose, which just came out recently and sidesteps this problem.. I don't understand the problem. Could you elaborate or post some code?. Chances are you're dependencies are misconfigured in some way. I still don't exactly understand what's going on, so I am going to need a reproduction of the issue.. You can use onTerminateDetach() if you want. We're not going to add an experimental API to this library though.. This looks like an issue with your builds, not with this library. If you can submit a reproduction of the issue then I can look into it.. This library is focused singularly on the task of linking streams to lifecycles. It doesn't deal with Schedulers at all.\nYou can write your own Transformer that automatically adds the schedulers that you want.. https://github.com/trello/RxLifecycle/blob/1.x/rxlifecycle-components/src/main/java/com/trello/rxlifecycle/components/support/RxFragment.java. This is sort of an unfortunate issue with library dependencies in test configurations that you can't get around easily. The same issue comes up with Android support annotations (if you're using two different libraries that depend on different versions of it).\nIf you make it provided then it keeps the annotations in the compiled classes, but then it has no code to actually interpret that code in the debug build.. See https://github.com/trello/RxLifecycle/issues/211 for more information about this.. You can pass the lifecycle Observable to your Presenter and use it from there.\nI'm closing this because GitHub issues are for bugs and feature requests for RxLifecycle. For usage questions, stackoverflow.com or the like is a better avenue.. I'd be down with a navi-like extension built on top of the new arch. I'm not sure when I'll get time to do it though.. Many thanks to @evant for adding support!. Thanks so much for all the work! I'll try to get a release out with this soon.. Single emits CancellationException when it disposes: https://github.com/trello/RxLifecycle#unsubscription\nDue to the way RxLifecycle is setup, there isn't a great way around it. I suggest checking out AutoDispose if you want to automatically dispose of Singles without getting an exception.. Let me rephrase: there is no way around it since I'm not breaking anyone's existing code by changing behavior at this point.. Should be fixed in the next version.. Thanks!. What happens if you switch the order of compose() and observeOn()?. I'm closing this because I suspect this was a temporary issue with Google's maven repository.. The simile would be merging multiple Observable<LifecycleEvent> as the source for events.\nThe issue tracker is for bugs and feature requests in RxLifecycle, not a help request forum. As such, I'm closing this issue.. Perhaps a sample would help? https://github.com/trello/RxLifecycle/tree/2.x/rxlifecycle-sample\n\nHow about a very short example showing the same program with & without RxLifecycle?\n\nhttps://github.com/dlew/android-subscription-leaks. Honestly, I don't have the will or the time to answer these questions if you're not willing to look at the samples and answer them for yourself. If the README and two different sample apps can't help you, then too bad.. Another possible avenue: AutoDispose does a very similar thing to RxLifecycle, perhaps you will find their documentation more appealing: https://github.com/uber/AutoDispose. Could you provide a sample app showing the same problems?. Yup.. The problem here is that you'll possibly be breaking a lot of peoples' code if we make this change... it's why I haven't figured out the best way forward.\nI was thinking more along the lines of calling CREATE_VIEW on both onCreateView() and onViewCreated(). I wasn't sure if that would also cause problems - if it does, it's probably along the lines of \"you shouldn't have been doing that in the first place.\"\nA third option is to warn people not to use these methods in Fragment.onCreateView() and instead tell people to use Fragment.onViewCreated(). Not totally satisfying, but it doesn't break existing code.. I'm closing this for lack of activity.. Thanks!. The reason we haven't done a solution like this is because of the problem you pointed out - it's only viable if applied directly before the subscribe call. I wasn't comfortable requiring such an unenforceable requirement (especially because much of the time, using it elsewhere in the stream would seem to work just fine, so you wouldn't realize they're all wrong).\nAt this point, though, I'm not going to be changing the behavior of the library. People are using it with its current behavior and it's not worth shaking things up when AutoDispose exists for those who want the other behavior.. Closed via #235. Thanks!. Thanks for the PR, but there's no need to push out an update for RxLifecycle just for a transitive dependency update. If you include 26.0.1 in your builds, RxLifecycle will use it as well.. On the one hand: yes, this makes a lot of sense.\nOn the other hand, I don't want to add another transitive dependency for people who don't need it.\nThoughts?. Yeah. I think if we want to add this, it should be in its own dependency. It's more of a pain to setup initially but it saves a lot of headache for consumers.\nIt's how we should've done the original split between OS and support components, too. We could still go back and do it that way, in fact.... This is great, thanks!. I've pushed out v2.2.0 which includes this new artifact.. The stack trace has nothing to do with this library. You ran out of memory in the app decoding some bitmaps.. Sorry, I don't speak that language - this will have to be translated before I can help.. Could you give a larger example? Out of context it's hard to diagnose what's going wrong.. I meant, where exactly is that code being called from? Like, is it being called in onCreateView()?. We'll have to upgrade the code to match the betas. I think this is probably alright because the beta APIs shouldn't be changing dramatically anymore.. My life is fairly hectic at the moment, but I'll see if I can find time in the next week to do another release.. Life continues to be hectic and I apologize for that. I will really, really try to find time to get to this this week.. It was closed because #249 was merged, which fixes the issue.. This issue tracker is for reporting issues with the RxLifecycle library. If you need help with usage, please refer to the README or StackOverflow.. Yes, it is for real.\nIt's not mentioned because people still do use it and like it. For those people, I'll keep supporting it.. Awesome, thanks!. It looks like this fails due to lint issues. Could you look into that?\nAlso, I thought fixing #245 would require some source code changes (inheritance-wise).. Thanks so much for the work!. Could you provide more details? Maybe a sample?. I don't speak Chinese.\n\u6211\u4e0d\u4f1a\u8bf4\u4e2d\u6587\u3002. As far as I know, there are no proguard rules needed for RxLifecycle. It doesn't rely on reflection or annotations, so all RxLifecycle code you use will automatically be kept by proguard.. It was originally built on top of RxJava 1, and you can still use RxLifecycle 1.x for RxJava 1 support. However, most development is now for RxLifecycle 2.x, which works with RxJava 2.. You could look into AutoDispose, a similar library with a better implementation.\nOr you can just give up and use Subscription. It's really not so bad. I prefer the explicit nature of it these days.\nI wrote more about RxLifecycle's woes here and my switch to Subscription: http://blog.danlew.net/2017/08/02/why-not-rxlifecycle/. clear() resets the internal state but you can keep using the same CompositeSubscription. unsubuscribe() terminally ends the CompositeSubscription and all its children.\nThis is an issue tracker for bugs and issues with this specific library, if you have any further questions on how to use RxJava, please take it to Stack Overflow or similar forums.. If you're compiling with older versions of java, you may have to apply the generics explicitly to bindActivity() to make it compile. It looks like it cannot infer the generic type automatically.. Have you tried applying the generics manually? E.g. RxLifecycleAndroid.<T>bindActivity(etc)?. I wish you'd asked before you did all this work... I appreciate the effort but at this point, we can't change the basic behavior of RxLifecycle without screwing up a bunch of peoples' code. Also, generally solutions like this don't work because it's possible that the downstream can keep emitting even if you cancel the upstream, since Disposable only disposes up (not down).. Thank you!. The description says Gradle 4.1, but I don't see a Gradle update... (and I'd pick something more recent than 4.1 at this point).\nThat said, it fails CI because you also have to update the .travis.yml file.. It's still not passing CI, not sure what you want me to do here. :P. Sorry, this PR kind of got lost in the busyness that was my life for the past few months. I'm closing this because now that I'm working on RxLifecycle 2 again (for a bit), half of these are out of date.. Use a different library, like AutoDispose.\nRxLifecycle has its way of doing things, and it's not changing at this point.. It should support it - have you added compile 'com.trello.rxlifecycle2:rxlifecycle-components:2.2.1'?. You're using unstable canary builds. I suspect you should be filing this with Google, not with me.. You might want to check out https://github.com/trello/navi.. I'm on parental leave at the moment, sorry for slow reply.\nSee #131 for why things might be going wrong here. If that's not the case, let me know and I can dig more.. This isn't an RxLifecycle issue. The only line with RxLifecycle is calling super(), you have to look higher up to see what's going wrong.. Jetifier should take care of this for now.\nProbably won't even consider doing this until AndroidX is out of alpha.. Have you filed this Google/R8? It seems like it's more in their wheelhouse than mine.. Could you link the Google ticket here?. Should be fixed via #275.. Could you provide a bit more of a stack trace? I haven't actually tried this out myself yet.. It's still not exactly clear to me why the Jetifier doesn't work here, since the point of it is to change android.arch.* to androidx.*. If it's not doing that, then we should be filing bugs with the Jetifier, not trying to change this lib. Changing this lib would cause problems for anyone who isn't updated to AndroidX yet.\nAt the very least, what we'd need to do is support is to create another artifact, not modify the existing ones (since that'd break back-compat).. Here's what I've decided to do for now: I'm updating all the dependencies (since referencing android arch 1.0.0 instead of 1.1.0 was causing problems for R8). If, after that update, AND after Jetifier is stable, people are still having Jetifier issues, then we can look into a longer-term solution.\nHowever, what I explicitly do not want to do is just update the package names in the library. That will break everyone who isn't switching to AndroidX just yet, which is completely fair given that it's only in beta.. I'm gonna need more details on this before I can fix it, like a reproduction.. You have to manually include that dependency to make sure you're getting the right version. See more here: https://stackoverflow.com/a/47066325. I'm not going to merge this, because it'll break compatibility with all apps not using AndroidX yet. I would rather have a solution that utilizes Jetifier.. In what way are these old tests deprecated? It seems like they're actually still relevant.. I covered this as part of https://github.com/trello/RxLifecycle/pull/275. I'm gonna need more details on what exactly you want.. This looks like a Proguard issue, where you're removing BehaviorSubject from the final APK.. I don't understand how this avoids any sort of object creation. In fact it adds some object creation by using a Delegate wrapper.. Those are convenience methods based on having a LifecycleOwner. If you want to reuse the owner multiple times, just create a AndroidLifecycle and use that (which doesn't require extension functions, because it already has the bindToLifecycle() and bindUntilEvent() methods built in).\nI think this just adds unnecessary complication to the setup. You're totally free to add this delegate to your own code, but I don't think it'd be useful in general.. This is an issue tracker for bugs/features in the library, not a place to seek help using the library. I suggest going to stackoverflow.com for help.\nYou're welcome to update this if it turns out to be an issue with the library.. Thanks for putting in the work, but I'll probably be doing this myself in a slightly different manner. In particular, I'm aiming not to have to enable the jetifier, which I think I should be able to pull off by updating Navi for AndroidX first.. Updated package name but forgot to update README. com.trello.rxlifecycle3 should work.. Yes.\nHowever, you are under no obligation to upgrade to RxLifecycle 3.0.0 yet. The only substantive change is supporting AndroidX. You can continue to safely use RxLifecycle 2.2.2 until you are ready to upgrade.. RxLifecycle 3.0.0 was pushed out to support AndroidX. If your codebase is not on AndroidX yet then you should not update.\nRead up on the AndroidX migration here for more information.. Thanks!. This is not something from RxLifecycle. Your own code is sending bad requests.. What are you using to try to download it?. I have my doubts that the issue lies within RxLifecycle itself since all it does is call BehaviorSubject.onNext() once within onStart(). Chances are you are either using that lifecycle call to invoke a bunch of behavior synchronously, or there's some non-RxLifecycle code that is slowing down startup.\nCould you provide a sample showing the performance issue?. The main difference between RxLifecycle 2.2.2 and RxLifecycle 3.0.0 is that 3.0.0 uses AndroidX. If you cannot use AndroidX yet, then continue to use 2.2.2.\nWhen you are ready to update to AndroidX, you can read more on that here: https://developer.android.com/jetpack/androidx/migrate. I don't see what this has to do with this library.\nIf you can provide a reproduction for why this library, in particular, is the cause of your problem, we can look into it.. Interesting idea, but I'm curious when this actually would be used. If it's just for some corner case, then I would argue it'd be better to just call bindUntilEvent() multiple times on the same stream, rather than shifting the entire API to account for it.. I'm sorry, but have to be honest: I don't have time to review other peoples' projects right now.. Fixed!\n. @hamidp I'm trying to be presumptuous here and positioning this as being the one true root Activity. :)\n. Nit: Extra newlines.\n. Because this is <Object> it won't accept anything that is a subclass of Object. E.g., this won't compile:\njava\nObservable<String> lifecycle = Observable.just(\"String\");\nRxLifecycle.bindView(lifecycle);\nI believe it should be <? extends Object>.\n. Remove - the others don't have an extra newline.\n. Maybe it's ? for this case. I'm very bad with generics (as are all humans).\n. Should this be <E> or <? extends E>? I only ask because we're sort of copying takeUntil and that's what they do (again, not exactly sure why since I suck at generics).\n. It seems like we should skip REBIND. My interpretation is that onBind() and onUnbind() are duals, and onRebind() is optional. I think it's roughly like Activity.onRestart(). That said - my interpretation is based on the docs, not experience.\n. While this seems technically correct, I'm worried about the effectiveness of using RxLifecycle for bind/unbind events. Think about this process:\n1. Bind 1 is called and uses this\n2. Bind 2 is called and uses this\n3. Bind 1 ends; subscriptions are NOT ended, since onUnbind hasn't been called yet (it waits until ALL binds are disconnected)\n4. Bind 2 ends; NOW all subscriptions are ended.\nI'm not sure this is a solvable problem with the current architecture.\n. Could this be on a newline to match the rest of it?\n. There should be both bindToLifecycle() and bindUntilEvent() for these.\n. Should have copyright at top of file.\n. No capital 'k' here.\n. Does this part of the project really need all these dependencies? I'm guessing it only needs the top two.\n. Kotlin 1.0 final got released, should update here.\n. Exatra newline here.\n. This comment seems unnecessary.\n. I would just make this a single example instead of two.\n. Eh, can deal with this post-merge.\n. Nah. I was just saying that this is two separate code samples but could just be wrapped into one.\n. This basically has the effect of enforcing a BehaviorSubject as the lifecycle, and I don't think that's right.\nIf that's what we want, we should specify that you must use a BehaviorSubject.\n. I don't want BehaviorSubjects being passed around. If only there were a way to enforce the idea of having to use a replay(1) stream. Hmm.\n. AFAIK this sentence was valid English in the first place. But if you really want to fix it up, you'd have it split the \"or\" on the verb:\n\nUseful if you are writing utilities on top of rxlifecycle-components or implementing your own component not supported by this library.\n. Are all of these really necessary? The interface implements it and that's all that people interact with.\n. Hmm, do you mean just as protection that the test isn't passing just because it was emitted early?\n. SGTM\n. It's purposefully left out here. The test itself verifies zero values emitted, so there's no reason to verify that twice.\n. Ah, makes sense, I'll add that, too.\n. See #163 and #164\n. I thought about that, but that really gets into the weeds of what RxJava is doing and thus could start failing with later versions.\n\nI think I am going to modify this so that we only check if the exception we know was thrown is part of the CompositeException.\n. Nit: I'd link up these two using $lifecycleVersion or something.. Nit: Might as well bump this to 2.3.2 while we're at it.. Seems reasonable to me.. Some typos in the package name - should be com.trello.lifecycle2.android.lifecycle. Package name doesn't match directory structure.. Yeah, it's a bit rough here isn't it...\nMinor: I'd make this class final. (I'm noticing this mistake in some classes I wrote before, too, will have to go correct that later.). I think the name is okay. I'd make it final.. Honestly, I hate Robolectric as a result of this project. I'm this close to just making them run on an emulator.. Although laborious, I think that's the right way to go. Otherwise people end up pulling in more than they bargained for when they pull in this project.. Speaking from previous experience, we should make a comment here that it's unreleased (or just remove this altogether). Otherwise people will start trying to use it before we release.. Good to know.\nNow to figure out why the CI is failing. :P. ",
    "hannesstruss": "This feels a bit too framework-y for this library.\nA HashMap that survives config changes could be generally useful, not only to store Observables. Projects like Memento already do similar things. Automatically resubscribing on the other hand maybe is a tad too much magic. It would also need additional configuration, e.g. what lifecycle event to resubscribe on, as people might have different requirements for that. \nMost people anyway have their own mechanisms in place already. I'm not sure there is a one-size-fits all solution.\n. ",
    "ZacSweers": "@dlew let me know if you want me to add tests for OnSubscribeViewDetachedFromWindowFirst. I wasn't sure how necessary it is since it's a fairly simple class.\n. Yup, mostly taken from there. If you're open to depending on RxBinding though, I\ncan definitely do the latter part. RxBinding doesn't have attach/detach\nevents yet, but Jake says he wants it so I could pull request that over\nthere first and then update this.\nThat's also be nice because then there wouldn't be any overlap between view\nevent implementations.\nOn Sat, Aug 8, 2015 at 10:23 AM Daniel Lew notifications@github.com wrote:\n\nWas this mostly taken from the old RxAndroid repo?\nI think it looks good, but I'd like to take it a slightly different\ndirection (implementation-wise). Right now it's lacking a bit in two ways:\n1. We have ViewEvent.ATTACH but never actually emit it.\n2. Our OnSubscribe has a bunch of logic in it that can be replicated\n   from other operators.\nI'd like it if we had a solution that's composed of two steps:\n1.\nAn RxBinding-esque way to get Observable from a View,\n   completely separate from anything else. (Perhaps maybe even just in\n   RxBinding itself, then we can make this depend on that library).\n   2.\nCombine that with takeUntil to automatically unsubscribe after\n   detachment.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/trello/RxLifecycle/pull/12#issuecomment-129014315.\n. Agreed. Opened a PR there for attach events: https://github.com/JakeWharton/RxBinding/issues/76\n. That PR is in RxBinding now, so I'll update this after its next release! Should I close it for now or just leave it open until then?\n. Alright, I'll leave it open for now\nOn Mon, Aug 10, 2015 at 6:17 AM Daniel Lew notifications@github.com wrote:\nWhatever you want to do. It doesn't much matter to me.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/trello/RxLifecycle/pull/12#issuecomment-129442424.\n. Yup, I'll update it when I get the chance today or tomorrow.\n\nOn Sun, Aug 23, 2015, 7:52 AM Daniel Lew notifications@github.com wrote:\n\nNow that there's a new version of RxBinding out, would this be possible to\ndo?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/trello/RxLifecycle/pull/12#issuecomment-133853378.\n. @dlew rebased and updated with use of RxBinding.detaches()\n. I just added takeUntil support to Single with an eye toward this. It'll now emit a CancellationException downstream if it's unsubscribed due to takeUntil, which would allow us to resume if necessary. See https://github.com/ReactiveX/RxJava/pull/3712\n\nCompletable is easy, just Completable.amb(other). There's a bug that will be fixed in the next version that currently prevents it from being usable here though. https://github.com/ReactiveX/RxJava/pull/3707\n. RxJava 1.1.2 is out and should work for both Single and Completable.\nI have a branch open right now that does this, but wanted to get feedback on the API design. Specifically, we can't have overloads of bind that return Single.Transformer and Completable.CompletableTransformer since they still shared the same signature. Options are:\nA. Make overrides specifically named (bind -> bindObservable, bindActivity -> bindObservableToActivity, etc).\nB. Make separate classes for Single and Completable with the same API. RxLifecycle, RxSingleLifecycle, RxCompletableLifecycle.\n\nOpen to suggestions. B seems like the cleaner approach, and much of the shared logic can be pulled out into package-local internals.\n. A sort of moonshot option C:\ngeneric return type and have the method take a Class to indicate which type it needs. Then create the appropriate transformer and (cast) return it. Loses type safety, but avoids all the duplicate code.\n. I did try the custom transformer that implements all three, but unfortunately there are conflicting method signatures that it can't resolve :/\n. Been hacking at option C, but unfortunately I can' seem to get it to a state where it doesn't at least complain about casting in line.\nThe following code:\n``` java\n@NonNull\n@CheckResult\npublic static  R bindActivity(\n        @NonNull final Class<? super R> transformerClass,\n        @NonNull final Observable lifecycle) {\n    return bind(transformerClass, lifecycle, ACTIVITY_LIFECYCLE);\n}\n@SuppressWarnings(\"unchecked\")\n@NonNull\n@CheckResult\npublic static  R bind(\n        @NonNull final Class<?> transformerClass,\n        @NonNull final Observable lifecycle,\n        @Nullable final Func1 correspondingEvents) {\n    checkNotNull(transformerClass, \"transformerClass == null\");\n    checkNotNull(lifecycle, \"lifecycle == null\");\n// Make sure we're truly comparing a single stream to itself\nfinal Observable<T> sharedLifecycle = lifecycle.share();\n\nfinal Observable<?> eventMappingObservable = correspondingEvents == null\n        ? lifecycle\n        : eventMappingObservable(sharedLifecycle, correspondingEvents);\n\n// Keep emitting from source until the corresponding event occurs in the lifecycle\nif (Completable.CompletableTransformer.class.isAssignableFrom(transformerClass)) {\n    return (R) new Completable.CompletableTransformer() {\n        @Override\n        public Completable call(Completable completable) {\n            return completable.ambWith(eventMappingObservable.toCompletable());\n        }\n    };\n} else if (Observable.Transformer.class.isAssignableFrom(transformerClass)) {\n    return (R) new Observable.Transformer<T, T>() {\n        @Override\n        public Observable<T> call(Observable<T> source) {\n            return source.takeUntil(eventMappingObservable);\n        }\n    };\n} else if (Observable.Transformer.class.isAssignableFrom(transformerClass)) {\n    return (R) new Single.Transformer<T, T>() {\n        @Override\n        public Single<T> call(Single<T> source) {\n            return source.takeUntil(eventMappingObservable);\n        }\n    };\n} else {\n    throw new IllegalArgumentException(\"Unsupported target class\");\n}\n\n}\n```\nResults in this:\n\n. It works, but lint yells at me. You don't get a lint warning?\n\n. Yeah unfortunately mixing doesn't really work either since Single and Observable aren't the same type (so the method signature in the transformer would conflict) and Completable is a different one entirely. Starting to think the slicing approach of option B is probably the best bet for now, and trying to refactor and share as much of the logic as possible.\n. Alright, just threw it up as a suggestion in case.\n. Same with OutsideLifecycleException\n. I'm not sure Navi helps here since it looks like it would still require writing our own bind() implementations\n. You wouldn't necessarily have to open them up, though having public examples might be helpful for what I'm about to suggest. The idea is so that you could pass other lifecycles like CONTROLLER_LIFECYCLE or a custom ACTIVITY_LIFECYCLE (e.g. your base actvitiy has other callbacks you want to expose). What's great about the bind() implementation is that it doesn't care if the lifecycle is of an activity, fragment, or goat. The only implementation change would maybe be to use .equals() rather than == to allow for non-enum parameters, but that would be a separate discussion I think.\nPerhaps using an interface that behaves the same way as Func1 could make it more clear? Something like LifecycleMapping#map(event) maybe? Then just create a Func1 internally in bind() that just calls it under the hood.\n. Yeah that could work\n. Could take a look at how Glide handles it: https://github.com/bumptech/glide/blob/c2fc19316d8680322cabeed31234d19e942866e8/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java\n. Hmm, I'm not sure what the best thing to do here is. Android Studio complains about this for some reason (screen below), and while it helps with your example, it requires any future messages to be strings too, meaning lifecycle.onNext(new Object()); wouldn't be allowed. Not sure if that would lead to issues later since detaches are all Objects. Curious to know what Android Studio is complaining about though.\n\n. You want more newlines or to remove this? I was just matching the pattern I thought other functions were using here\n. @SleeplessByte the issue here arises in that while it does seem like a pointless wildcard, using Observable<Object> doesn't allow you to pass in things that aren't Object, including subclasses.\nThe string example was just mentioned because if you mix it in a chain with different types, it could be problematic since detaches events are all just Object. Shouldn't really be a problem though, anyone mixing those chains are probably doing it wrong anyway\n. I think I sorted it out. See 66bd497ab46ae1c88f34e8f1c5d87c97d98884b1\n. Gah, fixed in b4c72bb\nI misread code above it and thought there was a space:\n\n. Taking this moment to revive my super rusty Dutch (ik kom uit Cura\u00e7ao). @SleeplessByte Ik denk dat ik heb het opgelost in 66bd497. Kunt je ook een kijkje te nemen?\n. Done in e8fdbdb\n. It's kind of enforced already. It happens to work fine for activities and fragments because people don't usually hook in prior to the constructor, and it happens to work for views because we don't map a lifecycle and just wait for a detach event. It breaks down anywhere you have a constructor that occurs before any lifecycle events (controller, presenter, what have you), and the result is it hangs trying to take(1) on a stream that has no events.\n. ",
    "SleeplessByte": ":+1: \n. ? extends Object literally means: Any Type that is Object or is lower in the class hierarchy than Object. \nSince all Types in Java are descendants of Object (yeah okay, primitives no, but generics + primitives isn't going to work anyway), this is any Type in Java. \n? is an unbounded wildcard.\nIt's a similar warning as writing if( someBoolean == true ).\nThat said, imo if your bound lifecycle is expecting to output  Strings, I would expect lifecycle.onNext(new Object()); to not be allowed. If my lifecycle is of type Object, I would.\n. Haha yeah @hzsweers I was aware. Just wanted to comment on the earlier \"maybe\" by @dlew.\nHowever your final point [...] probably doing it wrong anyway is spot on. Try to disallow doing it wrong ^_^.\n. Hah. Dat is correct Nederlands!\nI think you COULD change #bind to be Observable<? extends R>, so we can box lifecycle events with subclasses.\n. Mimic Observable#takeUntil and use <? extends E>.\nBtw, this is the difference between the three: \n- Observable<E> an Observable that only outputs E and exactly that.\n- Observable<? extends E> an Observable that outputs anything with an upperbound of E (so any descendant of E or E itself).\n- Observable<?> an Observable that outputs anything, can't use that here because the Operator (Transformer) expects a type!\n. ",
    "vekexasia": "As far as i can see ActivityLifecycleCallbacks was added in api level 14. \nIs there any bug in api level 14 using ActivityLifecycleCallbacks? I've some apps where the userbase have 3-5% api level 14. for now I use the tools:overrideLibrary but i don't see any reason why we would like to stick with api level 15.\nI know RXBinding library had a similar issue and it was raised down to 14. https://github.com/JakeWharton/RxBinding/pull/73 \n. Hello dlew, not me personally.\nAs mentioned in the ticket i attached a popular library is reporting 4.97% of users having 4.0. \nIf you don't want to go down to api level 14 for any reason i'll respect that. No worries :) I was just wondering why you decided to higher the minSdk to 15 since all the code within this library should be compatible at least with 14. (ActivityLifecycleCallbacks included)\nThank you for your time :+1: and for the great lib\n. Not sure why by if I change these lines from\njava\npublishSubject\n        .compose(RxLifecycle.bindUntilFragmentEvent(lifecycle(), FragmentEvent.PAUSE))\n        .observeOn(AndroidSchedulers.mainThread())\nto\njava\npublishSubject\n        .observeOn(AndroidSchedulers.mainThread())\n        .compose(RxLifecycle.bindUntilFragmentEvent(lifecycle(), FragmentEvent.PAUSE))\nEverything works just fine....\n. ok thanks :)\n. Hey @dlew I'll let you know tomorrow,\nI read the changelog. Did I read wrong or I might expect receiving \"onCompleted\" after the target FragmentEvent has been triggered?\n. ",
    "IlyaEremin": "Hello. What the reason not to set minSdk to 10 or 9? I mean what features/classes need api 14?\n. ",
    "jdreesen": "See https://github.com/trello/RxLifecycle/issues/13\n. Could you please provide a link to GitHub's/Stack Overflow's offensive political agenda? I'm not aware of that. Thx.\n. ",
    "laszlo-major": "Might be wise to put an explanation in the readme (though I guess many will still go for asking instead of reading), as people coming from old rxAndroid will be surprised by the jump in minSDK, even if you move the project down to minSDK 14.\n. ",
    "floating-cat": "I need to declare a flag in order to avoid emiting FragmentEvent.ATTACH twice if the Fragment's host is an Activity.\nAnd tests Fragment#onAttach(Context) or Fragment#onAttach(Acitivity) or both completely.\nCurrent this commit is full of bug, and it is odd that DialogFragment haven't deprecated Fragment#onAttach(Context), so I am sorry to close this pull request.\n. ",
    "Rainer-Lang": "@dlew What alternatives do we have - for the same behaviour?\n. ",
    "shekibobo": "That's fair. What about appcompat? That was the dependency that tripped us up. Does that one need to be locked down so tight?\n. ",
    "dkpalmer": "Sorry, I meant to post the error yesterday..\n[...]/build/intermediates/exploded-aar/com.android.support/appcompat-v7/23.0.0/res/values-v23/values-v23.xml\nError:(2) Error retrieving parent for item: No resource found that matches the given name 'android:TextAppearance.Material.Widget.Button.Inverse'.\nError:(2) Error retrieving parent for item: No resource found that matches the given name 'android:Widget.Material.Button.Colored'.\nI see the lib uses appcompat-v7 and compiles against 23.  My app also uses appcompat-v7, but I was compiling against 22.  I'm not sure how that's resolved with Gradle.\n. Yeah, I've since switched both compile and target to 23.  I just hadn't done it since the official release.\n. ",
    "drupalmav": "Does this mean this library cannot be used with compileSdkVersion 22 & buildToolsVersion \"22.0.1\"?\n. ",
    "eyecreate": "I am using java 7. It no longer complains now, thanks!\n. ",
    "JakeWharton": "Also \"GitHub\"\n. > migrating to support\nMigrating to 2.x means no longer doing Android as it'll be years if Android\never sees the APIs required to run 2.x.\nOn Tue, Sep 29, 2015 at 6:26 PM Ben Sandee notifications@github.com wrote:\n\n+1.\nIf you're following RxJava 2.x dev discussions it was suggested just today\nthat Single is half-baked in 1.x (it is in fact marked as @Experimental).\nIn 2.x it has more comprehensive support (e.g. a complete list of\noperators) and when migrating to support that it might be a nice time to\nrevisit this.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/trello/RxLifecycle/issues/39#issuecomment-144208591.\n. \n",
    "dalewking": "Note that it will be slightly more difficult because Single does not actually have a takeUntil operator so you will have to build that support yourself. Not sure how you will differentiate Observable vs. Single because you can't have a type implement both Observable.Transformer and Single.Transformer. You probably either have to have separate methods or your return value from bind methods is an object that has another method to get a Single version.\nThe workaround for now is do toObservable before the compose call and toSingle after it.\n. Regarding your points:\n1. It would likely be a chain of .toObservable().compose(...).toSingle()\n2. Oddly I tend to do the compose at the beginning of the chain since I want to stop the chain as early as possible.\n3. As I said it wouldn't be easy.\n4. I'll agree it is experimental in 1.x as others have said.\n. I think it would be bad to change any of the existing method names. Another alternative (an A.5) would be to not change existing calls, but add versions of the methods with Single and Completable in the name.\nBut I agree that B seems the best choice.\n. There has always been issues with the generic type inference with RxLifecycle and the compose method. See issues #44, #58, and #59. As it stands today in Kotlin I have to explicitly add a type parameter.\nWould be great if the type inference can be fixed once and for all, but the problem may actually be with RxJava's declaration of compose as well.\n. Any updates on this? Seems to have stalled a month ago. In the process of converting som Observables to Single and Completable\n. I can say with lots of calls, the whole toObservable() toX() pairing is a\ntedious and just seems wrong. It is unfortunate that Rx designers did not\nforsee the need to create one object that could translate all three.\nI wonder if this might be a solution. Right now all the bind calls return\nObservable.Transformer. What if you changed that to your own exension\ninterface like this:\ninterface RxLifecycleTransformer<T> extends Observable.Transformer<T, T>\n{\n    Single.Transformer<T, T> forSingle();\n    Func1<Completable, Completable> forCompletable();\n}\nWhere you implement the methods to convert for single and completable.\nThen for users, they just have to do something like:\n.compose(RxLifecycle.bindToLifecycle().forSingle())\n. Seems that parts of your API were missed. ActivitiyLifecycleProvider does not have the change to support Single and Completable and also Navi component does not have it.\n. FYI have submitted PR for RxJava2 that will allow a single object to act as transformer for all reactive types: https://github.com/ReactiveX/RxJava/pull/4672\n. And the PR was just merged, so RxLifeCycle for RxJava2 won't need this workaround.\n. Sorry, I do not do PR's on GitHub, but the change is just a global search and replace of \"Transformer<T, T>\" and replacing that with \"Transformer<? super T, ? extends T>\"\n. My boycotting is the fact that GitHub should be just about technology and be politically neutral, but it instead decided to promote an offensive political agenda. Therefore I can no longer in good conscience support them with my code. Note I also boycotted Stack Overflow for the same reason no longer have an account there and filter SO results from my search queries.\nI'd be happy to submit a patch file or host the change on GitLab, but most people are not happy with that.\n. I don't want to get into the specifics of their political agenda because unlike GitHub I am not trying to promote a political agenda here and don't want to see this devolve into a political debate. My point is that Github should have been politics free, but they crossed a line\nTo understand my position, just pick your own hot button political issue that you feel passionately about. Now imagine how you would feel if Github changed the logo at the top of every page, including YOUR OWN pages, to show support for the opposite opinion of your own. The particular issue itself is not as important as the fact that Github should be just about tech, not politics.\nWhile I refuse to support Github itself directly with my own code, I am not boycotting the people like you that use GitHub and the projects they create. I maintain an identity primarily so that I can support them with issue reports to make their software better. If GitHub could accept PRs from other repos, like GitLab I would gladly do it. I am sorry, but I have to draw the line somewhere.\n. I think the best solution would be to create an rxlifecycle-kotlin library that provides nice extension functions on Observable that lets you drop the compose so that instead of writing:\nmyObservable.compose(bindToLifeCycle())\nmyObservable.compose(bindToView(v))\nyou can just write:\nmyObservable.bindToLifeCycle(this)\nmyObservable.bindToView(v)\nDon't know if you have the Kotlin expertise to tackle that. I will try to look at it, but cannot make any promises.\n. I can report that the new beta release of Kotlin has fixed this and no longer requires explicitly specifying the type in .compose(bindToLifecycle())\n[Update] Sorry premature there. It still doesn't compile without explicitly specifying the type parameter on the compose\n. A start would be to create a branch for RxJava2 support and allow others to send you PR's to do the initial grunt work. However, first there probably needs to be some decisions on how it would be packaged and distributed. RxJava2 is designed to coexist beside RxJava1 to allow gradual transitions to it. Should RxLifeCycle for RxJava2 also support coexisting beside RxLifecycle for RxJava1 and what would that even look like?\n. One complication is that Completable has no takeUntil operator in RxJava2. Maybe they named it something else, but it may be a semantic thing. What should the Completable do if the event occurs? call on Completed? call on Error? Neither seems right.\nSo am I correct in that RxLifecycle when it gets the event for an Observable, it simply completes the Observable (i.e. calls onCompleted on the subscriber) instead of just unsubscribes?\n. I see there is actually a discussion on this very topic: https://github.com/ReactiveX/RxJava/issues/4646\n. FYI, RxJava 2.0 was released today\n. It was announced 2 days ago and you don't already have a working implementation?  ;-)\nJust created the issue as a reminder to do it someday. . ",
    "tbsandee": "+1. \nIf you're following RxJava 2.x dev discussions it was suggested just today that Single is half-baked in 1.x (it is in fact marked as @Experimental). In 2.x it has more comprehensive support (e.g. a complete list of operators) and when migrating to support that it might be a nice time to revisit this.\n. I was confused by this too -- and still am a bit. The README says it will \"unsubscribe in the opposing lifecycle event\". Is that just a bit out of date or is there some other nuance I'm missing in this conversation?\n. I like it, definitely helps understand what to expect. Thank you.\nI'm new to Rx so a lot of this may be clear to someone who is fully engaged, but I do have a related question since I have your ear. When used in this way, will completing the sequence typically clear references to the Android object (fragment, activity, etc) barring any other strong references leaking out? You often hear about needing to unsubscribe() but it's not immediately clear that a completed sequence has the same effect.\n. @ntoskrnl you might try this tool in the future -- I've had good luck with it!\nhttp://rebaseandsqua.sh/\n. To be honest, the 0.3.1 seems like a step backwards for what I suspect is the predominant platform -- Java 7 + Retrolambda -- because of the fact that it won't infer types properly with these updated signatures. The change may have made Kotlin support cleaner, but it seems to be at the expense of standard Java which is likely to have many more users. But yes, a wrapper is easy enough to write but the same could be said for Kotlin users, no?\n. Because I'm obsessed to use the newest rev of every library, I'm working on this alternative bind wrapper function in my base activity. Here's what I've come up with -- any comments as to whether this is the best possible?\njava\n  @SuppressWarnings(\"unchecked\")\n  @Nonnull\n  public final <T> Observable.Transformer<T, T> localBindToLifecycle() {\n    return (Observable.Transformer<T, T> )this.<T>bindToLifecycle();\n  }\n. I am using the Java 8 compiler + Retrolambda to rehost onto Android/Java 7 and it's not inferring properly for me. The 0.3.0 works fine, but 0.3.1 forces me to use the this.<T>bindToLifeCycle to compile.\n. FWIW, I use the current RxLifecycle release with my app's minSDK set to 18,\ntarget SDK set to 22 and compileSDK set to 23. No problems at all, runs\nfine on all devices we test on down to sdk 18.\nOn Wed, Nov 18, 2015 at 1:26 PM cmathew notifications@github.com wrote:\n\nCurrently this requires SDK version 23, which is very restrictive when\ntrying to support \"older\" builds of Android. Dropping this to at least 22\nwould allow use in Android 5 and below.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/trello/RxLifecycle/issues/55.\n. Yes I'm in the same situation. Not ready to update to the new permission\nmodel but need a few other sdk23 features. It works great for me.\n\nOn Wed, Nov 18, 2015, 4:00 PM cmathew notifications@github.com wrote:\n\n@tbsandee https://github.com/tbsandee thanks for the suggestion. If I\nset compileSDK to 23, but targetSDK 22, the app will behave like a 22? I\nask because I'm trying to avoid the API level 23 permissions model.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/trello/RxLifecycle/issues/55#issuecomment-157878374.\n. I don't know if we're voting or not but all things equal at this point I would prefer to keep (what I suspect is) the more-common use case of Java working cleanly.\n\nI'd be curious to know if anyone is able to use 0.3.1 with Java 8 + Retrolambda without adding the this.<T> prefix to the various bind calls in RxLifeCycle. If not, is there any magic setup that would work with both Kotlin and Java? Is it possible this is a Retrolambda issue?\n. In my case, changing my localBindToLifecycle() helper to use either of those variants, results in the compiler inferring type java.lang.Object instead of T.\n``` java\n@SuppressWarnings(\"unchecked\")\n  @Nonnull\n  public final  Observable.Transformer localBindToLifecycle() {\n    return (Observable.Transformer )this.bindToLifecycle();\n  }\n```\n. FWIW, this is what I'm using now:\n``` java\nabstract public class LifecycleProvider {\n  @Nonnull\n  static public LifecycleProvider from(ActivityLifecycleProvider provider) {\n    return new LifecycleProvider() {\n      @Override\n      @Nonnull\n      public  LifecycleTransformer bindToLifecycle() {\n        return provider.bindToLifecycle();\n      }\n    };\n  }\n@Nonnull\n  static public LifecycleProvider from(FragmentLifecycleProvider provider) {\n    return new LifecycleProvider() {\n      @Override\n      @Nonnull\n      public  LifecycleTransformer bindToLifecycle() {\n        return provider.bindToLifecycle();\n      }\n    };\n  }\n@Nonnull\n  abstract public  LifecycleTransformer bindToLifecycle();\n}\n```\n. Cool, well, I've created PR #138 with a quick stab if it helps.\n. Yeah, totally get it. I did do the minimal change without breaking existing public APIs. Thanks!\n. It's in a separate branch, but artifacts are released: \nhttps://github.com/trello/RxLifecycle/tree/2.x. ",
    "phajduk": "Update: Single has been updated to public API (more precisely to the @Beta) in RxJava 1.1.0.\n\nThe lack of takeUntil support in Single seems to be an oversight IMO. That indicates to me that Single isn't fully supported yet.\n\nI believe it's not oversight as there is lack of more features (like retry). \nAdditionally, are you sure that we should expect takeUntil operator in Single? Single emits only either one value or error. Taking values until some predicate is true have no sense as there will be always one value.\n. @dlew You're right. I meant that there is no reason to implement takeUntil(predicate) not takeUntil(observable) which one is of course used in RxLifecycle. There could be also variant takeUntil(single) but it's RxJava issue. \nThen :+1: from my side for using Single.toObservable().\n. ",
    "vanniktech": "Not really I'd assume it's just a cosmetic change\n. @dlew yes it avoids a lint check\n. This change also broke the existing code in our applications.\n. I reverted back to 0.3.0. Currently I don't have the time to deal with those changes.\n. +1 on 0.3.1\n. You're welcome. Are there any plans of releasing the changes since 0.3.0?\n. +1 for reverting the change\n. You basically want another module e.g. rxlifecycle-view which does the complete Lifecycle View binding related stuff?\n. I guess not that many. I do use both. So I need the dependency anyways.\nOn 8 December 2015 17:54:10 CET, Daniel Lew notifications@github.com wrote:\n\nQuestion: How many people use RxLifecycle but not RxBinding?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/trello/RxLifecycle/issues/66#issuecomment-162943580\n\n\nSent from my Android device with K-9 Mail. Please excuse my brevity.\n. Let me know whether I should squash manually or you'll Github do the job.\n. Travis seems flaky again, it can't find certain artifacts ... also having the problem with other projects \n. Which error? The one I quoted originally happens when I open the project in Android Studio. The one from Travis happens also for me with trying to get Android 24 sdk.\n. Could be I'm running beta2 of 2.2.0. Nonetheless Gradle 2.14.1 support was 'added' in 2.1.3\n. This one is now green @dlew (at least it was until I accidentally clicked on close PR)\n. @dlew the big advantage of already adding support for RxJava 2 now is that you still have the chance of changing the API. (E.g. the transformer change) Once the stable release is out it'll be much harder. \n. CompletableTransformer : renamed to Completable.Transformer\n. They were able to make that change since Completable was marked as Experimental\n. My guess is that the components of the travis configuration file are in the wrong order. \n. The extra dependency is really unfortunate. . True but in Android Studio I got a warning from an inspection telling me that also implementation classes should annotate the methods. If you want I can revert those changes too.\n. Yes though I had the feeling it was a bit weird to read. I changed it now to your proposed change.\n. how about adding an assertion that before this statement nothing was emitted (could be applied to all tests)\n. Exactly\n. Also in my opinion it increases readability of the test and the purpose becomes a bit clearer of what is being tested.\n. one is missing here\n. also here\n. same\n. Ok sorry I should have been more clear. I'd add a testSubscriber.assertNoErrors() before and then when you advance you should get the error\n. Missing extension methods for Maybe + Flowable. So far I also didn't see that support was added for those. This is just meant as a reminder.\n. it returns a LifecycleTransformer\n. it returns LifecycleTransformer that implements ObservableTransformer plus the one for Single + Completable\n. same\n. maybe consider using Completable.ambArray here\n. maybe consider using Completable.ambArray here\n. maybe consider using Completable.ambArray here\n. nice \ud83d\udc4d \n. Maybe assert that this exception contains your wanted ones in a certain order?\n. How about adding a message here so the main library doesn't need that second constructor?\n. Well RxJava usually agrees on a order in CompositeException and if it's the wrong order it gets fixed. The first one reported comes first and then the other ones.\n. just use google() it's available since gradle 4.0. ",
    "BugsBunnyBR": "Ok,\nI will move to onNext(), but I think there may be some case where onNext() is called multiple times.\nIs this the standard rx behavior? When I handle the Subscription.unsubscribe() by myself it does not seems to call Subscriber.onComplete()... Document this maybe?\nThanks.\n. ",
    "ypresto": "How about use lift() to get subscriber instance and unsubscribe instead of onComplete()?\nI have small helper to use with CompositeSubscription.\nhttps://gist.github.com/ypresto/accec4409654a1830f54\n. Ah, ok I found  #19 and understood why onCompleted() is required.\n. ",
    "ntoskrnl": "@dlew how do I do that? :)\n. i saw your message too late))\ni will try again)\n. Now I see 2 commits. First one contains all the changes and second one doesn't contain any changes...\nHow can I make it right?... \n. i will do it again\n. I actually don't know how to correctly change it. Looks like onAttach(Context) appeared in 23 SDK. If I change it for both RxFragment and support.RxFragment, the former one doesn't pass the test. When fragment.onAttach((Context) null) is called from within the test, it fails with NoSuchMethod exception.\n. If there were no other commits, then yes))\n. ",
    "almozavr": "Unhappy with that as compiler can't infer type now, have to write it every time :(\njava\nmyTypeObservable.compose(RxLifecycle.<MyType>bindView(view));\nvs.\njava\nmyTypeObservable.compose(RxLifecycle.bindView(view));\n. ",
    "tadfisher": "Support libraries added this as well (but did not deprecate the Activity version)\n. Try https://jitpack.io/\n. If you can't wait for a fix to hit production, add a dependency that points to a commit hash on Github.\n. ",
    "Deliganli": "would it be ok for me to just change onAttach(Activity) to onAttach(Context) in my RxFragment class? Because it is not receiving onAttach(Activity) lifecycle events on lower api levels.\n. ",
    "IgorGanapolsky": "@tadfisher What does jitpack.io solve?\n. You don't like Instant Run and faster gradle builds?\nOn Jan 21, 2016 7:00 AM, \"Daniel Lew\" notifications@github.com wrote:\n\nSwitching to 2.0.0 necessitates everyone uses Android Studio 2.0, right? I\ncould be wrong, I haven't been using it...\nIf that is the case, though, I'm not sure I'm comfortable with that.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/trello/RxLifecycle/pull/73#issuecomment-173596969.\n. \n",
    "cmathew": "@tbsandee thanks for the suggestion. If I set compileSDK to 23, but targetSDK 22, the app will behave like a 22? I ask because I'm trying to avoid the API level 23 permissions model.\n. ",
    "srodenberg": "Just a note, this library depends on RxBinding which assumes View.OnScrollChangeListener exists which requires api lvl 23. If you use proguard in your build you'll need to add in don't warn rules for those specific errors.\n. ",
    "markrietveld": "I made an account on youtrack to vote for the issue.\nI would recommend reverting too. I've confirmed that we kotlin users can write a small set of java forwarding methods for RxLifecycle that makes it work nicely:\n``` java\npublic class BindLifecycle {\n    public static  Observable.Transformer<? super T, T> bindActivity(Observable lifecycle) {\n        return RxLifecycle.bindActivity(lifecycle);\n    }\npublic static <T> Observable.Transformer<? super T, T> bindUntilActivityEvent(Observable<ActivityEvent> lifecycle, ActivityEvent fragmentEvent) {\n    return RxLifecycle.bindUntilActivityEvent(lifecycle, fragmentEvent);\n}\n\npublic static <T> Observable.Transformer<? super T, T> bindFragment(Observable<FragmentEvent> lifecycle) {\n    return RxLifecycle.bindFragment(lifecycle);\n}\n\npublic static <T> Observable.Transformer<? super T, T> bindUntilFragmentEvent(Observable<FragmentEvent> lifecycle, FragmentEvent fragmentEvent) {\n    return RxLifecycle.bindUntilFragmentEvent(lifecycle, fragmentEvent);\n}\n\npublic static <T> Observable.Transformer<? super T, T> bindView(View view) {\n    return RxLifecycle.bindView(view);\n}\n\npublic static <T, E> Observable.Transformer<? super T, T> bindView(Observable<? extends E> lifecycle) {\n    return RxLifecycle.bindView(lifecycle);\n}\n\n}\n```\nWith that you can call\nkotlin\nObservable.just(\"\")\n        .compose(BindLifecycle.bindUntilActivityEvent(this.lifecycle(), ActivityEvent.DESTROY))\n        .doOnNext {println(it is String)}\n        .subscribe()\nAnd have it print true\n. Detach support already exists already using this method in RxLifecycle\n. I wouldn't worry about it. People using using CompletableTransformer would have had to make this change regardless of this library, and people not using CompletableTransformer shouldn't have upgrade issues, right?\n. I think it won't complain, since RxLifecycle will already have been compiled by the time gradle downloads it. I'll try it after you release 0.8.0 and let you know. The inverse (Using RxJava 1.2 with RxLifecycle 0.7) compiles and works fine if I don't use CompletableTransformer.\n. Confirming: I don't use CompletableTransformer, and RxLifecycle 0.8.0 compiles and works for me with RxJava 1.1.9.\n. ",
    "damianflannery": "+1.  I reverted back to 0.3.0 because of this.\n. ",
    "qq1597395433": "the problem had been solved \n. ",
    "realdadfish": "Ah, just figured, bindToLifecycle() is final in Rx{Fragment,Activity,...}, so it cannot be easily overridden...\n. Ok, understood. You're right, a subscription can run without any special threading set up. I guess I have to find another way of abstracting this. My start with Rx was already steep and now that threading issues come into the mix (figuring out on which thread (sub-)observables and their subscriptions are executed is a little messy), things get very messy.\nSorry for the noise, I figure out something else.\n. ",
    "jiechic": "\bi want use \nobservable\n.compose(bindToLifecycle(customTransformer))\n.sub\nnot the \nobservable\n.compose(bindToLifecycle)\n.compose(customTransformer)\n.sub\ni can use once compose to deal with lifecycler and thread scheduling\nin my android app\uff0ci only copy \u201c.compose(bindToLifecycle(customTransformer))\u201d on each activity \bbut not \u201c.compose(bindToLifecycle)\n.compose(customTransformer)\u201d\u3002\nthis is some suggest for coding\uff0ci fork source for myself then use like that\u3002\n. ",
    "erikpedersen": "I totally understand and appreciate your position on this. From a purely \"selfish\" point of, this is the only other type of fragment outside the core ones already support here that I have ever bothered to use in our apps. The rest of them (except for maybe the PreferenceFragment) seem so specific in use case, that I haven't really considered them. Of course, I'm sure other developers have explored them and perhaps have utilized them. If I had to come up with a (tenuous, at best) argument here, I guess it just feels to me that ListFragment is on the edge of being one of the more generic types of fragments out there that developers may have used in common app use cases. I'm totally on board with you if you feel like ListFragment shouldn't be part of the core, but thanks for at least considering it!\n. ",
    "Piasy": "Oh yes... sorry that I miss it.\n. ",
    "npace": "The link provided by @markrietveld currently leads to a 404.\nI think this is the currently valid link: RxLifecycleAndroid.bindView. ",
    "dsvoronin": "all things solved!\n. of course!\nAnd since kotlin just released, i have to upgrade it\n. You want me to create example android project?\n. ",
    "danijoo": "thanks for the quick response ! :)\n. ",
    "rusmichal": "What about Lifecycle components? https://developer.android.com/topic/libraries/architecture/lifecycle.html. ",
    "Den-Rimus": "I understand about BehaviorSubject now, thanks.\nAs for Observable, that I'm trying to bind - it's a result of asObservable() called on subject that represents data stream in app-wide singletone data provider. So it is always there and multiple clients (fragments in our case) (well, technically not fragments but their presenters but that's out of current problem's scope) can bind to it to get current actual data or any updates from the same data stream.\nOur problem is that our RxBaseFragment (very similar to RxFragment in your library) binds to lifecycle until FragmentEvent.DESTROY_VIEW event, then gets unsubscribed by takeUntil and then the same instance tries to bind again, but gets FragmentEvent.DESTROY_VIEW event right after subscribing. Is that expected behavior?\n. ",
    "ajalt": "Done, although I'm surprised that you don't want your files to end in a  newline.\n. ",
    "nick-fedesna": "We feel it does belong in RxLifecycle proper since you get the check for free without the need to add an additional dependency. If it were in a separate project it wouldn't benefit as many people as I don't think many would add the extra dependency only for a lint check.  Not to mention the fact that they'd have to be aware of it's existence in the first place. \n. Fair enough, I'll get this going in it's own repo and let you know when there is something to link to.\n. @dlew we have the lint check published: compile 'io.vokal.lint:rxlifecycle:1.0.0'\nThe repository is here: https://github.com/vokal/Android-Lint-Checks\n. Thanks @dlew!\n. ",
    "forgemo": "Thank you for writing the Kotlin test! This helped me to solve my isssue. I tried your code and it threw the exact same exception as my code. Since this seemed quite suspicious to me, I completely uninstalled my app and tried your code again. It worked! My example is now working, too.\nI, however, couldn't find out what caused the issue and why only a complete \"uninstall\" did fix it. \n. ",
    "VictorAlbertos": "Sorry, I did not see it.\n. Because I needed RxLifecycle to support 2.x, I\u2019ve released this interop-wrapper library as a workaround until you release a version of RxLifecycle supporting natively 2.x.\nhttps://github.com/VictorAlbertos/RxLifecycleInterop\nIf you were willing to provide some guidelines about how to perform the migration, I would be happy to contribute to the porting :) \n. Also, you may apply onErrorResumeNext to check if the exception is of type CancellationException (I guess an RxLifecycle custom exception would have been nicer) to recover from it, otherwise just rethrow. \njava\nonErrorResumeNext(error -> {\n  if (error instanceof CancellationException) return Single.never();\n  return Single.error(error);\n});. ",
    "jnlopar": "Interesting. I was definitely seeing some crashes related to this, but it's possible one of the cases may have been off the main thread. I'll try to repro explicitly in a test though and report back.\n. So it turns out the ordering of subscribeOn is the key to getting it to blow up, at least in testing. If there is a subscribeOn anywhere after the compose, the operator lift flow will cause it to get called (and the subscription to happen)\nHere are a couple options I can think of, maybe you have better ones though:\n1. Leave as is but clearly document threading concerns on binding methods in RxLifecycle (which I think should happen anyway! :D )\n2. Make the mainThread subscribeOn explicit on the detaches instance sent to takeUntil.. downsides of this are that detach subscription may be delayed, and unless we check first to see if we're already on the main thread and run it, AndroidSchedulers will post it to run later.\n3. Make an overload with an optional subscribeOn scheduler to pass in. I kinda like this one because it would let people make a conscious decision if they were trying to start a view binding subscription off the main thread. They would know that it wasn't immediate and be able to acknowledged the downsides.\n4. Slightly more out there, but, we could make bindView (and possibly its friends) a little bit smarter. There's another issue here, and that is that RxBinding's detaches isn't going to output anything if the view is already detached... so, we could lift to a custom operator under the hood that makes sure subscription happens on the main thread, and also makes sure that events don't get emitted if the view returns false for isAttachedToWindow. This all kind of begs another question though (which maybe should be a separate issue?), and that is.. what happens if you bindView to a view that never ends up getting attached to a window (and thus, never 'detaches')? if the source observable doesn't complete on its own, will it just keep going?\n   5+. ???\n. Actually, sorry for the thread spam, but I think there is a reasonable 5:\n- Force bindView to do the attach state listener attachment synchronously when called. That would basically prevent anyone trying to subscribe it anywhere else, and also prevent a delayed subscription from setting up an attach listener after detach happens... you could even cache the detaches Observable so if the main observable subscribes after detach happens, it still gets the detach signal. the downside is of course it makes the observable have an eager side effect, and if you never subscribe from it then that is kind of wasted...\n. Yeah, I think that PR would work. The one place it may cause issues is if it is subscribed to off the main thread, and the post occurs after a detach happens (or if attach never happens, but that's a potential problem either way and most of the time programmer error). However, I think your pull is a good compromise. Maybe add a line to the doc of bindView recommending to call subscribe() on the main thread if they want to make sure the attach listener is set up synchronously?\n. ",
    "lofei117": "I called the code in onCreateView for fragment, and I also tested it in onCreate for activity, both of the subscription had been unsubscribed when I turned off the screen.\nIf I remove the code subscribeOn(AndroidSchedulers.mainThread()) it works well with the lifecycle. That's what confused me.\n. OK, thanks very much.\n. ",
    "alexfu": "@carmas123 You're looking for com.trello.rxlifecycle.components.support.RxFragment\n. ",
    "carmas123": "Nice, thank you\n. ",
    "cnisky": "When I try to use RxLifecycle in my project, it always prompt error for not find appcompact-v7:23.3.0, I have a version of appcompact-v7:23.0.2, it is useless. See picture below.\nIf I can use RxLifecycle without import  appcompact-v7:23.3.0 ? \nThanks.\n\n. ",
    "arvabalazs": "Hi,\nthank you for your answer. Unfortunatelly this is not the case, because when I only switch in the very same project between those lines, the result will be different.\nThe explicit cast helps me at the Single case, but it is ugly.\n```\nObservable.just(1).compose(bindToLifecycle()).subscribe(new Action1()\n        {\n            @Override\n            public void call(Integer integer)\n            {\n        }\n    });\n\nSingle.just(1).compose(bindToLifecycle().forSingle()).subscribe(new Action1()\n        {\n            @Override\n            public void call(Integer o)\n            {\n        }\n    });\n\n```\nThe second one cause a compiler error in a same file. I am using the latest AndroidStudio with pretty updated libs.\nCan you double check?\nThank you,\nBalazs\n. Thank you, I am waiting for your feedback!\nBalazs\n. ",
    "felipecsl": "\ud83d\udc4d that's exactly what we did in RxGroups, 2 separate artifacts, 1 java only, 1 android lib\n. ",
    "krn1": "I like this idea too\nOn Wed, Jun 15, 2016 at 3:25 AM, Felipe Lima notifications@github.com\nwrote:\n\n\ud83d\udc4d that's exactly what we did in RxGroups, 2 separate artifacts, 1 java\nonly, 1 android lib\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/trello/RxLifecycle/issues/127#issuecomment-226148428,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ASrNdSRd77xaE2qhALRc_43LryhjmvPTks5qL9M0gaJpZM4I1X57\n.\n. \n",
    "sregg": "Ah I see... Makes sense.\nI guess we're gonna have to make sure we call stuff in onViewCreated(), or if it's in onCreateView(), make sure to use bindUntilFragmentEvent(lifecycle(), FragmentEvent.DESTROY_VIEW)\nThanks for the help Dan.\n. ",
    "ultimate-deej": "@dlew To me a proper solution would be renaming CREATE_VIEW to VIEW_CREATED\n. Well we can restore CREATE_VIEW event, which will happen in onCreateView this time. Both events will have DESTROY_VIEW as their corresponding event.\nIn case user doesn't call super.onCreateView, that is his fault.\n. ",
    "xybCoder": "I have the same problem.\nWe're seeing a lot of non fatal logs in our Crashlytics indicating that ButterKnife bound views are null in the onNext of subscribers subscribed in onCreateView and with compose(bindToLifecycle()). @dlew How do you solve the problem? hope to get your help,thank you.. thank you. ",
    "masc3d": "To clarify I'm using PublishSubject and BehaviourSubject which are exposed by the application model as Observables for event dispatching. I suppose it was rather my fault, as I expected that .bindToLifecycle would kind of magically take care of unsubscribing..\nHow does a CompositeSubscription help in this scenario?\nI resolved this for now by adding this (rather simplified) extension method, which binds the subscription to the lifecycle:\nkotlin\nfun Subscription.bindToLifecycle(fragment: RxFragment): Subscription {\n    fragment.lifecycle()\n            .filter { it == FragmentEvent.DESTROY_VIEW }\n            .subscribe {\n                this.unsubscribe()\n            }\n    return this\n}\nAt least for rxlifecycle-kotlin this would be just as easy to use, I suppose..\n. Is it supposed to work for the scenario I described? I could prepare a test case for it, but maybe it's something you don't even want to explicitly support. Binding the subscription is totally acceptable for me.\n. Ok, I found the cause. You're using BehaviourSubject and in my code super.onViewCreated was called after the bindings, breaking the lifecycle. After correcting this it works as it's supposed to.. sorry for the false alarm and thanks for your feedback.\n. I don't see how \"no great way around it\" would be a reason to close this though @dlew . ",
    "enginebai": "My original fragment extend android.support.v4.app.Fragment and I use Fragment.requestPermissions(@NonNull String[] permissions, int requestCode), but RxFragment does not support this method if I change to inherit it.\n. ",
    "836154942": "sorry my english is not all . compile with your   'com.trello:rxlifecycle-components:0.6.1'  ,the support-v4 is \nVersion conflicted.\n. thanks .  compile witch 'com.android.support:support-v4:23.4.0' can Correctly compile\n. ",
    "ndori": "The first one, I'm using the lifecycle() method and filters the RESUME, then using either delay with lifecycle() as the delay observable or combineWith, depending on exactly what I want to achieve \n. o.k I will check it out, so as I understand it, you only want RxLifecycle to handle the unsubscription of subscribers (which performs through onComplete..)  right?\nI actually had another use case which is more appropriate to unsubscription , I will post it tomorrow.\nTnx for all the work, It is much appreciated \n. ",
    "tir38": "Ahh ok, it's the BehaviorSubscription never completes?\n. Sorry. I meant\nprivate final BehaviorSubject<ActivityEvent> lifecycleSubject = BehaviorSubject.create(); inside RxAppCompatActivity. This Subject never receives onComplete though.\n. ",
    "bobbymicroby": "+1\n. @dlew :) I saw that 2.0 was released yesterday and I was so eager to try it :) It's good that RxLifecycle is the only Rx dependency in my list that needs to be ported. Let's hope I can find a little time so I can help with the porting.\n. ",
    "huseyinozer": "+1\n. ",
    "UsherBaby": "@dlew  It does not unsubscribe the sequence , when the activity's onDestory() is called .\n-------------------Things go well code------------------------\nObservable.just(0)\n.subscribeOn(Schedulers.newThread())\n.map(...)\n.observeOn(AndroidSchedulers.mainThread())\ncompose(bindUntilEvent(ActivityEvent.DESTROY))\n.subscribe(....)\n-------------------Things go wrong code------------------------\nObservable.just(0)\n.subscribeOn(Schedulers.newThread())\n.compose(bindUntilEvent(ActivityEvent.DESTROY)) \n.map(...)\n.observeOn(AndroidSchedulers.mainThread())\n.subscribe(....)\n. @BugsBunnyBR \npublic static LifecycleTransformer bindView(@NonNull final View view)\nin RxLifecycleAndroid . Is that what you need ?\n. BottomSheetDialogFragment. @dlew Sorry for my poor English !  There is a java module which applies plugin: 'java'  in AndroidStudio . When I add compile 'com.trello.rxlifecycle2:rxlifecycle:2.0.1' to it , gradle dependencies go wrong ! I don't know why , because rxlifecycle is also a java module too . @dlew I forgot 'com.google.code.findbugs:jsr305:3.0.1' . Well , please close this issuse. ",
    "shgharib": "Thank you, I added \n\nandroidTestCompile 'com.google.code.findbugs:jsr305:3.0.1'\n\nnow it's working.\n. ",
    "Y-JH": "added it , it worked.thanks. ",
    "willf80": "It worked. Thanks you !. ",
    "asifAli101": "mine is not working, help please\n. ",
    "shoheikawano": "@dlew Sorry about that..! By looking at the CHANGES.md I thought it could be a simple upgrade; will look into it. \ud83d\ude47 \n. I just ran the tests locally and the failures replicated (36 tests done: 3 failed) ; I am sorry about sending PR without testing property \ud83d\ude47 I should have ran the tests before sending PR.\nBelow is the error log that I have confirmed; I will look into it.\n``` java\njava.lang.AssertionError: No onNext events expected yet some received: 1 (1 completion)\nat rx.observers.TestSubscriber.assertionError(TestSubscriber.java:670)\nat rx.observers.TestSubscriber.assertNoValues(TestSubscriber.java:600)\nat com.trello.rxlifecycle.UntilCorrespondingEventSingleTransformerTest.openAndCloseEvent(UntilCorrespondingEventSingleTransformerTest.java:68)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\nat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\nat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\nat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\nat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runners.Suite.runChild(Suite.java:128)\nat org.junit.runners.Suite.runChild(Suite.java:27)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\nat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:119)\nat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)\nat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\nat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n\njava.lang.AssertionError: No onNext events expected yet some received: 1 (1 completion)\nat rx.observers.TestSubscriber.assertionError(TestSubscriber.java:670)\nat rx.observers.TestSubscriber.assertNoValues(TestSubscriber.java:600)\nat com.trello.rxlifecycle.UntilEventSingleTransformerTest.twoEvents(UntilEventSingleTransformerTest.java:56)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\nat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\nat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\nat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\nat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runners.Suite.runChild(Suite.java:128)\nat org.junit.runners.Suite.runChild(Suite.java:27)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\nat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:119)\nat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)\nat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\nat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n\njava.lang.AssertionError: No onNext events expected yet some received: 1 (1 completion)\nat rx.observers.TestSubscriber.assertionError(TestSubscriber.java:670)\nat rx.observers.TestSubscriber.assertNoValues(TestSubscriber.java:600)\nat com.trello.rxlifecycle.UntilLifecycleSingleTransformerTest.oneEvent(UntilLifecycleSingleTransformerTest.java:42)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\nat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\nat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\nat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\nat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runners.Suite.runChild(Suite.java:128)\nat org.junit.runners.Suite.runChild(Suite.java:27)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\nat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:119)\nat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)\nat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\nat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n\n```\n. @dlew Thank you very much for figuring out what was actually wrong; I could not figure that out. \ud83d\ude47  It helped me understand a little bit more about RxJava. Again, thank you!\n. ",
    "ljf1172361058": "@dlew  thanks.\nIn the project build. Gradle Android with {}:\nconfigurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n}\nProblem solved.\n. thanks. ",
    "TillSimon": "Great. Thanks heaps!. @dlew Btw, do\n.compose(RxLifecycleAndroid.bindActivity(provider.lifecycle()))\nand\n.compose(provider.bindToLifecycle())\ndo the same thing? (So, e.g. when subscribed in onResume terminate it in onPause)\nAnd, does\n.compose(RxLifecycle.bind(provider.lifecycle()))\nreally terminate on whatever lifecycle event comes next? Like when subscribed in onCreate it would terminate in onCreateView for a Fragment? What would that be useful for?. Thanks for the update. Now what happens is, for this...\npublic ActivityMain() {\n        RxNavi.observe(this, Event.CREATE)\n                .map(o -> 1)\n                .compose(provider.bindToLifecycle())\n                .subscribe(i -> Timber.d(\"item %d\", i),\n                        t -> Timber.e(\"excp %s\", ((CompositeException) t).getExceptions().toString())\n                );\n    }\n...it emits the item and then terminates with the exception from before.\nitem 1\nexcp [java.lang.NullPointerException: The mapper function returned a null value.]. Now it works.\nThe gradle was synced to 2.0.1, but apparently took a couple of rebuilds until it got picked up correctly.\nSorry for that.. ",
    "jp1017": ":+1: Thank you very much. And you may show it in README. :smile: . @DaiFalin \nAdd this to your proguard-rules.pro file: :smile: \n-dontwarn javax.annotation.**. ",
    "ayjindal": "@dlew Any plans to support ListFragment?. ",
    "ianomad": "@dlew \nWhat about services?. @dlew \nWhat about custom views or adapter items?. ",
    "semireg": "Conductor Controllers would be a nice addition.. ",
    "dkhmelenko": "Sometimes there is a case when onNext is not emitted. In my case it was after applying filter operator and no item matched. So onNext was not called, but onCompleted was emitted. So I cannot rely on onNext. \nonCompleted means that sequence completed and emitting it in a moment when it could be not completed (destroying activity with active observable) is not a good idea.\nAt the same point in onError we able to specify an exception. And CancelationException fits here very well. Whenever onError was emitted user checks the type of the exception in order to process it properly.. I can understand you that it can break many existing code.\nOn the other side, tests for testing my observable functionality are not working now for me, as onCompleted can be emitted at any moment when activity is destroyed and not when sequence is done.\nI would suggest to extend functionality in order to give users opportunity to choose which callback should be emitted (onCompleted or onError(CancelationException)) in case activity is destroyed. This library simplifies the life of many developers and having such feature would make it even better.\nI can take care of PR a bit later or can help with ideas.. ",
    "PaulWoitaschek": "Am I correct that CancellationException is still thrown for rx2? Because I can't see that in the readme any longer.. Can you give an example in which cirumstances that doesn't work?\nkotlin\nfun main(args: Array<String>) {\n    var disposable: Disposable? = null\n    Observable.interval(1, TimeUnit.SECONDS)\n            .doOnSubscribe { disposable = it }\n            .subscribe(::println)\n    Thread.sleep(3000)\n    disposable?.dispose()\n    Thread.sleep(3000)\n}\nPrints 0, 1, 2. ",
    "qq2748": "\u5929\u54ea.....\u5176\u5b9e\u8fd8\u662f\u652f\u6301\u81ea\u5b9a\u4e49\u6bd4\u8f83\u597d\u4e00\u70b9. ",
    "xutao2388": "https://github.com/CreativeSDK/android-getting-started-samples/issues/33. solved by MultiDex \uff1b\nsee\uff1ahttps://github.com/CreativeSDK/android-getting-started-samples/issues/33. ",
    "jdsjlzx": "It works\uff0cthank you. I konw!\nrxlifecycle-components/src/main/java/com/trello/rxlifecycle/components/RxFragment.java\nrxlifecycle-components/src/main/java/com/trello/rxlifecycle/components/support/RxFragment.java\n. ",
    "tsuijten": "One other thing I noticed is that in this case:\nSingle.just(\"test\")\n                .delay(2, TimeUnit.SECONDS)\n                .observeOn(AndroidSchedulers.mainThread())\n                .bindToLifecycle(this)\n                .doOnUnsubscribe { Log.d(\"test\", \"doOnUnsubscribe\") }\n                .subscribeWith {\n                    onSuccess { Log.d(\"test\", \"onSuccess: $it\") }\n                    onError { Log.d(\"test\", \"onError: $it\") }\n                }\nThe doOnUnsubscribe is never called. In other words it seems the Single is never unsubscribed.\nAdditionally I created a test case in the RxLifecycle project:\n```\n    @Test\n    public void testSingle() {\n        BehaviorSubject lifecycle = BehaviorSubject.create();\n        TestSubscriber testSubscriber = new TestSubscriber<>();\n    observable.toSingle().compose(RxLifecycle.bindUntilEvent(lifecycle, FragmentEvent.PAUSE).forSingle())\n            .subscribe(testSubscriber);\n\n    lifecycle.onNext(FragmentEvent.ATTACH);\n    assertFalse(testSubscriber.isUnsubscribed());\n    lifecycle.onNext(FragmentEvent.CREATE);\n    assertFalse(testSubscriber.isUnsubscribed());\n    lifecycle.onNext(FragmentEvent.CREATE_VIEW);\n    assertFalse(testSubscriber.isUnsubscribed());\n    lifecycle.onNext(FragmentEvent.START);\n    assertFalse(testSubscriber.isUnsubscribed());\n    lifecycle.onNext(FragmentEvent.RESUME);\n    assertFalse(testSubscriber.isUnsubscribed());\n    lifecycle.onNext(FragmentEvent.PAUSE);\n    testSubscriber.assertCompleted();\n    testSubscriber.assertUnsubscribed();\n}\n\n```\nThe above testcase fails for a Single but Succeeds when I use an Observable. \nMaybe I'm missing something but I don't see why the behaviour differs, IMO a Single should behave the same as a Observable expect for the fact it always emit a single value / error.. Ah I think I understand what's going wrong. RxLifecycle works in such a way that it completes an Observable when the bound lifecycle event happens. Since a Single can't complete without a value an error is generated.\nWhat would be better IMO is to unsubscribe from the Observable / Single when the bound lifecycle event happens.. Why not?\nYou could do something like this in the UntilLifecycleSingleTransformer?\n```\nfinal class UntilLifecycleSingleTransformer implements Single.Transformer {\nfinal Observable<R> lifecycle;\n\npublic UntilLifecycleSingleTransformer(@Nonnull Observable<R> lifecycle) {\n    this.lifecycle = lifecycle;\n}\n\n@Override\npublic Single<T> call(final Single<T> source) {\n    return Single.create(new Single.OnSubscribe<T>() {\n        @Override\n        public void call(SingleSubscriber<? super T> singleSubscriber) {\n            final Subscription subscription = source.subscribe(singleSubscriber);\n            lifecycle.subscribe(new Action1<R>() {\n                @Override\n                public void call(R r) {\n                    // Event reached, unsubscribe from source\n                    subscription.unsubscribe();\n                }\n            });\n        }\n    });\n}\n\n}\n```\n. I trust you're right :) But I've been reading the comments, I still don't fully understand why it's unsafe to unsubscribe from the source in this fashion (except from the fact that my code snippet in incomplete). \nI recently wrote a similar operator for showing a progress dialog. In this case I used fromEmitter and implemented  setCancellation which also unsubscribes from the source if you unsubscribe from the returned Observable or cancel the progress dialog. So I must assume this is unsafe as well? \n```\nfun  Observable.withHud(activity: BaseActivity, @StringRes title: Int? = null, cancelable: Boolean = false): Observable {\n    val source = this\nreturn Observable.fromEmitter<T>({ emitter ->\n    val hud = ProgressHUD.show(activity, cancelable, null)\n    val sourceSubscription = source\n            .doOnUnsubscribe { hud.dismiss() }\n            .subscribe(emitter)\n\n    hud.setOnCancelListener { sourceSubscription.unsubscribe() }\n    emitter.setCancellation { sourceSubscription.unsubscribe() }\n}, Emitter.BackpressureMode.BUFFER)\n\n}\n```. Maybe you could mention him in this thread so he can help me understand why this is unsafe? . Thanks for the explanation @akarnokd! It makes sense that if you unsubscribe halfway in the chain you might get leaks downstream.\nSince I work with Singles a lot it quite a hassle to take the CancellationException into consideration... So I created the following Kotlin extensions to handle unsubscribing:\n```\nfun  Single.subscribeUntil(provider: com.trello.rxlifecycle.LifecycleProvider, event: E, body: FunctionSingleSubscriberModifier.() -> Unit) =\n        subscribeUntil(body, provider.bindUntilEvent(event))\nfun  Single.subscribeUntil(provider: com.trello.rxlifecycle.LifecycleProvider, body: FunctionSingleSubscriberModifier.() -> Unit) =\n        subscribeUntil(body, provider.bindToLifecycle())\nfun  Single.subscribeUntilDetach(view: View, body: FunctionSingleSubscriberModifier.() -> Unit) = \n        subscribeUntil(body, RxLifecycleAndroid.bindView(view))\nprivate fun  Single.subscribeUntil(body: FunctionSingleSubscriberModifier.() -> Unit, transformer: Observable.Transformer): Subscription {\n    val sourceSubscription = this.subscribeWith(body)\n    val untilSubscription = Observable.create {  }.compose(transformer).subscribeWith {\n        onCompleted { sourceSubscription.unsubscribe() }\n    }\n    return CompositeSubscription(sourceSubscription, untilSubscription)\n}\n```. ",
    "akarnokd": "It is unsafe because there is no guarantee bindToLifecycle is the last operator in the chain and if even so, there is no guarantee a Subscriber doesn't have resources associated with it. Resources are freed by calling unsubscribe() on the Subscriber which propagates upstream. An unsubscribe somewhere upstream won't propagate down and thus may leak resources. \n```java\npublic Observable someAPI() {\n   return Observable.just(\"1\").delay(2, TimeUnit.SECONDS)\n   .compose(bindToLifecycle(this)); // <-- how conventient?!\n}\nsomeAPI()\n.observeOn(Schedulers.io())\n.flatMap(v -> otherAPICall())\n.subscribe(...)\n```\nOne needs to communicate some terminal event, such as the error in this issue or an onCompleted signal to indicate the sequence is done and trigger the necessary cleanup.\nSo instead of this type of lifecylce binding, you'd need to have your own custom subscribe() that calls unsubscribe at the very end of the chain:\n````kotlin\nfun Observable.subscribeUntil(Activity bind, Action1 onNext, Action1 onError, Action0 onCompleted) {\n    Subscription s = this.subscribe(onNext, onError, onCompleted);\nbind.addDestroyListener(() -> s.unsubscribe()); // or something similar\n\n}\nfun Observable.subscribeUntil(Activity bind, Observer observer) {\n    Subscription s = this.subscribe(observer);\nbind.addDestroyListener(() -> s.unsubscribe()); // or something similar\n\n}\n``` . ",
    "renanferrari": "Is there a reason this library can't provide some kind of Subscriber \"wrapper\" that would properly handle unsubscriptions?\nI'm thinking instead of this:\njava\npublic class MyActivity extends RxActivity {\n    @Override\n    public void onResume() {\n        super.onResume();\n        myObservable\n            .compose(bindToLifecycle())\n            .subscribe(new Subscriber() {...});\n    }\n}\nWe would have something like this:\njava\npublic class MyActivity extends RxActivity {\n    @Override\n    public void onResume() {\n        super.onResume();\n        myObservable\n            .subscribe(bindToLifecycle(new Subscriber() {...}));\n    }\n}\nMakes sense?. ",
    "mradzinski": "VerifyError is indeed a build problem on @duwurensheng010 end and nothing to do with the library. It's a long shot, but judging by the 5.0 in the title and assuming that blow is actually meant to say below... 65K methods.. ",
    "aaronhe42": "Yeah, I actually saw the issue before sending this PR. It just the team I am working with only uses RxJava for non-UI streams and RxLifecycle for stream termination, so including RxBinding just for one method doesn't justify the cost of methods count increase for us. \nOkay, I guess I'll just port the RxLifecycleAndroid over in our app. It's fairly easy to do so.. ",
    "stanmots": "\nIf the Activity is being recreated then you actually get a new instance of Activity and it would be detrimental to hold onto subscriptions referencing the old Activity.\n\nI'm sorry If I misunderstood the purpose of this library, but in accordance with the README: \n\nRxLifecycle does not actually unsubscribe the sequence. Instead it terminates the sequence.\n\nFor example, I can store an observable in a retained fragment (so that every time the Activity is recreated I can retrieve the same observable instance). I just thought it is possible to complete the sequence automatically when the Activity is being destroyed and finished, without actually managing subscriptions.\nImagine a common use case: a presenter which survives a configuration change. This presenter can be saved in some static store or in a retained fragment (or even using a Loader). What if the presenter subscribes to an observable but this observable must be completed only when the Activity is finished (not temporarily destroyed due to a device rotation). Of course, I can use an interface to pass required events manually and unsubscribe when needed. Just thought I could achieve this more easily with this library by binding such observable to ActivityEvent.DESTROY_AND_FINISH.. Ok, thank you for the reply. It is more clear now. \nBy the way, I've just found FRAGMENT_EVENT_MAP. Correct me if I'm wrong, but it seems that in the case of the retained fragment the FragmentEvent.DESTROY would be exactly the same as the aforementioned  ActivityEvent.DESTROY_AND_FINISH :)\nIt is OK to use the retained fragment as a subclass of RxFragment? \n. Thanks, I'm closing the issue. ",
    "Jawnnypoo": "Ah okay, glad to hear it! \ud83d\udc4d . ",
    "DaRkRaGe": "Im sorry but I don't get it, what do I need to do and add to avoid this exception ?. Thanks for your reply. ",
    "weituotian": "actually i have no idea to add or modify some configurtion after i had read the acticle. @dlew \n\n. ",
    "ryansgot": "That makes sense to me. Thanks for the explanation.. ",
    "kassim": "Seems like it should come with a clearer warning in the documentation.\nIn any case, an easy workaround seems to be to convert your Single to an Observable. ",
    "atfox7": "We ran into this same issue as well. Using bindUntilEvent did not change the results though for us. Switching the order of compose() and observeOn does work however.. ",
    "shakil807g": "does .compose(provider.bindToLifecycle())   line need to call above subscribe  in order to work correctly ???. ",
    "jaychang0917": "Same problem. The following code doesn't work and keep emitting whenonStop()` is called.\n```java\nclass MainActivity : LifecycleActivity() {\nval provider : LifecycleProvider = AndroidLifecycle.createLifecycleProvider(this)\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n  }\noverride fun onStart() {\n    super.onStart()\n    Observable.interval(0, 1, TimeUnit.SECONDS)\n      .doOnDispose { println(\"dispose\") }\n      .compose(provider.bindToLifecycle())\n      .subscribe {\n        println(\"emiit:\" + it)\n      }\n  }\noverride fun onStop() {\n    super.onStop()\n    println(\"onStop\")\n  }\n}\n```. ",
    "micHar": "Just had the same situation where I had to put observeOn BEFORE bindToLifecycle, otherwise it randomly crashed (because it didn't close the stream properly upon destroy). Why does it happen?. Same here, we have stable lifecycle for quite some time now, do you plan a release to match it soon?. ",
    "27DH": "Hello,\nYou can try with this url = https://dl.google.com/dl/android/maven2/\nallprojects {\n    repositories {\n        jcenter()\n        maven { url 'https://dl.google.com/dl/android/maven2/' }\n    }\n}. ",
    "RobLewis": "Thank you, those will no doubt help. But I would still like answers to the questions in my OP. . ",
    "gofinal": "Solve this problem \nmaven {url 'https://maven.google.com'}. ",
    "pawegio": "Ok, I agree with both of you. What do you think about extracting it to another module, e.g. rxlifecycle-components-preference? I believe that it is reasonable since preference-v7 package comes with multiple fragments targeting different use cases such as:\n- PreferenceFragmentCompat (already added in this PR)\n- EditTextPreferenceDialogFragmentCompat\n- PreferenceDialogFragmentCompat\n- ListPreferenceDialogFragmentCompat\nSince I am currently experimenting with preference data stores I can handle it.. Now it is extracted to its own dependency.. ",
    "gonemad": "Yup should be a stable api now\nRelease Candidate - October 18, 2017\nAll major artifacts (except Paging) are now 1.0.0-rc1.. I stopped using this lib but for what its worth when i filed this issue i was not using the paging library and my investigation into the issue seemed to indicate nothing related to the paging library. I would not close this without verifying that. Nm ignore that. Didnt see it was fixed. ",
    "MichaelJokAr": "have same error too;. when I remove the paging library implementation \"android.arch.paging:runtime:1.0.0-alpha3\" ,it's fine. ",
    "bagrusss": "I have the same problem\n```\ndependencies {\n...\n\nimplementation \"android.arch.lifecycle:runtime:1.0.3\"\nimplementation \"android.arch.lifecycle:extensions:1.0.0\"\nannotationProcessor \"android.arch.lifecycle:compiler:1.0.0\"\n\nimplementation 'com.trello.rxlifecycle2:rxlifecycle-android-lifecycle-kotlin:2.2.0'\n\n...\n\n}\n```\nHave you any progress for this problem?. ",
    "AndroidDeveloperLB": "It just feels natural to use them both together. . I mean why not mention that you don't recommend it on the repo itself. Maybe even deprecate it, or present the disadvantages. \nPeople should know before using it. Not just the advantages, but also the disadvantages. \nOtherwise they take an informed decision. . ",
    "KoMinkyu": "According to this lifecycle component issue, I think there is no code changes needed.\nAnd also I reported about the RestrictedApi lint issue. It can be solved by applying a new version of buildTools and android build gradle version.\nI will update my PR to fix build failure.. ",
    "tvhieuit": "it worked well with rxjava2.. I'm just invalidate caches / restart and it worked :D . ",
    "AllenVork": "@dlew thx for your answer. I just took a look of the source code of clear and unsubscribe. The only difference between them is that unsubscribe method makes this.unsubscribed = true so you can't add subscription to it later. But I don't get it that why the clear method can clear references. Could you figure it out for me ?. ",
    "osama-raddad": "I am using java 8\n\ncompileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n}.\n\n",
    "nekocode": "Thanks for your reply! You reminds me that the downstream may continue to emit. Perhaps the AutoDispose is the only solution to actually cancel the observer's subscription. PR closed.. ",
    "trr-amsiq": "Sorry I meant 4.6\nI\u2019ve updated the .travis.yml file. ",
    "tristanrichard": "@dlew . I don't know what to. do about the error message\n. ",
    "bmc08gt": "The SDK license needs to be accepted on the travis server. ",
    "funcyhong": "Sorry, I just saw it now. I've already get it,thanks. ",
    "saravinfotech": "Hey sorry did try it out and it is working fine with the stable version, my bad. . ",
    "schwiz": "Oh cool thanks. ",
    "siralam": "@dlew Congratulations haha! And I think #131 should be the reason. Thanks!. ",
    "ahulyk": "@dlew yeap, i've also shared that with Google. @dlew linked issue. @dlew please check answer from Google side:\n\nI was digging into a different issue this morning and happened to figure out what's happening here. The RxLifecycle library was compiled with Android lifecycle version 1.0.0, which embedded keep rules with the internal \"ifused\" syntax into consumer jars. So the current version of RxLifecycle on maven will have this \"ifused\" rule for eternity. This wasn't really an issue until R8 released the feature to consume rules embedded in jars.\nI don't think we want to support the internal \"ifused\" syntax, so I would advise using a newer release of Android lifecycle which correctly produces \"-if\" syntax (I've verified that version 1.1.1 does this) and publish a new version of the RxLifecycle library.\n\nLooks like updating Android Lifecycle will solve the issue.. Jetifier works fine. \nYou just need to add following extensions for kotlin:\nRxLifecycleKtx for androidX. ",
    "RubyLichtenstein": "Now bindToLifeCycle except android.arch.lifecycle.LifecycleOwner\nShould be update to except androidx.lifecycle.LifecycleOwner\nkotlin \npublic fun <T> io.reactivex.Single<T>.bindToLifecycle(owner: android.arch.lifecycle.LifecycleOwner): io.reactivex.Single<T> { /* compiled code */ }\n. @danielesegato You can use this quick fix for now\nhttps://github.com/RubyLichtenstein/RxLifecycleAndroidX. ",
    "danielesegato": "@dlew sorry forgot to answer. It's basically what @RubyLichtenstein said. They simply changed the package of LifecycleOwner and RxLifecycle still look in the other one.\nI wrote a simple class like the one Ruby share to keep going for my project.. ",
    "jcsla": "@dlew \nPlease merge this PR to another branch. Thanks.. ",
    "GavinDon": "i mean in the model use implementation depend on. ",
    "chenzhentao": "\u51fa\u73b0\u8fd9\u4e2a\u95ee\u9898\u6709\u4e24\u79cd\u60c5\u51b5,1:\u5c31\u662f\u4f9d\u8d56\u5305\u8fc7\u591a,\u505a\u597d\u5206\u5305,2,\u5c31\u662f\u4f9d\u8d56\u51b2\u7a81,\u5217\u51fa\u6765\u4f9d\u8d56\u6811,\u67e5\u627e\u90a3\u4e2a\u51b2\u7a81\u5c31\u53ef\u4ee5\u4e86. ",
    "Ztiany": "Implementation of the rxlifecycle-android-lifecycle-kotlin module\uff1a\n```kotlin\nfun  Observable.bindToLifecycle(owner: LifecycleOwner): Observable\n        = this.compose(AndroidLifecycle.createLifecycleProvider(owner).bindToLifecycle())\nfun  Observable.bindUntilEvent(owner: LifecycleOwner, event: Lifecycle.Event): Observable\n        = this.compose(AndroidLifecycle.createLifecycleProvider(owner).bindUntilEvent(event))\n```\nEvery time you call bindToLifecycle or another method, AndroidLifecycle.createLifecycleProvider(owner) will create a new LifecycleProvider.\nnow\uff1a\n```kotlin\nprivate class Delegate {\nprivate lateinit var lifecycleProvider: LifecycleProvider<Lifecycle.Event>\n\noperator fun getValue(thisRef: LifecycleOwner?, property: KProperty<*>): LifecycleProvider<Lifecycle.Event> {\n    if (!::lifecycleProvider.isInitialized) {\n        Log.d(\"RxLifecycle-Kotlin\", \"initialize lifecycleProvider for $thisRef\")\n        lifecycleProvider = AndroidLifecycle.createLifecycleProvider(thisRef)\n    }\n    return lifecycleProvider\n}\n\n}\nfun  Observable.bindToLifecycle(owner: LifecycleOwner): Observable =\n        this.compose(owner.lifecycleProvider.bindToLifecycle())\nfun  Observable.bindUntilEvent(owner: LifecycleOwner, event: Lifecycle.Event): Observable =\n        this.compose(owner.lifecycleProvider.bindUntilEvent(event))\nprivate val LifecycleOwner.lifecycleProvider by Delegate()\n```\nEvery time you call bindToLifecycle or another method, Only one LifecycleProvider has been created for LifecycleOwner.. My previous advice was wrong. It is a bad way to use extensions and delegate at the same time. This will cause all instance objects of the extended class to share the same delegate. the delegate is static.. ",
    "moneeWong": "\nRxLifecycle 3.0.0 was pushed out to support AndroidX. If your codebase is not on AndroidX yet then you should not update.\nRead up on the AndroidX migration here for more information.\n\u6211\u7684\u9879\u76ee\u4e2d\u4f9d\u8d56\u4e86\u5176\u4ed6\u7684\u5f00\u6e90\u5e93\uff0c\u4ed6\u4eec\u6709\u4e9b\u8fd8\u672a\u5347\u7ea7AndroidX\uff0c\u6240\u4ee5\u6211\u8fd8\u4e0d\u80fd\u4f7f\u7528AndroidX\uff0c\u80fd\u5426\u51fa\u4e00\u4e2a\u517c\u5bb9\u7248\u672c\u53ef\u4ee5\u4e0d\u4f7f\u7528AndroidX\uff1f\u611f\u8c22\n. \n",
    "Young-Joe": "\nRxLifecycle 3.0.0 was pushed out to support AndroidX. If your codebase is not on AndroidX yet then you should not update.\nRead up on the AndroidX migration here for more information.\n\u6211\u7684\u9879\u76ee\u4e2d\u4f9d\u8d56\u4e86\u5176\u4ed6\u7684\u5f00\u6e90\u5e93\uff0c\u4ed6\u4eec\u6709\u4e9b\u8fd8\u672a\u5347\u7ea7AndroidX\uff0c\u6240\u4ee5\u6211\u8fd8\u4e0d\u80fd\u4f7f\u7528AndroidX\uff0c\u80fd\u5426\u51fa\u4e00\u4e2a\u517c\u5bb9\u7248\u672c\u53ef\u4ee5\u4e0d\u4f7f\u7528AndroidX\uff1f\u611f\u8c22\n\n\u54c8\u54c8,\u4f60\u6700\u597d\u5199\u82f1\u6587\u5427. \u4f5c\u8005\u4f30\u8ba1\u770b\u4e0d\u61c2\u6c49\u8bed~ \u6211\u4e5f\u633a\u60f3\u7528lifecycle\u7684.\u73b0\u5728\u53ea\u80fd\u5148\u59a5\u534f\u4e86. ",
    "petma": "\nWhat are you using to try to download it?\n\nI found out the reason:I used the com.trello.rxlifecycle2:rxlifecycle:3.0.0   but the right address is com.trello.rxlifecycle3:rxlifecycle:3.0.0. ",
    "Ruowenmei": "The Version is rxlifecycle-components:2.1.0 . ",
    "passin95": "Hi! This is why I submitted the commite before. Because I changed the RxLifecycle Framework, so I reopened a project (https://github.com/passin95/RxDispose). This project may support multiple types of events to work. Would you please kindly have a look at this project?. ",
    "ulyssesp": "Typo - \"provide either have\"\n. I would also go for \"Observable<FragmentEvent> that gives RxLifecycle the information\" but that's a grammatical choice.\n. ",
    "evant": "Couldn't think of a better name \u00af_(\u30c4)_/\u00af. This test fails on sdk = 16, I'm not sure why.. Wasn't sure if I should create a seperate kotlin module for this.. Open to a better name. This wraps a LifecycleOwner and provides a LifecycleProvider.. I chose to go with the provided events instead of the rxlifecycle-android ones. They are a bit more limited on fragments so I think this is less surprizing.. lifecycle events won't fire if you call methods on a fragment directly. You need to trigger them through the hosting activity.. ",
    "piotrek1543": "@trr-amsiq @tristanrichard guys, you forgot to update compileSdkVersion to 27, that's why Travis build still fails. \nTravis config file has compileSdkVersion set to 27 (android-27), but project still uses 26.. For now, the newest version is 1.1.1 for lifecycleVersion and 27.1.1 for supportLibVersion. "
}