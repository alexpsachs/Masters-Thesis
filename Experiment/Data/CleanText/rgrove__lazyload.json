{
    "rauanmayemir": "nb: i'm passing this from prototype js Classes (their \"methods\")\n. Hm.. i remember, i really had such problems, but after solving them, i cannot reproduce again.\nI guess there was problems with the scope of eval'd scripts came from ajax.\n. Take a look at this fragment:\n    if (pending[type] || !(p = pending[type] = queue[type].shift())) {\n      return;\n    }\nCase is:\ni'm lazy loading script from one place, and some time later loading it again, but\nthis string !(p = pending[type] = queue[type].shift()) returns me true.\nAfter firebuging i noticed, that either pending or queue doesn't clean up after loading scripts, so that in next cycle queue or pending is not empty.\nI'm using Firefox 3.5.8, but in Chrome 4 results are the same.\n. ",
    "rgrove": "Can you please post some code that reproduces the problem?\n. The !(p = pending[type] = queue[type].shift()) check will evaluate to true when the queue is empty, so it sounds like this is working correctly. If items weren't being removed from the queue, that expression would evaluate to false.\nSince I haven't seen an issue like the one you describe, I can't debug this unless you can provide executable code that reproduces the problem.\n. Can't reproduce and no new info, so closing.\n. Don't cause an error when polling on a page without any CSS. Closed by b4b1490978c5ac16ba29d5c6706216d2d1a40e3a\n. What version of LazyLoad are you using? Firefox 4 stopped ensuring script execution order by default, and LazyLoad 2.0.1 and greater have a workaround for this.\nIf you're already using 2.0.1 or greater and are still having problems, please provide a runnable test case that demonstrates the issue.\n. At some point I'll probably add a simple URL-based lookup hash to LazyLoad so that it can at least avoid loading URLs it's already seen. I don't want to implement anything more complex than that, though; it would increase the code size too much.\nIn the meantime, you could write a thin wrapper function around LazyLoad that uses a lookup hash just like I've described, and avoids loading anything that's already been loaded.\n. LazyLoad doesn't currently support a failure callback. The callback is called when the script is \"finished\", either as a result of being loaded successfully or failing to load.\nSo, this:\njs\nLazyLoad.js('foo.js', function () {\n    console.log('hello!');\n});\nWill behave exactly the same way as this:\nhtml\n<script src=\"foo.js\"></script>\n<script>console.log('hello!');</script>\nEven if foo.js fails to load, the callback and subsequent script are still executed.\n. Sorry for the silence. I've been trying to come to a decision on this one.\nOn the one hand, loadOnce() is valuable. On the other, it adds a lot of bytes. But meh, not a huge deal, and it can be optimized.\nComplicating this, though, is the fact that LazyLoad is kind of in maintenance mode these days. I'm not using it much myself, although I do want to keep it usable. I'm not sure I want to add any major new features to it, though. There are other script loaders with lots of great features. I think LazyLoad's strength is in doing the bare minimum, but doing it well and with very little code.\nSo, while I'm grateful for the patch, I think I'd prefer not to pull this change, but I'd encourage you to maintain it in your own fork.\n. Sorry this was ignored for so long (to be honest, I ignored it because the description of the issue implied a dependence on Ruby partials and I wasn't going to create a Ruby app to try to reproduce this). I think the underlying issue was addressed in ba2dac29. If it wasn't, please open an issue with clear steps to reproduce using plain HTML and JS.\n. Sorry I haven't pulled this. I'm not happy with the way this version sniff is implemented (it's more verbose than it needs to be), but I've been too busy to work on LazyLoad recently and I no longer use it myself. Ideally I'd prefer to use feature detection for this rather than a sniff, if possible.\n. If you're happy with this patch, feel free to use it. You don't need to wait for me to apply it.\n. I would happily merge a pull request that resolves this issue in the way I recommended above. I'm just not happy with this pull request. If you feel strongly about this, I encourage you to turn your feelings into code.\nI don't use LazyLoad anymore, so I rely heavily on the community of people who do use it to help maintain it. As guilty as it makes me feel sometimes, there are a ton of things vying for my time that are more pressing than maintaining a library I no longer use (such as my actual job, and the projects I maintain that I do still use, and my personal life, and feeding my cat).\nI'm flattered that there are people who still find LazyLoad useful and grateful that you all care enough to comment here, but commenting isn't going to fix this bug, and I'm not going to let guilt drive what I choose to work on. I hope you understand.\n. I'd actually prefer that the license be left out of minified source. I don't need my name taking up those precious bytes. If any lawyers come after you, tell them I said to leave you alone. :)\n. You're welcome!\n. @arfordweb See https://github.com/rgrove/lazyload/pull/10#issuecomment-19130685\n. I'll take it. Thanks @kitcambridge!\n. Unless you have magical powers (which would be super cool), there is one reliable way to solve this: put the document ready call in the LazyLoad callback.\nThere are many unreliable ways to solve this, but they will all fail and they will all be a waste of time. \nLazyLoad will tell you when everything has finished loading by executing its callback. If you're not willing to wait for the callback, your code may run before things finish loading, and there's nothing LazyLoad can do about it.\n. This isn't currently possible with LazyLoad, although it wouldn't be too hard to implement if someone wants to take a stab at it.\n. I appreciate the effort, but I'm not sure why anyone would want to do this. Also, lifting code from jQuery means jQuery's license must be maintained on that code.\nI'm not interested in this, but please feel free to maintain it in your own fork.\n. Merged! Thanks for the fix.\n. I'm not interested in this change, but please feel free to maintain it in your fork. Thanks!\n. 1. It adds no value in this case. LazyLoad tries to be as small as possible, so every byte counts.\n2. The diff contained 'user strict', not 'use strict'.\n. 1. That's just, like, your opinion, man.\n2. I appreciate you sharing your opinion with me, but I disagree. Thanks!\n. LazyLoad is intended to be global. I already said no to \"use strict\". Please stop.\n. LazyLoad supports JSHint just fine. Here's how to use JSHint with LazyLoad:\n1. Run JSHint on LazyLoad.\n. Please don't use pull requests for things that should simply be issues.\n. (Unless you have a fix, in which case, by all means open a pull request. But this PR only italicized a word, which is not useful.)\n. This is something you should probably do yourself if you need it. Doing it generically and reliably in LazyLoad is tricky and complicated and would significantly increase its size, but if you know how you're loading things you're in a much better position to keep track of what you're loading.\n. Good catch. The array copy can be performed in one line, though:\njs\npendingUrls = p.urls.concat();\nIf you make that change, I'll pull this in.\n. ",
    "inspiraller": "Thanks rgrove. That worked a charm. regards\n. ",
    "guiocavalcanti": "Ok, I'll try that. Thanks for the fast answer.\n. ",
    "kamov": "Hi\ncan someone show me an example?\nI am trying to do this, but is not working.\nAfter \njs\nfor (i = 0, len = pendingUrls.length; i < len; ++i) {\n      url = pendingUrls[i];\nI added this code:\n``` js\n                                var all_scripts = document.getElementsByTagName(\"script\");\n                            for(var i = 0; i < all_scripts.length; i++) {\n\n                                if(all_scripts[i].src ==url) {\n                                    alert('I found you!! Dont load me');\n                                    return true; // continue to next\n                                }\n                            }\n                            alert('I am going to load you.' + url);\n\n```\n. solved in this way (I appreciate any suggestion for improve it):\nI just change the for loop which appendChild nodes to head, by checking if that src it's already on head.\nThe final code is:\n``` js\nvar all_scripts = document.getElementsByTagName(\"script\");\nvar i_found_you = false;\n\nfor (i = 0, len = nodes.length; i < len; ++i) {\n\n  for(var ii = 0; ii < all_scripts.length; ii++) {\n\n      if(all_scripts[ii].src == nodes[i].getAttribute('src')) {\n\n          i_found_you = true;\n          break; // continue to next\n      }\n  }\n\n  if(!i_found_you)\n    head.appendChild(nodes[i]);\n\n}\n\n```\n. not working :(\n. ",
    "zhikuanlin": "code above has a bug, \n\"charset\" must be set to the newly created node before \"src\", see:\nhttp://yuilibrary.com/projects/yui3/ticket/2528363\n. ",
    "tylerzhu": "Is the problem solved?\n. ",
    "eduardojmatos": "Yeah, no problem. The issue is really the same related with https://github.com/rgrove/lazyload/commit/ba2dac29. Thanks for reply (even with delay :smile: )\n. ",
    "aaronhb": "Any chance of getting a minified version of this fix? This worked great!!!\n. ",
    "laberning": "Thanks, this just made my day!\n. ",
    "cherouvim": "Why not apply the patch and improve later? The fact that it doesn't work in IE10 is worst than the sniffing.\n. I am and already have. The problem I see with this is that every new (to lazyload) programmer will have to discover that it's not working with IE10, discover the fix and apply it.\n. ",
    "arfordweb": "I'd like to start my response by saying Thank You to Ryan for building this simple, easy-to-use plugin.  It is far more intuitive to me than most other JS loaders I've worked with.  Writing open source code is a thankless hobby, I'm sure.  To think that users of your free code might come back and complain about it is as counter-intuitive as anything in this world, but is also unfortunately inevitable.\nThat being said, I have to agree with cherouvim.  Finding and using a plugin like this one saves time and effort for developers, but not correcting a known bug when someone has submitted a working solution in turns costs those developers time and leads to frustration.  I second, on behalf of future LazyLoad users, the idea of pulling the not-so-perfect solution for now and perfecting it at your leisure.\n. Please pull.  Fixes IE10 issue.\n. Oops.  I just noticed there is a Pull Request for a version that fixes this issue (#13).  I tested the code in that update.  It's working properly in IE10.\n. ",
    "evangoer": "For those of us including your code from source as part of a larger project.\n. What, no animated GIF of a cat leaving a \"present\" for its owner? :D\nP.S.- thanks for LazyLoad, it is pretty darn great!\n. ",
    "gordyr": "I'm not quite sure I understand the question so I may be way off here.\nIf you mean how do you make sure you only load a single dependency once then....\nI do it by simply storing an array of script urls and checking against them whenever a new request to load a script is made.\nSomething along the lines of this should work fine.\n```\nvar scripts = [];\nif(scripts.indexOf(url) === -1){\n    scripts.push(url);  // Push the url into array before the complete callback so that we know instantly whether a load has been attempted.\n    LazyLoad.js(url, function(){\n});\n\n}\n```\nThis way when navigating around my webapps each page, page fragment, dialog, whatever...  has its own set of JS resources of which that particular piece of dynamically loaded content requires.  My own mini framework attempts to load the correct resources whenever said content is loaded. \nEach of these fragments may have the same dependencies.  For instance:\nImagine a single page that has 3 dynamically loaded segments:\nSegment 1 : Skeleton\nSegment 2 :  Content\nSegment 3 : Adverts\nNow each Segment, within it's own javascript has an array of dependencies:\nSegment 1 might be ['jquery.min.js', 'somethingelse.js', 'skeleton.js']  \nand Segment 2 might have ['jquery.min.js', 'anotherfile.js','yetanotherfile.js', 'content.js'] \netc..etc...\nNow both pieces of content are being loaded at the same time and each segment requires jquery.min.js.\nBut, since we have stored the jquery.min.js url in an array, it is only requested by the first completed segment, and then never again.\nThere's many other ways to go about it but this is the basic concept.  Hope it helps\n. ",
    "Itumac": "That's good enough for me coming from you. I can see those paths and they are all dark forest paths. I am looking into server based bundling solutions at the moment. Or a document.write spell! :)\n. ",
    "sankargorthi": "Cheers!\n. ",
    "zafar-saleem": "Any reason why 'use strict' shouldn't be used?\n. 1. It does add value as all javascript code should run in strict mode so that it prevents certain actions from being taken such as gaining access to the global object. Secondly, it is faster that jshint, eslint and jslint. Few characters do not add tons of bytes anyway. As this library is going to be minified anyway in release applications therefore, it size will be reduced thus will not affect app performance.\n2. Fixed typo.\n. ",
    "emanwebdev": "\nBut this PR (...) is not useful\n\nHi, sorry to have bothered you\nActually, i couldn't find any other way to bring it to your attention; hence it's been somehow useful :)\nMy apologizes for your precious time and THANKs for LazyLoad !\nBest Regards\nEmmanuel\n. ",
    "hyingreborn": "writer wrong... i means requirejs\n. ",
    "valeriansaliou": "Updated ;) By the way, thanks for the hint, did not know about this shortcut.\n. "
}