{
    "swankjesse": "Love it. A quick test case would be even better, just in case we ever do any heavy refactoring.\n. I'd rather otto do its own code generation. It's not too difficult and we can avoid a third-party dependency.\n. I don't think enforcing order on event delivery is a good idea. If you need ordered delivery, you need something with tighter coupling than EventBus.\n. This looks a lot like the cunning android bug I encountered in August.\n. > Is that really a good idea?\nWe do it in Dagger for a few reasons.\n1. Since the annotations exist outside of dagger.jar (in the JSR-330 jar), it's possible to build some part of your app without looping in Dagger. We're trying to be forgiving.\n2. Some tools (I've seen it in IntelliJ) aren't reliable about doing code gen. It would seem developer-hostile to crash when this happens.\nOne thing I'm sad about is that when we split up dagger into dagger and dagger-compiler, we made it a lot easier to release a crappy app. That refactor was well-intentioned but it makes our user's lives way more complicated. It's quite tricky to make sure that Dagger compiler is reliably on the build path but not on the runtime class path. This may be broken for Square's apps today!\n. I don't like Otto's thread enforcement. It's a global setting, but my code usually wants local configuration. . .\nSuppose I'm writing a library that bridges device events (power, location, network status) to Otto. My code posts these events on the main thread. Is that an implementation detail? Or something that needs to be documented? Or I'm writing a library that does background syncing based on incoming device events. My code wants its events to be published to a background looper thread. Is that an implementation detail?\nI'd like to see @Subscribe take an optional thread that it desires the notification on. For portability and simplicity, this could just be a string name:\n```\n  @Subscribe(\"main\") public void networkStateChanged(NetworkStateEvent e) {\n    connectedWarning.setVisibility(e.isServerReachable() ? GONE : VISIBLE);\n  }\n@Subscribe(\"network\") public void powerStateChanged(PowerEvent e) {\n    if (e.isPluggedIn()) {\n      syncSchedule = FREQUENT;\n    } else {\n      syncSchedule = INFREQUENT;\n    }\n  }\n```\n. Ah, didn't see that. Now I have, and I politely disagree with your very long response. \nYou're right that moving events across threads adds complexity. But it isn't accidental complexity; it's necessary complexity. Threads exist and bus events need to be aware of 'em. The only question is whether Otto addresses this complexity or whether it's up to the user.\nLet's discuss this offline...\n. LGTM\n. We have the type resolution technology, but I don't think it's worth supporting. To get this really right you'd need to make register() take a type argument, which I find rather ugly.\n. We should add this to the FAQ 'cause it keeps coming up and I think we want to keep saying No. If you depend on the order of event notifications, then you probably shouldn't be using Otto. We want different components of your app to handle events without worrying about the source of those events. And they also shouldn't by worrying about other subscribers to those events. If the order of events matters, then there are interdependencies between the subscribers and Otto is hiding those interdependencies. In this case you're better off with strong coupling, like listeners or some kind of controller pattern.\n. @ajostergaard what's your use case? To detect bugs?\n. It's not a direct conversion. But Rx is capable of the same kinds of decoupling events as Otto.\n. Thus post from @kaushikgopal is a good place to start.\nhttp://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/\n. This will write\n  \"... Is class com.squareup.FooEvent registered?\"\nwould you prefer\n  \"... Is com.squareup.FooEvent registered?\"\n(either works for me, but the toString on Class is often surprising)\n. Interesting fact. getMethods() is not a strict subset of getDeclaredMethods()...\n  getMethods() returns public methods on listenerClass AND its superclasses.\n  getDeclaredMethods() returns methods declared by listenerClass.\nWe probably didn't realize that we were already getting methods from superclasses, but we were!\n. For what it's worth, this comment is pretty useless when 'expected' is your exception name.\n. needs a fail();\n. needs a fail();\n. needs a fail();\n. use \"ConcurrentMap\" on the left hand side?\n. Similarly?\n. Square copyright header? You can copy it from EventProducer.java.\n. useless, remove all of this documentation. The method name is sufficient\n. Similarly\n. I'm not a fan of this type of test for race conditions. It's way too difficult to maintain. I'd rather we just make the fix without a test.\n. Can you make error() take an element so the compiler can provide line number information?\n. ",
    "JakeWharton": "Good call. Added.\n. This was from upstream :)\n. We debated this early on and opted not to add it at the time. What we found was that in all of the cases where we thought this would be necessary we had either overlooked an unregistration point or had a bug in our code. For example, fragments and activities have onResume/onPause and views have onAttachedToWindow/onDetachedToWindow.\nDo you have a specific use case where you are seeing this not be enough?\n. Hey @jjNford,\nNot sure if you saw that we just merged #12 which allows for @Produce methods to return null. This means that whenever you have any long-lived classes which manage some state (e.g., last known location) they don't have to worry about registering and unregistering.\nWith this change a class should register immediately. When the @Produce method is called you can return null to indicate that you don't yet have anything to say. In keeping with the example, once a location is known you would post that event onto the event bus and cache the location (for any further calls to the producer method).\nIn regard to your follow-up question, we use another Square library called Retrofit which always gives us callbacks on the main thread to eliminate the possibility of race conditions. Since we have this behavior we always know that any posts that occur as the result of a network callback will always be on the correct thread. If you receive your callbacks on a background thread I suggest that you post a runnable to the main thread which takes the action of posting the event to the bus.\n. Hold for tests.\n. Could you not simply do:\n``` java\npublic class AsyncBus extends Bus {\n  private final Handler mainThread = new Handler(Looper.getMainLooper());\n@Override public void post(final Object event) {\n    mainThread.post(new Runnable() {\n      @Override public void run() {\n        AsyncBus.super.post(event);\n      }\n    });\n  }\n}\n``\n. We're going to address this soon with code-generation. It also avoids this magic behavior which can lead to undesirable results.\n. The next major version of the library will restore superclass@Subscribeand@Producefunctionality.\n. No, not yet. Haven't had time to work on the code-gen variant which would allow it's restoration without any performance impact.\n. Go for it. Don't forget about@Provideannotations either.\n. Thanks!\n. Exposing a minimal API is most certainly by design. It allows us to ensure that implementers cannot get themselves into trouble or use the library in an unintended way. By exposing onlyregister(Object),unregister(Object), andpost(Object)`, it's hard to not know what to do.\nIf we were to expose the four methods you list above, there would be ambiguity in what consumers of the library should use. We would have people incorrectly utilizing these methods to try and register their own objects and implementing the Producer and Subscriber interfaces (which would also have to be public).\nIf you haven't already, you should look at the code-gen branch as it's the future direction of the library. Basically the @Produce and @Subscribe methods are located at compile-time and classes are generated which can call the methods directly rather than through reflection.\n. I've had it open in a tab the whole time. Just been really busy!\n1. The API doesn't change so it shouldn't affect any existing consumers. If they drop in the 2.0 jar they'll just get the code-generated stuff on the next compilation. It will also fall back to reflection if code-gen'd files don't exist.\n2. Yes. This is an unfortunate limitation. I would hope that when doing a production release you are running a full build from the command line and thus would get all of the correct generated classes. The reflection fallback will help with the partial compilation case.\n3. I like using strings since the code that does that generation has to be bundled into the final .jar (and then into your app). While this isn't a big deal on the server side, for Android keeping the .jar as small as possible is a big deal to us.\n4. I probably started the branch before that patch was made which is why you see the regression. As you pointed out, I've been running stuff with -DskipTests the whole time so there's still a lot of iteration on this technique before it's ready to be released. I'll be sure to get that in though.\n. Well the scope won't work here because a lot of people will just be dropping the .jar into their libs/ folder and that needs to include code-generation. Even if they are using Maven for the build the code-generated stuff needs to be on the normal classpath to be picked up by javac.\nThe only way you could get away with not having it part of the final dependency was if it had its own maven plugin or was invoked on a different dependency (e.g., otto-codegen) via the maven-exec-plugin as part of the generate-sources phase.\n. Good catch. Thanks!\n. This is by design to ensure fast performance on Android and is documented behavior on the website. Version 2.0 will use code-gen to restore entire class hierarchy subscription but all of the Version 1.x releases will only look at the concrete class type for annotations.\n. I'm not sure what you mean that registration in a parent will not work. We have base fragments and activities which do registration on behalf of their extending classes which works. When you call this from a base activity you are still referring to the extending type and not the type of the class in which the call is made.\n. Yes. That is because in both registrations this always refers to an object of type ChildActivity even if in the IDE reports this as being of type ParentActivity in the former call. This is not a limitation of the library (beyond the documented omission of class hierarchy traversal) but it is just how Java works.\n. An @Produce-annotated method optionally provides an initial event and data to new subscribers.\nI feel this pattern is best illustrated with examples:\nLets say your application uses a service to monitor a devices location using various passive and/or active techniques. When an activity gets created, you want to display information relevant to the last known location. The service can then have an @Produce method which creates LocationEvent instances with the last known value. This way, when the activity registers on the bus you can assume that after that registration call has returned that it has also received a location event and can continue with displaying the data (e.g., querying a web service for nearby stores around the location).\nAnother good example is when you are making HTTP requests and keeping the response cached somewhere (say, a list of employees). Most people would kick off a request and have their activity directly act when a response comes in on some callback. Problems arise here when that callback happens after onPause and before onResume, as happens when a device is being rotated. What you can instead do, is publish an event when the HTTP call returns on the bus so that anyone listening receives it and also send it to the cache. Then you can have a producer which talks to the cache to produce the results of the HTTP call if any new subscribers are interested in the response. This way, when you pause your activity (and unregister) and have a the call return, once you resume (and re-register) your producer will get called and the activity will be notified.\nDoes that make sense?\n. Because when you rotate the phone and the fragments are recreated they would not be able to get an initial location value until the next location change event. @Produce methods are for supplying initial values to @Subscribe methods so that when they register on the bus they can immediately act on required information.\n. Yes. Typically you would register a @Produce method in something more long-lived than an activity as well (e.g., a service that is constantly listening for location updates and keeping track of the latest). You can also use things like singletons for this that are always on the bus.\n. We should provide a custom collection in the test with a known iteration order to make the test reliably fail. \n. Maybe ThreadEnforcer.NONE as a name would be better since there is really no enforcement or control performed at all.\n. @loganj https://github.com/square/otto/pull/32\n. What additional enforcement would we ever add? If we don't have a need for something now I'd rather not implement it.\n. Good eye. Thanks!\n. See also: c73d738de8f18d3925873947aaaf00ffe2a090f9\n. Er, this would indicate a seriously broken version of Dalvik since Class#getDeclaredMethods() has been available since API 1. Does this happen on emulators, phones, or both? Is the device running a custom ROM from an OEM (e.g., HTC Sense, MotoBlur, TouchWiz, etc.)?\n. @tyvsmith What would you expect the library to do in that case? Without a fundamental re-write we're forced to use reflection.\n. You can use a Handler to post on the main thread.\n``` java\nHandler handler = new Handler(Looper.getMainLooper());\nBus bus = / obtain bus somehow/\n...\nfinal String data = \"hello, world!\";\nhandler.post(new Runnable() {\n    bus.post(data);\n});\n```\n. Otto is designed to be simple and focused. Thread enforcement was a feature we added to avoid missteps in concurrency. It is not the responsibility of the event bus (which is purely a subscription/distribution mechanism) to know about or change the thread on which event propagation is happening.\nIf you really want this feature you can extend Bus like this:\n``` java\npublic class AndroidBus extends Bus {\n  private final Handler mainThread = new Handler(Looper.getMainLooper());\npublic void postOnMain(final Object event) {\n    mainThread.post(new Runnable() {\n      post(event);\n    }\n  }\n}\n```\n. Or better yet:\njava\n@Override public void post(final Object event) {\n  if (Looper.myLooper() == Looper.getMainLooper()) {\n    super.post(event);\n  } else {\n    mainThread.post(new Runnable() {\n      post(event);\n    });\n  }\n}\n. You'll need ClassName.super.post() otherwise you'll be accessing the\nRunnable super class.\nOn Apr 21, 2013 3:35 PM, \"Pierre-Yves Ricau\" notifications@github.com\nwrote:\n\nSlight changem instead of this :\nmainThread.post(new Runnable() {\n                @Override\n                public void run() {\n                    post(event);\n                }\n            });\nYou'll want this instead :\nmainThread.post(new Runnable() {\n                @Override\n                public void run() {\n                    super.post(event);\n                }\n            });\nie directly call super instead of going through the subclass\nimplementation again which is useless here.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/38#issuecomment-16747923\n.\n. If it's in the same process it will work.\nOn Oct 28, 2014 5:54 PM, \"mattblang\" notifications@github.com wrote:\nAny idea if this will work on a Wear device to talk from\nWearableListenerService to Activity? I completely understand what you are\ndoing in the extended Bus, but I can't seem to get it to work.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/38#issuecomment-60857915.\n. I'll fix Travis shortly.\n. Change has been reverted.\n. This is in on 2.0-wip and #66 is about to change the names.\n. As mentioned, use an anonymous inner-class or the like for now. This will be restored with v2.0 which is currently in development.\n. Travis CI is broken so I'll verify manually in a bit.\n. Yep. Sadly GitHub doesn't let you just change the target branch of pulls so closing and re-opening is the only way. Since I'm commenting I'll just grab it. Thanks.\n. If the changes do not modify the existing public API in any way then we can accept them into master, yes.\n. Looks good. One nit. I think we can get this in and make a release next week.\n. No, Travis has been broken for months.\n. Thanks. I think for 2.0 we'll switch the names. Bus should be the interface and OttoBus the impl.\n. I'll create a new branch for this to go into. As a breaking API change, this necessitates a 2.0. Rather than leave it open we'll create a long-lived topic branch for 2.0 development. This was we won't block the 1.x releases while it is still in use.\n. I merged a bunch of other pending pulls. Can you rebase this and create a pull request on the 2.0-wip branch?\n. It will ship with v2.0 which has no timeline. I'll be creating a branch for 2.0 work tonight, however. Hopefully in the next few months we'll get it released. Keep an eye on the branch (will be called 2.0-wip).\n. I have created the branch, yes. However, it probably wont work with\nAndroidAnnotations until the actual 2.0 release in a few months.\nOn Feb 14, 2013 11:36 PM, \"Atali\" notifications@github.com wrote:\nHello,\nHave you created the branch 2.0-wip ? If yes, can I use it right now with\nandroidannotations ?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/57#issuecomment-13595474.\n. You can switch the target branch when you create the pull request. I can manually merge to the right branch.\n. Thanks for the pull but we decided not to do this. @Publish doesn't make sense since it's not the point of publishing. post(Object) is where you publish. @Produce is a way to create an event where it otherwise wouldn't exist (hence 'produce').\n. Done on 2.0-wip.\n. This will come with 2.0 when class hierarchy walking is restored. This was intentionally removed for the 1.x versions.\n. I wasn't even aware 2.0 compiled, to be honest.\n. Yes, but it's a long way from actually being a shippable version of the library. It doesn't surprise me at all that there are problems with it. I wouldn't recommend using it until we move it to the master branch to dictate that it's relatively stable and pushing toward release.\n. Well I'm starting actual 2.0 development today or tomorrow so it should move forward quickly. As it exists now it's more of a proof-of-concept.\n. All issues relevant to its development will be organized on the 2.0 milestone of the project.\n. I need to rebase it first, though, since the branch is about 6 months out of date.\n. Nobody is working on it. We have no plans to release 2.0 at this time.\nOn May 28, 2014 12:24 PM, \"Csaba Koz\u00e1k\" notifications@github.com wrote:\n@JakeWharton https://github.com/JakeWharton what is the status of the\n2.0 branch? Did you reject to continue development in that way?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/61#issuecomment-44452825\n.\n. #135 will restore hierarchy walking.\n. We probably should hide dispatch better. What's your use case?\n. Any reason you aren't moving to the main thread in post(Object)?\n. Version 2 adds Handler and Producer interfaces to the public API as a consequence of using code-generation so I suppose there's the possibility of using your own. Will have to think on this a bit.\n. #108 is the solution for this. Guava is looking to implement annotations which map to Executors on which the callbacks get run. A @MainThread annotation could run on one which wraps the main thread Handler. Closing since this issue is now redundant with that one.\n. This change is essentially 100% mechanical and cosmetic.\n\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO] \n[INFO] Otto (Parent) ..................................... SUCCESS [0.810s]\n[INFO] Otto .............................................. SUCCESS [4.923s]\n[INFO] Otto Sample ....................................... SUCCESS [7.598s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 14.453s\n[INFO] Finished at: Thu Feb 28 10:25:13 PST 2013\n[INFO] Final Memory: 29M/81M\n[INFO] ------------------------------------------------------------------------\n. Development is now being done on the 2.0-wip branch for the next major version. I just submitted a change yesterday which normalized all of the documentation much like you did here. We opted to go with the <p>s on their own line. Thanks for the pull request, though. Keep an eye on that branch for development and target all contributions there in the future.\n. I'll switch the default to be platform-dependent. ThreadEnforcer.ANY (or a custom thread enforcer) should be used on the JVM.\n. Yeah. It didn't auto-close because it wasn't merged to master.\n. cc/ @swankjesse @pyricau. and @cgruber or @tbroyer if they have time :)\n. So, this is the code-gen branch rebased on the existing v2 work. I don't like this approach (started 7 months ago, when I was a naive, young school girl) because it tries to shove all of the generated code in the com.squareup.otto package to use package-scoped methods on BasicBus.\nLooking for initial feedback and guidance. I'll probably switch the generated code to live in the packages with the @Subscribe and @Produce-annotated classes with some fanciness to avoid exposing too many method on the BasicBus directly (perhaps through a class contained in the com.squareup.otto.internal package).\n. This also results in A LOT of generated classes. Perhaps too many to justify annotation processing. Maybe we need to strike a balance of code generation merely to locate the methods but still use Class#getMethod and invoke in them? Thinking a bit out-loud there but that approach seems like it will cut down the code generation by a lot, increate re-use with the reflection implementation, and still give us performance benefits...\nAnyways, as I said, looking for initial critique and guidance to the direction.\n. > We could even walk through the class hierarchy and include subscribers / producers from parent classes\nThis is a must.\n\nI would also like to look at how we can test the annotation processor.\n\nDagger and Butter Knife do this well I think. Did you have something else in mind?\n. Sounds good to me! Butter Knife would be a good place to experiment with that since it's small, fast, and has few tests\n. Would be nice to completely remove it. We already cache the class lookups so you only pay the penalty once. If we also ignore things in android.* and java.* in practice you shouldn't have too many classes to walk.\nIf we do go the route of having it configurable I'd prefer a builder with bus instances having immutable configuration.\n. The results of .equals will be a match and thus it will remove the right one.\nWe're actually still very much in the experimental stage of how we want to accomplish this. Going to close this pull for now.\n. @swankjesse \n. [INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO]\n[INFO] Otto (Parent) ..................................... SUCCESS [1.580s]\n[INFO] Otto .............................................. SUCCESS [8.491s]\n[INFO] Otto Sample ....................................... SUCCESS [17.618s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 28.820s\n[INFO] Finished at: Tue Mar 05 17:02:25 PST 2013\n[INFO] Final Memory: 29M/81M\n[INFO] ------------------------------------------------------------------------\n. I think you want Dagger...\n. Hi James,\nFirst of all, thanks for using and working on Otto. I'll tell you up front that as this pull request stands we won't be accepting it. Let me outline a few reasons why below...\n\nThis often leads to confusion and subtle threading bugs.\n\nThe thread confinement as it exists now eliminates this. We intentionally enforce the Android main thread by default because that is what you should be using 99.9% of the time. This will actually keep your code clean because you always know on which thread the interaction will occur.\nAs you mentioned, you can remove the thread confinement with the ANY strategy. This was intended for three places:\n1. Testing on the JVM\n2. Applications on the JVM\n3. Extremely rare cases where background threads need communication that never touches the UI.\nBack to your implementation, you say that by making the poster determine threading it can lead to subtle bugs. Your implementation suffers the same problem but inverted. Here's an example:\njava\n@Subscribe(MAIN) updateUi(UpdateEvent event) { /* do something */ }\n@Subscribe(BG) updateFilesystem(UpdateEvent event) { /* do something */ }\njava\nList<Users> users = userService.list();\nUpdateEvent event = new UpdateEvent(users);\nbus.post(users);\nCollections.sort(users);\nIn this example, my UI thread will get the ordering from the remote server whereas the filesystem callback gets a list sorted differently.\nThese types of things are what Otto was designed to eliminate.\nThe asynchronous nature of parts of this implementation also will now hold references to any objects posted for an unknown amount of time until the main thread dispatch can occur. If the object falls out of scope quickly, this prevents garbage collection.\nWe advertise Otto as a replacement for the traditional manger/listener model where you register a listener who invokes methods on you when \"interesting\" things happen. These simple method calls very obviously happen on whatever thread the manager calls them on. We want Otto to behave this way so that the threading decisions and movements are on you, the very same as it would be if you were doing this manually.\nAdditionally, as a user I think this API is too complicated which will likely lead to threading bugs due to lack of understanding of what each annotation option entails. The extreme simplicity of Otto's API and behavior is actually one of it's core features. It's intentionally a relatively \"dumb\" implementation so that you get zero unexpected behavior when using it.\nNow, what you have here isn't all bad despite everything I wrote. Before this I was already convinced that we needed a thread-moving bus implementation standardized. You can very easily write an extension of the bus which synchronously moves posts to an appropriate thread in about 20 lines of code. We'll likely include one in the next major version of the library.\nI encourage you to stay tuned for Otto 2.0's feature set. I think you'll find that it meets most of your requirements while still remaining extremely simple yet explicit.\n. We are undergoing discussions around this internally. It probably will end up like you wanted but with a bit less configuration and choice. Simplicity is an extremely high feature of Otto and we want to keep it that way.\nAre you using your version of Otto with these features you've implemented? I'm curious as to whether you use all of the threading options that you provided.\n. This is documented as not being supported. Also a dupe of #61 though its ticket name is awful.\n. There's no way to do what I think you want anyways (beyond ugly, epic hacks). v2.0 will restore class hierarchy registration which will hopefully eliminate all these problems.\n. Is EventTwo a subclass of Event?\n. That's one reason. The other is deep, complex hierarchies and 100s of methods.\nClass hierarchy support would solve both of your problems as far as I can gather. In the top example posting Event or EventTwo would go to the right place and in your simple subclass example posts of Event on an instance of One or Two would go to the right place.\n. Current best workaround is to use inner-classes. Highest priority is to restore class hierarchy support for v2.0. There's already a proof-of-concept branch that needs refinement into shippable code.\n. I just closed #72 which had that behavior. Can you read my (very long) response there?\n. Otto does not do this for you because it's purely an event distribution mechanism. Plus it's an absolutely awful idea to keep references to events inside something that you don't control.\nHowever, we allow you to do this yourself by having what we call a 'producer' method. This method allows you to represent the current state and will be called whenever new subscribers for a type are registered. I urge you to read the documentation on the website and check out the sample app for more info.\n. At runtime T is basically just Object which is why you won't see it producing events for whatever generic type you specify.\n. I vote for not supporting. This can come later if we determine it's really, really needed.\n. This is Java 6 only.\nOn Mar 31, 2013 11:55 PM, \"Pierre-Yves Ricau\" notifications@github.com\nwrote:\n\nWe won't have any concurrency issue here since it's in a thread local\nYou can merge this Pull Request by running\ngit pull https://github.com/square/otto py/cg-dispatch\nOr view, comment on, or merge it at:\nhttps://github.com/square/otto/pull/81\nCommit Summary\n- Replacing ConcurrentLinkedQueue with ArrayDeque\nFile Changes\n- M library/src/main/java/com/squareup/otto/BasicBus.javahttps://github.com/square/otto/pull/81/files#diff-0(11)\nPatch Links:\n- https://github.com/square/otto/pull/81.patch\n- https://github.com/square/otto/pull/81.diff\n. Switch this back to an ArrayDeque? Ain't nobody got time for pre-9.\n\nEPIC PR REVIVAL FROM THE DEAD!\n. > Registering will only find methods on the immediate class type.\nThis is purely a discovery contract. @Produce and @Subscribe methods will only be located on the top-most class in the hierarchy of the instances passed to register. This is as much a performance optimization as it is an observation that usage of the event bus rarely required subscription on base classes. We will be removing this restriction in future versions of the library (without compromising the API by resorting to ugly things like subscription by convention).\nOn the other hand, a posted event object's class hierarchy is walked and subscribers for any of its types will be invoked. The event hierarchy is much more important than the registration hierarchy. For example, while I may be interested in LocationEvents, other aspects of the system might be communicating with WiFiLocationEvents, GpsLocationEvents, or even MockLocationEvents across the bus. As a subscriber, I shouldn't be forced to know of every subtype of the type that I care about. This is polymorphism at its finest.\nMake sense?\n. No one is working on Otto, and I doubt it'll see many more releases, if\nany. So I wouldn't expect this to change. If you want to register in a base\nclass register a nested class.\nOn Mon, Jul 20, 2015 at 4:05 PM Dan J notifications@github.com wrote:\n\nWe will be removing this restriction in future versions of the library\n(without compromising the API by resorting to ugly things like subscription\nby convention).\nDo you still have plans to remove this restriction? I'm assuming not as\nthat could be disruptive (e.g. if somebody has accidentally @Subscribed\nin their superclasses, a new release would cause that code to run). FYI, I\ndon't think greenrobot's EventBus https://github.com/greenrobot/EventBus\nhas this restriction.\nIf you are going to keep the restriction, then it would be great if Otto\ngave a compilation warning for using @Subscribe in an abstract base\nclass. That would have saved me some time. :-)\nThis is as much a performance optimization as it is an observation that\nusage of the event bus rarely required subscription on base classes.\nFYI, two common situations where I've done this are:\n1) In a common base Fragment.\n2) In a common base REST integration test class (example highlights below).\nI just hit the second case now - I've been used to using EventBus instead\nof Otto, so I hit this limitation without expecting it.\npublic abstract class BaseIntegrationTest {\n```\npublic void setUp() throws Exception {\n    super.setUp();\n    bus.register(this);\n}\npublic void tearDown() throws Exception {\n    super.tearDown();\nif (bus != null) {\n    bus.unregister(this);\n}\n\n}\nprotected void resetLatch() {\n    latch = new CountDownLatch(1);\n}\nprotected void assertBusEventReceived() {\n    try {\n        logger.debug(\"Start waiting for event\");\n    if (latch.await(30, TimeUnit.SECONDS)) {\n        logger.debug(\"Bus event received\");\n    } else {\n        fail(\"Timeout waiting for bus event\");\n    }\n} catch (InterruptedException e) {\n    fail(\"InterruptedException while waiting \" + e.getMessage());\n}\n\n}\nprotected void login() {\n    // \n    assertBusEventReceived();\n}\n@Subscribe\npublic void authenticationCallback(LoginResponse response) {\n    if (response.isError()) {\n        fail(\"Request failed\");\n    } else {\n        latch.countDown();\n    }\n}\n```\n}\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/83#issuecomment-123013100.\n. > Otherwise are there ways to achieve this with the current version of Otto?\n\nFilter in the subscribe method.\njava\n@Subscribe public void onFoo(FooEvent fooEvent) {\n  if (fooEvent.id != this.id) return;\n  // Do stuff...\n}\n. Bottom line here is that if you need advanced filtering then an event bus is probably not the right model. You can either write something more custom or use a library with more advanced stream filtering capabilities like RxJava.\n. Dupe #57. We're working on a long-term fix but there's currently no timeline for it, sorry.\n. Fixed by https://github.com/square/otto/pull/90\n. Ignore Travis CI. Can you verify mvn clean verify passes? I think I see some checkstyle violations.\n. Yes. However this is far too big to review on a friday afternoon. I'll try my best to take a look over the weekend.\n. This is a lot of information that almost no one needs. Creating an instance of an object with a default constructor isn't hard. The javadoc covers the thread enforcer and name stuff. And as to injection, that's a topic which is entirely too detailed to put here. I'm really inclined to just close this the other issue and pray that people know how to instantiate an object.\n. Thanks for taking the time to do this!\n. This means you can no longer use it in base classes.\n. That is inevitable. You register/unregister in a base activity and base fragment. Eventually you will have one with no methods but a ton of other shared architecture.\n. Moving this responsibility to the developer was a design decision.\nEvent caching inside of a bus is a bad idea because it's a great way to\naccidentally leak references. With the current system it's perfectly fine\nto post events with references to Views, Contexts, Application instances,\netc. because they're distributed but not retained.\nFurthermore, an advantage of a producer is that you can update the produced\nvalue as frequently as you want without having to post an event. Or you can\nuse the fact that a producer is only called when something new is\nregistered to trigger other events or actions (such as checking freshness\nof data and kicking off a background refresh of data).\nOn Oct 18, 2013 3:32 AM, \"Anup Cowkur\" notifications@github.com wrote:\n\nCan we have an option to cache events? The last event can be cached and\nthe next time a subscriber registers itself, it will receive a copy of that\ncached event. We have the concept of producers but the developer has to\nmaintain his own cache and provide it to the producer. It would be\nfantastic if there were an option to automate this.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/97\n.\n. These proguard rules seem ridiculously general. But we don't use proguard so I'll just leave it up to the community to moderate.\n. We tried that. It was a horrible anti-pattern.\n. Everything that needs to register and unregister is either connected to a lifecycle directly or completely disconnected (and thus never unregisters). A weak reference is either just being lazy and not wanting to properly tie registration to a lifecycle or you are not in proper control of a lifecycle and are guessing when you think unregistration should occur.\n\nIn the example above the adapter doesn't have a direct lifecycle but it's bound to that of the view to which it is attached. The fact that you want unregistration at all implies there is a lifecycle.\n. > Isn't it as much of an anti-pattern to leak every object that subscribes?\nYes it is. So call unsubscribe on them. The Bus is a mechanism for leaking an object not a leak itself.\n\nAn event bus should never be used to keep an object alive and in memory.\n\nYou are right. That is why you must unsubscribe after the object should stop receiving calls to ensure that it can be garbage collected.\nThe Bus is a strong coupling and it is your responsibility to manage subscription to it. We are not interested in making the references weak because it falsely absolves your from your responsibility. We have explored this already in great detail internally.\n. To answer the original question, you should unregister where appropriate for that object. As far as I can tell there's two cases:\n1. An object is responsible for managing something long lived. It registers once and stays hooked up to the bus until the process dies.\n2. An object is tied to something in the app that has a lifecycle (even if that lifecycle is not direct). An example from a comment is an adapter which is an object that is tied to a view. The view has a lifecycle of onAttachedToWindow and onDetachedFromWindow. A view is sometimes managed by a fragment which has onResume and onPause. All views are inside of activities which have onResume and onPause. There are plenty of lifecycles here for you to latch on to.\nThere are hybrids of the first case (such as something tied to the user being logged in) but ultimately that's just an extra conditional.\nIf you can't fit your object into one of these two categories you should evaluate whether or not it's the right type to actually be on the bus.\nThe bus is solely a means of decoupling parts of your app. It's no different than the strong reference that a listener would impose.\n. That has nothing to do with Otto. The exception tells you what is wrong.\nOn Nov 26, 2013 7:25 PM, \"staryanwx\" notifications@github.com wrote:\n\nwhen click the button,throw this exception:\n11-27 11:24:44.515: E/DatabaseUtils(2951): Writing exception to parcel\n11-27 11:24:44.515: E/DatabaseUtils(2951): java.lang.SecurityException:\nPermission Denial: get/set setting for user asks to run as user -2 but is\ncalling from user 0; this requires\nandroid.permission.INTERACT_ACROSS_USERS_FULL\n11-27 11:24:44.515: E/DatabaseUtils(2951): at\ncom.android.server.am.ActivityManagerService.handleIncomingUser(ActivityManagerService.java:13082)\n11-27 11:24:44.515: E/DatabaseUtils(2951): at\nandroid.app.ActivityManager.handleIncomingUser(ActivityManager.java:2038)\n11-27 11:24:44.515: E/DatabaseUtils(2951): at\ncom.android.providers.settings.SettingsProvider.callFromPackage(SettingsProvider.java:577)\n11-27 11:24:44.515: E/DatabaseUtils(2951): at\nandroid.content.ContentProvider$Transport.call(ContentProvider.java:279)\n11-27 11:24:44.515: E/DatabaseUtils(2951): at\nandroid.content.ContentProviderNative.onTransact(ContentProviderNative.java:273)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/100#issuecomment-29357464\n.\n. This is a symptom of older versions of Dalvik doing reflection in bulk. It's not specific to Otto but any reflection-based operation. Something as seemingly innocuous as specifying onClick bindings in XML will trigger this too. See:http://corner.squareup.com/2012/08/getting-to-the-bottom.html\n\nI don't think there's much for us to do here. It's not a problem on modern runtimes and it's doubtful we'll ever do a code-gen version.\n. Yes, DeadEvent is the proper way to do this. If you need to know about the number of subscribers or who the subscribers are then an event bus is likely not the right pattern.\n. Thanks. Will deploy shortly.\n. Thanks! I'll deploy it later.\n. Nice find. This is a bit of an edge case, but one we indeed thought of when designing @Produce. The reason for this is that while post() is a one-to-many operation we don't want register()-->subscribe() to produce multiple invocations.\nTake for example this case:\njava\nclass A {\n  @Produce public CharSequence provideChar() { return \"char\"; }\n  @Produce public String produceString() { return \"string\"; }\n  @Subscribe public void onObject(Object object) {\n    System.out.println(\"GOT: \" + object);\n  }\n}\nWhile very obviously an extreme case, you can see where the problem lies. If there are multiple @Produce-annotated methods which subclass @Subscribe types it becomes ambiguous which to call (or it requires multiple invocations).\nThis is why we require explicit 1:1 mapping.\n. PRs should be against master.\nOn Mar 5, 2014 4:22 AM, \"grodin\" notifications@github.com wrote:\n\nThanks for the explanation, that makes a lot of sense.\nIf I wanted to submit a pull request to make this explicit in the Javadoc\nand website, I should target the 2.0-wip branch, correct?\n\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/106#issuecomment-36736893\n.\n. Android has a limit of 4000 characters per log string. Despite having newlines, this all comes as one string.\n. Ideas would be to add an uncaught exception break point in your IDE to inspect the exception at runtime.\n. We'll probably just track what Guava does. They're looking at annotation-based Executors last I checked. This could be easily accomplished with that mechanism.\n. At this time, we have no plans for adding this feature to Otto.\n. I don't like this approach, personally. I'd rather just walk up the class hierarchy until you hit java.* or android.* and then stop.\n. I meant no annotation, always walk up until you hit android or java.\n. We're not going an opt-in route. #135.\n. #119 .\n. Please ask questions like this on StackOverflow with the 'otto' tag. Thanks!\n. You can use Strings as your events. Or any object. You don't have to make custom classes.\n. The bus pattern has no control over the number of subscribers. If you need tighter control, use a different pattern.\n. General questions about event bus usage should be asked on StackOverflow using the 'otto' tag. GitHub issues are for future features and bugs. We have no plans to add any kind of filtering feature since a bus is a one-to-many publisher.\n. Merged manually. Thanks.\n. If the service was in a different process it wouldn't work. Post if you still have issues (after a year...).\n. Producers don't honor class hierarchy like posting does. What would happen\nif you were producing both A1 and A2?\nOn Jul 27, 2014 2:55 AM, \"Vincent Mimoun-Prat\" notifications@github.com\nwrote:\nHi,\nfirst, thanks for this library. It's great. I have a question, I don't\nknow whether this is intentional or a bug.\nMy Event hierarchy:\nclass A {\n  public static class A1 extends A {}\n  public static class A2 extends A {}\n}\nMy producer:\nclass Activity {\n  @Produce\n  public A1 initialA1Event() { return new A1; }\n// Register in onCreate, unregister in onDestroy\n}\nMy receiver:\nclass Fragment {\n// Never gets the initial A1 event from activity\n  @Subscribe\n  public void receiveAnyA(A event) {}\n// Register in onResume, unregister in onPause\n}\nWith the above code, the subscriber does not receive an initial A event\nwhich would be produced by the Activity. If I change the subscribe handler\nto receive A1 specifically, it works.\nI would have expected that my Fragment gets notified of the activity's A1\nas an A event.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/122.\n. That seems illogical and doesn't scale to many subclasses. If you want a\nproduced value for A you should produce it directly and reconcile the many\ndifferent subclasses into a single value. Otherwise it sounds like you'd\nwant a different mechanism for seeding initial state.\nOn Jul 27, 2014 3:07 PM, \"Vincent Mimoun-Prat\" notifications@github.com\nwrote:\nWhat would happen if you were producing both A1 and A2?\nI would have expected in that case that both A1 and A2 get delivered to\nthe subcribers of A.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/122#issuecomment-50287450.\n. Yep, use a real object. Here's an example: https://github.com/square/otto/blob/master/otto/src/test/java/com/squareup/otto/StringCatcher.java\n. Otto supports Java and Android currently and this would make it not. You can implement this yourself with a subclass that overrides post().\n. Another thing that I don't like about this is that it promotes producers from being a hidden implementation detail to something that's exposed first-class. Also, the choice to use the bus that posts from background threads is not supported and was for people who were consciously ignoring the thread safety that this bus assumes.\n\nIf you want something that's coupled in a such a way it's best to inject a dependency through whatever means and query what would have been the produced value directly.\n. No. AndroidAnnotations is welcome to offer the same functionality via an annotation-processed component. We aren't going to offer any kind of explicit integration, however.\n. Because that would be hiding programmer error. Using resume/pause should\nnever see this occur. Are you sure you are doing it properly?\nOn Oct 29, 2014 6:09 AM, \"tungle\" notifications@github.com wrote:\n\nAlready registered my activity at onResume() but still running into this\nexception when I un-register it at onPause().\nHowever, I'd like to suggest better error handling. If the object is\nreally not registered, why don't Bus just ignore it when there is a call to\nun-register, instead of throwing an exception and crash the app?\nCaused by: java.lang.IllegalArgumentException: Missing event handler for\nan annotated method. Is class com.company.activity.MyActivity registered?\nat com.squareup.otto.Bus.unregister(Bus.java:288)\nat\ncom.company.activity.MyActivity.onPause(SingleTripResultActivity.java:231)\nat android.app.Activity.performPause(Activity.java:5493)\nat\nandroid.app.Instrumentation.callActivityOnPause(Instrumentation.java:1251)\nat\nandroid.app.ActivityThread.performPauseActivity(ActivityThread.java:3171)\nat\nandroid.app.ActivityThread.performPauseActivity(ActivityThread.java:3140)\nat android.app.ActivityThread.handlePauseActivity(ActivityThread.java:3118)\nat android.app.ActivityThread.access$1000(ActivityThread.java:157)\nat android.app.ActivityThread$H.handleMessage(ActivityThread.java:1258)\nat android.os.Handler.dispatchMessage(Handler.java:102)\nat android.os.Looper.loop(Looper.java:157)\nat android.app.ActivityThread.main(ActivityThread.java:5293)\nat java.lang.reflect.Method.invokeNative(Method.java)\nat java.lang.reflect.Method.invoke(Method.java:515)\nat\ncom.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1265)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1081)\nat dalvik.system.NativeStart.main(NativeStart.java)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/127.\n. Because it means you don't really understand your lifecycle.\n\nOn Sun, Oct 16, 2016, 7:25 PM Usmaan notifications@github.com wrote:\n\nWhy is there no isRegistered method at least to check if it is registered\nor not?\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/square/otto/issues/127#issuecomment-254083664, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEZjCyJbAjbmo4k6md7Abco4Xu8DPks5q0rJ6gaJpZM4C0X4v\n.\n. This type of question is best suited for StackOverflow since it looks like a problem in your code. You can use the 'otto' tag to ensure its seen and answered by the right people.\n. The fact that you want to unregister a regular object means that it's fundamentally tied to a lifecycle and you should use that lifecycle to dictate unregister. Whether it's an Android lifecycle or a custom one tied to something else (e.g., network connectivity, user logged in, etc.).\n\nOtherwise, you wouldn't be unregistering.\n. Technically everyone could subscribe to Object and do that!\n. Not so sure about that: https://github.com/square/otto/blob/2735190645b7906680e8b373345904ec1763b033/otto/src/test/java/com/squareup/otto/outside/AnnotatedHandlerFinderTest.java#L191-L207\n. Performance, most likely.\n. It's also cached and the device landscape has changed performance wise.\n. You will have to consult with a lawyer on your end on what you can or cannot do.\nNot only are we (the developers) of this library ill-equipped to answer the question, but any statements we make might undermine or implicitly alter the license that has been applied. This is especially important to avoid since a large chunk of the code is actually copied from Guava which we do not have the rights for altering its license. Sorry I can't be of more help.\n. This is a reasonable approach. And it's probably time to add it now that no one is supporting pre-4.0 (and if they are they can deal with the extra few nanos or simply not upgrade).\n. We're just going to enable this for all types by default. Opt-in not necessary. See #135.\n. How are you registering such that you don't know if something happens\nmultiple times? That's usually an indication you are doing something wrong.\nOn Jan 13, 2015 8:26 PM, \"Sabi\" notifications@github.com wrote:\n\nAny object should be able to query the bus of its registration status.\nIf registered it should return true else false.\nThis would be really handy in avoiding multiple registration and\nunregistration calls.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/137.\n. The right thing to do here is probably throw an exception. I'm surprised it\ndoesn't, actually.\nOn Jan 15, 2015 5:59 PM, \"Sabi\" notifications@github.com wrote:\nThat's right, I was doing something wrong which I fixed later. But having\nan api to see if already registered wood avoid such scenarios\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/137#issuecomment-70197348.\n. You are describing a race condition and simply delaying by an arbitrary amount is not a safe fix. If the main thread handler has many messages to process, 5ms might not always be enough. The correct way to fix this is to either just post a Runnable to the main thread after the fragment transaction has happened (this will ensure the event fires after the fragments have been initialized) or simply to use another mechanism instead of an event bus that isn't prone to data loss.\n\nAn event bus, by nature, is a means of broadcasting information to anyone who is listening. If you can't handle data loss by missed events, perhaps a more traditional listener pattern would be more appropriate.\n. You can already do 1 by subscribing to Object. I'm not really sure we want to add 2. Why do you care about this information?\n. > Is there any reason the project hasn't been ported to gradle?\nBecause Maven works fine.\n. All I see from that diff is you reformatted the entire file and thus masked any changes you made.\n. The logging would have to be tied to an instance, not static. In general, we're not going to add something like this for two reasons:\n- You can already accomplish most of it by subscribing to Object which allows you to see every event.\n- Otto is based on Guava's EventBus and we'd like to stay relatively in sync conceptually and semantically (although we obviously deviate a bit here for Android use). If you can get them to add logging, we'd add it here.\n. Thanks for this, but Maven is easier in every way for developing and releasing on our part. You can use regular IntelliJ IDEA for opening the project if you need to work on it directly. Additionally we don't want to maintain two build systems so if we switched we would delete all of the Maven stuff.\n. An event bus is a publish-subscribe mechanism which means that everyone who is listening to a type (in this case VolleySuccessObject), is going to see the same events. If you want to only listen to the result for a specific page, you shouldn't use an event bus or wrap the result in an object that knows which page it is destined for and check that value in the subscriber.\n. Events are inherently transient. If you cannot afford for an event to be missed you need another mechanism in place.\n. Thread safety was removed when we constrained the bus to the main thread. After exposing the ability to relax the main thread confinement the safety was never added back.\n. Yes, we should make it safe.\n. A fix was merged.\n. No. In process only.\nIf you want multi-process you'll need two instances and some mechanism of serializing events between processes. Doing that automatically is beyond the scope of the library.\n. This is by design.\n\nOtto will not traverse the class hierarchy and add methods from base classes or interfaces that are annotated.\n\nI'll leave this issue open as a feature request, but it's unlikely to be fixed.\n. That is much more efficient than supporting inheritance!\n. That is an acceptable trade-off for us.\nOn Mon, May 23, 2016, 7:14 AM KleinerHacker notifications@github.com\nwrote:\n\nSorry, but if this problem won't fix the framework is not usable with\nandroid annotations.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/150#issuecomment-220952308\n. This results in a strange coupling between the event publishing site and the subscribers. The purpose of a bus is to decouple the two but this API requires that a publisher know about specific subscribers types.\n\nIn addition to that, I see two additional problems with this API:\n- It does not have any means to differentiate two instances of of the same type so that only one received an event.\n- Its presence would open up the door for all kinds of additional types of filtering requests for APIs.\nFor an event bus which is supposed to simply exist as a central hub of message passing, the best way to filter is to have the subscriber decide whether or not it wants to react to an event based on some conditional. This is infinitely scalable and adaptable to whatever requirements an individual app has vs. the limit nature of filtering here.\n. Squashed and merged. Thanks!\n. No? Otto is just a glorified map of event classes to a list of subscribers. It will work on Android and on Wear but not between the two.\n. That lets events go from the phone to the wearable device which is a whole\ndifferent thing that we don't support.\nOn Wed, May 27, 2015, 12:11 AM Haider notifications@github.com wrote:\n\nRight thanks a lot Jake, I found another library here:\nhttps://github.com/tajchert/BusWear\nI was wondering why there was a specific library only for Wear. Thought\nmaybe there is an issue with current libraries?\nThanks a lot for letting me know so quickly, I use otto quite a lot in\nAndroid, want to see how it will perform for sending and receiving sensor\ndata within the wear module.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/156#issuecomment-105788842.\n. Very unlikely. There's very different semantics for cross-device\ncommunication.\n\nOn Wed, May 27, 2015, 12:25 AM Haider notifications@github.com wrote:\n\nRight makes sense, I might actually end up using that then. Are you going\nto support that in the future?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/156#issuecomment-105796185.\n. The access to these maps is subpar. They call containsKey and then get. This should be changed to a get and a null check instead (which then would trigger load).\n. I still don't like the triple map operations. Ideally on a cache miss in the map we would only require a put, not a put plus a second get. I think we just need to refactor how the cache works in order to prevent this.\n. I'll be sure to look this week. Thanks for following up.\n. Squashed and merged.\n. Thanks for doing this.\n. I'll do it this week.\n\nOn Tue, Jun 16, 2015 at 8:26 PM ashoykh notifications@github.com wrote:\n\nThanks for being so responsive!\nDo you have an estimate for when 1.3.8 will be available?\nThanks!\nOn Mon, Jun 15, 2015 at 10:57 PM, Jake Wharton notifications@github.com\nwrote:\n\nThanks for doing this.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/pull/157#issuecomment-112304245.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/pull/157#issuecomment-112610349.\n. It's definitely there: http://search.maven.org/#artifactdetails%7Ccom.squareup%7Cotto%7C1.3.8%7Cjar\n\nPaste the full output (potentially with --stacktrace). This is a Gradle usage question unrelated to Otto, though, which is usually more appropriate on a forum like StackOverflow where many more people have a change to see and answer.\n. I believe this approach could be foiled by triggering the initial class loading of Otto's classes on a background thread rather than the main thread. Granted, this is unlikely to occur in practice.\nWhy do you wish to remove the Android dependency? We've all but declared Otto an Android-only library.\n. Caused by: com..setLocation(HomeFragment.java:984)\ncom..HomeFragment.setLocation(HomeFragment.java:955)\ncom..HomeFragment_.access$001(HomeFragment_.java:36)\ncom..HomeFragment_.setLocation(HomeFragment_.java:249)\nThis is a problem in your code throwing an exception in the subscribe method.\n. Size is not relevant to Otto. Object references are passed and they are always the same size, regardless of the object size.\n. This is perfectly fine (if only a tiny bit strange). There should be no issues.\n. > they will all be triggered\nYes. They are the same class. It doesn't matter whether you reference it as A.Success, B.Success, or CommonLogic.Success they are all the same class. When you subscribe you are subscribing to the same class, Success. If you want different classes, you'll have to create different subclasses of Success.\n. We explored this and determined it was an anti-pattern. If you need to unregister an object there will always be some signal that it should be done. Otherwise the object can just remain subscribed for the lifetime of the process. You can even fire an event on the bus to inform objects to unregister as a decoupling mechanism if they are far removed from the lifecycle.\n. No. Why do you need such an API?\n. If you use matching lifecycle callbacks for registration there should be no need to defensively check against registration. Since Otto is instance-based, if you are truly worried about registering twice (because you are not using matching lifecycle callbacks) you can keep your own 'registered' boolean in the instance.\nWe spent a lot of time evaluating the need for a method which checks very early on (and now a few years ago), and it was determined that this is defensive check was an anti-pattern. The need to check if an object is registered was a defensive call that was always the result of a bug in handling registration, rather than something actually being registered twice legitimately. And in that rare case, as I said above, you can maintain your own flag.\n. Given the information provided, this has nothing to do with Otto.\n. Produce never runs as a result of an event being posted. It runs when a\nsubscriber is registered for that event type to provide an initial value\nfor that event.\nOn Thu, Oct 29, 2015, 6:40 AM hellosad notifications@github.com wrote:\n\nAt the beginning of program the method with @Produce\nhttps://github.com/Produce will run by itself , not once sometimes.\nwhat is it to do?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/172.\n. This is a breaking behavior change and a consumer change which cannot be added and released without a major version bump. As no one is really working on Otto, this is unlikely to be merged and released any time soon. If we were to do a major version bump, we would want to include a lot more changes.\n. We have no plans for this, no. The library is meant for pure publish/subscribe and higher-level operations like filtering and combining are pushed onto the consuming code.\n\nConsumers of events can filter events directly using normal mechanisms of Java:\njava\n@Subscribe public void onAnswerAvailable(QuoteReceivedEvent event) {\n  if (!\"GOOG\".equals(event.symbol()) && !\"AAPL\".equals(event.symbol()) {\n    return;\n  }\n  // Normal event handling code.\n}\nYou can also use a mechanisms where filtering is a first-class citizen like RxJava:\njava\nticker.quotes()\n    .fitler(q -> \"GOOG\".equals(q.symbol()) || \"APPL\".equals(q.symbol()))\n    .subscribe(q -> doSomethingWithQuote(q));\n. Yes. Just be sure to unregister at some point (based on activity lifecycle maybe) or your may leak the view and thus the entire activity.\n. These libraries do not interact. Try a clean build or disable/update your ProGuard config as it might be erroneously stripping classes.\nAs this is a usage question and not a bug or feature request, StackOverflow is a better place for these types of general questions.\n. You haven't provided enough information to make this report actionable, but in general it sounds like a usage problem and not an actual library bug. Please post this to StackOverflow with the 'otto' tag, along with more details about exactly what you are doing. This issue tracker is for feature request and bugs in the library itself.\n. This is a usage problem, not an Otto bug. Sounds like you either need a null check or you need to unregister when the UI goes away (or defer registering until the UI is available).\n. If you have further problems, StackOverflow with the 'otto' tag is a much more appropriate place to ask usage questions. There's many more people there helping and it serves as an archive for future people searching for help.\n. Is the second activity registered before the first one sends the event?\n. Probably, yes. Otto is not designed for communicating between activities. Since only one is displayed on the screen at a time, it's unsurprising that events get lost when each is registering and unregistering as their visibility status changes. You're much better off using the Intent system and activity result system for passing data as part of navigation flow. An event bus is for distribution of information and it should be assumed that events could always be missed.\n. All observables are producers in some sense as subscription is what causes\nevents to start flowing to the subscriber.\nOn Sun, Jan 24, 2016, 9:13 AM Tolriq notifications@github.com wrote:\n\n@swankjesse https://github.com/swankjesse Is there any advice / tips on\nthe producer pattern (@Produce https://github.com/Produce) with RxJava\ncan't seem to find related docs ?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/pull/181#issuecomment-174301246.\n. This class is included in the released jar so any classloading issues will be specific to your app, likely related to multidex.\n. Your build system is somehow including Otto twice. This is a problem with your build configuration somehow.\n. You registered it twice or you have two instances of the fragment.\n. Dupe of #187.\n. The default behavior verifies that the main thread is used, so you can just call new Bus().\n\nYou can see the implementation of the main thread enforcer here: https://github.com/square/otto/blob/a85ae721d337d9129eb49f5dc90c8e65d49d48ca/otto/src/main/java/com/squareup/otto/ThreadEnforcer.java#L43-L50. A similar approach would be used for other threads as well.\n. Thread enforcer doesn't allow thread movement. Just validation.\nOn Fri, Aug 12, 2016, 12:18 AM chokhmah notifications@github.com wrote:\n\nThanks.\nMy goal is to ensure that the Bus#post() will be run on main thread,\nbecause there are some method/class that calls Bus#post on a background\nthread. I used ThreadEnforcer.ANY and ThreadEnforcer.MAIN but it throws an\nexception when then on calling is from different thread. Also The bus I\ncreated is a singleton.\nMy current implementation is I put Bus#post() inside a Handler#post() to\nmake sure it is on the main thread. I am also thinking if I can customize\nthe ThreadEnforcer to run the Bus#post on the main thread so that I won't\nuse the Handler#post in handling the Bus#post.\nDoes my current implementation correct? or am I overthinking the approach\non ThreadEnforcer?\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/square/otto/issues/190#issuecomment-239357655, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEVD2m7V_eQIRPX6DG1hIvzJY6T5Qks5qe_QFgaJpZM4Jiwo9\n.\n. This seems like a duplicate of #139.\n. This project is built with Maven, not Gradle. You can use an IDE like IntelliJ IDEA to import it.. Otto is a jar, not an aar, so we cannot ship ProGuard rules. There are no plans to ship an aar.. No. All subscribers for an event must be called before the next event is delivered to any subscriber.\n\nIf you need more complex composition then you should look at RxJava which allows composing streams instead of events.. He drives the bus on the Simpsons.. I think you need to file this on SugarORM instead.. This has nothing to do with Otto\nOn Sun, Nov 19, 2017, 1:14 PM Kristaps89 notifications@github.com wrote:\n\nI disabled \"Instant run\", so I can fix this error.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/square/otto/issues/201#issuecomment-345537470, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEESac-EqoLs6e78eoc_hl0eTjzTVjks5s4HABgaJpZM4QiZ80\n.\n. The version of Gradle cannot affect the behavior of a library. If you think you have a bug please provide a failing test case or executable sample which demonstrates it. Otherwise we have no idea what's going on.. This project is no longer actively maintained, but this isn't enough information to determine a cause of the problem. Otto doesn't interact with either of those libraries directly so I have a hard time seeing how they could affect it. Perhaps try posting on StackOverflow?. This project is not under active development and has no plans to be.. Sounds like you're using a non-main thread confined bus and touched a view as a result of an event sent from a background thread. Either check and post to the main thread in your subscriber or switch to a main thread bus.. Event will never be null here so we can remove this section of code.\n. Line might be too long. We'll see.\n. Indent\n. The original was like this which we intentionally reverted to speed up unregistration. 'tis a shame to have to re-introduce the slowness (relatively speaking).\n. Class name needs Test suffix\n. Space after for\n. Our convention is to have annotations on the same line as the method declaration provided they are short enough. I think about every occurrence in this file meets that criteria.\n. Space after if\n. Space after //, capitalize first letter, period at the end.\n. Space after Runnable before {\n. Space before {\n. Space before {\n. Sadly, no. Our checkstyle needs to be much more strict it would seem!\n. Done.\n. JavaDoc is not descriptive of behavior.\n. Drop the package-private comment. End sentence with period. Space before */.\n. Capitalize first letter.\n. Actually can we drop this method altogether and just make the variable package scoped?\n. Docs for this whole class need moved from Bus.\n. This is a breaking API change. Can you reopen this against the code-gen branch for inclusion in v2.0?\n. These should go on the same line as the method declaration.\n. Toss this up onto the same line as theclass.\n. What happened to the empty lines in this header?\n. I don't remember why I ever did this last year when we started code gen... dumb me.\n. Now I do. Still dumb.\n. We might want to make this also have anObject... argsand doString.format(message, args)` to clean up some of the code above.\n. We need to add a note here before I forget. Something like:\n\nNote: If you post an event from within a subscribe method the events will not be delivered synchronously. They will be enqueued for  after the current event event's delivery has completed.\n. I will have to double-check today. But I think you are correct in that it happens for all methods.\n. Agreed. The rest is noise that distracts from Otto itself.\n. That works for me too. It's simple, clean, and most importantly doesn't distract from what you should actually be reading.\n. Just need a period after the </pre>.\n. Nevermind.\n. You need the \".\" otherwise \"javasucks.Class\" and \"androidsucks.Class\" names will incorrectly return true.\n. Is this block copied from the Guava implementation? We should attempt to revert back to their code as closely as possible.\n. nit: space before :\n. uuuuber nit: this should only use two space indent\n. ",
    "pforhan": "Note that we're still logging producer and handler via toString. \n. Quick question: Is this for non-Android uses of this library?  I was pretty sure that android apps are responsible for only using one thread, and by convention this is the app main thread.\n. I almost get it, but why not make the factory methods now?  Aren't we going to have to switch at some point otherwise?\n. I'm sort of with @JakeWharton on this, I don't think we should do this until we need it.  We can always bump the version again.\n. Do we have this in the code base?  Would make a great sample.\n. We just discussed this in the G+ community, but this feature will return when the code generation branch is merged to master.  You can try it now if you like.\nThe link describes how you can do this with the current master build.  Register anonymous classes on the bus, or override your annotated methods (keeping all the annotations) in the subclasses.\n. Travis says:\n```\n /home/travis/build.sh: line 101: android: command not found\n$ android update sdk --filter \"$TOOLS\" --no-ui --force\n/home/travis/build.sh: line 104: android: command not found\nThe command \"android update sdk --filter \"$TOOLS\" --no-ui --force\" failed and exited with 127 during before_install.\nYour build has been stopped.\n```\nDo we need to do something to fix that?\n. @JakeWharton, @adennie put the blank lines back in.  This looks great, it will simplify a bit of downstream code for us.\n. @ajostergaard Otto will post com.squareup.otto.DeadEvent events if there were no subscribers, if that helps.\n. Pull requests welcome.\n. My comments aside, I don't disagree with @JakeWharton -- especially since we have ThreadEnforcer info already.\n. I think this is related to a similar bug I see with subscribers in Java 8 -- otto's registering bridge methods.\nSee https://bugs.openjdk.java.net/browse/JDK-6695379 and http://mail.openjdk.java.net/pipermail/jdk8-dev/2014-January/003955.html\nOtto should exclude any bridge methods -- method.isBridge() tells this.\n. ```\nTests run: 49, Failures: 0, Errors: 0, Skipped: 0\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO] \n[INFO] Otto (Parent) ..................................... SUCCESS [0.454s]\n[INFO] Otto .............................................. SUCCESS [12.939s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 13.553s\n[INFO] Finished at: Fri Apr 04 15:34:56 CDT 2014\n[INFO] Final Memory: 26M/115M\n[INFO] ------------------------------------------------------------------------\n```\n. isBridge supported since 1.5, so that shouldn't cause trouble for older JDKs.\n. No, I don't think so.  The method's been around since JDK 5, and it was basically a recent change to class file format to copy their annotations over.\nAlso, no one uses this branch.  That being said, we should make a change for master that addresses the same problem on @Produce as well, we even have an issue about it.\n. I actually have a fix for this, somewhere.  Otto discards the message and doesn't really link it, either.\n. Ah, it's against a different branch, but I should be able to adapt it.\n. Drat, sorry I didn't port this down from the branch where I applied it.  Nice that you have tests.  See also 7e10ebff9\n. This generally LGTM.  I see you're also checking isSynthetic -- is that necessary?  It seemed like isBridge was sufficient, but I'm not well enough versed on the finer differences here.\n. LGTM.\n. I believe mockito extends the specified class so it can mock.  Otto does not support @Subscribe methods in superclasses.\nYou may be able to work around this by registering on the bus with a custom object in the constructor, the same advice given for this problem in the general sense...\njava\npublic TestListener(Bus bus) {\n  bus.register(new Object() {\n    @Subscribe public void receiveEvent(TestEvent event) {\n      realReceiveMethod(event);\n    }\n  }\n  public realReceiveMethod(event) {\n  }\n}\nThat may be mockable then.  Still, it's almost like you're testing the bus more than anything.\n. This sort of thing is generally better to ask on StackOverflow.\nWhat was your subscription method like?  I'd bet if you used an Integer as a parameter it would have worked -- I don't know if Otto is clever enough to look at unboxing values.\n. Change \"such returns\" to \"null values\"\n. As shown by the missing fails, split this method up and just use expected=IllegalArgumentException.class.  Even with the method boilerplate, should cut down the amount of code, and is much easier to read.\n. (Not related to this pull) Huh, that's a little odd.  I guess it keeps things simple, but I could see some use cases for producing something abstract or implementing an interface.\n. Would it be simpler to just say renamed here, instead of adding one, removing the other?\n. How about `By default, interactions with the bus must be on the main thread.  You can change this by specifying a ThreadEnforcer'\n. May as well link to Dagger on github here.\n. I think the class here is misspelled.\n. unenforcedBus instead of unsherriffed_bus? or anyThreadBus?  I don't know, just want to make sure it's clear.  Also, use standard Java naming conventions (camelCase)\n. Since this is what that issue was complaining about, why not just beef up this sentence and kill the rest?\nhtml\nThese examples assume you have a <code>Bus</code> instance in the variable <code>bus</code>.\nBecause a bus is only effective if it is shared, we recommend obtaining the instance through injection or \nanother appropriate mechanism.\n. You could easily implement a Queue instance that delegates to three queues internally.  Then, you could use one aggregated object to push to or pull from the Queue.  And you could keep using the same instance since this is thread-locked (or you could use a threadlocal to support multiple threads).\nI do worry about these three getting out of sync.\n. Maybe I'll make a little pull, we can see what that looks like.\n. You missed what I said.  We'd reuse the object, over and over again, every time we'd interact with the queue.  Behind the scenes, that queue would split the object up and place it in the three queues.\n. Well, there is that.  What do you expect, that I'd read code?\n. ",
    "jjNford": "That makes sense in terms of playing nice and registering/unregistering.\nI'm wanting to incorporate Otto in objects running tasks on other threads (like data models).  This allows android to handle on configuration changes and gives me the ability to use a producer to get the last model results if they happened to be returned on the screen rotation.\nLooking ahead though I feel this won't work great because the models/objects will have to be unregistered on the subscriber callback.  This was just an idea, not a must...\nWould love to hear your thoughts on this.\n. No worries, I just have a handler in my libraries activity class with a getActivityHandler() call - I just reconnect here, works fine.  Right now I'm having more trouble with ABS than anything - currently haven't found a solution.  On 2.3.6 & 2.3.7 devices items added to the bar from the onCreateOptionsMenu in a SherlockFragment (used in a SherlockFragmentActivity) cause the application to crash.  We could take this conversation off GitHub if you want (jj.n.ford at gmail.com).\n. ",
    "jasonparekh": "Nevermind, I misunderstood.  If the superclass has an annotated method that the subclass does not override, then it will still be found.  If the subclass overrides that method without the @Subscribe annotation, then there will be a problem.\nIn the case of AndroidAnnotations, it doesn't override methods so things should be OK (I probably have a bug elsewhere.)\n. ",
    "edenman": "Tests added.\n. @JakeWharton could we do this when codegen is added, since it happens at compile time?  I'm assuming the annotation processor gets generic type information...ignore me if it doesn't.\n. ",
    "eburke": "Limiting this annotation to public methods is an explicit design decision. We'll update the docs to make this more clear; we are considering even failing fast if a non-public method is annotated.\nReason - a future version of Otto may use code generation rather than runtime reflection. This will only work with public methods so we don't want to limit our flexibility to move away from reflection in the future.\n. ",
    "screendriver": "Thanks a lot for that information.\n. Thanks. He also mentioned that some thing will come in release 2.0. Unfortunately the last commit was 3 months ago :cry:\n. ",
    "scompt": "True, I can't think of any reason why the async bit can't be moved to the post side of things instead of dispatch. I'll test it out and close this issue if I can't find any problems. Thanks.\n. Yep, seems to work. Thanks for the pointer.\n. ",
    "naixx": "@JakeWharton, can you please tell, what to expect?\n. ",
    "pyricau": "Just came across this :) . I'm interested in knowing more about that \"soon to come code generation\". Any pointer :) ?\n. If you're willing to work with experimental / unstable stuff, @JakeWharton actually wrote a POC on a branch. Here is a usage example: https://github.com/pyricau/CleanAndroidCode\n. AndroidAnnotations now correctly integrates with Otto, see https://github.com/excilys/androidannotations/pull/526\n. Slight change, instead of this :\nmainThread.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        post(event);\n                    }\n                });\nYou'll want this instead :\nmainThread.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        AndroidBus.super.post(event);\n                    }\n                });\nie directly call through super instead of going through the subclass implementation again which is useless here.\n. Just a quick comment on this:\n\nSince we cannot guarantee the precense of annotation-generated classes at runtime, a reflection implementation is provided as a fallback which behaves exactly as the v1.x Otto Bus does.\n\nIs that really a good idea? If crap happens and annotation processing is disabled, you might not notice and release a crappy app. I'd rather have it fail, and allow for an alternate configuration to allow the reflexion approach.\nRegarding class generation, that was to be expected.. Is that really a problem? Do you fear going over the 3 million methods limits :-P ?\n. @swankjesse Obvisouly 1. is ruled out here, so this leaves us with 2.\nWhat it really means is that you want to be able to use reflection on dev runs, and code-gen in releases.\nMaybe we could detect that somehow (when dagger is used on Android), by checking the Build.DEBUG field or looking for the debuggable attribute of the manifest. The problem with Build.DEBUG is that its package isn't know at compile time, it needs to be accessed via reflection and you need to know the app package. And it may even not be here at all...\n. @tbroyer is right, we could generate only one class for all subscribers / producers of a given class. We could even walk through the class hierarchy and include subscribers / producers from parent classes. The problem then is to load and call the corresponding methods at runtime. Is it faster to call methods via reflection or to load classes via reflection and then do a direct call?\nI would also like to look at how we can test the annotation processor. We can definitely write junit tests that call the compiler and start the annotation processor and verify a few things regarding behavior of the generated classes and most importantly that verify extra compilation errors (\"method must have one parameter\" etc).\nI have a few ideas on how to test that, but if you know of other projects that has been doing that, I'm really interested in having a look and see what are the different options.\n. ## Some more TODOs\n- [ ] Write tests for the generated code\n- [ ] Write tests for the compile time validation\n- [ ] Move class generation to the annotated class package instead of com.squareup.otto\n- [ ] Write nicer generated code (moar imports / less FQN, no \"extends Object\")\n- [ ] More signature checks\n- [ ] Handle annotations in parent classes\nI don't think there's a need for the Target class. This behavior should be generated in subscribers and producers, and would remove the needs for generics here.\n. Yes. I checked butter-knife and it uses the invoker plugin to run a maven compilation on a small project and check if there's a build failure. It's great, but we can do better. We can write junit tests that call the JavaCompiler class and collect and assert diagnostics, check generated classes... without any maven plugin involved :) .\nThe main benefits are:\n- Fast tests that can run in the IDE (and even run continuously with infinitest)\n- Finer grained asserts (not just failure vs success, but even \"compilation error or warning right here\", assertion on the error message, etc)\nI'm fine with starting with the invoker tests though, since we already know how to write them. At some point I'd just like to have a \"test fwk for annotation processor\".\n. Another open question : we provide reflection as a fallback strategy. We didn't support walking up the class hierarchy via reflection for performance reasons. We will support that for code generation. What should we do for the fallback strategy ?\nI think we should either:\n1. Walk the class hierarchy at runtime for the fallback strategy as well, and consider this fallback strategy to be a \"dev only\" feature\n2. Remove the fallback strategy, to make sure users have a well configured annotation processor from the very beginning\nI think we can go with 1. if there's a way to make sure reflection is disabled for production builds. Something like :\njava\nBasicBus bus = new BasicBus();\nbus.enableReflectionFallback(BuildConfig.DEBUG);\n. Do we have a use case for that? On Android at least I think it's rare to have decoupled background components. Most of the background work happen in one place and then we're back on the ui thread.\nAFAIK anyone can create its own enforcer, so this only make sense if it's a common use case:\njava\nBus bus = new Bus(new ThreadEnforcer() {\n    @Override public void enforce(Bus bus) {\n      if (Looper.myLooper() == Looper.getMainLooper()) {\n        throw new IllegalStateException(\"Event bus \" + bus + \" accessed from main thread \" + Looper.myLooper());\n      }\n    }\n});\nOnce you go down that road, you may even want to specify which thread should be enforced...\njava\nfinal Thread enforcedThread = ?\nBus bus = new Bus(new ThreadEnforcer() {\n    @Override public void enforce(Bus bus) {\n      if (Thread.currentThread() == enforcedThread) {\n        throw new IllegalStateException(\"\");\n      }\n    }\n});\nDoesn't play nice with thread pools though..\n. The annotation processor gets generic type information. It get can as much information as you can get by reading the java code (except the code within methods of course).\nWhen reading this:\n``` java\npublic class MyClass {\nT lastEvent;\n\n@Produce\npublic T produceEvent() {\n    return lastEvent;\n}\n\n}\n```\nI don't see any information about the kind of object this might produce. Of course, if we now create a MySubclass extends MyClass<String>, that's another story..\n. This won't be possible with the current Otto version because we do not walk the class hierarchy.\nWith 2.0 we will switch to code generation and take parent classes into account. I know this use case is technically feasible, I don't know yet how easy it's going to be.\n. I don't think so. \n``` java\npublic class MyClass {\nT lastEvent;\n\n@Produce\npublic T produceEvent() {\n    return lastEvent;\n}\n\n}\npublic class MySubclass extends MyClass {}\n```\nif I register an instance of MySubclass, I do not need any type argument, we can already determine (both at compile time and runtime) that it's going to produce a String.\nI'm not sure there's enough value to implement this though. \n. Woops, added idea files, sorry, let me fix that and push force.\n. Fixed.\n. API level 9. Ok.\nPR updated, replaced with LinkedList.\n. I don't read GitHub notifications.\n. close close close. Sorry. Bad idea.\n. LGTM\n. Nice. I bet this JDK8 change is going to break many libraries.\n. return should be one line below. The sample app crashes (wrong missing subscriber exception) as soon as you pause the app.\n. Bug! Always returns fallbackFinder once a finder has been cached, ie typeFinder != null\n. I'll do that as a separate PR.\n. Now that I think of it this could be backed by just one array, each \"entry\" using 3 slots in the array. \n. Just assign that to a candidate in a programming interview! I'm kidding :)\n. We do not want to create any aggregated object. That's the whole point of these 3 queues: not creating useless intermediary objects that will be GCed immediately. As per thread locals, Otto is now single threaded so it's not necessary :) .\n. ",
    "pzmudzinski": "Any news about this issue? \n. Is it fixed in AA 2.7.1? Or is it fixed in latest Otto release? \n. ",
    "shrift": "I believe I have run into this issue as well... Using AndroidAnnotations to enhance a fragment, and also to inject several fields (including Otto), I find that despite calling register in the enhanced fragment my @Subscribe method does not receive any events. Indeed, all of those events end up in the DeadEvents listener... I had read that in theory as long as AndroidAnnotations does not override the @Subscribe annotated method, the events would still get delivered, but it seems they are not. Perhaps this is due to the fragment being created in xml (where you have to reference the EnhancedFragment_ class)?\nAnyways, very lengthy round about way of saying, I would love for \"seamless\" integration of Otto and AndroidAnnotations.\nI'd be happy to help if there is any way I can.\n. Ah, fantastic. Thanks Jake!\n. ",
    "scottagarman": "Jake, has the superclass @Subscribe and @Produce functionality been restored? I can't seem to get it to work in versions after 1.2.1.\n. ",
    "atali": "Great !!!!!!!!!!!!!!\n. Hello,\nHave you created the branch 2.0-wip ? If yes, can I use it right now with androidannotations ?\n. Ok thanks .\nMeanwhile the 2.0 next release, I am gonna patch otto with https://github.com/square/otto/pull/15.\nI keep an an eye on the branch!\n. ",
    "johncarl81": "This is for Android uses.  I would agree that the vanilla usage of Otto would be registering on the UI thread.  That being said, I believe there are uses for registering subscribers and providers in background threads, and you certainly can at this point with the library.\n. Ping.  Just wondering what you think.  Can I clarify anything?\n. I didn't realize how far you went with the code generation in that particular branch.  I have to say that I like this move.  Your technique allows Otto to dovetail without API changes* into Transfuse as a direct replacement for the EventManager.  It's also extremely fast without reflection.  I also whole-heartily agree with your approach to keep the API minimal.\nOn the Transfuse side I now have a default globally scoped instance of the Otto bus which Transfuse automatically registers @Produce and @Subscribe annotated methods.  I plan on replacing Transfuse's EventManager with it entirely.\nIf you haven't checked out Transfuse, I am using the same technique to generate code during compile time.  In fact I was aiming to do this for Otto, hence the request for the additional API extensions.\nA couple of thoughts I had while integrating Otto into Transfuse:\n1.  How do you plan to deal with already compiled library projects that use Otto?\n2.  Are you aware that you need to compile the entire source tree at once to generate a proper Finder class?  Personally I have not found this a problem as I always do a mvn clean package, but some people may have problems.\n3.  If java code generation becomes too much of a hassle with the string template approach you used, you may look into using a library like CodeModel which allows you to write java code.  It fits nicely with the Annotation Processor API.\n4.  I noticed you used a thread unsafe method of using the ConcurrentHashMap, make sure you use a putIfAbsent to ensure concurrency correctness (see 912abcab)\nI applaud your work with this branch, so excited for it to be released so I can integrate it 100% as Transfuse's default event bus.\n- except a little tweaking of the BusTest unit test to compile... I know it's a work in progress ;-)\n. This thread seems to have gone stale... I am interested if you have some responses to the points I brought up.\n. No problem Jake, appreciate the attention.\n1.  What I meant is that otto annotated classes within dependencies of your application will not run through the annotation processor and will therefore not have the generated code available in the generated Finder.  It's good that you have reflection as a fallback.  I wonder if there is an approach to find the generated code within libraries, maybe via a naming convention?\n2.  Cool.\n3.  Certainly a good argument for keeping the list of dependencies small.  Is there really no good option for trimming the dependencies down?  I've noticed that maven's <scope> doesn't quite work, and proguard can be tricky.\n4.  Sounds good.\n. In the webapp world I use <scope>provided</scope> which uses the given dependency during compilation, but doesn't include it within the war WEB-INF/lib directory.  Maybe this is a question for the maven-android-plugin guys, but  why is there no analogy for this in the android Maven plugin?  Is it part of the fundamental android build process?\n. I remembered I looked into this issue a while ago and found the thread where I was attempting to ask the same question:\nhttps://groups.google.com/forum/?fromgroups=#!topic/maven-android-developers/S-nkHWiSKMw\nIf you split your annotation processor into a separate jar than the main runtime library then you can avoid including the annotation processor classes and its dependencies in the final apk/dex files by marking the annotation processor library as <scope>provided</scope>.  This, of course, requires that you use maven for the build and may be a hassle for non-maven users to have to drop 2 jars into their /lib dir instead of one.  But, if you are concerned about the size of your final artifact then this may be a solution to look into.\nWe do this in Transfuse, where the man annotation processor is contained in a separate jar than the API of the library.  The annotation processor and its dependencies are therefore not included in the final classes.dex file, but the API is included.\n. @loganj I tried to reproduce this error with your fork tests against the original Otto Bus class without success. Do these tests fail for you?  I assume you are receiving the \"Missing event handler for an annotated method...\" IllegalArgumentException, is this correct?\n. @loganj Ah, yes, that updated test demonstrates the bug well.  Nice catch.\nI know this is a little after the fact since the pull request was just merged, but why is the check that the given foundHandler exists in the currentHandlers set necessary?  Couldn't the last lines of register() look like the following:\njava\nfor (Map.Entry<Class<?>, Set<EventHandler>> entry : foundHandlersMap.entrySet()) {\n  EventProducer producer = producersByType.get(entry.getKey());\n  if (producer != null) {\n    for (EventHandler foundHandler : entry.getValue()) {\n      dispatchProducerResultToHandler(foundHandler, producer);\n    }\n  }\n}\n. Sounds like this is a concurrency bug unregistering handlers.  I'm thinking that some locking is in order on the EventHandler class.\n. Looking forward to your test case/stab.\nI think there is a related concurrency issue when registering / unregistering from separate threads.  I'll put together some code to demonstrate.\n. The use case targeted here is to facilitate lightweight, decoupled thread to thread communication using Otto.  A concrete example of this is a background thread, say a file download, updating the UI with progress.  This allows an AsyncTask or Thread to avoid keeping a reference to the targeted Activity, while being able to update it.  This solves a huge problem in Android and should be a core use case of Otto.\nSynchronizing is not as expensive as one may think.  At any rate, we should make this library correct first and optimize only when performance becomes a problem.  I'm interested to hear the events/second performance test between the unsynchronized an synchronized code.\nMaking unregister() in ThreadEnforcer.ANY not thread safe is a bad idea.  If the decision is to make Otto not thread safe, then we should get rid of  ThreadEnforcer.ANY altogether.\nSpeaking to the risk of deadlock, Otto uses a ConcurrentLinkedQueue and  reentrancy guard to avoid events triggering other events, and the resulting deadlock problems.  Looks like this is only present in the post() operation, maybe the register() event triggering should consolidated into this operation.\n. Found a deadlock case along the lines of what was mentioned.  Took the opportunity to add a test and fix.  This Consolidates the event triggering technique to use the queue in both register() and post() cases.\nAlso, these tests may be non-deterministic although they run pretty consistently.  Not sure if they should be included in the final merge.\n. @loganj I'm beginning to agree with you the more I think about this.  There are tons of hard deadlock issues introduced by making EventHandler synchronized.  Also, making Otto focused on single-threaded use keeps the complexity to a minimum and performance up.\nYou're right, Otto can be paired with a Handler from a background thread to update the UI without issue (or keeping a reference to Activity). So, my use case is satisfied by ThreadEnforcer.MAIN.\nBy the way, you mentioned a framework that complements Otto, you may be interested in a library I've been working on that allows you leverage the Handler through AOP:\njava\n@UIThread public void trigger(){\n    bus.post(new Event());\n}\nI don't think Enqueuing is changing the contract, as the register() method also triggers the processing of the queue.  You can still rely on events being triggered during the call to register(), but more in line with regular post() event processing (see ReentrantEventsTest).  Check out the change, I'm interested to hear if there are any issues.\n@JakeWharton I think ThreadEnforcer.NONE is a step in the right direction.\nI am torn about concurrency in this library.  Part of me is thinking: rely on the Android Handler to take care of thread safety.  The other part of me is thinking: Otto should be resilient to these sorts of issues... And this comment is ringing in my head:\n* <p>This class is safe for concurrent use.\nHere's a thought, we could use a single worker thread within Otto to register, post and unregister events and event handlers.  In the ThreadEnforcer.MAIN case we could use a Handler to do the work of putting these operations back on the UI thread, and in the ThreadEnforcer.ANY case Otto could use its own background thread.  Thoughts?\n. I'm going ahead and canceling this PR.  Summing up some of the key points:\nIf multiple threads are used, and ANY/NONE, the end user may see events after unregistering.  Not sure if this is such a big deal, but its what triggered this investigation.  May be the lesser of all evils.\nSomething to consider is consolidating the event triggering / queuing technique.  This may be a change in contract though, as @loganj mentioned.\n. I'm not a fan either, I'll remove the test.  It was meant as a convenient way to just highlight the issue.  I wish there was a better way to unit test concurrency.. do you know of any?\n. Oops, done.\n. Should this trigger an exception?  I was thinking that it should just silently return, knowing that it shouldn't execute the method.\n. Same as before\n. I thought all these were verified during the build... my apologies because I knew these were your standards.\n. I agree that if we use this library in a single threaded mode then this exception makes sense, as this code should never be called if valid == false.\n. Yes, that's the intention, and I agree.  So, I see two options here, either change the valid boolean into an AtomicBoolean or remove the isValid() method.  Thoughts?\n. Should this be called from Bus.unregister()?\n. ",
    "ashughes": "Shouldn't it be @Produce not @Provide?\n. Thanks for adding that btw. I was wondering how to properly create a ProGuard rule for annotations.\n. ",
    "nicholassm": "Yes it should. I've made a pull-request. Thanks for noticing.\n. ",
    "thierryd": "I understood that registering will not \"walk up\" the hierachy to automatically register the parent classes. But the issue is that any registration call in a parent will never work with Otto v1. Even if the parent is not an abstract class.\nYou might want to clarify this point in the docs. :)\nOr release v2 soon. ;)\n. Let me rephrase my problem: any @Subscribe method in a parent is never registered. Take the following code:\n```\npublic class ParentActivity extends Activity {\n@Subscribe\npublic void onReceiveLoginEvent(final LoginEvent event) {\n    Log.d(\"Tag\", \"LoginEvent\");\n}\n\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    BusProvider.getInstance().register(this);\n}\n\n}\npublic class ChildActivity extends ParentClass {\n@Subscribe\npublic void onReceiveErrorEvent(final ErrorEvent event) {\n\n}\n\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    BusProvider.getInstance().register(this);\n\n    setContentView(R.layout.main);\n\n    BusProvider.getInstance().post(new LoginEvent());\n}\n\n}\n```\nWhen ParentActivity register to the bus, the AnnotatedHandlerFinder picks up the @Subscribe onReceiveErrorEvent method from ChildActivity. I cannot find a way to register the ParentActivity @Subscribe onReceiveLoginEvent method.\n. @RayFromSquare Thanks for the tip. That's a nice way to work around the limitation. :)\n. After some consideration @RayFromSquare solution is not perfect. The best way would be to create an anonymous inner class and assign a variable to it so that it can be unregistered later. :)\n. ",
    "ghost": "public class ParentActivity extends Activity {\n```\n@Subscribe\npublic void onReceiveLoginEvent(final LoginEvent event) {\n    Log.d(\"Tag\", \"LoginEvent\");\n}\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\nBusProvider.getInstance().register(new Object() {\n  @Subscribe\n  public void onReceiveLoginEvent(final LoginEvent event) {\n    Log.d(\"Tag\", \"LoginEvent\");\n  }\n});\n\n}\n```\n}\nOn Thu, Oct 11, 2012 at 9:33 AM, thierryd notifications@github.com wrote:\n\nLet me rephrase my problem: any @Subscribe method in a parent is never\nregistered. Take the following code:\npublic class ParentActivity extends Activity {\n```\n@Subscribe\npublic void onReceiveLoginEvent(final LoginEvent event) {\n    Log.d(\"Tag\", \"LoginEvent\");\n}\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\nBusProvider.getInstance().register(this);\n\n}\n```\n}\npublic class ChildActivity extends ParentClass {\n```\n@Subscribe\npublic void onReceiveErrorEvent(final ErrorEvent event) {\n}\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\nBusProvider.getInstance().register(this);\n\nsetContentView(R.layout.main);\n\nBusProvider.getInstance().post(new LoginEvent());\n\n}\n```\n}\nWhen ParentActivity register to the bus, the AnnotatedHandlerFinder picks\nup the @Subscribe onReceiveErrorEvent method from ChildActivity. I cannot\nfind a way to register the ParentActivity @Subscribe onReceiveLoginEventmethod.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/26#issuecomment-9347469.\n. Should delete the old instance method, of course. Fixed in the quoted text\nbelow.\n\nOn Thu, Oct 11, 2012 at 9:35 AM, Ray Ryan ray@squareup.com wrote:\n\npublic class ParentActivity extends Activity {\n```\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\nBusProvider.getInstance().register(new Object() {\n  @Subscribe\n  public void onReceiveLoginEvent(final LoginEvent event) {\n    Log.d(\"Tag\", \"LoginEvent\");\n  }\n});\n\n}\n```\n}\nOn Thu, Oct 11, 2012 at 9:33 AM, thierryd notifications@github.comwrote:\n\nLet me rephrase my problem: any @Subscribe method in a parent is never\nregistered. Take the following code:\npublic class ParentActivity extends Activity {\n```\n@Subscribe\npublic void onReceiveLoginEvent(final LoginEvent event) {\n    Log.d(\"Tag\", \"LoginEvent\");\n}\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\nBusProvider.getInstance().register(this);\n\n}\n```\n}\npublic class ChildActivity extends ParentClass {\n```\n@Subscribe\npublic void onReceiveErrorEvent(final ErrorEvent event) {\n}\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\nBusProvider.getInstance().register(this);\n\nsetContentView(R.layout.main);\n\nBusProvider.getInstance().post(new LoginEvent());\n\n}\n```\n}\nWhen ParentActivity register to the bus, the AnnotatedHandlerFinderpicks up the @Subscribe\nonReceiveErrorEvent method from ChildActivity. I cannot find a way to\nregister the ParentActivity @Subscribe onReceiveLoginEvent method.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/26#issuecomment-9347469.\n. @loganj no test? Even if you can't get one to fail reliably with the old mish-mash, you could add one that explicitly tests this ordering.\n. thank youuuu!\n. Looks just perfect. \nWhat are the drawbacks of such a pattern?\nAre there better alternative to propagate a model change in a service back to the ui?\nF.\n. I'm with @JakeWharton on this one. Correctness is nice and everything, but this is going to force contortions for little gain. -1\n. \n\n",
    "felipecsl": "So just to illustrate @thierryd comment:\n``` java\npublic class ParentActivity extends Activity {\n    private Object busEventListener;\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n     busEventListener = new Object() {\n        @Subscribe\n        public void onReceiveLoginEvent(final LoginEvent event) {\n            Log.d(\"Tag\", \"LoginEvent\");\n        }\n    };\n\n    BusProvider.getInstance().register(busEventListener);\n}\n\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    BusProvider.getInstance().unregister(busEventListener);\n}\n\n}\n``\n. I'm using mockito as well.\nIf I replace theBusobject with a plainObjectobject, it works fine.\nIm doingverify(bus).register(listener)` and the test fails since there were no interactions with that mock\n. Test 1:\njava\n    @Test\n    public void busMockTest() {\n        Object listener = new Object();\n        manager.register(listener);\n        verify(bus).register(listener);\n    }\nHere is manager.register():\njava\n    // bus is a mock(Bus.class)\n    public void register(Object listener) {\n        bus.register(listener);\n    }\nFails. Stack trace:\n```\nWanted but not invoked:\nbus.register(java.lang.Object@41a8dfb3);\n-> at com.weheartit.manager.WeHeartItNotificationManagerTest.busMockTest(WeHeartItNotificationManagerTest.java:62)\nActually, there were zero interactions with this mock.\nat com.weheartit.manager.WeHeartItNotificationManagerTest.busMockTest(WeHeartItNotificationManagerTest.java:62)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\nat java.lang.reflect.Method.invoke(Method.java:597)\nat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\nat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\nat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\nat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\nat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\nat com.xtremelabs.robolectric.RobolectricTestRunner$1.evaluate(RobolectricTestRunner.java:292)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:300)\nat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\nat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n\n```\n. Test 2:\njava\n    @Test\n    public void busMockTest() {\n        Object listener = new Object();\n        manager.register(listener);\n        verify(bus).equals(listener);\n    }\njava\n    // bus is a mock(Object.class)\n    public void register(Object listener) {\n        bus.equals(listener);\n    }\nThis passes\n. Ok there may be a problem where it only doens't work when I set up the mock in the @Before method.. Investigating\n. The problem is not the @Before. It is actually more subtle than that... I was able to work around it. Closing since it looks like it is not an issue for anyone else\n. ",
    "gmale": "Thanks so much @felipecsl, @thierryd and @RayFromSquare for this approach. It makes perfect sense and solves the problem, nicely. In case it helps anyone else, I had to tweak the implementation slightly to make it easier for subclasses to extend the behavior. Note: the listener can handle multiple events:\n``` java\npublic class ParentActivity extends Activity {\n    protected Object busEventListener;\n@Override\nprotected void onCreate(final Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n     busEventListener = new Object() {\n        @Subscribe\n        public void onReceiveLoginEvent(final LoginEvent event) {\n            ParentActivity.this.onReceiveLoginEvent(event);\n        }\n        @Subscribe\n        public void onReceiveLogoutEvent(final LogoutEvent event) {\n            ParentActivity.this.onReceiveLogoutEvent(event);\n        }\n    };\n\n    BusProvider.getInstance().register(busEventListener);\n}\n\n//subclasses extend me. This can be abstract, if necessary.\nprotected void onReceiveLoginEvent(final LoginEvent event) {\n    Log.d(\"Tag\", \"LoginEvent\");\n}\n\n//subclasses extend me. This can be abstract, if necessary.\nprotected void onReceiveLogoutEvent(final LogoutEvent event) {\n    Log.d(\"Tag\", \"LogoutEvent\");\n}\n\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    BusProvider.getInstance().unregister(busEventListener);\n}\n\n}\n```\nThis is tested and working. The parent class takes care of the boilerplate work and subclasses add a bit more functionality, when needed. Perfect. Thanks again!\n. ",
    "gautamk": "When using the method @gmale suggested make sure the overriding methods in the child class are not annotated with @Subscribe\n. ",
    "Niades": "Although there is a shortcoming to @gmale 's approach: the parent class must contain every possible event handler that it's ancestors might have, because otherwise they would have nothing to override and if they use @Subscribe, they simply won't get notified of any events because their instances are not registered in the bus, only the listener object is.\nI hope #135 will be merged soon.\n. ",
    "glenviewjeff": "I'm not sure I understand yet, I'm sorry--A simple code sample would probably be worth 1,000 words. \n. OK, then I'm still confused.  Why couldn't you just omit the @Produce annotation?  There's already a BusProvider.getInstance().post(produceLocationEvent()); in the onCreate method.\nWhat behavior is this annotation adding here?\n. OK, I think I get it now.  The problem is that fragments don't live as long as their parent activities.  \nWhile LocationMapFragment would get the LocationChangedEvent notification the first time it's instantiated, if it's destroyed and recreated (e.g., during rotation change) it will get another LocationChangedEvent if @Produce is present.\nSo any time new subscribers (listeners) are added to the EventBus, immediately after registration they are guaranteed to receive the events found in classes that have @Produce methods.  That is, as long as the producing classes have been previously registered with EventBus.\nIs that correct?\n. OK, thanks very much for taking the time to explain this to me.  I'm actually in the process of migrating to more flexible layouts with fragments and this will likely come in handy.  Maybe you could update the documentation for others with some of this text and even a few code snippets?\n. ",
    "intrications": "@glenviewjeff The demo app already has an example of how @Produce is useful:\nhttps://github.com/square/otto/blob/master/sample/src/main/java/com/squareup/otto/sample/LocationActivity.java\n. ",
    "meierjan": "I had the same questions and the documentation is still not clear here. Especially for this:\n\nTypically you would register a @Produce method in something more long-lived than an activity as well (e.g., a service that is constantly listening for location updates and keeping track of the latest). You can also use things like singletons for this that are always on the bus.\n. > maybe for a game about finding and collection fictional creatures\n\nAre we talking about Pokemons? \ud83d\udc4d \n. ",
    "clay-to-n": "@meierjan imagine the case where your app has multiple Activities and Fragments that require a recent location to work (maybe for a game about finding and collection fictional creatures).  You have some background LocationManager service that is posting Otto events whenever the location updates.  The Fragments and Activities subscribe to these events.\nHere's a timeline of that service posting these events, where each (0) is a location event:\n-----(0)-----(0)---------(0)---------(A)-----------(0)------------------(0)---------\nWhat happens if you start a new FragmentA at that (A) location?  There would be a time-gap between when the Fragment is initialized (and registered to the bus), and when it receives it's first location event.  In this gap, FragmentA has no location.\n-----(0)-----(0)---------(0)---------(A)-----------(0)------------------(0)---------\n-------------------------------------|<-time gap->|-----------------------------\nYou could get around this (using Otto) by having FragmentA post some NeedsLocation event, and having the LocationManager respond by posting a location update event.\nBut if you use the Provides annotation on the LocationManager, as soon as FragmentA is registered to the bus, it will receive the last posted location, without having to explicitly ask the LocationManager to send it the last known location..\n. ",
    "loganj": "The ordering is determined by the iterator from a collection inside register().  I have no way to control it.\nHold pls... I'll add a test for unregistering inside the handler, but it would have passed about half the time before this fix as well.\n. @johncarl81 Those tests fail for me, but not reliably.  You're correct, that is the exception I see.  As I mentioned in a previous comment, whether or not you see it depends entirely upon the order in which register() iterates over the class's handlers, and that's not defined.  To trigger it you need to call unregister() from within a handler before all of the handlers have been added to the map.  unregister() will crawl the class, try to remove a handler that has not yet been added, and throw.\nSorry, quick edit: You're right, these tests do not ever trigger this bug.  You need additional handler methods for that.  I'll add some more.\n. Suppose that a handler calls unregister while handling  a produced event.  Without that check, another produced event may subsequently be dispatched to another handler on the same object, even though the object has ostensibly already been unregistered.  I actually saw that happen to my client code.\nIn fact, there may still be a problem in a narrow edge case... If an object has multiple handlers for a single produced type, and one of those handlers unregisters the object before the other handlers have been dispatched, the other handlers may still be called.  I'll put a test case together tomorrow.\nThis is looking like a less expensive implementation might be in order, though.  register should probably just short-circuit if a handler on the target object calls unregister.  Will take a stab at that, too.\n. No, there's no concurrency involved.  This all happens on the same thread's stack, starting in register.\n. @JakeWharton added a producer unregistration test, fixed the producer validity check, and rebased.\n. It doesn't seem right to introduce so much synchronization when Otto's most common use is on a single thread (ie, the main thread).\nSuppose we were to instead apply the ThreadEnforcer in Bus#register and Bus#unregister.  You'd then modify ThreadEnforcer.ANY#enforce to acquire a lock, while leaving ThreadEnforcer.MAIN alone.  At that point you might also consider some name changes.\n. Actually, another option is to apply the ThreadEnforcer in register and unregister, and just document that unregister is unsafe under ThreadEnforcer.ANY.  This is roughly equivalent to changing nothing about the status quo, but being more explicit about the contract.\n. My strong inclination is that Otto should remain focused on single-threaded use, and that ThreadEnforcer.ANY should be better documented and maybe even deprecated and replaced with ThreadEnforcer.CREATING_THREAD or similar.\nEnqueuing produced events is a change in the contract for Bus#register, and not a trivial one. I have code that relies on the promise of an immediate call, and I'm not sure offhand whether a change to queued calls will have adverse effects.  (Essentially, I have Otto underpinning a reactive, bootstrapped state machine.)\n\"Thread safety\" can mean a lot of things, but the most important meaning is that a client should not be surprised by the library's behavior when used from multiple threads. That's achievable in a couple of ways, and the means I'm advocating now is documentation. I'd much prefer to better communicate ThreadEnforcer.ANY's behavior than to change it.\nRegarding the inter-thread use case, Otto already gets you the decoupling you've described.  Clients just have to either execute the post on the appropriate thread for the bus, or have handler methods re-dispatch from the bus's thread onto whatever thread is appropriate.  There is some boilerplate there, but it's not terribly onerous and is very easy to read and reason about.\nThere may well be room for a similar small library that hops threads and uses annotations to mark the intended thread of dispatch for a handler.  I just see that as more complementary to Otto than a natural part of it.\n. @JakeWharton +1 for renaming ThreadEnforcer.ANY to ThreadEnforcer.NONE\n@johncarl81 - \nAnnotations like @UIThread are exactly what I had in mind.  Nice.\nRegarding enqueuing: You have to consider multiple handlers of produced events which may alter the state of the producers.  I haven't written the test case to illustrate it, but there's definitely a difference in contract between immediate dispatch of produced events and enqueuing them.  There may be an argument that enqueuing is the better, more consistent contract, in which case I'd need to modify a couple of state machines...\n* <p>This class is safe for concurrent use.\nYeah, that comment is clearly insufficient.\nI did try wrapping Otto to do thread coercion in post() as you describe. I found I wasn't using it much because thread-hopping turned out to be relatively uncommon case, so in the end I just deleted the wrapper.  Your @UIThread snippet is nice because it doesn't hide the coercion behind the post() interface, so the concerns aren't tangled and it reads as it runs.\n. @pforhan NONE and MAIN are fine as constants, so they don't need factories.  We may want to add enforcers later that can't be constants, though.\n@JakeWharton Only suggesting we do this now since we're deprecating ThreadEnforcer.ANY anyway.  Just an opportunistic move.  I do have ThreadEnforcers#currentThread() spiked as a response to #30, but I'm sitting on it because I'm not convinced it's needed now.\n. [INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO]\n[INFO] Otto (Parent) ..................................... SUCCESS [0.624s]\n[INFO] Otto .............................................. SUCCESS [12.585s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 13.393s\n[INFO] Finished at: Thu Sep 19 10:29:45 PDT 2013\n[INFO] Final Memory: 19M/81M\n[INFO] ------------------------------------------------------------------------\n. You mean base classes couldn't safely do bus.register(this)?  I'm ok with that.  It seems wrong if this may or may not actually even want to be on the bus.\n. So use another base class or a marker interface or a class-level annotation, to either opt in or opt out of bus registration.  If we don't throw, we're passing up an opportunity to catch a mistake.\n. paging @pyricau \n. FP to make checkstyle stop whining.\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO]\n[INFO] Otto (Parent) ..................................... SUCCESS [0.477s]\n[INFO] Otto .............................................. SUCCESS [12.891s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 13.541s\n[INFO] Finished at: Mon Sep 23 11:58:05 PDT 2013\n[INFO] Final Memory: 20M/81M\n[INFO] ------------------------------------------------------------------------\n. @npombourcq Thanks!  Have you signed our CLA?  We need your signature to merge.\n. @imminent The exception was a red herring.  The original issue is that if you proguard the sample, it fails unless you set appropriate configuration for proguard.\n@staryanwx Thanks, but this is already documented on the website.  I think we do not need to add it to the sample app.\n. The solution to this problem is either:\n1. Do not proguard the sample app.\nor:\n1. If you do proguard the sample app, configure proguard as documented.\n. LGTM.  Travis is sad, though.\n. It's worse than that, even.  If there are L event methods in the listener, and C current handlers for the type, I've increased the cost from about L to about 2L + C.\nI do not feel good about that, but it would take much more surgery on the collections to bring the cost back down, and I don't know whether it's worth doing.\n. Yes.  A call to handleEvent should not happen once the handler's been invalidated; if it does, there's a bug somewhere in the Bus.  Fail fast and fail hard.\n. As noted on my PR, surprising states should throw.\n. Ouch.  Synchronizing on the handler's monitor every time we dispatch an event to it.  Apart from the inherent performance hit, there's a real risk here of surprising the client with deadlocks when his own code doesn't even perform any locking.  Suppose you have two handlers which end up transitively firing events to each other and expecting a response.  Especially given the decoupling nature of an event bus, that could be quite hard to track down.\n. Yes, thanks for the catch!  Added a test as well.\n. Yep, we could totally do that.  We'd have to grow/shrink the array ourselves, and we'd have to make it Object[].  So that's no fun.\n. @pforhan A single queue that wraps three queues... You mean like some kind of dispatch queue, maybe backed by three ArrayDeques? ;)\n. ",
    "klevi": "1st device: LG P500 running Android OS 2.2 (this should be stock Android)\n2nd device: Orange Boston - Gigabyte G1305 running CyanogenMod 7.2 (Android 2.3.7)\nSince they are very different, the problem should be something else. Note that I'm using your ActionBarSherlock library, but that shouldn't be an issue.\nEdit 1: just checked it on a Motorola Milestone running 2.2.1 ... same problem\nEdit 2: The HomeActivity extends SherlockFragmentActivity (maybe there's something wrong when extending onResume?)\n. I have no listeners in xml files, and also checked the project with Lint, but there's no API call that should have any backwards compatibility problem. Any other ideas?\nEdit: I red swankjesse's post over and over, and finally managed to solve the problem. Turns out I had a widget available from API level 11 in my code. Event if it was only declared, not used within the code where the app was running on older Android versions, the app was crashing. Don't know why exactly the exception was thrown pointing to this library, but probably because of the process described by swankjesse in the blog post above.\nThanks for the support, and sorry because of the false alarm.\nKeep up the good work!\n. ",
    "tyvsmith": "This should be re-opened. Otto uses reflection to look for producers. If a method class takes a parameter that didn't exist on the version being tested, it'll fail.\nCaused by: java.lang.NoSuchMethodException\n            at java.lang.Class.getDeclaredMethods(Native Method)\n            at java.lang.ClassCache.getDeclaredMethods(ClassCache.java:140)\n            at java.lang.Class.getDeclaredMethods(Class.java:757)            \n            at java.lang.Class.getDeclaredMethods(Class.java:757)\n            at com.squareup.otto.AnnotatedHandlerFinder.loadAnnotatedMethods(AnnotatedHandlerFinder.java:52)\n            at com.squareup.otto.AnnotatedHandlerFinder.findAllProducers(AnnotatedHandlerFinder.java:119)\n            at com.squareup.otto.HandlerFinder$1.findAllProducers(HandlerFinder.java:33)\n            at com.squareup.otto.Bus.register(Bus.java:187)\nFor example, assuming the containing class contains a register call, this method existing will cause Otto to fail on 2.3 (without being called).\n@TargetApi(Build.VERSION_CODES.HONEYCOMB)\n    public JsonReader testMethod(JsonReader test) {\n        return null;\n    }\n. @JakeWharton Agreed that a fundamental re-write would resolve this, but short of that, documenting this gotcha is probably important. Aside from that, I'd experiment with catching the exception and continuing. A developer shouldn't have a method that would cause this behavior that would also be subscribing or producing on that version of Android.\n. The workaround we're using for now is encouraging the use of inner classes and interface implementations to subscribe and produce, thus preventing the parent from being iterated on and containing the event bus logic to a guaranteed area. \nSomething like this in a base class:\n```\n    public interface EventBusMethods { }\n    protected abstract Bus getEventBus();\n    protected abstract EventBusMethods getEventBusMethods();\npublic BaseClass() {\n    getEventBus().register(getEventBusMethods());\n}\n\n```\n. ",
    "pommedeterresautee": "Thank you !!!!!! Most rapid answer ever !!!!\nI ll try it.\n. slightly modified version if you want to add it in a wiki:\n``` java\npublic static class AndroidBus extends Bus {\n    private final Handler mainThread = new Handler(Looper.getMainLooper());\n\n    @Override\n    public void post(final Object event) {\n        if (Looper.myLooper() == Looper.getMainLooper()) {\n            super.post(event);\n        } else {\n            mainThread.post(new Runnable() {\n                @Override\n                public void run() {\n                    post(event);\n                }\n            });\n        }\n    }\n}\n\n```\nWorks!\n. Was due to my own code...\n. ",
    "vogella": "In Eclipse we have a special annotation to declare that the method should be called in UI thread. \nFor example\n@Subscribe could be as before and @UiSubscribe could ensure a sync with the UI by the framework\nThis releases the caller from this decision. See http://www.vogella.com/articles/Eclipse4EventSystem/article.html#eventsystem_usagereceive for the usage in Eclipse 4.\n. ",
    "sallespromanager": "first, a thank you very much for your bIG contributions : @vogella from whom i learned a lot in his tutorials and @JakeWharton to such such elegant code.\ni have recently gone through this issue #38 and i think it is VERY important.\nwe're building apps based on Otto using fragments and this comes to table right away when you do a webview in a fragment and has to call Otto bus Events to do whatever else.\nMaybe it deserves an observation in the DOCs.\n. ",
    "djensen47": "+1 to adding this to the documentation as well as the samples.\nAnother possibility would be to create a subproject, e.g., AndroidOtto, that includes this functionality out of the box.\n. ",
    "theblang": "Any idea if this will work on a Wear device to talk from WearableListenerService to Activity?  I completely understand what you are doing in the extended Bus, but I can't seem to get it to work.\n. ",
    "juanmendez": "Lets pretend you have directly used Bus everywhere already, you can use composition over inheritance.\npublic class BusUtil\n{\n    private static final Handler mainThread = new Handler(Looper.getMainLooper());\n```\npublic static void postOnMain( final Bus bus, final Object event) {\nmainThread.post(new Runnable() {\n    @Override\n    public void run() {\n        bus.post(event);\n    }\n});\n\n}\n```\n}\n. ",
    "adennie": "FYI, I submitted a pull request for this in issue #55.\n. I'll resubmit to the code-gen branch as suggested.  Protocol question - should I close this pull request?\n. Hey, I just realized that my breaking change to ThreadEnforcer was  misguided and should not have been made (since ThreadEnforcer is specific to the Bus implementation, not the OttoBus interface).  Would you be open to me re-issuing a pull request against master that leaves out the ThreadEnforcer change?  I've been doing some interesting stuff in my own fork that leverages the interface, and it would be great to get it into your repo's master so that I'm not working from a one-off.\n. Oops.  Been staring at Square code too long, I guess :-)\n. sure, works for me.\n. OK, sure.\n. Ack, of course, my apologies.  I'll try to separate and transfer the docs in Bus.java that describe the interface and the high-level requirements for implementations of it, and leave the bits that are specific to the implementation provided by Bus.\n. OK, updated now.\n. Ugh, sorry, something in my Eclipse formatting rules is doing that.  I caught it once before, and restored the blank lines manually, but missed it this time.  I'll fix it.\n. ",
    "francisdb": "thanks @pforhan for mentioning\n. ",
    "sh1989": "This code is for #42 - I forgot to reference that in my original commit and so this pull has resulted in a new issue. D'oh!\n. Cheers Jake. In the original issue this is marked as something to be fixed towards milestone 2.0. Is there any way of merging these issues?\n. @JakeWharton I've moved this commit onto the 2.0-wip branch on my fork... I'm assuming when this is accepted it can be pushed to a new 2.0-wip branch, but the default target is currently master. :)\n. Everything is up to date with the 1.3 release now.\n. ",
    "tbsandee": "I appreciate the decision, and it's easy enough to work around with enough care. \nThat said, gIven how easy it is to accidentally subscribe to events in a class and then subclass it, I wonder if either of these would be useful:\n- a warning could be logged (difficult, since you've kept dependencies minimal and there's no logging)\n- a \"strict\" flag for the Bus, where an IllegalArgumentException might be thrown \n  if you try to subscribe to events using a non-final class. \nIn my code base, this is effectively what I've tried to do to avoid accidentally losing events.\n. So, quick experiment leads me to the fact that anonymous inner classes are non-final (I'm sure there's a good reason). Oh well.\n. Looks like a thread-safety issue to me. The flattenHierarchyCache in Otto.Bus is not threadsafe (just a hashmap with no synchronization), so if you call Bus.post() from multiple threads there is potential for corruption internally. I think that's arguably a bug, because the javadocs imply that you are allowed to relax the main thread restrictions if you want. It doesn't explicitly say that Otto.Bus is threadsafe though, and if you use your bus instance from a single thread (main, or other) it should work fine.\nIntentService.onHandleIntent() is called from a worker thread, not the main thread and calls to Bus.post() would typically be called from the main thread in simpler use cases.\nWhen you create your Otto instance you might consider keeping the ThreadEnforcer.MAIN policy and fixing up your code to use the main thread for Otto interactions. It's closer to what most people will do, although the docs aren't 100% clear on the threadsafety of the various methods.\n. FYI, see PR #154. I think multithreaded access to Otto is discouraged, but since the APIs allow it it seems like a safe fix with little to no real-world performance degradation.\n. fixed, thx\n. ",
    "imminent": "@JakeWharton I seem to have an error with unregistering Subscribers using 2.0 snapshot. It's the IllegalArugmentException \"Missing Subscriber...\". Do you have to handle subscription differently in 2.0? \n. The clean android code project uses it because the change is necessary for\nintegration with AndroidAnnotations, isn't it?\nOn Feb 27, 2013 1:39 PM, \"Jake Wharton\" notifications@github.com wrote:\n\nI wasn't even aware 2.0 compiled, to be honest.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/61#issuecomment-14201821\n.\n. That's what I was afraid of. I thought I would give it a try to find out\nthough. Would love to have these libraries working together. I'm all for\nreadable, maintainable code.\nOn Feb 27, 2013 2:07 PM, \"Jake Wharton\" notifications@github.com wrote:\nYes, but it's a long way from actually being a shippable version of the\nlibrary. It doesn't surprise me at all that there are problems with it. I\nwouldn't recommend using it until we move it to the master branch to\ndictate that it's relatively stable and pushing toward release.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/61#issuecomment-14203331\n.\n. Oh, awesome! Is there anything I can follow to see if I can contribute to\nits progress. Annotation processing is a bit outside my usual domain. These\nissues are for the whole repository, not just a branch, right?\nOn Feb 27, 2013 2:14 PM, \"Jake Wharton\" notifications@github.com wrote:\nWell I'm starting actual 2.0 development today or tomorrow so it should\nmove forward quickly. As it exists now it's more of a proof-of-concept.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/61#issuecomment-14203713\n.\n. Got it.\nOn Feb 27, 2013 2:21 PM, \"Jake Wharton\" notifications@github.com wrote:\nI need to rebase it first, though, since the branch is about 6 months out\nof date.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/61#issuecomment-14204069\n.\n. That pull request closed this issue, right? Should this issue be closed now?\n. Issue with register(Object object, long id) is it doesn't get you anything new, while definitely muddying the API. Can you register for the same event without an id? How do you maintain these id's to make sure the event keeps its same id and is different for other id? The easiest answer to all of these is Jake's snippet. The id is a field of the event, the component that creates these events can keep track of unique ids. If you wanted a subscriber to always do something, just ignore the id field.\n. @ajostergaard as for the DeadEvent coming loaded with enough of the original event, it just wraps the original event:\n\njava\n/**\n  * Creates a new DeadEvent.\n  *\n  * @param source object broadcasting the DeadEvent (generally the {@link Bus}).\n  * @param event the event that could not be delivered.\n  */\n  public DeadEvent(Object source, Object event) {\n    this.source = source;\n    this.event = event;\n  }\n. There's a pull request, I tried to talk about the 2 types of customization, and show an example of providing the bus through Dagger.\nI didn't cover the HandlerFinder since, frankly, I have never used it, and it seems to be less standard (the documentation hints that it's only for testing purposes. Seems to be able to find subscribers/producers by means other than @Subscribe/@Produce)\n. Yeah, I tried to make it verbose with the idea that it would probably more than enough.\n. That version only examples new Bus(), and outlines a pattern that can be assumed for the following examples.\n. This, not a problem at all. Was simple. I appreciate that you guys take\nthe time to show people how to use your libraries at all.\nOn Sep 6, 2013 3:39 PM, \"Jake Wharton\" notifications@github.com wrote:\n\nThanks for taking the time to do this!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/pull/93#issuecomment-23973921\n.\n. It already has Producer though, don't want to have 2 similar features in a library, makes things complicated for users of the library. Which do I use? What's the difference? Etc. It's not that events can't be cached already, it's that the event bus WON'T maintain said cache. So, unlike ThreadEnforcer.ANY (which removes the feature of checking the Thread that an event was posted on) Otto already handles both cases of cached events and non-cached events without any configuration.\n. @staryanwx This looks like an Android permissions issue, according to that stack trace. The culprit is names as \"requires android.permission.INTERACT_ACROSS_USERS_FULL\". Don't believe that is an Otto or Proguard problem.\n. Does it work with everything the same except no Proguard? If the exception\nyou're having isn't related to Otto how are we suppose to fix it through\nOtto? (Again, for Proguard, since it's a permissions issue, it shouldn't be\na Proguard issue either)\n\nIf you can get past that exception and show one that is a diagnosable Otto\nissue, or show that the permission exception is introduced solely by adding\nProguard, then we have something to go by. Right now there's isn't anything\nwe can tell you.\nOn Tuesday, November 26, 2013, staryanwx wrote:\n\nwho can Proguard otto demo(LocationActivity) to apk , and run correct \uff1f\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/100#issuecomment-29365546\n.\n\n\n\nDandr\u00e9 Allison                                (323) 823-4456\nKeepandShare.com http://www.keepandshare.com\nSchedule & Share. Simply. Securely.\n. So, a nice advantage to the current approach to dealing with this superclass subscription is that it is dependable. The current approach is to register a class field instead of the superclass itself:\n``` java\nclass SomeSuperClass {\n  private final SomeEventListener busListener;\nSomeSuperClass(Bus bus) {\n    busListener = new SomeEventListener();\n    bus.register(busListener);\n  }\npublic static class SomeEventListener {\n    @Subscribe public void onEvent(SomeEvent event) {\n      // do something\n    }\n  }\n}\n```\nThis is dependable because even if some subclass SomeSubClass extends SomeSuperClass comes along later and subscribes to SomeEvent, the SomeEventListener will still get called (as well). This statement can't be made for the other approach that traverses the class hierarchy, because there's but a single object. See how in this case, no subclass of SomeSuperClass can be written in a way that prevents \"// do something\" from happening when SomeEvent happens.\n. @Disruption actually there is a way to override an onEvent method if that's desired, and it's very simple.\n``` java\npublic class SomeSuperClass {\npublic void onEvent(SomeEvent event) {\n      // do something\n  }\n}\npublic class SomeSubClass extends SomeSuperClass {\nSomeSubClass(Bus bus) {\n    bus.register(this);\n  }\n@Subscribe @Override\n  public void onEvent(SomeEvent event) {\n    super.onEvent(event);\n    // do some more stuff\n  }\n}\n```\nBut this @Subscribe methods should prefer to be constructed in a self-contained manner that doesn't require extension, and doesn't care about the order they are triggered. Actually, you can you RxJava for Reactive programming if you a similar paradigm that does give you control over order of operation (it's similar because of the Observable model).\n. By default the Bus requires that events are posted from the main thread. There's absolutely no reason that having an Event or producer or consumer of Events in different packages causes any issues. If you can import it in the producer or consumer class then that's all you need.\n. Isn't it possible to simply register and immediately unregister with the Bus, in this case? That cases the producers to produce their events. This approach makes the producer and consumer more tightly coupled. Particularly, the consumer is either making a statement about the existence of the producer or handling the case when the producer doesn't exist. \nThe paradigm in Otto, is that the consumer waits for the event it cares about to come through the Bus. Which means, it doesn't care about the existence of the producer of the event or have to deal with the case when the producer doesn't exist. This also means, that other code can call this \"listening\" method explicitly, such as unit test code.\n. @mbaroukh Otto sends messages synchronously, so \"waiting\" was meant as more of the paradigm, than the actual implementation. Before the register method finishes, any Producers on the Bus for Events you care about will have sent those Events. There is no \"wait for an arbitrary amount of time\".\nIn your concrete case you want the Producer to maintain the state for the Activity, but the Activity can already registered with the Bus at this point, so it will be receiving the new Events already. So it wouldn't need to ask what the value is at exit, because it should already know.\nIf you don't like that paradigm, then you don't want to use a Event Bus for this case, what you're describing is the exact opposite of an Event Bus. To purpose is for the listener to not ask for the data, but to receive the data when it becomes available. If you do want to use Otto here, then you should register for that Event and store the data you care to present on the Activity.\n. @mbaroukh I don't have to be careful because I don't remove that Thread restriction, you have to be careful once you remove that restriction. It isn't bad design, this is what an Event Bus is. It is not a way to \"link\" different parts of an app, it is a way to \"communicate\" between different parts of an app. This communication is 1-directional (from poster to subscribers). The reason they don't have to know about each other, is because the poster only cares about posting the event to the Bus and the subscriber only cares about handling the event it subscribes to. \nWhat you're describing is a Model that holds the data for the Activity instead of the Activity holding the data itself. Something that the Activity can retrieve data from instead of receiving data from.\n. The point is, this isn't going to be added to Otto. If you want this behavior then you want something different than an Event Bus (if you think this is bad design, then you believe in what an Event Bus is, which is fine). The recommended implementation is for the Activity to know about this other component. \n. @mbaroukh what are you trying to convince me of? https://code.google.com/p/guava-libraries/wiki/EventBusExplained if you don't think this is good design, then you shouldn't use it.\n. If you're trying to debug this, try logging the Activity lifecycle methods. 2 possibilities, onPause is called without a corresponding onResume or onPause is called multiple times on the same Activity (more than onResume). Or, the lifecycle is as expected, but the BusProvider.getIstance().register(this) isn't working. This is assuming that the only place BusProvider.getInstance().unregister(this) is executed is the line in the code snippet. \n. Would encourage use of a Set if you're going to want to do a contains()\ncheck on it.\nOn Sat, Feb 27, 2016 at 5:46 PM Ramiz Raja notifications@github.com wrote:\n\nTry subclassing Bus. Something like\npublic class YourBus extends Bus{private ArrayList registeredObjects = new ArrayList<>();\n@Overridepublic void register(Object object) {\n    if (!registeredObjects.contains(object)) {\n        registeredObjects.add(object);\n        super.register(object);\n    }\n}\n@Overridepublic void unregister(Object object) {\n    if (registeredObjects.contains(object)) {\n        registeredObjects.remove(object);\n        super.unregister(object);\n    }\n}\n}\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/127#issuecomment-189762090.\n. Check out: https://plus.google.com/+LisaWrayZeitouni/posts/1rzvYZSF7zm Someone else asked this same question. \n. Is there a reason to want more interesting event hierarchies? \n. So, if you're already getting all of the network events, then you could filter them in the subscriber method by these interface tags, right?\n\njava\npublic void onNetworkEvent(NetworkEvent event) {\n  if (event instanceOf UserAccountEvent) {\n    // something interesting\n  }\n}\n. Otto does work with interfaces. You can post and subscribe with an interface as the declared typed of a parameter, I've done that before.\n. Well, @JakeWharton, I'm misremembering then, it was from about a year ago. But, if there's a test to specifically check that you can subscribe to an interface, then there must be good reason to not do so.\n. java\nif (eventType.isInterface()) {\n          throw new IllegalArgumentException(\"Method \" + method + \" has @Subscribe annotation on \" + eventType\n              + \" which is an interface.  Subscription must be on a concrete class type.\");\n}\nYou only want concrete types, do you know the design decision for that restriction? Any object will certainly be concrete when passed as a parameter.\n. @PiPeep that does mean that you should change this limitation if you want to support your change. Otherwise the annotation finder will explicitly not allow subscription to interfaces.\n. bus.post(new SomeEvent()) is functionally equivalent to onSomeEvent(new SomeEvent()), the default behavior for the bus even makes the execution synchronously. If you do have multiple executions then you have something else wrong.\n. Yeah, that's what I thought.\n. Instead of assuming in that case, just ignore dependency injection and straight up say Bus bus = new Bus(). You can still mention \"Because a bus is only effective if it is shared, we recommend obtaining the instance through injection or another appropriate mechanism.\" That way, there's no confusion about where bus is coming from.\n. ",
    "WonderCsabo": "@JakeWharton what is the status of the 2.0 branch? Did you reject to continue development in that way?\n. @JakeWharton any chance this will get merged soon? This would be a really useful feature.\n. ",
    "brh": "Please don't.  I am extending Bus to dispatch only on the UI thread (if it is going to an activity or a fragment).  I was going to make a suggestion for Otto to do this by default, but then I heard a talk on infoq from Eric Burke and he said Square had internally debated that and decided against it, due to some ordering or something..\n. Because I don't want all events to come off of the event thread only certain ones and probably at certain times.  Some would be going to DB, for example getting from the web and then posting to another service to write to the db.  Really taking the class doing 1 thing to an irritating level =-).\n. Even better would be if I could have my own EventHandler be used by Otto (via a factory method or the likes) and then in my dispatch I wouldn't have to do any instanceof checking.  Custom annotation would specify to be notified on UI thread.\n...\nIgnore the instanceof comment, just realized that won't work at all.\n. ",
    "dlam": "Interesting note (or maybe not so interesting): Oracle's Java code conventions tell us to put  tags on their own line, between paragraphs. Although I think that when it comes down to it, consistency throughout the project is more important - as long as the change is reasonable. In this case, I think it is!\nAny... comments?\nSource: http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html\nEdit: It's true, I wrote all that just for the pun.\n. Thanks, will do.\n. ",
    "cgruber": "On 6 Mar 2013, at 4:59, Jesse Wilson wrote:\n\nOne thing I'm sad about is that when we split up dagger into \ndagger and dagger-compiler, we made it a lot easier to release a \ncrappy app. That refactor was well-intentioned but it makes our user's \nlives way more complicated. It's quite tricky to make sure that Dagger \ncompiler is reliably on the build path but not on the runtime class \npath. This may be broken for Square's apps today!\n\nYou can make your parent poms include that dependency globally with \ntrue.  This means it will always be on the \nannotation processing class path.  If there's nothing to generate, it'll \nslow the builds fractionally, but it seems to be a very very small \nfraction.\n. ",
    "tbroyer": "Back to Otto: @JakeWharton if you're worried about the number of classes generated, couldn't you generate a single Producer and Subscriber for a given class whose methods would do the dispatch to the correct method based on the event? (using cascading ifs with instanceof checks or something like that \u2013I don't know Otto well, so maybe event.getClass() == Xxx.class could work too\u2013)\nThat'd be somehow splitting the dispatching from the bus to the subscribers/producers, but it's all internal API (at least it should be, you should move them to an internal subpackage, similar to how dagger's Binding is in dagger.internal), something Otto has full control on.\nThe main difference with what you're doing here, and doing currently with reflection, would be that invalidate() would apply to the whole object rather than just a method, but given that it's an internal method that's always actually called for all the subscribers/producers for a given object, it wouldn't change anything.\n. ",
    "colinfindlay-nz": "Stupid question - does unregistering work for other people? Maybe I'm not using the new code properly or am momentarily retarded but...\nprivate static final String UNINSTALL_SUBSCRIBER =\n      \"    bus.uninstallSubscriber(%s.class, new %s(instance));\\n\";\nLooks like it tries to uninstall a new instance of the subscriber - thus leaving the original subscriber alive and well (And still receiving events!)\n. ",
    "jhugman": "Hi Jake,\nThanks for looking at my pull request.\nI realize that my implicit assumptions were that events were immutable, and that mutating events after dispatch would (certainly for me) feel a bit icky. Given enforcing immutability of an arbitrary object passed to you would be difficult at either compile time or runtime, this implementation of thread shifting would rely on those similar aesthetics. This convention is also expected by Scala Actors.\nI understand that one of the design tenets of Otto is extreme simplicity, and thread moving is not part of it. (I am resigned to the fact that you're not going to take my patch :().\nHowever, developers are already trying to deliver messages to subscribers on different threads. We are encouraged to move functionality off the UI thread as much as possible.\nRelying on the caller/poster to post on the correct thread leads to a whole bunch of problems (for me):\n1. The poster needs to know what is listening and what thread the listeners want to act on. This is an encapsulation problem.\n2. Every poster of the same event all need to get the correct thread. This starts off with lots of boiler plate Runnables and Handlers all over the place, and then tends to be moved to utility methods on bus. Nevertheless, the developer needs to think about threads each time she posts a message, and again when she wants to refactor a subscriber to run on a different thread.\n3. Subscribers to the same event cannot be on a different threads. My subscribers updateUi and updateRemoteServer were a deliberate examples of where this is not desirable. I cannot think of a way to achieve this with a single bus, a proliferation of Message classes or each subscriber manually looking after Thread shifting.\nMoving the threading decision to the subscriber is the important bit here. Putting an optional parameter on the annotation seemed like the least disgusting way of achieving this.\nIf you are looking at thread moving for version 2.0, and I have any say in it, then I would very much prefer a subscriber/actor chooses. Let me know if I can do anything to help.\n. I understand (and value) the desire to keep Otto simple.\nI'm currently using subscribers for:\n- UI manipulation on the MAIN thread\n- database reads, networking, disk I/O etc with ASYNC threads\n- database writes, and a few non-pure functions on the single-threaded BACKGROUND thread.\nI'm almost never using the default/POSTER_DECIDES thread.\nI quite like the string identifier idea put forward in #74, as I can see that there may be times when there may be a need for running lots of subscribers in a single-threaded context, but some of them are parallelisable. e.g. have database writes go in a single thread, and have another background thread.\nHowever:\n- I prefer enums to magic strings.\n- ASYNC threads are really useful.\nIf it helps you any with simplicity, other things I considered:\n- using value() instead of thread() in the @Subscribe annotation. This would make subscription more terse e.g. @Subscribe(ExecuteOn.MAIN), though would mean you can't add any more parameters.\n- having @ExecuteOn annotations, either with a single annotation with a parameter, or multiple annotations. I didn't think this was particularly discoverable as an API.\n- using the ThreadEnforcer to choose the threads if thread parameter is missing. This would mean that the defaults change based on what you passed to the constructor of Bus. This sounds sensible, but I think would end up confusing.\n. ",
    "chrisjenx": "Sorry mid creation jake accidently hit create :(\n. Sorry see question now. I guess its not within the goal of the lib\n. I actually dont want class walking.\n. No. So Event and EventTwo are different. A better example being. If class two looked like:\nclass Two extends One \n  //...\n}\nSo One is registered at its level. the bus is associated with One.class therefor, .post(new Event(..)) would make it to One without needing to do class walking.\n. I'm assuming getDeclared.. is quicker than getAnnotations() thus the choice to not walk the class's?\n. Correct, it would solve the problem. Was more a question than a problem, Of course I can work around it. \nJust wasn't sure what your goal of the lib was.\n. OK great, Cheers.\n. ",
    "RomainPiel": "Fair enough, the producer method will be helpful enough I guess. Thanks for your help.\n. I see so there is no way to know what's returned by produceEvent(), fair enough. It was just an idea, no worries.\n. Actually that's exactly my use case. I'd like to implement stuff in my generic class that will be inherited by subclasses with types.\nIdeally it would be nice if I'd have to skip this workaround:\n``` Java\npublic class MySubclass extends MyClass {\nString lastEvent;\n\n@Produce\npublic String produceEvent() {\n    return lastEvent;\n}\n\n}\n```\n(ie instantiating my producer in each subclass)\n. Sweet! I'll keep watching then :+1: \n. ",
    "fred8": "Hi all,\nJust coming on this thread now. I think it would be interesting to add it. I have a bunch of events that are basically very close and I would like very much to be able to create a generic one.\nAnyway to submit a pull request? \nThank you!\n. ",
    "venator85": "Yeah thanks for the clarification.\n. ",
    "daj": "\nWe will be removing this restriction in future versions of the library (without compromising the API by resorting to ugly things like subscription by convention).\n\nDo you still have plans to remove this restriction?  I'm assuming not as that could be disruptive (e.g. if somebody has accidentally @Subscribed in their superclasses, a new release would cause that code to run).  FYI, I don't think greenrobot's EventBus has this restriction.\nIf you are going to keep the restriction, then it would be great if Otto gave a compilation warning for using @Subscribe in an abstract base class.  That would have saved me some time. :-)\n\nThis is as much a performance optimization as it is an observation that usage of the event bus rarely required subscription on base classes.  \n\nFYI, two common situations where I've done this are:\n1) In a common base Fragment.\n2) In a common base REST integration test class (example highlights below).\nI just hit the second case now - I've been used to using EventBus instead of Otto, so I hit this limitation without expecting it.\n```\npublic abstract class BaseIntegrationTest {\npublic void setUp() throws Exception {\n    super.setUp();\n    bus.register(this);\n}\n\npublic void tearDown() throws Exception {\n    super.tearDown();\n\n    if (bus != null) {\n        bus.unregister(this);\n    }\n}\n\nprotected void resetLatch() {\n    latch = new CountDownLatch(1);\n}\n\nprotected void assertBusEventReceived() {\n    try {\n        logger.debug(\"Start waiting for event\");\n\n        if (latch.await(30, TimeUnit.SECONDS)) {\n            logger.debug(\"Bus event received\");\n        } else {\n            fail(\"Timeout waiting for bus event\");\n        }\n    } catch (InterruptedException e) {\n        fail(\"InterruptedException while waiting \" + e.getMessage());\n    }\n}\n\nprotected void login() {\n    // <my login code>\n    assertBusEventReceived();\n}\n\n@Subscribe\npublic void authenticationCallback(LoginResponse response) {\n    if (response.isError()) {\n        fail(\"Request failed\");\n    } else {\n        latch.countDown();\n    }\n}\n\n}\n```\n. ",
    "giorgio-zamparelli": "I'm looking for a solution to the same problem.\nIn my model I've many objects called Meal. Each Meal have one unique id. I need a way to subscribe and publish to the MealChangedEvent based on the specific id of the meal.\nhusrevo proposed solution would work also for me.\nOtherwise are there ways to achieve this with the current version of Otto?\n. ",
    "esteewhy": "+1\n(event.id proved to be working)\n. ",
    "ajostergaard": "@swankjesse Does your emphatic no include the idea of providing some way for the source of the events to know whether there actually were any subscribers at all?\n. @swankjesse - no, to make sure somebody dealt with the event so that the source can handle it as a fallback (e.g. by raising a Notification as per commonsguy).\n@pforhan - if the DeadEvent comes loaded with enough of the original event then that certainly helps. :) Is there any documentation on the events Otto raises? Perhaps I've just been completely blind?!?\nActually I asked this question before finding out that LocalBroadcastManager returns false if there were no subscribers so I kind of don't need this anymore anyway - sorry for the 'noise'!\n. Thanks guys. :)\n. ",
    "holmes": "Stacktrace?\nWe've mocked it using Mockito without any issues.\n. Are you sure you're actually using the mock in your class under test?\nFeel free to show us your code\nOn Jun 18, 2013 11:54 AM, \"Felipe Lima\" notifications@github.com wrote:\n\nI'm using mockito as well.\nIf I replace the Bus object with a plain Object object, it works fine.\nIm doing verify(bus).register(listener) and the test fails since there\nwere no interactions with that mock\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/87#issuecomment-19632700\n.\n. Travis failure. I built locally and it's a gem:\n\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO] \n[INFO] Otto (Parent) ..................................... SUCCESS [0.579s]\n[INFO] Otto .............................................. SUCCESS [11.602s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 12.311s\n[INFO] Finished at: Thu Jan 23 16:52:58 PST 2014\n[INFO] Final Memory: 20M/81M\n[INFO] ------------------------------------------------------------------------\n. ",
    "naco-siren": "I have the same issue.\n. ",
    "beworker": "Ok, I'll do.\n. Done with checkstyle. Does it look better now?\n. ",
    "anupcowkur": "That makes a lot of sense. Maybe you guys can make it an advanced option like ThreadEnforcer.ANY for those who need it. Just a feature request. Thanks for taking the time to reply!\n. ",
    "npombourcq": "I have just signed it.\n. ",
    "SebastianEngel": "See @JakeWharton's answer in the G+ thread at https://plus.google.com/106183159594179737258/posts/1rzvYZSF7zm\n\"We never unregister singletons. They stay on the bus until the process dies.\"\n\"We don't like registering things in their constructor.\"\nJake mentioned to post a \"gist about some Dagger trickery\" they use. I'm also still waiting eagerly for it. :)\n. ",
    "twobitlabs": "It'd be great if Otto supported registering with a WeakReference so you could safely register POJO's or classes like Android Adapters that don't themselves know how long their lifecycle should be.\n. ",
    "chrispix": "@JakeWharton how so?\n. Isn't it as much of an anti-pattern to leak every object that subscribes? Wouldn't it be cleaner to just wrap every subscriber in a WeakReference? That would handle both the POJO case and missed calls to unregister. And callers could still explicitly register and unregister on appropriate state changes within their lifecycle.\n. ",
    "thuss": "I'd argue that there's no need for strong references to registered objects in an event bus, ever. An event bus should never be used to keep an object alive and in memory.\nOf course changing Otto to use weak references could present backwards compatibility issues for  users that do use it to keep objects alive but adding a new registerWeak method that then wraps the object in a WeakReference would work for everyone and give you the power to choose.\nI'd just like to gauge whether there'd be any openness towards a pull request. If not, that's fine, I'll drop it.\n. ",
    "vangorra": "\"just being lazy and not wanting to properly tie registration to a lifecycle or you are not in proper control of a lifecycle \"\nThe same argument can be made for memory management or any object and is always a huge headache because humans do not track allocations as well as machines. Hence the purpose of a garbage collection system.\nJava is fundamentally based on garbage collection and is \"lazy\" when it comes to memory management. Java developers have grown accustomed to expecting this sort of \"lazy\" behavior on many levels of an api. While introducing weak references can cause more issues, it can also fix a lot of problems too. Notably, imperfect human problems.\nWeak referencing doesn't have to be the default but I for one would at least like to be able to control how my objects are registered and unregistered. Perhaps an abstract class or a subscriber storage interface?\n. ",
    "necronet": "I don't why the discussion the Bus will secure and holde your object while is registered once you unsubscribe to it then the reference would be garbage collectable having Weak reference on the bus will defeat the purpose as it would not provide any certain that the object would still be around.\n. How did you register the object more than once? I've tried that (by mistake) and throws an exception!\n. As far as I know otto does not allow to double register an object can you be more specific?  can you provide an example?\n. Can you provide an example where you would need a delay? \n. ",
    "23code": "when click the button,throw this exception:\n11-27 11:24:44.515: E/DatabaseUtils(2951): Writing exception to parcel\n11-27 11:24:44.515: E/DatabaseUtils(2951): java.lang.SecurityException: Permission Denial: get/set setting for user asks to run as user -2 but is calling from user 0; this requires android.permission.INTERACT_ACROSS_USERS_FULL\n11-27 11:24:44.515: E/DatabaseUtils(2951):  at com.android.server.am.ActivityManagerService.handleIncomingUser(ActivityManagerService.java:13082)\n11-27 11:24:44.515: E/DatabaseUtils(2951):  at android.app.ActivityManager.handleIncomingUser(ActivityManager.java:2038)\n11-27 11:24:44.515: E/DatabaseUtils(2951):  at com.android.providers.settings.SettingsProvider.callFromPackage(SettingsProvider.java:577)\n11-27 11:24:44.515: E/DatabaseUtils(2951):  at android.content.ContentProvider$Transport.call(ContentProvider.java:279)\n11-27 11:24:44.515: E/DatabaseUtils(2951):  at android.content.ContentProviderNative.onTransact(ContentProviderNative.java:273)\n. this is otto demo(LocationActivity),i do not change anything. only add Proguard and packaged into APK and it exception. can you have a try  packaged LocationActivity demo into APK .or help me solve the problem. thanks\n. this is the demo project.  http://pan.baidu.com/s/1Ca2xl\nI am very happy to find this library, if because of confusion package cannot be used, it is very regrettable.\n. @imminent @JakeWharton   but \"android.permission.INTERACT_ACROSS_USERS_FULL\" is system permission.i has no way to solve this. can you help me ? did you use otto success when Proguard to apk?\n. ps:otto use directly in debug mode\n. i found the exception what i say above is not otto problem, that is my phone system problem.\nbut when Proguard packaged into APK, otto can not run  is the fact.\nhope fix , thanksss\n. who can Proguard otto demo(LocationActivity) to apk , and run correct \uff1f \n. @loganj  @imminent  I am a Chinese,my english is poor, maybe I didn't express clearly. i mean when i proguard the sample app.  it fails.\nin debug mode is run Perfect.\n. @tanggod  not fixed the problem,i has give up to use it.\n. @tanggod  \u6211\u4e5f\u662f\uff0c\u7528broadcast\u4e00\u6837\u53ef\u4ee5\u89e3\u51b3\uff0c\u5c31\u662f\u6bd4\u8f83\u9ebb\u70e6\n. ",
    "zhihuitang": "hi staryanwx, have you fixed the problem? I have the same problem with. My app run perfectly in Debug mode, but throws exception in non-debug mode.\n. \u8c22\u8c22\u4f60\u7684\u56de\u590d\u3002\n\u6211\u5f00\u53d1\u4e00\u4e2a\u7a0b\u5e8f\u641e\u4e861\u4e2a\u591a\u6708\uff0c\u8c03\u8bd5\u6a21\u5f0f\u4e0b\u8fd0\u884c\u90fd\u6ca1\u6709\u95ee\u9898\uff1b\u6700\u540e\u51c6\u5907\u53d1\u5e03\u7684\u65f6\u5019\uff0c\u5728\u6211\u624b\u673a\u4e0a\u8bd5\u4e86\u4e0b\uff0c\u53d1\u73b0\u6709\u95ee\u9898\u3002\u4eca\u5929\u641c\u4e86\u4e00\u5929\uff0c\u597d\u591a\u8001\u5916\u9047\u89c1\u4e86\u540c\u6837\u7684\u95ee\u9898\uff0c\u4f46\u90fd\u6ca1\u6709\u89e3\u51b3\u65b9\u6848\u3002\n\u641e\u4e0d\u5b9a\u6211\u7684\u5de5\u4f5c\u5c31\u8981\u767d\u8d39\u4e86\u3002\u3002\u3002\u3002\u3002\u5d29\u6e83\nOn Mon, Dec 30, 2013 at 2:24 AM, staryanwx notifications@github.com wrote:\n\n@tanggod https://github.com/tanggod not fixed the problem,i has give up\nto use it.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/otto/issues/100#issuecomment-31330214\n.\n. \n",
    "Kusand": "Cool, thanks for the link to the reading. Much appreciated. I wasn't positive there would be anything you could do short of returning to getMethods and giving up on the private-method-fast-fail, but wanted to note it.\n. ",
    "amangel": "If an event is posted, and there are no subscribers to receive it, a DeadEvent will be posted that contains the event itself, and the object that created it.\nSee: https://github.com/square/otto/blob/master/library/src/main/java/com/squareup/otto/DeadEvent.java\n. ",
    "grodin": "Thanks for the explanation, that makes a lot of sense.\nIf I wanted to submit a pull request to make this explicit in the Javadoc and website, I should target the 2.0-wip branch, correct?\n. ",
    "creativepsyco": "Currently I am subclassing Otto's event bus and explicitly allowing event\nproducers to choose which thread to post the event to. I only handle either\nMain thread or ANY thread in which case I don't care about the thread it\ngets posted to.\nOn Thu, Jan 8, 2015 at 5:19 PM, Jake Wharton notifications@github.com\nwrote:\n\nWe'll probably just track what Guava does. They're looking at\nannotation-based Executors last I checked. This could be easily\naccomplished with that mechanism.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/108#issuecomment-69154232.\n\n\nMohit Singh KANWAL (Mr)\n[image: Facebook] http://facebook.com/mohitkanwal  [image: Twitter]\nhttp://twitter.com/mohitkanwal\n. ",
    "csobrinho": "+1\n. ",
    "slapsys": ":+1: Would love to see this merged.\n. ",
    "falkorichter": "Looks nice, as someone related to this pull-request I approve it :+1: \n. ",
    "Disruption": ":+1: Seems very nice!\n. But that approach only gives you the option of \"1 class up, or all the way up\", while this approach lets you customize where you stop. Why is that worse?\nAnyways, the annotation could be parametrized, or a new annotation could be added to support both behaviours (one class up, all the way up), I don't think they are mutually exclusive.\n. @JakeWharton But isn't that not done for the sake of performance, as you commented on https://github.com/square/otto/issues/26#issuecomment-9343469 ? That's why the annotation seems like a nice idea, so the people not needing to traverse the whole hierarchy can just keep the one level code inspection/method traversing, and the ones wanting to go higher can manually activate it (Either fully hierarchy as you suggest, or one level, whatever).\nCheers!\n. @imminent Following the same reasoning, that also implies that you can not override the \"onEvent -> doSomething\" in order to call super and then do your things, but to listen to the event separately in two ways, which in turn means you don't know in what order it will be called, which is bad for a self-contained scenario. (That is, in the case of extensions, you usually want to call the super code first, and then your own if any). With the approach of multiple one-level listeners subscribed for specific behaviour, you have a 'random' execution order.\nOf course you can solve that in some elegant ways, like adding an \"afterEvent\" abstract method, and have it implemented, and so on, but sometimes it's not \"so trivial\".\nI think that having the option of choosing if you want to traverse the hierarchy is good, as it's not forced to the user in any way. A user wanting that behaviour have to explicitly annotate the class to get it, if not, he will get the current behaviour, which seems fair enough.\n. ",
    "tobiasheine": "+1\n. ",
    "paddyzab": "+1\n. ",
    "SierraGolf": "@JakeWharton can you give some feedback on this PR?\n. @JakeWharton / @rjrjr I agree that the approach to go to a set of specified packages, where the default would be java.* and android.* is a better implementation. It will actually make Otto more of a framework which follows the \"principle of least astonishment\" (it will simply work, no further annotation needed).\nMaybe in a first draft the packages can be hardcoded and be made configurable as people start to see the need for that?\nIf you guys agree, I will provide the above mentioned alternative implementation to this PR.\n. @JakeWharton / @rjrjr any feedback on my last comment, it has been a couple of month.\n. ",
    "rjrjr": "-1. This is clunky. Requiring subclasses to know which superclasses, if any, need to subscribe is almost no improvement over the current situation. \n. ",
    "thalespf": "+1\n. ",
    "tlahoda": "Anyway you want to do it (annotation or walk the path up to Object for all I care), can we please get this functionality in? Otto is mostly useless to me without it and I love the concept and how it has been done. The apps I am writing will benefit from Otto and this if we can get it in.\n. ",
    "411805662": "Strings carry less info \u3002sometime,we need pass a List or a Object.\nif i post(new User()), that will cause more than one listener recieve this event, but actually i just hope one of them accept.\n. i means I need a filter to tell subscriber whether should accept the event\u3002and how to design the filter\n. ",
    "Wavesonics": "Awesome that'd be great. Especially if we could get the original stack trace.\n. ",
    "cushon": "You're right, isBridge is sufficient. I removed the isSynthetic check.\nBackporting 7e10ebf works too, but it should be updated to handle Produce.\n. ",
    "fhur": "Could you post some code just to get a better idea of why this is happening?\n. ",
    "ggalmazor": "I'm realizing that I've changed the minor version number... I can rollback that change if needed. Apologies.\n. ",
    "vpratfr": "\nWhat would happen if you were producing both A1 and A2?\n\nI would have expected in that case that both A1 and A2 get delivered to the subcribers of A. In fact I would expect the producers to simply have the same behaviour as when using posting.\n. ",
    "alexustinovsm": "For instance,\n``` java\npublic class A {\n  // This code will work\n  @Subscribe public onSomeEvent(SomeEvent event) { / my code here / }\n}\n// This code won't work because HandlerFinder doesn't find subscribe\npublic class A1 extends A {}\n// This code won't work because HandlerFinder doesn't find subscribe\npublic class A2 extends A {}\n```\nI think this is a bug. I don't want to create the same method at 10 different children of A. I think it's very strange.\n. +1 the same problem\n. ",
    "sferra": "@alexustinovsm While the issue you describe doesn't relate to producers, I must agree that it is buggy behavior. The workaround would currently be to explicitly implement onSomeEvent in both A1and A2 so the methods are found:\n```\npublic class A1 extends A {\n  @Subscribe public onSomeEvent(SomeEvent event) {\n    super.onSomeEvent(event);\n  }\n}\npublic class A2 extends A {\n  @Subscribe public onSomeEvent(SomeEvent event) {\n    super.onSomeEvent(event);\n  }\n}\n```\nMaybe open a separate ticket for this issue?\n. ",
    "adrien-aubel": "I agree with @sferra, this is a behavior that is surprising. I think this should be at least mentioned in the documentation.\n. ",
    "gervaisb": "\nThat may be mockable then. Still, it's almost like you're testing the bus more than anything.\n\nExactly. That's why I will left my test as is. Thanks\n. ",
    "lakshanwd": "Oops. I thought this is an android library.\nAnyway Thanks!\n. ",
    "mbaroukh": "Thanks for your comment.\nThe fact is that it is extremmely more complicated to register / wait than just asking for the event.\nWhen registering/waiting, as you said, there may be no producer registered and then, you have to wait for an arbitrary amount of time before deciding that there won't be any data.\nIn a concrete case, I wanted to display a message when exiting from an activity according to some data returned from a Producer. To do this, I have to register my activity and keep a reference of the last produced data. According to me, this is not a good thing. I prefer to ask for the data when needed. And ask for it simply. If there is no producer registered, there is no data and that's fine.\n. > Before the register method finishes, any Producers on the Bus for Events you care about will have sent those Events.\nNo, not always.\nYou can, as I do and as suggest by Jake Warton himself, override post method to post on different threads (https://github.com/square/otto/issues/38).\nSo be carreful : you should not assume it is synchronous.\n\nIf you do want to use Otto here, then you should register for that Event \nand store the data you care to present on the Activity.\n\nThat is exactly the point I found as a bad design !\nI don't wan't all registered listener to keep a reference on data they will \"maybe\" use later.\nOtto is an event Bus, I'm ok with this. But it is also a bus that can be use to link different part of an app without having them to know each other.\nAnd by the way,\n\npurpose is for the listener to not ask for the data, but to receive the data when it becomes available.\n\nNot exactly right : when registering, you are asking the Producer to return data to you. But those data might not have been pushed previously and it is not really an event. Those data are not created because of an event but because you are registering. So it is exactly the same result as asking them directly, no ? (but far far more complicated)\n. Ok. I still think you are completely wrong but if I did not convinced you, too bad for me (and others developpers :) ).\nI will stick with my fork.\n. ",
    "nkeskinov": "@tungle Any luck on finding the cause or more details about this? I can confirm it is happening (version 1.3.5) without apparent reason:\n```\n// \"this\" is an Activity\n@Override\npublic void onResume() {\n    super.onResume();\nBusProvider.getInstance().register(this);\n\n// unrelated code\n\n}\n@Override\npublic void onPause() {\n    super.onPause();\nBusProvider.getInstance().unregister(this);\n\n}\n```\n. Thanks, I will try it. However, I plan to move to EventBus soon, so I am not sure if I will see the effects, but your suggestion makes sense.\n. Sorry, I moved to EventBus in meantime. Cannot confirm that the last proposed solution fixes the problem.\n. ",
    "albaraam": "I know I'm late @nkeskinov but can try to call \"unregister\" in \"onPause\" before calling the super like the following:\njava\n@Override\npublic void onPause() {\n    BusProvider.getInstance().unregister(this);\n    super.onPause();\n}\n. ",
    "adgeg": "We have exactly the same crash in our application. In our case, the unregistration is properly made before the call to super.onPause(), as @albaraamishlawi has suggested.\nFor us, this only appears on Samsung devices. And after a quick search, I can see issues where Activity#onPause() may have been called without Activity#onResume() on those devices... \n. ",
    "informramiz": "Try subclassing Bus. Something like\n``` java\npublic class YourBus extends Bus{\nprivate ArrayList registeredObjects = new ArrayList<>();\n@Override\npublic void register(Object object) {\n    if (!registeredObjects.contains(object)) {\n        registeredObjects.add(object);\n        super.register(object);\n    }\n}\n@Override\npublic void unregister(Object object) {\n    if (registeredObjects.contains(object)) {\n        registeredObjects.remove(object);\n        super.unregister(object);\n    }\n}\n}\n```\nPlease note that this will hide programmer errors by not throwing exception in any case of register/unregister. \n. ",
    "aleripe": "Same problem here. Any solution?\n. ",
    "jackcsk": "We've seen this issue from time to time on not only Samsung, but also OPPO and Sony devices (as reported by Fabrics), across Android 4 and 5.\nWe've implemented the register and unregister routine in onStart & onStop respectively since the beginning, so it is obvious that in some cases, onStart() was not called properly. (nope, there is no other call that may interrupt the register(this) call in onStart(), unless it is from AppCompatActivity or its parent class)\nWe've ended up using try-catch to wrap the exception\n. ",
    "usmaanz": "I have just seen this error occur in a similar set-up. It's a little hard to grasp but please feel free to question if you don't understand:\nhttp://stackoverflow.com/questions/40076459/otto-unregistering-the-same-instance\nEssentially, my Activity has a ViewPager and Two Fragments which try to Register and Unregister.\nWhen I close the Activity, it crashes because the FIRST fragment successfully unregisters but when the second fragment tries to unregister, the \"this\" parameter is for some strange, strange reason, the same reference object as the first one...Which has obviously been unregistered.\nWhy/how is this even possible?\n. Why is there no isRegistered method at least to check if it is registered or not?\n. ",
    "Nolanus": "As Otto needs to keep a reference to the registered class instance, i assume your object wont be garbage collected and thus stays in memory as long as the bus is \"alive\" (= not removed from memory).\nWhere to put the unregister(this) call depends on your business logic. Best might be to call the unregister(regularObject) before removing the reference to it from your own classes.\n```\nclass ISubscribe {\n   public ISubscribe(){\n     Bus.getInstance().register(this).\n   }\n   @Subscribe\n   public void sub(Object o){\n}\n}\nclass TheApp {\n   private ISubscribe is = new ISubscribe();\npublic void doFancyStuff(){\n      // I need a new ISubscribe instance now\n      Bus.getInstance().unregister(is);\n      is = new ISubscribe();\n   }\n}\n```\n. ",
    "bgw": "In an application I'm working on, I'd like to group all network events together by HTTP method, but I'd also like to be able to group them by the type of resources they're accessing (eg, user account). In this way, interfaces could act as tags.\nThis probably has an adverse effect on performance, but only if the posted events implement interfaces.\n. This isn't something I need, just something that would be nice to have. It feels inconsistent to me that otto traverses the class list, but not the interfaces.\nI think the questions are does this make sense in otto?, could it make dependent code cleaner? and is it worth the performance hit?\n. @imminent, I'll fix it later today.\ngit-blame reveals this was the commit that removed interface support, but the commit message doesn't reveal why.\nAssuming registration is fairly rare, and since custom events probably won't inherit any/many interfaces, the performance hit should be minimal.\n. Sorry for dropping the ball on this, university finals snuck up on me. I haven't forgotten.\n. ",
    "pauldambra": "Ah, so Otto has the Apache license because it is copied in from Guava?\nThanks... \n. ",
    "laenger": "Nvm, I just read on the website that this is an explicit design decision. Sorry for that.\n. ",
    "aheuermann": "Updated. Let me know if this is closer to what you had in mind.\n. It was not. I can give it another go tomorrow and see if I can mirror it better.\n. ",
    "filnik": "Hi, is there any news about this feature? It would be really useful to have it in production :) (thanks aheuermann)\n. ",
    "saurabytes": "That's right, I was doing something wrong which I fixed later. But having an api to see if already registered wood avoid such scenarios \n. In a static instance of a event handler. The activity asked to register twice and there was no exception.\n. I my activity i registered to a bus and forgot to unregister(by mistake). Later when that actiivity was created again it got registered again and so on so forth. This ended up in receiving multiple events(as many times the activity was created) in the handler.\n. ",
    "Sivanga": "Same thing for us.\n. ",
    "xsveda": "I don't think it has anythink to do with Otto.\nandroid.os.PersistableBundle is a class introduced in Lollipop for a new mechanism of \"resurecting\" apps after i.e. system restart. See Activity.onCreate(Bundle, PersistableBundle).\nI saw this error comming from RoboGuice library when injecting an Activity, but unfortunately I did not find the proper cause yet...\n. ",
    "DrorFichman": "We had a (similar) issue when using Bus in a class which referenced 'Objects' type.\nResolved when we removed the use of this specific type.\n. ",
    "CorentinPacaud": "I have the same issue after deploy successfully on a Lollipop device and try to deploy on a 4.4.4 device.\nWhen I try to re deploy on Android 5.0, it works. \nTrying to set targetSDK to 19 doesn't work.\nSo, what can we do to correct this ?\n. The StackOverflow topic : http://stackoverflow.com/questions/28857860/classnotfoundexception-didnt-find-class-android-os-persistablebundle-otto-an\n[RESOLVED]\n. It's said in the Stackoverflow Topic.\n. Maybe you mean this function : Activity : protected void onSaveInstanceState (Bundle outState)\nIt's different than onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState)\nOtherwise, you need to check if your on API 21 and over or not.\n. ",
    "caipivara": "So How can I manage it?\n. But what If I need to use onSaveInstanceState ? so how can I manage the save on my actual activity state? \n. Opa, yeah! thanks!!\n. ",
    "lkw103037": "I fix it!  @CorentinPacaud  @xsveda is right!   change function to   Activity.onCreate(Bundle)  or  onSaveInstanceState (Bundle outState) . it's work fine.  :)\n. ",
    "anisart": "Sorry, cleaning project resolve this issue)\n. ",
    "olegosipenko": "Sure. I have an activity hosting fragment with viewpager also hosting fragments in which I have list of items. Clicking on item I need to open new detail activity and I doing it using startActivityForResult in my activity. So when I come back from new activity result from new activity comes to calling activity, not to fragment and I am using Otto to post event with this result to the nested fragment. But If I post event without delay I get a NPE, cause fields in fragment not restored at that time. So I post event with small delay (round 5 ms) to avoid this NPE.\n. ",
    "clackbib": "Mainly for debugging purposes.\nOtto-plugin can help when keeping track/ debugging a project that relies on otto, but a project I work on is pretty big, and I feel like having base logging for this could help getting rid of unwanted/unused subscribes.\nI wen ahead and implemented what i think is a possible solution: \n435dfe762fe81803ac77472d3406640e8dd0039a\nNot necessarily the best one, but im having trouble getting it to run with maven. Is there any reason the project hasn't been ported to gradle?\n. Code formatting makes it look like I changed a lot more that what is actually different, sorry\n. Fixing right now\n. Here:\n806c5483b93f8236722ef4eb8b6219e7ad1edd4c\n. ",
    "manijshrestha": "Yep I understand, thanks for taking time reviewing the request.\n. ",
    "egor-n": "The event produced in 5 is fired but no one is listening to it, so basically, nothing happens - activity instance \"2\" doesn't know about the event from 5.\nTo solve this problem you can use @Produce annotation. Read more about it here in the \"Producing\" section.\nEssentially it goes like this:\n1. cache somewhere your data right before 5\n2. a method annotated with @Produce should return this data\n3. once activity instance \"2\" registers it immediately receives an event identical to event in 5.\n. ",
    "ppiech": "Makes sense.  So do you consider it a bug and something addressed in the future, or just a limitation.  I assume I can work around it by synchronizing around registration/unregistration (as long as events are not emitted as a side effect).\n. ",
    "kennydude": "I managed to work around it for now (using a manager class per activity for the bus), but thanks anyway I assume this is so that it isn't slowing things down too much.\n. ",
    "KleinerHacker": "Sorry, but if this problem won't fix the framework is not usable with android annotations.\n. ",
    "ewintory": "From EventBus.getInstance().post(sms); it seems to me that you're mixing Otto with Greenrobot's EventBus. @Produce annotation is only provided by Otto. If you want to use Otto you can do like this:\n``` java\npublic class OttoBus {\n        private static Bus bus;\n    public static Bus getInstance(){\n        if (bus == null)\n            bus = new Bus();\n\n        return bus;\n    }\n}\n\n```\nand later OttoBus.getInstance().post(sms);. \n. ",
    "ZkHaider": "Right thanks a lot Jake, I found another library here: https://github.com/tajchert/BusWear\nI was wondering why there was a specific library only for Wear. Thought maybe there is an issue with current libraries? \nThanks a lot for letting me know so quickly, I use otto quite a lot in Android, want to see how it will perform for sending and receiving sensor data within the wear module.\n. Right makes sense, I might actually end up using that then. Are you going to support that in the future?\n. ",
    "ashoykh": "Done\n. Hey Jake, do you have any other concerns about the pull request.  Thanks.\n. Makes sense.  I updated it so the caller of loadAnnotatedMethods passes in the map for subscriber/producer as an out parameter.  That way there's no get required.\n. Sorry for the build failure, I tested it locally with 'mvn test'.  Will fix the line length error.\n. Done with the latest change.\n. Hey Jake, I made it so that on a cache miss we only require a put rather then a put and a get.  Let me know if you'd like further refactoring.  Thanks!\n. Thanks for being so responsive!\nDo you have an estimate for when 1.3.8 will be available?\nThanks!\nOn Mon, Jun 15, 2015 at 10:57 PM, Jake Wharton notifications@github.com\nwrote:\n\nThanks for doing this.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/pull/157#issuecomment-112304245.\n. \n",
    "ManoyloK": "I seems like your TextView change = null, try  BusProvider.getInstance().register(this) in onViewCreated. ",
    "yunarta": "sorry for me being newbie on pull request. actually i only wanted to merge the first commit. while the other four is for my own dev usage.\nactually rather than removing android dependency, but this changes would make it easier to compile when i pull otto as submodule.\nwhile for the thread enforcing, i'm using otto for a app client running in background service. as well as for google app compute project. found that its really useful :+1:\nthe other five commits does allows same object to be produced by different producer.\n. ",
    "shivamsingh": "Using following as BUS.\n``` java\npublic class MainThreadBus extends Bus {\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\n@Override\npublic void post(final Object event) {\n    if (Looper.myLooper() == Looper.getMainLooper()) {\n        super.post(event);\n    } else {\n        mHandler.post(() -> MainThreadBus.super.post(event));\n    }\n}\n\n}\n```\n. ",
    "zhouhaibing089": "Quoted from official site\n\nRegistering will only find methods on the immediate class type. Unlike the Guava event bus, Otto will not traverse the class hierarchy and add methods from base classes or interfaces that are annotated. This is an explicit design decision to improve performance of the library as well as keep your code simple and unambiguous.\n. \n",
    "bahacan19": "thanks @zhouhaibing089 \n. ",
    "motcwang": "Combine will be better\uff01\n. ",
    "HugoGresse": "as Otto is now deprecated, I can close this issue I think. \n. ",
    "rtoshiro": "Well, just because I was unregistering my objects using activity/fragment life cycles and I wanted not to worry about registering calls.\n. Sure, I agree with you. It was just a lack of love about a code I'm testing. Thank you anyway for your answer and time.\n. ",
    "botunge": "hmm. how to get travis ci to update android sdk....\n. ",
    "felipecaldas": "Didn't work for me. I had it first onReume and now at onStart. I dont get the message in my Subscribe method. \n. Thanks Jake and Luaz.\nI can confirm that the interface used to subscribe is com.squareup.otto.Subscribe\nI confirm that register() is called in onStart() in both Activities and unregister it onStop()\nThe Activity2, the one that posts() is registered after Activity1.\nBasically, Activity1 calls Activity2 and then Activity2 sends a message to Activity1.\nThat's a correct pattern, right?\n. ok, I just tried removing the unregister() call from both Activities and now I got the event...\nis it maybe because when Activity1 calls Activity2 via Intent, the onStop() method is called and therefore unregistering the bus?\n. Dang, I completely thought that Otto was meant for communication between activities! That would've been really nice :)\nThanks for the info Jake.\nI suppose EventBus from GreenRobot also does not do this sort of job?\n. Just tried EventBus with RegisterSticky. It is pretty much working the same way as Otto. I cannot unregister Activity1, it needs to always listen\nNow the problem is that I have a GoogleApiClient class and the method that gets called from Activity2 needs it to be connected.\nSince that event is by-passing the onStart() of Activity1 (where mGoogleApiClient.connect() ) is, the object is not connect. And then I fail. Probably a second later, the onStart() is called and it gets connected.\nI will have to think of a different architecture.\n. ",
    "jemshit": "In Fragments , registering/unregistering on onResume() and onPause() works good for me. Now i'm having trouble in DialogFragment which this didn't work. So i register/unregister on onAttach() and onDetach(). Found thread about this: http://stackoverflow.com/questions/32165006/otto-event-no-firing\n. ",
    "JarvanMo": "ok thank you\n. ",
    "luaz": "\nCheck if you are using the correct \"Subscribe\" (Don't accidentally use Google's EventBus)\nMake sure  BusProvider.getInstance().register(this) is called in Activity2 (and not unregister) before post is called\n. \n",
    "gfx": "Oh, really?\nIs there any example to replace Otto with RxJava?\n. I think RxJava subjects are good replacement of Otto in some cases, but if you think Otto is deprecated, you'd better to explain how to. \n. Thanks. Can you add it to README please?\n. ",
    "Tolriq": "@swankjesse Is there any advice / tips on the producer pattern (@Produce) with RxJava can't seem to find related docs ?\n. ",
    "Giszmo": "I strongly disagree with deprecation in absence of a lean replacement.\neventBus.register(this);\n...\n@Subscribe\npublic void somethingHappened(SomeEvent event) {\n// do something\n}\nis not the same as \neventBus\n    .observable(SomeEvent.class)\n    .subscribe(event -> {\n      // do something\n    });\nnot to talk about the worse \"replacements\" I found, with instanceof checks.\n. If you think it's proguard, then please try that out. Deactivate proguard and see if it works. Also the title of your issue does not match the content.. ",
    "X-Strange": "I have the same issue, after add GCM to my app. I enabled multiDex compilation to solve 64k issue. \nMy dependencies (fragment):\n    compile 'com.squareup:otto:1.3.8'//Otto Bus\n    compile 'com.squareup.picasso:picasso:2.5.2'//Picasso\n    compile('com.squareup.retrofit:retrofit:2.0.0-beta2') {\n        exclude module: 'okhttp'\n    }\n    compile 'com.squareup.okhttp:okhttp:2.5.0' //OkHttp\n    compile 'com.squareup.retrofit:converter-gson:2.0.0-beta2' //Gson\nAnyone has an idea how to fix this?\n. ",
    "nanzee": "Same problem, looks to be happening only when multiDex is enabled and is only happening on emulator.  No issue on physical device.\n. ",
    "jjhesk": "+1. i have the same error too. I found this on stackoverflow but im not sure if it is the real fix of it.\n. ",
    "drakeet": "BTW: Maybe you made a mistake on the onCreate method, the SDK add a new\nonCreate method after 21, many people will overwrite the method then made\nerrors.\n\u4e16\u5916\u6843\u6e90 notifications@github.com\u4e8e2016\u5e745\u670813\u65e5 \u5468\u4e9409:26\u5199\u9053\uff1a\n\nI found this on stackoverflow\nhttp://stackoverflow.com/questions/28857860/classnotfoundexception-didnt-find-class-android-os-persistablebundle-otto-an\nbut im not sure if it is the real fix of it.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/square/otto/issues/183#issuecomment-218929839\n. \n",
    "kartiksetia": "This is because of 64K android method error. you have to add multidex library in your application class .\nhttp://stackoverflow.com/questions/26609734/how-to-enable-multidexing-with-the-new-android-multidex-support-library\n. ",
    "ChrashTest": "its fixed.\n. ",
    "tuanhs66": "Hi ChrashTest,\nYou've handled it happen.\nPlease help me!\nThanks!\n. ",
    "shanuka": "+1. ",
    "xueleitt": "thanks, I registered it twice.\n. ",
    "gauravsak": "@seransaca This might help.\n. @lectricas Did you get an exception in the first case? If not, what went wrong?\n. ",
    "chokhmah": "Thanks.\nMy goal is to ensure that the Bus#post() will be run on main thread, because there are some method/class that calls Bus#post on a background thread. I used ThreadEnforcer.ANY and ThreadEnforcer.MAIN but it throws an exception when calling from a different thread.  Also The bus I created is a singleton.\nMy current implementation is I put Bus#post() inside a Handler#post() to make sure it is on the main thread. I am also thinking if I can customize the ThreadEnforcer to run the Bus#post on the main thread so that I won't use the Handler#post in handling the Bus#post.\nDoes my current implementation correct? or am I overthinking the approach on ThreadEnforcer?\n. Okay. Thank you.\n. ",
    "lectricas": "@gauravsak  no, I haven't got any exceptions. I got just nothing. Maybe it don't know how to work with primitives\n. ",
    "JesseBuss": "PR here: https://github.com/square/otto/pull/193\n. ",
    "aaronpl1": "Who are you . ",
    "Kristaps89": "Thank you for you reply.. I disabled \"Instant run\", so I can fix this error.. ",
    "MarcosiOSdev": "There are some code that I use in my project. \nhttps://stackoverflow.com/questions/48506769/otto-bus-doesnt-work-when-i-use-post\nI only changed the version gradle , it was only thing  I've done ! . ",
    "rcdickerson": "Seems like we could save some map lookups by iterating through foundHandlersMap's entry set (instead of its key set).\n. Was the intention to guard access to \"valid\" with EventHandler.this? If so, you're missing a synchronized here. Instead of using synchronized, maybe we want an AtomicBoolean? (In general, I agree with @loganj that we should minimize locking to avoid the possibility of surprising deadlocks and performance hits.)\n. ",
    "StephenBarlow": "@JakeWharton I added language explaining non-synchronous situations. Am I correct in that post isn't synchronous if it's called during the execution of any other bus method, or is it just during another post()?\n. ",
    "jlabanca": "@Test(expected = NullPointException.class) is more JUnit4-ish\n. "
}