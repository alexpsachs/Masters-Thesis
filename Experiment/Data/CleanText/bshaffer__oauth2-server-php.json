{
    "bshaffer": "This is waiting on the MAC grant type specification to be completed\n. http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac\n. - Update the Response Object section for changes in the code (namely, grantAccessToken requires a Request Object\n- Link Grant Types to OAuth2 Draft\n. closing - too generic\n. Closing - too generic\n. Thank you for reporting this!  The new update should fix this problem, but I changed Storage\\UserCredentialsInterface to require getUserDetails.  This new method can return true, an empty array(), or an array of details for successful client retrieval\n. I have no idea why this issue was submitted, as it has nothing to do with the oauth2 server library\n. Thank you for submitting this pull request!\nthe PDO->execute statement binds the parameters in the same way that bindParam does, it simply uses PDO::PARAM_STRING as a default (see the docs)\nSo that being the case, how are these changes more secure?\n. As stated in my inline comment, there is no security benefit of string concatenation over sprintf.  Also, we don't need to worry about sql injection on table names, as that should NEVER be left up to user input.  As for username/password sql injection, these are open to sql injection attacks, but as we are binding those in the execute statements, sql injection is not possible.\nSince this class is NOT for production use (I will add a comment saying as much... and I apologize for the confusion) the user_id enhancement is not desirable.  It is meant to be a proof-of-concept / tracer bullet / whathaveyou. \nThanks for your support!\n. If there is a convincing reason to do so, then yes.  However, any time a property or method goes from private  to public, or public to protected, you are adding entrypoints into your model.  This makes it very hard to refactor later, as anything might break backwards compatibility depending on how its used.  For this reason, it's best for things to default to private and move to public only if there's a reason.\nWhich properties do you think should be protected and why?  Also, this should be a new thread...\n. sounds reasonable!  Will you send me a pull request?\n. This is great, thank you for adding this.  Two things:\n1. This breaks the test suite.  Please run the tests before submitting a pull request!!\n2. The PDO class is meant as an example storage engine, the simplest possible.  I probably should do a better job of notating this.  Any real application should consider extending this class or implementing the interfaces on a different one entirely in order to fix their application.\nI'd be happy to merge this if you can prevent the tests from failing!\n. One more thing - please make this merge orthogonal to PR #7, so I can merge either one independently of the other.  \nThe best way to do this is to make a new branch for each PR, and merge changes into there.  That way, your master and the master for your pull request won't step on each other!\n. The errors thrown in travis.ci are:\nPDOException: SQLSTATE[HY000]: General error: 1 no such column: user_id\nPDOException: SQLSTATE[42S22]: Column not found: 1054 Unknown column 'user_id' in 'field list'\nThis would be due to the selection of a non-existant  \"user_id\" column in the SQL statement: SELECT user_id, username... on line 183\nAs for your .ddl file... I don't know what this is, but it's probably more suited for the oauth2-server-demo repository.   In fact, I think the PDO class is better off living there as well, but we'll see..\n. Okay a couple more things...\n1. This would better be merged into the develop branch, as you are changing the passed configuration values to PDO, which will break backwards compatibility\n2. the setRefreshTokens function is not necessary\nAlso... why did you decide to change the config value names?  I'm guessing for brevity?\n. Looks like you've accidentally included some commits from the develop branch! Please submit this PR to the develop branch or branch your feature branch from master\n. Thank you for reporting this!\n. Fixed by 81ceb467b9b6745574a9ece4b3b2bbebf1e7c9b9\n- ClientCredentials does not issue refresh token\n- Access Token authorize requests do not issue refresh token in fragment\n- Refresh Token grant requests can be configured to not issue refresh token\n. Yes, that is correct.  The client ID should be a human-readable string.\n. The bearer token is already encoded as part of the Request header (do a var dump on the Request object when the Bearer header token is set).  The code you are modifying is only there to cover the multiple ways PHP handles HTTP basic authentication.  This takes a header consisting of HTTP_AUTHORIZATION Basic [auth info] and adds it to the PHP_AUTH_USER and PHP_AUTH_PW for consistency.\nThe Bearer token is pulled from the request here.  It does not need specific logic in the Request class.\nIs there an issue you have encountered you are trying to fix? if so please file an issue. Thanks!\n. It is a bit confusing in the OAuth2.0 spec.\nEran Hammer suggests using Client Credentials grant as specified here, or just using the \"Bearer\" or \"MAC\" protocols with a shared token\n. Thank you for catching this!  It should be fixed now.  Your suggestion of using \"headers\" instead of \"server\" is correct.\n. That is correct. Oauth primarily exists for the use case of three legged\noauth. You can implement two legged oauth still... The \"password grant\" is\na good example of this. But it wil require an extra round trip request (ie\nyou will always need a specific request to obtain the token). Hope this\nhelps!\nBrent\nOn Wednesday, January 9, 2013, F21 wrote:\n\nI just came across your library and would like to implement it into my\napplication to support OAuth 2.\nI am looking to implement 2-legged OAuth for server-to-server\nauthorization which means that I won't have to send a token with each\nrequest to my application's API.\nI am still looking through the source, but does this library support\n2-legged OAuth (processing request without a token)?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/20.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. Yes!  That sounds excellent!\n. I have no problem including third party libraries where it makes sense to do so!\n. Composer\nOn Thursday, January 10, 2013, F21 wrote:\n\nWe have a few choices :)\n- Directly include it in the repository.\n- Use Composer\n- Use a git submodule.\nWhich one would be preferred?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/20#issuecomment-12123028.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. So it seems that in order to use JWT as client validation, a client_assertion_type parameter needs to be supplied.  So, this is actually entirely separate from the grant type.  See this example here:\nhttp://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-04#page-5\nWhere the client assertion is JWT, but the grant type is still authorization_code.  So I believe we just need a new interface for OAuth2_AssertionType, and have OAuth2_AssertionType_HttpBasic and OAuth2_AssertionType_JWT.  The server defaults to HttpBasic if no client_assertion_type parameter is supplied.\n. In response to your first three paragraphs, you are correct, and we are on the same page.\nIf you will implement the JWT client library, I can work to help you integrate it, yes.\n. It sounds like you should add a different Token Type (JWT) to handle the authentication headers.\n. I think I'm misunderstanding something here. Grant types are only for the GRANT endpoint, and require client credentials. Token Types are for the ACCESS endpoint and determine what the token looks like. I don't understand why we can't use ClientAssertionType on the one hand, and TokenType on the other. This seems like the appropriate approach. \nI apologize if I'm missing something, I have not spent nearly enough time with the jwt spec\n. Eureka!  You sir, have solved my befuddlement!  JWT is client assertion and access token in one!  So you can use it for one or the other, if you like.\nIn that case, it is clear the GrantType interface has to be expanded to accomodate for bypassing the client credentials check.  Rather than checkAuthenticationHeaders being added to all GrantTypes, it may make more sense to have it assume two interfaces... the GrantType interface but also a ClientAssertionType interface.  Then, we can just add a logical check in the code... \nif ($grantType instanceof ClientAssertionType) {\n    // do something...  I assume we still DO check the client assertion is valid!\n} else {\n    $clientData = $this->getClientCredentials();\n    // and so on...\n}\nWhat do you think?  Will this get us where we want?  Seems like it will also set us up nicely for adding the ClientAssertionType functionality as well!\n. I am okay with embedding the library.  I will try to implement this as soon as I can, but please don't be shy and feel free to implement it yourself!\nI have half a hair to do some \"plugin\"-style architecture for the extension grants.  This is the first extension grant I have seen, so do we add it straight in, or create oauth2-server-extension-jwt?  I would prefer the latter, but I don't want to wait on this architecture to add this functionality, so it can wait!\n. A code HAS to be verified to be for the same client it was granted to, so it can't be snagged by a different client.  However, I can't find anything in the spec that prevents users from snagging each other's tokens by hijacking the the authorization code redirect URI.  There is no \"user signing\" of the authorization code.  \nThe way to guard against this is to have the server only allow the use of the authorization code once.  This is outlined in the spec: \nThe client MUST NOT use the authorization code\n     more than once.  If an authorization code is used more than\n     once, the authorization server MUST deny the request and SHOULD\n     revoke (when possible) all tokens previously issued based on\n     that authorization code\nSo, this is an issue in the library in the sense that we do not currently expire the code after it's been used.  It is an issue in the spec in the sense that... IF another user could hijack another user's redirect URI and request it before they can, they would indeed have that user's code associated with their account.  I see no way in the spec this is prevented.\nI hope this helps!  I'll get on a fix for this immediately (and am of course open to Pull Requests to fix it as well!)\n. Good resource, thank you!\nWhat is interesting is, communication to the OAuth server is TLS/SSL, but the redirect URI is not required to be TLS/SSL.  So it could still get intercepted.\nCan you explain what you mean by \"Enforce the state parameter using a nonce\"?  I'm not quite sure \"state\" should be used for that purpose, or even how that would be possible.\n. Of course!  Thank you for this.  I was getting state confused with scope.\nThe state parameter should always be used then.  I will update the demo to do so!\n. According to the spec, the refresh_token grant type MAY issue a new refresh token: \nThe authorization server MAY issue a new refresh token, in which case\n the client MUST discard the old refresh token and replace it with the\n new refresh token.\nAs a result, I've added the option always_issue_new_refresh_token (defaults to FALSE) in the OAuth2_GrantType_RefreshToken class.  So, by default a new refresh token is not issued, but you can easily configure this to do so.\nI am open to changing the default to TRUE\n. You caught me! Thank you for submitting this.\n. woops, for future reference this should have been submitted to the develop branch.  I'll merge the code appropriately\n. This looks awesome!  Thank you so much for writing all this and submitting it!  \nBefore I merge it, we just need to do two things:\n1. We need to convert all tabs to 4 spaces\n2. We need to validate client credentials in the JWT token\n. I'm sorry.  This PR now touches every file in the repository, and has added tons of changes to files it does not need to edit.  I cannot except this.\nThis PR has become too messy for me to understand the changes being requested.  I am going to close it, but please submit another one once it's cleaned up.\nAlso, the method in the new Interface should be getClientDataFromRequest, not getTokenDataFromRequest\n. Hmm... I cannot find anywhere in the fig standards where there must be an empty line before a return.  But I do want this repository to follow the PSR standards, so if it needs to be compliant, we should do so in a separate pull request.\n. I see, you ran it with the all flag.  Try running it like this:\nphp php-cs-fixer.phar fix /path/to/project --level=psr2\n. The use statements do not require a prefixing backslash (ie \\OAuth2...). This seems benign to me, but it may be confusing the autoloader.\u00a0\n\u2014\nBrent Shaffer\nOn Tue, Jul 2, 2013 at 4:17 AM, Francis Chuang notifications@github.com\nwrote:\n\n@ksnyde This looks like the class could not be found. Make sure you include the autoloader to load the classes from the library. See https://github.com/bshaffer/oauth2-server-php#installation\nAlternatively, the library is PSR-0 compliant, so if you have a PSR-0 autoloader you can use that.\nOr, if you are using composer, composer should generate a valid autoloader, so you can use that too.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/24#issuecomment-20340019\n. No, this is incorrect.  The prefixing slash is only necessary when a class is referenced outside the use statement.  You have:\n\nphp\nnamespace LG\\OAuth;\nuse LG\\Connection as Connection;\nuse \\OAuth2\\ResponseType\\AuthorizationCodeInterface as AuthorizationCodeInterface;\nAs the Autoloader looks for the prefix \"OAuth2\", it is possible this is causing the error.  I suggest trying this instead:\nphp\nnamespace LG\\OAuth;\nuse LG\\Connection as Connection;\nuse OAuth2\\ResponseType\\AuthorizationCodeInterface as AuthorizationCodeInterface;\nIt's just a guess... I cannot fathom what else might cause this. \n. Change your class header to this:\nphp\nnamespace LG\\Oauth;\nuse LG\\Connection as Connection;\nuse OAuth2\\Storage\\AuthorizationCodeInterface as AuthorizationCodeInterface;\nuse OAuth2\\Storage\\AccessTokenInterface as AccessTokenInterface;\nuse OAuth2\\Storage\\UserCredentialsInterface as UserCredentialsInterface;\nuse OAuth2\\Storage\\ClientCredentialsInterface as ClientCredentialsInterface;\nuse OAuth2\\Storage\\RefreshTokenInterface as RefreshTokenInterface;\nuse OAuth2\\Storage\\JwtBearerInterface as JwtBearerInterface;\nAs mentioned in your other ticket, you do not want to use the ResponseType interfaces in your Storage class.\n. No problem!  Glad we could get it sorted out.\nYes, enforceRedirect (and other methods) are implemented in the OAuth2\\ResponseType\\... classes out of the box, so you don't need to create them yourself.  Honestly, I'm not sure there are many use cases to use the ResponseType interfaces, but I added them just in case.\n. This looks really really great.  I am down to super picky stuff.  You seem like you might want this kind of feedback!\nThanks again.  Very excited to merge this\n. Sorry... not seeing the formatting changes\n. That's not necessary, but if you do be sure to rebase!!\n. just use the rebase command instead of merge.  It's best for merging downstream... it'll put my new commits behind your new commits, so they'll mimic what would happen if I merged from my end.\nNo problem, I resolved the differences and committed.  We're good to go!\n. We should be good to go now\n. I don't think it will be happening any time soon.  Code away!\n. One thing I wouldn't mind seeing is an interface for the ExtensionGrantType, so JWT and any other types can extend those.\n. Well, I DO like the word \"modular\" :)\nAs long as it implements a common interface I am cool with either approach... extending a base class or duplicating the code.  Our \"built in\" JWT client assertion could just extend the AuthorizationCode grant type wholesale. \nHonestly, I'd have to wrap my brain around the problem a little more.  I will definitely look into it, and offer feedback to any code you submit!\n. I may be missing something, but I believe this is already done.  JWTBearer now implements ClientAssertionTypeInterface.  This means, if we want to use it for client assertions, we just need to pass it in to the TokenController object when we create it.  \nThere is still the issue that there is no way to pass this in to the Server class.  However, if we add this, we should be good to go.\n. Sounds great! Please submit these changes!\nBut keep in mind the Pdo storage class is a stub class not meant for\nproduction, so any enhancements beyond fundamental fixes are discouraged. I\ndon't want to rewrite an ORM!\nThank you!\nOn Wednesday, January 16, 2013, KodoArkivo wrote:\n\nI've made the changes for supporting postgres, ended up being trivial so\nI'll just let you know what I did so you have the option to do it if you\nwish. In case you weren't aware the underlying issue is that Postgres using\ndouble quotes as a column identifier, not data.\nPDO.php: Just look for any \"%s\" in your SQL prepares and replace them with\na data binding, using the compact array constructor to map the values (like\nyou do in one of the commands anyway).\nDEMO: Obviously the SQLITE stuff for making the database doesn't need the\nfile exists tests and all that, I just fixed mine locally and it's all good.\nI've tested it with your demo app and it's creating tokens just fine using\nPG as back end PDO now. It's also fine with PG's schema based\n\"db.schema.table\" table naming (i.e. my table names are oauth.access_tokens\nwhere oauth is a private schema within the database).\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/28#issuecomment-12307740.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. Closing this because of PR #30.  Please open if you experience additional problems.\n. Why does this diff show the removal of every single line?\n. Closing in favor of bshaffer/oauth2-server-php/pull/30\n. This is a really great fix. Thank you for submitting it!\n. I'm not quite sure what this issue is about.  Where is the access to these variables required?  Can you tell me what you're trying to do?\n. This is consistent with other functions in the library. I can get behind this change. \n. I believe changing getAccessTokenData to accept $request is the best approach.\n. Fixed with #48 \n. I agree this is an issue. I will fix ASAP!\n. I think this paragraph says everything we need to know: \nThe client MUST use the HTTP \"POST\" method when making access token\nrequests.\nhttp://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-3.2\n. The latter\n. This issue is closed. Will you open a new issue for this?\n. Agreed.\n. Thank you!!!\n. We should add a test for this \n. Fixed with #43.  The world of open source thanks you, good man.\n. Looks great!  Thank you, Arul.\n. This is a tricky one... I cannot find anything in the spec to address this.  The closest reference to this I have found is here:\nRefresh tokens are issued to the client by the authorization server and are\nused to obtain a new access token when the current access token\nbecomes invalid or expires, or to obtain additional access tokens\nwith identical or narrower scope (access tokens may have a shorter\nlifetime and fewer permissions than authorized by the resource\nowner\nThis implies that multiple access tokens with \"identical or narrower scope\" can exist at the time time.  Perhaps we should make this configurable, and return the existing token by default.\n. @F21 yes, but more specifically the GrantController, as the Server class is nothing more than a convenience wrapper for the three Controllers (if that's confusing, I'm sorry.  Not sure how to get around that one).\nIf the flag is set, we'd just want to perform a call to getAccessToken with the proper checks, and skip the creation.  It should be pretty straightforward\n. These changes look great!  if you can add back assertArrayHasKey where you removed arrayHasKey, I will merge.\nThank you!\n. Phenomenal!  Thank you for these fixed.\n. Getting this:\nFatal error: Call to undefined function openssl_sign() in /home/travis/builds/bshaffer/oauth2-server-php/src/OAuth2/Util/JWT.php on line 87\nhttps://travis-ci.org/bshaffer/oauth2-server-php/jobs/4342679\n. I agree, but I believe we want a ScopeStorageInterface, as scope will be something different per implementation.  This could contain something along the lines of getValidScopes, or isValidScope... I'm not sure.  I think isValidScope might be logic better off placed in the AccessToken class, but this is open for discussion\n. If writing to storage failed, I think it best for an exception to be thrown and caught.  But I believe this would be part of the StorageInterface implementation, and not part of the code here.  Unless we want to add it to Storage_Pdo.\n. This should not be handled in the oauth library. This should be handled on a per-storage basis.  \nI do not want to force these methods to return a boolean value. \nHowever, the part concerning the scope is a valid bug.  Let's focus on that.  I'll work on adding the ScopeStorage interface.\n. fixed with pull request\n. Yes, see the issue above for an update on this.  The spec does seem to ignore this question, and implies multiple valid tokens for the same user/scope can exist at the same time.  I agree that this is silly, so I think we should just make the default behavior mimic facebook, and let the library be configurable\n. Looks great!  Thankyou sir!\nA little constructive feedback - typically it's best to make topic branches for each PR.  That way if you're working on more than one PR, or if you need to make changes, you don't wonk with your master branch :)\n. Please explain the situation in which these functions would throw an error\n. Is there a way to verify the input before calling the function? I agree we do not want to output php errors in this class, but squelching them is also not optimal\n. Yes, it does seem squelching is the only way to handle this, unfortunately. I would suggest \"decode\" return false on failure however, rather than throw an Exception.\n. Looks good!  Thanks for catching this.\n. Thanks for keeping me honest, F21 :)\n. @DeanD \nDoes this answer your question?  F21 is correct - You do not authorize a specific change, you grant the client the authorization to make changes.  To authorize a specific change would require extending the protocol.\nThere may be a way to extend the spec to provide the functionality you are requesting (see extension response types).  I think it's an intriguing concept, and certainly has its uses (especially if you're not exactly sure what the client wants with your resources).  I'll keep an ear to the ground, but this is the best answer I can give.\n. Indeed it is not :) thank you sir. \n. I am not sure why @F21 changed it.  I must have missed it in merging an unrelated change.  I apologize, I should have been closer to inspect the changes of the pull request.\n. Fixed as a part of 757087a2384082e2b52c25f70618624dd84d18aa\n. I will write a test to cover this.  It was passing, so I merged.  A bad habbit of mine :P\n. Those changes have been re-added.\nSo what needs to happen here is the addition of an OAuth2_ClientAssertionType_HttpBasic class.  This class will implement OAuth2_ClientAssertionTypeInterface, and take ClientCredentialStorage in the constructor, as this storage class is required for this.\nThis is something I've been wanting to add since the JWT functionality was added.\n@F21 - shouldn't reverting those changes have caused tests to break? \n. That makes sense.  if we create a mock of JWTStorage in the tests, however, it would fail\n$storage = $this->createMock('OAuth2_Storage_JWT');\nWe should probably test for this.  In the meantime, I'll add it to my list to create HttpBasic client assertion type.\n. closing in favor of #57 \n. From Travis.ci\nFatal error: Call to a member function getStatusCode() on a non-object in /home/travis/build/bshaffer/oauth2-server-php/test/OAuth2/GrantType/JWTBearerTest.php on line 40\n. This pull request is open for review... @F21 or whoever!\n. fixed by 613582a\n. I think this is a great idea!  unfortunately, as this library is currently supports PHP 5.2, the changes mentioned will cause a syntax error.\nI plan to deprecate php 5.2 support by spring, but right now I have a reason for keeping it around.  What would be best is to do a stop-gap, similar to how I am using RequestInterface as a stopgap for HttpFoundation\\Request.  \nSee this repo: oauth2-server-httpfoundation-bridge\nSo essentailly we'd create OAuth2_LoggerInterface, which would match Monolog.  Then we create a monolog bridge repository, and basically just extend the monolog class and implement the OAuth2_LoggerInterface.  Then once we drop 5.2, it will be trivial to add Monolog directly to composer.json.\nI know this is a pain, but it does seem to be only solution while retaining 5.2 support.  If you want, you can also send a pull request to a new branch I can make (add-monolog-support), and I can make these changes instead.\n. Yeah, I agree.  I may just rename my other repository oauth2-server-bridge, and put all sorts of bridge classes in there, since they will all inevitably be very simple, if we architect it right.\n. Did you all want to submit a PR with the logging added?\n. Agreed, @Rockstar04 \n. Can you all provide feedback as to what events you would like logged?\n. Logging does not really make sense with this library, as the errors returned contain all the logging you need.  Logging should happen at the level above this.\n. Closed with #115 \n. I like your thinking. My original thought was to use getSupportedScopes as a way to find the valid ones on a client/user basis.  \ngetClientDataFromRequest in the JWT grant type returns client_id.  Shouldn't we be able to use this?\n. $request is bulky.  Let's avoid passing it unless it makes sense.  I would prefer to stick to $user_id, $client_id, and $scope if possible.\n. in fact, we can get rid of getScopeFromRequest... that was mainly just a convenience method I wrote, but I see no reason why that needs to be in there, as that should never require custom logic.\n. If you want that level of complexity, you could inject the request into the scope object before passing it to the server.\n. Closed with the merging of PR #66 \n. Good call. Thank you. \n. Hi julien!  I think we should just cast the result of the mongo storage as \"false\" and call it a day.  null might be more appropriate, depending on the query, if you want to be extremely academic.  But let's just keep the mongo storage consistant with the existing storage classes (so as to not break BC)\n. I went ahead and did this.  Thanks for your work @julien-c!\n. My reasoning is that for anyone with extensive Scope needs, the ScopeInterface can be replaced with a custom class very easily.  I do like this added flexibility, however.  Thank you!\n. After reviewing this, I don't really think it makes sense to send in the format as part of getResponseHeaders.  Either the format has been specified before this, and we can return json as the Response-Type, or it hasn't been determined, and then there's no reason to return it.\nSo the question becomes when is the response type determined?  I believe it makes sense to keep it when the response is rendered.  The headers set by the oauth server have nothing to do with the response type, as that is decided by the application.\nI am closing this.  I think this should be set in the demo application instead.\n. PDO is supposed to be a stub class.  You should definitely extend this in your application in order to make it appropriate for your specific requirements\n. Thank you!  Authorization Header standardization has been a bear...\n. Agreed!  Thank you.\n. I agree this is necessary for consistency.  However, I am curious... since the scope can be derived from the request, why do we need to pass it in separately?\n. is anyone looking at a way to make this pass?\n. great!  Thank you!\n. That's very interesting.  I don't think there's any reason WHY this library needs to pull up every single scope... scopeExists actually seems much cleaner and more appropriate.  \nI am in full support of this idea.\n. The getSupportedScopes method has been removed entirely, as a result of this PR.  Anyone receiving this exception should be aware the change:\nFatal error: Call to undefined method OAuth2_Scope::getSupportedScopes() ...\nAnd update to use scopeExists instead\n. I agree with 2, but am on the fence about 1. Does the spec mention exact matches anywhere?  We can supply a config flag to enforce exact matches, but use cases exist where fuzzy matching is safe and desirable.\n. Thank you!  Yes, that is certainly sufficient to make exact matching the default.\n. These changes have been made.  @bojanz please review and reopen if you see something missing\n. Moved to https://github.com/bshaffer/oauth2-server-php-docs/issues/9\n. Do you know why this is failing?  The error is\n1) Warning\n36 The data provider specified for OAuth2_StorageTest::testCheckClientCredentials is invalid.\n37 Failed to connect to: localhost:27017: Transport endpoint is not connected\n. I was able to update travis.yml with the new script, and tests are passing as expected.  I would suggest creating a new branch, cherrypicking your commits, and rerunning the tests to see if the problem has been resolved\n. I have actually decided to skip travis.ci tests for mongodb, as these are failing intermittently due to a bug in travis.ci.  They can be run manually still, but this is the best I can do for now.\n. This seems fine to me.  It is unfortunate you have to pass in a storage object for something that doesn't actually require storage, but other than that small annoyance, this will work perfectly fine.\n. @F21 is exactly right.  You can explicitly supply the storage types by using the above model of setting the individual storage types and omitting refresh_token.  If that's not good enough, you can even instantiate the OAuth2_ResponseType_AccessTokenInterface object and pass null as the second argument, to nullify the passing of a refresh token.\nThere is an interesting situation here, where you have the Storage objects and the GrantType objects both determining Server behavior.  the Storage objects are more likely to implement many interfaces, where as GrantTypes are more likely to be set implicitly for the server configuration, so in that way it makes more sense to go by GrantType than by Storage to determine if refresh tokens should be issued.\nSo one option is to make the Server object check, before creating the default ResponseType_AccessToken object, if the RefreshToken grant type is set, and if it isn't we could exclude passing the storage in.  However, this could supply unintended results if grant types were added after the constructor, etc.\nAnother possibility is to throw an Exception \"In order to issue a refresh token in the AccessToken response type, the RefreshToken grant type must be set\"... I don't know.  I kind of like how it is now :)\n. The AccessToken response type is suppled a RefreshToken Storage object if it wants to return a refresh token with the access token.  If the server is missing the RefreshToken Grant Type, this is a misconfigured server, and is working as designed.\nUnless there is a scenario where this arises unexpectedly, I see no issue here.\n. Good catch!  Thank you.\n. This is interesting.  Yes, since handleXXX() calls always return a response object, I never thought to set it to the $response property as well.  However, for consistency I see no problem in doing this, as it is the expected behavior.\n. I am not really sure what this accomplishes.  You basically want the server to provide a setting to never pass the scope in through an implicit call? \nThe idea being if this is set, then the server should provide an endpoint to get the scope for the granted access token?  If that is the case, we should create a \"handleScopeRequest\" method as part of one of the controllers.\nAlso, that is a very lengthy post... can you point out the section you are referring to and quote it here?\n. All this PR does is unset the scope for implicit calls.  It does not provide the user with any means of retrieving it again.\n. In addition, it does not even check to see if the url WILL breech the 2083-character limit.  It just unsets it anyway.\n. More importantly, all of this has nothing to do with the security concerns pointed out in the blog post.\n. It is hard for me to swallow that users would come up against the 2083-character limit frequently enough to require such a thing.  \nUnless this is a common problem, mentioned in the spec, seconded by other users of this repo, etc, it should be left to custom implementation.\n. This is actually not right.  When using composer, the correct name is dev-develop\nsee https://packagist.org/packages/bshaffer/oauth2-server-php\n. This would be great!  I know many companies still rely on SAML Assertion for their authorization, and it would be awesome to support it.\nWe can have the SamlGrantType implement ClientAssertionType, and then the token controller will use it for authorization as well, which is the logic that allows the JWT tokens to do this, so I do not believe any enhancement is necessary here.\n. @aacotroneo that would be amazing\n. Even if you have a demo app and enough material to add a cookbook article to the docs, that would also be immensely helpful\n. No prob :)  I like it.  Thank you.\n. I don't know what's up with travis and mongo with PHP, but running all the tests locally against mongo worked great.  Merged.\nThank you!\n. This is definitely unclear.  Base64 is usually implemented to bypass issues such as escaping characters in a URL.  Tokens do not contain such characters (to my knowledge), and can be passed in the header, where such problems don't apply.  I imagine this is handled per-implementation.\n. Here is at least one example of base64-encoding being removed:\nhttps://github.com/lncd/OAuth2/pull/12/files\n. Yeah, this answer says it all, and is super helpful\n\nOn casual reading of \"The OAuth 2.0 Authorization Protocol: Bearer\nTokens\"* I've encountered several people (including myself) who have\nmade the assumption that the name b64token implies that some kind of\nbase64 encoding/decoding on the access token is taking place between\nthe client and RS.\nDigging a bit deeper in to \"HTTP/1.1, part 7: Authentication\"**,\nhowever, I see that b64token is just an ABNF syntax definition\nallowing for characters typically used in base64, base64url, etc.. So\nthe b64token doesn't define any encoding or decoding but rather just\ndefines what characters can be used in the part of the Authorization\nheader that will contain the access token.\n. The function used to be called handleGrantRequest, but has recently been renamed to handleTokenRequest to adhere to the oauth2.0 spec.\n\nSo, I imagine the codebase you're using is out of date!  Update it to the latest version, or just use handleGrantRequest instead.\n. I agree that there are better ways to approach this issue, and while the Memoize class can be very handy, it probably doesn't deserve to be in the core library.\n. I've merged in 88f9d5a and a3220e2 for Redis support.  Great additions, thank you!\n. Note: This will break Backwards Compatibility for anyone who has extended the OAuth2_Server class, as there are many protected methods and properties which will be moved to OAuth2_ServerFactory instead.\n. No, the current version works great.  I probably should be easier on myself.  It just makes dependency injection a little counter intuitive, but everything you need is still possible\n. @bojanz - My reasoning was the AccessTokenInterface was required, rather than just the ResponseType interface.  In retrospect, rather than requiring both, it should just throw an exception if the former does not exist in $responseTypes.\n@ademarre I am considering going this direction with the refactor.  3 distinct endpoints, 3 controllers.  It seems silly to hide this by wrapping them in a single class.  I am glad you found breaking them out to be useful!\n. fixed in #119\n. We changed the method from handleGrantRequest to handleTokenRequest. I am sure if you call handleGrantRequest you will fix the issue.\u00a0\nWhen did you check out the code, and what branch or tag did you use? The README is up to date with the current code base, so this problem should not exist unless you're using an older version of the library, but using the README of the current version.\u00a0\n\u2014\nBrent Shaffer\nOn Tue, Apr 23, 2013 at 5:40 AM, Ben Squire notifications@github.com\nwrote:\n\nHi All,\nTrying to implement the library into a ZF2 project, however in the README.md the line:\n    $server->handleTokenRequest(OAuth2_Request::createFromGlobals())->send();\nI get the error:\n    Fatal error: Call to undefined method OAuth2_Server::handleTokenRequest()\nI've had a look through the code, however I dont find a handleTokenRequest request function anywhere.\nKind Regards\nBen\nP.S: What should it be?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/104\n. Okay, thank you. The tag v0.5 has not been updated for the new methods. I can see how this is confusing however, so I will make a new tag for the new methods.\u00a0\n\nThe develop README says \"use this tag and call this method\".... But doing so is not possible with the tag suggested, only with the develop branch. \u00a0This is obviously an issue.\u00a0\n\u2014\nBrent Shaffer\nOn Tue, Apr 23, 2013 at 9:12 AM, Ben Squire notifications@github.com\nwrote:\n\nHi @bshaffer I am using this line in my composer, so version 0.5 presumably:\n\"bshaffer/oauth2-server-php\": \"v0.5\"\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/104#issuecomment-16860328\n. @bensquire I wish I had some great resources to hand to you, but I don't.  I think the best way to get up to speed is to follow the demo's README to get silex set up (which in turn sends you to Silex's docs).  Once you've done that, click around the demo to get your head around the oauth2 workflow.\n. there is now a stable v0.6 tag for the new method names.  You should be good to check this one out and call handleTokenRequest now.  \n\nSorry for the confusion!\n. The Pdo works well enough. The comment is intended to encourage users to extend these classes for their own project domain if customization is required, as the classes here are very simple.\u00a0\nUse of this storage class is fine for production, and the comment should be updated.\u00a0\n\u2014\nBrent Shaffer\nOn Wed, Apr 24, 2013 at 8:49 AM, mcd-php notifications@github.com wrote:\n\nTop comment says it's only an example stub. Why ? What are it's flaws, and what are the ways to correct them ?\nI modified the demo to work with Apache Cassandra via cassandra-pdo, just by creating tables (column families) and changing PDO DSN - it worked.\nIf not PDO, what should i use in production ? Does this project have ready storage adapter, or should i implement my own ? Or review another libs from http://oauth.net/2/ ?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/106\n. Possibly link to KnP University OAuth2 slides when available\n. Awesome! This looks great!  Although, I am a little concerned that the README pulls from develop instead of a stable branch!\n. Fixed in #119 \n. This is a good point - the Grant Type for JWT does not allow for us to auto-configure with just storage and default parameters, so we cannot really do it.\n\nIn your application do the following instead:\n``` php\n// bootstrap\ninclude 'vendor/autoload.php';\n$cfg = require 'config/config.php';\n// create server object\n$pdo = new PDO($cfg['pdo']['dsn']);\n$storage = new OAuth2_Storage_Pdo($pdo);\n$audience = 'http://youruri.com';\n$server = new OAuth2_Server($storage);\n$server->addGrantType(new OAuth2_GrantType_JWTBearer($storage, $audience), 'jwt_bearer');\n// handle the request\n$request = OAuth2_Request::createFromGlobals();\n$server->handleTokenRequest($request)->send();\n``\n. This is a good case for implementing #103 \n. I've removed the instantiation ofOAuth2_GrantType_JWTBearerfromgetDefaultGrantTypes`.  As this is a \"default\" method, it is ok to omit the JWTBearer grant type.\nThe README specifies the grant types should be added explicitly.  If this is followed, the user should have no problems.\n. These changes are really really great.  I am going to re-tag, due to the B.C. breaking here, and then we can merge this.\n. This is a really good find, and is definitely important to fix. Thank you for catching this!\n. Yes, this is for sure the right direction!  The only consideration I have is moving checkRestrictedGrantType from the ClientCredentials interface to the ClientInterface.  It makes more sense for this method to be there, as this is still a \"getter\" method, and credentials are still not involved in this controller.\n. @bojanz Can you explain what you mean by that?  As the token endpoint is never called with the implicit grant type, I do not think we need a GrantType object for it, we just need to supply allow_implicit to the Authorize controller.\nAlso, if this is a legitimate issue, can we open up a new issue for it?\n. I am also unclear as to what the issue is.  Implicit IS a grant type, so passing it is definitely appropriate.  I don't see a reason to create a GrantType object for it, as it does not follow the rules of other grant types.  Essentially, allow_implicit is redundant, since if an AccessToken response type is passed into the AuthorizeController, this is allowing the implicit grant type.\nIt's possible that instead of passing ResponseType objects in, we pass GrantType objects in, one being AuthorizationCode and the other being Implicit.  I don't really see this getting us anywhere, though.\nAnd I am not sure what @rjmackay refers to by implying anything is \"combined with authorization code\".  There is no implicit logic in authorization code, it all exists in the AuthorizeController and the ResponseType_AccessToken classes.\nSo, in conclusion... I don't understand what all the fuss is about :P\n. You have a compelling point. For consistency, it would be great to have an Implicit grant type that gets passed to AuthorizeController, along with the Authorization Code grant type when applicable.  We could then determine the valid \"ResponseTypes\" based on that... and essentially make the GrantTypes implement or extend the ResponseType interfaces.  I think this would make a good enhancement.  \n127 has been opened to address this\n. These changes are very broad.  It would be better to merge this into the refactor-server-class branch\n. Thank you for working hard on this!! I will need to take a bit of time to wrap my brain around all the changes being made here.\n. Can you provide a link to the OAuth2 spec which speaks to different scopes per grant type?  It is not so evident to me that scope validation \"obviously varies wildly per grant type.\"\n. I like what you've done here! I think we can improve on this.  I agree there is some redundancy in the TokenController class.  There is no reason for us to have validateRequest, getTokenDataFromRequest, and validateTokenData.  We can replace all of these with the singular getTokenDataFromRequest.\nBut rather than combine this and createAccessToken, I would rather just add the following method: \nphp\npublic function validateScope(array $tokenData, OAuth2_ScopeInterface $scopeUtil);\nThis will clean things up quite a bit, and allow each grant type to implement how scope will be validated.\n. Any thoughts, @bojanz, @F21, @julien-c?\n. Thank you for your feedback @bojanz.  Here is my explanation to your points above:\n1. tokenData does vary, but truly there's only two properties that ever get used on it, user_id and scope.  (in JWT, sub is synonymous with user_id). Your approach passes too many arguments into grantAccessToken without defining their purpose, which is why I tried a different approach. In general, I want the roll of GrantTypes to be more defined than a single function, and have been exploring ways to do so.  I want for someone to be able to open up the grantType class and see how that grant type functions on a basic level, instead of having a single monster method.  This may be impossible, but it's the goal.  If this goal is unobtainable, I agree with the single method approach as long as we do a better job with the arguments.\n2. I flip-flopped on this one.  Scope validation is pretty straightforward, and I feel it belongs in the TokenController class, although there are some small variations between grant types I'm not ready to put the entire validation in there.  However, I see your point as well.\n3. As there is no case in which $this->request is not null, I think it's silly to add this to it in the current implementation. \n. Summary of changes:\n- ResponseInterface objects are now passed in.  This makes everything much cleaner\n- GrantTypeInterface has been changed to have the following methods\n  - validateRequest\n  - getClientId\n  - getUserId\n  - getScope\n  - createAccessToken\n- ClientAssertionTypeInterface has been changed to have the following methods:\n  - validateRequest\n  - getClientId\n. ** BC BREAKING CHANGES * \nPlease check out the new tag v0.7 to restore the state before these changes were merged.  This will roll back any of the BC-Breaking issues associated with this Pull Request.  Sorry for the inconvenience!!\n. Fixed with #115 - please see #118 for an explanation\n. There is no case where client_id is null. I think this is a good idea.\u00a0\n\u2014\nBrent Shaffer\nOn Tue, May 7, 2013 at 6:27 PM, dsquier notifications@github.com wrote:\n\nI'd like a way to define $supportedScopes and $defaultScope for a specific client_id. For example:\nclient_id = alpha\n$supportedScopes = 'readonly alpha`;\n$defaultScope = 'alpha';\nclient_id = beta\n$supportedScopes = 'readonly beta'\n$defaultScope = 'beta';\nThis could be minimally accomplished by adding $client_id to getDefaultScope(), i.e.,\npublic function getDefaultScope($client_id = null)\nAdditionally, are there cases where $client_id would be null? If not, I'd also propose requiring $client_id in both getDefaultScope() and scopeExists(). It would simplify the data access layer.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/117\n. @bojanz why would we want to do away with the default NULL?\n. I'm sorry, I was unclear. We may always have a client_id, but that doesn't necessarily mean we always want to pass it in to those methods.  So I think $client_id = null in the declaration is okay.\n. It is worth noting that this will break backwards compatibility with existing ScopeStorage and ScopeInterface classes.  I am not sure the functionality is desirable enough for this\n. good point.  I'm just burnt out on breaking BC now. :)\n. the Client-Specific \"default scopes\" has been added, and support for client-restricted scopes has been moved to https://github.com/bshaffer/oauth2-server-php/issues/208\n. This is fixed as a result of #115 - please see the following code in TokenController:\n\n``` php\n/\n * Validate the scope of the token\n * If the grant type returns a value for the scope,\n * this value must be verified with the scope being requested\n /\n$availableScope = $grantType->getScope();\nif (!$requestedScope = $this->scopeUtil->getScopeFromRequest($request)) {\n    $requestedScope = $availableScope ? $availableScope : $this->scopeUtil->getDefaultScope();\n}\nif (($requestedScope && !$this->scopeUtil->scopeExists($requestedScope))\n    || ($availableScope && !$this->scopeUtil->checkScope($requestedScope, $availableScope))) {\n    $response->setError(400, 'invalid_scope', 'An unsupported scope was requested.');\n    return null;\n}\n```\n...and in OAuth2_GrantType_UserCredentials:\nphp\npublic function getScope()\n{\n    return isset($this->userInfo['scope']) ? $this->userInfo['scope'] : null;\n}\nThis essentially says \"does our user storage limit the user's scope?  If so, then the requested scope is validated against it.  Otherwise, just validate that the scope exists\"\nI'll add better comments in the code, as this is a little hard to read\n. * BC-BREAKING MERGE *\nIf you are lost because a git pull has broken your code, please check out tag v0.7 of this repository (git checkout v0.7), and you'll be back to normal!\n. We should add 5.5 as soon as it reaches an official release. \n. The use of bcrypt or password_hash is up to the application. Implementing this is as easy as extending the checkUserCredentials method on the UserCredentials storage object \nIf any further discussion is required here, please open a new issue. \n. We can EOL PHP5.2 once we've addressed #27, #80, and #134.  Also consider addressing #133 and #122.\n. This is a great idea, and is essentially what we have with the JWT (JSON Web Token).  The data is encoded inside the token, and as long as it's signed, we can verify it and unpack it.\nYou're suggesting we subclass the AccessToken type in order to support this?  So that you can use it with other grant types besides JWTBearer?\n. It is interesting because it's a cross between a Storage Interface and a TokenType interface.  One could say \"oh it's just a regular old Bearer Access Token with the data stored inside the token.  One could also say \"Oh, this is a new CryptoToken Type, which is a subclass of Bearer, and the Storage is optional.\nEither Storage or TokenType interfaces seem appropriate for implementing this.  However, as this truly is a different type of token, I am leaning towards extending Bearer for this.  Is there any spec we can look at to gain more context?\n. The logic for this would replace the existing AccessToken::generateAccessToken method, which creates a random string. \nAdd a CryptoToken response type, which could be provided to the Server constructor in order to use an encrypted token instead of database storage.\n. this has been added in #245 and documented here\n. This is great!!  if we can fix the White space issues and get the tests to pass, I am on board. \n. After further consideration, I think we should do the following with this enhancement:\n1. make \"return_existing_token\" the standard behavior, and get rid of the configuration parameter.  I do not see a reason to allow multiple tokens of the same client/scope combination\n2. make this behavior part of each grantType's \"createAccessToken\" function - test to see if the token exists, and if so then return it.  This means we won't need to change the GrantTypeInterface\n3. Make getAccessToken have an option $client_id and $scope, which can be called by the GrantType in createAccessToken to determine if a new token should be created or not.  This allows us to maintain BC and not over-complicate the interface\n. Yes. this is exactly what I had in mind. Unfortunately, I have made a mistake, as the Storage passed to the grant types does not always implement AccessToken storage, which means we can't rely on this method existing on those objects.\nI now think this should be implemented in the OAuth2_ResponseType_AccessToken  object ( instead of the GrantType object) in the createAccessToken function, and we can add the previous configuration parameter there as well.  Also, I think we should add a separate method once again (I like what you were doing before), and call it findExistingToken($client_id, $user_id, $scope)\nThe one downside to this is the check takes place for all grant types or none.  There may be a situation where we want only certain grant types to check for the existing token.  I am not sure if this is actually a use-case, so we should spend more time looking into what other OAuth2.0 servers do here, and implement something similar.\n. This resource compares twitter/facebook/google APIs for this scenario.  It's different in each case, but if we make it configurable we'll be good.  Returning an existing token certainly seems to be the expected default behavior.\n. Closing, as we have heard nothing from the author in over a month\n. Yes, very interested!  Unless I am mistaken, this is essentially an OAuth 1.0-style signed token, and is what we hope for in the MAC token spec (http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-00).\nI've created a branch to implement the MAC token type, but have not gotten around to finishing it.  I would love to add this feature.  Once added, we would then need to add logic to allow for MACs to be specified per grant type, as only the ClientCredentials Grant Type in your example would require signed tokens.\n. This is an oversight on my part. I'll fix it as soon as I can, or you can send a pull request to fix it. Thanks for catching this! We will need a test for client-specific scope.\u00a0\n\u2014\nBrent Shaffer\nOn Sun, May 12, 2013 at 7:10 PM, Francis Chuang notifications@github.com\nwrote:\n\nI just noticed that the client_id was not passed to scopeExists() in grantAccessToken(): https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Controller/TokenController.php#L123\nWas there any specific reason for this?\nSince the client_id is retrieved before the check to scopeExists(), I think it would be quite useful for client_id to be passed into scopeExists(), because grant types like the JWT grant type does not call the AuthorizationController during the authorization flow, but uses the TokenController directly.\nI think it would be quite useful to be able to have the client_id passed into scopeExists(), especially if we want certain scopes to be available to certain client_ids.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/124\n. It's null because it is not required to limit a scope based on client id in Oauth2. So if you're using these classes independently (it's a public method, after all) you don't need to provide a client id.\u00a0\n\nIt also makes it apparent whatever class implements the interface for scope MUST support a possible null value for client id.\u00a0\n\u2014\nBrent Shaffer\nOn Sun, May 12, 2013 at 7:36 PM, Francis Chuang notifications@github.com\nwrote:\n\nFurther thoughts on this:\nDoes the spec allow registration for clients without a valid client_id? If that's not allowed, then it certainly does not make sense for scopeExists() to accept a clientId of null, since clients should always have a client_id if that is the case.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/124#issuecomment-17789535\n. Thumbs up on this approach!\n\u2014\nBrent Shaffer\n\nOn Sun, May 12, 2013 at 8:02 PM, Francis Chuang notifications@github.com\nwrote:\n\nAnother possibility is to introduce a separate parameter for scopes specific to a client id called client_supported_scopes. I think this is the approach I will use.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/124#issuecomment-17789975\n. You caught me!  I actually made the change you suggest, but it broke in PHP 5.2 because I did NOT want the interface to change.  This is because I want the Controller classes to be very explicit, and require the response.  But the whole point of the Server class is to act as a convenience layer, so I wanted this to allow for a null response.\n\nAs soon as we drop 5.2 (#120), this will be added back in.\n. Response is now optional in the server classes. WooHoo!!\n. One approach is to add a new interface extending GrantType, i.e. AuthorizeGrantType, or something along those lines.  This would include the getAuthorizeResponse function which is currently part of ResponseTypeInterface.  The GrantTypes would then be passed the ResponseTypes as arguments to their constructor, and would return the same thing.  This would clean up the ambiguity, since both ResponseTypes in the AuthorizeController correspond to a GrantType in the TokenController.  Wrapping them in the GrantType class will make this relationship more obvious\n. The functionality for Implicit exists, but it is not encompassed in a GrantType class. \n. Yes.  This issue outlines an architectural plan that will make the distinction between the grant types more clear.\nI.e. OAuth2\\ResponseType\\AuthorizationCode will be rolled into OAuth2\\GrantType\\AuthorizationCode, and will implement a new interface called OAuth2\\GrantType\\AuthorizeInterface.  Then we would add an implicit grant type that would implement this same interface.  The existing OAuth2\\GrantTypeInterface would be renamed to OAuth2\\GrantType\\TokenInterface, and both interfaces would extend a OAuth2\\GrantTypeInterface containing zero methods.\nThen ResponseType classes would be removed entirely.  I'm not entirely sure if I like this plan, but it's definitely something to consider, and I believe it would be more intuitive / architecturally correct.\n. As suggested in #120 \n. Thank you for posting this in case anyone else runs into the same issue!\n. @bojanz do you have a drupal cookbook article we can include for this?\n@julien-c do you want to write anything for Laravel?\nI will be writing small articles using Doctrine1, Doctrine2, Symfony2, and Silex\n. That will do it!\n. Oh I think that'd be the best possible scenario\n. Nothing concrete... I'll have examples out within a week or two.\n. @julien-c see the cookbook branch.  It would be awesome to have some Laravel examples there, even if they're very simple!\n. We now have the oauth2 docs/cookbooks available here\nClosing this in favor of https://github.com/bshaffer/oauth2-server-php-docs/issues/3, https://github.com/bshaffer/oauth2-server-php-docs/issues/2, and https://github.com/bshaffer/oauth2-server-php-docs/issues/1\n. Is your goal here to implement this in the default StorageInterface classes?\n. We do not want to encrypt client secrets in the default implementation (clients are assigned secrets, and so we need to be able to provide it for them - most OAuth2.0 servers do this).  However, if you'd like to extend the ClientStorage class to do this, there is no problem in doing so.\nFor the UserStorage object, we shouldn't be storing passwords in plaintext per default.  This has now been updated to atleast perform a sha hash of the password.  However, it is still STRONGLY ENCOURAGED to extend this to be your own user storage implementation\n. Why would the client secret ever be allowed to be an empty string?\n. I also don't like this because if a user accidentally omits the client_secret parameter, they now get an invalid client credentials error instead of the more clear client_secret not found in header or post body.\nBut, as you said, the spec says it and we must all obey the spec.  I have done my duty :)\n. Thank you!\n. Yes, this is an issue. Would you like the addition of a $headers parameter to the constructor that, when not null, gets set instead of the fall to getHeadersFromServer?\n. fixed in 3f2baeb\n. We can store Redirect URIs as a space \u2013 separated list. Much like we do with multiple scopes.\n. supply a space-delimited (but url-safe) list of scopes in your authorize request.  It will look like this:\nhttps://mydomain.com/authorize\n   ?client_id=MY_CLIENT\n   &response_type=code\n   &scope=onescope%20twoscope%20redscope%20bluescope\n\nNote: Extra linebreaks are for readability only\n\nThis will create an authorization code with the following four scopes: \"onescope\", \"twoscope\", \"redscope\", and \"bluescope\"\nThese four scopes will then be validated against the available scopes using the OAuth2_ScopeUtil class to ensure they exist.  If you receive the error invalid_scope: An unsupported scope was requested, this is because you need to set your available scopes on your server object, like so:\nphp\n$scope = new OAuth2_Scope(array('onescope', 'twoscope', 'redscope', 'bluescope'));\n$server->setScopeUtil($scope);\nReopen this issue if you have any further questions\n. Yes, the idea is an empty array() is actually considered a \"successful\" pull of the user's data.  It means the user exists, but \"scope\" and \"user_id\" do not exist for that user. \nSo, we should update the docs to say that returning an empty array is implying the user is valid, where returning null or false implies the user is invalid.\nI'm not actually sure why this feature exists.  Looking at the code, user_id is a required array key on userInfo, and should never be empty.\n. Documentation updated and OAuth2_GrantType_UserCredentials now requires the user_id to be set\n. Thank you!\n. I do not see how this is a limitation of this library.  It seems like this should be handled in your Storage implementation\n. Honestly, I am not clear on what the issue is that you are describing.  But as I do not know of anywhere in the library that would prevent storing UTF-8 characters, I believe this is an issue with your specific implementation.\nThis library does not concern itself with how you store the information, as almost every project will have its own way of doing this.  This is why the storage interfaces exist.  I would suggest using an ORM such as Doctrine or Propel, and seeing if utf-8 issue is handled properly in there. \nIf you DO find where the problem is occuring, and its an issue with the library (say, the request object), then please reopen this issue.\n. Also, this might address your problem:\nhttp://stackoverflow.com/questions/4361459/php-pdo-charset-set-names\nTry passing charset=utf8 in your connection string\n. looks very good, thank you!\n. addresses #143 - fixes status code for insufficient_scope requests   5a3935f\n. I agree with your assessment.  Can you discern whether or not WWW-Authenticate is required for 400 - Bad Request responses as well?\n. 403 deserves the header, as mentioned in the spec, so that the scope parameter can be provided.\nIf the protected resource request does not include authentication\n   credentials or does not contain an access token that enables access\n   to the protected resource, the resource server MUST include the HTTP\n   \"WWW-Authenticate\" response header field\n400 is unclear.  The following like gives me comfort though: it MAY include it in\n   response to other conditions as well. \nSo my thinking is, it's not forbidden, and the draft for WWW-Authenticate allows for 400 errors.\n. I only added it for the 400 errors coming from the Resource Controller, which are defined by the Token Type.  Here is a complete list of 400 errors thrown by OAuth Server:\n- Http Basic Client Assertion Type\n  - The client credentials are invalid\n  - The grant type is unauthorized for this client_id\n- Authorize Controller\n  - Client credentials were not found in the headers or body\n  - No client id supplied\n  - The client id supplied is invalid\n  - The redirect URI must not contain a fragment\n  - The redirect URI provided is missing or does not match\n  - No redirect URI was supplied or stored\n  - A redirect URI must be supplied when multiple redirect URIs are registered\n  - The redirect URI is mandatory and was not supplied\n- Token Controller\n  - The grant type was not specified in the request\n  - Grant type \"%s\" not supported\n  - %s doesn't exist or is invalid for the client\n  - An unsupported scope was requested\n- Authorization Code\n  - Missing parameter: \"code\" is required\n  - Authorization code doesn't exist or is invalid for the client\n  - The redirect URI is missing or do not match\n  - The authorization code has expired\n- JWT\n  - Missing parameters: \"assertion\" required\n  - JWT is malformed\n  - Invalid issuer (iss) provided\n  - Invalid subject (sub) provided\n  - Expiration (exp) time must be present\n  - JWT has expired\n  - Expiration (exp) time must be a unix time stamp\n  - JWT cannot be used before the Not Before (nbf) time\n  - Not Before (nbf) time must be a unix time stamp\n  - Invalid audience (aud)\n  - Invalid issuer (iss) or subject (sub) provided\n  - JWT failed signature verification\n- Refresh Token\n  - Missing parameter: \"refresh_token\" is required\n  - Invalid refresh token\n  - Refresh token has expired\n- User Credentials\n  - Missing parameters: \"username\" and \"password\" required\n  - Invalid username and password combination\n  - Unable to retrieve user information\n- Bearer Token Type\n  - Only one method may be used to authenticate at a time (Auth header, GET or POST)\n  - Malformed auth header\n  - When putting the token in the body, the method must be POST\n  - The content type for POST requests must be \"application/x-www-form-urlencoded\"\n. I believe everything has been fixed appropriately here... @rjmackay will you confirm?\n. This is a great change!! We should be parsing this correctly for sure. Thank you for identifying this issue.\u00a0\n\u2014\nBrent Shaffer\nOn Wed, May 29, 2013 at 8:04 AM, Ben Squire notifications@github.com\nwrote:\n\nI'm running into numerous problems with the OAuth2_TokenType_Bearer class, when it comes to validating the CONTENT_TYPE.\nI'm currently trying to force jQuery to send it as:\n    application/x-www-form-urlencoded\nHowever in Firefox it is being overwritten and becoming:\n    application/x-www-form-urlencoded; charset=UTF-8\nwhich is for all intent and purpose the same thing. If the Bearer class simply used something like:\n    if ($request->server('CONTENT_TYPE') !== null && strpos($request->server('CONTENT_TYPE'), 'application/x-www-form-urlencoded') !== 0) {\nrather than:\n    if ($request->server('CONTENT_TYPE') !== null && $request->server('CONTENT_TYPE') != 'application/x-www-form-urlencoded') {\nall would be fine, is this an acceptable change? I'm quite happy to make a pull request.\nKind Regards\nBen\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/144\n. The scopes a token has access to are stored with the access token.  If additional scopes are desired, the client will have to start the authorization process all over again.\n. the client_id is the \"3rd Party\", or the party wanting to access the data, whereas the user_id is the First Party, or end user.  In JWT, the names are slightly different but the roles are the same.  iss, or the \"issuer\" is the client, and sub, or the \"subject\" is the user.\n. I apologize. I need to update the README. We have hardened default security so that the state parameter is required unless otherwise specified. You can disable this by passing the configuration value \"enforce_state\" to false.\u00a0\n\u2014\nBrent Shaffer\n\nOn Sat, Jun 1, 2013 at 2:10 AM, axsProjects notifications@github.com\nwrote:\n\nWhile following the readme example, while trying the authorization step, it gives an invalid request type error and says \"state parameter required\". There's no mention of the state parameter in the readme.   \nHave I missed something?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/147\n. merged\n. What DBMS's has this been tested with, other than MySQL?\n. @dsquier awesome repo!  I can call this out in the README if you'd like.\n. Good question! I have implemented a bridge library for HttpFoundation here:\u00a0\n\n\u200bHttps://GitHub.com/bshaffer/oauth2-httpfoundation-bridge\n\u200bThis details a Silex integration, so Symfony2 would be similar. I would love to write a bundle for this, and will definitely try to do so now that I know there is a need for it. The FOS bundle seemed popular enough that it wasn't worth my time.\u00a0\n\u2014\nBrent Shaffer\nOn Sat, Jun 8, 2013 at 9:56 AM, cpjolly notifications@github.com wrote:\n\nHi there,\nI see the mention of Symfony2 in the Cookbook/Examples issue, and I just wondered if there are any examples out there of using this library with Symfony2. I've built a couple of applications using the following server-side and client side bundles as a starting point for OAuth2 for authorization and data access, but am not that happy with the results.\nhttps://github.com/FriendsOfSymfony/FOSOAuthServerBundle \nhttps://github.com/hwi/HWIOAuthBundle\nThanks\nChris Jolly\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/151\n. Whoops, the URL is:\n\n\u200bhttps://github.com/bshaffer/oauth2-server-httpfoundation-bridge\n\u2014\nBrent Shaffer\nOn Sat, Jun 8, 2013 at 9:56 AM, cpjolly notifications@github.com wrote:\n\nHi there,\nI see the mention of Symfony2 in the Cookbook/Examples issue, and I just wondered if there are any examples out there of using this library with Symfony2. I've built a couple of applications using the following server-side and client side bundles as a starting point for OAuth2 for authorization and data access, but am not that happy with the results.\nhttps://github.com/FriendsOfSymfony/FOSOAuthServerBundle \nhttps://github.com/hwi/HWIOAuthBundle\nThanks\nChris Jolly\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/151\n. This issue has been moved here: https://github.com/bshaffer/oauth2-server-bundle/issues/2\n\nPlease stay current with the Symfony2 Cookbook Example for a walkthrough here.\n. The user ID is passed in with the call to the Authorize Controller and handled from there automatically. Please send a PR, as you're right, we need to add this!\n\u2014\nBrent Shaffer\nOn Sun, Jun 9, 2013 at 3:27 PM, Andy Beverley notifications@github.com\nwrote:\n\nI can't find any documentation about using the user_id parameter. Am I missing it or does it not exist?\nIf it's the latter, then I'll happily add a few notes to the Readme file, if that suits? It's taken me a while to work it out.\nBTW: Thanks for merging previous request - I didn't manage to work out how to resubmit within the Github web interface (next time I'll just check the code out myself!)\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/152\n. Yes, that is the correct way to do it.\n. The getUserDetails method on the storage objects is what you want to use to check if a user exists. It takes a username, and returns an array of data or null. This is available on th PDO storage class.\u00a0\n\n\u200bIn general, I have tried to make the server db layer as lightweight as possible, so i encourage extending the PDO object to fit any other application needs.\u00a0\n. The response parameter is optional in the current version, which is why it's excluded in the README.\u00a0\n\u2014\nBrent Shaffer\nOn Thu, Aug 8, 2013 at 7:37 AM, Minja Malovi\u0107 notifications@github.com\nwrote:\n\nPlease change\n$token = $server->getAccessTokenData(OAuth2_Request::createFromGlobals());\ninto this\n$token = $server->getAccessTokenData(OAuth2_Request::createFromGlobals(), new OAuth2_Response());\non link\nhttp://bshaffer.github.io/oauth2-server-php-docs/overview/userid/ \nthanks :)\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/152#issuecomment-22323777\n. User ID Documentation: http://bshaffer.github.io/oauth2-server-php-docs/overview/userid/\n. The user_id is retrieved server-side from the access token, but not client-side. And it will be null if the value in the database is null.. Are you referring to the oauth2 demo library?  If so, this issue should be opened there instead of here.\n. Can you try to explain what the issue is again? I am having a hard time understanding the problem. \u00a0\n\n\u200bYou've set the expiration to ten seconds, so the access token expires after ten seconds. This is the correct behavior.\n\u200bWhy would you want your access token to expire in 10 seconds?\u00a0\n\u2014\nBrent Shaffer\nOn Tue, Jun 11, 2013 at 8:07 AM, sttarneyiat notifications@github.com\nwrote:\n\nI am using the library for my own implementation and had this issue. I did\ndownload the demo app and played with it and the issue is there too. I did\nreport an issue on the demo app as well (\nhttps://github.com/bshaffer/oauth2-demo-php/issues/19) but it seemed to me\nthat the changes needed were in the vendor folder. I could be wrong if you\nlook at the demo issue I opened there are more details to where I thought\nthe issue may be.\nOn Jun 10, 2013 8:51 PM, \"Brent Shaffer\" notifications@github.com wrote:\n\nAre you referring to the oauth2 demohttps://github.com/bshaffer/oauth2-demo-phplibrary? If so, this issue should be opened\nthere https://github.com/bshaffer/oauth2-demo-php/issues/new instead of\nhere.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/153#issuecomment-19235393\n.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/153#issuecomment-19260152\n. You do not have a proper undersanding of the Refresh Token workflow.  The Refresh Token is used by your client to request a new Access Token once theirs has expired.  This is done using the /token endpoint.  So, the Refresh Token is used by the client to request a new Access Token.\n\n\nRead more on Refresh Tokens here:\n- Refresh Token Workflow\n. What you are doing above is a nice work around, but passing the token in the querystring is reserved for GET requests (see here: http://tools.ietf.org/html/rfc6750#section-2.3)\nThe real problem is you're passing multipart/form-data as the enctype value, which doesn't encode anything. This is not valid for OAuth2.  See here: http://tools.ietf.org/html/rfc6750#section-2.2\nSo in other words, you're explicitly not supposed to submit enctype=multipart/form-data with a Token.  I would suggest using a proxy call and sending the token in the Authorization header instead.\n. I actually retract this... I think the workaround being used here is fine.  After a closer reading of the spec, use of passing the token in the querystring is highly discouraged, but allowed in cases where the Authorization header and the use of application/x-www-form-urlencoded is unavailable.  This example above seems to fit that use case.\n. Good catch, I definitely agree. User_id is required.\u00a0\n\u2014\nBrent Shaffer\nOn Tue, Jun 11, 2013 at 8:51 PM, ademarre notifications@github.com\nwrote:\n\nI started getting the following notice after implementing OAuth2_Storage_AuthorizationCodeInterface:\n    PHP Notice:  Undefined index: user_id in /vagrant/main/vendor/bshaffer/oauth2-server-php/src/OAuth2/GrantType/AuthorizationCode.php on line 76\nThe DocBlock for OAuth2_Storage_AuthorizationCodeInterface::getAuthorizationCode() is missing the user_id element in the @return description. I imagine it should be REQUIRED, or else OAuth2_GrantType_AuthorizationCode needs to check if $this->authCode['user_id'] is set before trying to access it.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/156\n. Oh, tricky. Good catch. \n. This is definitely one of my goals. Switching 100% to http foundation means less code in the universe.\n\nHowever, there are other frameworks which have other request objects, such as yii, laravel, zend, Drupal etc. \u00a0so we want to make sure those frameworks can integrate easily by implementing some common interface.\u00a0\n\u2014\nBrent Shaffer\nOn Fri, Jun 14, 2013 at 5:27 AM, Julien Chaumond notifications@github.com\nwrote:\n\nI feel like the code would be cleaner if you just relied on HTTPFoundation's Request and Response. It would also, obviously, remove the need for a separated HTTPFoundation bridge. Is this something you'd be considering?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/158\n. Yes, but for Drupal 7 and the rest, we want an interface that clearly defines the requirements, as extending httpfoundation may not be an option, extending the native framework request object may be the only way.\u00a0\n\n\u200bone of my issues with httpfoundation is there is no request interface. So we will need our own request interface and implement it on top of the httpfoundation request\u00a0\n\u2014\nBrent Shaffer\nOn Fri, Jun 14, 2013 at 10:10 AM, Julien Chaumond\nnotifications@github.com wrote:\n\nWell, at least Laravel and Drupal 8 now use HTTPFoundation. For the other ones, it wouldn't be a breaking change anyways \u2013 if I'm not mistaken \u2013 as you can always extend Request and Response like you do right now.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/158#issuecomment-19462645\n. Yeah, we should make this happen sooner rather than later.  This is really just a hangover from the php 5.2 support\n. Yes, that's right. A different token type would require a subclass or new class implementing the TokenType interface\n\u2014\nBrent Shaffer\n\nOn Tue, Jun 18, 2013 at 10:29 AM, Raymond Plante notifications@github.com\nwrote:\n\nOk, so the JSON response with token_type is the correct thing to expect.  Yes, I'm was wondering where the type of token is being stored--but now I see it's hardcoded into the Access token constructor.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/159#issuecomment-19623193\n. The \"'\" should work just fine... Was it a typo? Are you on a windows machine?\n\n\u200bSingle quotes shouldn't cause this kind of error...\u00a0\n\u2014\nBrent Shaffer\nOn Tue, Jun 18, 2013 at 10:48 AM, fernandobagno notifications@github.com\nwrote:\n\nI remove \" ' \" from line command in grand_type=credentials and work ok. Sorry bi this ticket.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/160#issuecomment-19624405\n. Okay so the single quote is invalid on windows?\n\n\u200bI have not tested on windows. This is good feedback! Is there anything else that needs changed?\u00a0\n\u2014\nBrent Shaffer\nOn Wed, Jun 19, 2013 at 7:00 AM, fernandobagno notifications@github.com\nwrote:\n\nYes, I'm on a windows machine and typo is ok. I copy from your tutorial.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/160#issuecomment-19682048\n. What is your php version and operating system?\n\u2014\nBrent Shaffer\n\nOn Wed, Jun 19, 2013 at 12:48 AM, f4hem notifications@github.com wrote:\n\nFatal error: Can't inherit abstract function OAuth2\\GrantType\\GrantTypeInterface::validateRequest()\nwhy I get this message, I use branch develop with namespace\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/161\n. This is almost certainly because your version of PHP 5.3 is not supported. If possible, try upgrading your php version or using the php5.2_develop branch.\u00a0\n\nOn Sun Jun 23, 2013 at 9:28 AM, f4hem notifications@github.com=\"mailto:notifications@github.com\"> wrote:\nOS: mountain lion use MAMP packages\nphp version: 5.3.6\n\u2014\nReply to this email directly or view it on GitHub.\n. The earlier versions of PHP5.3 don't support inheriting from two different interfaces with the same function. \u00a0ClientAssertionType AND GrantType both declare the functions \"getClientId\" and \"validateRequest\", which is causing an error with your version of php5.3. \u00a0This is a shame because it is very practical. However, this is the issue you are encountering. I think the best way to handle this is to mark this library as not compatible with versions of php5.3 which do not support this feature (which includes 5.3.6)\u00a0\n\u2014\nBrent Shaffer\nOn Sun, Jun 23, 2013 at 9:56 AM, f4hem notifications@github.com wrote:\n\ninterface GrantTypeInterface\n{\n    // I comment this two lines, and works\n    // public function validateRequest(RequestInterface $request, ResponseInterface $response);\n    // public function getClientId();\n    public function getUserId();\n    public function getScope();\n    public function createAccessToken(AccessTokenInterface $accessToken, $client_id, $user_id, $scope);\n}\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/161#issuecomment-19876096\n. It appears this was fixed in PHP 5.3.9:\n\nhttps://bugs.php.net/bug.php?id=43200\nhttp://php.net/ChangeLog-5.php#5.3.9\nI will test a bit more to be sure\n. We have full test coverage for php 5.5.19.  I cannot test 5.5.9 specifically without a little more effort on my part than I'd like, but I see nothing in the php changelogs to suggest such an issue with 5.5.9.  \nHowever, if this is truly an issue, I would suggest using the php5.2 branch of this library\n. @dreaddy What version of PHP are you on now? The error you describe is actually different from the one mentioned earlier in this issue... your error is from extending an interface rather than combining them.\nWhat exactly do you think resolved the issue, if it was not the PHP version?\n. Thank you for looking into it. I'm more curious what version you were on before that was causing the problem... we have conflicting reports on which version causes the issue.\n. Aha, perhaps it was < 5.3.9\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\nOn Fri, Oct 3, 2014 at 2:41 PM, dreaddymck notifications@github.com wrote:\n\n@bshaffer https://github.com/bshaffer\nunderstood.\nPrior to the upgrade I was running php 5.3.x latest on CentOS release 6.5\n(Final).\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/161#issuecomment-57856721\n.\n. @almaruf the develop branch of this library is only compatible with php 5.3.9 and above (see the requirements). \n\nKeep in mind PHP 5.3 is EOL'd and is no longer receiving security fixes. Even so, I acknowledge many people do not have the ability to upload servers for a multitude of reasons. For them, we have the php5.2-develop branch. \nIf you need features only found in develop, consider extending or modifying the library to do so (i.e. copying the interface classes and removing the methods, and then ensuring your autoloader finds them first)\n. Hi Jovan,\nIf you call getAccessTokenData on the ResourceController (or Server) object, you will receive an array representing the access token's data, which includes the client_id parameter\n. I've added the method getToken, which can be called after validateRequest (if successful) in order to retrieve the token data.  This will allow you to get the client_id, expires, token, and any other data returned by your token storage.\n. Thank you for reporting this.\u00a0\nSounds like we just need to change the DB setup query to make redirect_uri nullable and then add a conditional in TokenController to check if the redirect_uri was set in the auth code.\u00a0\n\u2014\nBrent Shaffer\nOn Thu, Jun 20, 2013 at 7:43 AM, Raymond Plante notifications@github.com\nwrote:\n\nI ran into this issue as well.  When requesting a code without  supplying the redirect URI, the following request for the  access token using the returned code should not require a redirect URI.  It looks like whenever a Code is requested the redirect_uri is copied from the Client table.  If this field isn't empty, it will fail on access_token request without a redirect API. I found a way around this:\n1. Request the code without the redirect uri\n2. in the oauth_authorization_codes table delete the redirect_uri value\n3. Make the access toke request\n4. Viola! It works....\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/163#issuecomment-19753035\n. from the spec:\n\nIf the request lacks any authentication information (e.g., the client\n   was unaware that authentication is necessary or attempted using an\n   unsupported authentication method), the resource server SHOULD NOT\n   include an error code or other error information.\n. Oh yes... An empty JSON object is definitely no good. \n. This is good stuff!  However, I do not believe the Google Implementation belongs in the main README.  I will be creating a docs directory soon, and will be placing cookbook articles in there.  Once this is complete, I think this article will be perfect.\nThe User ID bit is good to go now, but since these are the same PR, it will have to wait until I get the cookbook stuff up (always better to split into multiple PRs!).  I'm aiming for later today.\nThank you for this!\n. This would be best in its own article, similar to the scope / state articles\n. Merged to cookbook in #178 and #181\n. I would try subclassing \u00a0TokenType_Bearer, or submitting a PR to make say \"-1\" keep the token alive forever.\u00a0\n\u2014\nBrent Shaffer\nOn Thu, Jun 20, 2013 at 3:03 PM, Raymond Plante notifications@github.com\nwrote:\n\nIs there a way to specify a never-expiring token or not to check expiration date other than the hack I do below?  \nCurrently,  for an access token request, I take the current timestamp and subtract it from the timestamp for Jan 1, 2038 and set the difference as the server's access_lifetime.  This gives me an expiration of Jan 1, 2038 for all my tokens.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/166\n. Good catch. Your analysis is correct, we should check that user ID is set before returning. .\n\u2014\nBrent Shaffer\n\nOn Thu, Jun 27, 2013 at 3:39 PM, trickleup notifications@github.com\nwrote:\n\nThanks for a great library.\nI found a minor discrepancy - when implementingOAuth2_Storage_AuthorizationCodeInterface, getAuthorizationCode() the docblock specifies that client_id, expires, and redirect_uri are required in the response: \n*     return array(\n     *     \"client_id\"    => CLIENT_ID,      // REQUIRED Stored client identifier\n     *     \"expires\"      => EXPIRES,        // REQUIRED Stored expiration in unix timestamp\n     *     \"redirect_uri\" => REDIRECT_URI,   // REQUIRED Stored redirect URI\n     *     \"scope\"        => SCOPE,          // OPTIONAL Stored scope values in space-separated string\n     * );\nBut when requesting an access token through an authorization code, OAuth2_GrantType_AuthorizationCode::getUserId() presumes that the user_id is present after being fetched from storage. Not hard to work around but unless I missed something, the interface docblock should require that user_id is present, or the getUserId() should do an isset() check (I would prefer the latter) so that they are consistent.\nI can submit a pull request if this seems in order.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/167\n. Sorry for the delay, this issue slipped under the radar.  Thank you for reporting this.  \n\nSo, it's not well documented, but the idea was that a Server implementation would either return Refresh Tokens on all access tokens for the supported grant types, or for none of them.  This is decided by omiting or passing the RefreshToken storage object to your AccessToken instance.  Omiting the Refresh Storage object will ensure refresh tokens are not sent out.\nThis is incredibly unintuitive, and requires the manual creation /manipulation of objects in order to change your server configuration.  So I agree... we  would be better off adding a configuration flag for UserCredentials to optionally return a refresh token.  We should do the same with AuthorizationCode, and throw an exception in AccessToken if the RefreshToken storage object does not exist.\n. Obviously the \"ConvApi\" is not something we want in the README\n\u2014\nBrent Shaffer\nOn Fri, Jun 28, 2013 at 8:45 AM, Trent Petersen notifications@github.com\nwrote:\n\nI could very well be wrong, I will admit I know very little about OAuth, but looking at the PDO Storage Query, and the JWT OAuth 2.0 Client Authentication and Authorization Grants Draft, this is what I came up with:\nSQL\nCREATE TABLE `ConvAPI`.`oauth_jwt` (\n  `client_id` VARCHAR(80) NOT NULL ,\n  `subject` VARCHAR(80) NULL ,\n  `public_key` VARCHAR(2000) NULL ,\n  PRIMARY KEY (`client_id`) );\nI do not agree with the table definition, but rather tried to stay consistent with what the existing examples define\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/170#issuecomment-20196246\n. This is now in the docs here: http://bshaffer.github.io/oauth2-server-php-docs/cookbook/\n. As the existing test suite did not catch this error, we need to include tests to check this case. \n. Good call, I do not have a contribute guide, but will add one shortly. Thank you for the fix!\n\nThe problem running the suite probably has to do with the redis tests... Unless you have a redis server running on localhost, they will fail. \n. It is most likely due to a bad merge. Please submit a PR for this and thanks for reporting!\n\u2014\nBrent Shaffer\nOn Fri, Jun 28, 2013 at 8:26 AM, Trent Petersen notifications@github.com\nwrote:\n\n/src/OAuth2/GrantType/JwtBearer.php\nI was trying to com up with a solution to #170 (and to try to understand JWT better myself) and noticed that there is a duplicate check in the validateRequest method.\nI would have made a PR to remove it, but I am unsure if you intended it to be a different check.\nPHP\n    public function validateRequest(RequestInterface $request, ResponseInterface $response)\n    {\n        if (!$request->request(\"assertion\")) {\n            $response->setError(400, 'invalid_request', 'Missing parameters: \"assertion\" required');\n            return null;\n        }\n        if (!$request->request(\"assertion\")) {\n            $response->setError(400, 'invalid_request', 'Missing parameters: \"assertion\" required');\n            return null;\n        }\n        // Store the undecoded JWT for later use\n        $undecodedJWT = $request->request('assertion');\n...\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/172\n. Thanks!\n. Agreed, it should be required in the docblock\n\u2014\nBrent Shaffer\n\nOn Fri, Jun 28, 2013 at 12:45 PM, trickleup notifications@github.com\nwrote:\n\nIn RefreshToken::createAccessToken(), refresh token is required:\nif ($issueNewRefreshToken) {\n    $this->storage->unsetRefreshToken($this->refreshToken['refresh_token']);\n}\nBut in RefreshTokenInterface::getRefreshToken() it is not required in the response array. \nMaybe in this case the best solution is to just require it in RefreshTokenInterface (i.e. just changing the docblock)?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/175\n. Please add \"string\" or \"identifier\" \n. We now have an example in Restler: http://bshaffer.github.io/oauth2-server-php-docs/cookbook/restler/\n\nClosed.  Refer to https://github.com/Luracast/Restler/issues/68 or to the cookbook repo for additional updates\n. Yeah, I'm still workin on the cookbook. PRs are always welcome!\n. I cannot find any evidence of this:\n\u200b\n\u00a0https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Redis.php\n\u2014\nBrent Shaffer\nOn Mon, Jul 1, 2013 at 12:01 AM, ywliu notifications@github.com wrote:\n\nHi,\nOn line 19 ,  OAuth2\\Storage\\Redis.php of the \"develop\" branch, \nJWTtBearerInterface\nshould read \nJwtBearerInterface.\nIt's a small typo , but big enough to break the autoloader.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/180\n. Yes, it has to do with the HTTP method being used. Loading the file in your browser will throw this error because the browser is issuing a GET request. That is why the example is using cURL, so you are able to issue a POST request \n. If you submit the POST request using multipart/form-data, you can include the access token parameter using the AUTHENTICATE header, or the access_token querystring parameter. The multipart/form-data encoding IS supported, but when used the access token is not allowed in the request body.\u00a0\n\u2014\nBrent Shaffer\n\nOn Wed, Jul 3, 2013 at 3:18 PM, alkhoo notifications@github.com wrote:\n\nCurrently, oauth2 library supports only application/x-www-form-urlencoded, \nQuestion: To upload a file (image), it requires a POST of multipart/form-data, if I add access_token to the submission, oauth2 won't work since it doesn't support it. \nNeed advice on the posibble work-around or patch. Offhand, it is easy to write a subroutine which checks against the stored access token, but that breaks the oauth2 flow. \nThanks in advance,\nAlvin\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/184\n. No problem, thanks for reporting the issue!\n. This looks great! thank you.\n. Would love to get the docs updated: http://bshaffer.github.io/oauth2-server-php-docs/overview/scope/\n. This may have to do with urldecode not being called before the redirect_uri is stored, but I'm not sure.\n\n@cristian-osf consider writing a Unit Test that expresses the error in this case.  That will help us with the fix.\n. Can you provide an example of these errors?  I cannot create them, myself.\n. Line 21 is now a white space indent. Before it was just a newline. Which is why it's showing in the diff. \n. No problem. I only ask because I turned on all warnings in a test script and could not reproduce the issue. It could relate to your php version. In any case, I need to reproduce it in order to be sure it's fixed. \n. good find!  thank you.\n. Thank you for your work on this!  I woud appreciate these two commits to be separate pull requests, however.\nTry creating a new branch from my develop branch named fix-reference-errors, cherrypick a932187f4a805a6b3d0bbef0903c7d377b4c6d4a, and then send a pull request from that branch.\n. Also, explain to me the advantage of the ErrorCode class.  Is the main reason this is desired is for code organization?  To me, it only serves to obscure the values being returned.\n. Open another PR with the error codes and we can continue discussion there.  However, i do not think it is a necessary enhancement.\n. This has been added to http://bshaffer.github.io/oauth2-server-php-docs/overview/scope/\nThank you\n. All properties and methods are private unless there is a specific reason to make them protected. This preserves backwards compatibility with future versions. \n. I agree there are some methods / properties that should be protected, however.  Such as storage and config properties\n. The spec states the ClientCredentials grant type MUST NOT allow for the issuing of refresh tokens. So the answer is, you have to use a different grant type to receive a refresh token with your access token. \n. @oytuntez no, just in this case, and even here it was an accident. We can definitely open Client Credentials up for Refresh Tokens\n. Yeah, good points by @Kalyse. Since it's not strictly forbidden, I wouldn't mind if a PR was submitted to add this, but it is not a priority for me.\n. The difference should be handled using SCOPE. When an access token is requested using client credentials, set a different scope for that token request as opposed to the authorization code request. \nhttp://bshaffer.github.io/oauth2-server-php-docs/overview/scope/\n. This library implements the query string identifier as set forth by the oauth2.0 specification.  UserCredentials should actually be changed to ResourceOwnerPasswordCredentials to match the spec, but this still is different from the password identifier.\nThe Jwt identifier exists because it is an extension grant, and the specification registers that value for the grant type identifier.\nSo, renaming UserCredentials to ResourceOwnerPasswordCredentials is a valid concern, but the rest matches the spec, and will not change.\n. This looks good! We will want to rename the test file and the interface file, and remove the old UserCredentials file entirely\n. Would you like to rebase this so I can merge it in for the 1.4 release?\n. Interesting. I wonder if there is test coverage for this. \n. yes I agree.  I think we just need an explode in the checkRestrictedGrantType method\n. I agree this would be a great change.\u00a0\n\u2014\nBrent Shaffer\nOn Wed, Jul 31, 2013 at 7:47 AM, Trent Petersen notifications@github.com\nwrote:\n\nI would say this is absolutely reasonable, and should be easy to accomplish through the config array that's already passed to the controller.\n+1\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/201#issuecomment-21863460\n. We should include at least one test for this\n. you're a rockstar\n. Ahh yes. Lets make it consistent with the Memory class. \u00a0\n\u2014\nBrent Shaffer\n\nOn Wed, Jul 31, 2013 at 8:02 AM, Trent Petersen notifications@github.com\nwrote:\n\nPreference for the column name for the restricted grants? I don't see anywhere that has a column for it already.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/202#issuecomment-21864476\n. I'm doing the same. No worries. \n. This is fantastic! Thank you.\n. This looks perfect.\n\nCan you educate me why 303 is better in some cases, so we can explain the use-case if anyone asks?\n. I apologize for the long delay here.  Your explanation is excellent, and I fully support this change.  Thank you!\n. We can add a method like this to the storage classes for convenience. However, it should not be required in the Storage interface.\u00a0\n\u2014\nBrent Shaffer\nOn Sun, Aug 11, 2013 at 8:15 AM, nasaorc notifications@github.com wrote:\n\ni would like to manually purge a authorized token\nfor example, user pressed a button in the mobile app\nthen i'll need to create a controller to remove all access_token,refresh_token\nand also they revoke app access from webpage too\ndoes this library has any function like this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/206\n. Yes, you are right. Any oauth implementation will allow for token revocation, retrieval of all existing tokens, and more.\u00a0\n\nI would love you to submit a Pull Request. This is the fastest way to get the code in. If not, then I will try my best. But it's community software so contributions are encouraged!\n\u2014\nBrent Shaffer\nOn Sun, Aug 11, 2013 at 11:56 AM, nasaorc notifications@github.com\nwrote:\n\nSo I need to wrote it by myself or wait for update?\nHow do I remove both access and refresh token from database\nI suggest this lib should have a function to achieve token revocation\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/206#issuecomment-22461944\n. Yes, you are right.  The RFC includes scope as a valid parameter for the client credentials grant type: http://tools.ietf.org/html/rfc6749#section-4.4.2\n\nThank you for finding this\n. I spoke too soon.  See this test for Client Credentials and scope. \nIf the scope comes through the request scope querystring parameter, as expected for most grant types, this is validated in the controller.  The GrantType::getScope method only returns a scope if it is not provided in the request, which is the case when using the Authorization Code Grant Type (see here) and JWT grant type.\nSo, the functionality you are requesting does exist.  It would be wise to add documentation above the method to avoid this confusion\n. The Implicit grant type, which is what you're asking for, does NOT support a refresh token.  See #4.2.2: \n\nThe authorization server MUST NOT issue a refresh token\n. The specification does not allow for refresh tokens on the implicit grant type. From the code:\n\n/* a refresh token MUST NOT be        \n     * included in the fragment\n     *\n     * @see http://tools.ietf.org/html/rfc6749#section-4.2.2\n     */\n. This is expected behavior. Default scope does not apply if another scope is specified. \n. You can achieve this by extending the OAuth2\\Scope object if you want the \"basic\" scope to be included for all requests, although I do not recommed this approach.  The \"basic\" scope should be omittable if desired.  Otherwise, you're basically including methods that have no scope, which can be achieved by passing null as the scope parameter to AuthorizeController::validateAuthorizeRequest\n. Do you want to submit a Pull request for this issue?\n. Also, any chance i can get some of your code samples for Yii integration for the cookbook?\n. What is your version of php? You must run >= php 5.3.9\n. The ScopeInterface should definitely be added to all the storage engines.  Good call.\nI'll try to code this up ASAP.  PRs are welcome!\n. Looks great!! Thank you. \n. On second look, we may want to go about this in a different way - this implementation only allows for client specific scope, and many implementations will want to use the storage classes to configure global scope \n. I don't understand. Why would we want to force scopes to be client specific?  This is a feature, not a requirement. \n. We do not want to force configuring scopes on a per-client basis.  There are the global scopes, and per-client scopes can be configured if desirable.\n. I can't see why not... The more storage engines the better\n. It is good to remember this library does not take into account your application-specific logic. The server returns the token response, which does not include a user_id according to the spec. \nWhat you may want to do is override the storage class so that the user_id is returned as part of getUserDetails\n. Moved to stack overflow.  Good dialog!\n. The clients need to have access to their secrets - I.E. the OAuth provider shows these secrets in the web UI.  So destructive encryption is not an option.  We could add support for PGP keys, but this is overkill and not something I've seen used in OAuth servers.\n. Looking at the Refresh Token specification, there is no mention of the original access token or what to do with it.\nI would like to look at other OAuth2.0 APIs (Google/Facebook/github) and see how they handle this.  Is the original access token revoked once a new one is issued?\n. You mean instead of the scope_group values, the call to getClientDetails in PDO should return the scope list by default?\nI think this is a good call.\n. Yes, that makes a lot of sense and would be perfect.\n. Sorry for stomping on your previous scope implementation... it was really great, but I'm hoping this works better for most use cases.\nWe should provide convenience methods on the PDO class for setDefaultScope($scope, $client_id = null) and setSupportedScope($scope, $client_id = null) as well.  I'll add this now.\n. Man, this is really throwing me for a loop.  I don't like the scope_group implementation because it adds complexity that may or may not be desired.\nYet, the issue is, client specific scopes pertain more to ClientStorage, but global default/supported scopes are more ScopeStorage.\nWhat if ScopeUtil accepts an optional ClientStorage argument in the constructor?  If this is passed in, and client_id is passed into the scopeExists and getDefaultScope functions, the client-specific scope is returned.  If not, it uses the ScopeStorage interface.  If client_id is supplied without the ClientStorage argument, an Exception is thrown.\nThis solves the issues I've been having conceptually, but I'm not sure if this is good in the long run, or just confuses everything.  Thoughts?\n. Okay, I am really sorry for my flip-floppiness here.  I've made all scope logic in the oauth_scopes table, to keep the storages separate.  This allows your scope storage to exist in memory while your client storage exists somewhere else.\nFor this reason, getClientDetails will not be returning the scopes.  I do not want to couple Storage\\ScopeInterface with Storage\\ClientInterface.  This may seem silly, but I think it's the best way.\n. I have updated the docs, but in general issues like this can be resolved by checking out the latest stable version from github.  At the time of this writing, the latest stable version is v1.0\n. Have you tried creating the oauth scopes table in MySQL?\u2014\nBrent Shaffer\nOn Thu, Feb 20, 2014 at 2:26 PM, feelzyinc notifications@github.com\nwrote:\n\nFYI ... I also have this issue no matter what version I use  (dev or master).\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/229#issuecomment-35670857\n. Thank you!\n. this issue has been moved to the documentation repo above\n. The tests will need to be updated for this new change, as they have been written to check for the old error message. \n. I have verified that the spec does not disallow PUT and DELETE methods from being used:\n\nhttp://tools.ietf.org/html/rfc6750#section-2.2\n. Keep in mind the Authorize header is still the preferred way to authenticate with an access token, unless otherwise unavailable\n. I think it would be fine to add. There may not be a use case for it, but maintain consistency, I think it's appropriate\u00a0\n\u2014\nBrent Shaffer\nOn Wed, Sep 11, 2013 at 5:14 PM, Jonathan Reinink\nnotifications@github.com wrote:\n\n\nKeep in mind the Authorize header is still the preferred way to authenticate with an access token, unless otherwise unavailable\nInteresting, I didn't even realize that. In that case, do you think it's even worth updating the library to accommodate PUT and DELETE? I ran into this issue while building a RESTful API, but if headers are the norm, that I'd rather go that direction.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/233#issuecomment-24283917\n. Unix timestamps are being used throughout, so I'm not exactly sure what is being asked for here\n. Interesting, I'm not sure why that was added.\n\n\nDoes your implementation require the client_id to be passed in for this function?\n. Do you want to submit a PR for it? You've made the changes so many times it sounds like you could submit the changes to this repository fairly quickly.. Try removing the trailing comma so your file is  valid JSON format. \nAlso, is this composer.json file in your project, or in the oauth library itself? Be sure not to edit the library composer.json\n. If you'd like more help, please provide your full JSON file.  However, it seems clear this issue can be fixed by validating your JSON.  If you believe the docs are responsible for this error, please point to the place in the documentation where the error exists.\nthank you.\n. I added this to the comments.  All the built-in storage engines already return the user_id as part of the getAccessToken response, so the only thing to really do here is update the doc block.\n. You're right... The call to getAllQueryParameters was removed in b53bec7e750b8d526762b17c24c98562d347d7fa.  It was initially put there for ExtensionGrant grant types, but until those are added I see no reason to keep it in the interface.\nBut please tell me the problem with using file_get_contents('php//input')?  And if there is a problem, do you know of a work around?  I definitely want this library to be zf2 compatible\n. There are some strange nuances around the PHP_AUTH_USER and PHP_AUTH_PW logic.  Some of this has to do with apache, some with PHP, and yes it's a huge pain in the butt.\nWe will be switching to HTTPFoundation soon, and this will become obsolete. But I disagree... the Request object should take care of the authorization parameter handling, and the HttpBasic class asks the most basic questions of it.\n. So after 5 months of solid contemplation, I have decided to close this PR because I believe this is already taken care of in the Request class (https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Request.php#L146).  Here, the different ways the Authorization header could appear are normalized to use PHP_AUTH_USER and PHP_AUTH_PW, which to my understanding is the default way PHP handles basic HTTP authentication. \nIf this is still an issue in your app, @svycka, then please reopen this (and could you submit a Test Case so I can see what is failing?) and I'll take another look.\nThanks!\n. I am thinking we should use parameters instead of sticking the type directly in the query\n. i.e.: \nphp\n$stmt = $this->db->prepare($sql = sprintf('SELECT scope FROM %s WHERE type=:type AND (client_id=:client_id OR client_id IS NULL) ORDER BY client_id IS NOT NULL DESC', $this->config['scope_table']));\n$stmt->execute(array('client_id' => $client_id, 'type' => 'supported'));\nThis should cover all our bases\n. Whitespace is off, and this is causing travis to fail.  If you can fix these issues, I can merge this\n. If 5edcf14 is reverted from this PR, I will merge it in\n. merged fddecc9 ( see 766870df1fca01248b8072915b47e0d0f5a0c1da )\n. addresses #121 \n. Documentation for this has been added here\n. This also allows client_id-specific storage of public/private keys, which is very important\n. Hi @nkarakotas \nWhat are you using for storage?  The error refers to the array returned by getUserDetails, and that the user_id key is not set on it.  \nAre you using custom or built in storage?\n. Closing due to inactivity.  Please reopen if you have additional questions\n. Validate is supposed to return a boolean.  The respective interface fields can be called to gather the client data, i.e. getClientId, getScope, getState, etc.\n. Hi @SinanEker!\nCan you post the code for where your ClientCredentials storage is passed in?  If you're using Mongo or PDO, can you include a screenshot (or paste a query select) for the client credentials table?\nI have tested the latest version locally and cannot find any issues.\n. Is it possible the credentials you have there are actually for a user rather than a client?\nPlease reopen this bug if you still need assistance.\n. good catch. Thank you very much!\n. Here is a test that verifies the 403 status code is set: https://github.com/bshaffer/oauth2-server-php/blob/v0.9/test/OAuth2/Controller/ResourceControllerTest.php#L108\nIt is passing.  Can you provide a test case that is failing?  You can fork this library and submit it in a PR.  If so, I can look into the fix.  Otherwise, I think it may be something broken in your implementation\n. Any word on this? Can you verify this is still taking place?\n. This is definitely interesting, but I do not know the cause.\u00a0\nAre you extending any part of the framework? Are you using any subclasses for anything, or are you using the http foundation bridge? Anything out of the standard implementation?\u00a0\n\u2014\nBrent Shaffer\nOn Fri, Nov 8, 2013 at 2:47 PM, marovelo notifications@github.com wrote:\n\nI forked your Demo Application and wrote a test similar to the one that fails in my application. I submited this test as a Pull Request if you are interested (see above).\nThe test doesn't fail so it seems like there is a problem in my implementation. \nI did some more debugging in my application and found out that your OAuth Server implementation sends out the correct HTTP Code (403) but somehow a 401 arrives as a response to my Curl Request. No idea why that happens.\nIf I comment out the line adding the WWW-Authenticate Header (see my post above) the correct 403 HTTP Code arrives.\nTo sum it up I'm quite sure it has nothing to do with your code. Maybe a Curl/Apache/PHP problem. I will need to do more research. Any suggestions are more than welcome.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/254#issuecomment-28049599\n. Not at all!  Your implementation is pretty standard.  Running through silex is the only thing I can think of.. it's possible that the request object is changing the status code somewhere.\n. Where does RFC2617 clearly state this? I only see reference to 401 and nothing referencing 403.\n\nThe OAuth2 spec unfortunately does not mention the insufficient_scope error, as far as I can tell.  However, requesting a Google API with insufficient scope returns the following (abbreviated) raw HTTP response:\n```\nHTTP/1.1 403 Forbidden\nVary: X-Origin\nWWW-Authenticate: Bearer realm=\"https://accounts.google.com/\", error=insufficient_scope, scope=\"https://www.googleapis.com/auth/plus.me\"\nContent-Type: application/json; charset=UTF-8\nDate: Fri, 11 Sep 2015 18:52:38 GMT\nExpires: Fri, 11 Sep 2015 18:52:38 GMT\n{\n \"error\": {\n  \"errors\": [\n   {\n    \"domain\": \"global\",\n    \"reason\": \"insufficientPermissions\",\n    \"message\": \"Insufficient Permission\",\n   }\n  ],\n  \"code\": 403,\n  \"message\": \"Insufficient Permission\"\n }\n}\n```\nIn addition, I ran PHP's built-in web server, and used the following code to test this issue:\nphp\nheader('WWW-Authenticate: Basic realm=\"My Realm\"');\nheader('HTTP/1.0 403 Unauthorized');\nAnd I received the following HTTP response:\n```\n12:04 $ curl -v http://localhost:8000 \n Rebuilt URL to: http://localhost:8000/\n   Trying ::1...\n* Connected to localhost (::1) port 8000 (#0)\n\nGET / HTTP/1.1\nHost: localhost:8000\nUser-Agent: curl/7.43.0\nAccept: /\n\nHTTP 1.0, assume close after body\n< HTTP/1.0 403 Unauthorized\n< Host: localhost:8000\n< Connection: close\n< X-Powered-By: PHP/5.5.28\n< WWW-Authenticate: Basic realm=\"My Realm\"\n< Content-type: text/html\n< \nClosing connection 0\n```\n\n\nHowever, if I reversed the order of the header parameters:\nphp\nheader('HTTP/1.0 403 Unauthorized');\nheader('WWW-Authenticate: Basic realm=\"My Realm\"');\nI received the following HTTP response:\n```\n12:04 $ curl -v http://localhost:8000 \n Rebuilt URL to: http://localhost:8000/\n   Trying ::1...\n* Connected to localhost (::1) port 8000 (#0)\n\nGET / HTTP/1.1\nHost: localhost:8000\nUser-Agent: curl/7.43.0\nAccept: /\n< HTTP/1.1 401 Unauthorized\n< Host: localhost:8000\n< Connection: close\n< X-Powered-By: PHP/5.5.28\n< WWW-Authenticate: Basic realm=\"My Realm\"\n< Content-type: text/html\n< \n* Closing connection 0\n```\n\nSo I may just need to add logic to output the status code HTTP header last, and we should be all set here.\n. No, I'm glad you did. I want to fix any bugs if they exist. But I do think 403 is appropriate for the insufficient_scope response.\nThe difference here though is that the origin server does accept the credentials sent (i.e. client_id / client_secret, access_token, etc), but the credentials do not have the required scopes. It may be mincing words, but I believe this is the intended behavior. \nEither way, it's a bug. We need to either change the order of the header (which as you say, is rather hackish), remove WWW-Authenticate from the insufficient_scope error response, or change the error response to use 401.  I am not exactly sure which is the best solution, at this point.\n. Unfortunately, even if there is a non-hackish way to do #1, your point about other frameworks plugging into this library is very true, and they may not propagate the fix. \n. I am not familar with OpenID Connect, and I do not know of an extension.  But if you end up integrating the two, please submit your work!\n. Not at all! That is why the response type interface exists! :-) I can't wait to see your work.\u00a0\n\u2014\nBrent Shaffer\nOn Mon, Oct 21, 2013 at 11:30 PM, Tom notifications@github.com wrote:\n\nWil do @bshaffer, OpenID Connect basically handles the authentication side instead of the authorization on top of oAuth2 and will be the next version of OpenID 2.0.\nBy a quick look around in the library it looks like it boils down to only a few minor chnages including adding a new ResponseType class, that would not be too much of a problem right?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/255#issuecomment-26778198\n. @tomvo are you still considering submitting a pull request for this?  If not, please close this issue.\n. This was done according to the spec.  See Error codes where the following is stated in the spec:\n\n```\n  If the request lacks any authentication information (e.g., the client\n   was unaware that authentication is necessary or attempted using an\n   unsupported authentication method), the resource server SHOULD NOT\n   include an error code or other error information.\nFor example:\n HTTP/1.1 401 Unauthorized\n WWW-Authenticate: Bearer realm=\"example\"\n\n```\n. Ben,\nThank you for the kind words!\nThis is a great question, and one that I've been considering, as i've seen instances of password grant being used in this manner.\nIf you see the spec docs here, they mention:\n\nThe authorization server MUST:\no  require client authentication for confidential clients or for any\n     client that was issued client credentials (or with other\n     authentication requirements),\n\nSo in other words, only if the client is not considered confidential can we allow the granting of a token without a client_secret parameter provided.  A non-confidential, or public client is defined as follows:\n\npublic\n     Clients incapable of maintaining the confidentiality of their\n     credentials (e.g., clients executing on the device used by the\n     resource owner, such as an installed native application or a web\n     browser-based application), and incapable of secure client\n     authentication via any other means.\n\nIn other words, a client executing on a device like in your example.\nThis library does not currenly support any logic for differenciating between confidential and public clients.  This is obviously a problem in this case.  The easiest way to add support for this in the library is to allow no client_secret to be provided for clients to whom no client_secret exists, as the spec states a public client must not be given a client secret. So this is a necessary (but perhaps not sufficient) condition for public clients.  If further support is added to the library later, it will not conflict with this logic.\nDo you have any interest in submitting a pull request for this change?\n. Yes, this seems appropriate.  The other thing we could do is use the delete method:\n\nhttps://github.com/nicolasff/phpredis/#del-delete\n\nAlthough, as long as the result is the same and we have tests that prove it, I'm okay with the solution above.\nI'd also like to remove the MockRedisClient, as there is no reason we can't just test against an actual redis server.\n. @sjwaller are you still considering submitting a pull request for this?\n. fixed in above PR\n. Thanks @JosephP91, I will update the walkthrough to mention it\n. The http headers is the preferred method, but there are a few cases where this is not possible. If you are uploading multipart form data and submitting to an API, the only place for the token is the Querystring. So there is nothing \"unsafe\" about it (http header is just as unsafe as a Querystring if you're using unencrypted http), but the http header should be used if possible.\u00a0\n\u2014\nBrent Shaffer\nOn Fri, Nov 8, 2013 at 3:20 PM, diggersworld notifications@github.com\nwrote:\n\nYou can put it where you want it and the library will find it. I use mine in the headers.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/262#issuecomment-28051601\n. Some of the interfaces and classes throw fatal errors in <5.3.9 due to this bug that was fixed in that release.\n\nMore information here\n. Yes, you are correct, the UserCredentials flow should provide a token.  There may be something wrong with your request.\nCould you provide more details of the request you're making here, so I can assist you further?\n. Sounds reasonable. Is this something you want to submit a PR for?\n. Good catch, thank you!\n. thank you for the prompt reply, @franz-deleon !\n. This looks great!  I have some picky suggestions and a question regarding the jti storage, but other than that it's perfect!\nWith nonce storage, the nonce and expiration are sufficient to reject the attack.  The way you've defined it, the nonce (jti) can be replayed as long as the other parameters are different.  This is not the intended use of a nonce.  This might be okay with JTI, I don't know, but in general security implementations should follow the standard way of doing things, and unless there is a direct reference to allowing the same token to be used for different clients/subjects/etc, I think we should avoid doing so.\nThanks again for your work on this!\n. The reason for my hesitation is I believe nonces are supposed to be globally unique.  Making them not globally unique may reduce collisions, but this is not the intended use of a nonce. \nI can't really justify rejecting this PR for that reason, but it smells a little bad to me.  Overall, this PR is great.  Thank you!\n. @TomHAnderson,\n@F21 is right on. We could definitely benefit from a config parameter require_jti, for instance, as yes I believe if you were to implement this measure you would want to enforce it across the board.\nIf you'd like to submit a PR, I'd start by converting the $audience parameter to a $config array (preserving BC by checking if $config is a string) and adding a require_jti config parameter defaulting to false.\n. Why do you have an issue with the JTI expiring at the same time as the JWT? according to @F21 this is consistent with the spec.\nI don't understand most of what you are proposing with the other parts of your comment, but in general I would want this:\n``` php\n$config = array(\n    'audience' => 'foo.com',\n    'require_jti' => true,\n);\n$jwt = new JwtBearer($storage, $config);\n``\n. The AuthorizationCode expires after 30 seconds. Could this be the problem you are seeing?\n. added in https://github.com/bshaffer/oauth2-server-php/pull/586 asunsetAccessTokenandunsetRefreshTokenin all storage classes.\n. closed in favor of above issue\n. The registered redirect URI at [line 78](https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Controller/AuthorizeController.php#L78) is only used if the supplied redirect URI (i.e.$this->redirect_uri) isnull` (see line 235). \nIf the registered redirect URI is space delimited and th supplied uri is null, then an error is thrown on line 158, and so would never reach the buildUri function which is called on line 105.\nSo, it is impossible for the code to reach the state described above, as the request has been validated\n. Client credentials are only not required for \"public\" clients. And you are right, the library does not currently support the distinction between private and confidential clients, something I would definitely like to change. \nBut for your standard web client (I.e. Confidential clients), the credentials are required\n. Please review #277, as this PR attempts to fix the above problem\n. fixed in #277 \n. thank you for reporting this!\n. @franz-deleon Yes, thank you.  PR for v1.1 is here: https://github.com/bshaffer/oauth2-server-php/pull/276\n. Thank you for the PR, Matt!\n. Some thoughts on this PR:\nLooking at the spec, it seems this behavior is actually intended for ALL grant types (other than Client Credentials and JWT).  For refresh_token, password, and authorization_code (and of course implicit) grant types, the client credentials are only required for confidential clients or clients issued a set of credentials\n\nIf the client type is confidential or the client was issued client\n   credentials (or assigned other authentication requirements), the\n   client MUST authenticate with the authorization server as described\n   in Section 3.2.1.\n\nAlso, this PR does not take into account the fact that the clients may be confidential, and they may have credentials granted.  Only in the case that they are public should they be allowed to perform the UserCredentials grant without specifying a client_secret.\nSo my thoughts are this:\n1. we add a configuration option to ClientAssertionType\\HttpBasic called allow_public_clients\n2. we set this to true by default, and set it to false for GrantType\\ClientCredentials\n3. we add a isPublicClient method to Storage\\ClientCredentialsInterface\n4. Profit\n. I have a PR coming for this shortly, for your review.\n. closed in favor of #277 \n. Highlights include:\n- Formatting / Whitespace fixes\n- Addition of JWT CryptoToken Support\n- Addition of jti (nonce) support for JWTs\n- Storage for Client Supported Scope / Default Scope / Scope Groups\n- Security fix for #274 \n- Misc other bug fixes and changes\n. My basis for making these mutually exclusive comes from this line, which is repeated for authorization_code, refresh_token, and password grant types:\n\nThe authorization server MUST:\no  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\n\nThis says to me \"if a client has been issued credentials, they must be validated\", which I've then extrapolated to mean \"if a client is public, they cannot be issued credentials\"\nThere is a previous note in the spec about having separate registrations for mulitple applications:\n\nA client may be implemented as a distributed set of components, each\n   with a different client type and security context (e.g., a\n   distributed client with both a confidential server-based component\n   and a public browser-based component).  If the authorization server\n   does not provide support for such clients or does not provide\n   guidance with regard to their registration, the client SHOULD\n   register each component as a separate client.\n\nSo, this says to me \"a client can have more than one client id associated with it, if there are multiple client types / implementations involved\".  So in your case, two sets of client credentials, one for the confidiential client and one for the public client, would be appropriate\n. Great!  Thank you for all your help!  Sorry I wrote my own PR... I have been mulling on this one for a while, so it made more sense for me to just implement it.\n. This looks like a problem with how you have configured your web server.  I am not familiar with Nginx, but if you post your configuration here, I may be able to help you.\nAlternatively, if you're running PHP 5.4 or higher, you can use the built in webserver by navigating to your root directory and running php -S localhost:9000.  Then you can substitute your cURL call above with the following:\nbash\n$ curl -u testclient:testpass http://localhost:9000/token.php -d 'grant_type=client_credentials'\nand that will do the trick!\n. A few thoughts on this:\nthe good\n- This is awesome and something this library really needs\n- I really appreciate your work on this\n- the code looks great\nthe bad\n- This is only useful for one grant type, UserCredentials\n- UserCredentials storage is the one most likely to implement another library's storage (i.e. Doctrine2, Wordpress, Drupal, etc)\n- This introduces a dependency on a 3rd party library (zend-bcrypt), and another step in the install process (running composer)\n- I have tried to avoid extending an abstract class for the storage objects\nSo, I am really not sure what to do.  On one hand it's awesome and the library needs it.  On the other hand, it introduces some complexity to the library I'e avoided having, and may not in practice add very much (granted users are using custom Storage for UserCredentials, which is the intention)\nA few options we have:\n1. Make your extension its own library, and use it in oauth2-demo-php and add an article on oauth2-server-php-docs\n2. Merge it\n3. Make it a trait and strip it down to use built-in PHP encryption functions\nAny thoughts / suggestions are appreciated from the masses!\n. Good catch! It actually requires php 5.3.8+. Could you update this?\n. fixed in above commit\n. Good questions!\nOne reason is that the Request object in symfony does not obey an interface, but instead relies on the accessing of public properties.  Since you cannot declare properties in an interface, this makes interopability difficult.\nAnother reason we have not used the originals is to remove dependencies of another library.  We provide a very simple Request class out of the box, and since we use an interface, we allow the use of your own objects if necessary.\nHave you run into problems as a result of this strategy?  If so please let me know, and we can look for a solution\n. I want to use an interface so others can easily write an adapter.  Interfaces clearly define the requirements for the adapter classes.\nI could build an HTTP foundation adapter that obeys the current interface.  That may be the best way to do it.\nYes, composer is for installing dependencies.  However, currently, this step is not required in the library installation, as I have tried to make it simple as possible\nI decided to pass the response by reference in order to make the code cleaner inside the classes.  You'll notice that when consuming the OAuth2\\Server class, passing the Request object in is not required.  Passing the request object in only used to allow dependency injection of other Request classes.\n. This is a good question.  I have not required the $user_id, but there may not be a use-case for a null User ID... such a concept is not even mentioned in the spec.  However, I think it does make sense to require it, as someone who does not do so is probably misusing the library...\n. This is great!  Thank you for catching this bug, and submitting a fix.  I have added one small suggestion and then I would love to merge it\n. If you look at this line, you'll see that the errors are already added to the Response object.  The error is added by the Bearer TokenType class, and in the event that no token exists, the response code is set to 401\nA 401 is returned alone, and nothing else.  This is done according to the specification, which reads as follows:\n\nIf the request lacks any authentication information (e.g., the client\n   was unaware that authentication is necessary or attempted using an\n   unsupported authentication method), the resource server SHOULD NOT\n   include an error code or other error information.\n\nSo in conclusion, this is working as designed.  Please reopen if you have any other questions.\n. there is no \"new spec\", the document I linked to is the latest version. Also, the error you are referring to above is referring to when authentication has already happened, but the request itself is missing a \"required parameter\" (i.e. an authorization code grant where the \"code\" parameter is missing)\nI don't like it either, it's very confusing and it's probably the most common bug on here. But I DO believe this is the correct way to implement the spec. But actually since the spec says SHOULD NOT, we could get away with having it anyway...\n. @dsquier thank you for the feedback, and sorry I screwed up the ScopeStorage implementation so badly the first time around... :(\nAlso, check out the changes I made to JWT.  I moved the scope out of the token payload.  Google places the scope inside the payload while Salesforce uses the querystring.  I decided to go with the second approach, since it keeps things more standard.\n. @dsquier thank you for catching those things.  I've updated this PR with your suggested changes\n1) The \"default_scope\" column has been removed from oauth_clients\n2) a $scope parameter has been added to all storages for setClientDetails\n. This is mainly being created in preparation for the backwards-compatibility-breaking https://github.com/bshaffer/oauth2-server-php/pull/287, which will change how Scope works, and how TokenController is created. \n. A user in issue #106 suggests using cassandra-pdo and the Pdo storage class.  I would love to get feedback on whether this works out of the box or not, and update the docs if so.\n. Good to know, thank you drew!\u00a0\nIf you do manage to build a Cassandra storage Implementation, please share your code! We would love to include it in this library.\u00a0\n\u2014\nBrent Shaffer\nOn Mon, Jan 6, 2014 at 3:35 PM, Drew Broadley notifications@github.com\nwrote:\n\nCheers @bshaffer, unfortunately things have moved on a bit since that extension was maintained (June 2012 is the last activity) and it's quite broken now.\nPHPCassa is the supported library of DataStax (https://github.com/thobbs/phpcassa) and is the preferred and maintained method of connecting. I have been burned from using others and them not keeping up with Cassandra's rapid change of protocols when settling into 1.x and beyond.\nSo unfortunately no PDO compliance.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/289#issuecomment-31694861\n. Wow drew, this looks great!\n\nHave you tried plugging this into the testing framework?\nSee\u00a0https://github.com/bshaffer/oauth2-server-php/blob/develop/test/lib/OAuth2/Storage/BaseTest.php and try adding it to the array and running the test suite\n\u2014\nBrent Shaffer\nOn Mon, Jan 13, 2014 at 10:35 AM, Drew Broadley notifications@github.com\nwrote:\n\nhttps://gist.github.com/drewbroadley/df4421161d25bddbd51a\nI used the Redis storage connector as a base, have created and using this.\nDepends on phpcassa (the client library supported by DataStax who has $$ to maintain it)\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/289#issuecomment-32140874\n. great!  Can't wait to see the improvements.\n. fixed in #298.  Thanks everyone!\n. I am not sure what advantage this would present\n. I think you have a valid point.  I don't see anyone needing to override these functions, so they could be static.  In the future, we could get rid of the scopeUtil class in favor of the ScopeStorage class, and use the static methods for these other things.\n. All scopes must be defined in oauth_scopes for them to be valid.  Simply defining them in the client is not enough.\n\nThere should be one canonical location for all scopes.\n. I should be more clear - you can edit the oauth_clients table in your database and add scopes that only exist for that client, but this is a bad idea as it will cause unexpected results, as you are seeing here.\nIf you have a better solution or think we need to change something / document something / etc, please reopen this issue\n. Why is this desirable rather than just defining all scopes in a single location?\u2014\nBrent Shaffer\nOn Sun, Jan 12, 2014 at 7:15 AM, Francis Chuang notifications@github.com\nwrote:\n\nI think this is a nice feature to have. However, at the moment, I only have JWT and authorization_code clients and each grant type has their own set of scopes.\nTherefore, I hope the implementation will also allow us to turn off the unioning of scopes.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/294#issuecomment-32108837\n. We could also just change the calls to getDefaultScope and scopeExists to accept the previous parameters of $client_id and even $grant_type, to allow the extension of these methods if desirable\n. @F21 Sorry for the delay.  Here is what I suggest - let's build on #304 and also pass in $grant_types = null and any other parameters you think might be relevant.  However, let's LEAVE THESE out of the built-in Storage classes.  I do not think they need to support the added complexity.\n. @bojanz excellent questions.\n1. As far as the user_id question goes, the entire concept of a user identifier is not defined in this library, and is defined by the server implementing the library.  Yes, we have the UserStorage, but that is the most rhudimentary of all the storages implemented in the library, and my hope has always been that someone will develop adaptors for Drupal, Wordpress, FOSUserBundle, etc.  So in conclusion, if we update the documentation to make this clear, will that suffice?\n2. I have been wondering the same thing.  In Adobe's implementation, we simply ignore the $subject parameter.  It does not make sense (to me) to have a public key per client per user.  If this implementation is desired, then this can be done by the application desiring it.  I have to double check the spec to be certain, however.  The author of this grant type is @dsquier.  Perhaps he can shed some light on it.\n. Thank you for your work on this!  I have a few high-level questions, and a few specific suggestions.\n\nSpecific Suggestions\n- We cannot merge anything that breaks the tests.  Please run phpunit to run the test suite (redis and mongo tests will skip if you do not have servers running)\n- There are no tests for the new functionality.  There absolutely must be tests to prove it works, or we cannot merge it\nHigh Level Questions\n1. What specification document are you using for this token?  Is it the JWT spec?\n2.  How is this different from the CryptoToken functionality that was added a few months ago?  I've been considering renaming this to just JWTToken, as CryptoToken is something non-standard.  And it seems that there may be some fields I need to implement.  But other than that, these changes look identical.\nPlease let me know your thoughts, and thanks again for contributing!\n. Thank you for the clarification.  I see your initial thinking here using id_token is correct, and my above questions have been answered!\nLet me pour over this spec and get back to you.  Feel free to update this PR as well, and please write tests before anything else.\n. @bojanz If the nonce is the only reason to save the ID token, maybe we should implement NonceInterface instead? This could also be used for the jti in the JWT Bearer type.\nI'm not sure there's much use saving the id_token, as it can be validated by any resource server carrying the library's public key.  We could also allow for optional local storage, as we do for CryptoTokens\n. Saving the ID token does not seem like a priority to me, as with a distributed system, some resource servers will have no access to the stored ID token (i.e. the Resource Server and the Token Server are not the same). I would love to chat with Nat Sakimura about this.\nI don't mind saving the id_token, as long as it's optional (or required for TokenServers alone) and Resource Servers do not need to validate the token based on the storage. Perhaps the goal is to ensure the id_token is saved somewhere, in which case I am okay with this.  A Storage Engine like MongoDB would be great for something like this.\n. This is a really great PR, nice work guys!\nI am going to pull this down and mess with it.  My main concern is that the openid functionality is too invasive of the core OAuth library. What I mean by this is that this is not an official part of the OAuth specification, and so I don't particularly like having id_token in the AccessToken Interface, or $nonce logic implemented in the controller.\nMy immediate thought is to have a OAuth\\Controller\\OpenIDAuthorizeController, and a OAuth\\ResponseType\\AccessTokenWithIDTokenInterface, or something along these lines. Let me know your thoughts on this.\nThanks again for your great work!\n. Another option is to create (I can set it up, if you don't want to maintain it) a oauth2-openid-extension repository. \n. The only Major problems I have with this are the same as above:\n1. nonce in AuthorizationCode - this should be NonceStorage, and we can even consume it in the JWT Grant Type if desired\n2. openid-specific logic in the AuthorizeController - I would rather this be OpenIDAuthorizeController and instantiate this class in Server, if possible.\nI may just need to take a hard look at all this myself.  I could be wrong... those are just the issues I currently see which conflict with existing paradigms\n. I would like to separate the OpenID-connect classes from the OAuth2 classes, mostly because these are separate specs and I want the code to be orthogonal.\nI'm working on a branch to do this, but this should in no way discourage you from updating this PR.\nThis is GREAT functionality, and I would love to merge it as soon as possible!! Thanks again for your hard work.\n. resolved by #351\n. The scopes are saved in the ClientStorage now (see the method getClientScope($client_id) that now exists in that interface).\nSo, the answer is \n- client-specific \"supported scopes\" have been moved out of OAuth2\\Storage\\ScopeInterface and into OAuth2\\Storage\\ClientInterface.\n- client-specific \"default scopes\" have been removed all together. There is no such thing as a client-specific default scope\nI had the PR open for comment, and should have cc'd you.  Tag v1.2 exists if you need to revert.\nAnd as always, please reopen this and offer comments if you have additional concerns.\n. This is great, thank you!\n. It would be nice to have a removeExpiredTokens method on the PDO class\n. I don't particularly like this solution as it will still leave orphaned tokens in the database.\u00a0\u2014\nBrent Shaffer\nOn Thu, Jan 9, 2014 at 8:10 AM, nasaorc notifications@github.com wrote:\n\nhow about remove the token when user requested a expired token?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/299#issuecomment-31940240\n. This is interesting, as we have tests in PHP 5.5 that are passing.  Are you still having this issue with the latest version?\n\nSee http://3v4l.org/ihSmU - this should work for PHP 5.3.9+\n. please reopen this if you're still having this issue\n. Thank you for catching this!\n. That is because the config for Oauth2\\Server is only passed in when the grant typed are created by default. If you pass the grant typed in explicitly, the configuration should be defined there.\u00a0\nIt's a weird edge case, and one I'm not quite sure how to handle\u00a0\n\u2014\nBrent Shaffer\nOn Sat, Jan 11, 2014 at 12:39 AM, nasaorc notifications@github.com\nwrote:\n\nI tried this:\nphp\n$config = [\n    'allow_credentials_in_request_body' => true,\n];\n$this->oauth_server = new OAuth2\\Server($storage,$config);\n$this->oauth_server->addGrantType(new OAuth2\\GrantType\\RefreshToken($storage));\nalso tried modify Server.php default config:\nphp\n     $this->config = array_merge(array(\n         'always_issue_new_refresh_token' => false,\n     ), $config);\nbut not work, only work if I modify RefreshToken.php:\nphp\n    $this->config = array_merge(array(\n        'always_issue_new_refresh_token' => true\n    ), $config);\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/302\n. Pass it in to the constructor of the grant type\u2014\nBrent Shaffer\n\nOn Sun, Jan 12, 2014 at 3:18 PM, nasaorc notifications@github.com wrote:\n\nhow can I pass the config too? thanks\nOn Jan 12, 2014 9:55 AM, \"Brent Shaffer\" notifications@github.com wrote:\n\nThat is because the config for Oauth2\\Server is only passed in when the\ngrant typed are created by default. If you pass the grant typed in\nexplicitly, the configuration should be defined there.\nIt's a weird edge case, and one I'm not quite sure how to handle\n\u2014\nBrent Shaffer\nOn Sat, Jan 11, 2014 at 12:39 AM, nasaorc notifications@github.com\nwrote:\n\nI tried this:\nphp\n$config = [\n'allow_credentials_in_request_body' => true,\n];\n$this->oauth_server = new OAuth2\\Server($storage,$config);\n$this->oauth_server->addGrantType(new\nOAuth2\\GrantType\\RefreshToken($storage));\nalso tried modify Server.php default config:\nphp\n$this->config = array_merge(array(\n'always_issue_new_refresh_token' => false,\n), $config);\nbut not work, only work if I modify RefreshToken.php:\nphp\n$this->config = array_merge(array(\n'always_issue_new_refresh_token' => true\n), $config);\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/302\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/302#issuecomment-32113019\n.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/302#issuecomment-32116306\n. No, that is the storage class. The grant type is Oauth2\\GrantType\\RefreshToken. Here is some sample code from the documentation:\n\n\nbshaffer.github.io/oauth2-server-php-docs/grant-types/refresh-token/\n\u2014\nBrent Shaffer\nOn Sun, Jan 12, 2014 at 5:10 PM, nasaorc notifications@github.com wrote:\n\nthe constructor of the grant type only is OAuth2\\Storage\\Pdo isn't it?\nany example code?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/302#issuecomment-32117593\n. I think it would be best for the default scope to exist in the ClientStorage rather than the ScopeStorage\n. I removed it because I think default scope per client sounds like an implementation detail more than something we should add to the core library. I.e you can create the scope per client when you register the applications. So the notion of a \"default scope per client\" still does not make sense to me. I still need the scenario explained to me that makes this necessary.\u00a0\n\nThe only time I see this coming into play is if the client is using authorization code and leaves scope blank. Then a default scope is assigned. Are you saying for your applications you want to assign different default scope in this case per client? Why not just have them pass scope in? Pardon my ignorance if I'm missing something obvious.\u00a0\nHowever IF we do add it, then yes I think it should be added to the client table.\u00a0\n\u2014\nBrent Shaffer\nOn Sun, Jan 12, 2014 at 7:05 AM, Francis Chuang notifications@github.com\nwrote:\n\n@dsquier Thanks for the feedback! I placed the default client scope it its own table because @bshaffer removed them from oauth_clients in 7f1211cc51955650366684addbf460b4afe85936.\n@bshaffer Is it alright if I reinstate the default client scope in the oauth_clients table?\nThanks for the link to your repo! Certainly beats trying to work out what tables are created by just looking at the code! :smile:\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/304#issuecomment-32108631\n. Have you considered making the default scope \"false\", which requires the client to provide a scope?\u2014\nBrent Shaffer\n\nOn Sun, Jan 12, 2014 at 11:31 AM, Francis Chuang notifications@github.com\nwrote:\n\nHi Brent,\nSorry for the confusion :smile: It there's a way to achieve the following without it being in the library's core, do let me know!\nIn my scenario, I am using the JWT grant type to get an access token. In this case, if we do not pass in a scope, I would like to be able to assign a default scope to the client on a per client basis. However, the problem is that there doesn't appear to be a way to do this. The request is sent to the token controller and since no scope was provided, the default scope is retrieved using getDefaultScope(). \nThe thing is that in our system, we have a few client types. For example, we have a system service type which is used to call system level jobs such as cleaning up temp files etc on the server. We also have other client types that actually use the services provided by the system.\nIn cases where clients do not pass in a scope, we do not want the system service client type to have a default scope that contains access to the services. If the client type was a normal client type, we do not want them to access system level services.\nHope that makes sense.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/304#issuecomment-32113502\n. This strikes me as an implementation-specific request (i.e. this applies mostly to your use-case, and not to oauth2 users as a whole).  If there are others who need this, I would love to hear from them, and then we can add this.\n\nHowever, it sounds to me like you should do something similar to the following:\n``` php\n// in your controller to get the token/authorize requests\n$request = OAuth2\\Request::createFromGlobals();\n$scopeUtil = OAuth2\\Scope(); // or however you want to create this\nif (!$scopeUtil->getScopeFromRequest($request)) {\n    $request->query('scope', 'default-scope1 default-scope2');\n}\n// .... and then call $server->handleAuthorizeRequest($request);\n// .... or maybe $server->handleTokenRequest($request);\n```\nThis will set the scope manually in the request if it doesn't exist... giving you the convenience you're looking for.\nDoes this seem like it would work?  If so, let's go ahead and close this PR.\nThanks for your contribution / help / etc.  I do appreciate the dialogue / development you've helped create even if we end up closing this.\n. Yes, we may want to pass in okssiblu relevant parameters so it easier to customize your own implemenation\u2014\nBrent Shaffer\nOn Wed, Jan 15, 2014 at 7:24 AM, Francis Chuang notifications@github.com\nwrote:\n\n@bshaffer That's certainly a way to do it and seems like the way to go. There are still some questions, but I will create a more specific issue for that.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/304#issuecomment-32314299\n. Let's pass in client_id and grant_type and possibly other relevant parameters, so that scopes can be customized in client implementations \n. Yes, that's exactly what I had in mind.\u00a0\u2014\nBrent Shaffer\n\nOn Thu, Jan 23, 2014 at 3:21 PM, Francis Chuang notifications@github.com\nwrote:\n\nI think passing grant_type is a good idea. I haven't considered that, but it can be quite useful for client implementations.\nSo basically, have those parameters available in the storage interfaces and leave them out of the concrete implementations like PDO, 'Redis` etc? It should be quite trivial to get this PR updated.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/304#issuecomment-33175853\n. This already returns a response object with an isSuccessful function, which could work as follows:\n\nphp\n$response = $server->handleTokenRequest($request);\nif ($response->isSuccessful()) {\n    // success grant token\n} else {\n    // error, invalid auth code..etc\n}\nOr in your implementation, you would have:\nphp\n$this->oauth_server->handleTokenRequest($this->oauth_request);\nif ($this->oauth_response->isSuccessful()) {\n    // success grant token\n} else {\n    // error, invalid auth code..etc\n}\n. This is a documentation issue with the sql query to run in the walkthrough. fixed in bshaffer/oauth2-server-php-docs@8a3feaa.\nSee the new SQL queryies here: http://bshaffer.github.io/oauth2-server-php-docs/cookbook/\nThis is because of changes in the develop branch. To avoid this from happening in the future try checking out to a TAG\n. You can change the value of the auth_code_lifetime when you instantiate your server class:\n``` php\n// your storage class - whatever this might be\n$dsn      = 'mysql:dbname=my_oauth2_db;host=localhost';\n$username = 'root';\n$password = '';\n$storage = new OAuth2\\Storage\\Pdo(array('dsn' => $dsn, 'username' => $username, 'password' => $password));\n// customize your \"auth_code_lifetime\" value\n$config = array(\n    'auth_code_lifetime' => 600  // ten minutes\n);\n// create the server class with your new config value\n$server = new OAuth2\\Server($storage, $config);\n$server->handleAuthorizeRequest(OAuth2\\Request::createFromGlobals());\n```\nIs this the information you were looking for?\n. This is a documentation issue with the sql query to run in the walkthrough.  fixed in https://github.com/bshaffer/oauth2-server-php-docs/commit/8a3feaaf2c28f8e4b5ca7f70c5c9b17e8fba94df.\nSee the new SQl queryies here: http://bshaffer.github.io/oauth2-server-php-docs/cookbook/\n. Please run the tests by running the command phpunit on the command line. We cannot merge this while the tests are failing. \n. To summarize this issue:\nRequest: The request was that redirect_uri is populated in the authorization_code database even if it wasn't passed in to the /authorize request, in the case that the client has a default redirect_uri\nReason: It's nice to always have the redirect_uri for logging purposes\nWhy this is Wrong: This is impossible because the supplied redirect URI for the /authorize request is validated against the supplied redirect URI for the /token endpoint, so we must track the supplied uri directly and NOT populate with the default value\nSolution: Log the redirect_uri in your own impementation, and leave the core library alone.\n. What is the real ask here? Would you like a way to automatically log transactions? This has been discussed and I agree it would be a nice enhancement.\u00a0\u2014\nBrent Shaffer\nOn Fri, Jan 17, 2014 at 12:57 AM, Alessandro Del Gobbo\nnotifications@github.com wrote:\n\nI don't think it is a bug... i see it as a non strictly-oauth2-related feature that is missing. The protocol don't say to store or track requests and infact a\nJust to be precise, redirect_uri(s) are permanently stored in the oauth_clients table, not _users, and temporarily reported in oauth_codes until the code expires.\nIt would be surely a good feature-set the tracking of all success and failed oauth requests but i think this is optional and also something related to the app being developed as each project require security tracking for different scope and also need different outputs.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/309#issuecomment-32481660\n. @drewbroadley the scope of your user should be passed through to the access_token, but NOT to the authorize_code.  The authorize_code scope is ONLY for scopes requested directly for that phase.\n\nif you want the user's scope to be provided by default, the best way to do this would be to check the scope before calling the validateAuthorizeRequest function.  If no scope exists, then set it to the user's scope who is logged in (if relevant)\nThe reason this isn't implemented in core is the idea of a user having a specific scope in general is not really part of the spec, and more implementation detail.  My hope is that the library allows customizations such as these to take place simpler.  If there is a better way to support this, I am definitely open to suggestions / PRs.\nThank you!\n. I see... yes, this sounds like a bug, as redirect_uri in authorization code WILL have a value if one is passed in during the auth process.  The only time it is null is if no redirect_uri is supplied upon authorize request, which is a valid request, since the redirect_uri can also be configured by the client.\nSo, if a redirect_uri is being supplied explicitly in the URL to an authorize request but not being passed to cassandra, there is a bug somewhere (possibly in the cassandra layer).  \nOn a side note, we added the Cassandra storage engine recently! Your feedback is much appreciated, if you'd like to try and use it.\n. This is a documentation issue with the sql query to run in the walkthrough. fixed in bshaffer/oauth2-server-php-docs@8a3feaa.\nSee the new SQl queryies here: http://bshaffer.github.io/oauth2-server-php-docs/cookbook/\nThis is because scope handling had been updated in the develop branch. To avoid issues like these in the future, you can stay checked out to Tags.\nPlease reopen if you have further questions. \n. Hey there!!! You need to use the HttpFoundationBridge library:\nhttps://github.com/bshaffer/oauth2-server-httpfoundation-bridge\n. Hey there. Can you provide the -v flag and post the verbose curl output here?\u2014\nBrent Shaffer\nOn Tue, Jan 21, 2014 at 12:29 AM, qsoomro notifications@github.com\nwrote:\n\nI am using an MVC framework and have integrated this library into my app and I have created up to the token controller part however I am stuck at when I'm using CLI to post to my token controller (my token controller doesn't use a .php ext in the URL)\nI am doing something like:\ncurl -u testclient:testpass http://localhost/token -d 'grant_type=client_credentials'        but I get a blank reply or nothing. What am I doing wrong? I am VERY eager to set up an OAuth2 server for my app.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/315\n. Copy and paste the actual output from the following command:\n\ncurl -v -u testclient:testpass http://localhost/oauth/token -d 'grant_type=client_credentials'\n. Will you post here what the solution was, in case anyone else encounters this issue?\n. I like this PR!  The OAuth2\\Server class exists for this very reason - to provide the user with an abstraction layer to instantiate the more complex classes.\nHowever, I do not like the organization of the code.  We need to keep things separate and clean.  I would like to see use_crypto_tokens checked in getAccessTokenResponseType, and if true, then createDefaultCryptoToken should be called, otherwise createDefaultAccessToken should be called.  The other logic in addStorage, etc, should be moved.\n. This is all exactly what I had in mind, and looks great.  If I could trouble you with one more suggestion, I would love to see some tests added to test/OAuth2/ServerTest.php to cover the exception being thrown and the default object being created (as a minimum)\n. No problem!  I liked your changes so much I couldn't wait to get them in :)\nI gave this a crack as well, but I'm more than happy to take a back seat.  Here's the branch I got started: jsacksick-openid_connect\n. this is true.  Or we can use the built-in url_encode function in PHP\n. moved to docs repo\n. Thank you for contributing.  Please resubmit when your changes are complete.\n. Due to the limitations of the AuthorizeController, I think we should stick with just passing in the client_id... either that, or pass in the response_type as well.\nI don't see why scopeExists should accept a client_id.  The client scope is validated based on the scopes attached to the client, and not in the scopeExists function.\nSo, unless there's a justification, I think the scopeExists function should remain unchanged, and the getDefaultScope function should either accept just a client_id, or receive response_type as well\n. The same issue exists with grant_type, as that is not available in the AuthorizeController, so for now let's pass the client_id alone and call it good.\n. Yes please!\u2014\nBrent Shaffer\nOn Fri, Jan 24, 2014 at 1:14 AM, Francis Chuang notifications@github.com\nwrote:\n\n@bshaffer Do you also want me to remove the client_id parameter from scopeExists()?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/320#issuecomment-33204470\n. 'require_exact_redirect_uri' means that the supplied URI to the /authorize endpoint and the registered URI for the client (ClientStorage) must be an exact match.\n\nThe $supplied_redirect_uri variable above is named appropriately - it is the exact redirect_uri as supplied in the querystring.  If you notice, this statement is setting a variable, not comparing values.  The conditional could be restated as \"If a redirect_uri was supplied in the querystring...\"\nYou are correct, the require_exact_redirect_uri does not require the redirect_uri to be sent, you are right.  But it does require that if the parameter IS sent, it must match the URI registered with the client exactly.\nCould you provide a Test Case to illustrate where this problem is occurring?  I have full test coverage to ensure that this is behaving correctly.  You can check out the test cases and verify for yourself they are behaving appropriately.\nAs this seems to be an issue of much confusion, I would love to get to the root of it. There is a misunderstanding somewhere.  Let's continue this discussion and find out where clarification, or a bug fix, is necessary. \n. I have not heard back, so I am closing this issue.  Please reopen with further information if you feel this is appropriate.\n. Can you describe the problem you ar trying to fix with this pull request?  As you can see here this pull request breaks all sorts of tests.\nI cannot accept this until the tests are fixed and the problem is described.\n. That is a good point... the Client ID is not explicitly required anywhere in the ResourceController validation.\nBut, your token needs to be associated with a client.  That way, the user can revoke tokens granting access to clients he/she no longer trusts.  So, while the value may not need to be returned in this particular instance, the client_id should be available to the access token at all times.\nUnless there is a use case I am not familiar with, in which case could you please explain it?\n. I will be updating the change log soon. Sorry for the inconvenience. The point in creating new tags is to allow you to upgrade your library and deal with backwards compatibility breaks on your own schedule.\u00a0\nYou can stay checked out to v1.2 if you do not want to deal with the BC breaks introduced in v1.3\nI agree that BC breaks should be called out in the changelog, and will do so. I also hope to have versioned documentation soon.\u00a0\nThanks for your feedback!\n. @svycka here is the changelog: https://github.com/bshaffer/oauth2-server-php/blob/develop/CHANGELOG.md\n. @svycka I am glad to hear it wasn't too bad upgrading (I hope). Feedback is always welcome!\n. nope, nothing security-wise\n. thanks for reporting this issue @mrboo00.  Are you using the most recent version of the library?\n. Can you include all the relevant code?  Are you sure your path to the AutoLoader file is correct and being included as expected?\n. Yes, the auto loader uses the names of the classes to determine the file path. It cannot be changed. \nIn general, you should leave your entire third party libraries unmodified. Otherwise you will lose your ability to update to newer versions. \n. Hey Andy!\nWhat \"better error message\" are you looking for?\nThe best way to do this would probably be to do something along these lines:\n``` php\n$response = $server->handleTokenRequest($request);\nif ($response->getParameter('error_description') === 'An unsupported scope was requested') {\n    return $this->sendBetterErrorMessage('my better error message');\n}\n```\nIs this what you are thinking, or am I missing something?\n. You are saying you want user-specific scopes. This is a point of much debate, as I'm not sure this is something we want. Although, if we went this route I could see us adding to the UserCredentialsInterface a call such as USER::getAvailableScope, that could be validated against.\u00a0\nFor Authorization Code this doesn't really make sense, since the userid is all we see - we never have a user object, for simplicity. So your app could either check the scope itself before calling the library, or pass the user scopes into the call, or something else I haven't thought of. But as you can see, it quickly becomes a tricky problem\u00a0\n\u2014\nBrent Shaffer\nOn Tue, Feb 4, 2014 at 5:34 PM, Andy Beverley notifications@github.com\nwrote:\n\nHi Brian,\nThanks for the prompt reply. I was thinking an error message more along the lines of the existing \"The request requires higher privileges than provided by the access token\" error message (i.e. the scope is supported, but the requested user does not have access to it).\nTo be honest, partly the reason for asking the question was to check whether I had missed existing functionality to do this, so you have answered that question.\nIn terms of going forward, I had a look at the source code, and wondered whether something like the following would be considered:\n- Store the user's available scopes in the server object when \"logging in\" the user.\n- When a token is requested, add the user's scopes to the token, only if available (otherwise return a 401 error).\n- Once the relevant scopes have been stored with a token, the token requests can be processed as normal.\n  I'm happy to have a look at this and see if I can produce a patch, if you think this is the correct way to go?\n  Thanks,\n  Andy\n\nReply to this email directly or view it on GitHub:\n  https://github.com/bshaffer/oauth2-server-php/issues/329#issuecomment-34125541\n. I would always love to see a PR for this, however. I'd like to see how you come up with solving this problem.\n. Hi @qsoomro \nFirst, find out which storage interfaces you want to implement.  You'll always need to implement AccessTokenInterface and ClientCredentialsInterface in any OAuth2 server.  After that, you'll want to implement additional interfaces based on the grant type.  For instance, if you want your server to support the authorization_code grant type (most common), you'll want to implement AuthorizationCodeInterface on your storage object(s) as well.\n\nWhen I say \"implement\", I mean you will write a new PHP class, and the declaration will look something like:\nphp\nclass MyCustomStorage implements OAuth2\\Storage\\AccessTokenInterface, \nOAuth2\\Storage\\ClientCredentialsInterface, OAuth2\\Storage\\AuthorizationCodeInterface\n{\n    // method implementation here...\n}\nAnd then you need to write all the methods that those interfaces require. For instance, ClientCredentialsInterface specifies the method getClientDetails, which accepts a $client_id parameter and returns an array of client data.\nFrom there, you'll pass this new storage object into the server class:\nphp\n$customStorage = new MyCustomStorage();\n$server = new OAuth2\\Server($customStorage);\nAll of the storage objects included in this library are no different from a \"Custom Storage\" object.  The only real difference is that they're included in the library by default, and they implement all the interfaces (yours doesn't have to implement all the storage interfaces, just the ones your application needs).\nCheck out the Cassandra Storage class for an example of a storage object implemented for a \"custom\" purpose - to interface with the Cassandra storage engine.\nI hope this helps.\n. Thank you for this feedback! If you can submit a pull request, that would be amazing. Otherwise I can make the changes myself, but usually a pull request is best for both parties :)\n. The first issue (Pdo storage) has been fixed, and the second issue (Memory Storage) is just an implementation decision, I do not think it requires a change\n. Thanks for the PR!\nCan you submit a test case with this as well, so we can be sure it is fixed, and won't break again?\n. The reason this is important is because our existing coverage missed this, so I want to make sure we don't miss it again.  Also, I would like to check this case with the other Storage objects as well.\n. tests added here: bd41360a803016ad0f59cd291a65bc0e2a274c64\n. scopeExists is not client specific. It is meant to apply to all scopes in the system. The scope is checked against the client's available scope already, so I don't see why we need to pass the $client_id to scopeExists as well.\n. Conceptually, it makes more sense for the method checking client scope to exist in OAuth2\\Storage\\ClientInterface.  \nIf you want to avoid loading all client scopes (which I assume is the problem), we could add $client->hasScope() and $client->scopeExists($scope) in lieu of $client->getClientScope()\n. I am not sure how you are implementing this under the hood, but the current approach is much cleaner than the previous approach... rather than having a row in every scope table for each available client scope, there is only one field which contains all of them, and that field will get loaded with the rest of the client data.\nThe decision had to be made to either have client scopes be kept separate from client storage, or kept separate from scope storage. I decided the majority of use-cases would rather have their client scopes stored with the clients, and not the other way around.\nI do think the library is flexible enough to allow you to do what you need to, however.  For instance, you could make the same class implement both ClientStorage and ScopeStorage. This would allow you to make calls into any already-loaded scopes.\nJust so we're on the same page here... your main complaint is the fact that you have to return a complete scope list instead of just true or false? Or do you think conceptually the new approach is broken? Please be explicit, as I am unsure what the problem is.\n. I like this very much\n. Thank you for catching this!\n. I have requested a pull request from @pjebs. This is definitely the\npreferred method.\nOn Fri, Sep 18, 2015 at 3:05 PM Erik notifications@github.com wrote:\n\nWhy not a Pull Request?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/337#issuecomment-141580422\n.\n. There are other aspects of the JWT spec that should be following when this change is made:\n- \"expires\" => \"exp\"\n- \"user_id\" => \"sub\"\n- \"client_id\" => \"iss\"\n. resolved in #460\n. @bbalet I will as soon as the changes are merged into master for v1.6\n. @bbalet docs updated and release tagged\n. We've already exposed interfaces to add/update/remove all these items depending on the storages used by the application.  To add controllers that allow the developers to administer these objects would be a huge boon.  It would essentially allow for the turning on of an OAuth2 API out of the box.\n. Yeah, that would be really really handy. The problem is, where would the serve be configured in that scenario, and how would the cli know how to instantiate it?\n\nThat would be a good addition to the symfony bundle\n\u2014\nBrent Shaffer\nOn Tue, May 13, 2014 at 11:27 PM, Clement Ridoret\nnotifications@github.com wrote:\n\nhow about having those admins functions available through a cli app? \n(symfony/console for example. that's what I built for a API using this library)\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/339#issuecomment-43043629\n. @Snooze-,\nI have good news! You do not need a PR for this... we have Public Clients supported already! You just need to make sure the secret for that client is empty (see the function isPublicClient in any of the storage classes)\n\nAs this library is extensible, feel free to make isPublicClient use whatever means you'd like to determine if the client can use password grant type without providing their secret, it's up to you!\nPlease reopen this if you have any more questions\n. @F21 this is a very good point. The way I'm implementing it in my own application is by ensuring that subject and the user_id associated with the client are the same.\nDo you see any potential downsides of doing it this way? It essentially requires a client to be created per subject, which I think is okay.\n. We are not going to do this change - it is better as it is\n. sure! I'll create some issues on your project's repository\n. @flx5 there is no build-in interface method to expire all for a user. If you're removing all access tokens for a single user, then you'll want to query everything for that user_id on both your access_token and refresh_token tables, and remove them.\nIf you want to revoke for just a client of a user (i.e. a user says they don't want a client to access their data anymore), then this can be done as well by revoking per client per user.  Again, there is no build-in feature for this.\nSorry for the inconvenience.  Good luck!\n. I'd say you're exactly right on all of your points. This would be an\namazing addition to the library, and is in line with exactly what I was\nhoping to add at some point, so your PR would be much appreciated!\nOn Sat, May 9, 2015 at 9:03 PM Patrick Hindmarsh notifications@github.com\nwrote:\n\nTheres actually an RFC for OAuth token revocation RFC7009\nhttps://tools.ietf.org/html/rfc7009, which outlines some ideas on how\nrevoking tokens should work from an API perspective.\nI've implemented some changes according to this spec in my fork, if you\nthink it might go some way to solving your use-case (and you'd like it in\nthe lib @bshaffer https://github.com/bshaffer) I'll he happy to issue a\nPR. It essentially creates a removeAccessToken() method on the storage\ninterfaces and adds a revoke endpoint to the controllers.\nI suspect due to the new removeAccessToken method this change would\nprobably have to land in a 2.0 release since it is not backwards\ncompatible. Thoughts?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/345#issuecomment-100576288\n.\n. Looks good. Thank you\n. You can find a parent refresh_token (if it exists) by querying for the client_id, user_id, and scope, as these will be unique per refresh token.  This is not super elegant, but it will work, unless there's something I'm missing.\n. This is a good discussion, and one that does call into question the library itself... how should something like this be implemented?  Should we have an idea of \"default grant types allowed\" similar to \"default scopes allowed\", and when clients return null for getRestrictedGrantTypes, we use the default grouping?\n\nI'd be okay with this, if you guys like that implementation.\n. We could add it to the $config array.  It's a little unfortunate, because both TokenController and AuthorizeController would need access to the default grant types.  If they were out of sync, that would cause some unexpected issues\n. I may be misunderstanding this issue, but this is easy to accomplish by calling $server->getAccessTokenData($request). If this function returns null, there is no access token data, or the access token supplied is invalid.  To determine which is which, you can grab the response object:\nphp\nif ($token = $server->getAccessTokenData($request)) {\n    // hey, we have a valid token!\n    // note, scope has NOT been checked on this token, so do that here\n} else {\n    $response = $server->getResponse();\n    if ($response->isClientError() && !$response->getParameter('error')) {\n        // no access token was supplied... this user is not logged in\n    } else { \n        // a bad access token was supplied... reject em\n        die('your token is wrong. We are assuming you are a hacker, leave now.');\n    }\n}\nIf there is something I am missing, please let me know and we can come up with a good solution\n. Yes this is true, but you can completely disregard that response object... you don't have to send it to the browser or use it in proceeding requests.  So, it's not hacky because it's not a global or anything... just ignore it and use a new response object for future calls to the $server\n. I suppose we could refactor the TokenType class to have a method requestHasToken or something along those lines.  Is this what you're hoping for?\n. This can now by done like so:\nphp\nif ($token = $server->getTokenType()->requestHasToken($request)) {\n    if ($token = $server->verifyResourceRequest($request, null, 'myscope')) {\n        // hey, we have a valid token!\n    } else {\n        // a bad access token was supplied... reject em\n        die('your token is wrong. We are assuming you are a hacker, leave now.');\n    }\n} else {\n        // no access token was supplied... this user is not logged in\n}\nI admit, it looks much nicer now :) let me know if you have any other questions\n. This is something you could manage using the SecurityProvider.  I'm not a Silex guru, but I believe you do it using something like this:\n``` php\n$app = new Silex\\Application();\n// create a security provider and lock everything down to a form\n$app->register(new Silex\\Provider\\SecurityServiceProvider(), array(\n    'security.firewalls' => array(\n        'main' => array(\n            'users' => $app->share(function () use ($app) {\n                return $app['security.user_provider'];\n            }),\n            'anonymous' => false,\n            'logout' => false,\n        ),\n    )\n));\n// custom privileges\n$app['security.access_rules'] = array(\n    // require login for just the API\n    array('^/api', 'IS_API_USER'),\n    // this section is for admins only\n    array('^/admin', 'ADMIN_ONLY'),\n);\n```\nYou can read more here\n. closing because this is more of a silex implementation question\n. TODO:\n- Only have the storage classes get/save the id_token if the application is configured for it\n  - I'm not sure there's a clean way to do this...\n  - I don't particularly want to require everyone have an id_token column that they never use...\n- See if we can't find a way to remove urlSafeEncode/Decode from the interface, or make this not required somehow\n  - I see no reason why anyone would need to override it, so it doesn't make a whole lot of sense to make it part of the interface.  There must be a better way\n- Update the MySQL in the docs for the new columns\n- Verify: Does the nonce need to be validated, or just passed back to the client?\n- Test coverage - is there enough? I am not an OpenID expert, there may be some holes\n. Yes, it's way past due for solid documentation. Sorry for the delay. In the meantime, try passing \"use_openid_connect\" => true to the Server in the $config variable, and that should at least get you started.\u00a0\u2014\nBrent Shaffer\nOn Thu, Jul 31, 2014 at 4:10 PM, Vic Vijayakumar notifications@github.com\nwrote:\n\nHey guys, thank you for the great work. Do you have any documentation on how to implement this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/351#issuecomment-50825670\n. Have you tried making a token or authorize request with the \"openid\" scope set?\u2014\nBrent Shaffer\n\nOn Thu, Jul 31, 2014 at 9:19 PM, Vic Vijayakumar notifications@github.com\nwrote:\n\nYeah, that's where I am right now. I can't tell what the next step is unfortunately.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/351#issuecomment-50845204\n. This sounds like a great idea \n. There are two quick ways to do this:\n1. When the user is authorizing a client (AKA the Authorization Code grant type), validate the scope requested by the client with the scope available to the user.  If the user cannot access the requested scope, return the proper error message or remove the scope from the token.\n\nphp\n    /* Authorization Controller */\n    // in this case, $user is just a generic object represented in your application for the logged-in user\n    if (!$server->getScopeUtil()->checkScope($request->getParameter('scope'), $user->getScope())) {\n        die('not enough privileges');\n   }\n1. When the resource is requested, use the ScopeUtil class to verify the user after the token itself, i.e.\nphp\n    /* Resource Controller */\n    if ($server->verifyResourceRequest($request)) {\n        $token = $server->getToken();\n        $user = $server->getStorage('user_credentials')->getUserDetails($token['user_id']);\n        if (!$server->getScopeUtil()->checkScope('required_scope_for_this_api', user['scope'])) {\n            die('not enough privileges');\n        }\n    }\nSo, to answer your question, there is not a lot of support in the library currently for user scopes.  There is validation against user scopes when using the UserCredentials grant type, but this will have no effect when using AuthorizationCode.\n. You don't always want to grant a client (third party) access to all of what a user can do. Scope is meant to LIMIT the functions the user grants to the client. So, grant the client a subset of the user's permission set.\u00a0\nThe scope / user relation is something we have struggled with in using this library. I know @bojanz has some requests as far as implementation here goes. It's complicated, and typically I've left this to the consuming applications, but it's becoming clear there is more we can do in the library itself.\u00a0\nPlease let me know if you have ideas on how we can do this better.\u00a0\n\u2014\nBrent Shaffer\nOn Wed, Mar 19, 2014 at 10:30 AM, Dashamir Hoxha notifications@github.com\nwrote:\n\nI'd like to share my experience with Drupal, even if this is not totally relevant.\nIn Drupal there is the module 'oauth2_server' which handles authentication/authorization, and there is the module 'services' which handles endpoints, resources, etc. Drupal has a granular and strong permission system and the module 'services' takes advantage of that to define which of the users (or groups of users) can access a certain resource. So, the job of 'oauth2_server' is just to authenticate the users (the access_token is used as a means of authentication), and further on the permission system of Drupal is used to decide what the authenticated user can and cannot do.\nThis way it seems that the scopes are not very useful. Well, at least in Drupal, with the server side workflow, I didn't find them very useful. I even find them confusing and misleading and I don't see how they can be used properly. You can avoid using them at all and everything would be fine. Please correct me if I am missing something.\nIn general, I think that the way that scopes are used depends on how they are integrated with the user permissions of the system that is implementing the services and the oauth2.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/353#issuecomment-38073220\n. @tnguyen444 You are correct, that column is for token scope... but this can be equal to or less than the user's scope, and that is no problem.\n\nIn fact, if your OAuth2\\Storage\\UserCredentialsInterface returns an array with scope set for the call to getUserDetails, this scope will be used in the access_token automatically (see the UserCredentials Grant Type)\n. Hey thanks for your contribution! This is an interesting take. Here is the diff\nI had in mind a more granular approach, but this would well for logging.\n. Working on windows is a really important feature. I don't know enough about the two methods to say they are equivalent, however.\u00a0\u2014\nBrent Shaffer\nOn Sat, Mar 22, 2014 at 4:27 PM, Patrick Hindmarsh\nnotifications@github.com wrote:\n\nOut of curiosity, has it been considered to use the openssl_random_pseudo_bytes() function as one of the available methods for generating access tokens and the like?\nIt's functionally pretty similar (if not slightly better, depending on your persuasion) to reading from /dev/urandom with the additional benefit of working on Windows. Perhaps something similar to how the 'password_compat' library generates salt for bcrypt.\nI'm happy to submit a pull, just wanted to check it was worth it.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/357\n. I'm going to close this, as I do not know enough about these functions to determine if this change is beneficial.  We use /dev/urandom on unix, and mt_rand on windows, both of which are good enough for generating an access token.  They do not have to be cryptographically secure, as they expire, so the threat window is minimized (at least, that is the design).\n. Hi Brock, great question!\n\nYou're requesting some \"or\" logic.  This would be done on the side of the ResourceController when the API in question is requested.\nIt would be a great idea if we defined some kind of ACL-logic for the API.  Currently, there is only the one $scope parameter, and they are all required.  So to get around this, you could do something like this:\nphp\n// verify without any scope checking\nif ($server->verifyResourceRequest($request)) {\n    $token = $server->getResourceController()->getToken();\n    $scopeUtil = $server->getScopeUtil();\n    if ($scopeUtil->checkScope('individual', $token['scope']) \n        || $scopeUtil->checkScope('admin', $token['scope']))\n    {\n          // serve up resource\n    } else {\n         // throw \"insufficient scope\" error\n    }\n} else {\n   // throw response error\n   $server->getResponse()->send();\n}\nThis is pretty clunky, so I would love your thoughts on how we could better implement this.  I am sure this is a common use case\n. Another option is to override the ScopeUtil class... This is a little tricky because you don't want the $scope string to be interpreted too differently, as it's used elsewhere in the library... for instance in the error response WWW-Authenticate header.\nSomething like this:\n``` php\nnamespace OAuth2;\nclass MyScope extends Scope\n{\n    public function checkScope($required_scope, $available_scope)\n    {\n        $requred_scopes = explode(' OR ', $required_scope);\n        foreach ($required_scopes as $scope) {\n            if (parent::checkScope($scope, $available_scope)) {\n                return true;\n            }\n        }\n    return false;\n}\n\n}\n```\nThen you could make the call like so:\n``` php\n// add custom scope class\n$myScope = new OAuth2\\MyScope($server->getStorage('scope'));\n$server->setScopeUtil($myScope); \n// verify the request\nif ($server->verifyResourceRequest($request, null, 'individual OR admin')) {\n    // serve the request\n} else {\n    // throw response error\n    $server->getResponse()->send();\n}\n```\nThis is a lot cleaner, but you would want to ensure your scope class is only set for the ResourceController, otherwise this may have some unexpected issues in other controllers\n. You can create a second instance of the PDO storage class and set this just for the client storage. Ie:\n$server = new OAuth2\\Server($pdo1, $config);\n$server->setStorage($pdo2, \"client_credentials\");\n\u2014\nBrent Shaffer\nOn Thu, Mar 27, 2014 at 1:50 AM, pjebs notifications@github.com wrote:\n\nRight now in the bootstrap file, you set the database name:\n$dsn      = 'mysql:dbname=my_oauth2_db;host=localhost';\nYou also have to already have these tables set:\nCREATE TABLE oauth_clients (client_id VARCHAR(80) NOT NULL, client_secret VARCHAR(80) NOT NULL, redirect_uri VARCHAR(2000) NOT NULL, grant_types VARCHAR(80), scope VARCHAR(100), user_id VARCHAR(80), CONSTRAINT client_id_pk PRIMARY KEY (client_id));\nCREATE TABLE oauth_access_tokens (access_token VARCHAR(40) NOT NULL, client_id VARCHAR(80) NOT NULL, user_id VARCHAR(255), expires TIMESTAMP NOT NULL, scope VARCHAR(2000), CONSTRAINT access_token_pk PRIMARY KEY (access_token));\nCREATE TABLE oauth_authorization_codes (authorization_code VARCHAR(40) NOT NULL, client_id VARCHAR(80) NOT NULL, user_id VARCHAR(255), redirect_uri VARCHAR(2000), expires TIMESTAMP NOT NULL, scope VARCHAR(2000), CONSTRAINT auth_code_pk PRIMARY KEY (authorization_code));\nCREATE TABLE oauth_refresh_tokens (refresh_token VARCHAR(40) NOT NULL, client_id VARCHAR(80) NOT NULL, user_id VARCHAR(255), expires TIMESTAMP NOT NULL, scope VARCHAR(2000), CONSTRAINT refresh_token_pk PRIMARY KEY (refresh_token));\nCREATE TABLE oauth_users (username VARCHAR(255) NOT NULL, password VARCHAR(2000), first_name VARCHAR(255), last_name VARCHAR(255), CONSTRAINT username_pk PRIMARY KEY (username));\nCREATE TABLE oauth_scopes (scope TEXT, is_default BOOLEAN);\nCREATE TABLE oauth_jwt (client_id VARCHAR(80) NOT NULL, subject VARCHAR(80), public_key VARCHAR(2000), CONSTRAINT client_id_pk PRIMARY KEY (client_id));\nHow can I have the table \"oauth_clients\" in a different database?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/360\n. Why would this be any different?\u2014\nBrent Shaffer\n\nOn Thu, Mar 27, 2014 at 4:01 AM, pjebs notifications@github.com wrote:\n\nEven if I'm using Authorisation Code grant type?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/360#issuecomment-38785355\n. Try setting your secondary storage for both \"client_credentials\" AND \"client\". In other words, call setStorage twice\u00a0\u2014\nBrent Shaffer\n\nOn Fri, Mar 28, 2014 at 8:34 PM, pjebs notifications@github.com wrote:\n\nThen when I change \"client_credentials\" to \"client\", it appears to work (i.e. passes through validateAuthorizeRequest and even provides a Code).\nBut the moment you try to get a Token, it again says it can't find the id_server.oauth_clients table in the database that stores all the other tables such as access tokens etc.\nCould this be an error in the library?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/360#issuecomment-38984545\n. Not a bug exactly... \u00a0\"client_credentials\" inherits from \u00a0\"client\", so even though they are two different interfaces, you might expect them both to be set when you set one or the other. But it is counter intuitive. It's part of the problem with using all the \"magic\" in the server class. I'm not sure there is a better way to do it that wouldn't cause even more confusion in other cases.\u00a0\u2014\nBrent Shaffer\n\nOn Sat, Mar 29, 2014 at 6:20 AM, pjebs notifications@github.com wrote:\n\nThanks Brent. 100% fixed.\nWhy did that cause the issue? Was it something wrong with the library?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/360#issuecomment-38994014\n. The documentation represents the v1.3 version of the library. \u00a0You've installed the development branch. Either switch to the stable tag, or add the id_token column to your AuthorizationCode data store\u00a0\u2014\nBrent Shaffer\n\nOn Fri, Mar 28, 2014 at 10:42 AM, bashekking notifications@github.com\nwrote:\n\nwhen I follow the install procedure and open the authorize.php page(/authorize.php?response_type=code&client_id=testclient&state=xyz) i get the following error\nFatal error: Uncaught exception 'PDOException' with message 'SQLSTATE[42S22]: Column not found: 1054 Unknown column 'id_token' in 'field list'' in /home/bas/development/codefined.com/oauth/www/oauth2-server-php/src/OAuth2/Storage/Pdo.php:181 Stack trace: #0 /home/bas/development/codefined.com/oauth/www/oauth2-server-php/src/OAuth2/Storage/Pdo.php(181): PDOStatement->execute(Array) #1 /home/bas/development/codefined.com/oauth/www/oauth2-server-php/src/OAuth2/ResponseType/AuthorizationCode.php(60): OAuth2\\Storage\\Pdo->setAuthorizationCode('11131b5f009e09d...', 'testclient', NULL, NULL, 1396023903, NULL) #2 /home/bas/development/codefined.com/oauth/www/oauth2-server-php/src/OAuth2/ResponseType/AuthorizationCode.php(32): OAuth2\\ResponseType\\AuthorizationCode->createAuthorizationCode('testclient', NULL, NULL, NULL) #3 /home/bas/development/codefined.com/oauth/www/oauth2-server-php/src/OAuth2/Controller/AuthorizeController.php(94): OAuth2\\ResponseType\\AuthorizationCode->getAuthorizeRespons\ne(Array, NULL) #4 /home/bas/development in /home/bas/development/codefined.com/oauth/www/oauth2-server-php/src/OAuth2/Storage/Pdo.php on line 181\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/361\n. I'm not sure what you are asking with the first question. As for the second question, it's for convenience.\u00a0\u2014\nBrent Shaffer\n\nOn Sat, Mar 29, 2014 at 3:53 PM, Jaka Jan\u010dar notifications@github.com\nwrote:\n\nE.g.\n- why does the implementer need to provide your default handling?\n- why does the implementer need to provide query(), when you already have getAllQueryParameters()?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/362\n. Server refers to the $_SERVER php global\u2014\nBrent Shaffer\n\nOn Sat, Mar 29, 2014 at 5:12 PM, Jaka Jan\u010dar notifications@github.com\nwrote:\n\nBy default handling I mean the , $default = null parameter.\nMy point is: every extra method/parameter you add to the interface for your convenience is an inconvenience to the implementer of the interface.\nserver() is practically unimplementable. What does it even mean?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/362#issuecomment-39012224\n. Feel free to submit a pull request for something you believe needs changing.  However, this issue appears to be more an opportunity for you to complain than anything else.  I do not agree that adding a default parameter makes the method any harder to implement. \n\nPlease reopen if you have a more specific request, or better yet submit a pull request yourself.  Thank you.\n. Yep, exactly. I'm doing this in my own implementation, but I've had to override the JWT class to do s\u2014\nBrent Shaffer\nOn Wed, May 21, 2014 at 1:09 PM, Bojan Zivanovic notifications@github.com\nwrote:\n\nAgreed. If we want to support key rollover on the app side for OpenID Connect (something that Google does for its implementation), we need a way to stick the key id in that header.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/363#issuecomment-43800838\n. I think we'd want something more robust, as there are many parameters available, not just \"kid\"\n. It looks good but we definitely need a test for this\u2014\nBrent Shaffer\n\nOn Thu, Apr 3, 2014 at 9:22 AM, Pierre-Yves Jamon\nnotifications@github.com wrote:\n\nMy proposal for #166\nYou can merge this Pull Request by running:\n  git pull https://github.com/Pym/oauth2-server-php develop\nOr you can view, comment on it, or merge it online at:\n  https://github.com/bshaffer/oauth2-server-php/pull/365\n-- Commit Summary --\n- Allow server access_lifetime to be setted to false for no expiring token check\n  -- File Changes --\n  M src/OAuth2/Controller/ResourceController.php (2)\n  M src/OAuth2/Server.php (2)\n  -- Patch Links --\n  https://github.com/bshaffer/oauth2-server-php/pull/365.patch\n  https://github.com/bshaffer/oauth2-server-php/pull/365.diff\n\nReply to this email directly or view it on GitHub:\n  https://github.com/bshaffer/oauth2-server-php/pull/365\n. see https://travis-ci.org/bshaffer/oauth2-server-php/jobs/22195962 - this is causing our build to fail\n. non-expiring access tokens pose a pretty real security threat, as this goes against pretty much everything OAuth2 stands for.  However, I don't see a real issue in putting this code in there... people can shoot themselves in the foot if they want to...\n. Access tokens expire so that if an attacker obtains one, their window of attack only lasts for a short period of time. It's a fundamental principle of oauth\u00a0\u2014\nBrent Shaffer\n\nOn Fri, Apr 4, 2014 at 1:39 AM, Pierre-Yves Jamon\nnotifications@github.com wrote:\n\nI will fix that and write a test for it.\nBut I don't really see a security threat here. Can you develop?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/365#issuecomment-39539097\n. Closing - we do not want to support non-expiring access tokens\n. The user_id column is only for the client_credentials grant type (i.e. OAuth2\\GrantType\\ClientCredentials.php, so if you're not using this, it's save to delete.\n\nHowever, if the column doesn't exist, you will receive an error in Pdo.php (if you're using this Storage class) when you try to save a client in setClientDetails (see Pdo.php#L101)\n. It's used to associate the client with the user who created it.\nOn Wed, Sep 16, 2015 at 5:31 PM pjebs notifications@github.com wrote:\n\nI am still wondering what the user_id column is for in client_credentials\ngrant type.\nIf it is used in the Resource Controller Endpoint, you getAccessTokenData\nstill gives you the client_id.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/366#issuecomment-140933199\n.\n. The user isn't irrelevant, client credentials still have a user context.\nThe client IS the user. If you don't want a user context at all, JwT bearer\nis more appropriate.\nOn Thu, Sep 17, 2015 at 8:44 AM pjebs notifications@github.com wrote:\nFor authorisation code grant type, I understand that user_id in token\ntable helps associate the token to the client and user.\nFor client credentials, the user is irrelevant so I still don't understand\nwhy it's needed and why it's in client table.\nGetAccessTokenData() can pull the client_id from the token anyway.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/366#issuecomment-141127614\n.\n. There is no maximum length.  This library defaults to 40, but nothing is set in stone.  This quote is from facebook's documentation:\nExpect that the size of all types of access tokens will change over time as Facebook makes changes to what is stored in them and how they are encoded. You can expect that they will grow and shrink over time. Please use a variable length data type without a specific maximum size to store access tokens.\n\nThis seems a little extreme to me... certainly you could add at least some bounds on the size of the token, but either way the rule of thumb stays true.\nIn one case, when using JWT tokens, data for the token is base64 encoded in the token itself so the length can be quite large (1000+ characters). This is a good case where maximum length does not apply.\n. Looks like a bug. Can you be more descriptive about how or why it fails?\u2014\nBrent Shaffer\nOn Thu, Apr 10, 2014 at 5:31 PM, bensinclair notifications@github.com\nwrote:\n\nI upgraded to version 1.3 today in case this was a bug that had been fixed but I'm having issues when an ampersand (&) is in the redirect URL.\nFor example, this would work: \nhttp://localhost/test/?test=true \nBut this would fail:\nhttp://localhost/test/?test=true&another_test=true\nIs that a bug or is that how it should be?\nMy code looks like this:\nphp\n$request = OAuth2\\Request::createFromGlobals();\n$response = new OAuth2\\Response();\n$server->validateAuthorizeRequest($request, $response);\n// Returned parameters\n$paramters = $response->getParameters();\n// Check redirect URI\nif (isset($paramters['error']) && $paramters['error'] == 'redirect_uri_mismatch')\n  oauth_die_redirect($_GET['redirect_uri'], 'invalid_redirect_uri', 'redirect_uri does not belong to the registered application');\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/370\n. I believe you need to set the server config parameter require_exact_redirect_uri to false to fix this issue.\n\nrequire_exact_redirect_uri=false allows you to add query string parameters onto the client's registered redirect URl.  If this is what you're trying to do, then this parameter must be set in order to do it.  Otherwise, the redirect_uri is considered a mismatch.\n. No, that sounds right. The problem is that I can't duplicate the issue.\u00a0\u2014\nBrent Shaffer\nOn Fri, Apr 25, 2014 at 5:49 PM, bensinclair notifications@github.com\nwrote:\n\nThanks Brent,\nThe thing is I have used http://localhost/test/?test=true&another_test=true as the client's registered redirect URI? That would mean it is matching wouldn't it?\nAm not setting the client's registered redirect URI to http://localhost/test/ and then trying to add the query string when making my calls.\nHave I missed something?\nBen\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/370#issuecomment-41449801\n. require_exact_redirect_uri is set in the OAuth2\\Server object or in the AuthorizeController object, if you're creating the controller manually.\n. @ssanders query string is allowed, but fragment is not.  Per the spec:\nThe redirection endpoint URI MUST be an absolute URI as defined by\n   [RFC3986] Section 4.3.  The endpoint URI MAY include an\n   \"application/x-www-form-urlencoded\" formatted (per Appendix B) query\n   component ([RFC3986] Section 3.4), which MUST be retained when adding\n   additional query parameters.  The endpoint URI MUST NOT include a\n   fragment component.\n. @ssanders yes, the mysql query example you have there is very bad.  Other than creating a large security vulnerability, it is not the proper way to achieve what you are trying to do.\n\nPass require_exact_redirect_uri in as part of the second argument for your Server class:\nphp\n$server = new OAuth2\\Server($storage, array('require_exact_redirect_uri' => true));\nOr, if you are using the less popular method of creating your Controller class individually (without the use of the OAuth2\\Server class), you can pass the variable in that way:\nphp\n$controller = new OAuth2\\Controller\\AuthorizeController($clientStorage, $responseTypes, array('require_exact_redirect_uri' => true));\n. It can. This is why the controllers are separated out into \"Resource\", \"Authorize\", and \"Token\".  All of these can be found at different endpoints and use different storages.\nIf I'm understanding you correctly, there is no technical limitation in having this setup.  You'll just want to make sure your Storage objects access some shared resource (MySQL, Mongo, NFS, or even call another API ).  I've done this as well... for instance, Clients are stored in api.endpoint1.com, and other endpoints call api.endpoint1.com/clients to retrieve the client store.\nIt's quite possible I'm not fully understanding your question, however, so please clarify if this is not the answer you were looking for.\n. The ResourceController (I am guessing it's using the Redis Storage as well?) will ask Redis for the token information.  Once it validates the token exists and hasn't expired, it will check the scope. Now this is (I believe) where you're getting confused.  When you call verifyResourceRequest, you MUST pass in the scope for each resource endpoint for that resource.  For instance, when they requiest api.server.com/todolist, if you have the scope todolist, you'll want to call\nphp\n$result = $server->verifyResourceRequest($request, $response, 'todolist');\nDoes that clarify things?\n. please reopen if you have additional questions\n. Thank you for your pull request, but before I can merge it I've identified a few problems.  Also, please run the tests to ensure the changes do not break existing tests.\nAs you can see from the failing tests, the function hash_pbkdf2 does not exist in php 5.4 and below. This library is supported for php 5.3.8+, so until this PR is updated to run in those versions as well, I cannot merge it.\nThanks again for submitting this. I would love to see the changes I've mentioned implemented, and then I would be happy to merge!\n. I've avoided making this change because I did not want to pull in external libraries for something I consider not necessary (most applications will use UserInterface for their user stores... I hope... rather than my incredibly rudimentary Pdo storage)\nHowever you're not the first to ask for this (see https://github.com/bshaffer/oauth2-server-php/pull/282) so, perhaps it's time I give in.\nWill you review the linked PR and see which implementation you prefer, or if we can somehow use ideas from both?\n. Hey everyone, I finally found time to weigh in here.\nI would love to do what @ezimuel suggests and create a new class in the OAuth2\\Encryption namespace, use the password_hash for PHP 5.5 and crypt for PHP 5.3-5.4.  Then allow this class to be passed into our Storage implementations (Similar to how the OAuth2\\Encryption\\Jwt class is used) and call this for all the hashing.  \nThis is great dialog and thank you everyone for taking part! I've sure learned a lot.  Or at least enough to know I should stay away from making any significant cryptography decisions.\n@ezimuel, @xaionaro, @phindmarsh please let me know if any of you are interested in the fix. If not,  I'll plan on coding it up and requesting your review.\n. @nasaorc as of the develop branch, you can manually set the refresh_token storage to null:\nphp\n$server = new OAuth2\\Server($pdo);\n$server->addStorage(null, 'refresh_token');\nThis will remove the Refresh Token storage, and so it will skip adding this to the token.\nIf you are not on the develop branch (as should be the case), you will need to change how you create your server class to instantiate each storage individually, rather than passing it in the constructor, like so:\nphp\n$storage = array(\n    'client' => $pdo,\n    'client_credentials' => $pdo,\n    'access_token' => $pdo,\n    'authorization_code' => $pdo,\n);\n$server = new OAuth2\\Server($storage);\nFeel free to reopen this if you have additional questions.\n. This is great! Although I would love a test for this in the test/OAuth2/ServerTest/php class\n. looks great! Thank you very much!\n. fixed in https://github.com/bshaffer/oauth2-server-php-docs/commit/4f9b993e14a587fba4683da522486ebf4c1d1414\n. Thank you for submitting this!  A few things:\n- I do not see any changes to require-dev, although I don't think it should be required, only suggested.  Running composer.phar install is not currently a part of the install process.\n- See Suggestion in above to improve test readability\n- I would recommend rebasing and squashing these so the commit history is cleaner\n- Finally, I would rather use a solution that allows the header to be case-insensitive (see HTTP 1.1 Spec)\n. Looks super wonderful.  Thank you so much for your work on this!\n. the UserCredentials grant type requires you to have a valid set of ClientCredentials as well.  Notice in the sample curl request, where the command includes -u TestClient:TestSecret:\n$ curl -u TestClient:TestSecret https://api.mysite.com/token -d 'grant_type=password&username=bshaffer&password=brent123'\nThose credentials need to be included, and also added to your storage somewhere.  try including that in your request, and change the above to something like this:\n``` php\n    //...\n    // create some users in memory\n    $users = array('bshaffer' => array('password' => 'brent123', 'first_name' => 'Brent', 'last_name' => 'Shaffer'));\n// HERE IS THE NEW PART\n$clients = array('TestClient' => array('client_secret' => 'TestSecret'));\n\n// create a storage object\n// ALSO NEW: pass \"client_credentials\" in with the Memory object\n\n$storage = new OAuth2\\Storage\\Memory(array('user_credentials' => $users, 'client_credentials' => $clients));\n\n```\nAs for the second error you're having, it's because you never added the ClientCredentials grant type object, which is required in order for you to use grant_type=client_credentials\nPlease reopen if you have any other questions.\n. > Oh I was under the impression that you could have a user_credential grantType without having a client_credential grantType, as discussed here: #341 \n@arianf you don't need the ClientCredentials grant type to use the UserCredentials grant type.  You DO, however, need a set of Client Credentials in your storage object.  Otherwise, there is no way to validate the client making the request.  Public clients are allowed, but they still require an instance of OAuth2\\Storage\\ClientCredentialsInterface in order to be configured\n\nAs for the second error you're having, it's because you never added the ClientCredentials grant type object, which is required in order for you to use grant_type=client_credentials\n\nEmphasis on second error... I was referring to when you set grant_type=client_credentials.\n. @swos- I would love you to submit a PR to said documentation.  Although, the link you supplied does have the following line:\n\nIf your client is public (by default, this is true when no secret is associated with the client), you can omit the client_secret value in the request\n\nBut if you think something else would be more clear, I'd be happy to add it! \n. @kentpachi you are overwriting your first $storage declaration with your second $storage declaration, therefore the client credentials you are creating are never passed to the server.\nremove your second $storage, and use the Memory object which has both $client_credentials and $user_credentials, and you should be good to go.\n. @justingreerbbi thanks for pointing this out. This line of code will also fix this issue (if you're using Apache)\nA similar line exists here, in this library, but perhaps if you're still experiencing the issue it's possible it is not being executed.\n@geeknz I would suggest opening a new ticket if you're still experiencing issues, detailing what is happening in your code. The piece you have posted looks great.\n. thank you!\n. Are you storing pass1 in your PDO database in plaintext?  This password should be hashed (see the setUser method)\n. The user ID is not typically returned as part of the access token response. If you'd like this to happen, you have a few options\n1. \u00a0Add a /profile API (or something along these lines) which you can call with the access token to retrieve a user ID\n2. Use OpenID Connect (the server parameter is \"use_openid_connect\" and request the scope \"openid\" and you will have a field returned with the access code \"id_token\", which will contain a user ID once base64 decoded\u00a0\n3. Override the ReponseType class and just stick a user ID in there for your own implementation\n4. Use CryptoTokens, which include the userID in the token payload.\u00a0\nThese are in order of precedence.\u00a0\nCan you tell me what oauth2 API you've used that makes you thnk you should get a user id in the token response?\n\u2014\nBrent Shaffer\nOn Fri, May 9, 2014 at 8:19 AM, bittlestudio notifications@github.com\nwrote:\n\nI need to get the userid when logging in, and I just can't find the way to do it.\nI'm sending this info:\n{\n            \"username\":USERNAME,\n            \"password\": PASSWORD,\n            \"grant_type\" : \"password\",\n      \"client_id\" : CLIENT\n}\nand I get the following response:\n{\naccess_token: \"23f32b51076912b193b648c0b54ddb518546fa38\"\nexpires_in: 3600\ntoken_type: \"Bearer\"\nscope: null\nrefresh_token: \"233086f639d78b77896b2f2a583072809c537910\"\n}\nI just can't get the user info.\nOn the other hand, it would be nice as well to be able to, in random calls, return information related to the user making the call, basing on the bearer token without needing to have an ID posted by GET or POST.\ni.e:\nwww.myapp.com/api/getcollections ---cool\nwww.myapp.com/api/getcollections/id ---not cool\nThank you!!\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/381\n. You got it. Open ID connect is supported in this library, and that is the second best route for you. Only second-best because it's more complicated, but it's actually a more precise solution. So, if you're interested that is another route to look into.\u2014\nBrent Shaffer\n\nOn Fri, May 9, 2014 at 8:58 AM, bittlestudio notifications@github.com\nwrote:\n\nNo, I'm not saying the user id should be returned in the token response. This is my first experience with oAuth2 and I just thought it made sense.\nMy problem here is that I have users logging in to retrieve personal information, and I don't find the way to do it since even though they authenticate, I can't identify their information.\nSo for option number 1, which is most likely what I need to use, I guess I would need to get the bearer token out of the request headers and use it to get the user id, right?\nThank you!\nBest,\nMartin\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/381#issuecomment-42675412\n. > Does that mean that I've got to extract the token out of the string?\n\nI don't know what this means.  The token comes back from an HTTP POST request to the /token endpoint in JSON format.  if \"extract the token out of the string\" you mean run a json decode function, then yes.\n. This library is not apigility. Can you link to the code in question or provide a gist? \u00a0If you have access to the oauth2 \u00a0$server object, you can call $server->getResponse() and pull the token from there. But again, I can't really advise because I don't know what code you're referring to.\u00a0\u2014\nBrent Shaffer\nOn Fri, May 9, 2014 at 11:24 AM, bittlestudio notifications@github.com\nwrote:\n\nWhat I meant is that, within the code of my apigility method (the code that triggers after the call), the only way I found to get the token is getting the HTTP Request headers with the php funcion apache_request_headers(). Then I would check for the Authorization key within the returned array, and then get the access token using substr() on the following string: \"Bearer whatever_the_token_is\".\nI'm pretty sure this is not the preferred way, so what's that about the /token endpoint? How do I access that JSON?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/381#issuecomment-42691499\n. I would ask on the apigility repository or DL how to access the OAuth2\\Server object from this class. Once you have that object, I can help guide you from there. The code you have provided is unfortunately not very useful to me, and not enough information for me to answer your question. \n. Thank you for catching this!! Although, I feel like Auth Time should be an optional parameter to the server / authorization controller function handleAuthorizeRequest \n. I've been looking at this myself, and came to the same conclusion. This may be tricky, as it would be nice to have a central place for the conversion to take place, so existing methods expecting an integer / string are not busted.\u00a0\u2014\nBrent Shaffer\n\nOn Mon, May 12, 2014 at 9:47 AM, R\u00e9mi Lanvin notifications@github.com\nwrote:\n\nYes I suppose that would make sense to pass it to handleAuthorizeRequest, the same way you pass the user id. But the modifications involved to do it are beyond my understanding of the lib. It seems the parameter will have to be passed to many different methods in many different classes, and some interfaces will have to be updated as well? I'm a bit lost in the execution flow to be honest, so if you're expecting me to do it I'll need some guidance.\nWhat if I change the \"user_id\" parameter so that it accepts an assoc array as well? If you can handleAuthorizeRequest with a string/int, it'll work as now, but if it's an assoc array, it'll fetch \"user_id\" and \"auth_time\" from it. This way the lib's API doesn't have to change (I think).\nExample:\nphp\n$server->handleAuthorizeRequest($request, $response, $is_authorized, $user_id); // will work as before for servers without OpenID Connect\n$server->handleAuthorizeRequest($request, $response, $is_authorized, array('user_id' => $user_id, 'auth_time' => $session_start_time)); // with additional auth time when using OpenID Connect\nWhat do you think?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/382#issuecomment-42849337\n. closing in favor of the above PR\n. I agree, they should be removed\u2014\nBrent Shaffer\n\nOn Tue, May 13, 2014 at 12:44 AM, Julien Goux notifications@github.com\nwrote:\n\nHello,\nI want to implement the User credentials grant with your library (which is excellent :D)\nI have an issue with the constraints set on the oauth_clients table.\nIn the doc, you give this query to create the oauth_clients table : \nsql\nCREATE TABLE oauth_clients (client_id VARCHAR(80) NOT NULL, client_secret VARCHAR(80) NOT NULL, redirect_uri VARCHAR(2000) NOT NULL, grant_types VARCHAR(80), scope VARCHAR(100), user_id VARCHAR(80), CONSTRAINT client_id_pk PRIMARY KEY (client_id));\nAs my client is public, I don't need to associate a client_secret to it, and as I want to use the User credentials grant, I don't need to set a redirect_uri either.\nSo maybe client_secret and redirect_uri don't need the NOT NULL constraint by default.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/383\n. closed in favor of https://github.com/bshaffer/oauth2-server-php-docs/issues/37\n. I am not sure what you are doing here, but it is not correct.  Your $users and your $clients are two very different things.\n\nI've looked over the documentation, and it is up-to-date.\n. One easier way to do this would just be to do the error checking after the call to parent::handleAuthorizeRequest, and check the response to see if it's an error, and the rest could follow.\n. No, that's not what I mean. It's not perfect, but, but it's certainly less hackish than the current PR .  I was thinking something more like this:\n``` php\npublic function handleAuthorizeRequest(RequestInterface $request, ResponseInterface $response, $is_authorized, $user_id = null)\n{\n    // the user declined access to the client's application\n    if ($is_authorized === false) {\n        if (!$this->validateAuthorizeRequest($request, $response)) {\n            return;\n        }\n    // If no redirect_uri is passed in the request, use client's registered one\n    if (empty($this->redirect_uri)) {\n        $clientData              = $this->clientStorage->getClientDetails($this->getClientId());\n        $registered_redirect_uri = $clientData['redirect_uri'];\n    }\n\n    $prompt = $request->query('prompt', 'consent');\n    if ($prompt == 'none') {\n        if (is_null($user_id)) {\n            $error = 'login_required';\n            $error_message = 'The user must log in';\n        } else {\n            $error = 'interaction_required';\n            $error_message = 'The user must grant access to your application';\n        }\n    } else {\n        $error = 'consent_required';\n        $error_message = 'The user denied access to your application';\n    }\n\n    $redirect_uri = $this->redirect_uri ?: $registered_redirect_uri;\n    $response->setRedirect($this->config['redirect_status_code'], $redirect_uri, $this->state, $error, error_message);\n\n    return;\n}\n\nreturn parent::handleAuthorizeRequest($request, $response, $is_authorized, $user_id);\n\n}\n```\nThis way, although the code is still duplicated, at least it does not ever get called twice\n. It's fine... the nullable can be for users not logged in.  It's also just for the case where oauth doesn't need to know the user_id, but I don't think that applies for OpenID \n. We could also add \nphp\nprotected function getNotAuthorizedResponse(Request $request, Response $response, $user_id = null)\nthat gets called in the parent controller, so that we don't need to touch the handleAuthorizeResponse method at all\n. Yes, there's been intermittent errors with travis for a while.  I restarted it, so it should be passing soon.\n. @bojanz As I have not heard back from you, I am assuming you've either been very busy, or given up on me and decided to use your own fork.  Do you still want this merged?\n. closing in favor of #412 \n. No problem, as long as you're ok with your current PR not being included\n. Yes, the main reason is that because http foundation used public properties, an interface cannot be used to customize it.  However, you should be able to work around this problem using the oauth2-server-httpfoundation-bridge library. Have you tried this?\n. As we have another 100 years before unix timestamps exceed 32-bit integers, do you agree it's best to just comment that line out?\n. no, you are right, it should be returned with the response and NOT encrypted\n. The code you have specified would not throw this exception.  There must be something else going on here.\nFeel free to open another issue if you're still running into this problem.\n. This is great! Thank you so much for contributing this!  A few things that will need fixing before we merge:\n- rename Dynamodb to DynamoDB, as this is the more standard casing.\n- add https://github.com/aws/aws-sdk-php to the composer.json file under suggest, i.e.:\njson\n{\n    # ...\n    \"suggest\": {\n        \"predis/predis\": \"Required to use the Redis storage engine\",\n        \"thobbs/phpcassa\": \"Required to use the Cassandra storage engine\",\n        \"aws/aws-sdk-php\": \"Required to use the DynamoDB storage engine\"\n    }\n}\n- Add a comment to the top of the Storage file as to how to install the dependeny\n``` php\n/\n * DynamoDB storage for all storage types\n \n * To use, install \"aws/aws-php-sdk\" via composer\n * \n *  composer require aws/aws-php-sdk:dev-master\n * \n\n * Once this is done, instantiate the DynamoDB client\n * \n *  $storage = new OAuth2\\Storage\\Dynamodb(array(\"key\" => \"YOURKEY\", \"secret\" => \"YOURSECRET\", \"region\" => \"YOURREGION\"));\n * \n\n * @see test/lib/OAuth2/Storage/Bootstrap::getDynamoDBStorage\n /\n``\n- Finally, we need to add this to our storage test suite (see [BaseTest](https://github.com/bshaffer/oauth2-server-php/blob/develop/test/lib/OAuth2/Storage/BaseTest.php)), so that the standard storage test suite runs against it. This will require you to add agetDynamoDBStoragefunction to the [OAuth2\\Storage\\Bootstrap`](https://github.com/bshaffer/oauth2-server-php/blob/develop/test/lib/OAuth2/Storage/Bootstrap.php) file\n. Since this is not a local test, this is a bit tricky. I would suggest making the credentials environment parameters, and in order to run them you need to set the AWS credentials yourself.\u00a0\nI can add this part, as it's a little non-standard\n\u2014\nBrent Shaffer\nOn Thu, Jun 12, 2014 at 11:10 AM, fauguste notifications@github.com\nwrote:\n\nFinally, we need to add this to our storage test suite (see BaseTest), so that the standard storage test suite runs against it. This will require you to add a getDynamoDBStorage function to the OAuth2\\Storage\\Bootstrap file\nWhere can we store secret ? Dynamodb need an AWS account.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/399#issuecomment-45920140\n. I can add the credentials using \"secure environment variables\" (http://docs.travis-ci.com/user/build-configuration/#Environment-variables). So don't worry about this for now.\n. If you can, just run the tests locally using your own credentials and verify it passes, and I'll set up the automated tests once I merge the PR.\n. Well, the PublicKey interface should be able to support a GLOBAL public/private key pair, which is what this test is checking.  There is also the need for a client-specific public/private key pair, in which what you are doing is preferred.  When $client_id=null, then the global key should be returned. So you could handle that by making the global pair client_id=0, or in a different table.. however you'd like.\n. Yes, I agree.  You can modify the test to explode both the arrays and then order them, and then compare them. \n. php\n$expected = explode(' ', $expected);\n$actual = explode(' ', $actual);\nsort($expected);\nsort($actual);\n$this->assertEquals($expected, $actual);\n. Sorry, I intended to merge after the creation of the 1.4 tag.  Thank you so much for your hard work on this!\n. Hey there. Great questions. The way to do this would be to implement the \"getClientScope\" method in your storage object (see ClientInterface).\u00a0\n\nSo if you're using MySQL PDO, this is done via the \"scope\" column of your \"oauth_client\" table.\u00a0\n\u2014\nBrent Shaffer\nOn Thu, Jun 19, 2014 at 7:40 AM, silvios notifications@github.com wrote:\n\nI am very new to all of this, but I am looking to implement scope for using with the client_credential grant type and can not seem to figure this out.\nI can create a client secret and a client id and send it in to get a token which i can use to call resources. When doing this exact step if i add a scope parameter i can request tokens with certain scopes.\ncurl -v \"http://localhost/api/token\" -d \"grant_type=client_credentials&client_id=api_user&client_secret=SaceCecuSAcusT27uP4AvucEdramUW4E&scope=\nx.readonly\"\nThis is where I am a little confused. When I create a client secret/client id, should I need to define the allowed scope if I want to limit the pair to a certain scope? I do not see a way to attach/define only x.readonly to that key pair. Is this something maybe I am supposed to implement some how? Or have I missed something?\nWhat happens if i only want to give a certain application access to part of the api, currently it seems that in the application thats where you define the scope I want to access but that means the key pair has access to everything from the start.\nThanks any help would really be appreciated.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/402\n. That is the right place. Are you using tag 1.4? Update to the latest stable version (the documentation is still at 1.3, so it's a little behind)\u2014\nBrent Shaffer\n\nOn Thu, Jun 19, 2014 at 7:53 AM, silvios notifications@github.com wrote:\n\nHey thank you so much for your quick reply!\nIn the class\nOAuth2\\Storage\\ClientInterface\nI do not see the getClientScope method am i perhaps looking in the wrong place?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/402#issuecomment-46570481\n. Yes, unfortunately that check is an AND and not an OR.  See #359 for suggestions on how to handle this.\n\nI agree the library needs to be modified to support this.\n. I feel like malformed_token is actually more of an Exception than an error, as this is a problem with the developer's implementation.  What is your reasoning behind this change?\n. This is really great, and I appreciate the work.  I have a question and a few requested changes, and then this will be ready to merge\n. Look at my inline comments. There are some white space issues and capitalization issues\n. @sumeko do you have an update on this?\n. Closing this due to inactivity\n. Out of the box, the server does not provide any scopes, so \"basic\" does not exist as a valid scope. Try to add \"basic\" to your database in the scope table and try again.\u00a0\u2014\nBrent Shaffer\nOn Tue, Jun 24, 2014 at 3:00 PM, tom22222 notifications@github.com\nwrote:\n\nSo I'm new to all this Oauth stuff and am undoubtedly doing something wrong.\nI don't even know if I'm in the right place to ask this question, please let me know if I should be asking elsewhere.\nSo, anyway, I followed the step by step walkthrough:\nhttp://bshaffer.github.io/oauth2-server-php-docs/cookbook/\nall the tests went through ok.\nThen I tried to test my server using Google Playground.  I filled in all the details mentioned here:\nhttp://bshaffer.github.io/oauth2-server-php-docs/cookbook/google-playground/\nI also updated the redirect path in the db:\nupdate oauth_clients\nset redirect_uri = 'https://developers.google.com/oauthplayground'\nwhere client_id = 'testclient'\n;\n(not sure if that was the right thing to do)\nI type in all of the details into the settings box, type the word \"basic\" in the scope secton.  I'm then expecting to be taken to my authorize.php so I can auth the request (step 8 in the example) but instead the playground displays this:\nRequest:\nHTTP/1.1 302 Found\nLocation: http://mydomain.com/auth/authorize.php?scope=basic&redirect_uri=https%3A%2F%2Fdevelopers.google.com%2Foauthplayground&response_type=code&client_id=testclient&access_type=offline\nResponse:\nGET /oauthplayground/?error=invalid_scope&error_description=An+unsupported+scope+was+requested HTTP/1.1\nHost: developers.google.com\nIf someone could point me in the right direction I'd be grateful.\nThanks!\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/406\n. This is the perfect place to ask! That way, google can index it for others to find if they have similar problems!\u2014\nBrent Shaffer\n\nOn Tue, Jun 24, 2014 at 3:22 PM, tom22222 notifications@github.com\nwrote:\n\nExcellent - it works!  Thanks very much for your help.  Is this the right place to be asking these types of questions as I'm bound to need to ask more as time goes on.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/406#issuecomment-47032790\n. 1. Good question.  This step is actually done when the client is registered.  How it works in most implementations is you create a JWT-Client... i.e. when you set the client up, you identify it as one that will use the JWT grant type.  When this is done, the Client Public Key is saved on the server side (using the oauth_jwt table).  This can be generated by the server, or supplied by the client. \n2. You'll notice the storage interface has this method: getClientKey($client_id, $subject).  This means, yes you would have an entry for each user in the oauth_jwt table.  How these are registered is entirely up to you.  This could be in your \"client management\" UI.  You could have the same public key for each user, or different ones. A second option is to make the JWT token have an \"organization context\", i.e. you send in the organization identifier as the $subject, and the token is authenticated that way.  This will make you lose the user context, however, so this is only advised for \"service accounts\"\n\nI hope that makes sense.  These are great questions so please keep asking.\n. closing this issue - feel free to reopen if you have additional questions\n. It would be nice to have a clean way to set the $expires differently depending on the grant type. Perhaps the best way would be to allow a public setter (i.e. setAccessTokenLifetime) in the AccessToken response type, and then call this setter in the grant type in createAccessToken right before creation. \n. The getRefreshToken method on your RefreshTokenStorage class will be able to retrieve existing tokens, but only based on the refresh token itself.  You would have to write a method to retrieve based on user ID.   As for setting the $user_id in the first place, it depends on the grant type (for instance, Client Credentials don't really have a user context), but as long as you're passing in the user ID to the handleAuthorizeRequest function, it should be set for you where relevant...\n. Think of Client Credentials as a refresh token that doesn't expire.  Refresh Tokens exist to prevent you from having to reauthorize a user so often.  But since there is no third-party in the Client Credentials exchange, there is no reason to have a refresh token.\nPlease reopen this if you have further issues / comments.\n. I am still waiting on the password option to be fixed.  Instead of having the local $passwordOption variable, it should be part of the configuration array.\nAlso, let's rebase this commit (use git rebase -i HEAD~4) to condense your commits here to a single commit, so that the repo's history is clean.\n. When you change the commit history, you have to do a git push origin my-branch -f\nOne of your problems is the PR is coming from your own branch. This should be a topic branch instead. \n. We have already discussed this issue in #372 and #282. A more robust solution is required.\n. Thank you for reporting this! It is now fixed on the develop branch\n. You can use dev-develop if you'd rather pull from there. Otherwise it's usually as requested.\u00a0\u2014\nBrent Shaffer\nOn Mon, Jul 7, 2014 at 3:41 PM, Andrew Gerst notifications@github.com\nwrote:\n\n@bshaffer how often do you merge develop into master?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/411#issuecomment-48245057\n. @freefri This seems like an appropriate use of the response object. \n. closing due to inactivity\n. This is not a small bug. The library basically says \"if you want YOUR application to require scope, have your ScopeStorage return false\". But, the default behavior of this library is to say \"no scope = all scope\", ie if no scope is requested then all permission is granted. \n\nIf this is either unclear in the docs or not the desired behavior, I am totally OK with changing it. Perhaps requiring scope should be the default. Let me know what you think. \n. It may be an even better solution to configure the controllers with a new parameter 'allow_null_scope' => (bool), rather than putting this logic in the scope storage.\n. What does your updated tokenController do exactly? You really shouldn't need to do that.  At the most, you will need to have your ScopeStorage or your ScopeUtil return false instead of null\n. That looks great! \n. I definitely agree it is strange, but it is intentional.\nsee the code and the spec\n\nIf the request lacks any authentication information (e.g., the client\n   was unaware that authentication is necessary or attempted using an\n   unsupported authentication method), the resource server SHOULD NOT\n   include an error code or other error information.\n. that's exactly right, @dashohoxha!  \n\nYou certainly CAN have a token-revoking mechanism on the server side, either for users logging out, or for users revoking client access.  This is not currently part of library, although it would be a good addition.\n. You are requesting an access token via the GET http method. This is not acceptable in oauth, you must use POST instead.\u00a0\u2014\nBrent Shaffer\nOn Tue, Jul 29, 2014 at 9:38 AM, utpal4job notifications@github.com\nwrote:\n\nHello, I have downloaded your script and also implemented the code as said on \"http://bshaffer.github.io/oauth2-server-php-docs/cookbook/\" url. But try to run the script i get the below errors:\n{\"error\":\"invalid_request\",\"error_description\":\"The request method must be POST when requesting an access token\",\"error_uri\":\"http:\\/\\/tools.ietf.org\\/html\\/rfc6749#section-3.2\"}\nPlease tell me how to solve the issue.\nRegards,\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/427\n. The walkthrough details how to issue a POST using the curl library.  There is no straightforward way to do this using the browser, which is what I am assuming you are using.\n\nThe following request (taken from the walkthrough) will issue a POST request:\ncurl -u testclient:testpass http://localhost/token.php -d 'grant_type=client_credentials'\n. These functions/properties have been left private because the library may change how this is implemented in the future, which would break others' implementations.\nYour reasoning here is you've added extra fields returned by the storage classes?\nAlso, please rebase your branch so that your PR is only the single commit.\n. I have requested you rebase this, and asked a question.  If I do not hear back from you, I will close this in a week.\n. Very strange... Can you add \"-v\" and paste your full curl output here?\u2014\nBrent Shaffer\nOn Wed, Jul 30, 2014 at 9:13 AM, utpal4job notifications@github.com\nwrote:\n\nHello, When try to run \"curl -u testclient:testpass http://localhost/token.php -d 'grant_type=client_credentials\" command then below error is appearing.\n{\"error\":\"invalid_client\",\"error_description\":\"Client credentials were not found in the headers or body\"}\nCan you please tell me why that error is appearing.\nRegards,\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/429\n. Add the -v onto the end of your previous curl command.\u00a0\n\n[root@ip-46-252-194-21 ~]# curl -u testclient:testpass http://www.stv22.com/my-oauth2/token.php -d 'grant_type=client_credentials -v\n\u2014\nBrent Shaffer\nOn Wed, Jul 30, 2014 at 12:24 PM, utpal4job notifications@github.com\nwrote:\n\nHello, When pasting below both commands then nothing happening.\n[root@ip-46-252-194-21 ~]# curl -v testclient:testpass http://www.stv22.com/my-oauth2/token.php -d 'grant_type=client_credentials\n\n[root@ip-46-252-194-21 ~]# curl -u testclient:testpass http://www.stv22.com/my-oauth2/token.php -v 'grant_type=client_credentials\nRegards,\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/429#issuecomment-50658379\n. You should probably refresh your command line skills. There was a missing single quote, but I feel like that is something you should easily be able to diagnose.\u00a0\n\n\n[root@ip-46-252-194-21 ~]# curl -u testclient:testpass http://www.stv22.com/my-oauth2/token.php -d 'grant_type=client_credentials' -v\n\u2014\nBrent Shaffer\nOn Wed, Jul 30, 2014 at 12:36 PM, utpal4job notifications@github.com\nwrote:\n\nHello, I have entered as you said and clicks the enter button then \">\" symbol is appearing. Can you please tell me what is happening.\nRegards,\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/429#issuecomment-50660059\n. This is most likely an environmental / web server setup issue.\n. wow, this looks great.  Thanks for catching this, and thanks for the thorough testing.\n. Yes! Use \"Authorization: Bearer xyz\" where xyz is the access token.\u00a0\u2014\nBrent Shaffer\n\nOn Thu, Jul 31, 2014 at 9:08 AM, silvios notifications@github.com wrote:\n\nHey Brent,\nI am trying to set up a way to add access tokens via header requests rather then sending it via GET or POST request.\nThe reason why is because both the above methods interfere with caching. Could you point me in the right direction?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/433\n. That should definitely work, unless you're using the http-foundation-bridge library, in which case you need to drop in a line to your htaccess to rewrite the header properly.\u00a0\u2014\nBrent Shaffer\n\nOn Thu, Jul 31, 2014 at 12:02 PM, silvios notifications@github.com\nwrote:\n\noddly that doesnt seem to work for me.\n$test = $server->verifyResourceRequest($request, $response);\nthis returns false, when i do it via the browser &access_token=sameToken it returns true, is there something i need to do to allow the header to work?\nThe header is this Authorization: Bearer tokenHere\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/433#issuecomment-50795547\n. It is an apache issue that the symfony guys refuse to fix. See this link:\u00a0http://stackoverflow.com/questions/11990388/request-headers-bag-is-missing-authorization-header-in-symfony-2\u2014\nBrent Shaffer\n\nOn Thu, Jul 31, 2014 at 12:15 PM, silvios notifications@github.com\nwrote:\n\nI am using the http-foundation-bridge library.\nwhen dumping the headers via the php side i get this: using getallheaders()\n [Authorization] => Bearer tokenHere\nIs this something I perhaps did not read correctly in the docs? I do not recall seeing anything that would stop the headers from working.\nWhat is a proper header supposed to look like?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/433#issuecomment-50797396\n. It is a good solution. If you want to submit a pull request, I'll merge it\u2014\nBrent Shaffer\n\nOn Thu, Jul 31, 2014 at 12:55 PM, silvios notifications@github.com\nwrote:\n\nWhy don't we fix this ourselves.\nin the HttpFoundationBridge namespace the Request class\nadd the function:\n  /\n     * Creates a new request with values from PHP's super globals. \n     * Overwrite to fix an apache header bug\n     \n     * @return Request A new request\n     \n     * @api\n     */\n    public static function createFromGlobals()\n    {\n        $request = parent::createFromGlobals();\n```\n    /\n     * fix the apache header issue. See....\n     * http://stackoverflow.com/questions/11990388/request-headers-bag-is-missing-authorization-header-in-symfony-2%E2%80%94\n     /\n    self::fixAuthHeader($request->headers);\nreturn $request;\n\n}\n```\n/\n     * PHP does not include HTTP_AUTHORIZATION in the $_SERVER array, so this header is missing.\n     * We retrieve it from apache_request_headers()\n     \n     * @param HeaderBag $headers\n     /\n    private static function fixAuthHeader(\\Symfony\\Component\\HttpFoundation\\HeaderBag $headers)\n    {\n        if (!$headers->has('Authorization') && function_exists('apache_request_headers')) \n        {\n            $all = apache_request_headers();\n            if (isset($all['Authorization']))\n            {\n                $headers->set('Authorization', $all['Authorization']);\n            }\n        }\n    }\nand this would be solved on our end or is this not a proper solution? We would no longer need the htaccess rules\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/433#issuecomment-50802823\n. Looks great. Thank you!\n. As stated in #435:\nI wanted a distinction between user_id, which is arbitrary (it could be a \"username\", it could be a table's primary key, etc), and username, which is something very specific.\nThis is mainly because we have so many different storage classes, sometimes a primary key is used, and sometimes one doesn't exist (i.e. for Memory storage). \n. Hmm... yeah, this is not optimal.  I wanted a distinction between user_id, which is arbitrary (it could be a username, it could be a table's primary key, etc), and username, which is something very specific.\n\nThis is mainly because we have so many different storage classes, sometimes a primary key is used, and sometimes one doesn't exist (i.e. for Memory storage).  Which storage class did you have to extend?  And what error were you receiving that this fixed?\n. I see now this question pertains specifically to the oauth_clients table.  In this case, user_id is used to identify the creator of the client, and associate them with a record in another storage (which is left to the user to decide, as the user_id may or may not use the same Storage class)\n. Great, so did I answer your question (on the second try)?\n. This is fine, but why don't you use the AUTHORIZATION header, as recommended by the spec?\u2014\nBrent Shaffer\nOn Mon, Aug 11, 2014 at 5:30 AM, Rubaka notifications@github.com wrote:\n\nPlz allow access_token in request body.For post,all working good but,when i request PUT method.\nthen in  bearer.php file in 75 line ,return false \n(bool)$request->request($this->config['token_param_name'])\nand code do  execute on 77 line,and throw error\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/436\n. I believe this is allowed if you use the Request class. It may not be allowed when using HttpFoundation\n. So, is this issue requesting a fix in the documentation?\n. Under Here is an example of a full server configuration you see the following lines:\n\nphp\n// create storage\n$storage = new OAuth2\\Storage\\Memory(array(\n    'keys' => array(\n        'public_key'  => $publicKey,\n        'private_key' => $privateKey,\n    ),\n    // add a Client ID for testing\n    'client_credentials' => array(\n        'CLIENT_ID' => array('client_secret' => 'CLIENT_SECRET')\n    ),\n));\nWhere the client credentials are added to the memory storage.  So where are you asking for these docs to be updated?\n. Yes, this should have been in the docs repository, but that's okay.  I appreciate you reporting it.\nfixed in https://github.com/bshaffer/oauth2-server-php-docs/commit/8ff6942a357a76e5b1572e910da9deace008d5ee\n. Yes, your issue is you should be calling handleAuthorizeRequest when passing the $isAuthorized parameter.  This is the function used to prompt a user with the \"do you want to authorize...\" screen. \nhandleTokenRequest is used to grant access tokens, and does not require an $isAuthorized parameter. So I imagine the issue is you're using the wrong method signature, and as a result the $userId is not being passed through. \n. This is a valid concern. However, not storing the client credentials in plaintext means you can never display the client secret to the user after they've created their client. \nThe client credentials are considered less valuable than a password because 1. They only get sent on calls to retrieve a token, so they are a little more difficult to grab, and 2. They are locked down to a single scope/purpose ideally, so the threat vector is minimized. \nHowever, I agree that it is high time this library supports better out-of-the-box security for user passwords, and at least supports the ability to do the same with the client secret. \nIn the meantime, you can accomplish the same (or even better) level of security by using JWT bearer instead of client credentials. Only the public key is stored, and the client secret is left empty or never used, so no sensitive credentials exist at all in the database. \n. A more appropriate fix would be to have the UserInfo controller use \"addParameters\" instead \n. @relaxnow you are right, it looks like we only support the AuthorizeController returning an id_token, when we should also allow the TokenController to return this as well, in the case that response_type=code rather than response_type=id_token.\n@belerophon I do not understand your question. It is only required if the user requests id_token as the response type.\n. id_token is required if you're using OpenID, but it's not required overall.  If you leave it out, you're just using oauth's standard authorization flow.\nThe id_token is for providing the identity.  It comes back as a JWT token, and the client can decode it and get the user's information from it.  It's basically when you as the client want to add something like Login With Facebook. When they come back to your site, the id_token can be used to access/create their account and log them in.\n. ... reopening because we should make id_token available in the TokenController\n. @belerophon you can certainly use the flow you discussed. Returning the id_token from the authorization endpoint simply saves a round-trip to the server, providing better UX on applications where it is wise to be stingy with network calls.\n. @relaxnow yes, it's a little hard to locate, as the logic happens in the\nResponseType and not the TokenController. But it does indeed happen!\n@bojanz thanks for your explanations.\nOn Tuesday, December 30, 2014, Boy Baukema notifications@github.com wrote:\n\nClosed #443 https://github.com/bshaffer/oauth2-server-php/issues/443.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/443#event-212851505\n.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. This is amazing! Thank you for adding this. \nI will merge it in and create the test suite for it. Other than lacking tests, everything looks ship-shape!\n. Please commit them! That will help tremendously, even if they aren't entirely functional.\u00a0\u2014\nBrent Shaffer\nOn Wed, Aug 27, 2014 at 7:04 PM, Tom Park notifications@github.com\nwrote:\n\nI had added tests for the Couchbase storage type, the only thing required now is to prep the Travis environment so that a Couchbase server is running on localhost and always has a bucket called 'auth' created inside it running on the standard Couchbase port (or tweak the port in the bootstrap).\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/pull/447#issuecomment-53661697\n. Stupid question... Couchbase is a fork of CouchDB that combines some features of Membase, right?  Which is fine, although it may make it harder to test as part of travis.ci, as only CouchDB is supported as a service.\n\nThis is still okay, as we can run the tests locally and skip them for travis.  However, is there enough crossover to use the couchdb service to make the CouchbaseDB class support both? Or is this just a fantasy that has no real application in the real world?\n. Now that tag 1.5 is created, we can merge this.  Thanks again!\n. @phindmarsh is right-on. I've built this behavior into one of my oauth servers. It would be great to have a cookbook article detailing this behavior.\n. This definitely sounds like a bug, thanks for filing the issue and I will investigate further. \n. This helps tremendously.  Thank you.\n. This doesn't seem possible... OAuth2\\GrantType\\ClientCredentials implements OAuth2\\GrantType\\GrantTypeInterface, as seen here...\nWhat version of the library are you using?\n. Could you write a script (or even better, a test in test/...) that will recreate the issue?  You can use gist or submit a PR... any way I can run it and see the problem occur.\n. Is it possible your autoloader is loading a different class for OAuth2\\GrantType\\ClientCredentials from  the one included in this library?\n. You need to change this line:\nphp\n$storageM = new OAuth2\\Storage\\Memory(array('user_credentials' => $users, $clients));\nto this line:\nphp\n$storageM = new OAuth2\\Storage\\Memory(array('user_credentials' => $users, 'client_credentials' => $clients));\n. does the order matter? I assume token id_token is equally valid.\n. So, order does not matter.  I would suggest the change normalize the order, in this case. The library could be opinionated (say, token id_token, since that's the current implementation and there's no reason to break BC with that), but a client submitting id_token token in the request would receive the same result.\n. From the spec:\n\nMultiple-Valued Response Types\nThe OAuth 2.0 specification allows for registration of space-separated response_type parameter values. If a Response Type contains one of more space characters (%20), it is compared as a space-delimited list of values in which the order of values does not matter.\n. closing in favor of #470 \n. I do not believe this is a valid issue.  See these lines:\n\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php#L83\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/ClientAssertionType/HttpBasic.php#L46\n. I did not realize MongoDB was legacy.  Thank you for catching this.\n. The UserCredentials grant type is not where the OAuth magic happens. The magic happens with Authorization Code and Implicit grant types, where the flow is 3-legged.\nWe have an example of UserCredentials grant type here, and there is another example in the demo app, so I don't see the usefulness in adding the line of code above.\n. closing in favor of https://github.com/bshaffer/oauth2-server-php-docs/issues/46\n. This is a great change! Thank you for doing this. I have one comment, and it would also be great to write tests for this. Otherwise, :thumbsup: \n. This PR brings a tear to my eye.  If you could fix my single suggestion and rebase it into a single commit for a cleaner commit history (use rebase -i HEAD~4), I will merge it post-haste :horse_racing: !\n. gah, your only mistake! My name is Brent! :)\n. I forgive you on account of your awesome PR\n. closing in favor of https://github.com/bshaffer/oauth2-server-php-docs/issues/45\n. hey @twmobius, good question.\nIn most applications, your authorization flow will look like this:\n1.  call validateAuthorizeRequest \n   - this should happen BEFORE logging them in (i.e., ensure that the call itself coming from the client is valid before going any further).  If this checks out, then... \n2. Ensure the user is logged in\n   - prompt them with a login screen if they are not already logged in.  Once they log in...\n3. Prompt the user to authorize the call\n   - this usually is a page with the text Do you want to authorize client XYZ to access these calls?.  When they respond with yes or no thanks, then...\n4.  Call handleAuthorizeRequest\n   - pass as the third argument $is_authorized for whether or not the user consented, and pass $user_id (whatever that is for your application) as the fourth argument.\nI hope this makes sense.  Feel free to reopen if you have additional questions.\n. closing in favor of https://github.com/bshaffer/oauth2-server-php-docs/issues/44\n. in the RefreshToken grant type on line 94, you see this:\nphp\n$issueNewRefreshToken = $this->config['always_issue_new_refresh_token'];\n//...\nif ($issueNewRefreshToken) {\n    $this->storage->unsetRefreshToken($this->refreshToken['refresh_token']);\n}\nThis means when 'always_issue_new_refresh_token' => true, the old refresh token is expired.  So unless I am missing your question, this is already happening.\n. You mean the new refresh token has the same expires date as the old refresh\ntoken?\nOn Wednesday, October 8, 2014, Nelson Silva notifications@github.com\nwrote:\n\nThanks for the reply, i was confused because in the db the expires date\nfrom refresh token stays the same shouldn't be updated to expire?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/464#issuecomment-58347413\n.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. No, this is not normal. The library deletes the token from the database\nusing unsetRefreshToken. What's Storage class are you using?\nOn Wednesday, October 8, 2014, Nelson Silva notifications@github.com\nwrote:\n\nNo the new refresh token as a new expire date but the old one stays with\nuntouch, is this normal?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/464#issuecomment-58348284\n.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. @donearh this issue is closed. If you have a similar problem, please open a new issue and provide us with as much detail as you can on how we can reproduce it.\nThank you!\n. @dd3v you must specify the grant type in the request, using the grant_type querystring parameter (i.e. grant_type=authorization_code&code=somecode.\nWhat he is trying to do above is utilize the Implicit Grant Type, but this request is made against the authorize.php endpoint, not the token.php endpoint.  I assume he realized this and closed the issue.\n. @paulstatezny this looks great, although the Client ID is not considered sensitive data.  I have no problem with supporting both methods, however.  Can you rebase this into a single commit?\n. from the spec:\n\nThe authorization server MUST support the use of the HTTP \"GET\"\n   method [RFC2616] for the authorization endpoint and MAY support the\n   use of the \"POST\" method as well.\n. One last thing before I merged this - because get doesn't exist in the RequestInterface class, we will want to make the second parameter of query (the default, if get doesn't exist) to be a call to request\n. I've made the changes to your commit in #471\n. Ben,\nYes this is a good solution. Create some admin-level scope and only provide this scope level to your API client, and do not make it available to public clients.  Then, the access tokens granted to your API Client will have the admin-level scopes, and they alone will be able to call the admin APIs.\n\nYour other options would be outside the OAuth spec - i.e. you could use a different type of authentication for backend administration APIs, or you could check to see if the access token came from API Client, etc... But I would not recommend these.\n~ Brent\n. You would never want to submit both forms of Authentication - in fact, according to the OAuth2 spec, if two authentication methods are used, the server must return a 400 Bad Request.  So the two will never conflict. \nAs you closed this, I assume you found this out on your own.\n. Hey there,\nThe MemoryStorage is exactly what it sounds like - the items are stored in memory and in memory alone. This means changes to this are not persisted between requests. \nThis is useful for setting up clients quickly and for running tests - you can load clients/access tokens from YAML or static PHP into the Memory storage class.  But any changes made have to be added on every single request, as these changes are never persisted to subsequent requests.\nYou will want to use PDO storage to create new access tokens.\n. This is a great idea!\nWhat you could actually do is make a memcache class that accepts any other storage class as its first argument, and calls that class if the cache key doesn't exist.  It would look something like this:\n``` php\nclass Memcache implements AccessTokenInterface\n{\n    protected $storage;\n    protected $memcache;\npublic function __construct(AccessTokenInterface $storage, $memcache)\n{\n    $this->storage = $storage;\n    $this->memcache = $memcache;\n}\n\npublic function getAccessToken($access_token)\n{\n    $cacheKey = 'storage-'.$access_token;\n\n    # Try and get from memory\n    $accessToken = $this->memcache->get($cacheKey);\n\n    # We have some data\n    if(!empty($accessToken)) {\n        return $accessToken;\n    }\n\n    $accessToken = $this->storage->getAccessToken('access_token');\n    $this->memcache->set($cacheKey, $accessToken, 0, 600);\n\n    return $token;\n}\n\n}\n``\n. I would love that very much! Please do so.\n. Hmm... I've written the tests so it should skip any tests that you don't have drivers for.  Can you run the tests withphpunit -vand see if there is any more information? Feel free to post the full output of the tests here.\n. Also, if you post your branch on github I can pull it down and run the tests, as my machine is set up. To run ALL the tests, you need the following:\n-predis/predis-thobbs/phpcassa-aws/aws-sdk-php`\n- MongoDB php extension\n- Couchbase php extension\n- Redis/Mongo/Cassandra databases running locally\nBut as i said, the library should skip those tests if they are not configured. \n. I don't think @sandinosaso ever submitted a pull request... but feel free to submit one as well @pjebs \n. @npmarrin good catch! I've made the change and added a test.\n. There is a method checkRestrictedGrantType as part of the ClientStorage interface.  What Storage object are you using for your OAuth implementation? You can see here in PDO Storage what this function does, and if the client details you're returning would cause the check to fail.\n. The cookbook provides basic code for you to test. If you want more help, you can post the code snippet where you initialize the Server, and also a screenshot or copy of the data in your database, and then also the exact CURL call you are making to receive this request. \nThere is most likely either something wrong in the way you've implemented the library, or the way you've added the data in your database.\nIs it possible your grant_types column in the database for that client isn't empty?  If it has anything in it, let's say even a bunch of whitespace, this might be causing this issue.\n. Everything looks good.  Try putting authorization_code client_credentials refresh_token implicit password in your grant_type column, just for testing purposes, and see if that works.\n. You must have had something returning in the grant_type column.  If it either doesn't exist, or is empty, that's the same as not restricting grant types.  however, if you had invalid characters or whitespace, every grant type would be restricted.\nWhether you restrict your clients to a specific grant type, or allow them to use any grant type, is entirely up to your implementation.\n. It appears that this was a matter of wrapping your -d 'grant_type...' in a proper set of quotes rather than fancy quotes?\nHow did this happen? The cookbook example shouldn't be using fancy quotes, but maybe there's some ::cough:: browser out there that displays them that way anyway?\n. Thank you for the patch! If you want to fork the repo and send me a pull request, that would be even better (see this page for instructions)\nThat way you'll get credit for contributing to this repo, and kudos from the opensource community :+1: \n. looks great, thanks!!\n. The develop branch has the change (see this file) - it was fixed in #471\n. What are you using to issue the call? Can you post your raw HTTP request here? \nThe error message means the client credentials (i.e. client_id and client_secret) are not found in the request body (i.e. the body of a POST request) or in the header (i.e. the Authorization header, for when HTTP Basic Authentication is being used).  Are you using either of these methods to send in your client credentials?\n. I am going to close this if I don't hear back from you\n. When you set up your server, make sure you pass it the UserCredentials grant type:\nphp\n$server->addGrantType(new OAuth2\\GrantType\\UserCredentials($storage));\n. Thanks for the reminder - I need to update the documentation to the new naming conventions.  But this refers to the server issuing JWT Tokens as Access Tokens, previously called Crypto Tokens - http://bshaffer.github.io/oauth2-server-php-docs/overview/crypto-tokens/\n. you can use JWT Access Tokens if you have distributed systems, and need to validate a token's authenticity by more than one party without having to make a network call.\nFor instance, a token is granted by the Authorization Server.  That token is a JSON Web Token signed by the Authorization Server's private key. The Resource Servers (where API calls are made) are spread out all over the world, running multiple applications. As long as the Resource Servers have the Authorization Server's public key, which does not need to be secured, they can validate the tokens quickly without any network calls.  The tokens don't even need to be persisted.\nIt's an enterprisey use case, but is very useful for distributed systems.\n. Unless you hash it, $randomData will be raw binary data, and so will contain invalid characters\n. The hashing is used because the final case using mt_rand is not binary data.\n. After reading your article, I think this is a great improvement.  \n\nThe most recent reported cases of Remote Timing Attack vulnerabilities, for example, were against the OpenID and OAuth protocols when it was reported in July 2010 that numerous open source implementations of these protocols did not prevent the disclosure of timing information that could enable a Remote Timing Attack. It is important to note that, as with many potential attacks, the protocols themselves contain no vulnerability. This is strictly a potential vulnerability contingent on the method of implementation.\n\nI hate to think this library is part of the problem.  Thank you for submitting this.\n. looks good, thanks!\n. Thank you for your concern, Shurik.  \nThere are two tests being skipped:\n1. MongoDB - there is an issue with travis.ci that has been present for quite some time. I tested this not too long ago and found it still had errors, so we continue to skip them. \n2. DynamoDB - we only run these for php5.3 because otherwise we run out of tables allowed in our Dynamo storage. So for simplicity we only run it once per test.\nThere may be ways around skipping these, but for right now it's not a huge priority.\n. This is a good ask! It may be a security concern to expose such information to a potential hacker, however. What do you think?\n. @etcware nothing like this happens out of the box with this library. You could easily implement the OAuth2\\Storage\\UserInterface and then associate that user with a group. But that is out of the scope of this library.\n. You forgot to add a description!\n. @MartyRichters unfortunately, the spec only allows for an exact match, or for the query portion of the URL to be varied. By using the substring match, we are already breaking with the spec (technically).\nI realize the validateRedirectUri method is private, making it extremely difficult to customize. We could make this protected so a custom implementation for regex could be added without too much trouble.\nThis is not an uncommon ask, so I may employ this anyway, or allow for a custom RedirectUriValidator utility class to be injected in.  What do you think?\n. great change! Thank you!\n. looks good! Thank you.\n. Very strange indeed. Thank you for catching this!\n. Also, the call is being made server side, so how would an end user ever see\nthe HTTP request?\nIf the call is made using JavaScript, then your friend is right and the\nImplicit grant should be used instead. But if it's made server side, there\nis no concern of this. And if the SSL certificate is verified, there is no\nconcern of a man in the middle attack.\nOn Friday, December 26, 2014, Erik notifications@github.com wrote:\n\n@bojanz https://github.com/bojanz I've asked my friend who claims this\nto explain it.. but thought I pose this to the project as well.\nThey should be back in a week or so.\nTo me, it seems obvious that if OAuth2.0 is used in conjunction with SSL,\nthe Authorization Header (including the trusted Basic Header for trusted\nclients) is encrypted. Yes?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/492#issuecomment-68151339\n.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. How did you modify the Resource Controller? Did you edit the class directly, or did you subclass it? Obviously the second way is the correct way to do it.\n. I see... well, have you checked the row in the database (if you're using PDO storage) to verify the expires is being set appropriately?\n. @mcondave closing this in 2 days due to inactivity unless I hear back from you\n. @dmalan you are right, we are allowing more than the query component to be altered. A PR would be much appreciated!\n. This library already supports this:\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/ClientAssertionType/HttpBasic.php#L100\n. @Spomky which web servers are you referring to which don't check this?\n. Okay, that seems reasonable.\n@justonestep We would need a test case for this change, as well as changing the comment to a colon, as suggested by @Spomky. Also, if you could rebase it to be a single commit, that would be best.\nThank you for your contribution!\n. you could have kept the same PR open and just updated / rebased your branch. But you might as well submit a new PR now\n. I agree with this change... FETCH_BOTH was implemented in #489 in order to explicitly state the fetch mode to be used. But as pointed out by @aacotroneo, there is no reason to fetch both.\nPerhaps we should also include a config parameter for fetch_mode, default it to FETCH_ASSOC, and allow this to be changed (to prevent BC issues and also, apparently @pedrosancao has a reason for doing so, perhaps he just wanted to keep with the default)\n. I'm okay with just making it FETCH_ASSOC... no reason to overcomplicate things.\n. I cannot merge this, as it is causing the tests to fail:\n1) OAuth2\\GrantType\\ClientCredentialsTest::testValidCredentialsInHeader\nFailed asserting that null is not null.\n/home/travis/build/bshaffer/oauth2-server-php/test/OAuth2/GrantType/ClientCredentialsTest.php:106\nplease fix the above failure if you still want me to merge this\n. I see your confusion... the title checkRestrictedGrantType makes you think grant_types in the client details would be a list of restricted grant types rather than allowed grant types.\nThe truth is, the grant_types field from the client details is the allowed grant types, so the in_array check is accurate, and everything is happy.\nThe method might be better written checkIfGrantTypeIsRestricted... but that has it's own drawbacks, so the current implementation works for me.  If you have a suggestion on how to clarify this, please submit it here.\nSo, to reiterate:\ngrant NOT in list = true (allowed)\ngrant in list = true (allowed) -- correct!\n. Final thought... Restricted refers to the fact that the client is restricted to the grant types in the list, not restricted from them. Very confusing, yes. Perhaps a doc line in the interface would make it clear.\n. We do have this issue outlined here, but I suppose we could add your method in there as well\n. Yes, it's not super intuitive, and this is a very common issue people run into. Any suggestions on how to better clarify it?\n. great idea!\n. First of all you need to branch from develop and not master. Second of all I have no idea what this pull request is about. \n. I believe this would work, yes. It means any false value would be equivalent to null, but I don't think we ever have a distinction from a storage standpoint.\n. Would you like to submit a PR for this and include a test in this directory?\n. I agree, as null is the return value we have defined in the documentation.\nThis is probably not worth an integration test. You should create a mock DynamoDBClient and pass it to the DynamoDB storage object, then define the client to return an empty string and test the storage object returns null.\nThe other fix for empty values does deserve an integration test.\n. The grant type is not \"overridden with a null value\" for User Credentials.  It's not the easiest logic to follow, but if you look at the TokenController, you'll see the only time getClientId is called for Grant Types not implementing ClientAssertionTypeInterface is to compare it to the one used for the authorization. So, for instance AuthorizationCode stores a client_id in the database, so getClientId ensures the Client ID associated with the code is the same as the one authenticated with in the token request.\nSince UserCredentials doesn't have to do this check, the getClientId function returns null.\nThe issue you're having must be a result of something else. If you can pinpoint the error in the code, or in your workflow, we can try to resolve it.\n. This is a good idea. I assume you were checked out to \"1.*\" or \"~1.0\"?\nOn Tuesday, January 27, 2015, Maks3w notifications@github.com wrote:\n\nI suggest this project adopt Semantic Versioning guidelines\nhttp://semver.org/ for release versions.\nThis make easy fast upgrade for fixes without deal with backward\ncompatibility breaks like the recent #437\nhttps://github.com/bshaffer/oauth2-server-php/pull/437\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/507.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. Thank you for bringing this up... I've been using the Brent-Semantics versions, which follows the guidelines \"create a minor version whenever there are sufficient changes to justify it, and it's ok to break BC as long as you document it\".\nI like your suggestion better, and will adopt it for now on!\n. I don't see why not\n. two thoughts on this PR... and sorry it has taken me so long to review it...\n1. If we DO want to pass a null value to dynamo DB (i.e. set the client_secret or scope value to null) will this implementation allow us to do this?\n2. can you squash these changes into a single commit using git rebase -i HEAD~3 ?\nThank you!\n. This looks great! I would appreciate a rebase of all of these commits into a single commit using git rebase -i HEAD~9\nAs far as how this is used... I honestly don't really know... but before merging I will definitely try to put this together. We will want documentation on this as well.\n. Thank you for making those changes\n. I was able to get your slim project up and running! Nice work. However, I do not see an easy way to create the SAML assertion. Can you provide some sample code on how to do this?\n. @aacotroneo Okay, I spent a little bit revisiting this, and I have a few thoughts/suggestions.\n1. Is the reason we have to turn \"strict\" to \"false\" because we are required to have an SSL Certificate signed by a root authority?\n2. I think we should just pass the OneLogin_Saml2_Response object into the constructor of the Saml2Bearer grant type\n3. Saml2Bearer should implement ClientAssertionType interface, and should definitely return a client_id via  the function getClientId, otherwise how do we know which client issued the token?\nWhat are your thoughts? \n. Those links refer to the PHP 5.2 versions of the library. 1.6 is the\ncurrent stable version.\nOn Friday, February 6, 2015, Andriy Lesyuk notifications@github.com wrote:\n\nI'm slightly confused:\n- The site http://bshaffer.github.io/oauth2-server-php-docs/ links\n  to 0.9 as the stable version.\n- But then also refers 1.6 (and 1.6 is newer than 0.9) What is the\n  stable version? 1.6?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/513.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. Yes, @thunderyup is right. This library is not meant to be an application\nframework, but yet to work inside any multitude of other frameworks. Use\none of those for your application, and integrate this oath library into it.\nOn Friday, March 13, 2015, thunderyup notifications@github.com wrote:\n\nUse this as a library to your application. i.e. an addition. It's not good\npractice to take it and extend it to be your application.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/516#issuecomment-79302290\n.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. None yet, but thank you for voicing your interest \n. here's some great reasons to switch. I'll be working on this soon.  Zend's Diactoros seems to be the best library for implementing the actual request object, although this eventually will matter very little, as this library fits the middleware profile perfectly.\n. There is a question of how to implement error handling. The Response object is now immutable, which means the current model will not work. We will need to make the following changes:\n1. AuthorizeController::handleAuthorizeRequest - returns ResponseInterface\n2. AuthorizeController::validateAuthorizeRequest - returns true on success, ResponseInterface on error\n3. ResourceController::verifyResourceRequest - returns true on success, ResponseInterface on error\n4. ResourceController::getAccessTokenData- returns array on success, ResponseInterface on error\n5. TokenController::handleTokenRequest - returns ResponseInterface \n6. TokenController::grantAccessToken - returns array on success, ResponseInterface on error\n7. TokenController::revoke - returns true on success, ResponseInterface on error\nThere is a pattern forming here, where you get a response object on error. This isn't a terrible solution, but is there a better one?\n. @copynpaste I do like this solution. It's also the model implemented by firebase/jwt. However, the general sentiment exists that Exception classes should not be used for error handling and validation. Also, requiring users to surround certain function calls with try-catch is a pain.\nWhat if we made the last parameter of these functions &$errors = null, and made this into an array of error information if the call failed. Then the Controller classes could transform these errors into Response objects.\n. I appreciate everyone's feedback on this thread. We've discussed the following possibilities:\n1. &$errors (see this branch) - No.\n2. Mixed return type (see this comment) - I am not a huge fan... this will end up in instance of checks after function calls.\n3. combined return type - i.e. array like [ 0 => $status, 1 => $response] - I hate this also.\n4. Exceptions - Not super great, as some responses require special handling, and this could get convoluted real quick.\n5. Custom return type - I'm not sure I'd want this on every function\nAwesome, so I hate all these options. \n. I don't think this library (which will function as a middleware) needs to have internal middlewares... seems a little malcovichian to me.\n. @codeliner With the exception of the ResourceController method (we should probably add something like ResourceController::handleResourceRequest for this), you are correct, and those should all function as middlewares. \n. I don't like this change.  If a client has a public key, it will be in the public key storage, and not in the client credential storage.\n. I believe we want no response. The [] (or even {}) is not desirable. Would you like to submit a PR to fix this?\n. this is definitely not a feature we want to support... which storage class are you using?\n. Post your code in server.php here. I'm guessing you forgot to include the autoloader file. \n. @soauth I cannot understand your question, but the second part sounds right (you pass the code to the token.php endpoint after the user approves the client).\ndoes the file C:\\xampp\\htdocs\\OAuth2\\Controller\\ResourceControllerInterface.php exist on your machine?\n. Oh, it's because you're on a windows machine, and the directory separators are different.\nWe can either correct this in a pull request, or you can run composer.phar install and then include __DIR__.'\\..\\vendor\\autoload.php instead.\n(where __dir__.'\\..\\ points to the root of your project)\n. You could just submit an empty string for client_secret in the database, or allow the column to be null in your table configuration.\nWhere did you get the SQL to create your table?\n. yep... looks like we need to remove the NOT NULL from the client_secret column there.  Thanks for reporting this!\n. Closing this, as it's now fixed.\n@mtangoo This is not standard practice AFAIK.\n. I think that's a great idea, and I love the thorough research you have done. Thank you!\n. sure! I was hoping for a Pull request from the OP, which is always the fastest way to get a change in. But I can probably add this by the end of the week otherwise.\n. resolved in #571\n. great stuff!! thank you.\n. wow, thank you for posting this here for others having the same issue\n. no, this functionality does not exist. It would be a good addition to the storage classes.\n. Hmm... shouldn't the decoding be done upon storage? I don't see why we would want this url-encoded in the database/storage...\n. Yes, let's try to fix this at the root. How did the url-encoded URL make it into the database in the first place?\n. closing until a better solution is proposed\n. if scopes is populated, it means the client is limited to the possibility of just those scopes\nif grant_types is null, it means the client can use any grant type\nuser_id is if you want to tie a set of client credentials to a specific user\n. Yes, and if user_id is populated in the client table, then that same value will be populated in the user_id field of the access_token for any access token created with those client credentials.\n. @deathemperor CAPTCHAs don't really apply in this context, but we could add functionality for account blocking. Although I don't like this method either. If someone wants to block your account, they just incorrectly guess your passwords a bunch. IP-based blocking might work, or the exponential slowdown of requests. But in general, this is a non-trivial problem to solve.\n. The spec suggests making the tokens large enough as to make guessing them nearly impossible (2^(-160)). I will check to see if our current token generation meets this requirement\n. So, our current implementation is 16^(-20), which is significantly less than 2^(-160)\nIf we doubled our token length, we would be at 16^(-40), which meets the requirement (exactly).  Or we could use the entire alphabet, and keep the token length down. However, it appears that in order to reach 2^-160, beyond using somewhere in the ballpark of 128 characters, we will need to extend the token/code lengths\n. I would like to know how Facebook and other well-known OAuth2 providers handle this in their own implementation.\n. Thank you for the information. You are correct, this is not how we store/enforce scopes. However, it would not require \"a major overhaul\" to support this. \nThe call to $tokenStorage->getAccessToken would simply need to perform a join (in MySQL) against a user-client table containing the granted scopes, and add them to the returned $tokenData array. \nWe would also need to provide a way for those scopes to be saved in AuthorizationController, which would be doable with the ScopeUtil class. \nIn any account, I like the idea, and I think a lot of implementations would benefit from this.\n. Looks like your $storage object is empty, but that should be impossible due to the requred constructor argument here.\nMaybe it's something to do with your PHP version, that the typehints are being enforced. But you are setting $this->storage on one line, and then you are passing in just $storage in the proceeding lines... this would be null, and could possibly cause this error.\n. no, there is no reason for it.. I would recommend making it consistent everywhere, whichever you decide.\n. Check the status code, it's probably 400 \n. Can you post your code? We have tests surrounding both of those cases, and the result is not an empty response.\nIt most likely has either to do with your integration, or with the bridge request/response classes.\n. try setting the refresh_token storage to null after you've instantiated the server object:\nphp\n$server->addStorage(null, 'refresh_token');\nThis will ensure no refresh token is returned.\n. @justingreerbbi have you tried supplying response_type=code id_token?\n. @ckmaresca can you elaborate on why compact is a security concern?\nIf you are using register_globals, then that is the security concern. Even so, the scope of the variables would remain local, and will not be affected.\n. I am still not quite clear how to solve this. Could you elaborate on this by providing an example of how my library could make this less confusing?\n. No problem! If there's some way we can correct this confusion, I'm happy to do it. Let's get to the bottom of this!\nSo, the hierarchy you are suggesting takes place in the TokenType\\Bearer class. You will see the Authorization header is checked first, followed by the request, followed by the query. This is the precedence defined in the spec (HTTP Header > POST > GET). \nI do not believe $_SESSION is ever supposed to carry the access_token parameter. If I am wrong, please let me know (using the specification). So this is implemented correctly, to the best of my knowledge.\n. You will also notice in this class we do additional checking, to ensure the access_token isn't provided in more than one place (here), that the header is not malformed (here), that the request method is correct when the access token is in the post body (here) and that the content type is correct (here)\n. hmm... I am definitely confused here. You should definitely not put an access token in the state parameter. This is a huge security concern. If an attacker can get between your user and your application, they would essentially have the user's credentials.\nAlso, you shouldn't need to store an access token in the session when you redirect... the redirect is performed in order to obtain an access token. If you already have one, why is the user being redirected? The access token should be generated and returned by the auth server, without the need to maintain user state.\n. Thanks @ckmaresca for taking the time to write such a thorough explanation. As the library is following the specification, and provides opportunities for subclassing in order to deal with the problem above, I am closing this issue.\n. good catch! Fixed in https://github.com/bshaffer/oauth2-server-php-docs/commit/2a6091e7c0c5dbf04207332e91b2b0e993da900b\n. You should definitely be able to inject your own user storage like you've\ntried to do initially. This is actually the preferred way.\nAre you overriding the user storage later on? I am very interested why this\nwould happen.\nOn Thursday, March 19, 2015, TarasHots notifications@github.com wrote:\n\nClosed #547 https://github.com/bshaffer/oauth2-server-php/issues/547.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/547#event-259314333\n.\n\n\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\n. Yes, you must incorporate the state parameter in the request. Read more here, but essentially it means you must supply &state=xyz in the query string, where xyz is some encoded session identifier for your user. This way a session cannot be hijacked. But the session identifier should not be useful, in case it is compromised, so it should be (ideally) something salted and hashed:\n$state = sha1(sessionid() . 'some-salt');\nThen you can verify the state against your session id when the authorization server passes it back.\n. @Squrix create two clients, one confidential and one private. This is the recommended method if you are wanting to use two different grant types anyway.\n. Yes, my thoughts had been it is best to make clients specific to the grant type you are using. I suppose a problem with this is when a user authorizes via Implicit and the server wishes to make backend-calls using Authorization Code. Having two authentication flows for two different clients would be very strange.\nIn this case, you could override the OAuthClient storage, and make isPublicClient be based off a database flag rather than the secret. But... since the spec clearly allows for clients to be used for both flows, I agree this would make a good enhancement.\n. Rikin,\nThat is certainly not enough information for us to help you out. I suggest looking at your error logs and turning the debug mode on in symfony. Ask on IRC (#symfony) or find someone with more experience to help you solve your issue.\n. I feel like the ConsistentRead option could be supplied to the DynamoDB storage on creation. This would allow the user of the application to decide if they wanted to use consistent reads or not.\nEventual Consistency most likely would be acceptable in most cases.\n. is this something you are willing to add in another Pull Request?\n. @WitzHsiao are you planning on submitting a PR for this change?\n. These should all read\nphp\n\"ConsistentRead\" => $this->config['consistent_read']\nWith the consistent_read parameter being defined here and defaulting to false\n. Also, there's a typo. All of these say ConsistenRead instead of ConsistentRead.\nAlso, we need tests.\n. @WitzHsiao pinging on this open issue\n. This is not what I had in mind. Rather than using isset each time, you can have the parameter defaulted in the constructor. i.e here:\nphp\n        $this->config = array_merge(array(\n            'client_table' => 'oauth_clients',\n            'access_token_table' => 'oauth_access_tokens',\n            'refresh_token_table' => 'oauth_refresh_tokens',\n            'code_table' => 'oauth_authorization_codes',\n            'user_table' => 'oauth_users',\n            'jwt_table'  => 'oauth_jwt',\n            'scope_table'  => 'oauth_scopes',\n            'public_key_table'  => 'oauth_public_keys',\n            'consistent_read' => false, // <---- HERE\n        ), $config);. If you are looking to define a scope (say somescope), then just use the Redis function setScope to do so\nphp\n$redis->setScope('somescope');\n. I love it! Thank you.\n. the iss in the case of the JwtAccessToken is the service, not the client. As the client_id denotes the party receiving the access token, I believe aud is appropriate here.\nIf you disagree with this logic, please elaborate.\n. @RomeroMsk\nI think the misunderstanding here is the difference between JwtAccessToken and JwtBearer.  The Client ID for JwtBearer meets the specification that \"iss\" (issuer) must be \"a unique identifier for the entity that issued the JWT\" because in the case of JWTBearer, the client has issued the JWT (in order to receive an access token from the OAuth server)\nIn the case of the JwtAccessToken, the \"iss\" (issuer) is the OAuth server. I have made the \"aud\" (audience) to be the client ID, but I agree this is not correct. Unfortunately the JWT Bearer spec does not apply here. We cannot make the \"aud\" the token endpoint, because a JwtAccessToken is not ever sent to the token endpoint. It is sent to the resource server(s). So \"aud\" may not apply. The Client ID should be set to \"sub\" (subject) in this case.\n@basz what would unbreak this for you? When dealing with the JwtAccessToken, I'm not sure an \"aud\" parameter is relevant.\n. Hey, this looks great! Which code editor are you using?\n. @Wilt I would love to see this standard for documenting implemented as standard across the library\n. merged!. Please follow the walkthrough here: \nhttp://bshaffer.github.io/oauth2-server-php-docs/cookbook/\nAfter you download and unpack the zip file to a directory of your choosing, follow all the steps listed there to get your project going:\n. yes, there was a reason those functions happen in the order they did. I understand the order of some error messages seem a little unintuitive, but there wasn't a clean way to reorganize it, as far as I could tell.\nBut please give it a crack!! If the tests pass, I'll merge it :)\n. this is working as designed, the TokenType is a 401 and no other information, as specified in the OAuth2 specification:\n\nIf the request lacks any authentication information (e.g., the client\n   was unaware that authentication is necessary or attempted using an\n   unsupported authentication method), the resource server SHOULD NOT\n   include an error code or other error information.\n. this is working as designed:\n\nthe test is failing because the TokenType is a 401 and no other information, as specified in the OAuth2 specification:\n\nIf the request lacks any authentication information (e.g., the client\n   was unaware that authentication is necessary or attempted using an\n   unsupported authentication method), the resource server SHOULD NOT\n   include an error code or other error information.\n. This is a good catch! We should definitely pass issuer to the JwtAccessToken class.\n\nWould you like to submit a Pull Request to fix this?\n. nice work, thanks!\n. Hey @phindmarsh! I do not take this lightly, and am sorry for not responding earlier. This is a critical change, and if you are truly willing to submit a PR, I would love to go with whichever option you find more appropriate. \nPatching the library itself would be easier, as bringing in firebase/php-jwt will require updating the documentation (because we would want it to be an optional dependency) and making other core updates. But, as you are more familiar with the problem itself, what is your preference?\n. Great! Yes, I agree it is ideal to use firebase's jwt library at some\npoint.\nOn Tue, Apr 21, 2015 at 3:11 PM Patrick Hindmarsh notifications@github.com\nwrote:\n\nNo worries, I'm happy to push a PR for this today.\nI agree about patching the library rather than pulling in firebase/php-jwt,\nalthough I do wonder if that is something to be considered for a later time\n(if only because that lib gets more eyes from a security context). Our\nOAuth server implementation uses it instead of the built in one at the\nrecommendation of a security audit.\nI'll get a PR together applying a fix for the internal JWT class, and we\ncan move the migration to firebase/php-jwt to another discussion.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/564#issuecomment-94944705\n.\n. Wow, this is impressive! I am unfamiliar with IBM DB2... how can we add tests for this?\n\nIt is easy to add tests for new storage engines in the test suite... you just need to add the class to the BaseTest::provideStorage method, and all the applicable storage tests will be run.\n. @alanseiden DynamoDB doesn't use mock objects in the storage tests - it calls a real DynamoDB instance that I've set up with my Amazon credentials. I had to add  an exception so it only runs against php 5.5 in travis ci - otherwise the tests ran 6 times and conflicted with each other.\nIs it possible to test against a local (travis) or remote (cloud) instance of IBM DB2? \n. Is there anything I can do to help this along? I am waiting to hear back from you concerning the testability of IMB-DB2\n. @alanseiden any progress on this?\n. excellent find! We should add IBM DB2 to the travis tests then, and we can close this sucker.\n. Using the PDO storage class and the pdo-ibm extension, a user should be able to integrate with this server and the IBM DB out of the box. They just need to create a PDO object using the IMB_DB2 dsn\n. Yes, refresh tokens are not allowed when using Implicit. How can we make this more clear in the documentation?\n. Everything looks great except for the interface change - if we can just rename the variable but keep the method signature the same, we can avoid having to create a new major version for this (Semantic Versioning requires a new version for B.C. breaks). This will benefit everyone, and make upgrading to the security patch seamless.\n. @phindmarsh good catch! We should just remove the method from the interface, but keep everything else the same. And in the next major release, I'll incorporate firebase/jwt-php\n. I will be tagging a new version for this as soon as we merge #571\nOn Thu, Apr 23, 2015 at 4:11 PM Patrick Hindmarsh notifications@github.com\nwrote:\n\nImplemented in #569\nhttps://github.com/bshaffer/oauth2-server-php/pull/569.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/pull/567#issuecomment-95732765\n.\n. closing because @phindmarsh has his shit together\n. woohoo! Looks great!\n. but if you use timestamps, they will be using seconds since the Unix Epoch, which means they're timezone-agnostic.\n\nWhere in the code is the offending date() function being called? We cannot move this to a database level because there are many Storage objects which do not support a NOW()-type functionality.\n. We could add the timezone to the current date-formatted string - this will only affect current installations which are already broken / buggy, such as yours.\n. wow, nice work! All I ask is you submit a test for this functionality by copying one of the methods for the Refresh Token Tests and change the unset_refresh_token_after_use to false. Also, we'll want to add the new config value here and here\n. added the above in cd648bc733ec31b90098d4cca2f1218720536b66\n. No worries, I took care of it :)\nOn Thu, Apr 23, 2015 at 11:55 PM Yordan Yordanov notifications@github.com\nwrote:\n\nI'm relatively new to unit testing, but I will try to do something. Should\nI also add the new config value to the two mentioned files?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/pull/571#issuecomment-95809915\n.\n. @pjcdawkins I see what you mean. We could create a patch for this (1.7.1) to remove the BC-breaking change\n. Client Credentials is not a good option for web-based JS apps, as you are exposing the credentials directly in the client code... unless I misunderstand you, and you're only imbedding the token in the code.\n. Sounds like you want to use the JWT Bearer Grant Type. Have you looked into this at all?\n. Will this change address this issue? https://github.com/bshaffer/oauth2-server-php/pull/583\n. @tthiery Thank you for finding this. As this seems like a laravel-specific issue (a framework I am not familiar with) could you please recommend a fix?\n\nwe have fixed the second issue you mentioned with apache_get_headers, obviously only for apache, but I am assuming you aren't using apache if you still have the issue.\n. @tthiery do you believe this behavior is the fault of my library? It seems to me this is the fault of Laravel including the parameters in two separate properties of the request object. \nI could maybe include a way to override the check, or something along those lines, but I don't want to get rid of the current validation. Can you suggest a solution?\n. This strikes me as a WONT FIX - I do not want to add logic in this library specifically to undo poorly conceived logic in laravel's createFromBase method. \nI am assuming you're calling OAuth2\\HttpFoundationBridge\\Request::createFromRequest correct? If so, this would be an OK place to add logic to say \"If this is a Laravel request, AND it is a GET request, unset the request body data\".  \nI would be willing to add that logic there as a solution to this problem, since this library is a bridge to other libraries, and framework-specific logic can be added appropriately to handle framework-specific issues. What do you think @tthiery ?\n. hmm, I imagine this could have to do with the HTTP Authorization header bug. However this is fixed in all Request objects you might be using here and here\nCan you provide 1) the version of this library you're using, 2) the web server (i.e. Apache, NGinx, etc), 3) php version, and 4) any customizations you've done or other relevant information?\nAlso, try @morrizon's solution and see if that works.\n. Closing this issue because I have not heard back. Please reopen if you can answer the questions above.\n. good recommendation - I like this solution. \nThe only other solution I can think of would involve subclassing both OAuth2\\GrantType\\ClientCredentials and OAuth2\\ResponseType\\AccessToken. We could add a $config['access_lifetime'] parameter to each GrantType which defaults to null, and if set would override the access_lifetime parameter.  I'm not crazy about this solution, but if this feature is something people want, I will consider it.\n. totally agree with this one. @F21 would you like to set up a PR for this? I would like to include the firebase library under suggest and not require in composer, and throw an exception if it hasn't been installed.\n. @pjcdawkins  I actually changed my mind on how to implement this - what do you think?\n. Although sending an access token in the URI is insecure, this is noted under SHOULD NOT and not MUST NOT (ref), meaning it's still allowed. \nThis being said, removing an access token sent via a query string is not standard, and so would not be an appropriate feature for this library. What would be more standard would be to call the /token endpoint ushing HTTP DELETE in order to revoke the token.\nWe could add an unsetAccessToken method to OAuth2\\Controller\\TokenController, but that is out of the scope of this issue, so I am closing this.\n. This is great stuff! Two things..\n1. We need to preserve backwards compatibility for the develop branch. However, it would be great to make this available in the 1.x versions of this library, so I suggest moving this logic into the class FirebaseJwt, so it can be implemented by those who prefer it instead.\n2. The changes here (which I really like) should be submitted to the v2.x branch, since they break BC. Even for this branch, I would like to minimize backwards compatibility breaks however, so my interface suggestions above still apply.\n. Yes!! Nice work.\nOn Sat, May 9, 2015 at 8:05 PM Francis Chuang notifications@github.com\nwrote:\n\nSee #584 https://github.com/bshaffer/oauth2-server-php/pull/584 and #585\nhttps://github.com/bshaffer/oauth2-server-php/pull/585 instead.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/pull/582#issuecomment-100572811\n.\n. @F21 I hate to do this to you (and will make the change myself if you do not want to), but the new model is to merge from develop into v2.x and then remove the BC layer from there. So once we merge up to v2.x in #635, we will want to rebase this on top of it (remove FirebaseJwt, etc).\n. Great stuff for this PR and #584!! Thank you, @F21 \n\nI have a few questions for clarification, otherwise :+1: \n. wow, this is fantastic! Your testing is great and the implementation is spot on.  I'll dive deeper in this tomorrow, but just glancing at it I have only two minor suggestions:\n1. run php-cs-fixer to fix some of the whitespace\n2. we shouldn't add the interface changes to the develop branch, because it will break BC. And then we can submit the interface changes to just the 2.x branch\n. good question, I usually run php-cs-fixer without phpdoc_params, so like so:\n```\nphp-cs-fixer fix . --fixers=-phpdoc_params\n```\nEven so, I found that you are right, and quite a few small cs issues seem to have escaped my notice :)\n. Only one real required change here (we need to remove the interface addition). Otherwise it looks great!\n. Then, I can merge this into 2.x and we can add the interface changes in another commit.\n. I think throwing an exception would be the nicest thing to do for the\ndeveloper, as the message we define will be more clear than a fatal error\nAs for the interface changes, yes we should submit them to 2.x in a\nseparate PR\nOn Mon, May 11, 2015 at 3:16 PM Patrick Hindmarsh notifications@github.com\nwrote:\n\nRighto, I've commented out (but left a @todo https://github.com/todo\nnote) on each of the new methods defined in the interfaces, added a check\nto make sure the unsetAccessToken method exists before running the test.\nObviously while this doesn't break BC, it will cause a fatal error if\nsomeone attempts to use the revoke endpoint with a storage that doesn't\nimplement that method, since there are no runtime checks to ensure that\nmethod exists. I can do this if you like, although not sure what it should\ndo instead (throw an exception, fail quietly etc).\nI assume at some point we'll put another PR against the 2.x branch with\nthe interface methods added back again?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/pull/586#issuecomment-101049503\n.\n. No, it looks great! However you will need to rebase it first, as we cannot merge it automatically. \n. These changes are great @phindmarsh! However, @HugoCardenas has a great point. I am submitting a PR to your token-revoke branch with a few changes to fix that issue, and once you merge that one in (and rebase out the merge commit) this'll be good to go\n. added phindmarsh/oauth2-server-php/pull/1 to address these issues\n. and there was much rejoicing! Thank you @phindmarsh  and everyone else involved for your hard work on this!!\n. This library abstracts the storage solution from the OAuth2 logic, so that you can customize it however you wish. \n\nClosing this issue because I'm not sure what else is being asked, but if you have a suggestion as to what would make your situation easier, please feel free to reopen this issue and explain this.\n. You're not doing it wrong, this is a great catch!\n. Will you submit this to the develop branch? \n. We don't currently support multiple redirect URIs, but it would be a great enhancement.\nYes, validateAuthorizeRequest would be the way to go.\n. I take that back, @phindmarsh is correct, we support a space-separated list.  See the function validateRedirectUri\n. Hmm, we should rename \"id\" to \"jti\". This was just done in oversight, I\nbelieve.\nOn Wed, May 20, 2015 at 6:35 AM Bas Kamer notifications@github.com wrote:\n\nSilly question perhaps, but why doesn't the JwtAccessToken ResponseType\nsupport the 'jti' key?\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/ResponseType/JwtAccessToken.php#L64\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/591.\n. We should add \"jti\" to v1.x, and remove \"id\" in v2.x\n. @basz please see #594 and verify this will satisfy your problem?\n. It depends on the type of storage you are using, and what you are looking for. The UserCredentialsInterface contains the method getUserDetails, which takes a username as the argument, and returns an associative array of details about the user.\n\nIf you're looking for something more specific, I suggest dropping to the Query Language used by your storage engine.\n. Hmm, rereading this, I think all you need to do is use the PDO storage\nclass instead of the Memory storage class\nOn Fri, May 22, 2015 at 2:25 AM David Gunawan notifications@github.com\nwrote:\n\nDid you mean droping Query language to replace $users data from above??\nokay then i will try. Thank you before\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/592#issuecomment-104564837\n.\n. Sounds like the invalid pass/username error is concerning your PDO\ncredentials and not an oauth user's credentials. Can you paste the error\nhere?\nOn Sun, May 24, 2015 at 7:58 PM David Gunawan notifications@github.com\nwrote:\nyeah, i already used the PDO (basic config where this PDO connect to DB)\ninstead of using Memory, but it returns invalid pass and username\ncombination, i think somehow it reads my dsn name username pass instead of\nreading from user_table.... So now i'm desperately confuse how can i\nretrieve data from user_table..\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/592#issuecomment-105090433\n.\n. Aha, I imagine the problem is that you are entering a plaintext password in the database, when it should actually be a sha1. You should use the addUser method in the PDO storage class.\n. Haha no, use \"setUser\". It was just after midnight and I was tired.\nOn Tue, May 26, 2015 at 1:41 AM David Gunawan notifications@github.com\nwrote:\nohh yeah mate, i got it wrong entering unencrypted password into database,\nmy bad. Did you mean i have to change method setUser in Pdo class into\naddUser method? Because the link from your previous post is refering to\nsetUser method in PDO (sorry got little confuse where the addUser is)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/592#issuecomment-105428281\n.\n. You should be able to use the setUser method that I linked to as part of\nthe PDO storage class!\nOn Tue, May 26, 2015 at 9:56 PM David Gunawan notifications@github.com\nwrote:\nOkay, got it, but i have to add public function setUser($username,\n$password, $firstName = null, $lastName = null); in the\nUserCredentialInterface class, so that this method can work properly.\nThanks mate for your help, and sorry to disturb your night :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/592#issuecomment-105746529\n.\n. No, if you add users using setUser, you will not get the error. The\npassword is being encrypted in setUser because it is insecure to store\nthese in plaintext.\nOn Wed, May 27, 2015 at 12:57 AM David Gunawan notifications@github.com\nwrote:\nyeah i did use it, but in UserCreden interface class i have to decrale the\nfunction to call setUser method in the PDO storage class, either way it\nwill return the same error as i mention in previous comment\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/592#issuecomment-105782587\n.\n. Hmm... The scopes should be associated with the token, but they're sent in as their own parameter and not part of the JWT assertion. \n. You can use Jwt AccessTokens with ANY grant type. But be careful not to\nconfuse this with JWT Bearer, which is its own specific kind of grant type\nOn Tue, May 26, 2015 at 5:41 PM JerryBels notifications@github.com wrote:\nA little thing : is it possible to use JWT with user credentials grant ?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/596#issuecomment-105698584\n.\n. You should store a non-decoded version of your registered URI string, and\nthat should take care of this issue.\nOn Mon, May 25, 2015 at 7:54 AM ainslied notifications@github.com wrote:\nHi,\nin oauth2-server-php/src/OAuth2/GrantType/AuthorizationCode.php\nthis functionality is done :\n\"ensure that the \"redirect_uri\" parameter is present if the \"redirect_uri\"\nparameter was included in the initial authorization request\"\nwith this code :\nif (!$request->request('redirect_uri') ||\nurldecode($request->request('redirect_uri')) != $authCode['redirect_uri'])\nBut it seems that the former url $authCode['redirect_uri']) to be compared\nwhith urldecode($request->request('redirect_uri')) has not be decoded\nI get this comparaison : \"http://exemple.com/pagewithspecialcharlike\u00e9\" !=\n\"http://exemple.com/pagewithspecialcharlike%C3%A9\"\nwhich generate the error produced within the if statement\nI solved the problem taking off the urldecode function.\nI think you can make this modification (sorry, I'm not very familiar with\npull requests)\nRegards,\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/597.\n. Sorry, non-encoded version.\nOn Mon, May 25, 2015 at 10:26 AM Brent Shaffer bshafs@gmail.com wrote:\nYou should store a non-decoded version of your registered URI string, and\nthat should take care of this issue.\nOn Mon, May 25, 2015 at 7:54 AM ainslied notifications@github.com wrote:\n\nHi,\nin oauth2-server-php/src/OAuth2/GrantType/AuthorizationCode.php\nthis functionality is done :\n\"ensure that the \"redirect_uri\" parameter is present if the\n\"redirect_uri\" parameter was included in the initial authorization request\"\nwith this code :\nif (!$request->request('redirect_uri') ||\nurldecode($request->request('redirect_uri')) != $authCode['redirect_uri'])\nBut it seems that the former url $authCode['redirect_uri']) to be\ncompared whith urldecode($request->request('redirect_uri')) has not be\ndecoded\nI get this comparaison : \"http://exemple.com/pagewithspecialcharlike\u00e9\"\n!= \"http://exemple.com/pagewithspecialcharlike%C3%A9\"\nwhich generate the error produced within the if statement\nI solved the problem taking off the urldecode function.\nI think you can make this modification (sorry, I'm not very familiar with\npull requests)\nRegards,\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/597.\n. Good catch, thanks!\n. Nope, I think it's mostly because it's a newer interface, so support just hasn't been added to it yet.\n\n\nIf this is something you'd like to see, you can submit a PR, or we can leave this issue open to gauge how interested the community is in having this added.\n. That would be lovely! User claims is used in the UserInfoController\n. I agree this should definitely be added! I'd love to get to it, but in the event this takes me a while to get to, pull requests are welcome!. Hey @sandinosaso! Thank you for your PR.\nWhile I like the idea of using Memcache as a storage engine, here are a few things that could be done to improve your implementation:\n1. The Memcache class should be injected into the constructor, so custom ports/hostnames can be used. You can default to localhost:11211 when nothing is passed in\n2. We should add some test coverage for these changes. Consider adding it to BaseTest::provideStorage\n3. Consider adding support for other storage types (i.e. ClientStorage, ClientCredentialsStorage, etc) \n. Pinging @sandinosaso on this. Any chance of getting my suggestions implemented?\n. What kind of user storage are you using? It sounds like you'll need to\nimplement an interface for UserStorage and you'll be all set.\nOn Wed, Aug 5, 2015 at 8:57 PM dsquier notifications@github.com wrote:\n\n@x-merlin-x https://github.com/x-merlin-x I've done a similar\nimplementation with \"Resource Owner Password Credentials\" (which I think\nyou're referring to with UserCredentials, basically get a token based on\nuser/pass authentication).\nI maintain the DDL for the PDO storage of this library here:\nhttps://github.com/dsquier/oauth2-server-php-mysql\nNote: there are limitations in how scopes and how the Resource Owner\nPassword Credential grant type is implemented. Keep these in mind when\nusing this library.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/611#issuecomment-128228207\n.\n. The Device flow was removed in favor of the implicit flow in the final Oauth2 draft. I imagine you realize this, and is why this PR is closed?\n. Hmm... this is strange, as these packages should be available. Were you able to resolve this issue?\n. closing this due to inactivity\n. @muhaha03 you just need to configure an AuthorizeController then. But if you configure a Server object and then just call the AuthorizeController methods (i.e. handleAuthorizeRequest) and display your own \"accept authorization\" form, you should be good to go.\n. Can you explain a little more about the issue you're having?\n\nI looked at the code, and the $config parameters seem to be passed correctly. Can you provide a sample of the working and non-working code, or identify where the problem occurs?\n. Oh yes, looks like it's not in a tagged version yet. I would suggest updating to dev-develop, or just continue nagging me until I tag the next release.\n. @andriysilka thanks for the nudge, tag v1.8.0 has been created. Please update your libraries accordingly!\n. closing - we need to only use 2.8 for now\n. Hey @iam-merlin sorry for the delay\nThe best way would be for you to fork this repository and submit a PR. If it's possible for our adapter to support both 2.x and 3.x, that would be the best way (we are using dependency injection for the actual class, so we should be able to execute different logic, depending)\nWhat do you think?\n. If you write an adapter I will definitely add it to the docs. It does seem like a better model to include these separately, so they can be versioned along with their dependencies. \nHowever, to simplify things for the user, if a small change will make the existing class compatible with both, I will be going that route. \n. @nesinervink have you tried using $server->getTokenController()->addGrantType($yourGrantType)?\nThis is one way to do this. However, the best way would be to add them explicitly in the constructor of your OAuth2\\Server object.\n. Grant types can be provided in the constructor of the server object, so\nthis should already be good to go via config. You should be able to\nspecify the grant types explicitly, and they'll be passed to the token\ncontroller on creation.\nNot having worked with ZF, I can't tell you much more. But have you tried\nthis? You would just declare each grant type in the service container and\nthen pass it to the oauth service via constructor\nOn Mon, Aug 10, 2015 at 2:40 PM Patrick Hindmarsh notifications@github.com\nwrote:\n\nI'm not familiar with ZF2 or the service injection container it uses, so\nunfortunately I'm not much help in that department, sorry!\nI only had one suggestion, once you have loaded the custom grant\nsuccessfully, you should not need to use a custom route\n/oauth/fb-access-token, but rather just use the standard /oauth/token\nendpoint with the grant_type=facebook parameter in the body. Since the\ngrant_type parameter defines what grant to use when issuing a token you\nshouldn't need to build any additional routing/server logic beyond just\ninjecting the grant type class when the server is instantiated.\nThe only thing you might need to do is allow certain clients access to use\nthat grant type by defining it in the grant_types column of the\noauth_clients table (this is a space separated list of allowed grants for\nthat client).\nSome pure speculation on the service manage returning a factory closure\nmay be that you can decorate that function (say, creating a new closure and\ninside executing the original then decorating the result and returning),\nand set your new 'decorated closure' in the service manager instead. This\nis similar to a pattern used in Pimple (the service container used by Silex\netc) which allows decorating existing services with the ->extend()\nmethod. Dunno if this is completely wrong or not, just a guess [image:\n:smile:]\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/627#issuecomment-129619201\n.\n. Thank you for allowing yourself to be summoned @weierophinney!\n\n@nesinervink does this answer your question?\n. closing due to inactivity\n. @skobeo no, typically the refresh token should be used once, and then replaced by a new refresh token that comes back with the new access token.\n. I agree! We made the createIDToken method public so that it could be subclassed and customized to do this. \nYou could then use dependency injection to add your subclass to the oauth server like this:\nphp\n$server = new OAuth2\\Server($storage, $config, $grantTypes, array(\n    'id_token' => new MyIdTokenClass($storage, $storage, array('issuer' => 'yourdomain.com')),\n));\nDoes this help?\n. I wish it was easier... if you have an idea how to best do this let us know.\n. no, because I want to use inheritance, and calling methods statically remove the ability to do this.\n. will resolve conflicts in #585\n. Hello and thank you!\nThis library implements RFC6749, which is the final version of the specification.\n. @jniebuhr @Cyruxx thank you for catching this\n. This library assumes that the client will provide just a client_id (if the client is public) or a client_id and client_secret (if the client is confidential). There is no anonymous-client User Credential grants allowed. \nWhat @ssanders is doing sounds like it should be done using the Client Credentials grant type, and not the User Credentials grant type.\nsee this part of the same section of the spec you mentioned above:\n```\n   The authorization server MUST:\no  require client authentication for confidential clients or for any\n      client that was issued client credentials (or with other\n      authentication requirements),\no  authenticate the client if client authentication is included,\n```\n. Note that the following sample request includes HTTP Basic Authorization, which is where the client credentials are located.\n. Thanks for your research and comments, on behalf of everyone looking for answers to this same question.\nIt MAY be possible by the spec to allow just username and password for this grant, but that is not the implementation path taken by this library, as the use cases for this are extremely small. But it should allow for public clients, and so only require a client_id, as long as the registered client does not have a secret assigned.\n. Thanks Tobias! I'm ok with not having a common base class. However we do\nneed to add your Storage Adapter to BaseTest and Test/Bootstrap so it can\nget tested with the rest of the test suite.\nOn Thu, Sep 17, 2015 at 5:04 AM Tobias Gassmann notifications@github.com\nwrote:\n\nsince I have copypasted lots of code from the original cassandra storage,\nmaybe there should be a common base-class for both storages.\nI did not want to be too intrusive, so I left existing code unchanged and\njust added the new storage.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/pull/642#issuecomment-141056729\n.\n. @tobias74 any word on this? I can provide you with more information on how to add these tests.\n. Just pull the repo, run composer install, and then run phpunit... you should be good to go.\n\nIt'll skip tests automatically it can't connect to, but if you run phpunit -v you'll see the output for how to set those up.\n. @tobias74 any word on this? Will you add this to the tests here?\n. You will also need to add more information about the dependent Cassandra client library, and also type-hinting in your constructor.\n. To answer your question about testing, just pull down the library and run phpunit in the project root. It'll skip the other storage tests unless you have them running, which is fine because you don't need to test those. Just model your tests after the existing cassandra storage class\n. These tests are passing for the existing OAuth2\\Storage\\Cassandra implementation, so most likely you'll need to debug your added storage class to make the tests pass. If you crack open the tests themselves, you'll see where the assertions are being made. \nThe first error (extraneous input ')' expecting EOF) seems like you have a syntax error in your CQL.\nThe second and third error seem to imply your Cassandra test data has not been set up correctly (see OAuth2\\Storage\\Bootstrap::createCassandraDB)\nGood luck!\n. So a question to help my own cassandra understanding - what are the advantages / disadvantages to the two cassandra libraries being used? Is one considered deprecated, or are they both viable options? Do the names Cassandra and CassandraCQL properly describe the differences between them?\n. Public clients should still have a client_id, just not a secret. All access\ntokens should be tied to a client, so it is known who is accessing Apis on\nbehalf of the users.\nOn Tue, Sep 22, 2015 at 11:13 AM Wilt notifications@github.com wrote:\n\nI posted this also on stackoverflow\nhttp://stackoverflow.com/questions/32723198/oauth2-client-id-column-not-allowed-to-be-null\n.\nWhy is in the database scheme from the client_id column not allowed to be\nnull (NOT NULL)? Is this the common configuration for a valid OAuth\ndatabase schema?\nIt is quite common to have public clients that don't need a password. I\nsee that people set an empty string ('') in such cases, but a null values\nseems much cleaner to me.\nIs there some special reason to prohibit null values in this case?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/644.\n. NULL is fine for client_secret. Feel free to alter the schema, or submit a\npull request to do this.\nOn Tue, Sep 22, 2015 at 11:54 PM Wilt notifications@github.com wrote:\nSorry for this but I made a mistike while writing this. I meant the\nclient_secret column not hte client_id column. Client secret is declared\nlike this: client_secret VARCHAR(80) NOT NULL, so my question remains,\nwhy not allow null?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/644#issuecomment-142512802\n.\n. In the meantime you should be able to do this:\n\n$server->addStorage($keyStorage, 'public_key');\nOn Tue, Dec 1, 2015 at 4:32 AM DavidBurgess1984 notifications@github.com\nwrote:\n\nI agree with the above - OAuth2\\Server::setKeyStorage() does not exist.\nWould appreciate if this could be looked into.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/647#issuecomment-160928498\n.\n. This should now be fixed, please verify\n. This is a good catch! And it reveals a hole in our code coverage. Thanks!\n. Hell Eugene! Thanks for your question!\n\nThe fourth argument to handleAuthorizationRequest should be your scalar $user_id, which I imagine will be in the array somewhere.\nAs for the wordpress UserStorage adapter, there is a Wordpress plugin which uses a version of this library, and uses an OAuth2\\Storage\\Wordpressdb class that may be what you're looking for.\n. This is great! Thank you for finding this and fixing these. \n. closing in favor of #698 (rebased and whitespace cleanup)\n. Yes, I recommend starting with the docs link (mentioned above) and becoming familiar with the OAuth2 flows using the demo application (also mentioned above), the code for which you can download and run to get started.\nThis library provides the bare tools to build an OAuth2 server. If you want something out-of-the-box, check out Apigility, which uses this library under the hood.\nThanks guys!\n. @msyadav88 yeah this is a server library, not a client library.  Try https://github.com/thephpleague/oauth2-client\n. Sorry, this is not a forum for OAuth2 client debugging. I highly recommend checking out the oauth2 demo (mentioned above).\n. This works with my OAuth Demo App if you fill in the following parameters:\n- Authorization Endpoint: http://brentertainment.com/oauth2/lockdin/authorize?state=xyz\n- Token Endpoint: http://brentertainment.com/oauth2/lockdin/token\n- OAuth Client ID: demoapp\n- OAuth Client Secret: demopass\n- For Input your own scopes enter openid\n- When it asks for a resource URL, for some reason it isn't finding the Authorization header sent by google (I don't know why!!) so you need to add it to the querystring of the resource request: http://brentertainment.com/oauth2/lockdin/resource?access_token=YOUR_ACCESS_TOKEN\n@Alexanderstephengreenwood setting Implicit to true should not be required for server side! You've probably accidentally set the dropdown to \"Client Side\"\nI hope this helps!\n. Thank you for the instructions @Kami-no, I will update the cookbook to reflect this.\n. closing as duplicate of #659 \n. Thank you for looking into this. Using JWT Bearer solely for Client Assertion has probably not been done frequently enough.\nSo this functionality works if the above example uses assertion instead of client_assertion?\n. It sounds like you want to use OpenIDConnect for this.\n. No, this is not intended behavior, since the whole point in registering a redirect URI (or set of them) is to prevent a wildcard URI. Otherwise, you'd just leave it blank.\nWe should add an array_filter call after explode, to remove any empty values and prevent this from happening.\n. fixed in #695 \n. closing in favor of #694 (I just rebased it and submitted to the proper branch)\n. closing in favor of #695\n. An empty string seems okay to me, I agree. I'd be curious what the reasoning is there.\nWe need tests for this, and also this code is very difficult to follow. \n. Sorry @Silve2611, but without more information I can't help you. Perhaps you can try posting your code and the error /stack trace you receive with the CURL call.\n. This is confusing to me - timestamps are timezone-agnostic. As long as the server's time is correct, it shouldn't matter what the timezone is set to, the result of time will be the same. All of them are the same amount of seconds from the Epoch (00:00:00 UTC, Thursday, 1 January 1970)...\n. You must not actually be on the branch. The class you've mentioned above doesn't exist in the 5.2-develop branch, as it includes namespaces, which aren't available in php 5.2.\nThe class above is here, and as you can see is different from the one mentioned in your error. Double check that you're on the right branch.\n. LGTM\n. thanks!\n. @DaCardinal good catch! that sounds like a great idea.\n. also we need to add a test so we can catch if this issue exists in the other storage classes.\n. Hmm, this is a good point, this is WAD.\n. This seems like a good idea. I seem to remember returning false for a specific reason, but it may have just been because Pdo returns false from its queries, which is not a real good reason.\n. I disagree with this second request. These are convenience functions, and if you add your own storage classes, you are free to add these functions or not.  The library classes require them for testing, but the actual OAuth server does not require them.\n. a few thoughts on this:\n1. get, set, etc should be protected. \n2. The base class is only for one storage class\n3. There are enough subtle differences between storage engines, I'm not convinced this will be desirable\n. This is looking a lot better! \n. Looks like you were able to solve this issue?\nIt is recommended you use composer instead of the built-in autoloader.\n. develop is where all changes are merged originally.\nmaster is the stable branch, and the tags come from there. It isn't really necessary now that we use semantic versioning, but that was the original purpose.\nv2.x is for backwards-compatibility breaking changes.\nFor composer, you can use dev-develop if you want all latest changes and dev-master if you want the latest stable changes. Don't use v2.x yet.  But as the docs state, you should just use composer.phar require bshaffer/oauth2-server-php \"~1.8\"\n. hmmm yes, I believe that is a copy/paste error\n. Extend OAuth2\\GrantType\\UserCredentials and pass in the client_id from the request.\n. you can use the \"restricted_grant_types\" parameter in Client Storage\n. A refresh token requires a client_id and client_secret, so I imagine that the refresh token is harmless. However, I'm not stoked about this behavior and agree there should be some code to prevent the issuing of a refresh token for public clients using the user credentials grant type.\n. Hello yes! That is the expected behavior. Access tokens are not automatically deleted. They expire, and hang around, and a script to remove them is all you need if you want to keep your DB table small.\nAs for your second question, if you follow the refresh_token grant type docs and check out the demo site for the example usage, you should be able to make the expected HTTP request for a refresh token grant. To extend this, just implement the interface and methods of OAuth2\\Storage\\RefreshTokenInterface in your custom storage and set the grant type to your server object:\n``` php\nuse OAuth2\\Storage\\RefreshTokenInterface;\nMyCustomStorage implements RefreshTokenInterface\n{\n   //...\n}\n```\nand then when setting up your server:\n``` php\n// will automatically detect implemented grant types and set them accordingly\n$storage = new MyCustomStorage()\n$server = new OAuth2\\Server($storage);\n// OR ...\n// will set the storage for \"refresh_token\" explicitly, if you'd rather avoid the magic\n$server = new OAuth2\\Server();\n$storage = new MyCustomStorage()\n$server->addGrantType($storage, 'refresh_token');\n```\n. You don't need to put a JWT in a database field. You use the signature to\nvalidate it, and then read the data straight out of the payload.\nOn Wed, Dec 30, 2015 at 4:02 AM Stefano D. Mtangoo notifications@github.com\nwrote:\n\nbump;\nWhat do I do to use JWT since they cannot fit the database table field?\nhow do you use it guys?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/687#issuecomment-167977050\n.\n. If you're talking about issuing JWT Access Tokens, by default they are not stored in any database. \n\nAs far as making a custom payload, override the JwtAccessToken::encodeToken method.\n. You are expected to handle your user registration outside of this library. There are many libraries that do this, most of them particular to a given framework. \nMost of the storages have a setUser method also, so you could create your own registration form and call this method to register your users.\n. There are no plans currently to add LDAP storage. However, if you have code that does so, or any kind of sample code that might help this effort, please post it here.\n. closing this, as it is wrong and there is really nothing good about it. Sorry :(\n. The ResponseInterface is returned, but then you call send on it, which does not have a return value\n. thanks yo\n. ahh, just realized this was to master. This should have been to develop.\n. This is awesome! a few things\n- we need to convert the tabs to spaces\n- have you considered using traits instead of a base class?\n. Yes, that is what I had in mind! This is tricky though because this would\nbreak compatibility with PHP 5.3.\nOn Wed, Jan 13, 2016 at 3:12 AM afilippov1985 notifications@github.com\nwrote:\n\nthough... storage class can declare that it implements interfaces, but\nactual implementation will be done by trait.\nThen ... would be better to create several traits (one for each\ninterface), each will implement corresponding interface.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/pull/697#issuecomment-171256411\n.\n. We should make this PR to master as the develop branch is no longer being used.\n\nAlso, the tests are passing as-is, so I'm not entirely sure what this fixes.. this is a duplicate of #523 \n. We also need test coverage for this. Are you willing to add this? It will also verify if this issue is happening in the other storage classes.. According to the OAuth2 spec, any access token requests to the /token endpoint need to be POST. \nIf you want to do something different, just make the POST request on the backend, or generate the token manually (using AccessToken::createAccessToken):\nphp\n$tokenResponseType = $server->getResponseType('token');\n$accessToken = $tokenResponseType->createAccessToken($clientId, $userId, $scope);\n. Wow this is impressive! Can we get some test coverage? I believe we can run tests locally at least, with Oracle XE. Hey guys!\nYes, it's hard to argue with that RFC, even though IMHO it seems unnecessary to require client credentials. But a PR would be much appreciated!\n. @lucasantarella If someone has your access token, you are completely compromised, and revoking it is about the nicest thing someone who obtains your token can do.\n. Now if an attacker obtained a refresh token, they wouldn't be able to get an access token w/o client credentials, and revoking it would provide a minor (if harmless) annoyance. \n. The users passwords are being hashed, but this should be implemented in a more secure way in most applications, and don't want this library to handle that.\nThe client_secret in most APIs is recoverable so they can be displayed in the UI.  I would suggest overriding the setClientCredentials and checkClientCredentials methods in your storage object if you'd like to hash it. \n. Hey Cameron! Yes, if you want to hash the client credentials (which, to reiterate, I do not think is necessary since Facebook, Google, etc do not do this), you will want to override your storage class. This is easy to do:\n``` php\nuse OAuth2\\Storage\\Pdo;\nclass HashClientSecretPdo extends Pdo\n{\n    public function setClientDetails($client_id, $client_secret = null, $redirect_uri = null, $grant_types = null, $scope = null, $user_id = null)\n    {\n            $client_secret = $client_secret ? sha1($client_secret) : null;\n        }\n        return parent::setClientDetails($client_id, $client_secret, $redirect_uri, $grant_types, $scope, $user_id);\n    }\npublic function checkClientCredentials($client_id, $client_secret = null)\n{\n    return parent::checkClientCredentials($client_id, $client_secret ? sha1($client_secret) : null);\n}\n\n}\n```\nNow pass your new storage class to the server object:\nphp\n$storage = new HashClientSecretPdo($connection);\n$server->addStorage($storage, 'client_credentials');\nThis is a naive implementation, but hopefully this helps.\n. Nice work! Thanks for sharing.\n. We have an exact test of this being implemented here, so unless there's some other bizarre fishiness going on, your original constructor should work as expected.\nIf you'd like help implementing it correctly, please paste the full non-working code here, with a means of proving the config value is incorrect.\n. Closing this issue. Please reopen or file another issue if you'd like to continue this discussion.\n. @bkcummins unfortunately, the behavior of this library is that if there are no scopes returned from $client->getClientScope, then there are no scopes restricted. You could have this library return a fake scope (say, the string ::none::) in order to achieve this behavior.\n. use the public getter:\nphp\n$clientAssertionType = $server->getClientAssertionType();\n. The validateRequest function is public, so you will be able to use it. You can also use the checkClientCredentials method on your storage object.\nphp\n$storage = $server->getStorage('client_credentials');\n$storage->checkClientCredentials($client_id, $client_secret);\n. If you call $server->getClientAssertionType(), you will not be instantiating another object. The code above does that, however. So I suggest using the getter method instead.\n. This is definitely a bug. It is a result of a storage class returning true even when no token was found.  \nSee the AccessToken class.  If unsetAccessToken returns true, then refreshStorage::unsetAccessToken is not called.\nI assume you're using the PDO storage class, which in unsetAccessToken returns true regardless of the result. We should instead call $stmt->rowCount() to determine if anything has been deleted.\n. this is now fixed by #729 \n. It's up to you - this change is in the develop branch only, as I usually wait a bit before tagging a major release after merging changes. I'll tag a new release in a week or so.\nTypically, you want to check out to a stable tag like this to make sure the package doesn't change unless you need it to change:\nbash\ncomposer require bshaffer/oauth2-server-php:1.8\nBut if your project is in active development, feel free to use develop:\nbash\ncomposer require bshaffer/oauth2-server-php:dev-develop\n. Hmm, I don't believe this is covered in the spec at all. I don't see anything related to revocation in section 2.3.\nThe token is a Bearer Token, which by definition means\n\nany party in possession of the token (a \"bearer\") can use the token in any way that any other party in possession of it can\n\nOne thing a token can do is \"revoke itself\". Unless there is a direct reference to this in a spec that I am not aware of, I believe this is in full compliance.\n. removed in #790 . Have you tried changing the access_lifetime config option in the OAuth Server object?\nphp\n$config['access_lifetime'] = 300; // 5 minutes\n$server = new OAuth2\\Server($storage, $config);\n. Since access tokens expire, the only way to remove them (currently) would be to run a query to clean up expired tokens. In Redis, the removal happens automatically, but for the rest of the storages this is not the case.\nWe could add a method to the Storage classes removeExpiredTokens or something along these lines. Then this method could be called on a cron. Would this be appropriate for your needs?\n. Yeah, Redis will automatically remove keys after their expiration, so it's a great application for access tokens, refresh tokens, and authorization codes. You can mix-and-match storage also, and keep MySQL or whathaveyou for your other storages (client/user/etc).\n. What is the error in PDO? This should not throw an error, as the field is optional.\nThis is the intended behavior, the auth_code table is only supposed to store the supplied redirect URI. As you have mentioned, this is supported in this library, and should work w/o it. We even have test coverage for this use case.\n. LGTM, thanks for finding this!\n. Can you explain exactly what this PR is fixing, and ideally add a test to cover the case to confirm the issue is fixed?\n. I added the tests for this to your commit in #749 \n. The error supplied key param cannot be coerced into a private key comes from the openssl library, and means that the private key string is invalid. Check to make sure this key is correctly loaded from storage (i.e. not truncated, as mentioned above) and also that it is a proper key format and matches the signature... This is probably a result of this bug \nYou can see a fix implemented here. \n. Hey this is really cool! Nice work. Looks like it's essentially an ORM for the models this library uses. A few things:\n- [ ] tests\n- [ ] code standards (should be consistent with the rest of this library)\nDoes this only work for APIs or can it be used for local PDO as well?\nThere is a lot of boilerplate/crud code that doesn't really belong in this repo.  Is there any way to get around that, or is it required for the library to function?\n. Thanks again for your work on this!\nIt would definitely be preferable to only have the single Phalcon storage class, without generating all the dependent wrapper classes for each table. This would keep the API consistent (i.e. passing arrays of data rather than objects) between the storage types.\nAlso, add the Phalcon storage class to BaseTest and it'll receive all the same testing as the rest of the storage classes.\n. No need to add them all to the same file! If we need them then we'll keep them. You can skip the tests in PHP7 and add the extension in .travis.yml.\n. We should have a MongoDB class, in addition to the Mongo storage class, which correspond to the mongodb.so and mongo.so extensions respectively.\n. @iNDicat0r would you mind submitting a PR with your changes?\n. Hmm, this is WAD, as receiving an id_token is considered part of the Implicit Flow according to the openid spec:\n\nAuthentication can follow one of three paths: the Authorization Code Flow (response_type=code), the Implicit Flow (response_type=id_token token or response_type=id_token), or the Hybrid Flow \n\nSo to receive an id_token, allow_implicit must be true. This is not a bug, although I agree the error message is unclear.\n. This looks promising, but a few major things need to be fixed before we merge this. \n1. Travis tests are failing because we need to add the mongodb.so extension in travis.yml.\n2. You need to fix the line endings so the diffs accurately reflect the changes submitted by this PR. check out dos2unix or this SO article on how to remove the carriage returns. \n3. What is the purpose of MongoDBTest? All these methods are covered by the standard storage suite of tests.\n. @AstRonin Sounds good! Okay, to address your questions:\n1. To deal with travis.yml, add the following lines to before_install:\nyaml\n   before_install:\n   - if [[ ${TRAVIS_PHP_VERSION:0:3} == \"7.0\" ]]; then\n       phpenv config-add testing/mongodb.ini;\n     elif [[ ${TRAVIS_PHP_VERSION:0:3} != \"5.3\" ]]; then\n       pecl install mongodb || /bin/true;\n     fi\n2. great!\n3. Ok I get it. If there's a way to test all storage classes for this, that would be best. If it's a mongodb-specific thing to test, then this works great. We should remove duplicate tests though.\n4. This is no problem! Have Bootstrap::getMongoDB use NullStorage in this case, and the tests will be skipped:\nphp\n   if ('5.3' === substr(phpversion(), 0, 3)) {\n       $this->mongodb = new NullStorage('MongoDB', 'The mongodb.so extension is not compatible with PHP 5.3');\n   }\n. Added in #790 . This is available now in v1.10. See the CHANGELOG for details!. Hi @CoDanny ! We have no plans yet, but this is an interesting spec, and definitely seems like one worth supporting.\n. I just ran through the same example, and could not duplicate your error. There must be something not set correctly in your environment. Can you tell me a little more about your platform? What version of this library are you using? What does your token.php and server.php look like?\n. Yes, that'll work.\n. We have an OpenID Connect Overview in the docs and it's part of the demo as well.\n. awesome thank you!. It would be great to make this a config value that can be modified. Submissions are welcome!\n. @iNDicat0r when you use the Refresh Token, you receive an entirely new Access Token. There is no concept of refreshing a specific access token, so binding is not necessary.\n. This is already handled in the OAuth2\\TokenType\\Bearer class, and it's correct according to the RFC.. These changes use the mongodb.so extension instead of the mongo.so extension, so this can be separated in to OAuth2/Storage/MongoDB for BC and clarity!. I added this for BC and also fixed the tests: #790 PTAL!\nI agree separate libraries would be better! I will definitely consider splitting these out.. Thanks guys! This looks great.. Woops, I need to cut a new release and not merge directly into master.. added to develop in 912477710cc09773b61cc43690427191fbfacfec. Upgrading to dev-develop should fix this issue.. The link is not incorrect, it points to the hosted HTML version of the docs.. Great! Thank you, @chadicus !. Thank you!. Hi @AAllport !\nCheck out the docs on Custom Storage. If you are using PDO, you should start by extending the OAuth2\\Storage\\PDO class and overriding the checkPassword and hashPassword methods:\n```php\nnamespace MyApp;\nuse OAuth2\\Storage\\PDO;\nclass MyPDO extends PDO\n{\n    protected function hashPassword($password)\n    {\n        // do custom logic for hashing/salting\n    }\n}\n```\nAnd then when you create the server:\nphp\n$storage = new MyApp\\MyPDO($pdo);\n$server = new OAuth2\\Server($storage);. Thanks for logging this issue!\nThere is no restriction for the number of tokens allowed for a specific username/password, so I'm not sure what would cause this. Please get more information from your customer - what is the request/response for this call? Can you duplicate the issue? . Woohoo! Glad to hear it.. You're right, we should probably fix this so it returns string|null.. We should fix it! I care :D \nFeel free to submit a PR, or I will try to get to it. Because it's a BC break it will have to be for 2.0. What error are you receiving?\nBy default, you should have the refresh token grant type available. If you are getting an error that the grant type is not supported, it may be because your server configuration is missing a means to store the refresh token. Will you include here the code used to create your OAuth2\\Server object?. @thanseehabdulla I removed your comment because you just pasted in all this code. I'm asking for the code you implemented in your application, i.e.:\nphp\n$server = new OAuth2\\Server;\nYou could also try zipping your whole application and adding it to the comment. But with the above information I have no way to debug your code or to help you in any way.. @svycka I agree that we need to make this a little easier. Do you have any suggestions? One way would be to provide a callable as a config argument:\n```php\n$config = [\n    'jwt_payload_callable' => function ($client_id, $user_id, $scope = null, $includeRefreshToken = true) { // do encoding },\n];\n$server = new OAuth2\\Server($storage, $config);\n```\nAnother option would be to create a specific protected method for this:\n```php\nclass MyJwtAccessToken extends AccessToken\n{\n    protected encodeAccessToken($client_id, $user_id, $scope = null, $includeRefreshToken = true)\n    {\n         // do encoding\n    }\n}\n//...\n$server = new OAuth2\\Server($storage, $config);\n$server->setResponseType(new MyJwtAccessToken, 'access_token');\n```\nI prefer the second one, but either works for me. Thoughts?\n. Thanks!. This is great! I'm being picky here, but I don't think the term generate is accurate for this case. I'd prefer the method be createPayload. Can you make this change?. @svycka I don't think tests are necessary for such a small refactoring.  \nAs for the name, with the previous examples, the \"generate\" refers to the randomization of the token ID. In this case, the method is just constructing the payload and not really generating anything. That's my reasoning.. Thank you for the PR!. @MajesticMaje @svycka @bluebaroncanada Sorry for the delay here, we're all tagged up! Please update your dependencies for ^1.10:\ncomposer require bshaffer/oauth2-server-php:^1.10. Yes! You can do this in the OAuth2\\Storage\\PDO class by passing in a different database name to the $config argument:\nphp\n$pdo = new OAuth2\\Storage\\PDO($connection, [\n    'client_table' => 'my_custom_table_name',\n    'access_token_table' => 'another_custom_table_name',\n    // ...\n]);. The simple answer is the standard JWT fields are different from the OAuth2 fields, but this library expects OAuth2 fields. So a handful of fields are renamed when this library pulls the tokens from storage.\nIs there a bug, or is this more of a \"wtf is going on here\"?. This happens when the AuthorizationCode grant type calls expireAuthorizationCode. If you're using the PDO storage class, the function removes the authorization code from the database.\nIf you'd like to change this behavior, extend the OAuth2\\Storage\\PDO class and override the expireAuthorizationCode function:\nphp\nclass MyPDO extends OAuth2\\Storage\\PDO\n{\n    public function expireAuthorizationCode($code)\n    {\n        // do nothing\n    }\n}\nAnd then after you've created your server:\nphp\n$pdo = new MyPDO($dsn);\n$server->addStorage($pdo, 'authorization_code');. It's just the way this library implements the behavior. Since an authorization code can only be used once, it makes sense to just remove it from the DB.\nFrom the spec:\n\nThe client MUST NOT use the authorization code\n         more than once.  If an authorization code is used more than\n         once, the authorization server MUST deny the request\n\nSo this is not the same as letting it expire, or returning an error message saying the code is expired. \nIf you want to change this behavior but stay within the spec, this is entirely possible. I would suggest adding a \"used\" bit to the DB and setting it to true, and checking if it's been used in OAuth2\\GrantType\\AuthorizationCode. This is looking great. We need to add the parameter here also!. @afilippov1985 yes, I think jwt_extra_payload_callable works for me.. Tests are failing!. Currently, when pulling the access token from the POST body, the content type does not support JSON. To support JSON, send the access token in with the Authorization header, or in the querystring.. Thanks!. Can we get a Test Case added for this?. This is great! #829 is merged. is random_bytes the new hotness, and considered better than openssl_random_pseudo_bytes?. 401 Is not the appropriate status code here:\nSimilar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet been provided\n401 is a request to a resource which has failed because authentication hasn't been provided. In the case above, authentication has failed because the request being made is wrong, i.e. BAD REQUEST.\n. Dumb question, is the leading \\ necessary? I assume the answer is PHPDoc reads from the same namespace as the executing PHP code does, and since we don't have a use statement and we are in a different namespace, PHPDoc sees this as \\OAuth2\\Controller\\OAuth2\\GrantType\\ClientCredentials (for instance). Because this breaks backwards compatibility, this should be submitted to the v2 branch!. thanks for reporting the issue and providing the fix! You are what makes open source great and I salute you! \ud83d\udd96 . This looks good, but I am adding php 7.2 in https://github.com/bshaffer/oauth2-server-php/pull/873 to verify the fix. You bring up a good point. $server->getResponseType and $server->getGrantType will be returning differently with this change. It may be time we rename master to v1-master, and rename develop to master and merge in the changes from the v2 branch.. @bluebaroncanada This change is very benign. We should look into moving to v2.0 soon, however!. This looks great! However the master branch is now the default branch. I've submitted #891 to the master branch.. Thank you for your contribution!!. It is probably the Authorization Header issue that apache has. We fix this manually in this library here, but it's possible the Slim framework bypasses this logic, and so the Authorization header is not getting picked up.. You could debug this by checking in the slim application here and see if the Authorization header exists.. Nice!! Sorry about the inconvenience, that bug is a true pain.. See this stackoverflow solution, it's almost certainly because Apache is not passing the headers through.. Hi @rhertogh ! Yes, username would be a great primary key.. Done! Thank you sir.. There is nothing specifically supported in this library, only that the user_id field in the various storage classes can be used to query the tables and remove the tokens.. There isn't a precedent in the spec to modify scopes one issued. There is only the concept of downgrading scopes, e.g. if you have a refresh token with scope \"thing1, thing2\", you can use that to get an access token with only scope \"thing1\" or only scope \"thing2\".\nThere's a better way to accomplish what you want. For instance, if your access token is tied to a user, check the user for the subscription status.. Wow, I am impressed that you caught this, and appreciate you took the time to fix it.. +1 thank you!. This has been merged into master. Thanks for the fix!. Works for me, thank you!. oh wow, sorry about that. Will add a release right now !. @Ben-Ho \nAdded tag v1.11.0!! Sorry for the delay!. Hello! Yes there is, although it isn't documented anywhere. If you use composer require bshaffer/oauth2-server-php:dev-master (I will be tagging a new version soon) you can add custom claims like this:\nphp\n$config = [\n    'jwt_extra_payload_callable' => function ($clientId, $userId, $scope) {\n        return ['mycustomclaim' => 'mycustomvalue'];\n    }\n];\n$server = new OAuth2\\Server($storage, $config);\nIn the tagged 1.10.0 version you can do it by subclassing the JwtAccessToken class like this:\n```php\nuse OAuth2\\ResponseType\\JwtAccessToken;\nclass MyJwtAccessToken extends JwtAccessToken\n{\n    public function __construct($publicKeyStorage)\n    {\n        parent::__construct($publicKeyStorage);\n    }\nprotected function createPayload($client_id, $user_id, $scope = null)\n{\n     // your own logic here to create / customize the payload\n     // ...\n}\n\n}\n```\nNow set this on your server object like this:\nphp\n$server->setResponseType(new MyJwtAccessToken($storage));. closing as this changes expected behavior and I do not see the benefit.. The uppercase Bearer is used when forming a header and making a request with a bearer token. You can see this is properly uppercased in OAuth2\\AccessToken\\Bearer. The token_type identifier in the AccessToken response type is a response parameter, and according to the RFC is case insensitive.. @hardysim Since this library has been around a while, I do not want to make a change without a very good reason. I am not confident that \"nobody gets hurt\", as that change could potentially break backwards compatibility in somebody's implementation (e.g. saving bearer to the database and using a case-sensitive query to pull it back out).. see my comments in #918 for why this is not needed.. Question - why is this a blocker for those projects? These interfaces are forwards-compatible with the latest versions of PHP.. I understand now, the interfaces were updates as part of the symfony package.\nWe may need to do some sneaky autoloading to get around this issue while maintaining BC with previous versions of PHP. Any ideas?. @X-Coder264 unfortunately, in practice, those other versions of PHP are heavily used and I don't want to drop support for them just yet.. Added https://github.com/bshaffer/oauth2-server-httpfoundation-bridge/pull/34, which will fix this issue without changing interfaces or requiring autoload hacks ;). Closing as duplicate. As mentioned in the referenced PR, expires_in is set as a configuration value on the OAuth2\\Server object, so if this is being set as a string it will be returned as a string. I imagine there's a bug in the upstream Drupal module causing this.. Can you explain why this is necessary? Thanks.. This library does not depend on any other dependencies, so I think you must be seeing that error for existing dependencies in composer.json when running composer require bshaffer/oauth2-server-php. Try installing this package in an empty directory and it should install as expected.. In case it wasn't clear, the errors you are seeing are a result of dependencies declared as part of another package. You can confirm this with the why command in composer:\ncomposer why herrera-io/json\n. yes, if you'd like to keep track of the users who created the oauth clients, this is the field to do it. It's not a part of the OAuth2 spec, it's just something I added because I thought it would be useful in most cases.. Yes, please feel free to submit a PR!. Thank you for finding this!\nIn PHP 5.x - 7.1 , this will always pass (since count returns 1 for all non-array arguments, as far as I can tell). \nIn PHP 7.2, this throws an error. . Fixed in master. I am not familiar with the Blackberry Spark Communications SDK, so I cannot say what the issue is. But in the following token, there IS no audience, so my guess is the SDK is expecting a JWT Token, which has an audience.\nRead more up on JWTs in the documentation.. This error is defined here, and happens because the Access Token is being defined in more than one of the Auth Header (e.g. Authorization: xyz, the GET parameter (e.g. ?access_token=xyz\"), or the POST parameter.. why is the indentation off here?\n. Why are you not using the more readiblesprintf` here?\n. indentation is really off here.  I am assuming this is a tabs-to-spaces issue?  This repo follows the PSR-2 guidelines\n. There is no additional security benefits of using string concatination to sprintf.  If anything, it's the opposite, since you can preserve the variable type with sprintf\n. This is not valid for the PDO storage engine. This should issue a delete statement\n. Whitespace issue?\nLooks like there are no real changes to this file at all.\n. My thinking here is... the client credentials still need to be verified... they're just not verified through the getClientCredentials method.  So we still need to check the credentials in the JWT token... no?\n. I'm seeing a lot of these... is your IDE set to use tabs?  This follows the PSR-0 standards, which uses four spaces.\n. I see.  I would recommend putting the JWT validation logic in validateTokenData, and the Client validation logic in a new method defined in the ClientAssertionType interface.  Remember, this interface should be generic and implemented for HttpBasic, which is the default. Something like: \ngetClientDataFromRequest - pull the client data from the request\nvalidateClientData - assertion logic\nThe method getTokenDataFromRequest should simply return an array of relevant information.  It should only return false if the data cannot be gathered, but it should not perform any validation (such as expiration checking)\n. Why are the parameters of this method so abbreviated?  I don't even know what $nbf is.  These should be more descriptive.\n. Can we make these key names more descriptive?  Or is there a good reason for these identifiers?\n. Let's be consistant and put a space after the if condition and before the opening {, as dictated by PSR-2\n. I apologize.  I see these reasons outlined in the spec.  It would be nice to have a @param comment block here to explain this, but I won't require it.\n. this is part of the JWT spec\n. I agree these are the appropriate names\n. Again, a docblock would be nice but not required.\n. This is a little picky, but following the other Util class, these methods should be non-static, and the consumers of this class should be able to pass in a Util instance optionally, to allow for dependency injection\n. Looks like it exists for all control structures (after the if statement, before the (.  after and before else).\n. Through the constructor, similar to the $util param in my other classes.  Like this:\n```\npublic function __construct(OAuth2_Storage_JWTBearerInterface $storage, $audience, OAuth2_Util_JWT)\n{\n    $this->storage = $storage;\n    $this->audience = $audience;\nif (is_null($util)) {\n     $util = new OAuth2_Util_JWT();\n}\n\n$this->util = $util;\n\n}\n``\n. formatting issue --- should be} else {`\n. Looks awesome!! but Nulls should be lowercase\n. Looks like you ADDED an uppercase null! :)\n. Well it looks like the validation is slightly different in either case, so it seems fine to me.\n. this needs to have the curly brace in the next line\n. This error message seems to be incorrect.  the parameters being checked for are not the names of the parameters in the error message\n. The same goes for this one as above\n. I would advocate throwing a logic exception here, as it's good to check for\nthese things, but this should never be broken unless the implementer of the\nlibrary has done something wrong.\nSincerely,\nBrent Shaffer\n@bshaffer http://twitter.com/bshaffer\nOn Mon, Jan 21, 2013 at 4:23 PM, F21 notifications@github.com wrote:\n\nIn src/OAuth2/GrantType/JWTBearer.php:\n\n\nreturn null;\nif (!empty($diff)) {\n  +\n$this->response = new OAuth2_Response_Error(400, 'invalid_grant', \"Invalid issuer (iss) or subject (sub) provided\");\n\n\nYes, that is true, however from the client's point of view, the cause of\nthe parameters being incorrect would be because they had an invalid iss or\nsub.\nHaving said that, Perhaps it might be better to remove this after all,\nbecause having an invalid iss and sub will be the only issues for causing\nan error, and this is already being done in getClientDataFromRequest().\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/pull/38/files#r2719620.\n. We should change these to assertArrayHasKey like above, instead of removing them all together.  Otherwise, the tests below will throw PHP warnings if the call to getAccessToken returns false/null\n. It seems like this function would be better off \"private\" or \"protected\".\n. This is great but we need to follow the PSR formatting standards and put the curly braces on a new line\n. What is the reason for this change?\n. :) thank you\n. This can more appropriately be client_id, as that is the only information ever required to grant an access token.  Also, let's add typehinting for scopeUtil and request, and put request before scopeUtil.\n. This is now done in the Controller class\n. I am curious, why is this needed?  If I am understanding this correctly, we would be better off using trim()\n. Looks like we need four spaces here instead of two (or maybe you're using tabs)\n. This is the old constructor, and it has been changed. Please use the new constructor, which passes in a client assertion type object instead of storage. \n. This should follow a more standard docblock:\n\nphp\n/**\n * retrieve user id\n */\n. Gonna merge anyway, because I really appreciate you committing this fix.  But there should be spaces after if and before/after else... Im surprised the PSR2 param to cs-fixer didnt catch this!\n. This is a good change!  But please follow PSR-0 standards and the format of this repository by placing the braces on the same line:\nphp\nif (is_null($token)) {\n    return false;\n}\n. This is great!! Although it should be \"Access Token\" instead of \"Authorization Token\"\n. There is no reason why both grant types can't be added to the server. Did you encountered issues doing this?\n. Great!  That defenitely sounds like good clarification.  \nIf you update your patch-1 branch, this Pull Request will automatically receive the change, so you don't need to submit a whole new pull request.\n. We need to keep whitespace consistent here \n. There is no padding of whitespace after parenthesis in this library \n. Good catch!  Although, this should be in a use statement instead of in global scope here.\n. new line should be before comment block\n. can we get rid of the extra line space here?\n. Now there is additional white space. \n. This looks like a Laravel-speciific commit here.  We need to remove this\n. I am definitely not opposed!  More so, I would love to create a cookbook article in the documentation section which outlines a Laravel integration\n. Why the extra whitespace here?\n. get rid of this space (for consistency)\n. There should be a new line before the return statement\n. there should be a space between ($jti) and {\n. Why are all these parameters required to get the JTI?  It seems like storing the exp and jti is sufficient (and also preferred).\n. Throwing an exception here would be preferred\n. Can we add a link to the spec here (http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-13#section-4.1.7) for convenience?\n. Since we have typehinting above, I feel like this could be an is_null or simply checking if it exists\n. This library does not implement a space after the bang in this fashion (if (! $this...)), so I think it's best to remove it, unless this is a standard.\n. The reason there is no \"isset\" here is the function that grabs these from the request defaults to an empty string if none is found.  Also, in the line above it, an exception is thrown if the function is overridden and a client_secret is not returned in the array.  I agree though, that this should be changed\n. Why isn't this logic in OAuth2\\Request instead?\n. rename to DEFAULT_BCRYPT_COST?\n. What is the case in which an exception is thrown?\n. instead of using (bool), can we use intval?  This is picky, but since $methodsUsed is an integer, this makes more sense.  Also, I prefer intval to (int), because PHP is trending towards this method of casting\n. I am very glad you caught this... I think your current PR works just fine.  Can you rebase so I can merge this?\n. this has been moved to TokenController, which is more appropriate\n. This is essentially a refactor.  No new functionality, just a cleaner / easier to understand way to validate the scope\n. Adds OAuth2\\Storage\\ClientInterface to constructor so we can validate client scope.\nIt's a rather large dependency to introduce, but we absolutely must ensure client scopes are validated, so this is the best option I have found\n. We are no longer allowing jwt to have a scope.  I've sent an email to IETF about this, since Google allows this, but Salesforce does not.  Since it is not present in the jwt spec, for now we will remove it and only accept scope via GET or POST\n. adds new client storage constructor for TokenController\n. This isn't ever used, since we added getClientScope to the storage interface, but for consistency I like it here\n. What does this mean?\n. This is also answered here\n. After further review, I think this IS the best way to do this... as token id_token truly is its OWN string identifier.\nThe only thing I would suggest is that maybe this should be its own class as well... i.e. AccessTokenWithIdTokenInterface.  it's pretty long, but it may fit the existing spec best.\n. This logic does not belong here\n. This should be in a function createDefaultCryptoToken, which gets called if the config flag is set \n. We also need to add store_encrypted_token_string to this default config array\n. I would like to see this in its own function, createDefaultCryptoTokenStorage, and this should also throw an exception if public_key isn't set.\n. I suppose this can go back where it was now\n. This should be moved above the LogicException thrown for a lacking access_token storage, as this is optional for crypto tokens, and may not be set.  I would place the thrown exception in the else stement below\n. this should be combined with the line above it, i.e. } else {\n. @bojanz I completely agree.  It seems silly.  In addition, I believe an access token (or at least the access token hash) is returned inside the id_token.  I looked through the spec, and saw no justification for these combined return types, only that they were possible.\nIf there's no use case for them, there's no point in implementing them.\nHowever, token id_token makes sense to me because, as I understand it, the id_token is related to the session (authentication), and the access token is related to API access (authorization), although that could be completely wrong.\n. This needs to be reverted back to bshaffer\n. I do not want to add this as a requirement, however it would be great to add this as a suggested package:\nhttps://getcomposer.org/doc/04-schema.md#suggest\nchange the keyword to \"suggest\" and you'll be good to go\n. This is causing tests to fail, and needs to be reverted.  We have discussed this in https://github.com/bshaffer/oauth2-server-php/pull/309#issuecomment-32255353\n. We are using namespaces, so the absolute path is not necessary\n. please explain what this is doing.  What happens if the preg_match fails?  We need to handle this validation.\n. This regex should not need to happen more than once\n. Global functions inside a class file? This is not okay. Please make these into the anonymous functions available in PHP 5.3\n. This comment should be removed\n. These both should be removed\n. Grant_type here should be removed\n. This function may be better off in the OAuth2\\Scope (aka $scopeUtil) class\n. formatting: this curly brace needs a new line\n. formatting: this curly brace needs a new line\n. It's picky, but I would prefer this conditional be reversed\nphp\nif ($this->config['use_openid_connect'] && !isset($this->responseTypes['id_token'])) {\n. love it\n. this is wonderful\n. Why is this called UserClaims here, but UserInfo elsewhere? I would prefer to use UserInfo, as this makes sense, but I am okay with either as long as it's consistent\n. UserProfileInfo also makes sense to me\n. Global constants are not a good idea.  Especially in a library like this.  If someone brings this into their own codebase, and they've already defined one of these contants, things will explode.\n. Method names should stick with the convention of the library (and PSR-1). This should be camel cased (i.e. hash) as should the method below (hashCheck)\n. These functions should not be public, as they are never called outside this class. They should be private, or at the most, protected.\n. I would love to see these values passed into the $config array, so the user can change these if their application requires\n. It's a fair question. Essentially, I do not want to make anything public unless the library requires it, and I don't want to make anything protected unless it's a clear place users will want to extend the library.\nThe reasoning here is when you open up the APIs to these classes, you restrict yourself from making modifications later. For instance, if we ever wanted to remove hashCheck, now we have to worry about all the applications calling hashCheck publicly.  If we make it protected, we only have to worry about the libraries subclassing Pdo, where as if it's private, we have 100% confidence that changing this method will not adversely affect any of the applications using this library.\nKeeping all the functions in your library wide open means users will implement them in ways you never intended, and you may be locked into supporting them as such, which is unfortunate.  So as a general rule, assign appropriate access levels and you and your users will both be happy (for the most part :smile: )\nAlso, when you look at a class file, you can safely skip private methods, and understand that protected methods are points where subclassing may occur.  It goes a long way in Self Documenting the library\n</endrant>\n. I would rather just set this each time, as this will be more clear when reading the tests\n. Undefined property: OAuth2\\OpenID\\Controller\\AuthorizeController::$client_id\n. Looks like the spacing is a little off here.  The standard indentation for this library is 4 spaces \n. We need to have a space between every if statement and their parenthesis, i.e. if (...) {\nBut this would be better off as something more like this:\nphp\n$clientData = compact($client_id, $redirect_uri, $grant_types, $scope, $user_id);\n$clientData = array_filter($clientData, function ($value) { return !is_null($value); });\n. Extra newline here\n. extra newline here.  I would suggest running https://github.com/fabpot/PHP-CS-Fixer against this, to highlight all the issues\n. As this code to determine the $redirect_uri is duplicated 3 times, let's pass in a $redirect_uri parameter to the setNotAuthorizedResponse function.  If we do that, I am good with a merge\n. I'm not sure about this whitespace here... The docblock should be flush with the function.  Is this a tabs-to-spaces issue?\n. This library uses the lowercase null, as required by PSR-2\n. This library uses the lowercase false, as required by PSR-2\n. I like this change, but it should be in a separate pull request\n. No, this library used four spaces. Please use this convention instead. \u00a0\u2014\nBrent Shaffer\nOn Tue, Jul 1, 2014 at 2:00 PM, Sum notifications@github.com wrote:\n\n\n\n*   'allow_public_clients'  => true              // if true, \"public clients\" (clients without a secret) may be authenticated\n* );\n* @endcode\n*/\n/**\n* @param \\OAuth2\\Storage\\ClientCredentialsInterface $storage\n* @param array                                      $config\n* OPTIONAL Configuration options for the server\n* @internal param \\OAuth2\\Storage\\ClientCredentialsInterface $clientStorage REQUIRED Storage class for retrieving client credentials information* REQUIRED Storage class for retrieving client credentials information\n* @code\n* $config = array(\n*   'allow_credentials_in_request_body' => true, // whether to look for credentials in the POST body in addition to the Authorize HTTP Header\n*   'allow_public_clients'  => true              // if true, \"public clients\" (clients without a secret) may be authenticated\n* );\n* @endcode\n*/\n  I converted the spaces to tabs which is better, i thought\n\n\nReply to this email directly or view it on GitHub:\n  https://github.com/bshaffer/oauth2-server-php/pull/405/files#r14425928\n. Why don't we add password_options as a key to the $config array instead of adding another argument?\n. the whitespace here is not correct - please use four spaces instead of tabs, and add a carriage turn before these last two return statements\n. I imagine we don't want a MongoConnectionException here.  Is there a Couchbase equivalent?\n. I imagine we can get by with the CouchbaseException base class, although we will want to test it out.\n. Unfortunately, we will have to use the php5.3-compatible array(...) syntax here\n. This is really picky, but for consistency with the rest of the library, this function should be convertJwtToOAuth2 (uppercase the A in OAuth2)\n. formatting - we need a space between for ( and the curly opening curly brace on the same line.\n. Also, why not just return $a === $b if the function does not exist?\n. I'm not sure this qualifies as a timing attack vulnerability... this is a simple string comparison, not a cryptographic algorithm.  I don't understand how this could leak any valuable information...\n\n\nThank you for the article. I read through it, and I am not convinced it applies here.\n. We need to put the curly brace on the same line, i.e. for (...) {\n. One final request - please rebase your commits into a single commit using git rebase -i HEAD~3\n. why is $settings here if it is never used?\n. I see... this is fine, but I would make its default be $settings = array so that it is not a required parameter\n. I see a lot of extra whitespace here... can we get rid of all superfluous whitespace? I suggest running php-cs-fixer for this.\n. this can be removed\n. This will throw a namespace error, as it will be looking for OAuth2\\Storage\\ Exception\\RuntimeException\n. we should verify here that these functions exist - if they don't, we should throw an exception requiring the ibm_db2 extension\n. can you explain exactly what's happening here? We're using the first array item as the algorithm, and the proceeding array items as arguments to the algorithm's function?\n. creative way to filter these, but I can't find anything wrong with it.\n. I would prefer to keep this null to preserve backwards compatibility, and we can change it to array() in the next major version\n. This is great!! I think the only thing I would change is make the constructor the following for consistency:\nphp\npublic function __construct(JwtBearerInterface $storage, $audience, EncryptionInterface $jwtUtil = null, $config = array())\n{\n    // ...\n    $this->config = array_merge(array(\n        'allowed_algorithms' => array('RS256', 'RS384', 'RS512')\n    ));\n    // ...\n}\nThis just keeps it consistent with the rest of the library\n. no, the PHP class is \\RuntimeException (see here)\n. I don't see the win in breaking BC by changing the signature here... we should keep this as null\n. error message should be firebase/php-jwt must be installed to use this feature. You can do this by running \"composer require firebase/php-jwt\"\n. Since this isn't part of the interface, it wouldn't be a bad idea to check the unsetAccessToken method exists, and skip this test if it doesn't. We would also want a @TODO to remove this for 2.x\n. We aren't allowed to do this for develop, as it will break BC\n. What kinds of exceptions are thrown here? Can we get a comment or some explanation why this try-catch exists?\n. We don't need to maintain BC here, since this class is new.\n. Can we get an explanation of what the $keyId is, and why it needs to be passed to the encode function?\n. We cannot break BC with interfaces, but we are not required to \"preserve\" BC for new classes.\nThis function is called here and here, and neither instance requires this \"BC\" logic.\n. I guess my real question was about how php-jwt employs exceptions. They   list all the possible exceptions here, which is nice. \nIn 2.x it would be great to catch these at the Response level, so the error messages can be added to the response.\n. This line checks the $config parameter, while the options being set above it are setting $this->config \n. It should probably be fixed, yes, as this inadvertently changed the default\nbehavior.\nOn Thu, Jun 11, 2015 at 12:30 PM Vytautas Stankus notifications@github.com\nwrote:\n\nIn src/OAuth2/GrantType/RefreshToken.php\nhttps://github.com/bshaffer/oauth2-server-php/pull/587#discussion_r32208013\n:\n\n@@ -34,6 +34,14 @@ public function __construct(RefreshTokenInterface $storage, $config = array())\n             'always_issue_new_refresh_token' => false,\n             'unset_refresh_token_after_use' => true\n         ), $config);\n+\n-        // to preserve B.C. with v1.6\n-        // @see https://github.com/bshaffer/oauth2-server-php/pull/580\n-        // @todo - remove in v2.0\n-        if (isset($config['always_issue_new_refresh_token']) && !isset($config['unset_refresh_token_after_use'])) {\n-            $this->config['unset_refresh_token_after_use'] = $config['always_issue_new_refresh_token'];\n\n@bshaffer https://github.com/bshaffer do you think this should be\nfixed? or this works as expected?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/pull/587/files#r32208013.\n. Why is this public (as opposed to protected) ?\n. Why isn't this a part of the array above? It would be more straightforward to have a single default config array.\n. for v2.x I think we should just make this required instead of suggesting it, since it's core functionality (as opposed to an optional storage class)\n. this second line requires another test, as the first line will throw an exception and therefore halt execution\n. How would it know what content type to use unless we set it? \n. would be cleaner: if (empty($registered_uri)) {\n. Unfortunately, we can't remove a class constant w/o breaking BC, so this has to be named back to VALID_CLAIMS\n. Please break this out across multiple lines and add comments, so the logic is clear.\n. why is this call desirable? Have you seen problems with xdebug on travis?\n. This is great! Thanks for adding this.\n. 7 errors out, and is required to be 7.0 (now that there is an official release).\n\nThis can be removed, as it's been added in a separate PR\n. That's only implemented in my response class, not as part of the interface.\n. brace should be on a new line\n. remove newline\n. remove newlines\n. add newline :P\n. why is composer install also in install? How about you move the phalcon installation to install instead? \n. Don't remove php 7 and hhvm!! Just add an if statement around your before_install:\nyaml\n  - composer install --prefer-source --no-interaction\n  - if [[ ${TRAVIS_PHP_VERSION:0:1} == \"5\" ]]; then vendor/bin/install-phalcon.sh 2.0.x; fi;\n  - phpenv config-rm xdebug.ini || return 0\n.. Or something similar\n. Seems like this class could be replaced with an array and array_merge\n. Can you use stdClass?\n. curly braces after function declarations should be on their own line, to be consistent with the styles in the rest of this library\n. hmm, something is wrong here. You must be using Windows newlines. You will need to use Unix newlines instead.\n. The tests for the Storage Interface methods are here, so I don't think any of these tests are needed.\n. we need to use array() syntax here, since this library is compatible with PHP 5.3\n. Please revert the changes made to composer.json. remove comment here. Let's go ahead and add this to a use statement above.. let's return $clientScopes here and remove the $getGlobalDefaults variable all together. This will greatly simplify this function.. Instead, this should be array('Allow' => array('POST', 'OPTIONS')). I would prefer these exceptions be handled like this:\n```php\nif (!is_callable($this->config['jwt_extra_payload']))) {\n    throw new \\InvalidArgumentException(\"config['jwt_extra_payload'] is not callable\");\n}\n$extra = call_user_func($this->config['jwt_extra_payload'], $client_id, $user_id, $scope);\nif (!is_array($extra)) {\n    throw new \\InvalidArgumentException(\"config['jwt_extra_payload'] callable must return array\");\n}\n$payload = array_merge($extra, $payload);\n``. Yes it is, otherwise thearray_mergebelow will throw an error.. nit, but I'd rather this just be \"jwt_extra_payload_callable is not callable\". Why don't we just pass this function$payload` and expect the returned array to be the new payload, e.g.:\nphp\n$payload = call_user_func($this->config['jwt_extra_payload_callable'], $payload);. I'm convinced. Ty for the explanation.. ",
    "ghost": "https://github.com/bshaffer/oauth2-server-demo/issues/3\n. I've made the changes for supporting postgres, ended up being trivial so I'll just let you know what I did so you have the option to do it if you wish. In case you weren't aware the underlying issue is that Postgres using double quotes as a column identifier, not data.\nPDO.php: Just look for any \"%s\" in your SQL prepares and replace them with a data binding, using the compact array constructor to map the values (like you do in one of the commands anyway).\nDEMO: Obviously the SQLITE stuff for making the database doesn't need the file exists tests and all that, I just fixed mine locally and it's all good.\nI've tested it with your demo app and it's creating tokens just fine using PG as back end PDO now. It's also fine with PG's schema based \"db.schema.table\" table naming (i.e. my table names are oauth.access_tokens where oauth is a private schema within the database).\n. OK, I've done a pull request. It's just the fundamental fixes to get the queries through postgres.\n. I noticed that and thought it was odd too. Let's bin it and I'll have another pop at it just in case it's something sublime did.\n. OK, I binned off that fork and went again. All looks good this time around. Sorry for confusion, I'm still getting up to speed with GIT for open source stuff. Not sure how to kill this pull request.\n. Guys, how can I check if the user ID exists in my database?\n. Yes, thank you. This method help me very well.\n. I remove \" ' \" from line command in grand_type=credentials and work ok. Closing this ticket. \n. Yes, I'm on a windows machine and typo is ok. I copy from your tutorial.\n. Maybe this is because the windows default charset, I don't no. Anyway, this is it. \nps.: my english is awful, sorry if have so much errors.\n. Thanks for the clarifications.\n. Why is called \"client_id\" at first place? It's actually an issuer(URL) of the token that is pushed in, therefore it's issuer's public key and has nothing to do with client. Client is stored under \"aud\" field inside JWT Token.\nhttp://openid.net/specs/openid-connect-core-1_0.html#IDToken\nReferring to this line in JWTBearer(176):\nif (!$key = $this->storage->getClientKey($jwt['iss'], $jwt['sub'])) {\n. @F21 ahhh true, see now the difference between oauth draft and openid connect draft.\n. @F21 still, there is inconsistency in library, looking inside IdToken(60-62) when creating id_token:\n'iss'        => $this->config['issuer'],\n'sub'        => $user_id,\n'aud'        => $client_id,\n'aud' should then be issuer(https://example.info/uri) and 'iss' identity of the client(client_id).\n. @F21 hmm if JWT Bearer is not the correct GrantType to be used for openid connect implementation, which one is then?\n. What is wrong with refresh token?\n. By doing refresh_token grant_type or am I missing something?\n. Ok so, there is a token endpoint on which request is done and if everything is ok, then access token and refresh token are returned.\nMeaning access token can and should be used for all requests until it is valid, when it is not valid anymore then refresh_token is used to retrieve new access_token. At this point refresh grant_type is called to retrieve access_token.\n. Try this\ncurl -i \"https://some-host/token\" \\\n        --user CLIENT_ID:CLIENT_SECRET \\\n        -X POST -d \"grant_type=client_credentials\"\n. Remove \\ if you are doing oneliner.\n. CLIENT_ID should actually be a value, but if it works :)\n. @F21 @bshaffer can someone have look at this, since it's kind of a blocking issue. Let me know if any changes are needed.\n. I've just re-read the code above and it works on the same principle as the scopes doesn't it, d'oh! Thinking about the logic behind it all, I can see why you've done it. At first I thought that if I don't want a client to have any grants, then I wouldn't specify any, but then if that was the case, I would just remove them from the client list!\nI was (will, if I fix my issue) to put in a paragraph about that for both scope and grant types in the docs, if there's me confused, there's going to be someone else...\n. Use this as a library to your application.  i.e. an addition.  It's not good practice to take it and extend it to be your application.\n. To use my own users table, I've extended the storage class I'm using.  In my case, it's Pdo.  You can change other things by overriding the functions in your preferred storage method.  I hope this helps.\nphp\nclass DoLoginPdo extends OAuth2\\Storage\\Pdo\n{\n    public function __construct($connection, $config = array())\n    {\n        parent::__construct($connection, $config);\n        $this->config['user_table'] = 'users';\n    }\n}\nThen, my initialization of the Oauth2 library looks like this:\n``` php\n        $dsn      = 'mysql:dbname=yourdatabasename;host=localhost';\n        $username = 'yourdatabaseusername';\n        $password = 'yourdatabasepassword';\n    try{\n        // $dsn is the Data Source Name for your database, for exmaple \"mysql:dbname=my_oauth2_db;host=localhost\"\n        $this->oauth2storage = new DoLoginPdo(array('dsn' => $dsn, 'username' => $username, 'password' => $password));\n\n        // Pass a storage object or array of storage objects to the OAuth2 server class\n        $this->oauth2server = new OAuth2\\Server($this->oauth2storage);\n\n        // Add the \"User Credentials\" grant type\n        $this->oauth2server->addGrantType(new OAuth2\\GrantType\\UserCredentials($this->oauth2storage));\n\n    }catch(PDOException $e){\n        // DO NOT send the password to the log files.\n        echo str_replace($password, ' *** Password Removed *** ' , $e);\n        die;\n    }\n\n```\n. Clients are the apps (could be web, mobile, desktop, anything) that are connecting to your Auth Server asking for a token that will later use that token to ask for resources on behalf of a user.  I think you understand that part.\n1 - My plan is to at least research Implicit grants when I implement my web app.  Depending on how your web application is implemented, you may want to do that also.  Otherwise, like you mention, you'll have to store the client id and secret in the client.  That could be on the server side if you're making the call from the server - that wouldn't be too bad.  For example, your web form would be sent to the browser, the user would enter their credentials, the credentials would be posted back to your server, the server would make the oauth call adding in the client id and secret, the result would be sent back to the browser.  Or, it could be in Javascript on the client side if you're doing AJAX calls - that would be worse for storing the client secret and not recommended.  In that case, you could do the same thing adding the client secret at the server.\n2 - You can use scopes to limit what each client is allowed to do - that's one way.\nI'd recommend studying the docs online several times.  AND, looking deeper in the Oauth2 library code to see what it's actually doing.  I've also found it beneficial to watch the oauth tables in the database while I make calls to the library.\n. @tthiery I'm having the same issue. I implemented your fix along with the advice you gave @JerryBels and it did not work. I tried replacing the variable, as he did, to no avail. I receive the same error from Laravel each time and that error is:\nArgument 1 passed to OAuth2\\HttpFoundationBridge\\Request::createFromRequest() must be an instance of Symfony\\Component\\HttpFoundation\\Request, instance of Illuminate\\Support\\Facades\\Request given\nHere is my current code:\n``` php\nRoute::get('private', function(Request $request)\n{\n    $request->request = new \\Symfony\\Component\\HttpFoundation\\ParameterBag();\n    $rawHeaders = getallheaders();\n    if (isset($rawHeaders[\"Authorization\"])) {\n        $authorizationHeader = $rawHeaders[\"Authorization\"];\n        $bridgedRequest->headers->add([ 'Authorization' => $authorizationHeader]);\n    }\n$bridgedRequest  = OAuth2\\HttpFoundationBridge\\Request::createFromRequest($request);\n$bridgedResponse = new OAuth2\\HttpFoundationBridge\\Response();\n\nif(App::make('oauth2')->verifyResourceRequest($bridgedRequest, $bridgedResponse))\n{\n\n    $token = App::make('oauth2')->getAccessTokenData($bridgedRequest);\n\n    return Response::json(array(\n        'private' => 'stuff',\n        'user_id' => $token['user_id'],\n        'client'  => $token['client_id'],\n        'expires' => $token['expires'],\n    ));\n}\nelse\n{\n    return Response::json(array(\n        'error' => 'Unauthorized'\n    ), $bridgedResponse->getStatusCode());\n}\n\n});\n```\n. Perhaps my workflow is incorrect? I have the same code you have above with my own credentials. First I get an access token:\ncurl\ncurl -u testclient:testpass \"http://domain.com/oauth/token\" -d \"grant_type=password&username=bshaffer&password=brent123\"\nI receive:\n{\"access_token\":\"62883e3fda62855c02f4e3f6e34a430fdf324c23\",\"expires_in\":3600,\"token_type\":\"Bearer\",\"scope\":null,\"refresh_token\":\"cedeb556632b3728ceff367fc885d10af4a7bbb6\"}\nThen I use the access_token to try to get the private resource:\ncurl\ncurl -u testclient:testpass \"http://domain.com/private?access_token=62883e3fda62855c02f4e3f6e34a430fdf324c23\"\nI receive:\n{\"error\":\"Unauthorized\"}\n. duplicate of #381 \n. same for https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Request.php#L197\n. Btw. all other calls to RequestInterface::server() are asking for REQUEST_METHOD - so it would make sense to completely remove this method and introducing a method directly shipping this information like RequestInterface::method() but this would introduce a BC break for sure.\n. ",
    "mjamado": "The real security issues were on statements that had something like client_id = \"%s\" with sprintf. That just gave me the creeps. If someone had sent \" OR 1=1 -- or worst in client_id, we would be in serious trouble.\nIn queries where user_id is used, and because of that int-or-string control, it's just a little more hardened to use PARAM_INT.\nThe rest was only for consistency sake.\n. As I said, string concatenation was only a panic option, and then my coding style took over; the real security issue was inline insertion of parameters, as in line 45, for example. There's nothing wrong with the sprintf (or string concatenation, for all that matters), as long as there's no direct parameter insertion.\nThis is not production ready; but it could be. Then, all it could take was the override of the password check, and that was it.\n. Copy-paste issue (tabs vs. spaces)\n. Readbility is debatable. Personally, I would use it like that, but it's mainly a coding style. The first sprintf had to go, because I nearly had a stroke with a security issue (see other comment); the rest just went away in the wake of that one.\nP.S.: just for clarification, I have no intention to force a ban on sprintf. I just panicked and removed every one in sight. The real changes here are the security issues (ie.: no direct-to-string parameters).\n. ",
    "xantrix": "Is it possible to change the visibility of properties in \"protected\" ? To easy extend functionality ?\n. Thanks for your answer.\nI would like to override method \"getUser($username)\" using $db property in my extended class.\nBut I can find a workaround ;)\n. I have sorted out but I will send you a request. Thanks!\n. ",
    "dsquier": "Thanks for the feedback! I'll make the changes and submit a new request.\nFWIW, I think what broke the tests was the inclusion of the *.ddl file to build the MySQL tables. I put this in a \"config\"  sub-dir that I shouldn't have. \nSpeaking of which-- is a file like this even worthy inclusion, or better left out? \n. For #1-- gotcha and will do.\nFor #2-- will remove.\nAs to the config value changes-- they stemmed from the new value needed to store the refresh token table. Initially, I used \"refresh_token_table_name\" and renamed \"token_table_name\" to \"access_token_table_name\", but felt those were a getting a bit longer than necessary and figured \"_name\" could be dropped without loosing meaning.\n. Closing this request. Will resubmit to merge with development branch.\n. There actually is a place where it's defined, in Bootstrap.php:\n```\nprivate function createMysqlDb(PDO $pdo)\n{\n    $pdo->exec('CREATE DATABASE oauth2_server_php');\n    $pdo->exec('USE oauth2_server_php');\n    $pdo->exec('CREATE TABLE oauth_clients (client_id TEXT, client_secret TEXT, redirect_uri TEXT)');\n    $pdo->exec('CREATE TABLE oauth_access_tokens (access_token TEXT, client_id TEXT, user_id TEXT, expires DATETIME, scope TEXT)');\n    $pdo->exec('CREATE TABLE oauth_authorization_codes (authorization_code TEXT, client_id TEXT, user_id TEXT, redirect_uri TEXT, expires DATETIME, scope TEXT)');\n    $pdo->exec('CREATE TABLE oauth_users (username TEXT, password TEXT, first_name TEXT, last_name TEXT)');\n// test data\n$pdo->exec('INSERT INTO oauth_clients (client_id, client_secret) VALUES (\"oauth_test_client\", \"testpass\")');\n$pdo->exec('INSERT INTO oauth_access_tokens (access_token, client_id) VALUES (\"testtoken\", \"Some Client\")');\n$pdo->exec('INSERT INTO oauth_authorization_codes (authorization_code, client_id) VALUES (\"testcode\", \"Some Client\")');\n$pdo->exec('INSERT INTO oauth_users (username, password) VALUES (\"testuser\", \"password\")');\n\n}\n```\nI used as a starting point and made some changes to support my implementation; such as converting TEXT datatypes to VARCHAR or INT's, adding a table to support Refresh Tokens, stricter constraints, primary keys, and forcing InnoDB as the storage engine and UTF-8 as the characterset. \nIf you'd like to use it, it's here:\nhttps://github.com/dsquier/oauth2-server-php-DDL\n. > Another question: why in your example: https://github.com/dsquier/oauth2-server-php-DDL/blob/master/oauth.ddl the > field client_id is varchar and not int with (auto increment)?\nThis is to allow for alphanumeric client_id's. Some OAuth providers may want to assign client_id's that are more human-readable or maybe use hashes which both require characters and VARCHAR allows for that.\n\nAlso in the other tables, I noticed that you use primary keys to varchar. What is the reason?\n\nI'm not sure I understand the question. The short answer is: to prevent duplicates and optimize query performance. Whether a primary key is on a INT or VARCHAR (or most other structured datatypes) shouldn't matter.\n. Looking into why this failed the PHP 5.4 test.\n. In case others encounter this same problem, the root cause of not being able retrieve the access_token from the header turned out to be a (missing) .htaccess entry:\nRewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\nWithout this only basic and digest authentication were getting parsed. More details:\nhttp://www.php.net/manual/en/features.http-auth.php#107642\n. In terms of hijacking another user's redirect URI-- the following can be done for additional protection:\n- Enforce the \"state\" parameter using a nonce \n- Decrease the lifetime of the authorization code (though, 30 seconds is already quite low..)\nAnd since it's required by the spec, all communication should be occurring over TLS/SSL.\nThere is a good write-up of the various threats (including this one) in a separate RFC available here:\nhttp://tools.ietf.org/html/rfc6819#section-4.2\n. Good catch-- I had forgotten TLS/SSL was not required by the redirection endpoint.\nAs for enforcing a \"state\" parameter, I was thinking of the following (source: http://tools.ietf.org/html/rfc6819#section-5.3.5)\n```\n5.3.5.  Link the \"state\" Parameter to User Agent Session\nThe \"state\" parameter is used to link client requests and prevent\n   CSRF attacks, for example, attacks against the redirect URI.  An\n   attacker could inject their own authorization \"code\" or access token,\n   which can result in the client using an access token associated with\n   the attacker's protected resources rather than the victim's (e.g.,\n   save the victim's bank account information to a protected resource\n   controlled by the attacker).\nThe client should utilize the \"state\" request parameter to send the\n   authorization server a value that binds the request to the user\n   agent's authenticated state (e.g., a hash of the session cookie used\n   to authenticate the user agent) when making an authorization request.\n   Once authorization has been obtained from the end user, the\n   authorization server redirects the end-user's user agent back to the\n   client with the required binding value contained in the \"state\"\n   parameter.\nThe binding value enables the client to verify the validity of the\n   request by matching the binding value to the user agent's\n   authenticated state.\n```\n. This is perfect, thanks much!\nOn Friday, January 11, 2013, Brent Shaffer wrote:\n\nAccording to the spechttp://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-6,\nthe refresh_token grant type MAY issue a new refresh token:\nThe authorization server MAY issue a new refresh token, in which case\nthe client MUST discard the old refresh token and replace it with the\nnew refresh token.\nAs a result, I've added the option always_issue_new_refresh_token(defaults to FALSE) in the\nOAuth2_GrantType_RefreshToken class. So, by default a new refresh token\nis not issued, but you can easily configure this to do so.\nI am open to changing the default to TRUE\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/22#issuecomment-12164033.\n. I ran into a similar issue when trying to get token data to use with a verify closure. I ended up using getAccessTokenParameter. To C\u00e9dric's question of how to get the token, I did this:\n\n$request = OAuth2_Request::createFromGlobals();\n$access_token = $bearer->getAccessTokenParameter($request);\nDoesn't seem very intuitive to me, but it's working.\n. Ah yes, good point.\nAnd as far as changing getAccessTokenData to pass $request, I like that idea as well.\n. You'll likely need to make other changes to Pdo.php in order to integrate the library, so I'd just replace * with the columns required and alias id to user_id like you did, i.e.:\nSELECT id user_id, email, password, oauth_client_id FROM user WHERE email = :email\n. I've encountered similar problems with scope. I'm confirming it's not my storage implementation, but the way TokenController.php uses checkScope() does not appear to correctly enforce supportedScopes (i.e., it lets anything be requested.)\nIf the fix I'm testing looks okay, I'll file and issue and submit a PR.\n. Sounds good. I submitted another scope-related issue https://github.com/bshaffer/oauth2-server-php/issues/118 I'd like to get figured out before this one, which I'm happy to do.\n. @bshaffer Is there an example of when you would not want to pass client_id?\nI can't think of one offhand, but assuming there is I'd still propose adding $client_id = null as a parameter to getDefaultScope for consistency with the other methods (as well as distinct scope support per client_id).\n. A few comments:\n1) I agree that there should be unique keys on certain columns. I've done this for my implementation, but it adds dependencies for handling a primary key violation, which should be explored further.\n2) I'm not sure constraining all keys to 255-characters is the way to go. For columns such as access_token, refresh_token, and authorization_code, I'd prefer to match the column width to the token/code length generated by the library (i.e., 40 characters).\n3) I'm not sure what value backticks provide on table and column names.  In fact, I think they're dangerous to use in any DDL (similar to enclosing tables or columns with single tick or quotation) as some DBMSs will create the object literally and if a subsequent select against the column doesn't match the literal, you'll get an error. Here is an example from Oracle:\n```\nSQLPLUS>create table ab (\"a\" number, \"B\" number);\nTable created.\nSQLPLUS>insert into ab (\"a\", \"B\") VALUES (1,2);\n1 row created.\nSQLPLUS>desc ab;\n Name                  Null?    Type\n\na                              NUMBER\n B                              NUMBER\nSQLPLUS>select a from ab;\nselect a from ab\n       *\nERROR at line 1:\nORA-00904: \"A\": invalid identifier\nSQLPLUS>select \"a\" from ab;\n     a\n\n\n     1\n\n```\n~~4) Finally, I'd like to see any changes to the DDL move towards ANSI SQL standards. This would allow portability to other RDBMSs, such as Oracle, PostgreSQL, etc. I believe the data model is simple enough to conform to, say, ANSI SQL-92 without loosing any functionality.~~\n. FWIW, the DDL I am currently using is available at:\nhttps://github.com/dsquier/oauth2-server-php-mysql\nThere are some areas for improvement (i.e., conforming to ANSI SQL and a some refinement of scope storage), but it's working with the current development branch on the library without issues.\n. I wasn't correct in #4 bringing ANSI SQL into the picture. I should have left this out, but let me clarify.\nSince this is all table (and index) definitions, I doubt we'll be able to get something to work across more than one database, much less multiple ones. More importantly, there is no ANSI standard for DDL granular enough to define tables cross-platform. For example, Oracle wants VARCHAR2 instead of VARCHAR, while MySQL wants the opposite.\n. @bshaffer You are more than welcome to include, I'd be honored!\n. The JSON response is correct, as token_type is a required field per the OAuth spec:\nhttp://tools.ietf.org/html/rfc6749#section-7.1\nIs your concern that token_type is not being stored in oauth_access_tokens?\n. I also like this idea. I've actually done this in my implementation and have found it very helpful for segregating client access based on scopes.\n. How about storing \"permitted\" grants as a space-delimited string? This follows the convention used for scopes by the OAuth standard (and likely how it will be stored inside the database).\nThe other question would be how to handle null values. I tend towards null = \"grant all\" if only for simplicity.\n. FWIW-- The OAuth 2.0 Token Revocation at http://tools.ietf.org/html/draft-ietf-oauth-revocation-11 discusses how to implement some of this functionality, but since it's not part of the OAuth 2.0 spec, I'd agree with @bshaffer.\n. I've been working on this in my implementation. Here are the steps I took to implement client- and user-specific supported scopes and client-specific default scopes:\n1) Modify MySQL tables to store supported_scopes for client and user and a default_scope for client. You can view the table definitions here:\nhttps://github.com/dsquier/oauth2-server-php-mysql#tables\n2) Implemented ScopeInterface in Pdo.php and added getDefaultScope and scopeExists methods per:\n```\n    public function getDefaultScope($client_id = null)\n    {\n        if (!is_null($client_id)) {\n            $stmt = $this->db->prepare($sql = 'SELECT default_scope scope FROM oauth_clients WHERE client_id = :client_id');\n            $stmt->execute(compact('client_id'));\n            return implode(' ', $stmt->fetch(\\PDO::FETCH_NUM));\n        }\n        return null;\n    }\npublic function scopeExists($scope, $client_id = null)\n{\n    if (!is_null($client_id)) {\n        $stmt = $this->db->prepare($sql = 'SELECT supported_scopes FROM oauth_clients WHERE client_id = :client_id');\n        $stmt->execute(compact('client_id'));\n        $clientSupportedScopes = explode(' ', $stmt->fetchColumn());\n        $scope = explode(' ', $scope);\n\n        return (count(array_diff($scope, $clientSupportedScopes)) == 0);\n    }\n    return false;\n}\n\n```\n3) Modified scope validation logic in TokenController.php from:\nif (($requestedScope && !$this->scopeUtil->scopeExists($requestedScope, $clientId))\n            || ($availableScope && !$this->scopeUtil->checkScope($requestedScope, $availableScope))) {\n            $response->setError(400, 'invalid_scope', 'An unsupported scope was requested');\n            return null;\n        }\nto:\nif (!$requestedScope ||\n            ($requestedScope && $this->scopeUtil->scopeExists($requestedScope, $clientId)) ||\n            ($availableScope && $this->scopeUtil->checkScope($requestedScope, $availableScope))) {\n            return $grantType->createAccessToken($this->accessToken, $clientId, $grantType->getUserId(), $requestedScope);\n        } else {\n            $response->setError(400, 'invalid_scope', 'An unsupported scope was requested');\n            return null;\n        }\nWhen in doubt, I followed what the Memory storage used, but my implementation still lacks a few things, namely;\n- Support for per-user default scopes\n- Support for a global default scope (Memory does this via $defaultScope with $clientDefaultScopes for per-client defaults)\n- Ability to validate requested scope against the union of client and user supported scopes (Memory does this)\nLong Story Short-- I'd like to implement ScopeInterface into Pdo, so any feedback/direction you have would be greatly appreciated!\n. I don't believe this exists. I'm attempting to do the same for PDO here in https://github.com/bshaffer/oauth2-server-php/issues/208#issuecomment-22534770\nAny feedback is welcome.\n. Here you go :)\nhttps://github.com/bshaffer/oauth2-server-php/pull/217\n. No problem-- I will add a global default and supported scope and resubmit a PR. We can discuss the merits of the change in https://github.com/bshaffer/oauth2-server-php/issues/218.\n. Added, along with a few more tests.\nhttps://github.com/bshaffer/oauth2-server-php/pull/221.\n. My thinking was since all token requests require a client_id, we can simply define which scopes can be requested at one level-- the client. This assumes implementations pass client_id when using ScopeInterface, which currently allows nulls.\nThat said, I'm not convinced this is needed, but the thought behind it was to have a single point to configure scope access (vs. two) at the expense of a bit of data duplication as you add clients.\n. Sound good. Once I get mock storage with Travis tests passing I'll submit a PR.\n. @bshaffer I gather from your update yesterday that this is no longer needed?\n. Implemented in 12409e068bf6e9f6c47280a99b1e12c4c3f49bdf\n. If you can trust your web app, one way would be to define two clients;\n1) Client for Trusted Web Applications\nclient_id = webapp\ngrant_types = client\nsupported_scopes = 'webapp_scope enduser_scope'\n2) Client for End Users\nclient_id = enduser\ngrant_types = password\nsupported_scopes = enduser_scope\nThen, protect your API endpoints using scopes. Anything that a user would need to run would have enduser_scope. Anything that requires higher privileged tasks would have webapp_scope. By assigning both scopes to the webapp client it has full access, while the enduser client would only have access endpoints with the enduser_scope scope.\n. I would not recommend this. It seems generally accepted that client_secret is not really secret, or at least should not be assumed secure.\nSince the library authenticates a client by sending the client_id and client_secret from the client, it will likely need to be to be stored on the client. As a result, it is subject to inspection.\nI suppose you could store an encrypted version of client_secret on the client, but that only prevents someone from seeing the actual text of client_secret, not from using the string to authenticate.\n. It doesn't do this in PDO, and I'd guess it's this way across all storage. I think this is more an implementation detail than something required by the OAuth 2.0 spec.\nThat said, if this was to be considered I'd prefer to see it as a configurable parameter as opposed to the default storage behavior.\n. Old access/refresh tokens remain. If an expired token is used the library returns an error. You could clean them up by running the following on a regular basis:\nDELETE FROM oauth_access_tokens WHERE expires < now();\nDELETE FROM oauth_refresh_tokens WHERE expires < now();\nThis is different from how authorization codes work, which are deleted when exchanged for a token but remain if they expire before use. You could do something similar to clean those up.\nPersonally, it would be nice to have more configuration around token behavior, such as whether or not a refresh token can be reused. It would be even cooler to configure this on a per-client basis, but I'll defer to @bshaffer on if/how that belongs in the library.\n. Or, since there is already a getDefaultScope(), perhaps just add a getSupportedScope() to storage?\n. Yes, exactly. Would getClientDetails then return something like?\nreturn array(\n    \"redirect_uri\"     => REDIRECT_URI,     // REQUIRED redirect_uri registered for the client\n    \"client_id\"        => CLIENT_ID,        // OPTIONAL the client id\n    \"grant_types\"      => GRANT_TYPES,      // OPTIONAL an array of restricted grant types\n    \"supported_scope\"  => SUPPORTED_SCOPE,  // OPTIONAL space delimited list of scopes client can request\n    \"default_scope\"    => DEFAULT_SCOPE,    // OPTIONAL space delimited list of scopes client requests if none specified\n);\n. No worries-- you're implementation is more extensible anyway. Also, nice cleanup on the test setup.\nI'm going to add an index to support the join at https://github.com/dsquier/oauth2-server-php-mysql, which I've been maintaining to track the develop branch.\n. I can understand. I've run into similar issues, which is partly why I proposed removing global scopes in deference to client-only ones in a prior Issue.\nThat said, I also see the possibility of user-specific scope permissions for Resource Owner Password Credential Grant. It almost seems as if that was attempted with getScope() in UserCredentials.\n. Try this:\nhttps://github.com/dsquier/oauth2-server-php-mysql\n. I agree with the move of scope storage-- this is easier to understand and implement. I will update my application with this change and report back with any feedback.\n. Got this integrated with a bit of testing. Some initial feedback:\n1) The oauth_clients table has a new column default_scope. I've been unable to have it assign a default scope to a token request. If a scope is not explicitly requested it defaults to the value in oauth_clients.scope.\n2) We should probably update the setClientDetails in the various storage classes to support the new columns. It's currently;\nphp\nsetClientDetails($client_id, $client_secret = null, $redirect_uri = null, $grant_types = null, $user_id = null)\n@bshaffer Going to do some more testing and follow up.\n. Opened https://github.com/bshaffer/oauth2-server-php/issues/293 since this pull is closed.\n. @F21 Seems a good balance. If this allows for default and supported scopes on a per-grant basis, it gets to where I hoped to have the library support out of the box. To keep things simple, disregard the unioning of permissions. Allow each grant to be configured separately and in isolation. This would keep things simpler and lessen confusion if new grants are added.\n. @bshaffer I like that idea. It seems a consistent approach and would make adding scopes for new grants relatively painless.\n. @F21 Thanks! I will review PR when I get home tonight and follow up with comment.\n. @F21 I updated my test server with #320 and everything works as before.\nWe've been assigning client_id to a user for handling permissions, but I will drop that in favor of directly assigning per user via user.scope. So, this looks good to me!\nThanks, both @bshaffer and @F21 for your help.\n. @F21 Could we just store the default client scope in a new column in oauth_clients rather than create another table?\nI've made a few other suggestions in https://github.com/bshaffer/oauth2-server-php/issues/294 regarding scopes. I'd be interested to hear your thoughts.\nFinally, I maintain DDL for PDO storage at https://github.com/dsquier/oauth2-server-php-mysql. I will keep that in sync with whatever direction we go, in case it's helpful to you.\n. I like this idea. From a storage perspective, you could simply add a column for refresh_token (or parent_refresh_token) to oauth_access_tokens and you're done.\nAt larger scale, the ability to manage the token data set becomes more of an issue. This would allow better tooling to do that.\n. @Gerst20051 That's against the OAuth 2.0 spec:\n\n4.4.  Client Credentials Grant\n...\n4.4.3.  Access Token Response\n   If the access token request is valid and authorized, the\n   authorization server issues an access token as described in\n   Section 5.1.  A refresh token SHOULD NOT be included.  If the request\n   failed client authentication or is invalid, the authorization server\n   returns an error response as described in Section 5.2.\n\nThis was actually possible in this library in the past, but was removed to better adhere to the OAuth 2.0 specification per above.\n. As I understand it, username is for reference, user_id is the primary key for oauth_users.\nI maintain DDL for the PDO library at https://github.com/dsquier/oauth2-server-php-mysql and have tested it against the latest (1.4) release without issue. The DDL in this case being:\nCREATE TABLE oauth_users (\n  user_id              INT UNSIGNED   NOT NULL AUTO_INCREMENT,\n  username             VARCHAR(80),\n  password             VARCHAR(80),\n  first_name           VARCHAR(80),\n  last_name            VARCHAR(80),\n  scope                VARCHAR(4000),\n  email                VARCHAR(2000),\n  email_verified       BOOLEAN,\n  PRIMARY KEY (user_id)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\nI believe this was done to help link external user databases to the library via a shared key.\n. @aesculus That's a good idea. I'll try and put one together.\n. Good question-- It's intent is to associate a \"person\" to a \"client\", a way to represent a \"Client Administrator\", if you will.\nI'm not sure the library does anything with it.\n. @phindmarsh I ran into a similar issue and tried to document the case and work-around as part of updating the MySQL DDL for this library to the recent 1.7.1 tag, it's over here:\nhttps://github.com/dsquier/oauth2-server-php-mysql\nTL;DR Be careful when using scopes with multiple grant types (i.e., Resource Owner Password Credential)\n. The challenge with adding columns is where to draw the line between oauth_users and integrating with another (i.e., external) account database. \nIf you rely on the Resource Owner Password Credential Grant Type, using oauth_users is probably not the best approach since it offers very basic password protection (i.e., uses sha, no salts).\nIntegrating with a separate account database only requires changing checkUserCredentials() and getUser() in Pdo.php, which I'd recommend if you're deploying with the Resource Owner Password Credential Grant Type.\nSomewhat related, I maintain MySQL DDL for this library. I'll be updating to the 1.7.1 tag very soon.\n. @x-merlin-x I've done a similar implementation with \"Resource Owner Password Credentials\" (which I think you're referring to with UserCredentials, basically get a token based on user/pass authentication).\nI maintain the DDL for the PDO storage of this library here:\nhttps://github.com/dsquier/oauth2-server-php-mysql\nNote: there are limitations in how scopes and how the Resource Owner Password Credential grant type is implemented. Keep these in mind when using this library.\n. @Wilt Good catch. This was something I chose based on my implementation, but as you indicated, was too restrictive. The DDL repo has been updated.\n. The length was based on the size of the token generated from the library.That said, I don't see why it should be constrained to 40 characters. The spec doesn't specify a maximum length.\nI checked Quora and a dev from Facebook says \"not to limit the size\":\nhttps://www.quora.com/Whats-the-maximum-length-of-an-OAuth-access-token-key-secret-pair?share=1\nWhile I can think of edge cases to counter this (i.e., URL length limits when appending tokens), I mostly agree, especially given how tokens are often overloaded with other data. I'll update the DDL I maintain for this library (https://github.com/dsquier/oauth2-server-php-mysql) to reflect that.\nThanks, and just curious-- what are you doing to generate such a large token?\n. Thanks for the example! I've pushed the changes to the develop branch of the DDL repo: https://github.com/dsquier/oauth2-server-php-mysql/tree/develop\nI'll do some testing with this and submit a PR to the actual library once it looks good.\n. @nuffstuff Good point!\nGiven the downsides of MyISAM, I'm hesitant to use it these days. I've had to restore more than a handful of production databases due to MyISAM corruption.\nHowever, not indexing this column would surely cause performance issues as the table grows.\nGiven this, two options I see are:\n1) Set it to VARCHAR(767) and accept this as the hard-limit. This would accommodate the token size @biwerr provided, which is 697 characters long. This assumes the use of single-byte characters, which seems a reasonable assumption.\n2) Specify the innodb_large_prefix option, allowing for keys up to 3072 bytes. This is turned on by default in MySQL 5.7.7, but appears to be on schedule for deprecation.\nGiven #1 solves the current issues and does not introduce the uncertainty of a deprecated feature, I'd lean towards that.\n. @nuffstuff \nYes, I believe you are correct.\nPut another way, the default value is ON after 5.7.7 and will effectively remain that way going forward. \nGiven most(?) MySQL instances are < 5.7.7, opting for a larger column and ensuring folks on lower versions update innodb_large_prefix could lead to confusion. It also seems this parameter was introduced in 5.5.14, which might cause problems when attempting to set on versions below that.\n@biwerr \nI'll need to dig into the JWT format more to comment. I have not used that in my implementation.\n. Thank you for catching that. Submitted commit to fix.\n. ",
    "JellyBellyDev": "Thank you for your answer dsquier.\nI can not find the file bootstrap.php in the repository! :S\nI'm trying to create this authentication system OAuth in a project ZF1 + doctrine1. The problem is that I am not very clear right execution flow of calls. Would you be kind as to tell me that?\nthanks\n. Another question: why in your example: https://github.com/dsquier/oauth2-server-php-DDL/blob/master/oauth.ddl the field client_id is varchar and not int with (auto increment)?\nAlso in the other tables, I noticed that you use primary keys to varchar. What is the reason?\nThanks\n. Ok! Now is clear to me thanks!\nFor example, in my case, I'm creating the OAuth provider where to use app for ios and android! What is the right name to give to clients?\nclient_id: ios_asd\nclient_secret: 123foo456bar\nand\nclient_id: android_asd\nclient_secret: 123foo456bar\n?\n. ",
    "F21": "After more research, I have discovered that google uses JWT grant tokens.\nWould you be interested in having a grant_type of urn:ietf:params:oauth:grant-type:jwt-bearer added?\n. What are your views on the oauth library requiring third party libraries? I am planning to build a small library to decode/encode JWTs and what not, but it will be a general purpose library.\n. We have a few choices :)\n- Directly include it in the repository.\n- Use Composer\n- Use a git submodule.\nWhich one would be preferred?\n. I have gotten most of the code implemented for JWT support. The only problem is that the OAuth server always calls getClientCredentials to check if there is Basic Auth headers or client_id and client_secret in the GET parameters or POST parameters.\nThis is a problem, because JWT only requires me to send grant_type and an assert which contains the payload. The payload is then decode to get at the data inside.\nHave you got any ideas on how to modify the server so that it supports this condition?\n. One possible solution could be to add an extra method to OAuth2_GrantTypeInterface called checkAuthenticationHeaders().\nThis would then return true or false for each grant type. Then before calling getClientCredentials() in grantAccessToken() in the GrantController, we first call that method to check if the GrantType requires us to check the Authentication header.\nWhat do you think?\n. Hi there,\nFrom my understanding using JWT as an authorization grant is completely unrelated to using it as client authentication.\nIn this case (when using it as an authorization grant), we do not need any of the to check the authentication headers at all as per 2.1 of the spec. Since we can identify/authenticate the request by its signature. Salesforce provides a pretty good description of the steps to perform authorization grant using JWTs.\nIn this case wouldn't we still need to make a change so that the authentication headers are not checked?\nRe: modifying OAuth2_AssertionType\nI am not 100% what needs to be done here as I am still don't know my way around the code base very well. Would you be able to implement the required changes for that, so I can implement JWT as client authentication?\n. I am almost done with the JWT grant type (except for finding a way to ask the library to not check for the authentication headers). A lot of tests have also been written :)\nAre you happy with me adding a checkAuthenticationHeaders() to OAuth2_GrantTypeInterface? This will be called before the headers are checked and if it returns true, the headers are checked, otherwise they are not.\nLet me know what you think :)\n. Another thought: Since we will have a JWT grant type and a JWT client authentication, I think it makes sense to fully integrate the JWT library into the library (instead of having it as a composer requirement). This way, I can move all the code for verifying a JWT into the JWT library.\nLet me know what you think :)\n. I couldn't find anything in the spec about a token_type for JWT though. It seems that for JWT we still use a token_type of `bearer.\nHaving said that, if the token_type was to be passed in via $config in the __contruct()  of server.php, we would not be able to ask the server to serve requests for multiple token_types.\n. Oh, and the example in the spec shows that we can only identify the JWT Authorization grant request using the grant_type parameter:\n```\nPOST /token.oauth2 HTTP/1.1\n     POST /token.oauth2 HTTP/1.1\n     Host: as.example.com\n     Content-Type: application/x-www-form-urlencoded\n grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer\n &assertion=eyJhbGciOiJFUzI1NiJ9.\n eyJpc3Mi[...omitted for brevity...].\n J9l-ZhwP[...omitted for brevity...]\n\n```\n. I guess I don't know my way around the code base very well at the moment, so I apologize for the confusion :)\nFor now, let's just talk about the JWT Authorization grant and not using JWTs as client authentications. We will get to that once Authorization grant has been implemented.\nFrom my understanding, we do not every need to send a request to the /authorize endpoint when we use JWT Authorization Grant. Out of band, we exchange either a client_id and a shared_secret or we generate a client_id and public/private key pair. We then store the public key and send the private key to the client (note that we never store the private key).\nTo get an access token, the client simply generates a JWT token as per the spec (which is just a bunch of rules for encoding a JSON representation) and generates a signature. The signature is signed by using either the shared_secret or the private key. The JWT is then sent to then endpoint as the assertion parameter.\nThis is sent to the /token endpoint like so:\n```\n     POST /token HTTP/1.1\n     Host: as.example.com\n     Content-Type: application/x-www-form-urlencoded\n grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer\n &assertion=eyJhbGciOiJFUzI1NiJ9.\n eyJpc3Mi[...omitted for brevity...].\n J9l-ZhwP[...omitted for brevity...]\n\n```\nWhen the server receives the request to /token, it checks the grant_type and loads the appropriate GrantTypeClass to process the request and return an access token.\nThe catch here is that the request should only contain 2 parameters: grant_type and assertion. There should be no other headers (authentication or anything else).\nWhat the server does, is first decode the assertion's JWT to find the iss property in the token. This iss (issuer) should contain a client_id. The server then looks up up this client_id to find the shared_secret or public key associated with it. The server then verifies the signature that was encoded with the shared_secret using the shared_secret, or if public/private keys are used, it verifies the signature using the public key, since it was encoded using the private key.\nThis step establishes (authenticates the client) since it verifies his identity. We then move on to check the other properties of the JWT, for example, the expiry, the audience (which is the URL of the OAuth Endpoint) and various other properties.\nIf all the checks pass, then we issue an access token without a refresh token. Once the token is issued, the client can use the token to gain access using the /access endpoint  just as if the access token was issued using any other grant type.\nIf the access token expires, the client then generates a JWT again (with a new expiry time, etc) and asks the /token endpoint for a new access token.\nNow, the problem is this:\nThe /token endpoint would call the handleGrantRequest() method in Server.php.\nThis then calls handleGrantRequest() in OAuth2_Controller_GrantController which then calls grantAccessToken().\nThe problem is that grantAccessToken() always calls $this->getClientCredentials() and checks if it returns a NULL. If it does, it assumes the request is bad or malformed.\nIn the case of a JWT token, we never send any authentication headers or any client credentials in the body. These things are actually inside the JWT token, which we process in the JWTBearer GrantType class (I have called it OAuth2_GrantType_JWTBearer in my implementation).\nTherefore, in order to deal with it, we will need to be able to have $this->getClientCredentials() either return a non-null response if the request is a JWT Authorization Grant (by checking grant_type) or not call to $this->getClientCredentials() if the request is a JWT Authorization Grant (by checking grant_type).\nThe question is, what's the best way to achieve the above while getting everything to be decoupled and clean :)\nI hope that clears things up and I apologize for the long-winded response. Let me know if I have made any mistakes :)\n. I think that sounds perfect! Definitely a lot cleaner than checkAuthenticationHeaders() I was proposing. Can you implement this and do a commit?\nI can then pull and merge then implement this on my end.\nAlso, what are your thoughts on just embedding the JWT library into the library? It is currently just 1 class anyway, and I feel that I can move all the JWT checking (expiry, audience, etc) into the JWT class which we can also call when we implement JWT Client Authentication down the track. :)\n. I think let's just add the extension grant straight in for now. I am assuming that to implement the plugin architecture, lots of refactoring will be required, which is not exactly trivial. I am happy with adding it straight in for now, and when the plugin architecture is done, we can refactor the code. Much of the code in the extension grants  should not require too much refactoring anyway.\nI will see what I can do and try and get a pull request out soon :)\n. Done in #25. So Closing.\n. Updated :) Hopefully everything's fine now :)\n. I think php-cs-fixer went and touch a lot of files to convert them to psr standards. I am going to revert back to before php-cs-fixer and start from there.\n. I tried a revert and things started breaking :(\nWhat I have done:\n- Made a copy of my own working copy.\n- Nuked my own fork.\n- Reforked.\n- Replaced the files that only applied to the change for JWT tokens.\n- Implemented getClientDataFromRequest() and validateClientData() in OAuth2_ClientAssertionTypeInterface.\nWhat I will then do is runphp-cs-fixer on the files I have updated only.\nThe only flaw is that if you run php-cs-fixer without explicitly telling it what to fix, it will also run some non-psr fixes which were designed for symphony.\n. I just tried with --dry-run to test and it seems to have touched a lot of files (even the ones I have not touched).\nThere also seems to be an issue with one of the class files:\n! The class OAuth2_GrantType_AuthorizationCodeInterface in /www/oauth2-server-php/src/OAuth2/ResponseType/AuthorizationCodeInterface.php does not match the file path according to PSR-0 rules\nShould I instead do a pull request that consists of the commits for JWT and a commit for the fixed files?\n. This travis-ci build also seems to be stuck: https://travis-ci.org/bshaffer/oauth2-server-php/builds/4175697\n. @ksnyde This looks like the class could not be found. Make sure you include the autoloader to load the classes from the library. See https://github.com/bshaffer/oauth2-server-php#installation\nAlternatively, the library is PSR-0 compliant, so if you have a PSR-0 autoloader you can use that.\nOr, if you are using composer, composer should generate a valid autoloader, so you can use that too.\n. This is not picky at all. I myself prefer libraries that are coded to certain standards and conventions, instead of ones that are all over the place and looks slapped together by multiple committers :) After all, I will be using this library in production myself and would need to revisit this in the future :)\n. All pushed :) Let me know if I have missed anything :)\n. Did you mean the if($clientData)...? That should be in dcbc06a.\n. I just saw you pushed some changes. I am going to merge them first on my end.\n. I seem to have messed up the merge. I need to read up on rebasing. So, here's just the commit with fixed formatting.\n. Before I start on this, what do you think about implementing the plugin architecture as mentioned earlier before doing this?\n. @bshaffer Just revisiting this (its been a while!).\nLatest spec for JWT is here.\nFor JWT client authentication, it is basically piggy backing on the authorization_code grant type. So we can either put the code for that into the AuthorizationCode grant type or perhaps provide some modular approach.\nI personally favour a more modular approach, but am unsure how this can be done. Any ideas :smile: ?\n. @bshaffer I will have a look at it over the next few days (pretty busy atm) and get back to you :smile: \n. Thanks to @bshaffer, ClientAssertionTypeInterface is implemented, client authentication is now supported. Now, we just need to find a way to pass this to the Server.\n. Definitely submit a pull request for this :) I would love to see this improvement in the library too.\n. After looking at the getAccessTokenData(), I think you have a good point. I think it would be nice if it is updated to require a $request instead of the token as part of its arguments:\nphp\n$data = $server->getAccessTokenData($request);\n. Have been thinking about this. Changing this to $request would break backwards-compatibility. Perhaps an easy way out would be to let verifyAccessRequest() return false if the token does not exist, or is expired, etc. But instead of returning a true if everything is fine, return the token. This would then not break backwards-compatibility with people who are using this library.\n. Maybe instead of just returning the token, make verifyAccessRequest() return the whole token data. Since verifyAccessRequest() will fetch the whole token data anyway, it kind of makes sense to pass it onto the user of the library, instead of having him call getAccessTokenData() which would hit storage again. Then it is up to the library user to do his own caching to keep the data, or to store the token and use getAccessTokenData() later to fetch the token data.\n. Another idea I have is to create a method called verifyAccessRequestAndGetData(), this would verify the access details and return the token data if everything goes well. Otherwise it will return a false. This will prevent verifyAccessRequest() breaking for people who do this:\n``` php\n$verified = $server->verifyAccessRequest();\nif($verified === true){\n}\n``\n. @bshaffer, How do you feel about this? I am happy to make the changes to the code (as I kind of need it for something I am working on). Which approach would you prefer?\n. @bshaffer: Cheers :) I will send a pull soon :)\n. ByGrantTypeclass do you meanGrantTypeInterface.phporGrantType\\JWTBearer.php?\n. PR #35 only addresses the php docblock documentation. README still needs to be updated.\n. Test added and some minor improvements.\n. I have just removed the check to see if the storage implements theClientCredentialsInterface, because grant implementations like JWT uses theClientAssertionTypeInterfaceand do not need the methods defined inClientCredentialsInterface.\n. Strange that the build failed. I will get this fixed asap.\n. Looks like in PHP 5.2 on travis-ci, openssl is not available. On 5.3, OPENSSL_ALGO_SHA256 is not available :(\n. This is because due to incompatibility problems, openssl is [disabled on PHP 5.2](http://about.travis-ci.org/blog/upcoming_ubuntu_11_10_migration/#OpenSSL).\n. Now, for PHP 5.2, we test using a symmetric algorithm such as SHA-256 instead of a public/private key pair, since openssl is not available in PHP 5.2 on travis-ci.\n. I just had a sticky beak at facebook's implementation and it looks like in their case, they will actually send you the existing token again if you request it again and the token is not expired.\n. @bshaffer: Yes, perhaps we can mimic FB's implementation. How would you suggest this be done? Just a parameter in the$config` array in the constructor of the server?\n. @bshaffer Would like to have a crack at this. What are your views on implementing this?\nLooking at https://github.com/bshaffer/oauth2-server-php/pull/122, we would implement a check to see if the token exists and return the old token in createAccessToken() in ResponseType\\AccessToken. Is this still the case?\nShould this behaviour be the default behaviour? Should there be a configuration flag to turn this on and off? I see that the Server class has some functionality to set/get configuration. However, this is not being passed to the TokenController at all.\nFinally, I am thinking that we should have a \"fuzzy parameter\" with a default of say 20 seconds. If the token expires 20 seconds from now, we return a new token instead.\n. Yup, that's because PHP 5.2 does not support openssl on travis-ci. I thought that should be fixed with the pull that checked the version (in the last merge) and used a symmetric algorithm for generating the JWT on PHP 5.2, but the build failed.\nI am just waiting for this pull to build to see if it passes, because I don't have PHP 5.2 on my VMs.\nBuild for this pull: https://travis-ci.org/bshaffer/oauth2-server-php/builds/4343292\n. Yay, the build passes :)\nMust have been an issue with detecting the PHP version.\n. I agree with this approach. First let's deal with the case where writing to storage has failed. What do you think is the best approach here: throw an exception, or to just return a failure message to the client?\n. It's been quite a while since I worked with PDO directly (I have been working exclusively with an ORM library called RedBean), so please let me know if I have got things wrong :)\nIn OAuth2_Storage_Pdo under setAccessToken(), the result of $statement->execute() is returned:\nPHP\nreturn $stmt->execute(compact('access_token', 'client_id', 'user_id', 'expires', 'scope');\nDoes execute ever throw an exception?\nIf we were to throw an exception in the storage, then we need to make sure that the implementer of the storage driver actually throws an exception on error (which I don't think there's an easy way to enforce). However, if we just check the return value of setAccessToken in createAccessToken, and return an error message to the client when the return value is falsy, then if the implementer forgets to return anything, the access token would never be created, and upon some investigation (hopefully through comments in the storage interfaces), he would discover that he forgot to return a value.\n. That sounds great! Looking forward to it :)\n. This is basically what I was wondering in #42. I have looked at the spec, but it does not give us any guidance as to the correct behaviour so the current behaviour should be \"fine\", I think.\nHaving said that, if we were to copy Facebook's implementation, we should probably do this: \n- If the existing token has not expired, return it.\n- If a new token is needed, delete the old token in the storage.\n. @bshaffer Good point :) I will sort that out on my fork :)\n. Unfortunately, an exception is not thrown. A warning is raised, so even wrapping the code in a try catch block will still cause the warning to be outputted.\nThe warning I am talking about is something like: supplied key param cannot be coerced into a public key. This happens when the public or private key provided is not in the correct format.\nIn any case, we do not really care whether the public key is valid or not, only the fact that we can verify the signature is important.\nSee this example code for the warning being thrown even though we have wrapped it in a try-catch:\n``` PHP\nvar_dump(openssl_verify('123456', '123456', 123456, 'sha256'));  //Causes a warning to be raised. returns false.\ntry {\n   var_dump(openssl_verify('123456', '123456', 123456, 'sha256')); //Also causes a warning to be raised. returns false.\n} catch (Exception $e) {\n    var_dump($e); //never executed\n}\nvar_dump(@openssl_verify('123456', '123456', 123456, 'sha256')); //No warning, returns false.\n```\nI was never a fan of using @ and use it very rarely in my applications, but I think in this case, it is appropriate as it may be beyond the scope of the library to set a set_error_handler().\n. That sounds like a possible solution as well :) However, perhaps it might be a bit overkill just to avoid the @, as a warning in this case would just return a false which is what we need.\nAnyone else have any thoughts on this?\n. @bshaffer, when an invalid key is passed to openssl_verify, a warning will be thrown.\nIt expects keys in this format:\n-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC/yMgbkPnOnrXt\n....\nFnh+zeEVijg18pMvVScrBw==\n-----END PRIVATE KEY-----\nIf for whatever reason, a corrupted version was stored by the storage driver or the key is tampered with, then a warning will be issued. In my previous comment, I passed 123456 to the function as the $key, which is invalid. This resulted in the openssl_verify function throwing a supplied key param cannot be coerced into a public key warning.\n. I just had a look at the openssl extension and it does not seem to provide any means to do so :(\n. That's a good point :) I will get a pull out soon :)\n. This can be closed :smile: \n. Usually this might mean you have a scope called update_user_details. When the client requests a token, it requests with the update_user_details scope, which gives it permission to update the user's details on Lock'din. \nLock'd in then has an API of some sort (REST, RPC, etc), and you then make a call to POST api.lockedin.com/user/user_id/ with perhaps a JSON document or some other representation to update it. Locked in would check to see if you have update_user_details scope in the token before it updates it.\nOAuth does not update or make changes to any of your data. It merely provides an authorization framework for you to say: give the DemoApp access to this user's data (modify/delete/update, etc) in the locked'in application without them having to give DemoApp their username and password. As for using the OAuth token to \"do stuff\", you need to implement an API in your app.\n@bshaffer's #56 allows you to implement this really easily as well :)\n. Sorry for the late reply guys!\nReason I changed that was to not force the client_credentials storage because if the oauth server is to only implement the JWT grant type, the client_credentials interface does not need to be implemented.\nHope that clears things up :)\n. @bshaffer: In that case, how about reverting 025b77a and 36b7c4c as well?  Since we are forcing storages to implement client_credentials, we can use it to enforce type checking.\n. @bshaffer: There shouldn't be any breakage because the tests use the Memory or PDO storage drivers and they both implement the ClientCredentials interface :)\n. Found the problem and just updated the code :)\n. Beautiful! Very looking forward to this! :)\n. I agree with @mariano and @Rockstar04. In production, I would do the logging from my own code and have an ExceptionHandler on a global basis to catch any uncaught exceptions.\n. After more investigation, what if we just pass some data about the request to getSupportedScopes? In this case, getSupportedScopes would just return a list of valid scopes depending on the grant_type, the client_id or some other info?\n. Hmm. But the problem with the \"simple\" approach is that we will not be able to get the client_id and other request info in the case of the JWT grant type. In this case, we will only be able to get the grant_type and assertion as the JWT is only decoded in the JWTBearer grant type.\nSo perhaps we do need a validateScope(), but we pass $request and the result of getTokenDataFromRequest to it.\n. Yes! That's what we need! I must have missed getClientDataFromRequest() when I was looking at the code yesterday :p \nHow about passing $request to getSupportedScopes() as well? Or do you think we should do a bit of refactoring to include the grant_type to the array returned by getClientDataFromRequest()?\n. Another thought: While we are at it, do you think we should also pass those things to getDefaultScope()? We can increase the flexibility by allowing different default scopes for different client_ids and user_ids etc.\nReason I considered passing $request is that it would be quite useful if we want to return different scopes depending on the grant_type. Is there any other way to get the grant_type without having to use $request?\n. That's a good idea! Since custom Scopes  can be implemented by using the ScopeInterface, things are quite customizable. :)\n. This seems to still be failing though.\n. From my understanding (my last PR was a few months ago), it is up to the grant type whether it should include a refresh token or not. For example, the JWT grant type I worked on does not issue refresh tokens, and that is set appropriately in JWTBearer.php. \nFrom a quick look at the code, it looks like this functionality does exist: In createAccessToken() of AccessToken.php, there's a check that only sends a refresh token if the refresh token storage is available.\nThen, when you instantiate a server, you pass in an associative array for the storages:\nPHP\narray(\n   'access_token' => new Access_Token_Storage,\n   //etc\n)\nIf you omit a storage called refresh_token, then refresh tokens won't be issued.\nIf however, you have just one storage driver that contains interfaces to everything (like the pdo driver), then, you could perhaps do something like this (untested :stuck_out_tongue: ):\n``` PHP\n $storage = new OAuth2_Storage_Pdo;\n$mystorages = array(\n    'access_token' => $storage,\n    'authorization_code' => $storage,\n    //etc (just omit the key for refresh token)\n );\n$server = new OAuth2_Server($mystorages ....\n```\nThis allows you to easily pick and choose what storage types your server supports :)\n. Looking at other controllers in the library, a successful response is not stored to $this->response, only errors are.\nWhat's your use case for this?\n. Should be closed by PR #92 \n. Whoops. My bad. I have reverted it on my fork as well.\n. @aacotroneo Unfortunately, no. Would love to see a PR if you're interested! :smile: \n. This looks awesome to me, so a +1 from me! :+1: \nA quick suggestion: \n- Add PHP 5.5 to the tests, since a final would be out in a few months time, it may be beneficial to see if the library works on it.\n- Possibly remove support for PHP 5.2 since the last release was in 2010 and people are encouraged to upgrade to 5.3.\n. Awesome! Thanks for the refactoring! :smile: \n. Agreed! And even PHP 5.3 is going to be EOLed soon with the release of PHP 5.5, so I think it's a good time to do this :smile: \n. On a related note, would you like to enable testing against PHP 5.5 in travis? 5.5 is entering RC at the moment, and I think it would be nice if we could test against it to catch any problems that might occur against 5.5 (not that I expect any problems).\n. Can you add a test for this? :smile: \n@mmdumi To fix most of the problems, I recommend using php-cs-fixer (it fixers most of major formatting problems, but not everything).\nRun it with the following command:\nphp-cs-fixer fix /path/to/the/file --level=psr2\n. I think this is a good idea! :smile: Are there any specs so that we can have a implementation that is standard?\nAnother thought: If I were able to reverse engine/disassemble your app to get the private key, wouldn't I still be able to launch attacks against your server?\n. Cheers @bshaffer.\nI will get a PR out with some tests :smile: \n. Looks like the MemoryStorage will need some refactoring for scopeExists() as it does not use the client_id in its checks.\n. Currently, the supportedScopes in the Memory storage is just a simple array: ['scope1', 'scope2']. What are your thoughts if we change the structure to an associative array:\n[\n  'clientId1' => ['scope1', 'scope2'],\n  'clientId2' => ['scope3', 'scope4'],\n  'any' => ['scope5']\n]\nThe flaw with this approach is that a clientId called any would cause issues. Any ideas appreciated :)\n. Another possibility is to introduce a separate parameter for scopes specific to a client id called client_supported_scopes. I think this is the approach I will use.\n. @bshaffer Is this still relevant? If not, we should close this :smile: \n. Looking good! :smile: \n@bshaffer Can this be merged?\n. Could you post a simple php script to reproduce this? This makes it easier for us to investigate and push a fix :smile: \n. @bshaffer I would love to submit a PR, but would like some input on how we should expire the jti. The spec says that the jti cannot be reused for the duration of the exp parameter (once it has been used).\nHowever, the question is how unique the jtis have to be. For instance, we can have a simple implementation where we have a list of jtis with their associated exps. Any jti that is on the list and not expired and reused will be denied.\nHowever, we can also make it a bit \"smarter\" by linking the jti to the iss, sub, and aud parameters. So, for a jti to be denied, all of those parameters must match and the token should not be expired.\nOnce we have decided how to deal with that, implementation should be quite trivial.\nCheers :smile: \n. @bshaffer Let's reopen this for some further discussion as I think I would like to push an update to this.\nUnfortunately, the spec doesn't give any guidance on how the JTIs should be generated:\n```\n\"jti\" (JWT ID) Claim\nThe jti (JWT ID) claim provides a unique identifier for the JWT. The identifier value MUST be assigned in a manner that ensures that there is a negligible probability that the same value will be accidentally assigned to a different data object. The jti claim can be used to prevent the JWT from being replayed. The jti value is a case-sensitive string. Use of this claim is OPTIONAL. \n```\nSo, the following approaches for generating a nonce may be considered valid:\n- Have a counter that increments the nonce for each new jwt generated.\n- Use the current timestamp as the nonce.\n- Use the md5 hash of the jwt.\nThe above would cause collisions if 2 clients use the same scheme for generating the jtis.\nSince the jtis are generated by the client, there is no way we can control their implementation.\nI would like to modify the storage implementation to the following:\nphp\npublic function getJti($client_id, $jti, $jwt)\nphp\npublic function setJti($client_id, $jti, $jwt);\nInstead of passing the jwt parameters to the storage implementations, we are passing the client_id jti and the decoded jwt.\nThis means that we could hopefully steer implementations to do the following:\n- Match only jtis with client_ids. This prevents clients using simplistic nonce generating routines to affect other clients.\n- Provide the decoded jwt, so that if required, the implementer can produce some sort of hash of the jwt to compare against if he feels he needs each nonce to be unique on a JWT basis.\nI recommend something like this for generating the jti, but since the spec does not give any guidance, pretty much any generating method is valid:\nphp\n$random_number = ... //generate using openssl_random_pseudo_bytes\n$jti = hash('sha256', serialize($jwt) . $random_number);\nIn conclusion:\n- Encourage storage implementers to check for nonce collisions on a client_id basis. One client's nonce should not affect another's. This is good practice in my opinion.\n- If required, the jwt is provided if the implementer wants to check for jtis on a JWT basis.\nWould love to hear your feedback on this! :smile: \n. @bshaffer Formatting has been fixed. I also added stubs for the Mongo and Redis driver so that the tests can run. Unfortunately, I don't know MongoDB or Redis to implement those. I hope someone can pick that up and get that implemented.\n. @bshaffer Thanks for the feedback! :smile: \nI have fixed the formatting issues.\nRegarding the way I implemented the JTI, the reason is to minimize nonce collisions.\nFor example, my JWT looks like this:\njson\n{\n   \"iss\": \"admin@service.com\",\n   \"sub\": \"peter@service.com\",\n   \"exp\": 12345678,\n   \"aud\": \"https://service.com/auth\",\n   \"jti\": \"SDIF02jraf90SDFJKO\"\n}\nThe JSON object encoded first and then signed using the private key as per the spec: http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html\nBecause the JWT is signed, it is impossible for an attacker to modify the JWT and still have the signature verified.\nThis means that the following JWTs (note the JTIs are the same) are valid once, because we treat the JWT as one discrete object:\njson\n{\n   \"iss\": \"admin@service.com\",\n   \"sub\": \"peter@service.com\",\n   \"exp\": 12345678,\n   \"aud\": \"https://service.com/auth\",\n   \"jti\": \"SDIF02jraf90SDFJKO\"\n}\njson\n{\n   \"iss\": \"admin@service.com\",\n   \"sub\": \"peter@service.com\",\n   \"exp\": 98765432,\n   \"aud\": \"https://service.com/auth\",\n   \"jti\": \"SDIF02jraf90SDFJKO\"\n}\nThis reduces the chance of a jti collision happening and is still secure because the whole JWT is signed. The attacker will not be able to modify some parameter and replay the request.\nHaving said that, the implementation does afford flexibility on how library users want to deal with this. Because all the parameters are passed to getJti(), the user can check the nonce on a JWT basis (as per my sample implementation in the PDO driver), or if desired, he can check for the nonce on a global basis (against all submitted JWTs).\nHope that clears things up! :smile: \n. @TomHAnderson \nJTIs are optional as per the spec. See point 7 in section 3.\nThe spec also mentions that the jti cannot be reused for until the JWT expires, so we need to keep it in the database.\nI don't see where the JTI is being ignored.\nThe spec says that the JTI parameter is optional, so that's why all calls are allowed (whether they include a JTI or not). Maybe a configuration parameter can be implemented so that JTIs are required.\nHope that helps! :smile: \n. I think this is a nice feature to have. However, at the moment, I only have JWT and authorization_code clients and each grant type has their own set of scopes.\nTherefore, I hope the implementation will also allow us to turn off the unioning of scopes.\n. After thinking about it, it think this is unnecessary.\n@dsquier Could we just have all the scopes in a scope table with maybe some identifier to say what category this scope is in? Maybe we can just leave this to people who implement custom storages?\n. That was in the PR I closed: https://github.com/bshaffer/oauth2-server-php/pull/304\nWhat's the consensus regarding this? The other option is to push the implementation to the user of the library and provide him with a bit of data to work with: https://github.com/bshaffer/oauth2-server-php/issues/312\n. @bshaffer Any more comments on this? This is sort of in a state of flux for our app. We are currently on 1.2 but would like to update to the latest develop. But to do so, we need to get this sorted first.\n. @dsquier I have a PR to pass the client_id to getDefaultScope() in #320. That will allow implementation for some of these things by lib users, however, we have not found an easy way to pass the grant type to getDefaultScope() and friends. If you have some suggestions of a suitable parameter to pass, do tell us :smile: \n. @dsquier More revision to that PR as per @bshaffer's request. Currently, we only pass client_id to getDefaultScope() and that should allow people to implement some of these things. However, to implement the others, we will need to pass more parameters to those methods.\n. @dsquier Thanks for your comments :) The only thing that's missing is not having a way to assign different scope based on the grant type. At the moment, that's not something I require in my app, so I can't really think of a clean way to do this.\n. Hey guys, I implemented JWT bearers early last year, so things could have changed.\nThe spec I used then was: http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-01\nWhere the spec was not clear, I followed google's implementation: https://developers.google.com/accounts/docs/OAuth2ServiceAccount\n1. The userId is whatever you use in your application. Some application use a username (wordpress) other uses email addresses (facebook). It's entirely up to you and both are equally valid. \n2. In google's implementation, each subject was given a separate key. That's what I have done in the implementation. Personally, I feel that this also affords some flexibility. If you feel that you need to have keys for each subject, the ability is there, but if you don't need that functionality you can ignore it. For me, having separate keys for each client to subject pair makes sense, because we are treating the whole JWT as a unique unit.\n. @luxifer: I agree. Clients should be able to have 1 key and impersonate other clients via the subject parameter.\nThe default storage implementation for the getClientKey() method in the storages interface unfortunately searches for a unique key for each client/subject pair when I implemented the JWT Bearer token a while back.\nHowever, all is not lost! If you are using a custom written storage, simply use getClientKey() to check to see if the client can impersonate the subject and then return the client's key. If you are using the provided storages, a quick workaround would be to extend the storage class and override getClientKey().\nI am currently a bit busy, but it would great if anyone can make this change to getClientKey(). This will also introduce some changes to the database schema resulting in breaking BC, but migration should not be too painful.\n. You shouldn't just be checking the client_id though, you should check to see if client_id can impersonate the subject.\nIn any case, do you think you can submit a PR?\n. @valheranze It's called client_id() to maintain consistency with other grant types in the library. This is the spec we are using: http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-09\n. @valheranze I am not familiar with the open id spec for JWT tokens, but the spec you linked to shows that the implementation is correct:\n```\niss REQUIRED. Issuer Identifier for the Issuer of the response. The iss value is a case sensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components and no query or fragment components. \nsub REQUIRED. Subject Identifier. A locally unique and never reassigned identifier within the Issuer for the End-User, which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed 255 ASCII characters in length. The sub value is a case sensitive string.\naud REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an audience value. It MAY also contain identifiers for other audiences. In the general case, the aud value is an array of case sensitive strings. In the common special case when there is one audience, the aud value MAY be a single case sensitive string. \n```\nThe JWT bearer token and open id implementation are 2 separate things. I do agree its confusing that open id's JWT and JWT bearer uses different things for the JWT's components.\n. @valheranze I have not used the Open ID implementation, but I assume that you will need to use the AuthorizationCode GrantType located in https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/OpenID/GrantType/AuthorizationCode.php\ncc @bshaffer Can we have a cookbook for open id in the documentation?\n. @bshaffer It appears this is the spec being used: http://openid.net/connect/ :smile: \n. Thanks for the explanation! It makes things much clearer now.\nBummer that we can't have client specific scopes though as it is something we are using in our app. Was this due to the spec?\n. also, it appears issues can't be reopened :smile: \n. After having a look at the code, I think I can inject the request object into my storage class and query the client_id and go from there to implement different default scopes per client_id. However, that seems very hacky to me and I am not comfortable doing that.\n. Yes, I think if that is the case, then it certainly makes sense to move getDefaultScope() to the ClientInterface. If you are happy with that, I can try and get a PR out :smile: \n. @dsquier Thanks for the feedback! I placed the default client scope it its own table because @bshaffer removed them from oauth_clients in 7f1211cc51955650366684addbf460b4afe85936.\n@bshaffer Is it alright if I reinstate the default client scope in the oauth_clients table?\nThanks for the link to your repo! Certainly beats trying to work out what tables are created by just looking at the code! :smile: \n. Hi Brent,\nSorry for the confusion :smile: It there's a way to achieve the following without it being in the library's core, do let me know!\nIn my scenario, I am using the JWT grant type to get an access token. In this case, if we do not pass in a scope, I would like to be able to assign a default scope to the client on a per client basis. However, the problem is that there doesn't appear to be a way to do this. The request is sent to the token controller and since no scope was provided, the default scope is retrieved using getDefaultScope(). \nThe thing is that in our system, we have a few client types. For example, we have a system service type which is used to call system level jobs such as cleaning up temp files etc on the server. We also have other client types that actually use the services provided by the system.\nIn cases where clients do not pass in a scope, we do not want the system service client type to have a default scope that contains access to the services. If the client type was a normal client type, we do not want them to access system level services.\nBecause these are all internal services, it makes it easier if we do not need to define scopes on the clients and instead, if we make changes, just have them happen on the service's side.\nHope that makes sense.\n. Yes, that's something we have considered, but it introduces complexities for us, since our clients and the api are all internal, they are \"trusted\" to some extent. We would like to avoid requiring clients to provide a scope and just update the default scope when adding services on the services side.\n. I have moved the client specific scopes to the clients table.\nI would love to hear what others think of this feature. Your comments and feedback is highly appreciated! :smile: \n. @bshaffer That's certainly a way to do it and seems like the way to go. There are still some questions, but I will create a more specific issue for that.\n. Reopening for further discussion.\n. I think passing grant_type is a good idea. I haven't considered that, but it can be quite useful for client implementations.\nSo basically, have those parameters available in the storage interfaces and leave them out of the concrete implementations like PDO, Redis etc? It should be quite trivial to get this PR updated.\n. Closing this in favour of #320.\n. You might have to rebase against the develop branch as we have made some changes to the signature of getDefaultScope().\n. I implemented the functionality for scopeExists() because you mentioned it in: https://github.com/bshaffer/oauth2-server-php/issues/294#issuecomment-32264814\nI personally don't have any need for that (atm), so am happy to remove it.\nAs for passing the response_type, that may be an issue, because that parameter is not available in the TokenController, so it's sort of one or the other. Is there another more generalized parameter we can pass in?\n. Sounds good. :smile: I will finish up this PR and get it out to you soon.\nI guess when the need arises, it will be easier to determine what needs to be passed in.\n. @bshaffer Do you also want me to remove the client_id parameter from scopeExists()?\n. @bshaffer All done! :smile: \n. @bshaffer Good catch! This should do it :smile: \n. This looks good to me! :smile:\n. @svycka I agree, the BC breaks are annoying, but some of the initial decisions (for example some of the choices I made when first implementing JWT) were not so good, so they have to be fixed :smile: \nThere is a CHANGELOG.md It hasn't been updated for 1.3, but perhaps @bshaffer will do that soon. My suggestion (if this is not being done yet), is to prefix or postfix a [BC] for changes in the change log that breaks compatibility.\n. Personally, I feel that while this is useful, it may be a bit out of the scope of the library.\nI feel that adding/removing clients should be left to the app developer, but perhaps there are some use-cases I have missed.\n. This looks great and brings us inline with other implementations. However, with this change, the subject is no longer checked.\nPreviously, the check was done in getClientKey() to see if a key exist for a client_id and subject condition.\nHowever, now the subject is removed, we need to still perform a check to see if the client_id is allow to act as/impersonate the subject.\nA simple way would be to keep passing the subject to getClientKey() and let storage implementers deal with it.\nAnother way would be to define a checkClientCanAccessSubject() storage method.\n. @bshaffer Yes, that is the basic usage for normal JWT clients. However in my app, we are using JWT clients as service accounts like google: https://developers.google.com/accounts/docs/OAuth2ServiceAccount\nTheir implementation hasn't been tracking the latest drafts but their prn parameter is essentially our sub parameter.\nIn this case, we need to be able to allow say client services to impersonate/act as john@company.com, bill@company.com but not jane@company.com. So we will still need some way to check if user_id is able to impersonate subject.\n. A +1 from me as well!\n. :+1: \n. @bshaffer I just got a chance to look at the code and would love to get your perspective on some things.\nIn the JWT bearer grant type, response type, storage and OpenID response type, the EncryptionInterface is marked as optional in the constructor and if not passed in, the constructor instantiates an instance of JWT.\nThis seems a bit odd to me. If certain things require the JWT object I think it's best to explicitly require the JWT component to be injected via the constructor.\nAnyway, my proposal looks like this (this will be a major BC break):\n- Remove EncryptionInterface and JWT encryption class.\n- Where constructors require an argument of the EncryptionInterface type replace it with the JWT class from firebase/php-jwt. We won't be coding to an interface, but this is acceptable IMO as we are not planning to have many implementations of a JWT interface anyway.\n- The above will require a reshuffling of constructor arguments as we will be replacing all instances of EncryptionInterface $encryptionUtil = null with JWT $jwt.\n- Add firebase/php-jwt as suggest in composer.json.\n- No need to throw an exception if JWT is not installed, because we are making it mandatory to inject the JWT library into classes that require it.\nLet me know what you think! There's going to be some major BC breaks, but I feel it is pretty worth it.\n. @Oxmoze Good call!\nI have converted the JWT class into a small bridge to use firebase/php-jwt in PR #582.\ncc @bshaffer \n. See #584 and #585 instead.\n. I have updated the PR to make use of exceptions from firebase/php-jwt.\n. Just noticed this very stale PR. Is this safe to close @bshaffer ?. @bshaffer Any more feedback for this and #584?\n. I am actually verifying the \"client credentials\", in this case the iss (client_id) and grabbing the public key or shared key from the data store. Since there are no authentication headers or credentials passed in via the body, I would need to open up the JWT to check.  See getTokenDataFromRequest() in c15a3b24b211e240 for the checking of credentials. I wasn't 100% sure whether that is the best place for it, but OAuth2_GrantType_UserCredentials also checks the credentials in getTokenDataFromRequest(). Let me know if this is a problem :)\n. Arg!!! I am using Zend Studio 9 on default settings. I will get this fixed :)\n. That is odd, I thought php-cs-fixer would have fixed that. I will get that sorted :)\n. Reason for this is that in the JWT, the properties are abbreviated into iss, exp, etc as per the draft (http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-04#section-3).\nI am happy to change them to the full words if you want, but I feel that keeping them in the form that is expected in the JWT would be less confusing.\n. I did this because the JWT properties are abbreviated (see http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-04#section-3). I feel that instead of having abbreviated versions and non-abbreviated versions floating around in the code, sticking to 1 form would be less confusing and neater. Having said that, that does rely on the reader of the code reading the draft or doing some research.\nIf you feel the non-abbreviated versions would be better, I am happy to update them :)\n. I will add a @param comment block, because that is probably the most correct way to explain it. And forcing someone to read the spec isn't exactly good user experience (especially if he is in a rush). I will get a commit out in a few minutes :)\n. Agreed. Will change this to non-static. What do you think is the best way to inject this?\n. Just ran php-cs-fixer on the file again, but it's not picking it up. I have updated it manually :(. Will need to file a bug with php-cs-fixer for this :)\n. This issue with php-cs-fixer has been filed here.\n. My apologies, can't believe I totally missed that! This should have been picked up by php-cs-fixer. There's an issue filed with them now.\n. Can't believe I missed that. That is now fixed. I also found another instance of NULL in one of the interfaces. That has now been fixed as well. :)\n. I must have gotten carried away and forgot to include that file in the commit. :package: \nI have also lodge an issue with php-cs-fixer so that they can include lowercasing of PHP keywords into the fixer :)\n. Now that I think about it, all the checking in here is redundant because they would get caught in getClientDataFromRequest(). What do you think if we just return true here?\n. Done :)\n. Yes, that is true, however from the client's point of view, the cause of the parameters being incorrect would be because they had an invalid iss or sub.\nHaving said that, Perhaps it might be better to remove this after all, because having an invalid iss and sub will be the only issues for causing an error, and this is already being done in getClientDataFromRequest().\n. Ahh! That seems to be much nicer than the current implementation! :)\n. My apologies! I will send another PR in a few moments :smile: \n. Just saw you fixed it :) Thank you! :smile: \n. That spec is for the general json web token spec. For jwt bearer tokens, we should follow this more specific spec: http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-07 I must have misinterpreted the scope parameter while implementing the grant type, so thanks for sorting that out! :smile: \n. This is to maintain compatibility with the rest of the code. The original JWT library returned false when something goes wrong (bad jwt, signature not verifying, etc). firebase/php-jwt throws exceptions, so we need to convert them to false to ensure things continue working.\n. If that's the case, then we will need to change the default value of $allowedAlgorithms to array() and break the interface. Another issue is due to the design of the original JWT library and the recent work to fix the security issue, the last parameter $allowedAlgorithms is conflated to provide a list of supported algorithms or to control whether the JWT should be verified or not. For firebase/php-jwt, the presence of the $key value controls whether the JWT should be verified or not.\n. They keyId is a new feature to select a key from a list to verify against.\nsee https://github.com/firebase/php-jwt/blob/master/Authentication/JWT.php#L119 and https://github.com/firebase/php-jwt/blob/master/Authentication/JWT.php#L119 \n. In firebase/php-jwt allowedAlgorithms should not be anything but an array (and it doesn't make sense for it to be anything but an array). In this case, I believe that we should update the interface to force allowedAlgorithms to be an array: array $allowedAlogrithms = array(). This allows us to remove the code to maintain BC and also provides type hinting in IDEs.\n. That's a good point! Will get this updated in the 2.x pr.\nEdit: This is now done in the PR for 2.x.\n. ",
    "damz": "Oups, sorry for that.\n. ",
    "ksnyde": "I'm just getting started but my first attempt to instantiate \\OAuth\\Server leads me to what appears to be a very similar message:\nPHP Fatal error:  Interface 'OAuth2\\ResponseType\\AuthorizationCodeInterface' not found in ...\nWhere the error originates is simply my storage object which is heavily modelled after the base Mongo storage adapter. The class starts like this:\n```\nnamespace LG\\OAuth;\nuse LG\\Connection as Connection;\nuse \\OAuth2\\ResponseType\\AuthorizationCodeInterface as AuthorizationCodeInterface;\nclass CouchbaseStorage implements AuthorizationCodeInterface,\n    AccessTokenInterface,\n    ClientCredentialsInterface,\n    UserCredentialsInterface,\n    RefreshTokenInterface,\n    JwtBearerInterface\n{ ... }\n```\nBecause I'm operating in my own namespace I used the explicit use statement to disambiguate the namespace for AuthorizationCodeInterface but it seems to make no difference. \nKen\np.s. obviously I'd expect if this did work that I'd need to make the same \"use\" statements for the other interfaces referred to but I haven't bothered to tackle that one yet. \n. Yes I have included the autoloader. Here's my code:\nrequire_once('../oauth2-server-php/src/OAuth2/Autoloader.php');\nOAuth2\\Autoloader::register();\nFor what it's worth this is my index.php in Restler (aka, the first file loaded for any API request). It then handes off execution to a handler class which then instantiates my storage class. \n. Actually they DO require a backslash when the object is in a namespace other than root. In any event I tried both but as you probably already know if I have this code:\nnamespace Foo\\Bar;\n use Monkey\\See\\MonkeyDo as MonkeyDo;\nit will look for MonkeyDo in the \\Foo\\Bar\\Monkey\\See namespace.\n. Well just for shits and giggles I thought I better try it again without the leading backslash. Same result but I was surprised to see the resolution to the appropriate namespace did work without the backslash ... I know I've seen the opposite behaviour and therefore including the backslash seems more defensive to me. Maybe the variation in behaviour comes from details in the PSR0 spec? I've been meaning to make sure that I am 100% compliant with ... I'm know I'm close. \nIn any event. I am quite certain this is not related to the issue as I've now just run from the interactive PHP environment three commands:\nrequire_once \"../oauth2-server-php/src/OAuth2/Autoloader.php\";\n OAuth2\\Autoloader::register();\n include \"include/oauth/CouchbaseStorage.php\";\nand I get the following:\nPHP Fatal error:  Class LG\\Oauth\\CouchbaseStorage contains 4 abstract methods and must therefore be declared abstract or implement the remaining methods (OAuth2\\ResponseType\\AuthorizationCodeInterface::enforceRedirect, OAuth2\\ResponseType\\AuthorizationCodeInterface::createAuthorizationCode, OAuth2\\ResponseType\\ResponseTypeInterface::getAuthorizeResponse, ...)\n. BTW, my CouchbaseStorage file now looks like this:\n```\nnamespace LG\\Oauth;\nuse LG\\Connection as Connection;\nuse OAuth2\\ResponseType\\AuthorizationCodeInterface as AuthorizationCodeInterface;\nuse OAuth2\\ResponseType\\ResponseTypeInterface as ResponseTypeInterface;\nuse OAuth2\\ResponseType\\AccessTokenInterface as AccessTokenInterface;\nuse OAuth2\\Storage\\UserCredentialsInterface as UserCredentialsInterface;\nuse OAuth2\\Storage\\ClientCredentialsInterface as ClientCredentialsInterface;\nuse OAuth2\\Storage\\RefreshTokenInterface as RefreshTokenInterface;\nuse OAuth2\\Storage\\JwtBearerInterface as JwtBearerInterface;\n/\n * Couchbase storage for all storage types\n \n * NOTE: based off of the example Mongo storage class written by Julien\n \n * @author Ken Snyder ken@lifegadget.co\n * @author Julien Chaumond chaumond@gmail.com\n */\nclass CouchbaseStorage implements AuthorizationCodeInterface,\n    AccessTokenInterface,\n    ClientCredentialsInterface,\n    UserCredentialsInterface,\n    RefreshTokenInterface,\n    JwtBearerInterface\n{\n``\n. Furthermore, I have checked and abstract references toenforceRedirect()exist in bothAuthorizationCode.phpandAuthorizationCodeInterface.php` but there is no implementation anywhere in the source code. \nSame applies to the other three cases.\nIn this first case, the implementation is probably just returning a boolean value ... effectively its configuration. I'll see if the other missing methods are this straight forward. Might be good to have the examples have a default value for these parameters if that's the case? Would allow them to work out-of-the-box.\n. Wow. That works. I'm at a loss. Where do I find the implementation of methods like enforceRedirect()? I did a global find with my editor and it didn't find it. :^/\nOk, I see the failure in my logic. I had added the \\ResponseType references earlier because I had been trying to trace the classname backwards and didn't realise there were two classes of the same name. \nThanks for you patience/help.\n. I realise I could also implement around the server by doing this:\n$controller = new UserController($username);\nstatic::$server->handleTokenRequest(static::$request,static::$response);\n$myParameters = static::$response->getParameters();\n$myParameters['user_id'] = $controller->user_id();\nstatic::$response->setParameters($myParameters);\nstatic::$response->send();\ndie();\nBut wouldn't this be a fairly typical usecase and isn't the signature of handleTokenRequest() already suggesting that it supports this?\n. Sure I understand about the app-specific stuff and I have gotten it to work with my solution above. I was just wondering whether the API was hinting towards this functionality being provided out-of-the-box. I'm happy to just use my own implementation for now.\n. ",
    "ccazette": "Hi Brent, I am trying to get access token data. For that, there's a method called getAccessTokenData(), which seems pretty appropriate, in AccessController and there's even a shortcut in Server. Thing is it takes 2 parameters that you cannot get easily from outside the library.\n. @dsquier, you can, but doing so your implementation assumes your using a bearer token. So later down the road, when supporting MAC tokens or even other token types, your implementation would need rewrite.\n. After more code and specs reading, I confirm this is an issue.\nThe library expects query parameters (see OAuth2_GrantType_AuthorizationCode::validateRequest(), OAuth2_GrantType_AuthorizationCode::getTokenDataFromRequest()) when it should come in POST parameters (see http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.1.1)\n. OK... This will sound ridiculous, now I've closed this by myself 2 times already, but now I definitely think this is an issue. Was linking to the wrong section of the specs.\nHere's the issue :\n- specs expects POST from client : http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.1.3\n- lib validates agains GET : OAuth2_GrantType_AuthorizationCode::validateRequest(), OAuth2_GrantType_AuthorizationCode::getTokenDataFromRequest()\nThis is my last word :)\n. Note that OAuth2_GrantType_UserCredentials also expects GET, when it should expect POST.\nhttp://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.3.2\n. That also applies to OAuth2_GrantType_RefreshToken.\nhttp://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-6\n. haha :)\ngood catch...\n. @bshaffer Thanks for the answer.\nFacebook's implementation returns your existing access token straight through redirects, but you're originally requesting against the /authorize endpoint. Meaning before returning the existing access token, you can check if its scope match the requested scope of the new authorize request.\nIf yes, return it. If no, go through the entire OAuth dance again, and generate a new token.\n. hehe.. indeed that's the very same question :)\nClosing this in favor of #42.\n. ",
    "asherkin": "I've just ran into this as well.\n. ",
    "guestisp": "Database table schema is missing.\n. Sorry, it was a typo in Doctrine Storage.\n. ",
    "stefanaxelsson": "Feel free to close issue #40 when these changes are merged.\n. Wouldn't a try/catch-approach be better than silencing the error?\n. I can't think of any library that has this issue, so I have nothing to compare it with. One solution could be:\n``` php\nfunction exception_error_handler($errno, $errstr, $errfile, $errline ) {\n    throw new ErrorException($errstr, $errno, 0, $errfile, $errline);\n}\nset_error_handler(\"exception_error_handler\");\ntry {\n    var_dump(openssl_verify('123456', '123456', 123456, 'sha256'));\n} catch (Exception $e) {\n    var_dump($e); \n}\nrestore_error_handler();\n```\n. ",
    "till": "@bshaffer Thanks, very much! cc @dazz\n. Sounds good. Thanks again! :)\n. @F21 In this case you should implement a null-storage of some kind. At least IMHO.\n. @bshaffer Do you think we'd even need to do an official bridge (and repository)? I think if I PR'd that interface and just TillLogger extends MonoLog implements OAuth2_LoggerInterface then there is zero maintenance required on your side. Not even sure if others need this.\nJust throwing this out there if you want to deprecate 5.2 anyway within the next 2 months.\n. Alright!\n. ",
    "dazz": "Thanks\n. ",
    "Rockstar04": "I get scared when I see the line about adding dependencies for a specific logging framework, would an alternative be supporting PSR3 compliant loggers in some way that's independent of the logger itself. (I know that MonoLog itself is already PSR3 compliant)\n. Now that I've been working with this library more at work, I can agree with @mariano completely, if you need logging the only sane place to put the logging is in your own code. Many of the things I would want to log are functions that return bool, and logging that in this library would require adding conditionals to check that value and log it appropriately before returning. \n. Should I develop my API with the current version or try to wait for the refactor? ETA?\n. @bshaffer Don't we already have an Implicit grant type? Was closing this issue missed when it was added or are we talking about something else?\n. Understood, its just a flag set on the server class to allow the authorization_code grant handle implicit grants.\n. @abeverley Not sure if you want to resubmit this against the branch bshaffer made for the documentation update. https://github.com/bshaffer/oauth2-server-php/tree/add-cookbook\n. Since the referencing PR was closed, I assume this issue can be closed as well?\nbshaffer's comments in the PR issue: \n\nnon-expiring access tokens pose a pretty real security threat, as this goes against pretty much everything OAuth2 stands for. However, I don't see a real issue in putting this code in there... people can shoot themselves in the foot if they want to...\nClosing - we do not want to support non-expiring access tokens\n. Looks like this is taken care of in #174 and #168 ? @bshaffer @trickleup could close this issue?\n. I could very well be wrong, I will admit I know very little about OAuth, but looking at the PDO Storage Query, and the JWT OAuth 2.0 Client Authentication and Authorization Grants Draft, this is what I came up with:\n\nSQL\nCREATE TABLE oauth_jwt (\n  client_id VARCHAR(80) NOT NULL ,\n  subject VARCHAR(80) NULL ,\n  public_key VARCHAR(2000) NULL ,\n  PRIMARY KEY (client_id) );\nI do not agree with the table definition, but rather tried to stay consistent with what the existing examples define\n. Facepalm. . . . .\nI corrected the db name, and removed the back ticks to be more consistent with the other example tables.\nThat's what I get for blindly copying out of MySQL Workbench.\n. For reference regarding the subject column, this is what the RFC draft states:\n\n\n\nThe JWT MUST contain a \"sub\" (subject) claim identifying the\n      subject of the transaction.  The subject MAY identify the\n      resource owner for whom the access token is being requested.\na.  When using a JWT as an authorization grant, the subject\n      SHOULD identify an authorized accessor for whom the access\n      token is being requested (typically the resource owner, or\n      an authorized delegate).\nb.  For client authentication, the subject MUST be the\n      \"client_id\" of the OAuth client.\n. Duplicate code removed with PR #173 \n. Ya Jwt seems like it could be brought inline with the rest as well, urn:ietf:params:oauth:grant-type:jwt-bearer isnt exactly intuitive.\n\n\n\nI am working on the doc as a way to force myself to really learn and understand this stuff, so I may be missing something that makes the JWT identifier make sense.\n. Perfect, thanks!\n. Sure, I will take a look when I get to work in a few hours.\nSent from my Droid 4\nOn Apr 8, 2014 11:20 PM, \"Brent Shaffer\" notifications@github.com wrote:\n\nWould you like to rebase this so I can merge it in for the 1.4 release?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/pull/199#issuecomment-39927446\n.\n. There are just too many changes, and the initial merge conflicts were pretty jacked. Best bet would be to just start over.\n. No, StorageTest does not have a testCheckRestrictedGrantType method.\n. I can knock out a quick PR for that, in the mean time here is a PHPUnit code coverage report to help highlight some weak spots in the unit testing (Excluding Mongo since I don't have it installed)\n\nhttp://trentpetersen.com/bshaffer-oauth2/coverage/index.html\n. I would say this is absolutely reasonable, and should be easy to accomplish through the config array that's already passed to the controller.\n+1\n. Sorry forgot to pull from upstream, but it looks alright\n. Lemme grab come coffee and I will get right to it!\n. Preference for the column name for the restricted grants? I don't see anywhere that has a column for it already.\nWow facepalm, its already in the code. . .  I really need the coffee!\n. I'm not sure how to handle the Mongo storage, I am not familiar with it. (I guess this is a reason to learn though)\n. ",
    "mariano": "I'm with @Rockstar04 Adding a dependency for a particular logger implementation seems unnecessary. At the very least we should be able to inject the logger implementation without this library requiring a particular one.\n. @bshaffer I personally don't need logging within the library. I do my logging in my own code, and treat third party libraries as what they are: third party libraries :) IMHO logging within oauth2-server-php would only be useful if you are debugging the library, that's why I believe it's an unnecessary requirement\n. +1\n. @alkhoo what password are you talking about? Either if its the user credentials or the client secret it is your responsibility to hash those passwords. That's your application code job, not this library. For example i have my Doctrine2 repositories implementing the Stirage interfaces and I'm thus able to integrate it with my application logic\n. ",
    "bojanz": "Since we added $client_id to getSupportedScopes(), it would have made sense to pass it to getDefaultScope() too.\nIf all scopes depend on the client, then so does the default scope.\n(I solved this in my implementation by injecting the value into the constructor).\n. I have a procedural function that checks access per context (a \"context\" is a group of clients and scopes).\nIt also accepts a scope parameter.\nSo it's used similar to how you'd use $server->verifyAccessRequest().\n``` php\nfunction oauth2_verify_access($context_name, $scope = NULL) {\n  $context = oauth2_entity_load_by_property('oauth2_context', array('name' => $context_name));\n  $server = oauth2_get_server($context);\n  $token = $server->getAccessTokenData(OAuth2_Request::createFromGlobals());\n  // If there's no token, that means validation failed. Stop here.\n  if (!$token) {\n    return oauth2_send_response($server->getResponse());\n  }\n// Make sure that the token we have matches our context.\n  if ($token['context'] != $context->name) {\n    $error = 'The access token provided is invalid';\n    $response = new OAuth2_Response_AuthenticationError(401, 'invalid_grant', $error, 'bearer', 'Service', $scope);\n    return oauth2_send_response($response);\n  }\n// Check scope, if provided.\n  // @todo Remove once $server->getAccessTokenData() starts forwarding the\n  // $scope parameter to the controller.\n  $scope_util = new OAuth2_Scope_Drupal($context);\n  if ($scope && (!isset($token[\"scope\"]) || !$token[\"scope\"] || !$this->scopeUtil->checkScope($scope, $token[\"scope\"]))) {\n    $error = 'The request requires higher privileges than provided by the access token';\n    $response = new OAuth2_Response_AuthenticationError(401, 'insufficient_scope', $error, 'bearer', 'Service', $scope);\n    return oauth2_send_response($response);\n  }\n}\n```\n. Hm, this breaks tests...\n. Okay, pushed an entirely new commit, this one should pass tests.\n1) Removed the old check with the explicit response, which was unused anyway.\n2) Left the initial token param check, but made it check for NULL explicitly. \nThis allows the code to fail properly if the access token parameter is present, but empty.\n3) Made the getAccessToken check less strict, other storage load checks accept both NULL and FALSE, so made it the same here.\n. Rebased (latest develop commits had mongodb test fixes), now passes.\n. Resubmitted, now respects coding standards.\n. Cool, I'll send in a pull request.\n. Aand this is still not enough for grant types that don't need an authorization request (client_credentials, password), in that case $tokenData['scope'] is still empty and fails validation. Looking into it.\n. New commit works on all grant types, and makes my tests pass.\n. The relevant part of the spec is http://tools.ietf.org/html/rfc6749#section-3.1.2\n\nThe authorization server SHOULD require the client to provide the\ncomplete redirection URI (the client MAY use the \"state\" request\n parameter to achieve per-request customization).  If requiring the\nregistration of the complete redirection URI is not possible, the\nauthorization server SHOULD require the registration of the URI\nscheme, authority, and path (allowing the client to dynamically vary\nonly the query component of the redirection URI when requesting\nauthorization).\nThe authorization server MAY allow the client to register multiple\nredirection endpoints.\n\nhttp://tools.ietf.org/html/rfc6749#section-10.15 says\n\nIn addition, if the authorization server allows the client to register only part of the\n  redirection URI, an attacker can use an open redirector operated by\n  the client to construct a redirection URI that will pass the\n  authorization server validation but will send the authorization code\n  or access token to an endpoint under the control of the attacker.\n\nSo, maybe a flag that's on by default? Dunno\n. Of course, having to do the second check basically makes the implicit flow the same complexity as the authorization code flow, but without passing the client_secret.\n. Fixed by #115 \n. The relevant part is:\n\n1) 'access_token' is a string that identifies your Resources on Provider. No other parameters are required to call \n Provider's API. There is no guarantee user's access_token1 for client1 is not used by client2 or client75 - nothing \n stops them.\n2) Let's assume I create a website: e.g. superfunnypicturez.com. I ask my users to authorize my Client on facebook \n and I don't ask any scopes at all - I need only \"/me\" endpoint with \"uid\" param to be available. They authorize my \n Client because superfunnypicturez.com requires only 'read' access and nothing seems to be dangerous. I get their \n'access_token's and now I can request /me endpoint and get their \"uid\"(often used for authentication)\n3) Let's assume there is another site: e.g. weuseimplicitflow.com and yep, it uses Implicit Flow(receives token via \nCALLBACK#access_token=123qwe...). It's a pity - this website authenticates users by given access_token. Most \nlikely it sends access_token on server-side and invokes /me endpoint from there.\n4) Since I am admin of superfunnypicturez.com and you authorized my Client and gave me an access_token from your > account I just put that access token in callback URL: CALLBACK#access_token=YOUR_TOKEN and now \nweuseimplicitflow.com's Client authenticates me as you because that token I just provided returns your 'uid' when \n/me endpoint is called. I need only one access_token from your Provider's account to rule all your accounts on 3rd \nparty websites that use Implicit Flow.\n\nThis means that if I have an untrusted list of clients, when my js app receives an access token I need to do an additional API call to make sure that the access token actually belongs to me (my client).\nI have an issue open about noting this: #81 \nAnyway, back to the main topic at hand, I posted this change because by default during implicit flow you get the scope passed to your redirect url. The url is limited to 2083 characters. So if you have scopes like this \"https://www.googleapis.com/auth/userinfo.email\" and the client can get several (which in my case is true), it is easy to breach that character limit (keep in mind that 2083 includes your complete domain name and the rest of the url callback).\nThat's why I need to fetch the scope via an additional call (and doing that when I'm validating the access token allows me to kill two birds with one stone).\nI can hack this together in my module, but I think it is a problem that is generic enough to be discussed here.\nI am fine with adding handleScopeRequest that accepts the access token and the client id and returns a \"verified\" boolean and a \"scope\" string, though I'm not sure if handleScopeRequest is the right name for the method then.\n. I didn't say it had anything to do, I said that the API call was related.\nI don't think it makes sense to check for 2083 characters since that would make for inconsistent behavior \ndepending on the selected scopes. So this behavior should either happen or not happen.\nIf you think the library should provide the additional call (and not the demo app), I can add it here.The first feedback I wanted was whether you even agree with the approach.\n. Yeah, links in that PR confirm that base64 encoding is not required, though I think it would have been clearer for the spec to require it. Oh, well. \nThanks for clarifying.\n. Couldn't the pdo storage class just add a protected $cache property and use that as a cache? \nThat way it wouldn't need to be wrapped in a completely new class.\n. Now's a good time to ask, why do we have this duplication on the constructor:\n* @param array $responseTypes\n* Response types to use.  array keys should be \"code\" and and \"token\" for     \n* Access Token and Authorization Code response types\n*\n* @param OAuth2_ResponseType_AccessTokenInterface $accessTokenResponseType \n* Response type to use for access token\nSince we already have $responseTypes (and $responseTypes['token']), can we remove $accessTokenResponseType?\nThis duplication forces me to inject my custom access token response type class twice.\n. http://drupal.org/node/1938218\nhttp://drupal.org/node/1958718\nThese are the documentation pages I wrote for the Drupal integration. \nThe second one is pretty generic, and both at least have a few useful links.\n. Yeah, I am going to fix it to a specific tag very soon (in time for the module RC). Updating for v0.7 right now.\n. This should go into the README then?\n. Rebased, now passes tests.\n. So we now need to add an additional grant type in addition to passing allow_implicit if we want implicit flow to work? Ouch! This should be documented in the README\n. After this change landed, implicit flow stopped working for me, telling me that the \"implicit\" grant type is unsupported. That's because we call $storage->checkRestrictedGrantType() with the client id and with \"implicit\" as the grant type.\nNow, the storage always looks up that setting somewhere, and in my case it looks up the setting which allows for \"authorization_code, password, client_credentials, refresh_token\", there's no implicit flow there because implicit is not represented by another grant type class.\nI did this to workaround it:\nhttp://drupalcode.org/project/oauth2_server.git/commitdiff/3327e0289fcb0e9b6f6eb8a6057abed7793e4b4d\nNot sure how to proceed. I find passing \"implicit\" as the grant type just wrong.\n. http://tools.ietf.org/html/rfc6749#section-4.1.3 shows that the authorization_code grant type accepts no scope parameter.\nhttp://tools.ietf.org/html/rfc6749#section-6 shows that the scope for the refresh_token grant type needs to be validated against the scope of the previous refresh token.\nClient credentials, password, and JWT grant an access token with no basis in prior requests (no authorization code, refresh token, etc), so it's obvious that the validation needs to be \"check that the requested scope exists\".\nYou can confirm this for client_credentials and password grant types in the spec.\nAs I said, the JWT OAuth2 spec says nothing about scopes, so we're in unspecced territory there.\nhttp://tools.ietf.org/html/rfc6749#section-3.3 provides general scope guidelines, such as:\n\nIf the client omits the scope parameter when requesting\nauthorization, the authorization server MUST either process the\n request using a pre-defined default value or fail the request\nindicating an invalid scope. \n. Well, one of my first complaints was that getTokenDataFromRequest() means absolutely nothing, because it's getting different things from different places.\n\nQuoting #88:\n\nFor the authorization_code grant type, the authorization code is fetched from storage.\nFor the refresh_token grant type, the refresh token is fetched from storage.\nFor the password grant type, user data is fetched from storage.\nFor the client_credentials grant_type, an array with just the scope from the request is returned.\nSo the \"FromRequest' part is mostly untrue, the method could use a better name.\n\nMerging validation into the main method allowed me to avoid having to invent a generic structure name and method name to encompass the different things being transfered here. So I can just have $authorizationCode, $refreshToken, $userInfo in the methods, which adds clarity. No confusing abstractions.\n. No longer relevant now that #115 landed.\n. I think it would have been more productive to discuss some of the points on my PR in #113, than go ahead and redo from scratch so that we get another unfinished version...\nA few points:\n1) The new tokenData method has more clear naming, but I'm not sure it should exist at all.\n     The way I see it, the token data is an internal matter of the grant type class.\n     The grant type class has one responsibility \"Grant an access token to this client, based on this request\".\n     This is clear in the code where the Controller gets the token data from the grant type, and then simply returns\n     it to the grant type class. Any class wanting to do something generic with the tokenData would have a problem\n     because the data varies wildly between grant types. \n2) My scope validation code was per grant type, which was a bit repetitive at times, but also very clear.\n     It illustrates that the logic is different for each grant type, and makes it very easy to understand.\n     Your code tries to satisfy all possible cases at once, making it convoluted and hard to read and understand.\n     It also ignores the fact that the authorization code grant type shouldn't have any scope validation or handling.\n3) https://github.com/bojanz/oauth2-server-php/commit/27010d0b6dcaeffdda5c8ef5614c137afe43b62f still needs to happen.\n. 1. Okay, that's reasonable.\n2. While scope validation may feel straightforward, your implementation is anything but.\n``` php\n      // if this is set, we are dealing with an authorization code or refresh token\n      $availableScope = isset($tokenData['scope']) ? $tokenData['scope'] : null;\n  if (!$requestedScope = $this->scopeUtil->getScopeFromRequest($request)) {\n      $requestedScope = $availableScope ? $availableScope : $this->scopeUtil->getDefaultScope();\n   }\n\n  if (($requestedScope && !$this->scopeUtil->scopeExists($requestedScope))\n      || ($availableScope && !$this->scopeUtil->checkScope($requestedScope, $availableScope))) {\n       $this->response = new OAuth2_Response_Error(400, 'invalid_scope', 'An unsupported scope was requested.');\n       return null;\n   }\n\n```\nMy only concern here is simplicity and understandability. \nA big comment could paste chunks of the spec that explain the intent, but the solution still has too much nested logic. And as I said already, we shouldn't do anything for \"authorization_code\", which would require adding another exception specifically for that grant type into the controller, meaning that the controller needs to become aware of that specific grant type.\n1. The point of https://github.com/bojanz/oauth2-server-php/commit/27010d0b6dcaeffdda5c8ef5614c137afe43b62f is making errors set during client_credentials bubble up to TokenController, like they do for other grant types.\nNeeded because of \nphp\n    public function getObjectResponse($object, OAuth2_Response $defaultResponse = null)\n    {\n        if ($object instanceof OAuth2_Response_ProviderInterface && $response = $object->getResponse()) {\n            return $response;\n        }\n        return $defaultResponse;\n    }\n. I think this was fixed in #115, please check :)\n. This would match scopeExists($scope, $client_id  = null), so it makes sense.\n(and if we do away with the default NULL, we should then fix the scopeExists signature as well). \n. I am just responding to your sentence \"There is no case where client_id is null.\"\n. The post-v0.7 refactorings (grant types, server) broke everything (I didn't have a single test passing anymore ;)), so backwards compatibility is hardly a topic here ;)\nThat said, I personally don't need this since I inject a similar param in the constructor of scopeUtil, but do agree that the proposed change looks good for consistency.\n. I see bshaffer has already covered the points I wanted to make, so I'll tune in later :)\n. Just the one I linked to previously: http://drupal.org/node/1938218\n. Requiring Symfony would be a big bother for the Drupal 7 integration since it would require the additional composer step (Drupal 8 relies on composer and includes Symfony, but we don't have that luxury for Drupal 7).\n. 1. You still need to be consistent in your examples. All of the storages you ship (pdo, mongo, etc) assume user_id is the username. And then BAM, in JWT user_id is the mail. Drupal follows the user_id -> username assumption and JWT simply cannot work because of this.\n2. Yeah, I'm ignoring the subject as well in the initial patch.\n. I'm preparing a new PR for this.\n. We are going to follow Google's lead and only implement the Authorization Code and Implicit flows. The third one, Hybrid flow is going to be skipped, because it would double the effort needed for no gain.\nI have pushed the first commit. Not yet ready for review, I will push more code in the next 12 hours.\nHad to make significant changes to the code I wrote last week to account for the fact that for the Authorization Code flow the id_token needs to be generated and saved when the authorizaton code is generated and saved. That's the only way to handle the nonce properly, which is a required parameter.\n(Previously I attempted to just generate and save the id_token in the response type). \n. There is also the auth_time (though that parameter is optional).\nI initially went with no storage for the same reasons (and you can see that the get method only supports fetching by code, the id_token is 850 chars long so it makes no sense as a key to fetch by).\nHowever, Nat Sakimura (one of the people behind the spec) is explicit about saving the id_token after authorizaton, and I fear that avoiding that will bring us future pain while making the code less clean and easy to understand.\n. Also note that OpenID Connect nonce's and JWT grant type JTI's have different semantics.\nThe OpenID Connect nonce is not validated for uniqueness and represents a session, not a single request.\n. Should have been clear about that, there is no plan to have the Resource Server contact us to validate the id_token. The id_token is validated on the Resource Server by verifying the signature and checking the claims.\nThat is why the storage only supports fetching by code.\nThe only point of the storage is to store the token between authorization and the granting of the access token.\nI could have added an id_token to the code storage but that flow would require passing the id_token response type to the code response type. The current approach is cleaner.\nNonce is required for the implicit flow (response type = id_token or token id_token) and optional for the authorization flow.\nI will add the methods to the EncryptionInterface. We base64url encode everything we encrypt, it makes sense to have it there.\n. Okay, change of plan.\nWe kill the id token storage, and use a column / property on the authentication code storage.\nIf the response type is \"code\", we generate an id_token first and then pass it to the \"code\" response type which passes it to storage. The \"code\" grant type then gets the id token and returns it before expiring the code.\nThe current way makes no sense once the code is expired, since the id_token storage is supposed to reference the code and that reference then dies.\n. I just pushed a commit that might be controversial. It introduces the concept of reserved scopes, to account for the fact that OpenID Connect has required scopes that must always exist.\nA public method returns the reserved scopes, and the default scopeExists() method bypasses storage for those reserved scopes.\nThis fixes the problem for most storages. It's a bit problematic for me because in Drupal I store the scope_id instead of the scope for tokens and auth codes, but I can just call getReservedScopes() after the server has been created for the first time and create the scopes in storage.\nI didn't want to mandate a create method in the interface because most storages won't need to actually create these scopes.\nOpinions welcome.\nAlso, keept needsIdToken on the controller instead of moving it to the scope util because the scope util doesn't have access to $this->config. Maybe I could split it (check $this->config in the controller and the scope in scope util?)\n. As for the question of whether this code should live in oauth2-server-php, I believe the answer is yes, for one simple reason: A large percent of OAuth2 deployments tries to use OAuth2 for authentication / login purposes. \nThey end up reinventing most of the security measures (or even worse, not reinventing them) and features given by OpenID Connect. I know because I've been there. OpenID Connect is really small and should be strongly recommended to anyone trying to use OAuth2 for authentication.\nPutting the code in a separate repository is going to drastically increase the size of the codebase and will make interoperability harder. It was already very hard to implement this in a clean way because of the way the library is structured (doesn't use a dependency injection container, mandating a ton of classes passed around in constructors), having to inherit all of the important classes would make it almost unfeasible.\nAn AccessTokenWithIDTokenInterface might make sense, but it's quite a bit of added complexity for what is one added optional parameter on one method.\n. The remaining tasks for this PR:\n1) We need to be able to return the user details based on the claims (email, profile, address).\n    These details are added to the id_token when the response type is id_token (and we could optionally add it when doing the authentication flow, or response type = token id_token).\n    They can also be returned from a UserInfo controller.\n    An easy way to do this is to add an additional $claims (or whatever we call it) parameter to     UserCredentialsInterface::getUserDetails(), then pass that storage to the id_token response type.\n    The next task would then be to implement the UserInfo controller.\n2) Making sure that the refresh_token is only returned when the scope \"offline_access\" is present (of course, only when OpenID Connect is used, meaning scope \"openid\" is present as well).\nEDIT: Pushed a commit for #2. Definitely might make sense to have a separate grant type class that inherits the class and overrides the createAccessToken method.\nDone for today, feel free to push your own fixes.\n. With the latest commits, this PR is feature complete.\nTODO:\n- The id_token is still returned during implicit flow even if the \"openid\" scope wasn't requested. Should add a validation rule that returns Error 400 Bad Request.\n- It is normal for sites to rotate the keys used to sign the id_tokens. There should be a way ($kid parameter in Jwt::encode) to add a kid value to the JWT header. The \"certificates\" endpoint can then key the certificates by kid. The certificate rollover is also a problem for crypto tokens, so it can be done in a separate PR.\n  Note that the \"certificates\" endpoint is currently not provided by the framework. I am not opposed to adding it. It's usually needed (Google has it, for instance), but not a part of the spec.\nAnyway, eagerly awaiting further reviews and direction :)\n. About claims VS UserInfo: \nI agree that the dual lingo is unfortunate, but I am just following the spec. \nThe spec calls these values \"claims\" everywhere. Then, it mandates a \"UserInfo\" endpoint saying: \"The UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns Claims about the authenticated End-User.\" (http://openid.net/specs/openid-connect-core-1_0-17.html#UserInfo). \nAbout OpenIdAuthorizeController:\nI agree that this is a good idea. It will allow us to clearly separate the OpenId Connect specific validation and logic.\nAbout storage:\nThere can't be a nonce storage, we are storing the entire id_token. I can create a separate IdToken storage again that is keyed by code_id, pass it to the OpenIdAuthorizeController and to the OpenIdAuthorizationCode grant type, if you think that is cleaner. It is however additional complexity compared to an optional column on the authorization code storage.\n. The OpenID Connect standard has been released. Now's a good moment to push this to completion.\nWhat's our way forward?\nI've reviewed your changes and they look good. I'm guessing the Server class needs a bit more boilerplate so that the right classes are instantiated.\n. Okay, pushed some changes, not sure if the second commit is what you had in mind.\n. Thanks for finishing this. I have been busy preparing the OpenID Connect PR (and matching Drupal server and client code) so I didn't have a chance to circle back.\n. My point is that getClientScope() shouldn't exist and that scopeExists() should be the only method for checking scopes, allowing it to filter any way it wants. Just like before.\n. Another problem is that I'm duplicating scope listing code instead of having one with the appropriate access checks. Previous code allowed us to treat the filtering as an access problem. The current code requires us to duplicate scopes into the client, and the code that goes with it.\n. Yes, there is no way to properly revoke refresh tokens if the access tokens don't have a link to the refresh token that issued them. Revoking is from a different spec, but still very common (most oauth2 providers provide it)\n. Supporting multiple servers in Drupal was a mistake, since a server in that case is just a way to group settings (such as grant types) and scopes for a group of clients. I hope to remove that in Drupal 8.\n. \"If you can have different settings and scopes for each client, and only a single server, then what is the purpose of having a server?\"\nExactly. Plus, the code for detecting a server based on client_id is really awkward (since we have the same endpoint for all servers).\n. Yes, that's how I would expect it to work. If no client specific grant types are found, we check the server ones.\n. This looks great, thank you for the work you've put into this.\nI believe there are enough tests, especially with your additions.\nThe nonce isn't validated, just passed back (you pass it to the server during authorization, get it back later with the token).\nMy only personal todo is that the jwt needs to include a kid, so that key rollover can work (if the token has a kid you don't have, refetch the keys from the server). That is something for a followup though.\nI'd love to see this merged as soon as possible so I can merge the Drupal part and we can get people to use it and test it.\n. Agreed. If we want to support key rollover on the app side for OpenID Connect (something that Google does for its implementation), we need a way to stick the key id in that header.\n. We'll either need to add a $kid param to encode() as well, or make the private key an array / object, no?\n. Are you talking about the UserInfo response?\n. We'd need to lie the parent method about $is_authorized being TRUE so that it doesn't trigger its own validation on that param, which is hackish, no?\n. Sure, why not. What about the is_null($user_id) check?\n. Good idea with the new function. Named it setNotAuthorizedResponse because it seemed more logical with the way it's currently written, but I can change that.\nThe tests seem to be passing (5.4 seems to be a random fail), now we just need to add some new ones.\n. Sure I do, I've been traveling, will get back to it by the end of the week.\nOn Jul 7, 2014 11:46 PM, \"Brent Shaffer\" notifications@github.com wrote:\n\n@bojanz https://github.com/bojanz As I have not heard back from you, I\nam assuming you've either been very busy, or given up on me and decided to\nuse your own fork. Do you still want this merged?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/pull/388#issuecomment-48245606\n.\n. The prompt parameter is optional according to the spec, so that PR is just a nice to have, no worries.\nOn the other hand, we might want to handle #363 before the release.\n. Thank you!\n. Is your storage getUserClaims() method actually returning the email?\n\nIf you're using the \"id_token\" response_type (meaning no access token is returned), you get all claims in the id_token. If you're using the regular \"token id_token\" response type then you're supposed to use the returned access token to query the UserInfo endpoint to get the email.\nThis is according to the spec, Google bended it slightly to send the email in all cases, but that's only safe if the email doesn't change (on systems such as Drupal, the emails is changeable...)\n. Thank you for driving this home. Much appreciated.\n. @belerophon \nThe id_token closes this security vulnerability: http://homakov.blogspot.com/2012/08/oauth2-one-accesstoken-to-rule-them-all.html\nIf you're using the implicit flow (JS frontend app that communicates with PHP backend app B, and does login to site C), the token you get is not guaranteed to have been issued for you (the client). Without OpenID Connect and the id_token, you need to ping a token validation endpoint, that will allow you to confirm that the token's client_id and other parameters.\nBut if you have an id_token, you can skip that roundtrip, by validating the id_token instead. It is cryptographically signed, and contains the client_id. The fact that it can also contain the profile information is a nice bonus.\n. The authorization flow is definitely supported by our OpenID Connect implementation.\nWe have explicit tests that cover this:\n1. https://github.com/bshaffer/oauth2-server-php/blob/develop/test/OAuth2/Controller/AuthorizeControllerTest.php#L419\n   This test confirms that when the authorization endpoint is hit with an \"openid\" scope and the \"code\" response type, an id_token is generated, saved along with the authorization code, but not returned.\n2. https://github.com/bshaffer/oauth2-server-php/blob/develop/test/OAuth2/OpenID/GrantType/AuthorizationCodeTest.php#L12\n   This test confirms that when the authorization code is given to the token endpoint, it returns an id_token.\nSo, I'm probably misunderstanding what the problem is. @relaxnow can you clarify?\n. @relaxnow And I'm saying that the tests already confirm that it does. \nLook at the TokenController, it just returns the output of the grant type's createAccessToken() method. Now look at OAuth2\\OpenID\\GrantType\\AuthorizationCode, it returns an id_token.\n. This was intentional. If a response type results in an access token being returned, the application can get fresher user information by using the access token to ping an endpoint.\nIf no access token was returned, we have no choice but to provide the data in id_token, accepting that it can get stale while it is passed around.\n. Your token request is sent over SSL, how would anyone be able to see the client name and secret?\n. \"For consistency with the rest of the system (scopeExists(), any storage method that accepts $scope), I've removed the ability for checkScope() to accept arrays. It now only deals with space-separated strings. Supporting dual forms is also hard to document. We should pick one, and stick with it through the codebase.\"\n. There is no reason to remove the trailing comma.\n. Unintended change, I'm guessing.\n. Moved around so that $this->addStorage() has access to $this->config\n. http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#Combinations\nMultiple response types are pure insanity, I can't see any point in \"code token\" (if you have the token, what's the point of the code? just to get the id_token?) or \"code token id_token\" (now the code is completely pointless) or \"code id_token\" (I need to hit /token for an access token anyway, so is the id_token there just for additional validation?)\nI have written to the OpenID Connect mailing list and my email is \"awaiting moderation\". Frustrating.\n. Also, supporting more than \"token id_token\" opens a ton of implementation questions (what gets generated when, how is it fetched, etc. You suddenly need to be able to fetch an id_token by code and other madness)\n. ",
    "julien-c": "Hmm, not sure why Travis fails. \n. @insom Oops, you're right, thanks.\n. Please note that the tests currently fail.\nThis is related to the semantics of null and false : for instance, getClientDetails for a fake client, returns false in the PDO implementation, but null in the Mongo one. \nWhich one is correct?\nWe have three choices :\n- either we make the Mongo implementation compatible with the current implementation (returns false when no data, not null)\n- or we make PDO compatible with the implementation of Mongo (returns null when no data)\n- or, we keep both implementations intact and tweak the test suite so that it, schematically, uses assertFalseOrNull (does not seem to exist in PhpUnit though)\nWhich way should I go?\n. @bshaffer Got it, I'll update my PR shortly.\n. Thanks a lot Brent! Sorry I didn't get to this earlier.\n. Reference for the new Travis build config for Mongo: http://about.travis-ci.org/blog/2013-03-08-preinstalled-php-extensions/\n. Actually, it might be an issue on Travis' part. They've been changing how things work with Mongo these last days, it might be why.\n. Travis issue report : https://github.com/travis-ci/travis-build/issues/87\n. This has got to be the longest Travis build ever (15 hrs 12 min 41 sec) :smile: \n. Thanks!\n. @bshaffer Sure! Will a demo repo on Github do the trick?\n. Will do then. Do you have a timeframe of when you'd like that?\n. Well, at least Laravel and Drupal 8 now use HTTPFoundation. For the other ones, it wouldn't be a breaking change anyways \u2013 if I'm not mistaken \u2013 as you can always extend Request and Response like you do right now.\n. :beers: \n. @bshaffer Fixed\n. ",
    "peacemoon": "the properties $db & $config in class \"OAuth2_Storage_Pdo\" are \"private\" and not \"protected\" so that i always receive error \"Undefined property: New_OAuth2_Storage_Pdo::$db\" when i try to extend the \"OAuth2_Storage_Pdo\" class\n. ",
    "sbonami": "Just kidding >.<\n. ",
    "trickleup": "Ok, great. Thanks for replying!\n. Sorry, nevermind, it broke the other grant type. Any recommendations on how to fix that for the user credentials grant though?\n. Great, thanks!\n. Thanks!\n. I may be out of my depth here, but I think there is a problem with this. $scope is the scope actually requested by the /token endpoint call, which is not provided by $tokenData.\nFor User Credentials Grant, $tokenData is fetched from User storage earlier in TokenController::grantAccessToken():\nif (!$tokenData = $grantType->getTokenDataFromRequest($request)) {\nAnd in UserCredentials.php this is deferred to $this->storage->getUserDetails() i.e. whatever scope is associated with the user. For Authorization Code Grant this is instead fetched from the Authorization Code storage.\nLater, in TokenController, if no scope parameter associated with user/auth code is found in storage, $tokenData[\"scope\"] set to the default scope:\nif (!isset($tokenData[\"scope\"])) {\n    $tokenData[\"scope\"] = $this->scopeUtil->getDefaultScope();\n}\nSo what the proposed change does is just to check whether the scope(s) stored with the user/auth code, or default scope, exists:\n// Check scope, if provided\nif (!is_null($tokenData[\"scope\"]) && !$this->scopeUtil->scopeExists($tokenData[\"scope\"], $clientData[\"client_id\"])) {\nSo the actual requested scope ($scope) is ignored (see #116). I have not experienced that User Credentials Grant grants any scope requested, only that it grants whatever scope is associated with the user, and not what's requested from /token.\nSo it seems correct that the requested $scope be checked against the user/auth code scope (as is now), i.e.:\n!$this->scopeUtil->checkScope($scope, $tokenData[\"scope\"])\n... and that the scopes in user/auth code storage are validated whenever they are created/updated against supported scopes .\nApologies for any oversights, please let me know if I have missed something.\n. Thanks!\n. thx\n. Thanks for feedback - that's a lot better.\n. +1\nJohan\nwww.trickleupfilms.org\nwww.trickleupweb.com\nOn Sun, Jul 7, 2013 at 8:58 PM, Francis Chuang notifications@github.comwrote:\n\n@bshaffer https://github.com/bshaffer What do you think about passing\nthe client_id to getDefaultScope()?\nThis would be useful when we have different types of clients in the system\nand would like to return a different set of default scopes depending on the\nclient_id if no scopes are provided.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/186\n.\n. \n",
    "aacotroneo": "Hi, Any updates on this one? I'm interested. I may take a look.\n. @F21 Of course! :) I haven't even started, but It shouldn't take long (I hope). I'll start by reading the draft!\n. Well, I'm working on it! \nMuch of the validation the oauth2-server needs to do is pretty similar to what a saml service provider does. So, I thought about making an adapter to use onelogin/php-saml which handles all the hard xml validation stuff and has lots of unit tests.\nI'm dealing with saml configuration right now. I'll try to make a simple case work, and then see how we can refactor it.\n. #510 \n. @bshaffer Here is a sample implementation of your server using Slim framework (i saw a request for that). You'll see that it also implements the saml2-bearer grant type, but there's not much to see there. It just adds the grant type with a proper configuration array. I'll see if I find a way to make a test client without needing to setup a real IDP.\nEdit: here = https://github.com/aacotroneo/saml2-bearer-server\n. Hi, I think PDO:: FETCH_ASSOC would be a better option than PDO::FETCH_BOTH as most of the interfaces that the PDO Storage implements state to return an associative array https://github.com/bshaffer/oauth2-server-php/pull/500. FETCH_BOTH brings unexpected additional data.\n. Yep, the performance thing would be a plus, but I consider PDO's default (as sensitive as it may seem) an implementation detail. The point of the PR was that we are implementing an interface (e.g. AccessTokenInterface) that returns 'associative array', not a 'mixed array' as FETCH_BOTH does. Other implementations (Redis, CouchDb, Memory.. ) do return a pure associative array.\n. FETCH_BOTH may be tricky to use, specially behind an interface. For example:\n$a = some AccessTokenInterface() ..\necho count($a->getAccessToken());\n//prints 5 'almost always'\n//prints 10 if it's a PDO Storage with FETCH_BOTH config\nI think the problem @pedrosancao had was just that he reused a PDO connection which had FETCH_OBJ as a default. So, PDO Storage failed as it expects (at least) associative keys as results from the querys. Please, could you confirm this @pedrosancao?\nIt would be a BC for those expecting the access token (in my example) to have 10 columns, or numerical indexes. But numerical indexes are not supported by the interfaces anyway.\n. Anyway, I understand your concern about BC's @bshaffer so if you want I can add a fetch_type to the constructor configuration array like you suggested and make another PR. Right now the config only contains table names, I don't know if there's a better place.\nThanks!\n. Update: Saml2 (Authorization Grants) grant type is not a ClientAssertionType. In fact, the draft states that client authentication is optional. Though it has another use for Client Authentication which obviously is a ClientAssertionType. But we may need to handle both separately.\n. I'm a little confused about how this should really be used in production. Here I link some real implementations, which have some differences and dont' give away all details:\ncase 1)\nPint Identity\ncase 2) wso2\ncase 3) salesforce\n. I agree with all recommendations. I'll make them asap.\nRegarding usage, I think that the server itself is compliant with the saml2-draft. What is missing is a way to generate valid assertions (in PHP at least), but it's kind of out of scope here.**\nI'll drop some docs at the sample project (https://github.com/aacotroneo/saml2-bearer-server) we can put that elsewhere later.\n** I'm using this grant right now. Due to this limitation, I had to drop some validations (one-login's 'strict=false' setting), but are instead made by the oauth clients (existing service providers). In this limited case, all parties need to be 100% trusted, but I can reuse the existing saml2 assertion as an implicit user authorization. Basically, each service provider 'transforms' its saml2 assertion into a oauth token to use some rest apis.\n. Right now I have a simplesamlphp server installed (with corresponding idp's) and use that (with aforementioned limitations). That's pretty heavy to make a simple integration test.\nI know that's no good. I can design some tests. I'm thinking about reusing some of the test assertions that onelogin uses in their tests. That will at least be enough to tests basic stuff.\n. 1 - This is what onelogin's says about it:\n\nIf 'strict' is True, then the PHP Toolkit will reject unsigned or unencrypted messages if it expects  them to be signed or encrypted. Also it will reject the messages if the SAML standard is not strictly followed: Destination, NameId, Conditions ... are validated too. \n\nNote that this will be a user's configuration, based on their infrastructure. It's not quite our problem right now (though it would be nice to have a nice working case).\nI couldn't create a strictly valid token to use in my infrastructure (with existing tools), so I use strict = false.\n2 - I just decoupled implementation onto the other objects in case we find another impl and to ease unit testing (I tried to avoid using real assertions in tests). Anyway it's just a code style, if you think that way is more consistent to the rest of the code, It's ok for me.\n3 - Note that this PR covered the authorization grant flow only. If I'm understanding correctly from the draft, it's not the client who issues the token. The client does not even appear on the assertion (it does for the client-auth flow but as the 'subject', not the issuer).\nThe draft states that you may however use this flow with client credentials (client_id, client_secret), and they are correctly handled by the tokenController.\n. Im not working with it anymore. But it's not a saml server. You basically pass a saml token (proof that you are auth'ed) and you get a oauth token.\n. It's used in line 34 for the default case. It's not used when you provide a Saml2AssertionInterface indeed (I used that for testing). I don't know how that can be reflected better.\n. ",
    "Kavindu-Dodan": "Doesn't it say to use base64 encoding. This phrase, \"The syntax of the \"Authorization\" header field for this scheme follows the usage of the Basic scheme defined in Section 2 of [RFC2617]\" points out to base64 encoding. As per RFC2617, Basic schema encode username password in base64 encoding. . ",
    "ademarre": "For what it's worth, I opted to use the controller classes directly. One reason is that I didn't want to instantiate dependencies (e.g. storage classes) that weren't needed for the current request. Determining which dependencies to inject pretty much came down to looking at the constructor signatures of the relevant controller class, at which point OAuth2_Server didn't seem to add much value.\n. There's little practical difference between 302 and 303, so it's more about being fastidious. 303 is better because its use doesn't bank on browsers violating the HTTP specification. The HTTP 302 Wikipedia article offers a concise explanation.\nThe \"proper\" behavior of 302 is unclear since popular browsers implemented it differently than specified in RFC 1945 - HTTP 1.0. According to the spec, when requesting a redirected resource, user agents are supposed to use the same request method as was used in the original request. So if the original request used POST, the second should use POST also. But browser vendors implemented it differently, using GET for the second request regardless of the original request method.\nSince virtually all HTTP clients violate the spec, HTTP 1.1 added codes 303 and 307 \"to make unambiguously clear\" the expected client behavior:\n\nNote: RFC 1945 and RFC 2068 specify that the client is not allowed to change the method on the redirected request.  However, most existing user agent implementations treat 302 as if it were a 303 response, performing a GET on the Location field-value regardless of the original request method. The status codes 303 and 307 have been added for servers that wish to make unambiguously clear which kind of reaction is expected of the client.\n\nRealistically, redirect responses from the authorization endpoint to the client's redirection endpoint, will probably work perfectly regardless of 302 or 303, but if we're being pedantic, I believe 303 is better because the expected behavior complies with the HTTP spec.\nThe OAuth spec says the authorization endpoint must support GET and may support POST. I don't think the spec says which methods ought to be used for the client's redirection endpoint, but the examples use GET as one might expect.\nAn unlikely corner case... If a resource owner uses a browser that handles 302 as prescribed by the HTTP spec, and he does a POST to the authorization endpoint and the response is a 302, then the browser will (after prompting the user to confirm) use POST for the subsequent request. It's possible that the redirect location is the client's redirection URI, which might not support POST.\n. ",
    "SinanEker": "I get the same, trying to generate manually a token. Have you searched in the interfaces or extending classes?\nAm 23.04.2013 um 12:40 schrieb Ben Squire notifications@github.com:\n\nHi All,\nTrying to implement the library into a ZF2 project, however in the README.md the line:\n$server->handleTokenRequest(OAuth2_Request::createFromGlobals())->send();\nI get the error:\nFatal error: Call to undefined method OAuth2_Server::handleTokenRequest()\nI've had a look through the code, however I dont find a handleTokenRequest request function anywhere.\nKind Regards\nBen\nP.S: What should it be?\n\u2014\nReply to this email directly or view it on GitHub.\n. Thank you! It works now!\n\nAm 23.04.2013 um 16:18 schrieb Ben Squire notifications@github.com:\n\nThanks @bshaffer Is there anything I can read to get a better understanding of how to implement this, I'm struggling to get my head around the dev site (I'm not familiar with Silex)... Cheers - Ben Squire\n\u2014\nReply to this email directly or view it on GitHub.\n. Hmm, what code of ClientCredentials do you exactly mean, because I followed the step-by-step instrcutions in the manual.\n. \n",
    "bensquire": "I did a recursive project search, it wasn't in any of the files...\n. Hi @bshaffer I am using this line in my composer, so version 0.5 presumably:\n\"bshaffer/oauth2-server-php\": \"v0.5\"\n. I had to update my composer file to use dev-develop:\n\"bshaffer/oauth2-server-php\": \"dev-develop\"\n. Thanks @bshaffer Is there anything I can read to get a better understanding of how to implement this, I'm struggling to get my head around the dev site (I'm not familiar with Silex)... Cheers - Ben Squire\n. Thanks @bshaffer!\n. Thanks for the feedback Brent! I can see that you call the PDO check on checkClientCredentials from HttpBasic. I could probably get something working, but I'm a bit hesitant to start changing the library, can you provide any guidance?\nCheers\nBen\n. Thanks @bshaffer , greatly appreciated!\n. Sorry about the slow reply guys, as it happens I finished the initial version of this feature shortly after @bshaffer 2nd comment. Just so we're clear I don't store the users credentials in the JS app, just the access token :)\nI haven't looked into JWT Bearer Grant Type, I'll do so now.... thanks :)\nIn the mean time @phindmarsh would you be able to share you code? I didn't go to the effort of making a new grant-type and basically just created a controller, which does what you described... At the moment we don't actually have any concept of scopes, just users and admin users :S but I take your point, thanks :)\n. Just looking to upgrade our system to PHP7 and stumbled across this issue, a merge would be fantastic :). ",
    "rjmackay": "realised this is failing tests. Let me know if I'm heading in the right direction and then I'll try to fix the tests.\n. Updated to move checkRestrictedGrantType to ClientInterface\n. Fixed a couple of minor issues in tests. The build is passing now. Let me know if anything else needs changing\n. Not sure why passing 'implicit' grant type is wrong. Implicit is treated as a seperate grant type by the spec: http://tools.ietf.org/html/rfc6749#section-4.2 so shouldn't have been combined with authorization_code in the first place.\nThe 'allow_implicit' flag is to enable Implicit Grant globally, whereas check grant type checks if a specific user is allowed that grant type. So these flags shouldn't be combined.\nMaybe it would be better if Implicit Grant had a seperate class from AuthorizationCode ?\n. @bshaffer I was referring to the fact there's only a grant type for AuthorizationCode, not a separate one for Implicit. \nI think the current implementation is workable. Maybe not entirely clear.. You enable all other grant types by adding GrantTypes but implicit has a special option.\n\"I don't see a reason to create a GrantType object for it, as it does not follow the rules of other grant types.\"\nI guess this makes sense since GrantTypes are not checked in Authorize controller.. I wonder if they should be since at the moment you can still get an authorization code even if this grant type is disabled, you just can't exchange that for an access token.\nNot sure if any of this changed with the recent server refactor?\nAll that said: I have everything I need working the current implementation, so I'm totally happy with this. Thanks for the hard work!\n. Sounds good. I haven't managed to update my application to use the latest refactored Server class yet - so not in a great position to work on this right now. Might have some time to help with this in a couple of weeks though.\n. Great, Thanks!\n. Updated and fixed coding style\n. Good catch on the insufficient_scope error, I hadn't noticed that was supposed to be a 403.\nNot 100% sure on WWW-Authenticate and 400. I've been reading http://tools.ietf.org/html/rfc2617 for more info too. I think www-authenticate is only valid for 401 responses, so not needed for 400 or 403.\n. Good point. 403 clearly gets the header with scope.\nMaybe 400 does too. What are we still returning 400 errors for?\nIf we return errors for something like trying to use the wrong token type (HTTP MAC where only Bearer is supported) that might make sense as a 400 error with a WWW-Authenticate header to show which token types ARE allowed.\n. I haven't had time to do a full review, but in everything I'm actively using this is fixed appropriately.\n. changed to OAuth2_Storage_ClientCredentialsInterface since thats needed for the checkRestrictedGrantType() call\n. OK will change. Sorry I work with Kohana normally which only uses PSR-0 and its own coding style, not PSR-2.. \n. ",
    "alkhoo": "Agreed, lets move on with PHP 5.5, I like the password_hash() function so that sensitive password is not stored in plain sight. \nQuestion: Does it make more sense to hash the password or would it break oauth2 RFC?\nNote: StackOverflow has a nice implementation for using bcrytpt() with PHP.\n. To read between the lines: \n1.   Yes, best to hash password with own application code and\n2.   No, it wont break the oauth2 RFC or the php oauth flow\nNext question: With bcrypt() or password_hash(), doesn't it make sense to update library  (eg:\"GrantType/UserCredentials.php\") for a global hash instead of making sure the line $request->request(\"password\") = bcrypt($password) exist in each application file?\n. Addendum: Here is my own flavor of bcrypt.php:\n```\n<?php\nif(CRYPT_BLOWFISH != 1) {\n    throw new Exception(\"bcrypt not supported in this installation. See http://php.net/crypt\");\n}\nfunction bcrypt($password,$cost)\n{\n    $salt=sprintf('$2y$%02d$',$cost);\n//For PHP < PHP 5.3.7 use this instead\n//    $salt=sprintf('$2a$%02d$',$cost);\n    $random = uniqid($salt,true);\nreturn crypt($password,$random);\n\n}\n``\n. To verify a password with the hash stored in database, I'd require the hash's salt, henceStorageInterface` is the best insertion point for a this quick hack without resorting to lengthy logic within the application code.\n. The larger picture is: if  tags of website is utf8, then database's character sets should follow suit. My knowledge of the entire library is still rudimentary, not enough to implement a global character set update. \nTo conform: Is Storage the only place that requires tweaking? \n. ",
    "atrauzzi": "I believe so.  Any structure of data could be encoded (array, json) and then when the token comes back, the expiry is the only thing that has to be inspected to determine validity.\nThe data - say a user id - would then be made available for the application to use.\n. Rails does offer some functionality for this, I've heard it referred to as \"HTTP token authentication\"\nhttp://api.rubyonrails.org/classes/ActionController/HttpAuthentication/Token.html\n. ",
    "mmdumi": "Thanks for your review. I've had some troubles with textmate and space indentation.\nI've followed your comments, fixed the spaces and also changed the constructor of TokenController to not pass the storage. I had to only add the config property to know if the user selected the 'return_existing_token' or not.\n. Sounds good\n. Is this what you had in mind ? \n. ",
    "csiszarattila": "Any chance to merge this feature in the future?\n. ",
    "gundamew": "I had some misunderstanding... Sorry for annoying.\n. ",
    "ahukkanen": "Well, I don't know if this is the best place to explain the whole situation but just noticed this by \"accident\" when testing the library.\nThe main point is that if it claims to be compliant with the RFC, it should follow every word in it.\nBut if you want to know the full story, it is that I'll need to use the User Credentials grant type for a native mobile application. With that grant type, both client secret and client ID are required. Then the RFC explicitly defines the following here:\nhttp://tools.ietf.org/html/rfc6749#section-10.1\nThe authorization server MUST NOT issue client passwords or other\n   client credentials to native application or user-agent-based\n   application clients for the purpose of client authentication.\nHowever, the next sentence from that allows issuing installation-specific passwords. But currently I'm not that convinced that it would add any layer of security to issue each instance of the application their own id/secret pairs vs. just having one global id as the requests are always authenticated against the user credentials as well.\nUsing a browser-based authentication flow isn't a possibility in this case.\nSo by the RFC my options are:\na) store instance-specific id/secret pairs on each device where the app is installed\nb) not to store client secret\nCurrently I'm leaning against b) because I don't see the added layer of security by issuing each client their own id/secret pairs. If they are both physically stored on the device, they can still be read by people who should not see them. And the token requests are still authenticated with the user credentials, so what's the point?\nI'm also starting to feel more like the whole RFC is flawed from the ground up for this use case and thinking whether I should use OAuth2.0 for this purpose at all.\n. Sorry, the link above was incorrect, so I corrected it.\n. Thanks a ton! Nice to see active development on this.\nAnd by the way, at this point, the API is up and running (in testing), haven't noticed any other issues so far. Great work!\n. ",
    "dangreaves": "You're welcome :)\n. ",
    "cameronk": "After some more testing, it seems that this doesn't work with Oracle, Postgre. or MS SQL Server. As @dsquier said, it's probably a good idea to conform with a standard such as ANSI SQL-92 for portability. However, I'm not particularly familiar with the syntax of DBMS's other than MySQL. I've pushed another commit, updating the README to include a schema which is compliant with MySQL and SQLite for the time being.\n. The above commit addresses all major DBMS's (MySQL, SQLite, Oracle, MS SQL, PostgreSQL) and contains the correct schema for each system.\n. @abeverley that's correct so far as I can tell. I'd recommend checking for the existence of each index before actually using it though, probably using isset() or a similar method.\n. ",
    "cpjolly": "Thanks for the info. One of the problems with FOSOAuthServerBundle is that it relies on\nhttps://github.com/FriendsOfSymfony/oauth2-php\nWhich is based on the old pre-standard Google oauth2 php library. The oauth2-php bundle has not been updated in line with the later revisions of the standard.\nIt all works fine for simple use-cases, but IMHO it's not a solid platform for going forward. I've done quite a bit of work extending it for my requirements. Perhaps I'm alone in using OAuth2 for a wide variety of authorization scenarios, but I'd much prefer to develop against a well supported library like yours.\nThanks again - Chris Jolly\n. Hi again Brent - I thought you might be interested in this blog post from Fabien Potencier, which talks about some simplifications being made in the security component of Symfony 2.4 to allow easier extension.\nhttp://symfony.com/blog/new-in-symfony-2-4-customize-the-security-features-with-ease\n. ",
    "abeverley": "Thanks, I'll send one shortly. The thing I struggled with was retrieving the user ID during a resource request. I ended up doing the following - is it correct?\n``` php\nif (!$server->verifyResourceRequest(OAuth2_Request::createFromGlobals(), new OAuth2_Response())) {\n    $server->getResponse()->send();\n    die;\n}\n$token = $server->getAccessTokenData(OAuth2_Request::createFromGlobals(), new OAuth2_Response());\necho \"User ID is \".$token['user_id'];\n```\n. Thanks for notifying me. I've made a pull request for the Google cookbook stuff.\nWith regards to the user_id documentation, do you think it's better in the walkthrough example (as it was previously, as it is indeed an example), or in its own page (as it's not documented anywhere else).\n. Hi Brian,\nThanks for the prompt reply. I was thinking an error message more along the lines of the existing \"The request requires higher privileges than provided by the access token\" error message (i.e. the scope is supported, but the requested user does not have access to it).\nTo be honest, partly the reason for asking the question was to check whether I had missed existing functionality to do this, so you have answered that question.\nIn terms of going forward, I had a look at the source code, and wondered whether something like the following would be considered:\n- Store the user's available scopes in the server object when \"logging in\" the user.\n- When a token is requested, add the user's scopes to the token, only if available (otherwise return a 401 error).\n- Once the relevant scopes have been stored with a token, the token requests can be processed as normal.\nI'm happy to have a look at this and see if I can produce a patch, if you think this is the correct way to go?\nThanks,\nAndy\n. I was just going to reply and say that I'd reconsidered my way of doing things! I need to look at everything in a bit more detail, but I was thinking that for my particular application, I'll probably just use scope in the way it was originally designed (i.e. have the client request the scope required).\nThe account holder for my application will create a separate API user(s) for access to their account (for info, this is a mailing list manager). My thought was that the scopes for the user(s) could be specified as well, in order to add an extra layer of protection, but I'm beginning to think there is not much point in doing this. I was, however, thinking of having a \"read only\" option for the API user, so I'll have to look at that in a bit more detail.\nThanks,\nAndy\n. Ah okay, I was worried I might get the terminology wrong!\n. No, I just wanted to make it clear that to get that part of the code working it required a different kind of grant, rather than an extra one. I incorrectly read the instruction as the grant line should be added to the end of the file instead.\nSomething like: \"...Just add the following grant type to token.php in place of (or just after) the previous ClientCredentials grant type...\" would probably be better instead I guess.\nI'll submit another pull request, once I've worked out how to do it.\nThanks\n. ",
    "theminjus": "Please change\n$token = $server->getAccessTokenData(OAuth2_Request::createFromGlobals());\ninto this\n$token = $server->getAccessTokenData(OAuth2_Request::createFromGlobals(), new OAuth2_Response());\non link\nhttp://bshaffer.github.io/oauth2-server-php-docs/overview/userid/ \nthanks :)\n. ",
    "frey1esm": "Can the user_id be returned with a new token?. ",
    "shahabmusic": "Can the user_id be retrieved from the access token? user_id is null in my access token. how to set it?. ",
    "sttarneyiat": "I am using the library for my own implementation and had this issue. I did\ndownload the demo app and played with it and the issue is there too. I did\nreport an issue on the demo app as well (\nhttps://github.com/bshaffer/oauth2-demo-php/issues/19) but it seemed to me\nthat the changes needed were in the vendor folder. I could be wrong if you\nlook at the demo issue I opened there are more details to where I thought\nthe issue may be.\nOn Jun 10, 2013 8:51 PM, \"Brent Shaffer\" notifications@github.com wrote:\n\nAre you referring to the oauth2 demohttps://github.com/bshaffer/oauth2-demo-phplibrary? If so, this issue should be opened\nthere https://github.com/bshaffer/oauth2-demo-php/issues/new instead of\nhere.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/153#issuecomment-19235393\n.\n. The issue is the refresh token. Since one is issued shouldn't it use the\nrefresh token to get a new access token once the access token expires? I\nset the expires_in to 10 seconds to just rapid test it. The access token is\nfine and works perfectly until it expires as expected, then the refresh\ntoken should be used to retrieve a new access token. That is the step that\ndoes not seem to occur.\n\nFrom my understanding the refresh_token would be used to request new access\ntokens. Am I misunderstanding the function of the refresh_token?\nOn Jun 11, 2013 11:02 AM, \"Brent Shaffer\" notifications@github.com wrote:\n\nCan you try to explain what the issue is again? I am having a hard time\nunderstanding the problem.\nYou've set the expiration to ten seconds, so the access token expires\nafter ten seconds. This is the correct behavior.\nWhy would you want your access token to expire in 10 seconds?\n\u2014\nBrent Shaffer\nOn Tue, Jun 11, 2013 at 8:07 AM, sttarneyiat notifications@github.com\nwrote:\n\nI am using the library for my own implementation and had this issue. I\ndid\ndownload the demo app and played with it and the issue is there too. I\ndid\nreport an issue on the demo app as well (\nhttps://github.com/bshaffer/oauth2-demo-php/issues/19) but it seemed to\nme\nthat the changes needed were in the vendor folder. I could be wrong if\nyou\nlook at the demo issue I opened there are more details to where I\nthought\nthe issue may be.\nOn Jun 10, 2013 8:51 PM, \"Brent Shaffer\" notifications@github.com\nwrote:\n\nAre you referring to the oauth2 demo<\nhttps://github.com/bshaffer/oauth2-demo-php>library? If so, this issue\nshould be opened\nthere https://github.com/bshaffer/oauth2-demo-php/issues/new instead\nof\nhere.\n\u2014\nReply to this email directly or view it on GitHub<\nhttps://github.com/bshaffer/oauth2-server-php/issues/153#issuecomment-19235393>\n.\n\nReply to this email directly or view it on GitHub:\n\nhttps://github.com/bshaffer/oauth2-server-php/issues/153#issuecomment-19260152\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/153#issuecomment-19267328\n.\n. \n",
    "robotrobot": "For anyone else searching for a solution for this, I solved it by doing:\n<form method=\"post\" action=\"/myresource?access_token=MY_TOKEN_HERE\" enctype=\"multipart/form-data\">\n. Thanks bshaffer, wow that was super quick! Also I think this should be OK for non-critical use cases esp. over SSL. Great library, BTW.\n. Sweet, thanks\n. Ok thanks for the clarification guys...\n. HHVM works but you need the specific mongodb.so for that env. \n. Test fails because Call to undefined method MongoDB\\Driver\\Manager::setAuthorizationCode() in /home/travis/build/bshaffer/oauth2-server-php/test/OAuth2/OpenID/Storage/AuthorizationCodeTest.php on line 77. \nI think you need to be more specific here and use the namespace new \\OAuth2\\Storage\\ MongoDB because the error suggests you are trying to call the setAuthorizationCode on the underlying MongoDB driver class, which obv won't work.\n. ",
    "reinink": "I second this request to use Symfony's HTTP Foundation. I also agree with @bshaffer that we need a standard interface for this sort of thing. I'd love to see PHP-FIG put something out like this, similar to the logger Interface. But yeah, until that happens HTTP Foundation is an excellent choice.\n. Ahh right, no namespaces.\nI did a little digging and I think PHP-FIG recommended response/request interfaces are in the works. From @philsturgeon\u200e's blog:\n\nSimon: Yeah we're working on finding an Editor for a HTTP Message/Request/Response PSR, then the HTTP Client Interface could be done a little later on.\nIt's not going to be quick, but it's progress.\n. @philsturgeon Understood!\n. @philsturgeon Haha, no worries. Thanks for the follow up either way\u2014I'm glad to know you guys and gals have this on your radar.\n. @bshaffer This looks to me like another great reason to move to HttpFoundation. I'm curious if @mikspark's issue would go away if he used it instead. I've actually already started using the HttpFoundation\\Request object, see my class below.\n\nThe main reason I did this was because I have other libraries that depend on the HttpFoundation\\Request, and when I used the OAuth2\\Request class simultaneously, there would be missing PUT parameters. It must have something to do with how these libraries read the PUT content from the php://input stream. Once one class got those values, the other one wouldn't.\n``` php\n<?php\nclass Request extends \\Symfony\\Component\\HttpFoundation\\Request implements \\OAuth2\\RequestInterface\n{\n    public function query($name, $default = null)\n    {\n        if ($this->query->get($name)) {\n            return $this->query->get($name);\n        } else {\n            return $default;\n        }\n    }\npublic function request($name, $default = null)\n{\n    if ($this->request->get($name)) {\n        return $this->request->get($name);\n    } else {\n        return $default;\n    }\n}\n\npublic function server($name, $default = null)\n{\n    if ($this->server->get($name)) {\n        return $this->server->get($name);\n    } else {\n        return $default;\n    }\n}\n\npublic function headers($name, $default = null)\n{\n    if ($this->headers->get($name)) {\n        return $this->headers->get($name);\n    } else {\n        return $default;\n    }\n}\n\npublic function getAllQueryParameters()\n{\n    return $this->query->all();\n}\n\n}\n```\n. @dsquier That makes perfect sense, thanks! Since posting this question a few days ago I've actually learned that scopes are probably the best way to do this.\nI still have a design question, which maybe you can help me with?\nFor the webapp client, I was also going to enable the password grant type as a way of logging my users in. I guess I could also just use client_credientials and then have a separate login API call. However, it seemed to make sense to use OAuth to log the users in. Is there a preferred way to do this?\nUpdate: I've started a question on StackOverflow to better explain where I'm still having trouble.\n. @dsquier Understood. I guess it just feels like good practice to encrypt passwords, just in case the database was ever compromised.\n. > Keep in mind the Authorize header is still the preferred way to authenticate with an access token, unless otherwise unavailable\nInteresting, I didn't even realize that. In that case, do you think it's even worth updating the library to accommodate PUT and DELETE? I ran into this issue while building a RESTful API, but if headers are the norm, that I'd rather go that direction.\n. ",
    "philsturgeon": "The FIG HTTP Message/Response PSR does not exist even in a Pre-Draft form. We're trying to get the people together to work on it, but it will take time. If/when it does get approved maybe it could be worked into the next major version, but its impossible to use it at this point.\u00a0\nEven if the Draft existed right now, it would be 2 months before it was accepted assuming nobody had any problems with anything. \n. @reinink I edited the response a little. I replied from my mail client and I assumed you were talking about https://github.com/php-loep/oauth2-server\n. ",
    "mikeziri": "how come am I getting this status code < HTTP/1.1 200 OK\nand this json\n{\"error\":\"invalid_grant\",\"error_description\":\"Invalid username and password combination\"}\nI should get 400 our 401\nEdit:\nmy bad. on the routes file/ controller I wasn't returning the response. It was just being called\n. ",
    "raymondjplante": "Ok, so the JSON response with token_type is the correct thing to expect.  Yes, I'm was wondering where the type of token is being stored--but now I see it's hardcoded into the Access token constructor.\n. I ran into this issue as well.  When requesting a code without  supplying the redirect URI, the following request for the  access token using the returned code should not require a redirect URI.  It looks like whenever a Code is requested the redirect_uri is copied from the Client table if not supplied in the code request.  When requesting the access token if the redirect_uri field isn't empty, it will fail on access_token request without a redirect API specified. I found a way around this:\n1. Request the code without the redirect uri\n2. in the oauth_authorization_codes table delete the redirect_uri value\n3. Make the access toke request\n4. Viola! It works....\nI implemented my own storage that never stores the redirect URI in the authorization_code table...  This isn't compliant, but I don't require my users to supply it and alway use the redirect url from the client table.\n. ",
    "fahmiardi": "OS: mountain lion use MAMP packages\nphp version: 5.3.6\n. And one again, what oauth2 version draft in this library?\n. interface GrantTypeInterface\n{\n    // I comment this two lines, and works\n    // public function validateRequest(RequestInterface $request, ResponseInterface $response);\n    // public function getClientId();\n    public function getUserId();\n    public function getScope();\n    public function createAccessToken(AccessTokenInterface $accessToken, $client_id, $user_id, $scope);\n}\n. That's correct. Thank's for clarification. I'll try use php 5.2. Maybe the next release, this library will support to earlier php versions. Great Library..\n. ",
    "zied-ellouze": "I used PHP 5.5.9, i have this problem\n. I'm sorry\nthe server uses 5.3.3, 5.5.9 it was one of my local machine \nI migrated to version 5.4, the problem is solved\n. What exact Eroor?\nI'm use centos6 and Php5.4.33, it's great\n. ",
    "dreaddymck": "Has anyone found a solution to this? I've upgrade to 5.4 and am still experiencing the error.\ncentos 6 \nPHP 5.4.33 (cli)\nOr\nCan someone recommend an alternative library.\n. @zied-ellouze The error I am experiencing is:\nFatal error: Can't inherit abstract function OAuth2\\Storage\\AuthorizationCodeInterface::setAuthorizationCode() (previously declared abstract in OAuth2\\OpenID\\Storage\\AuthorizationCodeInterface) in /home/dreaddy/projects/Pinnacle/oauth/oauth2-server-php/src/OAuth2/OpenID/Storage/AuthorizationCodeInterface.php on line 14\nEDIT\nyum install php54w ( plus the additional modules ) resolved the issue. Thank you.\n. @bshaffer checked my history. I think a result of a typo in the command\n yum install ..... php54w-pdo.... \nfor my initial php54w install attempt.\n. @bshaffer \nunderstood. \nPrior to the upgrade I was running  php 5.3.x latest on CentOS release 6.5 (Final). \n. ",
    "almaruf": "@bshaffer  I have this problem on PHP 5.3.8\nCan't inherit abstract function OAuth2\\Storage\\AuthorizationCodeInterface::setAuthorizationCode() (previously declared abstract in OAuth2\\OpenID\\Storage\\AuthorizationCodeInterface)\n. @needcaffeine  thanks\n. 0eefa2e209f3ba9a25cf07dfc96640e946c9d2fc oauth2-server-php (v0.9-328-g0eefa2e)\nMy PHP Version 5.4.27 running using XAMPP 3.2.1\n. I just tried your cookbook example in a Zend application , it fails at the init()\nclass TestController extends Zend_Controller_Action\n{\n    protected $_server;\n```\npublic function init() {\n    $appConf = Zend_Registry::get('config');      \n    $storage = new Api_Oauth2Storage( $appConf->resources->db->params );\n$this->_server = new OAuth2\\Server($storage);        \n$this->_server->addGrantType(new OAuth2\\GrantType\\UserCredentials($storage)); //PASS\n$this->_server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($storage)); // FAIL\n$this->_server->addGrantType(new OAuth2\\GrantType\\ClientCredentials($storage)); // FAIL\n\n}\npublic function testAction(){\n}\n```\n}\nBTW, the namespace is registered using Zend_Loader_Autoloader\n. My storage class extends the OAuth2\\Storage\\PDO class, if that matters at all https://gist.github.com/almaruf/33cfb5d466889b7128b5 \n. Found the issue, there was an oauth2 client using the same namespace Oauth2\\ here https://github.com/adoy/PHP-OAuth2 in one of the oauth2 client library that is included in my lib path.\nThanks for your direction :+1: \n. not sure its a great solution, but I changed the namespace used by the Oauth2 client, that works. ",
    "storeformypet": "bshaffer,\nThank you!\n. ",
    "davidkuridza": "@raymondjplante I ended up doing the same thing, just wanted to double check whether I'm not doing something wrong :)\n@bshaffer Sounds reasonable, will look into it after Wednesday next week when I get back to civilization (bad timing, but we had a trip planned for some time now). Unless it's already fixed by then of course :)\n. First thing I saw this morning when getting back was an email saying redirect_uri problem is fixed. I fetched the changes, tested them out and everything works as it should. Kudos to you, sir! :+1: \n. I fixed problematic whitespace indentation and amended the commit for this PR, as a side affect @bshaffer's comments where hidden. Sorry about that.\nAs for unit test, I'm having problems running the suite locally, will try again later today if time permits.\nOn a side note, do you have or plan on having a contribute guide?\n. I apologize for taking so long. Test added to verify #163 was not checking the actual value contained in $response->getHttpHeader('Location'), only the presence of code in the string. Try running the test on develop branch, you'll see it's failing, if you try debugging, $response->getHttpHeader('Location') will only contain ?code=....&state=xyz.\nChanges from develop branch have also been rebased and pushed to this one. There shouldn't be any problems merging it to upstream.\n. ",
    "steffkes": "not sure if i like this one .. but okay, the specs .. rolling eyes then at least i'll make sure (w/ another PR) that the response is  really empty and doesn't even contain an empty json-object\n. hmmm, yeah, well. the problem comes with bshaffer/oauth2-server-httpfoundation-bridge because the Response there extends JsonResponse from Symfony/HttpFoundation and they are using an ArrayObject if the content is empty (https://github.com/symfony/HttpFoundation/blob/master/JsonResponse.php#L41-43)\nwe could overwrite that by calling setContent but that's not available in OAuth2\\Response in this Package :?\n. ",
    "Pym": "What about something simpler, like set the access_lifetime to false:\nphp\n$server = new Server($storage, [\n    'access_lifetime' => false\n]);\nAnd in the getAccessTokenData() from OAuth2\\Controller\\ResourceController.php, we would have to replace the expired token check with:\nphp\n$this->config['access_lifetime'] !== false && time() > $token[\"expires\"]\nWhat do you think?\n. I will fix that and write a test for it.\nBut I don't really see a security threat here. Can you develop?\n. Yeah, of course. Our system is a bit different, since ours tokens are deleted at the end of our users sessions. I'm not so sure about my PR anymore, because like you said \"this goes against pretty much everything OAuth2 stands for\".\n\nIf omitted, the authorization server SHOULD provide the expiration time via other means or document the default value.\n. \n",
    "pjcdawkins": "A question can always be asked again!\nRFC 6750 says: \"Token servers SHOULD issue short-lived (one hour or less) bearer tokens, particularly when issuing tokens to clients that run within a web browser or other environments where information leakage may occur.  Using short-lived bearer tokens can reduce the impact of them being leaked.\"\nI'm prepared to go against a SHOULD.\nThe use case for me is API tokens, where (like GitHub's personal access tokens) there is an appropriate user interface with appropriate security mitigations (password confirmation, etc.) for users to create their own tokens, which they can revoke at any time, manually limit the scope, and potentially track usage, etc.\n\\OAuth2\\Controller\\ResourceController::getAccessTokenData() is where the expiry checking is done, and it will take quite a few layers to override it. I think the expiry checking should be more flexible. Can it just be done in something like AccessTokenInterface, with an isExpired() method?\n. Agreed, it would be useful to implement this, for revocation of refresh tokens and their associated access tokens together.\nSee RFC 7009 https://tools.ietf.org/html/rfc7009\n\nIf the particular token is a refresh token and the authorization server supports the revocation of access tokens, then the authorization server SHOULD also invalidate all access tokens based on the same authorization grant (see Implementation Note). If the token passed to the request is an access token, the server MAY revoke the respective refresh token as well.\n\nRegarding BC, I think that problem could be overcome. A new interface could be provided, for example (just a thought):\n``` php\nnamespace OAuth2\\Storage;\ninterface HierarchicalTokenInterface\n{\n  public function setParent($token);\n  public function getParent($token);\n  public function getChildren($token);\n}\n``\n. I'd just like to note here:truewas not the previous behavior, UNLESSalways_issue_new_refresh_tokenwas alsotrue`.\nSo this PR actually introduced a change (and it happened to cause our implementation to break).\n. I think this is a bug elsewhere actually\n. +1!\n. Better: more explicit and each option now does what it says it will\n. Looks like this would be resolved by #773 \n. The PR looks good to me \ud83d\udc4d\n... @bshaffer ?\n. The library requires the mcrypt extension. But PR #773 may resolve that\n. ",
    "mlambley": "My database server allows me to specify an expiry date of 01/01/6000, which gets around this problem.\nHowever +1 for a token isExpired method which can be easily overrided.. ",
    "jwilleke": "OAuth 2.0  Access Tokens are supposed to be \"short lived\" and it is recommended in  OAuth 2.0 Threat Model and Security Considerations.\nAnd as mentioned \"RFC 6750 says: \"Token servers SHOULD issue short-lived (one hour or less) bearer tokens\".\nTo extend the token use of the refresh token is well defined and the accepted OAuth 2.0 protocol method.. ",
    "jgoux": "Hello,\ncan you give an example of how to not send a refresh token when using the User Credential grant ?\nBy default it returns a refresh token.\n. ",
    "pedrosancao": "I notice the same issue, and figured out a dozen way to make it flexible.\nThe OAuth2\\ResponseType\\AccessToken receive the RefreshToken storage object in the constructor,  and this storage is \"magically\" created in OAuth2\\Server::addStorage it line 340 (in v1.3 tag).\nThe best two approach i thought:\n1 - to verify the existence of a OAuth2\\GrantType\\RefreshToken instance in the server, somewhere in the stack:\n- OAuth2\\Server::grantAccessToken\n- OAuth2\\Controller\\TokenController::grantAccessToken\n- OAuth2\\GrantType\\AuthorizationCode::createAccessToken\n- OAuth2\\ResponseType\\AccessToken::createAccessToken\n2 - make the same verification above in the OAuth2\\Server constructor, preventing the automatically creation of the RefreshToken storage object\nI would be glad to help in this improvement, but I want to discuss the solution first.\n. PDO::FETCH_BOTH is the default behavior as stated in the documentation, but considering the memory saved by avoiding duplicated data seems a nice improvement.\n. Confirm, my connection used FETCH_OBJ as default, so the setting the default PDO behavior should fix this specific issue\n. ",
    "simshaun": ":thumbsup:\nI encountered this issue after pressing Cancel on the authorization request form. No redirect_uri param was given in the URL and the lib was not using the redirect_uri from storage, so Response threw an exception about redirecting to an empty URL.\nThis PR fixed it.\n. It tells you exactly what the error is.\nYou have to send a POST request to request_token.php, not a GET.\nThe POST data should contain the code and grant_type parameters.\n. ",
    "mihahribar": ":+1: \n. ",
    "ywliu": "Sorry. A typo of my own.\nI meant on line 19 in Redis.php, it is \"JWTBearerInterface\" (capital W, capital T in JWT), but in other similar implentations, such as on line 22 in Pdo.php or on line 18 in Mongo.php, it is  \"JwtBearerInterface\" (lower-case w, lower-case t in JWT).  The file name of the interface is \"JwtBearerInterface.php\" so \"JWTBearerInterface\" in Redis.php would make the autoloader fail to find \"JWTBearerInterface.php\" on case-sensitive file systems, such as Linux.\nHope this time my explanation is clear. :)\n. ",
    "andrew13": ":+1: \n. ",
    "cristian-v": "The request to receive a token from an authorization code. \nExchange the token\n<form action=\"http://localhost/server/oauth/token/\" method=\"post\" enctype=\"multipart/form-data\" >\n        <input type=\"hidden\" name=\"grant_type\" value=\"authorization_code\">\n        <input type=\"hidden\" name=\"code\" value=\"fd853fa66e10f1d891ea83e2335412fed0a9c4fe\">\n        <input type=\"hidden\" name=\"client_id\" value=\"Cris\">\n        <input type=\"hidden\" name=\"client_secret\" value=\"Experimenting\">\n        <input type=\"hidden\" name=\"redirect_uri\" value=\"<?php echo urlencode('http://oauth:oauth++@localhost/client/redirect.php'); ?>\">\n        <input type=\"submit\" name=\"submit\" value=\"Exchange auth with token\">\n    </from>\nThe integration of the library\n```\n//adding the autoloader\nrequire_once('OAuth2/vendor/autoload.php');\nclass Oauth2Library {\n    public $dns;\n    public $user;\n    public $pass;\npublic function token(){\n    // creating the server\n    $this->setup();\n\n    // Handle a request for an OAuth2.0 Access Token and send the response to the client\n    $this->server->handleTokenRequest(OAuth2_Request::createFromGlobals(), new OAuth2_Response())->send();\n    return;\n}\n\npublic function authorizeFormSubmit()\n{\n    //create the server\n    $this->setup();\n\n    // check the form data to see if the user authorized the request\n    $authorized = true;//(bool) $this->request->get('authorize');\n\n    // call the oauth server and return the response\n    return $this->server->handleAuthorizeRequest(OAuth2_Request::createFromGlobals(), new OAuth2_Response(), $authorized)->send();\n}\n\npublic function setup(){\n    // $dsn is the Data Source Name for your database, for exmaple \"mysql:dbname=my_oauth2_db;host=localhost\"\n    $this->storage = new OAuth2_Storage_Pdo(array('dsn' => $this->dsn, 'username' => $this->user, 'password' => $this->pass));\n\n    // Pass a storage object or array of storage objects to the OAuth2 server class\n    $this->server = new OAuth2_Server($this->storage);\n\n    // Add the \"Authorization Code\" grant type\n    $this->server->addGrantType(new OAuth2_GrantType_AuthorizationCode($this->storage));\n    return;\n}\n\n}\n```\nThe sql with the oauth client \nINSERT INTO  oauth.oauth_clients (\nclient_id ,\nclient_secret ,\nredirect_uri\n)\nVALUES (\n'Cris',  'Experimenting',  'http://oauth:oauth++@localhost/client/redirect.php'\n); \n. The storage.json file\n{\n    \"authorization_codes\": {\n        \"testcode\": {\n            \"client_id\": \"Test Client ID\",\n            \"user_id\": \"1\",\n            \"redirect_uri\": \"http://user:pass++@brentertainment.com:2222/authorize/cb?auth_type=oauth\",\n            \"expires\": \"9999999999\"\n        }\n    }\n}\nThe function that tests this code:\n\npublic function testInvalidRedirectUri(){\n        $server = $this->getTestServer();\n        $request = TestRequest::createPost(array(\n            'grant_type' => 'authorization_code', // valid grant type\n            'code'       => 'testcode',\n            'client_id' => 'Test Client ID', // valid client id\n            'client_secret' => 'TestSecret', // valid client secret\n            'redirect_uri' => 'http://user:pass++@brentertainment.com:2222/authorize/cb?auth_type=oauth',\n            'scope' => 'clientscope1 clientscope2 scope1 scope2 scope3'\n        ));\n        $server->handleTokenRequest($request, $response = new Response());\n        $this->assertTrue($response instanceof Response);\n        $this->assertEquals($response->getStatusCode(), 200);\n        $this->assertNull($response->getParameter('error'));\n        $this->assertNull($response->getParameter('error_description'));\n        $this->assertNotNUll($response->getParameter('access_token'));\n        $this->assertNotNUll($response->getParameter('expires_in'));\n        $this->assertNotNUll($response->getParameter('token_type'));\n    }\n.",
    "gplv2": "I'll try to reproduce the warnings I initially had  in the error.log, most of them where complaints.  It's the fact that for sqlite you don't need username/password in de DSN they are being used unassigned.   This was a quick fix.  I'll spend time on it later today to sort it out.    with error reporting of E_ALL as in the provided examples, it will warn about this everytime.  Maybe It was wrong on my part to call it an error, I will confirm this though, really like this implementation.   Allow me to rephrase it as warnings.  My bad.\n. Yes, I understand perfectly.  It might be the version, hence the reason I specifically checked out this version due to the php version constraints I'm working with atm.  I'll get it sorted out and come back to you. Cheers.\n. Done\n. I just deleted the line in vi and saved,  I don't see what you mean.\n. ",
    "coveralls": "\nChanges Unknown when pulling 4c376beadf6ec4aff6ff523ff4b0ad7b1c19e00b on gplv2:php5.2-develop into * on bshaffer:php5.2-develop*.\n. ",
    "joscarsson": "This is the second hit when googling this, so to be absolutely correct it should be noted that the client credentials grant type SHOULD NOT issue a refresh token (http://tools.ietf.org/html/rfc6749#section-4.4.3). I think you are confusing it with the implicit grant, in which refresh tokens MUST NOT be issued.\n. ",
    "Kalyse": "Does anyone know the rationale for this? I actually can't figure out why this would be the case. Seems like an arbitrary decision?..\nMy first thought was that client_credentials grant doesn't require a username and password so an attacker who compromises your application key would find it easier to stay hidden?\n. I posted this many months ago.. \nhttp://stackoverflow.com/questions/29233772/why-is-a-refresh-token-not-provided-by-oauth2-servers-responding-to-a-client-cr\n. ",
    "dashohoxha": "Maybe because it makes no sense to refresh a token, when you can just as easy get a new one (no user approval required for getting a token when using client credentials).\n. I think that you should expire both the Access token and the Refresh token, because with a valid Refresh token you can get an Access token. This seems to be obvious.\n. For the case that you mention, another solution (besides having grant types per client) would be this:\nCreate two servers, enable proper grant types for them, then assign 20 clients to one of them and 1 client to the other.\nBut the problem here is that you can use only one server for authenticating services (at least in the Drupal implementation). So, you have to create two different endpoints and enable authentication servers and resources respectively for each of them. Then 20 of the clients will access one of these endpoints, 1 client will access the other.\nI am not sure whether this is a better solution than having grant types per client. However there is another problem that I have tried to solve in this way (using more than one endpoint). I have some services that can be accessed both publicly or with authentication (oauth2). When they are accessed with authentication, then some additional options are available.\nI couldn't find a better solution for this problem, other than using two endpoints. For one endpoint I use authentication with oauth2, for the other no authentication. The services (resources) are enabled on both endpoints. So, if you want to access them anonymously you have to use one endpoint, if you want to access them with authentication you have to use the other endpoint.\nUsing two endpoints seems to me a bit clumsy (not elegant) solution, but I don't know how a better solution could be. \n. Yes, but you can have two different groups of settings and scopes, and then you don't have to do per client configuration. I don't see what is wrong and why it is a mistake. If you can have different settings and scopes for each client, and only a single server, then what is the purpose of having a server? You can remove it at all.\nA better solution could be to allow different ways of authentication per resource (if this is possible), including no-authentication (public resource). For example, if you have three different oauth2 servers, you can select (with checkbox) for each resource which one of them can be used for authentication.\nAnyway, I am not sure how much this discussion is relevant to oauth2-server-php.\n. But if you have no servers you will have to enable resources for all the clients, instead of enabling them for groups of clients (servers). At least this is how the Drupal module 'services' works.\nAnyway, you know the details better than me, so do whatever you think is best.\n. I have encountered this problem in Drupal7 as well: a resource can be accessed publicly (no need for access token) or with authentication (there is an access token). There is no simple way to fall back to public access when there is no access token on the request (or token is not valid). I have assumed that this is related to the Drupal implementation and can be solved on that level. However, maybe it is better to solve it on the library level.\nFirst of all, there should be a way to declare that the authorization is optional for a certain resource. Maybe this can be achieved by using a special scope called 'public'.\n. I think you are right (although I don't understand all the details). At the part:\n// no access token was supplied... this user is not logged in\nthe server may still decide to offer the service to the client, if it is marked somehow that the service can also be accessed anonymously.\nIn Drupal there is a function called is_user_logged_in(). It returns TRUE when there is a valid token, and it will return FALSE when there is no token. Based on this, the service may offer more specific details to an authenticated user.\nSo, I think that this is an issue that should be solved by the module that uses this library.\n. I'd like to share my experience with Drupal, even if this is not totally relevant.\nIn Drupal there is the module 'oauth2_server' which handles authentication/authorization, and there is the module 'services' which handles endpoints, resources, etc. Drupal has a granular and strong permission system and the module 'services' takes advantage of that to define which of the users (or groups of users) can access a certain resource. So, the job of 'oauth2_server' is just to authenticate the users (the access_token is used as a means of authentication), and further on the permission system of Drupal is used to decide what the authenticated user can and cannot do.\nThis way it seems that the scopes are not very useful. Well, at least in Drupal, with the server side workflow, I didn't find them very useful. I even find them confusing and misleading and I don't see how they can be used properly. You can avoid using them at all and everything would be fine. Please correct me if I am missing something.\nIn general, I think that the way that scopes are used depends on how they are integrated with the user permissions of the system that is implementing the services and the oauth2. \n. Brent, you are right: scope is meant to LIMIT the normal permissions of the user, depending on the client that has the access_token. I missed this point, maybe because all the clients that I intend to use are trusted ones (not third party clients). I have even checked the option \"Automatic authorization\", which means that the users are not prompted for approving the client, and the authorization is done automatically (immediately after authenticating the user).\nActually it is possible (in the Drupal implementation) to set a list of scopes for each resource, and the authorization will fail if the client does not have all of these scopes (this happens before going to Drupal permission checking). However this is not very useful (in Drupal) because you can select only one oauth2 server per service (and each resource of this service), and all the clients of this oauth2 server have the same scopes (which are defined on the oauth2 server). This implies that either all the clients access all the available resources, or all the clients access none of the available resources. The real decision about using a resource is still left to the permission system of Drupal (which is not proper usage of scopes).\nI see two possible solutions to this (which have also been discussed in a previous discussion). Either allow more than one oauth2 server per service and select which server can be used for each resource, or allow different scopes for each client (and then only the clients that have the right scopes will access a certain resource). I think bojanz is in favor of the second solution.\n. Another solution (Drupal specific) that comes to my mind is this:\nDrupal has a function user_access('permission-name') which returns TRUE when the logged-in user has that permission. It can be used to decide what a user can or cannot do. Similar to this, we can have a function oauth2_scope('scope-name') which returns TRUE when the access_token that was used for authentication has that scope. Using this the application can make decisions about what resources can be used and what not.\nSo, it is not the oauth2_server that enforces the authorization (decides about what should be used and what not), it only provides the information of the available scopes to the other modules (for example the module 'services') and to the application, and let them decide about it.\nI think that this solution would be simpler to implement and more flexible, for all the parties that are interacting with each-other (the oauth2-server-php library, the oauth2_server module, and the services module).\nI hope that @bojanz is following this discussion and is taking note of these ideas.\n. I think this should be done with a separate api call (for example /api/me\nor /api/user_profile or /api/user_details). This is service/resource\nmanagement and is not responsibility of an oauth2 server.\nAs far as I can understand, the job of an ouath2 server is to get an\naccess_token from the request and to return information about the user and\nclient (app) that are related to it. Also it should manage the\naccess_token, its life-cycle and everything related to it. It can do other\nthings as well, but in my opinion they are responsibility of other parts of\nthe system and it doesn't have to do them.\nOn Thu, Mar 20, 2014 at 9:48 PM, tnguyen444 notifications@github.comwrote:\n\nI was going to use scopes to limit resources that are accessible on my\nserver (api). However, the api needs to return roles that a user belongs to\nso that the client (CMS) can use it's permission system to do this. What's\nthe best way to do this? When we return the token, can we return the roles\nthat are associated to a user or is the outside the proper use of OAuth? Or\nshould I use the getUserDetails method to do this via a separate api call?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/353#issuecomment-38219162\n.\n. I think that access control logic should be left to the API. The oauth2 server should provide to the API only the tools for checking easily the available scopes. For example it can be something like this:\n\nphp\nfunction checkScope($scope) {\n    $token = $server->getResourceController()->getToken();\n    $scopeUtil = $server->getScopeUtil();\n    return $scopeUtil->checkScope($scope, $token['scope']);\n}\nThen the API can check like this:\nphp\n    if (!checkScope('inidividual') and !checkScope('admin'))  return;\n    // else continue with serving the resource\n. I could try to make a patch for this, but I am not familiar with the code of oauth2-server-php and I am afraid of breaking something unintentionally. Anyway, some hints on where to start could be useful.\n. Thanks @phindmarsh, your suggestion was useful.\nI couldn't find out how to do with apache2 the same thing that you do with nginx, but I intercepted the OPTIONS request on the application. I use Drupal7 and it has a hook_book() which is called before everything else. So, I solved it by adding a code like this to a custom module:\nphp\n/**\n * Implements hook_boot().\n */\nfunction MODULE_boot() {\n  if ($_SERVER['REQUEST_METHOD'] == \"OPTIONS\") {\n    header('Access-Control-Allow-Origin: *');\n    header('Access-Control-Allow-Methods: POST, GET');\n    header('Access-Control-Allow-Headers: Authorization');\n    header('Access-Control-Max-Age: 1');  //1728000\n    header(\"Content-Length: 0\");\n    header(\"Content-Type: text/plain charset=UTF-8\");\n    exit(0);\n  }\n}\nI noticed a few things:\n- Returning a 200 status code is OK. Even the docs of CORS don't mention anything about returning status code 204. So, the \"caveat\" that you mention is not a problem.\n- It is more easy and clean to just say 'Access-Control-Allow-Origin: *' than to echo back the origin of the requester.\n- You don't have to include OPTIONS in the list of allowed methods (Access-Control-Allow-Methods).\n- In Access-Control-Allow-Headers you list only the non-standard HTTP headers. Most of the headers that you have included are standard (for example: User-Agent, Content-Type) and don't need to be listed.\nHowever I still think that this kind of solution is just a workaround or a hack. It would be better if oauth2-server-php supports CORS itself, because it is already a part of the HTTP standard (all browsers and mobile platforms support it) and it would save the trouble that each application tries to understand these issues and fix them on its own. I don't know what @bshaffer thinks.\n. From the way that oauth2 protocol works, there is an oauth2 server and a client application. The client application gets tokens from the oauth2 server and uses them to request services on behalf of the users. When the user logs out from the client application, the client application can destroy the tokens that it received on behalf of the user. They don't have to be destroyed on the oauth2 server. I think that at some time they will expire and will be destroyed automatically (kind of garbage collection). So, a \"log out\" function on the oauth2 server itself doesn't make sense to me.\nHowever the server application (that offers the web services, the oauth2 authentication/authorization, etc.) can have a \"log out\" function. So, when the user logs out from the client application, it can also be logged out automatically from the server application. But this has nothing to do with the oauth2 server itself.\nI hope this explanation attempt was useful. However I am not sure that my understanding is 100% correct (and I am not sure whether I got your question right).\n. First, issue a new refresh token every time that you issue an access token. Then, making the expiration time of the refresh token longer (for example one month) could also help.\nIf you do these, then a new authorization form will not be needed, unless the user does not access the site for more than one month.\n. How does the FB do it? I have no idea.\n. If your mobile app is built with jQuery Mobile, there is no place to hide the client_secret, it will be public. (I cannot speak for native iPhone/Android apps because I have no experience with them.) I think that this is not terribly bad thing, there are no bad implications etc., but I do think that the protocol should not ask for a 'client_secret' when it is actually useless and pointless.\nIn my mobile app (http://fjalori.fs.al/) I have actually implemented a proxy oauth2 authorization. This a bit of tricky solution, I haven't seen it somewhere else, but I think that it can be useful for others too. The idea is that the mobile application (which cannot have a redirect_uri, necessary for the authorization_code grant type), calls a server-side application to handle the authentication/authorization, and that server-side application hands over the token back to the mobile app after the process is done.\nTrying to explain it by words maybe seems a bit abstract, but if you see the code maybe you get a better idea:\n- https://github.com/B-Translator/vocabulary-jquery/blob/master/lib/oauth2_token.js#L239-256\n- https://github.com/B-Translator/vocabulary-jquery/blob/master/js/config.js#L11\n- https://github.com/dashohoxha/oauth2_login/blob/7.x-1.x/oauth2_login.module#L144-148\n. If https://test.com/ already has a SSL certificate, I think that this is already safe, nothing extra to be implemented. But I am not an expert.\n. SSL Client Certificates that you refer above, can be useful only for an intranet, when you know who are the users and you can issue a certificate for each of them (to be used by the application instead of the username/password). My opinion is that they are not useful for the Internet (where anybody can register and login to your app).\n. ",
    "oytuntez": "@bshaffer, just to clarify: are we reading SHOULD NOT cases as MUST NOT on the current implementation of the package, just like in this refresh token case?\n. This was among my notes about this package, great it's on the roadmap.\n. Great, thank you!\n. ",
    "nasaorc": "So I need to wrote it by myself or wait for update?\nHow do I remove both access and refresh token from database\nI suggest this lib should have a function to achieve token revocation\n. how about remove the token when user requested a expired token?\n. how can I pass the config too? thanks\nOn Jan 12, 2014 9:55 AM, \"Brent Shaffer\" notifications@github.com wrote:\n\nThat is because the config for Oauth2\\Server is only passed in when the\ngrant typed are created by default. If you pass the grant typed in\nexplicitly, the configuration should be defined there.\nIt's a weird edge case, and one I'm not quite sure how to handle\n\u2014\nBrent Shaffer\nOn Sat, Jan 11, 2014 at 12:39 AM, nasaorc notifications@github.com\nwrote:\n\nI tried this:\nphp\n$config = [\n'allow_credentials_in_request_body' => true,\n];\n$this->oauth_server = new OAuth2\\Server($storage,$config);\n$this->oauth_server->addGrantType(new\nOAuth2\\GrantType\\RefreshToken($storage));\nalso tried modify Server.php default config:\nphp\n$this->config = array_merge(array(\n'always_issue_new_refresh_token' => false,\n), $config);\nbut not work, only work if I modify RefreshToken.php:\nphp\n$this->config = array_merge(array(\n'always_issue_new_refresh_token' => true\n), $config);\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/bshaffer/oauth2-server-php/issues/302\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/302#issuecomment-32113019\n.\n. I solve it now, thanks\nthis works for me:\n\nphp\n$this->oauth_server = new OAuth2\\Server($storage,$config);\n$this->oauth_server->addGrantType(new OAuth2\\GrantType\\ClientCredentials($storage,$config));\n$this->oauth_server->addGrantType(new OAuth2\\GrantType\\RefreshToken($storage,$config));\n$this->oauth_server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($storage,$config));\n. Still get refresh token in response and database\nOn Mon, Apr 21, 2014 at 4:23 PM, abides notifications@github.com wrote:\n\njust remove the refresh token grant type;\n$grantType = new OAuth2\\GrantType\\RefreshToken($storage);\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/373#issuecomment-40922973\n.\n. \n",
    "mikehaertl": "Ok, thanks for clarifying. \n. ",
    "abhishekrohilla": "How do we send multiple scopes while generating token? Does the library support sending only one scope?\n. Asked the question too soon. Got it in RFC.\n The value of the scope parameter is expressed as a list of space-\n   delimited, case-sensitive strings.  The strings are defined by the\n   authorization server.\n. ",
    "frequenc1": "I really like the idea of pulling this out. We are having issues because we are using multiple instances of redis as our data storage (user credentials, admin credentails, token storage), Our Storage Class is getting way to army knife so anything that pulls these kinda of methods out are great. Thanks!\n. Yes please. It would be really useful\n. ",
    "mikspark": "sure, i submit PR and code examples as soon as possible\n. ",
    "builtbykrit": "@bshaffer I agree that a move to HttpFoundation would be a good thing. \n@reinink Thanks for posting your modified Request class!\n. ",
    "victorhqc": "Oh, my bad. I'm running php 5.3.6\nThanks!\n. Alright, I found the answer, it seems that now I have to declare the grant_types in the oauth_clients table, in my case I had to insert: implicit to make it work.\nPlease update the documentation :)\nhttp://bshaffer.github.io/oauth2-server-php-docs/grant-types/implicit/\n. ",
    "robedge": "By default the server does not create a new refresh token when you request an access token from refreshing.  Overriding that config value is simple.\nFind the line where you are adding the Refresh token grant type and change add this array to as the second param:\nphp\n$server->addGrantType(new OAuth2\\GrantType\\RefreshToken($storage, array(\n  'always_issue_new_refresh_token' => true\n)));\nNow when you refresh your token it should update your refresh token and expiration also.\n. ",
    "bensinclair": "Thanks Rob!\n. Hi Brent and Patrick,\nYes I an encoding the URL. Here's a sample\nhttp://myapi.com/oauth?type=web_server&client_id=123456&redirect_uri=http%3A%2F%2Flocalhost%2Ftest%2F%3Ftest%3Dtrue%26another_test%3Dtrue&scope=ManagePeople%2CManageGroups%2CManageCalendar%2CManageFinancials%2CAdministerAccount&state=return\nTo reproduce the issue, when I create a new client, the redirect_uri is stored in the oauth_clients table. So let's say I set the redirect_uri to http://localhost/test/?test=true&another_test=true\nWhen I then send a request to the Authorize Controller to obtain an auth_token and refresh_token, I need to specify the redirect_uri in the call. The URL I posted above is that very call. During that call, my code validates the authorization request (see my code above).\nBecause my redirect_uri contains the &, it throws an error.\nLet me know if you need more info.\nBen\n. Thanks Brent,\nThe thing is I have used http://localhost/test/?test=true&another_test=true as the client's registered redirect URI? That would mean it is matching wouldn't it?\nAm not setting the client's registered redirect URI to http://localhost/test/ and then trying to add the query string when making my calls.\nHave I missed something?\nBen\n. ",
    "Alex-Zaharow": "Thanx!\n. ",
    "DrayChou": "Standard does not mention the access token after submitting refresh token should be deleted.\nI modified some code, and now here in the business layer processing operations.\nThank you.\n. ",
    "JeroenMinnaert": "I was also wondering what happens to old access/refresh tokens once new ones are issued. I found an interesting example in the Salesforce REST API. They allow 5 access/refresh tokens per client per user ([More info here])(http://help.salesforce.com/help/doc/en/remoteaccess_request_manage.htm). This is particularly useful for testing, where you would login on multiple instances of your application at the same time.\n. ",
    "feelzyinc": "FYI ... I also have this issue no matter what version I use  (dev or master).\n. Thank you kind sir!   Your post has led me to the resolution of my issue.   I was intermixing two distinctly different versions of the tool.   I'm running an old PHP setup on my webhost and a new PHP setup on my localhost.\nI originally was working from this document:\nhttps://github.com/bshaffer/oauth2-server-php/tree/v0.9\nIn the \"Define your Schema\" section there isn't a create table cmd present for that table.   I later somehow found my way to the cookbook example at:\nhttp://bshaffer.github.io/oauth2-server-php-docs/cookbook/\nI didn't notice the table lists were different and skipped that first part since I had already done it.  (oops!)    USER ERROR.\nThanks for your ideas and the work that has went into this.  ;0)   Sorry to have taken your time on such a silly mistake.\nRegards,\n. ",
    "vojtabiberle": "OK, I already found soulution.\nself::$server = new \\OAuth2\\Server(array(\n                ...\n            ),\n            array(\n                'auth_code_lifetime' => 900\n            ));\n. ",
    "svycka": "loks like fixed.\n. I had to save times in some timezone because this was required for other module, but OAuth2 uses time() so I had convert it back for OAuth2 but this not so much of work so maybe closing..\n. the problem with php//input is the same #213 not only zf2 but also other modules who use this when your library calls file_get_contents('php//input') then zend can't get for example PUT request body i don't know easy workaround for this. This is my Request implementation of RequestInterface. More on php//input\n``` php\n<?php\nnamespace OAuth2Server\\Provider;\nuse OAuth2\\RequestInterface;\nuse Zend\\Http\\PhpEnvironment\\Request as HttpRequest;\nclass Request implements RequestInterface\n{\n    protected $request;\npublic function __construct(HttpRequest $request = null)\n{\n    if ($request instanceof HttpRequest)\n        $this->setRequest($request);\n}\n\npublic function setRequest(HttpRequest $request)\n{\n    $this->request = $request;\n}\n\npublic function getRequest()\n{\n    if (!$this->request instanceof HttpRequest) {\n        throw new \\OAuth2Server\\Exception('Zend\\Http\\PhpEnvironment\\Request was not set.');\n    }\n\n    return $this->request;\n}\n\npublic function query($name, $default = null)\n{\n    return $this->getRequest()->getQuery($name, $default);\n}\n\npublic function request($name, $default = null)\n{\n    if ($param = $this->getRequest()->getPost($name)) {\n        return $param;\n    }\n\n    $contentType = $this->server('CONTENT_TYPE', '');\n    $requestMethod = $this->server('REQUEST_METHOD', 'GET');\n\n    if (0 === strpos($contentType, 'application/json')\n        && in_array(strtoupper($requestMethod), array('POST', 'PUT', 'DELETE'))\n    ) {\n        $data = json_decode($this->getRequest()->getContent(), true);\n        if (array_key_exists($name, $data))\n            return $data[$name];\n    }\n    return $default;\n}\n\npublic function server($name, $default = null)\n{\n    return $this->getRequest()->getServer($name, $default);\n}\n\npublic function headers($name, $default = null)\n{\n    $header = $this->getRequest()->getHeader($name);\n\n    if ($header) {\n        return $header->getFieldValue();\n    }\n\n    return $default;\n}\n\npublic function getAllQueryParameters()\n{\n    return $this->getRequest()->getQuery()->toArray();\n}\n\n/**\n * @see https://github.com/bshaffer/oauth2-server-php/issues/240\n */\npublic function addAuthHeaders()\n{\n    if ($this->server('PHP_AUTH_USER')) {\n        $headers = $this->getRequest()->getHeaders();\n        $headers->addHeaderLine('PHP_AUTH_USER', $this->server('PHP_AUTH_USER'));\n        $headers->addHeaderLine('PHP_AUTH_PW', $this->server('PHP_AUTH_PW'));\n    } else {\n        /*\n         * php-cgi under Apache does not pass HTTP Basic user/pass to PHP by default\n         * For this workaround to work, add this line to your .htaccess file:\n         * RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n         *\n         * A sample .htaccess file:\n         * RewriteEngine On\n         * RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n         * RewriteCond %{REQUEST_FILENAME} !-f\n         * RewriteRule ^(.*)$ app.php [QSA,L]\n         */\n\n        $authorizationHeader = null;\n        if ($this->server('HTTP_AUTHORIZATION')) {\n            $authorizationHeader = $this->server('HTTP_AUTHORIZATION');\n        } elseif ($this->server('REDIRECT_HTTP_AUTHORIZATION')) {\n            $authorizationHeader = $this->server('REDIRECT_HTTP_AUTHORIZATION');\n        } else if ($this->headers('Authorization')) {\n            $authorizationHeader = trim($this->headers('Authorization'));\n        }\n\n        if (null !== $authorizationHeader) {\n            // Decode AUTHORIZATION header into PHP_AUTH_USER and PHP_AUTH_PW when authorization header is basic\n            if (0 === stripos($authorizationHeader, 'basic')) {\n                $exploded = explode(':', base64_decode(substr($authorizationHeader, 6)));\n                if (count($exploded) == 2) {\n                    $headers = $this->getRequest()->getHeaders();\n                    $headers->addHeaderLine('PHP_AUTH_USER', $exploded[0]);\n                    $headers->addHeaderLine('PHP_AUTH_PW', $exploded[1]);\n                }\n            }\n        }\n    }\n      // TODO: not sure why do we need this??\n\n//        // PHP_AUTH_USER/PHP_AUTH_PW\n//        if (isset($headers['PHP_AUTH_USER'])) {\n//            $headers['AUTHORIZATION'] = 'Basic '.base64_encode($headers['PHP_AUTH_USER'].':'.$headers['PHP_AUTH_PW']);\n//        }\n}\n\n}\n```\nI have not written any tests for this so don't know if it works correctly, but so far working without any problems.\nAlso factory for example how to initialize this\n``` php\nnamespace OAuth2Server\\Service;\nuse Zend\\ServiceManager\\FactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse OAuth2Server\\Provider\\Request as RequestProvider;\nclass RequestProviderFactory implements FactoryInterface\n{\n    public function createService(ServiceLocatorInterface $serviceLocator)\n    {\n        $request = $serviceLocator->get('request');\n        $request_provider = new RequestProvider;\n        $request_provider->setRequest($request);\n    $request_provider->addAuthHeaders();\n\n    return $request_provider;\n}\n\n}\n```\n. ops sorry for closing :D\n. I took quick look on HttpFoundation\\Request and I think they don't add PHP_AUTH_USER to headers it uses server params as ZF2 does, but your current inplementation copying from server to header don't know why.\n. Hrrr every update breaks compatibility please don't do this or change versions naming to be clear when it has BC and when not :D thanks\n. @bshaffer I fixed my code by following commit history. But thanks for changelog I will check it, maybe I missed something.\n. @bshaffer it was easy to fix code, but will be harder to update already published projects. Maybe I will not update if no serious security issues was fixed.\n. implemented with https://github.com/bshaffer/oauth2-server-php/pull/795. it is merged so in next release\nOn Sat, Aug 26, 2017, 15:30 clubery notifications@github.com wrote:\n\n@svycka https://github.com/svycka @bshaffer\nhttps://github.com/bshaffer when will #795\nhttps://github.com/bshaffer/oauth2-server-php/pull/795 be released?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/363#issuecomment-325122653,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABNj_oWq4KraYyxYcWUqfdgyppntO-BVks5scA_ggaJpZM4BvC_5\n.\n. @BVMiko yes, you are right this is for payload, not a header. sorry, I did not know that.\n. php5.3 really? http://php.net/supported-versions.php\n. will be easier when this will be released https://github.com/bshaffer/oauth2-server-php/pull/795. @kosciuk why would you want to store JWT token?. that's true but you could always change table to allow longer access_tokens if you really need to save (but don't know why would you) this lib does not force you to use default schema.. @bshaffer PHP 7.1 released and deprecated mcrypt. but this would mean BC break or we don't care because it is most like no one will notice?. thanks @bkcummins I understand that it should be possible but would like to customize a bit easier than extending some classes. @bshaffer I haven't thought much, but your second example seems pretty good. Also no BC break so can be implemented now I think.. resolved with https://github.com/bshaffer/oauth2-server-php/pull/795. @bshaffer done. I always have problems choosing names :) thought if we have generateAccessToken() generateRefreshToken() then why not generatePayload() :D not sure why those different. But anyway I did the change is it ok now? Also not sure but I guess tests are not required in this case?. @bshaffer is it possible that this will be merged soon? or should I go with workaround for now?. because it is merged an will be released in new version.\n\nOn Sep 7, 2017 6:37 PM, \"bluebaroncanada\" notifications@github.com wrote:\n\n@svycka https://github.com/svycka, can you advise us why you closed\nthis?. More like wtf at least now. So far havent found any issues. Maybe just a\nbit strange that they differs also docs does not say that those  names are\nreserved.\n\nOn Jan 17, 2017 23:31, \"Brent Shaffer\" notifications@github.com wrote:\nThe simple answer is the standard JWT fields\nhttps://tools.ietf.org/html/rfc7519#section-4.1 are different from the\nOAuth2 fields, but this library expects OAuth2 fields. So a handful of\nfields are renamed when this library pulls the tokens from storage.\nIs there a bug, or is this more of a \"wtf is going on here\"?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/797#issuecomment-273306367,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABNj_l0eFSFNGTCTa54KVDTpp1S9sYOxks5rTTM-gaJpZM4LkmgU\n.\n. @Listen-WebDev  if you use(most likely you do) refresh_token grant then you can issue new access token like this http://bshaffer.github.io/oauth2-server-php-docs/grant-types/refresh-token/. from documentation:\nfirst like you do you login with username and password: \n$ curl -u TestClient:TestSecret https://api.mysite.com/token -d 'grant_type=password&username=bshaffer&password=brent123'\nand get this: \n{\n    \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n    \"expires_in\":3600,\n    \"token_type\": \"bearer\",\n    \"scope\":null,\n    \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n}\nthen after one hour when your access_token expires you have to get new access token so you have two options send username and password or use refresh_token instead. Example from documentation:\ncurl -u TestClient:TestSecret https://api.mysite.com/token -d 'grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA'\nresponse:\n{\"access_token\":\"03807cb390319329bdf6c777d4dfae9c0d3b3c35\",\"expires_in\":3600,\"token_type\":\"bearer\",\"scope\":null}\nhere 03807cb390319329bdf6c777d4dfae9c0d3b3c35 is your new access token.\nkeep in mind that refresh tokens also expire but they live a lot longer. you can change time when they expires throught config 'refresh_token_lifetime'  => 2419200, also from documentation. 2419200 = 606024*28 is 28 days in seconds. I don't  think this is used by the library and guess this was added as a helper method to add client to storage but this library does not add clients by itself at least I don't know this feature. To sum up you don't have to implement setClientDetails() it is not used by the library.. first you have to find out why. My guess would be some error with database so I would start from enabling error reporting or logging and find out the error first after this I guess everything will be clear.. I think this is new feature and requires tests.. yes\nyou can found tested versions here https://github.com/bshaffer/oauth2-server-php/blob/develop/.travis.yml#L8-L13. https://github.com/bshaffer/oauth2-server-bundle. @afilippov1985 if those exist only for testing maybe reflection could be used instead?. you can find the example here: https://github.com/bshaffer/oauth2-server-php/pull/795#issue-199776010. hmm seems like @bshaffer forgot to remove php 5.3 support in https://github.com/bshaffer/oauth2-server-php/pull/869 not sure what to do now. removing support now will leave old users with a broken latest version that supports php 5.3.\nbut @augsteyer maybe time to update your php version? php5.3 is almost 4 years is not supported. then maybe add back php 5.3 to travis test matrix to be sure that everything works. @gdharris1970 maybe this will help https://oauth2.thephpleague.com/authorization-server/which-grant/. Because I don't want PHP_AUTH_USER, PHP_AUTH_PW I am only using Authorization bearer header but I am forced to create them anyway. I dont know why you decided to do this  with server params instead of authorization header, but if you want them in one place then maybe set them somewhere else not in server params or headers at all set them in some kind of config or something.\n. @bshaffer sorry but this does not fix BC and is totally wrong, how this if can be executed if just few lines above both config options are set but this condition expects one to be set and another not set while both are defined.\n. woops looks I got confused with $config and $this->config so this if could be ok but still I have a BC just not sure why. Investigating... Is test written to confirm this fix works?\n. Okay might found the reason. I am creating server like in documentation example http://bshaffer.github.io/oauth2-server-php-docs/grant-types/refresh-token/#implementation\n``` php\n// create a storage object to hold refresh tokens\n$storage = new OAuth2\\Storage\\Pdo(array('dsn' => 'sqlite:refreshtokens.sqlite'));\n// create the grant type\n$grantType = new OAuth2\\GrantType\\RefreshToken($storage);\n// add the grant type to your OAuth server\n$server->addGrantType($grantType);\n```\nas you can see creating OAuth2\\GrantType\\RefreshToken($storage) without $config so in this constructor $config is empty that's why this fix does not help. always_issue_new_refresh_token default was false so I didn't added always_issue_new_refresh_token here and now have problem.\n. @bshaffer do you think this should be fixed? or this works as expected?\n. I would add $payload to the callable arguments instead of this array_merge. if it is not empty and not callable maybe better throw exception because it is most likely something wrong with implementation and should be fixed instead of silently ignore this.. maybe better use call_user_func() instead of variable?. no, I man instead of:\nphp\n$extra = call_user_func($this->config['jwt_extra_payload'], $client_id, $user_id, $scope);\nif (is_array($extra)) {\n    $payload = array_merge($extra, $payload);\n}\ndo this:\nphp\n$payload = call_user_func($this->config['jwt_extra_payload'], $payload);. I don't see why can't change those if we need. specification does not say they are required and even if this lib does require some when we override them here it is most likely we will handle this change in other places as well.\n@bshaffer what do you think?. because of if (isset($this->config['jwt_extra_payload'])) will throw exception on empty values like null, '', 0 or false. I don't think this is required. this feature is to generate those claims for example if you would want increase jwt token expire time for some user you could not. But if you only want to add new parameters then yes its ok. also I don't know the reason why need here those:\nprotected $tokenType;\n    protected $tokenStorage;\n    protected $config;\n    protected $scopeUtil;. @bshaffer I still don't like the idea that it is impossible to change values in $payload.. @bshaffer this is about array_merge error vs custom error? result will be the same :D but maybe yes more clear error message is better. since I dont like nesting I would change this to \nphp\nif (!isset($this->config['jwt_extra_payload'])) {\n    return $payload;\n}\n//.... Is there a reason for underscore before method name?. ",
    "jdelaune": "Nope didn't need it, maybe just remove it from the comments to clear things up for other people?\n. ",
    "internalsystemerror": "I do! When provisioning a new client, I'm allowing the ability to set approved up users. This means that in checkUserCredentials, I need to check that the supplied client_id it in a list of approved users.\nThis i believe conforms to the draft specification for OAuth2, i can try and look it up in the rfc if necessary.\n. ",
    "darthtong": "Fast forward 4 years...I don't suppose after all this time this has been cleared up? The comment still exists but the code does not. I too require access to the client_id in this context.. ",
    "jahrralf": "Same here, I changed the source code to have this and need to make the same changes again and again for every update... Would be really to great to have client_ID in methods.. @bshaffer If I would be able to do a PR ;) Yes, I will try to. Thanks.. Well, I experiences some trouble here. My server, without always_issue_new_refresh_token = true, discarded the refresh_token after successfully renewing the access_token with a refresh_token. This is kind of weird, because afterwards you cannot ask for a new access_token again although the refresh_token would be valid for a few more days.\n. bshaffer, thanks a lot for replying to quickly. I had to find out that we have a kind of \"rate limiting\" for logging in which allowed only 15 logins in 15 minutes also if successful, that caused the problem. So no issue with your code, it is working very well. :). Could be that the server does not allow that kind of login data transfer... check in PHP if test:test reaches the server. I had similar issues with the Authorization header and hat to allow this header in .htaccess. Maybe this is a similar issue.... ",
    "zuzmic": "uff, im not very strong in git branching/pull requests, \nso i created new pull request\n. ",
    "hansmei": "I am facing the same issue here. I am using the built-in Pdo-storage for PHP 5.2 - develop. Am I supposed to create a custom storage class?\n. ",
    "madjennsy": "I was getting the same issue also. My solution was simple:\nALTER TABLE oauth_users  ADD user_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY  FIRST;\nIf someone has a better solution, please share it.\n. ",
    "needcaffeine": "I ended up extending Storage\\Pdo and returning user_id as one of the array items. I equated it to id.\n. Hey guys, thank you for the great work. Do you have any documentation on how to implement this?\n. Yeah, that's where I am right now. I can't tell what the next step is unfortunately.\n. I'm able to make a token request with the 'openid' scope. I get a token back and the appropriate scope is set in the database.\nWhen I make an authorize request, I get the error message config parameter \"issuer\" must be set. Okay, sure. So I look through the test suite and set the issuer to something crazy like untitled. Now the error is openssl_sign(): supplied key param cannot be coerced into a private key.\n. Hello @almaruf - the grant type of password is already supported. Please read this document and enable GrantType\\UserCredentials.\n. Hello @Deep21 -- take a look at https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php\nYou can pass in your own table names to that constructor, or extend it within your application.\n. ",
    "belteshazzar": "For me this problem stemmed from the SQL in the cookbook omitting the user_id. suggest updating the SQL to:\nCREATE TABLE oauth_users (user_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, username VARCHAR(255) NOT NULL, password VARCHAR(2000), first_name VARCHAR(255), last_name VARCHAR(255));\notherwise to fix after the fact add user_id to the oath_users table with madjennsy's solution\n. ",
    "bweston92": "Thanks, closed.\n. ",
    "marovelo": "I forked your Demo Application and wrote a test similar to the one that fails in my application. I submited this test as a Pull Request if you are interested (see above).\nThe test doesn't fail so it seems like there is a problem in my implementation. \nI did some more debugging in my application and found out that your OAuth Server implementation sends out the correct HTTP Code (403) but somehow a 401 arrives as a response to my Curl Request. No idea why that happens.\nIf I comment out the line adding the WWW-Authenticate Header (see my post above) the correct 403 HTTP Code arrives.\nTo sum it up I'm quite sure it has nothing to do with your code. Maybe a Curl/Apache/PHP problem. I will need to do more research. Any suggestions are more than welcome.\n. Here is a list of things that differ in my application compared to the standard implementation:\n- I implemented two custom Grants. One of them extends the Client Credentials Grant the other one the Refresh Token Grant.\n- I have a custom Scope and Storage implementation.\n- I am using your bshaffer/oauth2-server-httpfoundation-bridge for Silex compatibility in Version 0.9.\nAnything here that might cause this problem?\n. ",
    "nkahnfr": "Hi,\nI encountered the same issue but it seems related to PHP itself since 401 status code is enforced whenever a \"WWW-Authenticate\" header is defined (at least from what I understood from SAPI souce code).\nThe only workaround I found is to force the status code using the third parameter of \"header\" function.\nheader('WWW-Authenticate: Bearer realm=\"Test API\", scope=\"test\", error=\"insufficient_scope\", error_description=\"The request requires higher privileges than provided by the access token\"', true, 403);\nBut to do so with your library would require some modification to the \"OAuth2\\Response\" class since only name and value can be defined presently.\nEdit1: adding a dirty fix example of the workaround (\"send\" method of \"Response\" class)\nforeach ($this->getHttpHeaders() as $name => $header) {\n    if ('WWW-Authenticate' === $name)\n        header(sprintf('%s: %s', $name, $header), true, $this->statusCode);\n    else\n        header(sprintf('%s: %s', $name, $header));\n}\n. ",
    "masterzen": "I also encountered the issue and IMHO I think this is a bug in the library.\nThe section 10.4.2 of RFC2616 and section 10.4.4, and the RFC2617 clearly states that you should not send a WWW-Authenticate header with a 403 response (it is forbidden to retry the auth on a 403), and that it should have been a 401. The authentication can be retried only with a 401.\n. @bshaffer, first let me thank you for this awesome library.\nThe relevant part is in section 1.2 of RFC2617, which I forgot to point to in my previous comment:\n\nIf the origin server does not wish to accept the credentials sent with a request, it SHOULD return a 401 (Unauthorized) response. The response MUST include a WWW-Authenticate header field containing at least one (possibly new) challenge applicable to the requested resource.\n\nI also noticed that you can trick PHP into sending a 403 by changing the order of headers sent. But it looks like a workaround for something that is to me the correct behavior. Also, some of your users like me, are using this library inside a framework (Slim for me) that does the gory details of sending the Response. \nAnyway, sorry for resurrecting this old ticket :)\n. @bshaffer, apparently other OAuth2 implementations return 403 for insufficient_scope errors, and those that I looked up don't return a WWW-Authenticate header (at least for the ruby and java implementation). So that may be the solution.\n. ",
    "tomvo": "Wil do @bshaffer, OpenID Connect basically handles the authentication side instead of the authorization on top of oAuth2 and will be the next version of OpenID 2.0.\nBy a quick look around in the library it looks like it boils down to only a few minor chnages including adding a new ResponseType class, that would not be too much of a problem right?\n. @bshaffer Haven't gotten around on implementing this. We put the project that I needed that for on hold. Go ahead and close it. Maybe next year!\n. ",
    "sjwaller": "Hi Brent,\nSorry mate, I'm no longer working at the same company and as a result no\nlonger working with Predis.\nGood luck - I may well use your library some time in the future ;-)\nStewart\nOn 17 December 2013 00:25, Brent Shaffer notifications@github.com wrote:\n\n@sjwaller https://github.com/sjwaller are you still considering\nsubmitting a pull request for this?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/258#issuecomment-30715601\n.\n. \n",
    "diggersworld": "You'll need to enable the Grant Type for refresh token.\n// Add the \"Refresh Token\" grant type\n$server->addGrantType(new OAuth2\\GrantType\\RefreshToken($storage));\nIf following the same example as I did this will be in the Utils.php file.\n. No worries, glad to help.\n. You can put it where you want it and the library will find it. I use mine in the headers.\n. I think it comes down to personal preference. In my opinion the request was bad because you supplied invalid credentials. I reserve 401 or 403 when trying to access something where the user should already be authenticated.\n. You've both given valid points and I agree,\n. ",
    "JosephP91": "Thank you soooo much, diggersworld! \nI'm not following the example as you. But i found where to add that code line.\nFor those who have encountered the same problem using oauth2-server-php, you will need to add that line in the server.php file (when the Server object is created).\nThank you diggersworld!\n. @pjebs Figured out that there's a handleRevokeRequest method that does the work. Thank you anyway! :). ",
    "mhughes2k": "Sorry I realised later that I was making the request against the authorisation end point not the token end point when doing this flow.\n. ",
    "Sicaine": "@F21 i'm just answering because i found it through google and someone else might find it:\nI would only use uuid (in version 4). It reduces the risk of collisions to a level where i can trust it enough to generate unique ids.\n. ",
    "franz-deleon": "Change the response type of the access token.\nphp\nOAuth2\\ResponseType\\AccessToken($tokenStorage, $refreshStorage, array(\n    'access_lifetime'          => 3600,\n    'refresh_token_lifetime' => 1209600,\n));\n. @bshaffer should this be a hotfix considering its security implications?\n. ",
    "TomHAnderson": "I may be a little late for the party, but while implementing this for Doctrine (https://github.com/TomHAnderson/zf-oauth2/tree/feature/doctrine)  I see https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/GrantType/JwtBearer.php#L158 doesn't expire the Jti after it is used.  And if the Jti isn't found the Jwt is used without it.  \nIf a Jti is to be used only once then why does it's data stay the same after granting an auth token?\nIf a Jti is included at all why would you ignore it and fall back to Jwt?\nIs there a case where you only want to support Jwt calls with a Jti and exclude those without?\n. @bshaffer That sounds ok though it doesn't cover expiring the Jti.  The audience could expand to \nJit = { \n    \"audience\": {\n        \"require_jit\": (bool) true,\n        \"audience\": (string) url, etc,\n        \"expired\": (int) unix datetime, \n    },\n...\n}\naudience.audience is an indicator one or the other should be renamed.  I think because of this audience should not be turned into an array and instead a Jit.config should be created to handle customization of the Jit.\nJit = { \n    \"audience\": (string) value,\n    \"config\": {\n        \"require_jit\": (bool) true,\n        \"expired\": (int) unix datetime, \n    },\n...\n}\nBecause we're building outside the spec (and could influence the spec to our design) I don't want to redefine what any existing value means.  \nIn the config require_jit is a boolean and if set to true will stop the validation of a Jwt should the Jit not validate.  \nexpired would be a unix timestamp (pre the rest of the app) and would be set when the Jit is used.  If this value is set the Jit will not validate.\nIn order to enforce a Jit (where a Jwt without a Jit would validate) a server level configuration parameter of jwt would be passed to  OAuth2\\Server->__construct of 'jwt' => array ('require_jit' = true);  Instead of a config of just requrie_jit putting it in the context of jwt makes a little more sense to me.\n. This duplicates the require_jit, however.  Should require_jit be a config of Jwt?\n. :+1: to Authorization: Bearer header\n. This sounds like you have a group-list endpoint and you want to use an access_token to query it.  \nDo you think it's more complicated than that?  Are you suggesting users use groups to define clients?\n. ",
    "home-io": "When using example and trying to use Auth Code I recieve error: {\"error\":\"invalid_grant\",\"error_description\":\"The authorization code has expired\"}\n. Yes, not so much a problem as it was an issue of my own by not being able to copy paste curl command quick enough :) did some egrepping and found the lifetime to switch temporarily to longer time so I could test with curl.  Worked beautifully after that and I switched it back to 30 seconds because it is ultimately better to have it time out allmost immediately, apps/services should exchange code for token on the spot! Good work! Thanks for all the replies to my comments, feel free to edit/delete as needed to clean up comments.\n. this is with using the example code from official documentations, please fix. Cannot even see demonstration due to lacking working example.\n. thank you much bshaffer and awesome work! thanks for the tip.\n. yes that is what I ended up finding, last bit of my comment there is just letting you know you can delete my comment if you'd like, the issue was I wasn't copying and pasting the curl command fast enough to exchange before auth_code lifetime. It makes sense to have a 30 second lifetime because the \"service/app\" should exchange code for token immediately, no error or bug just my missunderstanding :)  Thanks for the reply! feel free to remove my comments, not sure how I do that on my own.\n. ",
    "mcilvena": "My interpretation of the spec (3.2.1) is that:\n- Confidential clients or other clients issued client credentials MUST authenticate with the authorization server...\n...a rule the library seem to currently enforce. However, it goes on to specify:\n- A client MAY use the \"client_id\" request parameter to identify itself when sending requests to the token endpoint.  In the \"authorization_code\" \"grant_type\" request to the token endpoint, an unauthenticated client MUST send its \"client_id\" to prevent itself from inadvertently accepting a code intended for a client with a different \"client_id\".\nI don't think the server MUST distinguish between confidential or public intended use when creating a client. If the client is issued with an ID AND a SECRET (which seems to be the typical implementation) by default, then the client should be able to be a public client regardless of the secret being set or not, but issuing the client_id to the token endpoint.\n. ",
    "jdaily": "The issue was another piece of code attempting to access token data:\nTake from the docs example:\n$token = $server->getAccessTokenData(OAuth2_Request::createFromGlobals());\nwhich should be: \n$token = $server->getAccessTokenData(OAuth2\\Request::createFromGlobals());\nSubmitted a pull request in doc repo\n. ",
    "weierophinney": "@bshaffer -- I have one last change to make, and then I think it's ready to merge.\n. @bshaffer Okay, all set to review!\n. @bshaffer I tried a quick integration test with an app -- the same one I tested my original PR against -- and I cannot figure out how to make it work.\nIn the test suite, the TokenControllerTest uses the Memory storage type, where the isPublicClient() method always returns true, regardless of grant type.\nIn my app, I do not instantiate the TokenController directly, but instead let the Server create a default instance. Originally, I had ClientCredentials, AuthorizationCode, RefreshToken, and UserCredentials grant types attached, and I was consistently getting an invalid_client error, with the message \"this client is invalid or must authenticate using a client secret.\" When I removed all but the UserCredentials grant type, I still get the same error and message.\nFrom what I can see, this is due to two separate issues.\nFirst, inside Server::createDefaultTokenController, if the first grant type encountered does not implement ClientAssertionTypeInterface, the HttpBasic instance it creates will only have the config value allow_credentials_in_request_body; all other configuration that might have been passed to the server is tossed.\nSecond, if the first grant type encountered happens to be ClientCredentials, that grant type is used for the clientAssertionType -- and that class explicitly disallows the new allow_public_clients flag.\nI can see the following potential solutions:\n- Pass the value of the allow_public_clients config item to the HttpBasic instance when creating a default TokenController instance.\n- Ignore ClientCredentials when creating a default TokenController instance. (This likely would go hand-in-hand with the previous.)\n- Document how to create a valid TokenController instance with a properly configured HttpBasic instance for the clientAssertionType.\nPersonally, I think this should be fairly turnkey, and think at the very least the first item should happen, but I'm wondering if the second should as well.\n. One additional note: while I can see that HttpBasic sets the allow_public_clients value to true by default, apparently a false value is being passed to the constructor somewhere, which is why I'm seeing this fail to work. I'm going to keep digging and see if I can figure out where.\n. @bshaffer Integration works as long as the specified client does not have a client_secret stored. So, that's the big question I have on this PR: should clients be allowed both \"confidential\" and \"public\" access, or be restricted to one or the other?\n. > So, this says to me \"a client can have more than one client id associated with it, if there are multiple client types / implementations involved\". So in your case, two sets of client credentials, one for the confidiential client and one for the public client, would be appropriate\nYes -- I was speaking to @ezimuel earlier today, and he drew the same conclusion. I think it's quite appropriate, and fairly easy to document as well.\n. @TarasHots This issue needs to be reported against zfcampus/zf-mvc-auth. As you note, $scope is not being passed, and oauth2-server-php is then correctly skipping the resource check. What you're essentially requesting is a way to specify the scope for zf-mvc-auth to send to oauth2-server-php, which is why you need to open the issue against that repository.\n. @nesinervink Use a delegator factory to alter the instance before returning it.\n. Just a note: instanceof or null === $value are both typically faster than is_null(). Also, leaving it as instanceof will ensure that if somebody uses a proxy or other pattern to overwrite the value, the assumptions still work.\n. Updated.\n. Line 35 checks if $clientData['client_secret'] is not set and throws an error, while this line checks if it is empty. On password request grant types, you will not pass the client_secret at all, meaning line 35 will kick in. I think you should likely do a check for isset($clientData['client_id']) by itself on line 35, and then change this line to:\nphp\nif (!isset($clientData['client_secret'] || $clientData['client_secret'] == '') {\n. That said, my tests still pass, so it may be a non-issue. :)\n. Here's the problem!!!\nAnd it may be a conceptual one primarily.\nThe question is: should a given client_id allow both private and public access, or only one or the other?\nI had been assuming that both were allowed, and so I have a client_secret in my database. However, if that's not the case, it's easy enough to change. I'm interested to hear you weigh in, however.\n. ",
    "christian-joly": "Thanks Brent,\nIt was indeed an issue with the setup of my nginx server with php. Everything works now\n. ",
    "ezimuel": "Hi @bshaffer, thanks for your feedback.The point of my PR was to give a default mechanism to store sensitive information such as password and client_credential in your library (I implemented it in the zf-oauth2 module of Apigility, https://github.com/zfcampus/zf-oauth2).\nI used an Abstract Class to give this feature to all the storage adapters. I used bcrypt because is considered the best algorithm, so far, and because it's available in PHP itself. I used the Zend\\Crypt\\Password\\Bcrypt component because it's not heavy and it implements security best practices, such as the usage of a good random number generator and the management of some side effects around the usage of the PHP crypt() internal function. \nI think we can work together on a different implementation but I don't see disadvantages in the usage of an external library such as Zend\\Crypt. The idea to use directly the crypt() PHP function is equivalent to rewrite the Zend\\Crypt\\Password\\Bcrypt and makes no sense to me. Anyway, I'm completely open to other proposals.\n. The usage of SHA-512 even with salt doesn't offer a secure solution for password storing. To know why please read this article. The only algorithm that is considered secure is bcrypt. I'm refactoring the PR #282 to use the bcrypt implementation of PHP without external libraries.\n. @xaionaro you maybe right my sentence \"The only algorithm that i considered secure is bcrypt\" was too strong, anyway bcrypt is a well known algorithm used in many applications to protect user's password. Some articles/posts on that:\n- Do any security experts recommend bcrypt for password storage?\n- A Future-Adaptable Password Scheme\n- Password Hashing: the Future is Now\n@xaionaro SHA-512 with n rounds (where n is > 10000) can be also a valid solution, even better the PBKDF2 suggested by NIST standard, but you need to implement by yourself in both the solutions (and this can be an issue). bcrypt is just ready to go and available in PHP since 5.3.0 (in the crypt function).\n. @xaionaro yes, this is annoying:\n- \"links are not scientific\"? No comment.\n- the hash_pbkdf2() function that you used is available in PHP starting from 5.5, I don't think @bshaffer wants to put this requirements;\n- bcrypt is supported starting from PHP 5.3.0, using the \"$2a$\" syntax, for instance crypt('test', '$2a$10$usesomesillystringforsalt$')\n- you don't need multirounding for bcrypt, you just need to use a random salt, different for each hash, for instance as I did here.\nI think the best options for the oauth2-server-php library is to provide a general Adapter class to protect sensitive data such as password and client_secret. In this way people can choose the algorithm that they want to safely store data.\n. @bshaffer I think this is a great idea. If you want to provide a skeleton for this class I will be more than happy to help you in the cryptographic part. I propose to use a class that implements an interface OAuth2\\Encryption\\PasswordInterface with a create() and verify() method, similar to this one: https://github.com/zendframework/zf2/blob/master/library/Zend/Crypt/Password/PasswordInterface.php. In  this way folks can inject the concrete implementation that they want to use.\n. Ok.\n. The exception is thrown If the $credential is not a valid bcrypt hash. In that case we assume the credential is not valid.\n. ",
    "Gargaj": "@ezimuel: Wouldn't it be more reasonable to refactor all the sha1() calls into something like\nphp\nprotected function hashPassword( $plainPwd )\n{\n  return sha1( $plainPwd );\n}\nand leave it up to the end-user to override it if they want something more secure when they extend the Storage class? That way the password hashing is unified across the board and it would be relatively easy to introduce a different hashing mechanism (like bcrypt) if you feel like it, or even disable hashing if you really need to (e.g. debugging).\n. This is not an issue of this project but an issue of PDO: http://security.stackexchange.com/questions/15452/should-passwords-be-revealed-in-error-message\nYou can avoid this by wrapping the PDO construction in a try/catch.\nI agree, however, that it should possibly be included in the example files as such.\n. ",
    "dannin": "I like this minus the dependency on 3rd party library. If they're ways to make it available as an extension to this rather than core, that'll be cool\n. ",
    "xaionaro": "Agree with @dannin. Using ZendFramework component for this issue is really bad idea, IMHO.\n. @bshaffer,\nI've fixed the code.\nAbout hash_pbkdf2 we can use \"https://github.com/rchouinard/hash_pbkdf2-compat\". Or this's too hacky?\n. First of all I want to thank for your responsiveness :)\n\nmost applications will use UserInterface for their user stores... I hope... \n\nWhere can I read about this way?\n\nrather than my incredibly rudimentary Pdo storage\n\nAnyway the password should be hashed secure enough (in every storage). So anyway it's required:\n- to use hash_pbkdf2;\n- or to use another implementation that won't be added to PHP (because hash_pbkdf2 is already there).\nI prefer the first variant :)\nSorry, that I prepared a patch only for Pdo, just I didn't try any other. Seems, I should move the hashing code to separate php-file. However I don't know the coding style of this project to make that right :(\n\nHowever you're not the first to ask for this (see #282) so, perhaps it's time I give in.\n\nPersonally I don't like this solution. I don't like Zend Framework, because it's too monstrous, IMHO. And IMHO hash_pbkdf2() way is much better due to native support in latest PHP.\n\nWill you review the linked PR and see which implementation you prefer, or if we can somehow use ideas from both?\n\nSorry for my incompetence but what is \"PR\"? The only associations are \"Page Rank\" and \"Public Relations\" :).\nMy opinion, the best way is next. We should make a separate git-branch where:\nMy hash functions are in separate PHP-file that is used by \"Cassandra.php\", \"Memory,php\", \"Mongo.php\", \"Pdo.php\" and Redis.php.\nAnd just wait while PHP5.3 and PHP5.4 will became obsolete. Before that people will be able to use the branch in conjunction with \"https://github.com/rchouinard/hash_pbkdf2-compat\" on PHP5.3 if they wish. ;)\nP.S.: Sorry for English. It's not native for me )\n. > Sorry for my incompetence but what is \"PR\"? The only associations are \"Page Rank\" and \"Public Relations\" :).\nOoh, got it. It's \"Pull Request\" ))... Damn..\nWell, seems I've already answered to that question, anyway)\n. > Any particular reason for choosing  hash_pbkdf2  over the  password_*  functions that are designed for hashing passwords for this exact purpose?\nWell. This's difficult question. Honestly I don't see essential difference. This's the difference what can I see:\n- hash_pbkdf2 is more flexible, AFAIK. For example in Russian the \"gost\" algo is required sometimes. It's even impossible to set number of rounds in password_* functions. That makes more possible to use rainbow tables to hack the hash. On the other hand theoretically salt should protect from that. However the salt strength may be reduced if match algo-vulnerability will be found. \n- password_* uses bcrypt: http://www.unlimitednovelty.com/2012/03/dont-use-bcrypt.html\nSorry, I'm physicist (not a cryptographer), so I just don't know what is better. :)\n\nUsing  password_hash  means if an algorithm needs to be changed in future it's just a few config tweaks and will remain compatible with previous hashes generated with the same library.\n\nThe same thing with my patch ;). Just change \"$config\" values and old hashes will continue to work, but new hashes will be generated according to the new \"$config\" :)\nMy opinion:\n- Much more beautiful to use password_*\n- More flexible and secure to use hash_pbkdf2\nbut I may be wrong, of course :)\n\nI don't think it is the job of this library to roll its own hashing functions. \n\nIMHO, the primary priority of this library should be \"security\". So I think we should suffer code beauty in favor of security if possible. But, of course, it's required to get a consultation from a good specialist in cryptography.\n. > unless you are a cryptographer (and even then), don't try and roll your own crypto\nWell. In my arrogantly opinion I'm better in cryptography than PHP authors. They are not cryptographers too :)\nAnd I'm not rolling own crypto. I'm just using \"well tunned\" pbkdf2 instead of untunnable bcrypt. Both pbkdf2 and bcrypt are ready and good password derivation functions. They are designed for the same task, just with different ways. \nI just selected unique number of rounds and used strong enough salt to protect hashes from rainbow tables. BTW, we can use random number of rounds (500 -- 2000). It makes much more difficult to hack all hashes at same time. If number of rounds is equal through all hashes a new effective rainbow table can be cached while brute forcing first hashes.\n\nYes, password_hash using bcrypt at the moment, however it is likely as the crypto landscape changed the function will be updated to support other algorithms. In my opinion this library should prefer standard implementations of these functions to get the best interop possible.\n\nI see, ok. Anyway the \"standard implementation\" secure enough for me to use this library in production.\n\nHowever if your requirements are such that the standard library doesn't do the right algorithm (or whatever), you should implement your own UserStorage class and implement it there.\n\npbkdf2 - is standard too. We just need to choose between two standard variants :)\n\nI don't mean to negate the work you have done, I'm still on the fence as to whether this library should do strong hashing at all (on the one hand it'll be better for those that can't be bothered, but if they can't be bothered they really shouldn't be writing authentication/password code in the first place ).\n\nI can easily fix to password_* functions. It's not problem for me. Just it's my humble opinion that my solution is better.\nAnother variant: we can make a configurable hashing class (or a bunch of simple functions) that can use both backends. And enable by default the bcrypt way.\n. @ezimuel: \n\nTo know why please read this article.\n\nFrom article:\n\nHow? Basically, it\u2019s slow as hell.\n\nAnd? Why is this better than SHA-512 with 1000000 rounds? It will be slow as hell, too. I'm working with HPC and I know what is CUDA and others, but I cannot get this article. Also don't forget thay the length of the hash is valuable, too.\n\nThe only algorithm that is considered secure is bcrypt. \n\nWhat? I didn't see such analysis. Opp., AFAIK, bcrypt is not well studied to make such conclusions. There may be found collisions or something like that in future.\nOn the other hand, IIRC, SHA is connected with NSA, so it may have well hidden vulnerabilities.\nAnyway, please provide a link to a good scientific article to make such conclusions as \"the only algorithm that is considered secure is bcrypt\". AFAIK, even scientific community not sure in this question. My position was much more humble and argumentative, IMHO.\nThe only well-known \"advantage\" of bcrypt that it requires more memory. So it's slightly harder to build a special hardware to hack hashes of it.\n. @ezimuel, sorry for annoying, but\u2026 :)\n- The links are not scientific, it's just somebodies' opinions. Look at Scopus or Web of Science, for example. \"A Future-Adaptable Password Scheme\" seems to be scientific, but I don't see there any comparison of the discussed ways.\n- pbkdf2 is well known algorithm used in many application to protect user's password, too. IMHO, the most of programmers uses bcrypt just due to strong propaganda in the Internet. And IMHO the elite uses bcrypt just because it's not connected with NSA (which have a long story of implementation and concealment vulnerabilities); I mean that bcrypt is not considered more secure, just it's considered more trusted.\n- As you can see, my solution uses 945 rounds with native hash_pbkdf2() functionality, which may be easily increased to 1000000. So the argument with slowness as advantage of bcrypt doesn't work here. I don't need to implement something here, hash_pbkdf2() is ready solution. It just uses external salt, that I generate with mcrypt functions. And my solution may be simplified because I'm mixing \"urandom\" and \"random\" sources just in case (it's security extra steps).\n- There's no blowfish support in crypt() of PHP5.3.0, AFAIK. [wrong minor version :) ]\n- crypt() doesn't have multirounding or analog, IIRC. So you need to reimplement secure hash-function or to use functions of PHP5.5\nIMHO:\nReally there's not essential difference between hash_pbkdf2() and password_hash() as a hashing backend. But hash_pbkdf2() supports a lot of algorithms, including \"gost\" that is required in Russia. It's not necessary to use SHA* in pbkdf2, while bcrypt is a lock-in. Also SHA is studied much better without world-wide-known vulnerabilities, while bcrypt is not well studied. bcrypt key is seems to be limited with 448 bits (cannot find good enough article), while SHA512 \u2014 512 bits. On the other hand it's harder to make special hardware to hack bcrypt (it's required more memory) and bcrypt is not connected with NSA. So, there's no right choice, IMHO.\nI think, the best solution is to make possible to switch between this backends and use bcrypt as the default one. :)\nSorry for my English, again.\n. @ezimuel: \n\nyes, this is annoying\n\nAs I said, sorry.\n\nbcrypt is supported starting from PHP 5.3.0, using the \"$2a$\" syntax, for instance crypt('test', '$2a$10$usesomesillystringforsalt$')\n\nAgree, this's meaningful.\n\nyou don't need multirounding for bcrypt, you just need to use a random salt, different for each hash, for instance as I did here.\n\nOk, you right. I've just tested.\n\nthe hash_pbkdf2() function that you used is available in PHP starting from 5.5, I don't think @bshaffer wants to put this requirements;\n\nWell. password_* functions appeared in 5.5 as well. I thought that implementation of bcrypt in crypt() was not good enough. But I was wrong, sorry.\n\nyou don't need multirounding for bcrypt, you just need to use a random salt, different for each hash, for instance as I did here.\n\nCorrect me if I'm wrong. You're depending on ZendFramework.\n@bshaffer:\nSeems, @ezimuel is right. crypt()-way is easiest, clearest, the most portable and it's secure enough, IMHO.\n@phindmarsh, @ezimuel:\n\n@xaionaro You earlier posted a link about why we shouldn't use bcrypt, then dismissed @ezimuel's similar links as 'not scientific', perhaps you shouldn't be so quick to defend your position.\n\nI didn't dismiss similar links. I know that my link wasn't scientific as well. Just I said:\n\nAnyway, please provide a link to a good scientific article to make such conclusions as \"the only algorithm that is considered secure is bcrypt\". AFAIK, even scientific community not sure in this question. My position was much more humble and argumentative, IMHO.\n\nAnd got that links in the answer. So I noticed that 2 articles are not \"good scientific\" and 1 have no comparison between discussed method. \n@phindmarsh:\n\nIt seems like you have very specific requirements for your hash function\n\nFrom specific only \"PHP5.5\". mcrypt - is very standard extension of PHP.\nAnyway, the fact that crypt() supports secure enough bcrypt in PHP5.3 makes it much more welcome, so my implementation is not interesting in this library.\n. Ok, I'll fix it today.\nI'm a C-programmer. I'm using #define and enum quite often. So it's just a habit, sorry :)\n. Ok, will be fixed in few minutes.\n. Why? It doesn't matter as for me. But this functions may be used outside the class, IMHO.\nHowever, ok, will be fixed soon.\n. ",
    "pablodip": "Why is an interface required in order to use a class? Symfony's request is only a representation of an HTTP request, which is what OAuth works with. You're true that this would make the server requires the Symfony's component, but I think that's what Composer is for :)\nThis would make much easier integrating all projects using the Symfony's HttpFoundation and HttpKernel components (which are a lot http://symfony.com/components/HttpFoundation http://symfony.com/components/HttpKernel), and for the rest just an adapter would be needed. But now all projects need an adapter.\nAlso would make this project smaller as the request and responses just are not necessary, and the less code the better!\nAnd about the second question, why passing the response by reference? :)\n. Thanks for your answers!\nAnother question: should the user be required in the authorization endpoint?\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Server.php#L236\n. ",
    "n1te1337": "@bshaffer it should be good to go\n. Good point about casting but using intval alone may be problematic:\nphp\nintval(\"3423dgdf\"); //3423\nintval(\"rrer3sd33\"); //0\nMaybe we can use both:\nphp\n//can't use boolval() since it requires php >= 5.5\nintval((bool)\"3423dgdf\"); //1\nintval((bool)\"rrer3sd33\"); //1\nWhat do you think?\n. ",
    "mdemblani": "But the new specs say that an invalid_request error should be returned\n\n. ",
    "garyr": "Nice job @bshaffer, this is great\n. ",
    "rubberpants": ":+1:\n. ",
    "hyrumt": "Looks reasonable.\n. ",
    "drewbroadley": "Cheers @bshaffer, unfortunately things have moved on a bit since that extension was maintained (June 2012 is the last activity) and it's quite broken now.\nPHPCassa is the supported library of DataStax (https://github.com/thobbs/phpcassa) and is the preferred and maintained method of connecting. I have been burned from using others and them not keeping up with Cassandra's rapid change of protocols when settling into 1.x and beyond.\nSo unfortunately no PDO compliance.\n. https://gist.github.com/drewbroadley/df4421161d25bddbd51a\nI used the Redis storage connector as a base, have created and using this.\nDepends on phpcassa (the client library supported by DataStax who has $$ to maintain it)\n. I have some further updates, bringing the data in to use columns rather than the \"__data\" field, and broken things out to separate column families for easier management.\nI I've forked out to https://github.com/drewbroadley/oauth2-server-php and will do a pull request when finished.\n. I was just about to submit this EXACT pull request.\nPlease fix :)\n. Would I be so bold to suggest there might be a bug then ?\nI expected my redirect_uri supplied in the oauth_users\ntable/collection/column family/etc. to be passed through to this phase\nafter the authorize call had it supplied also.\nOn Tue, Jan 14, 2014 at 11:57 PM, Brent Shaffer notifications@github.comwrote:\n\nTo summarize this issue:\nRequest: The request was that redirect_uri is populated in the\nauthorization_code database even if it wasn't passed in to the /authorizerequest, in the case that the client has a\ndefault redirect_uri\nReason: It's nice to always have the redirect_uri for logging purposes\nWhy this is Wrong: This is impossible because the supplied redirect URI\nfor the /authorize request is validated against the supplied redirect URI\nfor the /token endpoint, so we must track the supplied uri directly and\nNOT populate with the default value\nSolution: Log the redirect_uri in your own impementation, and leave the\ncore library alone.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/pull/309#issuecomment-32255353\n.\n. I had issues where I was expecting authorization_code to have the\nredirect_uri column that was sent upon doing an authorization request and\nit wasn't being sent with the array.\n\nThus this made Cassandra unhappy to send a key of \"redirect_uri\" without a\nvalue (it tried to set a column with a null value), which highlighted the\nissue. I then tracked down, and expected \"redirect_uri\" to have a value if\npassed during the auth process.\nIt might be a misunderstanding on my part, but it seemed to be how the\nlibrary should have worked (but wasn't) from my investigation.\nOn Fri, Jan 17, 2014 at 1:54 PM, Brent Shaffer notifications@github.comwrote:\n\n@drewbroadley https://github.com/drewbroadley the scope of your user\nshould be passed through to the access_token, but NOT to the\nauthorize_code. The authorize_code scope is ONLY for scopes requested\ndirectly for that phase.\nif you want the user's scope to be provided by default, the best way to do\nthis would be to check the scope before calling the\nvalidateAuthorizeRequest function. If no scope exists, then set it to the\nuser's scope who is logged in (if relevant)\nThe reason this isn't implementing in core is the idea of a user having a\nspecific scope in general is not really part of the spec, and more\nimplementation detail. My hope is that the library allows customizations\nsuch as these to take place simpler. If there is a better way to support\nthis, I am definitely open to suggestions / PRs.\nThank you!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/pull/309#issuecomment-32569528\n.\n. Yeah, a bit bogged down. I will get back to this and rebase plus review changes mentioned by @F21's\n. When setting param in OAuth2\\Server of 'require_exact_redirect_uri' to true, I expect that you require to have to send the exact \"redirect_uri\" when doing a token call as when doing an authoriziation call.\n\nThis is not the case as the current code always returns true, and assigns to a variable instead which invokes the creation of an authorization code and later an access token. In this case it also gives unreliable error reporting unless the suggested approach tot he fix is taken on. Only then does it give the correct error about redirect_uri not matching (as expected).\nIt needs to be changed to a comparator, and from the looks of things, the variable is not consistent so needs to be changed to $supplied_redirect_uri not $required_redirect_uri (a small mistake on my part)\n. ",
    "tholder": "I think you have to consider a client application implementation. I'd want to trap 401s so I can report 'Sorry your login details were incorrect'. A 400 should be because the data is incorrectly formatted or supplied.\nIt's not a massive issue, but we would prefer to see 401.\n. No worries, thanks for all your hard work on the project it's really nicely put together.\n. ",
    "adambutler": "@tholder I agree that a 401 makes more sense than a 400 since the credentials are rejected rather than in an incorrect format. \n\nI reserve 401 or 403 when trying to access something where the user should already be authenticated.\n\nI would argue that 403 is correct for this but we shouldn't be reserving 401 for this scenario. The spec says:\n\nSimilar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet been provided\n. \n",
    "AidasK": "This method does not depend on Scope object properties or methods. Because of this, it could be used as a function, without creating a new object. Of course, this would be a breaking change, so you can close this issue.\n. Well, I would like to fetch only the data I am going to use to process this request. And I don't need client_id.\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Controller/ResourceController.php#L84\nThis validation only checks my data integrity and nothing more. I trust my database and it writes a valid client_id via setAccessToken method.\nAlthough this is a minor issue, and a simple workaround would be to return an empty client_id then requested\n. :+1: cookbook would be great\n. ",
    "luxifer": "Why can't we have in the current implementation a public key per client only and not per client per user? Because if you want to use the JWT as an authorization grant you should have a subject. And for now the getClientKey is done by passing the issuer AND the subject. For me it's really painful to have to generate a private/public for each user/client\n. That's what i've done. I just override the getClientKey in my custom\nstorage to only check the client_id\n. In my case client_id is highly trusted so i don't have to check if it can impersonate the user. My purpose is to only use the JWT grant type for highly trusted client and Authorization Code or Implicit for others\n. :+1: This could be nice for example to plug monolog and thow exactly what appened and when during the development process of an oauth2 server\n. Of course. I'll write them today\nLe 25 avr. 2014 00:20, \"Brent Shaffer\" notifications@github.com a \u00e9crit :\n\nThis is great! Although I would love a test for this in the\ntest/OAuth2/ServerTest/php class\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/pull/374#issuecomment-41339757\n.\n. \n",
    "jsacksick": "It's far away from being done, there's still a lot of pending questions. The specs are available there (http://openid.net/developers/specs), I also started by following this tutorial (http://nat.sakimura.org/2013/07/28/write-openid-connect-server-in-three-simple-steps). More to follow\n. ",
    "niravtrivedi": "Thank you for Brent reply me.Issue is solved.\nOn Sat, Apr 5, 2014 at 10:16 PM, Brent Shaffer notifications@github.comwrote:\n\nClosed #300 https://github.com/bshaffer/oauth2-server-php/issues/300.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/300\n.\n\n\nThanks & Regards,\nNirav Trivedi\n. ",
    "aledelgo": "You are right, and my modification actually violate the protocol ( http://tools.ietf.org/html/rfc6749#section-4.1.3 ), so it should be cancelled.\nThe problem is that actually the redirect_uri field track perfectly what is the redirect_uri parameter passed by the client in the code-request (as it should) and not what redirect is performed in the end and this have a sense as the specification say:\nif the \"redirect_uri\" parameter was included in the authorization request as described in Section 4.1.1, and their values MUST be identical.\nSo the solution to track redirect_uri parameter and final redirects is to add another field in the table (this don't do much sense as code are deleted on expiring) or write them directly in a Log or another DB table... I think the latter could be performed in the own app-server implementation just before sending the response as all data are contained in the request and response objects of the server class.\n. I don't think it is a bug... i see it as a non strictly-oauth2-related feature that is missing. The protocol don't say to store or track requests.\nJust to be precise, redirect_uri(s) are permanently stored in the oauth_clients table \n(not in the oauth_users table) and temporarily reported in oauth_codes until the code expires.\nIt would be surely a good feature-set the tracking of all successed and failed oauth requests but i think this is optional and also something related to the app being developed because each project require security tracking for different reasons and also need different outputs.\nAlso it is easy to implement this kind of tracking as, having you to implement the oauth server, you have full control on request's context variables... a simple logger line would be the quickest track method.\nHope this help.\n. In the new mongo driver the value of mongo.native_long is set to 1 by default.\nAlso the setting of this parameter is not supported anymore in 32bit machines and trying to set it generate a fatal error.\n. ",
    "orange-rhino": "Thank you Brent now it works as a charm. Thanks again\nSent from my iPhone\n\nOn 14 Jan 2014, at 09:22, Brent Shaffer notifications@github.com wrote:\nThis is a documentation issue with the sql query to run in the walkthrough. fixed in bshaffer/oauth2-server-php-docs@8a3feaa.\nSee the new SQl queryies here: http://bshaffer.github.io/oauth2-server-php-docs/cookbook/\nThis is because scope handling had been updated in the develop branch. To avoid issues like these in the future, you can stay checked out to Tags.\nPlease reopen if you have further questions. \n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "mangelsnc": "Thank you @bshaffer ! Now it works!\n. ",
    "skyserpent": "Only error I'm seeing:\nError: \"\" - Code: 0\n. {\"access_token\":\"100d03c1e21e8091195e3273f0ba6ccca1396bf2\",\"expires_in\":3600,\"token_type\":\"Bearer\",\"scope\":null}\nGot it working.\n. Actually it was working when I switched from CLI to Cygwin even though that doesn't really matter but it stopped working again. I'm getting a blank response instead of another access token when I tried the POST again. I will update this issue with whatever I come across.\n- STATE: PERFORM => DONE handle 0x800574e8; line 1533 (connection #0)\n- Connection #0 to host localhost left intact\n- Expire cleared\nThat's the verbose output whereas before, I actually saw a generated token.\n. $ curl -v -u testclient:testpass http://localhost/oauth/token -d 'grant_type=client_credentials'\n- About to connect() to localhost port 80 (#0)\n-   Trying ::1...\n- 0x8001f140 is at send pipe head!\n- STATE: CONNECT => WAITCONNECT handle 0x800574e8; line 1032 (connection #0)\n- Connected to localhost (::1) port 80 (#0)\n- STATE: WAITCONNECT => DO handle 0x800574e8; line 1151 (connection #0)\n- Server auth using Basic with user 'testclient'\n\nPOST /oauth/token HTTP/1.1\nAuthorization: Basic dGVzdGNdrWVhdp0ZXN0cGFzcw==\nUser-Agent: curl/7.29.0\nHost: localhost\nAccept: /\nContent-Length: 29\nContent-Type: application/x-www-form-urlencoded\n\nupload completely sent off: 29 out of 29 bytes\nSTATE: DO => DO_DONE handle 0x800574e8; line 1236 (connection #0)\nSTATE: DO_DONE => WAITPERFORM handle 0x800574e8; line 1352 (connection #0)\nSTATE: WAITPERFORM => PERFORM handle 0x800574e8; line 1363 (connection #0)\nHTTP 1.1 or later with persistent connection, pipelining supported\n  < HTTP/1.1 302 Found\n  < Date: Wed, 22 Jan 2014 00:51:21 GMT\n  < Server: Apache/2.4.4 (Win32) OpenSSL/1.0.1e PHP/5.5.3\n  < X-Powered-By: PHP/5.5.3\n  < Set-Cookie: CAKEPHP=bd22nm4gs34g3gs3a3476vdta82; path=/; HttpOnly\n  < Location: http://localhost/oauth/\n  < Content-Length: 0\n  < Content-Type: text/html; charset=UTF-8\n  <\nSTATE: PERFORM => DONE handle 0x800574e8; line 1533 (connection #0)\nConnection #0 to host localhost left intact\nExpire cleared\n. \n\n",
    "gdragotto": "Good Morning,\nYes, i'm using the last version of OAuth2.\nThe path o autoloader is the correct one.Otherwise it not load the class correctly.\ncore_include(\"oauth/Autoloader.php\");\nOAuth2\\Autoloader::register();\n$storage = new OAuth2\\Storage\\Pdo(array('dsn' => 'mysql:dbname=_;host=, \n                                        'username' => , 'password' => _));\n$server = new OAuth2\\Server($storage);\n$server->addGrantType(new OAuth2\\GrantType\\ClientCredentials($storage));\n$server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($storage));\nUsing print_r(get_declared_classes()); i got only the autoloader\n[...] => OAuth2\\Autoloader ) [...]\n. Thank you for the care.\nI've found the solution: when you include the class you have NOT TO RENAME \"OAuth2\" FOLDER.\nHave a good day!\n. ",
    "lgelfan": "Sure - it was my first experience with this library, so I just wanted to make sure I wasn't missing anything. I can submit the changes.\n. ",
    "pjebs": "How do I change the \"Label\" to question? Since this isn't a bug report\n. I have sent an email to bs***@gmail.com with some code addressing this!\n. Even if I'm using Authorisation Code grant type?\n. It doesn't seem to work :(\nI keep getting this error:\nFatal error: Uncaught exception 'PDOException' with message 'SQLSTATE[42S02]: Base table or view not found: 1146 Table 'id_server.oauth_clients' doesn't exist' \n-It expects the oauth_clients table to be with all the other tables instead of being in a separate database as defined by OAUTH_CLIENTS_DB_NAME\n$dsn      = 'mysql:dbname=' . OAUTH_SERVER_DB_NAME . ';host=' . DB_HOST . ':' . DB_HOST_PORT;\n$dsn_client_credentials = 'mysql:dbname=' . OAUTH_CLIENTS_DB_NAME . ';host=' . DB_HOST . ':' . DB_HOST_PORT;\n$username = DB_USERNAME;\n$password = DB_PASSWORD;\n$storage = new OAuth2\\Storage\\Pdo(array('dsn' => $dsn, 'username' => $username, 'password' => $password));\n$storage_client_credentials = new OAuth2\\Storage\\Pdo(array('dsn' => $dsn_client_credentials, 'username' => $username, 'password' => $password));\n// Pass a storage object or array of storage objects to the OAuth2 server class\n$server = new OAuth2\\Server($storage);\n$server->addStorage($storage_client_credentials, \"client_credentials\");\n. Then when I change \"client_credentials\" to \"client\", it appears to work (i.e. passes through validateAuthorizeRequest and even provides a Code).\nBut the moment you try to get a Token, it again says it can't find the id_server.oauth_clients table in the database that stores all the other tables such as access tokens etc.\nCould this be an error in the library?\n. Thanks Brent. 100% fixed.\nWhy did that cause the issue? Was it something wrong with the library?\n. I am still wondering what the user_id column is for in client_credentials grant type.\nIf it is used in the Resource Controller Endpoint, you getAccessTokenData still gives you the client_id.\n. For authorisation code grant type, I understand that user_id in token table helps associate the token to the client and user.\nFor client credentials, the user is irrelevant so I still don't understand why it's needed and why it's in client table.\nGetAccessTokenData() can pull the client_id from the token anyway.\n. I was wondering what the progress was of this? It would definitely be a useful addition\n. Verified. Yes it is.\n. I have sent an email to bs***@gmail.com with some code addressing this!\n. Could you explain the user_id again in a bit more detail.\nDoes it mean a specific user IS the client?\n. I think this should be easy to implement and should be implemented. Double token length.\n. That may be the first step towards a client being able to specify MUST have scopes and NICE-TO-HAVE scopes.\nObviously this will deviate from the OAuth specifications but it will be a super-set so it won't contradict the specifications.\n. This is what facebook does:\n1. There is a whole list of scopes giving different types of permissions to 3rd party apps (clients).\n   i.e. scopes: A,B,C\n2. Each user for each client can register which of those scopes they allow for each client.\ni.e. User 1 -> For Client Z: Scope A & B\nUser 1 -> For Client Y: Scope B &C\nUser 2 -> For Client Z: Scope A, B & C\n1. When the client initially asks the User  for authorization for the scopes they require, it gets registered in a separate table NOT on the actual token.\n2. The actual token literally represents that the User just gave the client a 'key'. That way, in the future the user can deactivate scopes for a particular client as they see fit.\n3. When the client is attempting to access a resource endpoint, the endpoint does not check which scopes are registered with the token (because the token doesn't register that info). It checks in the database if user has given the client the appropriate scopes.\nHope it helps.\nYour current implementation would probably need a major overhaul to support a framework like Facebooks. Perhaps that is for the next version.\nNB: The user can also revoke the token given to the Client (analogous to taking back the key), which will then reset the relationship between the User and Client to before the Client asked for the initial authorization.\nAlso, extra note: This has nothing to do with the OAuth server but as a handy feature can be implemented by the server:\nFB returns to the client an \"app-scoped\" id so the client can identify the user consistently whilst the id remains unique only to the client.\ni.e. User 1 logs into Client Z: Receives an app-scoped id of 123.\nUser 1 logs into Client Y: Receives an app-scoped id of 543.\nThe OAuth server can translate id 123 back to User 1 (for Client Z) etc. But Client Y can not assume that id 123 represents User 1 because for Cilent Y, only id 543 represents User 1.\n. Can you provide more detail on how it can be done i.e. the stuff you wrote above.\n. I have sent an email to bs***@gmail.com with some code addressing this!\n. You'll need to provide more details including your code.\n. You seem to be missing this line:\nOAuth2\\Autoloader::register();\nDid you install using composer???\n. i.e. no error or error_description in json response. the response is just empty\n. No.\nI'm just var_dumping $bridgedResponse and its contents are empty.\nIf i was to change client_id to something non-existent, then $bridgedResponse will contain status code of 400 and error and error_description.\n. I found out this error occurs:\n1) Always when no state is provided regardless of scope\n2) When state is provided and scope is invalid (not in oauth_scopes table).\nHow can I fix this?\n. No bug - I didn't realise that sometimes $bridgeresponse is a redirect and othertimes it is not. When it is not, getContents() contains the error information. When it is a redirect, getContents is empty but you have to check location header.\nAlso this confused me a bit too:\nhttp://bshaffer.github.io/oauth2-server-php-docs/controllers/authorize/\nReceives a request object, returns false if the incoming request is not a valid Authorize Request. If the request is valid, returns an array of retrieved client details together with input. Applications should call this before displaying a login or authorization form to the user\nIt seems to always return a bool. Never an \"array of client details\".\n. Safe to close.\n. I.e totally disable default scopes everywhere\n. You need to put the logic outside of this library in your own code:\nYou can do this using session data and a separate GET and POST method:\n* GET: Presents login dialog box if not logged in\n * GET: Presents authorize dialog box if logged in\n * POST: Processes login username and password\n * POST: Processes authorization (confirm or reject) by customer\n * Returns oauth code (& redirects) if successful or appropriate error messages\n. Yes. Don't call send(). Inspect the properties in $response and create a json response using the info you need.\n. However you should ALWAYS be allowing the redirect. If you are making an app, perhaps the grant type you want is user credentials. See twitters documentation on xAuth.\n. How can I get access to the $client_id?\n. I only trust some clients for UserCredentials grant type. Is there a better way to restrict UserCredentials to only a limited set of clients.\n. It's in the client database table.\n. I don't understand what you are trying to do?\n. @bshaffer The workaround works but is this a bug?\n@Ganganation If you were to add the grant types via the server constructor (optional 3rd parameter), then the server will create a default refreshToken grant type instance with your original $config parameters passing through to it.\n. https://github.com/bshaffer/oauth2-server-php/issues/369\n. This is the top statement of log:\n[2016-10-02 01:56:02] production.ERROR: PDOException: SQLSTATE[22007]: Invalid datetime format: 1292 Incorrect datetime value: '2016-10-02 02:56:02' for column 'expires' at row 1 in XXX\nIt looks like server's time is 1:56:02.\nI'm not sure what access_lifetime was at the time but I suspect it was 3600 (1 hour).. time() + $this->config['access_lifetime'] returns a unix timestamp.\n$expires = date('Y-m-d H:i:s', $expires);\nSomehow PHP attempts to convert it to a Y-m-d H:i:s format incorrecty (?).\n. I didn't fix the issue.. I'm just waiting for @bshaffer  opinion on the matter because he may have a reason for timestamp. Nothing wrong with that. Looks fine.\nYou'll probably have to set the redirect_uri to something other than google though.. the 302 http status code IS THE REDIRECT. That tells the browser to perform a redirect.. You're probably printing the response on the screen rather than sending the response to the client(ie. browser)\n. Just delete the access token from access_tokens table.\n. Whether the token is invalid or expired, what's the difference? You still have to create a new one using same process.. what does VS mean?. ",
    "EMCP": "I had to write custom login in my controllers for this.  I'm using Apigility which in turn used this project, and their ACL was inadequate for the kind of control I needed.\n. Why not a Pull Request?\n. @bojanz I've asked my friend who claims this to explain it.. but thought I pose this to the project as well.\nThey should be back in a week or so.\nTo me, it seems obvious that if OAuth2.0 is used in conjunction with SSL, the Authorization Header (including the trusted Basic Header for trusted clients) is encrypted.  Yes?\n. @bshaffer thank you, I think perhaps my colleague assumed JavaScript was being executed.  I'll highlight the fact that this is running a PHP Curl Client.  Your understanding is where I was coming from.  I'll close for now and cite this conversation when I meet with him.\n. ",
    "bbalet": "Please update online documentation : \nhttp://bshaffer.github.io/oauth2-server-php-docs/overview/crypto-tokens/\n. ",
    "cridoret": "how about having those admins functions available through a cli app? \n(symfony/console for example. that's what I built for a API using this library)\n. ",
    "flx5": "Yes, just wanted to be sure about this.\nBut as I've stated above, my main question is wether I should simply do a query like \"SELECT * FROM oauth_refresh_tokens WHERE user_id = USER_ID\" or use a function I may have overseen.\n. ",
    "letsbyteit": "@bshaffer: Just a little question about revoking permission of a user's authorised client: You say 'his can be done as well by revoking per client per user', what exactly does that mean? \nShould I remove every entry where client_id and user_id matches? Or did I miss something?\n. ",
    "farooquiyasir": "I think there should be a proper way of doing this. There is no relationship between an access token and its refresh token. So you cannot delete a refresh token when revoking an access token.\n. I think it makes sense to revoke access of a client and not an individual access token. So if you are allowing your users to revoke access to the resource server, you will list individual clients in front of them, and will not want to repeat client names if there are more than one access tokens for a client. In that case a simple method can be written to delete / expire all access tokens + refresh token against an individual client.\n. ",
    "phindmarsh": "Theres actually an RFC for OAuth token revocation RFC7009, which outlines some ideas on how revoking tokens should work from an API perspective.\nI've implemented some changes according to this spec in my fork, if you think it might go some way to solving your use-case (and you'd like it in the lib @bshaffer) I'll he happy to issue a PR. It essentially creates a removeAccessToken() method on the storage interfaces and adds a revoke endpoint to the controllers. \nI suspect due to the new removeAccessToken method this change would probably have to land in a 2.0 release since it is not backwards compatible. Thoughts?\n. Ok no worries, I initially intended to submit a pull, but as you say, it's potentially overkill. If you change your mind in future I'd be happy to work on it.\n. Are you url encoding the & when you make your authorize request?\nI'd wager that since the & is a character used to delimit query arguments it makes it seem like the &another_test=true is a parameter to the authorize request not as part of your redirect uri.\nIf you url encode the redirect uri like this does it work (something like below):\nhttp%3A%2F%2Flocalhost%2Ftest%2F%3Ftest%3Dtrue%26another_test%3Dtrue\n. @ssanders Not especially relevant, but if thats a copy paste of your workaround, I'd strongly suggest you do some escaping of your POST variables before putting them in a query like that. \n. Any particular reason for choosing hash_pbkdf2 over the password_* functions that are designed for hashing passwords for this exact purpose?\nThey will be natively supported in 5.5, with an excellent polyfill (https://github.com/ircmaxell/password_compat) available until then. IMO these functions are a much better choice for hashing passwords since they use standard algorithms (bcrypt for example) and will eventually be a standard set of functions used in PHP.\nI don't think it is the job of this library to roll its own hashing functions. Using password_hash means if an algorithm needs to be changed in future it's just a few config tweaks and will remain compatible with previous hashes generated with the same library.\n. I'm not a cryptographer (or a physicist) either :smile: \nI think there are several different opinions at play here (as always with crypto stuff), mine is generally \"unless you are a cryptographer (and even then), don't try and roll your own crypto\".\nOne of the comments on that post about bcrypt you linked to sums it up well I think:\n\nThe reason I usually recommend bCrypt is actually due to the human factors involved; essentially, bindings are available for every language, the API is consistent and fairly foolproof.\nUsually we don't need \"optimally secure\" hash functions, we just need \"good enough to be indistinguishable from best practice\" and bCrypt fits the bill here fine.\n\nYes, password_hash using bcrypt at the moment, however it is likely as the crypto landscape changed the function will be updated to support other algorithms. In my opinion this library should prefer standard implementations of these functions to get the best interop possible.\nI understand your reservations about bcrypt, and the reasoning behind your implementation (tbh I didn't read the full detail so it being backwards compatible is pretty sweet). However if your requirements are such that the standard library doesn't do the right algorithm (or whatever), you should implement your own UserStorage class and implement it there.\nI don't mean to negate the work you have done, I'm still on the fence as to whether this library should do strong hashing at all (on the one hand it'll be better for those that can't be bothered, but if they can't be bothered they really shouldn't be writing authentication/password code in the first place :wink:).\n. Have to say, I generally agree that it shouldn't be up to this library to make choices about how to store sensitive data (be that bcrypt, pbkdf2 or whatever).\n@xaionaro You earlier posted a link about why we shouldn't use bcrypt, then dismissed @ezimuel's similar links as 'not scientific', perhaps you shouldn't be so quick to defend your position.\nFor me any implementation shouldn't add any additional dependencies or up the minimum version requirements for this library, since it's not a core feature. It seems like you have very specific requirements for your hash function, and I don't think it's appropriate to make other users install mcrypt and other dependencies just to use something that's probably overkill for most use cases (and likely overridden by custom UserStorage classes anyway).\n. @delwareconsulting The trouble with changing to numeric codes ('001', '002' etc) library wide is most of the text based codes (like invalid_request and invalid_scope) are defined in the OAuth 2.0 spec, particularly section 5.2 and section 7.2.\nSection 7.2 covers error responses to resource requests and does not define a set of error codes, however I'd suggest these should follow the convention defined in section 5.2 (i.e. not be codes like 001 but expired_token as the PR suggests).\nIMO the PR is a good solution, since it conforms to the spec (doesn't change the defined codes) and follows the existing naming convention.\n. You'll need to make or extend your own response type. \nI'd suggest you start with the OAuth2\\ResponseType\\AccessToken class, particularly the createAccessToken() method. Once you have extended that class you'll need to tell the server to use it instead of the default one.\nSomething like this:\nphp\n$server->addResponseType(new MyCustomAccessToken($tokenStorage, $refreshStorage, $config), 'token');\n. I'd suggest you handle this outside this library. You could intercept the OPTIONS request in your webserver (say nginx or Apache).\nFor example, I've used this configuration in the past (for nginx)\n```\n    if ($request_method = 'OPTIONS') {\n      add_header 'Access-Control-Allow-Origin' $http_origin;\n      add_header 'Access-Control-Allow-Credentials' 'true';\n      add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PATCH';\n      add_header 'Access-Control-Allow-Headers' 'Authorization,DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';\n  add_header 'Access-Control-Max-Age' 1728000;\n  add_header 'Content-Type' 'text/plain charset=UTF-8';\n  add_header 'Content-Length' 0;\n\n  return 204;\n}\n\n```\nIn this case, within a location directive of my nginx conf I have the above configuration, which will reply with a HTTP 204 code when an options request is made, setting the required CORS headers.\nThe only caveat to this (for nginx at least, not sure about Apache) is if you make a request to the oauth server that returns a non-200 status code, nginx will not apply the headers. To circumvent this you have to install the headers more module, which does not have this limitation. \nAlternatively, if you choose not to implement this with your webserver, you'll need to hook the request before the OAuth library gets it and return a response similar to the above. Depending on how you are integrating the library will change how you do this. Silex for example would need something like this:\nphp\n$app->after(function($request, $response){\n        $response->headers->add(array(\n            'Access-Control-Allow-Origin' => '*',\n            'Access-Control-Allow-Credentials' => 'true',\n            'Access-Control-Allow-Methods' => 'GET, POST, OPTIONS',\n            'Access-Control-Allow-Headers' => 'Authorization,DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type',\n        ));\n});\nFor my usecase, I use both methods outlined above, so OPTIONS requests are handled by the webserver, and everything else is handled by the Silex app that I have wrapping the OAuth server library.\nHope that helps.\n. Yeah I noticed that too, managed to get around it because I had a Grant Type. I think it is a bug, the doc block says one thing but the code does another.\n. @dashohoxha You can automatically issue a token without prompting for authorization by just calling the handleAuthorizeRequest() method as soon as the user logs in.\nThe third parameter for that method is $is_authorized, which is a boolean whether the user has authorized or not. So you'll need some way of storing a map between a user and a given client_id (probably) and check that first, or maybe just look at currently issued tokens or something, up to you. If that check is true, then call handleAuthorizeRequest() immediately after the user logs in, otherwise redirect them to the authorize page as you do currently.\nThe cookbook has an example for calling these methods under the \"Create an Authorize Controller\" heading (not the skipping if already authorized bit, but you should be able to see how the handleAuthorizeRequest() method works).\n. > LOL, that's really funny - you actually assumed that it was in state unencrypted? How cute.\nYou would be surprised how many people do stupid stuff with this library, it's better to err on the side of stupidity then assume otherwise unfortunately. \n. /cc @bshaffer I'd be keen to address this if you have an opinion.\n. No worries, I'm happy to push a PR for this today.\nI agree about patching the library rather than pulling in firebase/php-jwt, although I do wonder if that is something to be considered for a later time (if only because that lib gets more eyes from a security context). Our OAuth server implementation uses it instead of the built in one at the recommendation of a security audit.\nI'll get a PR together applying a fix for the internal JWT class, and we can move the migration to firebase/php-jwt to another discussion.\n. Replied inline to a few bits, I've updated the interface for the decode() method, had totally forgotten about the semver requirements. I see you've done the same already (after I'd pushed it) but it all looks good to me :+1:\n. One point on the semver requirements, does adding a new method to EncryptionInterface technically break BC too? Anyone updating would have to edit their classes implementing it to add the new getSupportedMethods() method. Perhaps it would be safer in JWTBearer:180 to just do something like: \nphp\n$allowed = array('RS256', 'RS384', 'RS512'); \n// Verify the JWT\nif (!$this->jwtUtil->decode($undecodedJWT, $key, $allowed)) {\n    $response->setError(400, 'invalid_grant', \"JWT failed signature verification\");\n    return null;\n}\nThen get rid of all that JWT::$supportedMethods business and deal with that in a major version bump. The downside being if the algorithms change in the JWT class we'd need to remember to edit them in the JWTBearer class too. If we declare them statically on JWT but not use a method to access that works too, but then creates a hard dependency where someone might be overloading the default JWT class and we've defined algorithms they don't support. Tricky business!\n. If we just remove the method from the interface but someone provides an alternative implementation of EncryptionInterface that'll bust it too since the method will be undefined right?\nPerhaps I should make a 'allowed_jwt_bearer_algorithms' config option that has the defaults set in it (array('RS256', 'RS384', 'RS512')), that way we don't need anything fancy in the interface, it'll still allow people to override it, and it wont break anything backwards.\nThoughts?\n. Actually, technically this PR will break BC regardless because if someone isn't passing an array of allowed algorithms to decode it will always return false, breaking what was working for them in the past. Decode will no longer work at all without it. There's no real safe way to provide defaults here either. I suppose it depends on how rigid the backwards compatibility needs to be.\nWe could fall back to the previous behaviour of trusting the header value if the supplied argument is not an array, but that's a little dodgy. If you'd prefer to keep this a minor version bump and maintain the BC in this regard then I'm happy to implement it this way.\n. Implemented in #569.\n. :+1: not often I am applauded for having my shit together.\n. I've updated the constructor, so this should be all good to go now :+1: \n. I have implemented pretty much exactly this, and perhaps the JWT Bearer would have been more appropriate for it (I'd implemented it before that was available in this lib), but this is what I did:\n- Create a new Grant Type called masquerade that takes an access token and a user_id to log in as.\n- When administrators are logged into the management system the access token (let's call it admin_token) a scope called masquerade is attached to it. This scope can only be requested by admin users\n- To log in as another user, I issue a POST request to the authorise endpoint, sending the admin_token and the user_id I want to log in as, with the grant type being masquerade.\n- The custom grant type checks the token is valid, and the scope is correctly associated. If it is, then the grant type returns a new token (say user_token) associated with the requested user.\n- This user_token is swapped into the JS web-app and reloaded. We are then logged in as a given user.\nA few things you need to be very careful of:\n- Only let this grant type be used by authorised people, either by scope or checking the original user_id is an administrative user. Otherwise anyone will be able to assume the account of anyone else, even admin users. \n- Don't let a user_token request a higher scope than the minimum required for you to achieve your login-as requirements (i.e. let someone assume the role of an administrative user).\nHope that helps, if you have any questions feel free to ask :)\n. @bensquire There isn't much to it, but I've copied the custom grant class and stripped out some of the irrelevant stuff (I extend some abstract grants etc) so it wont 'just work', but it should give you an idea of what to do. Essentially put the logic you have into the ->validateRequest() method and add the grant when you instantiate your server.\nhttps://gist.github.com/phindmarsh/11c80df8cd220c09b65c\n. No problem, what level do you run the linter at? I've just done a pass using the defaults and ended up with 92 modified files :open_mouth: \nOnce you've had a chance to review and I've done the cs-fixer I'll close and resubmit against the v2.x branch\n. I've re-run the php-cs-fixer with --level=psr2 and discarded the changes to files this PR hasn't touched - I figured you'd rather this PR was only dealing with the revoke changes, not style changes to files unaffected by it.\n. Righto, I've commented out (but left a @todo note) on each of the new methods defined in the interfaces, added a check to make sure the unsetAccessToken method exists before running the test. \nObviously while this doesn't break BC, it will cause a fatal error if someone attempts to use the revoke endpoint with a storage that doesn't implement that method, since there are no runtime checks to ensure that method exists. I can do this if you like, although not sure what it should do instead (throw an exception, fail quietly etc).\nI assume at some point we'll put another PR against the 2.x branch with the interface methods added back again?\n. Noted, added a \\RuntimeException to each call that was defined in that interface, and added a @todo to remove it when 2.0 lands. \nThat should be all the changes needed.\n. Ping @bshaffer, did you want to do anything here?\n. Sorry I keep forgetting to rebase this up to master. I'll do it now and then it should be ready to go.\n. Righto, all up to date now, @bshaffer this is ready when you are.\n. Merged and rebased back to a single commit, thanks @bshaffer :+1: \n. Space separated has worked for me in the past.\u00a0\n. Hey, on my phone so excuse the brevity.\nYou should look into the JWT access token stuff. It allows your auth server to issue signed tokens that you can later validate with only a JWT lib (such as fireball/jwt) and the signing key.\u00a0\nI use this exact method for an API where the service issuing tokens is separate from the api that uses them for auth. All that I share between is an hmac secret used to sign the JWT tokens. If the signature verifies then you can trust the user_id etc supplied in the token.\n. @JohnAdamsy thats pretty much exactly what I outlined above. \nYou have your AS issue JWT access tokens, which are JSON objects that have been base 64 encoded and signed with a secret key. Then all you need is a JWT lib on your RS (in any language), decode the token, verify the signature, and if all good you can trust the contents of the token to be what the AS issued in the first place. If you have AS and RS that are physically separated and you do not wish to write a bridge to the AS for each request to the RS then this is the way to do it. As I said, I've implemented it and it works perfectly. \n@JerryBels On that note, if the codebase issuing tokens (authorization server) is the same as your API (resource server) then you can use the verifyResourceRequest method of the Resource Controller to do exactly that (see the Create a Resource Controller of the cookbook page) . That only falls over if you have different codebases/apps, as hinted by @JohnAdamsy above). In that case I'd recommend the JWT token route. It is very simple to implement, just follow the JWT access token docs.\n. Well thats probably up to you, if I were in your position I'd probably just use the JWT tokens and pretend I don't share a database. \nI'm not that familiar with Laravel so I can't really help you with that, except to say that the docs are usually pretty accurate and that looks about right to me. It looks like you use that singleton method to configure your server, so any of the config code you see should probably go inside that block. \nOn the client secret, yes you probably should pass that through the same type of security you use for passwords, the only caveat being if you need to display that client_secret via a UI (if you allow third party developers to create clients etc) If you do that and use standard password hashing (like bcrypt/scrypt) you won't be able to reverse it. In that case you can either use two-way encryption (AES or some such), but thats probably outside the scope of this discussion. If you are only ever going to have first-party clients (i.e. ones you or your team write) and you don't need to discover the client_secret once it has been generated, then sure, hash away.\nOn your last point, no, client_id and client_secret are used to identify clients only. By default a user's credentials are stored in the oauth_users table (if you are using MySQL for example). Typically this is probably overridden by most developers to use their own user store. When authenticating a user some grant types will require both client credentials and user credentials. Client credentials are to authenticate the client (i.e. the application code, mobile app etc) is authorized, and user credentials are used the the traditional sense to validate the user is who they say they are.\n. You should look at implementing your own storage class that implements the UserCredentialsInterface. This will allow you to write all your own logic for getting user credentials and sideload it into the server instance. \nIIRC you are using Laravel, so when you make your singleton you'll do something like this:\n``` php\nApp::singleton('oauth2', function() {\n//create your server as you are now, this is just from the cookbook example.\n$storage = new OAuth2\\Storage\\Pdo(App::make('db')->getPdo());\n$server = new OAuth2\\Server($storage);\n\n// here you are setting your custom user storage class as the object to use to fetch\n// credentials for your server.\n$myUserStorage = new MyCustomUserStorageClass();\n$server->addStorage($myUserStorage, 'user_credentials');\n\n// whatever other server code you have...\n\nreturn $server;\n\n});\n```\nImplementing the UserCredentials interface in you own class should be straightfoward enough, you'll just need to make sure you return the right stuff. If you are looking for hints check out the existing Pdo Storage classes for ideas.\n. Yep thats right. You should not need to modify the library code itself, if you find you are changing internal classes etc you are probably not on the right track.\nAlso correct on passing the custom storage to the grant types as required. This lib is very extensible that way, almost all of it can be overloaded with custom code and configured when you build the server. \nGood work :+1: \n. They might have meant that access tokens are issued against a client, but you can't necessarily enforce that only that client can make requests with that token unless all your requests contain that client's credentials. \nYou might be thinking of OAuth 1.0a based applications, where the client application must sign all outbound requests before they are sent to the server, which would allow the server to determine if the access token was authorized for that access token. Unfortunately this is not a property of the OAuth 2.0 spec, so there is no 'built-in' way to do this with OAuth 2.\nI can't really think of a reliable way of doing what you want without having some sort of domain/client identifier that is sent when requesting an access token and also with every resource request. You then check this is valid and has the associated access token before proceeding. Probably the most appropriate way of doing this would be sending your client credentials when you make resource requests and use those credentials to load the client and check it is the same as the client the access token was issued against. \nI would advise against simply checking the HTTP_REFERER header or whatever to determine what domain the request came from as this is easily spoofed and defeats the purpose of the check in the first place. You also want to make sure you aren't transmitting your client credentials in the open (say from a Javascript app), they must remain a secret.\nIf that doesn't suit your requirements, then your best bet is probably just a short expiry on your access tokens, and treat them with the lowest privilege possible so if they are leaked the damage is for a very short period, and not that wide in scope. That said, you should probably be doing this anyway :smile: \n. The Base64 encoded tokens are probably using JWT. This doesn't especially help you in this case though because its more designed around signing tokens between two trusted locations and transmitting the token in the clear.\nThe trouble with doing any sort of signing/hashing/whatever in JS is it will be very easy to fake if someone unpacks your JS source. Having thought about it briefly, I can't think of a 'secure' way for you to ensure your api can only be accessed by your clients while requiring it be used by Javascript, simply because anyone who wants to dick around with your stuff will just use your JS to implement it themselves. An encoded window.location will be just as spoofable as HTTP_REFERER in this case, especially since you'll have to make your hmac key public, which means you may as well not even use one.\nThe best I can come up with (which is still pretty easy to get past) is for your api to have some sort of nonce that it sent when the JS application is requested. It should change pretty often and if a request is made where that nonce doesn't match the request is rejected. Functionally its the same as the access token, but means an adversary will need to lift an access token, plus the nonce, and keep them up to date in order to access you API outside the bounds you desire. Still, I can think of a plenty of ways to get around this, so its almost in the bounds of being a waste to implement. \nCan I ask, why must your API only be accessed by your clients? I don't want to make assumptions about your system or requirements, but when I've seen this in the past it's because the API hasn't implemented proper access controls etc and is attempting to hide that with a kind of security theatre :wink: \n. Ok sweet. My recommendation to you in that instance would be not to worry about trying to implement anything in this area. In my experience you'll just end up playing whack-a-mole and putting a whole lot of time down the toilet for little reward.\nInstead, I'd invest that time into making your API resilient and easy to introspect, so if you see abuses you can block or flag them. Things like IP logging, rate limits per IP etc will give you a much better end result of better visibility and control over your data. \nTake that as you will, but from a technical point of view I can't see the time you'll spend on it making it worthwhile.\n. The only trouble with adding this is the current behaviour is defined by RFC 6750 section 2.2, so allowing other content types is not permitted by the spec. When including the token in the token in the body:\n\n\nThe HTTP request entity-header includes the \"Content-Type\" header\n    field set to \"application/x-www-form-urlencoded\".\nThe entity-body follows the encoding requirements of the\n    \"application/x-www-form-urlencoded\" content-type as defined by\n    HTML 4.01 [W3C.REC-html401-19991224].\nThe HTTP request entity-body is single-part.\n\n\nThe alternative to this is to supply the token as an Authorization header or in the query string of the URL. In these two cases, you are allowed to use whatever Content-Type you like. \nIs it possible for you to use the token in a header or in the query string instead? That would allow you to use whatever Content-Type you want and still conform to the spec.\nEdit: just noticed you actually mention the RFC in you post, sorry about that!\n. Yep no problem, I have implemented uploads in both mobile and JS web-apps so it can be done quite easily, it just depends on the libraries you are using.\n. I've implemented exactly this using a custom grant type and the Facebook client SDKs for JS, iOS and Android.\nThe basic flow is:\n- Log the user in using the native client SDK for whatever platform (JS, iOS etc), requesting the email permission\n- Get the Facebook access_token from the response\n- Make a request to the OAuth 2.0 /token endpoint with grant_type=facebook and fb_access_token=<token>\n- In the custom grant type, use the fb_access_token to request the user's Facebook profile using the Graph API (the /me endpoint).\n- Locate a user in the local database with the same email address\n- If no users exists, create a new user account with the information from the /me request.\n- If a user exists, log them in and return an OAuth 2.0 access token\nThis flow works if you trust Facebook to verify email addresses for your users, you should make sure this condition holds for your application. You can also pretty much replace Facebook for any other 'social identity provider' such as Twitter, Google+ etc.\nI've knocked up an (untested, cut down) version of the grant type I wrote into a gist. It should give you a rough idea of what to do, it probably won't work out of the box because our code is structured slightly differently so the example is just the important bits copied and pasted together.\n. I'm not familiar with ZF2 or the service injection container it uses, so unfortunately I'm not much help in that department, sorry!\nI only had one suggestion, once you have loaded the custom grant successfully, you should not need to use a custom route /oauth/fb-access-token, but rather just use the standard /oauth/token endpoint with the grant_type=facebook parameter in the body. Since the grant_type parameter defines what grant to use when issuing a token you shouldn't need to build any additional routing/server logic beyond just injecting the grant type class when the server is instantiated.\nThe only thing you might need to do is allow certain clients access to use that grant type by defining it in the grant_types column of the oauth_clients table (this is a space separated list of allowed grants for that client).\nSome pure speculation on the service manage returning a factory closure may be that you can decorate that function (say, creating a new closure and inside executing the original then decorating the result and returning), and set your new 'decorated closure' in the service manager instead. This is similar to a pattern used in Pimple (the service container used by Silex etc) which allows decorating existing services with the ->extend() method. Dunno if this is completely wrong or not, just a guess :smile: \n. It depends on how you have configured your server to treat re-use or re-issuing of refresh tokens. In our case, our when a refresh token is used a new one is re-issued to replace it. This is done by setting the always_issue_new_refresh_token config option to true when bootstrapping your server (see here for docs). You can continue to use these new refresh tokens as long as you like without asking the user to log in again, provided you are refreshing within the expiry window.\nIn the case where you don't get new refresh tokens each time, or you wait a sufficient amount of time for the token to expire then you will need to ask the user to log in again to obtain a new one.\nTypically, you will want to keep track of when your access_token is due to expire and when you get close to that time use your refresh_token to get a new one. From here you have two choices:\n1. If a new refresh token is issued in the token response, replace your current refresh token and start over\n2. If you are allowed to use your refresh token repeatedly, then keep track of the refresh token expiry and request the user to log in when it expires. In most cases your server will have a really long refresh token lifetime if it doesn't enforce one-time-use.\nDoes that answer your question?\n. In a rough sense, yes you are correct. However from an UX perspective I'd advocate you took a more proactive approach to refreshing your tokens. Rather than sending a request and waiting for it to fail, keep track of the expiry time and do a refresh in the background before it expires. That way the user of your app doesn't have to wait while the request fails, you refresh the token and make the request again. Of course this is entirely up to you, but yes, you are on the right track.\n. No worries, if you don't have any further questions about this library just close the issue too :smile: \n. Under normal circumstances this should be CONTENT_TYPE as specified by RFC 3875 section 4.1.3:\n\nIf the request includes a message-body, the CONTENT_TYPE\nvariable is set to the Internet Media Type [6] of the\nmessage-body.\n[...]\nThe server MUST set this meta-variable if an\nHTTP Content-Type field is present in the client request header.\n\nIt seems like there was a bug in the built-in webserver PHP ships with in 5.5.8 where it was not being set correctly, but this has been patched now (see bug report)\nSo in unless your webserver or php version is misbehaving, the field should be CONTENT_TYPE, not HTTP_CONTENT_TYPE.\nOn a side note, I've glanced over that referenced issue you linked to, in the stacktrace it has 'CONTENT_TYPE' => 'application/json' which is expected, so I'm not sure this is causing that issue. One thing to note here is the OAuth 2.0 RFC6749 section 4.3.2 specifies that the CONTENT_TYPE must be application/x-www-form-urlencoded not application/json. This library enforces that requirement, so if you are sending POST requests to endpoints managed by this library it could be the reason it is throwing errors about missing data (since the POST body isn't in the correct format). \n. You are certainly on the right track, I have an AngularJS application that uses the same pattern (except the JWT is actually checked by a different app). As I understand it though the JWT Bearer grant is for a different thing. \nThe JWT Access Token docs are really useful (which I'm sure you have already read), but the token will be verified automatically if you configure your server to use JWT Access Tokens, or you can do it yourself with whatever library/code you like. The firebase/jwt lib (which is bundled with this lib) has a decode method that makes this really easy.\nDoes that help?\n. Nope, you were correct before when you suggested the user credentials grant type (grant_type=password). With this grant you effectively just POST the users username/email and password to the /token endpoint (plus the client key) and you'll get an access token back. If you have configured the server to use JWT Access Tokens then you should just get one automatically.\nFrom there, you can treat the JWT as a normal token in your Ember app, and then either decode it using this lib or, if your API is a different app, with whatever JWT lib you like.\n. Hey @danr1979 did you get this solved? If you did just close off this issue :smile: \n. Yeah I wasn't exactly thrilled with the implementation either, but it seemed like the quickest way.\n. Yep totally, forgot about that, good call.\n. Basically yeah, it is a copy of what the firebase/php-jwt lib does. I realise it is an increase in complexity, and if you'd rather remove it thats all good. I just figured it wouldn't be a good idea to hardcode the supported RSA algorithms and have to maintain them separately from the original switch statement that was there. Since the different function have very similar variable signatures it's not too bad.\n. Ah yep, nice catch. Have submitted an updated commit now.\n. ",
    "sarahhenkens": "What I'm doing now is, when a user revokes an application's refresh token, I search the tokens store for tokens that have the same client_id and scope condition and expire those. This works for me.\n. @bshaffer Your example works but it does set the response code to unauthorized in the response object. This makes it feel like a very hacky way of doing it. The response object no longer shows the correct state of the application because it should acutally be 200 - OK. The authorization was just optional.\nIn https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/TokenType/Bearer.php#L67 the following code:\n``` php\n        /\n         * If no authentication is provided, set the status code\n         * to 401 and return no other error information\n         \n         * @see http://tools.ietf.org/html/rfc6750#section-3.1\n         /\n        if ($methodsUsed == 0) {\n            $response->setStatusCode(401);\n        return null;\n    }\n\n```\nis setting the return code to 401 if no authorization was found.\n. Ok cool, thanks for the info :)\nOn 18 March 2014 14:51, Brent Shaffer notifications@github.com wrote:\n\nYes this is true, but you can completely disregard that response object...\nyou don't have to send it to the browser or use it in proceeding requests.\nSo, it's not hacky because it's not a global or anything... just ignore it\nand use a new response object for future calls to the $server\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bshaffer/oauth2-server-php/issues/349#issuecomment-37993427\n.\n. Exactly what I'm looking for, an easy way to see, \"Is a request token passed yes or no?\" in the case of yes, I then would manually call the getRequestTokenData method to validate it.\n. Awesome, this works great.\n. @bshaffer @phindmarsh\n\nI finally got around to implement this and the solution mentioned only works if I manually pass an instance of OAuth2\\TokenType\\Bearer to the Server constructor. Otherwise Server::getTokenType() always returns null because the tokenType hasn't been set since it gets lazy loaded.\n. ",
    "discipolo": "I am also getting openssl_sign(): supplied key param cannot be coerced into a private key.\nStill trying to find out how to configure which key and certificate to use\n. quite possibly ... maybe only show it on error_level = all or display_errors=true and mention that in the exception then? but even then, i guess everything can be exploited\n. ",
    "daedeloth": "Did anyone manage to get this working?\nSome documentation or demo code would be greatly appreciated :)\n. I think I've managed to get it working, but I'm really unsure if everything is implemented properly. I also have a very limited knowledge of what's happening, right now it looks like I've just implemented a basic oauth2 service with a user endpoint :/ But my openid client seems to be able to process the damn thing, so I guess it's fine.\nI'll take a closer look at it after launch date :)\n. I have indeed created the private & public keys and stored those in the database table \"oauth2_public_keys\". client_id is your oauth2 client id.\nMy implementation is available here: https://github.com/CatLabInteractive/oauth2\nAlthough I don't think it will be very useful since it's very much integrated in my framework.\n. ",
    "belerophon": "Regarding the openssl_sign:\n- I think you have to create a RSA key-pair for it to go away. the RSA key-pair is associated with the client application. Something like the following:\n```\n  $config = array(\n      \"digest_alg\" => 'sha512',\n      \"private_key_bits\" => 2048,\n      \"private_key_type\" => OPENSSL_KEYTYPE_RSA,\n  );\n// Create the private and public key\n  $res = openssl_pkey_new($config);\n// Extract the private key from $res to $privKey\n  $privKey = null;\n  openssl_pkey_export($res, $privKey);\n// Extract the public key from $res to $pubKey\n  $pubKey = openssl_pkey_get_details($res);\n  $pubKey = $pubKey[\"key\"];\n// insert the RSA key pair into the public key table\n  // https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php#L526\n  $this->insert('{{%oauth_public_key}}', [\n      'client_id' => 'YOU_CLIENT_APP_ID',\n      'public_key' => $pubKey,\n      'private_key' => $privKey,\n      'encryption_algorithm' => 'RS512',\n  ]);\n  ```\nIt is possible to use other types of keys...\nFrom my very, very limited knowledge, this is necessary when creating JWT tokens.\n What I still don't quite understand is why it is required when asking for openid scope, if no JWT token is given afterwards....\nIf someone can explain this better to me, I'd appreciate it also!! :)\nThanks!\n. Can you share your overall configuration of the server, and the steps you've taken to make it work (e.g., did you create the key pair I've mentioned) ?\nI am implementing this too, the server and clients, so I'd like to compare things...\n. I don't quite understand how can the id_token be optional. From what I read here:\n- http://openid.net/specs/openid-connect-implicit-1_0.html\nThe id_token seems to be required.\nAm I missing something?\n. I must admit that I have little knowledge on these matters. \nThat said, it seems that I was confused by section 2.1.5.1 where id_token appears as REQUIRED. However, section 2.1.2 above shows the response_type parameter... I did not see that before....\nI was calling the authorize controller without response_type=id_token... \nClearly, I have to study a little more OpenId and oAuth flows because I still don't understand the purpose of the id_token... :S\nHey, thanks anyway!\n. Let me take this chance to further understand this:\n- why do I need an encrypted piece of data -- the id_token -- if when I proceed with the flow, I acquire an access token that can be used to call the userInfo endpoint and have access user details. This endpoint does not reply with encrypted data.\nThanks again!\n. ",
    "tnguyen444": "I was going to use scopes to limit resources that are accessible on my server (api).  However, the api needs to return roles that a user belongs to so that the client (CMS) can use it's permission system to do this.  What's the best way to do this?  When we return the token, can we return the roles that are associated to a user or is the outside the proper use of OAuth?   Or should I use the getUserDetails method to do this via a separate api call?\n. Going back to using scopes to limit what can be accessed from my api, is there any way to set this for a token in the oauth_access_tokens.scope column?  I want to, whenever a user is authenticated via the password grant_type, and a token is create, to retrieve their roles in the database, and set their scope based on this, in this column.  Is this possible and is then even what this column is intended to be used for or is using the getUserDetails method the best way?\nFootnote: As, I examine the code, it seems as though the column is to be designated for the token request's scope, not the user scope.  Am I right?\n. ",
    "hkdobrev": "@bshaffer \n\nthere is not a lot of support in the library currently for user scopes\nit's becoming clear there is more we can do in the library itself\n\nIs there anything new on this topic?\n\nI am using the UserCredentials GrantType and I am going to use what @tnguyen444 and @bshaffer have last suggested for now.\nI think some basic implementation should be included at least in the demo app. And if it comes out be good and useful it could be moved to the library in some form.\n. @Franckrst You should save the refresh token on the client with the access token. When the access token expires you could request a new one with the refresh token.\nRead more about it here: http://bshaffer.github.io/oauth2-server-php-docs/grant-types/refresh-token/\n. @Franckrst Oh, you should not use client credentials with this use case.\nClient credentials should be used when for example you have another trusted server or trusted device to access the OAuth server.\nYou should use either Authorization Code or User Credentials grant type even disregarding the refresh token issue.\n. ",
    "jackdpeterson": "Started working on implementing observer pattern in server.php. Curious what your thoughts are.\nhttps://github.com/jackdpeterson/oauth2-server-php/blob/356/src/OAuth2/Server.php\nSample where I'm implementing the observable eventing to push events to Syslog.\nhttps://gist.github.com/jackdpeterson/f2e339836b7f88007040\n. I think I'll actually implement this functionality inside of the ZF/oauth2 repository becuase that actually contains the more granular domain-specific information that my use-case requires (mapping the specific user-id and so forth to the request). It's a little closer to the framework as well.\n. ",
    "whvandervelde": "Why not add checkScope to the Oauth2\\Storage\\ScopeInterface? (and modify the ScopeClass to call it through the storage same as scopeExists)\nThat way you don't have to extend Scope and can rely on the interface definitions.\nVerifying scope can still be done the same\nif (!App::$server->verifyResourceRequest($oAuthRequest, $response, $requiredScope)) {\n   $response->send();\n   die;\n}\nbut because you have control over what you pass in as $requiredScope and now also implement checkScope() you could do something like:\n```\npublic function checkScope($required_scope, $available_scope)\n{\n   $available_scope = explode(' ', trim($available_scope));\nif (is_array($required_scope)) {\n     return (count(array_intersect($required_scope, $available_scope)) > 0);\n   } else {\n    $required_scope = explode(' ', trim($required_scope)); \n    return (count(array_diff($required_scope, $available_scope)) == 0);\n   }\n}\n```\nSo it will treat $requiredScope passed as an array like ['scope1', 'scope2'] as OR and also keep the regular AND for $scope passed as a string. Should be easy to change for any other required logic.\nSmall additions: \n- you would have to make sure $required_scope is translated to a string properly to be compatible with default ResourceController. This sets a scope parameters for requests with incorrect scope in the WWW-Authenticate response header.\n- Proposed moving checkScope is simple but does break current ScopeInterface (important for existing implementations).\n- Maybe best is just to implement the ResourceControllerInterface and implement verifyResourceRequest as well when doing this?\n. ",
    "jakajancar": "By default handling I mean the , $default = null parameter.\nMy point is: every extra method/parameter you add to the interface for your convenience is an inconvenience to the implementer of the interface.\nserver() is practically unimplementable. What does it even mean?\n. ",
    "clubery": "@svycka @bshaffer when will #795 be released?. Hi @Herz3h , I also had this problem and found that scopes did not provide the level of granularity I needed. Since I am using doctrine2 as my DBAL, Instead I ended up implementing separate ACL functionality using https://github.com/myclabs/ACL. I then use my own custom mapping to tie user scopes to individual ACLs. I hope this helps. . @Herz3h It doesn't integrate, you have to do it yourself. What I did was create a hash containing my scopes that map to the names of specific ACLs in my application. Upon successful authorization I then retrieve the users scopes and it gives me a set of ACLs that user has access to, from then on for the lifetime of the request, I never check the user scopes and refer to the ACLs for permission checks.\nI happen to be doing this in an API where I expose the given ACLs to the user after authentication. This allows me to then utilise this control on the front end and since I am using angular, i modify the data structure from my API and pass them directly into angular-permission https://github.com/Narzerus/angular-permission which then allows me to show different elements of the page based on the users permission.\nThis is not simple and took me about a week to implement.. > So from what i understand any user can authenticate, and its only after retrieving its scopes in the resource server that you tell wether he can access a specific resource by using Scope <-> ACL hash, right ?\nAlmost correct, the scopes won't come from the resource server, they will come from the oauth server when you issue the access token.\n\nWhat i need is to check permission in the authorization server, so that only a user who has same scope as client scope (understand here: right to use a client) can get a token....but then this probably doesn't conform to oauth2 scopes way of working i guess..\n\nThe oauth server should only allow requested scopes that are associated with the client anyway, that behaviour comes out of the box\n. So I would expect here that the actual clientA has been configured to allow scope A and also has the 'password' grant_type configured.\nI did this in the table that holds my oauth client data. I haven't done anything special to get this to work. I have a separate class in my application that implements some of the required interfaces I need to get the oauth server to work. It also has code in there to deal with my own API which you can ignore but here it is: \n```\n<?php\nnamespace MMMusic;\nuse Exception;\nuse DateTime;\nuse DateInterval;\nuse Utils;\nuse Store;\nuse OAuthAccessToken;\nuse OAuthRefreshToken;\nuse OAuthClient;\nuse User as OAuthUser;\nuse OAuthScope;\nuse OAuthAuthorizationCode;\nuse OAuthClientKeys as KeyPair;\nuse OAuth2\\Storage\\AccessTokenInterface;\nuse OAuth2\\Storage\\ClientCredentialsInterface;\nuse OAuth2\\Storage\\UserCredentialsInterface;\nuse OAuth2\\Storage\\PublicKeyInterface;\nuse OAuth2\\Storage\\RefreshTokenInterface;\nuse OAuth2\\OpenID\\Storage\\UserClaimsInterface;\nuse OAuth2\\OpenID\\Storage\\AuthorizationCodeInterface;\nuse OAuth2\\ScopeInterface;\nuse OAuth2\\RequestInterface;\nuse OAuth2\\HttpFoundationBridge\\Request as BridgeRequest;\nuse Exceptions\\AccountBlockedException;\nuse Exceptions\\AccountNotVerifiedException;\nclass OAuth implements\n    AccessTokenInterface,\n    ClientCredentialsInterface,\n    AuthorizationCodeInterface,\n    UserCredentialsInterface,\n    PublicKeyInterface,\n    ScopeInterface,\n    RefreshTokenInterface,\n    UserClaimsInterface\n{\n    private $store;\n    private $log;\n    private $oauth_user;\npublic function setLogger($logger) {\n    $this->log = $logger;\n}\n\npublic function getLogger() {\n    return $this->log;\n}\n\n/**\n * The default scope to use in the event the client\n * does not request one. By returning \"false\", a\n * request_error is returned by the server to force a\n * scope request by the client. By returning \"null\",\n * opt out of requiring scopes\n *\n * @param $client_id\n * An optional client id that can be used to return customized default scopes.\n *\n * @return\n * string representation of default scope, null if\n * scopes are not defined, or false to force scope\n * request by the client\n *\n * ex:\n *     'default'\n * ex:\n *     null\n */\npublic function getDefaultScope($client_id = null) {\n    $scopes = $this->store()->entityManager()->getRepository('OAuthScope')->findBy(['isDefault' => 1]);\n    $_default_scopes = array_map(function($scope) {\n        return $scope->getScope();\n    }, $scopes);\n\n    $default_scope = implode(' ', $_default_scopes);\n    return $default_scope;\n}\n\n/**\n * Check if the provided scope exists.\n *\n * @param $scope\n * A space-separated string of scopes.\n *\n * @return\n * TRUE if it exists, FALSE otherwise.\n */\npublic function scopeExists($scope) {\n    $scopecheck = explode(' ', $scope);\n    $qb = $this->store()->entityManager()->createQueryBuilder();\n    $query = $qb->select($qb->expr()->count('s.scope'))\n                ->from('OAuthScope', 's')\n                ->andWhere('s.scope IN (:scopecheck)')\n                ->setParameter('scopecheck', $scopecheck);\n\n    $count = $query->getQuery()->getSingleScalarResult();\n\n    return ($count == count($scopecheck));\n}\n\n/**\n * Check if everything in required scope is contained in available scope.\n *\n * @param $required_scope\n * A space-separated string of scopes.\n *\n * @return\n * TRUE if everything in required scope is contained in available scope,\n * and FALSE if it isn't.\n *\n * @see http://tools.ietf.org/html/rfc6749#section-7\n *\n * @ingroup oauth2_section_7\n */\npublic function checkScope($required_scope, $available_scope) {\n    $_required_scopes = explode(\" \", $required_scope);\n    $_allowed_scopes = explode(\" \", $available_scope);\n\n    foreach($_required_scopes as $r_scope) {\n        if(!in_array($r_scope, $_allowed_scopes))\n            return false;\n    }\n\n    return true;\n}\n\n/**\n * Return scope info from request\n *\n * @param OAuth2\\RequestInterface\n * Request object to check\n *\n * @return\n * string representation of requested scope\n */\npublic function getScopeFromRequest(RequestInterface $req) {\n    return $req->query->get('scope')?: ( $req->request->get('scope')?: null );\n}\n\npublic function __construct(Store $_store, $logger = null) {\n    $this->setLogger($logger);\n    $this->store($_store);\n}\n\nprivate function store($store = null) {\n    if($store)\n        $this->store = $store;\n\n    return $this->store;\n}\n\n/// CLIENT STUFF\npublic function registerClient(\n    $user_id,\n    $email,\n    $password,\n    $redirect_uri,\n    $description,\n    $client_name,\n    $client_id,\n    $client_secret,\n    $grant_types = NULL,\n    $scope,\n    $autoflush = true\n) {\n\n    if($scope && (!$this->scopeExists($scope)))\n        throw new Exception(\"Client registration with invalid scope: $scope\");\n\n    $_OAuthClient = $this->_getClient($client_id);\n\n    if($_OAuthClient)\n        throw new Exception(\"OAuth Client with id '$client_id' already exists\");\n\n    // this will throw an exception if it fails\n    // we need a way of marking this user as the admin user\n    $_OAuthUser = $this->createUser($user_id, $email, $password, null, null, $scope, false);\n\n    $_OAuthClient = new OAuthClient();\n    $_OAuthClient->setClientName($client_name);\n    $_OAuthClient->setClientId($client_id);\n    $_OAuthClient->setClientSecret($client_secret);\n    $_OAuthClient->setRedirectUri($redirect_uri);\n    $_OAuthClient->setDescription($description);\n\n    if($scope)\n        $_OAuthClient->setScope($scope);\n\n    if($grant_types)\n        $_OAuthClient->setGrantTypes($grant_types);\n\n    // associate new user with this client\n    $_OAuthUser->addClient($_OAuthClient);\n\n    $this->store()->entityManager()->persist($_OAuthClient);\n    $this->store()->entityManager()->persist($_OAuthUser);\n\n    if($autoflush)\n        $this->store()->entityManager()->flush();\n\n    return $_OAuthClient;\n}\n\npublic function checkClientCredentials($client_id, $client_secret = NULL) {\n    $_OAuthClient = $this->_getClient($client_id);\n    return ($_OAuthClient && $_OAuthClient->getClientSecret() == $client_secret);\n}\n\npublic function checkRestrictedGrantType($client_id, $grant_type) {\n    $_OAuthClient = $this->_getClient($client_id);\n\n    if(!$_OAuthClient)\n        return false;\n\n    $_grant_types = $_OAuthClient->getGrantTypes();\n\n    if(isset($_grant_types)) {\n        $grant_types = explode(' ', $_grant_types);\n        return in_array($grant_type, (array) $grant_types);\n    }\n\n    // if grant_types are not defined, then none are restricted\n    return true;\n}\n\npublic function getClientDetails($client_id, $all = false) {\n    $_OAuthClient = $this->_getClient($client_id);\n\n    if(!$_OAuthClient)\n        return NULL;\n\n    // use\n\n    // this ALL needs to change to use the user client association\n    // but what user are you getting this user info for?\n    // should we be going for the default user in the user client association?\n    // or can we get away with not passing back the specific user details at all\n    // and then change all calls to this method to rely on getting user details\n    // from the user object, this is the preferred method\n    $client_details = [\n        'app_name'     => $_OAuthClient->getName(),\n        'redirect_uri' => $_OAuthClient->getRedirectUri(),\n        'client_id'    => $_OAuthClient->getClientId(),\n        'grant_types'  => $_OAuthClient->getGrantTypes(),\n        'user_id'      => $_OAuthClient->getUserId(), // this should always be null since we aint using it no mo\n        'scope'        => $_OAuthClient->getScope(),\n        'description'  => $_OAuthClient->getDescription()\n    ];\n\n    if($all) {\n        $client_details['client_secret'] = $_OAuthClient->getClientSecret();\n        $client_details['email']         = $_OAuthClient->getEmail();\n        $client_details['password']      = $_OAuthClient->getPassword();\n    }\n\n    return $client_details;\n}\n\npublic function updateAppSettings(OAuthClient $client, $app_settings) {\n    if(isset($app_settings['app_name']))\n        $client->setName($app_settings['app_name']);\n\n    if(isset($app_settings['redirect_uri']))\n        $client->setRedirectUri($app_settings['redirect_uri']);\n\n    if(isset($app_settings['description']))\n        $client->setDescription($app_settings['description']);\n\n//        throw new Exception(\"shitter - \" . $app_settings['redirect_uri']);\n    $this->store()->entityManager()->persist($client);\n    $this->store()->entityManager()->flush();\n}\n\npublic function updateLastLogin($username) {\n    $user = $this->getUserByUsername($username);\n\nif(!$user)\n        throw new Exception(\"Could not load user '$username' by username\");\n\n$user->setDateTimeLastLogin(new DateTime());\n\n    $this->store()->entityManager()->persist($user);\n    $this->store()->entityManager()->flush();\n}\n\npublic function getUserByUsername($username) {\n    //fwrite (STDERR, \"getting xxxuserdetails for $username \\n\");\n    return $this->store()->entityManager()->getRepository('User')->findOneBy(['username' => $username]);\n}\n\npublic function getUserByEmail($email) {\n    return $this->store()->entityManager()->getRepository('User')->findOneBy(['email' => $email]);\n}\n\npublic function createUser($username, $email, $password, $first_name = null, $last_name = null, $scope = null, $autoflush = true) {\n    $qb = $this->store()->entityManager()->getRepository('User')->createQueryBuilder('u');\n    $qb->select('u')\n       ->where($qb->expr()->orX(\n           $qb->expr()->eq('u.username', ':username'),\n           $qb->expr()->eq('u.email', ':email')\n       ))\n       ->setParameter('username', $username)\n       ->setParameter('email', $email);\n\n    $query = $qb->getQuery();\n    $existing_user = $query->getResult();\n\n    if($existing_user)\n        throw new Exception(\"User with username:$username or email:$email already exists\");\n\n    $_OAuthUser = new OAuthUser();\n\n    $_OAuthUser->setUsername($username);\n    $_OAuthUser->setEmail($email);\n    $_OAuthUser->setPassword($password, false, true);\n    $_OAuthUser->setFirstName($first_name);\n    $_OAuthUser->setLastName($last_name);\n    $_OAuthUser->setScope($scope);\n    $_OAuthUser->setIsVerified(false);\n    $_OAuthUser->setCreated(new DateTime());\n\n    $this->store()->entityManager()->persist($_OAuthUser);\n\n    if($autoflush)\n        $this->store()->entityManager()->flush();\n\n    return $_OAuthUser;\n}\n\nprivate function _getClient($client_id) {\n    return $this->store()->entityManager()->find('OAuthClient', $client_id);\n}\n\npublic function isPublicClient($client_id) {\n    $_OAuthClient = $this->_getClient($client_id);\n\n    // return false as the client with this id doesn't exist\n    if(! $_OAuthClient)\n        return false;\n\n    return empty($_OAuthClient->getClientSecret());\n}\n\npublic function getClientScope($client_id) {\n    $_OAuthClient = $this->_getClient($client_id);\n\n    // return false as the client with this id doesn't exist\n    if(! $_OAuthClient)\n        return false;\n\n    $scope = $_OAuthClient->getScope();\n\n    if(isset($scope))\n        return $scope;\n\n    return null;\n}\n\n// ACCESS TOKEN STUFF\npublic function _getAccessToken($auth_token, $user = null) {\n    //return $this->store()->entityManager()->getRepository('OAuthAccessToken')->findOneBy(['accessToken' => $auth_token]);\n\n    if(!$user) {\n        return $this->store()\n                    ->entityManager()\n                    ->createQuery('SELECT t FROM OAuthAccessToken t WHERE t.accessToken = :access_token AND t.revoked IS NULL')\n                    ->setParameter('access_token', $auth_token)\n                    ->getOneOrNullResult();\n    }\n    else {\n        return $this->store()\n                    ->entityManager()\n                    ->createQuery('SELECT t FROM OAuthAccessToken t WHERE t.accessToken = :access_token AND t.userId = :username AND t.revoked IS NULL')\n                    ->setParameter('access_token', $auth_token)\n                    ->setParameter('username', $user)\n                    ->getOneOrNullResult();\n    }\n}\n// ACCESS TOKEN STUFF\npublic function _getUserAccessTokens($user) {\n    return $this->store()\n                ->entityManager()\n                ->createQuery('SELECT t FROM OAuthAccessToken t WHERE t.userId = :username AND t.revoked IS NULL')\n                ->setParameter('username', $user)\n\n//                    ->getQuery()\n                    ->getResult();\n    }\npublic function getAccessToken($auth_token) {\n    $_OAuthAccessToken = $this->_getAccessToken($auth_token);\n\n    if(! $_OAuthAccessToken)\n        return NULL;\n\n    return [\n        'client_id' => $_OAuthAccessToken->getClientId(),\n        'user_id'   => $_OAuthAccessToken->getuserId(),\n        'expires'   => $_OAuthAccessToken->getExpires()->getTimestamp(), //DateTime object\n        'scope'     => $_OAuthAccessToken->getScope(),\n    ];\n}\n\npublic function setAccessToken($oauth_token, $client_id, $user_id, $expires, $scope = NULL) {\n    $oAuthClient = $this->_getClient($client_id);\n\n    if(!$oAuthClient)\n        throw new Exception(\"Invalid client_id: $client_id\");\n\n\n    $_OAuthAccessToken = $this->_getAccessToken($oauth_token, $user_id);\n   if(!$_OAuthAccessToken) {\n\n       $_OAuthAccessToken = new OAuthAccessToken();\n       $_OAuthAccessToken->setAccessToken($oauth_token);\n   }\n   //throw new Exception(\"setting access token for $user_id\");\n   $this->log->addInfo(\"Setting access token for user: $user_id\");\n   $expires_datetime = new DateTime();\n   $expires_datetime->setTimestamp($expires);\n\n   $realtime = time();\n   $realtime_datetime = new DateTime();\n   $realtime_datetime->setTimestamp($realtime);\n\n   $_OAuthAccessToken->setClient($oAuthClient);\n   $_OAuthAccessToken->setUserId($user_id);\n   $_OAuthAccessToken->setScope($scope);\n   $_OAuthAccessToken->setExpires($expires_datetime);\n\n   $this->store()->entityManager()->persist($_OAuthAccessToken);\n   $this->store()->entityManager()->flush();\n}\n\npublic function expireAccessToken($oauth_token) {\n    $_OAuthAccessToken = $this->_getAccessToken($oauth_token);\n\n    if($_OAuthAccessToken) {\n        $_OAuthAccessToken->setExpires((new Datetime(\"now\"))->sub(new DateInterval(\"P1D\")));\n        $this->store()->entityManager()->persist($_OAuthAccessToken);\n        $this->store()->entityManager()->flush();\n    }\n}\n\nprivate function _revokeAccessToken(OAuthAccessToken $accessToken) {\n    $accessToken->setExpires((new Datetime(\"now\"))->sub(new DateInterval(\"P1D\")));\n    $accessToken->setRevoked(new Datetime(\"now\"));\n    $this->store()->entityManager()->persist($accessToken);\n    return true;\n}\n\npublic function revokeAccessToken($oauth_token, $user) {\n    $_OAuthAccessToken = $this->_getAccessToken($oauth_token, $user);\n\n    if(!$_OAuthAccessToken)\n        return false;\n\n    $this->_revokeAccessToken($_OAuthAccessToken);\n    $this->store()->entityManager()->flush();\n\n    return true;\n}\n\npublic function revokeAllUserAccessTokens($user) {\n    $userAccessTokens = $this->_getUserAccessTokens($user);\n    foreach($userAccessTokens AS $accessToken) {\n        $this->_revokeAccessToken($accessToken);\n    }\n    $this->store()->entityManager()->flush();\n    return true;\n}\n\n// AUTHORIZATION CODE STUFF\n\nprivate function _getAuthorizationCode($code) {\n    return $this->store()->entityManager()->find('OAuthAuthorizationCode', $code);\n}\n\npublic function getAuthorizationCode($code) {\n    $_OAuthAuthorizationCode = $this->_getAuthorizationCode($code);\n\n    if(! $_OAuthAuthorizationCode)\n        return NULL;\n\n    return [\n        'client_id'    => $_OAuthAuthorizationCode->getClientId(),\n        'user_id'      => $_OAuthAuthorizationCode->getUserId(),\n        'expires'      => $_OAuthAuthorizationCode->getExpires()->getTimestamp(),\n        'redirect_uri' => $_OAuthAuthorizationCode->getRedirectUri(),\n        'scope'        => $_OAuthAuthorizationCode->getScope()\n    ];\n}\n\npublic function setAuthorizationCode($code, $client_id, $user_id, $redirect_uri, $expires, $scope = NULL, $id_token = null) {\n    $client = $this->_getClient($client_id);\n\n    if(!$client)\n        throw new Exception(\"Invalid client_id: $client_id\");\n\n    $_OAuthAuthorizationCode = $this->_getAuthorizationCode($code);\n\n    if(!$_OAuthAuthorizationCode) {\n        $_OAuthAuthorizationCode = new OAuthAuthorizationCode();\n        $_OAuthAuthorizationCode->setAuthorizationCode($code);\n    }\n\n    $_OAuthAuthorizationCode->setClientId($client_id);\n    $_OAuthAuthorizationCode->setUserId($user_id);\n    $_OAuthAuthorizationCode->setRedirectUri($redirect_uri);\n    $_OAuthAuthorizationCode->setScope($scope);\n\n    $expires_datetime = new DateTime();\n    $expires_datetime->setTimestamp($expires);\n    $_OAuthAuthorizationCode->setExpires($expires_datetime);\n\n    $this->store()->entityManager()->persist($_OAuthAuthorizationCode);\n    $this->store()->entityManager()->flush();\n}\n\npublic function expireAuthorizationCode($code) {\n    $_OAuthAuthorizationCode = $this->_getAuthorizationCode($code);\n\n    if($_OAuthAuthorizationCode) {\n        $this->store()->entityManager()->remove($_OAuthAuthorizationCode);\n        $this->store()->entityManager()->flush();\n    }\n}\n\npublic function checkUserCredentials($username, $password, $is_cryptedpassword = false) {\n\n    if(filter_var($username, FILTER_VALIDATE_EMAIL)) {\n        $this->oauth_user = $this->getUserByEmail($username);\n        if(!$this->oauth_user)\n            return false;\n        $username = $this->oauth_user->getUsername();\n    }\n\n    $this->log->addInfo(\"Checking user credentials for '$username' password crypted: \" . ($is_cryptedpassword?'yes':'no'));\n\n    $crypted_password = $is_cryptedpassword ? $password : hash('sha256', $password );\n\n    $this->log->addInfo(\"Encrypted password $is_cryptedpassword: \" . $crypted_password);\n\n    $valid_credentials = $this->store()\n                              ->entityManager()\n                              ->getRepository('User')\n                              ->findOneBy([\n                                  'username' => $username,\n                                  'password' => $crypted_password\n                              ]);\n\n    if($valid_credentials) {\n        $this->log->addInfo(\"Supplied account credentials for '$username' are valid!\");\n    } else {\n        $this->log->addInfo(\"Supplied account credentials for '$username' were invalid! login failure.\");\n    }\n\n    if($valid_credentials && $valid_credentials->getIsBlocked()) {\n        $this->log->addWarning(\"Account for '$username' is blocked!\");\n        throw new AccountBlockedException(\"account is blocked\");\n    }\n\n    if($valid_credentials && (!$valid_credentials->getIsVerified())) {\n        $this->log->addWarning(\"Account for '$username' is not verified!\");\n        throw new AccountNotVerifiedException(\"account not verified\");\n    }\n\n    return (bool)$valid_credentials;\n}\n\npublic function getUserDetails($username) {\n\n    $this->log->addInfo(\"Getting userdetails for: $username\");\n\n    $oauth_user = filter_var($username, FILTER_VALIDATE_EMAIL) ?\n                $this->oauth_user = $this->getUserByEmail($username) :\n                $this->getUserByUsername($username);\n\n    if(!$oauth_user)\n        return NULL;\n\n    return [\n        'user_id' => $oauth_user->getUsername(),\n        'scope' => $oauth_user->getScope(),\n    ];\n}\n\npublic function setClientKeys(OAuthClient $client, $private_key, $public_key, $algorithm) {\n    $keypair = new KeyPair();\n    $keypair->setClientId( $client->getClientId() );\n    $keypair->setEncryptionAlgorithm( $algorithm );\n    $keypair->setPublicKey( $public_key );\n    $keypair->setPrivateKey( $private_key );\n    $this->store()->entityManager()->persist($keypair);\n    $this->store()->entityManager()->flush();\n}\n\nprivate function _getClientKeys($client_id) {\n    return $this->store()->entityManager()->find('OAuthClientKeys', $client_id);\n}\n\npublic function getPublicKey($client_id = null) {\n    $_OAuthClientKeys = $this->_getClientKeys($client_id);\n    if(!$_OAuthClientKeys)\n        return NULL;\n\n    return $_OAuthClientKeys->getPublicKey();\n}\n\npublic function getPrivateKey($client_id = null) {\n    $_OAuthClientKeys = $this->_getClientKeys($client_id);\n    if(!$_OAuthClientKeys)\n        return NULL;\n\n    return $_OAuthClientKeys->getPrivateKey();\n}\n\npublic function getEncryptionAlgorithm($client_id = null) {\n    $_OAuthClientKeys = $this->_getClientKeys($client_id);\n    if(!$_OAuthClientKeys)\n        return NULL;\n\n    return $_OAuthClientKeys->getEncryptionAlgorithm();\n}\n\npublic function getUserClientSettings(OAuthUser $user) {\n    $app_settings = [];\n    $user_clients_collection = $user->getClients();\n\n    foreach($user_clients_collection AS $client) {\n        $app_settings[ $client->getClientId() ] = [\n            'app_name' => $client->getName(),\n            'redirect_uri' => $client->getRedirectUri(),\n            'description'  => $client->getDescription(),\n            'grant_types' => $client->getGrantTypes(),\n            'scope' => $client->getScope()\n        ];\n    }\n    return $app_settings;\n}\n\npublic function getPendingClientSecret(OAuthClient $client) {\n    // use the criteria to get this out the client object, this is just a lazy shortcut\n}\n\npublic function addPendingClientSecret(OAuthClient $client, $new_client_secret) {\n    // use the collection on the client and store it, lazy shortcut\n    return true;\n}\n\npublic function activatePendingClientSecret(OAuthPendingClientSecret $pendingClientSecret) {\n    // activate then...\n    $this->purgePendingClientSecrets($pendingClientSecret->getClient());\n    return true;\n}\n\npublic function purgePendingClientSecrets(OAuthClient $client) {\n    // use the criteria to purge the clients\n    return true;\n}\n\n/**\n * Grant refresh access tokens.\n *\n * Retrieve the stored data for the given refresh token.\n *\n * Required for OAuth2::GRANT_TYPE_REFRESH_TOKEN.\n *\n * @param $refresh_token\n * Refresh token to be check with.\n *\n * @return\n * An associative array as below, and NULL if the refresh_token is\n * invalid:\n * - refresh_token: Refresh token identifier.\n * - client_id: Client identifier.\n * - user_id: User identifier.\n * - expires: Expiration unix timestamp, or 0 if the token doesn't expire.\n * - scope: (optional) Scope values in space-separated string.\n *\n * @see http://tools.ietf.org/html/rfc6749#section-6\n *\n * @ingroup oauth2_section_6\n */\n\npublic function getRefreshToken($refresh_token) {\n    $_OAuthRefreshToken = $this->_getRefreshToken($refresh_token);\n\n    if(!$_OAuthRefreshToken) {\n        return NULL;\n    }\n\n    return [\n        'refresh_token' => $_OAuthRefreshToken->getRefreshToken(),\n        'client_id'     => $_OAuthRefreshToken->getClientId(),\n        'user_id'       => $_OAuthRefreshToken->getUserId(),\n        'expires'       => $_OAuthRefreshToken->getExpires()->getTimestamp(),\n        'scope'         => $_OAuthRefreshToken->getScope(),\n    ];\n}\n\n/**\n * Take the provided refresh token values and store them somewhere.\n *\n * This function should be the storage counterpart to getRefreshToken().\n *\n * If storage fails for some reason, we're not currently checking for\n * any sort of success/failure, so you should bail out of the script\n * and provide a descriptive fail message.\n *\n * Required for OAuth2::GRANT_TYPE_REFRESH_TOKEN.\n *\n * @param $refresh_token\n * Refresh token to be stored.\n * @param $client_id\n * Client identifier to be stored.\n * @param $user_id\n * User identifier to be stored.\n * @param $expires\n * Expiration timestamp to be stored. 0 if the token doesn't expire.\n * @param $scope\n * (optional) Scopes to be stored in space-separated string.\n *\n * @ingroup oauth2_section_6\n */\n\npublic function setRefreshToken($refresh_token, $client_id, $user_id, $expires, $scope = null) {\n    $oAuthClient = $this->_getClient($client_id);\n\n    if(!$oAuthClient)\n        throw new Exception(\"Invalid client_id: $client_id\");\n\n   $_OAuthRefreshToken = new OAuthRefreshToken();\n   $_OAuthRefreshToken->setRefreshToken($refresh_token);\n\n   $expires_datetime = new DateTime();\n   $expires_datetime->setTimestamp($expires);\n\n   $_OAuthRefreshToken->setClient($oAuthClient);\n   $_OAuthRefreshToken->setUserId($user_id);\n   $_OAuthRefreshToken->setScope($scope);\n   $_OAuthRefreshToken->setExpires($expires_datetime);\n\n   $this->store()->entityManager()->persist($_OAuthRefreshToken);\n   $this->store()->entityManager()->flush();\n}\n\n/**\n * Expire a used refresh token.\n *\n * This is not explicitly required in the spec, but is almost implied.\n * After granting a new refresh token, the old one is no longer useful and\n * so should be forcibly expired in the data store so it can't be used again.\n *\n * If storage fails for some reason, we're not currently checking for\n * any sort of success/failure, so you should bail out of the script\n * and provide a descriptive fail message.\n *\n * @param $refresh_token\n * Refresh token to be expirse.\n *\n * @ingroup oauth2_section_6\n */\npublic function unsetRefreshToken($refresh_token) {\n    $_OAuthRefreshToken = $this->_getRefreshToken($refresh_token);\n\n    if($_OAuthRefreshToken) {\n        $this->store()->entityManager()->remove($_OAuthRefreshToken);\n        $this->store()->entityManager()->flush();\n    }\n}\npublic function _getRefreshToken($refresh_token) {\n    return $this->store()\n        ->entityManager()\n        ->createQuery('SELECT t FROM OAuthRefreshToken t WHERE t.refreshToken = :refresh_token')\n        ->setParameter('refresh_token', $refresh_token)\n        ->getOneOrNullResult();\n}\n\npublic function getUserClaims($userId, $scope) {\n    throw new \\Exception(\"getUserClaims: $userId - $scope\");\n}\n\n}\n```\n. Another significant thing I did was to separate the users table from the oauth_client table. This class helps me handle this. ",
    "BVMiko": "@svycka I believe that you may be confusing the JWT header from the JWT payload.  #795 made it easier to modify the payload; however the JWT header is generated later during the encodeToken phase.. I also want to reference to issue #363; though this PR doesn't offer a way to modify the JWT header with arbitrary data; it does automatically provide the kid parameter; which I think may solve the issue for most.. ",
    "morvans": "As a side comment, note that Soundcloud implements this on their main front-end site : access token delivered to the JS application running in the browser receive a never expiring access_token. And as their own site is built upon their public API, every developer can request the same (by requesting a specific scope). Not sure if they're shooting themselves in their feet here.\n. ",
    "ssanders": "We get this too, but I\u2019m told that query strings in redirect_uri are not allowed per Oauth spec?\nAnd where do you set require_exact_redirect_uri?\n. Can you provide a code example please for require_exact_redirect_uri? I don't seem to be doing it right. Thanks!\n. Workaround in token controller:\nphp\nmysql_query(\"USE oauth\");\nmysql_query(\"SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ\");\nmysql_query(\"UPDATE oauth_authorization_codes SET redirect_uri = '\" . $_POST['redirect_uri'] . \"' WHERE authorization_code = '\" . $_POST['code'] . \"'\");\n. php\n$server->setConfig('access_lifetime', 1234567890);\n. We have added fields to various oauth tables with no problems.\n. We get this now, too. Should we delete old refresh tokens?. We deleted over 90% of our refresh tokens (they were all expired) \u2014 but this error persists\u2026?. nothing to add but bump. I agree. Our server sets client_id to username and client_secret to password to get around this.\n. We did this to accommodate some users and ended up just putting this at the top of our server.php:\n``` php\nif ($_GET) {\n$_POST = $_GET;\n$_GET  = array();\n\n$_SERVER['CONTENT_TYPE']   = 'application/x-www-form-urlencoded';\n$_SERVER['REQUEST_METHOD'] = 'POST';\n\n}\nif ($HTTP_RAW_POST_DATA) {\n$post = explode('&', $HTTP_RAW_POST_DATA);\n\nforeach ($post as $k => $v) {\n\n    $parts = explode('=', $v);\n\n    $_POST[$parts[0]] = $parts[1];\n}\n\n$HTTP_RAW_POST_DATA = '';\n\n$_SERVER['CONTENT_TYPE']   = 'application/x-www-form-urlencoded';\n$_SERVER['REQUEST_METHOD'] = 'POST';\n\n}\n. This may also relate to Duplicate PRIMARY key in setRefreshToken() when using PDO. #616.php\ndo {$accessToken = $this->generateAccessToken();}\nwhile ($this->tokenStorage->getAccessToken($accessToken));\n$token = array(\n    \"access_token\" => $accessToken, //$this->generateAccessToken(),\nphp\n//$token[\"refresh_token\"] = $this->generateRefreshToken();\ndo {$token[\"refresh_token\"] = $this->generateRefreshToken();}\nwhile ($this->refreshStorage->getRefreshToken($token[\"refresh_token\"]));\n```. ",
    "Zyles": "Yeah basically we front with the same endpoint \"api.server.com\" for everything. When user requests an access token they hit api.server.com/oauth/token for example. A token with expiration is stored in Redis on the Nginx proxy, so when the user then requests api.server.com/service/todolist/list/1 for example, Nginx looks for the access token in Redis so it does not have to query oauth server every single request.\nTrying to grasp this puzzle is where I get lost.\nIf the token exists it will connect to the resource server which hosts the todolist and here somehow we check the scope/permissions to get the users list?\nWhat I am looking for is guidelines on how to secure every resource servers routes and connect that to the correct user. It becomes a little bit unclear to me since we will be using the oauth server library on all 3 servers and what to do where.\nI could be making this more complex in my mind than it should. Maybe I just need to look at the problem as if it was a standalone API server with oauth built in, that just shares a database between all servers?\n. ",
    "ntsagkas": "Hi\nIs there a link that provides more information on the subject?\nE.g. what if a client1 gets authorized to use the API on Backend 1 (grant1) and a malicious user copies the authorization token given to client1 to a client2 that uses the API on Backend 2?\nFurthermore what is the best practice for new backends to \"register\" their scopes in the standalone server?\nAny guidance will be greatly apreciated :) \n. ",
    "abides": "just remove the refresh token grant type;\n$grantType = new OAuth2\\GrantType\\RefreshToken($storage);\n. Actually documentation says;\n$ curl -u TestClient:TestSecret https://api.mysite.com/token -d 'grant_type=password&username=bshaffer&password=brent123'\nSo if you change your code and replace client_credentials with array('grant_type' => 'password') can work better.\n. My opinion : First you check this code with using curl in command line like example in documentation. If it works maybe there is some problem in your php cURL function and it does not send the post parameters.\n. ",
    "brianium": "Awesome. I can definitely update the tests. I removed the require-dev after I saw what was happening in travis. As far as case insensitive headers, I can add some tests to the headers accessor method and try to make it behave in a case insensitive manner. Is this more of what you had in mind? BTW, great work on this. This is an awesome library.\n. @bshaffer - I beefed up readability of tests and added a case insensitive version of Request::headers() using array_change_key_case for the comparison. I squashed down the commits as well. \n. ",
    "arianf": "I tried testing to see if client credentials were set...\ncmd\n$ curl http://mywebsite.com/test/token.php -d 'grant_type=client_credentials'\njson\n{\"error\":\"unsupported_grant_type\",\"error_description\":\"Grant type \\\"client_credentials\\\" not supported\"}\n. Sorry for multiple comments, but when I do getGrantTypes();\nphp\nvar_dump($server->getGrantTypes());\nphp\narray(1) {\n  [0]=>\n  object(OAuth2\\GrantType\\UserCredentials)#4 (2) {\n    [\"userInfo\":\"OAuth2\\GrantType\\UserCredentials\":private]=>\n    NULL\n    [\"storage\":protected]=>\n    object(OAuth2\\Storage\\Memory)#2 (10) {\n      [\"authorizationCodes\"]=>\n      array(0) {\n      }\n      [\"userCredentials\"]=>\n      array(1) {\n        [\"bshaffer\"]=>\n        array(3) {\n          [\"password\"]=>\n          string(8) \"brent123\"\n          [\"first_name\"]=>\n          string(5) \"Brent\"\n          [\"last_name\"]=>\n          string(7) \"Shaffer\"\n        }\n      }\n      [\"clientCredentials\"]=>\n      array(0) {\n      }\n      [\"refreshTokens\"]=>\n      array(0) {\n      }\n      [\"accessTokens\"]=>\n      array(0) {\n      }\n      [\"jwt\"]=>\n      array(0) {\n      }\n      [\"jti\"]=>\n      array(0) {\n      }\n      [\"supportedScopes\"]=>\n      array(0) {\n      }\n      [\"defaultScope\"]=>\n      NULL\n      [\"keys\"]=>\n      array(0) {\n      }\n    }\n  }\n}\n. Oh I was under the impression that you could have a user_credential grantType without having a client_credential grantType, as discussed here: https://github.com/bshaffer/oauth2-server-php/issues/341\nIf I have a public client, do I still need to set ClientCredentials?\nAlso I am unable to open this issue, because I didn't close it.\n. Ohhh, thank you so much for the clarifications! That makes a lot more sense!\n. ",
    "kentpachi": "Hello,\nsorry to post again here but i've tried the code you give but it still doesn't works for me... still getting \"unsupported_grant_type\" for \"user_credentials\".... \nI have an angularjs backoffice and try to implement user_credentials as i am the owner of everything the javascript client side app, the oauth server, and the api which i'm trying to protect.\nI'm using restler \n- I've tried to implement custom storage, but no success always getting unsupported grant_type\n- i've tried the memory storage as you described it above but no success\nhere's my class\n```\nclass OpenAuth2\n{\nprotected static $server;\n\nprotected static $storage;\n\nprotected static $request;\n\npublic function __construct()\n{\n\n    // create some users in memory\n    $users = array(\n        'bshaffer' => array(\n            'password' => 'brent123',\n            'first_name' => 'Brent',\n            'last_name' => 'Shaffer'\n        )\n    );\n\n    // HERE IS THE NEW PART\n    $clients = array(\n        'TestClient' => array(\n            'client_secret' => 'TestSecret'\n        )\n    );\n\n    // create a storage object\n    // ALSO NEW: pass \"client_credentials\" in with the Memory object\n    $storage = new \\OAuth2\\Storage\\Memory(array(\n        'user_credentials' => $users,\n        'client_credentials' => $clients\n    ));\n    // create a storage object\n    $storage = new \\OAuth2\\Storage\\Memory(array(\n        'user_credentials' => $users\n    ));\n\n    // create the grant type\n    $grantType = new \\OAuth2\\GrantType\\UserCredentials($storage);\n\n    // Pass a storage object or array of storage objects to the OAuth2 server class\n    $server = new \\OAuth2\\Server($storage);\n\n    // add the grant type to your OAuth server\n    $server->addGrantType($grantType);\n\n    static::$request = \\OAuth2\\Request::createFromGlobals();\n    static::$server = $server;\n}\n\n/**\n * @url POST token\n *\n *            \n *\n */\npublic function token($grant_type,$client_id,$client_secret,$username,$password)\n{\n    // Handle a request for an OAuth2.0 Access Token and send the response to the client\n    static::$server->handleTokenRequest(static::$request)->send();\n}\n\n```\nany help would be very cool thanks.\n. Also i'm confused, what should be passed in grant_type ? \"user_credentials\" or \"password\" ??\nseems like when i set grant_type to \"password\" it says \"Invalid client credentials\"\n. Hello,\nthanks for your answer,  i changed my request to match yours.\nBut i'm still getting invalid client credentials ...\ni noticed that $storage was defined twice so i only kept the first one.\nhere's the new version of the class\n```\nnamespace v1;\nuse Luracast\\Restler\\iAuthenticate;\nuse OAuth2\\GrantType\\UserCredentials;\nuse OAuth2\\Server;\nuse OAuth2\\GrantType\\AuthorizationCode;\nuse OAuth2\\Request;\nuse OAuth2\\Response;\nclass OpenAuth2\n{\nprotected static $server;\nprotected static $storage;\nprotected static $request;\n\npublic function __construct()\n{\n\n    // create some users in memory\n    $users = array(\n        'bshaffer' => array(\n            'password' => 'brent123',\n            'first_name' => 'Brent',\n            'last_name' => 'Shaffer'\n        )\n    );\n\n    // HERE IS THE NEW PART\n    $clients = array(\n        array(\n            'client_id' => 'TestClient',\n            'client_secret' => 'TestSecret'\n        )\n    );\n\n    // create a storage object\n    // ALSO NEW: pass \"client_credentials\" in with the Memory object\n    $storage = new \\OAuth2\\Storage\\Memory(array(\n        'user_credentials' => $users,\n        'client_credentials' => $clients\n    ));\n\n\n    // create the grant type\n    $grantType = new \\OAuth2\\GrantType\\UserCredentials($storage);\n\n    // Pass a storage object or array of storage objects to the OAuth2 server class\n    $server = new \\OAuth2\\Server($storage);\n\n    // add the grant type to your OAuth server\n    $server->addGrantType($grantType);\n\n    static::$request = \\OAuth2\\Request::createFromGlobals();\n    static::$server = $server;\n}\n\n/**\n * @url POST token\n */\npublic function token($grant_type,$client_id,$username,$password)\n{\n    // Handle a request for an OAuth2.0 Access Token and send the response to the client\n    static::$server->handleTokenRequest(static::$request)->send();\n}\n\n}\n```\nthanks..\n. Ok, i took a look at checkUserCredantials and checkClientCredentials and getUserDetails in Memory class\nThen defining storage like this \n```\n   // create some users in memory\n        $users = array( 'bshaffer' => \n            array(\n                'password' => 'brent123',\n                'first_name' => 'Brent',\n                'last_name' => 'Shaffer'\n            )\n        );\n    $clients = array( 'TestClient' => \n        array(\n\n            'client_secret' => 'TestSecret'\n        )\n    );\n\n    // create a storage object\n    // ALSO NEW: pass \"client_credentials\" in with the Memory object\n    $storage = new \\OAuth2\\Storage\\Memory(array(\n        'user_credentials' => $users,\n        'client_credentials' => $clients\n    ));\n\n```\nWorked !!\nSo i had to replace \n$clients = array(\n            array(\n                'client_id' => 'TestClient',\n                'client_secret' => 'TestSecret'\n            )\n        );\nWith\n$clients = array( 'TestClient' => \n            array(\n                'client_secret' => 'TestSecret'\n            )\n        );\nThanks for your help ! and i answer myself, the grant_type is definetly \"password\" and not \"user_credentials\" \nThanks for putting me in the right direction !\n. ",
    "swos-": "@bshaffer Excellent work on this project!\nI took me a while to track down this issue.  I had followed example on the User Credentials Grant Type page (http://bshaffer.github.io/oauth2-server-php-docs/grant-types/user-credentials/).\nI had created the instance for UserCredentials as indicated, but when I ran curl (curl -v http://localhost/oauth2/token.php -d 'grant_type=password&client_id=TestClient&username=bshaffer&password=brent123'), I kept getting a json response with the following: {\"error\":\"invalid_client\",\"error_description\":\"The client credentials are invalid\"}\nAnyway, I followed this thread of discussion, and realized I needed to provide client credentials with a specified client id, but blank secret.\ntl;dr: Would you mind terribly if I make a pull request to oauth2-server-php-docs with some updated documentation for the User Credentials page?\n. @bshaffer Yeah, I wrestled with that line for a bit.  Following a successful implementation of what you had documented in the walkthrough, the User Credentials page appeared equally straightforward as well.  Not realizing if/how I needed to pass client credentials, though, I began to question a lot of my premises.\nAnyway, I'll try to write up some minor changes to the documentation which I think might clarify those points.  As an aside, the documentation for this project is great, and one of the primary reasons I'm interested in it over others!\n. ",
    "geeknz": "How do you declare a public client in memory? Can I use the following example? \nphp\n$memStorage = new OAuth2\\Storage\\Memory([\n    'client_credentials' => [\n        'TestClient' => [ 'client_secret' => '' ]\n    ]\n]);\nAlso is it possible to use a crypto token with user credentials? I'm having some trouble getting them working.\n``` php\n$credentialStorage = new UserCredentials( $database );\n$memStorage = new OAuth2\\Storage\\Memory([\n    'keys' => [\n        'public_key'  => file_get_contents( 'pubkey.pem' ),\n        'private_key' => file_get_contents( 'privkey.pem' )\n    ],\n    'client_credentials' => [\n        'TestClient' => [ 'client_secret' => '' ]\n    ]\n]);\n$cryptoStorage = new OAuth2\\Storage\\CryptoToken( $memStorage );\n$server = new OAuth2\\Server( $memStorage );\n$server->addStorage( $cryptoStorage, 'access_token' );\n$server->addStorage( $memStorage, 'client_credentials' );\n$server->addGrantType( new OAuth2\\GrantType\\UserCredentials( $credentialStorage ) );\n$server->addResponseType( new OAuth2\\ResponseType\\CryptoToken( $storage ) );\n$server->handleTokenRequest( OAuth2\\Request::createFromGlobals() )->send();\n```\n. @bshaffer Thank you. I discovered that the problem was actually in my UserCredentials implementation so it is working great now.\n. ",
    "justingreerbbi": "I know this topic is closed but would like to note a very likely solution to this that has not been mentioned. If the server is running using PHP CGI, then Auth basic headers will not get passed to PHP correctly thus causing this error. \nOne way to check if you pass the client_id and client_secret in the body along with the username and password and the error is not there, you need to modify your .htaccess or change native PHP module.\nRewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n. Yup, I seen that. I don't want to hijack the thread but I don't think the second line example is working. I will continue to poke around and open a new ticket with a possible patch.\n. OAuth2/request.php line 137 (PHP CGI)\n. So I ran into the issue today when using openID Connect to sign users into the free Moodle Learning Management System. The id_token should be returned when using response_type=code if the scope openid is present.  \nI am going to look into the hack around and the development branch to see if there is simple solution but this is not my forte so fingers crossed.\n. @mael-lg Could you provide your snippet of extending the constructor for OAuth2\\OpenID\\Controller\\AuthorizeController?\n. I wanted to chime in here and give a better solution. The class AuthorizeController already stores the property clientStorage object.\nIn the buildAuthorizeParameters method replace\nif ($this->needsIdToken($this->getScope()) && $this->getResponseType() == self::RESPONSE_TYPE_AUTHORIZATION_CODE) {\n            $params['id_token'] = $this->responseTypes['id_token']->createIdToken($this->getClientId(), $user_id, $this->nonce);\n        } \nwith \nif ($this->needsIdToken($this->getScope()) && $this->getResponseType() == self::RESPONSE_TYPE_AUTHORIZATION_CODE) {\n            $userClaims = $this->clientStorage->getUserClaims($user_id, $params['scope']); \n            $params['id_token'] = $this->responseTypes['id_token']->createIdToken($this->getClientId(), $user_id, $this->nonce, $userClaims);\n        }\nThat will return the claims as with the ID Token as expected. Hope this helps.\n. This is not entirely the expected behavior. When openid is presented in scope to should return a id_token as well but it has nothing to do with your code. I am in the same boat where the sever is not returning the id_token when the using response_type=code.\nHowever the functionality does work with the implicit method. I am doing some poking around as well but with no luck yet.\n. I came up with a solution by passing the the id token to setAuthorizationCode and then modifying the codes table in the DB to handle an ID to pass back.\nI was not able to get it to work just by modifying the settings. All responses came back in the URL or implicit and not in the JSON response as specified in spec.\n. ",
    "hitswa": "I didn't get yet whare exactlt the problem is? Where do I need to change in code?\nfollowing cookbook from here\nhttps://bshaffer.github.io/oauth2-server-php-docs/cookbook/\nexecuting this command a instructed in document\ncurl -u testclient:testpass http://localhost/token.php -d 'grant_type=client_credentials'\ngetting following response\n{\"error\":\"unsupported_grant_type\",\"error_description\":\"Grant type \\\"client_credentials\\\" not supported\"}{\"error\":\"unsupported_grant_type\",\"error_description\":\"Grant type \\\"client_credentials\\\" not supported\"}. Nope, none of above suggestions worked for me. just getting \n{\"error\":\"invalid_request\",\"error_description\":\"The grant type was not specified in the request\"}{\"error\":\"invalid_request\",\"error_description\":\"The grant type was not specified in the request\"}\nno matter if I use the single quote (') or double quote (\") as suggested by haven...\nin fact, when I use the double quote (\") I get this response\n{\"error\":\"unsupported_grant_type\",\"error_description\":\"Grant type \\\"client_credentials\\\" not supported\"}{\"error\":\"unsupported_grant_type\",\"error_description\":\"Grant type \\\"client_credentials\\\" not supported\"}\nAlso, when I tried suggestions from shenmadouyaowen I get following response\n{\"error\":\"invalid_request\",\"error_description\":\"The grant type was not specified in the request\"}{\"error\":\"invalid_request\",\"error_description\":\"The grant type was not specified in the request\"}'client_id' is not recognized as an internal or external command,\noperable program or batch file.'client_secret' is not recognized as an internal or external command,operable program or batch file.\nDidn't find anything suggested by kaoscoder on line number 88 in OAuth2\\Controller\\TokenController.php file but found it on 138. It seems like the code has been changed since his reply. Anyways, I changed acc to what he suggested and my error response was same.\nDidn't find anything suggested by kaoscoder in his next suggestion in the entire file...\nAt the end still getting the same response.\nMy working environment\nWindows 8.1\nXAMPP with PHP 7.1\nEditor: Visual Studio Code (command prompt as default terminal where I executed curl command)\n. ",
    "cgillespie": "I know this issue was a long time ago but I just came across it now. I really think this page http://bshaffer.github.io/oauth2-server-php-docs/grant-types/user-credentials/\nneeds to say something about this to make it clear that pdo is hashing passwords before comparing.\n. ",
    "martinzaleski": "No, I'm not saying the user id should be returned in the token response. This is my first experience with oAuth2 and I just thought it made sense.\nMy problem here is that I have users logging in to retrieve personal information, and I don't find the way to do it since even though they authenticate, I can't identify their information.\nSo for option number 1, which is most likely what I need to use, I guess I would need to get the bearer token out of the request headers and use it to get the user id, right?\nThank you!\nBest,\nMartin\n. Ok. So the Authorization header is:\nBearer whatever_the_token_is\nDoes that mean that I've got to extract the token out of the string? That doesn't sound like the cleanest, does it? \nDoesn't the library have a quick and cleaner method to retrieve the token within the Controller?\n. What I meant is that, within the code of my apigility method (the code that triggers after the call), the only way I found to get the token is getting the HTTP Request headers with the php funcion apache_request_headers(). Then I would check for the Authorization key within the returned array, and then get the access token using substr() on the following string: \"Bearer whatever_the_token_is\".\nI'm pretty sure this is not the preferred way, so what's that about the /token endpoint? How do I access that JSON?\n. Hi Brent, I know this is not apigility. I just thought you would know about it since the official apigility oAuth2 engine is integrated with this library.\nI'll provide you with the gist, which is just a copy of the Apigility controller:\nhttps://gist.github.com/bittlestudio/81b27e4857c009cba384\nIn line 52, I would like to be able to get the token.\nThank you very much for your time and patience, really apreciated.\n. ",
    "theroadrunnershow": "https://developers.google.com/drive/web/credentials\n. ",
    "rlanvin": "Yes I suppose that would make sense to pass it to handleAuthorizeRequest, the same way you pass the user id. But the modifications involved to do it are beyond my understanding of the lib. It seems the parameter will have to be passed to many different methods in many different classes, and some interfaces will have to be updated as well? I'm a bit lost in the execution flow to be honest, so if you're expecting me to do it I'll need some guidance.\nWhat if I change the \"user_id\" parameter so that it accepts an assoc array as well? If you can handleAuthorizeRequest with a string/int, it'll work as now, but if it's an assoc array, it'll fetch \"user_id\" and \"auth_time\" from it. This way the lib's API doesn't have to change (I think).\nExample:\nphp\n$server->handleAuthorizeRequest($request, $response, $is_authorized, $user_id); // will work as before for servers without OpenID Connect\n$server->handleAuthorizeRequest($request, $response, $is_authorized, array('user_id' => $user_id, 'auth_time' => $session_start_time)); // with additional auth time when using OpenID Connect\nWhat do you think?\n. Yes you're right it looks tricky. If you want a central conversion then I suppose the cleaner way is to have it in the first method call in Server class and work with array everywhere else (e.g user_parameters instead of user_id or something). Other option: it could be an array only in the OpenID classes, that's less changes but it's inconsistent.\nNow as I said before, I don't have a deep understanding of the working of this lib, so I might also be looking at it the wrong way.\n. ",
    "islandlinux": "Having a response code to indicate if the access_token has expired would be very useful. Something like this:\nphp\n    if ($token_param = $this->tokenType->getAccessTokenParameter($request, $response)) {\n        // Get the stored token data (from the implementing subclass)\n        // Check we have a well formed token\n        // Check token expiration (expires is a mandatory paramter)\n        if (!$token = $this->tokenStorage->getAccessToken($token_param)) {\n            $response->setError(401, 'invalid_token', 'The access token provided is invalid');\n        } elseif (!isset($token[\"expires\"]) || !isset($token[\"client_id\"])) {\n            $response->setError(401, 'malformed_token', 'Malformed token (missing \"expires\")');\n        } elseif (time() > $token[\"expires\"]) {\n            $response->setError(401, 'expired_token', 'The access token provided has expired');\n        } else {\n            return $token;\n        }\n    }\n. ",
    "shadow-fox": "In the oauth response while doing a successful authentication . \n. Currently the response looks like this\n{\n  \"access_token\":\"crypttoken\",\n  \"expires_in\":3600,\n  \"token_type\":\"bearer\",\n  \"scope\":null,\n  \"refresh_token\":\"crypttoken\"\n}\nWhat I want the response to be is \n{\n  \"access_token\":\"crypttoken\",\n  \"expires_in\":3600,\n  \"token_type\":\"bearer\",\n  \"scope\":null,\n  \"refresh_token\":\"crypttoken\",\n  \"role\":\"admin/user/moderator/guest\",\n  \"otherproperty\": \"otherpropertyvalue\"\n}\nHow to customize to support this?\n. ping @bshaffer . Which files to extend , which method to overwrite ?\n. ",
    "bgaillard": "Hi, we implemented a workaround for this problem, here is our controller, hope this helps. \n``` php\n<?php\nnamespace Gomoob\\Zend\\Mvc\\Controller;\nuse OAuth2\\Storage\\Pdo;\nuse OAuth2\\Server;\nuse OAuth2\\GrantType\\ClientCredentials;\nuse OAuth2\\Request;\nuse Zend\\Http\\Response;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\Mvc\\MvcEvent;\nuse Gomoob\\OAuth2\\SqlPdo;\nuse Gomoob\\Commons\\Exception\\IllegalStateException;\n/\n * Zend Controller used to manage OAuth2.0 requests.\n \n * @author Baptiste GAILLARD (baptiste.gaillard@gomoob.com)\n /\nclass OAuth2Controller extends AbstractActionController {\n/**\n * An OAuth2.0 server used to manage Access Token generation.\n *\n * @var \\OAuth2\\Server\n */\nprotected $oAuth2Server;\n\n/**\n * Sets the OAuth 2.0 server used to manage Access Token generation.\n *\n * @param Server $oAuth2Server the OAuth 2.0 server used to manage Access Token generation.\n */\npublic function setOAuth2Server(Server $oAuth2Server) {\n\n    $this -> oAuth2Server = $oAuth2Server;\n\n}\n\n/**\n * Action used to defined an OAuth 2.0 Token Endpoint.\n *\n * <p>This action should only be called using POST requests, otherwise you will received a JSON response with an\n *    error.</p>\n *\n * <p>For Client Credentials the data to POST should have the following format:</p>\n * <verbatim>\n *   {\n *       \"grant_type\" : \"client_credentials\",\n *       \"client_id\" : \"bgaillard\",\n *       \"client_secret\" : \"test\"\n *   }\n * </verbatim>\n *\n * <p>NOTE: This action should be called with the following HTTP header : 'Content-Type: application/json'.</p>\n *\n * @return \\Zend\\Stdlib\\ResponseInterface A reponse which contains a generated OAuth 2.0 Access Token.\n *\n * @see http://tools.ietf.org/html/draft-ietf-oauth-v2-23#section-3.2\n */\npublic function tokenAction() {\n\n    // An OAuth2 server must have been provided\n    if (!isset($this -> oAuth2Server)) {\n\n        throw new IllegalStateException('No OAuth2 Server has been configured in this controller !');\n\n    }\n\n    // Grants or Deny a requested Access Token\n\n    // WARNING: WITH ZEND FRAMEWORK 2 DO NEVER USE THE OAuth2 Request::createFromGlobals() FUNCTION BECAUSE IT WILL\n    //          CLEAR YOUR ZEND $request -> getContent(). THIS IS EXPLAINED BECAUSE THE CONTENT OF AN HTTP PUT OR\n    //          POST REQUEST IS ALWAYS READ ONLY ONCE PER PROCESS AND THEN CLEARED. SO IF YOU USED\n    //          Request::createFromGlobals() THE php://input STREAM WOULD BE READ AND CLEARED, THEN WHEN ZEND WOULD\n    //          TRY TO READ THE php://input STREAM AGAIN THE RETURNED PUT OR POST DATA WILL BE EMPTY !!!\n    $oAuth2Response = $this -> oAuth2Server -> handleTokenRequest($this -> createOAuth2RequestFromGlobals());\n\n    $zendResponse = $this -> getResponse();\n    $zendResponse -> setStatusCode($oAuth2Response -> getStatusCode());\n    $zendResponse -> setReasonPhrase($oAuth2Response -> getStatusText());\n    $zendResponse -> setContent($oAuth2Response -> getResponseBody());\n\n    return $zendResponse;\n\n}\n\n/**\n * This function is a replacement of the OAuth2 PHP Library 'Request::createFromGlobals()' by a function which is\n * compatible by the Zend Framework 2 Library.\n *\n * <p>\n *  WITH ZEND FRAMEWORK 2 DO NEVER USE THE OAuth2 Request::createFromGlobals() FUNCTION BECAUSE IT WILL CLEAR YOUR\n *  ZEND $request -> getContent(). THIS IS EXPLAINED BECAUSE THE CONTENT OF AN HTTP PUT OR POST REQUEST IS ALWAYS\n *  READ ONLY ONCE PER PROCESS AND THEN CLEARED. SO IF YOU USED Request::createFromGlobals() THE php://input STREAM\n *  WOULD BE READ AND CLEARED, THEN WHEN ZEND WOULD TRY TO READ THE php://input STREAM AGAIN THE RETURNED PUT OR\n *  POST DATA WILL BE EMPTY !!!\n * </p>\n *\n * <p>WITH THE ZEND FRAMEWORK 2 INSTEAD OF USING 'Request::createFromGlobals()' ALWAYS USE THIS FUNCTION !</p>\n *\n * @return \\OAuth2\\Request the created OAuth2 Request.\n */\nprotected function createOAuth2RequestFromGlobals() {\n\n    $request = new \\OAuth2\\Request($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER);\n\n    $contentType = $request -> server('CONTENT_TYPE', '');\n    $requestMethod = $request -> server('REQUEST_METHOD', 'GET');\n\n    if (0 === strpos($contentType, 'application/x-www-form-urlencoded') &&\n    in_array(strtoupper($requestMethod), array('PUT', 'DELETE'))) {\n\n        parse_str($request->getContent(), $data);\n        $request->request = $data;\n\n    } else if (0 === strpos($contentType, 'application/json') &&\n    in_array(strtoupper($requestMethod), array('POST', 'PUT', 'DELETE')) ) {\n\n        $data = json_decode($this -> getRequest() -> getContent(), true);\n        $request -> request = $data;\n\n    }\n\n    return $request;\n\n}\n\n}\n```\n. Hi @bshaffer, yes this is exaclty what we did in our builds to make is work on our staging servers which run on 32bits Centos distribs. \nAnyway this would not be very problematic as MongoDB clearly mention to not use the 32bits version in production environments (in our case we use 32bits versions only in testing and staging environments).\n. ",
    "egeriis": "It is the same issue with Laravel 4\n. @bshaffer Is there any reason that you're not using the latest HttpFoundation\\Request class from Symfony2? createFromGlobals differs from the one in this lib. And it fucks up reading from php://input when the Content-Type: application/json header is sent with the request.\nhttps://github.com/symfony/HttpFoundation/blob/master/Request.php\n. Yes, after searching around, I found the httpfoundation-bridge lib. So this works perfectly now, for Laravel 4:\nphp\nOAuth2\\HttpFoundationBridge\\Request::createFromRequest(Input::instance())\n. ",
    "arvinddgreat": "Hi Bshafer, same problem is with Phalcon\\Request integration as well. Is there any work around for the same?\n. ",
    "soutoner": "Did anyone solve the integration problem with Phalcon/Request?\n. ",
    "fauguste": "I found the problem, I created a \"userinfo\" service\n<?php\n// include our OAuth2 Server object\nrequire_once __DIR__.'/Server.php';\n$request = OAuth2\\Request::createFromGlobals();\n$response = $server->handleUserInfoRequest($request);\necho $response->send();\nIs it possible to add the email to the id_token ? The google openid connect provide this information directly in the id_token.\n. Google added email in id_token at claim named \"email\". \nI understood what is not a bug of your module and you respect the spec.\nI close this issue and I will use user info service.\n. Finally, we need to add this to our storage test suite (see BaseTest), so that the standard storage test suite runs against it. This will require you to add a getDynamoDBStorage function to the OAuth2\\Storage\\Bootstrap file\nWhere can we store secret ? Dynamodb need an AWS account.\n. PublicKeyTest::testSetAccessToken is failed because I defined client_id as primary in oauth_public_keys table.\nI used string null to solve this problem, but I not sure it is the best solution.\nWhich solution you prefer ?\n. An other test error :\nOAuth2\\Storage\\ScopeTest::testGetDefaultScope with data set #0 (OAuth2\\Storage\\DynamoDB)\nFailed asserting that two strings are equal.\n--- Expected\n+++ Actual\n@@ @@\n-'defaultscope2 defaultscope1'\n+'defaultscope1 defaultscope2'\n/home/ubuntu/oauth2-server-php/test/OAuth2/Storage/ScopeTest.php:47\nI thinks it is an error in the test, we can not define order of the default scope.\n. I pushed dynamodb tests and some corrections.\nAll tests are OK.\nYou have to configure Bootstrap::getDynamoDBStorage in order to set AWS secret, key and region.\nCreation and deletion of table are asynchronous, tests are waiting the success of these operations and it take a long time (function getDynamoDBStorage).\nLet me know if you have some trouble with dynamodb.\n. You can use a local dynamodb instance for testing ;\nhttp://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tools.DynamoDBLocal.html\nIf you are agree, I can test it and configure tests for working with this library.\n. Do you know when you can merge this fork ?\nThanks.\n. Thanks.\n. Issue corrected for Pdo and Dynamodb storage.\n. Let me know if you are agree with this modification and if you can merge it ?\nThanks\n. I have some trouble to do this.\nI think the best way is to drop my fork and pull request.\nAnd recreate and send it in one commit.\n. Thanks, I thinks all are done.\n. ",
    "silvios": "Hey thank you so much for your quick reply!\nIn the class\nOAuth2\\Storage\\ClientInterface\nI do not see the getClientScope method am i perhaps looking in the wrong place?\n. in my composer file i have this:\n\"bshaffer/oauth2-server-php\": \"v1.0\",\n        \"bshaffer/oauth2-server-httpfoundation-bridge\": \"v1.0\",\nI'm guessing that I'm pulling a really old version, I am using the demo you provided as the starting point of my api server\n. after updating to 1.4 i see that function now, I was using a really old version of the code without even really knowing it, since starting with this project, silex/symfony/composer/oauth are all new to me, I will see if i can figure out how to implement that interface as you suggested thank you!\n. oh wow, after adding the field and updating it looks like it works exactly as i expected it to work :) i didnt even have to do anything lol, very nice!\n. oddly that doesnt seem to work for me.\n$test = $server->verifyResourceRequest($request, $response);\nthis returns false, when i do it via the browser &access_token=sameToken it returns true, is there something i need to do to allow the header to work?\nThe header is this Authorization: Bearer tokenHere\n. I am using the http-foundation-bridge library.\nwhen dumping the headers via the php side i get this: using getallheaders()\n [Authorization] => Bearer tokenHere\nIs this something I perhaps did not read correctly in the docs? I do not recall seeing anything that would stop the headers from working.\nWhat is a proper header supposed to look like?\n. Why don't we fix this ourselves.\nin the HttpFoundationBridge namespace the Request class\nadd the function:\n/\n     * Creates a new request with values from PHP's super globals. \n     * Overwrite to fix an apache header bug\n     \n     * @return Request A new request\n     \n     * @api\n     */\n    public static function createFromGlobals()\n    {\n        $request = parent::createFromGlobals();\n```\n    /\n     * fix the apache header issue. See....\n     * http://stackoverflow.com/questions/11990388/request-headers-bag-is-missing-authorization-header-in-symfony-2%E2%80%94\n     /\n    self::fixAuthHeader($request->headers);\nreturn $request;\n\n}\n```\n/\n     * PHP does not include HTTP_AUTHORIZATION in the $_SERVER array, so this header is missing.\n     * We retrieve it from apache_request_headers()\n     \n     * @param HeaderBag $headers\n     /\n    private static function fixAuthHeader(\\Symfony\\Component\\HttpFoundation\\HeaderBag $headers)\n    {\n        if (!$headers->has('Authorization') && function_exists('apache_request_headers')) \n        {\n            $all = apache_request_headers();\n            if (isset($all['Authorization']))\n            {\n                $headers->set('Authorization', $all['Authorization']);\n            }\n        }\n    }\nand this would be solved on our end or is this not a proper solution? We would no longer need the htaccess rules\n. done, thanks again for your help, we can close this once it gets merged in, so I can update my project with the new code.\n. ",
    "dallasvogels": "Clarity and stability.\nIn the case where the access_token has expired I have to inspect the error_description and search in part or in full the text The access token provided has expired. Refreshing an access_token is a regular occurrence and searching the error_description to determine the state of the access_token  could lead to broken code if the  error_description were to change. It is less likely for the error label to change than the description.\n. ",
    "nueko": "What is the question?\nwhat are the requested change?\n. I will  fix it soon \n. +1\n. I converted the spaces to tabs which is better, i thought\n. ",
    "tom22222": "Excellent - it works!  Thanks very much for your help.  Is this the right place to be asking these types of questions as I'm bound to need to ask more as time goes on.\n. Well great, thanks again!\n. ",
    "shouldroforion": "Thanks for this. Perfect answer.\n. ",
    "Gerst20051": "how do you implement the refresh token? @valheranze i've seen some people put it on a cron.\n. yeah that will generate a new token. but knowing when and how to use the refresh grant type is the question.\n. ok thanks! as i learn about it more i'll clarify your explanation even further.\n. @luttkens do i have to build my own method to look up existing refresh token (say based on the user_id) or is this built into this library? i've been looking around but i haven't found anything for looking up refresh tokens. i'm also still trying to figure out how to create tokens and refresh tokens with the user_id defined.\n. @bshaffer i don't understand why the Client Credentials Grant Type doesn't issue a refresh token. I can only generate a refresh token via the authorization method. I'm trying to integrate this into our existing system with existing users etc... I might create my own oauth class since our needs are narrow. We just need to link tokens with user ids...\n. @bshaffer how often do you merge develop into master?\n. ",
    "luttkens": "@valheranze My understanding is that coneceptually refresh_tokens should never be sent to a client, so then it feels better to return a long-lived access token. But I guess that for a security point of view it is the same.\nAlso, I think it is easier for the client-developer to only implement the User Credentials Flow, instead of also handling expired access tokens and request new ones using a refresh token.\nBut if I were to go with refresh tokens; how do you set a custom life time? Doesn't that have the same issue?\nFor now I just to this:  (for long-lived access tokens)\n$server = Yii::app()->oauth->getServer();\n$request = OAuth2\\Request::createFromGlobals();\nif (isset($request->request['grant_type']) && $request->request['grant_type'] == \"password\")\n    $server->setConfig('access_lifetime', 3600*24*30);\n. @bshaffer I think that sounds like a good solution! I guess in practice, that would allow usage like this:\nclass MyUserCredentials extends UserCredentials {\n    public function createAccessToken(AccessTokenInterface $accessToken, $client_id, $user_id, $scope)\n    {\n        $accessToken->setAccessTokenLifetime(3600*24*30);\n        return $accessToken->createAccessToken($client_id, $user_id, $scope);\n    }\n}\n. ",
    "freefri": "I was facing a problem related with this. For me it is fine to handle the OPTIONS request out of the library, but I have to handle also the header('Access-Control-Allow-Origin: *'); for every response. For example when I am getting an Unauthorized error handled by the library. I've decide to add it in the OAuth2\\Response object with the function setHttpHeader('Access-Control-Allow-Origin', '*');\n. ",
    "multipletentacles": "Update: Changed the value of the $users array to be more compatible, still same problem:\n$users = array($_POST['username'] => $storage->getUserDetails($_POST['username']));\n. Update: Changed the value of the $users array to be more compatible, still same problem:\n$users = array($_POST['username'] => $storage->getUserDetails($_POST['username']));\n. Update: Changed the value of the $users array to be more compatible, still same problem:\n$users = array($_POST['username'] => $storage->getUserDetails($_POST['username']));\n. Update: Changed the value of the $users array to be more compatible, still same problem:\n$users = array($_POST['username'] => $storage->getUserDetails($_POST['username']));\n. I discovered the problem. Apparently, in version 0.9, the code is different than in the later versions as regards checking user credentials. The array for user_credentials is stored in the Storage object as a simple array with the key being the user id and the value being the password. Also, you have to supply client credentials to the storage object, too, or it won't work.\nTo discover this, I had to open all the files in oAuth2 server application, and search through all of them for the error message it was giving me, then I was able to trace back what the application was doing to check the user credentials which led to solving the problem.\n. ",
    "marcovanest": "@bshaffer \nYou're right, I looked it up in the specs section 3.3\n\nIf the client omits the scope parameter when requesting\nauthorization, the authorization server MUST either process the\nrequest using a pre-defined default value or fail the request\nindicating an invalid scope.  The authorization server SHOULD\ndocument its scope requirements and default value (if defined).\n\nChanging the behavior to require a scope would be the best solution in a perfect world :), but this would break a lot of applications out there which aren't using a scope parameter and which are also using the default PDO\\Storage / Library.\nWith the latter in mind the practical solution would be updating the docs to make this clear. Anyone who want to enforce the scope, should implement there own Storage or TokenController imho\n. That would indeed be another solution, in the mean time I've implemented a tokenController that extends the default tokenController and overrules the method grantAccessToken\n. ",
    "AlexMarlo": "In this configuration your client data mean that you support all grant types, because in your client data grant_types is empty.\nhere examples of request\n```\n$post_data = [\n  \"grant_type\" => \"password\",\n  \"client_id\" => \"TestClient\",\n  \"username\" => \"login@mail.com\",\n  \"password\" => \"password\"\n];\n$response = Request::sendPost( \"/oauth/authorize\",  $post_data);\n```\nI use mysql database and it works for me.\n. Try to add username in $users variable \n. Memory Storage has method checkPassword,  you can add echo or var_dump for password from request and password in db to see what is wrong \n. You welcome :) \n. ",
    "proctar": "This makes sense, thanks. Actually I just didn't think of removing access from the client side. In my mind, that should be controlled by the server. But removing access tokens from the client side works, yes.\nOf course, it would be cleaner to also get rid of the tokens from the server side but anyway.\nThanks,\n. ",
    "utpal4job": "Hello, Thanks for your reply. \nIt's fine that i will POST http method but how to use POST http method using that code. Can you please tell me in details or if you have any example how to use.\nRegards,\n. Hello, It's ok. Thanks for your reply.\nRegards.\n. Hello, When try to run \"curl -u testclient:testpass http://localhost/token.php -d 'grant_type=client_credentials\" command then below error is appearing.\n{\"error\":\"invalid_client\",\"error_description\":\"Client credentials were not found in the headers or body\"}\nCan you please tell me why that error is appearing.\nRegards,\n. Hello, When pasting below both commands then nothing happening.\n[root@ip-46-252-194-21 ~]# curl -v testclient:testpass http://www.stv22.com/my-oauth2/token.php -d 'grant_type=client_credentials\n[root@ip-46-252-194-21 ~]# curl -u testclient:testpass http://www.stv22.com/my-oauth2/token.php -v 'grant_type=client_credentials\nRegards,\n. Hello, I have entered as you said and clicks the enter button then \">\" symbol is appearing. Can you please tell me what is happening.\nRegards,\n. Hello, Thanks for your reply. Now i get the access token values.\nRegards,\n. Hello, I am getting the below response. I think the access token is not displaying.\n[root@ip-46-252-194-21 ~]# curl -u testclient:testpass http://www.stv22.com/my-oauth2/token.php -d 'grant_type=client_credentials' -v\n- About to connect() to www.stv22.com port 80 (#0)\n-   Trying 46.252.194.21... connected\n- Connected to www.stv22.com (46.252.194.21) port 80 (#0)\n- Server auth using Basic with user 'testclient'\n\nPOST /my-oauth2/token.php HTTP/1.1\nAuthorization: Basic dGVzdGNsaWVudDp0ZXN0cGFzcw==\nUser-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.14.0.0 zlib/1.2.3 libidn/1.18 libssh2/1.4.2\nHost: www.stv22.com\nAccept: /\nContent-Length: 29\nContent-Type: application/x-www-form-urlencoded\n< HTTP/1.1 200 OK\n  < Date: Wed, 30 Jul 2014 18:39:31 GMT\n  < Server: Apache\n  < X-Powered-By: PleskLin\n  < MS-Author-Via: DAV\n  < Content-Length: 0\n  < Connection: close\n  < Content-Type: text/html; charset=UTF-8\n  <\n- Closing connection #0\n\nRegards,\n. Hello, I have run the command what you have said. Below are response:\n[root@ip-46-252-194-21 ~]# curl -i \"http://www.stv22.com/my-oauth2/token.php\" \\ --user CLIENT_ID:testclient \\ -X POST -d \"grant_type=client_credentials\"\nHTTP/1.1 200 OK\nDate: Thu, 31 Jul 2014 08:25:47 GMT\nServer: Apache\nX-Powered-By: PleskLin\nMS-Author-Via: DAV\nContent-Length: 0\nConnection: close\nContent-Type: text/html; charset=UTF-8\ncurl: (6) Couldn't resolve host ' --user'\ncurl: (6) Couldn't resolve host 'CLIENT_ID:testclient'\ncurl: (6) Couldn't resolve host ' -X'\ncurl: (6) Couldn't resolve host 'POST'\nPlease tell me if i am wrong.\nRegards,\n. Hello, It's ok. Here is the response:\n[root@ip-46-252-194-21 ~]# curl -i \"http://www.stv22.com/my-oauth2/token.php\"  --user CLIENT_ID:testclient -X POST -d \"grant_type=client_credentials\"\nHTTP/1.1 200 OK\nDate: Thu, 31 Jul 2014 08:30:34 GMT\nServer: Apache\nX-Powered-By: PleskLin\nMS-Author-Via: DAV\nContent-Length: 0\nConnection: close\nContent-Type: text/html; charset=UTF-8\nRegards,\n. Hello, It's ok. Here is the response:\n[root@ip-46-252-194-21 ~]# curl -i \"http://www.stv22.com/my-oauth2/token.php\" --user testclient:testpass -X POST -d \"grant_type=client_credentials\"\nHTTP/1.1 200 OK\nDate: Thu, 31 Jul 2014 11:05:50 GMT\nServer: Apache\nX-Powered-By: PleskLin\nMS-Author-Via: DAV\nContent-Length: 0\nConnection: close\nContent-Type: text/html; charset=UTF-8\nRegards,\n. ",
    "mfarhanahmad": "@bshaffer I am able to initiate the token successful and also token is validating correctly on my resource page. Just one thing that I want to know,\nOn expiring token How can I generate a new token with refresh token ?. ",
    "ruifil": "Exactly I have haded extra field, in user info.\nThanks\n. ",
    "aesculus": "OK. Perhaps a data dictionary graphic in the documentation would help clarify all of this.  For those elements that don't have a relationship it could just be open.\n. ",
    "doc-iwatersports": "I was forced to extend the Storage Object because of the following code:\n``` php\n    public function getUserDetails($username)\n    {\n        if ($user = $this->getUser($username)) {\n            $user['user_id'] = $user['username'];\n        }\n    return $user;\n}\n\n```\nNot sure why this strangeness was in there.\n. I am extended the Mongo Storage class. You are right, my comment doesn't exactly pertain to the above question.\n. Yes, Thanks.\n. ",
    "jdelisle": "Yeah! Sorry probably should have reported it on the documentation repo...\n. This change made it work for me:\n``` php\n// create storage\n$storage = new OAuth2\\Storage\\Memory(array(\n    'keys' => array(\n        'public_key'  => $publicKey,\n        'private_key' => $privateKey,\n    ),\n    // add a Client ID for testing\n    'client_credentials' => array(\n        'CLIENT_ID' => array('client_secret' => 'CLIENT_SECRET')\n    ),\n));\n$server = new OAuth2\\Server();\n$server->addStorage($storage); // <<<<< THIS LINE ADDED <<<<<\n$server->addGrantType(new OAuth2\\GrantType\\ClientCredentials($storage)); // minimum config\n```\n. ",
    "ckmaresca": "Well, my use case is that the client secret is stored in a mobile app, so it's not like we'd ever display it since the only way to 'loose' it is to delete the app.\nI don't really want to go down the path of JWT tokens as our workflow is around client secret.  What I was asking is that, if you were to implement hashing, where would it be done?   Right now, I'm looking at modifying the storage class that we're using, is that a good way to do it?\nI would suggest breaking out a class that implements password_hash et al as part of the storage workflow.  Then it would be easier to modify the password storage instead of modifying the whole storage class.\n. Manged to isolate the namespace problems but using compact in a security context is probably not the wisest idea....\n. It turnout to be a conflict with two 'access_token' fields (I think, the problem went away when we changed how we were caching 3rd party tokens - I stopped looking after that).\nNothing to do with register_globals, but some vars are global by default, $_SESSION being the most obvious one.   \ncompact is a problem in an environment like ours where we are both an oauth server & multiple oauth clients at the same time.  Usually scope takes care of any issues (so does compact scope restrictions...), but there are some things (like $_SESSION) that you can't avoid because of the stateless nature of web clients.    Also, 3rd party access_tokens are returned in get strings, so there is a potential for confusion, particularly as local auth handled by your code gets lost in the transaction and we have to re-inject it into the request....\nIt's a useful shortcut, but I'd rather see a more explicit access_token identification than what is effectively a grep of the current namespace....  This is particularly true because your code looks for the token in certain super-globals ($_SESSION & $_GET + request headers) and adds the found token(s) to a locally scoped array (which is then picked up by compact, although it's not obvious or explict), IRC (but I could be wrong).   The chance for confusion is pretty high...\n. As I was trying to figure out what was going on, I noticed that you are creating a locally scoped set of values from super globals with this call https://github.com/bshaffer/oauth2-server-php/blob/6811d3d158be04a8b5539e9484d7465a91fcedb0/src/OAuth2/Request.php#L192 \nFrom this new locally scoped set of variables you are getting the access_token by using compact, AFAIK (I haven't full traced things).  Effectively, you're searching for access_token in a sub-set of the global namespace by doing this, which can cause issues if a URL being submitted has an access_token in the GET string (as part of an auth_redirect for Facebook API access, for example) and is also supposed to be authenticated using either $_SESSION or Authentication in the HTTP header.\nOne way to resolve this is to more explicitly pass access_token from the allowed methods (header, get, $_SESSION) defined in the Oauth2 protocol (which you are loosely doing kinda) - maybe configuring a hierarchy so that header & $_SESSION are trusted first over get.  Maybe a test to see where the value is coming from after finding it using compact?  I don't know.....\nThat said, I think that this software is by far the best Oauth2 server for PHP.  We've used every single one, and yours is the one that consistently does what we want in the way we expect.   This is really just a potential problem I noticed as I was trying to debug our particular issue...\n. Could be - all I know is that compact wound up picking up more than one variable (type was array not string).  After the problem went away, I stopped investigating & closed the issue.  What I wrote above is what I reconstructed from memory - it could be right, wrong or something inbetween.  \nFWIW - the way we solved it is by extracting the correct token from $_SESSION (where we store it specifically because all other references get lost in when you get a redirect from a 3rd party API [note: we also store it in state just in case...]) then 'artificially' injecting it into the current session as a 'fake' header (e.g. programmatically generated by the server, not submitted by the client).  We then call your code to Oauth2 the current client.\nThat solved it, and as much as I'd like to spend more time looking at this and figuring out a better way, this works for us (even if it is a hack).   It still doesn't solve the fundamental problem of potential namespace collisions, however.\nHTH figure out a better solution, but I don't have much more time to spend on this, too busy writing a json2json ETL tool.... ;-)\n. LOL, that's really funny - you actually assumed that it was in state unencrypted?  How cute.  \nAnyway - you are confused.  I'm not talking about a stand-alone [bshaffer] Oauth2 server, but rather (if you read my posts again) a situation where the backend server is acting as both [bshaffer] Oauth2 server & an Oauth2 client for ANOTHER 3rd party system which uses Oauth2. \n[Long explanation]\nIf you auth with a 3rd party (let's pick on Facebook as an example), Facebook generates an Oauth2 redirect - after a user has authorized access to their info - which comes back to the backend server (where the [bshaffer] Oauth2 server is part of the stack) via a user's web browser (client).  It looks exactly the same as a redirect coming from your [bshaffer] Oauth2 server, complete with a access_token and there is ZERO state information about who it belongs to because http is stateless - remember this is on the backend which is acting as both Oauth2 server (bshaffer code) & Oauth2 client (say Guzzle for simplicity sake), where the user is using a (stateless) web browser (client).\nBefore the Facebook access_token can be accepted & saved for a specific given web browser (client (and user)), we need to identify & authorize that web browser (client) (using an Oauth2 Bearer access_token generated by [bshaffer]).  But, remember, we lost all context & state information in the transactions that generated the redirect FROM Facebook (this is NOT a [bshaffer] redirect)....   The only way to know who the client is is by somehow retrieving the [bshaffer] access_token from some sort of storage that persists through the Facebook transaction & redirect, all while leaving the Facebook access_token (which we need to save) intact.\nWe do this by looking it up in $_SESSION (server side) which is tied to a web browser (client) cookie.   Because there is an off-chance that the cookie might be corrupted or deleted, we also have the [bshaffer] access_token passed as part of an encrypted string using the oauth2 state variable.  Which is convenient as some APIs use state as a kind of nonce and require a pseudo random variable, plus we can use it to double check the legitimacy of the request in case someone's cookies got hijacked along the way....  We could just pass the $_SESSION cookie ID, but really it amounts to the same thing as $_SESSION is directly tied to the access_token anyway.\nAfter we retrieve the [bshaffer] access_token, we then inject it into the web browser's (client) request vars on the server, typically as a header by modifying the relevant super-globals.   Then we can pass the request to the [bshaffer] Oauth2 code for validation.\nThis all works fine in theory, assuming that all 3rd party APIs send their access_tokens via GET and we inject our [bshaffer] access_token via a header.  But some APIs (like Fitbit) want to pass access_token via headers so they won't show up in logs....   Right now it's not an issue, but it soon will be as Fitbit switches from Oauth1 to Oauth2.   I don't know if they will still insist on access_token via header, but probably. (Yes, it's non-standard, no they won't care, yes it happens all the time - people regularly ignore standards when they don't suite their needs/philosophy/religion/dog/etc.)\nBecause the current [bshaffer] code is grabbing ALL access_tokens variables across all the different methods available, it did, at one point, cause a namespace collision in our situation.  We've managed to resolve it for now, but I have a feeling it will be more of a problem in the future.\n[edited for clarity - perhaps more confusing, who knows]\n. Well, I used to be on a red team many years ago, so I know just how stupid people can be.....\n. [changed title to actually reflect what we are discussing]\n. ",
    "relaxnow": "Thanks!\n. Thanks!\n. I investigated OIDC as an alternative to SAML2 and initially the id_token seemed to contain just that critical advantage that SAML2 browser SSO has in enterprise scenarios: \nA Relying Party (Service Provider in SAML2 terms) can receive an authentication from a OpenID Connect Provider (OP, or Identity Provider in SAML2) without needing direct access.\nSee many of these systems are behind NAT or some kind of firewall and sysadmins are (understandably) very reluctant to open these security critical systems up to the larger internet.\nBut because of the 2K limit on URLs (can't send a lot of data) and the need for browser clients to do public key verification (which many clients will forgo or implement incorrectly) I advised my client to send only what the spec requires and make RPs use the Token endpoint as much as possible.\nLike @bshaffer said, it can be useful for return visitors. But only if the RP does all that crypto work, I'd still recommend that they don't.\nStill the spec requires it and there may be enterprise systems that will require this.\n. @bonanza Like @bshaffer said the TokenController also needs to support this.\n. @bojanz sorry it took a while, holidays and all.\nAnyway, I looked into this and from the code it does look like if the Authorization Code gets stored with an id_token then it gets returned from the TokenController.\nUnfortunately I can't spin up my demo app easily to find out what caused this problem, so this issue might as well be closed and reopened if someone runs into an actual test case.\nThanks for your help!\n. ",
    "cardonr": "This problem can be solved by using\n$server->addGrantType(new OAuth2\\OpenID\\GrantType\\AuthorizationCode($storage));\ninstead of \n$server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($storage));\nwhen initializing the server.\nThe GrantType class AuthorizationCode in the OpenID package implements the createAccessToken function that add the id_token parameter when the Token Endpoint is called.\nThis should be documented on the OpenId Connect page.\nhttp://bshaffer.github.io/oauth2-server-php-docs/overview/openid-connect/\nNote that the Token EndPoint of the Demo application correctly return the id_token as expected.\n. Hi @bshaffer,\nAs already reported by @belerophon on 12 Mar 15, the Token Endpoint of a compliant OpenID Provider MUST always include an ID Token in the response.\nSee OpenID Connect Core 1.0 specification, point 3.1.3.3 \"Successful Token Response\": \n\nIn addition to the response parameters specified by OAuth 2.0, the following parameters MUST be included in the response: \n- id_token :  ID Token value associated with the authenticated session...\n\nFor this reason, a custom TokenController must be implemented for OpenId.\nPlease note that this applies for the Token Endpoint, and not the Authorization Endpoint for which an ID Token is returned depending on the value of the response_type parameter.\nKind regards,\nRodolphe Cardon\n. This problem can be solved by using\n$server->addGrantType(new OAuth2\\OpenID\\GrantType\\AuthorizationCode($storage));\ninstead of \n$server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($storage));\nThe GrantType class AuthorizationCode in the OpenID package implements the createAccessToken function that add the id_token parameter when the Token Endpoint is called.\nThis should be documented on the OpenId Connect page.\nhttp://bshaffer.github.io/oauth2-server-php-docs/overview/openid-connect/\n. ",
    "arundevpv": "I saw the same error. And i also found ,where is the problem happen. I'am using Pdo as storage medium.\nIn Oauth2/Storage/Pdo.php Line 317,\nif (!$userInfo = $stmt->fetch(\\PDO::FETCH_ASSOC)) { \n            return false;\n   }\nUndefined variable: userInfo in /var/www/html/oauth2/src/OAuth2/Storage/Pdo.php on line 317\nI changed that code to,\n$userInfo = $stmt->fetch(\\PDO::FETCH_ASSOC);\nNow it is working.\nNote:In db store the password in encrypted format ,use sha1().\n. I saw the same error. And i also found ,where is the problem happen. I'am using Pdo as storage medium.\nIn Oauth2/Storage/Pdo.php Line 317,\nif (!$userInfo = $stmt->fetch(\\PDO::FETCH_ASSOC)) { \n            return false;\n   }\nUndefined variable: userInfo in /var/www/html/oauth2/src/OAuth2/Storage/Pdo.php on line 317\nI changed that code to,\n$userInfo = $stmt->fetch(\\PDO::FETCH_ASSOC);\nNow it is working.\nNote:In db store the password in encrypted format ,use sha1().\n. ",
    "tom-park": "No problem, yes sorry about the lack of tests I am not too familiar with Travis CI and clearly some dependancies would need to be setup within the CI environment before any tests could be hooked up to it, otherwise I would just break your tests in this pull request till it is setup. Having had quick look through it all though and your tests, wouldn't be too difficult to assume a localhost Couchbase connection, like others, is available and I could write the tests as such if you would prefer.\n. I had added tests for the Couchbase storage type, the only thing required now is to prep the Travis environment so that a Couchbase server is running on localhost and always has a bucket called 'auth' created inside it running on the standard Couchbase port (or tweak the port in the bootstrap).\n. Already done so, the comment was added at the same time I committed them into the branch this pull request is linked to. So other than setting up a couchbase server, it should be done. With the other tests skipped, all Couchbase ones pass locally on my server (I don't have the local installs to test the rest locally, but the Auto Travis CI build just passed my branch again).\n. Although, as you state, Couchbase is the merging of the best features of two different projects. The result is actually drifting off into it's own direction to a large extent. The biggest problem in achieving one class for all is that the API is totally different between the two (one providing a HTTP API and one not) meaning adding two classes would always be the best solution anyway for adding CouchDB storage support (the data structures stored and the way it's done, would be the same though so if their were changes made to abstract the data structures away from the actual storing layer then you would find some crossover).\n. Yes you are quite correct, the API documentation specifically states that asking for a server count will indeed throw the CouchbaseException itself, this has been changed and committed.\n. ",
    "WitzHsiao": "Thank you @dashohoxha.\nBut is this the only way to do that? I want to follow the way that Facebook does.\n. sounds like a plan!\n. @bshaffer Sorry for reply lately. I've changed it to get ConsistenRead from config of DynamoDB.\n. @bshaffer Sorry, forgot this issue. Thanks for review. I have already fix the typo in the second commit.\n. ",
    "clawish": "+1 :+1: \n. Alright, very nice.\nI got the SQL from the cookbook:\nCREATE TABLE oauth_clients (client_id VARCHAR(80) NOT NULL, client_secret VARCHAR(80) NOT NULL, redirect_uri VARCHAR(2000) NOT NULL, grant_types VARCHAR(80), scope VARCHAR(100), user_id VARCHAR(80), CONSTRAINT clients_client_id_pk PRIMARY KEY (client_id));\n. ",
    "StyleT": "This flow definitely should be implemented in demo project\n. ",
    "mael-lg": "After some tests, it seems that claims are included in the ID token only in some cases...\nWhen the authorize request set response_type=code or reponse_type=token id_token, there are no user claims in the ID Token but when response_type=id_token, claims are included in the ID Token... \n. If it can help...\nTo fix it, I've overrided The  method createDefaultAuthorizeController of the class OAuth2\\Server and I replaced : \nphp\nif ($this->config['use_openid_connect']) {\n    return new OpenIDAuthorizeController($this->storages['client'], $this->responseTypes, $config, $this->getScopeUtil());\n}\nby : \nphp\nif ($this->config['use_openid_connect']) {\n    return new OpenIDAuthorizeController($this->storages['client'],$this->storages['public_key'], $this->responseTypes, $config, $this->getScopeUtil());\n}\nI've implemented a extend constructor in OAuth2\\OpenID\\Controller\\AuthorizeController wich has a OAuth2\\Storage\\PublicKeyInterface as parameter.\nAnd then, I've changed the buildAuthorizeParameters function  :\nphp\nif ($this->needsIdToken($this->getScope()) && $this->getResponseType() == self::RESPONSE_TYPE_AUTHORIZATION_CODE) {\n            $params['id_token'] = $this->responseTypes['id_token']->createIdToken($this->getClientId(), $user_id, $this->nonce);\n}\nwith :\nphp\nif ($this->needsIdToken($this->getScope()) && $this->getResponseType() == self::RESPONSE_TYPE_AUTHORIZATION_CODE) {\n            $userClaims = $this->publicKeyStorage->getUserClaims($user_id, $params['scope']); \n            $params['id_token'] = $this->responseTypes['id_token']->createIdToken($this->getClientId(), $user_id, $this->nonce, $userClaims); \n}\n. if I understand correctly, the id_token contains user claims only in this case : response_type=id_token (which is the only case which does not include in the response a way to get an access_token) ?\n. It was a mistake... a bad implementation of my part..\n. ",
    "produktive": "@almaruf I am having the same problem and I am using the same OAuth2 client. How did you fix this problem?. ",
    "Deep21": "Nice that's work perfectly for me.\nThank you Brent !\n. When I make a request with GET parameter like that \n?access_token=6124a7009484c6cc13d3283293a34fa197efa217 that's work, but it's is possible with headers ?\n. Hello I found a solution. \nIn the header I had to set Authorization Bearer bdc6bb86ee25bb64364cdd451ac2387351fecc6f\nThat's work !\n. Thank you @needcaffeine \n. ",
    "npmarrin": "The parse method from https://bitbucket.org/connect2id/oauth-2.0-sdk-with-openid-connect-extensions/src/816f01545ac0573ca2662a7e5dc807dee2d19baf/src/main/java/com/nimbusds/oauth2/sdk/ResponseType.java?at=master also defines the list according to  Section 5. I have not been able to find an example showing token id_token as a valid response type. Do you have an example to the contrary? \n. It looks like Google's OAuth 2.0 authentication API supports it in both formats. \" If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.\" https://developers.google.com/accounts/docs/OAuth2Login#response-type\n. I believe order matters. The draft spec used the words \"This section registers combinations\" and the final spec uses the words \"This section defines combinations of the values\". If you want to normalize for backwards compatibility as Google seems to be doing that would be fine however i would recommend the file name changes to be consistent with the current spec\n. The only issue I see is that line 191 of AuthorizeController.php should include an ltrim so that\n\"code%20%20%20id_token%20%20token\" doesn't come out like \"%20%20%20%20%20code id_token token\" as the spec allows for multiple %20 characters. \n$response_type = ltrim(implode(' ', $types));\nThank you for linking to the spec section for clarification.\n. ",
    "jversmis": "Some further info: we use Pdo as the storage type.\nIn the function checkClientCredentials, no client is found in the database. This means that $result['client_secret'] will also be empty which leads to the fact that the check return $result['client_secret'] == $client_secret; evaluates to true.\n. ",
    "SaniGit": "Hi @jversmis,\nDid you install the correct version of the oauth server or make some modifications to the php code of the oauth server ? \nJust tried using curl without client credentials : \ncurl http://someIP/my-oauth2-walkthrough/token.php -d 'grant_type=client_credentials'\nand the following error is received in the response:\n{\"error\":\"invalid_client\",\"error_description\":\"Client credentials were not found in the headers or body\"}\nNo token is granted, it is the correct behaviour.\n. ",
    "Franckrst": "thank you.\nI have learn this but i use Client Credentials and with this i can't have refresh token.\nNote: Refresh tokens are only provided when retrieving a token using the Authorization Code or User Credentials grant types.\n. Ok thank you !\n. ",
    "tozes": "Still needs some more work before pulling\n. Happy to help. Will try to get a new pull request soon.\n. ",
    "authyrtyr": "Thank you\n. ",
    "jaredtking": "Both excellent points. My bad on the array syntax slip. I will make those changes and resubmit.\n. I added a test that verifies the JWT claims are set properly in the resulting access token from createAccessToken()\n. Ah, sorry Brent! I must have picked up that other name in the issues.\n. ",
    "Maks3w": "This changes need to be forwarded to https://github.com/bshaffer/oauth2-server-php-docs\n. The second one is the expected for semantic versioning by Composer (https://getcomposer.org/doc/01-basic-usage.md#package-versions)\ncomposer require bshaffer/oauth2-server-php\nwill produce\n{\n   \"bshaffer/oauth2-server-php\": \"~1.6\"\n}\n. Proposed #665 as fix.\n. micro optimization by using the same result in both statements. \n. HHVM does not have this file. Just silently fail if Xdebug is not available\n. Also if you don't do test coverage this speed up the execution byu 2x or 3x\n. ",
    "twmobius": "Thanks @bshaffer  :)\n. ",
    "nssilva": "Thanks for the reply, i was confused because in the db the  expires date from refresh token stays the same shouldn't be updated to expire?\n. No the new refresh token as a new expire date but the old one stays untouch, is this normal?\n. I'm using PDo with firebird, i had to tweak a thing or two.\nthis are my server functions\nfunction grantType($storage) {\n        $grantType = new OAuth2\\GrantType\\RefreshToken($storage, array('always_issue_new_refresh_token' => true) );\n        return $grantType;\n    }\nfunction server($storage, $grantType) {\n    $server = new OAuth2\\Server($storage); \n    $server->addGrantType( new OAuth2\\GrantType\\ClientCredentials( $storage ) );\n    $server->addGrantType( new OAuth2\\GrantType\\UserCredentials( $storage ) );   \n    $server->addGrantType( $grantType ); \n    return $server;\n}\n//build storage database\n    $storage = storage();\n    //for refresh tokens\n    $grantType = grantType($storage);\n    //build server and pass grantType\n    $server = server($storage, $grantType);\nDo In need to do anything else?\n. I'm using PDo with firebird, how can i use that function? I'm new with oauth and this is all confusing. I'm using the basic implementation that you are using in the cookbook with user and password implementation.\ncan you care to provide some basic code so i can test it?\nThanks\n. here is the server implementation \n```\nrequire_once('/var/www//html/oauth2-server-php/src/OAuth2/Autoloader.php');\nrequire_once('/var/www/html/oauth/Database.php');\nOAuth2\\Autoloader::register();\nfunction storage() {\n    $database = new Database('localhost', 'OAUTH2.FDB', 'path', 'UTF8', 'user', 'password');\n    $database->setPdo();\n    $storage = new OAuth2\\Storage\\Pdo( $database->getPdo() );\nreturn $storage;\n\n}\nfunction grantType($storage) {\n    $grantType = new OAuth2\\GrantType\\RefreshToken($storage, array('always_issue_new_refresh_token' => true) );\nreturn $grantType;\n\n}\nfunction server($storage, $grantType) {\n    $server = new OAuth2\\Server($storage); \n    $server->addGrantType( new OAuth2\\GrantType\\ClientCredentials( $storage ) );\n    $server->addGrantType( new OAuth2\\GrantType\\UserCredentials( $storage ) ); \n    $server->addGrantType( $grantType ); \nreturn $server;\n\n}\n//build storage\n$storage = storage();\n//for refresh tokens\n$grantType = grantType($storage);\n//build server and pass grantType\n$server = server($storage, $grantType);\n```\nmy curl\nfunction send_receive2( $url, $param, $refresh=false, &$result=null ) {\n```\n    $handle = curl_init( $url );\ncurl_setopt($handle, CURLOPT_URL, $url);\ncurl_setopt($handle, CURLOPT_USERPWD, $param['client_id'].':'.$param['client_secret']);\ncurl_setopt($handle, CURLOPT_POST, true);\n\nif( $refresh ) { \n    curl_setopt( $handle, CURLOPT_POSTFIELDS, array('grant_type'=>$param['grant_type'], 'refresh_token'=>$param['refresh_token']) );\n} else {\n    curl_setopt( $handle, CURLOPT_POSTFIELDS, array('grant_type'=>$param['grant_type'], 'username'=>$param['user'], 'password'=>$param['password']) );\n}\n\ncurl_setopt( $handle, CURLOPT_RETURNTRANSFER, true );\n\n$result = json_decode( curl_exec( $handle ), true );\n$http_code = curl_getinfo( $handle,  CURLINFO_HTTP_CODE );\n\ncurl_close( $handle );\n\nif( $http_code == \"200\" ) {\n    return true;\n}\n\nreturn false;\n\n}\n```\nmy database screens\n\n\nmy field grant type in data base is empty, should it have password in it?\nAnd my token handler\n```\nrequire_once DIR.'/server.php';\n$server->handleTokenRequest(OAuth2\\Request::createFromGlobals())->send();\n```\n. Well it worked, strange cause i did not had this in the test database and it worked, why is that?\nIn my case i should only put password right?\nThanks\n. ",
    "donearh": "the same situation need more detail information about what we need to do if refresh token expired\n. Thanks for answer!\nNow I understand that if server send me response \"error: grant type, error_desc: refresh token is expired\" I need to log in user again. Its mean I need to check refresh token on expire on every server request where I use Oauth system.\nThe course of my actions:\nserver config: refresh token lifetime 14 days\n1. First I try to make a request to the server but the server returns that the access token is expired\n2. Then I try to update access token using the refresh token but the server also returns that refresh token is expired\n3. Not having received the token, I ask the user to log in again\nam I right? \n. You answered my question. You the best! \n. ",
    "dd3v": "hi, how to fix it? \n. ",
    "vetcoder": "Sorry for my bad English since i'm francophone. I solved this problem by specifying 2 headers in the request: Content-Type: application/json & Accept: application/json. Note: i'm using RestClient plugin for mozilla firefox for pulling requests to Server.. Sorry for my bad English since i'm francophone. I solved this problem by specifying 2 headers in the request: Content-Type: application/json & Accept: application/json. Note: i'm using RestClient plugin for mozilla firefox for pulling requests to Server.. ",
    "paulstatezny": "I mistakenly thought that the Request being used was an HttpFoundation request, hence the failing tests. I ported a modified version of HttpFoundation\\Request::get to OAuth2\\Request::get.\nAdded tests for the get method.\n. @bshaffer Thanks for pointing out that info from the spec. Just what I was looking for but wasn't able to locate.\nI'm not too concerned about Client ID -- just the user's password since authorize request endpoints tend to require that as part of the authentication.\n\nThe way in which the authorization server authenticates the resource owner (e.g., username and password login, session cookies) is beyond the scope of this specification.\n~ Section 3.1\n\nRebased into a single commit. Thanks!\n. ",
    "zenkiboy": "Yes. Thank you. \n. ",
    "sandinosaso": "That is fine I understand now. I Copy the PDO Storage class and made a new one PDOMemCache, this class use Memcache for caching in memory (MemCache is super fast) so when user is asking for a resource in the getAccessToken method I run the query against the database only first time if I have not in memcache, I save the result for future use, let say you got a memcache 10 min its ok. This way I avoid the overhead of making a sql query to the database each time, think about an api writted for an phone app and that a phone app calls many time to the api with the same token, this multiplies by the numbers of user using the app it a huge number, I am implementing an api that will be used widely by android, iphone, windows phone it must by really fast.\nI do some apache benchmark for some service I provide and time is really important, for example\nmaking 1000 request 100 per second when using memory directly it takes 2.757 seconds and when using PDO against mysql same requests takes 10.935 seconds, that is not affordable for me, now using memcache it takes 3.206 seconds that pretty good. I would like to make a pull request if you are interested in this kind of ideas, currently I modified only one function but this aplies for every query PDO makes, maybe it would be a new Storage PDOMemCache or PDO with an option of using memcache or not\nThis is what I did:\n``` php\n/ OAuth2\\Storage\\AccessTokenInterface /\n    public function getAccessToken($access_token)\n    {\n        $stmt = $this->db->prepare(sprintf('SELECT * from %s where access_token = :access_token', $this->config['access_token_table']));\n    $cacheKey = 'query-'.md5(serialize(array($stmt->queryString, compact('access_token'))));\n\n    # Try and get from memory\n    $checkCache = $this->memcache->get($cacheKey);\n\n    # We have some data\n    if(!empty($checkCache)) {\n        return $checkCache;\n    }else{\n        $token = $stmt->execute(compact('access_token'));\n        if ($token = $stmt->fetch()) {\n            // convert date string back to timestamp\n            $token['expires'] = strtotime($token['expires']);\n            $this->memcache->set($cacheKey, $token, 0, 600);\n        }\n    }\n\n    return $token;\n}\n\n``\n. WooooW that would be really helpfull can this be added to the Main repo, \nAnd the only other function it must implement ispublic function setAccessToken($oauth_token, $client_id, $user_id, $expires, $scope = null);`\nI think this method will always have to update the token in the passed $storage and also in mem_cache ?..\nThe only requeriment for this to work is having mem_cache enabled in php so I think is a great solution for making apps calls for resources super fast, maybe de 600 seconds time may be a parameter as well as you may need to choose how much your memcache is valid or can use the same time you used for accessToken.\nThe only thing you have to add is a first line to include Memcache\nlike use Memcache\nWhat do you think? I can implement it and share some benchmark showing it benefits, what I must do to get a pull request approved by you?\nRegards.\nSandino.\n. I have done it, I need your help with the test, I run phpunit and get the error:\nThe data provider specified for OAuth2\\Storage\\AccessTokenTest::testSetAccessToken is invalid.\ncould not find driver\nFor every test, what I messed up, is something that needs to be configured before running test?, Is there any documentation on running tests somewhere?.\nRegards.\nSandino\n. I never did but I can if you let me, the code is really simple as bshaffer suggested I implemented passing a valid storage, so I am using PDO storage with a mysql database and usign Memcache to faster retrieve access tokens\n``` php\nnamespace OAuth2\\Storage;\nuse Memcache;\nclass MemCacheToken implements AccessTokenInterface\n{\n    protected $storage;\n    protected $memcache;\npublic function __construct(AccessTokenInterface $storage, $config=array())\n{\n    $this->storage = $storage;\n\n    $this->memcache = new Memcache;\n\n    $host    = isset($config['host'])    ? $config['host']    : 'localhost';\n    $port    = isset($config['port'])    ? $config['port']    : 11211;\n    $timeout = isset($config['timeout']) ? $config['timeout'] : 1;\n\n    $this->memcache->connect($host, $port, $timeout);\n}\n\npublic function getAccessToken($access_token)\n{\n    $cacheKey = 'storage-'.$access_token;\n\n    # Try and get from memory\n    $accessToken = $this->memcache->get($cacheKey);\n\n    # We have some data\n    if(!empty($accessToken)) {\n        return $accessToken;\n    }\n\n    $accessToken = $this->storage->getAccessToken('access_token');\n    $this->memcache->set($cacheKey, $accessToken, 0, strtotime($accessToken['expires']));\n\n    return $accessToken;\n}\n\npublic function setAccessToken($oauth_token, $client_id, $user_id, $expires, $scope = null)\n{\n    $cacheKey = 'storage-'.$oauth_token;\n\n    $this->storage->setAccessToken($oauth_token, $client_id, $user_id, $expires, $scope);\n    $updatedAccessToken = $this->storage->getAccessToken($oauth_token);\n\n    $result = $this->memcache->replace($cacheKey, $updatedAccessToken, 0, $expires);\n    if( $result == false ) \n    { \n        $result = $this->memcache->set($cacheKey, $updatedAccessToken, 0, $expires);\n    }\n\n}\n\n}\n```\nFor use it just do\n``` php\n        try {\n            $pdotokenStorage = new OAuth2\\Storage\\Pdo(array('dsn' => $dsn, 'username' => $username, 'password' => $password));\n        }catch(PDOException $e) {\n            //Send email with error\n            Yii::app()->EmailSenderComponent->send('Database Error', $e->getMessage());\n                        //Log the error\n            Yii::log('Database error :'.$e->getMessage(), 'error', 'application.ApiController.init');\n            $this->_sendResponse(500, json_encode(array ('status'=> 500, 'message'=> 'Internal error contact the admin', 'code'=> 20003)), array('Content-type'   => 'application/json') );\n        }\n        // USING PDOMEMCACHE\n        $tokenStorage = new OAuth2\\Storage\\MemCacheToken($pdotokenStorage);\n```\nYou can also pass an array of parameter to choose wich MemCache server you want to connect\nLike this $tokenStorage = new OAuth2\\Storage\\MemCacheToken($pdotokenStorage, array('host' =>'YOURHOST', 'port'=>YOUR_PORT_NUMBER));\n. I created a pull request https://github.com/bshaffer/oauth2-server-php/pull/608\n. Here is a benchmark first with PDO to a local mysql database, the second the same PDO but MemCache powered :+1: \n``` sh\nApache Test against api endpoint\n 1000 request in 100 request step\nResults\nWith PDO            Time taken for tests:   16.339 seconds\nWith MemCache  Time taken for tests:   10.778 seconds\n\n\nWith PDO Only\nab -n 1000 -c 100 http://localhost/yii/apiv99/resource-server/json/rubros?access_token=363945d473218fcbaa8de0bdcd7d0b00769977ba\nThis is ApacheBench, Version 2.3 <$Revision: 1638069 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\nBenchmarking localhost (be patient)\nCompleted 100 requests\nCompleted 200 requests\nCompleted 300 requests\nCompleted 400 requests\nCompleted 500 requests\nCompleted 600 requests\nCompleted 700 requests\nCompleted 800 requests\nCompleted 900 requests\nCompleted 1000 requests\nFinished 1000 requests\nServer Software:        Apache/2.4.12\nServer Hostname:        localhost\nServer Port:            80\nDocument Path:          /movistaryii/apiv99/resource-server/json/rubros?access_token=363945d473218fcbaa8de0bdcd7d0b00769977ba\nDocument Length:        2980 bytes\nConcurrency Level:      100\nTime taken for tests:   16.339 seconds\nComplete requests:      1000\nFailed requests:        0\nTotal transferred:      3177000 bytes\nHTML transferred:       2980000 bytes\nRequests per second:    61.20 [#/sec] (mean)\nTime per request:       1633.909 [ms] (mean)\nTime per request:       16.339 [ms] (mean, across all concurrent requests)\nTransfer rate:          189.88 [Kbytes/sec] received\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    1   3.9      0      14\nProcessing:   273 1406 895.1   1134   10112\nWaiting:      273 1406 895.0   1134   10111\nTotal:        273 1408 896.2   1134   10112\nPercentage of the requests served within a certain time (ms)\n  50%   1134\n  66%   1592\n  75%   1800\n  80%   1909\n  90%   2440\n  95%   2804\n  98%   3785\n  99%   4062\n 100%  10112 (longest request)\n\nWith PDO + MemCache\nsandino@envy:~$ ab -n 1000 -c 100 http://localhost/yii/apiv99/resource-server/json/rubros?access_token=363945d473218fcbaa8de0bdcd7d0b00769977ba\nThis is ApacheBench, Version 2.3 <$Revision: 1638069 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\nBenchmarking localhost (be patient)\nCompleted 100 requests\nCompleted 200 requests\nCompleted 300 requests\nCompleted 400 requests\nCompleted 500 requests\nCompleted 600 requests\nCompleted 700 requests\nCompleted 800 requests\nCompleted 900 requests\nCompleted 1000 requests\nFinished 1000 requests\nServer Software:        Apache/2.4.12\nServer Hostname:        localhost\nServer Port:            80\nDocument Path:          /movistaryii/apiv99/resource-server/json/rubros?access_token=363945d473218fcbaa8de0bdcd7d0b00769977ba\nDocument Length:        2980 bytes\nConcurrency Level:      100\nTime taken for tests:   10.778 seconds\nComplete requests:      1000\nFailed requests:        0\nTotal transferred:      3177000 bytes\nHTML transferred:       2980000 bytes\nRequests per second:    92.78 [#/sec] (mean)\nTime per request:       1077.785 [ms] (mean)\nTime per request:       10.778 [ms] (mean, across all concurrent requests)\nTransfer rate:          287.86 [Kbytes/sec] received\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    1   2.1      0       8\nProcessing:   162 1049 375.8   1000    2632\nWaiting:      158 1049 375.8    999    2632\nTotal:        165 1050 376.2   1000    2639\nPercentage of the requests served within a certain time (ms)\n  50%   1000\n  66%   1144\n  75%   1244\n  80%   1337\n  90%   1585\n  95%   1784\n  98%   1977\n  99%   2076\n 100%   2639 (longest request)\n```\n. ",
    "zubairasghar": "Actually i am using windows machine, and in cmd it does not support these quotes, so what i did is i post through a web page then it works :-) thanks for help anyways\n. ",
    "pbfteambox": "I just created pull request #475 as requested!\n. Actually I have read the documentation. But I still don't get in what situation one needs a JWT Token.\nDo you have examples at hand of services that would need this feature ?\nAlso, is it desirable to create JWTToken for all case where an access token would be generated ?\nBest  regards,\nPatrick.\n. Ok thanks for that little bit of information. This is what was missing from the doc page (which is otherwise complete), for me!\n. ",
    "letsjustfixit": "@gwillings nice catch of that \ud83d\udc43\ud83d\udc1b  typo :) \ud83d\udc4d \n audience vs audiance\nUncaught PDOException: SQLSTATE[42S22]: Column not found: 1054 Unknown column 'audience' in 'where clause' in [..]\\vendor\\bshaffer\\oauth2-server-php\\src\\OAuth2\\Storage\\Pdo.php on line\naudiance            VARCHAR(80),. Invalidate the token within the middleware right after the validation.(revoke token). @Faryshta \nhttps://github.com/bshaffer/oauth2-server-php/blob/master/src/OAuth2/Controller/TokenController.php#L294. audience            VARCHAR(80),. ",
    "sureshsharma": "Hi Brent the earlier issue is resolved.\nNow there is another issue with Grant_type: User Credentials.\nWhile trying to implement user credential grant type got error: \n\" {\"error\":\"unsupported_grant_type\",\"error_description\":\"Grant type \\\"password\\\" not supported\"} \".\nWe have used Curl in our php code.\nMy php code is: \nphp\n\n<pfunction auto($url,$data)\n{\n$username='TestClient';\n$password='TestSecret';\n$URL='http://localhost/oauth_exp/token.php';\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL,$URL);\ncurl_setopt($ch, CURLOPT_TIMEOUT, 30); //timeout after 30 seconds\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER,1);\ncurl_setopt($ch, CURLOPT_USERPWD, \"$username:$password\");\ncurl_setopt($ch, CURLOPT_POSTFIELDS, $data);\n$result=curl_exec($ch);\ncurl_close ($ch);\nreturn $result;\n}\n$URL='http://localhost/oauth_exp/token.php';\n$data=array('grant_type' => 'password', 'username' => 'bshaffer', 'password' => 'brent123');\nprint_r($data);\ndie;\necho auto($URL,$data);\n?>\nPlease let me know where i am mistaken. \n. ",
    "sarciszewski": "Oh. You want 40 hexits not 40 random bytes.\nbin2hex($str) and pack('H*', $str) serve this purpose.\n. Right. Let me send a PR with a proposed change.\n. http://php.net/manual/en/function.hash-equals.php - Available in PHP 5.6; otherwise, a pure PHP implementation is provided.\n. Sure thing. Don't worry, most OAuth libraries fall prey to the same vulnerability, and it RARELY get exploited.\nTiming attacks are noisy and not trivial to pull off.\n. This attempts to compare strings in a way that does not leak timing information.\nhttp://blog.astrumfutura.com/2010/10/nanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously/\n. You're comparing a cryptographic secret. (Specifically, a signature.)\n. Sure. One moment :)\n. ",
    "ShurikAg": "Thanks a lot for clarification! That is definitely helpful!\n. ",
    "Michal-sk": "This is an old issue, but ill mention it anyway. Make sure you check your php.ini for the arg_separator.output setting, that might be set to &amp;\n. ",
    "elliotrock": "Just checked and my php version is 5.3.3, going to update that first.\n. decided to run the legacy version as I am on a CentOS server and it has moved passed the errors above.\nI shall close this.\n. ",
    "mcondave": "It was the resource.php from the tutorial here http://bshaffer.github.io/oauth2-server-php-docs/cookbook/. It's likely an error on my part but I can't understand what I did that would cause it.\n. ",
    "lukestokes": "A security researcher brought this to our attention recently as well.\nA registered URL of foobar.com would also match foobar.com.someevildomain.com or even foobar.comeonpeople.someevildomain.com\n@dmalan: did you put together a patch for this?\nI'm not sure of the best approach, but it seems if the input uri is longer than the registered uri, then the next character (or two) has to be either ?, &, or /?. Does that sound right?\n. Actually, turns out we had require_exact_redirect_uri on all along anyway and the security researcher was looking at a different, older system. Either way, something like this might work, though again, I'm not sure if it's the best approach in the else there:\nif (strlen($inputUri) > strlen($registered_uri)\n                    && strcmp(substr($inputUri, 0, strlen($registered_uri)), $registered_uri) === 0\n                    && (substr($inputUri, strlen($registered_uri), 1) === '?'\n                        || substr($inputUri, strlen($registered_uri), 1) === '&'\n                        || substr($inputUri, strlen($registered_uri), 2) === '/?')\n                    ) {\n                    return true;\n                }\n. ",
    "Spomky": "The correct encoding is base64_encode(ClientId:ClientSecret);\n. This PR is a good idea (after the change above). \nThis library should not rely only on the global variables. With some servers, they are not set and a check on the Authenticate header will fix this. \n. With PH-CGI or PH-FCGI for example. \n. This grant type flow was removed, but the Implicit grant type flow does not superseded it. \nGoogle for example still have an implementation of this grant type. It is reality helpful for apps on TV screens for example. \n. The redirect URI for apps is in general urn:ietf:wg:oauth:2.0:oob or http://localhost.\nHave you tried with these URIs?\nSee https://developers.google.com/identity/protocols/OAuth2InstalledApp.\n. Furthermore to the answer provided by @danopz and as per the RFC6749 section 3.1.2, the redirection URI must not contain a fragment parameter.\nThe given redirect URI (https://www.example.com/#/oauth2) should be rejected by the server.. ",
    "justb3a": "I changed the comment to a colon, added a test case and rebased it to an single commit\n (https://github.com/justonestep/oauth2-server-php/commit/baa30458abf258fe856ed9b4492ea619ef936431).\n Do I need to send a new pull request or is there another way to submit my changes?\n. I have no change to reopen this issue (button is deactivated \"The feature/.. branch was force-pushed or recreated\"). So I created a new PR. Thanks!\n. ",
    "spectravp": "Ack! Wish I found that sooner. LOL. I never saw that that was documented inline in the code. \n. Of course, I would leave it inline in the code, but what about adding it to this page of the documentation under \"Requirements\" or \"Installation\"? http://bshaffer.github.io/oauth2-server-php-docs/\n. ",
    "djhunx": "Hi, I find that an empty string ' ' is being passed to the  setAccessToken and setRefreshToken functions when there is no default scope in the oauth_scopes table in dynamodb. On second thought, do you think it's better to expect a null value when we don't intend to pass a scope into the function ?\nWhen no scope is passed, the scope is taken from the getDefaultScope() function of the storage and it returns the empty string when there is none set in the database.\nThe function can be modified to return null instead like\nbshaffer\\oauth2-server-php\\src\\OAuth2\\Storage\\DynamoDB.php\n```\npublic function getDefaultScope($client_id = null)\n    {\n    $result = $this->client->query(array(\n        'TableName' => $this->config['scope_table'],\n        'IndexName' => 'is_default-index',\n        'Select' => 'ALL_ATTRIBUTES',\n        'KeyConditions' => array(\n            'is_default' => array(\n                'AttributeValueList' => array(array('S' => 'true')),\n                'ComparisonOperator' => 'EQ',\n            ),\n        )\n    ));\n    $defaultScope = array();\n    if ($result->count() > 0) {\n        $array = $result->toArray();\n        foreach ($array[\"Items\"] as $item) {\n            $defaultScope[]  = $item['scope']['S'];\n        }\n        return empty($defaultScope) ? null : implode(' ', $defaultScope);           \n    }\n\n    return null;\n}\n\n```\nIn line 414, change\nreturn implode(' ', $defaultScope);\nto\nreturn empty($defaultScope) ? null : implode(' ', $defaultScope);\nIf you agree, could you also suggest how to write the test. The default scopes in the oauth_scopes table created on bootstrap have to be cleared to test for this use case. \n. not a problem. thanks for looking into it.\n1.  we are using it now on a project we are working on. I'd say yes, this implementation allows us to let the client_secret and/or scope have null values. It fixes the error in a situation where the scope is null and there's no default scope defined in the database.\n2.  i'm glad to squash the commits into one. (my first time to do it)\n. ",
    "ianhaycox": "Hello,\nI have a similar problem, which may be the intended behavior, where the client_id gets overwritten when using the password grant_type.\nFor example, using a client_id of 'txxx'\ncurl http://localhost:81/ -H \"Content-Type: application/json\" -d '{\"grant_type\":\"password\",\"client_id\":\"txxx\",\"username\":\"test\",\"password\":\"test\"}'\nPutting the username/password in the body returns an access token.  However, using Basic authorization and not passing the username/password in the body fails.\ncurl -u test:test http://localhost:81/ -H \"Content-Type: application/json\" -d '{\"grant_type\":\"password\",\"client_id\":\"txxx\"}'\nThe client_id and client_secret get set to 'test' and 'test'. Looking in OAuth2\\ClientAssertionType\\HttpBasic the getClientCredentials() method,\nif (!is_null($request->headers('PHP_AUTH_USER')) && !is_null($request->headers('PHP_AUTH_PW'))) {\n            return array('client_id' => $request->headers('PHP_AUTH_USER'), 'client_secret' => $request->headers('PHP_AUTH_PW'));\n        }\nI can see that the client data is overwritten by the authorization header, ignoring the client_id specified in the body.\nIs this intended, or am I misunderstanding how the UserCredential grant type works ?\nThanks.\nIan.\n. ",
    "HiBigBob": "@aacotroneo @bshaffer I raise the subject !  Can I use this to implement SAML2 into my oauth2 server ?   Is it stable ? Can you merge this PR ? Thank you for your comeback !!\n. ",
    "mdwheele": "In the case you are separating Resource Server from Authorization Server, the OAuth2 specification does not explicate how exactly the resource server verifies tokens it receives from Client Applications. A pragmatic approach is to expose a token verification (/verify_token) endpoint on the Authorization Server that accepts an access token. It would then be expected to return information about that token (user_id, scopes, etc.).  It may also be a good idea to figure out a way to establish a trusted relationship between Resource Servers and the Authorization Server in order to do this verification. It's not the end of the world per se, but you probably don't want just anybody to be able to verify a token to retrieve it's identifying information.\nI'm actually in the process of implementing this now and am looking at this package versus the League's version to determine which one will be an simpler integration to maintain. \nKeep in mind that your \"many Rest api\" is \"many Resource Servers\" and your \"OAuth2 server\" is actually a proposed centralized \"Authorization Server\".  The 90% use-case, unfortunate to you and I, is that most implementations can get away with Auth. and Resource Server being in the same stack.  For most use-cases, this is more than enough. Unfortunately, when that influences package APIs, it creates friction!  \nEither way, great package. Looking forward to attempting to plug it in :) \n. ",
    "zerrvox": "Any timeline on this?\n. @Lansoweb I really like the solution with returning response interfaces as well, then if it is already an psr-7 ready application you can just return the response directly if you don't need additional error handling.\nMaybe create an extended version of the response object, OAuthErrorResponse or similar named, which can hold additional error information you can access if you want to do specific error handling. \nToday In our application we are using the Symfony bridge and if it is an response with $response->isSuccessful() equals false, we alway just return it directly without doing any extra error handling. An solution with error response objects would allow similar behaviour.\nAnother solution could be to always return a boolean on calls such as  ResourceController::verifyResourceRequest and TokenController::revoke and then make a response object available through another method such as ResourceController::getErrorResponse. ResourceController::getAccessTokenData could either return false or empty array that you would have to test against to make sure it was succesful.\nIn this way you could always expect handle request to return response objects and all other methods you would have to to request the errorResponse explicit.\n. ",
    "benbor": "+1 \n. ",
    "danopz": "Maybe we should just throw some Exceptions on error and return the expected type.\nAs right now errors result in different responses - so it will be possible using Exceptions and transform them to that response on catch.\n. And return type would stay bool. I think this would be a good solution.\n. What about passing in the updated table names in config (constructor) to overwrite default ones?\n. Also there is a nice Demo-implementation on https://github.com/bshaffer/oauth2-demo-php.\n. What do you think why this library is named oauth2-server? Actually WP OAuth Server is using this library as base.\n. How or when to clean tokens is on your site/your decision. But on request it may take longer to respond.\nPhp 5.2 is outdated for about 5 years (http://php.net/eol.php), nobody should support that old version.\n. I like this approach. Could you add some very descriptive doc-blocks in that change pls. :smile: \n. Perfect for some contribution, don't you think so? :wink: \nLooks like this has to be a new Storage for BC.\n. Ah I've found that #697 adds this storage too\n. You don't have to use createFromGlobals, you can just create your own Request:\nnew Request();. What do you want to say to us?. This is application specific. The fragment MUST be the last part of the URI and the query part is before that. You try to add the query part inside of the fragment part - all after # is fragment - which results in an URI without query params.\nSo how are we able to get https://www.example.com/?code=2sadkfa3378dsadj&state=1#/oauth2?. > Argument 1 passed to OAuth2\\Server::handleTokenRequest() must be an instance of OAuth2\\RequestInterface, instance of yii\\web\\Request given, called in /WebServer/yii2/yiishop/vendor/filsh/yii2-oauth2-server/Server.php on line 39 and defined\nIssue here is you are passing in a yii Request where a OAuth Request is expected. You have to create an OAuth Request object and pass this one into the lib.. - [ ] Add GitHub topics/tags. This would not really make it to core. The plan is already to go with PSR-7, there is just no implementation right now.. Duplicate of #928 . https://bshaffer.github.io/oauth2-server-php-docs/. ref #940 \nLooks like this is just a config value provided from the dev? If thats the case this shouldn't be neccessary because you should just set an int value in the config.. Remove this pls\n. ",
    "Lansoweb": "@bshaffer The problem with the &$error solution is that you need to handle different scenarios with the array. You can have just and array with an error code and message, you to add some headers like tokenController: grantAccessToken  or parameters like in tokenController:handleRevokeRequest.\nYou will end up with a large method (or some small ones, like now) to handle all those. \nWhat if you return the ResponseInterface like you first proposed? Than the complexities of the error response falls with each method that needs them. So, in most error cases, you will just need:\nphp\n$response = $response\n    ->withStatusCode(400)\n    ->getBody()->write(\"The grant type was not specified in the request\");\nOr\nphp\n$response = $response\n    ->withStatusCode(405)\n    ->withAddedHeader('Allow', 'POST')\n    ->getBody()->write(\"'The request method must be POST when requesting an access token'\");\nJust need to handle content-type (html, json or xml) and body format accordingly.\nIf it's a redirect response, just use RedirectResponse.\n. @zerrvox True. If the return of a method is a Response (ErrorResponse, RedirectResponse, etc), we could just return it directly. \nWe could have something like a ContentTypeDecorator injected to the controllers, so they can call it to format the body (son ou xml).\nWell ... just saw a new branch called psr-7 with most of this already implemented =) And Brent already implemented the &$errors approach.\nAnother consideration @bshaffer, is that Diactoros requires php >= 5.4 (uses traits) and this lib requires >= 5.3.9, so we should increase the php minimum version with this new version.\n. @codeliner I'm too trying to use this with zend-expressive. For now i'm using a wrapper middleware around this library, but would be better if we have \"native\" support for middleware (either as 1 or 3).\n. @codeliner Not yet, but i can link the code somewhere. But i'm at home now (20:11), will do tomorrow at work ok?\n. @codeliner It simply creates a oauth2-server from a factory and injects it in my middlewares (constructor) that are also created by factories, and each middleware uses accordingly it's necessity (much like zf-oauth does)\n. @codeliner @bshaffer Me too.\n. @codeliner Apigility 2 will be middleware, so they will refactor other modules (zf-oauth specifically) to PSR-7, but no ETA yet ...\n. @basz Hi! I needed this for a big project that is micro-service oriented, but since expressive is not stable yet (still on RC) and we still have some changes on that, we decided to stick with apigility (v1) on our micro-services. So i stopped the work on this middleware :-(\n. @basz But there is already a branch here to psr-7, but it's not release yet: https://github.com/bshaffer/oauth2-server-php/tree/psr-7\n. ",
    "tthiery": "First of all +1. This issue is really important.\nI am a strict advocate of using only one return type instead of \"mixed\" return types. Also, @bshaffer is right, for normal cases, exceptions are the wrong method (they are not exceptional then). Using an extra out parameter (&$errror) is just a strange way to implement a result with more than one value.\nI would recommend returning a type with a status (true/false) property and a prepared response object property if required (like @zerrvox proposed).\nAlso do not be afraid of breaking your class design/contracts here (and also raise the PHP level a bit). For most users, changing to PSR-7 is anyway a big breaking thing. The bindings to this libraries anyway need to be rewritten. A nice transition tutorial is all what would be required for that.\nI am using Slim Framework 2.5 and just a few days ago build a ugly bridge to this library. With Slim Framework 3.0 and a new version of this library ... yeahhhh!\n. And another similar issue. For whatever reason the original symfony HttpFoundation Request is not containing the authorize header. Taking the authorize header using getallheaders and injecting it later in the header bag, will make the thing working.\nFile a extra issue if you like for it.\n. @bshaffer i am using apache\n. @bshaffer .. With your httpfoundation bridge you support laravel so the issue has to be analyzed starting there. Either they have changed the interface contract (@hannesvdvreken can you make a statement here) and then your adaptation is wrong ... or laravel has a bug.\nI am back to PHP programming after 10 years of absence. I have not idea/feeling how laravel should correctly behave. But since it is an reviewed PR in the laravel project ... I assume so far it is a contract change .. and therefore your issue in your projects.\n. If you fix it in the HttpFoundationBridge .. that is fine for me. Sounds like a solution. I agree, that it is the  wrong place to do it in your server library. The bridge is in the end an adapter pattern responsible exactly for issues like this one.\nDo not forget the second issue (first comment) ... similar case.\nShift the bug to the http foundation bridge! Thanks @bshaffer \n. @JerryBels actually, i unset to POST body by just assigning a new ParameterBag. something like  \nphp\n$request->request = new \\Symfony\\Component\\HttpFoundation\\ParameterBag();\nand for the second topic\nphp\n$rawHeaders = getallheaders();\nif (isset($rawHeaders[\"Authorization\"])) {\n     $authorizationHeader = $rawHeaders[\"Authorization\"];\n     $bridgedRequest->headers->add([ 'Authorization' => $authorizationHeader]);\n}\n. @JerryBels \"Bearer token\" is IMHO correct.\n. 2 issues\n- replace Request::instance() with $request\n- move the rewriting of the laravel/smyfony request before the creation of the bridge.\n. ",
    "codeliner": "@bshaffer I'd prefer your first suggestion: https://github.com/bshaffer/oauth2-server-php/issues/523#issuecomment-149941966\nWhenever ResponseInterface is returned it should be used as response no matter if it is an error response or not.\nThe better alternative would be to rewrite everything as middleware. If no error occurred call next middleware otherwise return ResponseInterface\n. These\n- AuthorizeController::handleAuthorizeRequest\n- ResourceController::getAccessTokenData\n- TokenController::handleTokenRequest\nlook like different endpoints which in turn should be different middleware. But I don't know the internals of your library. Just used it together with Apigility in the past. Looking for a way to add oauth2 to zend-expressive. However, if the entire oauth2-server should act as a single middleware then +1 for: https://github.com/bshaffer/oauth2-server-php/issues/523#issuecomment-149941966\n. @Lansoweb is your wrapper middleware open source? Link? :)\n. @Lansoweb awesome! Would be nice to take a look.\n@bshaffer sounds good. Let me know if you need help. Next two weeks I'll be busy with prooph components but then I have some time and we need PSR-7 oauth2 in January because we'll refactor an Apigility project to use expressive instead (oauth2 endpoints should continue to work without changes in the client) So I'd like to help to get PSR-7 support\n. ",
    "basz": "@Lansoweb mind sharing that link again?\nps. I'm guessing as soon as zend-expressive lands as 1.0.0 work will commence on apigility 2.0\n. ha, ok thanks\n. hi @bshaffer could you please have a look at https://github.com/zfcampus/zf-oauth2/issues/103\nare you able to clarify if I am making a theoretical mistake, apigility has a bug, or a problem exist with the oauth server. thanks a mill\n. @bshaffer all good - thanks!\n. I think - but I've been out of oauth for a bit- that this is correct and intended behavior...\n. ",
    "pabloroca": "+1 I am totally for this.\nHow is the status?\n. ",
    "xles": "+1\n. ",
    "lucasantarella": "+1\n. It would make sense that the client should need to be authenticated in order to revoke a token. This would prevent malicious people potentially revoking tokens constantly, inhibiting client access.\n. Hey,\nThanks for taking a look. I'll get working on the tests, that shouldn't be too big of a problem.\nI tried to adhere as closely as I could to the PDO Storage code. Could point out some places were I should make the code more consistent with the rest of the library?\nBy boilerplate code, do you mean the model files? Those are needed for the library to function. I don't think there is anyway to get around having those model files. I can tone down the PHPDoc if that helps at all.\nThis library works with PDO inherently. Really, it works with a ton of storage options (MySQL, PostgreSQL, SQLite, and Oracle).\n. For reference, here is the Phalcon documentation about the models and how to use them. The other option could be to use PHQL (Phalcon's dialect of SQL) to use in the library instead of all the Model::find([]) lines.\n. Even with PHQL, there still needs to be a model class defined for each table, even though it would be significantly cut down (only the public vars would need to be defined and the initialize() function). I could put all these classes at the bottom of the Phalcon.php file and have all the classes in one file, maybe that would help with the consistency of the repo. Let me know what you think.\n. I believe the test is going to fail straight-up right now. I have to add the TravisCI config for Phalcon since it's a PHP extension. Also, it's not compatible with PHP7.\n. @bshaffer Hope you enjoyed the holiday! I'm working with one of the Phalcon dev's to get PHP 5.3 build working in Travis CI. Seems to be a travis problem about not installing the Phalcon extension. Otherwise, the tests should work fine. The library will work on any Phalcon 2.x.x and up installation, and that includes PHP >= 5.3\n. Stumbling through the documentation, I found that you can use a function instead of a class. This allows the return array() to be used and negates the need for a special class. Sorry about the confusion! I didn't know myself.\n. Fixed all tests. \n. Hi @bshaffer I finally finished the tests and logic for this PR. What do you think about merging?\n. @janzankowski I believe that would be the functionality of an OAuth2 Client. If you are looking to add a \"Login with Google\" button on your service, you might want to look at ThePHPLeague's OAuth2 Client\nIf you mean you want to be a provider of the \"Login with MyService\" button (users will use your service to authenticate themselves on other OAuth2 consumers) then the answer YES! That is just an Authorization Grant Type flow, which this library definitely supports.. @duythien Where do you think I should put it? Root of the library or in the storage folder?\n. Ah, got it. Thanks for pointing them out. I'll clean it up ASAP. What do you\nthink about all the model files though? Too much for the style of the repo?\n. @bshaffer I was trying to do that, but I ran into a problem. It's really due to the nature of Phalcon.\nPhalcon projects use a Dependency Injector to manage data interactions between model classes and everything else. The reason for this is that when calling model classes, its is done statically. That means there is no way to pass table names in a one-stop-shop fashion to the models unless you do it every time you statically call the Model::find($tableName, $parameters) or something like that. The way I accomplished this is to take a Dependency Injector $di and add a custom service to it and pass it on to all the models once. This way, all the models can just reference that service in the $di when they need to lookup table maps. The catch, though, is that a $di service must be an instance of a class, ANY class, so I just made a holder class to hold the information while passing to the models. \nIt's not the most elegant way, but if you can find a better solution I'd seriously love to use it because I know this is the ugliest way to accomplish this task.\n. My bad... I'm kinda new to Travis and I've really only used a couple times, let alone with Phalcon. I'll fix it up right away.\n. I believe so. I'll branch and try it out. Would this be preferable? I always liked explicitly constructed models. I'll work it out and see if it works.\n. ",
    "northern": "+1\nJust a comment on the use of exceptions for error handling. This is exactly a scenario where you would use exceptions, I mean, if exceptions are not suitable for this scenario then please give an example of when exceptions are supposed to be suitable.\nReturning multiple data types is obviously a total no no. Error handling by using a parameter in which errors are returned is in my opinion clumsy at best because it allows the caller to simply ignore errors completely.\nExceptions are used when you deviate from the intended code path. In a normal circumstance the method should end at it's return statement. If something doesn't validate or is erroring otherwise and the method is prevented from completing its intended code path, that \"is\" the exception. I.e. an exception to the intended code path.\nBy throwing named exceptions will allow the caller to implement fine grained error handling, generic error handling, or, when exceptions are ignored they simply bubble up to the top. In any event, when something is supposed to work but it isn't there is no reason for the program to continue unless it's handled accordingly.\nUsing exceptions will also set the correct default, i.e, handle the exception or receive a general error. Using an errors parameter will make it more easy to just ignore errors completely and when an error does occur you don't have any real idea of where the error happened in the first place.\nIf I ignore the exceptions thrown and I suddenly see a OAuthAuthenticationException in my error logs it will give me a pretty good idea of there to start investigating the issue.\n. It means that the user needs to re-authenticate to obtain a new access and refresh token. If 14 days is not enough then you might opt to set the refresh token to a longer expiry time.\n. ",
    "chadicus": "If anyone is interested I've created bridge library for going to and from PSR-7 and OAuth2 requests/responses  You can find it here. The library is meant to work with Slim 3, however it should (in theory) work with any PSR-7 message\n. FYI, I'm more than happy to work on the code change required for this issue, I just need to know if the code should be changed.\n. If anyone is interested, I created companion library over the weekend. https://github.com/chadicus/oauth2-storage-mongodb. \nI also needed to use MongoDB for storage, but the current restrictions of this library, it was easier to create a separate storage implementation rather than try to get a PR approved here.  As soon as this library ups its version of PHP, I'll be creating a PR.\nPlease keep in mind my mongodb library is in its very early stages and I'm sure it has bugs. I would not recommend for production use at this time.\n. Since the minimum PHP requirement for this library is >=5.3.9 and the minimum requirement for the mongodb library is 5.4, @bshaffer may not be too quick to merge this PR. That being said, I am working on a component of sorts for implementing MongoDB storage.  You can find the library here.  When the minimum PHP requirement of this library in increased, I will put a PR here to add the new storage.\nMy library is in it's very early stages and should not be used for production code at this time.\n. @memmaker your build is failing because the homepage for your author's entry is incorrect. You have http://lrx-solutions,de  Note the comma before the de \n. @bshaffer  you could avoid BC changes by componentizing some of the library such as the mongodb storage. Users could pick and choose what storage implementation they wanted. Also it would be easier to test the smaller libraries. . @memmaker I created this library as a temporary solution until the new MongoDB code was added to the main oauth2 server code. Feel free to use any of it's code.  I'll be abandoning it once the new MongoDB storage is merged here.. you could always implement a custom GrantType. . Construct your mongo client with a typemap which converts all types to arrays.  http://php.net/manual/en/mongodb.persistence.deserialization.php#mongodb.persistence.typemaps. @fernandoigual  I have updated the MongoDB example in the slim-oauth2 package. Hopefully, this will help resolve your issue.. @hey-onlybaby If the Yii Request is PSR-7 then this might help. technically yes. If you use the password grant type and your Storage implementation has access to your user information. . ",
    "steverhoades": "@bshaffer @Lansoweb \nAny update on the remaining tasks, issues, status of the psr-7 branch located here:\nhttps://github.com/bshaffer/oauth2-server-php/tree/psr-7\nI'd like to create a middleware server leveraging the library and would be happy to pitch in where needed.\n. ",
    "maryamshoeybi": "@bshaffer any update on the status of psr-7?\n. ",
    "kwhat": "Is this still under development?. ",
    "mehmedean": "Sending no access_token still results in  [], is there any fix on this?\n. Thank you Brent, it now returns an empty response body.\n. ",
    "MShel": "Redis.\n. ",
    "stestrepo": "php\n\n<p$dsn      = 'mysql:dbname=oauth_db;host=localhost';\n$username = 'sayalig';\n$password = '234';\n// error reporting (this is a demo, after all!)\nini_set('display_errors',1);error_reporting(E_ALL);\n// Autoloading (composer is preferred, but for this example let's just do this)\nrequire_once('C:\\xampp\\htdocs\\OAuth2\\Autoloader.php');\nOAuth2\\Autoloader::register();\n// $dsn is the Data Source Name for your database, for exmaple \"mysql:dbname=my_oauth2_db;host=localhost\"\n$storage = new OAuth2\\Storage\\Pdo(array('dsn' => $dsn, 'username' => $username, 'password' => $password));\n// Pass a storage object or array of storage objects to the OAuth2 server class\n$server = new OAuth2\\Server($storage);\n// Add the \"Client Credentials\" grant type (it is the simplest of the grant types)\n$server->addGrantType(new OAuth2\\GrantType\\ClientCredentials($storage));\n// Add the \"Authorization Code\" grant type (this is where the oauth magic happens)\n$server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($storage));\n?>\n. Can u tell me from while file is authorization code to be passed to whom (eg i'm passing it after the user approves of client accessing its resources with server.) is it right ??? \n. yes\n. ",
    "mtangoo": "This was forgotten open.\nTo just add to this question, is submitting client_id over Authorization header (base64 encoded) a standard practice? I have seen a library doing that automatically. Am not sure if this server handles that automatically (I know it does very well if passed along username and password in password grant as an example)\n. bump;\nWhat do I do to use JWT since they cannot fit the database table field? how do you use it guys?\n. Thanks, how do I avoid that? AFAIK it the library stores everything in database. Also I don't see anyway to add my payload easily (may be there is a class I have to define them?)\nThanks for your time\n. Thanks. I will check on the Yii module I use to see why it tries to store the JWT\nThank you!\n. Erroneous re-opening\n. ",
    "Jacketbg": "Hey I'm having the same issue here, exactly with IFTTT integration. Otherwise great library, but this issue seems to have no work-around without hacking your code. I don't really want to to this, because we're using Composer to deploy to several prod servers.\nDo you think this change will made it into master branch anytime soon? Thanks.\n. I just made a Pull request in regards to this issue.\n. Timestamp (int) will be best, but I didn't suggest that, because it will surely break compatibility with older versions and current installations.\nHere are the date() calls:\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php#L147\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php#L181\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php#L196\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php#L286\nAnother possible solution would be to use gmdate() instead of date(), but this again can break compatibility and cause issues with current installations. This might be an edge case anyway, so if you think the risk is too high, you can close the issue.\n. I'm not sure if I understand correctly. You mean to add a timezone to the string that you pass to the RDBMS? I don't think that's possible. Or you meant something else?\n. I'm relatively new to unit testing, but I will try to do something. Should I also add the new config value to the two mentioned files?\n. That's a relief :+1: Thank you for the fast response!\n. ",
    "TarasHots": "I guess you should use client_id and client_secret instead of username with password(which are reffered to user_credentials grant type). Try this:\n$ curl -u TestClient:TestSecret https://api.mysite.com/token -d 'grant_type=client_credentials'\nor \n$ curl https://api.mysite.com/token -d 'grant_type=client_credentials&client_id=TestClient&client_secret=TestSecret'\nas mentioned in https://bshaffer.github.io/oauth2-server-php-docs/grant-types/client-credentials/\n. Thank you for as quick as possible answer. Seems this is only way to do this(I mean only via adding grant type). I've found solution too, but it little bit different:\n$userCredentialsStorage = new MyOAuthStorage($sm);\n$userCredentialsGrantType = new OAuth2\\GrantType\\UserCredentials($userCredentialsStorage);\n$oauthService->addGrantType($userCredentialsGrantType);\nNevertheless, thank you. I guess documentation should be updated about this, because this functionality is really helpful, but almost undocumented.\n. answer is in https://github.com/bshaffer/oauth2-server-php/issues/555\n. ",
    "poisa": "Gotcha. Thanks!\n. ",
    "jonbest": "this issue is invalid. it turns out that my build of php within centos 6 had --disable-pdo configured for some reason. i rebuilt with pdo and this works fine.\n. ",
    "JonDaniel": "I had a similar issue on Centos 7 on a standard amazon box install (had not previously connected php to mysql though mysql was on the box for another reasons).  The following sorted me out:\nyum install php-pdo.x86_64\nyum install php-ZendFramework-Db-Adapter-Pdo-Mysql.noarch\nyum install php-mysql.x86_64\nyum install php-ZendFramework-Db-Adapter-Mysqli.noarch\n. ",
    "tino415": "I agree, this was just quick fix, i just have problem that there was unencoded url, i probably should write bug report...\n. ",
    "nsams": "Does scope also limit the possible scopes when suing client credentials?\n. ",
    "deathemperor": "this should be a CAPTCHA or limit the number of requests, am I correct?\n. ",
    "duuushtin": "Please help..:D\n. I tested it in Codeigniter. Here is my controller.\nphp if ( ! defined('BASEPATH')) exit('No direct script access allowed');\nclass Oauth2 extends AKTK_Controller{\n\n<p```\nprivate $dsn      = 'mysql:dbname=oauth2_db;host=localhost';\nprivate $username = 'root';\nprivate $password = '';\nprivate $storage  = '';\nprivate $server   = '';\npublic function __construct()\n{\n    parent::__construct();\n    // $dsn is the Data Source Name for your database, for exmaple \"mysql:dbname=my_oauth2_db;host=localhost\"\n    $this->storage = new OAuth2\\Storage\\Pdo(array('dsn' => $this->dsn, 'username' => $this->username, 'password' => $this->password));\n// Pass a storage object or array of storage objects to the OAuth2 server class\n$this->server = new OAuth2\\Server($this->storage);\n\n// Add the \"Client Credentials\" grant type (it is the simplest of the grant types)\n$this->server->addGrantType(new OAuth2\\GrantType\\ClientCredentials($storage));\n\n// Add the \"Authorization Code\" grant type (this is where the oauth magic happens)\n$this->server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($storage));\n\n}\npublic function token()\n{\n    // error reporting (this is a demo, after all!)\n    ini_set('display_errors',1);error_reporting(E_ALL);\n    // Handle a request for an OAuth2.0 Access Token and send the response to the client\n    $this->server->handleTokenRequest(OAuth2\\Request::createFromGlobals())->send();\n}\n```\n}\n. yes I installed it using composer. I also have autoloaded it in the index.php.\n// Path to the vendor folder for Composer\ndefine('VENDORPATH', FCPATH.'vendor\\');\n/*\n\n\nLOAD THE BOOTSTRAP FILE\n\n\n\n- And away we go...\n  \n  */\n  require_once VENDORPATH.'oauth2-server\\src\\OAuth2\\Autoloader.php';\n  OAuth2\\Autoloader::register();\n  require_once BASEPATH.'core/CodeIgniter.php';\n/* End of file index.php /\n/ Location: ./index.php */\nWeird thing is that the authorization part of the tutorial works. But everytime i run that particular curl command I receive an error.\n. Thanks for this. Yes, I should have set it to $this->storage instead of $storage. The error has been fixed.:D\n. ",
    "pawski": "@belerophon @justingreerbbi  Hi, did you forgot to implement AuthorizationCodeInterface for OpenId and save to storage the id_token value, which is set to null by default?\npublic function setAuthorizationCode($code, $client_id, $user_id, $redirect_uri, $expires, $scope = null, ***$id_token = null***);\nI have configuration:\n'options' => [\n    ...\n    'allow_implicit' => false,\n    'use_openid_connect' => true,\n    'issuer' => 'Me'\n]\nAnd I request for response type of code and scope openid.\nThis works for me. It was't until I have save token to storage.\n. As a side, @bshaffer if I specify in scope other things, like email it is not included in idToken.\nGettting user claims works only in case of implicit grant\nThe reason for that is the AuthorizationController is not passing scopes - claims when calling createIdToken\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/OpenID/Controller/AuthorizeController.php#L43\nIs this done with purpose?\n. ",
    "biwerr": "I had the same issue, but it was my fault. I forget to add the openId grant type to the server \n$server->addGrantType(new OAuth2\\OpenID\\GrantType\\AuthorizationCode($storage)); \n. Sorry but i dont know why the token is so long :smile: \nI thinks depends on the token type and the used algorithm. In this case i need a openid jwt_bearer.\nPAYLOAD:DATA\n{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\"\n}\n{\n  \"id\": \"0744e85a42cd1e4133841b4f3f752ba0c58e12fd\",\n  \"jti\": \"0744e85a42cd1e4133841b4f3f752ba0c58e12fd\",\n  \"iss\": \"https://partner.example.local\",\n  \"aud\": \"local\",\n  \"sub\": \"15\",\n  \"exp\": 1454148257,\n  \"iat\": 1454061857,\n  \"token_type\": \"bearer\",\n  \"scope\": \"openid\"\n}\nDB Entry\neyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpZCI6IjA3NDRlODVhNDJjZDFlNDEzMzg0MWI0ZjNmNzUyYmEwYzU4ZTEyZmQiLCJqdGkiOiIwNzQ0ZTg1YTQyY2QxZTQxMzM4NDFiNGYzZjc1MmJhMGM1OGUxMmZkIiwiaXNzIjoiaHR0cHM6XC9cL3BhcnRuZXIuc2llZ2VuaWEubG9jYWwiLCJhdWQiOiJsb2NhbCIsInN1YiI6IjE1IiwiZXhwIjoxNDU0MTQ4MjU3LCJpYXQiOjE0NTQwNjE4NTcsInRva2VuX3R5cGUiOiJiZWFyZXIiLCJzY29wZSI6Im9wZW5pZCJ9.AsS5hyLmNU--efbXNl_vxNXajMMxAcH9iN0jMr4VNV0bWn-SHf9xKef7gEtVRUlttaYLtfS2Rb_ncimaKDc4D7M-ZZR3upKEUfSzI3cbI-hf8iZNkBV8sZd2JbcOTa0zXdIskNahGlrCYA0UvABsVpP7TIl36ux2an7lUreviqc9lZ3lqEk3aLlcV3_NN9c22WTwTqNZAEupZ5siSvOdZcbhIZ1y_V6U2rtemJ2EV6YokRWPylUsYc4qmd2l5ICczwrSeClMlQbJmgGC3dFL6T5zor08gCRS2FeU1I0PN0Bidxd5kuNFwIvclDVCjxjakUJgAax8s82jPpPcXty_EA\n. What is about using the decoded token-id as primary/index in an additional column?\n\"id\": \"0744e85a42cd1e4133841b4f3f752ba0c58e12fd\",\n. ",
    "bontibon": "Following @cardonr's advice, I implemented an OIDC-specific token controller. This was also able to fix another issue I was having with custom claims not being included in the id_token (#763).\n``` diff\n+++ b/lib/OAuth2/OpenID/Controller/TokenController.php\n@@ -0,0 +1,44 @@\n+<?php\n+\n+namespace OAuth2\\OpenID\\Controller;\n+\n+use OAuth2\\ResponseType\\AccessTokenInterface;\n+use OAuth2\\ClientAssertionType\\ClientAssertionTypeInterface;\n+use OAuth2\\Controller\\TokenControllerInterface;\n+use OAuth2\\ScopeInterface;\n+use OAuth2\\Storage\\ClientInterface;\n+use OAuth2\\RequestInterface;\n+use OAuth2\\ResponseInterface;\n+use OAuth2\\Controller\\TokenController as BaseController;\n+\n+class TokenController extends BaseController implements TokenControllerInterface\n+{\n+    protected $idToken;\n+    protected $userClaimsStorage;\n+\n+    public function __construct(AccessTokenInterface $accessToken, ClientInterface $clientStorage, IdTokenInterface $idToken, UserClaimsInterface $userClaimsStorage, array $grantTypes = array(), ClientAssertionTypeInterface $clientAssertionType = null, ScopeInterface $scopeUtil = null)\n+    {\n+        parent::__construct($accessToken, $clientStorage, $grantTypes, $clientAssertionType, $scopeUtil);\n+\n+        $this->idToken = $idToken;\n+        $this->userClaimsStorage = $userClaimsStorage;\n+    }\n+\n+    public function grantAccessToken(RequestInterface $request, ResponseInterface $response)\n+    {\n+        $accessToken = parent::grantAccessToken($request, $response);\n+\n+        if ($accessToken != null && array_key_exists('scope', $accessToken) && in_array('openid', explode(' ', $accessToken['scope']))) {\n+            $grantTypeIdentifier = $request->request('grant_type');\n+            $grantType = $this->grantTypes[$grantTypeIdentifier];\n+\n+            $userId = $grantType->getUserId();\n+            $scope = $grantType->getScope();\n+\n+            $claims = $this->userClaimsStorage->getUserClaims($userId, $scope);\n+            $accessToken['id_token'] = $this->idToken->createIdToken($grantType->getClientId(), $userId, null, $claims);\n+        }\n+\n+        return $accessToken;\n+    }\n+}\ndiff --git a/lib/OAuth2/Server.php b/lib/OAuth2/Server.php\nindex 171a4f0..d38f9f1 100644\n--- a/lib/OAuth2/Server.php\n+++ b/lib/OAuth2/Server.php\n@@ -4,6 +4,7 @@ namespace OAuth2;\nuse OAuth2\\Controller\\ResourceControllerInterface;\n use OAuth2\\Controller\\ResourceController;\n+use OAuth2\\OpenID\\Controller\\TokenController as OpenIDTokenController;\n use OAuth2\\OpenID\\Controller\\UserInfoControllerInterface;\n use OAuth2\\OpenID\\Controller\\UserInfoController;\n use OAuth2\\OpenID\\Controller\\AuthorizeController as OpenIDAuthorizeController;\n@@ -520,6 +521,10 @@ class Server implements ResourceControllerInterface,\n     $accessTokenResponseType = $this->getAccessTokenResponseType();\n\n\nif ($this->config['use_openid_connect']) {\nreturn new OpenIDTokenController($accessTokenResponseType, $this->storages['client'], $this->getIdTokenResponseType(), $this->storages['user_claims'], $this->grantTypes, $this->clientAssertionType, $this->getScopeUtil());\n}\n+\n         return new TokenController($accessTokenResponseType, $this->storages['client'], $this->grantTypes, $this->clientAssertionType, $this->getScopeUtil());\n     }\n```\n. Duplicate #449\n. \n",
    "AlbinoDrought": "Following @biwerr , adding the OpenID grant type worked for me. In hindsight it makes sense, but I didn't come across it in the documentation.\nSo, if you're like me and you've set use_openid_connect and the id_tokens are being generated properly (but never sent), I recommend adding the OpenID AuthorizationCode grant:\n$server->addGrantType(new OAuth2\\OpenID\\GrantType\\AuthorizationCode($storage));\nsee https://github.com/bshaffer/oauth2-server-php/issues/544#issuecomment-164734763\n. With the Google OAuth 2.0 Playground specifically, appending ?state=xyz to the entered Authorization endpoint worked perfectly for testing\n. ",
    "loganto": "@cardonr @bshaffer What should I do when implementing Password Credential Grant for OIDC logins? \nBecause in this case we're completely skipping authorization step and if token endpoint doesnt return id_token .... then what? \nHow can I make token endpoint return id_token with this library?. @lucasantarella do you know if ThePHPLeague's OAuth2 Client can be used for OIDC logins?. nvm. does look liek just a server component. Ill use jumbojett/openid-connect-php for a  client.. @01ivesm I'm having exactly the same issue. plz let me know if u were able to resolve it.. @01ivesm I don't think this is correct. Anything without id_token would be completely bypassing OIDC.\nSo this would be using pure oauth2 (supposedly authorization-only protocol) for authentication which is typically throwned upon I think.     . @01ivesm im not that experienced in OIDC subject tbh, but I would  put SSO server on own domain|subdomaian yeah, like:\nsso.SITE.com\nid.SITE.com\nauth.SITE.com. So I haven't been able to get this package to work with UserCredentials grant.  \nThis one however worked out of the box with example they provided:\n  https://github.com/steverhoades/oauth2-openid-connect-server  . ",
    "Dru1X": "Whoops! It looks like I missed #277, where most of this was answered.\nI still think that allowing a single client to be public and confidential in certain circumstances would be useful and would help with streamlining things (especially when it comes to separating the AS from the RS)\nAny thoughts?\n. ",
    "hiqdev": "Glad to hear it :)\nThank you for the library!\n. ",
    "RomeroMsk": "From your documentation:\n\n@param $iss The issuer, usually the client_id\n\nAnd from official specification:\n\nThe JWT MUST contain an \"iss\" (issuer) claim that contains a unique identifier for the entity that issued the JWT.\nThe JWT MUST contain an \"aud\" (audience) claim containing a value that identifies the authorization server as an intended audience. The token endpoint URL of the authorization server MAY be used as a value for an \"aud\" element to identify the authorization server as an intended audience of the JWT.\n\nSo, I see that iss points to issuer (client/service/application who initiate the rerquest), and aud points to  audience (for example, identificator of third party auth server or URL for auth).\n. @bshaffer, oh, I see now. Thanks for pointing that.\n. ",
    "Wilt": "Hello Brent,\nI am happy you like my changes. I use PHP storm : https://www.jetbrains.com/phpstorm/\nIf you want I can also look at other classes later if I find some time.\nGreetings,\nWilt\n. @bshaffer I finally found some time to work myself through the library and add php-docs and type hinting as in the example. I tried to be as thorough as possible and I think it is a good start. I believe it will also motivate other contributors to improve/update the php-doc even more. I did not manage to add docs to all Storage classes yet, but this can be added later. \nHope you like it.\n. Sorry for this but I made a mistike while writing my question. I meant the client_secret column not the client_id column (I updated my question). Client secret is declared like this: client_secret VARCHAR(80) NOT NULL, so my question remains, why not allow null?\n. I added pull requests for this.\nOnce in the database schema:\nhttps://github.com/bshaffer/oauth2-server-php/pull/645\nTwo times in the docs:\nhttps://github.com/bshaffer/oauth2-server-php-docs/pull/68\nhttps://github.com/bshaffer/oauth2-server-php-docs/pull/69\n. ",
    "Divi": "Well, I will launch tests locally and will reopen this PR :)\n. ",
    "alanseiden": "It seems that Pdo's tests use sqlite; DynamoDb uses mock objects. Are there any tests with something similar to ibm_db2 that requires a real server? The ibm_db2 extension is not OO, so might not be easy to mock.\n. IBM Db2 requires a real server. Clark Everetts of Zend wrote tests against a real IBM i server for ZF2's Zend_Db, so it's possible to do.\n. I'm going to see Clark this week at a conference. Perhaps we can put our heads together.\n. Today I did find a couple of bugs in the DDL and know how to correct the \nexception bug. Will correct those first.\nBrent Shaffer wrote:\n\n@alanseiden https://github.com/alanseiden any progress on this?\n\u2014\nReply to this email directly or view it on GitHub \nhttps://github.com/bshaffer/oauth2-server-php/pull/565#issuecomment-98865772.\n. I don't understand how PDO would help with testing of the ibm_db2 extension.\n. Would \\Exception\\RuntimeException (add slash in front) be acceptable here?\n. Yes, I tested \\RuntimeException successfully today. Thanks.\n. I've added a check for the ibm_db2 extension using extension_loaded(), the technique used in ZF2. Sufficient or should we also check for the functions?\n. \n",
    "afilippov1985": "PDO is able to work with IBM DB2 http://php.net/manual/en/ref.pdo-ibm.php\n. Please, make a working OpenID Connect example.\n. You forgot one very important line\nin server.php\n~~$server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($storage));~~\n$server->addGrantType(new OAuth2\\OpenID\\GrantType\\AuthorizationCode($server->getStorage('authorization_code')));\n. Full description how to use OpenID\n- Generate RSA key for OpenID Provider (server)\n  openssl genpkey -algorithm RSA -out serverprivatekey.pem -pkeyopt rsa_keygen_bits:2048\n- Export public key\n  openssl pkey -in serverprivatekey.pem -out serverpublickey.pem -pubout\n- Create tables\nsql\nCREATE TABLE oauth_clients (client_id VARCHAR(80) NOT NULL, client_secret VARCHAR(80), redirect_uri VARCHAR(2000), grant_types VARCHAR(80), scope VARCHAR(4000), user_id VARCHAR(80), PRIMARY KEY (client_id));\nCREATE TABLE oauth_access_tokens (access_token VARCHAR(40) NOT NULL, client_id VARCHAR(80) NOT NULL, user_id VARCHAR(80), expires TIMESTAMP NOT NULL, scope VARCHAR(4000), PRIMARY KEY (access_token));\nCREATE TABLE oauth_authorization_codes (authorization_code VARCHAR(40) NOT NULL, client_id VARCHAR(80) NOT NULL, user_id VARCHAR(80), redirect_uri VARCHAR(2000), expires TIMESTAMP NOT NULL, scope VARCHAR(4000), id_token VARCHAR(1000), PRIMARY KEY (authorization_code));\nCREATE TABLE oauth_refresh_tokens (refresh_token VARCHAR(40) NOT NULL, client_id VARCHAR(80) NOT NULL, user_id VARCHAR(80), expires TIMESTAMP NOT NULL, scope VARCHAR(4000), PRIMARY KEY (refresh_token));\nCREATE TABLE oauth_users (username VARCHAR(80), password VARCHAR(80), first_name VARCHAR(80), last_name VARCHAR(80), email VARCHAR(80), email_verified BOOLEAN, scope VARCHAR(4000));\nCREATE TABLE oauth_scopes (scope VARCHAR(80) NOT NULL, is_default BOOLEAN, PRIMARY KEY (scope));\nCREATE TABLE oauth_public_keys (client_id VARCHAR(80), public_key VARCHAR(2000), private_key VARCHAR(2000), encryption_algorithm VARCHAR(100) DEFAULT 'RS256');\n- Insert server's private key (contents of files serverpublickey.pem and serverprivatekey.pem)\nsql\nINSERT INTO `oauth_public_keys` VALUES (NULL, '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----\\n', '-----BEGIN PRIVATE KEY-----\\n...\\n-----END PRIVATE KEY-----\\n', 'RS256');\n- Add client\nsql\nINSERT INTO `oauth_clients` VALUES ('testclient', 'pass', 'http://client.com/auth.php', NULL, 'openid profile email', NULL);\n- Add user\nsql\nINSERT INTO `oauth_users` VALUES ('testuser', 'userpass', NULL, NULL, 'user@user.com', 1, NULL);\n- Create server.php file with contents\n``` php\n<?php\nini_set('display_errors', 1);\nchdir('..');\nrequire 'OAuth2/Autoloader.php';\nOAuth2\\Autoloader::register();\n$storage_pdo_config = array(\n    'dsn' => 'mysql:host=localhost;dbname=oauth2_server_php',\n    'username' => 'root',\n    'password' => ''\n);\n$storagePdo = new OAuth2\\Storage\\Pdo($storage_pdo_config);\n$config = array(\n    'use_openid_connect' => true,\n    'issuer' => 'http://server.com',\n);\n$server = new OAuth2\\Server($storagePdo, $config);\n$server->addGrantType(new OAuth2\\OpenID\\GrantType\\AuthorizationCode($server->getStorage('authorization_code')));\n``\n- Createauthorization.php` file with contents\n``` php\n<?php\nrequire 'server.php';\n$request = OAuth2\\Request::createFromGlobals();\n$response = new OAuth2\\Response();\nif (!$server->validateAuthorizeRequest($request, $response))\n{\n    $response->send();\n    exit();\n}\nif (empty($_POST)) // display an authorization form\n{\n    echo '\nDo You Authorize TestClient?\n\n\n';\n}\nelse\n{\n    $is_authorized = ($_POST['authorized'] === 'yes');\n    $user_id = 'testuser';\n    $server->handleAuthorizeRequest($request, $response, $is_authorized, $user_id)->send();\n}\n``\n- Createtoken.php` file with contents\n``` php\n<?php\n// include our OAuth2 Server object\nrequire 'server.php';\n$request = OAuth2\\Request::createFromGlobals();\n// Handle a request for an OAuth2.0 Access Token and send the response to the client\n$server->handleTokenRequest($request)->send();\n``\n- Createuserinfo.php` file with contents\n``` php\n<?php\n// include our OAuth2 Server object\nrequire 'server.php';\n$request = OAuth2\\Request::createFromGlobals();\n$server->handleUserInfoRequest($request)->send();\n``\n- Everything is done to use OpenID Connect.\n  Now create file at yourredirect_uri` (http://client.com/auth.php) with contents\n``` php\n<?php\nini_set('display_errors', 1);\n$client_id = 'testclient';\n$client_secret = 'pass';\n//$redirect_uri = '';\n$authorization_endpoint = 'http://server.com/authorization.php';\n$token_endpoint = 'http://server.com/token.php';\n$userinfo_endpoint = 'http://server.com/userinfo.php';\nif (isset($_GET['error']))\n{\n    exit(\"Error: {$_GET['error']}. Description: {$_GET['error_description']}\");\n}\nelse if (isset($_GET['code']) && isset($_GET['state']))\n{\n    // Step 2. Token request\n$code = $_GET['code'];\necho \"Authorization Code is {$code}\\n\\n\";\n\n$data = array(\n    'grant_type' => 'authorization_code',\n    'code' => $code,\n);\n\n$h = curl_init($token_endpoint);\ncurl_setopt($h, CURLOPT_RETURNTRANSFER, true);\ncurl_setopt($h, CURLOPT_TIMEOUT, 10);\ncurl_setopt($h, CURLOPT_USERPWD, \"{$client_id}:{$client_secret}\");\ncurl_setopt($h, CURLOPT_POST, true);\ncurl_setopt($h, CURLOPT_HTTPHEADER, array('Content-Type: application/x-www-form-urlencoded'));\ncurl_setopt($h, CURLOPT_POSTFIELDS, http_build_query($data));\n//curl_setopt($h, CURLOPT_SSL_VERIFYPEER, false);\n\n$res = curl_exec($h);\nif (!$res)\n    exit(curl_error($h));\n\ncurl_close($h);\n$res = json_decode($res, true);\n\necho \"Token Response:\\n\";\nprint_r($res);\necho \"\\n\";\n\n// Here you should decode JWT token and check sign using server's public key\n// $payload = Jwt::decode($response['id_token'], $this->serverPublicKey);\n\n// If Token Response is valid goto step 3\n// Step 3. Get UserInfo\n$access_token = $res['access_token'];\n\n$h = curl_init($userinfo_endpoint);\ncurl_setopt($h, CURLOPT_RETURNTRANSFER, true);\ncurl_setopt($h, CURLOPT_TIMEOUT, 10);\ncurl_setopt($h, CURLOPT_HTTPHEADER, array('Authorization: Bearer ' . $access_token));\n//curl_setopt($h, CURLOPT_SSL_VERIFYPEER, false);\n\n$res = curl_exec($h);\nif (!$res)\n    exit(curl_error($h));\n\ncurl_close($h);\n$res = json_decode($res, true);\n\necho \"UserInfo Response:\\n\";\nprint_r($res);\n\n}\nelse\n{\n    // Step 1. Authorization Code request\n$data = array(\n    'response_type' => 'code',\n    'client_id' => $client_id,\n    'state' => 'xyz',\n    'scope' => 'openid profile email',\n);\n\n$authorization_endpoint .= '?' . http_build_query($data);\nheader('Location: ' . $authorization_endpoint);\nexit();\n\n}\n``\n- Then type yourredirect_uri` in browser. You should see something like this\n```\nAuthorization Code is d23a0584e77873005db938041ac613a9dbc9d51c\nToken Response:\nArray\n(\n    [access_token] => c1661d6d07bd4ad983ebd3e148d8c34096578e88\n    [expires_in] => 3600\n    [token_type] => Bearer\n    [scope] => openid profile email\n    [id_token] => eyJ0eXAiOiJKV1QiLCJ .......  ...... JITkjlyGvt1MAoDA\n)\nUserInfo Response:\nArray\n(\n    [name] => \n    [family_name] => \n    [given_name] => \n    [middle_name] => \n    [nickname] => \n    [preferred_username] => \n    [profile] => \n    [picture] => \n    [website] => \n    [gender] => \n    [birthdate] => \n    [zoneinfo] => \n    [locale] => \n    [updated_at] => \n    [email] => user@user.com\n    [email_verified] => 1\n    [sub] => testuser\n)\n``\n. If you want to use JWT for client authentification, make following changes:\n- Generate client's private key using openssl.openssl genpkey -algorithm RSA -out clientprivatekey.pem -pkeyopt rsa_keygen_bits:2048- Export client's public keyopenssl pkey -in clientprivatekey.pem -out clientpublickey.pem -pubout`\n- Create tables\nsql\nCREATE TABLE `oauth_jti` (`issuer` VARCHAR(80) NOT NULL, `subject` VARCHAR(80) NULL DEFAULT NULL, `audience` VARCHAR(80) NULL DEFAULT NULL, `expires` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `jti` VARCHAR(2000) NOT NULL);\nCREATE TABLE `oauth_jwt` (`client_id` VARCHAR(80) NOT NULL, `subject` VARCHAR(80) NULL DEFAULT NULL, `public_key` VARCHAR(2000) NULL DEFAULT NULL, PRIMARY KEY (`client_id`));\n- Add client's public key to server table\nsql\nINSERT INTO `oauth_jwt` VALUES ('testclient', 'testclient', '-----BEGIN PUBLIC KEY-----\\nMIIB...\\n-----END PUBLIC KEY-----\\n');\n- Change server.php\n``` php\n<?php\nini_set('display_errors', 1);\nchdir('..');\nrequire 'OAuth2/Autoloader.php';\nOAuth2\\Autoloader::register();\n$storage_pdo_config = array(\n    'dsn' => 'mysql:host=localhost;dbname=oauth2_server_php',\n    'username' => 'root',\n    'password' => ''\n);\n$storagePdo = new OAuth2\\Storage\\Pdo($storage_pdo_config);\n$config = array(\n    'use_openid_connect' => true,\n    'issuer' => 'http://server.com',\n);\n//$server = new OAuth2\\Server($storagePdo, $config);\n$server = new OAuth2\\Server($storagePdo, $config, array(), array(), null, null, new OAuth2\\GrantType\\JwtBearer($storagePdo, $config['issuer']));\n$server->addGrantType(new OAuth2\\OpenID\\GrantType\\AuthorizationCode($server->getStorage('authorization_code')));\n``\n- Change client code (atredirect_uri`)\n``` php\n<?php\nini_set('display_errors', 1);\n$client_id = 'testclient';\n$client_secret = 'pass';\n$client_privatekey = '-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDeaoLtgrEP4ke8\n...YOUR CLIENT KEY...\nyYCvArkeMCbHcaGEMeUlBVI3\n-----END PRIVATE KEY-----\n';\n//$redirect_uri = '';\n$authorization_endpoint = 'http://server.com/authorization.php';\n$token_endpoint = 'http://server.com/token.php';\n$userinfo_endpoint = 'http://server.com/userinfo.php';\nif (isset($_GET['error']))\n{\n    exit(\"Error: {$_GET['error']}. Description: {$_GET['error_description']}\");\n}\nelse if (isset($_GET['code']) && isset($_GET['state']))\n{\n    // Step 2. Token request\n$code = $_GET['code'];\necho \"Authorization Code is {$code}\\n\\n\";\n\nrequire 'PATH_TO_OAUTH_LIB/OAuth2/Encryption/EncryptionInterface.php';\nrequire 'PATH_TO_OAUTH_LIB/OAuth2/Encryption/Jwt.php';\n$jwtclass = new OAuth2\\Encryption\\Jwt;\n\n$data = array(\n    'grant_type' => 'authorization_code',\n    'code' => $code,\n    //'client_assertion_type' => 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n    'assertion' => $jwtclass->encode(array(\n        'iss' => $client_id,\n        'sub' => $client_id,\n        'aud' => 'http://server.com', // same as issuer in server config !!!\n        'jti' => 'abcdef012345', // random string\n        'exp' => time() + 30,\n        'iat' => time(),\n    ), $client_privatekey, 'RS256'),\n);\n\n$h = curl_init($token_endpoint);\ncurl_setopt($h, CURLOPT_RETURNTRANSFER, true);\ncurl_setopt($h, CURLOPT_TIMEOUT, 10);\n//curl_setopt($h, CURLOPT_USERPWD, \"{$client_id}:{$client_secret}\");\ncurl_setopt($h, CURLOPT_POST, true);\ncurl_setopt($h, CURLOPT_HTTPHEADER, array('Content-Type: application/x-www-form-urlencoded'));\ncurl_setopt($h, CURLOPT_POSTFIELDS, http_build_query($data));\n//curl_setopt($h, CURLOPT_SSL_VERIFYPEER, false);\n\n$res = curl_exec($h);\nif (!$res)\n    exit(curl_error($h));\n\ncurl_close($h);\n$res = json_decode($res, true);\n\necho \"Token Response:\\n\";\nprint_r($res);\necho \"\\n\";\n\n// Here you should decode JWT token and check sign using server's public key\n// $payload = Jwt::decode($response['id_token'], $this->serverPublicKey);\n\n// If Token Response is valid goto step 3\n// Step 3. Get UserInfo\n$access_token = $res['access_token'];\n\n$h = curl_init($userinfo_endpoint);\ncurl_setopt($h, CURLOPT_RETURNTRANSFER, true);\ncurl_setopt($h, CURLOPT_TIMEOUT, 10);\ncurl_setopt($h, CURLOPT_HTTPHEADER, array('Authorization: Bearer ' . $access_token));\n//curl_setopt($h, CURLOPT_SSL_VERIFYPEER, false);\n\n$res = curl_exec($h);\nif (!$res)\n    exit(curl_error($h));\n\ncurl_close($h);\n$res = json_decode($res, true);\n\necho \"UserInfo Response:\\n\";\nprint_r($res);\n\n}\nelse\n{\n    // Step 1. Authorization Code request\n$data = array(\n    'response_type' => 'code',\n    'client_id' => $client_id,\n    'state' => 'xyz',\n    'scope' => 'openid profile email',\n);\n\n$authorization_endpoint .= '?' . http_build_query($data);\nheader('Location: ' . $authorization_endpoint);\nexit();\n\n}\n```\nSome notes about Token Request.\nThere is an issue #661 with it.\nPassing client_assertion_type parameter not necessary.\nJWT must be passed in assertion parameter instead of client_assertion.\n. A possible solution is to add date_default_timezone_set('UTC') in OAuth2\\Server constructor.\n. I was wrong.\ntime() returns time in UTC.\nAnd expiration checking works fine.\nBut, when saving to MySQL, date() function converts time to PHP's timezone.\nThen MySQL converts TIMESTAMP values from the MySQL's timezone to UTC for storage, and back from UTC to the MySQL's timezone for retrieval (PHP timezone and MySQL timezone may be different).\nSo MySQL shows TIMESTAMPs in current timezone and it confused me.\nSorry.\n. Related to issue #570\n. I disagree with this. Unsetting of the non-existent variable is OK. PHP don't throw any error if you unset non-existent variable.\nThis method should return result of the command execution by the storage driver, and not the result of unsetting.\n. Also, existing storages has functions to set data for unit tests (such as setClientDetails, setScope, setClientKey, unsetAccessToken, setUser). They should be added to corresponding storage interfaces.\n. Further work blocked by issue #677 \n. mongo extension is deprecated.\nSo, I wrote other storage adapter for MongoDB using new extension mongodb\nIt's not compatible with OAuth2\\Storage\\Mongo.\n. In other words.\nIf storage classes Redis, CouchbaseDB and Mongo implements interfaces UserClaimsInterface and PublicKeyInterface, they wouldn't have passed the tests.\n. Hmm.. I don't see any tabs.\nUnfortunately, traits can't implement interfaces. So we can't use instanceof to check whether class implements such interface.\n. ~~though... storage class can declare that it implements interfaces, but actual implementation will be done by trait.\nThen ...  would be better to create several traits (one for each interface), each will implement corresponding interface.~~\nNo, it was a bad idea.\n. Yes, I also wanted to mention about this. Traits require PHP >=5.4\n. Oops...  travis not working [https://travis-ci.org/bshaffer/oauth2-server-php/jobs/102334251]\n. Waiting for PR #701 \n. Rechecked.\nYes, it passes tests.\nCurrent develop branch also passes tests with #701 . @bluebaroncanada \nI think this code is ready to be merged.\nCurrent installations that uses Cassandra, Couchbase or Redis storage will not notice changes (I hope).. @bluebaroncanada @bshaffer \nThen I want to discuss #675 (first comment) to make interfaces consistent in v2.x\n. Set access_lifetime parameter in server config\nphp\n$config = array(\n    'access_lifetime' => 86400\n);\n$server = new OAuth2\\Server($storage, $config);\n. What storage adapter do you use?\n. Show you code where you initialize OAuth2\\Server class\nphp\n$server = new OAuth2\\Server(...)\n$server->addGrantType(...)\n. Instantiated grant types don't inherit server config\nSo always_issue_new_refresh_token parameter does not pass to OAuth2\\GrantTypeRefreshToken\nChange this\n$grantClass = new $class($storage);\nto this\n$config = [\n    'access_lifetime' => 86400, // 1 day\n    'refresh_token_lifetime' => 2419200, // 28 days\n    'always_issue_new_refresh_token' => true,\n    'unset_refresh_token_after_use' => false\n];\n.......\n$grantClass = new $class($storage, $config);\n. even better would be to write it this way\n``` php\n$server = new OAuth2\\Server($storage, [\n    'access_lifetime' => 86400, // 1 day\n    'refresh_token_lifetime' => 2419200, // 28 days\n]);\n$server->addGrantType(new OAuth2\\GrantType\\UserCredentials($server->getStorage('authorization_code')));\n$server->addGrantType(new OAuth2\\GrantType\\RefreshToken($server->getStorage('refresh_token'), ['always_issue_new_refresh_token' => true]));\n```\n. Travis is broken again\n. Fix \"Expiration (exp) time must be a unix time stamp\"\nHere ctype_digit($jwt['exp']) evals to false when $jwt['exp'] > PHP_INT_MAX\n``` php\n// on 32-bit\n$d = 99999999900;\nvar_dump($d, ctype_digit($d));\n//double(99999999900) bool(false) \n// BUT\n$d = '99999999900';\nvar_dump($d, ctype_digit($d));\n//string(11) \"99999999900\" bool(true) \n// on 64-bit\n$d = 99999999900;\nvar_dump($d, ctype_digit($d));\n//int(99999999900) bool(true) \n$d = '99999999900';\nvar_dump($d, ctype_digit($d));\n//string(11) \"99999999900\" bool(true) \n``\n. May be we should also check thataccess_token` key exists in array.\n. ping @bshaffer . I'll make a few smaller PRs.. I think, this lines is unwanted in server.php\nphp\n$request = OAuth2\\Request::createFromGlobals();\n$server->handleTokenRequest($request);\n$response = new OAuth2\\Response();\n. If you are going to use Pdo storage adapter\nTheoretically it can update expires column\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php#L151\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php#L192\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/Pdo.php#L207\nbut the probability of this event is negligible (collision of 160-bit random value)\nTo be sure you may rewrite code to use REPLACE sql query instead of SELECT-UPDATE-INSERT.\nIf your DB don't support REPLACE use consecutive DELETE-INSERT\n``` php\n$stmt = $this->db->prepare(sprintf('REPLACE INTO %s (access_token, client_id, expires, user_id, scope) VALUES (:access_token, :client_id, :expires, :user_id, :scope)', $this->config['access_token_table']));\nreturn $stmt->execute(compact('access_token', 'client_id', 'user_id', 'expires', 'scope'));\nor\n$this->db->beginTransaction();\n$stmt = $this->db->prepare(sprintf('DELETE FROM %s WHERE access_token=:access_token', $this->config['access_token_table']));\n$stmt->execute(compact('access_token'));\n$stmt = $this->db->prepare(sprintf('INSERT INTO %s (access_token, client_id, expires, user_id, scope) VALUES (:access_token, :client_id, :expires, :user_id, :scope)', $this->config['access_token_table']));\n$stmt->execute(compact('access_token', 'client_id', 'user_id', 'expires', 'scope'));\nreturn $this->db->commit();\n``\n. OverrideOAuth2\\ResponseType\\JwtAccessToken::createAccessToken()or create your own class from scratch (it must implementOAuth2\\ResponseType\\AccessTokenInterface)\nThen initializeOAuth2\\Server` passing 4th parameter\nphp\n$responseTypes = array('token' => new MyCustomJwtAccessToken(............));\n$server = new OAuth2\\Server($storage, $config, $grantTypes, $responseTypes);\n. There is no magic out of the box.\nYou have to override OAuth2\\Storage\\Pdo::getUser()\n``` php\n<?php\nnamespace OAuth2\\Storage;\nclass MyPdo extends Pdo\n{\n    public function getUser($username)\n    {\n        $stmt = $this->db->prepare($sql = sprintf('SELECT * from %s where id=:username', $this->config['user_table']));\n        $stmt->execute(array('username' => $username));\n    if (!$userInfo = $stmt->fetch(\\PDO::FETCH_ASSOC)) {\n        return false;\n    }\n\n    // the default behavior is to use \"username\" as the user_id\n    return array_merge(array(\n        'user_id' => $username\n    ), $userInfo);\n}\n\n}\n```\n. Let's vote:\n\n[x] Defensive programming\n$payload = array_merge($extra, $payload); // critical data can't be changed\n\nOR\n\n[ ] Flexibility\n$payload = array_merge($payload, $extra); // everything may be changed. How about to change parameter name to jwt_extra_payload_callable to clarify its purpose?\nMay be some other name?. Did you tried passing clone of \\PDO object ?\nlike this\nphp\n$connection = new \\PDO(....); // your connection\n$storage = new OAuth2\\Storage\\Pdo(clone $connection);\n$server = new OAuth2\\Server($storage);. setUser() used only for testing\nhttps://github.com/bshaffer/oauth2-server-php/issues/675#issuecomment-162627534\n. php\n$server = new \\OAuth2\\Server( $storage );\n$server->addGrantType(new \\OAuth2\\GrantType\\AuthorizationCode($storage));. I agree. Yes! My mistake.. Do you mean that callable must be defined like this? (pay attention that $payload passed by reference)\nfunction(&$payload, $client_id, $user_id, $scope) {}\n\nI think that standard JWT claims should be protected from external changes. That's why I put $payload last in array_merge(). Doing so callable may break JWT. Standard JWT claims should be protected from external changes.. I removed underscores to conform PSR-2 style. This may break proper work of JWT\nSee our conversation with @svycka - https://github.com/bshaffer/oauth2-server-php/pull/804/files/86bd64e745ee34fa03bfb3456e5d2a2ab0a1c07e#r98169436\nI agree to replace this\n$payload = array_merge($extra, $payload);\nto this\n$payload = array_merge($payload, $extra);. then, we should also rename the parameter to jwt_override_payload_callable. ",
    "CiTRO33": "Hello @alanseiden\nwe are trying to use Oauth with JWT Access Token (https://bshaffer.github.io/oauth2-server-php-docs/overview/jwt-access-tokens/) . \nWe insert the public / Private keys into the oauth_public_keys table.\nIf we want to generate a new access token,  we got an error.\nI figured out, that the SQL in the functions getPublicKey (Line 467 in /src/OAuth2/Storage/IbmDb2.php ), getPrivateKey  (Line 477 in /src/OAuth2/Storage/IbmDb2.php ) and getEncryptionAlgorithm  (Line 487 in /src/OAuth2/Storage/IbmDb2.php )  didn't work, because ORDER BY client_id IS NOT NULL DESC  didn't exists in DB2 V7R1.\nWhen i change this to ORDER BY client_id ASC the correct data is returned. \nSorted by example \"testclient\", NULL .\nmaybe its a performance improvements if we add FETCH FIRST ROW ONLY to retrun only one row.\n. ",
    "DannyBoyNg": "Please read the OAuth 2.0 specification. Refresh tokens are not allowed in the implicit grant flow.\n. ",
    "janedbal": "I know this is old PR, but it is very ugly BC break. This should be at least mentioned in release notes...\n. ",
    "hannesvdvreken": "@bshaffer I had no idea :-) sorry if I broke something for you.\n. ",
    "JerryBels": "Hello, @tthiery , @bshaffer ...\nI have the same issue here. How do I unset the request body data please ? Still a beginner with Laravel and Oauth2 both soooo... Thanks ahead :)\n. Hey, thanks for responding! In the route, $request is not defined, so I added a parameter Request $request and then set what you gave me... It didn't work, I still have a count of 2 and so a fail in getAccessTokenParameter. I guess I failed to unset... \nWhile I'm at it, for the header, I need to call the header Authorization with value Bearer mytokenvalue right? \n. Okay, thanks @tthiery ... And about the unset, you don't know where I got wrong ?\n```\nRoute::get('private', function(Request $request)\n{\n    $bridgedRequest  = OAuth2\\HttpFoundationBridge\\Request::createFromRequest(Request::instance());\n    $bridgedResponse = new OAuth2\\HttpFoundationBridge\\Response();\n// fix laravel\n$request->request = new \\Symfony\\Component\\HttpFoundation\\ParameterBag();\n$rawHeaders = getallheaders();\nif (isset($rawHeaders[\"Authorization\"])) {\n    $authorizationHeader = $rawHeaders[\"Authorization\"];\n    $bridgedRequest->headers->add([ 'Authorization' => $authorizationHeader]);\n}\n\nif (App::make('oauth2')->verifyResourceRequest($bridgedRequest, $bridgedResponse)) {\n\n    $token = App::make('oauth2')->getAccessTokenData($bridgedRequest);\n\n    return Response::json(array(\n        'private' => 'stuff',\n        'user_id' => $token['user_id'],\n        'client'  => $token['client_id'],\n        'expires' => $token['expires'],\n    ));\n}\nelse {\n    return Response::json(array(\n        'error' => 'Unauthorized'\n    ), $bridgedResponse->getStatusCode());\n}\n\n});\n```\n. Oh, thank you so much ! I actually succeeded into correcting it also by simply replacing $request with $bridgedRequest... But your comment helped me kickstart my brain to understand how all of this works. You really helped me a lot ! Thanks again :)\n. @beznez I think you need to declare the bridge before the fix... I did it this way : \n```\nApp::singleton('oauth2', function() {\n    $storage = new OAuth2\\Storage\\Pdo(array('dsn' => 'mysql:dbname=oauth2;host=localhost', 'username' => 'root', 'password' => 'root'));\n    $server = new OAuth2\\Server($storage);\n$server->addGrantType(new OAuth2\\GrantType\\ClientCredentials($storage));\n$server->addGrantType(new OAuth2\\GrantType\\UserCredentials($storage));\n\nreturn $server;\n\n});\nRoute::get('private', function()\n{\n    $bridgedRequest  = OAuth2\\HttpFoundationBridge\\Request::createFromRequest(Request::instance());\n    $bridgedResponse = new OAuth2\\HttpFoundationBridge\\Response();\n    // fix for laravel\n    $bridgedRequest->request = new \\Symfony\\Component\\HttpFoundation\\ParameterBag();\n    $rawHeaders = getallheaders();\n    if (isset($rawHeaders[\"Authorization\"])) {\n        $authorizationHeader = $rawHeaders[\"Authorization\"];\n        $bridgedRequest->headers->add([ 'Authorization' => $authorizationHeader]);\n    }\n\nif (App::make('oauth2')->verifyResourceRequest($bridgedRequest, $bridgedResponse)) {\n\n    $token = App::make('oauth2')->getAccessTokenData($bridgedRequest);\n\n    return Response::json(array(\n        'private' => 'stuff',\n        'user_id' => $token['user_id'],\n        'client'  => $token['client_id'],\n        'expires' => $token['expires'],\n    ));\n}\nelse {\n    return Response::json(array(\n        'error' => 'Unauthorized'\n    ), $bridgedResponse->getStatusCode());\n}\n\n});\n```\nAnd it worked perfectly (of course use your own credentials). Hope it helps.\n. Bump !\nAlso, something more : in the step-by-step tutorial the client_secret is stored directly. I guess it's for demo purpose, and it actually needs to be encoded in sha1 or something, right ?\n. Thanks for helping ! It looks a little complicated but I will try it. On the API side, in order to check the token, I have to implement the server in my Laravel like it's shown here http://bshaffer.github.io/oauth2-server-php-docs/cookbook/laravel/ ?\n. @phindmarsh thank you for helping ! So in my case, where I have the same database but on different codebases, what would you recommend ?\nAlso, the questions I asked before : \n\"On the API side, in order to check the token, I have to implement the server in my Laravel like it's shown here http://bshaffer.github.io/oauth2-server-php-docs/cookbook/laravel/ ?\"\nAnd : \n\"in the step-by-step tutorial the client_secret is stored directly. I guess it's for demo purpose, and it actually needs to be encoded in sha1 or something, right ?\"\nAnd then I have a confusion : are the client_id and client_secret said to be the user's credentials ? I mean, the username and password he sends from the authentication form ?\n. You helped me a lot, really. I will go back to work, thank you so much !\n. A little thing : is it possible to use JWT with user credentials grant ?\n. @phindmarsh thanks, that helps ! \nSo I would do \nclass MyCustomUserStorageClass implements OAuth2\\Storage\\UserCredentialsInterface {\n    public function checkUserCredentials($username, $password) { //stuff }\n    public function getUserDetails($username) { //stuff }\n}\nand return whatever is expected as can be seen in the comments here https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Storage/UserCredentialsInterface.php and then when I'm checking access tokens with User Credentials grant\n$server->handleTokenRequest(OAuth2\\Request::createFromGlobals())->send();\nit would use my own checkUserCredentials and getUserDetails in place of the default ones ?\nAlso, in this : \n$grantType = new OAuth2\\GrantType\\UserCredentials($storage);\nDo I have to use $myUserStorage instead ?\nThanks again !\n. Thanks :)\n. ",
    "morrizon": "Be sure that the user and pass match the database. In the cookbook the password is testpass and you're using testsecret. Also, you can add the user and pass as parameters:\nclient_id: testclient\nclient_secret: testpass\n. Then I think the params must be:\n- grant_type: client_credentials\n- client_id: testclient\n- client_secret: testsecret\nWhen I tested with curl I changed the option -u with that params and worked like a charm:\ncurl http://localhost/token.php -d 'grant_type=client_credentials&client_id=testclient&client_secret=testpass'\n. ",
    "knighti": "i have saved \"testsecret\" as \"password\" in database, that's why i am using it.\nI have also tested by adding user and pass as POST parameters but it does not work out.\nam i using the right method and way to pass the credentials as in the first picture attached?\n. ",
    "monteduro": "inserting this snippet in request process solve the problem\nphp\n$request = OAuth2\\Request::createFromGlobals();\nif (isset($request->request['grant_type']) && $request->request['grant_type'] == \"client_credentials\")\n    $server->setConfig('access_lifetime', 3600*24);\n. ",
    "freezy-sk": ":+1: \n. ",
    "Oxmoze": "Hi all,\nAs @bshaffer wrote, the firebase should not be defined as an hard dependency. There are other PHP libraries that provides great features and that can be used by the project. See this library for example.\nIMHO, you should not remove interfaces, but you should create \"bridges\" to use firebase or spomky-labs/jose or any other library (maybe in another repositories).\n. > it seems unnecessary to require client credentials.\nAs per the RFC mentionned above, in the section 2.1 \"Revocation Request\" it is clearly indicated The client also includes its authentication credentials as described in Section 2.3. of [RFC6749].\n. The RFC6749 section 5.2 in reference of the section 6 clearly indicates that in case of a wrong parameter or invalid grqnt (here the refresh_token parameter, the authorization server responds with an HTTP 400 (Bad Request) status code.\nSo I may be wrong, but this issue and the #846 are irrelevant.. ",
    "guillerodriguez": "@bshaffer The Server class provides default values for both always_issue_new_refresh_token and unset_refresh_token_after_use. So even if user code only defines always_issue_new_refresh_token (see issue #824), the \"isset\" test in commit 7731601 will not catch this case (both config parameters will always be defined).\n. ",
    "opengeek": "Any news on this being merged? I am looking for exactly this feature without resorting to directly manipulating the storage...\n. ",
    "suj87": "I was thinking more in terms of future updates maybe, or something along those lines. But that's good to know, I might just switch over to using the oauth table fully.\n. Thanks for the update and confirmation guys! :-) :+1: \n. ",
    "quintonparker": "Sure. Will do. Thanks\nSent from my iPhone\n\nOn 25 May 2015, at 10:50 PM, Brent Shaffer notifications@github.com wrote:\nWill you submit this to the develop branch?\n\u2014\nReply to this email directly or view it on GitHub.\n. Hey all\n\nI too created a PR for this issue some weeks ago and it was merged into develop branch if I recall correctly\nSent from my iPhone\n\nOn 22 Jul 2015, at 11:15 AM, Anna notifications@github.com wrote:\nThe config value of access_lifetime is not used in the JwtAccessToken when you do not set your own JwtAccessTokenResponseType.\n\u2014\nReply to this email directly or view it on GitHub.\n. Awesome. Thanks \ud83d\ude01\n\nSent from my iPhone\n\nOn 18 Sep 2015, at 8:09 PM, Brent Shaffer notifications@github.com wrote:\n@andriysilka thanks for the nudge, tag v1.8.0 has been created. Please update your libraries accordingly!\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "davigun": "Did you mean droping Query language to replace $users data from above??\nokay then i will try. Thank you before\n. yeah, i already used the PDO (basic config where this PDO connect to DB) instead of using Memory, but it returns invalid pass and username combination, i think somehow it reads my dsn name username pass instead of reading from user_table.... So now i'm desperately confuse how can i retrieve data from user_table..\n. \nthat's the error prompt. and this is from the server.php\n\nstorage changed from  >\n\n. ohh yeah mate, i got it wrong entering unencrypted password into database, my bad. Did you mean i have to change method setUser in Pdo class into addUser method? Because the link from your previous post is refering to setUser method in PDO (sorry got little confuse where the addUser is)\n. Okay, got it, but i have to add public function setUser($username, $password, $firstName = null, $lastName = null); in the UserCredentialInterface class, so that this method can work properly. Thanks mate for your help, and sorry to disturb your night :)\n. yeah i did use it, but in UserCreden interface class i have to decrale the function to call setUser method in the PDO storage class, either way it will return the same error as i mention in previous comment\n. yeah, im using setUser from now on, and have to change the password stored in database to SHA1 type, so that this password can correctly match when being searched by the method, and have to call the setUser function in UserCredenInterface class to make this works\n\nlike the above\n. ",
    "chateaux": "Were you able to resolve this? \n. ",
    "abhijeet24patil": "i need a proper explaination of jwt grant type with scopes. as i am new to this i didnt understand JWT Bearer from official site. Please tell me some other ways to make it understand properly. with example.\nThank you\n. ",
    "JohnAdamsy": "Also adding onto @JerryBels request'..is there a way to set this up on a separate server, simply: the Authorization Server (AS) and then have several Resource Servers (RS), simply: the APIs on other servers, such that API requests from the client are handled by the single AS. And in mind, suppose you have multiple Resource Servers not necessarily implemented in PHP, say for instance, RS 1 is Node JS,  RS 2 is running Ruby on Rails, etc. \n. @phindmarsh Ah good stuff. Let me get onto it and will get back. Thanks a lot for the clarification. \n. ",
    "ainslied": "Ok, thank you for your answer,\nI use a library which uses yours, there is probably an issue with it.\nRegards\n. ",
    "GasimGasimzada": "For now, I just copied the user claims functions from Pdo/Cassandra/DynamoDB and added UserClaimsInterface to Mongo. Everything seems to be working. I don't quiet understand the point of user claims yet (I am a newbie at OIDC) but thinking that others use the exact same functions for user claims, copying seemed like a logical decision.\nI will read the specs more to understand it and try to do a pull request.\n. ",
    "sajumani": "hi,\nam also trying to integrate User credential grant type... Will you people give clear doc...? \n. yes, am using mysql PDO. ",
    "activatedgeek": "I got it working after rewriting the code ground up. Here it is for my specification of only implementing grant_type=password:\nphp\nclass Storage implements\nAccessTokenInterface,\nClientCredentialsInterface,\nUserCredentialsInterface,\nRefreshTokenInterface {\n // custom code here\n}\n. Fixed. Apache2 was stripping down the Authorization header due to unknown reasons.\nAdded the following to the .htaccess file:\n```\n    RewriteEngine On\n## Allow authorization header\nRewriteCond %{HTTP:Authorization} ^(.*)\nRewriteRule .* - [e=HTTP_AUTHORIZATION:%1]\n\n``\n. Such kind of access restriction can be achieved viascopes. I don't thinkgrant_type` would be recommended here.\n. You need to make your OAuth2 server stateless and for session storage use some fast key-value datastore like Redis. Whenever you query for session, it should fetch the value from Redis. This way you can scale to as many instances as possible without the need for sticky sessions.\nIf you cannot do that, and want sticky sessions, I would suggest using Nginx as a reverse proxy https://www.nginx.com/products/session-persistence/.\nWARNING: The sticky session way is probably a bad practice for your use case.\nAlso if you are using Laravel, try configuring your Session Driver.\n. @isko-algorithm I think that might not be directly available. If you want to do that, probably you can create a new TokenController. See http://bshaffer.github.io/oauth2-server-php-docs/overview/controllers/ and the source code there after for the signature of the class constructor.\n. ",
    "caleuanhopkins": "hey @phindmarsh. First off, thanks for confirming I am sane! :stuck_out_tongue: I think they missed the part where I did mention OAuth 2 and I got really confused.\n100% agree about the HTTP_REFERER, have avoided it like the plague, knowing it's easily mimicked. I am indeed using a JS app which means the client id and secret is off bounds for being passed through the HTTP requests. \nI am thinking I need to hmac sha512 encode the access token, domain address (pulled from JS' window.domain global variable) and a time stamp each is far too complex to be easily decoded. On the PHP side, I can decode all them apart and then use them as I needed, as well as confirm the domain. I do want to restrict our api to only be accessible to register clients, so this 'weird' encoding can be passed onto the client's easily in the docs. \nI think Twitter do some basecode 64 encoding with their access tokens too, not 100% sure. Anyway, would love to hear your thoughts on this setup.\n. The data isn't actually sensitive, actually it's data we will be happy to be shared publicly. The reason we want to limit access to the data a) we want to stop people taking the piss fire requests often. I have already put in a nginx request burst limit on the server and b) we want to ensure this data isn't put on other sites and drives traffic away from our site. If someone dicks about with the access and does get to the data, it's not really a big issue. I just don't want to give it to them on a sliver platter.\nI will add there is the option that just leaving these api calls public is more than acceptable. Mainly I'm wanting to exhaust all options of trying securing the data before admitting the sensible option is just to keep in open but limit the requests per minute.\n. @phindmarsh awesome. Thanks so much for the help. Setting up an OAuth2 server is brand new to me so I was totally unsure of where to go with this issue and had no luck on Google Mailing lists for OAuth and Stack Overflow. I'll be adding more details to the API to try and track as much as possible. I already have the tokens expiring within an hour, but I'm thinking about dropping it down to 30mins or so now. Thanks again for the help! :smile: :+1: \n. @bshaffer Interested to know why this was opened again, are you planning on building something into the library that would allow this?\nI was discussing this on the OAuth google group and someone metioned about the Holder of the Key token which is still in draft status: https://tools.ietf.org/html/draft-tschofenig-oauth-hotk-01\nJust thought I'd share it to this topic.\n. ",
    "Raphy": "I'm wanting to implement an introspection endpoint for our OAuth2 Authorization Server to our OAuth2 Resources Server validate an AccessToken.\nIt could be nice to call something like : \nphp\n$response = $server->handleIntrospectRequest($request, $response)\nThere is some news about the implementation of the introspection ?\nThe draft was validated into RFC 7662 -  OAuth 2.0 Token Introspection\n. ",
    "UniBW": "Are there any news on the introspection endpoint?\nCheers\nAndreas. ",
    "hellracer": "Yeah, I can concur that the response Content-Type is in  text/html;charset=UTF-8 is there a way to return in it application/json?\n. I solved this issue by modifying the content-type on the reverse proxy side\n. ",
    "dkcwd": "@bshaffer just wanted to let you know that the reason the build failed above is a fairly major issue surrounding ongoing support for PHP 5.3 and PHP 5.4 with the library.\nThe current develop build fails on Travis for 5.3 and 5.4 even when making changes to documentation due to the AWS dependency. \nHere is my Travis build with only a change to the README.md https://travis-ci.org/dkcwd/oauth2-server-php/jobs/68900529\nHere is the commit history for my test branch: https://github.com/dkcwd/oauth2-server-php/commits/feature/testing-current-develop-build \nFeel free to get in touch, I'd really like to have the option of using the extra config which my PR makes available.\n. I'm comfortable with leaving that method accessible from outside of the object but equally happy to change that if it's a blocker to moving forward with the change.\n. I wanted to keep tables names and identity columns separate but interested in your opinion.\nWhat are your thoughts based on that?\nHang on....did you mean why a second array? Yeah that's a good point, I'll fix that :+1: \n. Now part of the same array....\n. ",
    "TroRg": "Implement your own user_credentials storage from UserCredentialInterface and no needs to merge your users table with openauth_users. After that when you auth with password grant type your access tokens will be assigned with user_id and you can access your users roles in api\n. I found many mistakes in my code and closed it. Need more time to understand code and all processes. =)\n. ",
    "martinberlin": "Thanks for your answer. Is there any demo example of how to achieve this ?\nOut-of-the box it just comes every time the authorization and you generate a new access token and a refresh token everytime.. ",
    "CLANdok": "Check your column (access_token) size, in my case it was varchar(40), i changed it to varchar(255) and now it's working !!. ",
    "skoop": "I can not reproduce this problem on my local system, @shamanis, was there perhaps some temporary issue with some package server?\n. ",
    "Arany": "Hey there,\nI can see that this is apparently fixed with this commit  d00a4002f11157b9198a5e5dca077a7d0fb58302 in master (access_lifetime was missing in createDefaultJwtAccessTokenResponseType).\nI am using composer to have thi library up to date, so probably there is an old version still in composer.\n. ",
    "andriysilka": "Could you pls add that PR to next tag?\nThanks\n. Thanks!\n. ",
    "iam-merlin": "First draft, need to add test and use it a little more : https://github.com/eoko/oauth2-adapter-dynamodb\n. @bshaffer ping, any idea?\n. Hi @bshaffer , nice to hear you :D.\nAfter thinking a little... that's gonna be hard to include this v3 (or improved the actual class) in you repository nicely. The main (and only reason) is the aws-sdk... there is 2 versions and you actually suggest only \"aws-sdk-php\". If we add this one, we'll have to create a very long description in composer.json or in documentation to explain how to use this adapter specifically v3 (my point of view).\nUsing composer, this can be interesting to explode all adapter storage to different project? This will simplify the codebase, all unit test and with a simple require every dependencies needed will be directly include, developers will be able to choose a specific version (aws will create a v4, google same etc.)... \nso, What do you think (it's a little about the philosophy of the project with adapters ^^)  ? :p \n(By the way; really nice project + work)\n. :+1: \n. hi @nesinervink,\nI've the same issue that you ;).\nMy problem is slightly different. My token provider will be a client application which will ask Facebook for an access_token (or authorization code, I don't know now), which will be validating by a custom grant type.\nIn the ZF2 module for oauth2, grand type are locked to predefined grant type (like JWT) :/. I think we are stuck with the current code :'( .\nMaybe I'll create a pull request for that in the evening. @nesinervink, do you think it's a good idea?\n@phindmarsh ty for the gist ;)\n. ",
    "parallelaus": "Any update on this issue? Is it now possible to use AWS SDK 3.x ?\n. Is there any hope of getting this bug fixed?. ",
    "coachroebuck": "I've read across conflicting opinions online, most notably here:\nhttp://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data\nI also read up on the documentation related to the form-encoded body parameter:\nhttp://tools.ietf.org/html/rfc6750#section-2.2\nI have a situation in which I must upload binary data. Uploads were failing because of the line in question. The proposed solution crossed my mind. \nI decided to push this up and get feedback from the community. Perhaps someone else may have a better idea.\nbtw: I see there's an automated process that got triggered in response to submitting a merge request: https://travis-ci.org/bshaffer/oauth2-server-php/builds/74029210\n. Thanks for the feedback! Your note revealed a problem with the client: that access_token was part of the POST request. \nMobile apps: I believe I can. I can have the mobile apps convert the binary data into something more manageable data.\nWeb browsers: I'll turn around and test that image upload html page tonight. \nI'll go ahead and close this merge request. In the meantime, is it OK for me to reach out to you offline in the event I continue to run into problems? (I don't think I will, but just in case).\nThanks again!\n. ",
    "nesinervink": "Thanks a lot for the guidance @phindmarsh. I am using Facebook JS SDK aswell for the frontend and facebook/facebook-php-sdk-v4 for the backend.\nPlease note, that I am working on a ZF2 backend API.\nI have implemented the new grant type based on your example and tested it with the custom controller by injecting new grant type via controller factory and adding it by calling $this->getOAuth2Server( null )->addGrantType( $grant_type ) in controller's __construct method.\nWhile I am using custom controller and custom route (e.g. /oauth/fb-access-token), new grant type does not get injected globally - it is available only in the instance of ZF\\OAuth2\\Service\\OAuth2Server that is created in controller's factory, that way it's not possible to use this grant type in default /oauth route, which is served by default TokenController.\nSo the question would be: how should I add the new grant type to make it available to default OAuth2\\Controller\\TokenController?\nAs mentioned before, I have tried doing this by retreiving ZF\\OAuth2\\Service\\OAuth2Server using service manager in onBootstrap, but at that stage the service itself is not created yet and service manager only returns a closure.\nP.S. I am also hoping to make a public extension lib for oauth2-server-php to help others save some time on this matter.\n. @bshaffer, I think my problem is that I am not sure at which moment I should do this, because if I try to get ZF\\OAuth2\\Service\\OAuth2Server from service manager in Module.php's onBootstrap hook, then service manager returns only closure of server's factory as the server itself is not yet instantiated.\nThis is because the server only gets instantiated at this point:\nhttps://github.com/zfcampus/zf-oauth2/blob/master/src/Controller/AuthController.php#L106\nand in turn only then server instantiates TokenController by calling createDefaultTokenController().\nSo my guess is that either service manager should provide an instance of ZF\\OAuth2\\Service\\OAuth2Server instead of factory closure, or custom grant types should be allowed to be added via config. But I might be missing some reasoning behind current model.\n. So as I understand overriding OAuth2ServerInstanceFactory would be the propepr way to do this, while the constructor of server is called there. But still I see this as way too interventive, while the factory has some private properties and whole __invoke must be overriden. Does not seem to be very update-safe.\nit would be very helpful to get some input from ZF2 gurus. (summoning @weierophinney)\n. ",
    "fferrara": "@nesinervink  same problem here. Have you solved that? Can you help me out?\n. ",
    "stefanKBL": "Hum i'm late in this issue, but is it correct to update the refresh token expire date on refresh success, keeping the same refresh token  ?\nthanks\n. thanks, i'll deal with that. Because i developp an api server, i understand that i have to tell the clients apps to keep the refresh token sended first by api (token password) and to call the refresh token process in case of the ressource process respond \"token expires\". Lot of traffic if the token is short time, but it seems that this is the right way: it will be stupid i think if the api search about a valid refresh token for an expire token without client request!\nthanks a lot and good job for the library, easy to use.\n. ",
    "anek77713": "The issue is with the built in php server it passes the content type variable as HTTP_CONTENT_TYPE;\nThe issue can be solved by adding something like this\n        $contentType = $request->server('CONTENT_TYPE', '');\n        if ( empty($contentType) ) $contentType = $request->server('HTTP_CONTENT_TYPE', '');\n. if it has been patched , then no need for\nif ( empty($contentType) ) $contentType = $request->server('HTTP_CONTENT_TYPE', '');\nthnx! :)\n. ",
    "danr1979": "Thanks for your swift response! \nSo, I handle the username/password authentication manually using my own code & use either this library or another to generate the jwt. Then, once the jwt has been returned to the requestor they can submit that in subsequent requests & this library can verify them using the jwt bearer grant?\nIs that right?\nThanks.\n. OK understood. Thanks.\n. Yep, thanks for your help.\n. ",
    "hajekj": "Thanks a lot, that's exactly what I have been looking for!\n. ",
    "francislavoie": "This is extremely unclean. If I change the IdToken response type, then the other default response types will not be filled in at controller creation time. Also, there's no simple way to get the server's existing config array to pass into my custom IdToken class because the array is protected and the getter is for individual keys in that array.\nA thought would be to allow passing in fully qualified class name to be instantiated for the IdToken? I dunno.\nI just want to match the OpenID spec which defines profile and email as scopes that should be allowed.\nEdit: Silly workaround... $server->getAuthorizeController(); just calling this before trying to add my own response type makes the defaults get filled in first. This helps.\nEdit2: Apparently if I change the id_token response type, it doesn't also change the code id_token response type... so I need to add both of those. That's pretty convoluted.\nEdit3: Doing what I mentioned in my first edit doesn't work finally. The controller gets given the response types at its creation time so instantiating the defaults that way doesn't work; any subsequent changes to them don't get reflected in the controllers... :/\nAlso, getUserIdAndAuthTime() in IdToken is private, so overriding this class doesn't fully work out of the box. It should probably be protected.\n. https://github.com/dsquier/oauth2-server-php-mysql\nThis ddl has redirect_uri as not null, that's why I had this same issue.\n. ",
    "arufian": "@pjebs Thanks. I'll try that.\n@Spomky Thanks. I guess custom URI also the solution for this.\nAnd regarding to google OAuth2, unfortunately our application policies not allowed external resources handling this job.\n. ",
    "amahrt": "+1\n. ",
    "Patroklo": "I think it's not a very big change to implement ClientAssertionblah in that library or, if that breaks backwards code, adding a new grant that does so. \nBut let's better wait for some module developer, probably there's something wrong in my understanding.\n. @ssanders another lame workaround that I have managed to do it's making a clientName and clientPassword as NULL, that way it worked fine, but still had to send empty parameters for those...\n. But, as I read in that text you have pasted, the client authentication would be only required if the client is confidential or you pass that credentials, doesn't say anything about making it a required field. \nAs I understand (I repeat, probably I'm wrong, but that's what I understand in that specification) what you are doing it's allways counting  the client as a confidential one or requiring that field, but there is also the third option in which you don't  have to use that field in this grant type.\nSorry if I'm annoying, but I'd like to clarify this point.\nEdit: Ok, I'm dumb. Reading more articles, I finally see that you MUST send via Authorization header the client infor, as stated here and here.\nEdit2: also, point out that if you are using LAMP you should activate in the .htaccess the Authorization header or this won't work adding: RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n. ",
    "tobias74": "since I have copypasted lots of code from the original cassandra storage, maybe there should be a common base-class for both storages.\nI did not want to be too intrusive, so I left existing code unchanged and just added the new storage.\n. I will add the tests this weekend, I have to get up to speed with Travis-CI. :-)\nHow could I run the tests locally?\n. I have added the tests according to the existing Cassandra-Storage. Three of my tests are still failing when I run phpunit locally:\n1) Warning\nThe data provider specified for OAuth2\\OpenID\\Storage\\AuthorizationCodeTest::testCreateAuthorizationCode is invalid.\nline 1:173 extraneous input ')' expecting EOF\n2) OAuth2\\OpenID\\Storage\\UserClaimsTest::testGetUserClaims with data set #9 (OAuth2\\Storage\\CassandraCQL Object (...))\nFailed asserting that 'testuser@test.com' matches expected null.\n3) OAuth2\\Storage\\PublicKeyTest::testSetAccessToken with data set #9 (OAuth2\\Storage\\CassandraCQL Object (...))\nFailed asserting that '-----BEGIN CERTIFICATE-----\nMIICiDCCAfGgAwIBAgIBADANBgkqhkiG9w0BAQQFADA9MQswCQYDVQQGEwJVUzEL\n...\nFRrlM1f6s9VTLWvwGItjfrof0Ba8Uq7ZDSb9Xg==\n-----END CERTIFICATE-----' matches expected null.\nI am still looking into that, maybe someone could point me in the right direction?\nThank you :-)\n. Yes, I had an error in my CQL! Now the tests seem to pass:\n\nOK, but incomplete, skipped, or risky tests!\nTests: 407, Assertions: 1197, Skipped: 126.\n\nConcerning advantages and disadvantages: I don't know :-)\nI had to choose a library in order to get started with cassandra. So I went with the datastax-library because it came up first on google and the given examples used CQL-Queries. \nOne downside of the datastax-library is the somewhat involved setup-process (\"pecl install cassandra\" throws errors on my machine, so I had to build from source manually).\nThe name \"CassandraCQL\" is just a working title, I am open to suggestions :-)\n. Thanks @Dylan1312 :-)\nshould I just copy your code or do you want to issue a pull-request?\n. I only wanted to change one line in the file \"src/OAuth2/Storage/Cassandra.php\".\nI dont really know how I ended up altering 3 files. I did not temper with the file \"src/OAuth2/Controller/AuthorizeController.php\", but anyway, there is a change?\n. there is a revised version of this pull-request, closing this now.\n. ",
    "Dylan1312": "This is exactly what I was about to start writing! Thanks @tobias74 \n. To add, phpcassa is deprecated and the author recommends moving to Datastax.\nAlso @tobias74, I noticed you haven't made us of Cassandra's row TTL to have tokens automatically expire. The $expire variable passed into setValue() is ignored. I wrote an example quickly if you'd like to look -> https://github.com/Dylan1312/oauth2-server-php/commit/b583ae8edd9486feef4844d05f9add1a5baa1c7a\n. Go ahead and copy if you're happy with it :+1: \n. ",
    "DavidBurgess1984": "I agree with the above - OAuth2\\Server::setKeyStorage() does not exist.  Would appreciate if this could be looked into.\n. ",
    "Qronicle": "Thanks for that @afilippov1985 :)\n. ",
    "tainazao": "Thank you so much @afilippov1985 \n. ",
    "matias-larsson-primeo": "Hi,\nI am facing an issue with the same part of the library, however mine is slightly different; the AuthorizeController doesn't validate user scope, so the access token's scope might become \"wider\" than the user's scope(s). This happens when the client has \"wider\" scopes than the user.\nLet me explain:\nIn my case I'm using the authorization_code method. In my context there are two scopes, and a user may have zero, one or both. The client must have both because the scope is validated from the client's scopes ( https://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Controller/AuthorizeController.php#L241 ). Now, even if the user has neither of the requested scopes, the access token will be granted to any requested scope that the client has.\nIsn't this a security issue?. Thanks for your reply.\nI didn't try that originally because I would like to have just one mysql connection in the application. However, I was unable to find information about if the clone actually results in a new connection, so I tried. Turns out the clone causes my apache server to crash (SEGFAULT). I haven't investigated further but it seems like it is not an option to clone PDO here.\nEdit: corrected \"SIGTERM\" -> \"SEGFAULT\"\nBR,\nMatias Larsson. Hi,\nOne more correction: I think it's just the PHP process that segfaults, not the server.\nI made a google search and found this: https://bugs.php.net/bug.php?id=49664\nI think it could cause the segfault when cloning PDO, and is the reason why cloning PDO is out of question. Perhaps it is because PDO is implemented in the PHP sources and not as a PHP class.\nJust wanted to share these points if anyone is looking into the issue.. I assume you would like a demonstration?\n```\n<?php\nini_set(\"display_errors\", 1);\nerror_reporting(-1);\nrequire_once(DIR . '/lib/oauth2-server-php-1.9.0/src/OAuth2/Autoloader.php');\nOAuth2\\Autoloader::register();\n$username = \"test\";\n$password = \"test\";\n$db_name = \"testdb\";\n$host=\"localhost\";\n$pdo = new \\PDO(\"mysql:dbname={$db_name};host={$host}\", $username, $password);\n$server = new OAuth2\\Server(new OAuth2\\Storage\\Pdo($pdo));\n$stm = $pdo->prepare(\"SELECT * from tbl\"); // non-existing table\nif ($stm->execute()) { // execute() throws, since OAuth2\\Storage\\Pdo changed the errmode\n    // ...\n} else {\n    echo \"error handling\";\n}\n// Fatal error: Uncaught exception 'PDOException'\n// After commenting out this line\n//     $connection->setAttribute(\\PDO::ATTR_ERRMODE, \\PDO::ERRMODE_EXCEPTION);\n// in lib/oauth2-server-php-1.9.0/src/OAuth2/Storage/Pdo.php, \"error handling\" will be printed.\n```\nI find this problematic especially for situations where the application should have only one MySQL connection and where a large codebase already depends on the default errmode.\nBy the way, I just want to say that your library has otherwise been amazing. Thank you for your great work!. Thanks.\nYes, when I clone the PDO instance, the PHP process seems to segfault. The script aborts and this is appended to apache error log:\n[notice] child pid 56633 exit signal Segmentation fault (11)\nInterestingly, it doesn't happen on the example I provided (by changing new OAuth2\\Storage\\Pdo($pdo) to new OAuth2\\Storage\\Pdo(clone $pdo) ), but does happen in the application code. In the application the PDO instance is owned by more than one object (as a class member) - other than that I don't know why it only crashes in the application. Must be that or something else that is done with the instance. I might look into this later, and if so, I will return with more info.. ",
    "krokwen": "oh my... its was stupid... sorry...\n. ",
    "EugeneLiang": "Hi there, thanks for the speedy reply! Much appreciated.\nAnother not so smart question following your answer: what about the first 3\nargument of handleAuthorizationRequest ? Do they have to be strictly Oauth\nobjects? ( I'm a php noob )\nCheers!\nOn Tue, 13 Oct 2015 at 08:42 Brent Shaffer notifications@github.com wrote:\n\nHell Eugene! Thanks for your question!\nThe fourth argument to handleAuthorizationRequest should be your $user_id,\nwhich I imagine will be in the array somewhere.\nAs for the wordpress UserStorage adapter, there is a Wordpress plugin\nhttps://wordpress.org/plugins/oauth2-provider/ which uses a version of\nthis library, and uses an OAuth2\\Storage\\Wordpressdb\nhttps://github.com/justingreerbbi/wordpress-oauth-server/blob/master/library/OAuth2/Storage/Wordpressdb.php\nclass that may be what you're looking for.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bshaffer/oauth2-server-php/issues/653#issuecomment-147558928\n.\n. \n",
    "dschreck": "I've recently integrated into a project, following docs was simple. Go to http://bshaffer.github.io/oauth2-server-php-docs/ - if you've read all the documentation and have an understanding of how OAuth works you will not be confused. \n. ",
    "msyadav88": "Actually I want to integrate the oauth2 with the wordpress plugin WP OAuth Server . Is oauth2-server-php the client library or server library ? \nI want a client library from which i can sent request to wordpress plugin and access data from wordpress site.\nPlease let me know if I am at right direction.\n. Thanks Brent for your important support,\nI have used the oauth2-client setup in my code but any code after including the GenericProvider.php file is not executed( line no 7 in below code). The code stucked on the GenericProvider.php file. I think there is the syntax error of square bracket used in GenericProvider.php as array ( line no 109 )\nPlease let me know if there is any error in library?\nphp\nrequire_once('config.php');\nrequire_once 'library/class.phpmailer.php'; \nerror_reporting(E_ALL);\ntry {\nrequire(PHYSICAL_PATH2.'oauth2-client-master/src/Provider/GenericProvider.php');\necho PHYSICAL_PATH2.'oauth2-client-master/src/Provider/GenericProvider.php'.'dfd';\n//require('oauth2-client-master/src/Provider/Exception/IdentityProviderException.php');\ndefine('REDIRECT_URI',$dynamiclink.'/createpage_api2.php');\ndefine('AUTHORIZATION_ENDPOINT',$wordpress_site.'oauth/authorize');\ndefine('TOKEN_ENDPOINT',$wordpress_site.'oauth/token');\n$provider = new \\League\\OAuth2\\Client\\Provider\\GenericProvider(array('clientId' = CLIENT_ID, 'clientSecret'            => CLIENT_SECRET,    'redirectUri'             => REDIRECT_URI,    'urlAuthorize'            => AUTHORIZATION_ENDPOINT,    'urlAccessToken'          => TOKEN_ENDPOINT,    'urlResourceOwnerDetails' => 'http://brentertainment.com/oauth2/lockdin/resource'));\n.",
    "Alexanderstephengreenwood": "Hi Kami-no,\nIt looks like the implicit grant needs to be set to true also.\nI'm struggling on setting the oauth config on that bit... Same with Postman app on Chrome.\nRegards,\nalex\n. ",
    "Kami-no": "Check #659 \n. ",
    "thrashy": "Sure. It seems to work using 'assertion' except that the subject of the JWT is used differently between the authorization grant and client authentication in the RFC(authorized user vs client id). I'm only using JWT for client authentication but someone using the database as a storage mechanism for both might be a bit tricky, without creating a second table or adding an additional column.\nJwtBearer is using the 'issuer' field of the JWT as the client id. As far as I can tell, the issuer and the subject seem to be analogous when performing client authentication in the RFC. I'm assuming I can use the same value for both since the client is the entity issuing the JWT. The spec doesn't say anything about validating the subject for client authentication.\n. ",
    "JanZelenka": "Hi!\nSorry for the dig but i ran into exactly the same problem. if one wishes to implement an FHIR complient API server the following POST request must be supported:\nscope | required | The scope of access requested. See note about scopes below\ngrant_type | required | Fixed value: client_credentials\nclient_assertion_type | required | Fixed value: urn:ietf:params:oauth:client-assertion-type:jwt-bearer\nclient_assertion | required | Signed authentication JWT value (see above)\nIt did take me some time but I did figure the following workaround out:\n`\n$objRequest = OAuth2\\Request::createFromGlobals();\n    if (\n            $objRequest->request('grant_type') === 'client_credentials'\n             and\n            $objRequest->request('client_assertion_type') === 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'\n            )\n    {\n        $objRequest->request['grant_type'] = 'urn:ietf:params:oauth:grant-type:jwt-bearer';\n        $objRequest->request['assertion'] = $objRequest->request('client_assertion');\n    }\n\n    $this->oauth2->handleTokenRequest($objRequest)->send();`\n\nSo far this seems to deliver exactly what the FHIR specs require but it would still be great if the library supported grant type client_credentials with client assertion type jwt-bearer out of the box.. ",
    "DaCardinal": "@bshaffer I made edits to fix this on the PDO storage would try and do a Pull request. Need to add tests too haven't tried the other storages\n. ",
    "Jiekai": "Hey Brent,\nI solved it. Turns out it was a simple directory error.\nDate: Tue, 8 Dec 2015 13:16:42 -0800\nFrom: notifications@github.com\nTo: oauth2-server-php@noreply.github.com\nCC: jiekaii@hotmail.com\nSubject: Re: [oauth2-server-php] Question regarding Token Controller (#679)\nLooks like you were able to solve this issue?\nIt is recommended you use composer instead of the built-in autoloader.\n\u2014\nReply to this email directly or view it on GitHub.\n. ",
    "yuql": "I get it.\nThanks.\n. ",
    "viyancs": "where that location  \"restricted_grant_types\" parameter in Client Storage?\n. Can u Explain More detail ? for this issue i have an idea but iam not sure this is better way or not,every app request to end point that use access_token right, maybe we can deal with this\n1. get access_token from parameter then check in table oauth_access_tokens to get client_id\n2. adding filter by client id inside endpoint example \njavascript\npublic function product() {\n   $access_token = $_GET['access_token'];\n   $db_access = OauthAccessToken::find()->where('access_token',$access_token)->get_one();\n   if (!empty($db_access) && $db_access->client_id === 'xxxxxx.xxxx.xxx') {\n     //todo code\n   }\n   else { \n     //error response \n   }\n}\n. ",
    "BrandonShega": "Oh awesome, I finally figured out how the refresh token works.  I have another quick question, am I able to implement the TokenControllerInterface to override those methods?  Our API uses a specific response design and I would like to maintain that instead of using the predefined responses.\n. Never mind, I figured it out :) Thanks for your help!\n. Never mind, I think it was the send() that was getting called, I will just send an error if there is one.\n. Sorry to bring this up again, when I run the first line $tokenResponseType is empty and then the second line says that I'm trying to call a function on a non-object.  Is there something that needs to be set up ahead of time for this?\n. Ya it's more of if the user is logging in with Facebook, they don't have a username/password so I need to be able to manually generate an access and refresh token to be able to pass back to the app to make API calls with.\n. ",
    "bluebaroncanada": "I will do this.  I want this, too.. So, with #701, this is passing?. So @bshaffer, unless you say otherwise, I'll merge this and #701 in about a week.. I agree.. You'll probably have to implement a version of your own for PayPal. It's really very simple.  Just copy the code from one of the existing implementations and modify it to suit your needs.  If you come up with something that works, please feel free to make a pull request.  I'm going to close this as \"Won't Fix\" for now, but if you really feel it should be here and you can convince me with a solid argument, I'll mark it for 2.0 or 3.0 implementation.. I'll look into this, but I'm marking it as an Enhancement unless you can prove it's a bug. . Do you have your routes configured for what method you're using?  I don't know Laravel too well, but in Zend Framework, there is a 'verb' option that you can set and if you try to submit with an unconfigured verb after setting explicit options, you'll end up with this error.. Yeah.  Sorry.  I thought you were saying, \"Closed because it's not easy to do.\". @MajesticMaje so if you use the develop branch, you should be all set.. Did you ever resolve this issue?\n. Do you have any code that you can provide?. Agreed.  I can see other utility for this issue.  I'm actually going to mark this as an enhancement.  I want to leave the PDO class itself closed; however, I'm writing a new PDO MySql class and I will put this in it.  \nYou said it SEGFAULTs?. That would be much appreciated.\n. I'm assigning this issue to version 2.0 unless you have a dire need for it in 1.8.. I'll have to look at this, but it might be behaviour by design.  I'll assign this for now but I might not get to it for a couple weeks.. Response::send($format). Can you create a pull request for this as well as making sure any necessary tests are implemented?. Can you please provide me some information on this?  What storage adapter are you using?  Can you give me a code snippet?. If you use use, you don't need the preceding \\.. Yeah.  Sorry.  I think that made some of you think that I actually care. :p . Can you post a link?. So, I think what he's saying is that you can pass in more than one interface that implements the storage.\n\"This library allows you to back up the access tokens to secondary storage. Just pass an object implementing OAuth2\\Storage\\AccessTokenInterface to the JwtAccessToken object to have access tokens stored in an additional location:\". Here's the signature for the constructor for Server:\n/**\n     * @param mixed                                                   $storage             (array or OAuth2\\Storage) - single object or array of objects implementing the\n     *                                                                                     required storage types (ClientCredentialsInterface and AccessTokenInterface as a minimum)\n     * @param array                                                   $config              specify a different token lifetime, token header name, etc\n     * @param array                                                   $grantTypes          An array of OAuth2\\GrantType\\GrantTypeInterface to use for granting access tokens\n     * @param array                                                   $responseTypes       Response types to use.  array keys should be \"code\" and and \"token\" for\n     *                                                                                     Access Token and Authorization Code response types\n     * @param \\OAuth2\\TokenType\\TokenTypeInterface                     $tokenType           The token type object to use. Valid token types are \"bearer\" and \"mac\"\n     * @param \\OAuth2\\ScopeInterface                                   $scopeUtil           The scope utility class to use to validate scope\n     * @param \\OAuth2\\ClientAssertionType\\ClientAssertionTypeInterface $clientAssertionType The method in which to verify the client identity.  Default is HttpBasic\n     *\n     * @ingroup oauth2_section_7\n     */\npublic function __construct($storage = array(), array $config = array(), array $grantTypes = array(), array $responseTypes = array(), TokenTypeInterface $tokenType = null, ScopeInterface $scopeUtil = null, ClientAssertionTypeInterface $clientAssertionType = null)\nThat might help.. There's a method at the bottom of Pdo.php that has all the tables.  Don't use the ones from the docs.  I've already submitted a couple of issues with his docs.. You should use checkUserCredentials.\nAlso, he's using sha1 encryption, and you're right, that should be return password_hash($plainTextPassword, PASSWORD_DEFAULT); and return password_verify($this->plainTextPassword, $this->user->getPasswordHash()); in the repo code.  You don't actually have to deal with that.  You just pass in the plain-text password.  You should try to learn how to read other people's code.\nYou can do a few things from here:\n1) Acquiesce to using the built in sha1 hashing.\n2) Submit a pull request that fixes this.\n3) Implement a new storage interface that implements the same interfaces.\n4) Extend the storage class and override the methods that you want to.\n. Yeah.  I was reading that.  It says that it MUST return fragment unless the response mode is \"specified\".  Do you know if that means it should override the default?. It's the preference but the default can be set by the application.. It does mention that, too, in the link in the first comment.. This was a docs issue.  A commit was made to the new docs and @bshaffer rebuilt last night.  There are many tickets associated with schema problems and they can probably be closed now.. Did you actually check this with Wireshark?  Can you try to log the value of statusCode?  Something fishy about that.. Thank you for that update!  Much appreciated.. It also doesn't set the email which is also used as the key in one of the tests.. You can delete the old ones.  Right now deleting actually deletes the token from the database, but I think it should keep the token, but set a deleted flag, so that you can review a record of issued tokens.  You could create an index if things are slow.  Are you using the PDO connector with MySql?. Well you can just write a script to clean up tokens every 24h or so.  In doing that, you could also just create an is_deleted flag and mark it as deleted.  You would probably want a compound index on is_deleted and the primary key.\nIt's up to you.  Either way will be pretty fast, but if you never need to audit, you can just delete the token.. I don't know anything about DynamoDB and I have a thesis and a full-time job.  If it is me that gets around to this, it could be a while.\nAre you debugging this with xdebug?. Do you have some code that I can look at?. I traced all usages of this variable and I think this is safe, though, I think what might be better is changing line 525 from if (0 == count($this->responseTypes)) { to if (!isset($this->responseTypes) || 0 == count($this->responseTypes)) {.  This will have fewer effects on the code.. I'm worried this commit or commits like it could cause other logical statements to trigger.  For example: null checks.. It might not just be internal code that's affected by this change, too.. Never mind.  It shouldn't be an issue.  My apologies.. Err.  Actually it is if $a=[]; $a===null;. I don't like any of this.  It violates the paradigms the library was built on.  I love doing callbacks like this, but it ought to be consistent.  If it's coming down to just an array merge, I think #795 is the place to do this.. ",
    "ojgarciab": "Could I help on this?\nThe solution should be a mixed storage solution because it is not a good idea to use LDAP as data storage.. ",
    "caidollar": "fixed. Caused by the php version. I istalled the php5.4, ok now.\n. ",
    "MyGuySi": "Perfect, thanks very much!\n. ",
    "Ganganation": "OAuth2\\Storage\\PDO\n. I created a little abstraction layer for the grant types, so this basically is my code:\n```\n$dsn = sprintf('%s:dbname=%s;host=%s', 'mysql', 'database', 'localhost');\n$username = 'username';\n$password = 'password';\n$storage = new OAuth2\\Storage\\Pdo(\n    [\n        'dsn' => $dsn,\n        'username' => $username,\n        'password' => $password,\n    ]\n);\n$server = new OAuth2\\Server($storage, [\n        'access_lifetime' => 86400, // 1 day\n        'refresh_token_lifetime' => 2419200, // 28 days\n        'always_issue_new_refresh_token' => true,\n        'unset_refresh_token_after_use' => false\n]);\n$grantTypes = [\n    'user_credentials' => 'UserCredentials',\n    'client_credentials' => 'ClientCredentials',\n    'authorization_code' => 'AuthorizationCode',\n    'refresh_token' => 'RefreshToken'\n];\n$serverGrants = [\n    'user_credentials',\n    'refresh_token',\n];\nforeach ($serverGrants as $grant) {\n        if (isset($grantTypes[$grant])) {\n            $class = 'OAuth2\\GrantType\\'. $grantTypes[$grant];\n            $grantClass = new $class($storage);\n        $server->addGrantType($grantClass);\n    } else {\n        throw new \\Exception(\"Grant type \". $grant .\" could not be added to server. It does not exist. Please use on of these\". print_r($grantTypes));\n    }\n\n}\n```\nRunning PHP version 5.6\n. You're awesome! That worked!\n. ",
    "ickyfoot": "Great stuff, afilippov1985, many thanks!. ",
    "jokabuyasina": "@ jahrralf I have the issue I tried your solution, still not returning a new refresh token.\nThis is my server.php\n$dsn      = 'mysql:dbname=;host=localhost';\n$username = '';\n$password = '';\n// Autoloading (composer is preferred, but for this example let's just do this)\nrequire_once('oauth2-server-php/src/OAuth2/Autoloader.php');\nOAuth2\\Autoloader::register();\n// $dsn is the Data Source Name for your database, for exmaple \"mysql:dbname=my_oauth2_db;host=localhost\"\n$storage = new OAuth2\\Storage\\Pdo(array('dsn' => $dsn, 'username' => $username, 'password' => $password));\n$server = new OAuth2\\Server($storage, [\n        'access_lifetime' => 1209600, \n        'refresh_token_lifetime' => 2700000, \n        'always_issue_new_refresh_token' => true,\n        'unset_refresh_token_after_use' => false\n]);\n$server->addGrantType(new OAuth2\\GrantType\\RefreshToken($storage));\n// Add the \"Client Credentials\" grant type (it is the simplest of the grant types)\n$server->addGrantType(new OAuth2\\GrantType\\ClientCredentials($storage));\n// Add the \"Authorization Code\" grant type (this is where the oauth magic happens)\n$server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($storage));    . ",
    "pYr0x": "maybe the docs should be clear about the config.\nthe configs that can be set by new \\OAuth2\\Server() only get used by the method getDefaultGrantTypes(). this method only gets called if you provide no storage array to the server. see code:\n...\nif (0 == count($this->grantTypes)) {\n  $this->grantTypes = $this->getDefaultGrantTypes();\n}\n...\nthe docs should mention that if you use addGrantType() or add grant types to the server, the config that is also passed to the server constructor are not used for the grant types you added manually!\nsummary:\nthis is not working:\n```\n        $pdoStorage = new \\OAuth2\\Storage\\Pdo($pdoConnection);\n        $userCredentialStorage = new \\twentytwo\\extensions\\OAuth\\UserCredentialStorage($pdoConnection);\n        $accessTokenStorage = new \\twentytwo\\extensions\\OAuth\\AccessTokenStorage($pdoConnection);\n    $app['oauth.server'] = new \\OAuth2\\Server([\n        // storages\n        'access_token' => $accessTokenStorage,\n        'refresh_token' => $pdoStorage,\n        'client' => $pdoStorage,\n        'scope' => $pdoStorage,\n        'user_credentials' => $userCredentialStorage\n    ], [\n        // configs\n        'always_issue_new_refresh_token' => true,\n        'refresh_token_lifetime'         => 2419200\n    ], [\n        // granttypes\n        'password' => new \\twentytwo\\extensions\\OAuth\\UserCredentials($userCredentialStorage),\n        'refresh_token' => new \\OAuth2\\GrantType\\RefreshToken($pdoStorage)\n    ]);\n\n```\nand should be:\n```\n        $pdoStorage = new \\OAuth2\\Storage\\Pdo($pdoConnection);\n        $userCredentialStorage = new \\twentytwo\\extensions\\OAuth\\UserCredentialStorage($pdoConnection);\n        $accessTokenStorage = new \\twentytwo\\extensions\\OAuth\\AccessTokenStorage($pdoConnection);\n    $app['oauth.server'] = new \\OAuth2\\Server([\n        // storages\n        'access_token' => $accessTokenStorage,\n        'refresh_token' => $pdoStorage,\n        'client' => $pdoStorage,\n        'scope' => $pdoStorage,\n        'user_credentials' => $userCredentialStorage\n    ], [\n        // configs\n\n    ], [\n        // granttypes\n        'password' => new \\twentytwo\\extensions\\OAuth\\UserCredentials($userCredentialStorage),\n        'refresh_token' => new \\OAuth2\\GrantType\\RefreshToken($pdoStorage, ['always_issue_new_refresh_token' => true])\n    ], [\n        // response types\n        'token' => new \\OAuth2\\ResponseType\\AccessToken($accessTokenStorage, $pdoStorage, ['refresh_token_lifetime' => 2419200])\n    ]);\n\n``` \n. ",
    "nuffstuff": "I'm hitting this now. \nOne thing to note: as this field is a primary key and if you use innodb then the varchar field has a limit of 767 bytes. MyIsam has the full 65,535 byte size but then you may need to consider the size of the resulting index.\n. @dsquier, can you double check the innodb document for that field? http://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_large_prefix. As i read it, it is only the parameter that allows large keys to be disabled which is being deprecated. I believe it is now enabled by default, providing the correct row format is used.\nRegarding my own usage i need to double-check what parameters go into making the JWT that size in the first place. \n. ",
    "Askab": "Thank you for the answer!\nI changed,but i'm got the same error.\n. ",
    "Makimizu": "thank you so much. it's worked. \n. ",
    "gradosevic": "I have resolved this issue. The problem was that authentication header was received as \"null\" on server. To fix it, I've added this to my .htaccess file:\n``` apacheconf\n\n    RewriteEngine On\nRewriteCond %{HTTP:Authorization} ^(.*)\nRewriteRule .* - [e=HTTP_AUTHORIZATION:%1]\n\n\n```\n. ",
    "chrismatchett": "Thanks gradosevic for finding this needle in a haystack. I had the same issue when I moved my oauth2 server to another host.\nChris. Thanks CameronGo,\nI will use your solution as a starting point.\nI know I'm missing something but it's still curious to me why Google/Facebook don't hash these passwords...I'm sure the penny will drop at some point.\nThanks again,\nChris\n. ",
    "bkcummins": "any additional thoughts on this?  how did you end up handling a jwt token revoke?\n. Will do...thx!  bkc\n. You're likely trying to access the endpoint as a GET but haven't set it up properly in your Laravel routes.\nHere is one example of what that could look like:\nRoute::get('oauth/token', 'YourController@yourMethod');\nThe Routes file location changed from Laravel 5.2 to 5.3.  Have a look at the docs for further examples.\nhttps://laravel.com/docs/master/routing\n. I am customizing the JWT payload by extending the OAuth2\\ResponseType\\JwtAccessToken and OAuth2\\Controller\\TokenController classes which are referenced where you create your OAuth2Server.\nMy JwtAccessToken extension only uses the createAccessToken method, and this is where you can customize the payload.  \nMy TokenController extension only uses the grantAccessToken method.\nHope that helps.. ",
    "mervick": "It works using this code\n```php\n    / @var \\OAuth2\\Server $server */\n    / @var \\OAuth2\\Storage\\PDO $storage */\n    $storage = $server->getStorage('access_token');\n    $refreshStorage = $server->getStorage('refresh_token');\n$config = [\n    'token_type' => $server->getConfig('token_type', 'Bearer'),\n    'access_lifetime' => $server->getConfig('access_lifetime'),\n];\n\n$token = new \\OAuth2\\ResponseType\\AccessToken($storage, $refreshStorage, $config);\n$accessToken = $token->createAccessToken($clientId, $userId);\n\nprint_r($accessToken);\n\n```. ",
    "adamteller-macmillan": "Thanks for your feedback. I consulted with my OPS team and they have resolved the issue. It was a very simple change at their side, and now things work as expected.  You may close this issue.\nThanks for your response, Adam\n. ",
    "derek-b": "From what I can tell, the main feature that would need to be supported is sending the session_state parameter with the authorization request.\n. ",
    "ErwinSteffens": "This would be awesome if integrated. We have done it by extending some controllers, and more. It would be great if it could be implemented in the library.\nAlso the monitoring of the session state would be really helpful: https://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification. ",
    "arthurlima96": "@bshaffer when pull request can be merged with the master branch ?. ",
    "CameronGo": "Sorry, I didn't see this one before I opened #734 and #726\n. Sorry for being dense, but I wanted to confirm: Do you mean I should create my own custom storage object that implements these classes (checkClientCredentials and setClientDetails)?  I didn't see a setClientCredentials and I was also uncertain if there was another way to override the classes you mentioned without creating a custom storage class.  \nThanks in advance, this library has been a huge help so far.\n. Just wanted to leave a note of thanks and also to post the code I implemented in case it is helpful to someone else.  I deviated from the example above in order to use the password_hash and password_verify functions, which do return different results each time the hash is run.  This precludes the ability to check the hash result directly against what is returned from the DB.  \nThe other thing I implemented here is an additional field in my client_table (client_name) in order to provide a user friendly name for the client that can be displayed on the authorization page, or anywhere else that might end up end-user facing.\n``` php\nnamespace OAuth2\\Storage;\nclass HashClientSecretPdo extends Pdo implements ClientCredentialsInterface {\n    / OAuth2\\Storage\\ClientCredentialsInterface /\n    public function checkClientCredentials($client_id, $client_secret = null)\n    {\n        $stmt = $this->db->prepare(sprintf('SELECT * from %s where client_id = :client_id', $this->config['client_table']));\n        $stmt->execute(compact('client_id'));\n        $result = $stmt->fetch(\\PDO::FETCH_ASSOC);\n    // make this extensible\n    return $result && password_verify($client_secret, $result['client_secret']);\n\n}\n\npublic function setClientDetails($client_id, $client_secret = null, $redirect_uri = null, $grant_types = null, $scope = null, $user_id = null, $client_name = null)\n{\n    $client_secret = $client_secret ? password_hash($client_secret, PASSWORD_DEFAULT, ['cost' => 12,]) : null;\n    // if it exists, update it.\n    if ($this->getClientDetails($client_id)) {\n        $stmt = $this->db->prepare($sql = sprintf('UPDATE %s SET client_secret=:client_secret, redirect_uri=:redirect_uri, grant_types=:grant_types, scope=:scope, user_id=:user_id, client_name=:client_name where client_id=:client_id', $this->config['client_table']));\n    } else {\n        $stmt = $this->db->prepare(sprintf('INSERT INTO %s (client_id, client_secret, redirect_uri, grant_types, scope, user_id, client_name) VALUES (:client_id, :client_secret, :redirect_uri, :grant_types, :scope, :user_id, :client_name)', $this->config['client_table']));\n    }\n\n    return $stmt->execute(compact('client_id', 'client_secret', 'redirect_uri', 'grant_types', 'scope', 'user_id', 'client_name'));\n}\n\n}\n```\n. @bshaffer Won't that just return the ClientAssertionType?  I don't think that will allow me to use the validateRequest function to authenticate the clientID and clientSecret credentials.\n. Yeah - I think I was trying to avoid instantiating another ClientAssertionType outside of the server object.  I prob didn't explain that adequately.  I have a solution working, but by doing exactly that.  Not sure how clean this is, but it works.\n``` php\n$request = OAuth2\\Request::createFromGlobals();\n$response = new OAuth2\\Response();\n$clientstorage = $server->getStorage('client_credentials');\n$clientassertion = new OAuth2\\ClientAssertionType\\HttpBasic($clientstorage);\n$authenticated = $clientassertion->validateRequest($request, $response);\nif ($authenticated!==true) {\n    exit('The client credentials provided are invalid.'.PHP_EOL);\n}\n$client_id = $clientassertion->getClientId();\n$client_details = $clientstorage->getClientDetails($client_id);\n```\n. I'm definitely a novice, so I assume I'm just missing something.  I realize now that I think you're saying this will return the actual ClientAssertionType object, whereas I had believed it was simply going to return some sort of value indicating which ClientAssertionType was in use.\nIf I understand your suggestion, then what I want to do is this:\nphp\n$request = OAuth2\\Request::createFromGlobals();\n$response = new OAuth2\\Response();\n$clientAssertionType = $server->getClientAssertionType();\n$authenticated = $clientAssertionType->validateRequest($request, $response);\nWhen I modify my code to do this; however, I get the following response:\nFatal error: Call to a member function validateRequest() on a non-object\nWhen I var_dump('$clientAssertionType') it simply outputs null.\n. @bshaffer : I decided to circle back and patch this in my code by extending your class.  (I would attempt a fix and pull request to benefit everyone, but I am not great at this and not sure how to build the test cases, etc.)  I have the below code for the PDO class, which I think addresses the issue you highlighted, but I'm not very sure where to implement it with the least impact to the rest of the classes.\nCan I just create a new file (customPDO.php) with just the one function like this:\n``` php\n<?php\nclass customPdo extends Pdo implements AccessTokenInterface {\n    public function unsetAccessToken($access_token)\n    {\n        $stmt = $this->db->prepare(sprintf('DELETE FROM %s WHERE access_token = :access_token', $this->config['access_token_table']));\n        $stmt->execute(compact('access_token'));\n    return ($stmt->rowCount() > 0);\n}\n\n}\n```\nThen include that file, and instantiate it as I would the original Pdo class and use my $storage object for everything the same as I am already?\nphp\n$storage = new OAuth2\\Storage\\Pdo(array('dsn' => $dsn, 'username' => $username, 'password' => $password));\nI apologize for the questions.  I'm OK at hacking stuff together, but still very much a novice.\n. @bshaffer I apologize in advance for the stupid question, but should i be including your master branch in my project, or this develop branch?\n. Hey @bshaffer , sorry for the long delay.  I hadn't had a chance to circle back to this until now.  I was basing my assumption on this section of the RFC that is referenced in the revoke endpoint documentation:\nhttps://tools.ietf.org/html/rfc7009#section-2\nIt mentions here:\n\nThe client also includes its authentication credentials as described\n   in Section 2.3. of RFC6749. \n\nThat section seems to particularly deal with the client credentials validation.  And then as it relates to the revocation details:\n\nThe authorization server first validates the client credentials (in\n   case of a confidential client) and then verifies whether the token\n   was issued to the client making the revocation request.  If this\n   validation fails, the request is refused and the client is informed\n   of the error by the authorization server as described below.\n\nWhat do you think?\n. Hey Chris, I'm not sure if this helps you.  I'm not using the Users table b/c we are doing authentication against an external system, but here is what I implemented to store ClientCredentials using the password_hash and password_verify functions.\n720\n. I agree.  It is defined as a secret, but not treated as such.  I've opted to treat mine as a true password (as you can see) and created a page to allow them to reset their secret.  So our workflow is to create an initial secret and then direct them to a page to change it before they use it in production.\n. @fabbio204 I believe you can get what you need using the existing resource controller.  See these functions: https://bshaffer.github.io/oauth2-server-php-docs/controllers/resource/\nThis is what we are using in our environment to pass in an access token, and the response you get back should include the client_id and user_id that are associated with the token.  Note: You would see a user_id value for a token of grant type Auth Code.  For a token of grant type client credentials, there would be no user_id, but you would still have a client_id.\nAnd just for good measure, here is the code we are using to create a /resource endpoint that returns the info in question.  in our implementation, we wanted to return the expiration time rather than an expiration datetime stamp, so you can see that modification here as well:\n``` php\n<?php\n// include our OAuth2 Server object\nrequire_once DIR.'/server.php';\n// Handle a request to a resource and authenticate the access token\nif (!$server->verifyResourceRequest(OAuth2\\Request::createFromGlobals())) {\n    $server->getResponse()->send();\n    die;\n}\n$token = $server->getAccessTokenData(OAuth2\\Request::createFromGlobals());\n$expires_in = $token[\"expires\"] - time(); \n$tokeninfo = $token;\nunset($tokeninfo[\"expires\"]);\n$tokeninfo[\"expires_in\"]=$expires_in;\necho json_encode($tokeninfo);\n```\n. ",
    "gabrielgagno": "Oh yes. Actually I've tried this yesterday and it worked. Now is there any way for me to assign a length, say, per client in the clients table?\n. Hmm okay will try to look at this approach. Thanks!\n. can somebody please address this? I'm having the same problem as well.\n. That would be really useful, but if I use redis, that would be enough, right?\nThat method would be really useful, but as for me, I will first try the Redis solution. Thanks!\n. ",
    "steve-dave": "ping @bshaffer \n. ",
    "thisisryian": "Happen to me too, even when in memory storage.\ni accidentaly open \"use_jwt_access_tokens\",\n$server = new OAuth2\\Server($storage, array(\n   /* 'use_jwt_access_tokens' => true,*/\n));\ndisable it solve my problem.\n. ",
    "byteworksng": "Here is what I did when I ran into the same problem.\n1. Confirm your public and primary keys are correctly created by trying to sign and verify random inputs using one of the valid encryption algorithms.\n2. Change the size of the primary key (\"access_token\" column) from \"40\" to \"255\" on the table \"oauth_access_tokens\".\nThats all.. ",
    "webmaestro365": "@thisisryian, what you did disables the three-part JWT Bearer tokens in the Curl response and you will only get a short token as in the example on https://bshaffer.github.io/oauth2-server-php-docs/grant-types/jwt-bearer. But it is possible to elicit the longer form with \"use_jwt_access_tokens\"  => true.\nLike @byteworksng said, increase the size of the primary key of oauth_access_tokens. However, in my case I needed the size to be about 670 odd. I made it 1024: the max size supported by my RDBMS.\nNow the important part\u2013why this problem is affecting only PDO users. You probably populated the oauth_jwt table with values like the memory storage jwt is populated in the documentation. But you also need a corresponding row in the oauth_public_keys PDO table for the same client. (Documentation needed). Without that, you can \"echo $jwt;\" the request assertion token but you cannot get the response token from token.php using Curl because probably the token controller does not know your private key which is not supplied to it by Curl or anything else unless you populate the PDO table oauth_public_keys for same client_id. I realize that this a bit late. The error you got is triggered by the Curl request.. ",
    "AstRonin": "@copynpaste I think, I will have a time...\n. https://github.com/bshaffer/oauth2-server-php/pull/748\n. Brent has a choice :)\n. Ok, I will do the changes after my holidays.\n1. I did not have to deal with travis.yml ... what I should do?\n2. Yes, about newlines, I noticed after pushing...\n3. I needed to make sure which methodes work (write/read/remove) as I expected in different situations. For example, method \\OAuth2\\Storage\\Mongo::setRefreshToken does insert instead of update and it looks like a bug. Standart tests don't identify it.\nAnother thing is that I can change [] to array() in Bootstrap.php for maintain a common style but we cannot use new MongoDB driver with php v5.3\n. I added new commit, but travis failed again...\n. ok, it's my fault, I mixed classes in Bootstrap in previous test...\nNow error only for :\n- PHP 5.3 - MongoDB does not work in 5.3 at all, but Trevis parsed anyway...\n- HHVM - Has no extension MongoDB\nWill I need add something else in travis.yml?\n. https://docs.mongodb.com/ecosystem/drivers/php/#language-compatibility\nIt discussed early\n. ",
    "iNDicat0r": "Well I installed the new extension mongodb.so and:\ncomposer require \"mongodb/mongodb=^1.0.0\"\nand then just extend the Storage class called Mongo, changed the insertto insertOne, and updateto updateOneand everything works as expected with an additional lightweight dependency which is mongodb/mongodb\nhttp://mongodb.github.io/mongo-php-library/getting-started/\n. I will take a look. DB structure should be also changed, access_token is of type varchar(40)\n. ",
    "achimha": "I believe it is a very common use case to add additional fields to a JWT. The other libraries I have dealt with provide simple ways to add user claims.\nWhile I can override the JwtAccessToken class, I have to provide a complete implementation, copying the existing logic because there is no way to add extra fields.\n. ",
    "galves": "You should be at least able to set the claims outlined here https://www.iana.org/assignments/jwt/jwt.xhtml. ",
    "Herz3h": "Whats the recommended flow to use for native apps if this flow is not available with this library ? \nAuthorization code with the risk of an app responding to the same scheme registered by own app?\n. It seems like it is with 3.2 at least, but then i used the symfony bundle here https://github.com/bshaffer/oauth2-server-bundle. Here is an attempt to do what i want: \nif ($requestedScope) {\n186             // validate the client has access to this scope\n187             if ($clientScope = $this->clientStorage->getClientScope($clientId)) {\n188                 if (!$this->scopeUtil->checkScope($requestedScope, $clientScope)) {\n189                     $response->setError(400, 'invalid_scope', 'The scope requested is invalid for this client');\n190\n191                     return false;\n192                 }\n193             } elseif (!$this->scopeUtil->scopeExists($requestedScope)) {\n194                 $response->setError(400, 'invalid_scope', 'An unsupported scope was requested');\n195\n196                 return null;\n197             }\n198             /* // validate the requested scope */\n199             /* if ($availableScope) { */\n200             /*     if (!$this->scopeUtil->checkScope($requestedScope, $availableScope)) { */\n201             /*         $response->setError(400, 'invalid_scope', 'The scope requested is invalid for this request' . $availableScope); */\n202\n203             /*         return null; */\n204             /*     } */\n205             /* } else { */\n206             /* } */\n207         }\nNot sure what to think about this.... Hey @clubery,\nThanks for the reply. But i don't see how does this integrate with oauth2 and scopes :/\nThe thing is i started implementing oauth2, thinking scopes are a way of telling what a user can do (in context of user) and what an app requires for someone to use it (in case of a client) but now i realize scope are used to let user limit what a client can do.\nMaybe i'm using oauth2 and it doesn't fit my problem (not sure about this, maybe there is solution to what i need with oauth2) and in such case what alternative would solve my need ?. So from what i understand any user can authenticate, and its only after retrieving its scopes in the resource server that you tell wether he can access a specific resource by using Scope <-> ACL hash, right ?\nWhat i need is to check permission in the authorization server, so that only a user who has same scope as client scope (understand here: right to use a client) can get a token....but then this probably doesn't conform to oauth2 scopes way of working i guess... That's strange then. I have this layout atm: \nClientA with scope A\nUserBob with scope B\nIf i try to get a token using password (user credentials) grant_type using UserBob username and password and sending the scope A i get this : \n{\"error\":\"invalid_scope\",\"error_description\":\"The scope requested is invalid for this request\"}\nAnd if i try with UserBob (like before) by sending the scope B i get a token which doesn't make sense then \ud83d\ude2e \nThis is using clientA client_id and client_secret in both cases of course.. Yes clientA has only the \"password\" grant and the \"scope A\" in scopes. So i'm confused now, is what i described in previous post normal behaviour then?. I've checked the class you posted (pretty long stuff to read), but doesn't seem to contain what i need (aka only allow user who have same scope as client scope in order to get a token).\nI want to customize the /token endpoint in order to do what i said above but then i don't know if this is a good idea or maybe oauth2 isn't suited for this need. Because if i start to customize how scope work at the server level i'm afraid i break compatibility with clients who don't actually about this change ?\nNeed more inputs on this please. Something that seems to suit more my need is keycloak. ",
    "belinde": "I need to implement PKCE ASAP for a project of mine. Do you have already written something or I have to start from scratch? In the second case what's the better way to submit my solution? A pull request is ok?. ",
    "shenmadouyaowen": "To add client_id and client_secret\ncurl -u testclient:testpass http://localhost/token.php -d 'grant_type=client_credentials&client_id=testclient&client_secret=testpass'\n. ",
    "oksim14": "Same error. Did you fix it? Thx\n. ",
    "kaoscoder": "I ran into the same issue and it's b/c OAuth2\\Controller\\TokenController class is checking for the grant_type in the OAuth2\\Request objects request array, but it's populated in the query array.\nin OAuth2\\Controller\\TokenController.php line 88:\nif` (!$grantTypeIdentifier = $request->request('grant_type')) {\n    $response->setError(400, 'invalid_request', 'The grant type was not specified in the request');\n    return null;\n}\nwhen I var_dumped the $request object, this is what I see:\nobject(OAuth2\\Request)#8 (8) {\n  [\"attributes\"]=>\n  array(0) {\n  }\n  [\"request\"]=>\n  array(0) {\n  }\n  [\"query\"]=>\n  array(3) {\n    [\"grant_type\"]=>\n    string(18) \"client_credentials\"\n    [\"client_id\"]=>\n    string(10) \"testclient\"\n    [\"client_secret\"]=>\n    string(8) \"testpass\"\n  }\n.\n.\n.\n}\nso maybe line 88 should be updated to \nif` (!$grantTypeIdentifier = $request->query('grant_type')) \n. ok I found the bug:\nin OAuth2\\Controller\\TokenController.php in the static createFromGlobals() function on line 195,  change\n$request = new $class($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER);\nto \n$request = new $class($_GET, $_REQUEST, array(), $_COOKIE, $_FILES, $_SERVER);\nsee more info about the $_REQUEST global variable here: http://php.net/manual/en/reserved.variables.request.php\n. ",
    "helven": "I changed the singlequote (') to doublequote (\") on the curl command and it works. I'm running Win10\ncurl -u testclient:testpass http://localhost/oauth/token.php -d \"grant_type=client_credentials\"\n. ",
    "nelsonc24": "helven +1, it works for me! Thanks!. ",
    "Abhishek103": "Hi, \nI am following the steps https://bshaffer.github.io/oauth2-server-php-docs/cookbook/laravel/ and when I tried to test via POSTMAN. I am getting this\n{\"error\":\"invalid_request\",\"error_description\":\"The grant type was not specified in the request\"} \nI am using window 10. \nThe version I am using :\n  \"bshaffer/oauth2-server-httpfoundation-bridge\": \"^1.3\",\n        \"bshaffer/oauth2-server-php\": \"^1.9\",\n . I am getting the same issue in the post man\n1/1\nMethodNotAllowedHttpException in RouteCollection.php line 251:\nin RouteCollection.php line 251\nat RouteCollection->methodNotAllowed(array('POST')) in RouteCollection.php line 238\nat RouteCollection->getRouteForMethods(object(Request), array('POST')) in RouteCollection.php line 176\nat RouteCollection->match(object(Request)) in Router.php line 533\nat Router->findRoute(object(Request)) in Router.php line 512\nat Router->dispatchToRoute(object(Request)) in Router.php line 498\nat Router->dispatch(object(Request)) in Kernel.php line 174\nat Kernel->Illuminate\\Foundation\\Http{closure}(object(Request)) in Pipeline.php line 30\nat Pipeline->Illuminate\\Routing{closure}(object(Request)) in TransformsRequest.php line 30\nat TransformsRequest->handle(object(Request), object(Closure)) in Pipeline.php line 148\nat Pipeline->Illuminate\\Pipeline{closure}(object(Request)) in Pipeline.php line 53\nat Pipeline->Illuminate\\Routing{closure}(object(Request)) in TransformsRequest.php line 30\nat TransformsRequest->handle(object(Request), object(Closure)) in Pipeline.php line 148\nat Pipeline->Illuminate\\Pipeline{closure}(object(Request)) in Pipeline.php line 53\nat Pipeline->Illuminate\\Routing{closure}(object(Request)) in ValidatePostSize.php line 27\nat ValidatePostSize->handle(object(Request), object(Closure)) in Pipeline.php line 148\nat Pipeline->Illuminate\\Pipeline{closure}(object(Request)) in Pipeline.php line 53\nat Pipeline->Illuminate\\Routing{closure}(object(Request)) in CheckForMaintenanceMode.php line 46\nat CheckForMaintenanceMode->handle(object(Request), object(Closure)) in Pipeline.php line 148\nat Pipeline->Illuminate\\Pipeline{closure}(object(Request)) in Pipeline.php line 53\nat Pipeline->Illuminate\\Routing{closure}(object(Request)) in Pipeline.php line 102\nat Pipeline->then(object(Closure)) in Kernel.php line 149\nat Kernel->sendRequestThroughRouter(object(Request)) in Kernel.php line 116\nat Kernel->handle(object(Request)) in index.php line 53\nBut I have checked I am using th correct end point. Laravel version is 5.4...\nAny help ??. ",
    "bandicsongor": "Hi, if you use POSTMAN don't forget to set the Body content type to 'x-www-form-urlencoded'. This works for me.. ",
    "oaktechster": "use this simple test to replicate the issue:\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\Psr7;\nuse GuzzleHttp\\Psr7\\Request;\nuse GuzzleHttp\\Exception\\ClientException;\ntry {\n    $client = new Client(['base_uri'=>'http://localhost']);\n    $header = [\n            'query' => [\n                'grant_type' => 'client_credentials',\n                ],\n            'headers' => [\n                'Authorization' => 'Basic '.$base64_encode('xxx:xxxx'),\n                'Content-Type' => 'application/x-www-form-urlencoded',\n                ],\n            'verify' => false,\n            'http_errors' => false,\n            'form_params' => [\n                'name' => 'test user',\n                'email' => 'test@test.com',\n                ]\n            ];\n//Send a form POST to http://localhost/access/tokens?grant_type=client_credentials\n$response = $client->request('POST', '/access/tokens', $header);\n$responseBody = $response->getBody(true);\n\nvar_dump($responseBody);\n\n} catch (ClientException $e) {\n    echo 'Exception:' .$e->getResponse()->getBody();\n}\nit will return the response:\n{\"error\":\"invalid_request\",\"error_description\":\"The grant type was not specified in the request\"}\nthe error is set in OAuth2/Controller/TokenController.php in the grantAccessToken() method:\nif (!$grantTypeIdentifier = $request->request('grant_type')) {\n            $response->setError(400, 'invalid_request', 'The grant type was not specified in the request');\n        return null;\n\n}\nYou can see that it's checking the for the \"grant_type\" in the request() method in OAuth2/Request class. In this class, the $request property is initialized using the $_POST global variable in the createFromGlobals() method:\n$class = get_called_class();\n/* @var Request $request /\n$request = new $class($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER);\nHowever, in the sample code above, the grant_type was set in the query string, so it's not available in the $_POST variable. If I var_dump the $request object above, this is what I get:\nobject(OAuth2\\Request)[74]\n  public 'attributes' => \n    array (size=0)\n      empty\n  public 'request' => \n    array (size=2)\n      'name' => string 'test user' (length=9)\n      'email' => string 'test@test.com' (length=13)\n  public 'query' => \n    array (size=1)\n      'grant_type' => string 'client_credentials' (length=18)\n  public 'server' => \n...\nYou can see that the \"grant_type\" is in the $query property of the OAuth2/Request class, not in the $request property.\npossible solutions:\n in OAuth2/Controller/TokenController.php in the grantAccessToken() method update it so it checks the query instead of the request.\nChange:\nif (!$grantTypeIdentifier = $request->request('grant_type')) {\nto\nif (!$grantTypeIdentifier = $request->query('grant_type')) { \nOR\nin OAuth2/Request.php in the createFromGlobals() method update it so the $request property is initialized using the $_REQUEST instead of $_POST.\nChange:\n$request = new $class($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER);\nto \n$request = new $class($_GET, $_REQUEST, array(), $_COOKIE, $_FILES, $_SERVER);\n$_REQUEST global variable is an associative array that by default contains the contents of $_GET, $_POST and $_COOKIE. \n. ",
    "zhangjinling": "$oauthResponse->getResponseBody();?\n. ",
    "lordcoste": "I've read the docs but can't find any reference to the Discovery Document URL. Is it supported?. ",
    "dweinerATL": "I found the issue -- I had a namespace issue that I had to resolve.  For some reason, my app returned a 200 OK response and the normal login page, so I didn't think to check the logs.\nI know, bad dev, no cookie!\n. ",
    "kosciuk": "And if I use JWT the token length is 600 .... @svycka Ups! You're right, I think I must use Memory storage instead Pdo. But in http://bshaffer.github.io/oauth2-server-php-docs/overview/jwt-access-tokens/, section Using Secondary Storage, Pdo will truncate the access token. ",
    "memmaker": "This is a bit irritating. Did the Travis build fail for my PR or did it not?\n. ",
    "esynaps": "This is an issue, see https://openid.net/specs/openid-connect-core-1_0.html#Authentication\nI also need the response type : code id_token token for a sign in button flow\n. Check your imports at the top of your file. You probably import the wrong class for Request.. Problem already reported here January 18, 2018. I think this repository is no longer maintained by the author.\nhttps://github.com/bshaffer/oauth2-demo-php/issues/67. ",
    "mathroc": "and it's been released so this issue might be closed ( https://github.com/bshaffer/oauth2-server-php/pull/788 ). ",
    "cbergau": "Hi, any news on that? :)\n. ",
    "samsonasik": "yes please \ud83d\udc4d . ",
    "mikehatch": "Here is a sample of the code I'm using to retrieve the token using the simple-oauth2 library: \n`const express = require(\"express\");\nconst simpleOauthModule = require('simple-oauth2');\nvar request = require('request');\nrequire('request-debug')(request);\nconst redirect_uri = 'https://myclientapp.com'\nconst app = express();\nconst oauth2 = simpleOauthModule.create({\n  client: {\n    id: 'service_id',\n    secret: 'servicepassword',\n  },\n  auth: {\n    tokenHost: 'https://_mydrupalsite_azurewebsites.net',\n    tokenPath: '/oauth2/token',\n    authorizePath: '/oauth2/authorize',\n  },\n});\n// Authorization uri definition\nconst authorizationUri = oauth2.authorizationCode.authorizeURL({\n  redirect_uri: redirect_uri + '/callback',\n  scope: 'basic',\n  state: '3(#0/!~',\n});\n// Initial page redirecting to Drupal\napp.get('/auth', (req, res) => {\n  console.log(authorizationUri);\n  res.redirect(authorizationUri);\n});\nvar token;\n// Callback service parsing the authorization token and asking for the access token\napp.get('/callback', (req, res) => {\n  const code = req.query.code;\n  console.log(code);\n  const options = {\n    code,\n    redirect_uri: redirect_uri + '/callback'\n  };\noauth2.authorizationCode.getToken(options, (error, result) => {\n    if (error) {\n      console.error('Access Token Error', error.message);\n      return res.json('Authentication failed');\n    }\n    console.log('The result (token data): ', result);\n    token = oauth2.accessToken.create(result);\n    res.send('Get Drupal node');\n      });\n});\napp.get('/success', (req, res) => {\n  res.send('');\n});\napp.get('/', (req, res) => {\n  res.send('HelloLog in with Drupal');\n});\napp.get('/drupal', (req, res) => {\n    authOptions.headers.Authorization = 'Bearer ' + token.token.access_token;\n    //try the request with bearer token\n    request.post(authOptions, function (error, response, body) {\n            if(!error && response.statusCode == 200) {\n                res.send(body);\n            } else {\n                res.send(response.statusCode);\n                console.log(error);\n                console.log(response.statusCode);\n            }\n        }\n    );\n    //try the request with query string\n    request(authOptions.url + '?' + 'access_token=' + token.token.access_token);\n})\napp.listen(3000, () => {\n  console.log('Express server started on port 3000'); // eslint-disable-line\n});\nvar authOptions = {\n    url: 'https://mydrupalsite.azurewebsites.net/user/1',\n    headers: {\n        'Authorization': '' //to be set later,\n}\n} `\nThe result from the token call are: \nThe result (token data):  { access_token: '1e6dfad85bf8152f9a6e3d8e55af3ad3ef4404f8',\n  expires_in: '3600',\n  token_type: 'Bearer',\n  scope: 'basic',\n  refresh_token: '0ca3fc88b49bbbec1b1486d0e0b2e595aca165f1' }\nBut the results after the /drupal path are always 403 Forbidden.\n. ",
    "dhanabalanc": "Yes correct.. I have replaced it as POST..  Working Good.\nRegards,\nDhanabalan.c \n. ",
    "StanBarrows": "Exact same issue over here: If I run the request locally it works perfectly fine. If i run it on production server i get the above mentioned error.\nMy Laravel Version is 5.4:. ",
    "Dickorir": "the same error throws in my local server but when online its throws the same error. what might be the problem. am using laravel 5.3 and php 7. ",
    "thanseehabdulla": "dealer.zip\n. hi @bshaffer ,i have sent the attachments.Please help us to renew access token with refresh token.. ",
    "hsiri": "@bshaffer sorry for hijacking this thread. but can you include this fix in your latest tag?. ",
    "theboolean": "You're welcome!. ",
    "ElectroLutz": "Is there an estimated date when this will be in a release? I find it very useful.. ",
    "MajesticMaje": "Any word on this? Would be a big help!. ",
    "timyounes": "Thanks @bshaffer . Thanks @bshaffer . One more question..Why it is necessary to delete the authorization code after it expires? What is the purpose of it?. Thanks @bshaffer. Now I understand what is the purpose of authorization code deletion. thanks @bluebaroncanada . ",
    "Listen-WebDev": "Hi svycka, thank you\nbut i don't understand :(. In first attemp i login in my app and check credentials (username and password) on my DB.  my first call to api is:\ncurl -u testclient:testpass https://localhost/token.php -d 'grant_type=password&username=myuser&password=mypass'\nfor check user and password with my DB users table i have implemented  UserCredentialsInterface and write two methods:\ncheckUserCredentials\ngetUserDetails()\nall seem works, my api token endpoint work and return access token (ie: a64ec1a1e5f40ff7a697d67fa44d9556c857608b  with different refresh token) and save all two token in DB in oauth_access_tokens and oauth_refresh_tokens.\nSo for example immagine to call after one hour this\ncurl https://localhost/resource.php -d 'access_token=a64ec1a1e5f40ff7a697d67fa44d9556c857608b'\nat this point my api return Token is expired. How to implement auto renew token in my class to extend time life in case of expired?\nsorry but for me is the first time that use outh2 \nthx for patience! :)\n. Thx :) i understand my problem is \"How to check expire token time and auto renew it with refresh token\"\nfor example in my resource.php (is a test file but imagine to request books list of my online store, in production will i have a resource file for each rest endpoint):\nrequire_once DIR.'/server.php';\nif (!$server->verifyResourceRequest(OAuth2\\Request::createFromGlobals())) {\n    echo json_encode(array('success' => false, 'message' => 'Token expired'));\n    die;\n}\necho json_encode(array('success' => true, 'message' => 'You accessed my APIs!'));\nhow can i check expire time then request new token with refresh token? (I don't like to store user and password in my app, i can change it then invalidate my credentials)\nThx svycka :)\nBest\n. ",
    "gioialorusso": "Thanks. I realized the same thing yesterday and I am doing this - not precisely a custom GrantType but I'm redefining the client_credentials case.. ",
    "bramaningds": "Closed, since it is not major issue. . ",
    "pyrotechnv": "Thanks for the reply.  We made the problem.  The Authorize.php that was not working had a blank line before to <?php tag, so it sent headers.  Therefore the $Response->send() would not work.  I hope that this can help someone.  B. Shaffer's code made it easy to track down once we looked into it.  Thanks again for an awesome, useful Oauth Server.. ",
    "nash4ever": "Hi, did you solve this issue? \nPlease tell us how could you fix this error.. We faced similar issue, and we changed the expires column type to DATETIME, and now it seems ok.. ",
    "andela-oadebayo": "@pjebs Am i supposed to do the redirect my self or does handleAuthorizeRequest() do that for me ?\n. @pjebs am just testing with google hoping it will redirect to google but it does not and am not printing it on the page. @pjebs this is the function that handles the authorization form\n`\npublic function verify(){\n        $this->autoRender = false;\n    // get the oauth server (configured in src/OAuth2Demo/Server/Server.php)\n    $server = $this->server['oauth_server'];\n\n    // get the oauth response (configured in src/OAuth2Demo/Server/Server.php)\n    $response = $this->server['oauth_response'];\n\n    if($this->request->is('post')) {\n        $authorized = (bool) $this->request->data['authorize'];\n        $user_id = $this->Session->read(\"student.id\");\n\n        return $server->handleAuthorizeRequest($this->server['oauth_request'], $response, $authorized, $user_id);\n    }\n}\n\n. and after that runs all is i see is thisHTTP/1.1 302 Found Location: http://oncusp.com/ogaboss/campus-credit/users/developer?code=404147cc0507d10fb882f3dd686000a571eccc42 []`\nSame thing when i cancel the authorization as well\nHTTP/1.1 302 Found Cache-Control: no-store Location: http://oncusp.com/ogaboss/campus-credit/users/developer?error=access_denied&error_description=The+user+denied+access+to+your+application {\"error\":\"access_denied\",\"error_description\":\"The user denied access to your application\"}. ",
    "aliaksei-kavaliou": "Hello,\nThe problem is that scope is ignored and no user claims added on create id_token OAuth2/OpenID/Controller/AuthorizeController.php line 62. ",
    "TheCrealm": "Is there a meaningful reason for this behavior?\nOr is there another way to extend the id token with custom scopes?. ",
    "negreanucalin": "I read the RFC 6750:\n\ninvalid_token\n The access token provided is expired, revoked, malformed, or\n invalid for other reasons. The resource SHOULD respond with\n the HTTP 401 (Unauthorized) status code. The client MAY\n request a new access token and retry the protected resource\n request.\n\nThough I do not agree: There is no difference between an invalid and expired token which can be problematic because you can't assume it's expired and try to get a new token (apon receiving an error).\nYou would have to rely on the response text rather than the error code (to get a new token) itself which is a bit bad if you ask me. If a user tries to log in for the first time VS(versus) a logged in user with an old/expired token,that is the difference. ",
    "ApacheEx": "@bshaffer,\nI've added test cases. Please check #829 . what is the reason of deletion this line? it should be here. Everything else looks good. . Yeah, that's true. ",
    "Shashwatsh": "Apologies, I didn't intend to do that.. Sorry, I made an empty pull request.. Wrong Repository, Sorry once again.. I will contact support@github.com and tell them to delete it.. ",
    "ivolator": "Just confirming the issue that is reported here.\nIt looks like the methods are missing this part:\n$expires = date('Y-m-d H:i:s', $expires);. ",
    "peluprvi": "@guillerodriguez I was looking almost the the issue as yours.\nIn my case, I have always_issue_new_refresh_token => true and unset_refresh_token_after_use => false.\nalways_issue_new_refresh_token is used to create a new refresh_token when you refresh your access_token. If it is false, your request will not return a new refresh_token and the old one will expire depends on your unset_refresh_token_after_use config. So, if it is false, you can refresh your token until it expires. If it is true, you can always use the new one.\nunset_refresh_token_after_use is used to revoke the old refresh_token when you refresh your access_token. It is true by default and, in this case, you will got an error requesting a second refresh with the old refresh_token (no matter its lifetime). If you set it to false, the old refresh_token can be reused and will only expire by the refresh token lifetime.\nYour access_token can be refreshed any time and it will not be revoked by the refreshing process (will be by access token lifetime).\nSee:\nhttps://github.com/bshaffer/oauth2-server-php/blob/master/src/OAuth2/GrantType/RefreshToken.php#L44\nhttps://github.com/bshaffer/oauth2-server-php/blob/master/src/OAuth2/GrantType/RefreshToken.php#L148\nIt took me a lot of time to find that. It really need to be in the documentation.\nI also think unset_refresh_token_after_use should be false by default, avoiding some browser tabs restore error (I described it there: https://github.com/websanova/vue-auth/issues/298).. ",
    "MatthiasKunnen": "Revoking the refresh token is a security measure. It's described here: https://tools.ietf.org/html/rfc6749#section-6\n\nThe authorization server MAY issue a new refresh token, in which case\n   the client MUST discard the old refresh token and replace it with the\n   new refresh token.  The authorization server MAY revoke the old\n   refresh token after issuing a new refresh token to the client.  If a\n   new refresh token is issued, the refresh token scope MUST be\n   identical to that of the refresh token included by the client in the\n   request.\n\nThe explanation to the best of my knowledge: \nIf a refresh token is compromised, an attacker would be able to make request which are indistinguishable from the user's normal requests. The only limit is the refresh token's expiration time. To combat this, a refresh token is made single use. When the attacker or the user tries to use a spent token, the API revokes all tokens since it can't know which request is legitimate.. ",
    "zolij": "First: I think you should start with this.\nAbout scopes, you can read this.\nBasically you have to define required scope in resource controller (the api endpoint). Available scopes can come from database or other place (see second link).\n\nSecond, i need create two records in oauth_clients table (one for the admin site, another for the public site).\n\nYes.\n\nThird, what is the oauth_users table purpose ?\n\nI think that's a \"starter kit\" table but if you implement your own user handling (other sql table or external auth such as ldap) then you can skip it.\n\nFourth, is oauth_clients.users_id column a reference to oauth_users.id column ?\n\nif you use that table then yes.. ",
    "pzingg": "I wanted to do the same thing and found a couple of ways to do this. \n\n\nOne is to add scopes, but that's not so easily done if the scopes are created per token; I extended OAuth2\\\\Scope class and overrode the checkScope and scopeExists methods to define my own scope-permitted logic.\n\n\nAnother way is to extend as many of the OAuth2\\\\ResponseType and OAuth2\\\\OpenID\\\\ResponseType classes as you need and find the methods that create tokens, claims, etc.\n\n\nIn either case you will probably then have to write a class that extends OAuth2\\\\Server to bring in these new classes. My child Server class has to override these methods:  createDefaultAuthorizeController, createDefaultIdTokenResponseType, createDefaultIdTokenTokenResponseType, createDefaultJwtAccessTokenResponseType, getDefaultResponseTypes, and getScopeUtil.. ",
    "soren121": "@bshaffer Yes, for reasons listed here: paragonie/random_compat#96. ",
    "fernandoigual": "Perfect! Thank you.. ",
    "lukaslentner": "Sorry, my own mistake!. ",
    "wimpog": "Thank you!. I use Symfony 3.3 and PostgreSQL database.\nI was able to bootstrap it.\nI created an OAuth2ServerBootStrap service:\n```\n<?php\n/*\n * File OAuth2ServerBootStrap.php\n /\nnamespace AppBundle\\Service;\nuse OAuth2\\GrantType\\AuthorizationCode;\nuse OAuth2\\GrantType\\ClientCredentials;\nuse OAuth2\\Server;\nuse OAuth2\\Storage\\Pdo;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\n/\n * Class OAuth2ServerBootStrap.\n */\nclass OAuth2ServerBootStrap\n{\n    /\n     * @var Server\n     */\n    protected $server;\n/**\n * @var Pdo\n */\nprotected $storage;\n\n/**\n * @var string\n */\nprotected $dsn;\n\n/**\n * @var string\n */\nprotected $username;\n\n/**\n * @var string\n */\nprotected $password;\n\n/**\n * OAuth2ServerBootStrap constructor.\n *\n * @param ContainerInterface $container\n */\npublic function __construct(ContainerInterface $container)\n{\n    $this->container = $container;\n\n    # Configure the DSN\n    $this->dsn  = 'pgsql:';\n    $this->dsn .= 'host=' . $this->container->getParameter('database_host') . ';';\n    $this->dsn .= 'port=' . $this->container->getParameter('database_port') . ';';\n    $this->dsn .= 'dbname=' . $this->container->getParameter('database_name') . ';';\n\n    # Get credentials\n    $this->username = $this->container->getParameter('database_user');\n    $this->password = $this->container->getParameter('database_password');\n\n    // $dsn is the Data Source Name for your database, for exanple \"mysql:dbname=my_oauth2_db;host=localhost\"\n    $this->storage = new Pdo(\n        array(\n            'dsn' => $this->dsn,\n            'username' => $this->username,\n            'password' => $this->password\n        )\n    );\n\n    // Pass a storage object or array of storage objects to the OAuth2 server class\n    $this->server = new Server($this->storage);\n\n    // Add the \"Client Credentials\" grant type (it is the simplest of the grant types)\n    $this->server->addGrantType(new ClientCredentials($this->storage));\n\n    // Add the \"Authorization Code\" grant type (this is where the oauth magic happens)\n    $this->server->addGrantType(new AuthorizationCode($this->storage));\n}\n\n/**\n * @return Server\n */\npublic function getServer()\n{\n    return $this->server;\n}\n\n/**\n * @return Pdo\n */\npublic function getStorage()\n{\n    return $this->storage;\n}\n\n/**\n * @return string\n */\npublic function getDsn()\n{\n    return $this->dsn;\n}\n\n}\nI registered it in **service.yml**:\nAppBundle\\Service\\OAuth2ServerBootStrap:\n        public: true\n```\nI then created a RequestListener class which listens to kernel events and registered it as a service:\nAppBundle\\EventListener\\RequestListener:\n        arguments: ['@doctrine.orm.entity_manager', '@service_container']\n        tags:\n            - { name: kernel.event_listener, event: kernel.controller, method: onKernelController }\nSee: http://stackoverflow.com/questions/11771368/how-can-i-access-entity-manager-if-i-create-custom-event-in-symfony2 and http://symfony.com/doc/current/event_dispatcher/before_after_filters.html on how to create it.\nIn RequestListener class in its onKernelController() function I bootstrap the OAuth2 Server:\n```\n/* @var OAuth2ServerBootStrap $oAuth2ServerBootStrapService /\n$oAuth2ServerBootStrapService = $this->container->get('AppBundle\\Service\\OAuth2ServerBootStrap');\n/ @var Server $server */\n$server = $oAuth2ServerBootStrapService->getServer();\nAnd then you can use the OAuth2 Server.\nI was able to create a **TokenController** and **VerifyController** and have them function.\nAt the moment I'm stuck at connecting this server to the Symfony's firewall. . I think, I have found a solution:composer require 'bshaffer/oauth2-server-httpfoundation-bridge'``` \nuse BridgeRequest and BridgeResponse** . ",
    "onward85": "I am baffled at this step as well.. ",
    "alpha1125": "3.3.4 confirmed. also with https://github.com/bshaffer/oauth2-server-bundle. ",
    "mortzdk": "Turned out my own storage implementation returned data that did not support the += operator.. Duplicate. ",
    "Holzberg": "I have the same problem.  We have multiple apps for our customers to login and use.  We only want certain users to be able to login through certain apps.  Behind it all, we have one REST API using this library for authentication.\nSo, I did what Herz3h did.  I setup a client with grant_type = password and scope = test123.\nI then created a user which has scope=test456 and I was able to get a token when logging in with this user.\nIs there a setting that we are missing?  It would be great if the system works this way.. This could easily be fixed if Storage->checkUserCredentials was passed the client id.\nThat way we could use client info checks against users, including checking client scopes against user scopes, ourselves.\nSo I'm proposing changing 'checkUserCredentials($username, $password)' to 'checkUserCredentials($username, $password, $client_id)'\nWould that be possible?. ",
    "maxailloud": "In PHPStorm not putting the leading \\ gives me an error. \nAnd rightfully as the class \\OAuth2\\Controller\\OAuth2\\GrantType\\ClientCredentials doesn't exist, but \\OAuth2\\GrantType\\ClientCredentials does.. Yes but importing a class just for the PHPDoc is pointless.\nIt's just updating the namespace of the classes use in the PHPDoc to have the real namespace.. ",
    "GreenFootballs": "This is the page I'm asking about - \"Using Secondary Storage\" is about 2/3 of the way down.\nhttps://bshaffer.github.io/oauth2-server-php-docs/overview/jwt-access-tokens/. ",
    "UltraFlux": "I am stuck in the same situation, I have the JWT working in the Memory as per the example. However, I cannot seem to get a backup PDO working.\n`// CREATE STORAGE\n$pdoStorage = new OAuth2\\Storage\\Pdo(array('dsn' => $dsn, 'username' => $username, 'password' => $password));\n$keyStorage = new OAuth2\\Storage\\Memory(array(\n    'keys' => array(\n        'public_key'  => $publicKey,\n        'private_key' => $privateKey,\n        'encryption_algorithm'  => 'HS512',\n    )\n));\n$server = new OAuth2\\Server($keyStorage, array(\n    'use_jwt_access_tokens' => true,\n));\n$server->addGrantType(new OAuth2\\GrantType\\ClientCredentials($keyStorage));\n$server->addGrantType(new OAuth2\\GrantType\\AuthorizationCode($keyStorage));\n$server->addGrantType(new OAuth2\\GrantType\\UserCredentials($keyStorage));\n$server->addGrantType(new OAuth2\\GrantType\\RefreshToken($keyStorage));`\nI can see potentially I can create a storage array based on the past comment but still cannot seem to pull this together. Does anyone know how to add a backup storage like PDO or help finalize the demo page?. ",
    "twarkie": "Oh, my temporary fix for this is simply:\ndo {\n    $accessToken = $this->generateAccessToken();\n} while($this->tokenStorage->getAccessToken($accessToken));\nAnd some numbers: ~500 tokens generated a day, ~100k tokens in total.. Yep, the column size for access_token is the issue here as well. The proposed schema here: https://bshaffer.github.io/oauth2-server-php-docs/cookbook/ needs to be updated with a larger field for access_token.. Actually, the column size is probably not the issue here. The generated key length is 40 characters which fits. Still using my workaround.. ",
    "abemassry": "@bshaffer opened up a new PR #870 against the v2 branch, closing this one.. @bshaffer Thanks!. ",
    "mneumueller": "Thanks for the clarification and the the RFC link.\nUnfortunately I receive as Redirect URI https://www.example.com/#/oauth2 from an Angular2 App.\nI'll keep my fork until this is fixed in the Angular2 App.. ",
    "markkimsal": "FYI, the OpenID spec has a \"response_mode\" parameter where the client can specify fragment or query parameters.  There's even a \"form_post\" response_mode where the AS generates an auto-submitting form (instead of Location based redirect) for the UA that POSTs to the client's redirect_uri.\nTo test out a $responseMode parameter that just handles queries and fragments I added\nprotected $responseMode = 'fragment';\nto OAuth2/Controller/AuthorizeController.php  and then hacked up buildUri like so:\n```\n    private function buildUri($uri, $params)\n    {\n        $parse_url = parse_url($uri);\n    // Add our params to the parsed uri\n    // ...\n\n    if ($this->responseMode == 'fragment') {\n        if (!isset($parse_url['fragment'])) {\n            $parse_url['fragment'] = '';\n        }\n        $parse_url['fragment'] .= $parse_url['query'];\n        unset($parse_url['query']);\n    }\n    // Put humpty dumpty back together\n    return\n       //...\n    ;\n}\n\n```\n... missing all the getters and setters of course.\nThe other solution would be tracking $responseMode all the way down to each responseType in the ResponseTypeInterface and then doing something like\n```\n    public function getAuthorizeResponse($params, $user_id = null)\n    { \n        $result = $this->authCode->getAuthorizeResponse($params, $user_id);\n        $id_token = $this->idToken->createIdToken($params['client_id'], $user_id, $params['nonce']);\n        $result[1][  $this->responseMode  ]['id_token'] = $id_token;\n    return $result;\n}\n\n```\nBut, response_mode is not really tied to a response type.  You can't mix and match query/fragment in one request.  It's part of the request and could be justified being handled by the controllers as much as justifying it being handled by each response type.\nhttps://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes\nhttp://openid.net/specs/oauth-v2-form-post-response-mode-1_0-02.html. I think OpenID uses fragment by default and OAuth uses query by default, but I have no docs to confirm that.. ",
    "arturm11": "Thank you for reply. After some more investigation I have found \"cgi.rfc2616_headers = true\" in my php.ini. Changing back to default solves the problem. \nBTW there was a bug in my workaround. It should be:\n```\nif (substr(php_sapi_name(), 0, 3) == 'cgi')\n    header(sprintf('Status: %s %s', $this->statusCode, $this->statusText));\nelse\n    header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText));\n```\nSee: https://stackoverflow.com/questions/3258634/php-how-to-send-http-response-code. ",
    "Issyu": "Is ony working for AWS SDK < 2.8 version... ",
    "bkonetzny": "Hi manix,\nI had the same problem as clients use different RedirectURIs on each environment.\nFound this issue here, which might help for you: https://github.com/bshaffer/oauth2-server-php/issues/590\nAccording to the code, it should be possible to add multiple redirect_uri entries seperated by space.\nThe redirect URI is needed from DB as a security measure, otherwise host would be able to call your endpoint and fake an authentication. So the redirect URI needs to be defined in DB on your server and not picked up from the incoming request.. ",
    "patchido": "giving a follow up on this, i have found out that if i run the php built-in server the code actually works, what could be the difference which makes apache return empty 401 response?. yes indeed, for some reason on apache the Header is not present and with the php built in server it is included.\nApache\n[2017-10-31 16:58:32] app.INFO: GET /books HTTP/1.1 Accept:          */* Accept-Encoding: gzip, deflate Accept-Language: es-US,en-US;q=0.8,en;q=0.6,es-419;q=0.4,es;q=0.2 Cache-Control:   no-cache Connection:      keep-alive Content-Type:    application/json Host:            testsite.local Postman-Token:   68562d4c-efb1-5120-1e17-a1fadaafe6aa User-Agent:      Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36   [] {\"uid\":\"556b9d3\"}\nPHP CLI\n[2017-10-31 17:07:32] app.INFO: GET /books HTTP/1.1 Accept:          */* Accept-Encoding: gzip, deflate, br Accept-Language: es-US,en-US;q=0.8,en;q=0.6,es-419;q=0.4,es;q=0.2 Authorization:   Bearer f658f75bec0029f98670ccdccec0f68de07bd0ea Cache-Control:   no-cache Connection:      keep-alive Content-Type:    application/json Host:            localhost:8888 Postman-Token:   937ade5a-2b89-6d48-a9cc-215ea9f4c6ad User-Agent:      Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36   [] {\"uid\":\"6f54947\"}. solved it by adding RewriteCond %{HTTP:Authorization} ^(.*)\nRewriteRule .* - [e=HTTP_AUTHORIZATION:%1] to my .htaccess. ",
    "nyl9488": "@northern do i need to send request to the server to check the expiry date? or i will store the request date + 14 days in the client side?. ",
    "reb3r": "You also can remove all $server->addGrantType(...) calls to rely on some magic that adds the grant types regarding the added storage capabilities. See here.. Which Webserver do you use? For an setup with apache, following entry to my .htaccess helped me:\n# Make Bearer Auth-Header available to PHP Backend (needed for OAUTH2)\n    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\nAlso make sure you enabled mod_rewrite.... Do you have an example related to OAuth2 where you need the extra status texts?. ",
    "lucavicidomini": "Hi @svycka and @afilippov1985, I read the interventions on the matter by both of you in the past months :)... Your solutions here didn't fit my case, but I just figured out a solution (at least, I hope so). I replaced the last two lines at the end of the if with these:\n$jwtTokenResponseType = new App\\CustomJwt( $keyStorage, $keyStorage, $keyStorage );\n$server->addResponseType( new AuthorizationCode( $storage ), 'code' );\n$server->addResponseType( $jwtTokenResponseType, 'token' );\nI had to pass three times $keyStorage to CustomJwt's constructor in order to have refresh token released (for reference: constructor is the same as JwtAccessToken and the first three parameters are: public key storage, token storage, refresh storage), and then manually add AuthorizationCode as response type.\nI'm leaving it here hoping that will help someone.\nPS: Thank you @c-reber for your suggestion, I will test it.. ",
    "augsteyer": "I believe this is the only thing that keeps this from being 5.3 compatible. Easier to switch these two to = array(); and retain 5.3.9 support, no?\nAlso, when working with 100k+ merchant systems, it's not that easy to tell everyone to upgrade their php. Merchant's are risk aversive bunch and would rather avoid our plugin than upgrade their system.. Doesn't look like there were any issues with me moving to a different linux distribution. Weird, normally Travis gives me a lot of headaches.. If you provide a plugin/service to a million+ online retailers out there, there is still a large number of them who have not upgraded their servers because of fears of breaking their store. One can say to not support such merchants out of principle, but that would mean losing millions of dollars. My CFO's always go for the dollars :) \np.s. heck, we still have merchants on 5.2. ",
    "gmox": "out of curiosity, why support a version of PHP that's not been updating for over 3 years?. ",
    "Ben-Ho": "@bshaffer do you plan on creating a new release for this fix? Currently we include your package by directly referencing the commit-hash in our projects composer.json, because we thought this would just be a matter of time. (currently no big problem as there are not many new changes in rou repo, but it gives me a bad feeling ;-) ). @bshaffer thank you! :-). ",
    "alexandre-le-borgne": "@bshaffer Is the project still maintained?. I had the same problem as you and I just override the method getDefaultResponseTypes() by removing the condition:\nif (0 == count($this->responseTypes)) { $this->responseTypes = $this->getDefaultResponseTypes(); }\nThen, you can pass in the parameter your own reponse types.\n. I think it is a mistake of the author.\nHe considers that if you customize a single response type then you must pass as a parameter of the constructor of the class Server all types that you use. The good idea would have been to be able to modify the classes used by the response types without being able to edit available response types because default ones already respect the RFC (code, id_token, token etc)\nReply of ps: Yes i edited my comment, ignore it. Same thing for this one ;). Hi\nI think your issue is not related to Oauth but you should take a look at this : https://stackoverflow.com/questions/4350060/where-clause-on-sql-server-text-data-type\nand continue to use double quotes in your curl command. ",
    "hhniao": "thanks for you answer.\nsure, if remove this condition. then all be working.\nbut i have a question, why them write this condition here?\nit is ietf of rules? or any other?\nps: i have received a email from github for notice the reply.  but content of email is diffrenent with reply. . as you say, it is respect the RFC, so it maybe respect rules of openid(i dont know how to call this organization.) too?\nif it is respect rules of openid, so maybe no need to write any code. maybe some config options can be finish it.\nhttp://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes\nA Subject Identifier is a locally unique and never reassigned identifier within the Issuer for the End-User, which is intended to be consumed by the Client. Two Subject Identifier types are defined by this specification:\npublic\nThis provides the same sub (subject) value to all Clients. It is the default if the provider has no subject_types_supported element in its discovery document.\npairwise\nThis provides a different sub value to each Client, so as not to enable Clients to correlate the End-User's activities without permission.\nThe OpenID Provider's Discovery document SHOULD list its supported Subject Identifier types in the subject_types_supported element. If there is more than one type listed in the array, the Client MAY elect to provide its preferred identifier type using the subject_type parameter during Registration.. it is strange!  why not pass test? \nClientTest::testCheckRestrictedGrantType i have no anything is modified about this. . ",
    "TheArtOfPour": "Mind if I take a look?. PR up https://github.com/bshaffer/oauth2-server-php/pull/911. ",
    "Airagale": "Hi good morning!\nThank you for your response. Shortly after I posted this I was able to figure it out. The issue was your tutorial was written for MySQL and I had to translate a few things over to MSSQL.\nTo solve this problem I changed all \"timestamp\" dataypes to datetime. I also changed some Boolean datatypes to BITs but I still haven't seen any hang ups on that. Using double quotes in the terminal was an important step I took as well. \nChanges were made in getBuildSql in /src/OAuth2/Storage/Pdo.php and of course in the SQL to generate the DB.\nPart of the issue was also that with my DB user I had set up to access the DB didn't have correct permissions either. (OOPS)\nAs I see any issues with using this with MSSQL I will update here. :) . ",
    "JamesB7": "That is only true in MySQL. Many databases order nulls higher than values.. ",
    "novacp": "just return the proper response within your controller by catching the response from this library.. ",
    "akshar001": "Go in to src/server.php find redirect_uri exact match setting it is true turn it to false and try again. ",
    "gabeblack": "I made that change in src/OAuth2/Server.php:\n        $this->config = array_merge(array(\n            'use_jwt_access_tokens'        => false,\n            'jwt_extra_payload_callable' => null,\n            'store_encrypted_token_string' => true,\n            'use_openid_connect'       => false,\n            'id_lifetime'              => 3600,\n            'access_lifetime'          => 3600,\n            'www_realm'                => 'Service',\n            'token_param_name'         => 'access_token',\n            'token_bearer_header_name' => 'Bearer',\n            'enforce_state'            => true,\n            'require_exact_redirect_uri' => false,\n            'allow_implicit'           => false,\n            'allow_credentials_in_request_body' => true,\n            'allow_public_clients'     => true,\n            'always_issue_new_refresh_token' => false,\n            'unset_refresh_token_after_use' => true,\n        ), $config);\nBut I still get the same error.... Note, I did have to create an .htaccess file with:\nSetEnvIf Authorization \"(.*)\" HTTP_AUTHORIZATION=$1\nin order to get the token.php to work per the install guide. (I was running in to the issue reported here: https://github.com/bshaffer/oauth2-server-php/issues/925 ). I guess my issue wasn't the same. My error had: \"#section-3.1.2\" in it.\nI found that portion of the code that referenced that section and changed the code to display the expected/measured uri and found that expected uri is what I put in for the INSERT command following the instructions on the step-by-step guide prior to trying it out on the google oauth2 playground:\nHere is the error (with my added info to show the expected/measured redirect_uri:\n{\"error\":\"redirect_uri_mismatch\",\"error_description\":\"The redirect URI provided \\\"https:\\/\\/developers.google.com\\/oauthplayground\\\" is missing or does not match \\\"http:\\/\\/blackdevices.com\\/\\\"\",\"error_uri\":\"http:\\/\\/tools.ietf.org\\/html\\/rfc6749#section-3.1.2\"}\nWhen following the step-by-step guide in the documentation, I had put in \"http://blackdevices.com\" for the redirect_uri when inserting the testclient in the db rather than http://fake. Does that mean I need to change the insert command to be https://developers.google.com/oauthplayground for the redirect_uri? Or is the \"fake\" some magic key word? Seems like a very manual process... I'm sure I am not doing something right.... ",
    "gdharris1970": "Anyone? Please help!. ",
    "kasparsd": "Duplicate of #736.\nIt appears that oauth2-server-php doesn't support dynamic client registration.. ",
    "hardysim": "I think this is correct. Even if I cannot find any \"specification\" on this, it seems that on every RFC concerning OAuth it's used with a capital B.\nSee https://tools.ietf.org/html/rfc6749#section-7.1. > The token_type identifier in the AccessToken response type is a response parameter, and according to the RFC is case insensitive\nThat's correct but then why not make it use the same format as when forming a header? This way nobody gets hurt but a receiver of this JWT can 1:1 use it as the header for a following request.. This is the only place where I've spotted a lower-case \"bearer\". Everywhere else it's already starting with a capital B.\nIt would be good if someone could verify that this really resolves #918. Thx.. @bshaffer would you kindly have a look? Maybe this is a fast one \ud83d\ude04.. ",
    "enobrev": "What worked for me was moving the config array to the 2nd parameter of the new RefreshToken call, like so:\nphp\n    $server->addGrantType(new OAuth2\\GrantType\\RefreshToken($storage, [\n        'always_issue_new_refresh_token' => true,\n        'unset_refresh_token_after_use'  => false\n    ]));\nAlso, at least for my use-case, setting unset_refresh_token_after_use to true made more sense as it ensures one-time use for refresh tokens.  Setting it to false leaves you with a new refresh token as well as leaving the old one around so it can be re-used.. ",
    "spiro-stathakis": "I had to add this to my Apache virtualhost directive as the server globals PHP_AUTH_USER and PHP_AUTH_PW where not accessible. \nSetEnvIf Authorization \"(.*)\" HTTP_AUTHORIZATION=$1. ",
    "nottavi": "Thanks @reb3r finally my issue was linked to the preflight request on an ajax POST.\nI've added the line in my .htaccess also and handled the preflight request in my Resource Controller, by doing nothing in that case\n$request = OAuth2\\Request::createFromGlobals();\nif( $_SERVER[\"REQUEST_METHOD\"] === \"OPTIONS\" ):\n    // Do we have to do something here ?\nelse:\n    // Handle the request\n    if (!$server->verifyResourceRequest($request)) {\n        $server->getResponse()->send();\n        die;\n    }    \nendif;. ",
    "pappu687": "Apigility Framework uses 422 for validation errors as standard. I needed to  customize usercredentials validation and throw 422 to maintain consistencies in the app but couldn't do it the normal way because they didn't exist in the Response class. . ",
    "X-Coder264": "@danopz The plan to go with PSR-7 is great, but it's been 3 years since any development was done in order to achieve that goal. So it's obvious that the plan is either dead or at the very least it isn't gonna be achieved anytime soon. Meanwhile this is the only blocker that we have on our projects in order to update them to use the latest version of Laravel or Symfony (and obviously we are not the only ones). So I'd say that this is worth merging and tagging as a new (major) version. Because the only other option is to basically refactor/rewrite the entire OAuth part of our projects to use another package which isn't a small task (or we should forever stay on an outdated framework version just because of this which just isn't an option).. IMHO I don't think there is any need to do any \"sneaky\" stuff just to preserve BC with ancient PHP versions. As of today even PHP 7.0 reached EOL and PHP 5.6 extended support period ends at the end of the month.. Well, we could still go with the route of tagging a new major version with this PR and then backporting all important bug fixes etc. to the 1.x branch for the foreseeable future. That seems like a better way to approach this problem that to be doing some hacky stuff just so that it can work with all PHP versions.. ",
    "janzankowski": "+1 For @X-Coder264 argument. This should be fixed.. ",
    "bzp2010": "You want to use the oauth in SSO(Single Sign On)?. @iranappo The oAuth2 only be used in connect to 3rd platform by openid, and you also need a login page to identify the user.. @iranappo If you want to use oauth2 in api\uff0cthere are some ways.\n1.Generate a access_token by password grant type for a user directly.This way can implements by this library like the document,but you cannot check user password and other user credentials flexibility.\n2.Make your own api to check user and generate a access_token by methods of the library. . ",
    "iranappo": "@bzp2010 Yes i want to use for sign. @chadicus So No needing writing code for login and can use oauth for sign or login\nThanks. @bzp2010 I dont want to use oAuth2 in site also i use it in api and if it is maybe so i use it for user login. Thank you. ",
    "brytey2k": "What do you get back. ",
    "01ivesm": "I am not sure if my way is the correct way. \nWhen the user has been authenticated and token has been received I literally use the following line  and literally use the user_id from the result to query the user information. \n$this->server->getStorage('access_token')->getAccessToken($token->getParameter('access_token'))\n. Do you think i need to run Authorization server on a independent domain? \n. I was thinking running the server side application along with a module for OAuth2. \nPOST htttp://domain/oauth/token -data grant_type=\"password|client\" etc\n. ",
    "jlfranklin": "The upstream Drupal module may be able to send it as an int (and I believe there is already a patch that does that), but this library should also validate the data it receives, and ensure the JSON transactions (which Drupal knows nothing about) are formatted according to spec, even when data is sent (implicitly) cast to another data type.\nPHP is very loose with types, recasting scalar values as needed, and so most PHP developers don't give specific scalar types much thought, anymore than they give memory management much thought.  It's only when something else demands a specific scalar type that it becomes an issue.  \nI think this is a case where Postel's law should be applied.. ",
    "neverabe": "@bshaffer, any clue?. ",
    "Faryshta": "@letsjustfixit how?. ",
    "julianaEngelmann": "Thank you!. ",
    "darthsteven": "Note that I'm using this with a Drupal oauth2 server module:\nhttps://www.drupal.org/project/oauth2_server/issues/3015065#comment-12863529\nwhich basically swaps out the storage class.\nI've not updated the built in storage classes, hence all the test failures.. ",
    "darrylkuhn": "Yes - this is a Laravel specific commit... I apologize, I totally forgot this pull request was outstanding. I can remove and put onto another branch. \nIt is an interesting problem though and I expect several other frameworks will have the same issue which is that file_get_contents('php://input') is readable only once. So there needs to be some sort of generic way of informing either the framework (eg. laravel,symfony, etc...) or Oauth2 that file_get_contents('php://input') has been read and the contents are $x... If you're not opposed I'll try and work something up...\n. ",
    "clarkphp": "Is the purpose of the expression to test if $result exists, and if so, perform the == comparison?  The == comparison operator has higher precedence than && logical operator, meaning if I have the intent correct, the expression should actually be $result && ($result['client_secret'] == $client_secret).  In this way, PHP's short-circuit boolean evaluation can be applied without undefined variable notice. Actually, the effect is the same: == will be evaluated before &&. I wonder if isset() is required here; will have to test.  Or have I missed something obvious (it wouldn't be the first time)?\n. ",
    "hugo-cardenas": "Hi, I'm merging your PR into my forked oauth repo as I needed it asap, and I was just writing some extra test and noticed some potential issue.\nIn this function, if you would pass some invalid $tokenTypeHint value in the first call (something different from \"refresh_token\" or \"access_token\") and the token you want to revoke would be stored in the tokenStorage, the expanded search for all token types would not work, as it would just retry once more always trying the refreshStorage and not finding anything.\nIf the token would be stored in refreshStorage, then it would succeed deleting it, out of luck.\nI noticed that AccessTokenTest is not really testing AccessToken class, but instead just the storage underneath it. So I noticed this when writing some test for the AccessToken class itself, which would cover the behaviour of revokeToken function.\n. I noticed afterwards that the check for the correct value of token_type_hint is done in TokenController and this is actually test covered, so there is no issue from the POV of the project overall.\nStill I think that a defensive programming is better, where every module/class/method is safe for itself and not relying on details of other code. Just my constructive 50 cents.\n. ",
    "mokemokechicken": "I'm sorry. I deleted it!\n. ",
    "casperbiering": "This change should not be needed, since Content-Type header is set when calling send method on Reponse object.\n. We do set it. When calling $response->send();\nhttps://github.com/bshaffer/oauth2-server-php/blob/develop/src/OAuth2/Response.php#L203\n. ",
    "duythien": "@lucasantarella I think you should created a new directory phalcon and move your code into it\n. I have no idea, maybe in storage\n. "
}